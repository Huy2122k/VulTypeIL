cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2007-6761,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"V4L/DVB (6751): V4L: Memory leak!  Fix count in videobuf-vmalloc mmap

This is pretty serious bug.  map->count is never initialized after the
call to kmalloc making the count start at some random trash value.  The
end result is leaking videobufs.

Also, fix up the debug statements to print unsigned values.

Pushed to http://ifup.org/hg/v4l-dvb too

Signed-off-by: Brandon Philips <bphilips@suse.de>
Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",0b29669c065f60501e7289e1950fa2a618962358,https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358,drivers/media/video/videobuf-vmalloc.c,videobuf_vm_open,"static void
videobuf_vm_open(struct vm_area_struct *vma)
{
struct videobuf_mapping *map = vma->vm_private_data;
dprintk(2,""vm_open %p [count=%d,vma=%08lx-%08lx]\n"",map,
map->count,vma->vm_start,vma->vm_end);
map->count++;
}","static void
videobuf_vm_open(struct vm_area_struct *VAR_0)
{
struct videobuf_mapping *VAR_1 = VAR_0->vm_private_data;
dprintk(2,""vm_open %p [count=%d,vma=%08lx-%08lx]\n"",VAR_1,
VAR_1->count,VAR_0->vm_start,VAR_0->vm_end);
VAR_1->count++;
}",torvalds/linux/0b29669c065f60501e7289e1950fa2a618962358/videobuf-vmalloc.c/vul/before/0.json,"static void
videobuf_vm_open(struct vm_area_struct *vma)
{
	struct videobuf_mapping *map = vma->vm_private_data;

	dprintk(2,""vm_open %p [count=%u,vma=%08lx-%08lx]\n"",map,
		map->count,vma->vm_start,vma->vm_end);

	map->count++;
}","static void
videobuf_vm_open(struct vm_area_struct *VAR_0)
{
	struct videobuf_mapping *VAR_1 = VAR_0->vm_private_data;

	dprintk(2,""vm_open %p [count=%u,vma=%08lx-%08lx]\n"",VAR_1,
		VAR_1->count,VAR_0->vm_start,VAR_0->vm_end);

	VAR_1->count++;
}",torvalds/linux/0b29669c065f60501e7289e1950fa2a618962358/videobuf-vmalloc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
 	struct videobuf_mapping *map = vma->vm_private_data;
 
-	dprintk(2,""vm_open %p [count=%d,vma=%08lx-%08lx]\n"",map,
+	dprintk(2,""vm_open %p [count=%u,vma=%08lx-%08lx]\n"",map,
 		map->count,vma->vm_start,vma->vm_end);
 
 	map->count++;","{'deleted_lines': ['\tdprintk(2,""vm_open %p [count=%d,vma=%08lx-%08lx]\\n"",map,'], 'added_lines': ['\tdprintk(2,""vm_open %p [count=%u,vma=%08lx-%08lx]\\n"",map,']}",True,"drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321.",7.8,HIGH,2,valid,2007-12-09T02:05:53Z,1
CVE-2007-6761,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"V4L/DVB (6751): V4L: Memory leak!  Fix count in videobuf-vmalloc mmap

This is pretty serious bug.  map->count is never initialized after the
call to kmalloc making the count start at some random trash value.  The
end result is leaking videobufs.

Also, fix up the debug statements to print unsigned values.

Pushed to http://ifup.org/hg/v4l-dvb too

Signed-off-by: Brandon Philips <bphilips@suse.de>
Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",0b29669c065f60501e7289e1950fa2a618962358,https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358,drivers/media/video/videobuf-vmalloc.c,__videobuf_mmap_mapper,"static int __videobuf_mmap_mapper(struct videobuf_queue *q,
struct vm_area_struct *vma)
{
struct videbuf_vmalloc_memory *mem;
struct videobuf_mapping *map;
unsigned int first;
int retval;
unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
if (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))
return -EINVAL;
for (first = 0; first < VIDEO_MAX_FRAME; first++) {
if (NULL == q->bufs[first])
continue;
if (V4L2_MEMORY_MMAP != q->bufs[first]->memory)
continue;
if (q->bufs[first]->boff == offset)
break;
}
if (VIDEO_MAX_FRAME == first) {
dprintk(1,""mmap app bug: offset invalid [offset=0x%lx]\n"",
(vma->vm_pgoff << PAGE_SHIFT));
return -EINVAL;
}
map = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);
if (NULL == map)
return -ENOMEM;
map->start = vma->vm_start;
map->end   = vma->vm_end;
map->q     = q;
q->bufs[first]->baddr = vma->vm_start;
vma->vm_ops          = &videobuf_vm_ops;
vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;
vma->vm_private_data = map;
mem=q->bufs[first]->priv;
BUG_ON (!mem);
MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);
retval=remap_vmalloc_range(vma, mem->vmalloc,0);
if (retval<0) {
dprintk(1,""mmap: postponing remap_vmalloc_range\n"");
mem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);
if (!mem->vma) {
kfree(map);
q->bufs[first]->map=NULL;
return -ENOMEM;
}
memcpy(mem->vma,vma,sizeof(*vma));
}
dprintk(1,""mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n"",
map,q,vma->vm_start,vma->vm_end,
(long int) q->bufs[first]->bsize,
vma->vm_pgoff,first);
videobuf_vm_open(vma);
return (0);
}","static int __videobuf_mmap_mapper(struct videobuf_queue *VAR_0,
struct vm_area_struct *VAR_1)
{
struct videbuf_vmalloc_memory *VAR_2;
struct videobuf_mapping *VAR_3;
unsigned int VAR_4;
int VAR_5;
unsigned long VAR_6 = VAR_1->vm_pgoff << VAR_7;
if (! (VAR_1->vm_flags & VAR_8) || ! (VAR_1->vm_flags & VAR_9))
return -VAR_10;
for (VAR_4 = 0; VAR_4 < VAR_11; VAR_4++) {
if (NULL == VAR_0->bufs[VAR_4])
continue;
if (VAR_12 != VAR_0->bufs[VAR_4]->memory)
continue;
if (VAR_0->bufs[VAR_4]->boff == VAR_6)
break;
}
if (VAR_11 == VAR_4) {
dprintk(1,""mmap app bug: offset invalid [offset=0x%lx]\n"",
(VAR_1->vm_pgoff << VAR_7));
return -VAR_10;
}
VAR_3 = VAR_0->bufs[VAR_4]->map = kmalloc(sizeof(struct videobuf_mapping),VAR_13);
if (NULL == VAR_3)
return -VAR_14;
VAR_3->start = VAR_1->vm_start;
VAR_3->end   = VAR_1->vm_end;
VAR_3->q     = VAR_0;
VAR_0->bufs[VAR_4]->baddr = VAR_1->vm_start;
VAR_1->vm_ops          = &VAR_15;
VAR_1->vm_flags       |= VAR_16 | VAR_17;
VAR_1->vm_private_data = VAR_3;
VAR_2=VAR_0->bufs[VAR_4]->priv;
BUG_ON (!VAR_2);
MAGIC_CHECK(VAR_2->magic,VAR_18);
VAR_5=remap_vmalloc_range(VAR_1, VAR_2->vmalloc,0);
if (VAR_5<0) {
dprintk(1,""mmap: postponing remap_vmalloc_range\n"");
VAR_2->vma=kmalloc(sizeof(*VAR_1),VAR_13);
if (!VAR_2->vma) {
kfree(VAR_3);
VAR_0->bufs[VAR_4]->map=NULL;
return -VAR_14;
}
memcpy(VAR_2->vma,VAR_1,sizeof(*VAR_1));
}
dprintk(1,""mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n"",
VAR_3,VAR_0,VAR_1->vm_start,VAR_1->vm_end,
(long int) VAR_0->bufs[VAR_4]->bsize,
VAR_1->vm_pgoff,VAR_4);
videobuf_vm_open(VAR_1);
return (0);
}",torvalds/linux/0b29669c065f60501e7289e1950fa2a618962358/videobuf-vmalloc.c/vul/before/1.json,"static int __videobuf_mmap_mapper(struct videobuf_queue *q,
			 struct vm_area_struct *vma)
{
	struct videbuf_vmalloc_memory *mem;
	struct videobuf_mapping *map;
	unsigned int first;
	int retval;
	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;

	if (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))
		return -EINVAL;

	/* look for first buffer to map */
	for (first = 0; first < VIDEO_MAX_FRAME; first++) {
		if (NULL == q->bufs[first])
			continue;

		if (V4L2_MEMORY_MMAP != q->bufs[first]->memory)
			continue;
		if (q->bufs[first]->boff == offset)
			break;
	}
	if (VIDEO_MAX_FRAME == first) {
		dprintk(1,""mmap app bug: offset invalid [offset=0x%lx]\n"",
			(vma->vm_pgoff << PAGE_SHIFT));
		return -EINVAL;
	}

	/* create mapping + update buffer list */
	map = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);
	if (NULL == map)
		return -ENOMEM;

	map->start = vma->vm_start;
	map->end   = vma->vm_end;
	map->q     = q;

	q->bufs[first]->baddr = vma->vm_start;

	vma->vm_ops          = &videobuf_vm_ops;
	vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;
	vma->vm_private_data = map;

	mem=q->bufs[first]->priv;
	BUG_ON (!mem);
	MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);

	/* Try to remap memory */
	retval=remap_vmalloc_range(vma, mem->vmalloc,0);
	if (retval<0) {
		dprintk(1,""mmap: postponing remap_vmalloc_range\n"");

		mem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);
		if (!mem->vma) {
			kfree(map);
			q->bufs[first]->map=NULL;
			return -ENOMEM;
		}
		memcpy(mem->vma,vma,sizeof(*vma));
	}

	dprintk(1,""mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n"",
		map,q,vma->vm_start,vma->vm_end,
		(long int) q->bufs[first]->bsize,
		vma->vm_pgoff,first);

	videobuf_vm_open(vma);

	return (0);
}","static int __videobuf_mmap_mapper(struct videobuf_queue *VAR_0,
			 struct vm_area_struct *VAR_1)
{
	struct videbuf_vmalloc_memory *VAR_2;
	struct videobuf_mapping *VAR_3;
	unsigned int VAR_4;
	int VAR_5;
	unsigned long VAR_6 = VAR_1->vm_pgoff << VAR_7;

	if (! (VAR_1->vm_flags & VAR_8) || ! (VAR_1->vm_flags & VAR_9))
		return -VAR_10;

	/* COMMENT_0 */
	for (VAR_4 = 0; VAR_4 < VAR_11; VAR_4++) {
		if (NULL == VAR_0->bufs[VAR_4])
			continue;

		if (VAR_12 != VAR_0->bufs[VAR_4]->memory)
			continue;
		if (VAR_0->bufs[VAR_4]->boff == VAR_6)
			break;
	}
	if (VAR_11 == VAR_4) {
		dprintk(1,""mmap app bug: offset invalid [offset=0x%lx]\n"",
			(VAR_1->vm_pgoff << VAR_7));
		return -VAR_10;
	}

	/* COMMENT_1 */
	VAR_3 = VAR_0->bufs[VAR_4]->map = kzalloc(sizeof(struct videobuf_mapping),VAR_13);
	if (NULL == VAR_3)
		return -VAR_14;

	VAR_3->start = VAR_1->vm_start;
	VAR_3->end   = VAR_1->vm_end;
	VAR_3->q     = VAR_0;

	VAR_0->bufs[VAR_4]->baddr = VAR_1->vm_start;

	VAR_1->vm_ops          = &VAR_15;
	VAR_1->vm_flags       |= VAR_16 | VAR_17;
	VAR_1->vm_private_data = VAR_3;

	VAR_2=VAR_0->bufs[VAR_4]->priv;
	BUG_ON (!VAR_2);
	MAGIC_CHECK(VAR_2->magic,VAR_18);

	/* COMMENT_2 */
	VAR_5=remap_vmalloc_range(VAR_1, VAR_2->vmalloc,0);
	if (VAR_5<0) {
		dprintk(1,""mmap: postponing remap_vmalloc_range\n"");

		VAR_2->vma=kmalloc(sizeof(*VAR_1),VAR_13);
		if (!VAR_2->vma) {
			kfree(VAR_3);
			VAR_0->bufs[VAR_4]->map=NULL;
			return -VAR_14;
		}
		memcpy(VAR_2->vma,VAR_1,sizeof(*VAR_1));
	}

	dprintk(1,""mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n"",
		VAR_3,VAR_0,VAR_1->vm_start,VAR_1->vm_end,
		(long int) VAR_0->bufs[VAR_4]->bsize,
		VAR_1->vm_pgoff,VAR_4);

	videobuf_vm_open(VAR_1);

	return (0);
}",torvalds/linux/0b29669c065f60501e7289e1950fa2a618962358/videobuf-vmalloc.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
 	}
 
 	/* create mapping + update buffer list */
-	map = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);
+	map = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);
 	if (NULL == map)
 		return -ENOMEM;
 ","{'deleted_lines': ['\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);'], 'added_lines': ['\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);']}",True,"drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321.",7.8,HIGH,2,valid,2007-12-09T02:05:53Z,1
CVE-2007-6761,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"V4L/DVB (6751): V4L: Memory leak!  Fix count in videobuf-vmalloc mmap

This is pretty serious bug.  map->count is never initialized after the
call to kmalloc making the count start at some random trash value.  The
end result is leaking videobufs.

Also, fix up the debug statements to print unsigned values.

Pushed to http://ifup.org/hg/v4l-dvb too

Signed-off-by: Brandon Philips <bphilips@suse.de>
Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",0b29669c065f60501e7289e1950fa2a618962358,https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358,drivers/media/video/videobuf-vmalloc.c,videobuf_vm_close,"static void
videobuf_vm_close(struct vm_area_struct *vma)
{
struct videobuf_mapping *map = vma->vm_private_data;
struct videobuf_queue *q = map->q;
int i;
dprintk(2,""vm_close %p [count=%d,vma=%08lx-%08lx]\n"",map,
map->count,vma->vm_start,vma->vm_end);
map->count--;
if (0 == map->count) {
dprintk(1,""munmap %p q=%p\n"",map,q);
mutex_lock(&q->lock);
for (i = 0; i < VIDEO_MAX_FRAME; i++) {
if (NULL == q->bufs[i])
continue;
if (q->bufs[i]->map != map)
continue;
q->ops->buf_release(q,q->bufs[i]);
q->bufs[i]->map   = NULL;
q->bufs[i]->baddr = 0;
}
mutex_unlock(&q->lock);
kfree(map);
}
return;
}","static void
videobuf_vm_close(struct vm_area_struct *VAR_0)
{
struct videobuf_mapping *VAR_1 = VAR_0->vm_private_data;
struct videobuf_queue *VAR_2 = VAR_1->q;
int VAR_3;
dprintk(2,""vm_close %p [count=%d,vma=%08lx-%08lx]\n"",VAR_1,
VAR_1->count,VAR_0->vm_start,VAR_0->vm_end);
VAR_1->count--;
if (0 == VAR_1->count) {
dprintk(1,""munmap %p q=%p\n"",VAR_1,VAR_2);
mutex_lock(&VAR_2->lock);
for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++) {
if (NULL == VAR_2->bufs[VAR_3])
continue;
if (VAR_2->bufs[VAR_3]->map != VAR_1)
continue;
VAR_2->ops->buf_release(VAR_2,VAR_2->bufs[VAR_3]);
VAR_2->bufs[VAR_3]->map   = NULL;
VAR_2->bufs[VAR_3]->baddr = 0;
}
mutex_unlock(&VAR_2->lock);
kfree(VAR_1);
}
return;
}",torvalds/linux/0b29669c065f60501e7289e1950fa2a618962358/videobuf-vmalloc.c/vul/before/2.json,"static void
videobuf_vm_close(struct vm_area_struct *vma)
{
	struct videobuf_mapping *map = vma->vm_private_data;
	struct videobuf_queue *q = map->q;
	int i;

	dprintk(2,""vm_close %p [count=%u,vma=%08lx-%08lx]\n"",map,
		map->count,vma->vm_start,vma->vm_end);

	map->count--;
	if (0 == map->count) {
		dprintk(1,""munmap %p q=%p\n"",map,q);
		mutex_lock(&q->lock);
		for (i = 0; i < VIDEO_MAX_FRAME; i++) {
			if (NULL == q->bufs[i])
				continue;

			if (q->bufs[i]->map != map)
				continue;

			q->ops->buf_release(q,q->bufs[i]);

			q->bufs[i]->map   = NULL;
			q->bufs[i]->baddr = 0;
		}
		mutex_unlock(&q->lock);
		kfree(map);
	}
	return;
}","static void
videobuf_vm_close(struct vm_area_struct *VAR_0)
{
	struct videobuf_mapping *VAR_1 = VAR_0->vm_private_data;
	struct videobuf_queue *VAR_2 = VAR_1->q;
	int VAR_3;

	dprintk(2,""vm_close %p [count=%u,vma=%08lx-%08lx]\n"",VAR_1,
		VAR_1->count,VAR_0->vm_start,VAR_0->vm_end);

	VAR_1->count--;
	if (0 == VAR_1->count) {
		dprintk(1,""munmap %p q=%p\n"",VAR_1,VAR_2);
		mutex_lock(&VAR_2->lock);
		for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++) {
			if (NULL == VAR_2->bufs[VAR_3])
				continue;

			if (VAR_2->bufs[VAR_3]->map != VAR_1)
				continue;

			VAR_2->ops->buf_release(VAR_2,VAR_2->bufs[VAR_3]);

			VAR_2->bufs[VAR_3]->map   = NULL;
			VAR_2->bufs[VAR_3]->baddr = 0;
		}
		mutex_unlock(&VAR_2->lock);
		kfree(VAR_1);
	}
	return;
}",torvalds/linux/0b29669c065f60501e7289e1950fa2a618962358/videobuf-vmalloc.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	struct videobuf_queue *q = map->q;
 	int i;
 
-	dprintk(2,""vm_close %p [count=%d,vma=%08lx-%08lx]\n"",map,
+	dprintk(2,""vm_close %p [count=%u,vma=%08lx-%08lx]\n"",map,
 		map->count,vma->vm_start,vma->vm_end);
 
 	map->count--;","{'deleted_lines': ['\tdprintk(2,""vm_close %p [count=%d,vma=%08lx-%08lx]\\n"",map,'], 'added_lines': ['\tdprintk(2,""vm_close %p [count=%u,vma=%08lx-%08lx]\\n"",map,']}",True,"drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321.",7.8,HIGH,2,valid,2007-12-09T02:05:53Z,1
CVE-2009-5147,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ruby,"* ext/dl/dl.c (rb_dlhandle_initialize): prohibits DL::dlopen
  with a tainted name of library.
  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.

* ext/dl/dl.c (rb_dlhandle_sym): ditto

git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_9_1@23405 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",4600cf725a86ce31266153647ae5aa1197b1215b,https://github.com/ruby/ruby/commit/4600cf725a86ce31266153647ae5aa1197b1215b,ext/dl/handle.c,rb_dlhandle_initialize,"VALUE
rb_dlhandle_initialize(int argc, VALUE argv[], VALUE self)
{
void *ptr;
struct dl_handle *dlhandle;
VALUE lib, flag;
char  *clib;
int   cflag;
const char *err;
switch( rb_scan_args(argc, argv, ""02"", &lib, &flag) ){
case 0:
clib = NULL;
cflag = RTLD_LAZY | RTLD_GLOBAL;
break;
case 1:
clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
cflag = RTLD_LAZY | RTLD_GLOBAL;
break;
case 2:
clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
cflag = NUM2INT(flag);
break;
default:
rb_bug(""rb_dlhandle_new"");
}
ptr = dlopen(clib, cflag);
#if defined(HAVE_DLERROR)
if( !ptr && (err = dlerror()) ){
rb_raise(rb_eDLError, ""%s"", err);
}
#else
if( !ptr ){
err = dlerror();
rb_raise(rb_eDLError, ""%s"", err);
}
#endif
Data_Get_Struct(self, struct dl_handle, dlhandle);
if( dlhandle->ptr && dlhandle->open && dlhandle->enable_close ){
dlclose(dlhandle->ptr);
}
dlhandle->ptr = ptr;
dlhandle->open = 1;
dlhandle->enable_close = 0;
if( rb_block_given_p() ){
rb_ensure(rb_yield, self, rb_dlhandle_close, self);
}
return Qnil;
}","VALUE
rb_dlhandle_initialize(int VAR_0, VALUE VAR_1[], VALUE VAR_2)
{
void *VAR_3;
struct dl_handle *VAR_4;
VALUE VAR_5, VAR_6;
char  *VAR_7;
int   VAR_8;
const char *VAR_9;
switch( rb_scan_args(VAR_0, VAR_1, ""02"", &VAR_5, &VAR_6) ){
case 0:
VAR_7 = NULL;
VAR_8 = VAR_10 | VAR_11;
break;
case 1:
VAR_7 = NIL_P(VAR_5) ? NULL : StringValuePtr(VAR_5);
VAR_8 = VAR_10 | VAR_11;
break;
case 2:
VAR_7 = NIL_P(VAR_5) ? NULL : StringValuePtr(VAR_5);
VAR_8 = NUM2INT(VAR_6);
break;
default:
rb_bug(""rb_dlhandle_new"");
}
VAR_3 = dlopen(VAR_7, VAR_8);
#if defined(VAR_12)
if( !VAR_3 && (VAR_9 = dlerror()) ){
rb_raise(VAR_13, ""%s"", VAR_9);
}
#else
if( !VAR_3 ){
VAR_9 = dlerror();
rb_raise(VAR_13, ""%s"", VAR_9);
}
#endif
Data_Get_Struct(VAR_2, struct dl_handle, VAR_4);
if( VAR_4->ptr && VAR_4->open && VAR_4->enable_close ){
dlclose(VAR_4->ptr);
}
VAR_4->ptr = VAR_3;
VAR_4->open = 1;
VAR_4->enable_close = 0;
if( rb_block_given_p() ){
rb_ensure(VAR_14, VAR_2, VAR_15, VAR_2);
}
return VAR_16;
}",ruby/4600cf725a86ce31266153647ae5aa1197b1215b/handle.c/vul/before/0.json,"VALUE
rb_dlhandle_initialize(int argc, VALUE argv[], VALUE self)
{
  void *ptr;
  struct dl_handle *dlhandle;
  VALUE lib, flag;
  char  *clib;
  int   cflag;
  const char *err;

  switch( rb_scan_args(argc, argv, ""02"", &lib, &flag) ){
  case 0:
    clib = NULL;
    cflag = RTLD_LAZY | RTLD_GLOBAL;
    break;
  case 1:
    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);
    cflag = RTLD_LAZY | RTLD_GLOBAL;
    break;
  case 2:
    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);
    cflag = NUM2INT(flag);
    break;
  default:
    rb_bug(""rb_dlhandle_new"");
  }

  ptr = dlopen(clib, cflag);
#if defined(HAVE_DLERROR)
  if( !ptr && (err = dlerror()) ){
    rb_raise(rb_eDLError, ""%s"", err);
  }
#else
  if( !ptr ){
    err = dlerror();
    rb_raise(rb_eDLError, ""%s"", err);
  }
#endif
  Data_Get_Struct(self, struct dl_handle, dlhandle);
  if( dlhandle->ptr && dlhandle->open && dlhandle->enable_close ){
    dlclose(dlhandle->ptr);
  }
  dlhandle->ptr = ptr;
  dlhandle->open = 1;
  dlhandle->enable_close = 0;

  if( rb_block_given_p() ){
    rb_ensure(rb_yield, self, rb_dlhandle_close, self);
  }

  return Qnil;
}","VALUE
rb_dlhandle_initialize(int VAR_0, VALUE VAR_1[], VALUE VAR_2)
{
  void *VAR_3;
  struct dl_handle *VAR_4;
  VALUE VAR_5, VAR_6;
  char  *VAR_7;
  int   VAR_8;
  const char *VAR_9;

  switch( rb_scan_args(VAR_0, VAR_1, ""02"", &VAR_5, &VAR_6) ){
  case 0:
    VAR_7 = NULL;
    VAR_8 = VAR_10 | VAR_11;
    break;
  case 1:
    VAR_7 = NIL_P(VAR_5) ? NULL : SafeStringValuePtr(VAR_5);
    VAR_8 = VAR_10 | VAR_11;
    break;
  case 2:
    VAR_7 = NIL_P(VAR_5) ? NULL : SafeStringValuePtr(VAR_5);
    VAR_8 = NUM2INT(VAR_6);
    break;
  default:
    rb_bug(""rb_dlhandle_new"");
  }

  VAR_3 = dlopen(VAR_7, VAR_8);
#if defined(VAR_12)
  if( !VAR_3 && (VAR_9 = dlerror()) ){
    rb_raise(VAR_13, ""%s"", VAR_9);
  }
#else
  if( !VAR_3 ){
    VAR_9 = dlerror();
    rb_raise(VAR_13, ""%s"", VAR_9);
  }
#endif
  Data_Get_Struct(VAR_2, struct dl_handle, VAR_4);
  if( VAR_4->ptr && VAR_4->open && VAR_4->enable_close ){
    dlclose(VAR_4->ptr);
  }
  VAR_4->ptr = VAR_3;
  VAR_4->open = 1;
  VAR_4->enable_close = 0;

  if( rb_block_given_p() ){
    rb_ensure(VAR_14, VAR_2, VAR_15, VAR_2);
  }

  return VAR_16;
}",ruby/4600cf725a86ce31266153647ae5aa1197b1215b/handle.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,11 +14,11 @@
     cflag = RTLD_LAZY | RTLD_GLOBAL;
     break;
   case 1:
-    clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
+    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);
     cflag = RTLD_LAZY | RTLD_GLOBAL;
     break;
   case 2:
-    clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
+    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);
     cflag = NUM2INT(flag);
     break;
   default:","{'deleted_lines': ['    clib = NIL_P(lib) ? NULL : StringValuePtr(lib);', '    clib = NIL_P(lib) ? NULL : StringValuePtr(lib);'], 'added_lines': ['    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);', '    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);']}",True,"DL::dlopen in Ruby 1.8, 1.9.0, 1.9.2, 1.9.3, 2.0.0 before patchlevel 648, and 2.1 before 2.1.8 opens libraries with tainted names.",7.3,HIGH,2,valid,2009-05-11T15:07:10Z,1
CVE-2009-5147,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ruby,"* ext/dl/dl.c (rb_dlhandle_initialize): prohibits DL::dlopen
  with a tainted name of library.
  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.

* ext/dl/dl.c (rb_dlhandle_sym): ditto

git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_1_9_1@23405 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",4600cf725a86ce31266153647ae5aa1197b1215b,https://github.com/ruby/ruby/commit/4600cf725a86ce31266153647ae5aa1197b1215b,ext/dl/handle.c,rb_dlhandle_sym,"VALUE
rb_dlhandle_sym(VALUE self, VALUE sym)
{
void (*func)();
struct dl_handle *dlhandle;
void *handle;
const char *name;
const char *err;
int i;
#if defined(HAVE_DLERROR)
# define CHECK_DLERROR if( err = dlerror() ){ func = 0; }
#else
# define CHECK_DLERROR
#endif
rb_secure(2);
name = StringValuePtr(sym);
Data_Get_Struct(self, struct dl_handle, dlhandle);
if( ! dlhandle->open ){
rb_raise(rb_eDLError, ""closed handle"");
}
handle = dlhandle->ptr;
func = dlsym(handle, name);
CHECK_DLERROR;
#if defined(FUNC_STDCALL)
if( !func ){
int  len = strlen(name);
char *name_n;
#if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__)
{
char *name_a = (char*)xmalloc(len+2);
strcpy(name_a, name);
name_n = name_a;
name_a[len]   = 'A';
name_a[len+1] = '\0';
func = dlsym(handle, name_a);
CHECK_DLERROR;
if( func ) goto found;
name_n = xrealloc(name_a, len+6);
}
#else
name_n = (char*)xmalloc(len+6);
#endif
memcpy(name_n, name, len);
name_n[len++] = '@';
for( i = 0; i < 256; i += 4 ){
sprintf(name_n + len, ""%d"", i);
func = dlsym(handle, name_n);
CHECK_DLERROR;
if( func ) break;
}
if( func ) goto found;
name_n[len-1] = 'A';
name_n[len++] = '@';
for( i = 0; i < 256; i += 4 ){
sprintf(name_n + len, ""%d"", i);
func = dlsym(handle, name_n);
CHECK_DLERROR;
if( func ) break;
}
found:
xfree(name_n);
}
#endif
if( !func ){
rb_raise(rb_eDLError, ""unknown symbol \""%s\"""", name);
}
return PTR2NUM(func);
}","VALUE
rb_dlhandle_sym(VALUE VAR_0, VALUE VAR_1)
{
void (*VAR_2)();
struct dl_handle *VAR_3;
void *VAR_4;
const char *VAR_5;
const char *VAR_6;
int VAR_7;
#if defined(VAR_8)
# define VAR_9 if( err = dlerror() ){ func = 0; }
#else
# define VAR_9
#endif
rb_secure(2);
VAR_5 = StringValuePtr(VAR_1);
Data_Get_Struct(VAR_0, struct dl_handle, VAR_3);
if( ! VAR_3->open ){
rb_raise(VAR_10, ""closed handle"");
}
VAR_4 = VAR_3->ptr;
VAR_2 = dlsym(VAR_4, VAR_5);
VAR_9;
#if defined(VAR_11)
if( !VAR_2 ){
int  VAR_12 = strlen(VAR_5);
char *VAR_13;
#if defined(VAR_14) || defined(VAR_15) || defined(VAR_16)
{
char *VAR_17 = (char*)xmalloc(VAR_12+2);
strcpy(VAR_17, VAR_5);
VAR_13 = VAR_17;
VAR_17[VAR_12]   = 'A';
VAR_17[VAR_12+1] = '\0';
VAR_2 = dlsym(VAR_4, VAR_17);
VAR_9;
if( VAR_2 ) goto found;
VAR_13 = xrealloc(VAR_17, VAR_12+6);
}
#else
VAR_13 = (char*)xmalloc(VAR_12+6);
#endif
memcpy(VAR_13, VAR_5, VAR_12);
VAR_13[VAR_12++] = '@';
for( VAR_7 = 0; VAR_7 < 256; VAR_7 += 4 ){
sprintf(VAR_13 + VAR_12, ""%d"", VAR_7);
VAR_2 = dlsym(VAR_4, VAR_13);
VAR_9;
if( VAR_2 ) break;
}
if( VAR_2 ) goto found;
VAR_13[VAR_12-1] = 'A';
VAR_13[VAR_12++] = '@';
for( VAR_7 = 0; VAR_7 < 256; VAR_7 += 4 ){
sprintf(VAR_13 + VAR_12, ""%d"", VAR_7);
VAR_2 = dlsym(VAR_4, VAR_13);
VAR_9;
if( VAR_2 ) break;
}
found:
xfree(VAR_13);
}
#endif
if( !VAR_2 ){
rb_raise(VAR_10, ""unknown symbol \""%s\"""", VAR_5);
}
return PTR2NUM(VAR_2);
}",ruby/4600cf725a86ce31266153647ae5aa1197b1215b/handle.c/vul/before/1.json,"VALUE
rb_dlhandle_sym(VALUE self, VALUE sym)
{
    void (*func)();
    struct dl_handle *dlhandle;
    void *handle;
    const char *name;
    const char *err;
    int i;

#if defined(HAVE_DLERROR)
# define CHECK_DLERROR if( err = dlerror() ){ func = 0; }
#else
# define CHECK_DLERROR
#endif

    rb_secure(2);

    name = SafeStringValuePtr(sym);

    Data_Get_Struct(self, struct dl_handle, dlhandle);
    if( ! dlhandle->open ){
	rb_raise(rb_eDLError, ""closed handle"");
    }
    handle = dlhandle->ptr;

    func = dlsym(handle, name);
    CHECK_DLERROR;
#if defined(FUNC_STDCALL)
    if( !func ){
	int  len = strlen(name);
	char *name_n;
#if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__)
	{
	    char *name_a = (char*)xmalloc(len+2);
	    strcpy(name_a, name);
	    name_n = name_a;
	    name_a[len]   = 'A';
	    name_a[len+1] = '\0';
	    func = dlsym(handle, name_a);
	    CHECK_DLERROR;
	    if( func ) goto found;
	    name_n = xrealloc(name_a, len+6);
	}
#else
	name_n = (char*)xmalloc(len+6);
#endif
	memcpy(name_n, name, len);
	name_n[len++] = '@';
	for( i = 0; i < 256; i += 4 ){
	    sprintf(name_n + len, ""%d"", i);
	    func = dlsym(handle, name_n);
	    CHECK_DLERROR;
	    if( func ) break;
	}
	if( func ) goto found;
	name_n[len-1] = 'A';
	name_n[len++] = '@';
	for( i = 0; i < 256; i += 4 ){
	    sprintf(name_n + len, ""%d"", i);
	    func = dlsym(handle, name_n);
	    CHECK_DLERROR;
	    if( func ) break;
	}
      found:
	xfree(name_n);
    }
#endif
    if( !func ){
	rb_raise(rb_eDLError, ""unknown symbol \""%s\"""", name);
    }

    return PTR2NUM(func);
}","VALUE
rb_dlhandle_sym(VALUE VAR_0, VALUE VAR_1)
{
    void (*VAR_2)();
    struct dl_handle *VAR_3;
    void *VAR_4;
    const char *VAR_5;
    const char *VAR_6;
    int VAR_7;

#if defined(VAR_8)
# define VAR_9 if( err = dlerror() ){ func = 0; }
#else
# define VAR_9
#endif

    rb_secure(2);

    VAR_5 = SafeStringValuePtr(VAR_1);

    Data_Get_Struct(VAR_0, struct dl_handle, VAR_3);
    if( ! VAR_3->open ){
	rb_raise(VAR_10, ""closed handle"");
    }
    VAR_4 = VAR_3->ptr;

    VAR_2 = dlsym(VAR_4, VAR_5);
    VAR_9;
#if defined(VAR_11)
    if( !VAR_2 ){
	int  VAR_12 = strlen(VAR_5);
	char *VAR_13;
#if defined(VAR_14) || defined(VAR_15) || defined(VAR_16)
	{
	    char *VAR_17 = (char*)xmalloc(VAR_12+2);
	    strcpy(VAR_17, VAR_5);
	    VAR_13 = VAR_17;
	    VAR_17[VAR_12]   = 'A';
	    VAR_17[VAR_12+1] = '\0';
	    VAR_2 = dlsym(VAR_4, VAR_17);
	    VAR_9;
	    if( VAR_2 ) goto found;
	    VAR_13 = xrealloc(VAR_17, VAR_12+6);
	}
#else
	VAR_13 = (char*)xmalloc(VAR_12+6);
#endif
	memcpy(VAR_13, VAR_5, VAR_12);
	VAR_13[VAR_12++] = '@';
	for( VAR_7 = 0; VAR_7 < 256; VAR_7 += 4 ){
	    sprintf(VAR_13 + VAR_12, ""%d"", VAR_7);
	    VAR_2 = dlsym(VAR_4, VAR_13);
	    VAR_9;
	    if( VAR_2 ) break;
	}
	if( VAR_2 ) goto found;
	VAR_13[VAR_12-1] = 'A';
	VAR_13[VAR_12++] = '@';
	for( VAR_7 = 0; VAR_7 < 256; VAR_7 += 4 ){
	    sprintf(VAR_13 + VAR_12, ""%d"", VAR_7);
	    VAR_2 = dlsym(VAR_4, VAR_13);
	    VAR_9;
	    if( VAR_2 ) break;
	}
      found:
	xfree(VAR_13);
    }
#endif
    if( !VAR_2 ){
	rb_raise(VAR_10, ""unknown symbol \""%s\"""", VAR_5);
    }

    return PTR2NUM(VAR_2);
}",ruby/4600cf725a86ce31266153647ae5aa1197b1215b/handle.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 
     rb_secure(2);
 
-    name = StringValuePtr(sym);
+    name = SafeStringValuePtr(sym);
 
     Data_Get_Struct(self, struct dl_handle, dlhandle);
     if( ! dlhandle->open ){","{'deleted_lines': ['    name = StringValuePtr(sym);'], 'added_lines': ['    name = SafeStringValuePtr(sym);']}",True,"DL::dlopen in Ruby 1.8, 1.9.0, 1.9.2, 1.9.3, 2.0.0 before patchlevel 648, and 2.1 before 2.1.8 opens libraries with tainted names.",7.3,HIGH,2,valid,2009-05-11T15:07:10Z,1
CVE-2014-8130,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vadz/libtiff,"* libtiff/tif_{unix,vms,win32}.c (_TIFFmalloc): ANSI C does not
require malloc() to return NULL pointer if requested allocation
size is zero.  Assure that _TIFFmalloc does.",3c5eb8b1be544e41d2c336191bc4936300ad7543,https://github.com/vadz/libtiff/commit/3c5eb8b1be544e41d2c336191bc4936300ad7543,libtiff/tif_unix.c,_TIFFmalloc,"void*
_TIFFmalloc(tmsize_t s)
{
return (malloc((size_t) s));
}","void*
_TIFFmalloc(tmsize_t VAR_0)
{
return (malloc((size_t) VAR_0));
}",vadz/libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543/tif_unix.c/vul/before/0.json,"void*
_TIFFmalloc(tmsize_t s)
{
        if (s == 0)
                return ((void *) NULL);

	return (malloc((size_t) s));
}","void*
_TIFFmalloc(tmsize_t VAR_0)
{
        if (VAR_0 == 0)
                return ((void *) NULL);

	return (malloc((size_t) VAR_0));
}",vadz/libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543/tif_unix.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 void*
 _TIFFmalloc(tmsize_t s)
 {
+        if (s == 0)
+                return ((void *) NULL);
+
 	return (malloc((size_t) s));
 }","{'deleted_lines': [], 'added_lines': ['        if (s == 0)', '                return ((void *) NULL);', '']}",True,"The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither.",6.5,MEDIUM,1,valid,2012-11-18T17:51:52Z,1
CVE-2014-8130,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vadz/libtiff,"* libtiff/tif_{unix,vms,win32}.c (_TIFFmalloc): ANSI C does not
require malloc() to return NULL pointer if requested allocation
size is zero.  Assure that _TIFFmalloc does.",3c5eb8b1be544e41d2c336191bc4936300ad7543,https://github.com/vadz/libtiff/commit/3c5eb8b1be544e41d2c336191bc4936300ad7543,libtiff/tif_win32.c,_TIFFmalloc,"void*
_TIFFmalloc(tmsize_t s)
{
return (malloc((size_t) s));
}","void*
_TIFFmalloc(tmsize_t VAR_0)
{
return (malloc((size_t) VAR_0));
}",vadz/libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543/tif_win32.c/vul/before/0.json,"void*
_TIFFmalloc(tmsize_t s)
{
        if (s == 0)
                return ((void *) NULL);

	return (malloc((size_t) s));
}","void*
_TIFFmalloc(tmsize_t VAR_0)
{
        if (VAR_0 == 0)
                return ((void *) NULL);

	return (malloc((size_t) VAR_0));
}",vadz/libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543/tif_win32.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 void*
 _TIFFmalloc(tmsize_t s)
 {
+        if (s == 0)
+                return ((void *) NULL);
+
 	return (malloc((size_t) s));
 }","{'deleted_lines': [], 'added_lines': ['        if (s == 0)', '                return ((void *) NULL);', '']}",True,"The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither.",6.5,MEDIUM,1,valid,2012-11-18T17:51:52Z,1
CVE-2014-8130,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,vadz/libtiff,"* libtiff/tif_{unix,vms,win32}.c (_TIFFmalloc): ANSI C does not
require malloc() to return NULL pointer if requested allocation
size is zero.  Assure that _TIFFmalloc does.",3c5eb8b1be544e41d2c336191bc4936300ad7543,https://github.com/vadz/libtiff/commit/3c5eb8b1be544e41d2c336191bc4936300ad7543,libtiff/tif_vms.c,_TIFFmalloc,"tdata_t
_TIFFmalloc(tsize_t s)
{
return (malloc((size_t) s));
}","tdata_t
_TIFFmalloc(tsize_t VAR_0)
{
return (malloc((size_t) VAR_0));
}",vadz/libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543/tif_vms.c/vul/before/0.json,"tdata_t
_TIFFmalloc(tsize_t s)
{
        if (s == 0)
                return ((void *) NULL);

	return (malloc((size_t) s));
}","tdata_t
_TIFFmalloc(tsize_t VAR_0)
{
        if (VAR_0 == 0)
                return ((void *) NULL);

	return (malloc((size_t) VAR_0));
}",vadz/libtiff/3c5eb8b1be544e41d2c336191bc4936300ad7543/tif_vms.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 tdata_t
 _TIFFmalloc(tsize_t s)
 {
+        if (s == 0)
+                return ((void *) NULL);
+
 	return (malloc((size_t) s));
 }","{'deleted_lines': [], 'added_lines': ['        if (s == 0)', '                return ((void *) NULL);', '']}",True,"The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither.",6.5,MEDIUM,1,valid,2012-11-18T17:51:52Z,1
CVE-2013-2016,['CWE-269'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,qemu,"virtio: properly validate address before accessing config

There are several several issues in the current checking:

- The check was based on the minus of unsigned values which can overflow
- It was done after .{set|get}_config() which can lead crash when config_len
  is zero since vdev->config is NULL

Fix this by:

- Validate the address in virtio_pci_config_{read|write}() before
  .{set|get}_config
- Use addition instead minus to do the validation

Cc: Michael S. Tsirkin <mst@redhat.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Acked-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Petr Matousek <pmatouse@redhat.com>
Message-id: 1367905369-10765-1-git-send-email-jasowang@redhat.com
Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>",5f5a1318653c08e435cfa52f60b6a712815b659d,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,hw/virtio/virtio.c,virtio_config_writeb,"void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
uint8_t val = data;
if (addr > (vdev->config_len - sizeof(val)))
return;
stb_p(vdev->config + addr, val);
if (k->set_config) {
k->set_config(vdev, vdev->config);
}
}","void virtio_config_writeb(VirtIODevice *VAR_0, uint32_t VAR_1, uint32_t VAR_2)
{
VirtioDeviceClass *VAR_3 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
uint8_t VAR_4 = VAR_2;
if (VAR_1 > (VAR_0->config_len - sizeof(VAR_4)))
return;
stb_p(VAR_0->config + VAR_1, VAR_4);
if (VAR_3->set_config) {
VAR_3->set_config(VAR_0, VAR_0->config);
}
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/before/3.json,"void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint8_t val = data;

    if (addr + sizeof(val) > vdev->config_len) {
        return;
    }

    stb_p(vdev->config + addr, val);

    if (k->set_config) {
        k->set_config(vdev, vdev->config);
    }
}","void virtio_config_writeb(VirtIODevice *VAR_0, uint32_t VAR_1, uint32_t VAR_2)
{
    VirtioDeviceClass *VAR_3 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
    uint8_t VAR_4 = VAR_2;

    if (VAR_1 + sizeof(VAR_4) > VAR_0->config_len) {
        return;
    }

    stb_p(VAR_0->config + VAR_1, VAR_4);

    if (VAR_3->set_config) {
        VAR_3->set_config(VAR_0, VAR_0->config);
    }
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -3,8 +3,9 @@
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint8_t val = data;
 
-    if (addr > (vdev->config_len - sizeof(val)))
+    if (addr + sizeof(val) > vdev->config_len) {
         return;
+    }
 
     stb_p(vdev->config + addr, val);
 ","{'deleted_lines': ['    if (addr > (vdev->config_len - sizeof(val)))'], 'added_lines': ['    if (addr + sizeof(val) > vdev->config_len) {', '    }']}",True,"A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.",7.8,HIGH,2,valid,2013-05-07T05:42:49Z,1
CVE-2013-2016,['CWE-269'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,qemu,"virtio: properly validate address before accessing config

There are several several issues in the current checking:

- The check was based on the minus of unsigned values which can overflow
- It was done after .{set|get}_config() which can lead crash when config_len
  is zero since vdev->config is NULL

Fix this by:

- Validate the address in virtio_pci_config_{read|write}() before
  .{set|get}_config
- Use addition instead minus to do the validation

Cc: Michael S. Tsirkin <mst@redhat.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Acked-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Petr Matousek <pmatouse@redhat.com>
Message-id: 1367905369-10765-1-git-send-email-jasowang@redhat.com
Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>",5f5a1318653c08e435cfa52f60b6a712815b659d,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,hw/virtio/virtio.c,virtio_config_readl,"uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)
{
VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
uint32_t val;
k->get_config(vdev, vdev->config);
if (addr > (vdev->config_len - sizeof(val)))
return (uint32_t)-1;
val = ldl_p(vdev->config + addr);
return val;
}","uint32_t virtio_config_readl(VirtIODevice *VAR_0, uint32_t VAR_1)
{
VirtioDeviceClass *VAR_2 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
uint32_t VAR_3;
VAR_2->get_config(VAR_0, VAR_0->config);
if (VAR_1 > (VAR_0->config_len - sizeof(VAR_3)))
return (uint32_t)-1;
VAR_3 = ldl_p(VAR_0->config + VAR_1);
return VAR_3;
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/before/2.json,"uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint32_t val;

    if (addr + sizeof(val) > vdev->config_len) {
        return (uint32_t)-1;
    }

    k->get_config(vdev, vdev->config);

    val = ldl_p(vdev->config + addr);
    return val;
}","uint32_t virtio_config_readl(VirtIODevice *VAR_0, uint32_t VAR_1)
{
    VirtioDeviceClass *VAR_2 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
    uint32_t VAR_3;

    if (VAR_1 + sizeof(VAR_3) > VAR_0->config_len) {
        return (uint32_t)-1;
    }

    VAR_2->get_config(VAR_0, VAR_0->config);

    VAR_3 = ldl_p(VAR_0->config + VAR_1);
    return VAR_3;
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -3,10 +3,11 @@
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint32_t val;
 
+    if (addr + sizeof(val) > vdev->config_len) {
+        return (uint32_t)-1;
+    }
+
     k->get_config(vdev, vdev->config);
-
-    if (addr > (vdev->config_len - sizeof(val)))
-        return (uint32_t)-1;
 
     val = ldl_p(vdev->config + addr);
     return val;","{'deleted_lines': ['', '    if (addr > (vdev->config_len - sizeof(val)))', '        return (uint32_t)-1;'], 'added_lines': ['    if (addr + sizeof(val) > vdev->config_len) {', '        return (uint32_t)-1;', '    }', '']}",True,"A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.",7.8,HIGH,2,valid,2013-05-07T05:42:49Z,1
CVE-2013-2016,['CWE-269'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,qemu,"virtio: properly validate address before accessing config

There are several several issues in the current checking:

- The check was based on the minus of unsigned values which can overflow
- It was done after .{set|get}_config() which can lead crash when config_len
  is zero since vdev->config is NULL

Fix this by:

- Validate the address in virtio_pci_config_{read|write}() before
  .{set|get}_config
- Use addition instead minus to do the validation

Cc: Michael S. Tsirkin <mst@redhat.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Acked-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Petr Matousek <pmatouse@redhat.com>
Message-id: 1367905369-10765-1-git-send-email-jasowang@redhat.com
Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>",5f5a1318653c08e435cfa52f60b6a712815b659d,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,hw/virtio/virtio.c,virtio_config_readw,"uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)
{
VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
uint16_t val;
k->get_config(vdev, vdev->config);
if (addr > (vdev->config_len - sizeof(val)))
return (uint32_t)-1;
val = lduw_p(vdev->config + addr);
return val;
}","uint32_t virtio_config_readw(VirtIODevice *VAR_0, uint32_t VAR_1)
{
VirtioDeviceClass *VAR_2 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
uint16_t VAR_3;
VAR_2->get_config(VAR_0, VAR_0->config);
if (VAR_1 > (VAR_0->config_len - sizeof(VAR_3)))
return (uint32_t)-1;
VAR_3 = lduw_p(VAR_0->config + VAR_1);
return VAR_3;
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/before/4.json,"uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint16_t val;

    if (addr + sizeof(val) > vdev->config_len) {
        return (uint32_t)-1;
    }

    k->get_config(vdev, vdev->config);

    val = lduw_p(vdev->config + addr);
    return val;
}","uint32_t virtio_config_readw(VirtIODevice *VAR_0, uint32_t VAR_1)
{
    VirtioDeviceClass *VAR_2 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
    uint16_t VAR_3;

    if (VAR_1 + sizeof(VAR_3) > VAR_0->config_len) {
        return (uint32_t)-1;
    }

    VAR_2->get_config(VAR_0, VAR_0->config);

    VAR_3 = lduw_p(VAR_0->config + VAR_1);
    return VAR_3;
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -3,10 +3,11 @@
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint16_t val;
 
+    if (addr + sizeof(val) > vdev->config_len) {
+        return (uint32_t)-1;
+    }
+
     k->get_config(vdev, vdev->config);
-
-    if (addr > (vdev->config_len - sizeof(val)))
-        return (uint32_t)-1;
 
     val = lduw_p(vdev->config + addr);
     return val;","{'deleted_lines': ['', '    if (addr > (vdev->config_len - sizeof(val)))', '        return (uint32_t)-1;'], 'added_lines': ['    if (addr + sizeof(val) > vdev->config_len) {', '        return (uint32_t)-1;', '    }', '']}",True,"A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.",7.8,HIGH,2,valid,2013-05-07T05:42:49Z,1
CVE-2013-2016,['CWE-269'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,qemu,"virtio: properly validate address before accessing config

There are several several issues in the current checking:

- The check was based on the minus of unsigned values which can overflow
- It was done after .{set|get}_config() which can lead crash when config_len
  is zero since vdev->config is NULL

Fix this by:

- Validate the address in virtio_pci_config_{read|write}() before
  .{set|get}_config
- Use addition instead minus to do the validation

Cc: Michael S. Tsirkin <mst@redhat.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Acked-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Petr Matousek <pmatouse@redhat.com>
Message-id: 1367905369-10765-1-git-send-email-jasowang@redhat.com
Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>",5f5a1318653c08e435cfa52f60b6a712815b659d,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,hw/virtio/virtio.c,virtio_config_writel,"void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
uint32_t val = data;
if (addr > (vdev->config_len - sizeof(val)))
return;
stl_p(vdev->config + addr, val);
if (k->set_config) {
k->set_config(vdev, vdev->config);
}
}","void virtio_config_writel(VirtIODevice *VAR_0, uint32_t VAR_1, uint32_t VAR_2)
{
VirtioDeviceClass *VAR_3 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
uint32_t VAR_4 = VAR_2;
if (VAR_1 > (VAR_0->config_len - sizeof(VAR_4)))
return;
stl_p(VAR_0->config + VAR_1, VAR_4);
if (VAR_3->set_config) {
VAR_3->set_config(VAR_0, VAR_0->config);
}
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/before/5.json,"void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint32_t val = data;

    if (addr + sizeof(val) > vdev->config_len) {
        return;
    }

    stl_p(vdev->config + addr, val);

    if (k->set_config) {
        k->set_config(vdev, vdev->config);
    }
}","void virtio_config_writel(VirtIODevice *VAR_0, uint32_t VAR_1, uint32_t VAR_2)
{
    VirtioDeviceClass *VAR_3 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
    uint32_t VAR_4 = VAR_2;

    if (VAR_1 + sizeof(VAR_4) > VAR_0->config_len) {
        return;
    }

    stl_p(VAR_0->config + VAR_1, VAR_4);

    if (VAR_3->set_config) {
        VAR_3->set_config(VAR_0, VAR_0->config);
    }
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -3,8 +3,9 @@
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint32_t val = data;
 
-    if (addr > (vdev->config_len - sizeof(val)))
+    if (addr + sizeof(val) > vdev->config_len) {
         return;
+    }
 
     stl_p(vdev->config + addr, val);
 ","{'deleted_lines': ['    if (addr > (vdev->config_len - sizeof(val)))'], 'added_lines': ['    if (addr + sizeof(val) > vdev->config_len) {', '    }']}",True,"A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.",7.8,HIGH,2,valid,2013-05-07T05:42:49Z,1
CVE-2013-2016,['CWE-269'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,qemu,"virtio: properly validate address before accessing config

There are several several issues in the current checking:

- The check was based on the minus of unsigned values which can overflow
- It was done after .{set|get}_config() which can lead crash when config_len
  is zero since vdev->config is NULL

Fix this by:

- Validate the address in virtio_pci_config_{read|write}() before
  .{set|get}_config
- Use addition instead minus to do the validation

Cc: Michael S. Tsirkin <mst@redhat.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Acked-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Petr Matousek <pmatouse@redhat.com>
Message-id: 1367905369-10765-1-git-send-email-jasowang@redhat.com
Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>",5f5a1318653c08e435cfa52f60b6a712815b659d,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,hw/virtio/virtio.c,virtio_config_readb,"uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)
{
VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
uint8_t val;
k->get_config(vdev, vdev->config);
if (addr > (vdev->config_len - sizeof(val)))
return (uint32_t)-1;
val = ldub_p(vdev->config + addr);
return val;
}","uint32_t virtio_config_readb(VirtIODevice *VAR_0, uint32_t VAR_1)
{
VirtioDeviceClass *VAR_2 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
uint8_t VAR_3;
VAR_2->get_config(VAR_0, VAR_0->config);
if (VAR_1 > (VAR_0->config_len - sizeof(VAR_3)))
return (uint32_t)-1;
VAR_3 = ldub_p(VAR_0->config + VAR_1);
return VAR_3;
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/before/0.json,"uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint8_t val;

    if (addr + sizeof(val) > vdev->config_len) {
        return (uint32_t)-1;
    }

    k->get_config(vdev, vdev->config);

    val = ldub_p(vdev->config + addr);
    return val;
}","uint32_t virtio_config_readb(VirtIODevice *VAR_0, uint32_t VAR_1)
{
    VirtioDeviceClass *VAR_2 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
    uint8_t VAR_3;

    if (VAR_1 + sizeof(VAR_3) > VAR_0->config_len) {
        return (uint32_t)-1;
    }

    VAR_2->get_config(VAR_0, VAR_0->config);

    VAR_3 = ldub_p(VAR_0->config + VAR_1);
    return VAR_3;
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,10 +3,11 @@
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint8_t val;
 
+    if (addr + sizeof(val) > vdev->config_len) {
+        return (uint32_t)-1;
+    }
+
     k->get_config(vdev, vdev->config);
-
-    if (addr > (vdev->config_len - sizeof(val)))
-        return (uint32_t)-1;
 
     val = ldub_p(vdev->config + addr);
     return val;","{'deleted_lines': ['', '    if (addr > (vdev->config_len - sizeof(val)))', '        return (uint32_t)-1;'], 'added_lines': ['    if (addr + sizeof(val) > vdev->config_len) {', '        return (uint32_t)-1;', '    }', '']}",True,"A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.",7.8,HIGH,2,valid,2013-05-07T05:42:49Z,1
CVE-2013-2016,['CWE-269'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,qemu,"virtio: properly validate address before accessing config

There are several several issues in the current checking:

- The check was based on the minus of unsigned values which can overflow
- It was done after .{set|get}_config() which can lead crash when config_len
  is zero since vdev->config is NULL

Fix this by:

- Validate the address in virtio_pci_config_{read|write}() before
  .{set|get}_config
- Use addition instead minus to do the validation

Cc: Michael S. Tsirkin <mst@redhat.com>
Cc: Petr Matousek <pmatouse@redhat.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Acked-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Petr Matousek <pmatouse@redhat.com>
Message-id: 1367905369-10765-1-git-send-email-jasowang@redhat.com
Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>",5f5a1318653c08e435cfa52f60b6a712815b659d,https://github.com/qemu/qemu/commit/5f5a1318653c08e435cfa52f60b6a712815b659d,hw/virtio/virtio.c,virtio_config_writew,"void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
uint16_t val = data;
if (addr > (vdev->config_len - sizeof(val)))
return;
stw_p(vdev->config + addr, val);
if (k->set_config) {
k->set_config(vdev, vdev->config);
}
}","void virtio_config_writew(VirtIODevice *VAR_0, uint32_t VAR_1, uint32_t VAR_2)
{
VirtioDeviceClass *VAR_3 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
uint16_t VAR_4 = VAR_2;
if (VAR_1 > (VAR_0->config_len - sizeof(VAR_4)))
return;
stw_p(VAR_0->config + VAR_1, VAR_4);
if (VAR_3->set_config) {
VAR_3->set_config(VAR_0, VAR_0->config);
}
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/before/1.json,"void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint16_t val = data;

    if (addr + sizeof(val) > vdev->config_len) {
        return;
    }

    stw_p(vdev->config + addr, val);

    if (k->set_config) {
        k->set_config(vdev, vdev->config);
    }
}","void virtio_config_writew(VirtIODevice *VAR_0, uint32_t VAR_1, uint32_t VAR_2)
{
    VirtioDeviceClass *VAR_3 = VIRTIO_DEVICE_GET_CLASS(VAR_0);
    uint16_t VAR_4 = VAR_2;

    if (VAR_1 + sizeof(VAR_4) > VAR_0->config_len) {
        return;
    }

    stw_p(VAR_0->config + VAR_1, VAR_4);

    if (VAR_3->set_config) {
        VAR_3->set_config(VAR_0, VAR_0->config);
    }
}",qemu/5f5a1318653c08e435cfa52f60b6a712815b659d/virtio.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,8 +3,9 @@
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     uint16_t val = data;
 
-    if (addr > (vdev->config_len - sizeof(val)))
+    if (addr + sizeof(val) > vdev->config_len) {
         return;
+    }
 
     stw_p(vdev->config + addr, val);
 ","{'deleted_lines': ['    if (addr > (vdev->config_len - sizeof(val)))'], 'added_lines': ['    if (addr + sizeof(val) > vdev->config_len) {', '    }']}",True,"A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.",7.8,HIGH,2,valid,2013-05-07T05:42:49Z,1
CVE-2014-0148,['CWE-835'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,qemu,"vhdx: Bounds checking for block_size and logical_sector_size (CVE-2014-0148)

Other variables (e.g. sectors_per_block) are calculated using these
variables, and if not range-checked illegal values could be obtained
causing infinite loops and other potential issues when calculating
BAT entries.

The 1.00 VHDX spec requires BlockSize to be min 1MB, max 256MB.
LogicalSectorSize is required to be either 512 or 4096 bytes.

Reported-by: Kevin Wolf <kwolf@redhat.com>
Signed-off-by: Jeff Cody <jcody@redhat.com>
Signed-off-by: Kevin Wolf <kwolf@redhat.com>
Reviewed-by: Max Reitz <mreitz@redhat.com>
Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>",1d7678dec4761acdc43439da6ceda41a703ba1a6,https://github.com/qemu/qemu/commit/1d7678dec4761acdc43439da6ceda41a703ba1a6,block/vhdx.c,vhdx_parse_metadata,"static int vhdx_parse_metadata(BlockDriverState *bs, BDRVVHDXState *s)
{
int ret = 0;
uint8_t *buffer;
int offset = 0;
uint32_t i = 0;
VHDXMetadataTableEntry md_entry;
buffer = qemu_blockalign(bs, VHDX_METADATA_TABLE_MAX_SIZE);
ret = bdrv_pread(bs->file, s->metadata_rt.file_offset, buffer,
VHDX_METADATA_TABLE_MAX_SIZE);
if (ret < 0) {
goto exit;
}
memcpy(&s->metadata_hdr, buffer, sizeof(s->metadata_hdr));
offset += sizeof(s->metadata_hdr);
vhdx_metadata_header_le_import(&s->metadata_hdr);
if (memcmp(&s->metadata_hdr.signature, ""metadata"", 8)) {
ret = -EINVAL;
goto exit;
}
s->metadata_entries.present = 0;
if ((s->metadata_hdr.entry_count * sizeof(md_entry)) >
(VHDX_METADATA_TABLE_MAX_SIZE - offset)) {
ret = -EINVAL;
goto exit;
}
for (i = 0; i < s->metadata_hdr.entry_count; i++) {
memcpy(&md_entry, buffer + offset, sizeof(md_entry));
offset += sizeof(md_entry);
vhdx_metadata_entry_le_import(&md_entry);
if (guid_eq(md_entry.item_id, file_param_guid)) {
if (s->metadata_entries.present & META_FILE_PARAMETER_PRESENT) {
ret = -EINVAL;
goto exit;
}
s->metadata_entries.file_parameters_entry = md_entry;
s->metadata_entries.present |= META_FILE_PARAMETER_PRESENT;
continue;
}
if (guid_eq(md_entry.item_id, virtual_size_guid)) {
if (s->metadata_entries.present & META_VIRTUAL_DISK_SIZE_PRESENT) {
ret = -EINVAL;
goto exit;
}
s->metadata_entries.virtual_disk_size_entry = md_entry;
s->metadata_entries.present |= META_VIRTUAL_DISK_SIZE_PRESENT;
continue;
}
if (guid_eq(md_entry.item_id, page83_guid)) {
if (s->metadata_entries.present & META_PAGE_83_PRESENT) {
ret = -EINVAL;
goto exit;
}
s->metadata_entries.page83_data_entry = md_entry;
s->metadata_entries.present |= META_PAGE_83_PRESENT;
continue;
}
if (guid_eq(md_entry.item_id, logical_sector_guid)) {
if (s->metadata_entries.present &
META_LOGICAL_SECTOR_SIZE_PRESENT) {
ret = -EINVAL;
goto exit;
}
s->metadata_entries.logical_sector_size_entry = md_entry;
s->metadata_entries.present |= META_LOGICAL_SECTOR_SIZE_PRESENT;
continue;
}
if (guid_eq(md_entry.item_id, phys_sector_guid)) {
if (s->metadata_entries.present & META_PHYS_SECTOR_SIZE_PRESENT) {
ret = -EINVAL;
goto exit;
}
s->metadata_entries.phys_sector_size_entry = md_entry;
s->metadata_entries.present |= META_PHYS_SECTOR_SIZE_PRESENT;
continue;
}
if (guid_eq(md_entry.item_id, parent_locator_guid)) {
if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {
ret = -EINVAL;
goto exit;
}
s->metadata_entries.parent_locator_entry = md_entry;
s->metadata_entries.present |= META_PARENT_LOCATOR_PRESENT;
continue;
}
if (md_entry.data_bits & VHDX_META_FLAGS_IS_REQUIRED) {
ret = -ENOTSUP;
goto exit;
}
}
if (s->metadata_entries.present != META_ALL_PRESENT) {
ret = -ENOTSUP;
goto exit;
}
ret = bdrv_pread(bs->file,
s->metadata_entries.file_parameters_entry.offset
+ s->metadata_rt.file_offset,
&s->params,
sizeof(s->params));
if (ret < 0) {
goto exit;
}
le32_to_cpus(&s->params.block_size);
le32_to_cpus(&s->params.data_bits);
if (s->params.data_bits & VHDX_PARAMS_HAS_PARENT) {
if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {
ret = -ENOTSUP; 
goto exit;
} else {
ret = -EINVAL;
goto exit;
}
}
ret = bdrv_pread(bs->file,
s->metadata_entries.virtual_disk_size_entry.offset
+ s->metadata_rt.file_offset,
&s->virtual_disk_size,
sizeof(uint64_t));
if (ret < 0) {
goto exit;
}
ret = bdrv_pread(bs->file,
s->metadata_entries.logical_sector_size_entry.offset
+ s->metadata_rt.file_offset,
&s->logical_sector_size,
sizeof(uint32_t));
if (ret < 0) {
goto exit;
}
ret = bdrv_pread(bs->file,
s->metadata_entries.phys_sector_size_entry.offset
+ s->metadata_rt.file_offset,
&s->physical_sector_size,
sizeof(uint32_t));
if (ret < 0) {
goto exit;
}
le64_to_cpus(&s->virtual_disk_size);
le32_to_cpus(&s->logical_sector_size);
le32_to_cpus(&s->physical_sector_size);
if (s->logical_sector_size == 0 || s->params.block_size == 0) {
ret = -EINVAL;
goto exit;
}
s->sectors_per_block = s->params.block_size / s->logical_sector_size;
s->chunk_ratio = (VHDX_MAX_SECTORS_PER_BLOCK) *
(uint64_t)s->logical_sector_size /
(uint64_t)s->params.block_size;
if (s->logical_sector_size & (s->logical_sector_size - 1)) {
ret = -EINVAL;
goto exit;
}
if (s->sectors_per_block & (s->sectors_per_block - 1)) {
ret = -EINVAL;
goto exit;
}
if (s->chunk_ratio & (s->chunk_ratio - 1)) {
ret = -EINVAL;
goto exit;
}
s->block_size = s->params.block_size;
if (s->block_size & (s->block_size - 1)) {
ret = -EINVAL;
goto exit;
}
vhdx_set_shift_bits(s);
ret = 0;
exit:
qemu_vfree(buffer);
return ret;
}","static int vhdx_parse_metadata(BlockDriverState *VAR_0, BDRVVHDXState *VAR_1)
{
int VAR_2 = 0;
uint8_t *VAR_3;
int VAR_4 = 0;
uint32_t VAR_5 = 0;
VHDXMetadataTableEntry VAR_6;
VAR_3 = qemu_blockalign(VAR_0, VAR_7);
VAR_2 = bdrv_pread(VAR_0->file, VAR_1->metadata_rt.file_offset, VAR_3,
VAR_7);
if (VAR_2 < 0) {
goto exit;
}
memcpy(&VAR_1->metadata_hdr, VAR_3, sizeof(VAR_1->metadata_hdr));
VAR_4 += sizeof(VAR_1->metadata_hdr);
vhdx_metadata_header_le_import(&VAR_1->metadata_hdr);
if (memcmp(&VAR_1->metadata_hdr.signature, ""metadata"", 8)) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->metadata_entries.present = 0;
if ((VAR_1->metadata_hdr.entry_count * sizeof(VAR_6)) >
(VAR_7 - VAR_4)) {
VAR_2 = -VAR_8;
goto exit;
}
for (VAR_5 = 0; VAR_5 < VAR_1->metadata_hdr.entry_count; VAR_5++) {
memcpy(&VAR_6, VAR_3 + VAR_4, sizeof(VAR_6));
VAR_4 += sizeof(VAR_6);
vhdx_metadata_entry_le_import(&VAR_6);
if (guid_eq(VAR_6.item_id, VAR_9)) {
if (VAR_1->metadata_entries.present & VAR_10) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->metadata_entries.file_parameters_entry = VAR_6;
VAR_1->metadata_entries.present |= VAR_10;
continue;
}
if (guid_eq(VAR_6.item_id, VAR_11)) {
if (VAR_1->metadata_entries.present & VAR_12) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->metadata_entries.virtual_disk_size_entry = VAR_6;
VAR_1->metadata_entries.present |= VAR_12;
continue;
}
if (guid_eq(VAR_6.item_id, VAR_13)) {
if (VAR_1->metadata_entries.present & VAR_14) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->metadata_entries.page83_data_entry = VAR_6;
VAR_1->metadata_entries.present |= VAR_14;
continue;
}
if (guid_eq(VAR_6.item_id, VAR_15)) {
if (VAR_1->metadata_entries.present &
VAR_16) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->metadata_entries.logical_sector_size_entry = VAR_6;
VAR_1->metadata_entries.present |= VAR_16;
continue;
}
if (guid_eq(VAR_6.item_id, VAR_17)) {
if (VAR_1->metadata_entries.present & VAR_18) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->metadata_entries.phys_sector_size_entry = VAR_6;
VAR_1->metadata_entries.present |= VAR_18;
continue;
}
if (guid_eq(VAR_6.item_id, VAR_19)) {
if (VAR_1->metadata_entries.present & VAR_20) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->metadata_entries.parent_locator_entry = VAR_6;
VAR_1->metadata_entries.present |= VAR_20;
continue;
}
if (VAR_6.data_bits & VAR_21) {
VAR_2 = -VAR_22;
goto exit;
}
}
if (VAR_1->metadata_entries.present != VAR_23) {
VAR_2 = -VAR_22;
goto exit;
}
VAR_2 = bdrv_pread(VAR_0->file,
VAR_1->metadata_entries.file_parameters_entry.offset
+ VAR_1->metadata_rt.file_offset,
&VAR_1->params,
sizeof(VAR_1->params));
if (VAR_2 < 0) {
goto exit;
}
le32_to_cpus(&VAR_1->params.block_size);
le32_to_cpus(&VAR_1->params.data_bits);
if (VAR_1->params.data_bits & VAR_24) {
if (VAR_1->metadata_entries.present & VAR_20) {
VAR_2 = -VAR_22; 
goto exit;
} else {
VAR_2 = -VAR_8;
goto exit;
}
}
VAR_2 = bdrv_pread(VAR_0->file,
VAR_1->metadata_entries.virtual_disk_size_entry.offset
+ VAR_1->metadata_rt.file_offset,
&VAR_1->virtual_disk_size,
sizeof(uint64_t));
if (VAR_2 < 0) {
goto exit;
}
VAR_2 = bdrv_pread(VAR_0->file,
VAR_1->metadata_entries.logical_sector_size_entry.offset
+ VAR_1->metadata_rt.file_offset,
&VAR_1->logical_sector_size,
sizeof(uint32_t));
if (VAR_2 < 0) {
goto exit;
}
VAR_2 = bdrv_pread(VAR_0->file,
VAR_1->metadata_entries.phys_sector_size_entry.offset
+ VAR_1->metadata_rt.file_offset,
&VAR_1->physical_sector_size,
sizeof(uint32_t));
if (VAR_2 < 0) {
goto exit;
}
le64_to_cpus(&VAR_1->virtual_disk_size);
le32_to_cpus(&VAR_1->logical_sector_size);
le32_to_cpus(&VAR_1->physical_sector_size);
if (VAR_1->logical_sector_size == 0 || VAR_1->params.block_size == 0) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->sectors_per_block = VAR_1->params.block_size / VAR_1->logical_sector_size;
VAR_1->chunk_ratio = (VAR_25) *
(uint64_t)VAR_1->logical_sector_size /
(uint64_t)VAR_1->params.block_size;
if (VAR_1->logical_sector_size & (VAR_1->logical_sector_size - 1)) {
VAR_2 = -VAR_8;
goto exit;
}
if (VAR_1->sectors_per_block & (VAR_1->sectors_per_block - 1)) {
VAR_2 = -VAR_8;
goto exit;
}
if (VAR_1->chunk_ratio & (VAR_1->chunk_ratio - 1)) {
VAR_2 = -VAR_8;
goto exit;
}
VAR_1->block_size = VAR_1->params.block_size;
if (VAR_1->block_size & (VAR_1->block_size - 1)) {
VAR_2 = -VAR_8;
goto exit;
}
vhdx_set_shift_bits(VAR_1);
VAR_2 = 0;
exit:
qemu_vfree(VAR_3);
return VAR_2;
}",qemu/1d7678dec4761acdc43439da6ceda41a703ba1a6/vhdx.c/vul/before/0.json,"static int vhdx_parse_metadata(BlockDriverState *bs, BDRVVHDXState *s)
{
    int ret = 0;
    uint8_t *buffer;
    int offset = 0;
    uint32_t i = 0;
    VHDXMetadataTableEntry md_entry;

    buffer = qemu_blockalign(bs, VHDX_METADATA_TABLE_MAX_SIZE);

    ret = bdrv_pread(bs->file, s->metadata_rt.file_offset, buffer,
                     VHDX_METADATA_TABLE_MAX_SIZE);
    if (ret < 0) {
        goto exit;
    }
    memcpy(&s->metadata_hdr, buffer, sizeof(s->metadata_hdr));
    offset += sizeof(s->metadata_hdr);

    vhdx_metadata_header_le_import(&s->metadata_hdr);

    if (memcmp(&s->metadata_hdr.signature, ""metadata"", 8)) {
        ret = -EINVAL;
        goto exit;
    }

    s->metadata_entries.present = 0;

    if ((s->metadata_hdr.entry_count * sizeof(md_entry)) >
        (VHDX_METADATA_TABLE_MAX_SIZE - offset)) {
        ret = -EINVAL;
        goto exit;
    }

    for (i = 0; i < s->metadata_hdr.entry_count; i++) {
        memcpy(&md_entry, buffer + offset, sizeof(md_entry));
        offset += sizeof(md_entry);

        vhdx_metadata_entry_le_import(&md_entry);

        if (guid_eq(md_entry.item_id, file_param_guid)) {
            if (s->metadata_entries.present & META_FILE_PARAMETER_PRESENT) {
                ret = -EINVAL;
                goto exit;
            }
            s->metadata_entries.file_parameters_entry = md_entry;
            s->metadata_entries.present |= META_FILE_PARAMETER_PRESENT;
            continue;
        }

        if (guid_eq(md_entry.item_id, virtual_size_guid)) {
            if (s->metadata_entries.present & META_VIRTUAL_DISK_SIZE_PRESENT) {
                ret = -EINVAL;
                goto exit;
            }
            s->metadata_entries.virtual_disk_size_entry = md_entry;
            s->metadata_entries.present |= META_VIRTUAL_DISK_SIZE_PRESENT;
            continue;
        }

        if (guid_eq(md_entry.item_id, page83_guid)) {
            if (s->metadata_entries.present & META_PAGE_83_PRESENT) {
                ret = -EINVAL;
                goto exit;
            }
            s->metadata_entries.page83_data_entry = md_entry;
            s->metadata_entries.present |= META_PAGE_83_PRESENT;
            continue;
        }

        if (guid_eq(md_entry.item_id, logical_sector_guid)) {
            if (s->metadata_entries.present &
                META_LOGICAL_SECTOR_SIZE_PRESENT) {
                ret = -EINVAL;
                goto exit;
            }
            s->metadata_entries.logical_sector_size_entry = md_entry;
            s->metadata_entries.present |= META_LOGICAL_SECTOR_SIZE_PRESENT;
            continue;
        }

        if (guid_eq(md_entry.item_id, phys_sector_guid)) {
            if (s->metadata_entries.present & META_PHYS_SECTOR_SIZE_PRESENT) {
                ret = -EINVAL;
                goto exit;
            }
            s->metadata_entries.phys_sector_size_entry = md_entry;
            s->metadata_entries.present |= META_PHYS_SECTOR_SIZE_PRESENT;
            continue;
        }

        if (guid_eq(md_entry.item_id, parent_locator_guid)) {
            if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {
                ret = -EINVAL;
                goto exit;
            }
            s->metadata_entries.parent_locator_entry = md_entry;
            s->metadata_entries.present |= META_PARENT_LOCATOR_PRESENT;
            continue;
        }

        if (md_entry.data_bits & VHDX_META_FLAGS_IS_REQUIRED) {
            /* cannot read vhdx file - required region table entry that
             * we do not understand.  per spec, we must fail to open */
            ret = -ENOTSUP;
            goto exit;
        }
    }

    if (s->metadata_entries.present != META_ALL_PRESENT) {
        ret = -ENOTSUP;
        goto exit;
    }

    ret = bdrv_pread(bs->file,
                     s->metadata_entries.file_parameters_entry.offset
                                         + s->metadata_rt.file_offset,
                     &s->params,
                     sizeof(s->params));

    if (ret < 0) {
        goto exit;
    }

    le32_to_cpus(&s->params.block_size);
    le32_to_cpus(&s->params.data_bits);


    /* We now have the file parameters, so we can tell if this is a
     * differencing file (i.e.. has_parent), is dynamic or fixed
     * sized (leave_blocks_allocated), and the block size */

    /* The parent locator required iff the file parameters has_parent set */
    if (s->params.data_bits & VHDX_PARAMS_HAS_PARENT) {
        if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {
            /* TODO: parse  parent locator fields */
            ret = -ENOTSUP; /* temp, until differencing files are supported */
            goto exit;
        } else {
            /* if has_parent is set, but there is not parent locator present,
             * then that is an invalid combination */
            ret = -EINVAL;
            goto exit;
        }
    }

    /* determine virtual disk size, logical sector size,
     * and phys sector size */

    ret = bdrv_pread(bs->file,
                     s->metadata_entries.virtual_disk_size_entry.offset
                                           + s->metadata_rt.file_offset,
                     &s->virtual_disk_size,
                     sizeof(uint64_t));
    if (ret < 0) {
        goto exit;
    }
    ret = bdrv_pread(bs->file,
                     s->metadata_entries.logical_sector_size_entry.offset
                                             + s->metadata_rt.file_offset,
                     &s->logical_sector_size,
                     sizeof(uint32_t));
    if (ret < 0) {
        goto exit;
    }
    ret = bdrv_pread(bs->file,
                     s->metadata_entries.phys_sector_size_entry.offset
                                          + s->metadata_rt.file_offset,
                     &s->physical_sector_size,
                     sizeof(uint32_t));
    if (ret < 0) {
        goto exit;
    }

    le64_to_cpus(&s->virtual_disk_size);
    le32_to_cpus(&s->logical_sector_size);
    le32_to_cpus(&s->physical_sector_size);

    if (s->params.block_size < VHDX_BLOCK_SIZE_MIN ||
        s->params.block_size > VHDX_BLOCK_SIZE_MAX) {
        ret = -EINVAL;
        goto exit;
    }

    /* only 2 supported sector sizes */
    if (s->logical_sector_size != 512 && s->logical_sector_size != 4096) {
        ret = -EINVAL;
        goto exit;
    }

    /* Both block_size and sector_size are guaranteed powers of 2, below.
       Due to range checks above, s->sectors_per_block can never be < 256 */
    s->sectors_per_block = s->params.block_size / s->logical_sector_size;
    s->chunk_ratio = (VHDX_MAX_SECTORS_PER_BLOCK) *
                     (uint64_t)s->logical_sector_size /
                     (uint64_t)s->params.block_size;

    /* These values are ones we will want to use for division / multiplication
     * later on, and they are all guaranteed (per the spec) to be powers of 2,
     * so we can take advantage of that for shift operations during
     * reads/writes */
    if (s->logical_sector_size & (s->logical_sector_size - 1)) {
        ret = -EINVAL;
        goto exit;
    }
    if (s->sectors_per_block & (s->sectors_per_block - 1)) {
        ret = -EINVAL;
        goto exit;
    }
    if (s->chunk_ratio & (s->chunk_ratio - 1)) {
        ret = -EINVAL;
        goto exit;
    }
    s->block_size = s->params.block_size;
    if (s->block_size & (s->block_size - 1)) {
        ret = -EINVAL;
        goto exit;
    }

    vhdx_set_shift_bits(s);

    ret = 0;

exit:
    qemu_vfree(buffer);
    return ret;
}","static int vhdx_parse_metadata(BlockDriverState *VAR_0, BDRVVHDXState *VAR_1)
{
    int VAR_2 = 0;
    uint8_t *VAR_3;
    int VAR_4 = 0;
    uint32_t VAR_5 = 0;
    VHDXMetadataTableEntry VAR_6;

    VAR_3 = qemu_blockalign(VAR_0, VAR_7);

    VAR_2 = bdrv_pread(VAR_0->file, VAR_1->metadata_rt.file_offset, VAR_3,
                     VAR_7);
    if (VAR_2 < 0) {
        goto exit;
    }
    memcpy(&VAR_1->metadata_hdr, VAR_3, sizeof(VAR_1->metadata_hdr));
    VAR_4 += sizeof(VAR_1->metadata_hdr);

    vhdx_metadata_header_le_import(&VAR_1->metadata_hdr);

    if (memcmp(&VAR_1->metadata_hdr.signature, ""metadata"", 8)) {
        VAR_2 = -VAR_8;
        goto exit;
    }

    VAR_1->metadata_entries.present = 0;

    if ((VAR_1->metadata_hdr.entry_count * sizeof(VAR_6)) >
        (VAR_7 - VAR_4)) {
        VAR_2 = -VAR_8;
        goto exit;
    }

    for (VAR_5 = 0; VAR_5 < VAR_1->metadata_hdr.entry_count; VAR_5++) {
        memcpy(&VAR_6, VAR_3 + VAR_4, sizeof(VAR_6));
        VAR_4 += sizeof(VAR_6);

        vhdx_metadata_entry_le_import(&VAR_6);

        if (guid_eq(VAR_6.item_id, VAR_9)) {
            if (VAR_1->metadata_entries.present & VAR_10) {
                VAR_2 = -VAR_8;
                goto exit;
            }
            VAR_1->metadata_entries.file_parameters_entry = VAR_6;
            VAR_1->metadata_entries.present |= VAR_10;
            continue;
        }

        if (guid_eq(VAR_6.item_id, VAR_11)) {
            if (VAR_1->metadata_entries.present & VAR_12) {
                VAR_2 = -VAR_8;
                goto exit;
            }
            VAR_1->metadata_entries.virtual_disk_size_entry = VAR_6;
            VAR_1->metadata_entries.present |= VAR_12;
            continue;
        }

        if (guid_eq(VAR_6.item_id, VAR_13)) {
            if (VAR_1->metadata_entries.present & VAR_14) {
                VAR_2 = -VAR_8;
                goto exit;
            }
            VAR_1->metadata_entries.page83_data_entry = VAR_6;
            VAR_1->metadata_entries.present |= VAR_14;
            continue;
        }

        if (guid_eq(VAR_6.item_id, VAR_15)) {
            if (VAR_1->metadata_entries.present &
                VAR_16) {
                VAR_2 = -VAR_8;
                goto exit;
            }
            VAR_1->metadata_entries.logical_sector_size_entry = VAR_6;
            VAR_1->metadata_entries.present |= VAR_16;
            continue;
        }

        if (guid_eq(VAR_6.item_id, VAR_17)) {
            if (VAR_1->metadata_entries.present & VAR_18) {
                VAR_2 = -VAR_8;
                goto exit;
            }
            VAR_1->metadata_entries.phys_sector_size_entry = VAR_6;
            VAR_1->metadata_entries.present |= VAR_18;
            continue;
        }

        if (guid_eq(VAR_6.item_id, VAR_19)) {
            if (VAR_1->metadata_entries.present & VAR_20) {
                VAR_2 = -VAR_8;
                goto exit;
            }
            VAR_1->metadata_entries.parent_locator_entry = VAR_6;
            VAR_1->metadata_entries.present |= VAR_20;
            continue;
        }

        if (VAR_6.data_bits & VAR_21) {
            /* COMMENT_0 */
                                                                       
            VAR_2 = -VAR_22;
            goto exit;
        }
    }

    if (VAR_1->metadata_entries.present != VAR_23) {
        VAR_2 = -VAR_22;
        goto exit;
    }

    VAR_2 = bdrv_pread(VAR_0->file,
                     VAR_1->metadata_entries.file_parameters_entry.offset
                                         + VAR_1->metadata_rt.file_offset,
                     &VAR_1->params,
                     sizeof(VAR_1->params));

    if (VAR_2 < 0) {
        goto exit;
    }

    le32_to_cpus(&VAR_1->params.block_size);
    le32_to_cpus(&VAR_1->params.data_bits);


    /* COMMENT_2 */
                                                                
                                                            

    /* COMMENT_5 */
    if (VAR_1->params.data_bits & VAR_24) {
        if (VAR_1->metadata_entries.present & VAR_20) {
            /* COMMENT_6 */
            VAR_2 = -VAR_22; /* COMMENT_7 */
            goto exit;
        } else {
            /* COMMENT_8 */
                                                     
            VAR_2 = -VAR_8;
            goto exit;
        }
    }

    /* COMMENT_10 */
                              

    VAR_2 = bdrv_pread(VAR_0->file,
                     VAR_1->metadata_entries.virtual_disk_size_entry.offset
                                           + VAR_1->metadata_rt.file_offset,
                     &VAR_1->virtual_disk_size,
                     sizeof(uint64_t));
    if (VAR_2 < 0) {
        goto exit;
    }
    VAR_2 = bdrv_pread(VAR_0->file,
                     VAR_1->metadata_entries.logical_sector_size_entry.offset
                                             + VAR_1->metadata_rt.file_offset,
                     &VAR_1->logical_sector_size,
                     sizeof(uint32_t));
    if (VAR_2 < 0) {
        goto exit;
    }
    VAR_2 = bdrv_pread(VAR_0->file,
                     VAR_1->metadata_entries.phys_sector_size_entry.offset
                                          + VAR_1->metadata_rt.file_offset,
                     &VAR_1->physical_sector_size,
                     sizeof(uint32_t));
    if (VAR_2 < 0) {
        goto exit;
    }

    le64_to_cpus(&VAR_1->virtual_disk_size);
    le32_to_cpus(&VAR_1->logical_sector_size);
    le32_to_cpus(&VAR_1->physical_sector_size);

    if (VAR_1->params.block_size < VAR_25 ||
        VAR_1->params.block_size > VAR_26) {
        VAR_2 = -VAR_8;
        goto exit;
    }

    /* COMMENT_12 */
    if (VAR_1->logical_sector_size != 512 && VAR_1->logical_sector_size != 4096) {
        VAR_2 = -VAR_8;
        goto exit;
    }

    /* COMMENT_13 */
                                                                            
    VAR_1->sectors_per_block = VAR_1->params.block_size / VAR_1->logical_sector_size;
    VAR_1->chunk_ratio = (VAR_27) *
                     (uint64_t)VAR_1->logical_sector_size /
                     (uint64_t)VAR_1->params.block_size;

    /* COMMENT_15 */
                                                                              
                                                                   
                      
    if (VAR_1->logical_sector_size & (VAR_1->logical_sector_size - 1)) {
        VAR_2 = -VAR_8;
        goto exit;
    }
    if (VAR_1->sectors_per_block & (VAR_1->sectors_per_block - 1)) {
        VAR_2 = -VAR_8;
        goto exit;
    }
    if (VAR_1->chunk_ratio & (VAR_1->chunk_ratio - 1)) {
        VAR_2 = -VAR_8;
        goto exit;
    }
    VAR_1->block_size = VAR_1->params.block_size;
    if (VAR_1->block_size & (VAR_1->block_size - 1)) {
        VAR_2 = -VAR_8;
        goto exit;
    }

    vhdx_set_shift_bits(VAR_1);

    VAR_2 = 0;

exit:
    qemu_vfree(VAR_3);
    return VAR_2;
}",qemu/1d7678dec4761acdc43439da6ceda41a703ba1a6/vhdx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -175,12 +175,20 @@
     le32_to_cpus(&s->logical_sector_size);
     le32_to_cpus(&s->physical_sector_size);
 
-    if (s->logical_sector_size == 0 || s->params.block_size == 0) {
-        ret = -EINVAL;
-        goto exit;
-    }
-
-    /* both block_size and sector_size are guaranteed powers of 2 */
+    if (s->params.block_size < VHDX_BLOCK_SIZE_MIN ||
+        s->params.block_size > VHDX_BLOCK_SIZE_MAX) {
+        ret = -EINVAL;
+        goto exit;
+    }
+
+    /* only 2 supported sector sizes */
+    if (s->logical_sector_size != 512 && s->logical_sector_size != 4096) {
+        ret = -EINVAL;
+        goto exit;
+    }
+
+    /* Both block_size and sector_size are guaranteed powers of 2, below.
+       Due to range checks above, s->sectors_per_block can never be < 256 */
     s->sectors_per_block = s->params.block_size / s->logical_sector_size;
     s->chunk_ratio = (VHDX_MAX_SECTORS_PER_BLOCK) *
                      (uint64_t)s->logical_sector_size /","{'deleted_lines': ['    if (s->logical_sector_size == 0 || s->params.block_size == 0) {', '        ret = -EINVAL;', '        goto exit;', '    }', '', '    /* both block_size and sector_size are guaranteed powers of 2 */'], 'added_lines': ['    if (s->params.block_size < VHDX_BLOCK_SIZE_MIN ||', '        s->params.block_size > VHDX_BLOCK_SIZE_MAX) {', '        ret = -EINVAL;', '        goto exit;', '    }', '', '    /* only 2 supported sector sizes */', '    if (s->logical_sector_size != 512 && s->logical_sector_size != 4096) {', '        ret = -EINVAL;', '        goto exit;', '    }', '', '    /* Both block_size and sector_size are guaranteed powers of 2, below.', '       Due to range checks above, s->sectors_per_block can never be < 256 */']}",True,"Qemu before 2.0 block driver for Hyper-V VHDX Images is vulnerable to infinite loops and other potential issues when calculating BAT entries, due to missing bounds checks for block_size and logical_sector_size variables. These are used to derive other fields like 'sectors_per_block' etc. A user able to alter the Qemu disk image could ise this flaw to crash the Qemu instance resulting in DoS.",5.5,MEDIUM,1,valid,2014-03-26T12:05:39Z,1
CVE-2016-3179,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,miniupnp,minissdpd.c: Initialize pointers to NULL (fix),140ee8d2204b383279f854802b27bdb41c1d5d1a,https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a,minissdpd/minissdpd.c,processRequest,"void processRequest(struct reqelem * req)
{
ssize_t n;
unsigned int l, m;
unsigned char buf[2048];
const unsigned char * p;
int type;
struct device * d = devlist;
unsigned char rbuf[4096];
unsigned char * rp = rbuf+1;
unsigned char nrep = 0;
time_t t;
struct service * newserv = NULL;
struct service * serv;
n = read(req->socket, buf, sizeof(buf));
if(n<0) {
if(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)
return;
syslog(LOG_ERR, ""(s=%d) processRequest(): read(): %m"", req->socket);
goto error;
}
if(n==0) {
syslog(LOG_INFO, ""(s=%d) request connection closed"", req->socket);
goto error;
}
t = time(NULL);
type = buf[0];
p = buf + 1;
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding)"");
goto error;
}
if(l == 0 && type != 3) {
syslog(LOG_WARNING, ""bad request (length=0)"");
goto error;
}
syslog(LOG_INFO, ""(s=%d) request type=%d str='%.*s'"",
req->socket, type, l, p);
switch(type) {
case 1:
case 2:
case 3:
while(d && (nrep < 255)) {
if(d->t < t) {
syslog(LOG_INFO, ""outdated device"");
} else {
if(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l
+ d->headers[HEADER_USN].l + 6
+ (rp - rbuf) >= (int)sizeof(rbuf))
break;
if( (type==1 && 0==memcmp(d->headers[HEADER_NT].p, p, l))
||(type==2 && 0==memcmp(d->headers[HEADER_USN].p, p, l))
||(type==3) ) {
m = d->headers[HEADER_LOCATION].l;
CODELENGTH(m, rp);
memcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);
rp += d->headers[HEADER_LOCATION].l;
m = d->headers[HEADER_NT].l;
CODELENGTH(m, rp);
memcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);
rp += d->headers[HEADER_NT].l;
m = d->headers[HEADER_USN].l;
CODELENGTH(m, rp);
memcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);
rp += d->headers[HEADER_USN].l;
nrep++;
}
}
d = d->next;
}
for(serv = servicelisthead.lh_first;
serv && (nrep < 255);
serv = serv->entries.le_next) {
if(strlen(serv->location) + strlen(serv->st)
+ strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))
break;
if( (type==1 && 0==strncmp(serv->st, (const char *)p, l))
||(type==2 && 0==strncmp(serv->usn, (const char *)p, l))
||(type==3) ) {
m = strlen(serv->location);
CODELENGTH(m, rp);
memcpy(rp, serv->location, m);
rp += m;
m = strlen(serv->st);
CODELENGTH(m, rp);
memcpy(rp, serv->st, m);
rp += m;
m = strlen(serv->usn);
CODELENGTH(m, rp);
memcpy(rp, serv->usn, m);
rp += m;
nrep++;
}
}
rbuf[0] = nrep;
syslog(LOG_DEBUG, ""(s=%d) response : %d device%s"",
req->socket, nrep, (nrep > 1) ? ""s"" : """");
if(write(req->socket, rbuf, rp - rbuf) < 0) {
syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
goto error;
}
break;
case 4:
newserv = malloc(sizeof(struct service));
if(!newserv) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
goto error;
}
newserv->st = malloc(l + 1);
if(!newserv->st) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->st, p, l);
newserv->st[l] = '\0';
p += l;
if(p >= buf + n) {
syslog(LOG_WARNING, ""bad request (missing usn)"");
goto error;
}
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (usn contains forbidden chars)"");
goto error;
}
syslog(LOG_INFO, ""usn='%.*s'"", l, p);
newserv->usn = malloc(l + 1);
if(!newserv->usn) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->usn, p, l);
newserv->usn[l] = '\0';
p += l;
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (server contains forbidden chars)"");
goto error;
}
syslog(LOG_INFO, ""server='%.*s'"", l, p);
newserv->server = malloc(l + 1);
if(!newserv->server) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->server, p, l);
newserv->server[l] = '\0';
p += l;
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (location contains forbidden chars)"");
goto error;
}
syslog(LOG_INFO, ""location='%.*s'"", l, p);
newserv->location = malloc(l + 1);
if(!newserv->location) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->location, p, l);
newserv->location[l] = '\0';
for(serv = servicelisthead.lh_first;
serv;
serv = serv->entries.le_next) {
if(0 == strcmp(newserv->usn, serv->usn)
&& 0 == strcmp(newserv->st, serv->st)) {
syslog(LOG_INFO, ""Service allready in the list. Updating..."");
free(newserv->st);
free(newserv->usn);
free(serv->server);
serv->server = newserv->server;
free(serv->location);
serv->location = newserv->location;
free(newserv);
newserv = NULL;
return;
}
}
LIST_INSERT_HEAD(&servicelisthead, newserv, entries);
newserv = NULL;
break;
default:
syslog(LOG_WARNING, ""Unknown request type %d"", type);
rbuf[0] = '\0';
if(write(req->socket, rbuf, 1) < 0) {
syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
goto error;
}
}
return;
error:
if(newserv) {
free(newserv->st);
free(newserv->usn);
free(newserv->server);
free(newserv->location);
free(newserv);
newserv = NULL;
}
close(req->socket);
req->socket = -1;
return;
}","void processRequest(struct reqelem * VAR_0)
{
ssize_t VAR_1;
unsigned int VAR_2, VAR_3;
unsigned char VAR_4[2048];
const unsigned char * VAR_5;
int VAR_6;
struct device * VAR_7 = VAR_8;
unsigned char VAR_9[4096];
unsigned char * VAR_10 = VAR_9+1;
unsigned char VAR_11 = 0;
time_t VAR_12;
struct service * VAR_13 = NULL;
struct service * VAR_14;
VAR_1 = read(VAR_0->socket, VAR_4, sizeof(VAR_4));
if(VAR_1<0) {
if(VAR_15 == VAR_16 || VAR_15 == VAR_17 || VAR_15 == VAR_18)
return;
syslog(VAR_19, ""(s=%d) processRequest(): read(): %m"", VAR_0->socket);
goto error;
}
if(VAR_1==0) {
syslog(VAR_20, ""(s=%d) request connection closed"", VAR_0->socket);
goto error;
}
VAR_12 = time(NULL);
VAR_6 = VAR_4[0];
VAR_5 = VAR_4 + 1;
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_21, ""bad request (length encoding)"");
goto error;
}
if(VAR_2 == 0 && VAR_6 != 3) {
syslog(VAR_21, ""bad request (length=0)"");
goto error;
}
syslog(VAR_20, ""(s=%d) request type=%d str='%.*s'"",
VAR_0->socket, VAR_6, VAR_2, VAR_5);
switch(VAR_6) {
case 1:
case 2:
case 3:
while(VAR_7 && (VAR_11 < 255)) {
if(VAR_7->t < VAR_12) {
syslog(VAR_20, ""outdated device"");
} else {
if(VAR_7->headers[VAR_22].l + VAR_7->headers[VAR_23].l
+ VAR_7->headers[VAR_24].l + 6
+ (VAR_10 - VAR_9) >= (int)sizeof(VAR_9))
break;
if( (VAR_6==1 && 0==memcmp(VAR_7->headers[VAR_23].p, VAR_5, VAR_2))
||(VAR_6==2 && 0==memcmp(VAR_7->headers[VAR_24].p, VAR_5, VAR_2))
||(VAR_6==3) ) {
VAR_3 = VAR_7->headers[VAR_22].l;
CODELENGTH(VAR_3, VAR_10);
memcpy(VAR_10, VAR_7->headers[VAR_22].p, VAR_7->headers[VAR_22].l);
VAR_10 += VAR_7->headers[VAR_22].l;
VAR_3 = VAR_7->headers[VAR_23].l;
CODELENGTH(VAR_3, VAR_10);
memcpy(VAR_10, VAR_7->headers[VAR_23].p, VAR_7->headers[VAR_23].l);
VAR_10 += VAR_7->headers[VAR_23].l;
VAR_3 = VAR_7->headers[VAR_24].l;
CODELENGTH(VAR_3, VAR_10);
memcpy(VAR_10, VAR_7->headers[VAR_24].p, VAR_7->headers[VAR_24].l);
VAR_10 += VAR_7->headers[VAR_24].l;
VAR_11++;
}
}
VAR_7 = VAR_7->next;
}
for(VAR_14 = VAR_25.lh_first;
VAR_14 && (VAR_11 < 255);
VAR_14 = VAR_14->entries.le_next) {
if(strlen(VAR_14->location) + strlen(VAR_14->st)
+ strlen(VAR_14->usn) + 6 + (VAR_10 - VAR_9) >= sizeof(VAR_9))
break;
if( (VAR_6==1 && 0==strncmp(VAR_14->st, (const char *)VAR_5, VAR_2))
||(VAR_6==2 && 0==strncmp(VAR_14->usn, (const char *)VAR_5, VAR_2))
||(VAR_6==3) ) {
VAR_3 = strlen(VAR_14->location);
CODELENGTH(VAR_3, VAR_10);
memcpy(VAR_10, VAR_14->location, VAR_3);
VAR_10 += VAR_3;
VAR_3 = strlen(VAR_14->st);
CODELENGTH(VAR_3, VAR_10);
memcpy(VAR_10, VAR_14->st, VAR_3);
VAR_10 += VAR_3;
VAR_3 = strlen(VAR_14->usn);
CODELENGTH(VAR_3, VAR_10);
memcpy(VAR_10, VAR_14->usn, VAR_3);
VAR_10 += VAR_3;
VAR_11++;
}
}
VAR_9[0] = VAR_11;
syslog(VAR_26, ""(s=%d) response : %d device%s"",
VAR_0->socket, VAR_11, (VAR_11 > 1) ? ""s"" : """");
if(write(VAR_0->socket, VAR_9, VAR_10 - VAR_9) < 0) {
syslog(VAR_19, ""(s=%d) write: %m"", VAR_0->socket);
goto error;
}
break;
case 4:
VAR_13 = malloc(sizeof(struct service));
if(!VAR_13) {
syslog(VAR_19, ""cannot allocate memory"");
goto error;
}
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_19, ""bad request (st contains forbidden chars)"");
goto error;
}
VAR_13->st = malloc(VAR_2 + 1);
if(!VAR_13->st) {
syslog(VAR_19, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_13->st, VAR_5, VAR_2);
VAR_13->st[VAR_2] = '\0';
VAR_5 += VAR_2;
if(VAR_5 >= VAR_4 + VAR_1) {
syslog(VAR_21, ""bad request (missing usn)"");
goto error;
}
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_21, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_19, ""bad request (usn contains forbidden chars)"");
goto error;
}
syslog(VAR_20, ""usn='%.*s'"", VAR_2, VAR_5);
VAR_13->usn = malloc(VAR_2 + 1);
if(!VAR_13->usn) {
syslog(VAR_19, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_13->usn, VAR_5, VAR_2);
VAR_13->usn[VAR_2] = '\0';
VAR_5 += VAR_2;
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_21, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_19, ""bad request (server contains forbidden chars)"");
goto error;
}
syslog(VAR_20, ""server='%.*s'"", VAR_2, VAR_5);
VAR_13->server = malloc(VAR_2 + 1);
if(!VAR_13->server) {
syslog(VAR_19, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_13->server, VAR_5, VAR_2);
VAR_13->server[VAR_2] = '\0';
VAR_5 += VAR_2;
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_21, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_19, ""bad request (location contains forbidden chars)"");
goto error;
}
syslog(VAR_20, ""location='%.*s'"", VAR_2, VAR_5);
VAR_13->location = malloc(VAR_2 + 1);
if(!VAR_13->location) {
syslog(VAR_19, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_13->location, VAR_5, VAR_2);
VAR_13->location[VAR_2] = '\0';
for(VAR_14 = VAR_25.lh_first;
VAR_14;
VAR_14 = VAR_14->entries.le_next) {
if(0 == strcmp(VAR_13->usn, VAR_14->usn)
&& 0 == strcmp(VAR_13->st, VAR_14->st)) {
syslog(VAR_20, ""Service allready in the list. Updating..."");
free(VAR_13->st);
free(VAR_13->usn);
free(VAR_14->server);
VAR_14->server = VAR_13->server;
free(VAR_14->location);
VAR_14->location = VAR_13->location;
free(VAR_13);
VAR_13 = NULL;
return;
}
}
LIST_INSERT_HEAD(&VAR_25, VAR_13, VAR_27);
VAR_13 = NULL;
break;
default:
syslog(VAR_21, ""Unknown request type %d"", VAR_6);
VAR_9[0] = '\0';
if(write(VAR_0->socket, VAR_9, 1) < 0) {
syslog(VAR_19, ""(s=%d) write: %m"", VAR_0->socket);
goto error;
}
}
return;
error:
if(VAR_13) {
free(VAR_13->st);
free(VAR_13->usn);
free(VAR_13->server);
free(VAR_13->location);
free(VAR_13);
VAR_13 = NULL;
}
close(VAR_0->socket);
VAR_0->socket = -1;
return;
}",miniupnp/140ee8d2204b383279f854802b27bdb41c1d5d1a/minissdpd.c/vul/before/0.json,"void processRequest(struct reqelem * req)
{
	ssize_t n;
	unsigned int l, m;
	unsigned char buf[2048];
	const unsigned char * p;
	int type;
	struct device * d = devlist;
	unsigned char rbuf[4096];
	unsigned char * rp = rbuf+1;
	unsigned char nrep = 0;
	time_t t;
	struct service * newserv = NULL;
	struct service * serv;

	n = read(req->socket, buf, sizeof(buf));
	if(n<0) {
		if(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)
			return;	/* try again later */
		syslog(LOG_ERR, ""(s=%d) processRequest(): read(): %m"", req->socket);
		goto error;
	}
	if(n==0) {
		syslog(LOG_INFO, ""(s=%d) request connection closed"", req->socket);
		goto error;
	}
	t = time(NULL);
	type = buf[0];
	p = buf + 1;
	DECODELENGTH_CHECKLIMIT(l, p, buf + n);
	if(p+l > buf+n) {
		syslog(LOG_WARNING, ""bad request (length encoding)"");
		goto error;
	}
	if(l == 0 && type != 3) {
		syslog(LOG_WARNING, ""bad request (length=0)"");
		goto error;
	}
	syslog(LOG_INFO, ""(s=%d) request type=%d str='%.*s'"",
	       req->socket, type, l, p);
	switch(type) {
	case 1:	/* request by type */
	case 2:	/* request by USN (unique id) */
	case 3:	/* everything */
		while(d && (nrep < 255)) {
			if(d->t < t) {
				syslog(LOG_INFO, ""outdated device"");
			} else {
				/* test if we can put more responses in the buffer */
				if(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l
				  + d->headers[HEADER_USN].l + 6
				  + (rp - rbuf) >= (int)sizeof(rbuf))
					break;
				if( (type==1 && 0==memcmp(d->headers[HEADER_NT].p, p, l))
				  ||(type==2 && 0==memcmp(d->headers[HEADER_USN].p, p, l))
				  ||(type==3) ) {
					/* response :
					 * 1 - Location
					 * 2 - NT (device/service type)
					 * 3 - usn */
					m = d->headers[HEADER_LOCATION].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);
					rp += d->headers[HEADER_LOCATION].l;
					m = d->headers[HEADER_NT].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);
					rp += d->headers[HEADER_NT].l;
					m = d->headers[HEADER_USN].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);
					rp += d->headers[HEADER_USN].l;
					nrep++;
				}
			}
			d = d->next;
		}
		/* Also look in service list */
		for(serv = servicelisthead.lh_first;
		    serv && (nrep < 255);
		    serv = serv->entries.le_next) {
			/* test if we can put more responses in the buffer */
			if(strlen(serv->location) + strlen(serv->st)
			  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))
			  	break;
			if( (type==1 && 0==strncmp(serv->st, (const char *)p, l))
			  ||(type==2 && 0==strncmp(serv->usn, (const char *)p, l))
			  ||(type==3) ) {
				/* response :
				 * 1 - Location
				 * 2 - NT (device/service type)
				 * 3 - usn */
				m = strlen(serv->location);
				CODELENGTH(m, rp);
				memcpy(rp, serv->location, m);
				rp += m;
				m = strlen(serv->st);
				CODELENGTH(m, rp);
				memcpy(rp, serv->st, m);
				rp += m;
				m = strlen(serv->usn);
				CODELENGTH(m, rp);
				memcpy(rp, serv->usn, m);
				rp += m;
				nrep++;
			}
		}
		rbuf[0] = nrep;
		syslog(LOG_DEBUG, ""(s=%d) response : %d device%s"",
		       req->socket, nrep, (nrep > 1) ? ""s"" : """");
		if(write(req->socket, rbuf, rp - rbuf) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
		break;
	case 4:	/* submit service */
		newserv = malloc(sizeof(struct service));
		if(!newserv) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memset(newserv, 0, sizeof(struct service));	/* set pointers to NULL */
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
			goto error;
		}
		newserv->st = malloc(l + 1);
		if(!newserv->st) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->st, p, l);
		newserv->st[l] = '\0';
		p += l;
		if(p >= buf + n) {
			syslog(LOG_WARNING, ""bad request (missing usn)"");
			goto error;
		}
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(p+l > buf+n) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (usn contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""usn='%.*s'"", l, p);
		newserv->usn = malloc(l + 1);
		if(!newserv->usn) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->usn, p, l);
		newserv->usn[l] = '\0';
		p += l;
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(p+l > buf+n) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (server contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""server='%.*s'"", l, p);
		newserv->server = malloc(l + 1);
		if(!newserv->server) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->server, p, l);
		newserv->server[l] = '\0';
		p += l;
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(p+l > buf+n) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (location contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""location='%.*s'"", l, p);
		newserv->location = malloc(l + 1);
		if(!newserv->location) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->location, p, l);
		newserv->location[l] = '\0';
		/* look in service list for duplicate */
		for(serv = servicelisthead.lh_first;
		    serv;
		    serv = serv->entries.le_next) {
			if(0 == strcmp(newserv->usn, serv->usn)
			  && 0 == strcmp(newserv->st, serv->st)) {
				syslog(LOG_INFO, ""Service allready in the list. Updating..."");
				free(newserv->st);
				free(newserv->usn);
				free(serv->server);
				serv->server = newserv->server;
				free(serv->location);
				serv->location = newserv->location;
				free(newserv);
				newserv = NULL;
				return;
			}
		}
		/* Inserting new service */
		LIST_INSERT_HEAD(&servicelisthead, newserv, entries);
		newserv = NULL;
		/*rbuf[0] = '\0';
		if(write(req->socket, rbuf, 1) < 0)
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
		*/
		break;
	default:
		syslog(LOG_WARNING, ""Unknown request type %d"", type);
		rbuf[0] = '\0';
		if(write(req->socket, rbuf, 1) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
	}
	return;
error:
	if(newserv) {
		free(newserv->st);
		free(newserv->usn);
		free(newserv->server);
		free(newserv->location);
		free(newserv);
		newserv = NULL;
	}
	close(req->socket);
	req->socket = -1;
	return;
}","void processRequest(struct reqelem * VAR_0)
{
	ssize_t VAR_1;
	unsigned int VAR_2, VAR_3;
	unsigned char VAR_4[2048];
	const unsigned char * VAR_5;
	int VAR_6;
	struct device * VAR_7 = VAR_8;
	unsigned char VAR_9[4096];
	unsigned char * VAR_10 = VAR_9+1;
	unsigned char VAR_11 = 0;
	time_t VAR_12;
	struct service * VAR_13 = NULL;
	struct service * VAR_14;

	VAR_1 = read(VAR_0->socket, VAR_4, sizeof(VAR_4));
	if(VAR_1<0) {
		if(VAR_15 == VAR_16 || VAR_15 == VAR_17 || VAR_15 == VAR_18)
			return;	/* COMMENT_0 */
		syslog(VAR_19, ""(s=%d) processRequest(): read(): %m"", VAR_0->socket);
		goto error;
	}
	if(VAR_1==0) {
		syslog(VAR_20, ""(s=%d) request connection closed"", VAR_0->socket);
		goto error;
	}
	VAR_12 = time(NULL);
	VAR_6 = VAR_4[0];
	VAR_5 = VAR_4 + 1;
	DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
	if(VAR_5+VAR_2 > VAR_4+VAR_1) {
		syslog(VAR_21, ""bad request (length encoding)"");
		goto error;
	}
	if(VAR_2 == 0 && VAR_6 != 3) {
		syslog(VAR_21, ""bad request (length=0)"");
		goto error;
	}
	syslog(VAR_20, ""(s=%d) request type=%d str='%.*s'"",
	       VAR_0->socket, VAR_6, VAR_2, VAR_5);
	switch(VAR_6) {
	case 1:	/* COMMENT_1 */
	case 2:	/* COMMENT_2 */
	case 3:	/* COMMENT_3 */
		while(VAR_7 && (VAR_11 < 255)) {
			if(VAR_7->t < VAR_12) {
				syslog(VAR_20, ""outdated device"");
			} else {
				/* COMMENT_4 */
				if(VAR_7->headers[VAR_22].l + VAR_7->headers[VAR_23].l
				  + VAR_7->headers[VAR_24].l + 6
				  + (VAR_10 - VAR_9) >= (int)sizeof(VAR_9))
					break;
				if( (VAR_6==1 && 0==memcmp(VAR_7->headers[VAR_23].p, VAR_5, VAR_2))
				  ||(VAR_6==2 && 0==memcmp(VAR_7->headers[VAR_24].p, VAR_5, VAR_2))
				  ||(VAR_6==3) ) {
					/* COMMENT_5 */
                    
                                    
                  
					VAR_3 = VAR_7->headers[VAR_22].l;
					CODELENGTH(VAR_3, VAR_10);
					memcpy(VAR_10, VAR_7->headers[VAR_22].p, VAR_7->headers[VAR_22].l);
					VAR_10 += VAR_7->headers[VAR_22].l;
					VAR_3 = VAR_7->headers[VAR_23].l;
					CODELENGTH(VAR_3, VAR_10);
					memcpy(VAR_10, VAR_7->headers[VAR_23].p, VAR_7->headers[VAR_23].l);
					VAR_10 += VAR_7->headers[VAR_23].l;
					VAR_3 = VAR_7->headers[VAR_24].l;
					CODELENGTH(VAR_3, VAR_10);
					memcpy(VAR_10, VAR_7->headers[VAR_24].p, VAR_7->headers[VAR_24].l);
					VAR_10 += VAR_7->headers[VAR_24].l;
					VAR_11++;
				}
			}
			VAR_7 = VAR_7->next;
		}
		/* COMMENT_9 */
		for(VAR_14 = VAR_25.lh_first;
		    VAR_14 && (VAR_11 < 255);
		    VAR_14 = VAR_14->entries.le_next) {
			/* COMMENT_4 */
			if(strlen(VAR_14->location) + strlen(VAR_14->st)
			  + strlen(VAR_14->usn) + 6 + (VAR_10 - VAR_9) >= sizeof(VAR_9))
			  	break;
			if( (VAR_6==1 && 0==strncmp(VAR_14->st, (const char *)VAR_5, VAR_2))
			  ||(VAR_6==2 && 0==strncmp(VAR_14->usn, (const char *)VAR_5, VAR_2))
			  ||(VAR_6==3) ) {
				/* COMMENT_10 */
                   
                                   
                 
				VAR_3 = strlen(VAR_14->location);
				CODELENGTH(VAR_3, VAR_10);
				memcpy(VAR_10, VAR_14->location, VAR_3);
				VAR_10 += VAR_3;
				VAR_3 = strlen(VAR_14->st);
				CODELENGTH(VAR_3, VAR_10);
				memcpy(VAR_10, VAR_14->st, VAR_3);
				VAR_10 += VAR_3;
				VAR_3 = strlen(VAR_14->usn);
				CODELENGTH(VAR_3, VAR_10);
				memcpy(VAR_10, VAR_14->usn, VAR_3);
				VAR_10 += VAR_3;
				VAR_11++;
			}
		}
		VAR_9[0] = VAR_11;
		syslog(VAR_26, ""(s=%d) response : %d device%s"",
		       VAR_0->socket, VAR_11, (VAR_11 > 1) ? ""s"" : """");
		if(write(VAR_0->socket, VAR_9, VAR_10 - VAR_9) < 0) {
			syslog(VAR_19, ""(s=%d) write: %m"", VAR_0->socket);
			goto error;
		}
		break;
	case 4:	/* COMMENT_14 */
		VAR_13 = malloc(sizeof(struct service));
		if(!VAR_13) {
			syslog(VAR_19, ""cannot allocate memory"");
			goto error;
		}
		memset(VAR_13, 0, sizeof(struct service));	/* COMMENT_15 */
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_19, ""bad request (st contains forbidden chars)"");
			goto error;
		}
		VAR_13->st = malloc(VAR_2 + 1);
		if(!VAR_13->st) {
			syslog(VAR_19, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_13->st, VAR_5, VAR_2);
		VAR_13->st[VAR_2] = '\0';
		VAR_5 += VAR_2;
		if(VAR_5 >= VAR_4 + VAR_1) {
			syslog(VAR_21, ""bad request (missing usn)"");
			goto error;
		}
		DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
		if(VAR_5+VAR_2 > VAR_4+VAR_1) {
			syslog(VAR_21, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_19, ""bad request (usn contains forbidden chars)"");
			goto error;
		}
		syslog(VAR_20, ""usn='%.*s'"", VAR_2, VAR_5);
		VAR_13->usn = malloc(VAR_2 + 1);
		if(!VAR_13->usn) {
			syslog(VAR_19, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_13->usn, VAR_5, VAR_2);
		VAR_13->usn[VAR_2] = '\0';
		VAR_5 += VAR_2;
		DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
		if(VAR_5+VAR_2 > VAR_4+VAR_1) {
			syslog(VAR_21, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_19, ""bad request (server contains forbidden chars)"");
			goto error;
		}
		syslog(VAR_20, ""server='%.*s'"", VAR_2, VAR_5);
		VAR_13->server = malloc(VAR_2 + 1);
		if(!VAR_13->server) {
			syslog(VAR_19, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_13->server, VAR_5, VAR_2);
		VAR_13->server[VAR_2] = '\0';
		VAR_5 += VAR_2;
		DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
		if(VAR_5+VAR_2 > VAR_4+VAR_1) {
			syslog(VAR_21, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_19, ""bad request (location contains forbidden chars)"");
			goto error;
		}
		syslog(VAR_20, ""location='%.*s'"", VAR_2, VAR_5);
		VAR_13->location = malloc(VAR_2 + 1);
		if(!VAR_13->location) {
			syslog(VAR_19, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_13->location, VAR_5, VAR_2);
		VAR_13->location[VAR_2] = '\0';
		/* COMMENT_16 */
		for(VAR_14 = VAR_25.lh_first;
		    VAR_14;
		    VAR_14 = VAR_14->entries.le_next) {
			if(0 == strcmp(VAR_13->usn, VAR_14->usn)
			  && 0 == strcmp(VAR_13->st, VAR_14->st)) {
				syslog(VAR_20, ""Service allready in the list. Updating..."");
				free(VAR_13->st);
				free(VAR_13->usn);
				free(VAR_14->server);
				VAR_14->server = VAR_13->server;
				free(VAR_14->location);
				VAR_14->location = VAR_13->location;
				free(VAR_13);
				VAR_13 = NULL;
				return;
			}
		}
		/* COMMENT_17 */
		LIST_INSERT_HEAD(&VAR_25, VAR_13, VAR_27);
		VAR_13 = NULL;
		/* COMMENT_18 */
                                     
                                                    
    
		break;
	default:
		syslog(VAR_21, ""Unknown request type %d"", VAR_6);
		VAR_9[0] = '\0';
		if(write(VAR_0->socket, VAR_9, 1) < 0) {
			syslog(VAR_19, ""(s=%d) write: %m"", VAR_0->socket);
			goto error;
		}
	}
	return;
error:
	if(VAR_13) {
		free(VAR_13->st);
		free(VAR_13->usn);
		free(VAR_13->server);
		free(VAR_13->location);
		free(VAR_13);
		VAR_13 = NULL;
	}
	close(VAR_0->socket);
	VAR_0->socket = -1;
	return;
}",miniupnp/140ee8d2204b383279f854802b27bdb41c1d5d1a/minissdpd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -119,6 +119,7 @@
 			syslog(LOG_ERR, ""cannot allocate memory"");
 			goto error;
 		}
+		memset(newserv, 0, sizeof(struct service));	/* set pointers to NULL */
 		if(containsForbiddenChars(p, l)) {
 			syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
 			goto error;","{'deleted_lines': [], 'added_lines': ['\t\tmemset(newserv, 0, sizeof(struct service));\t/* set pointers to NULL */']}",True,The processRequest function in minissdpd.c in MiniSSDPd 1.2.20130907-3 allows local users to cause a denial of service (invalid free and daemon crash) via vectors related to error handling.,5.5,MEDIUM,1,valid,2014-04-12T08:05:42Z,1
CVE-2014-8321,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,aircrack-ng,"Airodump-ng: Fixed GPS stack overflow (Closes #13 on GitHub).

git-svn-id: http://svn.aircrack-ng.org/trunk@2416 28c6078b-6c39-48e3-add9-af49d547ecab",ff70494dd389ba570dbdbf36f217c28d4381c6b5,https://github.com/aircrack-ng/aircrack-ng/commit/ff70494dd389ba570dbdbf36f217c28d4381c6b5,src/airodump-ng.c,gps_tracker,"void gps_tracker( void )
{
ssize_t unused;
int gpsd_sock;
char line[256], *temp;
struct sockaddr_in gpsd_addr;
int ret, is_json, pos;
fd_set read_fd;
struct timeval timeout;
pos = 0;
gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );
if( gpsd_sock < 0 ) {
return;
}
gpsd_addr.sin_family      = AF_INET;
gpsd_addr.sin_port        = htons( 2947 );
gpsd_addr.sin_addr.s_addr = inet_addr( ""127.0.0.1"" );
if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,
sizeof( gpsd_addr ) ) < 0 ) {
return;
}
FD_ZERO(&read_fd);
FD_SET(gpsd_sock, &read_fd);
timeout.tv_sec = 1;
timeout.tv_usec = 0;
is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);
if (is_json) {
if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )
return;
is_json = (line[0] == '{');
if (is_json) {
memset( line, 0, sizeof( line ) );
strcpy(line, ""?WATCH={\""json\"":true};\n"");
if( send( gpsd_sock, line, 22, 0 ) != 22 )
return;
memset(line, 0, sizeof(line));
if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )
return;
if (strncmp(line, ""{\""class\"":\""DEVICES\"",\""devices\"":[]}"", 32) == 0) {
close(gpsd_sock);
return;
} else {
pos = strlen(line);
}
}
}
while( G.do_exit == 0 )
{
usleep( 500000 );
memset( G.gps_loc, 0, sizeof( float ) * 5 );
if (is_json) {
if (pos == sizeof( line )) {
memset(line, 0, sizeof(line));
pos = 0;
}
if( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 )
return;
temp = strstr(line, ""{\""class\"":\""TPV\"""");
if (temp == NULL) {
continue;
}
if (strchr(temp, '}') == NULL) {
pos = strlen(temp);
if (temp != line) {
memmove(line, temp, pos);
memset(line + pos, 0, sizeof(line) - pos);
}
}
temp = strstr(temp, ""\""lat\"":"");
if (temp == NULL) {
continue;
}
ret = sscanf(temp + 6, ""%f"", &G.gps_loc[0]);
temp = strstr(temp, ""\""lon\"":"");
if (temp == NULL) {
continue;
}
ret = sscanf(temp + 6, ""%f"", &G.gps_loc[1]);
temp = strstr(temp, ""\""alt\"":"");
if (temp == NULL) {
continue;
}
ret = sscanf(temp + 6, ""%f"", &G.gps_loc[4]);
temp = strstr(temp, ""\""speed\"":"");
if (temp == NULL) {
continue;
}
ret = sscanf(temp + 6, ""%f"", &G.gps_loc[2]);
temp = strstr(temp, ""{\""class\"":\""TPV\"""");
if (temp == NULL) {
memset( line, 0, sizeof( line ) );
pos = 0;
} else {
pos = strlen(temp);
memmove(line, temp, pos);
memset(line + pos, 0, sizeof(line) - pos);
}
} else {
memset( line, 0, sizeof( line ) );
snprintf( line,  sizeof( line ) - 1, ""PVTAD\r\n"" );
if( send( gpsd_sock, line, 7, 0 ) != 7 )
return;
memset( line, 0, sizeof( line ) );
if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )
return;
if( memcmp( line, ""GPSD,P="", 7 ) != 0 )
continue;
if( line[7] == '?' )
continue;
ret = sscanf( line + 7, ""%f %f"", &G.gps_loc[0], &G.gps_loc[1] );
if( ( temp = strstr( line, ""V="" ) ) == NULL ) continue;
ret = sscanf( temp + 2, ""%f"", &G.gps_loc[2] ); 
if( ( temp = strstr( line, ""T="" ) ) == NULL ) continue;
ret = sscanf( temp + 2, ""%f"", &G.gps_loc[3] ); 
if( ( temp = strstr( line, ""A="" ) ) == NULL ) continue;
ret = sscanf( temp + 2, ""%f"", &G.gps_loc[4] ); 
}
if (G.record_data)
fputs( line, G.f_gps );
G.save_gps = 1;
if (G.do_exit == 0)
{
unused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );
kill( getppid(), SIGUSR2 );
}
}
}","void gps_tracker( void )
{
ssize_t VAR_0;
int VAR_1;
char VAR_2[256], *VAR_3;
struct sockaddr_in VAR_4;
int VAR_5, VAR_6, VAR_7;
fd_set VAR_8;
struct timeval VAR_9;
VAR_7 = 0;
VAR_1 = socket( VAR_10, VAR_11, 0 );
if( VAR_1 < 0 ) {
return;
}
VAR_4.sin_family      = VAR_10;
VAR_4.sin_port        = htons( 2947 );
VAR_4.sin_addr.s_addr = inet_addr( ""127.0.0.1"" );
if( connect( VAR_1, (struct sockaddr *) &VAR_4,
sizeof( VAR_4 ) ) < 0 ) {
return;
}
FD_ZERO(&VAR_8);
FD_SET(VAR_1, &VAR_8);
VAR_9.tv_sec = 1;
VAR_9.tv_usec = 0;
VAR_6 = select(VAR_1 + 1, &VAR_8, NULL, NULL, &VAR_9);
if (VAR_6) {
if( recv( VAR_1, VAR_2, sizeof( VAR_2 ) - 1, 0 ) <= 0 )
return;
VAR_6 = (VAR_2[0] == '{');
if (VAR_6) {
memset( VAR_2, 0, sizeof( VAR_2 ) );
strcpy(VAR_2, ""?WATCH={\""json\"":true};\n"");
if( send( VAR_1, VAR_2, 22, 0 ) != 22 )
return;
memset(VAR_2, 0, sizeof(VAR_2));
if( recv( VAR_1, VAR_2, sizeof( VAR_2 ) - 1, 0 ) <= 0 )
return;
if (strncmp(VAR_2, ""{\""class\"":\""DEVICES\"",\""devices\"":[]}"", 32) == 0) {
close(VAR_1);
return;
} else {
VAR_7 = strlen(VAR_2);
}
}
}
while( VAR_12.do_exit == 0 )
{
usleep( 500000 );
memset( VAR_12.gps_loc, 0, sizeof( float ) * 5 );
if (VAR_6) {
if (VAR_7 == sizeof( VAR_2 )) {
memset(VAR_2, 0, sizeof(VAR_2));
VAR_7 = 0;
}
if( recv( VAR_1, VAR_2 + VAR_7, sizeof( VAR_2 ) - 1, 0 ) <= 0 )
return;
VAR_3 = strstr(VAR_2, ""{\""class\"":\""TPV\"""");
if (VAR_3 == NULL) {
continue;
}
if (strchr(VAR_3, '}') == NULL) {
VAR_7 = strlen(VAR_3);
if (VAR_3 != VAR_2) {
memmove(VAR_2, VAR_3, VAR_7);
memset(VAR_2 + VAR_7, 0, sizeof(VAR_2) - VAR_7);
}
}
VAR_3 = strstr(VAR_3, ""\""lat\"":"");
if (VAR_3 == NULL) {
continue;
}
VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[0]);
VAR_3 = strstr(VAR_3, ""\""lon\"":"");
if (VAR_3 == NULL) {
continue;
}
VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[1]);
VAR_3 = strstr(VAR_3, ""\""alt\"":"");
if (VAR_3 == NULL) {
continue;
}
VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[4]);
VAR_3 = strstr(VAR_3, ""\""speed\"":"");
if (VAR_3 == NULL) {
continue;
}
VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[2]);
VAR_3 = strstr(VAR_3, ""{\""class\"":\""TPV\"""");
if (VAR_3 == NULL) {
memset( VAR_2, 0, sizeof( VAR_2 ) );
VAR_7 = 0;
} else {
VAR_7 = strlen(VAR_3);
memmove(VAR_2, VAR_3, VAR_7);
memset(VAR_2 + VAR_7, 0, sizeof(VAR_2) - VAR_7);
}
} else {
memset( VAR_2, 0, sizeof( VAR_2 ) );
snprintf( VAR_2,  sizeof( VAR_2 ) - 1, ""PVTAD\r\n"" );
if( send( VAR_1, VAR_2, 7, 0 ) != 7 )
return;
memset( VAR_2, 0, sizeof( VAR_2 ) );
if( recv( VAR_1, VAR_2, sizeof( VAR_2 ) - 1, 0 ) <= 0 )
return;
if( memcmp( VAR_2, ""GPSD,P="", 7 ) != 0 )
continue;
if( VAR_2[7] == '?' )
continue;
VAR_5 = sscanf( VAR_2 + 7, ""%f %f"", &VAR_12.gps_loc[0], &VAR_12.gps_loc[1] );
if( ( VAR_3 = strstr( VAR_2, ""V="" ) ) == NULL ) continue;
VAR_5 = sscanf( VAR_3 + 2, ""%f"", &VAR_12.gps_loc[2] ); 
if( ( VAR_3 = strstr( VAR_2, ""T="" ) ) == NULL ) continue;
VAR_5 = sscanf( VAR_3 + 2, ""%f"", &VAR_12.gps_loc[3] ); 
if( ( VAR_3 = strstr( VAR_2, ""A="" ) ) == NULL ) continue;
VAR_5 = sscanf( VAR_3 + 2, ""%f"", &VAR_12.gps_loc[4] ); 
}
if (VAR_12.record_data)
fputs( VAR_2, VAR_12.f_gps );
VAR_12.save_gps = 1;
if (VAR_12.do_exit == 0)
{
VAR_0 = write( VAR_12.gc_pipe[1], VAR_12.gps_loc, sizeof( float ) * 5 );
kill( getppid(), VAR_13 );
}
}
}",aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5/airodump-ng.c/vul/before/0.json,"void gps_tracker( void )
{
	ssize_t unused;
    int gpsd_sock;
    char line[256], *temp;
    struct sockaddr_in gpsd_addr;
    int ret, is_json, pos;
    fd_set read_fd;
    struct timeval timeout;

    /* attempt to connect to localhost, port 2947 */

    pos = 0;
    gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 );

    if( gpsd_sock < 0 ) {
        return;
    }

    gpsd_addr.sin_family      = AF_INET;
    gpsd_addr.sin_port        = htons( 2947 );
    gpsd_addr.sin_addr.s_addr = inet_addr( ""127.0.0.1"" );

    if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr,
                 sizeof( gpsd_addr ) ) < 0 ) {
        return;
    }

    // Check if it's GPSd < 2.92 or the new one
    // 2.92+ immediately send stuff
    // < 2.92 requires to send PVTAD command
    FD_ZERO(&read_fd);
    FD_SET(gpsd_sock, &read_fd);
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout);
    if (is_json) {
    	/*
			{""class"":""VERSION"",""release"":""2.95"",""rev"":""2010-11-16T21:12:35"",""proto_major"":3,""proto_minor"":3}
			?WATCH={""json"":true};
			{""class"":""DEVICES"",""devices"":[]}
    	 */


    	// Get the crap and ignore it: {""class"":""VERSION"",""release"":""2.95"",""rev"":""2010-11-16T21:12:35"",""proto_major"":3,""proto_minor"":3}
    	if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )
    		return;

    	is_json = (line[0] == '{');
    	if (is_json) {
			// Send ?WATCH={""json"":true};
			memset( line, 0, sizeof( line ) );
			strcpy(line, ""?WATCH={\""json\"":true};\n"");
			if( send( gpsd_sock, line, 22, 0 ) != 22 )
				return;

			// Check that we have devices
			memset(line, 0, sizeof(line));
			if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )
				return;

			// Stop processing if there is no device
			if (strncmp(line, ""{\""class\"":\""DEVICES\"",\""devices\"":[]}"", 32) == 0) {
				close(gpsd_sock);
				return;
			} else {
				pos = strlen(line);
			}
    	}
    }

    /* loop reading the GPS coordinates */

    while( G.do_exit == 0 )
    {
        usleep( 500000 );
        memset( G.gps_loc, 0, sizeof( float ) * 5 );

        /* read position, speed, heading, altitude */
        if (is_json) {
        	// Format definition: http://catb.org/gpsd/gpsd_json.html

        	if (pos == sizeof( line )) {
        		memset(line, 0, sizeof(line));
        		pos = 0;
        	}

        	// New version, JSON
        	if( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )
        		return;

        	// search for TPV class: {""class"":""TPV""
        	temp = strstr(line, ""{\""class\"":\""TPV\"""");
        	if (temp == NULL) {
        		continue;
        	}

        	// Make sure the data we have is complete
        	if (strchr(temp, '}') == NULL) {
        		// Move the data at the beginning of the buffer;
        		pos = strlen(temp);
        		if (temp != line) {
        			memmove(line, temp, pos);
        			memset(line + pos, 0, sizeof(line) - pos);
        		}
        	}

			// Example line: {""class"":""TPV"",""tag"":""MID2"",""device"":""/dev/ttyUSB0"",""time"":1350957517.000,""ept"":0.005,""lat"":46.878936576,""lon"":-115.832602964,""alt"":1968.382,""track"":0.0000,""speed"":0.000,""climb"":0.000,""mode"":3}

        	// Latitude
        	temp = strstr(temp, ""\""lat\"":"");
			if (temp == NULL) {
				continue;
			}

			ret = sscanf(temp + 6, ""%f"", &G.gps_loc[0]);

			// Longitude
			temp = strstr(temp, ""\""lon\"":"");
			if (temp == NULL) {
				continue;
			}

			ret = sscanf(temp + 6, ""%f"", &G.gps_loc[1]);

			// Altitude
			temp = strstr(temp, ""\""alt\"":"");
			if (temp == NULL) {
				continue;
			}

			ret = sscanf(temp + 6, ""%f"", &G.gps_loc[4]);

			// Speed
			temp = strstr(temp, ""\""speed\"":"");
			if (temp == NULL) {
				continue;
			}

			ret = sscanf(temp + 6, ""%f"", &G.gps_loc[2]);

			// No more heading

			// Get the next TPV class
			temp = strstr(temp, ""{\""class\"":\""TPV\"""");
			if (temp == NULL) {
				memset( line, 0, sizeof( line ) );
				pos = 0;
			} else {
				pos = strlen(temp);
				memmove(line, temp, pos);
				memset(line + pos, 0, sizeof(line) - pos);
			}

        } else {
        	memset( line, 0, sizeof( line ) );

			snprintf( line,  sizeof( line ) - 1, ""PVTAD\r\n"" );
			if( send( gpsd_sock, line, 7, 0 ) != 7 )
				return;

			memset( line, 0, sizeof( line ) );
			if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 )
				return;

			if( memcmp( line, ""GPSD,P="", 7 ) != 0 )
				continue;

			/* make sure the coordinates are present */

			if( line[7] == '?' )
				continue;

			ret = sscanf( line + 7, ""%f %f"", &G.gps_loc[0], &G.gps_loc[1] );

			if( ( temp = strstr( line, ""V="" ) ) == NULL ) continue;
			ret = sscanf( temp + 2, ""%f"", &G.gps_loc[2] ); /* speed */

			if( ( temp = strstr( line, ""T="" ) ) == NULL ) continue;
			ret = sscanf( temp + 2, ""%f"", &G.gps_loc[3] ); /* heading */

			if( ( temp = strstr( line, ""A="" ) ) == NULL ) continue;
			ret = sscanf( temp + 2, ""%f"", &G.gps_loc[4] ); /* altitude */
        }

        if (G.record_data)
			fputs( line, G.f_gps );

		G.save_gps = 1;

        if (G.do_exit == 0)
		{
			unused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 );
			kill( getppid(), SIGUSR2 );
		}
    }
}","void gps_tracker( void )
{
	ssize_t VAR_0;
    int VAR_1;
    char VAR_2[256], *VAR_3;
    struct sockaddr_in VAR_4;
    int VAR_5, VAR_6, VAR_7;
    fd_set VAR_8;
    struct timeval VAR_9;

    /* COMMENT_0 */

    VAR_7 = 0;
    VAR_1 = socket( VAR_10, VAR_11, 0 );

    if( VAR_1 < 0 ) {
        return;
    }

    VAR_4.sin_family      = VAR_10;
    VAR_4.sin_port        = htons( 2947 );
    VAR_4.sin_addr.s_addr = inet_addr( ""127.0.0.1"" );

    if( connect( VAR_1, (struct sockaddr *) &VAR_4,
                 sizeof( VAR_4 ) ) < 0 ) {
        return;
    }

    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    FD_ZERO(&VAR_8);
    FD_SET(VAR_1, &VAR_8);
    VAR_9.tv_sec = 1;
    VAR_9.tv_usec = 0;
    VAR_6 = select(VAR_1 + 1, &VAR_8, NULL, NULL, &VAR_9);
    if (VAR_6) {
    	/* COMMENT_4 */
                                                                                                   
                        
                                   
        


    	/* COMMENT_9 */
    	if( recv( VAR_1, VAR_2, sizeof( VAR_2 ) - 1, 0 ) <= 0 )
    		return;

    	VAR_6 = (VAR_2[0] == '{');
    	if (VAR_6) {
			/* COMMENT_10 */
			memset( VAR_2, 0, sizeof( VAR_2 ) );
			strcpy(VAR_2, ""?WATCH={\""json\"":true};\n"");
			if( send( VAR_1, VAR_2, 22, 0 ) != 22 )
				return;

			/* COMMENT_11 */
			memset(VAR_2, 0, sizeof(VAR_2));
			if( recv( VAR_1, VAR_2, sizeof( VAR_2 ) - 1, 0 ) <= 0 )
				return;

			/* COMMENT_12 */
			if (strncmp(VAR_2, ""{\""class\"":\""DEVICES\"",\""devices\"":[]}"", 32) == 0) {
				close(VAR_1);
				return;
			} else {
				VAR_7 = strlen(VAR_2);
			}
    	}
    }

    /* COMMENT_13 */

    while( VAR_12.do_exit == 0 )
    {
        usleep( 500000 );
        memset( VAR_12.gps_loc, 0, sizeof( float ) * 5 );

        /* COMMENT_14 */
        if (VAR_6) {
        	/* COMMENT_15 */

        	if (VAR_7 == sizeof( VAR_2 )) {
        		memset(VAR_2, 0, sizeof(VAR_2));
        		VAR_7 = 0;
        	}

        	/* COMMENT_16 */
        	if( recv( VAR_1, VAR_2 + VAR_7, sizeof( VAR_2 ) - VAR_7 - 1, 0 ) <= 0 )
        		return;

        	/* COMMENT_17 */
        	VAR_3 = strstr(VAR_2, ""{\""class\"":\""TPV\"""");
        	if (VAR_3 == NULL) {
        		continue;
        	}

        	/* COMMENT_18 */
        	if (strchr(VAR_3, '}') == NULL) {
        		/* COMMENT_19 */
        		VAR_7 = strlen(VAR_3);
        		if (VAR_3 != VAR_2) {
        			memmove(VAR_2, VAR_3, VAR_7);
        			memset(VAR_2 + VAR_7, 0, sizeof(VAR_2) - VAR_7);
        		}
        	}

			/* COMMENT_20 */

        	/* COMMENT_21 */
        	VAR_3 = strstr(VAR_3, ""\""lat\"":"");
			if (VAR_3 == NULL) {
				continue;
			}

			VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[0]);

			/* COMMENT_22 */
			VAR_3 = strstr(VAR_3, ""\""lon\"":"");
			if (VAR_3 == NULL) {
				continue;
			}

			VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[1]);

			/* COMMENT_23 */
			VAR_3 = strstr(VAR_3, ""\""alt\"":"");
			if (VAR_3 == NULL) {
				continue;
			}

			VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[4]);

			/* COMMENT_24 */
			VAR_3 = strstr(VAR_3, ""\""speed\"":"");
			if (VAR_3 == NULL) {
				continue;
			}

			VAR_5 = sscanf(VAR_3 + 6, ""%f"", &VAR_12.gps_loc[2]);

			/* COMMENT_25 */

			/* COMMENT_26 */
			VAR_3 = strstr(VAR_3, ""{\""class\"":\""TPV\"""");
			if (VAR_3 == NULL) {
				memset( VAR_2, 0, sizeof( VAR_2 ) );
				VAR_7 = 0;
			} else {
				VAR_7 = strlen(VAR_3);
				memmove(VAR_2, VAR_3, VAR_7);
				memset(VAR_2 + VAR_7, 0, sizeof(VAR_2) - VAR_7);
			}

        } else {
        	memset( VAR_2, 0, sizeof( VAR_2 ) );

			snprintf( VAR_2,  sizeof( VAR_2 ) - 1, ""PVTAD\r\n"" );
			if( send( VAR_1, VAR_2, 7, 0 ) != 7 )
				return;

			memset( VAR_2, 0, sizeof( VAR_2 ) );
			if( recv( VAR_1, VAR_2, sizeof( VAR_2 ) - 1, 0 ) <= 0 )
				return;

			if( memcmp( VAR_2, ""GPSD,P="", 7 ) != 0 )
				continue;

			/* COMMENT_27 */

			if( VAR_2[7] == '?' )
				continue;

			VAR_5 = sscanf( VAR_2 + 7, ""%f %f"", &VAR_12.gps_loc[0], &VAR_12.gps_loc[1] );

			if( ( VAR_3 = strstr( VAR_2, ""V="" ) ) == NULL ) continue;
			VAR_5 = sscanf( VAR_3 + 2, ""%f"", &VAR_12.gps_loc[2] ); /* COMMENT_28 */

			if( ( VAR_3 = strstr( VAR_2, ""T="" ) ) == NULL ) continue;
			VAR_5 = sscanf( VAR_3 + 2, ""%f"", &VAR_12.gps_loc[3] ); /* COMMENT_29 */

			if( ( VAR_3 = strstr( VAR_2, ""A="" ) ) == NULL ) continue;
			VAR_5 = sscanf( VAR_3 + 2, ""%f"", &VAR_12.gps_loc[4] ); /* COMMENT_30 */
        }

        if (VAR_12.record_data)
			fputs( VAR_2, VAR_12.f_gps );

		VAR_12.save_gps = 1;

        if (VAR_12.do_exit == 0)
		{
			VAR_0 = write( VAR_12.gc_pipe[1], VAR_12.gps_loc, sizeof( float ) * 5 );
			kill( getppid(), VAR_13 );
		}
    }
}",aircrack-ng/ff70494dd389ba570dbdbf36f217c28d4381c6b5/airodump-ng.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -86,7 +86,7 @@
         	}
 
         	// New version, JSON
-        	if( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 )
+        	if( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )
         		return;
 
         	// search for TPV class: {""class"":""TPV""","{'deleted_lines': ['        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 )'], 'added_lines': ['        \tif( recv( gpsd_sock, line + pos, sizeof( line ) - pos - 1, 0 ) <= 0 )']}",True,Stack-based buffer overflow in the gps_tracker function in airodump-ng.c in Aircrack-ng before 1.2 RC 1 allows local users to execute arbitrary code or gain privileges via unspecified vectors.,7.8,HIGH,2,valid,2014-10-03T01:51:21Z,1
CVE-2014-3687,['CWE-400'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"net: sctp: fix panic on duplicate ASCONF chunks

When receiving a e.g. semi-good formed connection scan in the
form of ...

  -------------- INIT[ASCONF; ASCONF_ACK] ------------->
  <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------
  -------------------- COOKIE-ECHO -------------------->
  <-------------------- COOKIE-ACK ---------------------
  ---------------- ASCONF_a; ASCONF_b ----------------->

... where ASCONF_a equals ASCONF_b chunk (at least both serials
need to be equal), we panic an SCTP server!

The problem is that good-formed ASCONF chunks that we reply with
ASCONF_ACK chunks are cached per serial. Thus, when we receive a
same ASCONF chunk twice (e.g. through a lost ASCONF_ACK), we do
not need to process them again on the server side (that was the
idea, also proposed in the RFC). Instead, we know it was cached
and we just resend the cached chunk instead. So far, so good.

Where things get nasty is in SCTP's side effect interpreter, that
is, sctp_cmd_interpreter():

While incoming ASCONF_a (chunk = event_arg) is being marked
!end_of_packet and !singleton, and we have an association context,
we do not flush the outqueue the first time after processing the
ASCONF_ACK singleton chunk via SCTP_CMD_REPLY. Instead, we keep it
queued up, although we set local_cork to 1. Commit 2e3216cd54b1
changed the precedence, so that as long as we get bundled, incoming
chunks we try possible bundling on outgoing queue as well. Before
this commit, we would just flush the output queue.

Now, while ASCONF_a's ASCONF_ACK sits in the corked outq, we
continue to process the same ASCONF_b chunk from the packet. As
we have cached the previous ASCONF_ACK, we find it, grab it and
do another SCTP_CMD_REPLY command on it. So, effectively, we rip
the chunk->list pointers and requeue the same ASCONF_ACK chunk
another time. Since we process ASCONF_b, it's correctly marked
with end_of_packet and we enforce an uncork, and thus flush, thus
crashing the kernel.

Fix it by testing if the ASCONF_ACK is currently pending and if
that is the case, do not requeue it. When flushing the output
queue we may relink the chunk for preparing an outgoing packet,
but eventually unlink it when it's copied into the skb right
before transmission.

Joint work with Vlad Yasevich.

Fixes: 2e3216cd54b1 (""sctp: Follow security requirement of responding with 1 packet"")
Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",b69040d8e39f20d5215a03502a8e8b4c6ab78395,https://github.com/torvalds/linux/commit/b69040d8e39f20d5215a03502a8e8b4c6ab78395,net/sctp/associola.c,sctp_assoc_lookup_asconf_ack,"struct sctp_chunk *sctp_assoc_lookup_asconf_ack(
const struct sctp_association *asoc,
__be32 serial)
{
struct sctp_chunk *ack;
list_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {
if (ack->subh.addip_hdr->serial == serial) {
sctp_chunk_hold(ack);
return ack;
}
}
return NULL;
}","struct sctp_chunk *sctp_assoc_lookup_asconf_ack(
const struct sctp_association *VAR_0,
__be32 VAR_1)
{
struct sctp_chunk *VAR_2;
list_for_each_entry(VAR_2, &VAR_0->asconf_ack_list, VAR_3) {
if (VAR_2->subh.addip_hdr->serial == VAR_1) {
sctp_chunk_hold(VAR_2);
return VAR_2;
}
}
return NULL;
}",torvalds/linux/b69040d8e39f20d5215a03502a8e8b4c6ab78395/associola.c/vul/before/0.json,"struct sctp_chunk *sctp_assoc_lookup_asconf_ack(
					const struct sctp_association *asoc,
					__be32 serial)
{
	struct sctp_chunk *ack;

	/* Walk through the list of cached ASCONF-ACKs and find the
	 * ack chunk whose serial number matches that of the request.
	 */
	list_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {
		if (sctp_chunk_pending(ack))
			continue;
		if (ack->subh.addip_hdr->serial == serial) {
			sctp_chunk_hold(ack);
			return ack;
		}
	}

	return NULL;
}","struct sctp_chunk *sctp_assoc_lookup_asconf_ack(
					const struct sctp_association *VAR_0,
					__be32 VAR_1)
{
	struct sctp_chunk *VAR_2;

	/* COMMENT_0 */
                                                              
    
	list_for_each_entry(VAR_2, &VAR_0->asconf_ack_list, VAR_3) {
		if (sctp_chunk_pending(VAR_2))
			continue;
		if (VAR_2->subh.addip_hdr->serial == VAR_1) {
			sctp_chunk_hold(VAR_2);
			return VAR_2;
		}
	}

	return NULL;
}",torvalds/linux/b69040d8e39f20d5215a03502a8e8b4c6ab78395/associola.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,8 @@
 	 * ack chunk whose serial number matches that of the request.
 	 */
 	list_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {
+		if (sctp_chunk_pending(ack))
+			continue;
 		if (ack->subh.addip_hdr->serial == serial) {
 			sctp_chunk_hold(ack);
 			return ack;","{'deleted_lines': [], 'added_lines': ['\t\tif (sctp_chunk_pending(ack))', '\t\t\tcontinue;']}",True,The sctp_assoc_lookup_asconf_ack function in net/sctp/associola.c in the SCTP implementation in the Linux kernel through 3.17.2 allows remote attackers to cause a denial of service (panic) via duplicate ASCONF chunks that trigger an incorrect uncork within the side-effect interpreter.,7.5,HIGH,2,valid,2014-10-09T20:55:32Z,1
CVE-2014-9922,['CWE-264'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",69c433ed2ecd2d3264efd7afec4439524b319121,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,fs/overlayfs/super.c,ovl_fill_super,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
struct path lowerpath;
struct path upperpath;
struct path workpath;
struct inode *root_inode;
struct dentry *root_dentry;
struct ovl_entry *oe;
struct ovl_fs *ufs;
struct kstatfs statfs;
int err;
err = -ENOMEM;
ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
if (!ufs)
goto out;
err = ovl_parse_opt((char *) data, &ufs->config);
if (err)
goto out_free_config;
err = -EINVAL;
if (!ufs->config.upperdir || !ufs->config.lowerdir ||
!ufs->config.workdir) {
pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
goto out_free_config;
}
err = -ENOMEM;
oe = ovl_alloc_entry();
if (oe == NULL)
goto out_free_config;
err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
if (err)
goto out_free_oe;
err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
if (err)
goto out_put_upperpath;
err = ovl_mount_dir(ufs->config.workdir, &workpath);
if (err)
goto out_put_lowerpath;
err = -EINVAL;
if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
!S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
!S_ISDIR(workpath.dentry->d_inode->i_mode)) {
pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
goto out_put_workpath;
}
if (upperpath.mnt != workpath.mnt) {
pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
goto out_put_workpath;
}
if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
goto out_put_workpath;
}
if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
goto out_put_workpath;
}
if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
goto out_put_workpath;
}
err = vfs_statfs(&lowerpath, &statfs);
if (err) {
pr_err(""overlayfs: statfs failed on lowerpath\n"");
goto out_put_workpath;
}
ufs->lower_namelen = statfs.f_namelen;
ufs->upper_mnt = clone_private_mount(&upperpath);
err = PTR_ERR(ufs->upper_mnt);
if (IS_ERR(ufs->upper_mnt)) {
pr_err(""overlayfs: failed to clone upperpath\n"");
goto out_put_workpath;
}
ufs->lower_mnt = clone_private_mount(&lowerpath);
err = PTR_ERR(ufs->lower_mnt);
if (IS_ERR(ufs->lower_mnt)) {
pr_err(""overlayfs: failed to clone lowerpath\n"");
goto out_put_upper_mnt;
}
ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
err = PTR_ERR(ufs->workdir);
if (IS_ERR(ufs->workdir)) {
pr_err(""overlayfs: failed to create directory %s/%s\n"",
ufs->config.workdir, OVL_WORKDIR_NAME);
goto out_put_lower_mnt;
}
ufs->lower_mnt->mnt_flags |= MNT_READONLY;
if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
sb->s_flags |= MS_RDONLY;
sb->s_d_op = &ovl_dentry_operations;
err = -ENOMEM;
root_inode = ovl_new_inode(sb, S_IFDIR, oe);
if (!root_inode)
goto out_put_workdir;
root_dentry = d_make_root(root_inode);
if (!root_dentry)
goto out_put_workdir;
mntput(upperpath.mnt);
mntput(lowerpath.mnt);
path_put(&workpath);
oe->__upperdentry = upperpath.dentry;
oe->lowerdentry = lowerpath.dentry;
root_dentry->d_fsdata = oe;
sb->s_magic = OVERLAYFS_SUPER_MAGIC;
sb->s_op = &ovl_super_operations;
sb->s_root = root_dentry;
sb->s_fs_info = ufs;
return 0;
out_put_workdir:
dput(ufs->workdir);
out_put_lower_mnt:
mntput(ufs->lower_mnt);
out_put_upper_mnt:
mntput(ufs->upper_mnt);
out_put_workpath:
path_put(&workpath);
out_put_lowerpath:
path_put(&lowerpath);
out_put_upperpath:
path_put(&upperpath);
out_free_oe:
kfree(oe);
out_free_config:
kfree(ufs->config.lowerdir);
kfree(ufs->config.upperdir);
kfree(ufs->config.workdir);
kfree(ufs);
out:
return err;
}","static int ovl_fill_super(struct super_block *VAR_0, void *VAR_1, int VAR_2)
{
struct path VAR_3;
struct path VAR_4;
struct path VAR_5;
struct inode *VAR_6;
struct dentry *VAR_7;
struct ovl_entry *VAR_8;
struct ovl_fs *VAR_9;
struct kstatfs VAR_10;
int VAR_11;
VAR_11 = -VAR_12;
VAR_9 = kzalloc(sizeof(struct ovl_fs), VAR_13);
if (!VAR_9)
goto out;
VAR_11 = ovl_parse_opt((char *) VAR_1, &VAR_9->config);
if (VAR_11)
goto out_free_config;
VAR_11 = -VAR_14;
if (!VAR_9->config.upperdir || !VAR_9->config.lowerdir ||
!VAR_9->config.workdir) {
pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
goto out_free_config;
}
VAR_11 = -VAR_12;
VAR_8 = ovl_alloc_entry();
if (VAR_8 == NULL)
goto out_free_config;
VAR_11 = ovl_mount_dir(VAR_9->config.upperdir, &VAR_4);
if (VAR_11)
goto out_free_oe;
VAR_11 = ovl_mount_dir(VAR_9->config.lowerdir, &VAR_3);
if (VAR_11)
goto out_put_upperpath;
VAR_11 = ovl_mount_dir(VAR_9->config.workdir, &VAR_5);
if (VAR_11)
goto out_put_lowerpath;
VAR_11 = -VAR_14;
if (!S_ISDIR(VAR_4.dentry->d_inode->i_mode) ||
!S_ISDIR(VAR_3.dentry->d_inode->i_mode) ||
!S_ISDIR(VAR_5.dentry->d_inode->i_mode)) {
pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
goto out_put_workpath;
}
if (VAR_4.mnt != VAR_5.mnt) {
pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
goto out_put_workpath;
}
if (!ovl_workdir_ok(VAR_5.dentry, VAR_4.dentry)) {
pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
goto out_put_workpath;
}
if (!ovl_is_allowed_fs_type(VAR_4.dentry)) {
pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
goto out_put_workpath;
}
if (!ovl_is_allowed_fs_type(VAR_3.dentry)) {
pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
goto out_put_workpath;
}
VAR_11 = vfs_statfs(&VAR_3, &VAR_10);
if (VAR_11) {
pr_err(""overlayfs: statfs failed on lowerpath\n"");
goto out_put_workpath;
}
VAR_9->lower_namelen = VAR_10.f_namelen;
VAR_9->upper_mnt = clone_private_mount(&VAR_4);
VAR_11 = PTR_ERR(VAR_9->upper_mnt);
if (IS_ERR(VAR_9->upper_mnt)) {
pr_err(""overlayfs: failed to clone upperpath\n"");
goto out_put_workpath;
}
VAR_9->lower_mnt = clone_private_mount(&VAR_3);
VAR_11 = PTR_ERR(VAR_9->lower_mnt);
if (IS_ERR(VAR_9->lower_mnt)) {
pr_err(""overlayfs: failed to clone lowerpath\n"");
goto out_put_upper_mnt;
}
VAR_9->workdir = ovl_workdir_create(VAR_9->upper_mnt, VAR_5.dentry);
VAR_11 = PTR_ERR(VAR_9->workdir);
if (IS_ERR(VAR_9->workdir)) {
pr_err(""overlayfs: failed to create directory %s/%s\n"",
VAR_9->config.workdir, VAR_15);
goto out_put_lower_mnt;
}
VAR_9->lower_mnt->mnt_flags |= VAR_16;
if (VAR_9->upper_mnt->mnt_sb->s_flags & VAR_17)
VAR_0->s_flags |= VAR_17;
VAR_0->s_d_op = &VAR_18;
VAR_11 = -VAR_12;
VAR_6 = ovl_new_inode(VAR_0, VAR_19, VAR_8);
if (!VAR_6)
goto out_put_workdir;
VAR_7 = d_make_root(VAR_6);
if (!VAR_7)
goto out_put_workdir;
mntput(VAR_4.mnt);
mntput(VAR_3.mnt);
path_put(&VAR_5);
VAR_8->__upperdentry = VAR_4.dentry;
VAR_8->lowerdentry = VAR_3.dentry;
VAR_7->d_fsdata = VAR_8;
VAR_0->s_magic = VAR_20;
VAR_0->s_op = &VAR_21;
VAR_0->s_root = VAR_7;
VAR_0->s_fs_info = VAR_9;
return 0;
out_put_workdir:
dput(VAR_9->workdir);
out_put_lower_mnt:
mntput(VAR_9->lower_mnt);
out_put_upper_mnt:
mntput(VAR_9->upper_mnt);
out_put_workpath:
path_put(&VAR_5);
out_put_lowerpath:
path_put(&VAR_3);
out_put_upperpath:
path_put(&VAR_4);
out_free_oe:
kfree(VAR_8);
out_free_config:
kfree(VAR_9->config.lowerdir);
kfree(VAR_9->config.upperdir);
kfree(VAR_9->config.workdir);
kfree(VAR_9);
out:
return VAR_11;
}",torvalds/linux/69c433ed2ecd2d3264efd7afec4439524b319121/super.c/vul/before/0.json,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	/* FIXME: workdir is not needed for a R/O mount */
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
	}
	ufs->lower_namelen = statfs.f_namelen;

	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

	ufs->upper_mnt = clone_private_mount(&upperpath);
	err = PTR_ERR(ufs->upper_mnt);
	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	/*
	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
	 * will fail instead of modifying lower fs.
	 */
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	/* If the upper fs is r/o, we mark overlayfs r/o too */
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}","static int ovl_fill_super(struct super_block *VAR_0, void *VAR_1, int VAR_2)
{
	struct path VAR_3;
	struct path VAR_4;
	struct path VAR_5;
	struct inode *VAR_6;
	struct dentry *VAR_7;
	struct ovl_entry *VAR_8;
	struct ovl_fs *VAR_9;
	struct kstatfs VAR_10;
	int VAR_11;

	VAR_11 = -VAR_12;
	VAR_9 = kzalloc(sizeof(struct ovl_fs), VAR_13);
	if (!VAR_9)
		goto out;

	VAR_11 = ovl_parse_opt((char *) VAR_1, &VAR_9->config);
	if (VAR_11)
		goto out_free_config;

	/* COMMENT_0 */
	VAR_11 = -VAR_14;
	if (!VAR_9->config.upperdir || !VAR_9->config.lowerdir ||
	    !VAR_9->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	VAR_11 = -VAR_12;
	VAR_8 = ovl_alloc_entry();
	if (VAR_8 == NULL)
		goto out_free_config;

	VAR_11 = ovl_mount_dir(VAR_9->config.upperdir, &VAR_4);
	if (VAR_11)
		goto out_free_oe;

	VAR_11 = ovl_mount_dir(VAR_9->config.lowerdir, &VAR_3);
	if (VAR_11)
		goto out_put_upperpath;

	VAR_11 = ovl_mount_dir(VAR_9->config.workdir, &VAR_5);
	if (VAR_11)
		goto out_put_lowerpath;

	VAR_11 = -VAR_14;
	if (!S_ISDIR(VAR_4.dentry->d_inode->i_mode) ||
	    !S_ISDIR(VAR_3.dentry->d_inode->i_mode) ||
	    !S_ISDIR(VAR_5.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (VAR_4.mnt != VAR_5.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(VAR_5.dentry, VAR_4.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(VAR_4.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(VAR_3.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	VAR_11 = vfs_statfs(&VAR_3, &VAR_10);
	if (VAR_11) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
	}
	VAR_9->lower_namelen = VAR_10.f_namelen;

	VAR_0->s_stack_depth = max(VAR_4.mnt->mnt_sb->s_stack_depth,
				VAR_3.mnt->mnt_sb->s_stack_depth) + 1;

	VAR_11 = -VAR_14;
	if (VAR_0->s_stack_depth > VAR_15) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

	VAR_9->upper_mnt = clone_private_mount(&VAR_4);
	VAR_11 = PTR_ERR(VAR_9->upper_mnt);
	if (IS_ERR(VAR_9->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	VAR_9->lower_mnt = clone_private_mount(&VAR_3);
	VAR_11 = PTR_ERR(VAR_9->lower_mnt);
	if (IS_ERR(VAR_9->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	VAR_9->workdir = ovl_workdir_create(VAR_9->upper_mnt, VAR_5.dentry);
	VAR_11 = PTR_ERR(VAR_9->workdir);
	if (IS_ERR(VAR_9->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       VAR_9->config.workdir, VAR_16);
		goto out_put_lower_mnt;
	}

	/* COMMENT_1 */
                                                             
                                            
    
	VAR_9->lower_mnt->mnt_flags |= VAR_17;

	/* COMMENT_5 */
	if (VAR_9->upper_mnt->mnt_sb->s_flags & VAR_18)
		VAR_0->s_flags |= VAR_18;

	VAR_0->s_d_op = &VAR_19;

	VAR_11 = -VAR_12;
	VAR_6 = ovl_new_inode(VAR_0, VAR_20, VAR_8);
	if (!VAR_6)
		goto out_put_workdir;

	VAR_7 = d_make_root(VAR_6);
	if (!VAR_7)
		goto out_put_workdir;

	mntput(VAR_4.mnt);
	mntput(VAR_3.mnt);
	path_put(&VAR_5);

	VAR_8->__upperdentry = VAR_4.dentry;
	VAR_8->lowerdentry = VAR_3.dentry;

	VAR_7->d_fsdata = VAR_8;

	VAR_0->s_magic = VAR_21;
	VAR_0->s_op = &VAR_22;
	VAR_0->s_root = VAR_7;
	VAR_0->s_fs_info = VAR_9;

	return 0;

out_put_workdir:
	dput(VAR_9->workdir);
out_put_lower_mnt:
	mntput(VAR_9->lower_mnt);
out_put_upper_mnt:
	mntput(VAR_9->upper_mnt);
out_put_workpath:
	path_put(&VAR_5);
out_put_lowerpath:
	path_put(&VAR_3);
out_put_upperpath:
	path_put(&VAR_4);
out_free_oe:
	kfree(VAR_8);
out_free_config:
	kfree(VAR_9->config.lowerdir);
	kfree(VAR_9->config.upperdir);
	kfree(VAR_9->config.workdir);
	kfree(VAR_9);
out:
	return VAR_11;
}",torvalds/linux/69c433ed2ecd2d3264efd7afec4439524b319121/super.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,15 @@
 		goto out_put_workpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
+
+	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
+				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;
+
+	err = -EINVAL;
+	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
+		goto out_put_workpath;
+	}
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);","{'deleted_lines': [], 'added_lines': ['', '\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,', '\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;', '', '\terr = -EINVAL;', '\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {', '\t\tpr_err(""overlayfs: maximum fs stacking depth exceeded\\n"");', '\t\tgoto out_put_workpath;', '\t}']}",True,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",7.8,HIGH,2,valid,2014-10-23T22:14:39Z,1
CVE-2014-9922,['CWE-264'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"fs: limit filesystem stacking depth

Add a simple read-only counter to super_block that indicates how deep this
is in the stack of filesystems.  Previously ecryptfs was the only stackable
filesystem and it explicitly disallowed multiple layers of itself.

Overlayfs, however, can be stacked recursively and also may be stacked
on top of ecryptfs or vice versa.

To limit the kernel stack usage we must limit the depth of the
filesystem stack.  Initially the limit is set to 2.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>",69c433ed2ecd2d3264efd7afec4439524b319121,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,fs/ecryptfs/main.c,ecryptfs_mount,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
const char *dev_name, void *raw_data)
{
struct super_block *s;
struct ecryptfs_sb_info *sbi;
struct ecryptfs_dentry_info *root_info;
const char *err = ""Getting sb failed"";
struct inode *inode;
struct path path;
uid_t check_ruid;
int rc;
sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
if (!sbi) {
rc = -ENOMEM;
goto out;
}
rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
if (rc) {
err = ""Error parsing options"";
goto out;
}
s = sget(fs_type, NULL, set_anon_super, flags, NULL);
if (IS_ERR(s)) {
rc = PTR_ERR(s);
goto out;
}
rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
if (rc)
goto out1;
ecryptfs_set_superblock_private(s, sbi);
s->s_bdi = &sbi->bdi;
sbi = NULL;
s->s_op = &ecryptfs_sops;
s->s_d_op = &ecryptfs_dops;
err = ""Reading sb failed"";
rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
if (rc) {
ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
goto out1;
}
if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
rc = -EINVAL;
printk(KERN_ERR ""Mount on filesystem of type ""
""eCryptfs explicitly disallowed due to ""
""known incompatibilities\n"");
goto out_free;
}
if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
rc = -EPERM;
printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
""requested user (uid: %d)\n"",
i_uid_read(path.dentry->d_inode),
from_kuid(&init_user_ns, current_uid()));
goto out_free;
}
ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
s->s_flags = flags & ~MS_POSIXACL;
s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);
s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
s->s_blocksize = path.dentry->d_sb->s_blocksize;
s->s_magic = ECRYPTFS_SUPER_MAGIC;
inode = ecryptfs_get_inode(path.dentry->d_inode, s);
rc = PTR_ERR(inode);
if (IS_ERR(inode))
goto out_free;
s->s_root = d_make_root(inode);
if (!s->s_root) {
rc = -ENOMEM;
goto out_free;
}
rc = -ENOMEM;
root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
if (!root_info)
goto out_free;
ecryptfs_set_dentry_private(s->s_root, root_info);
root_info->lower_path = path;
s->s_flags |= MS_ACTIVE;
return dget(s->s_root);
out_free:
path_put(&path);
out1:
deactivate_locked_super(s);
out:
if (sbi) {
ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
kmem_cache_free(ecryptfs_sb_info_cache, sbi);
}
printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
return ERR_PTR(rc);
}","static struct dentry *ecryptfs_mount(struct file_system_type *VAR_0, int VAR_1,
const char *VAR_2, void *VAR_3)
{
struct super_block *VAR_4;
struct ecryptfs_sb_info *VAR_5;
struct ecryptfs_dentry_info *VAR_6;
const char *VAR_7 = ""Getting sb failed"";
struct inode *inode;
struct path path;
uid_t VAR_8;
int VAR_9;
VAR_5 = kmem_cache_zalloc(VAR_10, VAR_11);
if (!VAR_5) {
VAR_9 = -VAR_12;
goto out;
}
VAR_9 = ecryptfs_parse_options(VAR_5, VAR_3, &VAR_8);
if (VAR_9) {
VAR_7 = ""Error parsing options"";
goto out;
}
VAR_4 = sget(VAR_0, NULL, VAR_13, VAR_1, NULL);
if (IS_ERR(VAR_4)) {
VAR_9 = PTR_ERR(VAR_4);
goto out;
}
VAR_9 = bdi_setup_and_register(&VAR_5->bdi, ""ecryptfs"", VAR_14);
if (VAR_9)
goto out1;
ecryptfs_set_superblock_private(VAR_4, VAR_5);
VAR_4->s_bdi = &VAR_5->bdi;
VAR_5 = NULL;
VAR_4->s_op = &VAR_15;
VAR_4->s_d_op = &VAR_16;
VAR_7 = ""Reading sb failed"";
VAR_9 = kern_path(VAR_2, VAR_17 | VAR_18, &path);
if (VAR_9) {
ecryptfs_printk(VAR_19, ""kern_path() failed\n"");
goto out1;
}
if (path.dentry->d_sb->s_type == &VAR_20) {
VAR_9 = -VAR_21;
printk(KERN_ERR ""Mount on filesystem of type ""
""eCryptfs explicitly disallowed due to ""
""known incompatibilities\n"");
goto out_free;
}
if (VAR_8 && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
VAR_9 = -VAR_22;
printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
""requested user (uid: %d)\n"",
i_uid_read(path.dentry->d_inode),
from_kuid(&VAR_23, current_uid()));
goto out_free;
}
ecryptfs_set_superblock_lower(VAR_4, path.dentry->d_sb);
VAR_4->s_flags = VAR_1 & ~VAR_24;
VAR_4->s_flags |= path.dentry->d_sb->s_flags & (VAR_25 | VAR_24);
VAR_4->s_maxbytes = path.dentry->d_sb->s_maxbytes;
VAR_4->s_blocksize = path.dentry->d_sb->s_blocksize;
VAR_4->s_magic = VAR_26;
inode = ecryptfs_get_inode(path.dentry->d_inode, VAR_4);
VAR_9 = PTR_ERR(inode);
if (IS_ERR(inode))
goto out_free;
VAR_4->s_root = d_make_root(inode);
if (!VAR_4->s_root) {
VAR_9 = -VAR_12;
goto out_free;
}
VAR_9 = -VAR_12;
VAR_6 = kmem_cache_zalloc(VAR_27, VAR_11);
if (!VAR_6)
goto out_free;
ecryptfs_set_dentry_private(VAR_4->s_root, VAR_6);
VAR_6->lower_path = path;
VAR_4->s_flags |= VAR_28;
return dget(VAR_4->s_root);
out_free:
path_put(&path);
out1:
deactivate_locked_super(VAR_4);
out:
if (VAR_5) {
ecryptfs_destroy_mount_crypt_stat(&VAR_5->mount_crypt_stat);
kmem_cache_free(VAR_10, VAR_5);
}
printk(KERN_ERR ""%s; rc = [%d]\n"", VAR_7, VAR_9);
return ERR_PTR(VAR_9);
}",torvalds/linux/69c433ed2ecd2d3264efd7afec4439524b319121/main.c/vul/before/0.json,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, flags, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	/* ->kill_sb() will take care of sbi after that point */
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&init_user_ns, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);

	/**
	 * Set the POSIX ACL flag based on whether they're enabled in the lower
	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
	 * Allow a ro eCryptfs mount even when the lower mount is rw.
	 */
	s->s_flags = flags & ~MS_POSIXACL;
	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);

	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_make_root(inode);
	if (!s->s_root) {
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	/* ->kill_sb() will take care of root_info */
	ecryptfs_set_dentry_private(s->s_root, root_info);
	root_info->lower_path = path;

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}","static struct dentry *ecryptfs_mount(struct file_system_type *VAR_0, int VAR_1,
			const char *VAR_2, void *VAR_3)
{
	struct super_block *VAR_4;
	struct ecryptfs_sb_info *VAR_5;
	struct ecryptfs_dentry_info *VAR_6;
	const char *VAR_7 = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t VAR_8;
	int VAR_9;

	VAR_5 = kmem_cache_zalloc(VAR_10, VAR_11);
	if (!VAR_5) {
		VAR_9 = -VAR_12;
		goto out;
	}

	VAR_9 = ecryptfs_parse_options(VAR_5, VAR_3, &VAR_8);
	if (VAR_9) {
		VAR_7 = ""Error parsing options"";
		goto out;
	}

	VAR_4 = sget(VAR_0, NULL, VAR_13, VAR_1, NULL);
	if (IS_ERR(VAR_4)) {
		VAR_9 = PTR_ERR(VAR_4);
		goto out;
	}

	VAR_9 = bdi_setup_and_register(&VAR_5->bdi, ""ecryptfs"", VAR_14);
	if (VAR_9)
		goto out1;

	ecryptfs_set_superblock_private(VAR_4, VAR_5);
	VAR_4->s_bdi = &VAR_5->bdi;

	/* COMMENT_0 */
	VAR_5 = NULL;
	VAR_4->s_op = &VAR_15;
	VAR_4->s_d_op = &VAR_16;

	VAR_7 = ""Reading sb failed"";
	VAR_9 = kern_path(VAR_2, VAR_17 | VAR_18, &path);
	if (VAR_9) {
		ecryptfs_printk(VAR_19, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &VAR_20) {
		VAR_9 = -VAR_21;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (VAR_8 && !uid_eq(path.dentry->d_inode->i_uid, current_uid())) {
		VAR_9 = -VAR_22;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
			i_uid_read(path.dentry->d_inode),
			from_kuid(&VAR_23, current_uid()));
		goto out_free;
	}

	ecryptfs_set_superblock_lower(VAR_4, path.dentry->d_sb);

	/* COMMENT_1 */
                                                                        
                                                                     
                                                              
    
	VAR_4->s_flags = VAR_1 & ~VAR_24;
	VAR_4->s_flags |= path.dentry->d_sb->s_flags & (VAR_25 | VAR_24);

	VAR_4->s_maxbytes = path.dentry->d_sb->s_maxbytes;
	VAR_4->s_blocksize = path.dentry->d_sb->s_blocksize;
	VAR_4->s_magic = VAR_26;
	VAR_4->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	VAR_9 = -VAR_21;
	if (VAR_4->s_stack_depth > VAR_27) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}

	inode = ecryptfs_get_inode(path.dentry->d_inode, VAR_4);
	VAR_9 = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	VAR_4->s_root = d_make_root(inode);
	if (!VAR_4->s_root) {
		VAR_9 = -VAR_12;
		goto out_free;
	}

	VAR_9 = -VAR_12;
	VAR_6 = kmem_cache_zalloc(VAR_28, VAR_11);
	if (!VAR_6)
		goto out_free;

	/* COMMENT_6 */
	ecryptfs_set_dentry_private(VAR_4->s_root, VAR_6);
	VAR_6->lower_path = path;

	VAR_4->s_flags |= VAR_29;
	return dget(VAR_4->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(VAR_4);
out:
	if (VAR_5) {
		ecryptfs_destroy_mount_crypt_stat(&VAR_5->mount_crypt_stat);
		kmem_cache_free(VAR_10, VAR_5);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", VAR_7, VAR_9);
	return ERR_PTR(VAR_9);
}",torvalds/linux/69c433ed2ecd2d3264efd7afec4439524b319121/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -76,6 +76,13 @@
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
+	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;
+
+	rc = -EINVAL;
+	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
+		goto out_free;
+	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);","{'deleted_lines': [], 'added_lines': ['\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;', '', '\trc = -EINVAL;', '\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {', '\t\tpr_err(""eCryptfs: maximum fs stacking depth exceeded\\n"");', '\t\tgoto out_free;', '\t}']}",True,"The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c.",7.8,HIGH,2,valid,2014-10-23T22:14:39Z,1
CVE-2014-9630,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,videolan/vlc,"stream_out: rtp: don't use VLA for user controlled data

It should fix a possible invalid memory access

When streaming ogg-files via rtp, an ogg-file can trigger an invalid
write access using an overly long 'configuration' string.

The original code attemps to allocate space to hold the string on the stack
and hence, cannot verify if allocation succeeds. Instead, we now allocate the
buffer on the heap and return if allocation fails.

In detail, rtp_packetize_xiph_config allocates a buffer on the stack at (1) where
the size depends on the local variable 'len'. The variable 'len' is
calculated at (0) to be the length of a string contained in a specially
crafted Ogg Vorbis file, and therefore, it is attacker-controlled.

Signed-off-by: Jean-Baptiste Kempf <jb@videolan.org>",204291467724867b79735c0ee3aeb0dbc2200f97,https://github.com/videolan/vlc/commit/204291467724867b79735c0ee3aeb0dbc2200f97,modules/stream_out/rtpfmt.c,rtp_packetize_xiph_config,"int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,
int64_t i_pts )
{
if (fmtp == NULL)
return VLC_EGENERIC;
char *start = strstr(fmtp, ""configuration="");
assert(start != NULL);
start += sizeof(""configuration="") - 1;
char *end = strchr(start, ';');
assert(end != NULL);
size_t len = end - start;
char b64[len + 1];
memcpy(b64, start, len);
b64[len] = '\0';
int     i_max   = rtp_mtu (id) - 6; 
uint8_t *p_orig, *p_data;
int i_data;
i_data = vlc_b64_decode_binary(&p_orig, b64);
if (i_data <= 9)
{
free(p_orig);
return VLC_EGENERIC;
}
p_data = p_orig + 9;
i_data -= 9;
int i_count = ( i_data + i_max - 1 ) / i_max;
for( int i = 0; i < i_count; i++ )
{
int           i_payload = __MIN( i_max, i_data );
block_t *out = block_Alloc( 18 + i_payload );
unsigned fragtype, numpkts;
if (i_count == 1)
{
fragtype = 0;
numpkts = 1;
}
else
{
numpkts = 0;
if (i == 0)
fragtype = 1;
else if (i == i_count - 1)
fragtype = 3;
else
fragtype = 2;
}
uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |
(fragtype << 6) | (1 << 4) | numpkts;
rtp_packetize_common( id, out, 0, i_pts );
SetDWBE( out->p_buffer + 12, header);
SetWBE( out->p_buffer + 16, i_payload);
memcpy( &out->p_buffer[18], p_data, i_payload );
out->i_dts    = i_pts;
rtp_packetize_send( id, out );
p_data += i_payload;
i_data -= i_payload;
}
free(p_orig);
return VLC_SUCCESS;
}","int rtp_packetize_xiph_config( sout_stream_id_sys_t *VAR_0, const char *VAR_1,
int64_t VAR_2 )
{
if (VAR_1 == NULL)
return VAR_3;
char *VAR_4 = strstr(VAR_1, ""configuration="");
assert(VAR_4 != NULL);
VAR_4 += sizeof(""configuration="") - 1;
char *VAR_5 = strchr(VAR_4, ';');
assert(VAR_5 != NULL);
size_t VAR_6 = VAR_5 - VAR_4;
char VAR_7[VAR_6 + 1];
memcpy(VAR_7, VAR_4, VAR_6);
VAR_7[VAR_6] = '\0';
int     VAR_8   = rtp_mtu (VAR_0) - 6; 
uint8_t *VAR_9, *VAR_10;
int VAR_11;
VAR_11 = vlc_b64_decode_binary(&VAR_9, VAR_7);
if (VAR_11 <= 9)
{
free(VAR_9);
return VAR_3;
}
VAR_10 = VAR_9 + 9;
VAR_11 -= 9;
int VAR_12 = ( VAR_11 + VAR_8 - 1 ) / VAR_8;
for( int VAR_13 = 0; VAR_13 < VAR_12; VAR_13++ )
{
int           VAR_14 = __MIN( VAR_8, VAR_11 );
block_t *VAR_15 = block_Alloc( 18 + VAR_14 );
unsigned VAR_16, VAR_17;
if (VAR_12 == 1)
{
VAR_16 = 0;
VAR_17 = 1;
}
else
{
VAR_17 = 0;
if (VAR_13 == 0)
VAR_16 = 1;
else if (VAR_13 == VAR_12 - 1)
VAR_16 = 3;
else
VAR_16 = 2;
}
uint32_t VAR_18 = ((VAR_19 & 0xffffff) << 8) |
(VAR_16 << 6) | (1 << 4) | VAR_17;
rtp_packetize_common( VAR_0, VAR_15, 0, VAR_2 );
SetDWBE( VAR_15->p_buffer + 12, VAR_18);
SetWBE( VAR_15->p_buffer + 16, VAR_14);
memcpy( &VAR_15->p_buffer[18], VAR_10, VAR_14 );
VAR_15->i_dts    = VAR_2;
rtp_packetize_send( VAR_0, VAR_15 );
VAR_10 += VAR_14;
VAR_11 -= VAR_14;
}
free(VAR_9);
return VAR_20;
}",videolan/vlc/204291467724867b79735c0ee3aeb0dbc2200f97/rtpfmt.c/vul/before/0.json,"int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,
                               int64_t i_pts )
{
    if (fmtp == NULL)
        return VLC_EGENERIC;

    /* extract base64 configuration from fmtp */
    char *start = strstr(fmtp, ""configuration="");
    assert(start != NULL);
    start += sizeof(""configuration="") - 1;
    char *end = strchr(start, ';');
    assert(end != NULL);
    size_t len = end - start;

    char *b64 = malloc(len + 1);
    if(!b64)
        return VLC_EGENERIC;

    memcpy(b64, start, len);
    b64[len] = '\0';

    int     i_max   = rtp_mtu (id) - 6; /* payload max in one packet */

    uint8_t *p_orig, *p_data;
    int i_data;

    i_data = vlc_b64_decode_binary(&p_orig, b64);
    free(b64);
    if (i_data <= 9)
    {
        free(p_orig);
        return VLC_EGENERIC;
    }
    p_data = p_orig + 9;
    i_data -= 9;

    int i_count = ( i_data + i_max - 1 ) / i_max;

    for( int i = 0; i < i_count; i++ )
    {
        int           i_payload = __MIN( i_max, i_data );
        block_t *out = block_Alloc( 18 + i_payload );

        unsigned fragtype, numpkts;
        if (i_count == 1)
        {
            fragtype = 0;
            numpkts = 1;
        }
        else
        {
            numpkts = 0;
            if (i == 0)
                fragtype = 1;
            else if (i == i_count - 1)
                fragtype = 3;
            else
                fragtype = 2;
        }
        /* Ident:24, Fragment type:2, Vorbis/Theora Data Type:2, # of pkts:4 */
        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |
                          (fragtype << 6) | (1 << 4) | numpkts;

        /* rtp common header */
        rtp_packetize_common( id, out, 0, i_pts );

        SetDWBE( out->p_buffer + 12, header);
        SetWBE( out->p_buffer + 16, i_payload);
        memcpy( &out->p_buffer[18], p_data, i_payload );

        out->i_dts    = i_pts;

        rtp_packetize_send( id, out );

        p_data += i_payload;
        i_data -= i_payload;
    }

    free(p_orig);

    return VLC_SUCCESS;
}","int rtp_packetize_xiph_config( sout_stream_id_sys_t *VAR_0, const char *VAR_1,
                               int64_t VAR_2 )
{
    if (VAR_1 == NULL)
        return VAR_3;

    /* COMMENT_0 */
    char *VAR_4 = strstr(VAR_1, ""configuration="");
    assert(VAR_4 != NULL);
    VAR_4 += sizeof(""configuration="") - 1;
    char *VAR_5 = strchr(VAR_4, ';');
    assert(VAR_5 != NULL);
    size_t VAR_6 = VAR_5 - VAR_4;

    char *VAR_7 = malloc(VAR_6 + 1);
    if(!VAR_7)
        return VAR_3;

    memcpy(VAR_7, VAR_4, VAR_6);
    VAR_7[VAR_6] = '\0';

    int     VAR_8   = rtp_mtu (VAR_0) - 6; /* COMMENT_1 */

    uint8_t *VAR_9, *VAR_10;
    int VAR_11;

    VAR_11 = vlc_b64_decode_binary(&VAR_9, VAR_7);
    free(VAR_7);
    if (VAR_11 <= 9)
    {
        free(VAR_9);
        return VAR_3;
    }
    VAR_10 = VAR_9 + 9;
    VAR_11 -= 9;

    int VAR_12 = ( VAR_11 + VAR_8 - 1 ) / VAR_8;

    for( int VAR_13 = 0; VAR_13 < VAR_12; VAR_13++ )
    {
        int           VAR_14 = __MIN( VAR_8, VAR_11 );
        block_t *VAR_15 = block_Alloc( 18 + VAR_14 );

        unsigned VAR_16, VAR_17;
        if (VAR_12 == 1)
        {
            VAR_16 = 0;
            VAR_17 = 1;
        }
        else
        {
            VAR_17 = 0;
            if (VAR_13 == 0)
                VAR_16 = 1;
            else if (VAR_13 == VAR_12 - 1)
                VAR_16 = 3;
            else
                VAR_16 = 2;
        }
        /* COMMENT_2 */
        uint32_t VAR_18 = ((VAR_19 & 0xffffff) << 8) |
                          (VAR_16 << 6) | (1 << 4) | VAR_17;

        /* COMMENT_3 */
        rtp_packetize_common( VAR_0, VAR_15, 0, VAR_2 );

        SetDWBE( VAR_15->p_buffer + 12, VAR_18);
        SetWBE( VAR_15->p_buffer + 16, VAR_14);
        memcpy( &VAR_15->p_buffer[18], VAR_10, VAR_14 );

        VAR_15->i_dts    = VAR_2;

        rtp_packetize_send( VAR_0, VAR_15 );

        VAR_10 += VAR_14;
        VAR_11 -= VAR_14;
    }

    free(VAR_9);

    return VAR_20;
}",videolan/vlc/204291467724867b79735c0ee3aeb0dbc2200f97/rtpfmt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,11 @@
     char *end = strchr(start, ';');
     assert(end != NULL);
     size_t len = end - start;
-    char b64[len + 1];
+
+    char *b64 = malloc(len + 1);
+    if(!b64)
+        return VLC_EGENERIC;
+
     memcpy(b64, start, len);
     b64[len] = '\0';
 
@@ -21,6 +25,7 @@
     int i_data;
 
     i_data = vlc_b64_decode_binary(&p_orig, b64);
+    free(b64);
     if (i_data <= 9)
     {
         free(p_orig);","{'deleted_lines': ['    char b64[len + 1];'], 'added_lines': ['', '    char *b64 = malloc(len + 1);', '    if(!b64)', '        return VLC_EGENERIC;', '', '    free(b64);']}",True,"The rtp_packetize_xiph_config function in modules/stream_out/rtpfmt.c in VideoLAN VLC media player before 2.1.6 uses a stack-allocation approach with a size determined by arbitrary input data, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted length value.",7.8,HIGH,2,valid,2014-12-05T12:58:24Z,1
CVE-2016-7513,['CWE-189'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,,a54fe0e8600eaf3dc6fe717d3c0398001507f723,https://github.com/ImageMagick/ImageMagick/commit/a54fe0e8600eaf3dc6fe717d3c0398001507f723,magick/cache.c,ClonePixelCacheRepository,"static MagickBooleanType ClonePixelCacheRepository(
CacheInfo *restrict clone_info,CacheInfo *restrict cache_info,
ExceptionInfo *exception)
{
#define MaxCacheThreads  2
#define cache_threads(source,destination,chunk) \
num_threads((chunk) < (16*GetMagickResourceLimit(ThreadResource)) ? 1 : \
GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \
GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)
MagickBooleanType
status;
NexusInfo
**restrict cache_nexus,
**restrict clone_nexus;
size_t
length;
ssize_t
y;
assert(cache_info != (CacheInfo *) NULL);
assert(clone_info != (CacheInfo *) NULL);
assert(exception != (ExceptionInfo *) NULL);
if (cache_info->type == PingCache)
return(MagickTrue);
if (((cache_info->type == MemoryCache) || (cache_info->type == MapCache)) &&
((clone_info->type == MemoryCache) || (clone_info->type == MapCache)) &&
(cache_info->columns == clone_info->columns) &&
(cache_info->rows == clone_info->rows) &&
(cache_info->active_index_channel == clone_info->active_index_channel))
{
CopyPixels(clone_info->pixels,cache_info->pixels,cache_info->columns*
cache_info->rows);
if ((cache_info->active_index_channel != MagickFalse) &&
(clone_info->active_index_channel != MagickFalse))
(void) memcpy(clone_info->indexes,cache_info->indexes,
cache_info->columns*cache_info->rows*sizeof(*cache_info->indexes));
return(MagickTrue);
}
cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);
clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);
if ((cache_nexus == (NexusInfo **) NULL) ||
(clone_nexus == (NexusInfo **) NULL))
ThrowFatalException(ResourceLimitFatalError,""MemoryAllocationFailed"");
length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*
sizeof(*cache_info->pixels);
status=MagickTrue;
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp parallel for schedule(static,4) shared(status) \
cache_threads(cache_info,clone_info,cache_info->rows)
#endif
for (y=0; y < (ssize_t) cache_info->rows; y++)
{
const int
id = GetOpenMPThreadId();
PixelPacket
*pixels;
RectangleInfo
region;
if (status == MagickFalse)
continue;
if (y >= (ssize_t) clone_info->rows)
continue;
region.width=cache_info->columns;
region.height=1;
region.x=0;
region.y=y;
pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,
cache_nexus[id],exception);
if (pixels == (PixelPacket *) NULL)
continue;
status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);
if (status == MagickFalse)
continue;
region.width=clone_info->columns;
pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,
clone_nexus[id],exception);
if (pixels == (PixelPacket *) NULL)
continue;
(void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)
clone_nexus[id]->length);
(void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length);
status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);
}
if ((cache_info->active_index_channel != MagickFalse) &&
(clone_info->active_index_channel != MagickFalse))
{
length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*
sizeof(*cache_info->indexes);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp parallel for schedule(static,4) shared(status) \
cache_threads(cache_info,clone_info,cache_info->rows)
#endif
for (y=0; y < (ssize_t) cache_info->rows; y++)
{
const int
id = GetOpenMPThreadId();
PixelPacket
*pixels;
RectangleInfo
region;
if (status == MagickFalse)
continue;
if (y >= (ssize_t) clone_info->rows)
continue;
region.width=cache_info->columns;
region.height=1;
region.x=0;
region.y=y;
pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,
cache_nexus[id],exception);
if (pixels == (PixelPacket *) NULL)
continue;
status=ReadPixelCacheIndexes(cache_info,cache_nexus[id],exception);
if (status == MagickFalse)
continue;
region.width=clone_info->columns;
pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,
clone_nexus[id],exception);
if (pixels == (PixelPacket *) NULL)
continue;
(void) memcpy(clone_nexus[id]->indexes,cache_nexus[id]->indexes,length);
status=WritePixelCacheIndexes(clone_info,clone_nexus[id],exception);
}
}
cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);
clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);
if (cache_info->debug != MagickFalse)
{
char
message[MaxTextExtent];
(void) FormatLocaleString(message,MaxTextExtent,""%s => %s"",
CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),
CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));
(void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",message);
}
return(status);
}","static MagickBooleanType ClonePixelCacheRepository(
CacheInfo *restrict VAR_0,CacheInfo *restrict VAR_1,
ExceptionInfo *VAR_2)
{
#define VAR_3  2
#define cache_threads(VAR_4,VAR_5,VAR_6) \
num_threads((chunk) < (16*GetMagickResourceLimit(ThreadResource)) ? 1 : \
GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \
GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)
MagickBooleanType
VAR_7;
NexusInfo
**restrict VAR_8,
**restrict VAR_9;
size_t
VAR_10;
ssize_t
VAR_11;
assert(VAR_1 != (CacheInfo *) NULL);
assert(VAR_0 != (CacheInfo *) NULL);
assert(VAR_2 != (ExceptionInfo *) NULL);
if (VAR_1->type == VAR_12)
return(VAR_13);
if (((VAR_1->type == VAR_14) || (VAR_1->type == VAR_15)) &&
((VAR_0->type == VAR_14) || (VAR_0->type == VAR_15)) &&
(VAR_1->columns == VAR_0->columns) &&
(VAR_1->rows == VAR_0->rows) &&
(VAR_1->active_index_channel == VAR_0->active_index_channel))
{
CopyPixels(VAR_0->pixels,VAR_1->pixels,VAR_1->columns*
VAR_1->rows);
if ((VAR_1->active_index_channel != VAR_16) &&
(VAR_0->active_index_channel != VAR_16))
(void) memcpy(VAR_0->indexes,VAR_1->indexes,
VAR_1->columns*VAR_1->rows*sizeof(*VAR_1->indexes));
return(VAR_13);
}
VAR_8=AcquirePixelCacheNexus(VAR_3);
VAR_9=AcquirePixelCacheNexus(VAR_3);
if ((VAR_8 == (NexusInfo **) NULL) ||
(VAR_9 == (NexusInfo **) NULL))
ThrowFatalException(VAR_17,""MemoryAllocationFailed"");
VAR_10=(size_t) MagickMin(VAR_1->columns,VAR_0->columns)*
sizeof(*VAR_1->pixels);
VAR_7=VAR_13;
#if defined(VAR_18)
#pragma omp parallel for schedule(static,4) shared(status) \
cache_threads(cache_info,clone_info,cache_info->rows)
#endif
for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->rows; VAR_11++)
{
const int
VAR_19 = GetOpenMPThreadId();
PixelPacket
*VAR_20;
RectangleInfo
VAR_21;
if (VAR_7 == VAR_16)
continue;
if (VAR_11 >= (ssize_t) VAR_0->rows)
continue;
VAR_21.width=VAR_1->columns;
VAR_21.height=1;
VAR_21.x=0;
VAR_21.y=VAR_11;
VAR_20=SetPixelCacheNexusPixels(VAR_1,VAR_22,&VAR_21,VAR_13,
VAR_8[VAR_19],VAR_2);
if (VAR_20 == (PixelPacket *) NULL)
continue;
VAR_7=ReadPixelCachePixels(VAR_1,VAR_8[VAR_19],VAR_2);
if (VAR_7 == VAR_16)
continue;
VAR_21.width=VAR_0->columns;
VAR_20=SetPixelCacheNexusPixels(VAR_0,VAR_23,&VAR_21,VAR_13,
VAR_9[VAR_19],VAR_2);
if (VAR_20 == (PixelPacket *) NULL)
continue;
(void) ResetMagickMemory(VAR_9[VAR_19]->pixels,0,(size_t)
VAR_9[VAR_19]->length);
(void) memcpy(VAR_9[VAR_19]->pixels,VAR_8[VAR_19]->pixels,VAR_10);
VAR_7=WritePixelCachePixels(VAR_0,VAR_9[VAR_19],VAR_2);
}
if ((VAR_1->active_index_channel != VAR_16) &&
(VAR_0->active_index_channel != VAR_16))
{
VAR_10=(size_t) MagickMin(VAR_1->columns,VAR_0->columns)*
sizeof(*VAR_1->indexes);
#if defined(VAR_18)
#pragma omp parallel for schedule(static,4) shared(status) \
cache_threads(cache_info,clone_info,cache_info->rows)
#endif
for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->rows; VAR_11++)
{
const int
VAR_19 = GetOpenMPThreadId();
PixelPacket
*VAR_20;
RectangleInfo
VAR_21;
if (VAR_7 == VAR_16)
continue;
if (VAR_11 >= (ssize_t) VAR_0->rows)
continue;
VAR_21.width=VAR_1->columns;
VAR_21.height=1;
VAR_21.x=0;
VAR_21.y=VAR_11;
VAR_20=SetPixelCacheNexusPixels(VAR_1,VAR_22,&VAR_21,VAR_13,
VAR_8[VAR_19],VAR_2);
if (VAR_20 == (PixelPacket *) NULL)
continue;
VAR_7=ReadPixelCacheIndexes(VAR_1,VAR_8[VAR_19],VAR_2);
if (VAR_7 == VAR_16)
continue;
VAR_21.width=VAR_0->columns;
VAR_20=SetPixelCacheNexusPixels(VAR_0,VAR_23,&VAR_21,VAR_13,
VAR_9[VAR_19],VAR_2);
if (VAR_20 == (PixelPacket *) NULL)
continue;
(void) memcpy(VAR_9[VAR_19]->indexes,VAR_8[VAR_19]->indexes,VAR_10);
VAR_7=WritePixelCacheIndexes(VAR_0,VAR_9[VAR_19],VAR_2);
}
}
VAR_8=DestroyPixelCacheNexus(VAR_8,VAR_3);
VAR_9=DestroyPixelCacheNexus(VAR_9,VAR_3);
if (VAR_1->debug != VAR_16)
{
char
VAR_24[VAR_25];
(void) FormatLocaleString(VAR_24,VAR_25,""%s => %s"",
CommandOptionToMnemonic(VAR_26,(ssize_t) VAR_1->type),
CommandOptionToMnemonic(VAR_26,(ssize_t) VAR_0->type));
(void) LogMagickEvent(VAR_27,GetMagickModule(),""%s"",VAR_24);
}
return(VAR_7);
}",ImageMagick/a54fe0e8600eaf3dc6fe717d3c0398001507f723/cache.c/vul/before/0.json,"static MagickBooleanType ClonePixelCacheRepository(
  CacheInfo *restrict clone_info,CacheInfo *restrict cache_info,
  ExceptionInfo *exception)
{
#define MaxCacheThreads  2
#define cache_threads(source,destination,chunk) \
  num_threads((chunk) < (16*GetMagickResourceLimit(ThreadResource)) ? 1 : \
    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \
    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)

  MagickBooleanType
    status;

  NexusInfo
    **restrict cache_nexus,
    **restrict clone_nexus;

  size_t
    length;

  ssize_t
    y;

  assert(cache_info != (CacheInfo *) NULL);
  assert(clone_info != (CacheInfo *) NULL);
  assert(exception != (ExceptionInfo *) NULL);
  if (cache_info->type == PingCache)
    return(MagickTrue);
  if (((cache_info->type == MemoryCache) || (cache_info->type == MapCache)) &&
      ((clone_info->type == MemoryCache) || (clone_info->type == MapCache)) &&
      (cache_info->columns == clone_info->columns) &&
      (cache_info->rows == clone_info->rows) &&
      (cache_info->active_index_channel == clone_info->active_index_channel))
    {
      /*
        Identical pixel cache morphology.
      */
      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*
        cache_info->rows*sizeof(*cache_info->pixels));
      if ((cache_info->active_index_channel != MagickFalse) &&
          (clone_info->active_index_channel != MagickFalse))
        (void) memcpy(clone_info->indexes,cache_info->indexes,
          cache_info->columns*cache_info->rows*sizeof(*cache_info->indexes));
      return(MagickTrue);
    }
  /*
    Mismatched pixel cache morphology.
  */
  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);
  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);
  if ((cache_nexus == (NexusInfo **) NULL) ||
      (clone_nexus == (NexusInfo **) NULL))
    ThrowFatalException(ResourceLimitFatalError,""MemoryAllocationFailed"");
  length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*
    sizeof(*cache_info->pixels);
  status=MagickTrue;
#if defined(MAGICKCORE_OPENMP_SUPPORT)
  #pragma omp parallel for schedule(static,4) shared(status) \
    cache_threads(cache_info,clone_info,cache_info->rows)
#endif
  for (y=0; y < (ssize_t) cache_info->rows; y++)
  {
    const int
      id = GetOpenMPThreadId();

    PixelPacket
      *pixels;

    RectangleInfo
      region;

    if (status == MagickFalse)
      continue;
    if (y >= (ssize_t) clone_info->rows)
      continue;
    region.width=cache_info->columns;
    region.height=1;
    region.x=0;
    region.y=y;
    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,
      cache_nexus[id],exception);
    if (pixels == (PixelPacket *) NULL)
      continue;
    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);
    if (status == MagickFalse)
      continue;
    region.width=clone_info->columns;
    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,
      clone_nexus[id],exception);
    if (pixels == (PixelPacket *) NULL)
      continue;
    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)
      clone_nexus[id]->length);
    (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length);
    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);
  }
  if ((cache_info->active_index_channel != MagickFalse) &&
      (clone_info->active_index_channel != MagickFalse))
    {
      /*
        Clone indexes.
      */
      length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*
        sizeof(*cache_info->indexes);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
      #pragma omp parallel for schedule(static,4) shared(status) \
        cache_threads(cache_info,clone_info,cache_info->rows)
#endif
      for (y=0; y < (ssize_t) cache_info->rows; y++)
      {
        const int
          id = GetOpenMPThreadId();

        PixelPacket
          *pixels;

        RectangleInfo
          region;

        if (status == MagickFalse)
          continue;
        if (y >= (ssize_t) clone_info->rows)
          continue;
        region.width=cache_info->columns;
        region.height=1;
        region.x=0;
        region.y=y;
        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,
          cache_nexus[id],exception);
        if (pixels == (PixelPacket *) NULL)
          continue;
        status=ReadPixelCacheIndexes(cache_info,cache_nexus[id],exception);
        if (status == MagickFalse)
          continue;
        region.width=clone_info->columns;
        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,
          clone_nexus[id],exception);
        if (pixels == (PixelPacket *) NULL)
          continue;
        (void) memcpy(clone_nexus[id]->indexes,cache_nexus[id]->indexes,length);
        status=WritePixelCacheIndexes(clone_info,clone_nexus[id],exception);
      }
    }
  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);
  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);
  if (cache_info->debug != MagickFalse)
    {
      char
        message[MaxTextExtent];

      (void) FormatLocaleString(message,MaxTextExtent,""%s => %s"",
        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),
        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));
      (void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",message);
    }
  return(status);
}","static MagickBooleanType ClonePixelCacheRepository(
  CacheInfo *restrict VAR_0,CacheInfo *restrict VAR_1,
  ExceptionInfo *VAR_2)
{
#define VAR_3  2
#define cache_threads(VAR_4,VAR_5,VAR_6) \
  num_threads((chunk) < (16*GetMagickResourceLimit(ThreadResource)) ? 1 : \
    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \
    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)

  MagickBooleanType
    VAR_7;

  NexusInfo
    **restrict VAR_8,
    **restrict VAR_9;

  size_t
    VAR_10;

  ssize_t
    VAR_11;

  assert(VAR_1 != (CacheInfo *) NULL);
  assert(VAR_0 != (CacheInfo *) NULL);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  if (VAR_1->type == VAR_12)
    return(VAR_13);
  if (((VAR_1->type == VAR_14) || (VAR_1->type == VAR_15)) &&
      ((VAR_0->type == VAR_14) || (VAR_0->type == VAR_15)) &&
      (VAR_1->columns == VAR_0->columns) &&
      (VAR_1->rows == VAR_0->rows) &&
      (VAR_1->active_index_channel == VAR_0->active_index_channel))
    {
      /* COMMENT_0 */
                                         
        
      (void) memcpy(VAR_0->pixels,VAR_1->pixels,VAR_1->columns*
        VAR_1->rows*sizeof(*VAR_1->pixels));
      if ((VAR_1->active_index_channel != VAR_16) &&
          (VAR_0->active_index_channel != VAR_16))
        (void) memcpy(VAR_0->indexes,VAR_1->indexes,
          VAR_1->columns*VAR_1->rows*sizeof(*VAR_1->indexes));
      return(VAR_13);
    }
  /* COMMENT_3 */
                                      
    
  VAR_8=AcquirePixelCacheNexus(VAR_3);
  VAR_9=AcquirePixelCacheNexus(VAR_3);
  if ((VAR_8 == (NexusInfo **) NULL) ||
      (VAR_9 == (NexusInfo **) NULL))
    ThrowFatalException(VAR_17,""MemoryAllocationFailed"");
  VAR_10=(size_t) MagickMin(VAR_1->columns,VAR_0->columns)*
    sizeof(*VAR_1->pixels);
  VAR_7=VAR_13;
#if defined(VAR_18)
  #pragma omp parallel for schedule(static,4) shared(status) \
    cache_threads(cache_info,clone_info,cache_info->rows)
#endif
  for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->rows; VAR_11++)
  {
    const int
      VAR_19 = GetOpenMPThreadId();

    PixelPacket
      *VAR_20;

    RectangleInfo
      VAR_21;

    if (VAR_7 == VAR_16)
      continue;
    if (VAR_11 >= (ssize_t) VAR_0->rows)
      continue;
    VAR_21.width=VAR_1->columns;
    VAR_21.height=1;
    VAR_21.x=0;
    VAR_21.y=VAR_11;
    VAR_20=SetPixelCacheNexusPixels(VAR_1,VAR_22,&VAR_21,VAR_13,
      VAR_8[VAR_19],VAR_2);
    if (VAR_20 == (PixelPacket *) NULL)
      continue;
    VAR_7=ReadPixelCachePixels(VAR_1,VAR_8[VAR_19],VAR_2);
    if (VAR_7 == VAR_16)
      continue;
    VAR_21.width=VAR_0->columns;
    VAR_20=SetPixelCacheNexusPixels(VAR_0,VAR_23,&VAR_21,VAR_13,
      VAR_9[VAR_19],VAR_2);
    if (VAR_20 == (PixelPacket *) NULL)
      continue;
    (void) ResetMagickMemory(VAR_9[VAR_19]->pixels,0,(size_t)
      VAR_9[VAR_19]->length);
    (void) memcpy(VAR_9[VAR_19]->pixels,VAR_8[VAR_19]->pixels,VAR_10);
    VAR_7=WritePixelCachePixels(VAR_0,VAR_9[VAR_19],VAR_2);
  }
  if ((VAR_1->active_index_channel != VAR_16) &&
      (VAR_0->active_index_channel != VAR_16))
    {
      /* COMMENT_6 */
                      
        
      VAR_10=(size_t) MagickMin(VAR_1->columns,VAR_0->columns)*
        sizeof(*VAR_1->indexes);
#if defined(VAR_18)
      #pragma omp parallel for schedule(static,4) shared(status) \
        cache_threads(cache_info,clone_info,cache_info->rows)
#endif
      for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->rows; VAR_11++)
      {
        const int
          VAR_19 = GetOpenMPThreadId();

        PixelPacket
          *VAR_20;

        RectangleInfo
          VAR_21;

        if (VAR_7 == VAR_16)
          continue;
        if (VAR_11 >= (ssize_t) VAR_0->rows)
          continue;
        VAR_21.width=VAR_1->columns;
        VAR_21.height=1;
        VAR_21.x=0;
        VAR_21.y=VAR_11;
        VAR_20=SetPixelCacheNexusPixels(VAR_1,VAR_22,&VAR_21,VAR_13,
          VAR_8[VAR_19],VAR_2);
        if (VAR_20 == (PixelPacket *) NULL)
          continue;
        VAR_7=ReadPixelCacheIndexes(VAR_1,VAR_8[VAR_19],VAR_2);
        if (VAR_7 == VAR_16)
          continue;
        VAR_21.width=VAR_0->columns;
        VAR_20=SetPixelCacheNexusPixels(VAR_0,VAR_23,&VAR_21,VAR_13,
          VAR_9[VAR_19],VAR_2);
        if (VAR_20 == (PixelPacket *) NULL)
          continue;
        (void) memcpy(VAR_9[VAR_19]->indexes,VAR_8[VAR_19]->indexes,VAR_10);
        VAR_7=WritePixelCacheIndexes(VAR_0,VAR_9[VAR_19],VAR_2);
      }
    }
  VAR_8=DestroyPixelCacheNexus(VAR_8,VAR_3);
  VAR_9=DestroyPixelCacheNexus(VAR_9,VAR_3);
  if (VAR_1->debug != VAR_16)
    {
      char
        VAR_24[VAR_25];

      (void) FormatLocaleString(VAR_24,VAR_25,""%s => %s"",
        CommandOptionToMnemonic(VAR_26,(ssize_t) VAR_1->type),
        CommandOptionToMnemonic(VAR_26,(ssize_t) VAR_0->type));
      (void) LogMagickEvent(VAR_27,GetMagickModule(),""%s"",VAR_24);
    }
  return(VAR_7);
}",ImageMagick/a54fe0e8600eaf3dc6fe717d3c0398001507f723/cache.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,8 +35,8 @@
       /*
         Identical pixel cache morphology.
       */
-      CopyPixels(clone_info->pixels,cache_info->pixels,cache_info->columns*
-        cache_info->rows);
+      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*
+        cache_info->rows*sizeof(*cache_info->pixels));
       if ((cache_info->active_index_channel != MagickFalse) &&
           (clone_info->active_index_channel != MagickFalse))
         (void) memcpy(clone_info->indexes,cache_info->indexes,","{'deleted_lines': ['      CopyPixels(clone_info->pixels,cache_info->pixels,cache_info->columns*', '        cache_info->rows);'], 'added_lines': ['      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*', '        cache_info->rows*sizeof(*cache_info->pixels));']}",True,Off-by-one error in magick/cache.c in ImageMagick allows remote attackers to cause a denial of service (segmentation fault) via unspecified vectors.,6.5,MEDIUM,1,valid,2014-12-16T12:24:08Z,1
CVE-2014-9717,['CWE-284'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,torvalds/linux,"mnt: Honor MNT_LOCKED when detaching mounts

Modify umount(MNT_DETACH) to keep mounts in the hash table that are
locked to their parent mounts, when the parent is lazily unmounted.

In mntput_no_expire detach the children from the hash table, depending
on mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.

In __detach_mounts if there are any mounts that have been unmounted
but still are on the list of mounts of a mountpoint, remove their
children from the mount hash table and those children to the unmounted
list so they won't linger potentially indefinitely waiting for their
final mntput, now that the mounts serve no purpose.

Cc: stable@vger.kernel.org
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",ce07d891a0891d3c0d0c2d73d577490486b809e1,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,fs/namespace.c,__detach_mounts,"void __detach_mounts(struct dentry *dentry)
{
struct mountpoint *mp;
struct mount *mnt;
namespace_lock();
mp = lookup_mountpoint(dentry);
if (!mp)
goto out_unlock;
lock_mount_hash();
while (!hlist_empty(&mp->m_list)) {
mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
umount_tree(mnt, 0);
}
unlock_mount_hash();
put_mountpoint(mp);
out_unlock:
namespace_unlock();
}","void __detach_mounts(struct dentry *dentry)
{
struct mountpoint *VAR_0;
struct mount *VAR_1;
namespace_lock();
VAR_0 = lookup_mountpoint(dentry);
if (!VAR_0)
goto out_unlock;
lock_mount_hash();
while (!hlist_empty(&VAR_0->m_list)) {
VAR_1 = hlist_entry(VAR_0->m_list.first, struct mount, VAR_2);
umount_tree(VAR_1, 0);
}
unlock_mount_hash();
put_mountpoint(VAR_0);
out_unlock:
namespace_unlock();
}",torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/before/0.json,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (!mp)
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
				umount_mnt(p);
			}
		}
		else umount_tree(mnt, 0);
	}
	unlock_mount_hash();
	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}","void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *VAR_0;
	struct mount *VAR_1;

	namespace_lock();
	VAR_0 = lookup_mountpoint(dentry);
	if (!VAR_0)
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&VAR_0->m_list)) {
		VAR_1 = hlist_entry(VAR_0->m_list.first, struct mount, VAR_2);
		if (VAR_1->mnt.mnt_flags & VAR_3) {
			struct mount *VAR_4, *VAR_5;
			list_for_each_entry_safe(VAR_4, VAR_5, &VAR_1->mnt_mounts,  VAR_6) {
				hlist_add_head(&VAR_4->mnt_umount.s_list, &VAR_7);
				umount_mnt(VAR_4);
			}
		}
		else umount_tree(VAR_1, 0);
	}
	unlock_mount_hash();
	put_mountpoint(VAR_0);
out_unlock:
	namespace_unlock();
}",torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,14 @@
 	lock_mount_hash();
 	while (!hlist_empty(&mp->m_list)) {
 		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
-		umount_tree(mnt, 0);
+		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
+			struct mount *p, *tmp;
+			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
+				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
+				umount_mnt(p);
+			}
+		}
+		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);","{'deleted_lines': ['\t\tumount_tree(mnt, 0);'], 'added_lines': ['\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {', '\t\t\tstruct mount *p, *tmp;', '\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {', '\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);', '\t\t\t\tumount_mnt(p);', '\t\t\t}', '\t\t}', '\t\telse umount_tree(mnt, 0);']}",True,"fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",6.1,MEDIUM,1,valid,2014-12-24T03:37:03Z,1
CVE-2014-9717,['CWE-284'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,torvalds/linux,"mnt: Honor MNT_LOCKED when detaching mounts

Modify umount(MNT_DETACH) to keep mounts in the hash table that are
locked to their parent mounts, when the parent is lazily unmounted.

In mntput_no_expire detach the children from the hash table, depending
on mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.

In __detach_mounts if there are any mounts that have been unmounted
but still are on the list of mounts of a mountpoint, remove their
children from the mount hash table and those children to the unmounted
list so they won't linger potentially indefinitely waiting for their
final mntput, now that the mounts serve no purpose.

Cc: stable@vger.kernel.org
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",ce07d891a0891d3c0d0c2d73d577490486b809e1,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,fs/namespace.c,umount_tree,"static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
{
LIST_HEAD(tmp_list);
struct mount *p;
if (how & UMOUNT_PROPAGATE)
propagate_mount_unlock(mnt);
for (p = mnt; p; p = next_mnt(p, mnt)) {
p->mnt.mnt_flags |= MNT_UMOUNT;
list_move(&p->mnt_list, &tmp_list);
}
list_for_each_entry(p, &tmp_list, mnt_list) {
list_del_init(&p->mnt_child);
}
if (how & UMOUNT_PROPAGATE)
propagate_umount(&tmp_list);
while (!list_empty(&tmp_list)) {
p = list_first_entry(&tmp_list, struct mount, mnt_list);
list_del_init(&p->mnt_expire);
list_del_init(&p->mnt_list);
__touch_mnt_namespace(p->mnt_ns);
p->mnt_ns = NULL;
if (how & UMOUNT_SYNC)
p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);
if (mnt_has_parent(p)) {
mnt_add_count(p->mnt_parent, -1);
umount_mnt(p);
}
change_mnt_propagation(p, MS_PRIVATE);
}
}","static void umount_tree(struct mount *VAR_0, enum umount_tree_flags VAR_1)
{
LIST_HEAD(VAR_2);
struct mount *VAR_3;
if (VAR_1 & VAR_4)
propagate_mount_unlock(VAR_0);
for (VAR_3 = VAR_0; VAR_3; VAR_3 = next_mnt(VAR_3, VAR_0)) {
VAR_3->mnt.mnt_flags |= VAR_5;
list_move(&VAR_3->mnt_list, &VAR_2);
}
list_for_each_entry(VAR_3, &VAR_2, VAR_6) {
list_del_init(&VAR_3->mnt_child);
}
if (VAR_1 & VAR_4)
propagate_umount(&VAR_2);
while (!list_empty(&VAR_2)) {
VAR_3 = list_first_entry(&VAR_2, struct mount, VAR_6);
list_del_init(&VAR_3->mnt_expire);
list_del_init(&VAR_3->mnt_list);
__touch_mnt_namespace(VAR_3->mnt_ns);
VAR_3->mnt_ns = NULL;
if (VAR_1 & VAR_7)
VAR_3->mnt.mnt_flags |= VAR_8;
pin_insert_group(&VAR_3->mnt_umount, &VAR_3->mnt_parent->mnt, &VAR_9);
if (mnt_has_parent(VAR_3)) {
mnt_add_count(VAR_3->mnt_parent, -1);
umount_mnt(VAR_3);
}
change_mnt_propagation(VAR_3, VAR_10);
}
}",torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/before/1.json,"static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
{
	LIST_HEAD(tmp_list);
	struct mount *p;

	if (how & UMOUNT_PROPAGATE)
		propagate_mount_unlock(mnt);

	/* Gather the mounts to umount */
	for (p = mnt; p; p = next_mnt(p, mnt)) {
		p->mnt.mnt_flags |= MNT_UMOUNT;
		list_move(&p->mnt_list, &tmp_list);
	}

	/* Hide the mounts from mnt_mounts */
	list_for_each_entry(p, &tmp_list, mnt_list) {
		list_del_init(&p->mnt_child);
	}

	/* Add propogated mounts to the tmp_list */
	if (how & UMOUNT_PROPAGATE)
		propagate_umount(&tmp_list);

	while (!list_empty(&tmp_list)) {
		bool disconnect;
		p = list_first_entry(&tmp_list, struct mount, mnt_list);
		list_del_init(&p->mnt_expire);
		list_del_init(&p->mnt_list);
		__touch_mnt_namespace(p->mnt_ns);
		p->mnt_ns = NULL;
		if (how & UMOUNT_SYNC)
			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;

		disconnect = !IS_MNT_LOCKED_AND_LAZY(p);

		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
				 disconnect ? &unmounted : NULL);
		if (mnt_has_parent(p)) {
			mnt_add_count(p->mnt_parent, -1);
			if (!disconnect) {
				/* Don't forget about p */
				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
			} else {
				umount_mnt(p);
			}
		}
		change_mnt_propagation(p, MS_PRIVATE);
	}
}","static void umount_tree(struct mount *VAR_0, enum umount_tree_flags VAR_1)
{
	LIST_HEAD(VAR_2);
	struct mount *VAR_3;

	if (VAR_1 & VAR_4)
		propagate_mount_unlock(VAR_0);

	/* COMMENT_0 */
	for (VAR_3 = VAR_0; VAR_3; VAR_3 = next_mnt(VAR_3, VAR_0)) {
		VAR_3->mnt.mnt_flags |= VAR_5;
		list_move(&VAR_3->mnt_list, &VAR_2);
	}

	/* COMMENT_1 */
	list_for_each_entry(VAR_3, &VAR_2, VAR_6) {
		list_del_init(&VAR_3->mnt_child);
	}

	/* COMMENT_2 */
	if (VAR_1 & VAR_4)
		propagate_umount(&VAR_2);

	while (!list_empty(&VAR_2)) {
		bool VAR_7;
		VAR_3 = list_first_entry(&VAR_2, struct mount, VAR_6);
		list_del_init(&VAR_3->mnt_expire);
		list_del_init(&VAR_3->mnt_list);
		__touch_mnt_namespace(VAR_3->mnt_ns);
		VAR_3->mnt_ns = NULL;
		if (VAR_1 & VAR_8)
			VAR_3->mnt.mnt_flags |= VAR_9;

		VAR_7 = !IS_MNT_LOCKED_AND_LAZY(VAR_3);

		pin_insert_group(&VAR_3->mnt_umount, &VAR_3->mnt_parent->mnt,
				 VAR_7 ? &VAR_10 : NULL);
		if (mnt_has_parent(VAR_3)) {
			mnt_add_count(VAR_3->mnt_parent, -1);
			if (!VAR_7) {
				/* COMMENT_3 */
				list_add_tail(&VAR_3->mnt_child, &VAR_3->mnt_parent->mnt_mounts);
			} else {
				umount_mnt(VAR_3);
			}
		}
		change_mnt_propagation(VAR_3, VAR_11);
	}
}",torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,6 +22,7 @@
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
+		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
@@ -30,10 +31,18 @@
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 
-		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);
+		disconnect = !IS_MNT_LOCKED_AND_LAZY(p);
+
+		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
+				 disconnect ? &unmounted : NULL);
 		if (mnt_has_parent(p)) {
 			mnt_add_count(p->mnt_parent, -1);
-			umount_mnt(p);
+			if (!disconnect) {
+				/* Don't forget about p */
+				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
+			} else {
+				umount_mnt(p);
+			}
 		}
 		change_mnt_propagation(p, MS_PRIVATE);
 	}","{'deleted_lines': ['\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);', '\t\t\tumount_mnt(p);'], 'added_lines': ['\t\tbool disconnect;', '\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);', '', '\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,', '\t\t\t\t disconnect ? &unmounted : NULL);', '\t\t\tif (!disconnect) {', ""\t\t\t\t/* Don't forget about p */"", '\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);', '\t\t\t} else {', '\t\t\t\tumount_mnt(p);', '\t\t\t}']}",True,"fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",6.1,MEDIUM,1,valid,2014-12-24T03:37:03Z,1
CVE-2014-9717,['CWE-284'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,torvalds/linux,"mnt: Honor MNT_LOCKED when detaching mounts

Modify umount(MNT_DETACH) to keep mounts in the hash table that are
locked to their parent mounts, when the parent is lazily unmounted.

In mntput_no_expire detach the children from the hash table, depending
on mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.

In __detach_mounts if there are any mounts that have been unmounted
but still are on the list of mounts of a mountpoint, remove their
children from the mount hash table and those children to the unmounted
list so they won't linger potentially indefinitely waiting for their
final mntput, now that the mounts serve no purpose.

Cc: stable@vger.kernel.org
Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",ce07d891a0891d3c0d0c2d73d577490486b809e1,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,fs/namespace.c,mntput_no_expire,"static void mntput_no_expire(struct mount *mnt)
{
rcu_read_lock();
mnt_add_count(mnt, -1);
if (likely(mnt->mnt_ns)) { 
rcu_read_unlock();
return;
}
lock_mount_hash();
if (mnt_get_count(mnt)) {
rcu_read_unlock();
unlock_mount_hash();
return;
}
if (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {
rcu_read_unlock();
unlock_mount_hash();
return;
}
mnt->mnt.mnt_flags |= MNT_DOOMED;
rcu_read_unlock();
list_del(&mnt->mnt_instance);
unlock_mount_hash();
if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {
struct task_struct *task = current;
if (likely(!(task->flags & PF_KTHREAD))) {
init_task_work(&mnt->mnt_rcu, __cleanup_mnt);
if (!task_work_add(task, &mnt->mnt_rcu, true))
return;
}
if (llist_add(&mnt->mnt_llist, &delayed_mntput_list))
schedule_delayed_work(&delayed_mntput_work, 1);
return;
}
cleanup_mnt(mnt);
}","static void mntput_no_expire(struct mount *VAR_0)
{
rcu_read_lock();
mnt_add_count(VAR_0, -1);
if (likely(VAR_0->mnt_ns)) { 
rcu_read_unlock();
return;
}
lock_mount_hash();
if (mnt_get_count(VAR_0)) {
rcu_read_unlock();
unlock_mount_hash();
return;
}
if (unlikely(VAR_0->mnt.mnt_flags & VAR_1)) {
rcu_read_unlock();
unlock_mount_hash();
return;
}
VAR_0->mnt.mnt_flags |= VAR_1;
rcu_read_unlock();
list_del(&VAR_0->mnt_instance);
unlock_mount_hash();
if (likely(!(VAR_0->mnt.mnt_flags & VAR_2))) {
struct task_struct *VAR_3 = VAR_4;
if (likely(!(VAR_3->flags & VAR_5))) {
init_task_work(&VAR_0->mnt_rcu, VAR_6);
if (!task_work_add(VAR_3, &VAR_0->mnt_rcu, true))
return;
}
if (llist_add(&VAR_0->mnt_llist, &VAR_7))
schedule_delayed_work(&VAR_8, 1);
return;
}
cleanup_mnt(VAR_0);
}",torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/before/2.json,"static void mntput_no_expire(struct mount *mnt)
{
	rcu_read_lock();
	mnt_add_count(mnt, -1);
	if (likely(mnt->mnt_ns)) { /* shouldn't be the last one */
		rcu_read_unlock();
		return;
	}
	lock_mount_hash();
	if (mnt_get_count(mnt)) {
		rcu_read_unlock();
		unlock_mount_hash();
		return;
	}
	if (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {
		rcu_read_unlock();
		unlock_mount_hash();
		return;
	}
	mnt->mnt.mnt_flags |= MNT_DOOMED;
	rcu_read_unlock();

	list_del(&mnt->mnt_instance);

	if (unlikely(!list_empty(&mnt->mnt_mounts))) {
		struct mount *p, *tmp;
		list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
			umount_mnt(p);
		}
	}
	unlock_mount_hash();

	if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {
		struct task_struct *task = current;
		if (likely(!(task->flags & PF_KTHREAD))) {
			init_task_work(&mnt->mnt_rcu, __cleanup_mnt);
			if (!task_work_add(task, &mnt->mnt_rcu, true))
				return;
		}
		if (llist_add(&mnt->mnt_llist, &delayed_mntput_list))
			schedule_delayed_work(&delayed_mntput_work, 1);
		return;
	}
	cleanup_mnt(mnt);
}","static void mntput_no_expire(struct mount *VAR_0)
{
	rcu_read_lock();
	mnt_add_count(VAR_0, -1);
	if (likely(VAR_0->mnt_ns)) { /* COMMENT_0 */
		rcu_read_unlock();
		return;
	}
	lock_mount_hash();
	if (mnt_get_count(VAR_0)) {
		rcu_read_unlock();
		unlock_mount_hash();
		return;
	}
	if (unlikely(VAR_0->mnt.mnt_flags & VAR_1)) {
		rcu_read_unlock();
		unlock_mount_hash();
		return;
	}
	VAR_0->mnt.mnt_flags |= VAR_1;
	rcu_read_unlock();

	list_del(&VAR_0->mnt_instance);

	if (unlikely(!list_empty(&VAR_0->mnt_mounts))) {
		struct mount *VAR_2, *VAR_3;
		list_for_each_entry_safe(VAR_2, VAR_3, &VAR_0->mnt_mounts,  VAR_4) {
			umount_mnt(VAR_2);
		}
	}
	unlock_mount_hash();

	if (likely(!(VAR_0->mnt.mnt_flags & VAR_5))) {
		struct task_struct *VAR_6 = VAR_7;
		if (likely(!(VAR_6->flags & VAR_8))) {
			init_task_work(&VAR_0->mnt_rcu, VAR_9);
			if (!task_work_add(VAR_6, &VAR_0->mnt_rcu, true))
				return;
		}
		if (llist_add(&VAR_0->mnt_llist, &VAR_10))
			schedule_delayed_work(&VAR_11, 1);
		return;
	}
	cleanup_mnt(VAR_0);
}",torvalds/linux/ce07d891a0891d3c0d0c2d73d577490486b809e1/namespace.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -21,6 +21,13 @@
 	rcu_read_unlock();
 
 	list_del(&mnt->mnt_instance);
+
+	if (unlikely(!list_empty(&mnt->mnt_mounts))) {
+		struct mount *p, *tmp;
+		list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
+			umount_mnt(p);
+		}
+	}
 	unlock_mount_hash();
 
 	if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {","{'deleted_lines': [], 'added_lines': ['', '\tif (unlikely(!list_empty(&mnt->mnt_mounts))) {', '\t\tstruct mount *p, *tmp;', '\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {', '\t\t\tumount_mnt(p);', '\t\t}', '\t}']}",True,"fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",6.1,MEDIUM,1,valid,2014-12-24T03:37:03Z,1
CVE-2015-8957,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=26838,78f82d9d1c2944725a279acd573a22168dc6e22a,https://github.com/ImageMagick/ImageMagick/commit/78f82d9d1c2944725a279acd573a22168dc6e22a,coders/sun.c,ReadSUNImage,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*image;
int
bit;
MagickBooleanType
status;
MagickSizeType
number_pixels;
register Quantum
*q;
register ssize_t
i,
x;
register unsigned char
*p;
size_t
bytes_per_line,
extent,
length;
ssize_t
count,
y;
SUNInfo
sun_info;
unsigned char
*sun_data,
*sun_pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
sun_info.magic=ReadBlobMSBLong(image);
do
{
if (sun_info.magic != 0x59a66a95)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
sun_info.width=ReadBlobMSBLong(image);
sun_info.height=ReadBlobMSBLong(image);
sun_info.depth=ReadBlobMSBLong(image);
sun_info.length=ReadBlobMSBLong(image);
sun_info.type=ReadBlobMSBLong(image);
sun_info.maptype=ReadBlobMSBLong(image);
sun_info.maplength=ReadBlobMSBLong(image);
extent=sun_info.height*sun_info.width;
if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
(sun_info.type != RT_FORMAT_RGB))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.depth == 0) || (sun_info.depth > 32))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
(sun_info.maptype != RMT_RAW))
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
image->columns=sun_info.width;
image->rows=sun_info.height;
image->depth=sun_info.depth <= 8 ? sun_info.depth :
MAGICKCORE_QUANTUM_DEPTH;
if (sun_info.depth < 24)
{
size_t
one;
image->storage_class=PseudoClass;
image->colors=sun_info.maplength;
one=1;
if (sun_info.maptype == RMT_NONE)
image->colors=one << sun_info.depth;
if (sun_info.maptype == RMT_EQUAL_RGB)
image->colors=sun_info.maplength/3;
}
switch (sun_info.maptype)
{
case RMT_NONE:
{
if (sun_info.depth < 24)
{
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
break;
}
case RMT_EQUAL_RGB:
{
unsigned char
*sun_colormap;
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
case RMT_RAW:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,sun_info.maplength,sun_colormap);
if (count != (ssize_t) sun_info.maplength)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
default:
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
}
image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
UndefinedPixelTrait;
image->columns=sun_info.width;
image->rows=sun_info.height;
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
sun_info.length || !sun_info.length)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
number_pixels=(MagickSizeType) image->columns*image->rows;
if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
sun_data=(unsigned char *) AcquireQuantumMemory((size_t) sun_info.length,
sizeof(*sun_data));
if (sun_data == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
if (count != (ssize_t) sun_info.length)
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
sun_pixels=sun_data;
bytes_per_line=0;
if (sun_info.type == RT_ENCODED)
{
size_t
height;
height=sun_info.height;
bytes_per_line=sun_info.width*sun_info.depth;
if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
((bytes_per_line/sun_info.depth) != sun_info.width))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
bytes_per_line+=15;
bytes_per_line<<=1;
if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
bytes_per_line>>=4;
sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
bytes_per_line*sizeof(*sun_pixels));
if (sun_pixels == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
height);
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
}
p=sun_pixels;
if (sun_info.depth == 1)
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=7; bit >= 0; bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
q);
q+=GetPixelChannels(image);
}
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
0x01),q);
q+=GetPixelChannels(image);
}
p++;
}
if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
else
if (image->storage_class == PseudoClass)
{
if (bytes_per_line == 0)
bytes_per_line=image->columns;
length=image->rows*(image->columns+image->columns % 2);
if (((sun_info.type == RT_ENCODED) &&
(length > (bytes_per_line*image->rows))) ||
((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelIndex(image,*p++,q);
q+=GetPixelChannels(image);
}
if ((image->columns % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
{
size_t
bytes_per_pixel;
bytes_per_pixel=3;
if (image->alpha_trait != UndefinedPixelTrait)
bytes_per_pixel++;
if (bytes_per_line == 0)
bytes_per_line=bytes_per_pixel*image->columns;
length=image->rows*(bytes_per_line+image->columns % 2);
if (((sun_info.type == RT_ENCODED) &&
(length > (bytes_per_line*image->rows))) ||
((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (image->alpha_trait != UndefinedPixelTrait)
SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
if (sun_info.type == RT_STANDARD)
{
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
}
else
{
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
}
if (image->colors != 0)
{
SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelRed(image,q)].red),q);
SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelGreen(image,q)].green),q);
SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelBlue(image,q)].blue),q);
}
q+=GetPixelChannels(image);
}
if (((bytes_per_pixel*image->columns) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
if (image->storage_class == PseudoClass)
(void) SyncImage(image,exception);
sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
sun_info.magic=ReadBlobMSBLong(image);
if (sun_info.magic == 0x59a66a95)
{
AcquireNextImage(image_info,image,exception);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while (sun_info.magic == 0x59a66a95);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*VAR_8;
int
VAR_9;
MagickBooleanType
VAR_10;
MagickSizeType
VAR_11;
register Quantum
*VAR_12;
register ssize_t
VAR_13,
VAR_14;
register unsigned char
*VAR_15;
size_t
VAR_16,
VAR_17,
VAR_18;
ssize_t
VAR_19,
VAR_20;
SUNInfo
VAR_21;
unsigned char
*VAR_22,
*VAR_23;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_24);
if (VAR_0->debug != VAR_25)
(void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_24);
VAR_8=AcquireImage(VAR_0,VAR_1);
VAR_10=OpenBlob(VAR_0,VAR_8,VAR_27,VAR_1);
if (VAR_10 == VAR_25)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
(void) ResetMagickMemory(&VAR_21,0,sizeof(VAR_21));
VAR_21.magic=ReadBlobMSBLong(VAR_8);
do
{
if (VAR_21.magic != 0x59a66a95)
ThrowReaderException(VAR_28,""ImproperImageHeader"");
VAR_21.width=ReadBlobMSBLong(VAR_8);
VAR_21.height=ReadBlobMSBLong(VAR_8);
VAR_21.depth=ReadBlobMSBLong(VAR_8);
VAR_21.length=ReadBlobMSBLong(VAR_8);
VAR_21.type=ReadBlobMSBLong(VAR_8);
VAR_21.maptype=ReadBlobMSBLong(VAR_8);
VAR_21.maplength=ReadBlobMSBLong(VAR_8);
VAR_17=VAR_21.height*VAR_21.width;
if ((VAR_21.height != 0) && (VAR_21.width != VAR_17/VAR_21.height))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.type != VAR_5) && (VAR_21.type != VAR_6) &&
(VAR_21.type != VAR_7))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.maptype == VAR_3) && (VAR_21.maplength != 0))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.depth == 0) || (VAR_21.depth > 32))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.maptype != VAR_3) && (VAR_21.maptype != VAR_2) &&
(VAR_21.maptype != VAR_4))
ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
VAR_8->columns=VAR_21.width;
VAR_8->rows=VAR_21.height;
VAR_8->depth=VAR_21.depth <= 8 ? VAR_21.depth :
VAR_30;
if (VAR_21.depth < 24)
{
size_t
VAR_31;
VAR_8->storage_class=VAR_32;
VAR_8->colors=VAR_21.maplength;
VAR_31=1;
if (VAR_21.maptype == VAR_3)
VAR_8->colors=VAR_31 << VAR_21.depth;
if (VAR_21.maptype == VAR_2)
VAR_8->colors=VAR_21.maplength/3;
}
switch (VAR_21.maptype)
{
case VAR_3:
{
if (VAR_21.depth < 24)
{
if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
}
break;
}
case VAR_2:
{
unsigned char
*VAR_34;
if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_34=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
sizeof(*VAR_34));
if (VAR_34 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
VAR_34[VAR_13]);
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
VAR_34[VAR_13]);
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
VAR_34[VAR_13]);
VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
break;
}
case VAR_4:
{
unsigned char
*VAR_34;
VAR_34=(unsigned char *) AcquireQuantumMemory(VAR_21.maplength,
sizeof(*VAR_34));
if (VAR_34 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_19=ReadBlob(VAR_8,VAR_21.maplength,VAR_34);
if (VAR_19 != (ssize_t) VAR_21.maplength)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
break;
}
default:
ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
}
VAR_8->alpha_trait=VAR_21.depth == 32 ? VAR_35 :
VAR_36;
VAR_8->columns=VAR_21.width;
VAR_8->rows=VAR_21.height;
if (VAR_0->ping != VAR_25)
{
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}
VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
if (VAR_10 == VAR_25)
return(DestroyImageList(VAR_8));
if ((VAR_21.length*sizeof(*VAR_22))/sizeof(*VAR_22) !=
VAR_21.length || !VAR_21.length)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_11=(MagickSizeType) VAR_8->columns*VAR_8->rows;
if ((VAR_21.type != VAR_6) && (VAR_21.depth >= 8) &&
((VAR_11*((VAR_21.depth+7)/8)) > VAR_21.length))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
VAR_22=(unsigned char *) AcquireQuantumMemory((size_t) VAR_21.length,
sizeof(*VAR_22));
if (VAR_22 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_19=(ssize_t) ReadBlob(VAR_8,VAR_21.length,VAR_22);
if (VAR_19 != (ssize_t) VAR_21.length)
ThrowReaderException(VAR_28,""UnableToReadImageData"");
VAR_23=VAR_22;
VAR_16=0;
if (VAR_21.type == VAR_6)
{
size_t
VAR_37;
VAR_37=VAR_21.height;
VAR_16=VAR_21.width*VAR_21.depth;
if ((VAR_37 == 0) || (VAR_21.width == 0) || (VAR_21.depth == 0) ||
((VAR_16/VAR_21.depth) != VAR_21.width))
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_16+=15;
VAR_16<<=1;
if ((VAR_16 >> 1) != (VAR_21.width*VAR_21.depth+15))
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_16>>=4;
VAR_23=(unsigned char *) AcquireQuantumMemory(VAR_37,
VAR_16*sizeof(*VAR_23));
if (VAR_23 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
(void) DecodeImage(VAR_22,VAR_21.length,VAR_23,VAR_16*
VAR_37);
VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
}
VAR_15=VAR_23;
if (VAR_21.depth == 1)
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
{
for (VAR_9=7; VAR_9 >= 0; VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((VAR_8->columns % 8) != 0)
{
for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
0x01),VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
else
if (VAR_8->storage_class == VAR_32)
{
if (VAR_16 == 0)
VAR_16=VAR_8->columns;
VAR_18=VAR_8->rows*(VAR_8->columns+VAR_8->columns % 2);
if (((VAR_21.type == VAR_6) &&
(VAR_18 > (VAR_16*VAR_8->rows))) ||
((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
ThrowReaderException(VAR_28,""UnableToReadImageData"");
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
SetPixelIndex(VAR_8,*VAR_15++,VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
if ((VAR_8->columns % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
}
else
{
size_t
VAR_39;
VAR_39=3;
if (VAR_8->alpha_trait != VAR_36)
VAR_39++;
if (VAR_16 == 0)
VAR_16=VAR_39*VAR_8->columns;
VAR_18=VAR_8->rows*(VAR_16+VAR_8->columns % 2);
if (((VAR_21.type == VAR_6) &&
(VAR_18 > (VAR_16*VAR_8->rows))) ||
((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
ThrowReaderException(VAR_28,""UnableToReadImageData"");
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
if (VAR_8->alpha_trait != VAR_36)
SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
if (VAR_21.type == VAR_5)
{
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
else
{
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
if (VAR_8->colors != 0)
{
SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
}
VAR_12+=GetPixelChannels(VAR_8);
}
if (((VAR_39*VAR_8->columns) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
}
if (VAR_8->storage_class == VAR_32)
(void) SyncImage(VAR_8,VAR_1);
VAR_23=(unsigned char *) RelinquishMagickMemory(VAR_23);
if (EOFBlob(VAR_8) != VAR_25)
{
ThrowFileException(VAR_1,VAR_28,""UnexpectedEndOfFile"",
VAR_8->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_21.magic=ReadBlobMSBLong(VAR_8);
if (VAR_21.magic == 0x59a66a95)
{
AcquireNextImage(VAR_0,VAR_8,VAR_1);
if (GetNextImageInList(VAR_8) == (Image *) NULL)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
VAR_8=SyncNextImageInList(VAR_8);
VAR_10=SetImageProgress(VAR_8,VAR_40,TellBlob(VAR_8),
GetBlobSize(VAR_8));
if (VAR_10 == VAR_25)
break;
}
} while (VAR_21.magic == 0x59a66a95);
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}",ImageMagick/78f82d9d1c2944725a279acd573a22168dc6e22a/sun.c/vul/before/0.json,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bytes_per_line,
    extent,
    length;

  ssize_t
    count,
    y;

  SUNInfo
    sun_info;

  unsigned char
    *sun_data,
    *sun_pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read SUN raster header.
  */
  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
  sun_info.magic=ReadBlobMSBLong(image);
  do
  {
    /*
      Verify SUN identifier.
    */
    if (sun_info.magic != 0x59a66a95)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    sun_info.width=ReadBlobMSBLong(image);
    sun_info.height=ReadBlobMSBLong(image);
    sun_info.depth=ReadBlobMSBLong(image);
    sun_info.length=ReadBlobMSBLong(image);
    sun_info.type=ReadBlobMSBLong(image);
    sun_info.maptype=ReadBlobMSBLong(image);
    sun_info.maplength=ReadBlobMSBLong(image);
    extent=sun_info.height*sun_info.width;
    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
        (sun_info.type != RT_FORMAT_RGB))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.depth == 0) || (sun_info.depth > 32))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
        (sun_info.maptype != RMT_RAW))
      ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    image->depth=sun_info.depth <= 8 ? sun_info.depth :
      MAGICKCORE_QUANTUM_DEPTH;
    if (sun_info.depth < 24)
      {
        size_t
          one;

        image->storage_class=PseudoClass;
        image->colors=sun_info.maplength;
        one=1;
        if (sun_info.maptype == RMT_NONE)
          image->colors=one << sun_info.depth;
        if (sun_info.maptype == RMT_EQUAL_RGB)
          image->colors=sun_info.maplength/3;
      }
    switch (sun_info.maptype)
    {
      case RMT_NONE:
      {
        if (sun_info.depth < 24)
          {
            /*
              Create linear color ramp.
            */
            if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case RMT_EQUAL_RGB:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      case RMT_RAW:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,sun_info.maplength,sun_colormap);
        if (count != (ssize_t) sun_info.maplength)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
      UndefinedPixelTrait;
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    if (image_info->ping != MagickFalse)
      {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
        sun_info.length || !sun_info.length)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    number_pixels=(MagickSizeType) image->columns*image->rows;
    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bytes_per_line=sun_info.width*sun_info.depth;
    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
    if (sun_data == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
    if (count != (ssize_t) sun_info.length)
      ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
    sun_pixels=sun_data;
    bytes_per_line=0;
    if (sun_info.type == RT_ENCODED)
      {
        size_t
          height;

        /*
          Read run-length encoded raster pixels.
        */
        height=sun_info.height;
        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
            ((bytes_per_line/sun_info.depth) != sun_info.width))
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bytes_per_line+=15;
        bytes_per_line<<=1;
        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bytes_per_line>>=4;
        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
          bytes_per_line*sizeof(*sun_pixels));
        if (sun_pixels == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
          height);
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
      }
    /*
      Convert SUN raster image to pixel packets.
    */
    p=sun_pixels;
    if (sun_info.depth == 1)
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=7; bit >= 0; bit--)
          {
            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
              q);
            q+=GetPixelChannels(image);
          }
          p++;
        }
        if ((image->columns % 8) != 0)
          {
            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
            {
              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
                0x01),q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
          p++;
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    else
      if (image->storage_class == PseudoClass)
        {
          if (bytes_per_line == 0)
            bytes_per_line=image->columns;
          length=image->rows*(image->columns+image->columns % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelIndex(image,*p++,q);
              q+=GetPixelChannels(image);
            }
            if ((image->columns % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
      else
        {
          size_t
            bytes_per_pixel;

          bytes_per_pixel=3;
          if (image->alpha_trait != UndefinedPixelTrait)
            bytes_per_pixel++;
          if (bytes_per_line == 0)
            bytes_per_line=bytes_per_pixel*image->columns;
          length=image->rows*(bytes_per_line+image->columns % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
              if (sun_info.type == RT_STANDARD)
                {
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                }
              else
                {
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                }
              if (image->colors != 0)
                {
                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelRed(image,q)].red),q);
                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelGreen(image,q)].green),q);
                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelBlue(image,q)].blue),q);
                }
              q+=GetPixelChannels(image);
            }
            if (((bytes_per_pixel*image->columns) % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    sun_info.magic=ReadBlobMSBLong(image);
    if (sun_info.magic == 0x59a66a95)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (sun_info.magic == 0x59a66a95);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *VAR_8;

  int
    VAR_9;

  MagickBooleanType
    VAR_10;

  MagickSizeType
    VAR_11;

  register Quantum
    *VAR_12;

  register ssize_t
    VAR_13,
    VAR_14;

  register unsigned char
    *VAR_15;

  size_t
    VAR_16,
    VAR_17,
    VAR_18;

  ssize_t
    VAR_19,
    VAR_20;

  SUNInfo
    VAR_21;

  unsigned char
    *VAR_22,
    *VAR_23;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_24);
  if (VAR_0->debug != VAR_25)
    (void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_24);
  VAR_8=AcquireImage(VAR_0,VAR_1);
  VAR_10=OpenBlob(VAR_0,VAR_8,VAR_27,VAR_1);
  if (VAR_10 == VAR_25)
    {
      VAR_8=DestroyImageList(VAR_8);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                           
    
  (void) ResetMagickMemory(&VAR_21,0,sizeof(VAR_21));
  VAR_21.magic=ReadBlobMSBLong(VAR_8);
  do
  {
    /* COMMENT_6 */
                            
      
    if (VAR_21.magic != 0x59a66a95)
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    VAR_21.width=ReadBlobMSBLong(VAR_8);
    VAR_21.height=ReadBlobMSBLong(VAR_8);
    VAR_21.depth=ReadBlobMSBLong(VAR_8);
    VAR_21.length=ReadBlobMSBLong(VAR_8);
    VAR_21.type=ReadBlobMSBLong(VAR_8);
    VAR_21.maptype=ReadBlobMSBLong(VAR_8);
    VAR_21.maplength=ReadBlobMSBLong(VAR_8);
    VAR_17=VAR_21.height*VAR_21.width;
    if ((VAR_21.height != 0) && (VAR_21.width != VAR_17/VAR_21.height))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.type != VAR_5) && (VAR_21.type != VAR_6) &&
        (VAR_21.type != VAR_7))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.maptype == VAR_3) && (VAR_21.maplength != 0))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.depth == 0) || (VAR_21.depth > 32))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.maptype != VAR_3) && (VAR_21.maptype != VAR_2) &&
        (VAR_21.maptype != VAR_4))
      ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
    VAR_8->columns=VAR_21.width;
    VAR_8->rows=VAR_21.height;
    VAR_8->depth=VAR_21.depth <= 8 ? VAR_21.depth :
      VAR_30;
    if (VAR_21.depth < 24)
      {
        size_t
          VAR_31;

        VAR_8->storage_class=VAR_32;
        VAR_8->colors=VAR_21.maplength;
        VAR_31=1;
        if (VAR_21.maptype == VAR_3)
          VAR_8->colors=VAR_31 << VAR_21.depth;
        if (VAR_21.maptype == VAR_2)
          VAR_8->colors=VAR_21.maplength/3;
      }
    switch (VAR_21.maptype)
    {
      case VAR_3:
      {
        if (VAR_21.depth < 24)
          {
            /* COMMENT_9 */
                                       
              
            if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
              ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
          }
        break;
      }
      case VAR_2:
      {
        unsigned char
          *VAR_34;

        /* COMMENT_12 */
                                   
          
        if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
          ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
        VAR_34=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
          sizeof(*VAR_34));
        if (VAR_34 == (unsigned char *) NULL)
          ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
            VAR_34[VAR_13]);
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
            VAR_34[VAR_13]);
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
            VAR_34[VAR_13]);
        VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
        break;
      }
      case VAR_4:
      {
        unsigned char
          *VAR_34;

        /* COMMENT_15 */
                                   
          
        VAR_34=(unsigned char *) AcquireQuantumMemory(VAR_21.maplength,
          sizeof(*VAR_34));
        if (VAR_34 == (unsigned char *) NULL)
          ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
        VAR_19=ReadBlob(VAR_8,VAR_21.maplength,VAR_34);
        if (VAR_19 != (ssize_t) VAR_21.maplength)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
        break;
      }
      default:
        ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
    }
    VAR_8->alpha_trait=VAR_21.depth == 32 ? VAR_35 :
      VAR_36;
    VAR_8->columns=VAR_21.width;
    VAR_8->rows=VAR_21.height;
    if (VAR_0->ping != VAR_25)
      {
        (void) CloseBlob(VAR_8);
        return(GetFirstImageInList(VAR_8));
      }
    VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
    if (VAR_10 == VAR_25)
      return(DestroyImageList(VAR_8));
    if ((VAR_21.length*sizeof(*VAR_22))/sizeof(*VAR_22) !=
        VAR_21.length || !VAR_21.length)
      ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
    VAR_11=(MagickSizeType) VAR_8->columns*VAR_8->rows;
    if ((VAR_21.type != VAR_6) && (VAR_21.depth >= 8) &&
        ((VAR_11*((VAR_21.depth+7)/8)) > VAR_21.length))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    VAR_16=VAR_21.width*VAR_21.depth;
    VAR_22=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      VAR_21.length,VAR_16*VAR_21.width),sizeof(*VAR_22));
    if (VAR_22 == (unsigned char *) NULL)
      ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
    VAR_19=(ssize_t) ReadBlob(VAR_8,VAR_21.length,VAR_22);
    if (VAR_19 != (ssize_t) VAR_21.length)
      ThrowReaderException(VAR_28,""UnableToReadImageData"");
    VAR_23=VAR_22;
    VAR_16=0;
    if (VAR_21.type == VAR_6)
      {
        size_t
          VAR_37;

        /* COMMENT_18 */
                                                
          
        VAR_37=VAR_21.height;
        if ((VAR_37 == 0) || (VAR_21.width == 0) || (VAR_21.depth == 0) ||
            ((VAR_16/VAR_21.depth) != VAR_21.width))
          ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
        VAR_16+=15;
        VAR_16<<=1;
        if ((VAR_16 >> 1) != (VAR_21.width*VAR_21.depth+15))
          ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
        VAR_16>>=4;
        VAR_23=(unsigned char *) AcquireQuantumMemory(VAR_37,
          VAR_16*sizeof(*VAR_23));
        if (VAR_23 == (unsigned char *) NULL)
          ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
        (void) DecodeImage(VAR_22,VAR_21.length,VAR_23,VAR_16*
          VAR_37);
        VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
      }
    /* COMMENT_21 */
                                                
      
    VAR_15=VAR_23;
    if (VAR_21.depth == 1)
      for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
      {
        VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
        if (VAR_12 == (Quantum *) NULL)
          break;
        for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
        {
          for (VAR_9=7; VAR_9 >= 0; VAR_9--)
          {
            SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
              VAR_12);
            VAR_12+=GetPixelChannels(VAR_8);
          }
          VAR_15++;
        }
        if ((VAR_8->columns % 8) != 0)
          {
            for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
            {
              SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
                0x01),VAR_12);
              VAR_12+=GetPixelChannels(VAR_8);
            }
            VAR_15++;
          }
        if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
          VAR_15++;
        if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
          break;
        if (VAR_8->previous == (Image *) NULL)
          {
            VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
              VAR_8->rows);
            if (VAR_10 == VAR_25)
              break;
          }
      }
    else
      if (VAR_8->storage_class == VAR_32)
        {
          if (VAR_16 == 0)
            VAR_16=VAR_8->columns;
          VAR_18=VAR_8->rows*(VAR_8->columns+VAR_8->columns % 2);
          if (((VAR_21.type == VAR_6) &&
               (VAR_18 > (VAR_16*VAR_8->rows))) ||
              ((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
            ThrowReaderException(VAR_28,""UnableToReadImageData"");
          for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              SetPixelIndex(VAR_8,*VAR_15++,VAR_12);
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if ((VAR_8->columns % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
                VAR_8->rows);
                if (VAR_10 == VAR_25)
                  break;
              }
          }
        }
      else
        {
          size_t
            VAR_39;

          VAR_39=3;
          if (VAR_8->alpha_trait != VAR_36)
            VAR_39++;
          if (VAR_16 == 0)
            VAR_16=VAR_39*VAR_8->columns;
          VAR_18=VAR_8->rows*(VAR_16+VAR_8->columns % 2);
          if (((VAR_21.type == VAR_6) &&
               (VAR_18 > (VAR_16*VAR_8->rows))) ||
              ((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
            ThrowReaderException(VAR_28,""UnableToReadImageData"");
          for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              if (VAR_8->alpha_trait != VAR_36)
                SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
              if (VAR_21.type == VAR_5)
                {
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              else
                {
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              if (VAR_8->colors != 0)
                {
                  SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
                  SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
                  SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
                }
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if (((VAR_39*VAR_8->columns) % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
                VAR_8->rows);
                if (VAR_10 == VAR_25)
                  break;
              }
          }
        }
    if (VAR_8->storage_class == VAR_32)
      (void) SyncImage(VAR_8,VAR_1);
    VAR_23=(unsigned char *) RelinquishMagickMemory(VAR_23);
    if (EOFBlob(VAR_8) != VAR_25)
      {
        ThrowFileException(VAR_1,VAR_28,""UnexpectedEndOfFile"",
          VAR_8->filename);
        break;
      }
    /* COMMENT_24 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_21.magic=ReadBlobMSBLong(VAR_8);
    if (VAR_21.magic == 0x59a66a95)
      {
        /* COMMENT_27 */
                                        
          
        AcquireNextImage(VAR_0,VAR_8,VAR_1);
        if (GetNextImageInList(VAR_8) == (Image *) NULL)
          {
            VAR_8=DestroyImageList(VAR_8);
            return((Image *) NULL);
          }
        VAR_8=SyncNextImageInList(VAR_8);
        VAR_10=SetImageProgress(VAR_8,VAR_40,TellBlob(VAR_8),
          GetBlobSize(VAR_8));
        if (VAR_10 == VAR_25)
          break;
      }
  } while (VAR_21.magic == 0x59a66a95);
  (void) CloseBlob(VAR_8);
  return(GetFirstImageInList(VAR_8));
}",ImageMagick/78f82d9d1c2944725a279acd573a22168dc6e22a/sun.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -213,8 +213,9 @@
     if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
         ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
-    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) sun_info.length,
-      sizeof(*sun_data));
+    bytes_per_line=sun_info.width*sun_info.depth;
+    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
+      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
     if (sun_data == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
@@ -231,7 +232,6 @@
           Read run-length encoded raster pixels.
         */
         height=sun_info.height;
-        bytes_per_line=sun_info.width*sun_info.depth;
         if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
             ((bytes_per_line/sun_info.depth) != sun_info.width))
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");","{'deleted_lines': ['    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) sun_info.length,', '      sizeof(*sun_data));', '        bytes_per_line=sun_info.width*sun_info.depth;'], 'added_lines': ['    bytes_per_line=sun_info.width*sun_info.depth;', '    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(', '      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));']}",True,Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file.,6.5,MEDIUM,1,valid,2015-01-06T12:13:31Z,1
CVE-2015-8957,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=26848,bd96074b254c6607a0f7731e59f923ad19d5a46d,https://github.com/ImageMagick/ImageMagick/commit/bd96074b254c6607a0f7731e59f923ad19d5a46d,coders/sun.c,ReadSUNImage,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*image;
int
bit;
MagickBooleanType
status;
MagickSizeType
number_pixels;
register Quantum
*q;
register ssize_t
i,
x;
register unsigned char
*p;
size_t
bytes_per_line,
extent,
length;
ssize_t
count,
y;
SUNInfo
sun_info;
unsigned char
*sun_data,
*sun_pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
sun_info.magic=ReadBlobMSBLong(image);
do
{
if (sun_info.magic != 0x59a66a95)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
sun_info.width=ReadBlobMSBLong(image);
sun_info.height=ReadBlobMSBLong(image);
sun_info.depth=ReadBlobMSBLong(image);
sun_info.length=ReadBlobMSBLong(image);
sun_info.type=ReadBlobMSBLong(image);
sun_info.maptype=ReadBlobMSBLong(image);
sun_info.maplength=ReadBlobMSBLong(image);
extent=sun_info.height*sun_info.width;
if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
(sun_info.type != RT_FORMAT_RGB))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.depth == 0) || (sun_info.depth > 32))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
(sun_info.maptype != RMT_RAW))
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
image->columns=sun_info.width;
image->rows=sun_info.height;
image->depth=sun_info.depth <= 8 ? sun_info.depth :
MAGICKCORE_QUANTUM_DEPTH;
if (sun_info.depth < 24)
{
size_t
one;
image->storage_class=PseudoClass;
image->colors=sun_info.maplength;
one=1;
if (sun_info.maptype == RMT_NONE)
image->colors=one << sun_info.depth;
if (sun_info.maptype == RMT_EQUAL_RGB)
image->colors=sun_info.maplength/3;
}
switch (sun_info.maptype)
{
case RMT_NONE:
{
if (sun_info.depth < 24)
{
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
break;
}
case RMT_EQUAL_RGB:
{
unsigned char
*sun_colormap;
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
case RMT_RAW:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,sun_info.maplength,sun_colormap);
if (count != (ssize_t) sun_info.maplength)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
default:
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
}
image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
UndefinedPixelTrait;
image->columns=sun_info.width;
image->rows=sun_info.height;
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
sun_info.length || !sun_info.length)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
number_pixels=(MagickSizeType) image->columns*image->rows;
if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
bytes_per_line=sun_info.width*sun_info.depth;
sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
if (sun_data == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
if (count != (ssize_t) sun_info.length)
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
sun_pixels=sun_data;
bytes_per_line=0;
if (sun_info.type == RT_ENCODED)
{
size_t
height;
height=sun_info.height;
if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
((bytes_per_line/sun_info.depth) != sun_info.width))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
bytes_per_line+=15;
bytes_per_line<<=1;
if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
bytes_per_line>>=4;
sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
bytes_per_line*sizeof(*sun_pixels));
if (sun_pixels == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
height);
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
}
p=sun_pixels;
if (sun_info.depth == 1)
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=7; bit >= 0; bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
q);
q+=GetPixelChannels(image);
}
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
0x01),q);
q+=GetPixelChannels(image);
}
p++;
}
if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
else
if (image->storage_class == PseudoClass)
{
if (bytes_per_line == 0)
bytes_per_line=image->columns;
length=image->rows*(image->columns+image->columns % 2);
if (((sun_info.type == RT_ENCODED) &&
(length > (bytes_per_line*image->rows))) ||
((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelIndex(image,*p++,q);
q+=GetPixelChannels(image);
}
if ((image->columns % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
{
size_t
bytes_per_pixel;
bytes_per_pixel=3;
if (image->alpha_trait != UndefinedPixelTrait)
bytes_per_pixel++;
if (bytes_per_line == 0)
bytes_per_line=bytes_per_pixel*image->columns;
length=image->rows*(bytes_per_line+image->columns % 2);
if (((sun_info.type == RT_ENCODED) &&
(length > (bytes_per_line*image->rows))) ||
((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (image->alpha_trait != UndefinedPixelTrait)
SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
if (sun_info.type == RT_STANDARD)
{
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
}
else
{
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
}
if (image->colors != 0)
{
SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelRed(image,q)].red),q);
SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelGreen(image,q)].green),q);
SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelBlue(image,q)].blue),q);
}
q+=GetPixelChannels(image);
}
if (((bytes_per_pixel*image->columns) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
if (image->storage_class == PseudoClass)
(void) SyncImage(image,exception);
sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
sun_info.magic=ReadBlobMSBLong(image);
if (sun_info.magic == 0x59a66a95)
{
AcquireNextImage(image_info,image,exception);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while (sun_info.magic == 0x59a66a95);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*VAR_8;
int
VAR_9;
MagickBooleanType
VAR_10;
MagickSizeType
VAR_11;
register Quantum
*VAR_12;
register ssize_t
VAR_13,
VAR_14;
register unsigned char
*VAR_15;
size_t
VAR_16,
VAR_17,
VAR_18;
ssize_t
VAR_19,
VAR_20;
SUNInfo
VAR_21;
unsigned char
*VAR_22,
*VAR_23;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_24);
if (VAR_0->debug != VAR_25)
(void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_24);
VAR_8=AcquireImage(VAR_0,VAR_1);
VAR_10=OpenBlob(VAR_0,VAR_8,VAR_27,VAR_1);
if (VAR_10 == VAR_25)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
(void) ResetMagickMemory(&VAR_21,0,sizeof(VAR_21));
VAR_21.magic=ReadBlobMSBLong(VAR_8);
do
{
if (VAR_21.magic != 0x59a66a95)
ThrowReaderException(VAR_28,""ImproperImageHeader"");
VAR_21.width=ReadBlobMSBLong(VAR_8);
VAR_21.height=ReadBlobMSBLong(VAR_8);
VAR_21.depth=ReadBlobMSBLong(VAR_8);
VAR_21.length=ReadBlobMSBLong(VAR_8);
VAR_21.type=ReadBlobMSBLong(VAR_8);
VAR_21.maptype=ReadBlobMSBLong(VAR_8);
VAR_21.maplength=ReadBlobMSBLong(VAR_8);
VAR_17=VAR_21.height*VAR_21.width;
if ((VAR_21.height != 0) && (VAR_21.width != VAR_17/VAR_21.height))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.type != VAR_5) && (VAR_21.type != VAR_6) &&
(VAR_21.type != VAR_7))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.maptype == VAR_3) && (VAR_21.maplength != 0))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.depth == 0) || (VAR_21.depth > 32))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.maptype != VAR_3) && (VAR_21.maptype != VAR_2) &&
(VAR_21.maptype != VAR_4))
ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
VAR_8->columns=VAR_21.width;
VAR_8->rows=VAR_21.height;
VAR_8->depth=VAR_21.depth <= 8 ? VAR_21.depth :
VAR_30;
if (VAR_21.depth < 24)
{
size_t
VAR_31;
VAR_8->storage_class=VAR_32;
VAR_8->colors=VAR_21.maplength;
VAR_31=1;
if (VAR_21.maptype == VAR_3)
VAR_8->colors=VAR_31 << VAR_21.depth;
if (VAR_21.maptype == VAR_2)
VAR_8->colors=VAR_21.maplength/3;
}
switch (VAR_21.maptype)
{
case VAR_3:
{
if (VAR_21.depth < 24)
{
if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
}
break;
}
case VAR_2:
{
unsigned char
*VAR_34;
if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_34=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
sizeof(*VAR_34));
if (VAR_34 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
VAR_34[VAR_13]);
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
VAR_34[VAR_13]);
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_34);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
VAR_34[VAR_13]);
VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
break;
}
case VAR_4:
{
unsigned char
*VAR_34;
VAR_34=(unsigned char *) AcquireQuantumMemory(VAR_21.maplength,
sizeof(*VAR_34));
if (VAR_34 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_19=ReadBlob(VAR_8,VAR_21.maplength,VAR_34);
if (VAR_19 != (ssize_t) VAR_21.maplength)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
VAR_34=(unsigned char *) RelinquishMagickMemory(VAR_34);
break;
}
default:
ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
}
VAR_8->alpha_trait=VAR_21.depth == 32 ? VAR_35 :
VAR_36;
VAR_8->columns=VAR_21.width;
VAR_8->rows=VAR_21.height;
if (VAR_0->ping != VAR_25)
{
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}
VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
if (VAR_10 == VAR_25)
return(DestroyImageList(VAR_8));
if ((VAR_21.length*sizeof(*VAR_22))/sizeof(*VAR_22) !=
VAR_21.length || !VAR_21.length)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_11=(MagickSizeType) VAR_8->columns*VAR_8->rows;
if ((VAR_21.type != VAR_6) && (VAR_21.depth >= 8) &&
((VAR_11*((VAR_21.depth+7)/8)) > VAR_21.length))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
VAR_16=VAR_21.width*VAR_21.depth;
VAR_22=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
VAR_21.length,VAR_16*VAR_21.width),sizeof(*VAR_22));
if (VAR_22 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_19=(ssize_t) ReadBlob(VAR_8,VAR_21.length,VAR_22);
if (VAR_19 != (ssize_t) VAR_21.length)
ThrowReaderException(VAR_28,""UnableToReadImageData"");
VAR_23=VAR_22;
VAR_16=0;
if (VAR_21.type == VAR_6)
{
size_t
VAR_37;
VAR_37=VAR_21.height;
if ((VAR_37 == 0) || (VAR_21.width == 0) || (VAR_21.depth == 0) ||
((VAR_16/VAR_21.depth) != VAR_21.width))
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_16+=15;
VAR_16<<=1;
if ((VAR_16 >> 1) != (VAR_21.width*VAR_21.depth+15))
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
VAR_16>>=4;
VAR_23=(unsigned char *) AcquireQuantumMemory(VAR_37,
VAR_16*sizeof(*VAR_23));
if (VAR_23 == (unsigned char *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
(void) DecodeImage(VAR_22,VAR_21.length,VAR_23,VAR_16*
VAR_37);
VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
}
VAR_15=VAR_23;
if (VAR_21.depth == 1)
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
{
for (VAR_9=7; VAR_9 >= 0; VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((VAR_8->columns % 8) != 0)
{
for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
0x01),VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
else
if (VAR_8->storage_class == VAR_32)
{
if (VAR_16 == 0)
VAR_16=VAR_8->columns;
VAR_18=VAR_8->rows*(VAR_8->columns+VAR_8->columns % 2);
if (((VAR_21.type == VAR_6) &&
(VAR_18 > (VAR_16*VAR_8->rows))) ||
((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
ThrowReaderException(VAR_28,""UnableToReadImageData"");
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
SetPixelIndex(VAR_8,*VAR_15++,VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
if ((VAR_8->columns % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
}
else
{
size_t
VAR_39;
VAR_39=3;
if (VAR_8->alpha_trait != VAR_36)
VAR_39++;
if (VAR_16 == 0)
VAR_16=VAR_39*VAR_8->columns;
VAR_18=VAR_8->rows*(VAR_16+VAR_8->columns % 2);
if (((VAR_21.type == VAR_6) &&
(VAR_18 > (VAR_16*VAR_8->rows))) ||
((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
ThrowReaderException(VAR_28,""UnableToReadImageData"");
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
if (VAR_8->alpha_trait != VAR_36)
SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
if (VAR_21.type == VAR_5)
{
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
else
{
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
if (VAR_8->colors != 0)
{
SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
}
VAR_12+=GetPixelChannels(VAR_8);
}
if (((VAR_39*VAR_8->columns) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
}
if (VAR_8->storage_class == VAR_32)
(void) SyncImage(VAR_8,VAR_1);
VAR_23=(unsigned char *) RelinquishMagickMemory(VAR_23);
if (EOFBlob(VAR_8) != VAR_25)
{
ThrowFileException(VAR_1,VAR_28,""UnexpectedEndOfFile"",
VAR_8->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_21.magic=ReadBlobMSBLong(VAR_8);
if (VAR_21.magic == 0x59a66a95)
{
AcquireNextImage(VAR_0,VAR_8,VAR_1);
if (GetNextImageInList(VAR_8) == (Image *) NULL)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
VAR_8=SyncNextImageInList(VAR_8);
VAR_10=SetImageProgress(VAR_8,VAR_40,TellBlob(VAR_8),
GetBlobSize(VAR_8));
if (VAR_10 == VAR_25)
break;
}
} while (VAR_21.magic == 0x59a66a95);
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}",ImageMagick/bd96074b254c6607a0f7731e59f923ad19d5a46d/sun.c/vul/before/0.json,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bytes_per_line,
    extent,
    length;

  ssize_t
    count,
    y;

  SUNInfo
    sun_info;

  unsigned char
    *sun_data,
    *sun_pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read SUN raster header.
  */
  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
  sun_info.magic=ReadBlobMSBLong(image);
  do
  {
    /*
      Verify SUN identifier.
    */
    if (sun_info.magic != 0x59a66a95)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    sun_info.width=ReadBlobMSBLong(image);
    sun_info.height=ReadBlobMSBLong(image);
    sun_info.depth=ReadBlobMSBLong(image);
    sun_info.length=ReadBlobMSBLong(image);
    sun_info.type=ReadBlobMSBLong(image);
    sun_info.maptype=ReadBlobMSBLong(image);
    sun_info.maplength=ReadBlobMSBLong(image);
    extent=sun_info.height*sun_info.width;
    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
        (sun_info.type != RT_FORMAT_RGB))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.depth == 0) || (sun_info.depth > 32))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
        (sun_info.maptype != RMT_RAW))
      ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    image->depth=sun_info.depth <= 8 ? sun_info.depth :
      MAGICKCORE_QUANTUM_DEPTH;
    if (sun_info.depth < 24)
      {
        size_t
          one;

        image->colors=sun_info.maplength;
        one=1;
        if (sun_info.maptype == RMT_NONE)
          image->colors=one << sun_info.depth;
        if (sun_info.maptype == RMT_EQUAL_RGB)
          image->colors=sun_info.maplength/3;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    switch (sun_info.maptype)
    {
      case RMT_EQUAL_RGB:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      case RMT_RAW:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,sun_info.maplength,sun_colormap);
        if (count != (ssize_t) sun_info.maplength)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
      UndefinedPixelTrait;
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    if (image_info->ping != MagickFalse)
      {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
        sun_info.length || !sun_info.length)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    number_pixels=(MagickSizeType) image->columns*image->rows;
    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bytes_per_line=sun_info.width*sun_info.depth;
    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
    if (sun_data == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
    if (count != (ssize_t) sun_info.length)
      ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
    sun_pixels=sun_data;
    bytes_per_line=0;
    if (sun_info.type == RT_ENCODED)
      {
        size_t
          height;

        /*
          Read run-length encoded raster pixels.
        */
        height=sun_info.height;
        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
            ((bytes_per_line/sun_info.depth) != sun_info.width))
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bytes_per_line+=15;
        bytes_per_line<<=1;
        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bytes_per_line>>=4;
        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
          bytes_per_line*sizeof(*sun_pixels));
        if (sun_pixels == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
          height);
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
      }
    /*
      Convert SUN raster image to pixel packets.
    */
    p=sun_pixels;
    if (sun_info.depth == 1)
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=7; bit >= 0; bit--)
          {
            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
              q);
            q+=GetPixelChannels(image);
          }
          p++;
        }
        if ((image->columns % 8) != 0)
          {
            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
            {
              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
                0x01),q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
          p++;
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    else
      if (image->storage_class == PseudoClass)
        {
          if (bytes_per_line == 0)
            bytes_per_line=image->columns;
          length=image->rows*(image->columns+image->columns % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelIndex(image,*p++,q);
              q+=GetPixelChannels(image);
            }
            if ((image->columns % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
      else
        {
          size_t
            bytes_per_pixel;

          bytes_per_pixel=3;
          if (image->alpha_trait != UndefinedPixelTrait)
            bytes_per_pixel++;
          if (bytes_per_line == 0)
            bytes_per_line=bytes_per_pixel*image->columns;
          length=image->rows*(bytes_per_line+image->columns % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
              if (sun_info.type == RT_STANDARD)
                {
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                }
              else
                {
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                }
              if (image->colors != 0)
                {
                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelRed(image,q)].red),q);
                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelGreen(image,q)].green),q);
                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelBlue(image,q)].blue),q);
                }
              q+=GetPixelChannels(image);
            }
            if (((bytes_per_pixel*image->columns) % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    sun_info.magic=ReadBlobMSBLong(image);
    if (sun_info.magic == 0x59a66a95)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (sun_info.magic == 0x59a66a95);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *VAR_8;

  int
    VAR_9;

  MagickBooleanType
    VAR_10;

  MagickSizeType
    VAR_11;

  register Quantum
    *VAR_12;

  register ssize_t
    VAR_13,
    VAR_14;

  register unsigned char
    *VAR_15;

  size_t
    VAR_16,
    VAR_17,
    VAR_18;

  ssize_t
    VAR_19,
    VAR_20;

  SUNInfo
    VAR_21;

  unsigned char
    *VAR_22,
    *VAR_23;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_24);
  if (VAR_0->debug != VAR_25)
    (void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_24);
  VAR_8=AcquireImage(VAR_0,VAR_1);
  VAR_10=OpenBlob(VAR_0,VAR_8,VAR_27,VAR_1);
  if (VAR_10 == VAR_25)
    {
      VAR_8=DestroyImageList(VAR_8);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                           
    
  (void) ResetMagickMemory(&VAR_21,0,sizeof(VAR_21));
  VAR_21.magic=ReadBlobMSBLong(VAR_8);
  do
  {
    /* COMMENT_6 */
                            
      
    if (VAR_21.magic != 0x59a66a95)
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    VAR_21.width=ReadBlobMSBLong(VAR_8);
    VAR_21.height=ReadBlobMSBLong(VAR_8);
    VAR_21.depth=ReadBlobMSBLong(VAR_8);
    VAR_21.length=ReadBlobMSBLong(VAR_8);
    VAR_21.type=ReadBlobMSBLong(VAR_8);
    VAR_21.maptype=ReadBlobMSBLong(VAR_8);
    VAR_21.maplength=ReadBlobMSBLong(VAR_8);
    VAR_17=VAR_21.height*VAR_21.width;
    if ((VAR_21.height != 0) && (VAR_21.width != VAR_17/VAR_21.height))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.type != VAR_5) && (VAR_21.type != VAR_6) &&
        (VAR_21.type != VAR_7))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.maptype == VAR_3) && (VAR_21.maplength != 0))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.depth == 0) || (VAR_21.depth > 32))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.maptype != VAR_3) && (VAR_21.maptype != VAR_2) &&
        (VAR_21.maptype != VAR_4))
      ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
    VAR_8->columns=VAR_21.width;
    VAR_8->rows=VAR_21.height;
    VAR_8->depth=VAR_21.depth <= 8 ? VAR_21.depth :
      VAR_30;
    if (VAR_21.depth < 24)
      {
        size_t
          VAR_31;

        VAR_8->colors=VAR_21.maplength;
        VAR_31=1;
        if (VAR_21.maptype == VAR_3)
          VAR_8->colors=VAR_31 << VAR_21.depth;
        if (VAR_21.maptype == VAR_2)
          VAR_8->colors=VAR_21.maplength/3;
        if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
      }
    switch (VAR_21.maptype)
    {
      case VAR_2:
      {
        unsigned char
          *VAR_33;

        /* COMMENT_9 */
                                   
          
        VAR_33=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
          sizeof(*VAR_33));
        if (VAR_33 == (unsigned char *) NULL)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
            VAR_33[VAR_13]);
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
            VAR_33[VAR_13]);
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
            VAR_33[VAR_13]);
        VAR_33=(unsigned char *) RelinquishMagickMemory(VAR_33);
        break;
      }
      case VAR_4:
      {
        unsigned char
          *VAR_33;

        /* COMMENT_12 */
                                   
          
        VAR_33=(unsigned char *) AcquireQuantumMemory(VAR_21.maplength,
          sizeof(*VAR_33));
        if (VAR_33 == (unsigned char *) NULL)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_19=ReadBlob(VAR_8,VAR_21.maplength,VAR_33);
        if (VAR_19 != (ssize_t) VAR_21.maplength)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        VAR_33=(unsigned char *) RelinquishMagickMemory(VAR_33);
        break;
      }
      default:
        ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
    }
    VAR_8->alpha_trait=VAR_21.depth == 32 ? VAR_34 :
      VAR_35;
    VAR_8->columns=VAR_21.width;
    VAR_8->rows=VAR_21.height;
    if (VAR_0->ping != VAR_25)
      {
        (void) CloseBlob(VAR_8);
        return(GetFirstImageInList(VAR_8));
      }
    VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
    if (VAR_10 == VAR_25)
      return(DestroyImageList(VAR_8));
    if ((VAR_21.length*sizeof(*VAR_22))/sizeof(*VAR_22) !=
        VAR_21.length || !VAR_21.length)
      ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
    VAR_11=(MagickSizeType) VAR_8->columns*VAR_8->rows;
    if ((VAR_21.type != VAR_6) && (VAR_21.depth >= 8) &&
        ((VAR_11*((VAR_21.depth+7)/8)) > VAR_21.length))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    VAR_16=VAR_21.width*VAR_21.depth;
    VAR_22=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      VAR_21.length,VAR_16*VAR_21.width),sizeof(*VAR_22));
    if (VAR_22 == (unsigned char *) NULL)
      ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
    VAR_19=(ssize_t) ReadBlob(VAR_8,VAR_21.length,VAR_22);
    if (VAR_19 != (ssize_t) VAR_21.length)
      ThrowReaderException(VAR_28,""UnableToReadImageData"");
    VAR_23=VAR_22;
    VAR_16=0;
    if (VAR_21.type == VAR_6)
      {
        size_t
          VAR_36;

        /* COMMENT_15 */
                                                
          
        VAR_36=VAR_21.height;
        if ((VAR_36 == 0) || (VAR_21.width == 0) || (VAR_21.depth == 0) ||
            ((VAR_16/VAR_21.depth) != VAR_21.width))
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_16+=15;
        VAR_16<<=1;
        if ((VAR_16 >> 1) != (VAR_21.width*VAR_21.depth+15))
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_16>>=4;
        VAR_23=(unsigned char *) AcquireQuantumMemory(VAR_36,
          VAR_16*sizeof(*VAR_23));
        if (VAR_23 == (unsigned char *) NULL)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        (void) DecodeImage(VAR_22,VAR_21.length,VAR_23,VAR_16*
          VAR_36);
        VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
      }
    /* COMMENT_18 */
                                                
      
    VAR_15=VAR_23;
    if (VAR_21.depth == 1)
      for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
      {
        VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
        if (VAR_12 == (Quantum *) NULL)
          break;
        for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
        {
          for (VAR_9=7; VAR_9 >= 0; VAR_9--)
          {
            SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
              VAR_12);
            VAR_12+=GetPixelChannels(VAR_8);
          }
          VAR_15++;
        }
        if ((VAR_8->columns % 8) != 0)
          {
            for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
            {
              SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
                0x01),VAR_12);
              VAR_12+=GetPixelChannels(VAR_8);
            }
            VAR_15++;
          }
        if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
          VAR_15++;
        if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
          break;
        if (VAR_8->previous == (Image *) NULL)
          {
            VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
              VAR_8->rows);
            if (VAR_10 == VAR_25)
              break;
          }
      }
    else
      if (VAR_8->storage_class == VAR_38)
        {
          if (VAR_16 == 0)
            VAR_16=VAR_8->columns;
          VAR_18=VAR_8->rows*(VAR_8->columns+VAR_8->columns % 2);
          if (((VAR_21.type == VAR_6) &&
               (VAR_18 > (VAR_16*VAR_8->rows))) ||
              ((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
            ThrowReaderException(VAR_28,""UnableToReadImageData"");
          for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              SetPixelIndex(VAR_8,*VAR_15++,VAR_12);
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if ((VAR_8->columns % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
                VAR_8->rows);
                if (VAR_10 == VAR_25)
                  break;
              }
          }
        }
      else
        {
          size_t
            VAR_39;

          VAR_39=3;
          if (VAR_8->alpha_trait != VAR_35)
            VAR_39++;
          if (VAR_16 == 0)
            VAR_16=VAR_39*VAR_8->columns;
          VAR_18=VAR_8->rows*(VAR_16+VAR_8->columns % 2);
          if (((VAR_21.type == VAR_6) &&
               (VAR_18 > (VAR_16*VAR_8->rows))) ||
              ((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
            ThrowReaderException(VAR_28,""UnableToReadImageData"");
          for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              if (VAR_8->alpha_trait != VAR_35)
                SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
              if (VAR_21.type == VAR_5)
                {
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              else
                {
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              if (VAR_8->colors != 0)
                {
                  SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
                  SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
                  SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
                }
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if (((VAR_39*VAR_8->columns) % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
                VAR_8->rows);
                if (VAR_10 == VAR_25)
                  break;
              }
          }
        }
    if (VAR_8->storage_class == VAR_38)
      (void) SyncImage(VAR_8,VAR_1);
    VAR_23=(unsigned char *) RelinquishMagickMemory(VAR_23);
    if (EOFBlob(VAR_8) != VAR_25)
      {
        ThrowFileException(VAR_1,VAR_28,""UnexpectedEndOfFile"",
          VAR_8->filename);
        break;
      }
    /* COMMENT_21 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_21.magic=ReadBlobMSBLong(VAR_8);
    if (VAR_21.magic == 0x59a66a95)
      {
        /* COMMENT_24 */
                                        
          
        AcquireNextImage(VAR_0,VAR_8,VAR_1);
        if (GetNextImageInList(VAR_8) == (Image *) NULL)
          {
            VAR_8=DestroyImageList(VAR_8);
            return((Image *) NULL);
          }
        VAR_8=SyncNextImageInList(VAR_8);
        VAR_10=SetImageProgress(VAR_8,VAR_40,TellBlob(VAR_8),
          GetBlobSize(VAR_8));
        if (VAR_10 == VAR_25)
          break;
      }
  } while (VAR_21.magic == 0x59a66a95);
  (void) CloseBlob(VAR_8);
  return(GetFirstImageInList(VAR_8));
}",ImageMagick/bd96074b254c6607a0f7731e59f923ad19d5a46d/sun.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -116,28 +116,17 @@
         size_t
           one;
 
-        image->storage_class=PseudoClass;
         image->colors=sun_info.maplength;
         one=1;
         if (sun_info.maptype == RMT_NONE)
           image->colors=one << sun_info.depth;
         if (sun_info.maptype == RMT_EQUAL_RGB)
           image->colors=sun_info.maplength/3;
+        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
+          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     switch (sun_info.maptype)
     {
-      case RMT_NONE:
-      {
-        if (sun_info.depth < 24)
-          {
-            /*
-              Create linear color ramp.
-            */
-            if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
-              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
-          }
-        break;
-      }
       case RMT_EQUAL_RGB:
       {
         unsigned char
@@ -146,8 +135,6 @@
         /*
           Read SUN raster colormap.
         */
-        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
-          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
           sizeof(*sun_colormap));
         if (sun_colormap == (unsigned char *) NULL)","{'deleted_lines': ['        image->storage_class=PseudoClass;', '      case RMT_NONE:', '      {', '        if (sun_info.depth < 24)', '          {', '            /*', '              Create linear color ramp.', '            */', '            if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)', '              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");', '          }', '        break;', '      }', '        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)', '          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");'], 'added_lines': ['        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)', '          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");']}",True,Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file.,6.5,MEDIUM,1,valid,2015-01-08T15:44:24Z,1
CVE-2015-8957,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,,450bd716ed3b9186dd10f9e60f630a3d9eeea2a4,https://github.com/ImageMagick/ImageMagick/commit/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4,coders/sun.c,ReadSUNImage,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*image;
int
bit;
MagickBooleanType
status;
MagickSizeType
number_pixels;
register Quantum
*q;
register ssize_t
i,
x;
register unsigned char
*p;
size_t
bytes_per_line,
extent,
length;
ssize_t
count,
y;
SUNInfo
sun_info;
unsigned char
*sun_data,
*sun_pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
sun_info.magic=ReadBlobMSBLong(image);
do
{
if (sun_info.magic != 0x59a66a95)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
sun_info.width=ReadBlobMSBLong(image);
sun_info.height=ReadBlobMSBLong(image);
sun_info.depth=ReadBlobMSBLong(image);
sun_info.length=ReadBlobMSBLong(image);
sun_info.type=ReadBlobMSBLong(image);
sun_info.maptype=ReadBlobMSBLong(image);
sun_info.maplength=ReadBlobMSBLong(image);
extent=sun_info.height*sun_info.width;
if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
(sun_info.type != RT_FORMAT_RGB))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.depth == 0) || (sun_info.depth > 32))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
(sun_info.maptype != RMT_RAW))
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
image->columns=sun_info.width;
image->rows=sun_info.height;
image->depth=sun_info.depth <= 8 ? sun_info.depth :
MAGICKCORE_QUANTUM_DEPTH;
if (sun_info.depth < 24)
{
size_t
one;
image->colors=sun_info.maplength;
one=1;
if (sun_info.maptype == RMT_NONE)
image->colors=one << sun_info.depth;
if (sun_info.maptype == RMT_EQUAL_RGB)
image->colors=sun_info.maplength/3;
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
switch (sun_info.maptype)
{
case RMT_EQUAL_RGB:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
case RMT_RAW:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,sun_info.maplength,sun_colormap);
if (count != (ssize_t) sun_info.maplength)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
default:
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
}
image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
UndefinedPixelTrait;
image->columns=sun_info.width;
image->rows=sun_info.height;
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
sun_info.length || !sun_info.length)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
number_pixels=(MagickSizeType) image->columns*image->rows;
if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
bytes_per_line=sun_info.width*sun_info.depth;
sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
if (sun_data == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
if (count != (ssize_t) sun_info.length)
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
sun_pixels=sun_data;
bytes_per_line=0;
if (sun_info.type == RT_ENCODED)
{
size_t
height;
height=sun_info.height;
if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
((bytes_per_line/sun_info.depth) != sun_info.width))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
bytes_per_line+=15;
bytes_per_line<<=1;
if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
bytes_per_line>>=4;
sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
bytes_per_line*sizeof(*sun_pixels));
if (sun_pixels == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
height);
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
}
p=sun_pixels;
if (sun_info.depth == 1)
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=7; bit >= 0; bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
q);
q+=GetPixelChannels(image);
}
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
0x01),q);
q+=GetPixelChannels(image);
}
p++;
}
if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
else
if (image->storage_class == PseudoClass)
{
if (bytes_per_line == 0)
bytes_per_line=image->columns;
length=image->rows*(image->columns+image->columns % 2);
if (((sun_info.type == RT_ENCODED) &&
(length > (bytes_per_line*image->rows))) ||
((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelIndex(image,*p++,q);
q+=GetPixelChannels(image);
}
if ((image->columns % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
{
size_t
bytes_per_pixel;
bytes_per_pixel=3;
if (image->alpha_trait != UndefinedPixelTrait)
bytes_per_pixel++;
if (bytes_per_line == 0)
bytes_per_line=bytes_per_pixel*image->columns;
length=image->rows*(bytes_per_line+image->columns % 2);
if (((sun_info.type == RT_ENCODED) &&
(length > (bytes_per_line*image->rows))) ||
((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (image->alpha_trait != UndefinedPixelTrait)
SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
if (sun_info.type == RT_STANDARD)
{
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
}
else
{
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
}
if (image->colors != 0)
{
SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelRed(image,q)].red),q);
SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelGreen(image,q)].green),q);
SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelBlue(image,q)].blue),q);
}
q+=GetPixelChannels(image);
}
if (((bytes_per_pixel*image->columns) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
if (image->storage_class == PseudoClass)
(void) SyncImage(image,exception);
sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
sun_info.magic=ReadBlobMSBLong(image);
if (sun_info.magic == 0x59a66a95)
{
AcquireNextImage(image_info,image,exception);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while (sun_info.magic == 0x59a66a95);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*VAR_8;
int
VAR_9;
MagickBooleanType
VAR_10;
MagickSizeType
VAR_11;
register Quantum
*VAR_12;
register ssize_t
VAR_13,
VAR_14;
register unsigned char
*VAR_15;
size_t
VAR_16,
VAR_17,
VAR_18;
ssize_t
VAR_19,
VAR_20;
SUNInfo
VAR_21;
unsigned char
*VAR_22,
*VAR_23;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_24);
if (VAR_0->debug != VAR_25)
(void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_24);
VAR_8=AcquireImage(VAR_0,VAR_1);
VAR_10=OpenBlob(VAR_0,VAR_8,VAR_27,VAR_1);
if (VAR_10 == VAR_25)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
(void) ResetMagickMemory(&VAR_21,0,sizeof(VAR_21));
VAR_21.magic=ReadBlobMSBLong(VAR_8);
do
{
if (VAR_21.magic != 0x59a66a95)
ThrowReaderException(VAR_28,""ImproperImageHeader"");
VAR_21.width=ReadBlobMSBLong(VAR_8);
VAR_21.height=ReadBlobMSBLong(VAR_8);
VAR_21.depth=ReadBlobMSBLong(VAR_8);
VAR_21.length=ReadBlobMSBLong(VAR_8);
VAR_21.type=ReadBlobMSBLong(VAR_8);
VAR_21.maptype=ReadBlobMSBLong(VAR_8);
VAR_21.maplength=ReadBlobMSBLong(VAR_8);
VAR_17=VAR_21.height*VAR_21.width;
if ((VAR_21.height != 0) && (VAR_21.width != VAR_17/VAR_21.height))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.type != VAR_5) && (VAR_21.type != VAR_6) &&
(VAR_21.type != VAR_7))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.maptype == VAR_3) && (VAR_21.maplength != 0))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.depth == 0) || (VAR_21.depth > 32))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
if ((VAR_21.maptype != VAR_3) && (VAR_21.maptype != VAR_2) &&
(VAR_21.maptype != VAR_4))
ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
VAR_8->columns=VAR_21.width;
VAR_8->rows=VAR_21.height;
VAR_8->depth=VAR_21.depth <= 8 ? VAR_21.depth :
VAR_30;
if (VAR_21.depth < 24)
{
size_t
VAR_31;
VAR_8->colors=VAR_21.maplength;
VAR_31=1;
if (VAR_21.maptype == VAR_3)
VAR_8->colors=VAR_31 << VAR_21.depth;
if (VAR_21.maptype == VAR_2)
VAR_8->colors=VAR_21.maplength/3;
if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
}
switch (VAR_21.maptype)
{
case VAR_2:
{
unsigned char
*VAR_33;
VAR_33=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
sizeof(*VAR_33));
if (VAR_33 == (unsigned char *) NULL)
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
VAR_33[VAR_13]);
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
VAR_33[VAR_13]);
VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
if (VAR_19 != (ssize_t) VAR_8->colors)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
VAR_33[VAR_13]);
VAR_33=(unsigned char *) RelinquishMagickMemory(VAR_33);
break;
}
case VAR_4:
{
unsigned char
*VAR_33;
VAR_33=(unsigned char *) AcquireQuantumMemory(VAR_21.maplength,
sizeof(*VAR_33));
if (VAR_33 == (unsigned char *) NULL)
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
VAR_19=ReadBlob(VAR_8,VAR_21.maplength,VAR_33);
if (VAR_19 != (ssize_t) VAR_21.maplength)
ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
VAR_33=(unsigned char *) RelinquishMagickMemory(VAR_33);
break;
}
default:
ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
}
VAR_8->alpha_trait=VAR_21.depth == 32 ? VAR_34 :
VAR_35;
VAR_8->columns=VAR_21.width;
VAR_8->rows=VAR_21.height;
if (VAR_0->ping != VAR_25)
{
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}
VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
if (VAR_10 == VAR_25)
return(DestroyImageList(VAR_8));
if ((VAR_21.length*sizeof(*VAR_22))/sizeof(*VAR_22) !=
VAR_21.length || !VAR_21.length)
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
VAR_11=(MagickSizeType) VAR_8->columns*VAR_8->rows;
if ((VAR_21.type != VAR_6) && (VAR_21.depth >= 8) &&
((VAR_11*((VAR_21.depth+7)/8)) > VAR_21.length))
ThrowReaderException(VAR_28,""ImproperImageHeader"");
VAR_16=VAR_21.width*VAR_21.depth;
VAR_22=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
VAR_21.length,VAR_16*VAR_21.width),sizeof(*VAR_22));
if (VAR_22 == (unsigned char *) NULL)
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
VAR_19=(ssize_t) ReadBlob(VAR_8,VAR_21.length,VAR_22);
if (VAR_19 != (ssize_t) VAR_21.length)
ThrowReaderException(VAR_28,""UnableToReadImageData"");
VAR_23=VAR_22;
VAR_16=0;
if (VAR_21.type == VAR_6)
{
size_t
VAR_36;
VAR_36=VAR_21.height;
if ((VAR_36 == 0) || (VAR_21.width == 0) || (VAR_21.depth == 0) ||
((VAR_16/VAR_21.depth) != VAR_21.width))
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
VAR_16+=15;
VAR_16<<=1;
if ((VAR_16 >> 1) != (VAR_21.width*VAR_21.depth+15))
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
VAR_16>>=4;
VAR_23=(unsigned char *) AcquireQuantumMemory(VAR_36,
VAR_16*sizeof(*VAR_23));
if (VAR_23 == (unsigned char *) NULL)
ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
(void) DecodeImage(VAR_22,VAR_21.length,VAR_23,VAR_16*
VAR_36);
VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
}
VAR_15=VAR_23;
if (VAR_21.depth == 1)
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
{
for (VAR_9=7; VAR_9 >= 0; VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((VAR_8->columns % 8) != 0)
{
for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
0x01),VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
else
if (VAR_8->storage_class == VAR_38)
{
if (VAR_16 == 0)
VAR_16=VAR_8->columns;
VAR_18=VAR_8->rows*(VAR_8->columns+VAR_8->columns % 2);
if (((VAR_21.type == VAR_6) &&
(VAR_18 > (VAR_16*VAR_8->rows))) ||
((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
ThrowReaderException(VAR_28,""UnableToReadImageData"");
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
SetPixelIndex(VAR_8,*VAR_15++,VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
if ((VAR_8->columns % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
}
else
{
size_t
VAR_39;
VAR_39=3;
if (VAR_8->alpha_trait != VAR_35)
VAR_39++;
if (VAR_16 == 0)
VAR_16=VAR_39*VAR_8->columns;
VAR_18=VAR_8->rows*(VAR_16+VAR_8->columns % 2);
if (((VAR_21.type == VAR_6) &&
(VAR_18 > (VAR_16*VAR_8->rows))) ||
((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
ThrowReaderException(VAR_28,""UnableToReadImageData"");
for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
if (VAR_8->alpha_trait != VAR_35)
SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
if (VAR_21.type == VAR_5)
{
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
else
{
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
if (VAR_8->colors != 0)
{
SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
}
VAR_12+=GetPixelChannels(VAR_8);
}
if (((VAR_39*VAR_8->columns) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
VAR_8->rows);
if (VAR_10 == VAR_25)
break;
}
}
}
if (VAR_8->storage_class == VAR_38)
(void) SyncImage(VAR_8,VAR_1);
VAR_23=(unsigned char *) RelinquishMagickMemory(VAR_23);
if (EOFBlob(VAR_8) != VAR_25)
{
ThrowFileException(VAR_1,VAR_28,""UnexpectedEndOfFile"",
VAR_8->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_21.magic=ReadBlobMSBLong(VAR_8);
if (VAR_21.magic == 0x59a66a95)
{
AcquireNextImage(VAR_0,VAR_8,VAR_1);
if (GetNextImageInList(VAR_8) == (Image *) NULL)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
VAR_8=SyncNextImageInList(VAR_8);
VAR_10=SetImageProgress(VAR_8,VAR_40,TellBlob(VAR_8),
GetBlobSize(VAR_8));
if (VAR_10 == VAR_25)
break;
}
} while (VAR_21.magic == 0x59a66a95);
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}",ImageMagick/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4/sun.c/vul/before/0.json,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bytes_per_line,
    extent,
    length;

  ssize_t
    count,
    y;

  SUNInfo
    sun_info;

  unsigned char
    *sun_data,
    *sun_pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read SUN raster header.
  */
  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
  sun_info.magic=ReadBlobMSBLong(image);
  do
  {
    /*
      Verify SUN identifier.
    */
    if (sun_info.magic != 0x59a66a95)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    sun_info.width=ReadBlobMSBLong(image);
    sun_info.height=ReadBlobMSBLong(image);
    sun_info.depth=ReadBlobMSBLong(image);
    sun_info.length=ReadBlobMSBLong(image);
    sun_info.type=ReadBlobMSBLong(image);
    sun_info.maptype=ReadBlobMSBLong(image);
    sun_info.maplength=ReadBlobMSBLong(image);
    extent=sun_info.height*sun_info.width;
    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
        (sun_info.type != RT_FORMAT_RGB))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.depth == 0) || (sun_info.depth > 32))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
        (sun_info.maptype != RMT_RAW))
      ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    image->depth=sun_info.depth <= 8 ? sun_info.depth :
      MAGICKCORE_QUANTUM_DEPTH;
    if (sun_info.depth < 24)
      {
        size_t
          one;

        image->colors=sun_info.maplength;
        one=1;
        if (sun_info.maptype == RMT_NONE)
          image->colors=one << sun_info.depth;
        if (sun_info.maptype == RMT_EQUAL_RGB)
          image->colors=sun_info.maplength/3;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    switch (sun_info.maptype)
    {
      case RMT_NONE:
        break;
      case RMT_EQUAL_RGB:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      case RMT_RAW:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,sun_info.maplength,sun_colormap);
        if (count != (ssize_t) sun_info.maplength)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
      UndefinedPixelTrait;
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    if (image_info->ping != MagickFalse)
      {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
        sun_info.length || !sun_info.length)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    number_pixels=(MagickSizeType) image->columns*image->rows;
    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bytes_per_line=sun_info.width*sun_info.depth;
    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
    if (sun_data == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
    if (count != (ssize_t) sun_info.length)
      ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
    sun_pixels=sun_data;
    bytes_per_line=0;
    if (sun_info.type == RT_ENCODED)
      {
        size_t
          height;

        /*
          Read run-length encoded raster pixels.
        */
        height=sun_info.height;
        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
            ((bytes_per_line/sun_info.depth) != sun_info.width))
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bytes_per_line+=15;
        bytes_per_line<<=1;
        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        bytes_per_line>>=4;
        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
          bytes_per_line*sizeof(*sun_pixels));
        if (sun_pixels == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
          height);
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
      }
    /*
      Convert SUN raster image to pixel packets.
    */
    p=sun_pixels;
    if (sun_info.depth == 1)
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=7; bit >= 0; bit--)
          {
            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
              q);
            q+=GetPixelChannels(image);
          }
          p++;
        }
        if ((image->columns % 8) != 0)
          {
            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
            {
              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
                0x01),q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
          p++;
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    else
      if (image->storage_class == PseudoClass)
        {
          if (bytes_per_line == 0)
            bytes_per_line=image->columns;
          length=image->rows*(image->columns+image->columns % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelIndex(image,*p++,q);
              q+=GetPixelChannels(image);
            }
            if ((image->columns % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
      else
        {
          size_t
            bytes_per_pixel;

          bytes_per_pixel=3;
          if (image->alpha_trait != UndefinedPixelTrait)
            bytes_per_pixel++;
          if (bytes_per_line == 0)
            bytes_per_line=bytes_per_pixel*image->columns;
          length=image->rows*(bytes_per_line+image->columns % 2);
          if (((sun_info.type == RT_ENCODED) &&
               (length > (bytes_per_line*image->rows))) ||
              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
              if (sun_info.type == RT_STANDARD)
                {
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                }
              else
                {
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                }
              if (image->colors != 0)
                {
                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelRed(image,q)].red),q);
                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelGreen(image,q)].green),q);
                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelBlue(image,q)].blue),q);
                }
              q+=GetPixelChannels(image);
            }
            if (((bytes_per_pixel*image->columns) % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    sun_info.magic=ReadBlobMSBLong(image);
    if (sun_info.magic == 0x59a66a95)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (sun_info.magic == 0x59a66a95);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *VAR_8;

  int
    VAR_9;

  MagickBooleanType
    VAR_10;

  MagickSizeType
    VAR_11;

  register Quantum
    *VAR_12;

  register ssize_t
    VAR_13,
    VAR_14;

  register unsigned char
    *VAR_15;

  size_t
    VAR_16,
    VAR_17,
    VAR_18;

  ssize_t
    VAR_19,
    VAR_20;

  SUNInfo
    VAR_21;

  unsigned char
    *VAR_22,
    *VAR_23;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_24);
  if (VAR_0->debug != VAR_25)
    (void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_24);
  VAR_8=AcquireImage(VAR_0,VAR_1);
  VAR_10=OpenBlob(VAR_0,VAR_8,VAR_27,VAR_1);
  if (VAR_10 == VAR_25)
    {
      VAR_8=DestroyImageList(VAR_8);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                           
    
  (void) ResetMagickMemory(&VAR_21,0,sizeof(VAR_21));
  VAR_21.magic=ReadBlobMSBLong(VAR_8);
  do
  {
    /* COMMENT_6 */
                            
      
    if (VAR_21.magic != 0x59a66a95)
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    VAR_21.width=ReadBlobMSBLong(VAR_8);
    VAR_21.height=ReadBlobMSBLong(VAR_8);
    VAR_21.depth=ReadBlobMSBLong(VAR_8);
    VAR_21.length=ReadBlobMSBLong(VAR_8);
    VAR_21.type=ReadBlobMSBLong(VAR_8);
    VAR_21.maptype=ReadBlobMSBLong(VAR_8);
    VAR_21.maplength=ReadBlobMSBLong(VAR_8);
    VAR_17=VAR_21.height*VAR_21.width;
    if ((VAR_21.height != 0) && (VAR_21.width != VAR_17/VAR_21.height))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.type != VAR_5) && (VAR_21.type != VAR_6) &&
        (VAR_21.type != VAR_7))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.maptype == VAR_3) && (VAR_21.maplength != 0))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.depth == 0) || (VAR_21.depth > 32))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    if ((VAR_21.maptype != VAR_3) && (VAR_21.maptype != VAR_2) &&
        (VAR_21.maptype != VAR_4))
      ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
    VAR_8->columns=VAR_21.width;
    VAR_8->rows=VAR_21.height;
    VAR_8->depth=VAR_21.depth <= 8 ? VAR_21.depth :
      VAR_30;
    if (VAR_21.depth < 24)
      {
        size_t
          VAR_31;

        VAR_8->colors=VAR_21.maplength;
        VAR_31=1;
        if (VAR_21.maptype == VAR_3)
          VAR_8->colors=VAR_31 << VAR_21.depth;
        if (VAR_21.maptype == VAR_2)
          VAR_8->colors=VAR_21.maplength/3;
        if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_25)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
      }
    switch (VAR_21.maptype)
    {
      case VAR_3:
        break;
      case VAR_2:
      {
        unsigned char
          *VAR_33;

        /* COMMENT_9 */
                                   
          
        VAR_33=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
          sizeof(*VAR_33));
        if (VAR_33 == (unsigned char *) NULL)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
            VAR_33[VAR_13]);
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
            VAR_33[VAR_13]);
        VAR_19=ReadBlob(VAR_8,VAR_8->colors,VAR_33);
        if (VAR_19 != (ssize_t) VAR_8->colors)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
            VAR_33[VAR_13]);
        VAR_33=(unsigned char *) RelinquishMagickMemory(VAR_33);
        break;
      }
      case VAR_4:
      {
        unsigned char
          *VAR_33;

        /* COMMENT_12 */
                                   
          
        VAR_33=(unsigned char *) AcquireQuantumMemory(VAR_21.maplength,
          sizeof(*VAR_33));
        if (VAR_33 == (unsigned char *) NULL)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_19=ReadBlob(VAR_8,VAR_21.maplength,VAR_33);
        if (VAR_19 != (ssize_t) VAR_21.maplength)
          ThrowReaderException(VAR_28,""UnexpectedEndOfFile"");
        VAR_33=(unsigned char *) RelinquishMagickMemory(VAR_33);
        break;
      }
      default:
        ThrowReaderException(VAR_29,""ColormapTypeNotSupported"");
    }
    VAR_8->alpha_trait=VAR_21.depth == 32 ? VAR_34 :
      VAR_35;
    VAR_8->columns=VAR_21.width;
    VAR_8->rows=VAR_21.height;
    if (VAR_0->ping != VAR_25)
      {
        (void) CloseBlob(VAR_8);
        return(GetFirstImageInList(VAR_8));
      }
    VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
    if (VAR_10 == VAR_25)
      return(DestroyImageList(VAR_8));
    if ((VAR_21.length*sizeof(*VAR_22))/sizeof(*VAR_22) !=
        VAR_21.length || !VAR_21.length)
      ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
    VAR_11=(MagickSizeType) VAR_8->columns*VAR_8->rows;
    if ((VAR_21.type != VAR_6) && (VAR_21.depth >= 8) &&
        ((VAR_11*((VAR_21.depth+7)/8)) > VAR_21.length))
      ThrowReaderException(VAR_28,""ImproperImageHeader"");
    VAR_16=VAR_21.width*VAR_21.depth;
    VAR_22=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      VAR_21.length,VAR_16*VAR_21.width),sizeof(*VAR_22));
    if (VAR_22 == (unsigned char *) NULL)
      ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
    VAR_19=(ssize_t) ReadBlob(VAR_8,VAR_21.length,VAR_22);
    if (VAR_19 != (ssize_t) VAR_21.length)
      ThrowReaderException(VAR_28,""UnableToReadImageData"");
    VAR_23=VAR_22;
    VAR_16=0;
    if (VAR_21.type == VAR_6)
      {
        size_t
          VAR_36;

        /* COMMENT_15 */
                                                
          
        VAR_36=VAR_21.height;
        if ((VAR_36 == 0) || (VAR_21.width == 0) || (VAR_21.depth == 0) ||
            ((VAR_16/VAR_21.depth) != VAR_21.width))
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_16+=15;
        VAR_16<<=1;
        if ((VAR_16 >> 1) != (VAR_21.width*VAR_21.depth+15))
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        VAR_16>>=4;
        VAR_23=(unsigned char *) AcquireQuantumMemory(VAR_36,
          VAR_16*sizeof(*VAR_23));
        if (VAR_23 == (unsigned char *) NULL)
          ThrowReaderException(VAR_32,""MemoryAllocationFailed"");
        (void) DecodeImage(VAR_22,VAR_21.length,VAR_23,VAR_16*
          VAR_36);
        VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
      }
    /* COMMENT_18 */
                                                
      
    VAR_15=VAR_23;
    if (VAR_21.depth == 1)
      for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
      {
        VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
        if (VAR_12 == (Quantum *) NULL)
          break;
        for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
        {
          for (VAR_9=7; VAR_9 >= 0; VAR_9--)
          {
            SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
              VAR_12);
            VAR_12+=GetPixelChannels(VAR_8);
          }
          VAR_15++;
        }
        if ((VAR_8->columns % 8) != 0)
          {
            for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
            {
              SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
                0x01),VAR_12);
              VAR_12+=GetPixelChannels(VAR_8);
            }
            VAR_15++;
          }
        if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
          VAR_15++;
        if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
          break;
        if (VAR_8->previous == (Image *) NULL)
          {
            VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
              VAR_8->rows);
            if (VAR_10 == VAR_25)
              break;
          }
      }
    else
      if (VAR_8->storage_class == VAR_38)
        {
          if (VAR_16 == 0)
            VAR_16=VAR_8->columns;
          VAR_18=VAR_8->rows*(VAR_8->columns+VAR_8->columns % 2);
          if (((VAR_21.type == VAR_6) &&
               (VAR_18 > (VAR_16*VAR_8->rows))) ||
              ((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
            ThrowReaderException(VAR_28,""UnableToReadImageData"");
          for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              SetPixelIndex(VAR_8,*VAR_15++,VAR_12);
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if ((VAR_8->columns % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
                VAR_8->rows);
                if (VAR_10 == VAR_25)
                  break;
              }
          }
        }
      else
        {
          size_t
            VAR_39;

          VAR_39=3;
          if (VAR_8->alpha_trait != VAR_35)
            VAR_39++;
          if (VAR_16 == 0)
            VAR_16=VAR_39*VAR_8->columns;
          VAR_18=VAR_8->rows*(VAR_16+VAR_8->columns % 2);
          if (((VAR_21.type == VAR_6) &&
               (VAR_18 > (VAR_16*VAR_8->rows))) ||
              ((VAR_21.type != VAR_6) && (VAR_18 > VAR_21.length)))
            ThrowReaderException(VAR_28,""UnableToReadImageData"");
          for (VAR_20=0; VAR_20 < (ssize_t) VAR_8->rows; VAR_20++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_20,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              if (VAR_8->alpha_trait != VAR_35)
                SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
              if (VAR_21.type == VAR_5)
                {
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              else
                {
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              if (VAR_8->colors != 0)
                {
                  SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
                  SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
                  SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
                }
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if (((VAR_39*VAR_8->columns) % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_25)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_37,(MagickOffsetType) VAR_20,
                VAR_8->rows);
                if (VAR_10 == VAR_25)
                  break;
              }
          }
        }
    if (VAR_8->storage_class == VAR_38)
      (void) SyncImage(VAR_8,VAR_1);
    VAR_23=(unsigned char *) RelinquishMagickMemory(VAR_23);
    if (EOFBlob(VAR_8) != VAR_25)
      {
        ThrowFileException(VAR_1,VAR_28,""UnexpectedEndOfFile"",
          VAR_8->filename);
        break;
      }
    /* COMMENT_21 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_21.magic=ReadBlobMSBLong(VAR_8);
    if (VAR_21.magic == 0x59a66a95)
      {
        /* COMMENT_24 */
                                        
          
        AcquireNextImage(VAR_0,VAR_8,VAR_1);
        if (GetNextImageInList(VAR_8) == (Image *) NULL)
          {
            VAR_8=DestroyImageList(VAR_8);
            return((Image *) NULL);
          }
        VAR_8=SyncNextImageInList(VAR_8);
        VAR_10=SetImageProgress(VAR_8,VAR_40,TellBlob(VAR_8),
          GetBlobSize(VAR_8));
        if (VAR_10 == VAR_25)
          break;
      }
  } while (VAR_21.magic == 0x59a66a95);
  (void) CloseBlob(VAR_8);
  return(GetFirstImageInList(VAR_8));
}",ImageMagick/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4/sun.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -127,6 +127,8 @@
       }
     switch (sun_info.maptype)
     {
+      case RMT_NONE:
+        break;
       case RMT_EQUAL_RGB:
       {
         unsigned char","{'deleted_lines': [], 'added_lines': ['      case RMT_NONE:', '        break;']}",True,Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file.,6.5,MEDIUM,1,valid,2015-01-09T20:02:31Z,1
CVE-2016-7166,['CWE-399'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libarchive,"Fix a potential crash issue discovered by Alexander Cherepanov:

It seems bsdtar automatically handles stacked compression. This is a
nice feature but it could be problematic when it's completely
unlimited.  Most clearly it's illustrated with quines:

$ curl -sRO http://www.maximumcompression.com/selfgz.gz
$ (ulimit -v 10000000 && bsdtar -tvf selfgz.gz)
bsdtar: Error opening archive: Can't allocate data for gzip decompression

Without ulimit, bsdtar will eat all available memory. This could also
be a problem for other applications using libarchive.",6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0,https://github.com/libarchive/libarchive/commit/6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0,libarchive/archive_read.c,choose_filters,"static int
choose_filters(struct archive_read *a)
{
int number_bidders, i, bid, best_bid;
struct archive_read_filter_bidder *bidder, *best_bidder;
struct archive_read_filter *filter;
ssize_t avail;
int r;
for (;;) {
number_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);
best_bid = 0;
best_bidder = NULL;
bidder = a->bidders;
for (i = 0; i < number_bidders; i++, bidder++) {
if (bidder->bid != NULL) {
bid = (bidder->bid)(bidder, a->filter);
if (bid > best_bid) {
best_bid = bid;
best_bidder = bidder;
}
}
}
if (best_bidder == NULL) {
__archive_read_filter_ahead(a->filter, 1, &avail);
if (avail < 0) {
__archive_read_close_filters(a);
__archive_read_free_filters(a);
return (ARCHIVE_FATAL);
}
a->archive.compression_name = a->filter->name;
a->archive.compression_code = a->filter->code;
return (ARCHIVE_OK);
}
filter
= (struct archive_read_filter *)calloc(1, sizeof(*filter));
if (filter == NULL)
return (ARCHIVE_FATAL);
filter->bidder = best_bidder;
filter->archive = a;
filter->upstream = a->filter;
a->filter = filter;
r = (best_bidder->init)(a->filter);
if (r != ARCHIVE_OK) {
__archive_read_close_filters(a);
__archive_read_free_filters(a);
return (ARCHIVE_FATAL);
}
}
}","static int
choose_filters(struct archive_read *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4;
struct archive_read_filter_bidder *VAR_5, *VAR_6;
struct archive_read_filter *VAR_7;
ssize_t VAR_8;
int VAR_9;
for (;;) {
VAR_1 = sizeof(VAR_0->bidders) / sizeof(VAR_0->bidders[0]);
VAR_4 = 0;
VAR_6 = NULL;
VAR_5 = VAR_0->bidders;
for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++, VAR_5++) {
if (VAR_5->bid != NULL) {
VAR_3 = (VAR_5->bid)(VAR_5, VAR_0->filter);
if (VAR_3 > VAR_4) {
VAR_4 = VAR_3;
VAR_6 = VAR_5;
}
}
}
if (VAR_6 == NULL) {
__archive_read_filter_ahead(VAR_0->filter, 1, &VAR_8);
if (VAR_8 < 0) {
__archive_read_close_filters(VAR_0);
__archive_read_free_filters(VAR_0);
return (VAR_10);
}
VAR_0->archive.compression_name = VAR_0->filter->name;
VAR_0->archive.compression_code = VAR_0->filter->code;
return (VAR_11);
}
VAR_7
= (struct archive_read_filter *)calloc(1, sizeof(*VAR_7));
if (VAR_7 == NULL)
return (VAR_10);
VAR_7->bidder = VAR_6;
VAR_7->archive = VAR_0;
VAR_7->upstream = VAR_0->filter;
VAR_0->filter = VAR_7;
VAR_9 = (VAR_6->init)(VAR_0->filter);
if (VAR_9 != VAR_11) {
__archive_read_close_filters(VAR_0);
__archive_read_free_filters(VAR_0);
return (VAR_10);
}
}
}",libarchive/6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0/archive_read.c/vul/before/0.json,"static int
choose_filters(struct archive_read *a)
{
	int number_bidders, i, bid, best_bid, n;
	struct archive_read_filter_bidder *bidder, *best_bidder;
	struct archive_read_filter *filter;
	ssize_t avail;
	int r;

	for (n = 0; n < 25; ++n) {
		number_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);

		best_bid = 0;
		best_bidder = NULL;

		bidder = a->bidders;
		for (i = 0; i < number_bidders; i++, bidder++) {
			if (bidder->bid != NULL) {
				bid = (bidder->bid)(bidder, a->filter);
				if (bid > best_bid) {
					best_bid = bid;
					best_bidder = bidder;
				}
			}
		}

		/* If no bidder, we're done. */
		if (best_bidder == NULL) {
			/* Verify the filter by asking it for some data. */
			__archive_read_filter_ahead(a->filter, 1, &avail);
			if (avail < 0) {
				__archive_read_close_filters(a);
				__archive_read_free_filters(a);
				return (ARCHIVE_FATAL);
			}
			a->archive.compression_name = a->filter->name;
			a->archive.compression_code = a->filter->code;
			return (ARCHIVE_OK);
		}

		filter
		    = (struct archive_read_filter *)calloc(1, sizeof(*filter));
		if (filter == NULL)
			return (ARCHIVE_FATAL);
		filter->bidder = best_bidder;
		filter->archive = a;
		filter->upstream = a->filter;
		a->filter = filter;
		r = (best_bidder->init)(a->filter);
		if (r != ARCHIVE_OK) {
			__archive_read_close_filters(a);
			__archive_read_free_filters(a);
			return (ARCHIVE_FATAL);
		}
	}
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Input requires too many filters for decoding"");
	return (ARCHIVE_FATAL);
}","static int
choose_filters(struct archive_read *VAR_0)
{
	int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;
	struct archive_read_filter_bidder *VAR_6, *VAR_7;
	struct archive_read_filter *VAR_8;
	ssize_t VAR_9;
	int VAR_10;

	for (VAR_5 = 0; VAR_5 < 25; ++VAR_5) {
		VAR_1 = sizeof(VAR_0->bidders) / sizeof(VAR_0->bidders[0]);

		VAR_4 = 0;
		VAR_7 = NULL;

		VAR_6 = VAR_0->bidders;
		for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++, VAR_6++) {
			if (VAR_6->bid != NULL) {
				VAR_3 = (VAR_6->bid)(VAR_6, VAR_0->filter);
				if (VAR_3 > VAR_4) {
					VAR_4 = VAR_3;
					VAR_7 = VAR_6;
				}
			}
		}

		/* COMMENT_0 */
		if (VAR_7 == NULL) {
			/* COMMENT_1 */
			__archive_read_filter_ahead(VAR_0->filter, 1, &VAR_9);
			if (VAR_9 < 0) {
				__archive_read_close_filters(VAR_0);
				__archive_read_free_filters(VAR_0);
				return (VAR_11);
			}
			VAR_0->archive.compression_name = VAR_0->filter->name;
			VAR_0->archive.compression_code = VAR_0->filter->code;
			return (VAR_12);
		}

		VAR_8
		    = (struct archive_read_filter *)calloc(1, sizeof(*VAR_8));
		if (VAR_8 == NULL)
			return (VAR_11);
		VAR_8->bidder = VAR_7;
		VAR_8->archive = VAR_0;
		VAR_8->upstream = VAR_0->filter;
		VAR_0->filter = VAR_8;
		VAR_10 = (VAR_7->init)(VAR_0->filter);
		if (VAR_10 != VAR_12) {
			__archive_read_close_filters(VAR_0);
			__archive_read_free_filters(VAR_0);
			return (VAR_11);
		}
	}
	archive_set_error(&VAR_0->archive, VAR_13,
	    ""Input requires too many filters for decoding"");
	return (VAR_11);
}",libarchive/6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0/archive_read.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,13 +1,13 @@
 static int
 choose_filters(struct archive_read *a)
 {
-	int number_bidders, i, bid, best_bid;
+	int number_bidders, i, bid, best_bid, n;
 	struct archive_read_filter_bidder *bidder, *best_bidder;
 	struct archive_read_filter *filter;
 	ssize_t avail;
 	int r;
 
-	for (;;) {
+	for (n = 0; n < 25; ++n) {
 		number_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);
 
 		best_bid = 0;
@@ -53,4 +53,7 @@
 			return (ARCHIVE_FATAL);
 		}
 	}
+	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+	    ""Input requires too many filters for decoding"");
+	return (ARCHIVE_FATAL);
 }","{'deleted_lines': ['\tint number_bidders, i, bid, best_bid;', '\tfor (;;) {'], 'added_lines': ['\tint number_bidders, i, bid, best_bid, n;', '\tfor (n = 0; n < 25; ++n) {', '\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,', '\t    ""Input requires too many filters for decoding"");', '\treturn (ARCHIVE_FATAL);']}",True,"libarchive before 3.2.0 does not limit the number of recursive decompressions, which allows remote attackers to cause a denial of service (memory consumption and application crash) via a crafted gzip file.",5.5,MEDIUM,1,valid,2015-01-10T20:24:58Z,1
CVE-2016-0823,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"pagemap: do not leak physical addresses to non-privileged userspace

As pointed by recent post[1] on exploiting DRAM physical imperfection,
/proc/PID/pagemap exposes sensitive information which can be used to do
attacks.

This disallows anybody without CAP_SYS_ADMIN to read the pagemap.

[1] http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html

[ Eventually we might want to do anything more finegrained, but for now
  this is the simple model.   - Linus ]

Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Acked-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
Acked-by: Andy Lutomirski <luto@amacapital.net>
Cc: Pavel Emelyanov <xemul@parallels.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Mark Seaborn <mseaborn@chromium.org>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce,https://github.com/torvalds/linux/commit/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce,fs/proc/task_mmu.c,pagemap_open,"static int pagemap_open(struct inode *inode, struct file *file)
{
pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
""to stop being page-shift some time soon. See the ""
""linux/Documentation/vm/pagemap.txt for details.\n"");
return 0;
}","static int pagemap_open(struct inode *inode, struct file *file)
{
pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
""to stop being page-shift some time soon. See the ""
""linux/Documentation/vm/pagemap.txt for details.\n"");
return 0;
}",torvalds/linux/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce/task_mmu.c/vul/before/0.json,"static int pagemap_open(struct inode *inode, struct file *file)
{
	/* do not disclose physical addresses: attack vector */
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
			""to stop being page-shift some time soon. See the ""
			""linux/Documentation/vm/pagemap.txt for details.\n"");
	return 0;
}","static int pagemap_open(struct inode *inode, struct file *file)
{
	/* COMMENT_0 */
	if (!capable(VAR_0))
		return -VAR_1;
	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
			""to stop being page-shift some time soon. See the ""
			""linux/Documentation/vm/pagemap.txt for details.\n"");
	return 0;
}",torvalds/linux/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce/task_mmu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 static int pagemap_open(struct inode *inode, struct file *file)
 {
+	/* do not disclose physical addresses: attack vector */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");","{'deleted_lines': [], 'added_lines': ['\t/* do not disclose physical addresses: attack vector */', '\tif (!capable(CAP_SYS_ADMIN))', '\t\treturn -EPERM;']}",True,"The pagemap_open function in fs/proc/task_mmu.c in the Linux kernel before 3.19.3, as used in Android 6.0.1 before 2016-03-01, allows local users to obtain sensitive physical-address information by reading a pagemap file, aka Android internal bug 25739721.",4.0,MEDIUM,1,valid,2015-03-09T21:11:12Z,1
CVE-2015-4602,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,php/php-src,Check that the type is correct,fb83c76deec58f1fab17c350f04c9f042e5977d1,https://github.com/php/php-src/commit/fb83c76deec58f1fab17c350f04c9f042e5977d1,ext/standard/incomplete_class.c,php_lookup_class_name,"PHPAPI char *php_lookup_class_name(zval *object, zend_uint *nlen)
{
zval **val;
char *retval = NULL;
HashTable *object_properties;
TSRMLS_FETCH();
object_properties = Z_OBJPROP_P(object);
if (zend_hash_find(object_properties, MAGIC_MEMBER, sizeof(MAGIC_MEMBER), (void **) &val) == SUCCESS) {
retval = estrndup(Z_STRVAL_PP(val), Z_STRLEN_PP(val));
if (nlen) {
*nlen = Z_STRLEN_PP(val);
}
}
return retval;
}","PHPAPI VAR_0 *php_lookup_class_name(zval *VAR_1, zend_uint *VAR_2)
{
zval **VAR_3;
char *VAR_4 = NULL;
HashTable *VAR_5;
TSRMLS_FETCH();
VAR_5 = Z_OBJPROP_P(VAR_1);
if (zend_hash_find(VAR_5, VAR_6, sizeof(VAR_6), (void **) &VAR_3) == VAR_7) {
VAR_4 = estrndup(Z_STRVAL_PP(VAR_3), Z_STRLEN_PP(VAR_3));
if (VAR_2) {
*VAR_2 = Z_STRLEN_PP(VAR_3);
}
}
return VAR_4;
}",,"PHPAPI char *php_lookup_class_name(zval *object, zend_uint *nlen)
{
	zval **val;
	char *retval = NULL;
	HashTable *object_properties;
	TSRMLS_FETCH();

	object_properties = Z_OBJPROP_P(object);

	if (zend_hash_find(object_properties, MAGIC_MEMBER, sizeof(MAGIC_MEMBER), (void **) &val) == SUCCESS && Z_TYPE_PP(val) == IS_STRING) {
		retval = estrndup(Z_STRVAL_PP(val), Z_STRLEN_PP(val));

		if (nlen) {
			*nlen = Z_STRLEN_PP(val);
		}
	}

	return retval;
}","PHPAPI VAR_0 *php_lookup_class_name(zval *VAR_1, zend_uint *VAR_2)
{
	zval **VAR_3;
	char *VAR_4 = NULL;
	HashTable *VAR_5;
	TSRMLS_FETCH();

	VAR_5 = Z_OBJPROP_P(VAR_1);

	if (zend_hash_find(VAR_5, VAR_6, sizeof(VAR_6), (void **) &VAR_3) == VAR_7 && Z_TYPE_PP(VAR_3) == VAR_8) {
		VAR_4 = estrndup(Z_STRVAL_PP(VAR_3), Z_STRLEN_PP(VAR_3));

		if (VAR_2) {
			*VAR_2 = Z_STRLEN_PP(VAR_3);
		}
	}

	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 
 	object_properties = Z_OBJPROP_P(object);
 
-	if (zend_hash_find(object_properties, MAGIC_MEMBER, sizeof(MAGIC_MEMBER), (void **) &val) == SUCCESS) {
+	if (zend_hash_find(object_properties, MAGIC_MEMBER, sizeof(MAGIC_MEMBER), (void **) &val) == SUCCESS && Z_TYPE_PP(val) == IS_STRING) {
 		retval = estrndup(Z_STRVAL_PP(val), Z_STRLEN_PP(val));
 
 		if (nlen) {","{'deleted_lines': ['\tif (zend_hash_find(object_properties, MAGIC_MEMBER, sizeof(MAGIC_MEMBER), (void **) &val) == SUCCESS) {'], 'added_lines': ['\tif (zend_hash_find(object_properties, MAGIC_MEMBER, sizeof(MAGIC_MEMBER), (void **) &val) == SUCCESS && Z_TYPE_PP(val) == IS_STRING) {']}",True,"The __PHP_Incomplete_Class function in ext/standard/incomplete_class.c in PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via an unexpected data type, related to a ""type confusion"" issue.",9.8,CRITICAL,3,valid,2015-03-23T01:17:47Z,1
CVE-2017-15116,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,crypto/rng.c,crypto_rng_init_tfm,"static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
{
struct crypto_rng *rng = __crypto_rng_cast(tfm);
struct rng_alg *alg = crypto_rng_alg(rng);
struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
if (oalg->rng_make_random) {
rng->generate = generate;
rng->seed = rngapi_reset;
rng->seedsize = oalg->seedsize;
return 0;
}
rng->generate = alg->generate;
rng->seed = alg->seed;
rng->seedsize = alg->seedsize;
return 0;
}","static int crypto_rng_init_tfm(struct crypto_tfm *VAR_0)
{
struct crypto_rng *VAR_1 = __crypto_rng_cast(VAR_0);
struct rng_alg *VAR_2 = crypto_rng_alg(VAR_1);
struct old_rng_alg *VAR_3 = crypto_old_rng_alg(VAR_1);
if (VAR_3->rng_make_random) {
VAR_1->generate = VAR_4;
VAR_1->seed = VAR_5;
VAR_1->seedsize = VAR_3->seedsize;
return 0;
}
VAR_1->generate = VAR_2->generate;
VAR_1->seed = VAR_2->seed;
VAR_1->seedsize = VAR_2->seedsize;
return 0;
}",torvalds/linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/rng.c/vul/before/0.json,"static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
{
	return 0;
}","static int crypto_rng_init_tfm(struct crypto_tfm *VAR_0)
{
	return 0;
}",torvalds/linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/rng.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,19 +1,4 @@
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
-	struct crypto_rng *rng = __crypto_rng_cast(tfm);
-	struct rng_alg *alg = crypto_rng_alg(rng);
-	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);
-
-	if (oalg->rng_make_random) {
-		rng->generate = generate;
-		rng->seed = rngapi_reset;
-		rng->seedsize = oalg->seedsize;
-		return 0;
-	}
-
-	rng->generate = alg->generate;
-	rng->seed = alg->seed;
-	rng->seedsize = alg->seedsize;
-
 	return 0;
 }","{'deleted_lines': ['\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);', '\tstruct rng_alg *alg = crypto_rng_alg(rng);', '\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);', '', '\tif (oalg->rng_make_random) {', '\t\trng->generate = generate;', '\t\trng->seed = rngapi_reset;', '\t\trng->seedsize = oalg->seedsize;', '\t\treturn 0;', '\t}', '', '\trng->generate = alg->generate;', '\trng->seed = alg->seed;', '\trng->seedsize = alg->seedsize;', ''], 'added_lines': []}",True,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,5.5,MEDIUM,1,valid,2015-04-21T02:46:46Z,1
CVE-2017-15116,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,crypto/rng.c,seedsize,"static unsigned int seedsize(struct crypto_alg *alg)
{
struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
return alg->cra_rng.rng_make_random ?
alg->cra_rng.seedsize : ralg->seedsize;
}","static unsigned int seedsize(struct crypto_alg *VAR_0)
{
struct rng_alg *VAR_1 = container_of(VAR_0, struct rng_alg, VAR_2);
return VAR_0->cra_rng.rng_make_random ?
VAR_0->cra_rng.seedsize : VAR_1->seedsize;
}",torvalds/linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/rng.c/vul/before/2.json,"static unsigned int seedsize(struct crypto_alg *alg)
{
	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);

	return ralg->seedsize;
}","static unsigned int seedsize(struct crypto_alg *VAR_0)
{
	struct rng_alg *VAR_1 = container_of(VAR_0, struct rng_alg, VAR_2);

	return VAR_1->seedsize;
}",torvalds/linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/rng.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,6 +2,5 @@
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
-	return alg->cra_rng.rng_make_random ?
-	       alg->cra_rng.seedsize : ralg->seedsize;
+	return ralg->seedsize;
 }","{'deleted_lines': ['\treturn alg->cra_rng.rng_make_random ?', '\t       alg->cra_rng.seedsize : ralg->seedsize;'], 'added_lines': ['\treturn ralg->seedsize;']}",True,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,5.5,MEDIUM,1,valid,2015-04-21T02:46:46Z,1
CVE-2017-15116,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"crypto: rng - Remove old low-level rng interface

Now that all rng implementations have switched over to the new
interface, we can remove the old low-level interface.

Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,crypto/rng.c,crypto_rng_reset,"int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
{
u8 *buf = NULL;
int err;
if (!seed && slen) {
buf = kmalloc(slen, GFP_KERNEL);
if (!buf)
return -ENOMEM;
get_random_bytes(buf, slen);
seed = buf;
}
err = tfm->seed(tfm, seed, slen);
kfree(buf);
return err;
}","int crypto_rng_reset(struct crypto_rng *VAR_0, const u8 *VAR_1, unsigned int VAR_2)
{
u8 *VAR_3 = NULL;
int VAR_4;
if (!VAR_1 && VAR_2) {
VAR_3 = kmalloc(VAR_2, VAR_5);
if (!VAR_3)
return -VAR_6;
get_random_bytes(VAR_3, VAR_2);
VAR_1 = VAR_3;
}
VAR_4 = VAR_0->seed(VAR_0, VAR_1, VAR_2);
kfree(VAR_3);
return VAR_4;
}",torvalds/linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/rng.c/vul/before/1.json,"int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
{
	u8 *buf = NULL;
	int err;

	if (!seed && slen) {
		buf = kmalloc(slen, GFP_KERNEL);
		if (!buf)
			return -ENOMEM;

		get_random_bytes(buf, slen);
		seed = buf;
	}

	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);

	kfree(buf);
	return err;
}","int crypto_rng_reset(struct crypto_rng *VAR_0, const u8 *VAR_1, unsigned int VAR_2)
{
	u8 *VAR_3 = NULL;
	int VAR_4;

	if (!VAR_1 && VAR_2) {
		VAR_3 = kmalloc(VAR_2, VAR_5);
		if (!VAR_3)
			return -VAR_6;

		get_random_bytes(VAR_3, VAR_2);
		VAR_1 = VAR_3;
	}

	VAR_4 = crypto_rng_alg(VAR_0)->seed(VAR_0, VAR_1, VAR_2);

	kfree(VAR_3);
	return VAR_4;
}",torvalds/linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6/rng.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 		seed = buf;
 	}
 
-	err = tfm->seed(tfm, seed, slen);
+	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;","{'deleted_lines': ['\terr = tfm->seed(tfm, seed, slen);'], 'added_lines': ['\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);']}",True,The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).,5.5,MEDIUM,1,valid,2015-04-21T02:46:46Z,1
CVE-2015-8950,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,torvalds/linux,"arm64: dma-mapping: always clear allocated buffers

Buffers allocated by dma_alloc_coherent() are always zeroed on Alpha,
ARM (32bit), MIPS, PowerPC, x86/x86_64 and probably other architectures.
It turned out that some drivers rely on this 'feature'. Allocated buffer
might be also exposed to userspace with dma_mmap() call, so clearing it
is desired from security point of view to avoid exposing random memory
to userspace. This patch unifies dma_alloc_coherent() behavior on ARM64
architecture with other implementations by unconditionally zeroing
allocated buffer.

Cc: <stable@vger.kernel.org> # v3.14+
Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
Signed-off-by: Will Deacon <will.deacon@arm.com>",6829e274a623187c24f7cfc0e3d35f25d087fcc5,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,arch/arm64/mm/dma-mapping.c,__dma_alloc_coherent,"static void *__dma_alloc_coherent(struct device *dev, size_t size,
dma_addr_t *dma_handle, gfp_t flags,
struct dma_attrs *attrs)
{
if (dev == NULL) {
WARN_ONCE(1, ""Use an actual device structure for DMA allocation\n"");
return NULL;
}
if (IS_ENABLED(CONFIG_ZONE_DMA) &&
dev->coherent_dma_mask <= DMA_BIT_MASK(32))
flags |= GFP_DMA;
if (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {
struct page *page;
void *addr;
size = PAGE_ALIGN(size);
page = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,
get_order(size));
if (!page)
return NULL;
*dma_handle = phys_to_dma(dev, page_to_phys(page));
addr = page_address(page);
if (flags & __GFP_ZERO)
memset(addr, 0, size);
return addr;
} else {
return swiotlb_alloc_coherent(dev, size, dma_handle, flags);
}
}","static void *__dma_alloc_coherent(struct device *VAR_0, size_t VAR_1,
dma_addr_t *VAR_2, gfp_t VAR_3,
struct dma_attrs *VAR_4)
{
if (VAR_0 == NULL) {
WARN_ONCE(1, ""Use an actual device structure for DMA allocation\n"");
return NULL;
}
if (IS_ENABLED(VAR_5) &&
VAR_0->coherent_dma_mask <= DMA_BIT_MASK(32))
VAR_3 |= VAR_6;
if (IS_ENABLED(VAR_7) && (VAR_3 & VAR_8)) {
struct page *page;
void *VAR_9;
VAR_1 = PAGE_ALIGN(VAR_1);
page = dma_alloc_from_contiguous(VAR_0, VAR_1 >> VAR_10,
get_order(VAR_1));
if (!page)
return NULL;
*VAR_2 = phys_to_dma(VAR_0, page_to_phys(page));
VAR_9 = page_address(page);
if (VAR_3 & VAR_11)
memset(VAR_9, 0, VAR_1);
return VAR_9;
} else {
return swiotlb_alloc_coherent(VAR_0, VAR_1, VAR_2, VAR_3);
}
}",torvalds/linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5/dma-mapping.c/vul/before/0.json,"static void *__dma_alloc_coherent(struct device *dev, size_t size,
				  dma_addr_t *dma_handle, gfp_t flags,
				  struct dma_attrs *attrs)
{
	if (dev == NULL) {
		WARN_ONCE(1, ""Use an actual device structure for DMA allocation\n"");
		return NULL;
	}

	if (IS_ENABLED(CONFIG_ZONE_DMA) &&
	    dev->coherent_dma_mask <= DMA_BIT_MASK(32))
		flags |= GFP_DMA;
	if (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {
		struct page *page;
		void *addr;

		size = PAGE_ALIGN(size);
		page = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,
							get_order(size));
		if (!page)
			return NULL;

		*dma_handle = phys_to_dma(dev, page_to_phys(page));
		addr = page_address(page);
		memset(addr, 0, size);
		return addr;
	} else {
		return swiotlb_alloc_coherent(dev, size, dma_handle, flags);
	}
}","static void *__dma_alloc_coherent(struct device *VAR_0, size_t VAR_1,
				  dma_addr_t *VAR_2, gfp_t VAR_3,
				  struct dma_attrs *VAR_4)
{
	if (VAR_0 == NULL) {
		WARN_ONCE(1, ""Use an actual device structure for DMA allocation\n"");
		return NULL;
	}

	if (IS_ENABLED(VAR_5) &&
	    VAR_0->coherent_dma_mask <= DMA_BIT_MASK(32))
		VAR_3 |= VAR_6;
	if (IS_ENABLED(VAR_7) && (VAR_3 & VAR_8)) {
		struct page *page;
		void *VAR_9;

		VAR_1 = PAGE_ALIGN(VAR_1);
		page = dma_alloc_from_contiguous(VAR_0, VAR_1 >> VAR_10,
							get_order(VAR_1));
		if (!page)
			return NULL;

		*VAR_2 = phys_to_dma(VAR_0, page_to_phys(page));
		VAR_9 = page_address(page);
		memset(VAR_9, 0, VAR_1);
		return VAR_9;
	} else {
		return swiotlb_alloc_coherent(VAR_0, VAR_1, VAR_2, VAR_3);
	}
}",torvalds/linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5/dma-mapping.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,8 +22,7 @@
 
 		*dma_handle = phys_to_dma(dev, page_to_phys(page));
 		addr = page_address(page);
-		if (flags & __GFP_ZERO)
-			memset(addr, 0, size);
+		memset(addr, 0, size);
 		return addr;
 	} else {
 		return swiotlb_alloc_coherent(dev, size, dma_handle, flags);","{'deleted_lines': ['\t\tif (flags & __GFP_ZERO)', '\t\t\tmemset(addr, 0, size);'], 'added_lines': ['\t\tmemset(addr, 0, size);']}",True,"arch/arm64/mm/dma-mapping.c in the Linux kernel before 4.0.3, as used in the ION subsystem in Android and other products, does not initialize certain data structures, which allows local users to obtain sensitive information from kernel memory by triggering a dma_mmap call.",5.5,MEDIUM,1,valid,2015-04-23T11:46:16Z,1
CVE-2015-8950,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,torvalds/linux,"arm64: dma-mapping: always clear allocated buffers

Buffers allocated by dma_alloc_coherent() are always zeroed on Alpha,
ARM (32bit), MIPS, PowerPC, x86/x86_64 and probably other architectures.
It turned out that some drivers rely on this 'feature'. Allocated buffer
might be also exposed to userspace with dma_mmap() call, so clearing it
is desired from security point of view to avoid exposing random memory
to userspace. This patch unifies dma_alloc_coherent() behavior on ARM64
architecture with other implementations by unconditionally zeroing
allocated buffer.

Cc: <stable@vger.kernel.org> # v3.14+
Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
Signed-off-by: Will Deacon <will.deacon@arm.com>",6829e274a623187c24f7cfc0e3d35f25d087fcc5,https://github.com/torvalds/linux/commit/6829e274a623187c24f7cfc0e3d35f25d087fcc5,arch/arm64/mm/dma-mapping.c,__alloc_from_pool,"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
unsigned long val;
void *ptr = NULL;
if (!atomic_pool) {
WARN(1, ""coherent pool not initialised!\n"");
return NULL;
}
val = gen_pool_alloc(atomic_pool, size);
if (val) {
phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
*ret_page = phys_to_page(phys);
ptr = (void *)val;
if (flags & __GFP_ZERO)
memset(ptr, 0, size);
}
return ptr;
}","static void *__alloc_from_pool(size_t VAR_0, struct page **VAR_1, gfp_t VAR_2)
{
unsigned long VAR_3;
void *VAR_4 = NULL;
if (!VAR_5) {
WARN(1, ""coherent pool not initialised!\n"");
return NULL;
}
VAR_3 = gen_pool_alloc(VAR_5, VAR_0);
if (VAR_3) {
phys_addr_t VAR_6 = gen_pool_virt_to_phys(VAR_5, VAR_3);
*VAR_1 = phys_to_page(VAR_6);
VAR_4 = (void *)VAR_3;
if (VAR_2 & VAR_7)
memset(VAR_4, 0, VAR_0);
}
return VAR_4;
}",torvalds/linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5/dma-mapping.c/vul/before/1.json,"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
	unsigned long val;
	void *ptr = NULL;

	if (!atomic_pool) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}

	val = gen_pool_alloc(atomic_pool, size);
	if (val) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);

		*ret_page = phys_to_page(phys);
		ptr = (void *)val;
		memset(ptr, 0, size);
	}

	return ptr;
}","static void *__alloc_from_pool(size_t VAR_0, struct page **VAR_1, gfp_t VAR_2)
{
	unsigned long VAR_3;
	void *VAR_4 = NULL;

	if (!VAR_5) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}

	VAR_3 = gen_pool_alloc(VAR_5, VAR_0);
	if (VAR_3) {
		phys_addr_t VAR_6 = gen_pool_virt_to_phys(VAR_5, VAR_3);

		*VAR_1 = phys_to_page(VAR_6);
		VAR_4 = (void *)VAR_3;
		memset(VAR_4, 0, VAR_0);
	}

	return VAR_4;
}",torvalds/linux/6829e274a623187c24f7cfc0e3d35f25d087fcc5/dma-mapping.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -14,8 +14,7 @@
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
-		if (flags & __GFP_ZERO)
-			memset(ptr, 0, size);
+		memset(ptr, 0, size);
 	}
 
 	return ptr;","{'deleted_lines': ['\t\tif (flags & __GFP_ZERO)', '\t\t\tmemset(ptr, 0, size);'], 'added_lines': ['\t\tmemset(ptr, 0, size);']}",True,"arch/arm64/mm/dma-mapping.c in the Linux kernel before 4.0.3, as used in the ION subsystem in Android and other products, does not initialize certain data structures, which allows local users to obtain sensitive information from kernel memory by triggering a dma_mmap call.",5.5,MEDIUM,1,valid,2015-04-23T11:46:16Z,1
CVE-2015-4643,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,improve fix for Bug #69545,0765623d6991b62ffcd93ddb6be8a5203a2fa7e2,https://github.com/php/php-src/commit/0765623d6991b62ffcd93ddb6be8a5203a2fa7e2,ext/ftp/ftp.c,ftp_genlist,"char**
ftp_genlist(ftpbuf_t *ftp, const char *cmd, const char *path TSRMLS_DC)
{
php_stream*tmpstream = NULL;
databuf_t*data = NULL;
char*ptr;
intch, lastch;
size_tsize, rcvd;
size_tlines;
char**ret = NULL;
char**entry;
char*text;
if ((tmpstream = php_stream_fopen_tmpfile()) == NULL) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create temporary file.  Check permissions in temporary files directory."");
return NULL;
}
if (!ftp_type(ftp, FTPTYPE_ASCII)) {
goto bail;
}
if ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {
goto bail;
}
ftp->data = data;
if (!ftp_putcmd(ftp, cmd, path)) {
goto bail;
}
if (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125 && ftp->resp != 226)) {
goto bail;
}
if (ftp->resp == 226) {
ftp->data = data_close(ftp, data);
php_stream_close(tmpstream);
return ecalloc(1, sizeof(char*));
}
if ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {
goto bail;
}
size = 0;
lines = 0;
lastch = 0;
while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {
if (rcvd == -1 || rcvd > ((size_t)(-1))-size) {
goto bail;
}
php_stream_write(tmpstream, data->buf, rcvd);
size += rcvd;
for (ptr = data->buf; rcvd; rcvd--, ptr++) {
if (*ptr == '\n' && lastch == '\r') {
lines++;
} else {
size++;
}
lastch = *ptr;
}
}
ftp->data = data_close(ftp, data);
php_stream_rewind(tmpstream);
ret = safe_emalloc((lines + 1), sizeof(char*), size);
entry = ret;
text = (char*) (ret + lines + 1);
*entry = text;
lastch = 0;
while ((ch = php_stream_getc(tmpstream)) != EOF) {
if (ch == '\n' && lastch == '\r') {
*(text - 1) = 0;
*++entry = text;
} else {
*text++ = ch;
}
lastch = ch;
}
*entry = NULL;
php_stream_close(tmpstream);
if (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {
efree(ret);
return NULL;
}
return ret;
bail:
ftp->data = data_close(ftp, data);
php_stream_close(tmpstream);
if (ret)
efree(ret);
return NULL;
}","char**
ftp_genlist(ftpbuf_t *VAR_0, const char *VAR_1, const char *VAR_2 TSRMLS_DC)
{
php_stream*VAR_3 = NULL;
databuf_t*VAR_4 = NULL;
char*VAR_5;
intVAR_6, VAR_7;
size_tVAR_8, VAR_9;
size_tVAR_10;
char**VAR_11 = NULL;
char**VAR_12;
char*VAR_13;
if ((VAR_3 = php_stream_fopen_tmpfile()) == NULL) {
VAR_14(NULL VAR_15, VAR_16, ""Unable to create temporary file.  Check permissions in temporary files directory."");
return NULL;
}
if (!ftp_type(VAR_0, VAR_17)) {
goto bail;
}
if ((VAR_4 = ftp_getdata(VAR_0 VAR_15)) == NULL) {
goto bail;
}
VAR_0->data = VAR_4;
if (!ftp_putcmd(VAR_0, VAR_1, VAR_2)) {
goto bail;
}
if (!ftp_getresp(VAR_0) || (VAR_0->resp != 150 && VAR_0->resp != 125 && VAR_0->resp != 226)) {
goto bail;
}
if (VAR_0->resp == 226) {
VAR_0->data = data_close(VAR_0, VAR_4);
php_stream_close(VAR_3);
return ecalloc(1, sizeof(char*));
}
if ((VAR_4 = data_accept(VAR_4, VAR_0 VAR_15)) == NULL) {
goto bail;
}
VAR_8 = 0;
VAR_10 = 0;
VAR_7 = 0;
while ((VAR_9 = my_recv(VAR_0, VAR_4->fd, VAR_4->buf, VAR_18))) {
if (VAR_9 == -1 || VAR_9 > ((size_t)(-1))-VAR_8) {
goto bail;
}
php_stream_write(VAR_3, VAR_4->buf, VAR_9);
VAR_8 += VAR_9;
for (VAR_5 = VAR_4->buf; VAR_9; VAR_9--, VAR_5++) {
if (*VAR_5 == '\n' && VAR_7 == '\r') {
VAR_10++;
} else {
VAR_8++;
}
VAR_7 = *VAR_5;
}
}
VAR_0->data = data_close(VAR_0, VAR_4);
php_stream_rewind(VAR_3);
VAR_11 = safe_emalloc((VAR_10 + 1), sizeof(char*), VAR_8);
VAR_12 = VAR_11;
VAR_13 = (char*) (VAR_11 + VAR_10 + 1);
*VAR_12 = VAR_13;
VAR_7 = 0;
while ((VAR_6 = php_stream_getc(VAR_3)) != VAR_19) {
if (VAR_6 == '\n' && VAR_7 == '\r') {
*(VAR_13 - 1) = 0;
*++VAR_12 = VAR_13;
} else {
*VAR_13++ = VAR_6;
}
VAR_7 = VAR_6;
}
*VAR_12 = NULL;
php_stream_close(VAR_3);
if (!ftp_getresp(VAR_0) || (VAR_0->resp != 226 && VAR_0->resp != 250)) {
efree(VAR_11);
return NULL;
}
return VAR_11;
bail:
VAR_0->data = data_close(VAR_0, VAR_4);
php_stream_close(VAR_3);
if (VAR_11)
efree(VAR_11);
return NULL;
}",,"char**
ftp_genlist(ftpbuf_t *ftp, const char *cmd, const char *path TSRMLS_DC)
{
	php_stream	*tmpstream = NULL;
	databuf_t	*data = NULL;
	char		*ptr;
	int		ch, lastch;
	size_t		size, rcvd;
	size_t		lines;
	char		**ret = NULL;
	char		**entry;
	char		*text;


	if ((tmpstream = php_stream_fopen_tmpfile()) == NULL) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to create temporary file.  Check permissions in temporary files directory."");
		return NULL;
	}

	if (!ftp_type(ftp, FTPTYPE_ASCII)) {
		goto bail;
	}

	if ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {
		goto bail;
	}
	ftp->data = data;

	if (!ftp_putcmd(ftp, cmd, path)) {
		goto bail;
	}
	if (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125 && ftp->resp != 226)) {
		goto bail;
	}

	/* some servers don't open a ftp-data connection if the directory is empty */
	if (ftp->resp == 226) {
		ftp->data = data_close(ftp, data);
		php_stream_close(tmpstream);
		return ecalloc(1, sizeof(char*));
	}

	/* pull data buffer into tmpfile */
	if ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {
		goto bail;
	}
	size = 0;
	lines = 0;
	lastch = 0;
	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {
		if (rcvd == -1 || rcvd > ((size_t)(-1))-size) {
			goto bail;
		}

		php_stream_write(tmpstream, data->buf, rcvd);

		size += rcvd;
		for (ptr = data->buf; rcvd; rcvd--, ptr++) {
			if (*ptr == '\n' && lastch == '\r') {
				lines++;
			}
			lastch = *ptr;
		}
	}

	ftp->data = data_close(ftp, data);

	php_stream_rewind(tmpstream);

	ret = safe_emalloc((lines + 1), sizeof(char*), size);

	entry = ret;
	text = (char*) (ret + lines + 1);
	*entry = text;
	lastch = 0;
	while ((ch = php_stream_getc(tmpstream)) != EOF) {
		if (ch == '\n' && lastch == '\r') {
			*(text - 1) = 0;
			*++entry = text;
		} else {
			*text++ = ch;
		}
		lastch = ch;
	}
	*entry = NULL;

	php_stream_close(tmpstream);

	if (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {
		efree(ret);
		return NULL;
	}

	return ret;
bail:
	ftp->data = data_close(ftp, data);
	php_stream_close(tmpstream);
	if (ret)
		efree(ret);
	return NULL;
}","char**
ftp_genlist(ftpbuf_t *VAR_0, const char *VAR_1, const char *VAR_2 TSRMLS_DC)
{
	php_stream	*VAR_3 = NULL;
	databuf_t	*VAR_4 = NULL;
	char		*VAR_5;
	int		VAR_6, VAR_7;
	size_t		VAR_8, VAR_9;
	size_t		VAR_10;
	char		**VAR_11 = NULL;
	char		**VAR_12;
	char		*VAR_13;


	if ((VAR_3 = php_stream_fopen_tmpfile()) == NULL) {
		VAR_14(NULL VAR_15, VAR_16, ""Unable to create temporary file.  Check permissions in temporary files directory."");
		return NULL;
	}

	if (!ftp_type(VAR_0, VAR_17)) {
		goto bail;
	}

	if ((VAR_4 = ftp_getdata(VAR_0 VAR_15)) == NULL) {
		goto bail;
	}
	VAR_0->data = VAR_4;

	if (!ftp_putcmd(VAR_0, VAR_1, VAR_2)) {
		goto bail;
	}
	if (!ftp_getresp(VAR_0) || (VAR_0->resp != 150 && VAR_0->resp != 125 && VAR_0->resp != 226)) {
		goto bail;
	}

	/* COMMENT_0 */
	if (VAR_0->resp == 226) {
		VAR_0->data = data_close(VAR_0, VAR_4);
		php_stream_close(VAR_3);
		return ecalloc(1, sizeof(char*));
	}

	/* COMMENT_1 */
	if ((VAR_4 = data_accept(VAR_4, VAR_0 VAR_15)) == NULL) {
		goto bail;
	}
	VAR_8 = 0;
	VAR_10 = 0;
	VAR_7 = 0;
	while ((VAR_9 = my_recv(VAR_0, VAR_4->fd, VAR_4->buf, VAR_18))) {
		if (VAR_9 == -1 || VAR_9 > ((size_t)(-1))-VAR_8) {
			goto bail;
		}

		php_stream_write(VAR_3, VAR_4->buf, VAR_9);

		VAR_8 += VAR_9;
		for (VAR_5 = VAR_4->buf; VAR_9; VAR_9--, VAR_5++) {
			if (*VAR_5 == '\n' && VAR_7 == '\r') {
				VAR_10++;
			}
			VAR_7 = *VAR_5;
		}
	}

	VAR_0->data = data_close(VAR_0, VAR_4);

	php_stream_rewind(VAR_3);

	VAR_11 = safe_emalloc((VAR_10 + 1), sizeof(char*), VAR_8);

	VAR_12 = VAR_11;
	VAR_13 = (char*) (VAR_11 + VAR_10 + 1);
	*VAR_12 = VAR_13;
	VAR_7 = 0;
	while ((VAR_6 = php_stream_getc(VAR_3)) != VAR_19) {
		if (VAR_6 == '\n' && VAR_7 == '\r') {
			*(VAR_13 - 1) = 0;
			*++VAR_12 = VAR_13;
		} else {
			*VAR_13++ = VAR_6;
		}
		VAR_7 = VAR_6;
	}
	*VAR_12 = NULL;

	php_stream_close(VAR_3);

	if (!ftp_getresp(VAR_0) || (VAR_0->resp != 226 && VAR_0->resp != 250)) {
		efree(VAR_11);
		return NULL;
	}

	return VAR_11;
bail:
	VAR_0->data = data_close(VAR_0, VAR_4);
	php_stream_close(VAR_3);
	if (VAR_11)
		efree(VAR_11);
	return NULL;
}",,"--- func_before
+++ func_after
@@ -58,8 +58,6 @@
 		for (ptr = data->buf; rcvd; rcvd--, ptr++) {
 			if (*ptr == '\n' && lastch == '\r') {
 				lines++;
-			} else {
-				size++;
 			}
 			lastch = *ptr;
 		}","{'deleted_lines': ['\t\t\t} else {', '\t\t\t\tsize++;'], 'added_lines': []}",True,"Integer overflow in the ftp_genlist function in ext/ftp/ftp.c in PHP before 5.4.42, 5.5.x before 5.5.26, and 5.6.x before 5.6.10 allows remote FTP servers to execute arbitrary code via a long reply to a LIST command, leading to a heap-based buffer overflow.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-4022.",9.8,CRITICAL,3,valid,2015-06-01T00:23:06Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_set_array,"static void spl_array_set_array(zval *object, spl_array_object *intern, zval **array, long ar_flags, int just_array TSRMLS_DC) {
if (Z_TYPE_PP(array) == IS_ARRAY) {
SEPARATE_ZVAL_IF_NOT_REF(array);
}
if (Z_TYPE_PP(array) == IS_OBJECT && (Z_OBJ_HT_PP(array) == &spl_handler_ArrayObject || Z_OBJ_HT_PP(array) == &spl_handler_ArrayIterator)) {
zval_ptr_dtor(&intern->array);
if (just_array){
spl_array_object *other = (spl_array_object*)zend_object_store_get_object(*array TSRMLS_CC);
ar_flags = other->ar_flags & ~SPL_ARRAY_INT_MASK;
}
ar_flags |= SPL_ARRAY_USE_OTHER;
intern->array = *array;
} else {
if (Z_TYPE_PP(array) != IS_OBJECT && Z_TYPE_PP(array) != IS_ARRAY) {
zend_throw_exception(spl_ce_InvalidArgumentException, ""Passed variable is not an array or object, using empty array instead"", 0 TSRMLS_CC);
return;
}
zval_ptr_dtor(&intern->array);
intern->array = *array;
}
if (object == *array) {
intern->ar_flags |= SPL_ARRAY_IS_SELF;
intern->ar_flags &= ~SPL_ARRAY_USE_OTHER;
} else {
intern->ar_flags &= ~SPL_ARRAY_IS_SELF;
}
intern->ar_flags |= ar_flags;
Z_ADDREF_P(intern->array);
if (Z_TYPE_PP(array) == IS_OBJECT) {
zend_object_get_properties_t handler = Z_OBJ_HANDLER_PP(array, get_properties);
if ((handler != std_object_handlers.get_properties && handler != spl_array_get_properties)
|| !spl_array_get_hash_table(intern, 0 TSRMLS_CC)) {
zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, ""Overloaded object of type %s is not compatible with %s"", Z_OBJCE_PP(array)->name, intern->std.ce->name);
}
}
spl_array_rewind(intern TSRMLS_CC);
}","static void spl_array_set_array(zval *VAR_0, spl_array_object *VAR_1, zval **VAR_2, long VAR_3, int VAR_4 TSRMLS_DC) {
if (Z_TYPE_PP(VAR_2) == VAR_5) {
SEPARATE_ZVAL_IF_NOT_REF(VAR_2);
}
if (Z_TYPE_PP(VAR_2) == VAR_6 && (Z_OBJ_HT_PP(VAR_2) == &VAR_7 || Z_OBJ_HT_PP(VAR_2) == &VAR_8)) {
zval_ptr_dtor(&VAR_1->array);
if (VAR_4){
spl_array_object *VAR_9 = (spl_array_object*)zend_object_store_get_object(*VAR_2 VAR_10);
VAR_3 = VAR_9->ar_flags & ~VAR_11;
}
VAR_3 |= VAR_12;
VAR_1->array = *VAR_2;
} else {
if (Z_TYPE_PP(VAR_2) != VAR_6 && Z_TYPE_PP(VAR_2) != VAR_5) {
zend_throw_exception(VAR_13, ""Passed variable is not an array or object, using empty array instead"", 0 VAR_10);
return;
}
zval_ptr_dtor(&VAR_1->array);
VAR_1->array = *VAR_2;
}
if (VAR_0 == *VAR_2) {
VAR_1->ar_flags |= VAR_14;
VAR_1->ar_flags &= ~VAR_12;
} else {
VAR_1->ar_flags &= ~VAR_14;
}
VAR_1->ar_flags |= VAR_3;
Z_ADDREF_P(VAR_1->array);
if (Z_TYPE_PP(VAR_2) == VAR_6) {
zend_object_get_properties_t VAR_15 = Z_OBJ_HANDLER_PP(VAR_2, VAR_16);
if ((VAR_15 != VAR_17.get_properties && VAR_15 != VAR_18)
|| !spl_array_get_hash_table(VAR_1, 0 VAR_10)) {
zend_throw_exception_ex(VAR_13, 0 VAR_10, ""Overloaded object of type %s is not compatible with %s"", Z_OBJCE_PP(VAR_2)->name, VAR_1->std.ce->name);
}
}
VAR_19(intern TSRMLS_CC);
}",,"static void spl_array_set_array(zval *object, spl_array_object *intern, zval **array, long ar_flags, int just_array TSRMLS_DC) {

	if (Z_TYPE_PP(array) == IS_ARRAY) {
		SEPARATE_ZVAL_IF_NOT_REF(array);
	}

	if (Z_TYPE_PP(array) == IS_OBJECT && (Z_OBJ_HT_PP(array) == &spl_handler_ArrayObject || Z_OBJ_HT_PP(array) == &spl_handler_ArrayIterator)) {
		zval_ptr_dtor(&intern->array);
		if (just_array)	{
			spl_array_object *other = (spl_array_object*)zend_object_store_get_object(*array TSRMLS_CC);
			ar_flags = other->ar_flags & ~SPL_ARRAY_INT_MASK;
		}
		ar_flags |= SPL_ARRAY_USE_OTHER;
		intern->array = *array;
	} else {
		if (Z_TYPE_PP(array) != IS_OBJECT && Z_TYPE_PP(array) != IS_ARRAY) {
			zend_throw_exception(spl_ce_InvalidArgumentException, ""Passed variable is not an array or object, using empty array instead"", 0 TSRMLS_CC);
			return;
		}
		zval_ptr_dtor(&intern->array);
		intern->array = *array;
	}
	if (object == *array) {
		intern->ar_flags |= SPL_ARRAY_IS_SELF;
		intern->ar_flags &= ~SPL_ARRAY_USE_OTHER;
	} else {
		intern->ar_flags &= ~SPL_ARRAY_IS_SELF;
	}
	intern->ar_flags |= ar_flags;
	Z_ADDREF_P(intern->array);
	if (Z_TYPE_PP(array) == IS_OBJECT) {
		zend_object_get_properties_t handler = Z_OBJ_HANDLER_PP(array, get_properties);
		if ((handler != std_object_handlers.get_properties && handler != spl_array_get_properties)
		|| !spl_array_get_hash_table(intern, 0 TSRMLS_CC)) {
			zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, ""Overloaded object of type %s is not compatible with %s"", Z_OBJCE_PP(array)->name, intern->std.ce->name);
		}
	}

	spl_array_rewind(intern TSRMLS_CC);
}","static void spl_array_set_array(zval *VAR_0, spl_array_object *VAR_1, zval **VAR_2, long VAR_3, int VAR_4 TSRMLS_DC) {

	if (Z_TYPE_PP(VAR_2) == VAR_5) {
		SEPARATE_ZVAL_IF_NOT_REF(VAR_2);
	}

	if (Z_TYPE_PP(VAR_2) == VAR_6 && (Z_OBJ_HT_PP(VAR_2) == &VAR_7 || Z_OBJ_HT_PP(VAR_2) == &VAR_8)) {
		zval_ptr_dtor(&VAR_1->array);
		if (VAR_4)	{
			spl_array_object *VAR_9 = (spl_array_object*)zend_object_store_get_object(*VAR_2 VAR_10);
			VAR_3 = VAR_9->ar_flags & ~VAR_11;
		}
		VAR_3 |= VAR_12;
		VAR_1->array = *VAR_2;
	} else {
		if (Z_TYPE_PP(VAR_2) != VAR_6 && Z_TYPE_PP(VAR_2) != VAR_5) {
			zend_throw_exception(VAR_13, ""Passed variable is not an array or object, using empty array instead"", 0 VAR_10);
			return;
		}
		zval_ptr_dtor(&VAR_1->array);
		VAR_1->array = *VAR_2;
	}
	if (VAR_0 == *VAR_2) {
		VAR_1->ar_flags |= VAR_14;
		VAR_1->ar_flags &= ~VAR_12;
	} else {
		VAR_1->ar_flags &= ~VAR_14;
	}
	VAR_1->ar_flags |= VAR_3;
	Z_ADDREF_P(VAR_1->array);
	if (Z_TYPE_PP(VAR_2) == VAR_6) {
		zend_object_get_properties_t VAR_15 = Z_OBJ_HANDLER_PP(VAR_2, VAR_16);
		if ((VAR_15 != VAR_17.get_properties && VAR_15 != VAR_18)
		|| !spl_array_get_hash_table(VAR_1, 0 VAR_10)) {
			zend_throw_exception_ex(VAR_13, 0 VAR_10, ""Overloaded object of type %s is not compatible with %s"", Z_OBJCE_PP(VAR_2)->name, VAR_1->std.ce->name);
		}
	}

	VAR_19(intern TSRMLS_CC);
}",,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 		if (just_array)	{
 			spl_array_object *other = (spl_array_object*)zend_object_store_get_object(*array TSRMLS_CC);
 			ar_flags = other->ar_flags & ~SPL_ARRAY_INT_MASK;
-		}		
+		}
 		ar_flags |= SPL_ARRAY_USE_OTHER;
 		intern->array = *array;
 	} else {","{'deleted_lines': ['\t\t}\t\t'], 'added_lines': ['\t\t}']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_object_count_elements_helper,"int static spl_array_object_count_elements_helper(spl_array_object *intern, long *count TSRMLS_DC) 
{
HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
HashPosition pos;
if (!aht) {
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Array was modified outside object and is no longer an array"");
*count = 0;
return FAILURE;
}
if (Z_TYPE_P(intern->array) == IS_OBJECT) {
pos = intern->pos;
*count = 0;
spl_array_rewind(intern TSRMLS_CC);
while(intern->pos && spl_array_next(intern TSRMLS_CC) == SUCCESS) {
(*count)++;
}
spl_array_set_pos(intern, pos);
return SUCCESS;
} else {
*count = zend_hash_num_elements(aht);
return SUCCESS;
}
}","int static spl_array_object_count_elements_helper(spl_array_object *VAR_0, long *VAR_1 TSRMLS_DC) 
{
HashTable *VAR_2 = spl_array_get_hash_table(VAR_0, 0 VAR_3);
HashPosition VAR_4;
if (!VAR_2) {
VAR_5(NULL VAR_3, VAR_6, ""Array was modified outside object and is no longer an array"");
*VAR_1 = 0;
return VAR_7;
}
if (Z_TYPE_P(VAR_0->array) == VAR_8) {
VAR_4 = VAR_0->pos;
*VAR_1 = 0;
VAR_9(intern TSRMLS_CC);
while(intern->pos && spl_array_next(intern TSRMLS_CC) == VAR_10) {
(*VAR_1)++;
}
spl_array_set_pos(intern, VAR_4);
return VAR_10;
} else {
*VAR_1 = zend_hash_num_elements(VAR_2);
return VAR_10;
}
}",,"int static spl_array_object_count_elements_helper(spl_array_object *intern, long *count TSRMLS_DC) /* {{{ */
{
	HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
	HashPosition pos;

	if (!aht) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Array was modified outside object and is no longer an array"");
		*count = 0;
		return FAILURE;
	}

	if (Z_TYPE_P(intern->array) == IS_OBJECT) {
		/* We need to store the 'pos' since we'll modify it in the functions
		 * we're going to call and which do not support 'pos' as parameter. */
		pos = intern->pos;
		*count = 0;
		spl_array_rewind(intern TSRMLS_CC);
		while(intern->pos && spl_array_next(intern TSRMLS_CC) == SUCCESS) {
			(*count)++;
		}
		spl_array_set_pos(intern, pos);
		return SUCCESS;
	} else {
		*count = zend_hash_num_elements(aht);
		return SUCCESS;
	}
}","int static spl_array_object_count_elements_helper(spl_array_object *VAR_0, long *VAR_1 TSRMLS_DC) /* COMMENT_0 */
{
	HashTable *VAR_2 = spl_array_get_hash_table(VAR_0, 0 VAR_3);
	HashPosition VAR_4;

	if (!VAR_2) {
		VAR_5(NULL VAR_3, VAR_6, ""Array was modified outside object and is no longer an array"");
		*VAR_1 = 0;
		return VAR_7;
	}

	if (Z_TYPE_P(VAR_0->array) == VAR_8) {
		/* COMMENT_1 */
                                                                        
		VAR_4 = VAR_0->pos;
		*VAR_1 = 0;
		VAR_9(intern TSRMLS_CC);
		while(intern->pos && spl_array_next(intern TSRMLS_CC) == VAR_10) {
			(*VAR_1)++;
		}
		spl_array_set_pos(intern, VAR_4);
		return VAR_10;
	} else {
		*VAR_1 = zend_hash_num_elements(VAR_2);
		return VAR_10;
	}
}",,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 	}
 
 	if (Z_TYPE_P(intern->array) == IS_OBJECT) {
-		/* We need to store the 'pos' since we'll modify it in the functions 
+		/* We need to store the 'pos' since we'll modify it in the functions
 		 * we're going to call and which do not support 'pos' as parameter. */
 		pos = intern->pos;
 		*count = 0;","{'deleted_lines': [""\t\t/* We need to store the 'pos' since we'll modify it in the functions ""], 'added_lines': [""\t\t/* We need to store the 'pos' since we'll modify it in the functions""]}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_read_dimension_ex,"static zval *spl_array_read_dimension_ex(int check_inherited, zval *object, zval *offset, int type TSRMLS_DC) 
{
zval **ret;
if (check_inherited) {
spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
if (intern->fptr_offset_get) {
zval *rv;
if (!offset) {
ALLOC_INIT_ZVAL(offset);
} else {
SEPARATE_ARG_IF_REF(offset);
}
zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_get, ""offsetGet"", &rv, offset);
zval_ptr_dtor(&offset);
if (rv) {
zval_ptr_dtor(&intern->retval);
MAKE_STD_ZVAL(intern->retval);
ZVAL_ZVAL(intern->retval, rv, 1, 1);
return intern->retval;
}
return EG(uninitialized_zval_ptr);
}
}
ret = spl_array_get_dimension_ptr_ptr(check_inherited, object, offset, type TSRMLS_CC);
if ((type == BP_VAR_W || type == BP_VAR_RW || type == BP_VAR_UNSET) && !Z_ISREF_PP(ret) && ret != &EG(uninitialized_zval_ptr)) {
if (Z_REFCOUNT_PP(ret) > 1) {
zval *newval;
MAKE_STD_ZVAL(newval);
*newval = **ret;
zval_copy_ctor(newval);
Z_SET_REFCOUNT_P(newval, 1);
Z_DELREF_PP(ret);
*ret = newval;
}
Z_SET_ISREF_PP(ret);
}
return *ret;
}","static zval *spl_array_read_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2, int VAR_3 TSRMLS_DC) 
{
zval **VAR_4;
if (VAR_0) {
spl_array_object *VAR_5 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_6);
if (VAR_5->fptr_offset_get) {
zval *VAR_7;
if (!VAR_2) {
ALLOC_INIT_ZVAL(VAR_2);
} else {
SEPARATE_ARG_IF_REF(VAR_2);
}
zend_call_method_with_1_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_5->fptr_offset_get, ""offsetGet"", &VAR_7, VAR_2);
zval_ptr_dtor(&VAR_2);
if (VAR_7) {
zval_ptr_dtor(&VAR_5->retval);
MAKE_STD_ZVAL(VAR_5->retval);
ZVAL_ZVAL(VAR_5->retval, VAR_7, 1, 1);
return VAR_5->retval;
}
return EG(VAR_8);
}
}
VAR_4 = spl_array_get_dimension_ptr_ptr(VAR_0, VAR_1, VAR_2, VAR_3 VAR_6);
if ((VAR_3 == VAR_9 || VAR_3 == VAR_10 || VAR_3 == VAR_11) && !Z_ISREF_PP(VAR_4) && VAR_4 != &EG(VAR_8)) {
if (Z_REFCOUNT_PP(VAR_4) > 1) {
zval *VAR_12;
MAKE_STD_ZVAL(VAR_12);
*VAR_12 = **VAR_4;
zval_copy_ctor(VAR_12);
Z_SET_REFCOUNT_P(VAR_12, 1);
Z_DELREF_PP(VAR_4);
*VAR_4 = VAR_12;
}
Z_SET_ISREF_PP(VAR_4);
}
return *VAR_4;
}",,"static zval *spl_array_read_dimension_ex(int check_inherited, zval *object, zval *offset, int type TSRMLS_DC) /* {{{ */
{
	zval **ret;

	if (check_inherited) {
		spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
		if (intern->fptr_offset_get) {
			zval *rv;
			if (!offset) {
				ALLOC_INIT_ZVAL(offset);
			} else {
				SEPARATE_ARG_IF_REF(offset);
			}
			zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_get, ""offsetGet"", &rv, offset);
			zval_ptr_dtor(&offset);
			if (rv) {
				zval_ptr_dtor(&intern->retval);
				MAKE_STD_ZVAL(intern->retval);
				ZVAL_ZVAL(intern->retval, rv, 1, 1);
				return intern->retval;
			}
			return EG(uninitialized_zval_ptr);
		}
	}
	ret = spl_array_get_dimension_ptr_ptr(check_inherited, object, offset, type TSRMLS_CC);

	/* When in a write context,
	 * ZE has to be fooled into thinking this is in a reference set
	 * by separating (if necessary) and returning as an is_ref=1 zval (even if refcount == 1) */
	if ((type == BP_VAR_W || type == BP_VAR_RW || type == BP_VAR_UNSET) && !Z_ISREF_PP(ret) && ret != &EG(uninitialized_zval_ptr)) {
		if (Z_REFCOUNT_PP(ret) > 1) {
			zval *newval;

			/* Separate */
			MAKE_STD_ZVAL(newval);
			*newval = **ret;
			zval_copy_ctor(newval);
			Z_SET_REFCOUNT_P(newval, 1);

			/* Replace */
			Z_DELREF_PP(ret);
			*ret = newval;
		}

		Z_SET_ISREF_PP(ret);
	}

	return *ret;
}","static zval *spl_array_read_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2, int VAR_3 TSRMLS_DC) /* COMMENT_0 */
{
	zval **VAR_4;

	if (VAR_0) {
		spl_array_object *VAR_5 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_6);
		if (VAR_5->fptr_offset_get) {
			zval *VAR_7;
			if (!VAR_2) {
				ALLOC_INIT_ZVAL(VAR_2);
			} else {
				SEPARATE_ARG_IF_REF(VAR_2);
			}
			zend_call_method_with_1_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_5->fptr_offset_get, ""offsetGet"", &VAR_7, VAR_2);
			zval_ptr_dtor(&VAR_2);
			if (VAR_7) {
				zval_ptr_dtor(&VAR_5->retval);
				MAKE_STD_ZVAL(VAR_5->retval);
				ZVAL_ZVAL(VAR_5->retval, VAR_7, 1, 1);
				return VAR_5->retval;
			}
			return EG(VAR_8);
		}
	}
	VAR_4 = spl_array_get_dimension_ptr_ptr(VAR_0, VAR_1, VAR_2, VAR_3 VAR_6);

	/* COMMENT_1 */
                                                                
                                                                                             
	if ((VAR_3 == VAR_9 || VAR_3 == VAR_10 || VAR_3 == VAR_11) && !Z_ISREF_PP(VAR_4) && VAR_4 != &EG(VAR_8)) {
		if (Z_REFCOUNT_PP(VAR_4) > 1) {
			zval *VAR_12;

			/* COMMENT_4 */
			MAKE_STD_ZVAL(VAR_12);
			*VAR_12 = **VAR_4;
			zval_copy_ctor(VAR_12);
			Z_SET_REFCOUNT_P(VAR_12, 1);

			/* COMMENT_5 */
			Z_DELREF_PP(VAR_4);
			*VAR_4 = VAR_12;
		}

		Z_SET_ISREF_PP(VAR_4);
	}

	return *VAR_4;
}",,"--- func_before
+++ func_after
@@ -11,7 +11,7 @@
 			} else {
 				SEPARATE_ARG_IF_REF(offset);
 			}
-			zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_get, ""offsetGet"", &rv, offset);	
+			zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_get, ""offsetGet"", &rv, offset);
 			zval_ptr_dtor(&offset);
 			if (rv) {
 				zval_ptr_dtor(&intern->retval);","{'deleted_lines': ['\t\t\tzend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_get, ""offsetGet"", &rv, offset);\t'], 'added_lines': ['\t\t\tzend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_get, ""offsetGet"", &rv, offset);']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_it_move_forward,"static void spl_array_it_move_forward(zend_object_iterator *iter TSRMLS_DC) 
{
spl_array_it       *iterator = (spl_array_it *)iter;
spl_array_object   *object   = iterator->object;
HashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);
if (object->ar_flags & SPL_ARRAY_OVERLOADED_NEXT) {
zend_user_it_move_forward(iter TSRMLS_CC);
} else {
zend_user_it_invalidate_current(iter TSRMLS_CC);
if (!aht) {
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ArrayIterator::current(): Array was modified outside object and is no longer an array"");
return;
}
if ((object->ar_flags & SPL_ARRAY_IS_REF) && spl_hash_verify_pos_ex(object, aht TSRMLS_CC) == FAILURE) {
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ArrayIterator::next(): Array was modified outside object and internal position is no longer valid"");
} else {
spl_array_next_no_verify(object, aht TSRMLS_CC);
}
}
}","static void spl_array_it_move_forward(zend_object_iterator *VAR_0 TSRMLS_DC) 
{
spl_array_it       *VAR_1 = (spl_array_it *)VAR_0;
spl_array_object   *VAR_2   = VAR_1->object;
HashTable          *VAR_3      = spl_array_get_hash_table(VAR_2, 0 VAR_4);
if (VAR_2->ar_flags & VAR_5) {
VAR_6(iter TSRMLS_CC);
} else {
VAR_7(iter TSRMLS_CC);
if (!VAR_3) {
VAR_8(NULL TSRMLS_CC, VAR_9, ""ArrayIterator::current(): Array was modified outside object and is no longer an array"");
return;
}
if ((VAR_2->ar_flags & VAR_10) && spl_hash_verify_pos_ex(VAR_2, VAR_3 TSRMLS_CC) == VAR_11) {
VAR_8(NULL TSRMLS_CC, VAR_9, ""ArrayIterator::next(): Array was modified outside object and internal position is no longer valid"");
} else {
spl_array_next_no_verify(VAR_2, VAR_3 TSRMLS_CC);
}
}
}",,"static void spl_array_it_move_forward(zend_object_iterator *iter TSRMLS_DC) /* {{{ */
{
	spl_array_it       *iterator = (spl_array_it *)iter;
	spl_array_object   *object   = iterator->object;
	HashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);

	if (object->ar_flags & SPL_ARRAY_OVERLOADED_NEXT) {
		zend_user_it_move_forward(iter TSRMLS_CC);
	} else {
		zend_user_it_invalidate_current(iter TSRMLS_CC);
		if (!aht) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ArrayIterator::current(): Array was modified outside object and is no longer an array"");
			return;
		}

		if ((object->ar_flags & SPL_ARRAY_IS_REF) && spl_hash_verify_pos_ex(object, aht TSRMLS_CC) == FAILURE) {
			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ArrayIterator::next(): Array was modified outside object and internal position is no longer valid"");
		} else {
			spl_array_next_no_verify(object, aht TSRMLS_CC);
		}
	}
}","static void spl_array_it_move_forward(zend_object_iterator *VAR_0 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_it       *VAR_1 = (spl_array_it *)VAR_0;
	spl_array_object   *VAR_2   = VAR_1->object;
	HashTable          *VAR_3      = spl_array_get_hash_table(VAR_2, 0 VAR_4);

	if (VAR_2->ar_flags & VAR_5) {
		VAR_6(iter TSRMLS_CC);
	} else {
		VAR_7(iter TSRMLS_CC);
		if (!VAR_3) {
			VAR_8(NULL TSRMLS_CC, VAR_9, ""ArrayIterator::current(): Array was modified outside object and is no longer an array"");
			return;
		}

		if ((VAR_2->ar_flags & VAR_10) && spl_hash_verify_pos_ex(VAR_2, VAR_3 TSRMLS_CC) == VAR_11) {
			VAR_8(NULL TSRMLS_CC, VAR_9, ""ArrayIterator::next(): Array was modified outside object and internal position is no longer valid"");
		} else {
			spl_array_next_no_verify(VAR_2, VAR_3 TSRMLS_CC);
		}
	}
}",,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ArrayIterator::current(): Array was modified outside object and is no longer an array"");
 			return;
 		}
-	
+
 		if ((object->ar_flags & SPL_ARRAY_IS_REF) && spl_hash_verify_pos_ex(object, aht TSRMLS_CC) == FAILURE) {
 			php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""ArrayIterator::next(): Array was modified outside object and internal position is no longer valid"");
 		} else {","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_write_dimension_ex,"static void spl_array_write_dimension_ex(int check_inherited, zval *object, zval *offset, zval *value TSRMLS_DC) 
{
spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
long index;
HashTable *ht;
if (check_inherited && intern->fptr_offset_set) {
if (!offset) {
ALLOC_INIT_ZVAL(offset);
} else {
SEPARATE_ARG_IF_REF(offset);
}
zend_call_method_with_2_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_set, ""offsetSet"", NULL, offset, value);
zval_ptr_dtor(&offset);
return;
}
if (!offset) {
ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (ht->nApplyCount > 0) {
zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
Z_ADDREF_P(value);
zend_hash_next_index_insert(ht, (void**)&value, sizeof(void*), NULL);
return;
}
switch(Z_TYPE_P(offset)) {
case IS_STRING:
ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (ht->nApplyCount > 0) {
zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
Z_ADDREF_P(value);
zend_symtable_update(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void**)&value, sizeof(void*), NULL);
return;
case IS_DOUBLE:
case IS_RESOURCE:
case IS_BOOL: 
case IS_LONG: 
ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (ht->nApplyCount > 0) {
zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
if (offset->type == IS_DOUBLE) {
index = (long)Z_DVAL_P(offset);
} else {
index = Z_LVAL_P(offset);
}
Z_ADDREF_P(value);
zend_hash_index_update(ht, index, (void**)&value, sizeof(void*), NULL);
return;
case IS_NULL:
ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (ht->nApplyCount > 0) {
zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
Z_ADDREF_P(value);
zend_hash_next_index_insert(ht, (void**)&value, sizeof(void*), NULL);
return;
default:
zend_error(E_WARNING, ""Illegal offset type"");
return;
}
}","static void spl_array_write_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2, zval *VAR_3 TSRMLS_DC) 
{
spl_array_object *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);
long VAR_6;
HashTable *VAR_7;
if (VAR_0 && VAR_4->fptr_offset_set) {
if (!VAR_2) {
ALLOC_INIT_ZVAL(VAR_2);
} else {
SEPARATE_ARG_IF_REF(VAR_2);
}
zend_call_method_with_2_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_4->fptr_offset_set, ""offsetSet"", NULL, VAR_2, VAR_3);
zval_ptr_dtor(&VAR_2);
return;
}
if (!VAR_2) {
VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
if (VAR_7->nApplyCount > 0) {
zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
Z_ADDREF_P(VAR_3);
zend_hash_next_index_insert(VAR_7, (void**)&VAR_3, sizeof(void*), NULL);
return;
}
switch(Z_TYPE_P(VAR_2)) {
case VAR_9:
VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
if (VAR_7->nApplyCount > 0) {
zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
Z_ADDREF_P(VAR_3);
zend_symtable_update(VAR_7, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void**)&VAR_3, sizeof(void*), NULL);
return;
case VAR_10:
case VAR_11:
case VAR_12: 
case VAR_13: 
VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
if (VAR_7->nApplyCount > 0) {
zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
if (VAR_2->type == VAR_10) {
VAR_6 = (long)Z_DVAL_P(VAR_2);
} else {
VAR_6 = Z_LVAL_P(VAR_2);
}
Z_ADDREF_P(VAR_3);
zend_hash_index_update(VAR_7, VAR_6, (void**)&VAR_3, sizeof(void*), NULL);
return;
case VAR_14:
VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
if (VAR_7->nApplyCount > 0) {
zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
Z_ADDREF_P(VAR_3);
zend_hash_next_index_insert(VAR_7, (void**)&VAR_3, sizeof(void*), NULL);
return;
default:
zend_error(VAR_8, ""Illegal offset type"");
return;
}
}",,"static void spl_array_write_dimension_ex(int check_inherited, zval *object, zval *offset, zval *value TSRMLS_DC) /* {{{ */
{
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
	long index;
	HashTable *ht;

	if (check_inherited && intern->fptr_offset_set) {
		if (!offset) {
			ALLOC_INIT_ZVAL(offset);
		} else {
			SEPARATE_ARG_IF_REF(offset);
		}
		zend_call_method_with_2_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_set, ""offsetSet"", NULL, offset, value);
		zval_ptr_dtor(&offset);
		return;
	}

	if (!offset) {
		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
		if (ht->nApplyCount > 0) {
			zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		Z_ADDREF_P(value);
		zend_hash_next_index_insert(ht, (void**)&value, sizeof(void*), NULL);
		return;
	}
	switch(Z_TYPE_P(offset)) {
	case IS_STRING:
		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
		if (ht->nApplyCount > 0) {
			zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		Z_ADDREF_P(value);
		zend_symtable_update(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void**)&value, sizeof(void*), NULL);
		return;
	case IS_DOUBLE:
	case IS_RESOURCE:
	case IS_BOOL:
	case IS_LONG:
		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
		if (ht->nApplyCount > 0) {
			zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		if (offset->type == IS_DOUBLE) {
			index = (long)Z_DVAL_P(offset);
		} else {
			index = Z_LVAL_P(offset);
		}
		Z_ADDREF_P(value);
		zend_hash_index_update(ht, index, (void**)&value, sizeof(void*), NULL);
		return;
	case IS_NULL:
		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
		if (ht->nApplyCount > 0) {
			zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		Z_ADDREF_P(value);
		zend_hash_next_index_insert(ht, (void**)&value, sizeof(void*), NULL);
		return;
	default:
		zend_error(E_WARNING, ""Illegal offset type"");
		return;
	}
}","static void spl_array_write_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2, zval *VAR_3 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_object *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);
	long VAR_6;
	HashTable *VAR_7;

	if (VAR_0 && VAR_4->fptr_offset_set) {
		if (!VAR_2) {
			ALLOC_INIT_ZVAL(VAR_2);
		} else {
			SEPARATE_ARG_IF_REF(VAR_2);
		}
		zend_call_method_with_2_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_4->fptr_offset_set, ""offsetSet"", NULL, VAR_2, VAR_3);
		zval_ptr_dtor(&VAR_2);
		return;
	}

	if (!VAR_2) {
		VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
		if (VAR_7->nApplyCount > 0) {
			zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		Z_ADDREF_P(VAR_3);
		zend_hash_next_index_insert(VAR_7, (void**)&VAR_3, sizeof(void*), NULL);
		return;
	}
	switch(Z_TYPE_P(VAR_2)) {
	case VAR_9:
		VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
		if (VAR_7->nApplyCount > 0) {
			zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		Z_ADDREF_P(VAR_3);
		zend_symtable_update(VAR_7, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void**)&VAR_3, sizeof(void*), NULL);
		return;
	case VAR_10:
	case VAR_11:
	case VAR_12:
	case VAR_13:
		VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
		if (VAR_7->nApplyCount > 0) {
			zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		if (VAR_2->type == VAR_10) {
			VAR_6 = (long)Z_DVAL_P(VAR_2);
		} else {
			VAR_6 = Z_LVAL_P(VAR_2);
		}
		Z_ADDREF_P(VAR_3);
		zend_hash_index_update(VAR_7, VAR_6, (void**)&VAR_3, sizeof(void*), NULL);
		return;
	case VAR_14:
		VAR_7 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
		if (VAR_7->nApplyCount > 0) {
			zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		Z_ADDREF_P(VAR_3);
		zend_hash_next_index_insert(VAR_7, (void**)&VAR_3, sizeof(void*), NULL);
		return;
	default:
		zend_error(VAR_8, ""Illegal offset type"");
		return;
	}
}",,"--- func_before
+++ func_after
@@ -14,7 +14,7 @@
 		zval_ptr_dtor(&offset);
 		return;
 	}
-	
+
 	if (!offset) {
 		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
 		if (ht->nApplyCount > 0) {
@@ -37,8 +37,8 @@
 		return;
 	case IS_DOUBLE:
 	case IS_RESOURCE:
-	case IS_BOOL: 
-	case IS_LONG: 
+	case IS_BOOL:
+	case IS_LONG:
 		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
 		if (ht->nApplyCount > 0) {
 			zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");","{'deleted_lines': ['\t', '\tcase IS_BOOL: ', '\tcase IS_LONG: '], 'added_lines': ['', '\tcase IS_BOOL:', '\tcase IS_LONG:']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_it_get_current_key,"static int spl_array_it_get_current_key(zend_object_iterator *iter, char **str_key, uint *str_key_len, ulong *int_key TSRMLS_DC) 
{
spl_array_it       *iterator = (spl_array_it *)iter;
spl_array_object   *object   = iterator->object;
HashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);
if (object->ar_flags & SPL_ARRAY_OVERLOADED_KEY) {
return zend_user_it_get_current_key(iter, str_key, str_key_len, int_key TSRMLS_CC);
} else {
if (spl_array_object_verify_pos_ex(object, aht, ""ArrayIterator::current(): "" TSRMLS_CC) == FAILURE) {
return HASH_KEY_NON_EXISTANT;
}
return zend_hash_get_current_key_ex(aht, str_key, str_key_len, int_key, 1, &object->pos);
}
}","static int spl_array_it_get_current_key(zend_object_iterator *VAR_0, char **VAR_1, uint *VAR_2, ulong *VAR_3 TSRMLS_DC) 
{
spl_array_it       *VAR_4 = (spl_array_it *)VAR_0;
spl_array_object   *VAR_5   = VAR_4->object;
HashTable          *VAR_6      = spl_array_get_hash_table(VAR_5, 0 VAR_7);
if (VAR_5->ar_flags & VAR_8) {
return zend_user_it_get_current_key(VAR_0, VAR_1, VAR_2, VAR_3 VAR_7);
} else {
if (spl_array_object_verify_pos_ex(VAR_5, VAR_6, ""ArrayIterator::current(): "" VAR_7) == VAR_9) {
return VAR_10;
}
return zend_hash_get_current_key_ex(VAR_6, VAR_1, VAR_2, VAR_3, 1, &VAR_5->pos);
}
}",,"static int spl_array_it_get_current_key(zend_object_iterator *iter, char **str_key, uint *str_key_len, ulong *int_key TSRMLS_DC) /* {{{ */
{
	spl_array_it       *iterator = (spl_array_it *)iter;
	spl_array_object   *object   = iterator->object;
	HashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);

	if (object->ar_flags & SPL_ARRAY_OVERLOADED_KEY) {
		return zend_user_it_get_current_key(iter, str_key, str_key_len, int_key TSRMLS_CC);
	} else {
		if (spl_array_object_verify_pos_ex(object, aht, ""ArrayIterator::current(): "" TSRMLS_CC) == FAILURE) {
			return HASH_KEY_NON_EXISTANT;
		}

		return zend_hash_get_current_key_ex(aht, str_key, str_key_len, int_key, 1, &object->pos);
	}
}","static int spl_array_it_get_current_key(zend_object_iterator *VAR_0, char **VAR_1, uint *VAR_2, ulong *VAR_3 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_it       *VAR_4 = (spl_array_it *)VAR_0;
	spl_array_object   *VAR_5   = VAR_4->object;
	HashTable          *VAR_6      = spl_array_get_hash_table(VAR_5, 0 VAR_7);

	if (VAR_5->ar_flags & VAR_8) {
		return zend_user_it_get_current_key(VAR_0, VAR_1, VAR_2, VAR_3 VAR_7);
	} else {
		if (spl_array_object_verify_pos_ex(VAR_5, VAR_6, ""ArrayIterator::current(): "" VAR_7) == VAR_9) {
			return VAR_10;
		}

		return zend_hash_get_current_key_ex(VAR_6, VAR_1, VAR_2, VAR_3, 1, &VAR_5->pos);
	}
}",,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 		if (spl_array_object_verify_pos_ex(object, aht, ""ArrayIterator::current(): "" TSRMLS_CC) == FAILURE) {
 			return HASH_KEY_NON_EXISTANT;
 		}
-	
+
 		return zend_hash_get_current_key_ex(aht, str_key, str_key_len, int_key, 1, &object->pos);
 	}
 }","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_get_iterator,"zend_object_iterator *spl_array_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC) 
{
spl_array_it       *iterator;
spl_array_object   *array_object = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
if (by_ref && (array_object->ar_flags & SPL_ARRAY_OVERLOADED_CURRENT)) {
zend_error(E_ERROR, ""An iterator cannot be used with foreach by reference"");
}
iterator     = emalloc(sizeof(spl_array_it));
Z_ADDREF_P(object);
iterator->intern.it.data = (void*)object;
iterator->intern.it.funcs = &spl_array_it_funcs;
iterator->intern.ce = ce;
iterator->intern.value = NULL;
iterator->object = array_object;
return (zend_object_iterator*)iterator;
}","zend_object_iterator *spl_array_get_iterator(zend_class_entry *VAR_0, zval *VAR_1, int VAR_2 TSRMLS_DC) 
{
spl_array_it       *VAR_3;
spl_array_object   *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);
if (VAR_2 && (VAR_4->ar_flags & VAR_6)) {
zend_error(VAR_7, ""An iterator cannot be used with foreach by reference"");
}
VAR_3     = emalloc(sizeof(spl_array_it));
Z_ADDREF_P(VAR_1);
VAR_3->intern.it.data = (void*)VAR_1;
VAR_3->intern.it.funcs = &VAR_8;
VAR_3->intern.ce = VAR_0;
VAR_3->intern.value = NULL;
VAR_3->object = VAR_4;
return (zend_object_iterator*)VAR_3;
}",,"zend_object_iterator *spl_array_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC) /* {{{ */
{
	spl_array_it       *iterator;
	spl_array_object   *array_object = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);

	if (by_ref && (array_object->ar_flags & SPL_ARRAY_OVERLOADED_CURRENT)) {
		zend_error(E_ERROR, ""An iterator cannot be used with foreach by reference"");
	}

	iterator     = emalloc(sizeof(spl_array_it));

	Z_ADDREF_P(object);
	iterator->intern.it.data = (void*)object;
	iterator->intern.it.funcs = &spl_array_it_funcs;
	iterator->intern.ce = ce;
	iterator->intern.value = NULL;
	iterator->object = array_object;

	return (zend_object_iterator*)iterator;
}","zend_object_iterator *spl_array_get_iterator(zend_class_entry *VAR_0, zval *VAR_1, int VAR_2 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_it       *VAR_3;
	spl_array_object   *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);

	if (VAR_2 && (VAR_4->ar_flags & VAR_6)) {
		zend_error(VAR_7, ""An iterator cannot be used with foreach by reference"");
	}

	VAR_3     = emalloc(sizeof(spl_array_it));

	Z_ADDREF_P(VAR_1);
	VAR_3->intern.it.data = (void*)VAR_1;
	VAR_3->intern.it.funcs = &VAR_8;
	VAR_3->intern.ce = VAR_0;
	VAR_3->intern.value = NULL;
	VAR_3->object = VAR_4;

	return (zend_object_iterator*)VAR_3;
}",,"--- func_before
+++ func_after
@@ -15,6 +15,6 @@
 	iterator->intern.ce = ce;
 	iterator->intern.value = NULL;
 	iterator->object = array_object;
-	
+
 	return (zend_object_iterator*)iterator;
 }","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_get_dimension_ptr_ptr,"static zval **spl_array_get_dimension_ptr_ptr(int check_inherited, zval *object, zval *offset, int type TSRMLS_DC) 
{
spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
zval **retval;
long index;
HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (!offset) {
return &EG(uninitialized_zval_ptr);
}
if ((type == BP_VAR_W || type == BP_VAR_RW) && (ht->nApplyCount > 0)) {
zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
return &EG(error_zval_ptr);;
}
switch(Z_TYPE_P(offset)) {
case IS_NULL:
Z_STRVAL_P(offset) = """";
Z_STRLEN_P(offset) = 0;
case IS_STRING:
if (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &retval) == FAILURE) {
switch (type) {
case BP_VAR_R:
zend_error(E_NOTICE, ""Undefined index: %s"", Z_STRVAL_P(offset));
case BP_VAR_UNSET:
case BP_VAR_IS:
retval = &EG(uninitialized_zval_ptr);
break;
case BP_VAR_RW:
zend_error(E_NOTICE,""Undefined index: %s"", Z_STRVAL_P(offset));
case BP_VAR_W: {
zval *value;
ALLOC_INIT_ZVAL(value);
zend_symtable_update(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void**)&value, sizeof(void*), (void **)&retval);
}
}
}
return retval;
case IS_RESOURCE:
zend_error(E_STRICT, ""Resource ID#%ld used as offset, casting to integer (%ld)"", Z_LVAL_P(offset), Z_LVAL_P(offset));
case IS_DOUBLE:
case IS_BOOL: 
case IS_LONG: 
if (offset->type == IS_DOUBLE) {
index = (long)Z_DVAL_P(offset);
} else {
index = Z_LVAL_P(offset);
}
if (zend_hash_index_find(ht, index, (void **) &retval) == FAILURE) {
switch (type) {
case BP_VAR_R:
zend_error(E_NOTICE, ""Undefined offset: %ld"", index);
case BP_VAR_UNSET:
case BP_VAR_IS:
retval = &EG(uninitialized_zval_ptr);
break;
case BP_VAR_RW:
zend_error(E_NOTICE, ""Undefined offset: %ld"", index);
case BP_VAR_W: {
zval *value;
ALLOC_INIT_ZVAL(value);
zend_hash_index_update(ht, index, (void**)&value, sizeof(void*), (void **)&retval);
}
}
}
return retval;
default:
zend_error(E_WARNING, ""Illegal offset type"");
return (type == BP_VAR_W || type == BP_VAR_RW) ?
&EG(error_zval_ptr) : &EG(uninitialized_zval_ptr);
}
}","static zval **spl_array_get_dimension_ptr_ptr(int VAR_0, zval *VAR_1, zval *VAR_2, int VAR_3 TSRMLS_DC) 
{
spl_array_object *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);
zval **VAR_6;
long VAR_7;
HashTable *VAR_8 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
if (!VAR_2) {
return &EG(VAR_9);
}
if ((VAR_3 == VAR_10 || VAR_3 == VAR_11) && (VAR_8->nApplyCount > 0)) {
zend_error(VAR_12, ""Modification of ArrayObject during sorting is prohibited"");
return &EG(VAR_13);;
}
switch(Z_TYPE_P(VAR_2)) {
case VAR_14:
Z_STRVAL_P(VAR_2) = """";
Z_STRLEN_P(VAR_2) = 0;
case VAR_15:
if (zend_symtable_find(VAR_8, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void **) &VAR_6) == VAR_16) {
switch (VAR_3) {
case VAR_17:
zend_error(VAR_18, ""Undefined index: %s"", Z_STRVAL_P(VAR_2));
case VAR_19:
case VAR_20:
VAR_6 = &EG(VAR_9);
break;
case VAR_11:
zend_error(VAR_18,""Undefined index: %s"", Z_STRVAL_P(VAR_2));
case VAR_10: {
zval *VAR_21;
ALLOC_INIT_ZVAL(VAR_21);
zend_symtable_update(VAR_8, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void**)&VAR_21, sizeof(void*), (void **)&VAR_6);
}
}
}
return VAR_6;
case VAR_22:
zend_error(VAR_23, ""Resource ID#%ld used as offset, casting to integer (%ld)"", Z_LVAL_P(VAR_2), Z_LVAL_P(VAR_2));
case VAR_24:
case VAR_25: 
case VAR_26: 
if (VAR_2->type == VAR_24) {
VAR_7 = (long)Z_DVAL_P(VAR_2);
} else {
VAR_7 = Z_LVAL_P(VAR_2);
}
if (zend_hash_index_find(VAR_8, VAR_7, (void **) &VAR_6) == VAR_16) {
switch (VAR_3) {
case VAR_17:
zend_error(VAR_18, ""Undefined offset: %ld"", VAR_7);
case VAR_19:
case VAR_20:
VAR_6 = &EG(VAR_9);
break;
case VAR_11:
zend_error(VAR_18, ""Undefined offset: %ld"", VAR_7);
case VAR_10: {
zval *VAR_21;
ALLOC_INIT_ZVAL(VAR_21);
zend_hash_index_update(VAR_8, VAR_7, (void**)&VAR_21, sizeof(void*), (void **)&VAR_6);
}
}
}
return VAR_6;
default:
zend_error(VAR_12, ""Illegal offset type"");
return (VAR_3 == VAR_10 || VAR_3 == VAR_11) ?
&EG(VAR_13) : &EG(VAR_9);
}
}",,"static zval **spl_array_get_dimension_ptr_ptr(int check_inherited, zval *object, zval *offset, int type TSRMLS_DC) /* {{{ */
{
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
	zval **retval;
	long index;
	HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);

	if (!offset) {
		return &EG(uninitialized_zval_ptr);
	}

	if ((type == BP_VAR_W || type == BP_VAR_RW) && (ht->nApplyCount > 0)) {
		zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
		return &EG(error_zval_ptr);;
	}

	switch(Z_TYPE_P(offset)) {
	case IS_NULL:
		Z_STRVAL_P(offset) = """";
		Z_STRLEN_P(offset) = 0;
	case IS_STRING:
		if (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
					zend_error(E_NOTICE, ""Undefined index: %s"", Z_STRVAL_P(offset));
				case BP_VAR_UNSET:
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,""Undefined index: %s"", Z_STRVAL_P(offset));
				case BP_VAR_W: {
				    zval *value;
				    ALLOC_INIT_ZVAL(value);
				    zend_symtable_update(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void**)&value, sizeof(void*), (void **)&retval);
				}
			}
		}
		return retval;
	case IS_RESOURCE:
		zend_error(E_STRICT, ""Resource ID#%ld used as offset, casting to integer (%ld)"", Z_LVAL_P(offset), Z_LVAL_P(offset));
	case IS_DOUBLE:
	case IS_BOOL:
	case IS_LONG:
		if (offset->type == IS_DOUBLE) {
			index = (long)Z_DVAL_P(offset);
		} else {
			index = Z_LVAL_P(offset);
		}
		if (zend_hash_index_find(ht, index, (void **) &retval) == FAILURE) {
			switch (type) {
				case BP_VAR_R:
					zend_error(E_NOTICE, ""Undefined offset: %ld"", index);
				case BP_VAR_UNSET:
				case BP_VAR_IS:
					retval = &EG(uninitialized_zval_ptr);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE, ""Undefined offset: %ld"", index);
				case BP_VAR_W: {
				    zval *value;
				    ALLOC_INIT_ZVAL(value);
					zend_hash_index_update(ht, index, (void**)&value, sizeof(void*), (void **)&retval);
			   }
			}
		}
		return retval;
	default:
		zend_error(E_WARNING, ""Illegal offset type"");
		return (type == BP_VAR_W || type == BP_VAR_RW) ?
			&EG(error_zval_ptr) : &EG(uninitialized_zval_ptr);
	}
}","static zval **spl_array_get_dimension_ptr_ptr(int VAR_0, zval *VAR_1, zval *VAR_2, int VAR_3 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_object *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);
	zval **VAR_6;
	long VAR_7;
	HashTable *VAR_8 = spl_array_get_hash_table(VAR_4, 0 VAR_5);

	if (!VAR_2) {
		return &EG(VAR_9);
	}

	if ((VAR_3 == VAR_10 || VAR_3 == VAR_11) && (VAR_8->nApplyCount > 0)) {
		zend_error(VAR_12, ""Modification of ArrayObject during sorting is prohibited"");
		return &EG(VAR_13);;
	}

	switch(Z_TYPE_P(VAR_2)) {
	case VAR_14:
		Z_STRVAL_P(VAR_2) = """";
		Z_STRLEN_P(VAR_2) = 0;
	case VAR_15:
		if (zend_symtable_find(VAR_8, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void **) &VAR_6) == VAR_16) {
			switch (VAR_3) {
				case VAR_17:
					zend_error(VAR_18, ""Undefined index: %s"", Z_STRVAL_P(VAR_2));
				case VAR_19:
				case VAR_20:
					VAR_6 = &EG(VAR_9);
					break;
				case VAR_11:
					zend_error(VAR_18,""Undefined index: %s"", Z_STRVAL_P(VAR_2));
				case VAR_10: {
				    zval *VAR_21;
				    ALLOC_INIT_ZVAL(VAR_21);
				    zend_symtable_update(VAR_8, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void**)&VAR_21, sizeof(void*), (void **)&VAR_6);
				}
			}
		}
		return VAR_6;
	case VAR_22:
		zend_error(VAR_23, ""Resource ID#%ld used as offset, casting to integer (%ld)"", Z_LVAL_P(VAR_2), Z_LVAL_P(VAR_2));
	case VAR_24:
	case VAR_25:
	case VAR_26:
		if (VAR_2->type == VAR_24) {
			VAR_7 = (long)Z_DVAL_P(VAR_2);
		} else {
			VAR_7 = Z_LVAL_P(VAR_2);
		}
		if (zend_hash_index_find(VAR_8, VAR_7, (void **) &VAR_6) == VAR_16) {
			switch (VAR_3) {
				case VAR_17:
					zend_error(VAR_18, ""Undefined offset: %ld"", VAR_7);
				case VAR_19:
				case VAR_20:
					VAR_6 = &EG(VAR_9);
					break;
				case VAR_11:
					zend_error(VAR_18, ""Undefined offset: %ld"", VAR_7);
				case VAR_10: {
				    zval *VAR_21;
				    ALLOC_INIT_ZVAL(VAR_21);
					zend_hash_index_update(VAR_8, VAR_7, (void**)&VAR_21, sizeof(void*), (void **)&VAR_6);
			   }
			}
		}
		return VAR_6;
	default:
		zend_error(VAR_12, ""Illegal offset type"");
		return (VAR_3 == VAR_10 || VAR_3 == VAR_11) ?
			&EG(VAR_13) : &EG(VAR_9);
	}
}",,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 	if (!offset) {
 		return &EG(uninitialized_zval_ptr);
 	}
-	
+
 	if ((type == BP_VAR_W || type == BP_VAR_RW) && (ht->nApplyCount > 0)) {
 		zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
 		return &EG(error_zval_ptr);;
@@ -40,8 +40,8 @@
 	case IS_RESOURCE:
 		zend_error(E_STRICT, ""Resource ID#%ld used as offset, casting to integer (%ld)"", Z_LVAL_P(offset), Z_LVAL_P(offset));
 	case IS_DOUBLE:
-	case IS_BOOL: 
-	case IS_LONG: 
+	case IS_BOOL:
+	case IS_LONG:
 		if (offset->type == IS_DOUBLE) {
 			index = (long)Z_DVAL_P(offset);
 		} else {","{'deleted_lines': ['\t', '\tcase IS_BOOL: ', '\tcase IS_LONG: '], 'added_lines': ['', '\tcase IS_BOOL:', '\tcase IS_LONG:']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_unset_dimension_ex,"static void spl_array_unset_dimension_ex(int check_inherited, zval *object, zval *offset TSRMLS_DC) 
{
spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
long index;
HashTable *ht;
if (check_inherited && intern->fptr_offset_del) {
SEPARATE_ARG_IF_REF(offset);
zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_del, ""offsetUnset"", NULL, offset);
zval_ptr_dtor(&offset);
return;
}
switch(Z_TYPE_P(offset)) {
case IS_STRING:
ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (ht->nApplyCount > 0) {
zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
if (ht == &EG(symbol_table)) {
if (zend_delete_global_variable(Z_STRVAL_P(offset), Z_STRLEN_P(offset) TSRMLS_CC)) {
zend_error(E_NOTICE,""Undefined index: %s"", Z_STRVAL_P(offset));
}
} else {
if (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {
zend_error(E_NOTICE,""Undefined index: %s"", Z_STRVAL_P(offset));
} else {
spl_array_object *obj = intern;
while (1) {
if ((obj->ar_flags & SPL_ARRAY_IS_SELF) != 0) {
break;
} else if (Z_TYPE_P(obj->array) == IS_OBJECT) {
if ((obj->ar_flags & SPL_ARRAY_USE_OTHER) == 0) {
obj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);
break;
} else {
obj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);
}
} else {
obj = NULL;
break;
}
}
if (obj) {
zend_property_info *property_info = zend_get_property_info(obj->std.ce, offset, 1 TSRMLS_CC);
if (property_info &&
(property_info->flags & ZEND_ACC_STATIC) == 0 &&
property_info->offset >= 0) {
obj->std.properties_table[property_info->offset] = NULL;
}
}
}
}
break;
case IS_DOUBLE:
case IS_RESOURCE:
case IS_BOOL: 
case IS_LONG: 
if (offset->type == IS_DOUBLE) {
index = (long)Z_DVAL_P(offset);
} else {
index = Z_LVAL_P(offset);
}
ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (ht->nApplyCount > 0) {
zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
if (zend_hash_index_del(ht, index) == FAILURE) {
zend_error(E_NOTICE,""Undefined offset: %ld"", Z_LVAL_P(offset));
}
break;
default:
zend_error(E_WARNING, ""Illegal offset type"");
return;
}
spl_hash_verify_pos(intern TSRMLS_CC); 
}","static void spl_array_unset_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2 TSRMLS_DC) 
{
spl_array_object *VAR_3 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_4);
long VAR_5;
HashTable *VAR_6;
if (VAR_0 && VAR_3->fptr_offset_del) {
SEPARATE_ARG_IF_REF(VAR_2);
zend_call_method_with_1_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_3->fptr_offset_del, ""offsetUnset"", NULL, VAR_2);
zval_ptr_dtor(&VAR_2);
return;
}
switch(Z_TYPE_P(VAR_2)) {
case VAR_7:
VAR_6 = spl_array_get_hash_table(VAR_3, 0 VAR_4);
if (VAR_6->nApplyCount > 0) {
zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
if (VAR_6 == &EG(VAR_9)) {
if (zend_delete_global_variable(Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2) VAR_4)) {
zend_error(VAR_10,""Undefined index: %s"", Z_STRVAL_P(VAR_2));
}
} else {
if (zend_symtable_del(VAR_6, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1) == VAR_11) {
zend_error(VAR_10,""Undefined index: %s"", Z_STRVAL_P(VAR_2));
} else {
spl_array_object *VAR_12 = VAR_3;
while (1) {
if ((VAR_12->ar_flags & VAR_13) != 0) {
break;
} else if (Z_TYPE_P(VAR_12->array) == VAR_14) {
if ((VAR_12->ar_flags & VAR_15) == 0) {
VAR_12 = (spl_array_object*)zend_object_store_get_object(VAR_12->array VAR_4);
break;
} else {
VAR_12 = (spl_array_object*)zend_object_store_get_object(VAR_12->array VAR_4);
}
} else {
VAR_12 = NULL;
break;
}
}
if (VAR_12) {
zend_property_info *VAR_16 = zend_get_property_info(VAR_12->std.ce, VAR_2, 1 VAR_4);
if (VAR_16 &&
(VAR_16->flags & VAR_17) == 0 &&
VAR_16->offset >= 0) {
VAR_12->std.properties_table[VAR_16->offset] = NULL;
}
}
}
}
break;
case VAR_18:
case VAR_19:
case VAR_20: 
case VAR_21: 
if (VAR_2->type == VAR_18) {
VAR_5 = (long)Z_DVAL_P(VAR_2);
} else {
VAR_5 = Z_LVAL_P(VAR_2);
}
VAR_6 = spl_array_get_hash_table(VAR_3, 0 VAR_4);
if (VAR_6->nApplyCount > 0) {
zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
return;
}
if (zend_hash_index_del(VAR_6, VAR_5) == VAR_11) {
zend_error(VAR_10,""Undefined offset: %ld"", Z_LVAL_P(VAR_2));
}
break;
default:
zend_error(VAR_8, ""Illegal offset type"");
return;
}
VAR_22(intern TSRMLS_CC); 
}",,"static void spl_array_unset_dimension_ex(int check_inherited, zval *object, zval *offset TSRMLS_DC) /* {{{ */
{
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
	long index;
	HashTable *ht;

	if (check_inherited && intern->fptr_offset_del) {
		SEPARATE_ARG_IF_REF(offset);
		zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_del, ""offsetUnset"", NULL, offset);
		zval_ptr_dtor(&offset);
		return;
	}

	switch(Z_TYPE_P(offset)) {
	case IS_STRING:
		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
		if (ht->nApplyCount > 0) {
			zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		if (ht == &EG(symbol_table)) {
			if (zend_delete_global_variable(Z_STRVAL_P(offset), Z_STRLEN_P(offset) TSRMLS_CC)) {
				zend_error(E_NOTICE,""Undefined index: %s"", Z_STRVAL_P(offset));
			}
		} else {
			if (zend_symtable_del(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1) == FAILURE) {
				zend_error(E_NOTICE,""Undefined index: %s"", Z_STRVAL_P(offset));
			} else {
				spl_array_object *obj = intern;

				while (1) {
					if ((obj->ar_flags & SPL_ARRAY_IS_SELF) != 0) {
						break;
					} else if (Z_TYPE_P(obj->array) == IS_OBJECT) {
					    if ((obj->ar_flags & SPL_ARRAY_USE_OTHER) == 0) {
							obj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);
					    	break;
						} else {
							obj = (spl_array_object*)zend_object_store_get_object(obj->array TSRMLS_CC);
					    }
					} else {
						obj = NULL;
						break;
					}
				}
				if (obj) {
					zend_property_info *property_info = zend_get_property_info(obj->std.ce, offset, 1 TSRMLS_CC);

					if (property_info &&
					    (property_info->flags & ZEND_ACC_STATIC) == 0 &&
					    property_info->offset >= 0) {
					    obj->std.properties_table[property_info->offset] = NULL;
					}
				}
			}
		}
		break;
	case IS_DOUBLE:
	case IS_RESOURCE:
	case IS_BOOL:
	case IS_LONG:
		if (offset->type == IS_DOUBLE) {
			index = (long)Z_DVAL_P(offset);
		} else {
			index = Z_LVAL_P(offset);
		}
		ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
		if (ht->nApplyCount > 0) {
			zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		if (zend_hash_index_del(ht, index) == FAILURE) {
			zend_error(E_NOTICE,""Undefined offset: %ld"", Z_LVAL_P(offset));
		}
		break;
	default:
		zend_error(E_WARNING, ""Illegal offset type"");
		return;
	}
	spl_hash_verify_pos(intern TSRMLS_CC); /* call rewind on FAILURE */
}","static void spl_array_unset_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_object *VAR_3 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_4);
	long VAR_5;
	HashTable *VAR_6;

	if (VAR_0 && VAR_3->fptr_offset_del) {
		SEPARATE_ARG_IF_REF(VAR_2);
		zend_call_method_with_1_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_3->fptr_offset_del, ""offsetUnset"", NULL, VAR_2);
		zval_ptr_dtor(&VAR_2);
		return;
	}

	switch(Z_TYPE_P(VAR_2)) {
	case VAR_7:
		VAR_6 = spl_array_get_hash_table(VAR_3, 0 VAR_4);
		if (VAR_6->nApplyCount > 0) {
			zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		if (VAR_6 == &EG(VAR_9)) {
			if (zend_delete_global_variable(Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2) VAR_4)) {
				zend_error(VAR_10,""Undefined index: %s"", Z_STRVAL_P(VAR_2));
			}
		} else {
			if (zend_symtable_del(VAR_6, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1) == VAR_11) {
				zend_error(VAR_10,""Undefined index: %s"", Z_STRVAL_P(VAR_2));
			} else {
				spl_array_object *VAR_12 = VAR_3;

				while (1) {
					if ((VAR_12->ar_flags & VAR_13) != 0) {
						break;
					} else if (Z_TYPE_P(VAR_12->array) == VAR_14) {
					    if ((VAR_12->ar_flags & VAR_15) == 0) {
							VAR_12 = (spl_array_object*)zend_object_store_get_object(VAR_12->array VAR_4);
					    	break;
						} else {
							VAR_12 = (spl_array_object*)zend_object_store_get_object(VAR_12->array VAR_4);
					    }
					} else {
						VAR_12 = NULL;
						break;
					}
				}
				if (VAR_12) {
					zend_property_info *VAR_16 = zend_get_property_info(VAR_12->std.ce, VAR_2, 1 VAR_4);

					if (VAR_16 &&
					    (VAR_16->flags & VAR_17) == 0 &&
					    VAR_16->offset >= 0) {
					    VAR_12->std.properties_table[VAR_16->offset] = NULL;
					}
				}
			}
		}
		break;
	case VAR_18:
	case VAR_19:
	case VAR_20:
	case VAR_21:
		if (VAR_2->type == VAR_18) {
			VAR_5 = (long)Z_DVAL_P(VAR_2);
		} else {
			VAR_5 = Z_LVAL_P(VAR_2);
		}
		VAR_6 = spl_array_get_hash_table(VAR_3, 0 VAR_4);
		if (VAR_6->nApplyCount > 0) {
			zend_error(VAR_8, ""Modification of ArrayObject during sorting is prohibited"");
			return;
		}
		if (zend_hash_index_del(VAR_6, VAR_5) == VAR_11) {
			zend_error(VAR_10,""Undefined offset: %ld"", Z_LVAL_P(VAR_2));
		}
		break;
	default:
		zend_error(VAR_8, ""Illegal offset type"");
		return;
	}
	VAR_22(intern TSRMLS_CC); /* COMMENT_1 */
}",,"--- func_before
+++ func_after
@@ -52,13 +52,13 @@
 					    obj->std.properties_table[property_info->offset] = NULL;
 					}
 				}
-			}			
+			}
 		}
 		break;
 	case IS_DOUBLE:
 	case IS_RESOURCE:
-	case IS_BOOL: 
-	case IS_LONG: 
+	case IS_BOOL:
+	case IS_LONG:
 		if (offset->type == IS_DOUBLE) {
 			index = (long)Z_DVAL_P(offset);
 		} else {","{'deleted_lines': ['\t\t\t}\t\t\t', '\tcase IS_BOOL: ', '\tcase IS_LONG: '], 'added_lines': ['\t\t\t}', '\tcase IS_BOOL:', '\tcase IS_LONG:']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_iterator_append,"void spl_array_iterator_append(zval *object, zval *append_value TSRMLS_DC) 
{
spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (!aht) {
php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Array was modified outside object and is no longer an array"");
return;
}
if (Z_TYPE_P(intern->array) == IS_OBJECT) {
php_error_docref(NULL TSRMLS_CC, E_RECOVERABLE_ERROR, ""Cannot append properties to objects, use %s::offsetSet() instead"", Z_OBJCE_P(object)->name);
return;
}
spl_array_write_dimension(object, NULL, append_value TSRMLS_CC);
if (!intern->pos) {
spl_array_set_pos(intern, aht->pListTail);
}
}","void spl_array_iterator_append(zval *VAR_0, zval *VAR_1 TSRMLS_DC) 
{
spl_array_object *VAR_2 = (spl_array_object*)zend_object_store_get_object(VAR_0 VAR_3);
HashTable *VAR_4 = spl_array_get_hash_table(VAR_2, 0 VAR_3);
if (!VAR_4) {
VAR_5(NULL VAR_3, VAR_6, ""Array was modified outside object and is no longer an array"");
return;
}
if (Z_TYPE_P(VAR_2->array) == VAR_7) {
VAR_5(NULL VAR_3, VAR_8, ""Cannot append properties to objects, use %s::offsetSet() instead"", Z_OBJCE_P(VAR_0)->name);
return;
}
spl_array_write_dimension(VAR_0, NULL, VAR_1 VAR_3);
if (!VAR_2->pos) {
spl_array_set_pos(VAR_2, VAR_4->pListTail);
}
}",,"void spl_array_iterator_append(zval *object, zval *append_value TSRMLS_DC) /* {{{ */
{
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
	HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);

	if (!aht) {
		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Array was modified outside object and is no longer an array"");
		return;
	}

	if (Z_TYPE_P(intern->array) == IS_OBJECT) {
		php_error_docref(NULL TSRMLS_CC, E_RECOVERABLE_ERROR, ""Cannot append properties to objects, use %s::offsetSet() instead"", Z_OBJCE_P(object)->name);
		return;
	}

	spl_array_write_dimension(object, NULL, append_value TSRMLS_CC);
	if (!intern->pos) {
		spl_array_set_pos(intern, aht->pListTail);
	}
}","void spl_array_iterator_append(zval *VAR_0, zval *VAR_1 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_object *VAR_2 = (spl_array_object*)zend_object_store_get_object(VAR_0 VAR_3);
	HashTable *VAR_4 = spl_array_get_hash_table(VAR_2, 0 VAR_3);

	if (!VAR_4) {
		VAR_5(NULL VAR_3, VAR_6, ""Array was modified outside object and is no longer an array"");
		return;
	}

	if (Z_TYPE_P(VAR_2->array) == VAR_7) {
		VAR_5(NULL VAR_3, VAR_8, ""Cannot append properties to objects, use %s::offsetSet() instead"", Z_OBJCE_P(VAR_0)->name);
		return;
	}

	spl_array_write_dimension(VAR_0, NULL, VAR_1 VAR_3);
	if (!VAR_2->pos) {
		spl_array_set_pos(VAR_2, VAR_4->pListTail);
	}
}",,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 		php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Array was modified outside object and is no longer an array"");
 		return;
 	}
-	
+
 	if (Z_TYPE_P(intern->array) == IS_OBJECT) {
 		php_error_docref(NULL TSRMLS_CC, E_RECOVERABLE_ERROR, ""Cannot append properties to objects, use %s::offsetSet() instead"", Z_OBJCE_P(object)->name);
 		return;","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_has_dimension_ex,"static int spl_array_has_dimension_ex(int check_inherited, zval *object, zval *offset, int check_empty TSRMLS_DC) 
{
spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
long index;
zval *rv, **tmp;
if (check_inherited && intern->fptr_offset_has) {
SEPARATE_ARG_IF_REF(offset);
zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_has, ""offsetExists"", &rv, offset);
zval_ptr_dtor(&offset);
if (rv && zend_is_true(rv)) {
zval_ptr_dtor(&rv);
return 1;
}
if (rv) {
zval_ptr_dtor(&rv);
}
return 0;
}
switch(Z_TYPE_P(offset)) {
case IS_STRING:
{
HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &tmp) != FAILURE) {
switch (check_empty) {
case 0:
return Z_TYPE_PP(tmp) != IS_NULL;
case 2:
return 1;
default:
return zend_is_true(*tmp);
}
}
}
return 0;
case IS_DOUBLE:
case IS_RESOURCE:
case IS_BOOL: 
case IS_LONG:
{
HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
if (offset->type == IS_DOUBLE) {
index = (long)Z_DVAL_P(offset);
} else {
index = Z_LVAL_P(offset);
}
if (zend_hash_index_find(ht, index, (void **)&tmp) != FAILURE) {
switch (check_empty) {
case 0:
return Z_TYPE_PP(tmp) != IS_NULL;
case 2:
return 1;
default:
return zend_is_true(*tmp);
}
}
return 0;
}
default:
zend_error(E_WARNING, ""Illegal offset type"");
}
return 0;
}","static int spl_array_has_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2, int VAR_3 TSRMLS_DC) 
{
spl_array_object *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);
long VAR_6;
zval *VAR_7, **VAR_8;
if (VAR_0 && VAR_4->fptr_offset_has) {
SEPARATE_ARG_IF_REF(VAR_2);
zend_call_method_with_1_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_4->fptr_offset_has, ""offsetExists"", &VAR_7, VAR_2);
zval_ptr_dtor(&VAR_2);
if (VAR_7 && zend_is_true(VAR_7)) {
zval_ptr_dtor(&VAR_7);
return 1;
}
if (VAR_7) {
zval_ptr_dtor(&VAR_7);
}
return 0;
}
switch(Z_TYPE_P(VAR_2)) {
case VAR_9:
{
HashTable *VAR_10 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
if (zend_symtable_find(VAR_10, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void **) &VAR_8) != VAR_11) {
switch (VAR_3) {
case 0:
return Z_TYPE_PP(VAR_8) != VAR_12;
case 2:
return 1;
default:
return zend_is_true(*VAR_8);
}
}
}
return 0;
case VAR_13:
case VAR_14:
case VAR_15: 
case VAR_16:
{
HashTable *VAR_10 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
if (VAR_2->type == VAR_13) {
VAR_6 = (long)Z_DVAL_P(VAR_2);
} else {
VAR_6 = Z_LVAL_P(VAR_2);
}
if (zend_hash_index_find(VAR_10, VAR_6, (void **)&VAR_8) != VAR_11) {
switch (VAR_3) {
case 0:
return Z_TYPE_PP(VAR_8) != VAR_12;
case 2:
return 1;
default:
return zend_is_true(*VAR_8);
}
}
return 0;
}
default:
zend_error(VAR_17, ""Illegal offset type"");
}
return 0;
}",,"static int spl_array_has_dimension_ex(int check_inherited, zval *object, zval *offset, int check_empty TSRMLS_DC) /* {{{ */
{
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
	long index;
	zval *rv, **tmp;

	if (check_inherited && intern->fptr_offset_has) {
		SEPARATE_ARG_IF_REF(offset);
		zend_call_method_with_1_params(&object, Z_OBJCE_P(object), &intern->fptr_offset_has, ""offsetExists"", &rv, offset);
		zval_ptr_dtor(&offset);
		if (rv && zend_is_true(rv)) {
			zval_ptr_dtor(&rv);
			return 1;
		}
		if (rv) {
			zval_ptr_dtor(&rv);
		}
		return 0;
	}

	switch(Z_TYPE_P(offset)) {
		case IS_STRING:
			{
				HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
				if (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &tmp) != FAILURE) {
					switch (check_empty) {
						case 0:
							return Z_TYPE_PP(tmp) != IS_NULL;
						case 2:
							return 1;
						default:
							return zend_is_true(*tmp);
					}
				}
			}
			return 0;
		case IS_DOUBLE:
		case IS_RESOURCE:
		case IS_BOOL:
		case IS_LONG:
			{
				HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
				if (offset->type == IS_DOUBLE) {
					index = (long)Z_DVAL_P(offset);
				} else {
					index = Z_LVAL_P(offset);
				}
				if (zend_hash_index_find(ht, index, (void **)&tmp) != FAILURE) {
					switch (check_empty) {
						case 0:
							return Z_TYPE_PP(tmp) != IS_NULL;
						case 2:
							return 1;
						default:
							return zend_is_true(*tmp);
					}
				}
				return 0;
			}
		default:
			zend_error(E_WARNING, ""Illegal offset type"");
	}
	return 0;
}","static int spl_array_has_dimension_ex(int VAR_0, zval *VAR_1, zval *VAR_2, int VAR_3 TSRMLS_DC) /* COMMENT_0 */
{
	spl_array_object *VAR_4 = (spl_array_object*)zend_object_store_get_object(VAR_1 VAR_5);
	long VAR_6;
	zval *VAR_7, **VAR_8;

	if (VAR_0 && VAR_4->fptr_offset_has) {
		SEPARATE_ARG_IF_REF(VAR_2);
		zend_call_method_with_1_params(&VAR_1, Z_OBJCE_P(VAR_1), &VAR_4->fptr_offset_has, ""offsetExists"", &VAR_7, VAR_2);
		zval_ptr_dtor(&VAR_2);
		if (VAR_7 && zend_is_true(VAR_7)) {
			zval_ptr_dtor(&VAR_7);
			return 1;
		}
		if (VAR_7) {
			zval_ptr_dtor(&VAR_7);
		}
		return 0;
	}

	switch(Z_TYPE_P(VAR_2)) {
		case VAR_9:
			{
				HashTable *VAR_10 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
				if (zend_symtable_find(VAR_10, Z_STRVAL_P(VAR_2), Z_STRLEN_P(VAR_2)+1, (void **) &VAR_8) != VAR_11) {
					switch (VAR_3) {
						case 0:
							return Z_TYPE_PP(VAR_8) != VAR_12;
						case 2:
							return 1;
						default:
							return zend_is_true(*VAR_8);
					}
				}
			}
			return 0;
		case VAR_13:
		case VAR_14:
		case VAR_15:
		case VAR_16:
			{
				HashTable *VAR_10 = spl_array_get_hash_table(VAR_4, 0 VAR_5);
				if (VAR_2->type == VAR_13) {
					VAR_6 = (long)Z_DVAL_P(VAR_2);
				} else {
					VAR_6 = Z_LVAL_P(VAR_2);
				}
				if (zend_hash_index_find(VAR_10, VAR_6, (void **)&VAR_8) != VAR_11) {
					switch (VAR_3) {
						case 0:
							return Z_TYPE_PP(VAR_8) != VAR_12;
						case 2:
							return 1;
						default:
							return zend_is_true(*VAR_8);
					}
				}
				return 0;
			}
		default:
			zend_error(VAR_17, ""Illegal offset type"");
	}
	return 0;
}",,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
 		}
 		return 0;
 	}
-	
+
 	switch(Z_TYPE_P(offset)) {
 		case IS_STRING:
 			{
@@ -36,9 +36,9 @@
 			return 0;
 		case IS_DOUBLE:
 		case IS_RESOURCE:
-		case IS_BOOL: 
+		case IS_BOOL:
 		case IS_LONG:
-			{	
+			{
 				HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
 				if (offset->type == IS_DOUBLE) {
 					index = (long)Z_DVAL_P(offset);","{'deleted_lines': ['\t', '\t\tcase IS_BOOL: ', '\t\t\t{\t'], 'added_lines': ['', '\t\tcase IS_BOOL:', '\t\t\t{']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2015-6832,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70068 (Dangling pointer in the unserialization of ArrayObject items),b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,https://github.com/php/php-src/commit/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2,ext/spl/spl_array.c,spl_array_method,"static void spl_array_method(INTERNAL_FUNCTION_PARAMETERS, char *fname, int fname_len, int use_arg) 
{
spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
zval *tmp, *arg = NULL;
zval *retval_ptr = NULL;
MAKE_STD_ZVAL(tmp);
Z_TYPE_P(tmp) = IS_ARRAY;
Z_ARRVAL_P(tmp) = aht;
if (!use_arg) {
aht->nApplyCount++;
zend_call_method(NULL, NULL, NULL, fname, fname_len, &retval_ptr, 1, tmp, NULL TSRMLS_CC);
aht->nApplyCount--;
} else if (use_arg == SPL_ARRAY_METHOD_MAY_USER_ARG) {
if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""|z"", &arg) == FAILURE) {
Z_TYPE_P(tmp) = IS_NULL;
zval_ptr_dtor(&tmp);
zend_throw_exception(spl_ce_BadMethodCallException, ""Function expects one argument at most"", 0 TSRMLS_CC);
return;
}
aht->nApplyCount++;
zend_call_method(NULL, NULL, NULL, fname, fname_len, &retval_ptr, arg? 2 : 1, tmp, arg TSRMLS_CC);
aht->nApplyCount--;
} else {
if (ZEND_NUM_ARGS() != 1 || zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""z"", &arg) == FAILURE) {
Z_TYPE_P(tmp) = IS_NULL;
zval_ptr_dtor(&tmp);
zend_throw_exception(spl_ce_BadMethodCallException, ""Function expects exactly one argument"", 0 TSRMLS_CC);
return;
}
aht->nApplyCount++;
zend_call_method(NULL, NULL, NULL, fname, fname_len, &retval_ptr, 2, tmp, arg TSRMLS_CC);
aht->nApplyCount--;
}
Z_TYPE_P(tmp) = IS_NULL; 
zval_ptr_dtor(&tmp);
if (retval_ptr) {
COPY_PZVAL_TO_ZVAL(*return_value, retval_ptr);
}
}","static void spl_array_method(INTERNAL_FUNCTION_PARAMETERS, char *VAR_0, int VAR_1, int VAR_2) 
{
spl_array_object *VAR_3 = (spl_array_object*)zend_object_store_get_object(getThis() VAR_4);
HashTable *VAR_5 = spl_array_get_hash_table(VAR_3, 0 VAR_4);
zval *VAR_6, *VAR_7 = NULL;
zval *VAR_8 = NULL;
MAKE_STD_ZVAL(VAR_6);
Z_TYPE_P(VAR_6) = VAR_9;
Z_ARRVAL_P(VAR_6) = VAR_5;
if (!VAR_2) {
VAR_5->nApplyCount++;
zend_call_method(NULL, NULL, NULL, VAR_0, VAR_1, &VAR_8, 1, VAR_6, NULL VAR_4);
VAR_5->nApplyCount--;
} else if (VAR_2 == VAR_10) {
if (zend_parse_parameters_ex(VAR_11, ZEND_NUM_ARGS() VAR_4, ""|z"", &VAR_7) == VAR_12) {
Z_TYPE_P(VAR_6) = VAR_13;
zval_ptr_dtor(&VAR_6);
zend_throw_exception(VAR_14, ""Function expects one argument at most"", 0 VAR_4);
return;
}
VAR_5->nApplyCount++;
zend_call_method(NULL, NULL, NULL, VAR_0, VAR_1, &VAR_8, VAR_7? 2 : 1, VAR_6, VAR_7 VAR_4);
VAR_5->nApplyCount--;
} else {
if (ZEND_NUM_ARGS() != 1 || zend_parse_parameters_ex(VAR_11, ZEND_NUM_ARGS() VAR_4, ""z"", &VAR_7) == VAR_12) {
Z_TYPE_P(VAR_6) = VAR_13;
zval_ptr_dtor(&VAR_6);
zend_throw_exception(VAR_14, ""Function expects exactly one argument"", 0 VAR_4);
return;
}
VAR_5->nApplyCount++;
zend_call_method(NULL, NULL, NULL, VAR_0, VAR_1, &VAR_8, 2, VAR_6, VAR_7 VAR_4);
VAR_5->nApplyCount--;
}
Z_TYPE_P(VAR_6) = VAR_13; 
zval_ptr_dtor(&VAR_6);
if (VAR_8) {
COPY_PZVAL_TO_ZVAL(*VAR_15, VAR_8);
}
}",php/php-src/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2/spl_array.c/vul/before/0.json,"static void spl_array_method(INTERNAL_FUNCTION_PARAMETERS, char *fname, int fname_len, int use_arg) /* {{{ */
{
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
	zval *tmp, *arg = NULL;
	zval *retval_ptr = NULL;

	MAKE_STD_ZVAL(tmp);
	Z_TYPE_P(tmp) = IS_ARRAY;
	Z_ARRVAL_P(tmp) = aht;

	if (!use_arg) {
		aht->nApplyCount++;
		zend_call_method(NULL, NULL, NULL, fname, fname_len, &retval_ptr, 1, tmp, NULL TSRMLS_CC);
		aht->nApplyCount--;
	} else if (use_arg == SPL_ARRAY_METHOD_MAY_USER_ARG) {
		if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""|z"", &arg) == FAILURE) {
			Z_TYPE_P(tmp) = IS_NULL;
			zval_ptr_dtor(&tmp);
			zend_throw_exception(spl_ce_BadMethodCallException, ""Function expects one argument at most"", 0 TSRMLS_CC);
			return;
		}
		aht->nApplyCount++;
		zend_call_method(NULL, NULL, NULL, fname, fname_len, &retval_ptr, arg? 2 : 1, tmp, arg TSRMLS_CC);
		aht->nApplyCount--;
	} else {
		if (ZEND_NUM_ARGS() != 1 || zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, ""z"", &arg) == FAILURE) {
			Z_TYPE_P(tmp) = IS_NULL;
			zval_ptr_dtor(&tmp);
			zend_throw_exception(spl_ce_BadMethodCallException, ""Function expects exactly one argument"", 0 TSRMLS_CC);
			return;
		}
		aht->nApplyCount++;
		zend_call_method(NULL, NULL, NULL, fname, fname_len, &retval_ptr, 2, tmp, arg TSRMLS_CC);
		aht->nApplyCount--;
	}
	Z_TYPE_P(tmp) = IS_NULL; /* we want to destroy the zval, not the hashtable */
	zval_ptr_dtor(&tmp);
	if (retval_ptr) {
		COPY_PZVAL_TO_ZVAL(*return_value, retval_ptr);
	}
}","static void spl_array_method(INTERNAL_FUNCTION_PARAMETERS, char *VAR_0, int VAR_1, int VAR_2) /* COMMENT_0 */
{
	spl_array_object *VAR_3 = (spl_array_object*)zend_object_store_get_object(getThis() VAR_4);
	HashTable *VAR_5 = spl_array_get_hash_table(VAR_3, 0 VAR_4);
	zval *VAR_6, *VAR_7 = NULL;
	zval *VAR_8 = NULL;

	MAKE_STD_ZVAL(VAR_6);
	Z_TYPE_P(VAR_6) = VAR_9;
	Z_ARRVAL_P(VAR_6) = VAR_5;

	if (!VAR_2) {
		VAR_5->nApplyCount++;
		zend_call_method(NULL, NULL, NULL, VAR_0, VAR_1, &VAR_8, 1, VAR_6, NULL VAR_4);
		VAR_5->nApplyCount--;
	} else if (VAR_2 == VAR_10) {
		if (zend_parse_parameters_ex(VAR_11, ZEND_NUM_ARGS() VAR_4, ""|z"", &VAR_7) == VAR_12) {
			Z_TYPE_P(VAR_6) = VAR_13;
			zval_ptr_dtor(&VAR_6);
			zend_throw_exception(VAR_14, ""Function expects one argument at most"", 0 VAR_4);
			return;
		}
		VAR_5->nApplyCount++;
		zend_call_method(NULL, NULL, NULL, VAR_0, VAR_1, &VAR_8, VAR_7? 2 : 1, VAR_6, VAR_7 VAR_4);
		VAR_5->nApplyCount--;
	} else {
		if (ZEND_NUM_ARGS() != 1 || zend_parse_parameters_ex(VAR_11, ZEND_NUM_ARGS() VAR_4, ""z"", &VAR_7) == VAR_12) {
			Z_TYPE_P(VAR_6) = VAR_13;
			zval_ptr_dtor(&VAR_6);
			zend_throw_exception(VAR_14, ""Function expects exactly one argument"", 0 VAR_4);
			return;
		}
		VAR_5->nApplyCount++;
		zend_call_method(NULL, NULL, NULL, VAR_0, VAR_1, &VAR_8, 2, VAR_6, VAR_7 VAR_4);
		VAR_5->nApplyCount--;
	}
	Z_TYPE_P(VAR_6) = VAR_13; /* COMMENT_1 */
	zval_ptr_dtor(&VAR_6);
	if (VAR_8) {
		COPY_PZVAL_TO_ZVAL(*VAR_15, VAR_8);
	}
}",php/php-src/b7fa67742cd8d2b0ca0c0273b157f6ffee9ad6e2/spl_array.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,11 +4,11 @@
 	HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
 	zval *tmp, *arg = NULL;
 	zval *retval_ptr = NULL;
-	
+
 	MAKE_STD_ZVAL(tmp);
 	Z_TYPE_P(tmp) = IS_ARRAY;
 	Z_ARRVAL_P(tmp) = aht;
-	
+
 	if (!use_arg) {
 		aht->nApplyCount++;
 		zend_call_method(NULL, NULL, NULL, fname, fname_len, &retval_ptr, 1, tmp, NULL TSRMLS_CC);","{'deleted_lines': ['\t', '\t'], 'added_lines': ['', '']}",True,"Use-after-free vulnerability in the SPL unserialize implementation in ext/spl/spl_array.c in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to execute arbitrary code via crafted serialized data that triggers misuse of an array field.",7.3,HIGH,2,valid,2015-07-27T00:25:25Z,1
CVE-2016-2053,['CWE-310'],AV:L/AC:M/Au:N/C:N/I:N/A:C,0,torvalds/linux,"ASN.1: Fix non-match detection failure on data overrun

If the ASN.1 decoder is asked to parse a sequence of objects, non-optional
matches get skipped if there's no more data to be had rather than a
data-overrun error being reported.

This is due to the code segment that decides whether to skip optional
matches (ie. matches that could get ignored because an element is marked
OPTIONAL in the grammar) due to a lack of data also skips non-optional
elements if the data pointer has reached the end of the buffer.

This can be tested with the data decoder for the new RSA akcipher algorithm
that takes three non-optional integers.  Currently, it skips the last
integer if there is insufficient data.

Without the fix, #defining DEBUG in asn1_decoder.c will show something
like:

	next_op: pc=0/13 dp=0/270 C=0 J=0
	- match? 30 30 00
	- TAG: 30 266 CONS
	next_op: pc=2/13 dp=4/270 C=1 J=0
	- match? 02 02 00
	- TAG: 02 257
	- LEAF: 257
	next_op: pc=5/13 dp=265/270 C=1 J=0
	- match? 02 02 00
	- TAG: 02 3
	- LEAF: 3
	next_op: pc=8/13 dp=270/270 C=1 J=0
	next_op: pc=11/13 dp=270/270 C=1 J=0
	- end cons t=4 dp=270 l=270/270

The next_op line for pc=8/13 should be followed by a match line.

This is not exploitable for X.509 certificates by means of shortening the
message and fixing up the ASN.1 CONS tags because:

 (1) The relevant records being built up are cleared before use.

 (2) If the message is shortened sufficiently to remove the public key, the
     ASN.1 parse of the RSA key will fail quickly due to a lack of data.

 (3) Extracted signature data is either turned into MPIs (which cope with a
     0 length) or is simpler integers specifying algoritms and suchlike
     (which can validly be 0); and

 (4) The AKID and SKID extensions are optional and their removal is handled
     without risking passing a NULL to asymmetric_key_generate_id().

 (5) If the certificate is truncated sufficiently to remove the subject,
     issuer or serialNumber then the ASN.1 decoder will fail with a 'Cons
     stack underflow' return.

This is not exploitable for PKCS#7 messages by means of removal of elements
from such a message from the tail end of a sequence:

 (1) Any shortened X.509 certs embedded in the PKCS#7 message are survivable
     as detailed above.

 (2) The message digest content isn't used if it shows a NULL pointer,
     similarly, the authattrs aren't used if that shows a NULL pointer.

 (3) A missing signature results in a NULL MPI - which the MPI routines deal
     with.

 (4) If data is NULL, it is expected that the message has detached content and
     that is handled appropriately.

 (5) If the serialNumber is excised, the unconditional action associated
     with it will pick up the containing SEQUENCE instead, so no NULL
     pointer will be seen here.

     If both the issuer and the serialNumber are excised, the ASN.1 decode
     will fail with an 'Unexpected tag' return.

     In either case, there's no way to get to asymmetric_key_generate_id()
     with a NULL pointer.

 (6) Other fields are decoded to simple integers.  Shortening the message
     to omit an algorithm ID field will cause checks on this to fail early
     in the verification process.


This can also be tested by snipping objects off of the end of the ASN.1 stream
such that mandatory tags are removed - or even from the end of internal
SEQUENCEs.  If any mandatory tag is missing, the error EBADMSG *should* be
produced.  Without this patch ERANGE or ENOPKG might be produced or the parse
may apparently succeed, perhaps with ENOKEY or EKEYREJECTED being produced
later, depending on what gets snipped.

Just snipping off the final BIT_STRING or OCTET_STRING from either sample
should be a start since both are mandatory and neither will cause an EBADMSG
without the patches

Reported-by: Marcel Holtmann <marcel@holtmann.org>
Signed-off-by: David Howells <dhowells@redhat.com>
Tested-by: Marcel Holtmann <marcel@holtmann.org>
Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>",0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f,lib/asn1_decoder.c,asn1_ber_decoder,"int asn1_ber_decoder(const struct asn1_decoder *decoder,
void *context,
const unsigned char *data,
size_t datalen)
{
const unsigned char *machine = decoder->machine;
const asn1_action_t *actions = decoder->actions;
size_t machlen = decoder->machlen;
enum asn1_opcode op;
unsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;
const char *errmsg;
size_t pc = 0, dp = 0, tdp = 0, len = 0;
int ret;
unsigned char flags = 0;
#define FLAG_INDEFINITE_LENGTH0x01
#define FLAG_MATCHED0x02
#define FLAG_LAST_MATCHED0x04 
#define FLAG_CONS0x20 
#define NR_CONS_STACK 10
unsigned short cons_dp_stack[NR_CONS_STACK];
unsigned short cons_datalen_stack[NR_CONS_STACK];
unsigned char cons_hdrlen_stack[NR_CONS_STACK];
#define NR_JUMP_STACK 10
unsigned char jump_stack[NR_JUMP_STACK];
if (datalen > 65535)
return -EMSGSIZE;
next_op:
pr_debug(""next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n"",
pc, machlen, dp, datalen, csp, jsp);
if (unlikely(pc >= machlen))
goto machine_overrun_error;
op = machine[pc];
if (unlikely(pc + asn1_op_lengths[op] > machlen))
goto machine_overrun_error;
if (op <= ASN1_OP__MATCHES_TAG) {
unsigned char tmp;
if ((op & ASN1_OP_MATCH__COND &&
flags & FLAG_MATCHED) ||
dp == datalen) {
flags &= ~FLAG_LAST_MATCHED;
pc += asn1_op_lengths[op];
goto next_op;
}
flags = 0;
hdr = 2;
if (unlikely(dp >= datalen - 1))
goto data_overrun_error;
tag = data[dp++];
if (unlikely((tag & 0x1f) == ASN1_LONG_TAG))
goto long_tag_not_supported;
if (op & ASN1_OP_MATCH__ANY) {
pr_debug(""- any %02x\n"", tag);
} else {
optag = machine[pc + 1];
flags |= optag & FLAG_CONS;
tmp = optag ^ tag;
tmp &= ~(optag & ASN1_CONS_BIT);
pr_debug(""- match? %02x %02x %02x\n"", tag, optag, tmp);
if (tmp != 0) {
if (op & ASN1_OP_MATCH__SKIP) {
pc += asn1_op_lengths[op];
dp--;
goto next_op;
}
goto tag_mismatch;
}
}
flags |= FLAG_MATCHED;
len = data[dp++];
if (len > 0x7f) {
if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
if (unlikely(!(tag & ASN1_CONS_BIT)))
goto indefinite_len_primitive;
flags |= FLAG_INDEFINITE_LENGTH;
if (unlikely(2 > datalen - dp))
goto data_overrun_error;
} else {
int n = len - 0x80;
if (unlikely(n > 2))
goto length_too_long;
if (unlikely(dp >= datalen - n))
goto data_overrun_error;
hdr += n;
for (len = 0; n > 0; n--) {
len <<= 8;
len |= data[dp++];
}
if (unlikely(len > datalen - dp))
goto data_overrun_error;
}
}
if (flags & FLAG_CONS) {
if (unlikely(csp >= NR_CONS_STACK))
goto cons_stack_overflow;
cons_dp_stack[csp] = dp;
cons_hdrlen_stack[csp] = hdr;
if (!(flags & FLAG_INDEFINITE_LENGTH)) {
cons_datalen_stack[csp] = datalen;
datalen = dp + len;
} else {
cons_datalen_stack[csp] = 0;
}
csp++;
}
pr_debug(""- TAG: %02x %zu%s\n"",
tag, len, flags & FLAG_CONS ? "" CONS"" : """");
tdp = dp;
}
switch (op) {
case ASN1_OP_MATCH_ANY_ACT:
case ASN1_OP_COND_MATCH_ANY_ACT:
ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
if (ret < 0)
return ret;
goto skip_data;
case ASN1_OP_MATCH_ACT:
case ASN1_OP_MATCH_ACT_OR_SKIP:
case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);
if (ret < 0)
return ret;
goto skip_data;
case ASN1_OP_MATCH:
case ASN1_OP_MATCH_OR_SKIP:
case ASN1_OP_MATCH_ANY:
case ASN1_OP_COND_MATCH_OR_SKIP:
case ASN1_OP_COND_MATCH_ANY:
skip_data:
if (!(flags & FLAG_CONS)) {
if (flags & FLAG_INDEFINITE_LENGTH) {
ret = asn1_find_indefinite_length(
data, datalen, &dp, &len, &errmsg);
if (ret < 0)
goto error;
} else {
dp += len;
}
pr_debug(""- LEAF: %zu\n"", len);
}
pc += asn1_op_lengths[op];
goto next_op;
case ASN1_OP_MATCH_JUMP:
case ASN1_OP_MATCH_JUMP_OR_SKIP:
case ASN1_OP_COND_MATCH_JUMP_OR_SKIP:
pr_debug(""- MATCH_JUMP\n"");
if (unlikely(jsp == NR_JUMP_STACK))
goto jump_stack_overflow;
jump_stack[jsp++] = pc + asn1_op_lengths[op];
pc = machine[pc + 2];
goto next_op;
case ASN1_OP_COND_FAIL:
if (unlikely(!(flags & FLAG_MATCHED)))
goto tag_mismatch;
pc += asn1_op_lengths[op];
goto next_op;
case ASN1_OP_COMPLETE:
if (unlikely(jsp != 0 || csp != 0)) {
pr_err(""ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n"",
jsp, csp);
return -EBADMSG;
}
return 0;
case ASN1_OP_END_SET:
case ASN1_OP_END_SET_ACT:
if (unlikely(!(flags & FLAG_MATCHED)))
goto tag_mismatch;
case ASN1_OP_END_SEQ:
case ASN1_OP_END_SET_OF:
case ASN1_OP_END_SEQ_OF:
case ASN1_OP_END_SEQ_ACT:
case ASN1_OP_END_SET_OF_ACT:
case ASN1_OP_END_SEQ_OF_ACT:
if (unlikely(csp <= 0))
goto cons_stack_underflow;
csp--;
tdp = cons_dp_stack[csp];
hdr = cons_hdrlen_stack[csp];
len = datalen;
datalen = cons_datalen_stack[csp];
pr_debug(""- end cons t=%zu dp=%zu l=%zu/%zu\n"",
tdp, dp, len, datalen);
if (datalen == 0) {
datalen = len;
if (unlikely(datalen - dp < 2))
goto data_overrun_error;
if (data[dp++] != 0) {
if (op & ASN1_OP_END__OF) {
dp--;
csp++;
pc = machine[pc + 1];
pr_debug(""- continue\n"");
goto next_op;
}
goto missing_eoc;
}
if (data[dp++] != 0)
goto invalid_eoc;
len = dp - tdp - 2;
} else {
if (dp < len && (op & ASN1_OP_END__OF)) {
datalen = len;
csp++;
pc = machine[pc + 1];
pr_debug(""- continue\n"");
goto next_op;
}
if (dp != len)
goto cons_length_error;
len -= tdp;
pr_debug(""- cons len l=%zu d=%zu\n"", len, dp - tdp);
}
if (op & ASN1_OP_END__ACT) {
unsigned char act;
if (op & ASN1_OP_END__OF)
act = machine[pc + 2];
else
act = machine[pc + 1];
ret = actions[act](context, hdr, 0, data + tdp, len);
}
pc += asn1_op_lengths[op];
goto next_op;
case ASN1_OP_MAYBE_ACT:
if (!(flags & FLAG_LAST_MATCHED)) {
pc += asn1_op_lengths[op];
goto next_op;
}
case ASN1_OP_ACT:
ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
if (ret < 0)
return ret;
pc += asn1_op_lengths[op];
goto next_op;
case ASN1_OP_RETURN:
if (unlikely(jsp <= 0))
goto jump_stack_underflow;
pc = jump_stack[--jsp];
flags |= FLAG_MATCHED | FLAG_LAST_MATCHED;
goto next_op;
default:
break;
}
pr_err(""ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n"",
op, pc);
return -EBADMSG;
data_overrun_error:
errmsg = ""Data overrun error"";
goto error;
machine_overrun_error:
errmsg = ""Machine overrun error"";
goto error;
jump_stack_underflow:
errmsg = ""Jump stack underflow"";
goto error;
jump_stack_overflow:
errmsg = ""Jump stack overflow"";
goto error;
cons_stack_underflow:
errmsg = ""Cons stack underflow"";
goto error;
cons_stack_overflow:
errmsg = ""Cons stack overflow"";
goto error;
cons_length_error:
errmsg = ""Cons length error"";
goto error;
missing_eoc:
errmsg = ""Missing EOC in indefinite len cons"";
goto error;
invalid_eoc:
errmsg = ""Invalid length EOC"";
goto error;
length_too_long:
errmsg = ""Unsupported length"";
goto error;
indefinite_len_primitive:
errmsg = ""Indefinite len primitive not permitted"";
goto error;
tag_mismatch:
errmsg = ""Unexpected tag"";
goto error;
long_tag_not_supported:
errmsg = ""Long tag not supported"";
error:
pr_debug(""\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n"",
errmsg, pc, dp, optag, tag, len);
return -EBADMSG;
}","int asn1_ber_decoder(const struct asn1_decoder *VAR_0,
void *VAR_1,
const unsigned char *VAR_2,
size_t VAR_3)
{
const unsigned char *VAR_4 = VAR_0->machine;
const asn1_action_t *VAR_5 = VAR_0->actions;
size_t VAR_6 = VAR_0->machlen;
enum asn1_opcode VAR_7;
unsigned char VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0, VAR_12 = 0;
const char *VAR_13;
size_t VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0;
int VAR_18;
unsigned char VAR_19 = 0;
#define VAR_200x01
#define VAR_210x02
#define VAR_220x04 
#define VAR_230x20 
#define NR_CONS_STACK 10
unsigned short VAR_32[VAR_33];
unsigned short VAR_34[VAR_33];
unsigned char VAR_35[VAR_33];
#define VAR_36 10
unsigned char VAR_37[VAR_36];
if (VAR_3 > 65535)
return -VAR_38;
next_op:
pr_debug(""next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n"",
VAR_14, VAR_6, VAR_15, VAR_3, VAR_9, VAR_10);
if (unlikely(VAR_14 >= VAR_6))
goto machine_overrun_error;
VAR_7 = VAR_4[VAR_14];
if (unlikely(VAR_14 + VAR_39[VAR_7] > VAR_6))
goto machine_overrun_error;
if (VAR_7 <= VAR_40) {
unsigned char VAR_41;
if ((VAR_7 & VAR_42 &&
VAR_19 & VAR_21) ||
VAR_15 == VAR_3) {
VAR_19 &= ~VAR_22;
VAR_14 += VAR_39[VAR_7];
goto next_op;
}
VAR_19 = 0;
VAR_12 = 2;
if (unlikely(VAR_15 >= VAR_3 - 1))
goto data_overrun_error;
VAR_8 = VAR_2[VAR_15++];
if (unlikely((VAR_8 & 0x1f) == VAR_43))
goto long_tag_not_supported;
if (VAR_7 & VAR_44) {
pr_debug(""- any %02x\n"", VAR_8);
} else {
VAR_11 = VAR_4[VAR_14 + 1];
VAR_19 |= VAR_11 & VAR_23;
VAR_41 = VAR_11 ^ VAR_8;
VAR_41 &= ~(VAR_11 & VAR_45);
pr_debug(""- match? %02x %02x %02x\n"", VAR_8, VAR_11, VAR_41);
if (VAR_41 != 0) {
if (VAR_7 & VAR_46) {
VAR_14 += VAR_39[VAR_7];
VAR_15--;
goto next_op;
}
goto tag_mismatch;
}
}
VAR_19 |= VAR_21;
VAR_17 = VAR_2[VAR_15++];
if (VAR_17 > 0x7f) {
if (unlikely(VAR_17 == VAR_47)) {
if (unlikely(!(VAR_8 & VAR_45)))
goto indefinite_len_primitive;
VAR_19 |= VAR_20;
if (unlikely(2 > VAR_3 - VAR_15))
goto data_overrun_error;
} else {
int VAR_48 = VAR_17 - 0x80;
if (unlikely(VAR_48 > 2))
goto length_too_long;
if (unlikely(VAR_15 >= VAR_3 - VAR_48))
goto data_overrun_error;
VAR_12 += VAR_48;
for (VAR_17 = 0; VAR_48 > 0; VAR_48--) {
VAR_17 <<= 8;
VAR_17 |= VAR_2[VAR_15++];
}
if (unlikely(VAR_17 > VAR_3 - VAR_15))
goto data_overrun_error;
}
}
if (VAR_19 & VAR_23) {
if (unlikely(VAR_9 >= VAR_33))
goto cons_stack_overflow;
VAR_32[VAR_9] = VAR_15;
VAR_35[VAR_9] = VAR_12;
if (!(VAR_19 & VAR_20)) {
VAR_34[VAR_9] = VAR_3;
VAR_3 = VAR_15 + VAR_17;
} else {
VAR_34[VAR_9] = 0;
}
VAR_9++;
}
pr_debug(""- TAG: %02x %zu%s\n"",
VAR_8, VAR_17, VAR_19 & VAR_23 ? "" CONS"" : """");
VAR_16 = VAR_15;
}
switch (VAR_7) {
case VAR_49:
case VAR_50:
VAR_18 = VAR_5[VAR_4[VAR_14 + 1]](VAR_1, VAR_12, VAR_8, VAR_2 + VAR_15, VAR_17);
if (VAR_18 < 0)
return VAR_18;
goto skip_data;
case VAR_51:
case VAR_52:
case VAR_53:
VAR_18 = VAR_5[VAR_4[VAR_14 + 2]](VAR_1, VAR_12, VAR_8, VAR_2 + VAR_15, VAR_17);
if (VAR_18 < 0)
return VAR_18;
goto skip_data;
case VAR_54:
case VAR_55:
case VAR_56:
case VAR_57:
case VAR_58:
skip_data:
if (!(VAR_19 & VAR_23)) {
if (VAR_19 & VAR_20) {
VAR_18 = asn1_find_indefinite_length(
VAR_2, VAR_3, &VAR_15, &VAR_17, &VAR_13);
if (VAR_18 < 0)
goto error;
} else {
VAR_15 += VAR_17;
}
pr_debug(""- LEAF: %zu\n"", VAR_17);
}
VAR_14 += VAR_39[VAR_7];
goto next_op;
case VAR_59:
case VAR_60:
case VAR_61:
pr_debug(""- MATCH_JUMP\n"");
if (unlikely(VAR_10 == VAR_36))
goto jump_stack_overflow;
VAR_37[VAR_10++] = VAR_14 + VAR_39[VAR_7];
VAR_14 = VAR_4[VAR_14 + 2];
goto next_op;
case VAR_62:
if (unlikely(!(VAR_19 & VAR_21)))
goto tag_mismatch;
VAR_14 += VAR_39[VAR_7];
goto next_op;
case VAR_63:
if (unlikely(VAR_10 != 0 || VAR_9 != 0)) {
pr_err(""ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n"",
VAR_10, VAR_9);
return -VAR_64;
}
return 0;
case VAR_65:
case VAR_66:
if (unlikely(!(VAR_19 & VAR_21)))
goto tag_mismatch;
case VAR_67:
case VAR_68:
case VAR_69:
case VAR_70:
case VAR_71:
case VAR_72:
if (unlikely(VAR_9 <= 0))
goto cons_stack_underflow;
VAR_9--;
VAR_16 = VAR_32[VAR_9];
VAR_12 = VAR_35[VAR_9];
VAR_17 = VAR_3;
VAR_3 = VAR_34[VAR_9];
pr_debug(""- end cons t=%zu dp=%zu l=%zu/%zu\n"",
VAR_16, VAR_15, VAR_17, VAR_3);
if (VAR_3 == 0) {
VAR_3 = VAR_17;
if (unlikely(VAR_3 - VAR_15 < 2))
goto data_overrun_error;
if (VAR_2[VAR_15++] != 0) {
if (VAR_7 & VAR_73) {
VAR_15--;
VAR_9++;
VAR_14 = VAR_4[VAR_14 + 1];
pr_debug(""- continue\n"");
goto next_op;
}
goto missing_eoc;
}
if (VAR_2[VAR_15++] != 0)
goto invalid_eoc;
VAR_17 = VAR_15 - VAR_16 - 2;
} else {
if (VAR_15 < VAR_17 && (VAR_7 & VAR_73)) {
VAR_3 = VAR_17;
VAR_9++;
VAR_14 = VAR_4[VAR_14 + 1];
pr_debug(""- continue\n"");
goto next_op;
}
if (VAR_15 != VAR_17)
goto cons_length_error;
VAR_17 -= VAR_16;
pr_debug(""- cons len l=%zu d=%zu\n"", VAR_17, VAR_15 - VAR_16);
}
if (VAR_7 & VAR_74) {
unsigned char VAR_75;
if (VAR_7 & VAR_73)
VAR_75 = VAR_4[VAR_14 + 2];
else
VAR_75 = VAR_4[VAR_14 + 1];
VAR_18 = VAR_5[VAR_75](VAR_1, VAR_12, 0, VAR_2 + VAR_16, VAR_17);
}
VAR_14 += VAR_39[VAR_7];
goto next_op;
case VAR_76:
if (!(VAR_19 & VAR_22)) {
VAR_14 += VAR_39[VAR_7];
goto next_op;
}
case VAR_77:
VAR_18 = VAR_5[VAR_4[VAR_14 + 1]](VAR_1, VAR_12, VAR_8, VAR_2 + VAR_16, VAR_17);
if (VAR_18 < 0)
return VAR_18;
VAR_14 += VAR_39[VAR_7];
goto next_op;
case VAR_78:
if (unlikely(VAR_10 <= 0))
goto jump_stack_underflow;
VAR_14 = VAR_37[--VAR_10];
VAR_19 |= VAR_21 | VAR_22;
goto next_op;
default:
break;
}
pr_err(""ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n"",
VAR_7, VAR_14);
return -VAR_64;
data_overrun_error:
VAR_13 = ""Data overrun error"";
goto error;
machine_overrun_error:
VAR_13 = ""Machine overrun error"";
goto error;
jump_stack_underflow:
VAR_13 = ""Jump stack underflow"";
goto error;
jump_stack_overflow:
VAR_13 = ""Jump stack overflow"";
goto error;
cons_stack_underflow:
VAR_13 = ""Cons stack underflow"";
goto error;
cons_stack_overflow:
VAR_13 = ""Cons stack overflow"";
goto error;
cons_length_error:
VAR_13 = ""Cons length error"";
goto error;
missing_eoc:
VAR_13 = ""Missing EOC in indefinite len cons"";
goto error;
invalid_eoc:
VAR_13 = ""Invalid length EOC"";
goto error;
length_too_long:
VAR_13 = ""Unsupported length"";
goto error;
indefinite_len_primitive:
VAR_13 = ""Indefinite len primitive not permitted"";
goto error;
tag_mismatch:
VAR_13 = ""Unexpected tag"";
goto error;
long_tag_not_supported:
VAR_13 = ""Long tag not supported"";
error:
pr_debug(""\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n"",
VAR_13, VAR_14, VAR_15, VAR_11, VAR_8, VAR_17);
return -VAR_64;
}",torvalds/linux/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f/asn1_decoder.c/vul/before/0.json,"int asn1_ber_decoder(const struct asn1_decoder *decoder,
		     void *context,
		     const unsigned char *data,
		     size_t datalen)
{
	const unsigned char *machine = decoder->machine;
	const asn1_action_t *actions = decoder->actions;
	size_t machlen = decoder->machlen;
	enum asn1_opcode op;
	unsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;
	const char *errmsg;
	size_t pc = 0, dp = 0, tdp = 0, len = 0;
	int ret;

	unsigned char flags = 0;
#define FLAG_INDEFINITE_LENGTH	0x01
#define FLAG_MATCHED		0x02
#define FLAG_LAST_MATCHED	0x04 /* Last tag matched */
#define FLAG_CONS		0x20 /* Corresponds to CONS bit in the opcode tag
				      * - ie. whether or not we are going to parse
				      *   a compound type.
				      */

#define NR_CONS_STACK 10
	unsigned short cons_dp_stack[NR_CONS_STACK];
	unsigned short cons_datalen_stack[NR_CONS_STACK];
	unsigned char cons_hdrlen_stack[NR_CONS_STACK];
#define NR_JUMP_STACK 10
	unsigned char jump_stack[NR_JUMP_STACK];

	if (datalen > 65535)
		return -EMSGSIZE;

next_op:
	pr_debug(""next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n"",
		 pc, machlen, dp, datalen, csp, jsp);
	if (unlikely(pc >= machlen))
		goto machine_overrun_error;
	op = machine[pc];
	if (unlikely(pc + asn1_op_lengths[op] > machlen))
		goto machine_overrun_error;

	/* If this command is meant to match a tag, then do that before
	 * evaluating the command.
	 */
	if (op <= ASN1_OP__MATCHES_TAG) {
		unsigned char tmp;

		/* Skip conditional matches if possible */
		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
			flags &= ~FLAG_LAST_MATCHED;
			pc += asn1_op_lengths[op];
			goto next_op;
		}

		flags = 0;
		hdr = 2;

		/* Extract a tag from the data */
		if (unlikely(dp >= datalen - 1))
			goto data_overrun_error;
		tag = data[dp++];
		if (unlikely((tag & 0x1f) == ASN1_LONG_TAG))
			goto long_tag_not_supported;

		if (op & ASN1_OP_MATCH__ANY) {
			pr_debug(""- any %02x\n"", tag);
		} else {
			/* Extract the tag from the machine
			 * - Either CONS or PRIM are permitted in the data if
			 *   CONS is not set in the op stream, otherwise CONS
			 *   is mandatory.
			 */
			optag = machine[pc + 1];
			flags |= optag & FLAG_CONS;

			/* Determine whether the tag matched */
			tmp = optag ^ tag;
			tmp &= ~(optag & ASN1_CONS_BIT);
			pr_debug(""- match? %02x %02x %02x\n"", tag, optag, tmp);
			if (tmp != 0) {
				/* All odd-numbered tags are MATCH_OR_SKIP. */
				if (op & ASN1_OP_MATCH__SKIP) {
					pc += asn1_op_lengths[op];
					dp--;
					goto next_op;
				}
				goto tag_mismatch;
			}
		}
		flags |= FLAG_MATCHED;

		len = data[dp++];
		if (len > 0x7f) {
			if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
				/* Indefinite length */
				if (unlikely(!(tag & ASN1_CONS_BIT)))
					goto indefinite_len_primitive;
				flags |= FLAG_INDEFINITE_LENGTH;
				if (unlikely(2 > datalen - dp))
					goto data_overrun_error;
			} else {
				int n = len - 0x80;
				if (unlikely(n > 2))
					goto length_too_long;
				if (unlikely(dp >= datalen - n))
					goto data_overrun_error;
				hdr += n;
				for (len = 0; n > 0; n--) {
					len <<= 8;
					len |= data[dp++];
				}
				if (unlikely(len > datalen - dp))
					goto data_overrun_error;
			}
		}

		if (flags & FLAG_CONS) {
			/* For expected compound forms, we stack the positions
			 * of the start and end of the data.
			 */
			if (unlikely(csp >= NR_CONS_STACK))
				goto cons_stack_overflow;
			cons_dp_stack[csp] = dp;
			cons_hdrlen_stack[csp] = hdr;
			if (!(flags & FLAG_INDEFINITE_LENGTH)) {
				cons_datalen_stack[csp] = datalen;
				datalen = dp + len;
			} else {
				cons_datalen_stack[csp] = 0;
			}
			csp++;
		}

		pr_debug(""- TAG: %02x %zu%s\n"",
			 tag, len, flags & FLAG_CONS ? "" CONS"" : """");
		tdp = dp;
	}

	/* Decide how to handle the operation */
	switch (op) {
	case ASN1_OP_MATCH_ANY_ACT:
	case ASN1_OP_COND_MATCH_ANY_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH_ACT:
	case ASN1_OP_MATCH_ACT_OR_SKIP:
	case ASN1_OP_COND_MATCH_ACT_OR_SKIP:
		ret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);
		if (ret < 0)
			return ret;
		goto skip_data;

	case ASN1_OP_MATCH:
	case ASN1_OP_MATCH_OR_SKIP:
	case ASN1_OP_MATCH_ANY:
	case ASN1_OP_COND_MATCH_OR_SKIP:
	case ASN1_OP_COND_MATCH_ANY:
	skip_data:
		if (!(flags & FLAG_CONS)) {
			if (flags & FLAG_INDEFINITE_LENGTH) {
				ret = asn1_find_indefinite_length(
					data, datalen, &dp, &len, &errmsg);
				if (ret < 0)
					goto error;
			} else {
				dp += len;
			}
			pr_debug(""- LEAF: %zu\n"", len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MATCH_JUMP:
	case ASN1_OP_MATCH_JUMP_OR_SKIP:
	case ASN1_OP_COND_MATCH_JUMP_OR_SKIP:
		pr_debug(""- MATCH_JUMP\n"");
		if (unlikely(jsp == NR_JUMP_STACK))
			goto jump_stack_overflow;
		jump_stack[jsp++] = pc + asn1_op_lengths[op];
		pc = machine[pc + 2];
		goto next_op;

	case ASN1_OP_COND_FAIL:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_COMPLETE:
		if (unlikely(jsp != 0 || csp != 0)) {
			pr_err(""ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n"",
			       jsp, csp);
			return -EBADMSG;
		}
		return 0;

	case ASN1_OP_END_SET:
	case ASN1_OP_END_SET_ACT:
		if (unlikely(!(flags & FLAG_MATCHED)))
			goto tag_mismatch;
	case ASN1_OP_END_SEQ:
	case ASN1_OP_END_SET_OF:
	case ASN1_OP_END_SEQ_OF:
	case ASN1_OP_END_SEQ_ACT:
	case ASN1_OP_END_SET_OF_ACT:
	case ASN1_OP_END_SEQ_OF_ACT:
		if (unlikely(csp <= 0))
			goto cons_stack_underflow;
		csp--;
		tdp = cons_dp_stack[csp];
		hdr = cons_hdrlen_stack[csp];
		len = datalen;
		datalen = cons_datalen_stack[csp];
		pr_debug(""- end cons t=%zu dp=%zu l=%zu/%zu\n"",
			 tdp, dp, len, datalen);
		if (datalen == 0) {
			/* Indefinite length - check for the EOC. */
			datalen = len;
			if (unlikely(datalen - dp < 2))
				goto data_overrun_error;
			if (data[dp++] != 0) {
				if (op & ASN1_OP_END__OF) {
					dp--;
					csp++;
					pc = machine[pc + 1];
					pr_debug(""- continue\n"");
					goto next_op;
				}
				goto missing_eoc;
			}
			if (data[dp++] != 0)
				goto invalid_eoc;
			len = dp - tdp - 2;
		} else {
			if (dp < len && (op & ASN1_OP_END__OF)) {
				datalen = len;
				csp++;
				pc = machine[pc + 1];
				pr_debug(""- continue\n"");
				goto next_op;
			}
			if (dp != len)
				goto cons_length_error;
			len -= tdp;
			pr_debug(""- cons len l=%zu d=%zu\n"", len, dp - tdp);
		}

		if (op & ASN1_OP_END__ACT) {
			unsigned char act;
			if (op & ASN1_OP_END__OF)
				act = machine[pc + 2];
			else
				act = machine[pc + 1];
			ret = actions[act](context, hdr, 0, data + tdp, len);
		}
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_MAYBE_ACT:
		if (!(flags & FLAG_LAST_MATCHED)) {
			pc += asn1_op_lengths[op];
			goto next_op;
		}
	case ASN1_OP_ACT:
		ret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);
		if (ret < 0)
			return ret;
		pc += asn1_op_lengths[op];
		goto next_op;

	case ASN1_OP_RETURN:
		if (unlikely(jsp <= 0))
			goto jump_stack_underflow;
		pc = jump_stack[--jsp];
		flags |= FLAG_MATCHED | FLAG_LAST_MATCHED;
		goto next_op;

	default:
		break;
	}

	/* Shouldn't reach here */
	pr_err(""ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n"",
	       op, pc);
	return -EBADMSG;

data_overrun_error:
	errmsg = ""Data overrun error"";
	goto error;
machine_overrun_error:
	errmsg = ""Machine overrun error"";
	goto error;
jump_stack_underflow:
	errmsg = ""Jump stack underflow"";
	goto error;
jump_stack_overflow:
	errmsg = ""Jump stack overflow"";
	goto error;
cons_stack_underflow:
	errmsg = ""Cons stack underflow"";
	goto error;
cons_stack_overflow:
	errmsg = ""Cons stack overflow"";
	goto error;
cons_length_error:
	errmsg = ""Cons length error"";
	goto error;
missing_eoc:
	errmsg = ""Missing EOC in indefinite len cons"";
	goto error;
invalid_eoc:
	errmsg = ""Invalid length EOC"";
	goto error;
length_too_long:
	errmsg = ""Unsupported length"";
	goto error;
indefinite_len_primitive:
	errmsg = ""Indefinite len primitive not permitted"";
	goto error;
tag_mismatch:
	errmsg = ""Unexpected tag"";
	goto error;
long_tag_not_supported:
	errmsg = ""Long tag not supported"";
error:
	pr_debug(""\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n"",
		 errmsg, pc, dp, optag, tag, len);
	return -EBADMSG;
}","int asn1_ber_decoder(const struct asn1_decoder *VAR_0,
		     void *VAR_1,
		     const unsigned char *VAR_2,
		     size_t VAR_3)
{
	const unsigned char *VAR_4 = VAR_0->machine;
	const asn1_action_t *VAR_5 = VAR_0->actions;
	size_t VAR_6 = VAR_0->machlen;
	enum asn1_opcode VAR_7;
	unsigned char VAR_8 = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0, VAR_12 = 0;
	const char *VAR_13;
	size_t VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0;
	int VAR_18;

	unsigned char VAR_19 = 0;
#define VAR_20	0x01
#define VAR_21		0x02
#define VAR_22	0x04 /* Last tag matched */
#define VAR_23		0x20 /* Corresponds to CONS bit in the opcode tag
				      * - VAR_24. whether or VAR_25 we VAR_26 going VAR_27 VAR_28
				      *   VAR_29 VAR_30 VAR_31.
				      */

#define NR_CONS_STACK 10
	unsigned short VAR_32[VAR_33];
	unsigned short VAR_34[VAR_33];
	unsigned char VAR_35[VAR_33];
#define VAR_36 10
	unsigned char VAR_37[VAR_36];

	if (VAR_3 > 65535)
		return -VAR_38;

next_op:
	pr_debug(""next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n"",
		 VAR_14, VAR_6, VAR_15, VAR_3, VAR_9, VAR_10);
	if (unlikely(VAR_14 >= VAR_6))
		goto machine_overrun_error;
	VAR_7 = VAR_4[VAR_14];
	if (unlikely(VAR_14 + VAR_39[VAR_7] > VAR_6))
		goto machine_overrun_error;

	/* COMMENT_0 */
                           
    
	if (VAR_7 <= VAR_40) {
		unsigned char VAR_41;

		/* COMMENT_3 */
		if ((VAR_7 & VAR_42 && VAR_19 & VAR_21) ||
		    (VAR_7 & VAR_43 && VAR_15 == VAR_3)) {
			VAR_19 &= ~VAR_22;
			VAR_14 += VAR_39[VAR_7];
			goto next_op;
		}

		VAR_19 = 0;
		VAR_12 = 2;

		/* COMMENT_4 */
		if (unlikely(VAR_15 >= VAR_3 - 1))
			goto data_overrun_error;
		VAR_8 = VAR_2[VAR_15++];
		if (unlikely((VAR_8 & 0x1f) == VAR_44))
			goto long_tag_not_supported;

		if (VAR_7 & VAR_45) {
			pr_debug(""- any %02x\n"", VAR_8);
		} else {
			/* COMMENT_5 */
                                                        
                                                        
                     
      
			VAR_11 = VAR_4[VAR_14 + 1];
			VAR_19 |= VAR_11 & VAR_23;

			/* COMMENT_10 */
			VAR_41 = VAR_11 ^ VAR_8;
			VAR_41 &= ~(VAR_11 & VAR_46);
			pr_debug(""- match? %02x %02x %02x\n"", VAR_8, VAR_11, VAR_41);
			if (VAR_41 != 0) {
				/* COMMENT_11 */
				if (VAR_7 & VAR_43) {
					VAR_14 += VAR_39[VAR_7];
					VAR_15--;
					goto next_op;
				}
				goto tag_mismatch;
			}
		}
		VAR_19 |= VAR_21;

		VAR_17 = VAR_2[VAR_15++];
		if (VAR_17 > 0x7f) {
			if (unlikely(VAR_17 == VAR_47)) {
				/* COMMENT_12 */
				if (unlikely(!(VAR_8 & VAR_46)))
					goto indefinite_len_primitive;
				VAR_19 |= VAR_20;
				if (unlikely(2 > VAR_3 - VAR_15))
					goto data_overrun_error;
			} else {
				int VAR_48 = VAR_17 - 0x80;
				if (unlikely(VAR_48 > 2))
					goto length_too_long;
				if (unlikely(VAR_15 >= VAR_3 - VAR_48))
					goto data_overrun_error;
				VAR_12 += VAR_48;
				for (VAR_17 = 0; VAR_48 > 0; VAR_48--) {
					VAR_17 <<= 8;
					VAR_17 |= VAR_2[VAR_15++];
				}
				if (unlikely(VAR_17 > VAR_3 - VAR_15))
					goto data_overrun_error;
			}
		}

		if (VAR_19 & VAR_23) {
			/* COMMENT_13 */
                                       
      
			if (unlikely(VAR_9 >= VAR_33))
				goto cons_stack_overflow;
			VAR_32[VAR_9] = VAR_15;
			VAR_35[VAR_9] = VAR_12;
			if (!(VAR_19 & VAR_20)) {
				VAR_34[VAR_9] = VAR_3;
				VAR_3 = VAR_15 + VAR_17;
			} else {
				VAR_34[VAR_9] = 0;
			}
			VAR_9++;
		}

		pr_debug(""- TAG: %02x %zu%s\n"",
			 VAR_8, VAR_17, VAR_19 & VAR_23 ? "" CONS"" : """");
		VAR_16 = VAR_15;
	}

	/* COMMENT_16 */
	switch (VAR_7) {
	case VAR_49:
	case VAR_50:
		VAR_18 = VAR_5[VAR_4[VAR_14 + 1]](VAR_1, VAR_12, VAR_8, VAR_2 + VAR_15, VAR_17);
		if (VAR_18 < 0)
			return VAR_18;
		goto skip_data;

	case VAR_51:
	case VAR_52:
	case VAR_53:
		VAR_18 = VAR_5[VAR_4[VAR_14 + 2]](VAR_1, VAR_12, VAR_8, VAR_2 + VAR_15, VAR_17);
		if (VAR_18 < 0)
			return VAR_18;
		goto skip_data;

	case VAR_54:
	case VAR_55:
	case VAR_56:
	case VAR_57:
	case VAR_58:
	skip_data:
		if (!(VAR_19 & VAR_23)) {
			if (VAR_19 & VAR_20) {
				VAR_18 = asn1_find_indefinite_length(
					VAR_2, VAR_3, &VAR_15, &VAR_17, &VAR_13);
				if (VAR_18 < 0)
					goto error;
			} else {
				VAR_15 += VAR_17;
			}
			pr_debug(""- LEAF: %zu\n"", VAR_17);
		}
		VAR_14 += VAR_39[VAR_7];
		goto next_op;

	case VAR_59:
	case VAR_60:
	case VAR_61:
		pr_debug(""- MATCH_JUMP\n"");
		if (unlikely(VAR_10 == VAR_36))
			goto jump_stack_overflow;
		VAR_37[VAR_10++] = VAR_14 + VAR_39[VAR_7];
		VAR_14 = VAR_4[VAR_14 + 2];
		goto next_op;

	case VAR_62:
		if (unlikely(!(VAR_19 & VAR_21)))
			goto tag_mismatch;
		VAR_14 += VAR_39[VAR_7];
		goto next_op;

	case VAR_63:
		if (unlikely(VAR_10 != 0 || VAR_9 != 0)) {
			pr_err(""ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n"",
			       VAR_10, VAR_9);
			return -VAR_64;
		}
		return 0;

	case VAR_65:
	case VAR_66:
		if (unlikely(!(VAR_19 & VAR_21)))
			goto tag_mismatch;
	case VAR_67:
	case VAR_68:
	case VAR_69:
	case VAR_70:
	case VAR_71:
	case VAR_72:
		if (unlikely(VAR_9 <= 0))
			goto cons_stack_underflow;
		VAR_9--;
		VAR_16 = VAR_32[VAR_9];
		VAR_12 = VAR_35[VAR_9];
		VAR_17 = VAR_3;
		VAR_3 = VAR_34[VAR_9];
		pr_debug(""- end cons t=%zu dp=%zu l=%zu/%zu\n"",
			 VAR_16, VAR_15, VAR_17, VAR_3);
		if (VAR_3 == 0) {
			/* COMMENT_17 */
			VAR_3 = VAR_17;
			if (unlikely(VAR_3 - VAR_15 < 2))
				goto data_overrun_error;
			if (VAR_2[VAR_15++] != 0) {
				if (VAR_7 & VAR_73) {
					VAR_15--;
					VAR_9++;
					VAR_14 = VAR_4[VAR_14 + 1];
					pr_debug(""- continue\n"");
					goto next_op;
				}
				goto missing_eoc;
			}
			if (VAR_2[VAR_15++] != 0)
				goto invalid_eoc;
			VAR_17 = VAR_15 - VAR_16 - 2;
		} else {
			if (VAR_15 < VAR_17 && (VAR_7 & VAR_73)) {
				VAR_3 = VAR_17;
				VAR_9++;
				VAR_14 = VAR_4[VAR_14 + 1];
				pr_debug(""- continue\n"");
				goto next_op;
			}
			if (VAR_15 != VAR_17)
				goto cons_length_error;
			VAR_17 -= VAR_16;
			pr_debug(""- cons len l=%zu d=%zu\n"", VAR_17, VAR_15 - VAR_16);
		}

		if (VAR_7 & VAR_74) {
			unsigned char VAR_75;
			if (VAR_7 & VAR_73)
				VAR_75 = VAR_4[VAR_14 + 2];
			else
				VAR_75 = VAR_4[VAR_14 + 1];
			VAR_18 = VAR_5[VAR_75](VAR_1, VAR_12, 0, VAR_2 + VAR_16, VAR_17);
		}
		VAR_14 += VAR_39[VAR_7];
		goto next_op;

	case VAR_76:
		if (!(VAR_19 & VAR_22)) {
			VAR_14 += VAR_39[VAR_7];
			goto next_op;
		}
	case VAR_77:
		VAR_18 = VAR_5[VAR_4[VAR_14 + 1]](VAR_1, VAR_12, VAR_8, VAR_2 + VAR_16, VAR_17);
		if (VAR_18 < 0)
			return VAR_18;
		VAR_14 += VAR_39[VAR_7];
		goto next_op;

	case VAR_78:
		if (unlikely(VAR_10 <= 0))
			goto jump_stack_underflow;
		VAR_14 = VAR_37[--VAR_10];
		VAR_19 |= VAR_21 | VAR_22;
		goto next_op;

	default:
		break;
	}

	/* COMMENT_18 */
	pr_err(""ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n"",
	       VAR_7, VAR_14);
	return -VAR_64;

data_overrun_error:
	VAR_13 = ""Data overrun error"";
	goto error;
machine_overrun_error:
	VAR_13 = ""Machine overrun error"";
	goto error;
jump_stack_underflow:
	VAR_13 = ""Jump stack underflow"";
	goto error;
jump_stack_overflow:
	VAR_13 = ""Jump stack overflow"";
	goto error;
cons_stack_underflow:
	VAR_13 = ""Cons stack underflow"";
	goto error;
cons_stack_overflow:
	VAR_13 = ""Cons stack overflow"";
	goto error;
cons_length_error:
	VAR_13 = ""Cons length error"";
	goto error;
missing_eoc:
	VAR_13 = ""Missing EOC in indefinite len cons"";
	goto error;
invalid_eoc:
	VAR_13 = ""Invalid length EOC"";
	goto error;
length_too_long:
	VAR_13 = ""Unsupported length"";
	goto error;
indefinite_len_primitive:
	VAR_13 = ""Indefinite len primitive not permitted"";
	goto error;
tag_mismatch:
	VAR_13 = ""Unexpected tag"";
	goto error;
long_tag_not_supported:
	VAR_13 = ""Long tag not supported"";
error:
	pr_debug(""\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n"",
		 VAR_13, VAR_14, VAR_15, VAR_11, VAR_8, VAR_17);
	return -VAR_64;
}",torvalds/linux/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f/asn1_decoder.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,9 +47,8 @@
 		unsigned char tmp;
 
 		/* Skip conditional matches if possible */
-		if ((op & ASN1_OP_MATCH__COND &&
-		     flags & FLAG_MATCHED) ||
-		    dp == datalen) {
+		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
+		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
 			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;","{'deleted_lines': ['\t\tif ((op & ASN1_OP_MATCH__COND &&', '\t\t     flags & FLAG_MATCHED) ||', '\t\t    dp == datalen) {'], 'added_lines': ['\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||', '\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {']}",True,"The asn1_ber_decoder function in lib/asn1_decoder.c in the Linux kernel before 4.3 allows attackers to cause a denial of service (panic) via an ASN.1 BER file that lacks a public key, leading to mishandling by the public_key_verify_signature function in crypto/asymmetric_keys/public_key.c.",4.7,MEDIUM,1,valid,2015-08-05T11:54:46Z,1
CVE-2015-8953,['CWE-399'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"ovl: fix dentry reference leak

In ovl_copy_up_locked(), newdentry is leaked if the function exits through
out_cleanup as this just to out after calling ovl_cleanup() - which doesn't
actually release the ref on newdentry.

The out_cleanup segment should instead exit through out2 as certainly
newdentry leaks - and possibly upper does also, though this isn't caught
given the catch of newdentry.

Without this fix, something like the following is seen:

	BUG: Dentry ffff880023e9eb20{i=f861,n=#ffff880023e82d90} still in use (1) [unmount of tmpfs tmpfs]
	BUG: Dentry ffff880023ece640{i=0,n=bigfile}  still in use (1) [unmount of tmpfs tmpfs]

when unmounting the upper layer after an error occurred in copyup.

An error can be induced by creating a big file in a lower layer with
something like:

	dd if=/dev/zero of=/lower/a/bigfile bs=65536 count=1 seek=$((0xf000))

to create a large file (4.1G).  Overlay an upper layer that is too small
(on tmpfs might do) and then induce a copy up by opening it writably.

Reported-by: Ulrich Obergfell <uobergfe@redhat.com>
Signed-off-by: David Howells <dhowells@redhat.com>
Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
Cc: <stable@vger.kernel.org> # v3.18+",ab79efab0a0ba01a74df782eb7fa44b044dae8b5,https://github.com/torvalds/linux/commit/ab79efab0a0ba01a74df782eb7fa44b044dae8b5,fs/overlayfs/copy_up.c,ovl_copy_up_locked,"static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
struct dentry *dentry, struct path *lowerpath,
struct kstat *stat, struct iattr *attr,
const char *link)
{
struct inode *wdir = workdir->d_inode;
struct inode *udir = upperdir->d_inode;
struct dentry *newdentry = NULL;
struct dentry *upper = NULL;
umode_t mode = stat->mode;
int err;
newdentry = ovl_lookup_temp(workdir, dentry);
err = PTR_ERR(newdentry);
if (IS_ERR(newdentry))
goto out;
upper = lookup_one_len(dentry->d_name.name, upperdir,
dentry->d_name.len);
err = PTR_ERR(upper);
if (IS_ERR(upper))
goto out1;
stat->mode &= S_IFMT;
err = ovl_create_real(wdir, newdentry, stat, link, NULL, true);
stat->mode = mode;
if (err)
goto out2;
if (S_ISREG(stat->mode)) {
struct path upperpath;
ovl_path_upper(dentry, &upperpath);
BUG_ON(upperpath.dentry != NULL);
upperpath.dentry = newdentry;
err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
if (err)
goto out_cleanup;
}
err = ovl_copy_xattr(lowerpath->dentry, newdentry);
if (err)
goto out_cleanup;
mutex_lock(&newdentry->d_inode->i_mutex);
err = ovl_set_attr(newdentry, stat);
if (!err && attr)
err = notify_change(newdentry, attr, NULL);
mutex_unlock(&newdentry->d_inode->i_mutex);
if (err)
goto out_cleanup;
err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
if (err)
goto out_cleanup;
ovl_dentry_update(dentry, newdentry);
newdentry = NULL;
if (!S_ISDIR(stat->mode))
ovl_dentry_set_opaque(dentry, true);
out2:
dput(upper);
out1:
dput(newdentry);
out:
return err;
out_cleanup:
ovl_cleanup(wdir, newdentry);
goto out;
}","static int ovl_copy_up_locked(struct dentry *VAR_0, struct dentry *VAR_1,
struct dentry *dentry, struct path *VAR_2,
struct kstat *VAR_3, struct iattr *VAR_4,
const char *VAR_5)
{
struct inode *VAR_6 = VAR_0->d_inode;
struct inode *VAR_7 = VAR_1->d_inode;
struct dentry *VAR_8 = NULL;
struct dentry *VAR_9 = NULL;
umode_t VAR_10 = VAR_3->mode;
int VAR_11;
VAR_8 = ovl_lookup_temp(VAR_0, dentry);
VAR_11 = PTR_ERR(VAR_8);
if (IS_ERR(VAR_8))
goto out;
VAR_9 = lookup_one_len(dentry->d_name.name, VAR_1,
dentry->d_name.len);
VAR_11 = PTR_ERR(VAR_9);
if (IS_ERR(VAR_9))
goto out1;
VAR_3->mode &= VAR_12;
VAR_11 = ovl_create_real(VAR_6, VAR_8, VAR_3, VAR_5, NULL, true);
VAR_3->mode = VAR_10;
if (VAR_11)
goto out2;
if (S_ISREG(VAR_3->mode)) {
struct path VAR_13;
ovl_path_upper(dentry, &VAR_13);
BUG_ON(VAR_13.dentry != NULL);
VAR_13.dentry = VAR_8;
VAR_11 = ovl_copy_up_data(VAR_2, &VAR_13, VAR_3->size);
if (VAR_11)
goto out_cleanup;
}
VAR_11 = ovl_copy_xattr(VAR_2->dentry, VAR_8);
if (VAR_11)
goto out_cleanup;
mutex_lock(&VAR_8->d_inode->i_mutex);
VAR_11 = ovl_set_attr(VAR_8, VAR_3);
if (!VAR_11 && VAR_4)
VAR_11 = notify_change(VAR_8, VAR_4, NULL);
mutex_unlock(&VAR_8->d_inode->i_mutex);
if (VAR_11)
goto out_cleanup;
VAR_11 = ovl_do_rename(VAR_6, VAR_8, VAR_7, VAR_9, 0);
if (VAR_11)
goto out_cleanup;
ovl_dentry_update(dentry, VAR_8);
VAR_8 = NULL;
if (!S_ISDIR(VAR_3->mode))
ovl_dentry_set_opaque(dentry, true);
out2:
dput(VAR_9);
out1:
dput(VAR_8);
out:
return VAR_11;
out_cleanup:
ovl_cleanup(VAR_6, VAR_8);
goto out;
}",torvalds/linux/ab79efab0a0ba01a74df782eb7fa44b044dae8b5/copy_up.c/vul/before/0.json,"static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
			      struct dentry *dentry, struct path *lowerpath,
			      struct kstat *stat, struct iattr *attr,
			      const char *link)
{
	struct inode *wdir = workdir->d_inode;
	struct inode *udir = upperdir->d_inode;
	struct dentry *newdentry = NULL;
	struct dentry *upper = NULL;
	umode_t mode = stat->mode;
	int err;

	newdentry = ovl_lookup_temp(workdir, dentry);
	err = PTR_ERR(newdentry);
	if (IS_ERR(newdentry))
		goto out;

	upper = lookup_one_len(dentry->d_name.name, upperdir,
			       dentry->d_name.len);
	err = PTR_ERR(upper);
	if (IS_ERR(upper))
		goto out1;

	/* Can't properly set mode on creation because of the umask */
	stat->mode &= S_IFMT;
	err = ovl_create_real(wdir, newdentry, stat, link, NULL, true);
	stat->mode = mode;
	if (err)
		goto out2;

	if (S_ISREG(stat->mode)) {
		struct path upperpath;
		ovl_path_upper(dentry, &upperpath);
		BUG_ON(upperpath.dentry != NULL);
		upperpath.dentry = newdentry;

		err = ovl_copy_up_data(lowerpath, &upperpath, stat->size);
		if (err)
			goto out_cleanup;
	}

	err = ovl_copy_xattr(lowerpath->dentry, newdentry);
	if (err)
		goto out_cleanup;

	mutex_lock(&newdentry->d_inode->i_mutex);
	err = ovl_set_attr(newdentry, stat);
	if (!err && attr)
		err = notify_change(newdentry, attr, NULL);
	mutex_unlock(&newdentry->d_inode->i_mutex);
	if (err)
		goto out_cleanup;

	err = ovl_do_rename(wdir, newdentry, udir, upper, 0);
	if (err)
		goto out_cleanup;

	ovl_dentry_update(dentry, newdentry);
	newdentry = NULL;

	/*
	 * Non-directores become opaque when copied up.
	 */
	if (!S_ISDIR(stat->mode))
		ovl_dentry_set_opaque(dentry, true);
out2:
	dput(upper);
out1:
	dput(newdentry);
out:
	return err;

out_cleanup:
	ovl_cleanup(wdir, newdentry);
	goto out2;
}","static int ovl_copy_up_locked(struct dentry *VAR_0, struct dentry *VAR_1,
			      struct dentry *dentry, struct path *VAR_2,
			      struct kstat *VAR_3, struct iattr *VAR_4,
			      const char *VAR_5)
{
	struct inode *VAR_6 = VAR_0->d_inode;
	struct inode *VAR_7 = VAR_1->d_inode;
	struct dentry *VAR_8 = NULL;
	struct dentry *VAR_9 = NULL;
	umode_t VAR_10 = VAR_3->mode;
	int VAR_11;

	VAR_8 = ovl_lookup_temp(VAR_0, dentry);
	VAR_11 = PTR_ERR(VAR_8);
	if (IS_ERR(VAR_8))
		goto out;

	VAR_9 = lookup_one_len(dentry->d_name.name, VAR_1,
			       dentry->d_name.len);
	VAR_11 = PTR_ERR(VAR_9);
	if (IS_ERR(VAR_9))
		goto out1;

	/* COMMENT_0 */
	VAR_3->mode &= VAR_12;
	VAR_11 = ovl_create_real(VAR_6, VAR_8, VAR_3, VAR_5, NULL, true);
	VAR_3->mode = VAR_10;
	if (VAR_11)
		goto out2;

	if (S_ISREG(VAR_3->mode)) {
		struct path VAR_13;
		ovl_path_upper(dentry, &VAR_13);
		BUG_ON(VAR_13.dentry != NULL);
		VAR_13.dentry = VAR_8;

		VAR_11 = ovl_copy_up_data(VAR_2, &VAR_13, VAR_3->size);
		if (VAR_11)
			goto out_cleanup;
	}

	VAR_11 = ovl_copy_xattr(VAR_2->dentry, VAR_8);
	if (VAR_11)
		goto out_cleanup;

	mutex_lock(&VAR_8->d_inode->i_mutex);
	VAR_11 = ovl_set_attr(VAR_8, VAR_3);
	if (!VAR_11 && VAR_4)
		VAR_11 = notify_change(VAR_8, VAR_4, NULL);
	mutex_unlock(&VAR_8->d_inode->i_mutex);
	if (VAR_11)
		goto out_cleanup;

	VAR_11 = ovl_do_rename(VAR_6, VAR_8, VAR_7, VAR_9, 0);
	if (VAR_11)
		goto out_cleanup;

	ovl_dentry_update(dentry, VAR_8);
	VAR_8 = NULL;

	/* COMMENT_1 */
                                                
    
	if (!S_ISDIR(VAR_3->mode))
		ovl_dentry_set_opaque(dentry, true);
out2:
	dput(VAR_9);
out1:
	dput(VAR_8);
out:
	return VAR_11;

out_cleanup:
	ovl_cleanup(VAR_6, VAR_8);
	goto out2;
}",torvalds/linux/ab79efab0a0ba01a74df782eb7fa44b044dae8b5/copy_up.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,5 +72,5 @@
 
 out_cleanup:
 	ovl_cleanup(wdir, newdentry);
-	goto out;
+	goto out2;
 }","{'deleted_lines': ['\tgoto out;'], 'added_lines': ['\tgoto out2;']}",True,"fs/overlayfs/copy_up.c in the Linux kernel before 4.2.6 uses an incorrect cleanup code path, which allows local users to cause a denial of service (dentry reference leak) via filesystem operations on a large file in a lower overlayfs layer.",5.5,MEDIUM,1,valid,2015-09-18T10:45:22Z,1
CVE-2016-6288,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #70480 (php_url_parse_ex() buffer overflow read),629e4da7cc8b174acdeab84969cbfc606a019b31,https://github.com/php/php-src/commit/629e4da7cc8b174acdeab84969cbfc606a019b31,ext/standard/url.c,php_url_parse_ex,"PHPAPI php_url *php_url_parse_ex(char const *str, int length)
{
char port_buf[6];
php_url *ret = ecalloc(1, sizeof(php_url));
char const *s, *e, *p, *pp, *ue;
s = str;
ue = s + length;
if ((e = memchr(s, ':', length)) && (e - s)) {
p = s;
while (p < e) {
if (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {
if (e + 1 < ue) {
goto parse_port;
} else {
goto just_path;
}
}
p++;
}
if (*(e + 1) == '\0') { 
ret->scheme = estrndup(s, (e - s));
php_replace_controlchars_ex(ret->scheme, (e - s));
goto end;
}
if (*(e+1) != '/') {
p = e + 1;
while (isdigit(*p)) {
p++;
}
if ((*p == '\0' || *p == '/') && (p - e) < 7) {
goto parse_port;
}
ret->scheme = estrndup(s, (e-s));
php_replace_controlchars_ex(ret->scheme, (e - s));
length -= ++e - s;
s = e;
goto just_path;
} else {
ret->scheme = estrndup(s, (e-s));
php_replace_controlchars_ex(ret->scheme, (e - s));
if (*(e+2) == '/') {
s = e + 3;
if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
if (*(e + 3) == '/') {
if (*(e + 5) == ':') {
s = e + 4;
}
goto nohost;
}
}
} else {
if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
s = e + 1;
goto nohost;
} else {
length -= ++e - s;
s = e;
goto just_path;
}
}
}
} else if (e) { 
parse_port:
p = e + 1;
pp = p;
while (pp-p < 6 && isdigit(*pp)) {
pp++;
}
if (pp - p > 0 && pp - p < 6 && (*pp == '/' || *pp == '\0')) {
long port;
memcpy(port_buf, p, (pp - p));
port_buf[pp - p] = '\0';
port = strtol(port_buf, NULL, 10);
if (port > 0 && port <= 65535) {
ret->port = (unsigned short) port;
if (*s == '/' && *(s + 1) == '/') { 
s += 2;
}
} else {
STR_FREE(ret->scheme);
efree(ret);
return NULL;
}
} else if (p == pp && *pp == '\0') {
STR_FREE(ret->scheme);
efree(ret);
return NULL;
} else if (*s == '/' && *(s + 1) == '/') { 
s += 2;
} else {
goto just_path;
}
} else if (*s == '/' && *(s + 1) == '/') { 
s += 2;
} else {
just_path:
ue = s + length;
goto nohost;
}
e = ue;
if (!(p = memchr(s, '/', (ue - s)))) {
char *query, *fragment;
query = memchr(s, '?', (ue - s));
fragment = memchr(s, '#', (ue - s));
if (query && fragment) {
if (query > fragment) {
e = fragment;
} else {
e = query;
}
} else if (query) {
e = query;
} else if (fragment) {
e = fragment;
}
} else {
e = p;
}
if ((p = zend_memrchr(s, '@', (e-s)))) {
if ((pp = memchr(s, ':', (p-s)))) {
ret->user = estrndup(s, (pp-s));
php_replace_controlchars_ex(ret->user, (pp - s));
pp++;
ret->pass = estrndup(pp, (p-pp));
php_replace_controlchars_ex(ret->pass, (p-pp));
} else {
ret->user = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->user, (p-s));
}
s = p + 1;
}
if (*s == '[' && *(e-1) == ']') {
p = s;
} else {
for(p = e; p >= s && *p != ':'; p--);
}
if (p >= s && *p == ':') {
if (!ret->port) {
p++;
if (e-p > 5) { 
STR_FREE(ret->scheme);
STR_FREE(ret->user);
STR_FREE(ret->pass);
efree(ret);
return NULL;
} else if (e - p > 0) {
long port;
memcpy(port_buf, p, (e - p));
port_buf[e - p] = '\0';
port = strtol(port_buf, NULL, 10);
if (port > 0 && port <= 65535) {
ret->port = (unsigned short)port;
} else {
STR_FREE(ret->scheme);
STR_FREE(ret->user);
STR_FREE(ret->pass);
efree(ret);
return NULL;
}
}
p--;
}
} else {
p = e;
}
if ((p-s) < 1) {
STR_FREE(ret->scheme);
STR_FREE(ret->user);
STR_FREE(ret->pass);
efree(ret);
return NULL;
}
ret->host = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->host, (p - s));
if (e == ue) {
return ret;
}
s = e;
nohost:
if ((p = memchr(s, '?', (ue - s)))) {
pp = strchr(s, '#');
if (pp && pp < p) {
if (pp - s) {
ret->path = estrndup(s, (pp-s));
php_replace_controlchars_ex(ret->path, (pp - s));
}
p = pp;
goto label_parse;
}
if (p - s) {
ret->path = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->path, (p - s));
}
if (pp) {
if (pp - ++p) { 
ret->query = estrndup(p, (pp-p));
php_replace_controlchars_ex(ret->query, (pp - p));
}
p = pp;
goto label_parse;
} else if (++p - ue) {
ret->query = estrndup(p, (ue-p));
php_replace_controlchars_ex(ret->query, (ue - p));
}
} else if ((p = memchr(s, '#', (ue - s)))) {
if (p - s) {
ret->path = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->path, (p - s));
}
label_parse:
p++;
if (ue - p) {
ret->fragment = estrndup(p, (ue-p));
php_replace_controlchars_ex(ret->fragment, (ue - p));
}
} else {
ret->path = estrndup(s, (ue-s));
php_replace_controlchars_ex(ret->path, (ue - s));
}
end:
return ret;
}","PHPAPI VAR_0 *php_url_parse_ex(char const *VAR_1, int VAR_2)
{
char VAR_3[6];
php_url *VAR_4 = ecalloc(1, sizeof(php_url));
char const *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;
VAR_5 = VAR_1;
VAR_9 = VAR_5 + VAR_2;
if ((VAR_6 = memchr(VAR_5, ':', VAR_2)) && (VAR_6 - VAR_5)) {
VAR_7 = VAR_5;
while (VAR_7 < VAR_6) {
if (!isalpha(*VAR_7) && !isdigit(*VAR_7) && *VAR_7 != '+' && *VAR_7 != '.' && *VAR_7 != '-') {
if (VAR_6 + 1 < VAR_9) {
goto parse_port;
} else {
goto just_path;
}
}
VAR_7++;
}
if (*(VAR_6 + 1) == '\0') { 
VAR_4->scheme = estrndup(VAR_5, (VAR_6 - VAR_5));
php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
goto end;
}
if (*(VAR_6+1) != '/') {
VAR_7 = VAR_6 + 1;
while (isdigit(*VAR_7)) {
VAR_7++;
}
if ((*VAR_7 == '\0' || *VAR_7 == '/') && (VAR_7 - VAR_6) < 7) {
goto parse_port;
}
VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
VAR_2 -= ++VAR_6 - VAR_5;
VAR_5 = VAR_6;
goto just_path;
} else {
VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
if (*(VAR_6+2) == '/') {
VAR_5 = VAR_6 + 3;
if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
if (*(VAR_6 + 3) == '/') {
if (*(VAR_6 + 5) == ':') {
VAR_5 = VAR_6 + 4;
}
goto nohost;
}
}
} else {
if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
VAR_5 = VAR_6 + 1;
goto nohost;
} else {
VAR_2 -= ++VAR_6 - VAR_5;
VAR_5 = VAR_6;
goto just_path;
}
}
}
} else if (VAR_6) { 
parse_port:
VAR_7 = VAR_6 + 1;
VAR_8 = VAR_7;
while (VAR_8-VAR_7 < 6 && isdigit(*VAR_8)) {
VAR_8++;
}
if (VAR_8 - VAR_7 > 0 && VAR_8 - VAR_7 < 6 && (*VAR_8 == '/' || *VAR_8 == '\0')) {
long VAR_10;
memcpy(VAR_3, VAR_7, (VAR_8 - VAR_7));
VAR_3[VAR_8 - VAR_7] = '\0';
VAR_10 = strtol(VAR_3, NULL, 10);
if (VAR_10 > 0 && VAR_10 <= 65535) {
VAR_4->port = (unsigned short) VAR_10;
if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { 
VAR_5 += 2;
}
} else {
STR_FREE(VAR_4->scheme);
efree(VAR_4);
return NULL;
}
} else if (VAR_7 == VAR_8 && *VAR_8 == '\0') {
STR_FREE(VAR_4->scheme);
efree(VAR_4);
return NULL;
} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { 
VAR_5 += 2;
} else {
goto just_path;
}
} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { 
VAR_5 += 2;
} else {
just_path:
VAR_9 = VAR_5 + VAR_2;
goto nohost;
}
VAR_6 = VAR_9;
if (!(VAR_7 = memchr(VAR_5, '/', (VAR_9 - VAR_5)))) {
char *VAR_11, *VAR_12;
VAR_11 = memchr(VAR_5, '?', (VAR_9 - VAR_5));
VAR_12 = memchr(VAR_5, '#', (VAR_9 - VAR_5));
if (VAR_11 && VAR_12) {
if (VAR_11 > VAR_12) {
VAR_6 = VAR_12;
} else {
VAR_6 = VAR_11;
}
} else if (VAR_11) {
VAR_6 = VAR_11;
} else if (VAR_12) {
VAR_6 = VAR_12;
}
} else {
VAR_6 = VAR_7;
}
if ((VAR_7 = zend_memrchr(VAR_5, '@', (VAR_6-VAR_5)))) {
if ((VAR_8 = memchr(VAR_5, ':', (VAR_7-VAR_5)))) {
VAR_4->user = estrndup(VAR_5, (VAR_8-VAR_5));
php_replace_controlchars_ex(VAR_4->user, (VAR_8 - VAR_5));
VAR_8++;
VAR_4->pass = estrndup(VAR_8, (VAR_7-VAR_8));
php_replace_controlchars_ex(VAR_4->pass, (VAR_7-VAR_8));
} else {
VAR_4->user = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->user, (VAR_7-VAR_5));
}
VAR_5 = VAR_7 + 1;
}
if (*VAR_5 == '[' && *(VAR_6-1) == ']') {
VAR_7 = VAR_5;
} else {
for(VAR_7 = VAR_6; VAR_7 >= VAR_5 && *VAR_7 != ':'; VAR_7--);
}
if (VAR_7 >= VAR_5 && *VAR_7 == ':') {
if (!VAR_4->port) {
VAR_7++;
if (VAR_6-VAR_7 > 5) { 
STR_FREE(VAR_4->scheme);
STR_FREE(VAR_4->user);
STR_FREE(VAR_4->pass);
efree(VAR_4);
return NULL;
} else if (VAR_6 - VAR_7 > 0) {
long VAR_10;
memcpy(VAR_3, VAR_7, (VAR_6 - VAR_7));
VAR_3[VAR_6 - VAR_7] = '\0';
VAR_10 = strtol(VAR_3, NULL, 10);
if (VAR_10 > 0 && VAR_10 <= 65535) {
VAR_4->port = (unsigned short)VAR_10;
} else {
STR_FREE(VAR_4->scheme);
STR_FREE(VAR_4->user);
STR_FREE(VAR_4->pass);
efree(VAR_4);
return NULL;
}
}
VAR_7--;
}
} else {
VAR_7 = VAR_6;
}
if ((VAR_7-VAR_5) < 1) {
STR_FREE(VAR_4->scheme);
STR_FREE(VAR_4->user);
STR_FREE(VAR_4->pass);
efree(VAR_4);
return NULL;
}
VAR_4->host = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->host, (VAR_7 - VAR_5));
if (VAR_6 == VAR_9) {
return VAR_4;
}
VAR_5 = VAR_6;
nohost:
if ((VAR_7 = memchr(VAR_5, '?', (VAR_9 - VAR_5)))) {
VAR_8 = strchr(VAR_5, '#');
if (VAR_8 && VAR_8 < VAR_7) {
if (VAR_8 - VAR_5) {
VAR_4->path = estrndup(VAR_5, (VAR_8-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_8 - VAR_5));
}
VAR_7 = VAR_8;
goto label_parse;
}
if (VAR_7 - VAR_5) {
VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
}
if (VAR_8) {
if (VAR_8 - ++VAR_7) { 
VAR_4->query = estrndup(VAR_7, (VAR_8-VAR_7));
php_replace_controlchars_ex(VAR_4->query, (VAR_8 - VAR_7));
}
VAR_7 = VAR_8;
goto label_parse;
} else if (++VAR_7 - VAR_9) {
VAR_4->query = estrndup(VAR_7, (VAR_9-VAR_7));
php_replace_controlchars_ex(VAR_4->query, (VAR_9 - VAR_7));
}
} else if ((VAR_7 = memchr(VAR_5, '#', (VAR_9 - VAR_5)))) {
if (VAR_7 - VAR_5) {
VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
}
label_parse:
VAR_7++;
if (VAR_9 - VAR_7) {
VAR_4->fragment = estrndup(VAR_7, (VAR_9-VAR_7));
php_replace_controlchars_ex(VAR_4->fragment, (VAR_9 - VAR_7));
}
} else {
VAR_4->path = estrndup(VAR_5, (VAR_9-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_9 - VAR_5));
}
end:
return VAR_4;
}",,"PHPAPI php_url *php_url_parse_ex(char const *str, int length)
{
	char port_buf[6];
	php_url *ret = ecalloc(1, sizeof(php_url));
	char const *s, *e, *p, *pp, *ue;
		
	s = str;
	ue = s + length;

	/* parse scheme */
	if ((e = memchr(s, ':', length)) && (e - s)) {
		/* validate scheme */
		p = s;
		while (p < e) {
			/* scheme = 1*[ lowalpha | digit | ""+"" | ""-"" | ""."" ] */
			if (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {
				if (e + 1 < ue) {
					goto parse_port;
				} else {
					goto just_path;
				}
			}
			p++;
		}
	
		if (*(e + 1) == '\0') { /* only scheme is available */
			ret->scheme = estrndup(s, (e - s));
			php_replace_controlchars_ex(ret->scheme, (e - s));
			goto end;
		}

		/* 
		 * certain schemas like mailto: and zlib: may not have any / after them
		 * this check ensures we support those.
		 */
		if (*(e+1) != '/') {
			/* check if the data we get is a port this allows us to 
			 * correctly parse things like a.com:80
			 */
			p = e + 1;
			while (isdigit(*p)) {
				p++;
			}
			
			if ((*p == '\0' || *p == '/') && (p - e) < 7) {
				goto parse_port;
			}
			
			ret->scheme = estrndup(s, (e-s));
			php_replace_controlchars_ex(ret->scheme, (e - s));
			
			length -= ++e - s;
			s = e;
			goto just_path;
		} else {
			ret->scheme = estrndup(s, (e-s));
			php_replace_controlchars_ex(ret->scheme, (e - s));
		
			if (*(e+2) == '/') {
				s = e + 3;
				if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
					if (*(e + 3) == '/') {
						/* support windows drive letters as in:
						   file:///c:/somedir/file.txt
						*/
						if (*(e + 5) == ':') {
							s = e + 4;
						}
						goto nohost;
					}
				}
			} else {
				if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
					s = e + 1;
					goto nohost;
				} else {
					length -= ++e - s;
					s = e;
					goto just_path;
				}	
			}
		}	
	} else if (e) { /* no scheme; starts with colon: look for port */
		parse_port:
		p = e + 1;
		pp = p;

		while (pp-p < 6 && isdigit(*pp)) {
			pp++;
		}

		if (pp - p > 0 && pp - p < 6 && (*pp == '/' || *pp == '\0')) {
			long port;
			memcpy(port_buf, p, (pp - p));
			port_buf[pp - p] = '\0';
			port = strtol(port_buf, NULL, 10);
			if (port > 0 && port <= 65535) {
				ret->port = (unsigned short) port;
				if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */
				    s += 2;
				}
			} else {
				STR_FREE(ret->scheme);
				efree(ret);
				return NULL;
			}
		} else if (p == pp && *pp == '\0') {
			STR_FREE(ret->scheme);
			efree(ret);
			return NULL;
		} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */
			s += 2;
		} else {
			goto just_path;
		}
	} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */
		s += 2;
	} else {
		just_path:
		ue = s + length;
		goto nohost;
	}
	
	e = ue;
	
	if (!(p = memchr(s, '/', (ue - s)))) {
		char *query, *fragment;

		query = memchr(s, '?', (ue - s));
		fragment = memchr(s, '#', (ue - s));

		if (query && fragment) {
			if (query > fragment) {
				e = fragment;
			} else {
				e = query;
			}
		} else if (query) {
			e = query;
		} else if (fragment) {
			e = fragment;
		}
	} else {
		e = p;
	}	
		
	/* check for login and password */
	if ((p = zend_memrchr(s, '@', (e-s)))) {
		if ((pp = memchr(s, ':', (p-s)))) {
			ret->user = estrndup(s, (pp-s));
			php_replace_controlchars_ex(ret->user, (pp - s));
		
			pp++;
			ret->pass = estrndup(pp, (p-pp));
			php_replace_controlchars_ex(ret->pass, (p-pp));
		} else {
			ret->user = estrndup(s, (p-s));
			php_replace_controlchars_ex(ret->user, (p-s));
		}
		
		s = p + 1;
	}

	/* check for port */
	if (*s == '[' && *(e-1) == ']') {
		/* Short circuit portscan, 
		   we're dealing with an 
		   IPv6 embedded address */
		p = s;
	} else {
		/* memrchr is a GNU specific extension
		   Emulate for wide compatibility */
		for(p = e; p >= s && *p != ':'; p--);
	}

	if (p >= s && *p == ':') {
		if (!ret->port) {
			p++;
			if (e-p > 5) { /* port cannot be longer then 5 characters */
				STR_FREE(ret->scheme);
				STR_FREE(ret->user);
				STR_FREE(ret->pass);
				efree(ret);
				return NULL;
			} else if (e - p > 0) {
				long port;
				memcpy(port_buf, p, (e - p));
				port_buf[e - p] = '\0';
				port = strtol(port_buf, NULL, 10);
				if (port > 0 && port <= 65535) {
					ret->port = (unsigned short)port;
				} else {
					STR_FREE(ret->scheme);
					STR_FREE(ret->user);
					STR_FREE(ret->pass);
					efree(ret);
					return NULL;
				}
			}
			p--;
		}	
	} else {
		p = e;
	}
	
	/* check if we have a valid host, if we don't reject the string as url */
	if ((p-s) < 1) {
		STR_FREE(ret->scheme);
		STR_FREE(ret->user);
		STR_FREE(ret->pass);
		efree(ret);
		return NULL;
	}

	ret->host = estrndup(s, (p-s));
	php_replace_controlchars_ex(ret->host, (p - s));
	
	if (e == ue) {
		return ret;
	}
	
	s = e;
	
	nohost:
	
	if ((p = memchr(s, '?', (ue - s)))) {
		pp = memchr(s, '#', (ue - s));

		if (pp && pp < p) {
			if (pp - s) {
				ret->path = estrndup(s, (pp-s));
				php_replace_controlchars_ex(ret->path, (pp - s));
			}
			p = pp;
			goto label_parse;
		}
	
		if (p - s) {
			ret->path = estrndup(s, (p-s));
			php_replace_controlchars_ex(ret->path, (p - s));
		}	
	
		if (pp) {
			if (pp - ++p) { 
				ret->query = estrndup(p, (pp-p));
				php_replace_controlchars_ex(ret->query, (pp - p));
			}
			p = pp;
			goto label_parse;
		} else if (++p - ue) {
			ret->query = estrndup(p, (ue-p));
			php_replace_controlchars_ex(ret->query, (ue - p));
		}
	} else if ((p = memchr(s, '#', (ue - s)))) {
		if (p - s) {
			ret->path = estrndup(s, (p-s));
			php_replace_controlchars_ex(ret->path, (p - s));
		}	
		
		label_parse:
		p++;
		
		if (ue - p) {
			ret->fragment = estrndup(p, (ue-p));
			php_replace_controlchars_ex(ret->fragment, (ue - p));
		}	
	} else {
		ret->path = estrndup(s, (ue-s));
		php_replace_controlchars_ex(ret->path, (ue - s));
	}
end:
	return ret;
}","PHPAPI VAR_0 *php_url_parse_ex(char const *VAR_1, int VAR_2)
{
	char VAR_3[6];
	php_url *VAR_4 = ecalloc(1, sizeof(php_url));
	char const *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;
		
	VAR_5 = VAR_1;
	VAR_9 = VAR_5 + VAR_2;

	/* COMMENT_0 */
	if ((VAR_6 = memchr(VAR_5, ':', VAR_2)) && (VAR_6 - VAR_5)) {
		/* COMMENT_1 */
		VAR_7 = VAR_5;
		while (VAR_7 < VAR_6) {
			/* COMMENT_2 */
			if (!isalpha(*VAR_7) && !isdigit(*VAR_7) && *VAR_7 != '+' && *VAR_7 != '.' && *VAR_7 != '-') {
				if (VAR_6 + 1 < VAR_9) {
					goto parse_port;
				} else {
					goto just_path;
				}
			}
			VAR_7++;
		}
	
		if (*(VAR_6 + 1) == '\0') { /* COMMENT_3 */
			VAR_4->scheme = estrndup(VAR_5, (VAR_6 - VAR_5));
			php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
			goto end;
		}

		/* COMMENT_4 */
                                                                         
                                         
     
		if (*(VAR_6+1) != '/') {
			/* COMMENT_8 */
                                          
      
			VAR_7 = VAR_6 + 1;
			while (isdigit(*VAR_7)) {
				VAR_7++;
			}
			
			if ((*VAR_7 == '\0' || *VAR_7 == '/') && (VAR_7 - VAR_6) < 7) {
				goto parse_port;
			}
			
			VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
			php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
			
			VAR_2 -= ++VAR_6 - VAR_5;
			VAR_5 = VAR_6;
			goto just_path;
		} else {
			VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
			php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
		
			if (*(VAR_6+2) == '/') {
				VAR_5 = VAR_6 + 3;
				if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
					if (*(VAR_6 + 3) == '/') {
						/* COMMENT_11 */
                                    
        
						if (*(VAR_6 + 5) == ':') {
							VAR_5 = VAR_6 + 4;
						}
						goto nohost;
					}
				}
			} else {
				if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
					VAR_5 = VAR_6 + 1;
					goto nohost;
				} else {
					VAR_2 -= ++VAR_6 - VAR_5;
					VAR_5 = VAR_6;
					goto just_path;
				}	
			}
		}	
	} else if (VAR_6) { /* COMMENT_14 */
		parse_port:
		VAR_7 = VAR_6 + 1;
		VAR_8 = VAR_7;

		while (VAR_8-VAR_7 < 6 && isdigit(*VAR_8)) {
			VAR_8++;
		}

		if (VAR_8 - VAR_7 > 0 && VAR_8 - VAR_7 < 6 && (*VAR_8 == '/' || *VAR_8 == '\0')) {
			long VAR_10;
			memcpy(VAR_3, VAR_7, (VAR_8 - VAR_7));
			VAR_3[VAR_8 - VAR_7] = '\0';
			VAR_10 = strtol(VAR_3, NULL, 10);
			if (VAR_10 > 0 && VAR_10 <= 65535) {
				VAR_4->port = (unsigned short) VAR_10;
				if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { /* COMMENT_15 */
				    VAR_5 += 2;
				}
			} else {
				STR_FREE(VAR_4->scheme);
				efree(VAR_4);
				return NULL;
			}
		} else if (VAR_7 == VAR_8 && *VAR_8 == '\0') {
			STR_FREE(VAR_4->scheme);
			efree(VAR_4);
			return NULL;
		} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { /* COMMENT_15 */
			VAR_5 += 2;
		} else {
			goto just_path;
		}
	} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { /* COMMENT_15 */
		VAR_5 += 2;
	} else {
		just_path:
		VAR_9 = VAR_5 + VAR_2;
		goto nohost;
	}
	
	VAR_6 = VAR_9;
	
	if (!(VAR_7 = memchr(VAR_5, '/', (VAR_9 - VAR_5)))) {
		char *VAR_11, *VAR_12;

		VAR_11 = memchr(VAR_5, '?', (VAR_9 - VAR_5));
		VAR_12 = memchr(VAR_5, '#', (VAR_9 - VAR_5));

		if (VAR_11 && VAR_12) {
			if (VAR_11 > VAR_12) {
				VAR_6 = VAR_12;
			} else {
				VAR_6 = VAR_11;
			}
		} else if (VAR_11) {
			VAR_6 = VAR_11;
		} else if (VAR_12) {
			VAR_6 = VAR_12;
		}
	} else {
		VAR_6 = VAR_7;
	}	
		
	/* COMMENT_16 */
	if ((VAR_7 = zend_memrchr(VAR_5, '@', (VAR_6-VAR_5)))) {
		if ((VAR_8 = memchr(VAR_5, ':', (VAR_7-VAR_5)))) {
			VAR_4->user = estrndup(VAR_5, (VAR_8-VAR_5));
			php_replace_controlchars_ex(VAR_4->user, (VAR_8 - VAR_5));
		
			VAR_8++;
			VAR_4->pass = estrndup(VAR_8, (VAR_7-VAR_8));
			php_replace_controlchars_ex(VAR_4->pass, (VAR_7-VAR_8));
		} else {
			VAR_4->user = estrndup(VAR_5, (VAR_7-VAR_5));
			php_replace_controlchars_ex(VAR_4->user, (VAR_7-VAR_5));
		}
		
		VAR_5 = VAR_7 + 1;
	}

	/* COMMENT_17 */
	if (*VAR_5 == '[' && *(VAR_6-1) == ']') {
		/* COMMENT_18 */
                           
                             
		VAR_7 = VAR_5;
	} else {
		/* COMMENT_21 */
                                      
		for(VAR_7 = VAR_6; VAR_7 >= VAR_5 && *VAR_7 != ':'; VAR_7--);
	}

	if (VAR_7 >= VAR_5 && *VAR_7 == ':') {
		if (!VAR_4->port) {
			VAR_7++;
			if (VAR_6-VAR_7 > 5) { /* COMMENT_23 */
				STR_FREE(VAR_4->scheme);
				STR_FREE(VAR_4->user);
				STR_FREE(VAR_4->pass);
				efree(VAR_4);
				return NULL;
			} else if (VAR_6 - VAR_7 > 0) {
				long VAR_10;
				memcpy(VAR_3, VAR_7, (VAR_6 - VAR_7));
				VAR_3[VAR_6 - VAR_7] = '\0';
				VAR_10 = strtol(VAR_3, NULL, 10);
				if (VAR_10 > 0 && VAR_10 <= 65535) {
					VAR_4->port = (unsigned short)VAR_10;
				} else {
					STR_FREE(VAR_4->scheme);
					STR_FREE(VAR_4->user);
					STR_FREE(VAR_4->pass);
					efree(VAR_4);
					return NULL;
				}
			}
			VAR_7--;
		}	
	} else {
		VAR_7 = VAR_6;
	}
	
	/* COMMENT_24 */
	if ((VAR_7-VAR_5) < 1) {
		STR_FREE(VAR_4->scheme);
		STR_FREE(VAR_4->user);
		STR_FREE(VAR_4->pass);
		efree(VAR_4);
		return NULL;
	}

	VAR_4->host = estrndup(VAR_5, (VAR_7-VAR_5));
	php_replace_controlchars_ex(VAR_4->host, (VAR_7 - VAR_5));
	
	if (VAR_6 == VAR_9) {
		return VAR_4;
	}
	
	VAR_5 = VAR_6;
	
	nohost:
	
	if ((VAR_7 = memchr(VAR_5, '?', (VAR_9 - VAR_5)))) {
		VAR_8 = memchr(VAR_5, '#', (VAR_9 - VAR_5));

		if (VAR_8 && VAR_8 < VAR_7) {
			if (VAR_8 - VAR_5) {
				VAR_4->path = estrndup(VAR_5, (VAR_8-VAR_5));
				php_replace_controlchars_ex(VAR_4->path, (VAR_8 - VAR_5));
			}
			VAR_7 = VAR_8;
			goto label_parse;
		}
	
		if (VAR_7 - VAR_5) {
			VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
			php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
		}	
	
		if (VAR_8) {
			if (VAR_8 - ++VAR_7) { 
				VAR_4->query = estrndup(VAR_7, (VAR_8-VAR_7));
				php_replace_controlchars_ex(VAR_4->query, (VAR_8 - VAR_7));
			}
			VAR_7 = VAR_8;
			goto label_parse;
		} else if (++VAR_7 - VAR_9) {
			VAR_4->query = estrndup(VAR_7, (VAR_9-VAR_7));
			php_replace_controlchars_ex(VAR_4->query, (VAR_9 - VAR_7));
		}
	} else if ((VAR_7 = memchr(VAR_5, '#', (VAR_9 - VAR_5)))) {
		if (VAR_7 - VAR_5) {
			VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
			php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
		}	
		
		label_parse:
		VAR_7++;
		
		if (VAR_9 - VAR_7) {
			VAR_4->fragment = estrndup(VAR_7, (VAR_9-VAR_7));
			php_replace_controlchars_ex(VAR_4->fragment, (VAR_9 - VAR_7));
		}	
	} else {
		VAR_4->path = estrndup(VAR_5, (VAR_9-VAR_5));
		php_replace_controlchars_ex(VAR_4->path, (VAR_9 - VAR_5));
	}
end:
	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -224,7 +224,7 @@
 	nohost:
 	
 	if ((p = memchr(s, '?', (ue - s)))) {
-		pp = strchr(s, '#');
+		pp = memchr(s, '#', (ue - s));
 
 		if (pp && pp < p) {
 			if (pp - s) {","{'deleted_lines': [""\t\tpp = strchr(s, '#');""], 'added_lines': [""\t\tpp = memchr(s, '#', (ue - s));""]}",True,The php_url_parse_ex function in ext/standard/url.c in PHP before 5.5.38 allows remote attackers to cause a denial of service (buffer over-read) or possibly have unspecified other impact via vectors involving the smart_str data type.,9.8,CRITICAL,3,valid,2015-09-28T18:31:14Z,1
CVE-2015-8789,['CWE-Other'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,Matroska-Org/libebml,"EbmlMaster: propagate upper level element after infinite sized one correctly

When the parser encountered a deeply nested element with an infinite
size then a following element of an upper level was not propagated
correctly. Instead the element with the infinite size was added into the
EBML element tree a second time resulting in memory access after freeing
it and multiple attempts to free the same memory address during
destruction.

Fixes the issue reported as Cisco TALOS-CAN-0037.",88409e2a94dd3b40ff81d08bf6d92f486d036b24,https://github.com/Matroska-Org/libebml/commit/88409e2a94dd3b40ff81d08bf6d92f486d036b24,src/EbmlMaster.cpp,EbmlMaster::Read,"void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)
{
if (ReadFully == SCOPE_NO_DATA)
return;
EbmlElement * ElementLevelA;
size_t Index;
for (Index=0; Index<ElementList.size(); Index++) {
if (!(*ElementList[Index]).IsLocked()) {
delete ElementList[Index];
}
}
ElementList.clear();
uint64 MaxSizeToRead;
if (IsFiniteSize())
MaxSizeToRead = GetSize();
else
MaxSizeToRead = 0x7FFFFFFF;
if (MaxSizeToRead > 0)
{
inDataStream.I_O().setFilePointer(GetSizePosition() + GetSizeLength(), seek_beginning);
ElementLevelA = inDataStream.FindNextElement(sContext, UpperEltFound, MaxSizeToRead, AllowDummyElt);
while (ElementLevelA != NULL && UpperEltFound <= 0 && MaxSizeToRead > 0) {
if (IsFiniteSize() && ElementLevelA->IsFiniteSize())
MaxSizeToRead = GetEndPosition() - ElementLevelA->GetEndPosition();       if (!AllowDummyElt && ElementLevelA->IsDummy()) {
if (ElementLevelA->IsFiniteSize()) {
ElementLevelA->SkipData(inDataStream, sContext);
delete ElementLevelA;         } else {
delete ElementLevelA;           break;
}
} else {
ElementLevelA->Read(inDataStream, EBML_CONTEXT(ElementLevelA), UpperEltFound, FoundElt, AllowDummyElt, ReadFully);
bool DeleteElement = true;
if (ElementLevelA->ValueIsSet() || (ReadFully != SCOPE_ALL_DATA)) {
ElementList.push_back(ElementLevelA);
DeleteElement = false;
}
if (ElementLevelA->IsFiniteSize()) {
ElementLevelA->SkipData(inDataStream, EBML_CONTEXT(ElementLevelA));
if (DeleteElement)
delete ElementLevelA;
} else {
if (DeleteElement)
delete ElementLevelA;
break;
}
}
if (UpperEltFound > 0) {
UpperEltFound--;
if (UpperEltFound > 0 || MaxSizeToRead <= 0)
goto processCrc;
ElementLevelA = FoundElt;
continue;
}
if (UpperEltFound < 0) {
UpperEltFound++;
if (UpperEltFound < 0)
goto processCrc;
}
if (MaxSizeToRead <= 0)
goto processCrc;
ElementLevelA = inDataStream.FindNextElement(sContext, UpperEltFound, MaxSizeToRead, AllowDummyElt);
}
if (UpperEltFound > 0) {
FoundElt = ElementLevelA;
}
}
processCrc:
EBML_MASTER_ITERATOR Itr, CrcItr;
for (Itr = ElementList.begin(); Itr != ElementList.end();) {
if ((EbmlId)(*(*Itr)) == EBML_ID(EbmlCrc32)) {
bChecksumUsed = true;
Checksum = *(static_cast<EbmlCrc32*>(*Itr));
CrcItr = Itr;
break;
}
++Itr;
}
if (bChecksumUsed)
{
delete *CrcItr;
Remove(CrcItr);
}
SetValueIsSet();
}","void EbmlMaster::Read(EbmlStream & VAR_0, const EbmlSemanticContext & VAR_1, int & VAR_2, EbmlElement * & VAR_3, bool VAR_4, ScopeMode VAR_5)
{
if (VAR_5 == VAR_6)
return;
EbmlElement * VAR_7;
size_t VAR_8;
for (VAR_8=0; VAR_8<VAR_9.size(); VAR_8++) {
if (!(*VAR_9[VAR_8]).IsLocked()) {
delete VAR_9[VAR_8];
}
}
VAR_9.clear();
uint64 VAR_10;
if (IsFiniteSize())
VAR_10 = GetSize();
else
VAR_10 = 0x7FFFFFFF;
if (VAR_10 > 0)
{
VAR_0.I_O().setFilePointer(GetSizePosition() + GetSizeLength(), VAR_11);
VAR_7 = VAR_0.FindNextElement(VAR_1, VAR_2, VAR_10, VAR_4);
while (VAR_7 != NULL && VAR_2 <= 0 && VAR_10 > 0) {
if (IsFiniteSize() && VAR_7->IsFiniteSize())
VAR_10 = GetEndPosition() - VAR_7->GetEndPosition(); 
if (!VAR_4 && VAR_7->IsDummy()) {
if (VAR_7->IsFiniteSize()) {
VAR_7->SkipData(VAR_0, VAR_1);
delete VAR_7; 
} else {
delete VAR_7; 
break;
}
} else {
VAR_7->Read(VAR_0, EBML_CONTEXT(VAR_7), VAR_2, VAR_3, VAR_4, VAR_5);
bool VAR_12 = true;
if (VAR_7->ValueIsSet() || (VAR_5 != VAR_13)) {
VAR_9.push_back(VAR_7);
VAR_12 = false;
}
if (VAR_7->IsFiniteSize()) {
VAR_7->SkipData(VAR_0, EBML_CONTEXT(VAR_7));
if (VAR_12)
delete VAR_7;
} else {
if (VAR_12)
delete VAR_7;
break;
}
}
if (VAR_2 > 0) {
VAR_2--;
if (VAR_2 > 0 || VAR_10 <= 0)
goto processCrc;
VAR_7 = VAR_3;
continue;
}
if (VAR_2 < 0) {
VAR_2++;
if (VAR_2 < 0)
goto processCrc;
}
if (VAR_10 <= 0)
goto processCrc;
VAR_7 = VAR_0.FindNextElement(VAR_1, VAR_2, VAR_10, VAR_4);
}
if (VAR_2 > 0) {
VAR_3 = VAR_7;
}
}
processCrc:
VAR_14 VAR_15, VAR_16;
for (VAR_15 = VAR_9.begin(); VAR_15 != VAR_9.end();) {
if ((VAR_17)(*(*VAR_15)) == EBML_ID(VAR_18)) {
VAR_19 = true;
VAR_20 = *(VAR_21<EbmlCrc32*>(*VAR_15));
VAR_16 = VAR_15;
break;
}
++VAR_15;
}
if (VAR_19)
{
delete *VAR_16;
Remove(VAR_16);
}
SetValueIsSet();
}",Matroska-Org/libebml/88409e2a94dd3b40ff81d08bf6d92f486d036b24/EbmlMaster.cpp/vul/before/0.json,"void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)
{
  if (ReadFully == SCOPE_NO_DATA)
    return;

  EbmlElement * ElementLevelA;
  // remove all existing elements, including the mandatory ones...
  size_t Index;
  for (Index=0; Index<ElementList.size(); Index++) {
    if (!(*ElementList[Index]).IsLocked()) {
      delete ElementList[Index];
    }
  }
  ElementList.clear();
  uint64 MaxSizeToRead;

  if (IsFiniteSize())
    MaxSizeToRead = GetSize();
  else
    MaxSizeToRead = 0x7FFFFFFF;

  // read blocks and discard the ones we don't care about
  if (MaxSizeToRead > 0)
  {
    inDataStream.I_O().setFilePointer(GetSizePosition() + GetSizeLength(), seek_beginning);
    ElementLevelA = inDataStream.FindNextElement(sContext, UpperEltFound, MaxSizeToRead, AllowDummyElt);
    while (ElementLevelA != NULL && UpperEltFound <= 0 && MaxSizeToRead > 0) {
      if (IsFiniteSize() && ElementLevelA->IsFiniteSize())
        MaxSizeToRead = GetEndPosition() - ElementLevelA->GetEndPosition(); // even if it's the default value
      if (!AllowDummyElt && ElementLevelA->IsDummy()) {
        if (ElementLevelA->IsFiniteSize()) {
          ElementLevelA->SkipData(inDataStream, sContext);
          delete ElementLevelA; // forget this unknown element
        } else {
          delete ElementLevelA; // forget this unknown element
          break;
        }
      } else {
        ElementLevelA->Read(inDataStream, EBML_CONTEXT(ElementLevelA), UpperEltFound, FoundElt, AllowDummyElt, ReadFully);

        // Discard elements that couldn't be read properly if
        // SCOPE_ALL_DATA has been requested. This can happen
        // e.g. if block data is defective.
        bool DeleteElement = true;

        if (ElementLevelA->ValueIsSet() || (ReadFully != SCOPE_ALL_DATA)) {
          ElementList.push_back(ElementLevelA);
          DeleteElement = false;
        }

        // just in case
        if (ElementLevelA->IsFiniteSize()) {
          ElementLevelA->SkipData(inDataStream, EBML_CONTEXT(ElementLevelA));
          if (DeleteElement)
            delete ElementLevelA;
        } else {
          if (DeleteElement)
            delete ElementLevelA;

          if (UpperEltFound) {
            --UpperEltFound;
            if (UpperEltFound > 0 || MaxSizeToRead <= 0)
              goto processCrc;
            ElementLevelA = FoundElt;
          }

          break;
        }
      }

      if (UpperEltFound > 0) {
        UpperEltFound--;
        if (UpperEltFound > 0 || MaxSizeToRead <= 0)
          goto processCrc;
        ElementLevelA = FoundElt;
        continue;
      }

      if (UpperEltFound < 0) {
        UpperEltFound++;
        if (UpperEltFound < 0)
          goto processCrc;
      }

      if (MaxSizeToRead <= 0)
        goto processCrc;// this level is finished

      ElementLevelA = inDataStream.FindNextElement(sContext, UpperEltFound, MaxSizeToRead, AllowDummyElt);
    }
    if (UpperEltFound > 0) {
      FoundElt = ElementLevelA;
    }
  }
processCrc:

  EBML_MASTER_ITERATOR Itr, CrcItr;
  for (Itr = ElementList.begin(); Itr != ElementList.end();) {
    if ((EbmlId)(*(*Itr)) == EBML_ID(EbmlCrc32)) {
      bChecksumUsed = true;
      // remove the element
      Checksum = *(static_cast<EbmlCrc32*>(*Itr));
      CrcItr = Itr;
      break;
    }
    ++Itr;
  }

  if (bChecksumUsed)
  {
    delete *CrcItr;
    Remove(CrcItr);
  }

  SetValueIsSet();
}","void EbmlMaster::Read(EbmlStream & VAR_0, const EbmlSemanticContext & VAR_1, int & VAR_2, EbmlElement * & VAR_3, bool VAR_4, ScopeMode VAR_5)
{
  if (VAR_5 == VAR_6)
    return;

  EbmlElement * VAR_7;
  /* COMMENT_0 */
  size_t VAR_8;
  for (VAR_8=0; VAR_8<VAR_9.size(); VAR_8++) {
    if (!(*VAR_9[VAR_8]).IsLocked()) {
      delete VAR_9[VAR_8];
    }
  }
  VAR_9.clear();
  uint64 VAR_10;

  if (IsFiniteSize())
    VAR_10 = GetSize();
  else
    VAR_10 = 0x7FFFFFFF;

  /* COMMENT_1 */
  if (VAR_10 > 0)
  {
    VAR_0.I_O().setFilePointer(GetSizePosition() + GetSizeLength(), VAR_11);
    VAR_7 = VAR_0.FindNextElement(VAR_1, VAR_2, VAR_10, VAR_4);
    while (VAR_7 != NULL && VAR_2 <= 0 && VAR_10 > 0) {
      if (IsFiniteSize() && VAR_7->IsFiniteSize())
        VAR_10 = GetEndPosition() - VAR_7->GetEndPosition(); /* COMMENT_2 */
      if (!VAR_4 && VAR_7->IsDummy()) {
        if (VAR_7->IsFiniteSize()) {
          VAR_7->SkipData(VAR_0, VAR_1);
          delete VAR_7; /* COMMENT_3 */
        } else {
          delete VAR_7; /* COMMENT_3 */
          break;
        }
      } else {
        VAR_7->Read(VAR_0, EBML_CONTEXT(VAR_7), VAR_2, VAR_3, VAR_4, VAR_5);

        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        bool VAR_12 = true;

        if (VAR_7->ValueIsSet() || (VAR_5 != VAR_13)) {
          VAR_9.push_back(VAR_7);
          VAR_12 = false;
        }

        /* COMMENT_7 */
        if (VAR_7->IsFiniteSize()) {
          VAR_7->SkipData(VAR_0, EBML_CONTEXT(VAR_7));
          if (VAR_12)
            delete VAR_7;
        } else {
          if (VAR_12)
            delete VAR_7;

          if (VAR_2) {
            --VAR_2;
            if (VAR_2 > 0 || VAR_10 <= 0)
              goto processCrc;
            VAR_7 = VAR_3;
          }

          break;
        }
      }

      if (VAR_2 > 0) {
        VAR_2--;
        if (VAR_2 > 0 || VAR_10 <= 0)
          goto processCrc;
        VAR_7 = VAR_3;
        continue;
      }

      if (VAR_2 < 0) {
        VAR_2++;
        if (VAR_2 < 0)
          goto processCrc;
      }

      if (VAR_10 <= 0)
        goto processCrc;/* COMMENT_8 */

      VAR_7 = VAR_0.FindNextElement(VAR_1, VAR_2, VAR_10, VAR_4);
    }
    if (VAR_2 > 0) {
      VAR_3 = VAR_7;
    }
  }
processCrc:

  VAR_14 VAR_15, VAR_16;
  for (VAR_15 = VAR_9.begin(); VAR_15 != VAR_9.end();) {
    if ((VAR_17)(*(*VAR_15)) == EBML_ID(VAR_18)) {
      VAR_19 = true;
      /* COMMENT_9 */
      VAR_20 = *(VAR_21<EbmlCrc32*>(*VAR_15));
      VAR_16 = VAR_15;
      break;
    }
    ++VAR_15;
  }

  if (VAR_19)
  {
    delete *VAR_16;
    Remove(VAR_16);
  }

  SetValueIsSet();
}",Matroska-Org/libebml/88409e2a94dd3b40ff81d08bf6d92f486d036b24/EbmlMaster.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -56,6 +56,14 @@
         } else {
           if (DeleteElement)
             delete ElementLevelA;
+
+          if (UpperEltFound) {
+            --UpperEltFound;
+            if (UpperEltFound > 0 || MaxSizeToRead <= 0)
+              goto processCrc;
+            ElementLevelA = FoundElt;
+          }
+
           break;
         }
       }","{'deleted_lines': [], 'added_lines': ['', '          if (UpperEltFound) {', '            --UpperEltFound;', '            if (UpperEltFound > 0 || MaxSizeToRead <= 0)', '              goto processCrc;', '            ElementLevelA = FoundElt;', '          }', '']}",True,"Use-after-free vulnerability in the EbmlMaster::Read function in libEBML before 1.3.3 allows context-dependent attackers to have unspecified impact via a ""deeply nested element with infinite size"" followed by another element of an upper level in an EBML document.",9.6,CRITICAL,3,valid,2015-10-20T12:53:44Z,1
CVE-2015-8863,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,jqlang/jq,"Heap buffer overflow in tokenadd() (fix #105)

This was an off-by one: the NUL terminator byte was not allocated on
resize.  This was triggered by JSON-encoded numbers longer than 256
bytes.",8eb1367ca44e772963e704a700ef72ae2e12babd,https://github.com/jqlang/jq/commit/8eb1367ca44e772963e704a700ef72ae2e12babd,src/jv_parse.c,tokenadd,"static void tokenadd(struct jv_parser* p, char c) {
assert(p->tokenpos <= p->tokenlen);
if (p->tokenpos == p->tokenlen) {
p->tokenlen = p->tokenlen*2 + 256;
p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);
}
assert(p->tokenpos < p->tokenlen);
p->tokenbuf[p->tokenpos++] = c;
}","static void tokenadd(struct jv_parser* VAR_0, char VAR_1) {
assert(VAR_0->tokenpos <= VAR_0->tokenlen);
if (VAR_0->tokenpos == VAR_0->tokenlen) {
VAR_0->tokenlen = VAR_0->tokenlen*2 + 256;
VAR_0->tokenbuf = jv_mem_realloc(VAR_0->tokenbuf, VAR_0->tokenlen);
}
assert(VAR_0->tokenpos < VAR_0->tokenlen);
VAR_0->tokenbuf[VAR_0->tokenpos++] = VAR_1;
}",jqlang/jq/8eb1367ca44e772963e704a700ef72ae2e12babd/jv_parse.c/vul/before/1.json,"static void tokenadd(struct jv_parser* p, char c) {
  assert(p->tokenpos <= p->tokenlen);
  if (p->tokenpos >= (p->tokenlen - 1)) {
    p->tokenlen = p->tokenlen*2 + 256;
    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);
  }
  assert(p->tokenpos < p->tokenlen);
  p->tokenbuf[p->tokenpos++] = c;
}","static void tokenadd(struct jv_parser* VAR_0, char VAR_1) {
  assert(VAR_0->tokenpos <= VAR_0->tokenlen);
  if (VAR_0->tokenpos >= (VAR_0->tokenlen - 1)) {
    VAR_0->tokenlen = VAR_0->tokenlen*2 + 256;
    VAR_0->tokenbuf = jv_mem_realloc(VAR_0->tokenbuf, VAR_0->tokenlen);
  }
  assert(VAR_0->tokenpos < VAR_0->tokenlen);
  VAR_0->tokenbuf[VAR_0->tokenpos++] = VAR_1;
}",jqlang/jq/8eb1367ca44e772963e704a700ef72ae2e12babd/jv_parse.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void tokenadd(struct jv_parser* p, char c) {
   assert(p->tokenpos <= p->tokenlen);
-  if (p->tokenpos == p->tokenlen) {
+  if (p->tokenpos >= (p->tokenlen - 1)) {
     p->tokenlen = p->tokenlen*2 + 256;
     p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);
   }","{'deleted_lines': ['  if (p->tokenpos == p->tokenlen) {'], 'added_lines': ['  if (p->tokenpos >= (p->tokenlen - 1)) {']}",True,"Off-by-one error in the tokenadd function in jv_parse.c in jq allows remote attackers to cause a denial of service (crash) via a long JSON-encoded number, which triggers a heap-based buffer overflow.",9.8,CRITICAL,3,valid,2015-10-24T22:24:57Z,1
CVE-2015-8863,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,jqlang/jq,"Heap buffer overflow in tokenadd() (fix #105)

This was an off-by one: the NUL terminator byte was not allocated on
resize.  This was triggered by JSON-encoded numbers longer than 256
bytes.",8eb1367ca44e772963e704a700ef72ae2e12babd,https://github.com/jqlang/jq/commit/8eb1367ca44e772963e704a700ef72ae2e12babd,src/jv_parse.c,check_literal,"static pfunc check_literal(struct jv_parser* p) {
if (p->tokenpos == 0) return 0;
const char* pattern = 0;
int plen;
jv v;
switch (p->tokenbuf[0]) {
case 't': pattern = ""true""; plen = 4; v = jv_true(); break;
case 'f': pattern = ""false""; plen = 5; v = jv_false(); break;
case 'n': pattern = ""null""; plen = 4; v = jv_null(); break;
}
if (pattern) {
if (p->tokenpos != plen) return ""Invalid literal"";
for (int i=0; i<plen; i++)
if (p->tokenbuf[i] != pattern[i])
return ""Invalid literal"";
TRY(value(p, v));
} else {
p->tokenbuf[p->tokenpos] = 0;     char* end = 0;
double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);
if (end == 0 || *end != 0)
return ""Invalid numeric literal"";
TRY(value(p, jv_number(d)));
}
p->tokenpos = 0;
return 0;
}","static pfunc check_literal(struct jv_parser* VAR_0) {
if (VAR_0->tokenpos == 0) return 0;
const char* VAR_1 = 0;
int VAR_2;
jv VAR_3;
switch (VAR_0->tokenbuf[0]) {
case 't': VAR_1 = ""true""; VAR_2 = 4; VAR_3 = jv_true(); break;
case 'f': VAR_1 = ""false""; VAR_2 = 5; VAR_3 = jv_false(); break;
case 'n': VAR_1 = ""null""; VAR_2 = 4; VAR_3 = jv_null(); break;
}
if (VAR_1) {
if (VAR_0->tokenpos != VAR_2) return ""Invalid literal"";
for (int VAR_4=0; VAR_4<VAR_2; VAR_4++)
if (VAR_0->tokenbuf[VAR_4] != VAR_1[VAR_4])
return ""Invalid literal"";
TRY(value(VAR_0, VAR_3));
} else {
VAR_0->tokenbuf[VAR_0->tokenpos] = 0; 
char* VAR_5 = 0;
double VAR_6 = jvp_strtod(&VAR_0->dtoa, VAR_0->tokenbuf, &VAR_5);
if (VAR_5 == 0 || *VAR_5 != 0)
return ""Invalid numeric literal"";
TRY(value(VAR_0, jv_number(VAR_6)));
}
VAR_0->tokenpos = 0;
return 0;
}",jqlang/jq/8eb1367ca44e772963e704a700ef72ae2e12babd/jv_parse.c/vul/before/0.json,"static pfunc check_literal(struct jv_parser* p) {
  if (p->tokenpos == 0) return 0;

  const char* pattern = 0;
  int plen;
  jv v;
  switch (p->tokenbuf[0]) {
  case 't': pattern = ""true""; plen = 4; v = jv_true(); break;
  case 'f': pattern = ""false""; plen = 5; v = jv_false(); break;
  case 'n': pattern = ""null""; plen = 4; v = jv_null(); break;
  }
  if (pattern) {
    if (p->tokenpos != plen) return ""Invalid literal"";
    for (int i=0; i<plen; i++)
      if (p->tokenbuf[i] != pattern[i])
        return ""Invalid literal"";
    TRY(value(p, v));
  } else {
    // FIXME: better parser
    p->tokenbuf[p->tokenpos] = 0;
    char* end = 0;
    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);
    if (end == 0 || *end != 0)
      return ""Invalid numeric literal"";
    TRY(value(p, jv_number(d)));
  }
  p->tokenpos = 0;
  return 0;
}","static pfunc check_literal(struct jv_parser* VAR_0) {
  if (VAR_0->tokenpos == 0) return 0;

  const char* VAR_1 = 0;
  int VAR_2;
  jv VAR_3;
  switch (VAR_0->tokenbuf[0]) {
  case 't': VAR_1 = ""true""; VAR_2 = 4; VAR_3 = jv_true(); break;
  case 'f': VAR_1 = ""false""; VAR_2 = 5; VAR_3 = jv_false(); break;
  case 'n': VAR_1 = ""null""; VAR_2 = 4; VAR_3 = jv_null(); break;
  }
  if (VAR_1) {
    if (VAR_0->tokenpos != VAR_2) return ""Invalid literal"";
    for (int VAR_4=0; VAR_4<VAR_2; VAR_4++)
      if (VAR_0->tokenbuf[VAR_4] != VAR_1[VAR_4])
        return ""Invalid literal"";
    TRY(value(VAR_0, VAR_3));
  } else {
    /* COMMENT_0 */
    VAR_0->tokenbuf[VAR_0->tokenpos] = 0;
    char* VAR_5 = 0;
    double VAR_6 = jvp_strtod(&VAR_0->dtoa, VAR_0->tokenbuf, &VAR_5);
    if (VAR_5 == 0 || *VAR_5 != 0)
      return ""Invalid numeric literal"";
    TRY(value(VAR_0, jv_number(VAR_6)));
  }
  VAR_0->tokenpos = 0;
  return 0;
}",jqlang/jq/8eb1367ca44e772963e704a700ef72ae2e12babd/jv_parse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
     TRY(value(p, v));
   } else {
     // FIXME: better parser
-    p->tokenbuf[p->tokenpos] = 0; // FIXME: invalid
+    p->tokenbuf[p->tokenpos] = 0;
     char* end = 0;
     double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);
     if (end == 0 || *end != 0)","{'deleted_lines': ['    p->tokenbuf[p->tokenpos] = 0; // FIXME: invalid'], 'added_lines': ['    p->tokenbuf[p->tokenpos] = 0;']}",True,"Off-by-one error in the tokenadd function in jv_parse.c in jq allows remote attackers to cause a denial of service (crash) via a long JSON-encoded number, which triggers a heap-based buffer overflow.",9.8,CRITICAL,3,valid,2015-10-24T22:24:57Z,1
CVE-2015-8962,['CWE-415'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"sg: Fix double-free when drives detach during SG_IO

In sg_common_write(), we free the block request and return -ENODEV if
the device is detached in the middle of the SG_IO ioctl().

Unfortunately, sg_finish_rem_req() also tries to free srp->rq, so we
end up freeing rq->cmd in the already free rq object, and then free
the object itself out from under the current user.

This ends up corrupting random memory via the list_head on the rq
object. The most common crash trace I saw is this:

  ------------[ cut here ]------------
  kernel BUG at block/blk-core.c:1420!
  Call Trace:
  [<ffffffff81281eab>] blk_put_request+0x5b/0x80
  [<ffffffffa0069e5b>] sg_finish_rem_req+0x6b/0x120 [sg]
  [<ffffffffa006bcb9>] sg_common_write.isra.14+0x459/0x5a0 [sg]
  [<ffffffff8125b328>] ? selinux_file_alloc_security+0x48/0x70
  [<ffffffffa006bf95>] sg_new_write.isra.17+0x195/0x2d0 [sg]
  [<ffffffffa006cef4>] sg_ioctl+0x644/0xdb0 [sg]
  [<ffffffff81170f80>] do_vfs_ioctl+0x90/0x520
  [<ffffffff81258967>] ? file_has_perm+0x97/0xb0
  [<ffffffff811714a1>] SyS_ioctl+0x91/0xb0
  [<ffffffff81602afb>] tracesys+0xdd/0xe2
    RIP [<ffffffff81281e04>] __blk_put_request+0x154/0x1a0

The solution is straightforward: just set srp->rq to NULL in the
failure branch so that sg_finish_rem_req() doesn't attempt to re-free
it.

Additionally, since sg_rq_end_io() will never be called on the object
when this happens, we need to free memory backing ->cmd if it isn't
embedded in the object itself.

KASAN was extremely helpful in finding the root cause of this bug.

Signed-off-by: Calvin Owens <calvinowens@fb.com>
Acked-by: Douglas Gilbert <dgilbert@interlog.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>",f3951a3709ff50990bf3e188c27d346792103432,https://github.com/torvalds/linux/commit/f3951a3709ff50990bf3e188c27d346792103432,drivers/scsi/sg.c,sg_common_write,"static int
sg_common_write(Sg_fd * sfp, Sg_request * srp,
unsigned char *cmnd, int timeout, int blocking)
{
int k, at_head;
Sg_device *sdp = sfp->parentdp;
sg_io_hdr_t *hp = &srp->header;
srp->data.cmd_opcode = cmnd[0];
hp->status = 0;
hp->masked_status = 0;
hp->msg_status = 0;
hp->info = 0;
hp->host_status = 0;
hp->driver_status = 0;
hp->resid = 0;
SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,
""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
(int) cmnd[0], (int) hp->cmd_len));
k = sg_start_req(srp, cmnd);
if (k) {
SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,
""sg_common_write: start_req err=%d\n"", k));
sg_finish_rem_req(srp);
return k;
}
if (atomic_read(&sdp->detaching)) {
if (srp->bio)
blk_end_request_all(srp->rq, -EIO);
sg_finish_rem_req(srp);
return -ENODEV;
}
hp->duration = jiffies_to_msecs(jiffies);
if (hp->interface_id != '\0' &&
(SG_FLAG_Q_AT_TAIL & hp->flags))
at_head = 0;
else
at_head = 1;
srp->rq->timeout = timeout;
kref_get(&sfp->f_ref); 
blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,
srp->rq, at_head, sg_rq_end_io);
return 0;
}","static int
sg_common_write(Sg_fd * VAR_0, Sg_request * VAR_1,
unsigned char *VAR_2, int VAR_3, int VAR_4)
{
int VAR_5, VAR_6;
Sg_device *VAR_7 = VAR_0->parentdp;
sg_io_hdr_t *VAR_8 = &VAR_1->header;
VAR_1->data.cmd_opcode = VAR_2[0];
VAR_8->status = 0;
VAR_8->masked_status = 0;
VAR_8->msg_status = 0;
VAR_8->info = 0;
VAR_8->host_status = 0;
VAR_8->driver_status = 0;
VAR_8->resid = 0;
SCSI_LOG_TIMEOUT(4, sg_printk(VAR_9, VAR_0->parentdp,
""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
(int) VAR_2[0], (int) VAR_8->cmd_len));
VAR_5 = sg_start_req(VAR_1, VAR_2);
if (VAR_5) {
SCSI_LOG_TIMEOUT(1, sg_printk(VAR_9, VAR_0->parentdp,
""sg_common_write: start_req err=%d\n"", VAR_5));
sg_finish_rem_req(VAR_1);
return VAR_5;
}
if (atomic_read(&VAR_7->detaching)) {
if (VAR_1->bio)
blk_end_request_all(VAR_1->rq, -VAR_10);
sg_finish_rem_req(VAR_1);
return -VAR_11;
}
VAR_8->duration = jiffies_to_msecs(VAR_12);
if (VAR_8->interface_id != '\0' &&
(VAR_13 & VAR_8->flags))
VAR_6 = 0;
else
VAR_6 = 1;
VAR_1->rq->timeout = VAR_3;
kref_get(&VAR_0->f_ref); 
blk_execute_rq_nowait(VAR_7->device->request_queue, VAR_7->disk,
VAR_1->rq, VAR_6, VAR_14);
return 0;
}",torvalds/linux/f3951a3709ff50990bf3e188c27d346792103432/sg.c/vul/before/0.json,"static int
sg_common_write(Sg_fd * sfp, Sg_request * srp,
		unsigned char *cmnd, int timeout, int blocking)
{
	int k, at_head;
	Sg_device *sdp = sfp->parentdp;
	sg_io_hdr_t *hp = &srp->header;

	srp->data.cmd_opcode = cmnd[0];	/* hold opcode of command */
	hp->status = 0;
	hp->masked_status = 0;
	hp->msg_status = 0;
	hp->info = 0;
	hp->host_status = 0;
	hp->driver_status = 0;
	hp->resid = 0;
	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
			(int) cmnd[0], (int) hp->cmd_len));

	k = sg_start_req(srp, cmnd);
	if (k) {
		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,
			""sg_common_write: start_req err=%d\n"", k));
		sg_finish_rem_req(srp);
		return k;	/* probably out of space --> ENOMEM */
	}
	if (atomic_read(&sdp->detaching)) {
		if (srp->bio) {
			if (srp->rq->cmd != srp->rq->__cmd)
				kfree(srp->rq->cmd);

			blk_end_request_all(srp->rq, -EIO);
			srp->rq = NULL;
		}

		sg_finish_rem_req(srp);
		return -ENODEV;
	}

	hp->duration = jiffies_to_msecs(jiffies);
	if (hp->interface_id != '\0' &&	/* v3 (or later) interface */
	    (SG_FLAG_Q_AT_TAIL & hp->flags))
		at_head = 0;
	else
		at_head = 1;

	srp->rq->timeout = timeout;
	kref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */
	blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,
			      srp->rq, at_head, sg_rq_end_io);
	return 0;
}","static int
sg_common_write(Sg_fd * VAR_0, Sg_request * VAR_1,
		unsigned char *VAR_2, int VAR_3, int VAR_4)
{
	int VAR_5, VAR_6;
	Sg_device *VAR_7 = VAR_0->parentdp;
	sg_io_hdr_t *VAR_8 = &VAR_1->header;

	VAR_1->data.cmd_opcode = VAR_2[0];	/* COMMENT_0 */
	VAR_8->status = 0;
	VAR_8->masked_status = 0;
	VAR_8->msg_status = 0;
	VAR_8->info = 0;
	VAR_8->host_status = 0;
	VAR_8->driver_status = 0;
	VAR_8->resid = 0;
	SCSI_LOG_TIMEOUT(4, sg_printk(VAR_9, VAR_0->parentdp,
			""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
			(int) VAR_2[0], (int) VAR_8->cmd_len));

	VAR_5 = sg_start_req(VAR_1, VAR_2);
	if (VAR_5) {
		SCSI_LOG_TIMEOUT(1, sg_printk(VAR_9, VAR_0->parentdp,
			""sg_common_write: start_req err=%d\n"", VAR_5));
		sg_finish_rem_req(VAR_1);
		return VAR_5;	/* COMMENT_1 */
	}
	if (atomic_read(&VAR_7->detaching)) {
		if (VAR_1->bio) {
			if (VAR_1->rq->cmd != VAR_1->rq->__cmd)
				kfree(VAR_1->rq->cmd);

			blk_end_request_all(VAR_1->rq, -VAR_10);
			VAR_1->rq = NULL;
		}

		sg_finish_rem_req(VAR_1);
		return -VAR_11;
	}

	VAR_8->duration = jiffies_to_msecs(VAR_12);
	if (VAR_8->interface_id != '\0' &&	/* COMMENT_2 */
	    (VAR_13 & VAR_8->flags))
		VAR_6 = 0;
	else
		VAR_6 = 1;

	VAR_1->rq->timeout = VAR_3;
	kref_get(&VAR_0->f_ref); /* COMMENT_3 */
	blk_execute_rq_nowait(VAR_7->device->request_queue, VAR_7->disk,
			      VAR_1->rq, VAR_6, VAR_14);
	return 0;
}",torvalds/linux/f3951a3709ff50990bf3e188c27d346792103432/sg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,8 +26,14 @@
 		return k;	/* probably out of space --> ENOMEM */
 	}
 	if (atomic_read(&sdp->detaching)) {
-		if (srp->bio)
+		if (srp->bio) {
+			if (srp->rq->cmd != srp->rq->__cmd)
+				kfree(srp->rq->cmd);
+
 			blk_end_request_all(srp->rq, -EIO);
+			srp->rq = NULL;
+		}
+
 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}","{'deleted_lines': ['\t\tif (srp->bio)'], 'added_lines': ['\t\tif (srp->bio) {', '\t\t\tif (srp->rq->cmd != srp->rq->__cmd)', '\t\t\t\tkfree(srp->rq->cmd);', '', '\t\t\tsrp->rq = NULL;', '\t\t}', '']}",True,Double free vulnerability in the sg_common_write function in drivers/scsi/sg.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (memory corruption and system crash) by detaching a device during an SG_IO ioctl call.,7.3,HIGH,2,valid,2015-10-30T23:57:00Z,1
CVE-2015-7513,['CWE-369'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"KVM: x86: Reload pit counters for all channels when restoring state

Currently if userspace restores the pit counters with a count of 0
on channels 1 or 2 and the guest attempts to read the count on those
channels, then KVM will perform a mod of 0 and crash.  This will ensure
that 0 values are converted to 65536 as per the spec.

This is CVE-2015-7513.

Signed-off-by: Andy Honig <ahonig@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",0185604c2d82c560dab2f2933a18f797e74ab5a8,https://github.com/torvalds/linux/commit/0185604c2d82c560dab2f2933a18f797e74ab5a8,arch/x86/kvm/x86.c,kvm_vm_ioctl_set_pit,"static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
mutex_lock(&kvm->arch.vpit->pit_state.lock);
memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));
kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);
mutex_unlock(&kvm->arch.vpit->pit_state.lock);
return 0;
}","static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *VAR_0)
{
mutex_lock(&kvm->arch.vpit->pit_state.lock);
memcpy(&kvm->arch.vpit->pit_state, VAR_0, sizeof(struct kvm_pit_state));
kvm_pit_load_count(kvm, 0, VAR_0->channels[0].count, 0);
mutex_unlock(&kvm->arch.vpit->pit_state.lock);
return 0;
}",torvalds/linux/0185604c2d82c560dab2f2933a18f797e74ab5a8/x86.c/vul/before/0.json,"static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
{
	int i;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));
	for (i = 0; i < 3; i++)
		kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}","static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *VAR_0)
{
	int VAR_1;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	memcpy(&kvm->arch.vpit->pit_state, VAR_0, sizeof(struct kvm_pit_state));
	for (VAR_1 = 0; VAR_1 < 3; VAR_1++)
		kvm_pit_load_count(kvm, VAR_1, VAR_0->channels[VAR_1].count, 0);
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}",torvalds/linux/0185604c2d82c560dab2f2933a18f797e74ab5a8/x86.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,10 @@
 static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 {
+	int i;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));
-	kvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);
+	for (i = 0; i < 3; i++)
+		kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }","{'deleted_lines': ['\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);'], 'added_lines': ['\tint i;', '\tfor (i = 0; i < 3; i++)', '\t\tkvm_pit_load_count(kvm, i, ps->channels[i].count, 0);']}",True,"arch/x86/kvm/x86.c in the Linux kernel before 4.4 does not reset the PIT counter values during state restoration, which allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via a zero value, related to the kvm_vm_ioctl_set_pit and kvm_vm_ioctl_set_pit2 functions.",6.5,MEDIUM,1,valid,2015-11-18T22:50:23Z,1
CVE-2015-7513,['CWE-369'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"KVM: x86: Reload pit counters for all channels when restoring state

Currently if userspace restores the pit counters with a count of 0
on channels 1 or 2 and the guest attempts to read the count on those
channels, then KVM will perform a mod of 0 and crash.  This will ensure
that 0 values are converted to 65536 as per the spec.

This is CVE-2015-7513.

Signed-off-by: Andy Honig <ahonig@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",0185604c2d82c560dab2f2933a18f797e74ab5a8,https://github.com/torvalds/linux/commit/0185604c2d82c560dab2f2933a18f797e74ab5a8,arch/x86/kvm/x86.c,kvm_vm_ioctl_set_pit2,"static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
int start = 0;
u32 prev_legacy, cur_legacy;
mutex_lock(&kvm->arch.vpit->pit_state.lock);
prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
if (!prev_legacy && cur_legacy)
start = 1;
memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
sizeof(kvm->arch.vpit->pit_state.channels));
kvm->arch.vpit->pit_state.flags = ps->flags;
kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
mutex_unlock(&kvm->arch.vpit->pit_state.lock);
return 0;
}","static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *VAR_0)
{
int VAR_1 = 0;
u32 VAR_2, VAR_3;
mutex_lock(&kvm->arch.vpit->pit_state.lock);
VAR_2 = kvm->arch.vpit->pit_state.flags & VAR_4;
VAR_3 = VAR_0->flags & VAR_4;
if (!VAR_2 && VAR_3)
VAR_1 = 1;
memcpy(&kvm->arch.vpit->pit_state.channels, &VAR_0->channels,
sizeof(kvm->arch.vpit->pit_state.channels));
kvm->arch.vpit->pit_state.flags = VAR_0->flags;
kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, VAR_1);
mutex_unlock(&kvm->arch.vpit->pit_state.lock);
return 0;
}",torvalds/linux/0185604c2d82c560dab2f2933a18f797e74ab5a8/x86.c/vul/before/1.json,"static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
	int start = 0;
	int i;
	u32 prev_legacy, cur_legacy;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && cur_legacy)
		start = 1;
	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
	       sizeof(kvm->arch.vpit->pit_state.channels));
	kvm->arch.vpit->pit_state.flags = ps->flags;
	for (i = 0; i < 3; i++)
		kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}","static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *VAR_0)
{
	int VAR_1 = 0;
	int VAR_2;
	u32 VAR_3, VAR_4;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	VAR_3 = kvm->arch.vpit->pit_state.flags & VAR_5;
	VAR_4 = VAR_0->flags & VAR_5;
	if (!VAR_3 && VAR_4)
		VAR_1 = 1;
	memcpy(&kvm->arch.vpit->pit_state.channels, &VAR_0->channels,
	       sizeof(kvm->arch.vpit->pit_state.channels));
	kvm->arch.vpit->pit_state.flags = VAR_0->flags;
	for (VAR_2 = 0; VAR_2 < 3; VAR_2++)
		kvm_pit_load_count(kvm, VAR_2, kvm->arch.vpit->pit_state.channels[VAR_2].count, VAR_1);
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}",torvalds/linux/0185604c2d82c560dab2f2933a18f797e74ab5a8/x86.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
+	int i;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
@@ -10,7 +11,8 @@
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
-	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
+	for (i = 0; i < 3; i++)
+		kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }","{'deleted_lines': ['\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);'], 'added_lines': ['\tint i;', '\tfor (i = 0; i < 3; i++)', '\t\tkvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);']}",True,"arch/x86/kvm/x86.c in the Linux kernel before 4.4 does not reset the PIT counter values during state restoration, which allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via a zero value, related to the kvm_vm_ioctl_set_pit and kvm_vm_ioctl_set_pit2 functions.",6.5,MEDIUM,1,valid,2015-11-18T22:50:23Z,1
CVE-2015-7510,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,systemd,"nss-mymachines: do not allow overlong machine names

https://github.com/systemd/systemd/issues/2002",cb31827d62066a04b02111df3052949fda4b6888,https://github.com/systemd/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888,src/nss-mymachines/nss-mymachines.c,_nss_mymachines_getpwnam_r,"enum nss_status _nss_mymachines_getpwnam_r(
const char *name,
struct passwd *pwd,
char *buffer, size_t buflen,
int *errnop) {
_cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;
_cleanup_bus_message_unref_ sd_bus_message* reply = NULL;
_cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;
const char *p, *e, *machine;
uint32_t mapped;
uid_t uid;
size_t l;
int r;
assert(name);
assert(pwd);
p = startswith(name, ""vu-"");
if (!p)
goto not_found;
e = strrchr(p, '-');
if (!e || e == p)
goto not_found;
r = parse_uid(e + 1, &uid);
if (r < 0)
goto not_found;
machine = strndupa(p, e - p);
if (!machine_name_is_valid(machine))
goto not_found;
r = sd_bus_open_system(&bus);
if (r < 0)
goto fail;
r = sd_bus_call_method(bus,
""org.freedesktop.machine1"",
""/org/freedesktop/machine1"",
""org.freedesktop.machine1.Manager"",
""MapFromMachineUser"",
&error,
&reply,
""su"",
machine, (uint32_t) uid);
if (r < 0) {
if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))
goto not_found;
goto fail;
}
r = sd_bus_message_read(reply, ""u"", &mapped);
if (r < 0)
goto fail;
l = strlen(name);
if (buflen < l+1) {
*errnop = ENOMEM;
return NSS_STATUS_TRYAGAIN;
}
memcpy(buffer, name, l+1);
pwd->pw_name = buffer;
pwd->pw_uid = mapped;
pwd->pw_gid = 65534; 
pwd->pw_gecos = buffer;
pwd->pw_passwd = (char*) ""*""; 
pwd->pw_dir = (char*) ""/"";
pwd->pw_shell = (char*) ""/sbin/nologin"";
*errnop = 0;
return NSS_STATUS_SUCCESS;
not_found:
*errnop = 0;
return NSS_STATUS_NOTFOUND;
fail:
*errnop = -r;
return NSS_STATUS_UNAVAIL;
}","enum nss_status _nss_mymachines_getpwnam_r(
const char *VAR_0,
struct passwd *VAR_1,
char *VAR_2, size_t VAR_3,
int *VAR_4) {
_cleanup_bus_error_free_ VAR_5 VAR_6 = VAR_7;
_cleanup_bus_message_unref_ VAR_8* VAR_9 = NULL;
_cleanup_bus_flush_close_unref_ VAR_10 *VAR_11 = NULL;
const char *VAR_12, *VAR_13, *VAR_14;
uint32_t VAR_15;
uid_t VAR_16;
size_t VAR_17;
int VAR_18;
assert(VAR_0);
assert(VAR_1);
VAR_12 = startswith(VAR_0, ""vu-"");
if (!VAR_12)
goto not_found;
VAR_13 = strrchr(VAR_12, '-');
if (!VAR_13 || VAR_13 == VAR_12)
goto not_found;
VAR_18 = parse_uid(VAR_13 + 1, &VAR_16);
if (VAR_18 < 0)
goto not_found;
VAR_14 = strndupa(VAR_12, VAR_13 - VAR_12);
if (!machine_name_is_valid(VAR_14))
goto not_found;
VAR_18 = sd_bus_open_system(&VAR_11);
if (VAR_18 < 0)
goto fail;
VAR_18 = sd_bus_call_method(VAR_11,
""org.freedesktop.machine1"",
""/org/freedesktop/machine1"",
""org.freedesktop.machine1.Manager"",
""MapFromMachineUser"",
&VAR_6,
&VAR_9,
""su"",
VAR_14, (uint32_t) VAR_16);
if (VAR_18 < 0) {
if (sd_bus_error_has_name(&VAR_6, VAR_19))
goto not_found;
goto fail;
}
VAR_18 = sd_bus_message_read(VAR_9, ""u"", &VAR_15);
if (VAR_18 < 0)
goto fail;
VAR_17 = strlen(VAR_0);
if (VAR_3 < VAR_17+1) {
*VAR_4 = VAR_20;
return VAR_21;
}
memcpy(VAR_2, VAR_0, VAR_17+1);
VAR_1->pw_name = VAR_2;
VAR_1->pw_uid = VAR_15;
VAR_1->pw_gid = 65534; 
VAR_1->pw_gecos = VAR_2;
VAR_1->pw_passwd = (char*) ""*""; 
VAR_1->pw_dir = (char*) ""/"";
VAR_1->pw_shell = (char*) ""/sbin/nologin"";
*VAR_4 = 0;
return VAR_22;
not_found:
*VAR_4 = 0;
return VAR_23;
fail:
*VAR_4 = -VAR_18;
return VAR_24;
}",systemd/cb31827d62066a04b02111df3052949fda4b6888/nss-mymachines.c/vul/before/1.json,"enum nss_status _nss_mymachines_getpwnam_r(
                const char *name,
                struct passwd *pwd,
                char *buffer, size_t buflen,
                int *errnop) {

        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;
        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;
        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;
        const char *p, *e, *machine;
        uint32_t mapped;
        uid_t uid;
        size_t l;
        int r;

        assert(name);
        assert(pwd);

        p = startswith(name, ""vu-"");
        if (!p)
                goto not_found;

        e = strrchr(p, '-');
        if (!e || e == p)
                goto not_found;

        if (e - p > HOST_NAME_MAX - 1) /* -1 for the last dash */
                goto not_found;

        r = parse_uid(e + 1, &uid);
        if (r < 0)
                goto not_found;

        machine = strndupa(p, e - p);
        if (!machine_name_is_valid(machine))
                goto not_found;

        r = sd_bus_open_system(&bus);
        if (r < 0)
                goto fail;

        r = sd_bus_call_method(bus,
                               ""org.freedesktop.machine1"",
                               ""/org/freedesktop/machine1"",
                               ""org.freedesktop.machine1.Manager"",
                               ""MapFromMachineUser"",
                               &error,
                               &reply,
                               ""su"",
                               machine, (uint32_t) uid);
        if (r < 0) {
                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))
                        goto not_found;

                goto fail;
        }

        r = sd_bus_message_read(reply, ""u"", &mapped);
        if (r < 0)
                goto fail;

        l = strlen(name);
        if (buflen < l+1) {
                *errnop = ENOMEM;
                return NSS_STATUS_TRYAGAIN;
        }

        memcpy(buffer, name, l+1);

        pwd->pw_name = buffer;
        pwd->pw_uid = mapped;
        pwd->pw_gid = 65534; /* nobody */
        pwd->pw_gecos = buffer;
        pwd->pw_passwd = (char*) ""*""; /* locked */
        pwd->pw_dir = (char*) ""/"";
        pwd->pw_shell = (char*) ""/sbin/nologin"";

        *errnop = 0;
        return NSS_STATUS_SUCCESS;

not_found:
        *errnop = 0;
        return NSS_STATUS_NOTFOUND;

fail:
        *errnop = -r;
        return NSS_STATUS_UNAVAIL;
}","enum nss_status _nss_mymachines_getpwnam_r(
                const char *VAR_0,
                struct passwd *VAR_1,
                char *VAR_2, size_t VAR_3,
                int *VAR_4) {

        _cleanup_bus_error_free_ VAR_5 VAR_6 = VAR_7;
        _cleanup_bus_message_unref_ VAR_8* VAR_9 = NULL;
        _cleanup_bus_flush_close_unref_ VAR_10 *VAR_11 = NULL;
        const char *VAR_12, *VAR_13, *VAR_14;
        uint32_t VAR_15;
        uid_t VAR_16;
        size_t VAR_17;
        int VAR_18;

        assert(VAR_0);
        assert(VAR_1);

        VAR_12 = startswith(VAR_0, ""vu-"");
        if (!VAR_12)
                goto not_found;

        VAR_13 = strrchr(VAR_12, '-');
        if (!VAR_13 || VAR_13 == VAR_12)
                goto not_found;

        if (VAR_13 - VAR_12 > VAR_19 - 1) /* COMMENT_0 */
                goto not_found;

        VAR_18 = parse_uid(VAR_13 + 1, &VAR_16);
        if (VAR_18 < 0)
                goto not_found;

        VAR_14 = strndupa(VAR_12, VAR_13 - VAR_12);
        if (!machine_name_is_valid(VAR_14))
                goto not_found;

        VAR_18 = sd_bus_open_system(&VAR_11);
        if (VAR_18 < 0)
                goto fail;

        VAR_18 = sd_bus_call_method(VAR_11,
                               ""org.freedesktop.machine1"",
                               ""/org/freedesktop/machine1"",
                               ""org.freedesktop.machine1.Manager"",
                               ""MapFromMachineUser"",
                               &VAR_6,
                               &VAR_9,
                               ""su"",
                               VAR_14, (uint32_t) VAR_16);
        if (VAR_18 < 0) {
                if (sd_bus_error_has_name(&VAR_6, VAR_20))
                        goto not_found;

                goto fail;
        }

        VAR_18 = sd_bus_message_read(VAR_9, ""u"", &VAR_15);
        if (VAR_18 < 0)
                goto fail;

        VAR_17 = strlen(VAR_0);
        if (VAR_3 < VAR_17+1) {
                *VAR_4 = VAR_21;
                return VAR_22;
        }

        memcpy(VAR_2, VAR_0, VAR_17+1);

        VAR_1->pw_name = VAR_2;
        VAR_1->pw_uid = VAR_15;
        VAR_1->pw_gid = 65534; /* COMMENT_1 */
        VAR_1->pw_gecos = VAR_2;
        VAR_1->pw_passwd = (char*) ""*""; /* COMMENT_2 */
        VAR_1->pw_dir = (char*) ""/"";
        VAR_1->pw_shell = (char*) ""/sbin/nologin"";

        *VAR_4 = 0;
        return VAR_23;

not_found:
        *VAR_4 = 0;
        return VAR_24;

fail:
        *VAR_4 = -VAR_18;
        return VAR_25;
}",systemd/cb31827d62066a04b02111df3052949fda4b6888/nss-mymachines.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,6 +22,9 @@
 
         e = strrchr(p, '-');
         if (!e || e == p)
+                goto not_found;
+
+        if (e - p > HOST_NAME_MAX - 1) /* -1 for the last dash */
                 goto not_found;
 
         r = parse_uid(e + 1, &uid);","{'deleted_lines': [], 'added_lines': ['                goto not_found;', '', '        if (e - p > HOST_NAME_MAX - 1) /* -1 for the last dash */']}",True,Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd.,9.8,CRITICAL,3,valid,2015-11-23T18:59:43Z,1
CVE-2015-7510,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,systemd,"nss-mymachines: do not allow overlong machine names

https://github.com/systemd/systemd/issues/2002",cb31827d62066a04b02111df3052949fda4b6888,https://github.com/systemd/systemd/commit/cb31827d62066a04b02111df3052949fda4b6888,src/nss-mymachines/nss-mymachines.c,_nss_mymachines_getgrnam_r,"enum nss_status _nss_mymachines_getgrnam_r(
const char *name,
struct group *gr,
char *buffer, size_t buflen,
int *errnop) {
_cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;
_cleanup_bus_message_unref_ sd_bus_message* reply = NULL;
_cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;
const char *p, *e, *machine;
uint32_t mapped;
uid_t gid;
size_t l;
int r;
assert(name);
assert(gr);
p = startswith(name, ""vg-"");
if (!p)
goto not_found;
e = strrchr(p, '-');
if (!e || e == p)
goto not_found;
r = parse_gid(e + 1, &gid);
if (r < 0)
goto not_found;
machine = strndupa(p, e - p);
if (!machine_name_is_valid(machine))
goto not_found;
r = sd_bus_open_system(&bus);
if (r < 0)
goto fail;
r = sd_bus_call_method(bus,
""org.freedesktop.machine1"",
""/org/freedesktop/machine1"",
""org.freedesktop.machine1.Manager"",
""MapFromMachineGroup"",
&error,
&reply,
""su"",
machine, (uint32_t) gid);
if (r < 0) {
if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))
goto not_found;
goto fail;
}
r = sd_bus_message_read(reply, ""u"", &mapped);
if (r < 0)
goto fail;
l = sizeof(char*) + strlen(name) + 1;
if (buflen < l) {
*errnop = ENOMEM;
return NSS_STATUS_TRYAGAIN;
}
memzero(buffer, sizeof(char*));
strcpy(buffer + sizeof(char*), name);
gr->gr_name = buffer + sizeof(char*);
gr->gr_gid = gid;
gr->gr_passwd = (char*) ""*""; 
gr->gr_mem = (char**) buffer;
*errnop = 0;
return NSS_STATUS_SUCCESS;
not_found:
*errnop = 0;
return NSS_STATUS_NOTFOUND;
fail:
*errnop = -r;
return NSS_STATUS_UNAVAIL;
}","enum nss_status _nss_mymachines_getgrnam_r(
const char *VAR_0,
struct group *VAR_1,
char *VAR_2, size_t VAR_3,
int *VAR_4) {
_cleanup_bus_error_free_ VAR_5 VAR_6 = VAR_7;
_cleanup_bus_message_unref_ VAR_8* VAR_9 = NULL;
_cleanup_bus_flush_close_unref_ VAR_10 *VAR_11 = NULL;
const char *VAR_12, *VAR_13, *VAR_14;
uint32_t VAR_15;
uid_t VAR_16;
size_t VAR_17;
int VAR_18;
assert(VAR_0);
assert(VAR_1);
VAR_12 = startswith(VAR_0, ""vg-"");
if (!VAR_12)
goto not_found;
VAR_13 = strrchr(VAR_12, '-');
if (!VAR_13 || VAR_13 == VAR_12)
goto not_found;
VAR_18 = parse_gid(VAR_13 + 1, &VAR_16);
if (VAR_18 < 0)
goto not_found;
VAR_14 = strndupa(VAR_12, VAR_13 - VAR_12);
if (!machine_name_is_valid(VAR_14))
goto not_found;
VAR_18 = sd_bus_open_system(&VAR_11);
if (VAR_18 < 0)
goto fail;
VAR_18 = sd_bus_call_method(VAR_11,
""org.freedesktop.machine1"",
""/org/freedesktop/machine1"",
""org.freedesktop.machine1.Manager"",
""MapFromMachineGroup"",
&VAR_6,
&VAR_9,
""su"",
VAR_14, (uint32_t) VAR_16);
if (VAR_18 < 0) {
if (sd_bus_error_has_name(&VAR_6, VAR_19))
goto not_found;
goto fail;
}
VAR_18 = sd_bus_message_read(VAR_9, ""u"", &VAR_15);
if (VAR_18 < 0)
goto fail;
VAR_17 = sizeof(char*) + strlen(VAR_0) + 1;
if (VAR_3 < VAR_17) {
*VAR_4 = VAR_20;
return VAR_21;
}
memzero(VAR_2, sizeof(char*));
strcpy(VAR_2 + sizeof(char*), VAR_0);
VAR_1->gr_name = VAR_2 + sizeof(char*);
VAR_1->gr_gid = VAR_16;
VAR_1->gr_passwd = (char*) ""*""; 
VAR_1->gr_mem = (char**) VAR_2;
*VAR_4 = 0;
return VAR_22;
not_found:
*VAR_4 = 0;
return VAR_23;
fail:
*VAR_4 = -VAR_18;
return VAR_24;
}",systemd/cb31827d62066a04b02111df3052949fda4b6888/nss-mymachines.c/vul/before/0.json,"enum nss_status _nss_mymachines_getgrnam_r(
                const char *name,
                struct group *gr,
                char *buffer, size_t buflen,
                int *errnop) {

        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;
        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;
        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;
        const char *p, *e, *machine;
        uint32_t mapped;
        uid_t gid;
        size_t l;
        int r;

        assert(name);
        assert(gr);

        p = startswith(name, ""vg-"");
        if (!p)
                goto not_found;

        e = strrchr(p, '-');
        if (!e || e == p)
                goto not_found;

        if (e - p > HOST_NAME_MAX - 1)  /* -1 for the last dash */
                goto not_found;

        r = parse_gid(e + 1, &gid);
        if (r < 0)
                goto not_found;

        machine = strndupa(p, e - p);
        if (!machine_name_is_valid(machine))
                goto not_found;

        r = sd_bus_open_system(&bus);
        if (r < 0)
                goto fail;

        r = sd_bus_call_method(bus,
                               ""org.freedesktop.machine1"",
                               ""/org/freedesktop/machine1"",
                               ""org.freedesktop.machine1.Manager"",
                               ""MapFromMachineGroup"",
                               &error,
                               &reply,
                               ""su"",
                               machine, (uint32_t) gid);
        if (r < 0) {
                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))
                        goto not_found;

                goto fail;
        }

        r = sd_bus_message_read(reply, ""u"", &mapped);
        if (r < 0)
                goto fail;

        l = sizeof(char*) + strlen(name) + 1;
        if (buflen < l) {
                *errnop = ENOMEM;
                return NSS_STATUS_TRYAGAIN;
        }

        memzero(buffer, sizeof(char*));
        strcpy(buffer + sizeof(char*), name);

        gr->gr_name = buffer + sizeof(char*);
        gr->gr_gid = gid;
        gr->gr_passwd = (char*) ""*""; /* locked */
        gr->gr_mem = (char**) buffer;

        *errnop = 0;
        return NSS_STATUS_SUCCESS;

not_found:
        *errnop = 0;
        return NSS_STATUS_NOTFOUND;

fail:
        *errnop = -r;
        return NSS_STATUS_UNAVAIL;
}","enum nss_status _nss_mymachines_getgrnam_r(
                const char *VAR_0,
                struct group *VAR_1,
                char *VAR_2, size_t VAR_3,
                int *VAR_4) {

        _cleanup_bus_error_free_ VAR_5 VAR_6 = VAR_7;
        _cleanup_bus_message_unref_ VAR_8* VAR_9 = NULL;
        _cleanup_bus_flush_close_unref_ VAR_10 *VAR_11 = NULL;
        const char *VAR_12, *VAR_13, *VAR_14;
        uint32_t VAR_15;
        uid_t VAR_16;
        size_t VAR_17;
        int VAR_18;

        assert(VAR_0);
        assert(VAR_1);

        VAR_12 = startswith(VAR_0, ""vg-"");
        if (!VAR_12)
                goto not_found;

        VAR_13 = strrchr(VAR_12, '-');
        if (!VAR_13 || VAR_13 == VAR_12)
                goto not_found;

        if (VAR_13 - VAR_12 > VAR_19 - 1)  /* COMMENT_0 */
                goto not_found;

        VAR_18 = parse_gid(VAR_13 + 1, &VAR_16);
        if (VAR_18 < 0)
                goto not_found;

        VAR_14 = strndupa(VAR_12, VAR_13 - VAR_12);
        if (!machine_name_is_valid(VAR_14))
                goto not_found;

        VAR_18 = sd_bus_open_system(&VAR_11);
        if (VAR_18 < 0)
                goto fail;

        VAR_18 = sd_bus_call_method(VAR_11,
                               ""org.freedesktop.machine1"",
                               ""/org/freedesktop/machine1"",
                               ""org.freedesktop.machine1.Manager"",
                               ""MapFromMachineGroup"",
                               &VAR_6,
                               &VAR_9,
                               ""su"",
                               VAR_14, (uint32_t) VAR_16);
        if (VAR_18 < 0) {
                if (sd_bus_error_has_name(&VAR_6, VAR_20))
                        goto not_found;

                goto fail;
        }

        VAR_18 = sd_bus_message_read(VAR_9, ""u"", &VAR_15);
        if (VAR_18 < 0)
                goto fail;

        VAR_17 = sizeof(char*) + strlen(VAR_0) + 1;
        if (VAR_3 < VAR_17) {
                *VAR_4 = VAR_21;
                return VAR_22;
        }

        memzero(VAR_2, sizeof(char*));
        strcpy(VAR_2 + sizeof(char*), VAR_0);

        VAR_1->gr_name = VAR_2 + sizeof(char*);
        VAR_1->gr_gid = VAR_16;
        VAR_1->gr_passwd = (char*) ""*""; /* COMMENT_1 */
        VAR_1->gr_mem = (char**) VAR_2;

        *VAR_4 = 0;
        return VAR_23;

not_found:
        *VAR_4 = 0;
        return VAR_24;

fail:
        *VAR_4 = -VAR_18;
        return VAR_25;
}",systemd/cb31827d62066a04b02111df3052949fda4b6888/nss-mymachines.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,9 @@
 
         e = strrchr(p, '-');
         if (!e || e == p)
+                goto not_found;
+
+        if (e - p > HOST_NAME_MAX - 1)  /* -1 for the last dash */
                 goto not_found;
 
         r = parse_gid(e + 1, &gid);","{'deleted_lines': [], 'added_lines': ['                goto not_found;', '', '        if (e - p > HOST_NAME_MAX - 1)  /* -1 for the last dash */']}",True,Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd.,9.8,CRITICAL,3,valid,2015-11-23T18:59:43Z,1
CVE-2015-7990,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:C,0,torvalds/linux,"RDS: fix race condition when sending a message on unbound socket

Sasha's found a NULL pointer dereference in the RDS connection code when
sending a message to an apparently unbound socket.  The problem is caused
by the code checking if the socket is bound in rds_sendmsg(), which checks
the rs_bound_addr field without taking a lock on the socket.  This opens a
race where rs_bound_addr is temporarily set but where the transport is not
in rds_bind(), leading to a NULL pointer dereference when trying to
dereference 'trans' in __rds_conn_create().

Vegard wrote a reproducer for this issue, so kindly ask him to share if
you're interested.

I cannot reproduce the NULL pointer dereference using Vegard's reproducer
with this patch, whereas I could without.

Complete earlier incomplete fix to CVE-2015-6937:

  74e98eb08588 (""RDS: verify the underlying transport exists before creating a connection"")

Cc: David S. Miller <davem@davemloft.net>
Cc: stable@vger.kernel.org

Reviewed-by: Vegard Nossum <vegard.nossum@oracle.com>
Reviewed-by: Sasha Levin <sasha.levin@oracle.com>
Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",8c7188b23474cca017b3ef354c4a58456f68303a,https://github.com/torvalds/linux/commit/8c7188b23474cca017b3ef354c4a58456f68303a,net/rds/connection.c,__rds_conn_create,"static struct rds_connection *__rds_conn_create(struct net *net,
__be32 laddr, __be32 faddr,
struct rds_transport *trans, gfp_t gfp,
int is_outgoing)
{
struct rds_connection *conn, *parent = NULL;
struct hlist_head *head = rds_conn_bucket(laddr, faddr);
struct rds_transport *loop_trans;
unsigned long flags;
int ret;
rcu_read_lock();
conn = rds_conn_lookup(net, head, laddr, faddr, trans);
if (conn && conn->c_loopback && conn->c_trans != &rds_loop_transport &&
laddr == faddr && !is_outgoing) {
parent = conn;
conn = parent->c_passive;
}
rcu_read_unlock();
if (conn)
goto out;
conn = kmem_cache_zalloc(rds_conn_slab, gfp);
if (!conn) {
conn = ERR_PTR(-ENOMEM);
goto out;
}
INIT_HLIST_NODE(&conn->c_hash_node);
conn->c_laddr = laddr;
conn->c_faddr = faddr;
spin_lock_init(&conn->c_lock);
conn->c_next_tx_seq = 1;
rds_conn_net_set(conn, net);
init_waitqueue_head(&conn->c_waitq);
INIT_LIST_HEAD(&conn->c_send_queue);
INIT_LIST_HEAD(&conn->c_retrans);
ret = rds_cong_get_maps(conn);
if (ret) {
kmem_cache_free(rds_conn_slab, conn);
conn = ERR_PTR(ret);
goto out;
}
loop_trans = rds_trans_get_preferred(net, faddr);
if (loop_trans) {
rds_trans_put(loop_trans);
conn->c_loopback = 1;
if (is_outgoing && trans->t_prefer_loopback) {
trans = &rds_loop_transport;
}
}
if (trans == NULL) {
kmem_cache_free(rds_conn_slab, conn);
conn = ERR_PTR(-ENODEV);
goto out;
}
conn->c_trans = trans;
ret = trans->conn_alloc(conn, gfp);
if (ret) {
kmem_cache_free(rds_conn_slab, conn);
conn = ERR_PTR(ret);
goto out;
}
atomic_set(&conn->c_state, RDS_CONN_DOWN);
conn->c_send_gen = 0;
conn->c_outgoing = (is_outgoing ? 1 : 0);
conn->c_reconnect_jiffies = 0;
INIT_DELAYED_WORK(&conn->c_send_w, rds_send_worker);
INIT_DELAYED_WORK(&conn->c_recv_w, rds_recv_worker);
INIT_DELAYED_WORK(&conn->c_conn_w, rds_connect_worker);
INIT_WORK(&conn->c_down_w, rds_shutdown_worker);
mutex_init(&conn->c_cm_lock);
conn->c_flags = 0;
rdsdebug(""allocated conn %p for %pI4 -> %pI4 over %s %s\n"",
conn, &laddr, &faddr,
trans->t_name ? trans->t_name : ""[unknown]"",
is_outgoing ? ""(outgoing)"" : """");
spin_lock_irqsave(&rds_conn_lock, flags);
if (parent) {
if (parent->c_passive) {
trans->conn_free(conn->c_transport_data);
kmem_cache_free(rds_conn_slab, conn);
conn = parent->c_passive;
} else {
parent->c_passive = conn;
rds_cong_add_conn(conn);
rds_conn_count++;
}
} else {
struct rds_connection *found;
found = rds_conn_lookup(net, head, laddr, faddr, trans);
if (found) {
trans->conn_free(conn->c_transport_data);
kmem_cache_free(rds_conn_slab, conn);
conn = found;
} else {
hlist_add_head_rcu(&conn->c_hash_node, head);
rds_cong_add_conn(conn);
rds_conn_count++;
}
}
spin_unlock_irqrestore(&rds_conn_lock, flags);
out:
return conn;
}","static struct rds_connection *__rds_conn_create(struct net *net,
__be32 VAR_0, __be32 VAR_1,
struct rds_transport *VAR_2, gfp_t VAR_3,
int VAR_4)
{
struct rds_connection *VAR_5, *VAR_6 = NULL;
struct hlist_head *VAR_7 = rds_conn_bucket(VAR_0, VAR_1);
struct rds_transport *VAR_8;
unsigned long VAR_9;
int VAR_10;
rcu_read_lock();
VAR_5 = rds_conn_lookup(net, VAR_7, VAR_0, VAR_1, VAR_2);
if (VAR_5 && VAR_5->c_loopback && VAR_5->c_trans != &VAR_11 &&
VAR_0 == VAR_1 && !VAR_4) {
VAR_6 = VAR_5;
VAR_5 = VAR_6->c_passive;
}
rcu_read_unlock();
if (VAR_5)
goto out;
VAR_5 = kmem_cache_zalloc(VAR_12, VAR_3);
if (!VAR_5) {
VAR_5 = ERR_PTR(-VAR_13);
goto out;
}
INIT_HLIST_NODE(&VAR_5->c_hash_node);
VAR_5->c_laddr = VAR_0;
VAR_5->c_faddr = VAR_1;
spin_lock_init(&VAR_5->c_lock);
VAR_5->c_next_tx_seq = 1;
rds_conn_net_set(VAR_5, net);
init_waitqueue_head(&VAR_5->c_waitq);
INIT_LIST_HEAD(&VAR_5->c_send_queue);
INIT_LIST_HEAD(&VAR_5->c_retrans);
VAR_10 = rds_cong_get_maps(VAR_5);
if (VAR_10) {
kmem_cache_free(VAR_12, VAR_5);
VAR_5 = ERR_PTR(VAR_10);
goto out;
}
VAR_8 = rds_trans_get_preferred(net, VAR_1);
if (VAR_8) {
rds_trans_put(VAR_8);
VAR_5->c_loopback = 1;
if (VAR_4 && VAR_2->t_prefer_loopback) {
VAR_2 = &VAR_11;
}
}
if (VAR_2 == NULL) {
kmem_cache_free(VAR_12, VAR_5);
VAR_5 = ERR_PTR(-VAR_14);
goto out;
}
VAR_5->c_trans = VAR_2;
VAR_10 = VAR_2->conn_alloc(VAR_5, VAR_3);
if (VAR_10) {
kmem_cache_free(VAR_12, VAR_5);
VAR_5 = ERR_PTR(VAR_10);
goto out;
}
atomic_set(&VAR_5->c_state, VAR_15);
VAR_5->c_send_gen = 0;
VAR_5->c_outgoing = (VAR_4 ? 1 : 0);
VAR_5->c_reconnect_jiffies = 0;
INIT_DELAYED_WORK(&VAR_5->c_send_w, VAR_16);
INIT_DELAYED_WORK(&VAR_5->c_recv_w, VAR_17);
INIT_DELAYED_WORK(&VAR_5->c_conn_w, VAR_18);
INIT_WORK(&VAR_5->c_down_w, VAR_19);
mutex_init(&VAR_5->c_cm_lock);
VAR_5->c_flags = 0;
rdsdebug(""allocated conn %p for %pI4 -> %pI4 over %s %s\n"",
VAR_5, &VAR_0, &VAR_1,
VAR_2->t_name ? VAR_2->t_name : ""[unknown]"",
VAR_4 ? ""(outgoing)"" : """");
spin_lock_irqsave(&VAR_20, VAR_9);
if (VAR_6) {
if (VAR_6->c_passive) {
VAR_2->conn_free(VAR_5->c_transport_data);
kmem_cache_free(VAR_12, VAR_5);
VAR_5 = VAR_6->c_passive;
} else {
VAR_6->c_passive = VAR_5;
rds_cong_add_conn(VAR_5);
VAR_21++;
}
} else {
struct rds_connection *VAR_22;
VAR_22 = rds_conn_lookup(net, VAR_7, VAR_0, VAR_1, VAR_2);
if (VAR_22) {
VAR_2->conn_free(VAR_5->c_transport_data);
kmem_cache_free(VAR_12, VAR_5);
VAR_5 = VAR_22;
} else {
hlist_add_head_rcu(&VAR_5->c_hash_node, VAR_7);
rds_cong_add_conn(VAR_5);
VAR_21++;
}
}
spin_unlock_irqrestore(&VAR_20, VAR_9);
out:
return VAR_5;
}",torvalds/linux/8c7188b23474cca017b3ef354c4a58456f68303a/connection.c/vul/before/0.json,"static struct rds_connection *__rds_conn_create(struct net *net,
						__be32 laddr, __be32 faddr,
				       struct rds_transport *trans, gfp_t gfp,
				       int is_outgoing)
{
	struct rds_connection *conn, *parent = NULL;
	struct hlist_head *head = rds_conn_bucket(laddr, faddr);
	struct rds_transport *loop_trans;
	unsigned long flags;
	int ret;

	rcu_read_lock();
	conn = rds_conn_lookup(net, head, laddr, faddr, trans);
	if (conn && conn->c_loopback && conn->c_trans != &rds_loop_transport &&
	    laddr == faddr && !is_outgoing) {
		/* This is a looped back IB connection, and we're
		 * called by the code handling the incoming connect.
		 * We need a second connection object into which we
		 * can stick the other QP. */
		parent = conn;
		conn = parent->c_passive;
	}
	rcu_read_unlock();
	if (conn)
		goto out;

	conn = kmem_cache_zalloc(rds_conn_slab, gfp);
	if (!conn) {
		conn = ERR_PTR(-ENOMEM);
		goto out;
	}

	INIT_HLIST_NODE(&conn->c_hash_node);
	conn->c_laddr = laddr;
	conn->c_faddr = faddr;
	spin_lock_init(&conn->c_lock);
	conn->c_next_tx_seq = 1;
	rds_conn_net_set(conn, net);

	init_waitqueue_head(&conn->c_waitq);
	INIT_LIST_HEAD(&conn->c_send_queue);
	INIT_LIST_HEAD(&conn->c_retrans);

	ret = rds_cong_get_maps(conn);
	if (ret) {
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(ret);
		goto out;
	}

	/*
	 * This is where a connection becomes loopback.  If *any* RDS sockets
	 * can bind to the destination address then we'd rather the messages
	 * flow through loopback rather than either transport.
	 */
	loop_trans = rds_trans_get_preferred(net, faddr);
	if (loop_trans) {
		rds_trans_put(loop_trans);
		conn->c_loopback = 1;
		if (is_outgoing && trans->t_prefer_loopback) {
			/* ""outgoing"" connection - and the transport
			 * says it wants the connection handled by the
			 * loopback transport. This is what TCP does.
			 */
			trans = &rds_loop_transport;
		}
	}

	conn->c_trans = trans;

	ret = trans->conn_alloc(conn, gfp);
	if (ret) {
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(ret);
		goto out;
	}

	atomic_set(&conn->c_state, RDS_CONN_DOWN);
	conn->c_send_gen = 0;
	conn->c_outgoing = (is_outgoing ? 1 : 0);
	conn->c_reconnect_jiffies = 0;
	INIT_DELAYED_WORK(&conn->c_send_w, rds_send_worker);
	INIT_DELAYED_WORK(&conn->c_recv_w, rds_recv_worker);
	INIT_DELAYED_WORK(&conn->c_conn_w, rds_connect_worker);
	INIT_WORK(&conn->c_down_w, rds_shutdown_worker);
	mutex_init(&conn->c_cm_lock);
	conn->c_flags = 0;

	rdsdebug(""allocated conn %p for %pI4 -> %pI4 over %s %s\n"",
	  conn, &laddr, &faddr,
	  trans->t_name ? trans->t_name : ""[unknown]"",
	  is_outgoing ? ""(outgoing)"" : """");

	/*
	 * Since we ran without holding the conn lock, someone could
	 * have created the same conn (either normal or passive) in the
	 * interim. We check while holding the lock. If we won, we complete
	 * init and return our conn. If we lost, we rollback and return the
	 * other one.
	 */
	spin_lock_irqsave(&rds_conn_lock, flags);
	if (parent) {
		/* Creating passive conn */
		if (parent->c_passive) {
			trans->conn_free(conn->c_transport_data);
			kmem_cache_free(rds_conn_slab, conn);
			conn = parent->c_passive;
		} else {
			parent->c_passive = conn;
			rds_cong_add_conn(conn);
			rds_conn_count++;
		}
	} else {
		/* Creating normal conn */
		struct rds_connection *found;

		found = rds_conn_lookup(net, head, laddr, faddr, trans);
		if (found) {
			trans->conn_free(conn->c_transport_data);
			kmem_cache_free(rds_conn_slab, conn);
			conn = found;
		} else {
			hlist_add_head_rcu(&conn->c_hash_node, head);
			rds_cong_add_conn(conn);
			rds_conn_count++;
		}
	}
	spin_unlock_irqrestore(&rds_conn_lock, flags);

out:
	return conn;
}","static struct rds_connection *__rds_conn_create(struct net *net,
						__be32 VAR_0, __be32 VAR_1,
				       struct rds_transport *VAR_2, gfp_t VAR_3,
				       int VAR_4)
{
	struct rds_connection *VAR_5, *VAR_6 = NULL;
	struct hlist_head *VAR_7 = rds_conn_bucket(VAR_0, VAR_1);
	struct rds_transport *VAR_8;
	unsigned long VAR_9;
	int VAR_10;

	rcu_read_lock();
	VAR_5 = rds_conn_lookup(net, VAR_7, VAR_0, VAR_1, VAR_2);
	if (VAR_5 && VAR_5->c_loopback && VAR_5->c_trans != &VAR_11 &&
	    VAR_0 == VAR_1 && !VAR_4) {
		/* COMMENT_0 */
                                                      
                                                     
                               
		VAR_6 = VAR_5;
		VAR_5 = VAR_6->c_passive;
	}
	rcu_read_unlock();
	if (VAR_5)
		goto out;

	VAR_5 = kmem_cache_zalloc(VAR_12, VAR_3);
	if (!VAR_5) {
		VAR_5 = ERR_PTR(-VAR_13);
		goto out;
	}

	INIT_HLIST_NODE(&VAR_5->c_hash_node);
	VAR_5->c_laddr = VAR_0;
	VAR_5->c_faddr = VAR_1;
	spin_lock_init(&VAR_5->c_lock);
	VAR_5->c_next_tx_seq = 1;
	rds_conn_net_set(VAR_5, net);

	init_waitqueue_head(&VAR_5->c_waitq);
	INIT_LIST_HEAD(&VAR_5->c_send_queue);
	INIT_LIST_HEAD(&VAR_5->c_retrans);

	VAR_10 = rds_cong_get_maps(VAR_5);
	if (VAR_10) {
		kmem_cache_free(VAR_12, VAR_5);
		VAR_5 = ERR_PTR(VAR_10);
		goto out;
	}

	/* COMMENT_4 */
                                                                      
                                                                     
                                                       
    
	VAR_8 = rds_trans_get_preferred(net, VAR_1);
	if (VAR_8) {
		rds_trans_put(VAR_8);
		VAR_5->c_loopback = 1;
		if (VAR_4 && VAR_2->t_prefer_loopback) {
			/* COMMENT_9 */
                                                 
                                                
      
			VAR_2 = &VAR_11;
		}
	}

	VAR_5->c_trans = VAR_2;

	VAR_10 = VAR_2->conn_alloc(VAR_5, VAR_3);
	if (VAR_10) {
		kmem_cache_free(VAR_12, VAR_5);
		VAR_5 = ERR_PTR(VAR_10);
		goto out;
	}

	atomic_set(&VAR_5->c_state, VAR_14);
	VAR_5->c_send_gen = 0;
	VAR_5->c_outgoing = (VAR_4 ? 1 : 0);
	VAR_5->c_reconnect_jiffies = 0;
	INIT_DELAYED_WORK(&VAR_5->c_send_w, VAR_15);
	INIT_DELAYED_WORK(&VAR_5->c_recv_w, VAR_16);
	INIT_DELAYED_WORK(&VAR_5->c_conn_w, VAR_17);
	INIT_WORK(&VAR_5->c_down_w, VAR_18);
	mutex_init(&VAR_5->c_cm_lock);
	VAR_5->c_flags = 0;

	rdsdebug(""allocated conn %p for %pI4 -> %pI4 over %s %s\n"",
	  VAR_5, &VAR_0, &VAR_1,
	  VAR_2->t_name ? VAR_2->t_name : ""[unknown]"",
	  VAR_4 ? ""(outgoing)"" : """");

	/* COMMENT_13 */
                                                             
                                                                
                                                                    
                                                                    
              
    
	spin_lock_irqsave(&VAR_19, VAR_9);
	if (VAR_6) {
		/* COMMENT_20 */
		if (VAR_6->c_passive) {
			VAR_2->conn_free(VAR_5->c_transport_data);
			kmem_cache_free(VAR_12, VAR_5);
			VAR_5 = VAR_6->c_passive;
		} else {
			VAR_6->c_passive = VAR_5;
			rds_cong_add_conn(VAR_5);
			VAR_20++;
		}
	} else {
		/* COMMENT_21 */
		struct rds_connection *VAR_21;

		VAR_21 = rds_conn_lookup(net, VAR_7, VAR_0, VAR_1, VAR_2);
		if (VAR_21) {
			VAR_2->conn_free(VAR_5->c_transport_data);
			kmem_cache_free(VAR_12, VAR_5);
			VAR_5 = VAR_21;
		} else {
			hlist_add_head_rcu(&VAR_5->c_hash_node, VAR_7);
			rds_cong_add_conn(VAR_5);
			VAR_20++;
		}
	}
	spin_unlock_irqrestore(&VAR_19, VAR_9);

out:
	return VAR_5;
}",torvalds/linux/8c7188b23474cca017b3ef354c4a58456f68303a/connection.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -66,12 +66,6 @@
 		}
 	}
 
-	if (trans == NULL) {
-		kmem_cache_free(rds_conn_slab, conn);
-		conn = ERR_PTR(-ENODEV);
-		goto out;
-	}
-
 	conn->c_trans = trans;
 
 	ret = trans->conn_alloc(conn, gfp);","{'deleted_lines': ['\tif (trans == NULL) {', '\t\tkmem_cache_free(rds_conn_slab, conn);', '\t\tconn = ERR_PTR(-ENODEV);', '\t\tgoto out;', '\t}', ''], 'added_lines': []}",True,Race condition in the rds_sendmsg function in net/rds/sendmsg.c in the Linux kernel before 4.3.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6937.,5.8,MEDIUM,1,valid,2015-11-24T22:13:21Z,1
CVE-2015-7990,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:C,0,torvalds/linux,"RDS: fix race condition when sending a message on unbound socket

Sasha's found a NULL pointer dereference in the RDS connection code when
sending a message to an apparently unbound socket.  The problem is caused
by the code checking if the socket is bound in rds_sendmsg(), which checks
the rs_bound_addr field without taking a lock on the socket.  This opens a
race where rs_bound_addr is temporarily set but where the transport is not
in rds_bind(), leading to a NULL pointer dereference when trying to
dereference 'trans' in __rds_conn_create().

Vegard wrote a reproducer for this issue, so kindly ask him to share if
you're interested.

I cannot reproduce the NULL pointer dereference using Vegard's reproducer
with this patch, whereas I could without.

Complete earlier incomplete fix to CVE-2015-6937:

  74e98eb08588 (""RDS: verify the underlying transport exists before creating a connection"")

Cc: David S. Miller <davem@davemloft.net>
Cc: stable@vger.kernel.org

Reviewed-by: Vegard Nossum <vegard.nossum@oracle.com>
Reviewed-by: Sasha Levin <sasha.levin@oracle.com>
Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",8c7188b23474cca017b3ef354c4a58456f68303a,https://github.com/torvalds/linux/commit/8c7188b23474cca017b3ef354c4a58456f68303a,net/rds/send.c,rds_sendmsg,"int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
{
struct sock *sk = sock->sk;
struct rds_sock *rs = rds_sk_to_rs(sk);
DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
__be32 daddr;
__be16 dport;
struct rds_message *rm = NULL;
struct rds_connection *conn;
int ret = 0;
int queued = 0, allocated_mr = 0;
int nonblock = msg->msg_flags & MSG_DONTWAIT;
long timeo = sock_sndtimeo(sk, nonblock);
if (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {
ret = -EOPNOTSUPP;
goto out;
}
if (msg->msg_namelen) {
if (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {
ret = -EINVAL;
goto out;
}
daddr = usin->sin_addr.s_addr;
dport = usin->sin_port;
} else {
lock_sock(sk);
daddr = rs->rs_conn_addr;
dport = rs->rs_conn_port;
release_sock(sk);
}
if (daddr == 0 || rs->rs_bound_addr == 0) {
ret = -ENOTCONN; 
goto out;
}
if (payload_len > rds_sk_sndbuf(rs)) {
ret = -EMSGSIZE;
goto out;
}
ret = rds_rm_size(msg, payload_len);
if (ret < 0)
goto out;
rm = rds_message_alloc(ret, GFP_KERNEL);
if (!rm) {
ret = -ENOMEM;
goto out;
}
if (payload_len) {
rm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));
if (!rm->data.op_sg) {
ret = -ENOMEM;
goto out;
}
ret = rds_message_copy_from_user(rm, &msg->msg_iter);
if (ret)
goto out;
}
rm->data.op_active = 1;
rm->m_daddr = daddr;
if (rs->rs_conn && rs->rs_conn->c_faddr == daddr)
conn = rs->rs_conn;
else {
conn = rds_conn_create_outgoing(sock_net(sock->sk),
rs->rs_bound_addr, daddr,
rs->rs_transport,
sock->sk->sk_allocation);
if (IS_ERR(conn)) {
ret = PTR_ERR(conn);
goto out;
}
rs->rs_conn = conn;
}
ret = rds_cmsg_send(rs, rm, msg, &allocated_mr);
if (ret)
goto out;
if (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {
printk_ratelimited(KERN_NOTICE ""rdma_op %p conn xmit_rdma %p\n"",
&rm->rdma, conn->c_trans->xmit_rdma);
ret = -EOPNOTSUPP;
goto out;
}
if (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {
printk_ratelimited(KERN_NOTICE ""atomic_op %p conn xmit_atomic %p\n"",
&rm->atomic, conn->c_trans->xmit_atomic);
ret = -EOPNOTSUPP;
goto out;
}
rds_conn_connect_if_down(conn);
ret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);
if (ret) {
rs->rs_seen_congestion = 1;
goto out;
}
while (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,
dport, &queued)) {
rds_stats_inc(s_send_queue_full);
if (nonblock) {
ret = -EAGAIN;
goto out;
}
timeo = wait_event_interruptible_timeout(*sk_sleep(sk),
rds_send_queue_rm(rs, conn, rm,
rs->rs_bound_port,
dport,
&queued),
timeo);
rdsdebug(""sendmsg woke queued %d timeo %ld\n"", queued, timeo);
if (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)
continue;
ret = timeo;
if (ret == 0)
ret = -ETIMEDOUT;
goto out;
}
rds_stats_inc(s_send_queued);
ret = rds_send_xmit(conn);
if (ret == -ENOMEM || ret == -EAGAIN)
queue_delayed_work(rds_wq, &conn->c_send_w, 1);
rds_message_put(rm);
return payload_len;
out:
if (allocated_mr)
rds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);
if (rm)
rds_message_put(rm);
return ret;
}","int rds_sendmsg(struct socket *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
struct sock *VAR_3 = sock->sk;
struct rds_sock *VAR_4 = rds_sk_to_rs(VAR_3);
VAR_5(struct sockaddr_in *, VAR_6, VAR_1->msg_name);
__be32 VAR_7;
__be16 dportVAR_8;
struct rds_message *VAR_9 = NULL;
struct rds_connection *VAR_10;
int VAR_11 = 0;
int VAR_12 = 0, VAR_13 = 0;
int VAR_14 = VAR_1->msg_flags & VAR_15;
long VAR_16 = sock_sndtimeo(VAR_3, VAR_14);
if (VAR_1->msg_flags & ~(VAR_15 | VAR_17)) {
VAR_11 = -VAR_18;
goto out;
}
if (VAR_1->msg_namelen) {
if (VAR_1->msg_namelen < sizeof(*VAR_6) || VAR_6->sin_family != VAR_19) {
VAR_11 = -VAR_20;
goto out;
}
VAR_7 = VAR_6->sin_addr.s_addr;
dport = VAR_6->sin_port;
} else {
lock_sock(VAR_3);
VAR_7 = VAR_4->rs_conn_addr;
dport = VAR_4->rs_conn_port;
release_sock(VAR_3);
}
if (VAR_7 == 0 || VAR_4->rs_bound_addr == 0) {
VAR_11 = -VAR_21; 
goto out;
}
if (VAR_2 > rds_sk_sndbuf(VAR_4)) {
VAR_11 = -VAR_22;
goto out;
}
VAR_11 = rds_rm_size(VAR_1, VAR_2);
if (VAR_11 < 0)
goto out;
VAR_9 = rds_message_alloc(VAR_11, VAR_23);
if (!VAR_9) {
VAR_11 = -VAR_24;
goto out;
}
if (VAR_2) {
VAR_9->data.op_sg = rds_message_alloc_sgs(VAR_9, ceil(VAR_2, VAR_25));
if (!VAR_9->data.op_sg) {
VAR_11 = -VAR_24;
goto out;
}
VAR_11 = rds_message_copy_from_user(VAR_9, &VAR_1->msg_iter);
if (VAR_11)
goto out;
}
VAR_9->data.op_active = 1;
VAR_9->m_daddr = VAR_7;
if (VAR_4->rs_conn && VAR_4->rs_conn->c_faddr == VAR_7)
VAR_10 = VAR_4->rs_conn;
else {
VAR_10 = rds_conn_create_outgoing(sock_net(sock->sk),
VAR_4->rs_bound_addr, VAR_7,
VAR_4->rs_transport,
sock->sk->sk_allocation);
if (IS_ERR(VAR_10)) {
VAR_11 = PTR_ERR(VAR_10);
goto out;
}
VAR_4->rs_conn = VAR_10;
}
VAR_11 = rds_cmsg_send(VAR_4, VAR_9, VAR_1, &VAR_13);
if (VAR_11)
goto out;
if (VAR_9->rdma.op_active && !VAR_10->c_trans->xmit_rdma) {
printk_ratelimited(KERN_NOTICE ""rdma_op %p conn xmit_rdma %p\n"",
&VAR_9->rdma, VAR_10->c_trans->xmit_rdma);
VAR_11 = -VAR_18;
goto out;
}
if (VAR_9->atomic.op_active && !VAR_10->c_trans->xmit_atomic) {
printk_ratelimited(KERN_NOTICE ""atomic_op %p conn xmit_atomic %p\n"",
&VAR_9->atomic, VAR_10->c_trans->xmit_atomic);
VAR_11 = -VAR_18;
goto out;
}
rds_conn_connect_if_down(VAR_10);
VAR_11 = rds_cong_wait(VAR_10->c_fcong, dport, VAR_14, VAR_4);
if (VAR_11) {
VAR_4->rs_seen_congestion = 1;
goto out;
}
while (!rds_send_queue_rm(VAR_4, VAR_10, VAR_9, VAR_4->rs_bound_port,
dport, &VAR_12)) {
rds_stats_inc(VAR_26);
if (VAR_14) {
VAR_11 = -VAR_27;
goto out;
}
VAR_16 = wait_event_interruptible_timeout(*sk_sleep(VAR_3),
rds_send_queue_rm(VAR_4, VAR_10, VAR_9,
VAR_4->rs_bound_port,
dport,
&VAR_12),
VAR_16);
rdsdebug(""sendmsg woke queued %d timeo %ld\n"", VAR_12, VAR_16);
if (VAR_16 > 0 || VAR_16 == VAR_28)
continue;
VAR_11 = VAR_16;
if (VAR_11 == 0)
VAR_11 = -VAR_29;
goto out;
}
rds_stats_inc(VAR_30);
VAR_11 = rds_send_xmit(VAR_10);
if (VAR_11 == -VAR_24 || VAR_11 == -VAR_27)
queue_delayed_work(VAR_31, &VAR_10->c_send_w, 1);
rds_message_put(VAR_9);
return VAR_2;
out:
if (VAR_13)
rds_rdma_unuse(VAR_4, rds_rdma_cookie_key(VAR_9->m_rdma_cookie), 1);
if (VAR_9)
rds_message_put(VAR_9);
return VAR_11;
}",torvalds/linux/8c7188b23474cca017b3ef354c4a58456f68303a/send.c/vul/before/0.json,"int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
{
	struct sock *sk = sock->sk;
	struct rds_sock *rs = rds_sk_to_rs(sk);
	DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
	__be32 daddr;
	__be16 dport;
	struct rds_message *rm = NULL;
	struct rds_connection *conn;
	int ret = 0;
	int queued = 0, allocated_mr = 0;
	int nonblock = msg->msg_flags & MSG_DONTWAIT;
	long timeo = sock_sndtimeo(sk, nonblock);

	/* Mirror Linux UDP mirror of BSD error message compatibility */
	/* XXX: Perhaps MSG_MORE someday */
	if (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {
		ret = -EOPNOTSUPP;
		goto out;
	}

	if (msg->msg_namelen) {
		/* XXX fail non-unicast destination IPs? */
		if (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {
			ret = -EINVAL;
			goto out;
		}
		daddr = usin->sin_addr.s_addr;
		dport = usin->sin_port;
	} else {
		/* We only care about consistency with ->connect() */
		lock_sock(sk);
		daddr = rs->rs_conn_addr;
		dport = rs->rs_conn_port;
		release_sock(sk);
	}

	lock_sock(sk);
	if (daddr == 0 || rs->rs_bound_addr == 0) {
		release_sock(sk);
		ret = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}
	release_sock(sk);

	if (payload_len > rds_sk_sndbuf(rs)) {
		ret = -EMSGSIZE;
		goto out;
	}

	/* size of rm including all sgs */
	ret = rds_rm_size(msg, payload_len);
	if (ret < 0)
		goto out;

	rm = rds_message_alloc(ret, GFP_KERNEL);
	if (!rm) {
		ret = -ENOMEM;
		goto out;
	}

	/* Attach data to the rm */
	if (payload_len) {
		rm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));
		if (!rm->data.op_sg) {
			ret = -ENOMEM;
			goto out;
		}
		ret = rds_message_copy_from_user(rm, &msg->msg_iter);
		if (ret)
			goto out;
	}
	rm->data.op_active = 1;

	rm->m_daddr = daddr;

	/* rds_conn_create has a spinlock that runs with IRQ off.
	 * Caching the conn in the socket helps a lot. */
	if (rs->rs_conn && rs->rs_conn->c_faddr == daddr)
		conn = rs->rs_conn;
	else {
		conn = rds_conn_create_outgoing(sock_net(sock->sk),
						rs->rs_bound_addr, daddr,
					rs->rs_transport,
					sock->sk->sk_allocation);
		if (IS_ERR(conn)) {
			ret = PTR_ERR(conn);
			goto out;
		}
		rs->rs_conn = conn;
	}

	/* Parse any control messages the user may have included. */
	ret = rds_cmsg_send(rs, rm, msg, &allocated_mr);
	if (ret)
		goto out;

	if (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {
		printk_ratelimited(KERN_NOTICE ""rdma_op %p conn xmit_rdma %p\n"",
			       &rm->rdma, conn->c_trans->xmit_rdma);
		ret = -EOPNOTSUPP;
		goto out;
	}

	if (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {
		printk_ratelimited(KERN_NOTICE ""atomic_op %p conn xmit_atomic %p\n"",
			       &rm->atomic, conn->c_trans->xmit_atomic);
		ret = -EOPNOTSUPP;
		goto out;
	}

	rds_conn_connect_if_down(conn);

	ret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);
	if (ret) {
		rs->rs_seen_congestion = 1;
		goto out;
	}

	while (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,
				  dport, &queued)) {
		rds_stats_inc(s_send_queue_full);

		if (nonblock) {
			ret = -EAGAIN;
			goto out;
		}

		timeo = wait_event_interruptible_timeout(*sk_sleep(sk),
					rds_send_queue_rm(rs, conn, rm,
							  rs->rs_bound_port,
							  dport,
							  &queued),
					timeo);
		rdsdebug(""sendmsg woke queued %d timeo %ld\n"", queued, timeo);
		if (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)
			continue;

		ret = timeo;
		if (ret == 0)
			ret = -ETIMEDOUT;
		goto out;
	}

	/*
	 * By now we've committed to the send.  We reuse rds_send_worker()
	 * to retry sends in the rds thread if the transport asks us to.
	 */
	rds_stats_inc(s_send_queued);

	ret = rds_send_xmit(conn);
	if (ret == -ENOMEM || ret == -EAGAIN)
		queue_delayed_work(rds_wq, &conn->c_send_w, 1);

	rds_message_put(rm);
	return payload_len;

out:
	/* If the user included a RDMA_MAP cmsg, we allocated a MR on the fly.
	 * If the sendmsg goes through, we keep the MR. If it fails with EAGAIN
	 * or in any other way, we need to destroy the MR again */
	if (allocated_mr)
		rds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);

	if (rm)
		rds_message_put(rm);
	return ret;
}","int rds_sendmsg(struct socket *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
	struct sock *VAR_3 = sock->sk;
	struct rds_sock *VAR_4 = rds_sk_to_rs(VAR_3);
	VAR_5(struct sockaddr_in *, VAR_6, VAR_1->msg_name);
	__be32 VAR_7;
	__be16 dportVAR_8;
	struct rds_message *VAR_9 = NULL;
	struct rds_connection *VAR_10;
	int VAR_11 = 0;
	int VAR_12 = 0, VAR_13 = 0;
	int VAR_14 = VAR_1->msg_flags & VAR_15;
	long VAR_16 = sock_sndtimeo(VAR_3, VAR_14);

	/* COMMENT_0 */
	/* COMMENT_1 */
	if (VAR_1->msg_flags & ~(VAR_15 | VAR_17)) {
		VAR_11 = -VAR_18;
		goto out;
	}

	if (VAR_1->msg_namelen) {
		/* COMMENT_2 */
		if (VAR_1->msg_namelen < sizeof(*VAR_6) || VAR_6->sin_family != VAR_19) {
			VAR_11 = -VAR_20;
			goto out;
		}
		VAR_7 = VAR_6->sin_addr.s_addr;
		dport = VAR_6->sin_port;
	} else {
		/* COMMENT_3 */
		lock_sock(VAR_3);
		VAR_7 = VAR_4->rs_conn_addr;
		dport = VAR_4->rs_conn_port;
		release_sock(VAR_3);
	}

	lock_sock(VAR_3);
	if (VAR_7 == 0 || VAR_4->rs_bound_addr == 0) {
		release_sock(VAR_3);
		VAR_11 = -VAR_21; /* COMMENT_4 */
		goto out;
	}
	release_sock(VAR_3);

	if (VAR_2 > rds_sk_sndbuf(VAR_4)) {
		VAR_11 = -VAR_22;
		goto out;
	}

	/* COMMENT_5 */
	VAR_11 = rds_rm_size(VAR_1, VAR_2);
	if (VAR_11 < 0)
		goto out;

	VAR_9 = rds_message_alloc(VAR_11, VAR_23);
	if (!VAR_9) {
		VAR_11 = -VAR_24;
		goto out;
	}

	/* COMMENT_6 */
	if (VAR_2) {
		VAR_9->data.op_sg = rds_message_alloc_sgs(VAR_9, ceil(VAR_2, VAR_25));
		if (!VAR_9->data.op_sg) {
			VAR_11 = -VAR_24;
			goto out;
		}
		VAR_11 = rds_message_copy_from_user(VAR_9, &VAR_1->msg_iter);
		if (VAR_11)
			goto out;
	}
	VAR_9->data.op_active = 1;

	VAR_9->m_daddr = VAR_7;

	/* COMMENT_7 */
                                                  
	if (VAR_4->rs_conn && VAR_4->rs_conn->c_faddr == VAR_7)
		VAR_10 = VAR_4->rs_conn;
	else {
		VAR_10 = rds_conn_create_outgoing(sock_net(sock->sk),
						VAR_4->rs_bound_addr, VAR_7,
					VAR_4->rs_transport,
					sock->sk->sk_allocation);
		if (IS_ERR(VAR_10)) {
			VAR_11 = PTR_ERR(VAR_10);
			goto out;
		}
		VAR_4->rs_conn = VAR_10;
	}

	/* COMMENT_9 */
	VAR_11 = rds_cmsg_send(VAR_4, VAR_9, VAR_1, &VAR_13);
	if (VAR_11)
		goto out;

	if (VAR_9->rdma.op_active && !VAR_10->c_trans->xmit_rdma) {
		printk_ratelimited(KERN_NOTICE ""rdma_op %p conn xmit_rdma %p\n"",
			       &VAR_9->rdma, VAR_10->c_trans->xmit_rdma);
		VAR_11 = -VAR_18;
		goto out;
	}

	if (VAR_9->atomic.op_active && !VAR_10->c_trans->xmit_atomic) {
		printk_ratelimited(KERN_NOTICE ""atomic_op %p conn xmit_atomic %p\n"",
			       &VAR_9->atomic, VAR_10->c_trans->xmit_atomic);
		VAR_11 = -VAR_18;
		goto out;
	}

	rds_conn_connect_if_down(VAR_10);

	VAR_11 = rds_cong_wait(VAR_10->c_fcong, dport, VAR_14, VAR_4);
	if (VAR_11) {
		VAR_4->rs_seen_congestion = 1;
		goto out;
	}

	while (!rds_send_queue_rm(VAR_4, VAR_10, VAR_9, VAR_4->rs_bound_port,
				  dport, &VAR_12)) {
		rds_stats_inc(VAR_26);

		if (VAR_14) {
			VAR_11 = -VAR_27;
			goto out;
		}

		VAR_16 = wait_event_interruptible_timeout(*sk_sleep(VAR_3),
					rds_send_queue_rm(VAR_4, VAR_10, VAR_9,
							  VAR_4->rs_bound_port,
							  dport,
							  &VAR_12),
					VAR_16);
		rdsdebug(""sendmsg woke queued %d timeo %ld\n"", VAR_12, VAR_16);
		if (VAR_16 > 0 || VAR_16 == VAR_28)
			continue;

		VAR_11 = VAR_16;
		if (VAR_11 == 0)
			VAR_11 = -VAR_29;
		goto out;
	}

	/* COMMENT_10 */
                                                                   
                                                                 
    
	rds_stats_inc(VAR_30);

	VAR_11 = rds_send_xmit(VAR_10);
	if (VAR_11 == -VAR_24 || VAR_11 == -VAR_27)
		queue_delayed_work(VAR_31, &VAR_10->c_send_w, 1);

	rds_message_put(VAR_9);
	return VAR_2;

out:
	/* COMMENT_14 */
                                                                        
                                                           
	if (VAR_13)
		rds_rdma_unuse(VAR_4, rds_rdma_cookie_key(VAR_9->m_rdma_cookie), 1);

	if (VAR_9)
		rds_message_put(VAR_9);
	return VAR_11;
}",torvalds/linux/8c7188b23474cca017b3ef354c4a58456f68303a/send.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,11 +35,13 @@
 		release_sock(sk);
 	}
 
-	/* racing with another thread binding seems ok here */
+	lock_sock(sk);
 	if (daddr == 0 || rs->rs_bound_addr == 0) {
+		release_sock(sk);
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}
+	release_sock(sk);
 
 	if (payload_len > rds_sk_sndbuf(rs)) {
 		ret = -EMSGSIZE;","{'deleted_lines': ['\t/* racing with another thread binding seems ok here */'], 'added_lines': ['\tlock_sock(sk);', '\t\trelease_sock(sk);', '\trelease_sock(sk);']}",True,Race condition in the rds_sendmsg function in net/rds/sendmsg.c in the Linux kernel before 4.3.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6937.,5.8,MEDIUM,1,valid,2015-11-24T22:13:21Z,1
CVE-2015-8400,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,shellinabox,"Disable HTTP fallback via ""/plain"" URL (CVE-2015-8400)

* Disabled all methods of HTTP fallback when HTTPS is enabled. This
  is enforced on server side so that even modified client code (JS)
  can not redirect client from HTTPS to HTTP, like it was possible
  before (issue #355).
* Current solution unfortunately also disables automatic upgrade from
  HTTP to HTTPS (when available), since all non-SSL connections are
  droped immediately.",4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a,https://github.com/shellinabox/shellinabox/commit/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a,libhttp/httpconnection.c,httpHandleConnection,"int httpHandleConnection(struct ServerConnection *connection, void *http_,
short *events, short revents) {
struct HttpConnection *http        = (struct HttpConnection *)http_;
struct Trie *handlers              = serverGetHttpHandlers(http->server);
http->connection                   = connection;
int  bytes;
do {
bytes                            = 0;
*events                          = 0;
char buf[4096];
int  eof                         = http->closed;
if ((revents & POLLIN) && !http->closed) {
bytes                          = httpRead(http, buf, sizeof(buf));
if (bytes > 0) {
http->headerLength          += bytes;
if (http->headerLength > MAX_HEADER_LENGTH) {
debug(""[http] Connection closed due to exceeded header size!"");
httpSendReply(http, 413, ""Header too big"", NO_MSG);
bytes                      = 0;
eof                        = 1;
}
} else {
if (bytes == 0 || errno != EAGAIN) {
httpCloseRead(http);
eof                        = 1;
} else {
if (http->sslHndl && http->lastError == SSL_ERROR_WANT_WRITE) {
*events                 |= POLLOUT;
}
}
bytes                        = 0;
}
}
if (bytes > 0 && http->state == SNIFFING_SSL) {
int isSSL                      = 0;
char method[12]                = { 0 };
for (int i = -http->partialLength, j = 0, ch;
(ch = httpGetChar(http, buf, bytes, &i)) != -1;
j++) {
if ((j > 0 && (ch == ' ' || ch == '\t')) ||
ch == '\r' || ch == '\n') {
isSSL                      = strcmp(method, ""OPTIONS"") &&
strcmp(method, ""GET"") &&
strcmp(method, ""HEAD"") &&
strcmp(method, ""POST"") &&
strcmp(method, ""PUT"") &&
strcmp(method, ""DELETE"") &&
strcmp(method, ""TRACE"") &&
strcmp(method, ""CONNECT"");
http->state                = COMMAND;
break;
} else if (j >= (int)sizeof(method)-1 ||
ch < 'A' || (ch > 'Z' && ch < 'a') || ch > 'z') {
isSSL                      = 1;
http->state                = COMMAND;
break;
} else {
method[j]                  = ch & ~0x20;
}
}
if (isSSL) {
if (httpPromoteToSSL(http, buf, bytes) < 0) {
httpCloseRead(http);
bytes                      = 0;
eof                        = 1;
} else {
http->headerLength         = 0;
*events                   |= POLLIN;
continue;
}
}
}
if (bytes > 0 || (eof && http->partial)) {
check(!!http->partial == !!http->partialLength);
int  offset                    = -http->partialLength;
int  eob                       = 0;
do {
int pushBack                 = 0;
int consumed                 = 0;
if (http->state == SNIFFING_SSL || http->state == COMMAND ||
http->state == HEADERS) {
check(!http->expecting);
int  lineLength            = 0;
int  colon                 = -1;
int  firstSpace            = -1;
int  lastSpace             = -1;
int  fullLine              = 1;
for (int i = offset; ; lineLength++) {
int ch                   = httpGetChar(http, buf, bytes, &i);
if (ch == ':') {
if (colon < 0) {
colon                = lineLength;
}
} else if (ch == ' ' || ch == '\t') {
if (firstSpace < 0) {
firstSpace           = lineLength;
} else {
lastSpace            = lineLength;
}
} else if (ch == '\n') {
break;
} else if (ch == -1) {
fullLine               = 0;
eob                    = 1;
break;
}
}
if (fullLine || eof) {
consumed                 = lineLength + 1;
if (lineLength) {
if (http->state == SNIFFING_SSL || http->state == COMMAND) {
if (!httpParseCommand(http, offset, buf, bytes, firstSpace,
lastSpace, lineLength)) {
break;
}
} else {
check(http->state == HEADERS);
if (!httpParseHeaders(http, handlers, offset, buf, bytes,
colon, lineLength)) {
break;
}
}
}
} else {
pushBack                 = lineLength;
}
} else if (http->state == PAYLOAD ||
http->state == DISCARD_PAYLOAD) {
if (http->expecting) {
int len                  = bytes - offset;
if (http->expecting > 0 &&
len > http->expecting) {
len                    = http->expecting;
}
if (http->state == PAYLOAD) {
len                    = httpParsePayload(http, offset, buf,
len + offset);
}
consumed                 = len;
pushBack                 = bytes - offset - len;
}
} else if (http->state == WEBSOCKET) {
if (!httpHandleWebSocket(http, offset, buf, bytes)) {
httpCloseRead(http);
break;
}
consumed                  += bytes - offset;
} else {
check(0);
}
offset                      += consumed;
if (pushBack) {
check(offset + pushBack == bytes);
if (offset >= 0) {
check(http->partial      = realloc(http->partial, pushBack));
memcpy(http->partial, buf + offset, pushBack);
} else if (pushBack != http->partialLength) {
char *partial;
check(partial            = malloc(pushBack));
for (int i = offset, j = 0; j < pushBack; j++) {
partial[j]             = httpGetChar(http, buf, bytes, &i);
}
free(http->partial);
http->partial            = partial;
}
http->partialLength        = pushBack;
offset                     = -pushBack;
break;
} else {
eob                       |= offset >= bytes;
}
} while (!eob && !http->closed);
if (http->closed || offset >= 0) {
free(http->partial);
http->partial                = NULL;
http->partialLength          = 0;
} else if (-offset != http->partialLength) {
check(-offset < http->partialLength);
memmove(http->partial, http->partial + http->partialLength + offset,
-offset);
http->partialLength          = -offset;
}
}
if (eof) {
check(!http->partial);
switch (http->state) {
case SNIFFING_SSL:
case COMMAND:
break;
case HEADERS:
check(!http->expecting);
http->callback               = NULL;
http->arg                    = NULL;
httpHandleCommand(http, handlers);
httpCloseRead(http);
httpSetState(http, COMMAND);
break;
case PAYLOAD:
case DISCARD_PAYLOAD:
case WEBSOCKET:
http->expecting              = 0;
httpCloseRead(http);
httpSetState(http, COMMAND);
break;
}
}
for (;;) {
if (http->msg && http->msgLength > 0) {
int wrote                    = httpWrite(http, http->msg,
http->msgLength);
if (wrote < 0 && errno != EAGAIN) {
httpCloseRead(http);
free(http->msg);
http->msgLength            = 0;
http->msg                  = NULL;
break;
} else if (wrote > 0) {
if (wrote == http->msgLength) {
free(http->msg);
http->msgLength          = 0;
http->msg                = NULL;
} else {
memmove(http->msg, http->msg + wrote, http->msgLength - wrote);
http->msgLength         -= wrote;
}
}
else if (wrote < 0 && errno == EAGAIN && http->sslHndl) {
if (http->lastError == SSL_ERROR_WANT_READ && !http->closed) {
*events                 |= POLLIN;
}
}
}
if (http->isPartialReply && (!http->msg || http->msgLength <= 0)) {
httpConsumePayload(http, """", 0);
} else {
break;
}
}
*events                         |=
(*events & ~(POLLIN|POLLOUT)) |
(!http->closed && ((http->state != PAYLOAD &&
http->state != DISCARD_PAYLOAD) ||
http->expecting) ? POLLIN : 0) |
(http->msg || http->isPartialReply ? POLLOUT : 0);
connection                       = httpGetServerConnection(http);
int timedOut                     = serverGetTimeout(connection) < 0;
if (timedOut) {
free(http->partial);
http->partial                  = NULL;
http->partialLength            = 0;
free(http->msg);
http->msg                      = NULL;
http->msgLength                = 0;
}
if ((!(*events || http->isSuspended) || timedOut) && http->sslHndl) {
*events                        = 0;
serverSetTimeout(connection, 1);
int wasAlreadyClosed           = http->closed;
httpCloseRead(http);
dcheck(!ERR_peek_error());
sslBlockSigPipe();
int rc                         = SSL_shutdown(http->sslHndl);
switch (rc) {
case 1:
sslFreeHndl(&http->sslHndl);
break;
case 0:
if (!wasAlreadyClosed) {
*events                   |= POLLIN;
}
break;
case -1:
switch (SSL_get_error(http->sslHndl, rc)) {
case SSL_ERROR_WANT_READ:
if (!wasAlreadyClosed) {
*events                 |= POLLIN;
}
break;
case SSL_ERROR_WANT_WRITE:
*events                   |= POLLOUT;
break;
}
break;
}
ERR_clear_error();
dcheck(!ERR_peek_error());
if (sslUnblockSigPipe()) {
*events                      = 0;
sslFreeHndl(&http->sslHndl);
}
} else if (!http->sslHndl && timedOut) {
*events                        = 0;
serverSetTimeout(connection, 0);
httpCloseRead(http);
}
revents                          = POLLIN | POLLOUT;
} while (bytes > 0 && *events & POLLIN && !http->closed);
return (*events & (POLLIN|POLLOUT)) ||
(!http->closed && http->isSuspended);
}","int httpHandleConnection(struct ServerConnection *VAR_0, void *VAR_1,
short *VAR_2, short VAR_3) {
struct HttpConnection *VAR_4        = (struct HttpConnection *)VAR_1;
struct Trie *VAR_5              = serverGetHttpHandlers(VAR_4->server);
VAR_4->connection                   = VAR_0;
int  VAR_6;
do {
VAR_6                            = 0;
*VAR_2                          = 0;
char VAR_7[4096];
int  VAR_8                         = VAR_4->closed;
if ((VAR_3 & VAR_9) && !VAR_4->closed) {
VAR_6                          = httpRead(VAR_4, VAR_7, sizeof(VAR_7));
if (VAR_6 > 0) {
VAR_4->headerLength          += VAR_6;
if (VAR_4->headerLength > VAR_10) {
debug(""[http] Connection closed due to exceeded header size!"");
httpSendReply(VAR_4, 413, ""Header too big"", VAR_11);
VAR_6                      = 0;
VAR_8                        = 1;
}
} else {
if (VAR_6 == 0 || VAR_12 != VAR_13) {
httpCloseRead(VAR_4);
VAR_8                        = 1;
} else {
if (VAR_4->sslHndl && VAR_4->lastError == VAR_14) {
*VAR_2                 |= VAR_15;
}
}
VAR_6                        = 0;
}
}
if (VAR_6 > 0 && VAR_4->state == VAR_16) {
int VAR_17                      = 0;
char VAR_18[12]                = { 0 };
for (int VAR_19 = -VAR_4->partialLength, VAR_20 = 0, VAR_21;
(VAR_21 = httpGetChar(VAR_4, VAR_7, VAR_6, &VAR_19)) != -1;
VAR_20++) {
if ((VAR_20 > 0 && (VAR_21 == ' ' || VAR_21 == '\t')) ||
VAR_21 == '\r' || VAR_21 == '\n') {
VAR_17                      = strcmp(VAR_18, ""OPTIONS"") &&
strcmp(VAR_18, ""GET"") &&
strcmp(VAR_18, ""HEAD"") &&
strcmp(VAR_18, ""POST"") &&
strcmp(VAR_18, ""PUT"") &&
strcmp(VAR_18, ""DELETE"") &&
strcmp(VAR_18, ""TRACE"") &&
strcmp(VAR_18, ""CONNECT"");
VAR_4->state                = VAR_22;
break;
} else if (VAR_20 >= (int)sizeof(VAR_18)-1 ||
VAR_21 < 'A' || (VAR_21 > 'Z' && VAR_21 < 'a') || VAR_21 > 'z') {
VAR_17                      = 1;
VAR_4->state                = VAR_22;
break;
} else {
VAR_18[VAR_20]                  = VAR_21 & ~0x20;
}
}
if (VAR_17) {
if (httpPromoteToSSL(VAR_4, VAR_7, VAR_6) < 0) {
httpCloseRead(VAR_4);
VAR_6                      = 0;
VAR_8                        = 1;
} else {
VAR_4->headerLength         = 0;
*VAR_2                   |= VAR_9;
continue;
}
}
}
if (VAR_6 > 0 || (VAR_8 && VAR_4->partial)) {
check(!!VAR_4->partial == !!VAR_4->partialLength);
int  VAR_23                    = -VAR_4->partialLength;
int  VAR_24                       = 0;
do {
int VAR_25                 = 0;
int VAR_26                 = 0;
if (VAR_4->state == VAR_16 || VAR_4->state == VAR_22 ||
VAR_4->state == VAR_27) {
check(!VAR_4->expecting);
int  VAR_28            = 0;
int  VAR_29                 = -1;
int  VAR_30            = -1;
int  VAR_31             = -1;
int  VAR_32              = 1;
for (int VAR_19 = VAR_23; ; VAR_28++) {
int VAR_21                   = httpGetChar(VAR_4, VAR_7, VAR_6, &VAR_19);
if (VAR_21 == ':') {
if (VAR_29 < 0) {
VAR_29                = VAR_28;
}
} else if (VAR_21 == ' ' || VAR_21 == '\t') {
if (VAR_30 < 0) {
VAR_30           = VAR_28;
} else {
VAR_31            = VAR_28;
}
} else if (VAR_21 == '\n') {
break;
} else if (VAR_21 == -1) {
VAR_32               = 0;
VAR_24                    = 1;
break;
}
}
if (VAR_32 || VAR_8) {
VAR_26                 = VAR_28 + 1;
if (VAR_28) {
if (VAR_4->state == VAR_16 || VAR_4->state == VAR_22) {
if (!httpParseCommand(VAR_4, VAR_23, VAR_7, VAR_6, VAR_30,
VAR_31, VAR_28)) {
break;
}
} else {
check(VAR_4->state == VAR_27);
if (!httpParseHeaders(VAR_4, VAR_5, VAR_23, VAR_7, VAR_6,
VAR_29, VAR_28)) {
break;
}
}
}
} else {
VAR_25                 = VAR_28;
}
} else if (VAR_4->state == VAR_33 ||
VAR_4->state == VAR_34) {
if (VAR_4->expecting) {
int VAR_35                  = VAR_6 - VAR_23;
if (VAR_4->expecting > 0 &&
VAR_35 > VAR_4->expecting) {
VAR_35                    = VAR_4->expecting;
}
if (VAR_4->state == VAR_33) {
VAR_35                    = httpParsePayload(VAR_4, VAR_23, VAR_7,
VAR_35 + VAR_23);
}
VAR_26                 = VAR_35;
VAR_25                 = VAR_6 - VAR_23 - VAR_35;
}
} else if (VAR_4->state == VAR_36) {
if (!httpHandleWebSocket(VAR_4, VAR_23, VAR_7, VAR_6)) {
httpCloseRead(VAR_4);
break;
}
VAR_26                  += VAR_6 - VAR_23;
} else {
check(0);
}
VAR_23                      += VAR_26;
if (VAR_25) {
check(VAR_23 + VAR_25 == VAR_6);
if (VAR_23 >= 0) {
check(VAR_4->partial      = realloc(VAR_4->partial, VAR_25));
memcpy(VAR_4->partial, VAR_7 + VAR_23, VAR_25);
} else if (VAR_25 != VAR_4->partialLength) {
char *VAR_37;
check(VAR_37            = malloc(VAR_25));
for (int VAR_19 = VAR_23, VAR_20 = 0; VAR_20 < VAR_25; VAR_20++) {
VAR_37[VAR_20]             = httpGetChar(VAR_4, VAR_7, VAR_6, &VAR_19);
}
free(VAR_4->partial);
VAR_4->partial            = VAR_37;
}
VAR_4->partialLength        = VAR_25;
VAR_23                     = -VAR_25;
break;
} else {
VAR_24                       |= VAR_23 >= VAR_6;
}
} while (!VAR_24 && !VAR_4->closed);
if (VAR_4->closed || VAR_23 >= 0) {
free(VAR_4->partial);
VAR_4->partial                = NULL;
VAR_4->partialLength          = 0;
} else if (-VAR_23 != VAR_4->partialLength) {
check(-VAR_23 < VAR_4->partialLength);
memmove(VAR_4->partial, VAR_4->partial + VAR_4->partialLength + VAR_23,
-VAR_23);
VAR_4->partialLength          = -VAR_23;
}
}
if (VAR_8) {
check(!VAR_4->partial);
switch (VAR_4->state) {
case VAR_16:
case VAR_22:
break;
case VAR_27:
check(!VAR_4->expecting);
VAR_4->callback               = NULL;
VAR_4->arg                    = NULL;
httpHandleCommand(VAR_4, VAR_5);
httpCloseRead(VAR_4);
httpSetState(VAR_4, VAR_22);
break;
case VAR_33:
case VAR_34:
case VAR_36:
VAR_4->expecting              = 0;
httpCloseRead(VAR_4);
httpSetState(VAR_4, VAR_22);
break;
}
}
for (;;) {
if (VAR_4->msg && VAR_4->msgLength > 0) {
int VAR_38                    = httpWrite(VAR_4, VAR_4->msg,
VAR_4->msgLength);
if (VAR_38 < 0 && VAR_12 != VAR_13) {
httpCloseRead(VAR_4);
free(VAR_4->msg);
VAR_4->msgLength            = 0;
VAR_4->msg                  = NULL;
break;
} else if (VAR_38 > 0) {
if (VAR_38 == VAR_4->msgLength) {
free(VAR_4->msg);
VAR_4->msgLength          = 0;
VAR_4->msg                = NULL;
} else {
memmove(VAR_4->msg, VAR_4->msg + VAR_38, VAR_4->msgLength - VAR_38);
VAR_4->msgLength         -= VAR_38;
}
}
else if (VAR_38 < 0 && VAR_12 == VAR_13 && VAR_4->sslHndl) {
if (VAR_4->lastError == VAR_39 && !VAR_4->closed) {
*VAR_2                 |= VAR_9;
}
}
}
if (VAR_4->isPartialReply && (!VAR_4->msg || VAR_4->msgLength <= 0)) {
httpConsumePayload(VAR_4, """", 0);
} else {
break;
}
}
*VAR_2                         |=
(*VAR_2 & ~(VAR_9|VAR_15)) |
(!VAR_4->closed && ((VAR_4->state != VAR_33 &&
VAR_4->state != VAR_34) ||
VAR_4->expecting) ? VAR_9 : 0) |
(VAR_4->msg || VAR_4->isPartialReply ? VAR_15 : 0);
VAR_0                       = httpGetServerConnection(VAR_4);
int VAR_40                     = serverGetTimeout(VAR_0) < 0;
if (VAR_40) {
free(VAR_4->partial);
VAR_4->partial                  = NULL;
VAR_4->partialLength            = 0;
free(VAR_4->msg);
VAR_4->msg                      = NULL;
VAR_4->msgLength                = 0;
}
if ((!(*VAR_2 || VAR_4->isSuspended) || VAR_40) && VAR_4->sslHndl) {
*VAR_2                        = 0;
serverSetTimeout(VAR_0, 1);
int VAR_41           = VAR_4->closed;
httpCloseRead(VAR_4);
dcheck(!ERR_peek_error());
sslBlockSigPipe();
int VAR_42                         = SSL_shutdown(VAR_4->sslHndl);
switch (VAR_42) {
case 1:
sslFreeHndl(&VAR_4->sslHndl);
break;
case 0:
if (!VAR_41) {
*VAR_2                   |= VAR_9;
}
break;
case -1:
switch (SSL_get_error(VAR_4->sslHndl, VAR_42)) {
case VAR_39:
if (!VAR_41) {
*VAR_2                 |= VAR_9;
}
break;
case VAR_14:
*VAR_2                   |= VAR_15;
break;
}
break;
}
ERR_clear_error();
dcheck(!ERR_peek_error());
if (sslUnblockSigPipe()) {
*VAR_2                      = 0;
sslFreeHndl(&VAR_4->sslHndl);
}
} else if (!VAR_4->sslHndl && VAR_40) {
*VAR_2                        = 0;
serverSetTimeout(VAR_0, 0);
httpCloseRead(VAR_4);
}
VAR_3                          = VAR_9 | VAR_15;
} while (VAR_6 > 0 && *VAR_2 & VAR_9 && !VAR_4->closed);
return (*VAR_2 & (VAR_9|VAR_15)) ||
(!VAR_4->closed && VAR_4->isSuspended);
}",shellinabox/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a/httpconnection.c/vul/before/0.json,"int httpHandleConnection(struct ServerConnection *connection, void *http_,
                         short *events, short revents) {
  struct HttpConnection *http        = (struct HttpConnection *)http_;
  struct Trie *handlers              = serverGetHttpHandlers(http->server);
  http->connection                   = connection;
  int  bytes;
  do {
    bytes                            = 0;
    *events                          = 0;
    char buf[4096];
    int  eof                         = http->closed;
    if ((revents & POLLIN) && !http->closed) {
      bytes                          = httpRead(http, buf, sizeof(buf));
      if (bytes > 0) {
        http->headerLength          += bytes;
        if (http->headerLength > MAX_HEADER_LENGTH) {
          debug(""[http] Connection closed due to exceeded header size!"");
          httpSendReply(http, 413, ""Header too big"", NO_MSG);
          bytes                      = 0;
          eof                        = 1;
        }
      } else {
        if (bytes == 0 || errno != EAGAIN) {
          httpCloseRead(http);
          eof                        = 1;
        } else {
          if (http->sslHndl && http->lastError == SSL_ERROR_WANT_WRITE) {
            *events                 |= POLLOUT;
          }
        }
        bytes                        = 0;
      }
    }

    if (bytes > 0 && http->state == SNIFFING_SSL) {
      // Assume that all legitimate HTTP commands start with a sequence of
      // letters followed by a space character. If we don't see this pattern,
      // or if the method does not match one of the known methods, we try
      // switching to SSL, instead.
      int isSSL                      = 0;
      char method[12]                = { 0 };
      for (int i = -http->partialLength, j = 0, ch;
           (ch = httpGetChar(http, buf, bytes, &i)) != -1;
           j++) {
        if ((j > 0 && (ch == ' ' || ch == '\t')) ||
            ch == '\r' || ch == '\n') {
          isSSL                      = strcmp(method, ""OPTIONS"") &&
                                       strcmp(method, ""GET"") &&
                                       strcmp(method, ""HEAD"") &&
                                       strcmp(method, ""POST"") &&
                                       strcmp(method, ""PUT"") &&
                                       strcmp(method, ""DELETE"") &&
                                       strcmp(method, ""TRACE"") &&
                                       strcmp(method, ""CONNECT"");
          http->state                = COMMAND;
          break;
        } else if (j >= (int)sizeof(method)-1 ||
                   ch < 'A' || (ch > 'Z' && ch < 'a') || ch > 'z') {
          isSSL                      = 1;
          http->state                = COMMAND;
          break;
        } else {
          method[j]                  = ch & ~0x20;
        }
      }
      if (isSSL) {
        if (httpPromoteToSSL(http, buf, bytes) < 0) {
          httpCloseRead(http);
          bytes                      = 0;
          eof                        = 1;
        } else {
          http->headerLength         = 0;
          *events                   |= POLLIN;
          continue;
        }
      } else {
        if (http->ssl && http->ssl->enabled && http->ssl->force) {
          debug(""[http] Non-SSL connections not allowed!"");
          httpCloseRead(http);
          bytes                      = 0;
          eof                        = 1;
        }
      }
    }

    if (bytes > 0 || (eof && http->partial)) {
      check(!!http->partial == !!http->partialLength);
      int  offset                    = -http->partialLength;
      int  eob                       = 0;
      do {
        int pushBack                 = 0;
        int consumed                 = 0;
        if (http->state == SNIFFING_SSL || http->state == COMMAND ||
            http->state == HEADERS) {
          check(!http->expecting);
          int  lineLength            = 0;
          int  colon                 = -1;
          int  firstSpace            = -1;
          int  lastSpace             = -1;
          int  fullLine              = 1;
          for (int i = offset; ; lineLength++) {
            int ch                   = httpGetChar(http, buf, bytes, &i);
            if (ch == ':') {
              if (colon < 0) {
                colon                = lineLength;
              }
            } else if (ch == ' ' || ch == '\t') {
              if (firstSpace < 0) {
                firstSpace           = lineLength;
              } else {
                lastSpace            = lineLength;
              }
            } else if (ch == '\n') {
              break;
            } else if (ch == -1) {
              fullLine               = 0;
              eob                    = 1;
              break;
            }
          }
          if (fullLine || eof) {
            consumed                 = lineLength + 1;
            if (lineLength) {
              if (http->state == SNIFFING_SSL || http->state == COMMAND) {
                if (!httpParseCommand(http, offset, buf, bytes, firstSpace,
                                      lastSpace, lineLength)) {
                  break;
                }
              } else {
                check(http->state == HEADERS);
                if (!httpParseHeaders(http, handlers, offset, buf, bytes,
                                      colon, lineLength)) {
                  break;
                }
              }
            }
          } else {
            pushBack                 = lineLength;
          }
        } else if (http->state == PAYLOAD ||
                   http->state == DISCARD_PAYLOAD) {
          if (http->expecting) {
            int len                  = bytes - offset;
            if (http->expecting > 0 &&
                len > http->expecting) {
              len                    = http->expecting;
            }
            if (http->state == PAYLOAD) {
              len                    = httpParsePayload(http, offset, buf,
                                                        len + offset);
            }
            consumed                 = len;
            pushBack                 = bytes - offset - len;
          }
        } else if (http->state == WEBSOCKET) {
          if (!httpHandleWebSocket(http, offset, buf, bytes)) {
            httpCloseRead(http);
            break;
          }
          consumed                  += bytes - offset;
        } else {
          check(0);
        }

        offset                      += consumed;
        if (pushBack) {
          check(offset + pushBack == bytes);
          if (offset >= 0) {
            check(http->partial      = realloc(http->partial, pushBack));
            memcpy(http->partial, buf + offset, pushBack);
          } else if (pushBack != http->partialLength) {
            char *partial;
            check(partial            = malloc(pushBack));
            for (int i = offset, j = 0; j < pushBack; j++) {
              partial[j]             = httpGetChar(http, buf, bytes, &i);
            }
            free(http->partial);
            http->partial            = partial;
          }
          http->partialLength        = pushBack;
          offset                     = -pushBack;
          break;
        } else {
          eob                       |= offset >= bytes;
        }
      } while (!eob && !http->closed);
      if (http->closed || offset >= 0) {
        free(http->partial);
        http->partial                = NULL;
        http->partialLength          = 0;
      } else if (-offset != http->partialLength) {
        check(-offset < http->partialLength);
        memmove(http->partial, http->partial + http->partialLength + offset,
                -offset);
        http->partialLength          = -offset;
      }
    }

    // If the peer closed the connection, clean up now.
    if (eof) {
      check(!http->partial);
      switch (http->state) {
      case SNIFFING_SSL:
      case COMMAND:
        break;
      case HEADERS:
        check(!http->expecting);
        http->callback               = NULL;
        http->arg                    = NULL;
        httpHandleCommand(http, handlers);
        httpCloseRead(http);
        httpSetState(http, COMMAND);
        break;
      case PAYLOAD:
      case DISCARD_PAYLOAD:
      case WEBSOCKET:
        http->expecting              = 0;
        httpCloseRead(http);
        httpSetState(http, COMMAND);
        break;
      }
    }

    for (;;) {
      // Try to write any pending outgoing data
      if (http->msg && http->msgLength > 0) {
        int wrote                    = httpWrite(http, http->msg,
                                                 http->msgLength);
        if (wrote < 0 && errno != EAGAIN) {
          httpCloseRead(http);
          free(http->msg);
          http->msgLength            = 0;
          http->msg                  = NULL;
          break;
        } else if (wrote > 0) {
          if (wrote == http->msgLength) {
            free(http->msg);
            http->msgLength          = 0;
            http->msg                = NULL;
          } else {
            memmove(http->msg, http->msg + wrote, http->msgLength - wrote);
            http->msgLength         -= wrote;
          }
        }
        // SSL might require reading in order to write
        else if (wrote < 0 && errno == EAGAIN && http->sslHndl) {
          if (http->lastError == SSL_ERROR_WANT_READ && !http->closed) {
            *events                 |= POLLIN;
          }
        }
      }

      // If the callback only provided partial data, refill the outgoing
      // buffer whenever it runs low.
      if (http->isPartialReply && (!http->msg || http->msgLength <= 0)) {
        httpConsumePayload(http, """", 0);
      } else {
        break;
      }
    }

    *events                         |=
      (*events & ~(POLLIN|POLLOUT)) |
      (!http->closed && ((http->state != PAYLOAD &&
                          http->state != DISCARD_PAYLOAD) ||
                         http->expecting) ? POLLIN : 0) |
      (http->msg || http->isPartialReply ? POLLOUT : 0);

    connection                       = httpGetServerConnection(http);
    int timedOut                     = serverGetTimeout(connection) < 0;
    if (timedOut) {
      free(http->partial);
      http->partial                  = NULL;
      http->partialLength            = 0;
      free(http->msg);
      http->msg                      = NULL;
      http->msgLength                = 0;
    }

    if ((!(*events || http->isSuspended) || timedOut) && http->sslHndl) {
      *events                        = 0;
      serverSetTimeout(connection, 1);
      int wasAlreadyClosed           = http->closed;
      httpCloseRead(http);
      dcheck(!ERR_peek_error());
      sslBlockSigPipe();
      int rc                         = SSL_shutdown(http->sslHndl);
      switch (rc) {
      case 1:
        sslFreeHndl(&http->sslHndl);
        break;
      case 0:
        if (!wasAlreadyClosed) {
          *events                   |= POLLIN;
        }
        break;
      case -1:
        switch (SSL_get_error(http->sslHndl, rc)) {
        case SSL_ERROR_WANT_READ:
          if (!wasAlreadyClosed) {
            *events                 |= POLLIN;
          }
          break;
        case SSL_ERROR_WANT_WRITE:
          *events                   |= POLLOUT;
          break;
        }
        break;
      }
      ERR_clear_error();
      dcheck(!ERR_peek_error());
      if (sslUnblockSigPipe()) {
        *events                      = 0;
        sslFreeHndl(&http->sslHndl);
      }
    } else if (!http->sslHndl && timedOut) {
      *events                        = 0;
      serverSetTimeout(connection, 0);
      httpCloseRead(http);
    }
    revents                          = POLLIN | POLLOUT;
  } while (bytes > 0 && *events & POLLIN && !http->closed);
  return (*events & (POLLIN|POLLOUT)) ||
         (!http->closed && http->isSuspended);
}","int httpHandleConnection(struct ServerConnection *VAR_0, void *VAR_1,
                         short *VAR_2, short VAR_3) {
  struct HttpConnection *VAR_4        = (struct HttpConnection *)VAR_1;
  struct Trie *VAR_5              = serverGetHttpHandlers(VAR_4->server);
  VAR_4->connection                   = VAR_0;
  int  VAR_6;
  do {
    VAR_6                            = 0;
    *VAR_2                          = 0;
    char VAR_7[4096];
    int  VAR_8                         = VAR_4->closed;
    if ((VAR_3 & VAR_9) && !VAR_4->closed) {
      VAR_6                          = httpRead(VAR_4, VAR_7, sizeof(VAR_7));
      if (VAR_6 > 0) {
        VAR_4->headerLength          += VAR_6;
        if (VAR_4->headerLength > VAR_10) {
          debug(""[http] Connection closed due to exceeded header size!"");
          httpSendReply(VAR_4, 413, ""Header too big"", VAR_11);
          VAR_6                      = 0;
          VAR_8                        = 1;
        }
      } else {
        if (VAR_6 == 0 || VAR_12 != VAR_13) {
          httpCloseRead(VAR_4);
          VAR_8                        = 1;
        } else {
          if (VAR_4->sslHndl && VAR_4->lastError == VAR_14) {
            *VAR_2                 |= VAR_15;
          }
        }
        VAR_6                        = 0;
      }
    }

    if (VAR_6 > 0 && VAR_4->state == VAR_16) {
      /* COMMENT_0 */
      /* COMMENT_1 */
      /* COMMENT_2 */
      /* COMMENT_3 */
      int VAR_17                      = 0;
      char VAR_18[12]                = { 0 };
      for (int VAR_19 = -VAR_4->partialLength, VAR_20 = 0, VAR_21;
           (VAR_21 = httpGetChar(VAR_4, VAR_7, VAR_6, &VAR_19)) != -1;
           VAR_20++) {
        if ((VAR_20 > 0 && (VAR_21 == ' ' || VAR_21 == '\t')) ||
            VAR_21 == '\r' || VAR_21 == '\n') {
          VAR_17                      = strcmp(VAR_18, ""OPTIONS"") &&
                                       strcmp(VAR_18, ""GET"") &&
                                       strcmp(VAR_18, ""HEAD"") &&
                                       strcmp(VAR_18, ""POST"") &&
                                       strcmp(VAR_18, ""PUT"") &&
                                       strcmp(VAR_18, ""DELETE"") &&
                                       strcmp(VAR_18, ""TRACE"") &&
                                       strcmp(VAR_18, ""CONNECT"");
          VAR_4->state                = VAR_22;
          break;
        } else if (VAR_20 >= (int)sizeof(VAR_18)-1 ||
                   VAR_21 < 'A' || (VAR_21 > 'Z' && VAR_21 < 'a') || VAR_21 > 'z') {
          VAR_17                      = 1;
          VAR_4->state                = VAR_22;
          break;
        } else {
          VAR_18[VAR_20]                  = VAR_21 & ~0x20;
        }
      }
      if (VAR_17) {
        if (httpPromoteToSSL(VAR_4, VAR_7, VAR_6) < 0) {
          httpCloseRead(VAR_4);
          VAR_6                      = 0;
          VAR_8                        = 1;
        } else {
          VAR_4->headerLength         = 0;
          *VAR_2                   |= VAR_9;
          continue;
        }
      } else {
        if (VAR_4->ssl && VAR_4->ssl->enabled && VAR_4->ssl->force) {
          debug(""[http] Non-SSL connections not allowed!"");
          httpCloseRead(VAR_4);
          VAR_6                      = 0;
          VAR_8                        = 1;
        }
      }
    }

    if (VAR_6 > 0 || (VAR_8 && VAR_4->partial)) {
      check(!!VAR_4->partial == !!VAR_4->partialLength);
      int  VAR_23                    = -VAR_4->partialLength;
      int  VAR_24                       = 0;
      do {
        int VAR_25                 = 0;
        int VAR_26                 = 0;
        if (VAR_4->state == VAR_16 || VAR_4->state == VAR_22 ||
            VAR_4->state == VAR_27) {
          check(!VAR_4->expecting);
          int  VAR_28            = 0;
          int  VAR_29                 = -1;
          int  VAR_30            = -1;
          int  VAR_31             = -1;
          int  VAR_32              = 1;
          for (int VAR_19 = VAR_23; ; VAR_28++) {
            int VAR_21                   = httpGetChar(VAR_4, VAR_7, VAR_6, &VAR_19);
            if (VAR_21 == ':') {
              if (VAR_29 < 0) {
                VAR_29                = VAR_28;
              }
            } else if (VAR_21 == ' ' || VAR_21 == '\t') {
              if (VAR_30 < 0) {
                VAR_30           = VAR_28;
              } else {
                VAR_31            = VAR_28;
              }
            } else if (VAR_21 == '\n') {
              break;
            } else if (VAR_21 == -1) {
              VAR_32               = 0;
              VAR_24                    = 1;
              break;
            }
          }
          if (VAR_32 || VAR_8) {
            VAR_26                 = VAR_28 + 1;
            if (VAR_28) {
              if (VAR_4->state == VAR_16 || VAR_4->state == VAR_22) {
                if (!httpParseCommand(VAR_4, VAR_23, VAR_7, VAR_6, VAR_30,
                                      VAR_31, VAR_28)) {
                  break;
                }
              } else {
                check(VAR_4->state == VAR_27);
                if (!httpParseHeaders(VAR_4, VAR_5, VAR_23, VAR_7, VAR_6,
                                      VAR_29, VAR_28)) {
                  break;
                }
              }
            }
          } else {
            VAR_25                 = VAR_28;
          }
        } else if (VAR_4->state == VAR_33 ||
                   VAR_4->state == VAR_34) {
          if (VAR_4->expecting) {
            int VAR_35                  = VAR_6 - VAR_23;
            if (VAR_4->expecting > 0 &&
                VAR_35 > VAR_4->expecting) {
              VAR_35                    = VAR_4->expecting;
            }
            if (VAR_4->state == VAR_33) {
              VAR_35                    = httpParsePayload(VAR_4, VAR_23, VAR_7,
                                                        VAR_35 + VAR_23);
            }
            VAR_26                 = VAR_35;
            VAR_25                 = VAR_6 - VAR_23 - VAR_35;
          }
        } else if (VAR_4->state == VAR_36) {
          if (!httpHandleWebSocket(VAR_4, VAR_23, VAR_7, VAR_6)) {
            httpCloseRead(VAR_4);
            break;
          }
          VAR_26                  += VAR_6 - VAR_23;
        } else {
          check(0);
        }

        VAR_23                      += VAR_26;
        if (VAR_25) {
          check(VAR_23 + VAR_25 == VAR_6);
          if (VAR_23 >= 0) {
            check(VAR_4->partial      = realloc(VAR_4->partial, VAR_25));
            memcpy(VAR_4->partial, VAR_7 + VAR_23, VAR_25);
          } else if (VAR_25 != VAR_4->partialLength) {
            char *VAR_37;
            check(VAR_37            = malloc(VAR_25));
            for (int VAR_19 = VAR_23, VAR_20 = 0; VAR_20 < VAR_25; VAR_20++) {
              VAR_37[VAR_20]             = httpGetChar(VAR_4, VAR_7, VAR_6, &VAR_19);
            }
            free(VAR_4->partial);
            VAR_4->partial            = VAR_37;
          }
          VAR_4->partialLength        = VAR_25;
          VAR_23                     = -VAR_25;
          break;
        } else {
          VAR_24                       |= VAR_23 >= VAR_6;
        }
      } while (!VAR_24 && !VAR_4->closed);
      if (VAR_4->closed || VAR_23 >= 0) {
        free(VAR_4->partial);
        VAR_4->partial                = NULL;
        VAR_4->partialLength          = 0;
      } else if (-VAR_23 != VAR_4->partialLength) {
        check(-VAR_23 < VAR_4->partialLength);
        memmove(VAR_4->partial, VAR_4->partial + VAR_4->partialLength + VAR_23,
                -VAR_23);
        VAR_4->partialLength          = -VAR_23;
      }
    }

    /* COMMENT_4 */
    if (VAR_8) {
      check(!VAR_4->partial);
      switch (VAR_4->state) {
      case VAR_16:
      case VAR_22:
        break;
      case VAR_27:
        check(!VAR_4->expecting);
        VAR_4->callback               = NULL;
        VAR_4->arg                    = NULL;
        httpHandleCommand(VAR_4, VAR_5);
        httpCloseRead(VAR_4);
        httpSetState(VAR_4, VAR_22);
        break;
      case VAR_33:
      case VAR_34:
      case VAR_36:
        VAR_4->expecting              = 0;
        httpCloseRead(VAR_4);
        httpSetState(VAR_4, VAR_22);
        break;
      }
    }

    for (;;) {
      /* COMMENT_5 */
      if (VAR_4->msg && VAR_4->msgLength > 0) {
        int VAR_38                    = httpWrite(VAR_4, VAR_4->msg,
                                                 VAR_4->msgLength);
        if (VAR_38 < 0 && VAR_12 != VAR_13) {
          httpCloseRead(VAR_4);
          free(VAR_4->msg);
          VAR_4->msgLength            = 0;
          VAR_4->msg                  = NULL;
          break;
        } else if (VAR_38 > 0) {
          if (VAR_38 == VAR_4->msgLength) {
            free(VAR_4->msg);
            VAR_4->msgLength          = 0;
            VAR_4->msg                = NULL;
          } else {
            memmove(VAR_4->msg, VAR_4->msg + VAR_38, VAR_4->msgLength - VAR_38);
            VAR_4->msgLength         -= VAR_38;
          }
        }
        /* COMMENT_6 */
        else if (VAR_38 < 0 && VAR_12 == VAR_13 && VAR_4->sslHndl) {
          if (VAR_4->lastError == VAR_39 && !VAR_4->closed) {
            *VAR_2                 |= VAR_9;
          }
        }
      }

      /* COMMENT_7 */
      /* COMMENT_8 */
      if (VAR_4->isPartialReply && (!VAR_4->msg || VAR_4->msgLength <= 0)) {
        httpConsumePayload(VAR_4, """", 0);
      } else {
        break;
      }
    }

    *VAR_2                         |=
      (*VAR_2 & ~(VAR_9|VAR_15)) |
      (!VAR_4->closed && ((VAR_4->state != VAR_33 &&
                          VAR_4->state != VAR_34) ||
                         VAR_4->expecting) ? VAR_9 : 0) |
      (VAR_4->msg || VAR_4->isPartialReply ? VAR_15 : 0);

    VAR_0                       = httpGetServerConnection(VAR_4);
    int VAR_40                     = serverGetTimeout(VAR_0) < 0;
    if (VAR_40) {
      free(VAR_4->partial);
      VAR_4->partial                  = NULL;
      VAR_4->partialLength            = 0;
      free(VAR_4->msg);
      VAR_4->msg                      = NULL;
      VAR_4->msgLength                = 0;
    }

    if ((!(*VAR_2 || VAR_4->isSuspended) || VAR_40) && VAR_4->sslHndl) {
      *VAR_2                        = 0;
      serverSetTimeout(VAR_0, 1);
      int VAR_41           = VAR_4->closed;
      httpCloseRead(VAR_4);
      dcheck(!ERR_peek_error());
      sslBlockSigPipe();
      int VAR_42                         = SSL_shutdown(VAR_4->sslHndl);
      switch (VAR_42) {
      case 1:
        sslFreeHndl(&VAR_4->sslHndl);
        break;
      case 0:
        if (!VAR_41) {
          *VAR_2                   |= VAR_9;
        }
        break;
      case -1:
        switch (SSL_get_error(VAR_4->sslHndl, VAR_42)) {
        case VAR_39:
          if (!VAR_41) {
            *VAR_2                 |= VAR_9;
          }
          break;
        case VAR_14:
          *VAR_2                   |= VAR_15;
          break;
        }
        break;
      }
      ERR_clear_error();
      dcheck(!ERR_peek_error());
      if (sslUnblockSigPipe()) {
        *VAR_2                      = 0;
        sslFreeHndl(&VAR_4->sslHndl);
      }
    } else if (!VAR_4->sslHndl && VAR_40) {
      *VAR_2                        = 0;
      serverSetTimeout(VAR_0, 0);
      httpCloseRead(VAR_4);
    }
    VAR_3                          = VAR_9 | VAR_15;
  } while (VAR_6 > 0 && *VAR_2 & VAR_9 && !VAR_4->closed);
  return (*VAR_2 & (VAR_9|VAR_15)) ||
         (!VAR_4->closed && VAR_4->isSuspended);
}",shellinabox/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a/httpconnection.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,6 +72,13 @@
           http->headerLength         = 0;
           *events                   |= POLLIN;
           continue;
+        }
+      } else {
+        if (http->ssl && http->ssl->enabled && http->ssl->force) {
+          debug(""[http] Non-SSL connections not allowed!"");
+          httpCloseRead(http);
+          bytes                      = 0;
+          eof                        = 1;
         }
       }
     }","{'deleted_lines': [], 'added_lines': ['        }', '      } else {', '        if (http->ssl && http->ssl->enabled && http->ssl->force) {', '          debug(""[http] Non-SSL connections not allowed!"");', '          httpCloseRead(http);', '          bytes                      = 0;', '          eof                        = 1;']}",True,"The HTTPS fallback implementation in Shell In A Box (aka shellinabox) before 2.19 makes it easier for remote attackers to conduct DNS rebinding attacks via the ""/plain"" URL.",7.4,HIGH,2,valid,2015-12-03T16:44:31Z,1
CVE-2015-8400,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,shellinabox,"Disable HTTP fallback via ""/plain"" URL (CVE-2015-8400)

* Disabled all methods of HTTP fallback when HTTPS is enabled. This
  is enforced on server side so that even modified client code (JS)
  can not redirect client from HTTPS to HTTP, like it was possible
  before (issue #355).
* Current solution unfortunately also disables automatic upgrade from
  HTTP to HTTPS (when available), since all non-SSL connections are
  droped immediately.",4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a,https://github.com/shellinabox/shellinabox/commit/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a,shellinabox/shellinaboxd.c,setUpSSL,"static void setUpSSL(Server *server) {
serverEnableSSL(server, enableSSL);
if (enableSSL) {
check(serverSupportsSSL());
if (certificateFd >= 0) {
serverSetCertificateFd(server, certificateFd);
} else if (certificateDir) {
char *tmp;
if (strchr(certificateDir, '%')) {
fatal(""[ssl] Invalid certificate directory name \""%s\""."", certificateDir);
}
check(tmp = stringPrintf(NULL, ""%s/certificate%%s.pem"", certificateDir));
serverSetCertificate(server, tmp, 1);
free(tmp);
} else {
serverSetCertificate(server, ""certificate%s.pem"", 1);
}
}
}","static void setUpSSL(Server *VAR_0) {
serverEnableSSL(VAR_0, VAR_1);
if (VAR_1) {
check(serverSupportsSSL());
if (VAR_2 >= 0) {
serverSetCertificateFd(VAR_0, VAR_2);
} else if (VAR_3) {
char *VAR_4;
if (strchr(VAR_3, '%')) {
fatal(""[ssl] Invalid certificate directory name \""%s\""."", VAR_3);
}
check(VAR_4 = stringPrintf(NULL, ""%s/certificate%%s.pem"", VAR_3));
serverSetCertificate(VAR_0, VAR_4, 1);
free(VAR_4);
} else {
serverSetCertificate(VAR_0, ""certificate%s.pem"", 1);
}
}
}",shellinabox/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a/shellinaboxd.c/vul/before/0.json,"static void setUpSSL(Server *server) {

  serverSetupSSL(server, enableSSL, forceSSL);

  // Enable SSL support (if available)
  if (enableSSL) {
    check(serverSupportsSSL());
    if (certificateFd >= 0) {
      serverSetCertificateFd(server, certificateFd);
    } else if (certificateDir) {
      char *tmp;
      if (strchr(certificateDir, '%')) {
        fatal(""[ssl] Invalid certificate directory name \""%s\""."", certificateDir);
      }
      check(tmp = stringPrintf(NULL, ""%s/certificate%%s.pem"", certificateDir));
      serverSetCertificate(server, tmp, 1);
      free(tmp);
    } else {
      serverSetCertificate(server, ""certificate%s.pem"", 1);
    }
  }
}","static void setUpSSL(Server *VAR_0) {

  serverSetupSSL(VAR_0, VAR_1, VAR_2);

  /* COMMENT_0 */
  if (VAR_1) {
    check(serverSupportsSSL());
    if (VAR_3 >= 0) {
      serverSetCertificateFd(VAR_0, VAR_3);
    } else if (VAR_4) {
      char *VAR_5;
      if (strchr(VAR_4, '%')) {
        fatal(""[ssl] Invalid certificate directory name \""%s\""."", VAR_4);
      }
      check(VAR_5 = stringPrintf(NULL, ""%s/certificate%%s.pem"", VAR_4));
      serverSetCertificate(VAR_0, VAR_5, 1);
      free(VAR_5);
    } else {
      serverSetCertificate(VAR_0, ""certificate%s.pem"", 1);
    }
  }
}",shellinabox/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a/shellinaboxd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static void setUpSSL(Server *server) {
-  serverEnableSSL(server, enableSSL);
+
+  serverSetupSSL(server, enableSSL, forceSSL);
 
   // Enable SSL support (if available)
   if (enableSSL) {","{'deleted_lines': ['  serverEnableSSL(server, enableSSL);'], 'added_lines': ['', '  serverSetupSSL(server, enableSSL, forceSSL);']}",True,"The HTTPS fallback implementation in Shell In A Box (aka shellinabox) before 2.19 makes it easier for remote attackers to conduct DNS rebinding attacks via the ""/plain"" URL.",7.4,HIGH,2,valid,2015-12-03T16:44:31Z,1
CVE-2015-8400,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,shellinabox,"Disable HTTP fallback via ""/plain"" URL (CVE-2015-8400)

* Disabled all methods of HTTP fallback when HTTPS is enabled. This
  is enforced on server side so that even modified client code (JS)
  can not redirect client from HTTPS to HTTP, like it was possible
  before (issue #355).
* Current solution unfortunately also disables automatic upgrade from
  HTTP to HTTPS (when available), since all non-SSL connections are
  droped immediately.",4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a,https://github.com/shellinabox/shellinabox/commit/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a,libhttp/ssl.c,initSSL,"void initSSL(struct SSLSupport *ssl) {
ssl->enabled               = serverSupportsSSL();
ssl->sslContext            = NULL;
ssl->sniCertificatePattern = NULL;
ssl->generateMissing       = 0;
ssl->renegotiationCount    = 0;
initTrie(&ssl->sniContexts, sslDestroyCachedContext, ssl);
}","void initSSL(struct SSLSupport *VAR_0) {
VAR_0->enabled               = serverSupportsSSL();
VAR_0->sslContext            = NULL;
VAR_0->sniCertificatePattern = NULL;
VAR_0->generateMissing       = 0;
VAR_0->renegotiationCount    = 0;
initTrie(&VAR_0->sniContexts, VAR_1, VAR_0);
}",shellinabox/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a/ssl.c/vul/before/0.json,"void initSSL(struct SSLSupport *ssl) {
  ssl->enabled               = serverSupportsSSL();
  ssl->force                 = 0;
  ssl->sslContext            = NULL;
  ssl->sniCertificatePattern = NULL;
  ssl->generateMissing       = 0;
  ssl->renegotiationCount    = 0;
  initTrie(&ssl->sniContexts, sslDestroyCachedContext, ssl);
}","void initSSL(struct SSLSupport *VAR_0) {
  VAR_0->enabled               = serverSupportsSSL();
  VAR_0->force                 = 0;
  VAR_0->sslContext            = NULL;
  VAR_0->sniCertificatePattern = NULL;
  VAR_0->generateMissing       = 0;
  VAR_0->renegotiationCount    = 0;
  initTrie(&VAR_0->sniContexts, VAR_1, VAR_0);
}",shellinabox/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a/ssl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 void initSSL(struct SSLSupport *ssl) {
   ssl->enabled               = serverSupportsSSL();
+  ssl->force                 = 0;
   ssl->sslContext            = NULL;
   ssl->sniCertificatePattern = NULL;
   ssl->generateMissing       = 0;","{'deleted_lines': [], 'added_lines': ['  ssl->force                 = 0;']}",True,"The HTTPS fallback implementation in Shell In A Box (aka shellinabox) before 2.19 makes it easier for remote attackers to conduct DNS rebinding attacks via the ""/plain"" URL.",7.4,HIGH,2,valid,2015-12-03T16:44:31Z,1
CVE-2015-8558,['CWE-835'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,qemu,"ehci: make idt processing more robust

Make ehci_process_itd return an error in case we didn't do any actual
iso transfer because we've found no active transaction.  That'll avoid
ehci happily run in circles forever if the guest builds a loop out of
idts.

This is CVE-2015-8558.

Cc: qemu-stable@nongnu.org
Reported-by: Qinghao Tang <luodalongde@gmail.com>
Tested-by: P J P <ppandit@redhat.com>
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>",156a2e4dbffa85997636a7a39ef12da6f1b40254,https://github.com/qemu/qemu/commit/156a2e4dbffa85997636a7a39ef12da6f1b40254,hw/usb/hcd-ehci.c,ehci_process_itd,"static int ehci_process_itd(EHCIState *ehci,
EHCIitd *itd,
uint32_t addr)
{
USBDevice *dev;
USBEndpoint *ep;
uint32_t i, len, pid, dir, devaddr, endp;
uint32_t pg, off, ptr1, ptr2, max, mult;
ehci->periodic_sched_active = PERIODIC_ACTIVE;
dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);
devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);
endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);
max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);
mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);
for(i = 0; i < 8; i++) {
if (itd->transact[i] & ITD_XACT_ACTIVE) {
pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);
off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;
ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);
ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);
len  = get_field(itd->transact[i], ITD_XACT_LENGTH);
if (len > max * mult) {
len = max * mult;
}
if (len > BUFF_SIZE) {
return -1;
}
qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);
if (off + len > 4096) {
uint32_t len2 = off + len - 4096;
uint32_t len1 = len - len2;
qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);
qemu_sglist_add(&ehci->isgl, ptr2, len2);
} else {
qemu_sglist_add(&ehci->isgl, ptr1 + off, len);
}
pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;
dev = ehci_find_device(ehci, devaddr);
ep = usb_ep_get(dev, pid, endp);
if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {
usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,
(itd->transact[i] & ITD_XACT_IOC) != 0);
usb_packet_map(&ehci->ipacket, &ehci->isgl);
usb_handle_packet(dev, &ehci->ipacket);
usb_packet_unmap(&ehci->ipacket, &ehci->isgl);
} else {
DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
ehci->ipacket.status = USB_RET_NAK;
ehci->ipacket.actual_length = 0;
}
qemu_sglist_destroy(&ehci->isgl);
switch (ehci->ipacket.status) {
case USB_RET_SUCCESS:
break;
default:
fprintf(stderr, ""Unexpected iso usb result: %d\n"",
ehci->ipacket.status);
case USB_RET_IOERROR:
case USB_RET_NODEV:
if (dir) {
itd->transact[i] |= ITD_XACT_XACTERR;
ehci_raise_irq(ehci, USBSTS_ERRINT);
}
break;
case USB_RET_BABBLE:
itd->transact[i] |= ITD_XACT_BABBLE;
ehci_raise_irq(ehci, USBSTS_ERRINT);
break;
case USB_RET_NAK:
ehci->ipacket.actual_length = 0;
break;
}
if (!dir) {
set_field(&itd->transact[i], len - ehci->ipacket.actual_length,
ITD_XACT_LENGTH); 
} else {
set_field(&itd->transact[i], ehci->ipacket.actual_length,
ITD_XACT_LENGTH); 
}
if (itd->transact[i] & ITD_XACT_IOC) {
ehci_raise_irq(ehci, USBSTS_INT);
}
itd->transact[i] &= ~ITD_XACT_ACTIVE;
}
}
return 0;
}","static int ehci_process_itd(EHCIState *VAR_0,
EHCIitd *VAR_1,
uint32_t VAR_2)
{
USBDevice *VAR_3;
USBEndpoint *VAR_4;
uint32_t VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
uint32_t VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
VAR_0->periodic_sched_active = VAR_17;
VAR_8 =(VAR_1->bufptr[1] & VAR_18);
VAR_9 = get_field(VAR_1->bufptr[0], VAR_19);
VAR_10 = get_field(VAR_1->bufptr[0], VAR_20);
VAR_15 = get_field(VAR_1->bufptr[1], VAR_21);
VAR_16 = get_field(VAR_1->bufptr[2], VAR_22);
for(VAR_5 = 0; VAR_5 < 8; VAR_5++) {
if (VAR_1->transact[VAR_5] & VAR_23) {
VAR_11   = get_field(VAR_1->transact[VAR_5], VAR_24);
VAR_12  = VAR_1->transact[VAR_5] & VAR_25;
VAR_13 = (VAR_1->bufptr[VAR_11] & VAR_26);
VAR_14 = (VAR_1->bufptr[VAR_11+1] & VAR_26);
VAR_6  = get_field(VAR_1->transact[VAR_5], VAR_27);
if (VAR_6 > VAR_15 * VAR_16) {
VAR_6 = VAR_15 * VAR_16;
}
if (VAR_6 > VAR_28) {
return -1;
}
qemu_sglist_init(&VAR_0->isgl, VAR_0->device, 2, VAR_0->as);
if (VAR_12 + VAR_6 > 4096) {
uint32_t VAR_29 = VAR_12 + VAR_6 - 4096;
uint32_t VAR_30 = VAR_6 - VAR_29;
qemu_sglist_add(&VAR_0->isgl, VAR_13 + VAR_12, VAR_30);
qemu_sglist_add(&VAR_0->isgl, VAR_14, VAR_29);
} else {
qemu_sglist_add(&VAR_0->isgl, VAR_13 + VAR_12, VAR_6);
}
VAR_7 = VAR_8 ? VAR_31 : VAR_32;
VAR_3 = ehci_find_device(VAR_0, VAR_9);
VAR_4 = usb_ep_get(VAR_3, VAR_7, VAR_10);
if (VAR_4 && VAR_4->type == VAR_33) {
usb_packet_setup(&VAR_0->ipacket, VAR_7, VAR_4, 0, VAR_2, false,
(VAR_1->transact[VAR_5] & VAR_34) != 0);
usb_packet_map(&VAR_0->ipacket, &VAR_0->isgl);
usb_handle_packet(VAR_3, &VAR_0->ipacket);
usb_packet_unmap(&VAR_0->ipacket, &VAR_0->isgl);
} else {
DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
VAR_0->ipacket.status = VAR_35;
VAR_0->ipacket.actual_length = 0;
}
qemu_sglist_destroy(&VAR_0->isgl);
switch (VAR_0->ipacket.status) {
case VAR_36:
break;
default:
fprintf(VAR_37, ""Unexpected iso usb result: %d\n"",
VAR_0->ipacket.status);
case VAR_38:
case VAR_39:
if (VAR_8) {
VAR_1->transact[VAR_5] |= VAR_40;
ehci_raise_irq(VAR_0, VAR_41);
}
break;
case VAR_42:
VAR_1->transact[VAR_5] |= VAR_43;
ehci_raise_irq(VAR_0, VAR_41);
break;
case VAR_35:
VAR_0->ipacket.actual_length = 0;
break;
}
if (!VAR_8) {
set_field(&VAR_1->transact[VAR_5], VAR_6 - VAR_0->ipacket.actual_length,
VAR_27); 
} else {
set_field(&VAR_1->transact[VAR_5], VAR_0->ipacket.actual_length,
VAR_27); 
}
if (VAR_1->transact[VAR_5] & VAR_34) {
ehci_raise_irq(VAR_0, VAR_44);
}
VAR_1->transact[VAR_5] &= ~VAR_23;
}
}
return 0;
}",qemu/156a2e4dbffa85997636a7a39ef12da6f1b40254/hcd-ehci.c/vul/before/0.json,"static int ehci_process_itd(EHCIState *ehci,
                            EHCIitd *itd,
                            uint32_t addr)
{
    USBDevice *dev;
    USBEndpoint *ep;
    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;
    uint32_t pg, off, ptr1, ptr2, max, mult;

    ehci->periodic_sched_active = PERIODIC_ACTIVE;

    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);
    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);
    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);
    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);
    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);

    for(i = 0; i < 8; i++) {
        if (itd->transact[i] & ITD_XACT_ACTIVE) {
            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);
            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;
            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);
            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);
            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);

            if (len > max * mult) {
                len = max * mult;
            }

            if (len > BUFF_SIZE) {
                return -1;
            }

            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);
            if (off + len > 4096) {
                /* transfer crosses page border */
                uint32_t len2 = off + len - 4096;
                uint32_t len1 = len - len2;
                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);
                qemu_sglist_add(&ehci->isgl, ptr2, len2);
            } else {
                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);
            }

            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;

            dev = ehci_find_device(ehci, devaddr);
            ep = usb_ep_get(dev, pid, endp);
            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {
                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,
                                 (itd->transact[i] & ITD_XACT_IOC) != 0);
                usb_packet_map(&ehci->ipacket, &ehci->isgl);
                usb_handle_packet(dev, &ehci->ipacket);
                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);
            } else {
                DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
                ehci->ipacket.status = USB_RET_NAK;
                ehci->ipacket.actual_length = 0;
            }
            qemu_sglist_destroy(&ehci->isgl);

            switch (ehci->ipacket.status) {
            case USB_RET_SUCCESS:
                break;
            default:
                fprintf(stderr, ""Unexpected iso usb result: %d\n"",
                        ehci->ipacket.status);
                /* Fall through */
            case USB_RET_IOERROR:
            case USB_RET_NODEV:
                /* 3.3.2: XACTERR is only allowed on IN transactions */
                if (dir) {
                    itd->transact[i] |= ITD_XACT_XACTERR;
                    ehci_raise_irq(ehci, USBSTS_ERRINT);
                }
                break;
            case USB_RET_BABBLE:
                itd->transact[i] |= ITD_XACT_BABBLE;
                ehci_raise_irq(ehci, USBSTS_ERRINT);
                break;
            case USB_RET_NAK:
                /* no data for us, so do a zero-length transfer */
                ehci->ipacket.actual_length = 0;
                break;
            }
            if (!dir) {
                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,
                          ITD_XACT_LENGTH); /* OUT */
            } else {
                set_field(&itd->transact[i], ehci->ipacket.actual_length,
                          ITD_XACT_LENGTH); /* IN */
            }
            if (itd->transact[i] & ITD_XACT_IOC) {
                ehci_raise_irq(ehci, USBSTS_INT);
            }
            itd->transact[i] &= ~ITD_XACT_ACTIVE;
            xfers++;
        }
    }
    return xfers ? 0 : -1;
}","static int ehci_process_itd(EHCIState *VAR_0,
                            EHCIitd *VAR_1,
                            uint32_t VAR_2)
{
    USBDevice *VAR_3;
    USBEndpoint *VAR_4;
    uint32_t VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11 = 0;
    uint32_t VAR_12, VAR_13, VAR_14, VAR_15, VAR_16, VAR_17;

    VAR_0->periodic_sched_active = VAR_18;

    VAR_8 =(VAR_1->bufptr[1] & VAR_19);
    VAR_9 = get_field(VAR_1->bufptr[0], VAR_20);
    VAR_10 = get_field(VAR_1->bufptr[0], VAR_21);
    VAR_16 = get_field(VAR_1->bufptr[1], VAR_22);
    VAR_17 = get_field(VAR_1->bufptr[2], VAR_23);

    for(VAR_5 = 0; VAR_5 < 8; VAR_5++) {
        if (VAR_1->transact[VAR_5] & VAR_24) {
            VAR_12   = get_field(VAR_1->transact[VAR_5], VAR_25);
            VAR_13  = VAR_1->transact[VAR_5] & VAR_26;
            VAR_14 = (VAR_1->bufptr[VAR_12] & VAR_27);
            VAR_15 = (VAR_1->bufptr[VAR_12+1] & VAR_27);
            VAR_6  = get_field(VAR_1->transact[VAR_5], VAR_28);

            if (VAR_6 > VAR_16 * VAR_17) {
                VAR_6 = VAR_16 * VAR_17;
            }

            if (VAR_6 > VAR_29) {
                return -1;
            }

            qemu_sglist_init(&VAR_0->isgl, VAR_0->device, 2, VAR_0->as);
            if (VAR_13 + VAR_6 > 4096) {
                /* COMMENT_0 */
                uint32_t VAR_30 = VAR_13 + VAR_6 - 4096;
                uint32_t VAR_31 = VAR_6 - VAR_30;
                qemu_sglist_add(&VAR_0->isgl, VAR_14 + VAR_13, VAR_31);
                qemu_sglist_add(&VAR_0->isgl, VAR_15, VAR_30);
            } else {
                qemu_sglist_add(&VAR_0->isgl, VAR_14 + VAR_13, VAR_6);
            }

            VAR_7 = VAR_8 ? VAR_32 : VAR_33;

            VAR_3 = ehci_find_device(VAR_0, VAR_9);
            VAR_4 = usb_ep_get(VAR_3, VAR_7, VAR_10);
            if (VAR_4 && VAR_4->type == VAR_34) {
                usb_packet_setup(&VAR_0->ipacket, VAR_7, VAR_4, 0, VAR_2, false,
                                 (VAR_1->transact[VAR_5] & VAR_35) != 0);
                usb_packet_map(&VAR_0->ipacket, &VAR_0->isgl);
                usb_handle_packet(VAR_3, &VAR_0->ipacket);
                usb_packet_unmap(&VAR_0->ipacket, &VAR_0->isgl);
            } else {
                DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
                VAR_0->ipacket.status = VAR_36;
                VAR_0->ipacket.actual_length = 0;
            }
            qemu_sglist_destroy(&VAR_0->isgl);

            switch (VAR_0->ipacket.status) {
            case VAR_37:
                break;
            default:
                fprintf(VAR_38, ""Unexpected iso usb result: %d\n"",
                        VAR_0->ipacket.status);
                /* COMMENT_1 */
            case VAR_39:
            case VAR_40:
                /* COMMENT_2 */
                if (VAR_8) {
                    VAR_1->transact[VAR_5] |= VAR_41;
                    ehci_raise_irq(VAR_0, VAR_42);
                }
                break;
            case VAR_43:
                VAR_1->transact[VAR_5] |= VAR_44;
                ehci_raise_irq(VAR_0, VAR_42);
                break;
            case VAR_36:
                /* COMMENT_3 */
                VAR_0->ipacket.actual_length = 0;
                break;
            }
            if (!VAR_8) {
                set_field(&VAR_1->transact[VAR_5], VAR_6 - VAR_0->ipacket.actual_length,
                          VAR_28); /* COMMENT_4 */
            } else {
                set_field(&VAR_1->transact[VAR_5], VAR_0->ipacket.actual_length,
                          VAR_28); /* COMMENT_5 */
            }
            if (VAR_1->transact[VAR_5] & VAR_35) {
                ehci_raise_irq(VAR_0, VAR_45);
            }
            VAR_1->transact[VAR_5] &= ~VAR_24;
            VAR_11++;
        }
    }
    return VAR_11 ? 0 : -1;
}",qemu/156a2e4dbffa85997636a7a39ef12da6f1b40254/hcd-ehci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 {
     USBDevice *dev;
     USBEndpoint *ep;
-    uint32_t i, len, pid, dir, devaddr, endp;
+    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;
     uint32_t pg, off, ptr1, ptr2, max, mult;
 
     ehci->periodic_sched_active = PERIODIC_ACTIVE;
@@ -94,7 +94,8 @@
                 ehci_raise_irq(ehci, USBSTS_INT);
             }
             itd->transact[i] &= ~ITD_XACT_ACTIVE;
+            xfers++;
         }
     }
-    return 0;
+    return xfers ? 0 : -1;
 }","{'deleted_lines': ['    uint32_t i, len, pid, dir, devaddr, endp;', '    return 0;'], 'added_lines': ['    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;', '            xfers++;', '    return xfers ? 0 : -1;']}",True,The ehci_process_itd function in hw/usb/hcd-ehci.c in QEMU allows local guest OS administrators to cause a denial of service (infinite loop and CPU consumption) via a circular isochronous transfer descriptor (iTD) list.,5.5,MEDIUM,1,valid,2015-12-14T08:21:23Z,1
CVE-2015-8569,['CWE-200'],AV:L/AC:M/Au:N/C:P/I:N/A:N,0,torvalds/linux,"pptp: verify sockaddr_len in pptp_bind() and pptp_connect()

Reported-by: Dmitry Vyukov <dvyukov@gmail.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",09ccfd238e5a0e670d8178cf50180ea81ae09ae1,https://github.com/torvalds/linux/commit/09ccfd238e5a0e670d8178cf50180ea81ae09ae1,drivers/net/ppp/pptp.c,pptp_connect,"static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,
int sockaddr_len, int flags)
{
struct sock *sk = sock->sk;
struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;
struct pppox_sock *po = pppox_sk(sk);
struct pptp_opt *opt = &po->proto.pptp;
struct rtable *rt;
struct flowi4 fl4;
int error = 0;
if (sp->sa_protocol != PX_PROTO_PPTP)
return -EINVAL;
if (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))
return -EALREADY;
lock_sock(sk);
if (sk->sk_state & PPPOX_CONNECTED) {
error = -EBUSY;
goto end;
}
if (sk->sk_state & PPPOX_DEAD) {
error = -EALREADY;
goto end;
}
if (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {
error = -EINVAL;
goto end;
}
po->chan.private = sk;
po->chan.ops = &pptp_chan_ops;
rt = ip_route_output_ports(sock_net(sk), &fl4, sk,
opt->dst_addr.sin_addr.s_addr,
opt->src_addr.sin_addr.s_addr,
0, 0,
IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);
if (IS_ERR(rt)) {
error = -EHOSTUNREACH;
goto end;
}
sk_setup_caps(sk, &rt->dst);
po->chan.mtu = dst_mtu(&rt->dst);
if (!po->chan.mtu)
po->chan.mtu = PPP_MRU;
ip_rt_put(rt);
po->chan.mtu -= PPTP_HEADER_OVERHEAD;
po->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);
error = ppp_register_channel(&po->chan);
if (error) {
pr_err(""PPTP: failed to register PPP channel (%d)\n"", error);
goto end;
}
opt->dst_addr = sp->sa_addr.pptp;
sk->sk_state = PPPOX_CONNECTED;
end:
release_sock(sk);
return error;
}","static int pptp_connect(struct socket *VAR_0, struct sockaddr *VAR_1,
int VAR_2, int VAR_3)
{
struct sock *VAR_4 = sock->sk;
struct sockaddr_pppox *VAR_5 = (struct sockaddr_pppox *) VAR_1;
struct pppox_sock *VAR_6 = pppox_sk(VAR_4);
struct pptp_opt *VAR_7 = &VAR_6->proto.pptp;
struct rtable *VAR_8;
struct flowi4 VAR_9;
int VAR_10 = 0;
if (VAR_5->sa_protocol != VAR_11)
return -VAR_12;
if (lookup_chan_dst(VAR_5->sa_addr.pptp.call_id, VAR_5->sa_addr.pptp.sin_addr.s_addr))
return -VAR_13;
lock_sock(VAR_4);
if (VAR_4->sk_state & VAR_14) {
VAR_10 = -VAR_15;
goto end;
}
if (VAR_4->sk_state & VAR_16) {
VAR_10 = -VAR_13;
goto end;
}
if (!VAR_7->src_addr.sin_addr.s_addr || !VAR_5->sa_addr.pptp.sin_addr.s_addr) {
VAR_10 = -VAR_12;
goto end;
}
VAR_6->chan.private = VAR_4;
VAR_6->chan.ops = &VAR_17;
VAR_8 = ip_route_output_ports(sock_net(VAR_4), &VAR_9, VAR_4,
VAR_7->dst_addr.sin_addr.s_addr,
VAR_7->src_addr.sin_addr.s_addr,
0, 0,
VAR_18, RT_CONN_FLAGS(VAR_4), 0);
if (IS_ERR(VAR_8)) {
VAR_10 = -VAR_19;
goto end;
}
sk_setup_caps(VAR_4, &VAR_8->dst);
VAR_6->chan.mtu = dst_mtu(&VAR_8->dst);
if (!VAR_6->chan.mtu)
VAR_6->chan.mtu = VAR_20;
ip_rt_put(VAR_8);
VAR_6->chan.mtu -= VAR_21;
VAR_6->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);
VAR_10 = ppp_register_channel(&VAR_6->chan);
if (VAR_10) {
pr_err(""PPTP: failed to register PPP channel (%d)\n"", VAR_10);
goto end;
}
VAR_7->dst_addr = VAR_5->sa_addr.pptp;
VAR_4->sk_state = VAR_14;
end:
release_sock(VAR_4);
return VAR_10;
}",torvalds/linux/09ccfd238e5a0e670d8178cf50180ea81ae09ae1/pptp.c/vul/before/0.json,"static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,
	int sockaddr_len, int flags)
{
	struct sock *sk = sock->sk;
	struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;
	struct pppox_sock *po = pppox_sk(sk);
	struct pptp_opt *opt = &po->proto.pptp;
	struct rtable *rt;
	struct flowi4 fl4;
	int error = 0;

	if (sockaddr_len < sizeof(struct sockaddr_pppox))
		return -EINVAL;

	if (sp->sa_protocol != PX_PROTO_PPTP)
		return -EINVAL;

	if (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))
		return -EALREADY;

	lock_sock(sk);
	/* Check for already bound sockets */
	if (sk->sk_state & PPPOX_CONNECTED) {
		error = -EBUSY;
		goto end;
	}

	/* Check for already disconnected sockets, on attempts to disconnect */
	if (sk->sk_state & PPPOX_DEAD) {
		error = -EALREADY;
		goto end;
	}

	if (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {
		error = -EINVAL;
		goto end;
	}

	po->chan.private = sk;
	po->chan.ops = &pptp_chan_ops;

	rt = ip_route_output_ports(sock_net(sk), &fl4, sk,
				   opt->dst_addr.sin_addr.s_addr,
				   opt->src_addr.sin_addr.s_addr,
				   0, 0,
				   IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);
	if (IS_ERR(rt)) {
		error = -EHOSTUNREACH;
		goto end;
	}
	sk_setup_caps(sk, &rt->dst);

	po->chan.mtu = dst_mtu(&rt->dst);
	if (!po->chan.mtu)
		po->chan.mtu = PPP_MRU;
	ip_rt_put(rt);
	po->chan.mtu -= PPTP_HEADER_OVERHEAD;

	po->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);
	error = ppp_register_channel(&po->chan);
	if (error) {
		pr_err(""PPTP: failed to register PPP channel (%d)\n"", error);
		goto end;
	}

	opt->dst_addr = sp->sa_addr.pptp;
	sk->sk_state = PPPOX_CONNECTED;

 end:
	release_sock(sk);
	return error;
}","static int pptp_connect(struct socket *VAR_0, struct sockaddr *VAR_1,
	int VAR_2, int VAR_3)
{
	struct sock *VAR_4 = sock->sk;
	struct sockaddr_pppox *VAR_5 = (struct sockaddr_pppox *) VAR_1;
	struct pppox_sock *VAR_6 = pppox_sk(VAR_4);
	struct pptp_opt *VAR_7 = &VAR_6->proto.pptp;
	struct rtable *VAR_8;
	struct flowi4 VAR_9;
	int VAR_10 = 0;

	if (VAR_2 < sizeof(struct sockaddr_pppox))
		return -VAR_11;

	if (VAR_5->sa_protocol != VAR_12)
		return -VAR_11;

	if (lookup_chan_dst(VAR_5->sa_addr.pptp.call_id, VAR_5->sa_addr.pptp.sin_addr.s_addr))
		return -VAR_13;

	lock_sock(VAR_4);
	/* COMMENT_0 */
	if (VAR_4->sk_state & VAR_14) {
		VAR_10 = -VAR_15;
		goto end;
	}

	/* COMMENT_1 */
	if (VAR_4->sk_state & VAR_16) {
		VAR_10 = -VAR_13;
		goto end;
	}

	if (!VAR_7->src_addr.sin_addr.s_addr || !VAR_5->sa_addr.pptp.sin_addr.s_addr) {
		VAR_10 = -VAR_11;
		goto end;
	}

	VAR_6->chan.private = VAR_4;
	VAR_6->chan.ops = &VAR_17;

	VAR_8 = ip_route_output_ports(sock_net(VAR_4), &VAR_9, VAR_4,
				   VAR_7->dst_addr.sin_addr.s_addr,
				   VAR_7->src_addr.sin_addr.s_addr,
				   0, 0,
				   VAR_18, RT_CONN_FLAGS(VAR_4), 0);
	if (IS_ERR(VAR_8)) {
		VAR_10 = -VAR_19;
		goto end;
	}
	sk_setup_caps(VAR_4, &VAR_8->dst);

	VAR_6->chan.mtu = dst_mtu(&VAR_8->dst);
	if (!VAR_6->chan.mtu)
		VAR_6->chan.mtu = VAR_20;
	ip_rt_put(VAR_8);
	VAR_6->chan.mtu -= VAR_21;

	VAR_6->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);
	VAR_10 = ppp_register_channel(&VAR_6->chan);
	if (VAR_10) {
		pr_err(""PPTP: failed to register PPP channel (%d)\n"", VAR_10);
		goto end;
	}

	VAR_7->dst_addr = VAR_5->sa_addr.pptp;
	VAR_4->sk_state = VAR_14;

 end:
	release_sock(VAR_4);
	return VAR_10;
}",torvalds/linux/09ccfd238e5a0e670d8178cf50180ea81ae09ae1/pptp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
 	struct rtable *rt;
 	struct flowi4 fl4;
 	int error = 0;
+
+	if (sockaddr_len < sizeof(struct sockaddr_pppox))
+		return -EINVAL;
 
 	if (sp->sa_protocol != PX_PROTO_PPTP)
 		return -EINVAL;","{'deleted_lines': [], 'added_lines': ['', '\tif (sockaddr_len < sizeof(struct sockaddr_pppox))', '\t\treturn -EINVAL;']}",True,"The (1) pptp_bind and (2) pptp_connect functions in drivers/net/ppp/pptp.c in the Linux kernel through 4.3.3 do not verify an address length, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism via a crafted application.",2.3,LOW,0,valid,2015-12-14T21:48:36Z,1
CVE-2015-8569,['CWE-200'],AV:L/AC:M/Au:N/C:P/I:N/A:N,0,torvalds/linux,"pptp: verify sockaddr_len in pptp_bind() and pptp_connect()

Reported-by: Dmitry Vyukov <dvyukov@gmail.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",09ccfd238e5a0e670d8178cf50180ea81ae09ae1,https://github.com/torvalds/linux/commit/09ccfd238e5a0e670d8178cf50180ea81ae09ae1,drivers/net/ppp/pptp.c,pptp_bind,"static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,
int sockaddr_len)
{
struct sock *sk = sock->sk;
struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;
struct pppox_sock *po = pppox_sk(sk);
struct pptp_opt *opt = &po->proto.pptp;
int error = 0;
lock_sock(sk);
opt->src_addr = sp->sa_addr.pptp;
if (add_chan(po))
error = -EBUSY;
release_sock(sk);
return error;
}","static int pptp_bind(struct socket *VAR_0, struct sockaddr *VAR_1,
int VAR_2)
{
struct sock *VAR_3 = sock->sk;
struct sockaddr_pppox *VAR_4 = (struct sockaddr_pppox *) VAR_1;
struct pppox_sock *VAR_5 = pppox_sk(VAR_3);
struct pptp_opt *VAR_6 = &VAR_5->proto.pptp;
int VAR_7 = 0;
lock_sock(VAR_3);
VAR_6->src_addr = VAR_4->sa_addr.pptp;
if (add_chan(VAR_5))
VAR_7 = -VAR_8;
release_sock(VAR_3);
return VAR_7;
}",torvalds/linux/09ccfd238e5a0e670d8178cf50180ea81ae09ae1/pptp.c/vul/before/1.json,"static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,
	int sockaddr_len)
{
	struct sock *sk = sock->sk;
	struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;
	struct pppox_sock *po = pppox_sk(sk);
	struct pptp_opt *opt = &po->proto.pptp;
	int error = 0;

	if (sockaddr_len < sizeof(struct sockaddr_pppox))
		return -EINVAL;

	lock_sock(sk);

	opt->src_addr = sp->sa_addr.pptp;
	if (add_chan(po))
		error = -EBUSY;

	release_sock(sk);
	return error;
}","static int pptp_bind(struct socket *VAR_0, struct sockaddr *VAR_1,
	int VAR_2)
{
	struct sock *VAR_3 = sock->sk;
	struct sockaddr_pppox *VAR_4 = (struct sockaddr_pppox *) VAR_1;
	struct pppox_sock *VAR_5 = pppox_sk(VAR_3);
	struct pptp_opt *VAR_6 = &VAR_5->proto.pptp;
	int VAR_7 = 0;

	if (VAR_2 < sizeof(struct sockaddr_pppox))
		return -VAR_8;

	lock_sock(VAR_3);

	VAR_6->src_addr = VAR_4->sa_addr.pptp;
	if (add_chan(VAR_5))
		VAR_7 = -VAR_9;

	release_sock(VAR_3);
	return VAR_7;
}",torvalds/linux/09ccfd238e5a0e670d8178cf50180ea81ae09ae1/pptp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,9 @@
 	struct pppox_sock *po = pppox_sk(sk);
 	struct pptp_opt *opt = &po->proto.pptp;
 	int error = 0;
+
+	if (sockaddr_len < sizeof(struct sockaddr_pppox))
+		return -EINVAL;
 
 	lock_sock(sk);
 ","{'deleted_lines': [], 'added_lines': ['', '\tif (sockaddr_len < sizeof(struct sockaddr_pppox))', '\t\treturn -EINVAL;']}",True,"The (1) pptp_bind and (2) pptp_connect functions in drivers/net/ppp/pptp.c in the Linux kernel through 4.3.3 do not verify an address length, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism via a crafted application.",2.3,LOW,0,valid,2015-12-14T21:48:36Z,1
CVE-2016-1568,['CWE-416'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,qemu,"ide: ahci: reset ncq object to unused on error

When processing NCQ commands, AHCI device emulation prepares a
NCQ transfer object; To which an aio control block(aiocb) object
is assigned in 'execute_ncq_command'. In case, when the NCQ
command is invalid, the 'aiocb' object is not assigned, and NCQ
transfer object is left as 'used'. This leads to a use after
free kind of error in 'bdrv_aio_cancel_async' via 'ahci_reset_port'.
Reset NCQ transfer object to 'unused' to avoid it.

[Maintainer edit: s/ACHI/AHCI/ in the commit message. --js]

Reported-by: Qinghao Tang <luodalongde@gmail.com>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
Reviewed-by: John Snow <jsnow@redhat.com>
Message-id: 1452282511-4116-1-git-send-email-ppandit@redhat.com
Signed-off-by: John Snow <jsnow@redhat.com>",4ab0359a8ae182a7ac5c99609667273167703fab,https://github.com/qemu/qemu/commit/4ab0359a8ae182a7ac5c99609667273167703fab,hw/ide/ahci.c,ncq_err,"static void ncq_err(NCQTransferState *ncq_tfs)
{
IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];
ide_state->error = ABRT_ERR;
ide_state->status = READY_STAT | ERR_STAT;
ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);
}","static void ncq_err(NCQTransferState *VAR_0)
{
IDEState *VAR_1 = &VAR_0->drive->port.ifs[0];
VAR_1->error = VAR_2;
VAR_1->status = VAR_3 | VAR_4;
VAR_0->drive->port_regs.scr_err |= (1 << VAR_0->tag);
}",qemu/4ab0359a8ae182a7ac5c99609667273167703fab/ahci.c/vul/before/0.json,"static void ncq_err(NCQTransferState *ncq_tfs)
{
    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];

    ide_state->error = ABRT_ERR;
    ide_state->status = READY_STAT | ERR_STAT;
    ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);
    ncq_tfs->used = 0;
}","static void ncq_err(NCQTransferState *VAR_0)
{
    IDEState *VAR_1 = &VAR_0->drive->port.ifs[0];

    VAR_1->error = VAR_2;
    VAR_1->status = VAR_3 | VAR_4;
    VAR_0->drive->port_regs.scr_err |= (1 << VAR_0->tag);
    VAR_0->used = 0;
}",qemu/4ab0359a8ae182a7ac5c99609667273167703fab/ahci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,4 +5,5 @@
     ide_state->error = ABRT_ERR;
     ide_state->status = READY_STAT | ERR_STAT;
     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);
+    ncq_tfs->used = 0;
 }","{'deleted_lines': [], 'added_lines': ['    ncq_tfs->used = 0;']}",True,"Use-after-free vulnerability in hw/ide/ahci.c in QEMU, when built with IDE AHCI Emulation support, allows guest OS users to cause a denial of service (instance crash) or possibly execute arbitrary code via an invalid AHCI Native Command Queuing (NCQ) AIO command.",8.8,HIGH,2,valid,2016-01-11T19:10:42Z,1
CVE-2016-2782,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"USB: visor: fix null-deref at probe

Fix null-pointer dereference at probe should a (malicious) Treo device
lack the expected endpoints.

Specifically, the Treo port-setup hack was dereferencing the bulk-in and
interrupt-in urbs without first making sure they had been allocated by
core.

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Johan Hovold <johan@kernel.org>",cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,https://github.com/torvalds/linux/commit/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0,drivers/usb/serial/visor.c,treo_attach,"static int treo_attach(struct usb_serial *serial)
{
struct usb_serial_port *swap_port;
if (!((le16_to_cpu(serial->dev->descriptor.idVendor)
== HANDSPRING_VENDOR_ID) ||
(le16_to_cpu(serial->dev->descriptor.idVendor)
== KYOCERA_VENDOR_ID)) ||
(serial->num_interrupt_in == 0))
return 0;
#define COPY_PORT(dest, src)\
do { \
int i;\
\
for (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\
dest->read_urbs[i] = src->read_urbs[i];\
dest->read_urbs[i]->context = dest;\
dest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \
}\
dest->read_urb = src->read_urb;\
dest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\
dest->bulk_in_buffer = src->bulk_in_buffer;\
dest->bulk_in_size = src->bulk_in_size;\
dest->interrupt_in_urb = src->interrupt_in_urb;\
dest->interrupt_in_urb->context = dest;\
dest->interrupt_in_endpointAddress = \
src->interrupt_in_endpointAddress;\
dest->interrupt_in_buffer = src->interrupt_in_buffer;\
} while (0);
swap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);
if (!swap_port)
return -ENOMEM;
COPY_PORT(swap_port, serial->port[0]);
COPY_PORT(serial->port[0], serial->port[1]);
COPY_PORT(serial->port[1], swap_port);
kfree(swap_port);
return 0;
}","static int treo_attach(struct usb_serial *VAR_0)
{
struct usb_serial_port *VAR_1;
if (!((le16_to_cpu(VAR_0->dev->descriptor.idVendor)
== VAR_2) ||
(le16_to_cpu(VAR_0->dev->descriptor.idVendor)
== VAR_3)) ||
(VAR_0->num_interrupt_in == 0))
return 0;
#define COPY_PORT(VAR_4, VAR_5)\
do { \
int i;\
\
for (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\
dest->read_urbs[i] = src->read_urbs[i];\
dest->read_urbs[i]->context = dest;\
dest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \
}\
dest->read_urb = src->read_urb;\
dest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\
dest->bulk_in_buffer = src->bulk_in_buffer;\
dest->bulk_in_size = src->bulk_in_size;\
dest->interrupt_in_urb = src->interrupt_in_urb;\
dest->interrupt_in_urb->context = dest;\
dest->interrupt_in_endpointAddress = \
src->interrupt_in_endpointAddress;\
dest->interrupt_in_buffer = src->interrupt_in_buffer;\
} while (0);
VAR_1 = kmalloc(sizeof(*VAR_1), VAR_6);
if (!VAR_1)
return -VAR_7;
COPY_PORT(VAR_1, VAR_0->port[0]);
COPY_PORT(VAR_0->port[0], VAR_0->port[1]);
COPY_PORT(VAR_0->port[1], VAR_1);
kfree(VAR_1);
return 0;
}",torvalds/linux/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0/visor.c/vul/before/0.json,"static int treo_attach(struct usb_serial *serial)
{
	struct usb_serial_port *swap_port;

	/* Only do this endpoint hack for the Handspring devices with
	 * interrupt in endpoints, which for now are the Treo devices. */
	if (!((le16_to_cpu(serial->dev->descriptor.idVendor)
						== HANDSPRING_VENDOR_ID) ||
		(le16_to_cpu(serial->dev->descriptor.idVendor)
						== KYOCERA_VENDOR_ID)) ||
		(serial->num_interrupt_in == 0))
		return 0;

	if (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {
		dev_err(&serial->interface->dev, ""missing endpoints\n"");
		return -ENODEV;
	}

	/*
	* It appears that Treos and Kyoceras want to use the
	* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,
	* so let's swap the 1st and 2nd bulk in and interrupt endpoints.
	* Note that swapping the bulk out endpoints would break lots of
	* apps that want to communicate on the second port.
	*/
#define COPY_PORT(dest, src)						\
	do { \
		int i;							\
									\
		for (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {	\
			dest->read_urbs[i] = src->read_urbs[i];		\
			dest->read_urbs[i]->context = dest;		\
			dest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \
		}							\
		dest->read_urb = src->read_urb;				\
		dest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\
		dest->bulk_in_buffer = src->bulk_in_buffer;		\
		dest->bulk_in_size = src->bulk_in_size;			\
		dest->interrupt_in_urb = src->interrupt_in_urb;		\
		dest->interrupt_in_urb->context = dest;			\
		dest->interrupt_in_endpointAddress = \
					src->interrupt_in_endpointAddress;\
		dest->interrupt_in_buffer = src->interrupt_in_buffer;	\
	} while (0);

	swap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);
	if (!swap_port)
		return -ENOMEM;
	COPY_PORT(swap_port, serial->port[0]);
	COPY_PORT(serial->port[0], serial->port[1]);
	COPY_PORT(serial->port[1], swap_port);
	kfree(swap_port);

	return 0;
}","static int treo_attach(struct usb_serial *VAR_0)
{
	struct usb_serial_port *VAR_1;

	/* COMMENT_0 */
                                                                  
	if (!((le16_to_cpu(VAR_0->dev->descriptor.idVendor)
						== VAR_2) ||
		(le16_to_cpu(VAR_0->dev->descriptor.idVendor)
						== VAR_3)) ||
		(VAR_0->num_interrupt_in == 0))
		return 0;

	if (VAR_0->num_bulk_in < 2 || VAR_0->num_interrupt_in < 2) {
		dev_err(&VAR_0->interface->dev, ""missing endpoints\n"");
		return -VAR_4;
	}

	/* COMMENT_2 */
                                                     
                                                                      
                                                                 
                                                                
                                                    
   
#define COPY_PORT(VAR_5, VAR_6)						\
	do { \
		int i;							\
									\
		for (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {	\
			dest->read_urbs[i] = src->read_urbs[i];		\
			dest->read_urbs[i]->context = dest;		\
			dest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \
		}							\
		dest->read_urb = src->read_urb;				\
		dest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\
		dest->bulk_in_buffer = src->bulk_in_buffer;		\
		dest->bulk_in_size = src->bulk_in_size;			\
		dest->interrupt_in_urb = src->interrupt_in_urb;		\
		dest->interrupt_in_urb->context = dest;			\
		dest->interrupt_in_endpointAddress = \
					src->interrupt_in_endpointAddress;\
		dest->interrupt_in_buffer = src->interrupt_in_buffer;	\
	} while (0);

	VAR_1 = kmalloc(sizeof(*VAR_1), VAR_7);
	if (!VAR_1)
		return -VAR_8;
	COPY_PORT(VAR_1, VAR_0->port[0]);
	COPY_PORT(VAR_0->port[0], VAR_0->port[1]);
	COPY_PORT(VAR_0->port[1], VAR_1);
	kfree(VAR_1);

	return 0;
}",torvalds/linux/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0/visor.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,11 @@
 						== KYOCERA_VENDOR_ID)) ||
 		(serial->num_interrupt_in == 0))
 		return 0;
+
+	if (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {
+		dev_err(&serial->interface->dev, ""missing endpoints\n"");
+		return -ENODEV;
+	}
 
 	/*
 	* It appears that Treos and Kyoceras want to use the","{'deleted_lines': [], 'added_lines': ['', '\tif (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {', '\t\tdev_err(&serial->interface->dev, ""missing endpoints\\n"");', '\t\treturn -ENODEV;', '\t}']}",True,The treo_attach function in drivers/usb/serial/visor.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by inserting a USB device that lacks a (1) bulk-in or (2) interrupt-in endpoint.,4.6,MEDIUM,1,valid,2016-01-12T11:05:20Z,1
CVE-2016-0740,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,python-pillow/Pillow,Fix for buffer overflow in TiffDecode.c CVE-2016-0740,6dcbf5bd96b717c58d7b642949da8d323099928e,https://github.com/python-pillow/Pillow/commit/6dcbf5bd96b717c58d7b642949da8d323099928e,libImaging/TiffDecode.c,ImagingLibTiffDecode,"int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, int bytes) {
TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
char *filename = ""tempfile.tif"";
char *mode = ""r"";
TIFF *tiff;
int size;
TRACE((""in decoder: bytes %d\n"", bytes));
TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state,
state->x, state->y, state->ystep));
TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize,
state->xoff, state->yoff));
TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes));
TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));
TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));
TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
im->mode, im->type, im->bands, im->xsize, im->ysize));
TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
im->image8, im->image32, im->image, im->block));
TRACE((""Image: pixelsize: %d, linesize %d \n"",
im->pixelsize, im->linesize));
dump_state(clientstate);
clientstate->size = bytes;
clientstate->eof = clientstate->size;
clientstate->loc = 0;
clientstate->data = (tdata_t)buffer;
clientstate->flrealloc = 0;
dump_state(clientstate);
TIFFSetWarningHandler(NULL);
TIFFSetWarningHandlerExt(NULL);
if (clientstate->fp) {
TRACE((""Opening using fd: %d\n"",clientstate->fp));
lseek(clientstate->fp,0,SEEK_SET); tiff = TIFFFdOpen(clientstate->fp, filename, mode);
} else {
TRACE((""Opening from string\n""));
tiff = TIFFClientOpen(filename, mode,
(thandle_t) clientstate,
_tiffReadProc, _tiffWriteProc,
_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
_tiffMapProc, _tiffUnmapProc);
}
if (!tiff){
TRACE((""Error, didn't get the tiff\n""));
state->errcode = IMAGING_CODEC_BROKEN;
return -1;
}
if (clientstate->ifd){
int rv;
unsigned int ifdoffset = clientstate->ifd;
TRACE((""reading tiff ifd %d\n"", ifdoffset));
rv = TIFFSetSubDirectory(tiff, ifdoffset);
if (!rv){
TRACE((""error in TIFFSetSubDirectory""));
return -1;
}
}
size = TIFFScanlineSize(tiff);
TRACE((""ScanlineSize: %d \n"", size));
if (size > state->bytes) {
TRACE((""Error, scanline size > buffer size\n""));
state->errcode = IMAGING_CODEC_BROKEN;
TIFFClose(tiff);
return -1;
}
while(state->y < state->ysize){
if (TIFFReadScanline(tiff, (tdata_t)state->buffer, (uint32)state->y, 0) == -1) {
TRACE((""Decode Error, row %d\n"", state->y));
state->errcode = IMAGING_CODEC_BROKEN;
TIFFClose(tiff);
return -1;
}
state->shuffle((UINT8*) im->image[state->y + state->yoff] +
state->xoff * im->pixelsize,
state->buffer,
state->xsize);
state->y++;
}
TIFFClose(tiff);
TRACE((""Done Decoding, Returning \n""));
return -1;
}","int ImagingLibTiffDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8* VAR_2, int VAR_3) {
TIFFSTATE *VAR_4 = (TIFFSTATE *)VAR_1->context;
char *VAR_5 = ""tempfile.tif"";
char *VAR_6 = ""r"";
TIFF *VAR_7;
int VAR_8;
TRACE((""in decoder: bytes %d\n"", VAR_3));
TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", VAR_1->count, VAR_1->state,
VAR_1->x, VAR_1->y, VAR_1->ystep));
TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", VAR_1->xsize, VAR_1->ysize,
VAR_1->xoff, VAR_1->yoff));
TRACE((""State: bits %d, bytes %d \n"", VAR_1->bits, VAR_1->bytes));
TRACE((""Buffer: %p: %c%c%c%c\n"", VAR_2, (char)VAR_2[0], (char)VAR_2[1],(char)VAR_2[2], (char)VAR_2[3]));
TRACE((""State->Buffer: %c%c%c%c\n"", (char)VAR_1->buffer[0], (char)VAR_1->buffer[1],(char)VAR_1->buffer[2], (char)VAR_1->buffer[3]));
TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
VAR_0->mode, VAR_0->type, VAR_0->bands, VAR_0->xsize, VAR_0->ysize));
TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
VAR_0->image8, VAR_0->image32, VAR_0->image, VAR_0->block));
TRACE((""Image: pixelsize: %d, linesize %d \n"",
VAR_0->pixelsize, VAR_0->linesize));
dump_state(VAR_4);
VAR_4->size = VAR_3;
VAR_4->eof = VAR_4->size;
VAR_4->loc = 0;
VAR_4->data = (tdata_t)VAR_2;
VAR_4->flrealloc = 0;
dump_state(VAR_4);
TIFFSetWarningHandler(NULL);
TIFFSetWarningHandlerExt(NULL);
if (VAR_4->fp) {
TRACE((""Opening using fd: %d\n"",VAR_4->fp));
lseek(VAR_4->fp,0,VAR_9); 
VAR_7 = TIFFFdOpen(VAR_4->fp, VAR_5, VAR_6);
} else {
TRACE((""Opening from string\n""));
VAR_7 = TIFFClientOpen(VAR_5, VAR_6,
(thandle_t) VAR_4,
VAR_10, VAR_11,
VAR_12, VAR_13, VAR_14,
VAR_15, VAR_16);
}
if (!VAR_7){
TRACE((""Error, didn't get the tiff\n""));
VAR_1->errcode = VAR_17;
return -1;
}
if (VAR_4->ifd){
int VAR_18;
unsigned int VAR_19 = VAR_4->ifd;
TRACE((""reading tiff ifd %d\n"", VAR_19));
VAR_18 = TIFFSetSubDirectory(VAR_7, VAR_19);
if (!VAR_18){
TRACE((""error in TIFFSetSubDirectory""));
return -1;
}
}
VAR_8 = TIFFScanlineSize(VAR_7);
TRACE((""ScanlineSize: %d \n"", VAR_8));
if (VAR_8 > VAR_1->bytes) {
TRACE((""Error, scanline size > buffer size\n""));
VAR_1->errcode = VAR_17;
TIFFClose(VAR_7);
return -1;
}
while(VAR_1->y < VAR_1->ysize){
if (TIFFReadScanline(VAR_7, (tdata_t)VAR_1->buffer, (uint32)VAR_1->y, 0) == -1) {
TRACE((""Decode Error, row %d\n"", VAR_1->y));
VAR_1->errcode = VAR_17;
TIFFClose(VAR_7);
return -1;
}
VAR_1->shuffle((UINT8*) VAR_0->image[VAR_1->y + VAR_1->yoff] +
VAR_1->xoff * VAR_0->pixelsize,
VAR_1->buffer,
VAR_1->xsize);
VAR_1->y++;
}
TIFFClose(VAR_7);
TRACE((""Done Decoding, Returning \n""));
return -1;
}",python-pillow/Pillow/6dcbf5bd96b717c58d7b642949da8d323099928e/TiffDecode.c/vul/before/0.json,"int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, int bytes) {
	TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
	char *filename = ""tempfile.tif"";
	char *mode = ""r"";
	TIFF *tiff;
	tsize_t size;


	/* buffer is the encoded file, bytes is the length of the encoded file */
	/* 	it all ends up in state->buffer, which is a uint8* from Imaging.h */

    TRACE((""in decoder: bytes %d\n"", bytes));
	TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state,
		   state->x, state->y, state->ystep));
	TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize,
		   state->xoff, state->yoff));
	TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes));
	TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));
	TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));
	TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
		   im->mode, im->type, im->bands, im->xsize, im->ysize));
	TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
		   im->image8, im->image32, im->image, im->block));
	TRACE((""Image: pixelsize: %d, linesize %d \n"",
		   im->pixelsize, im->linesize));

	dump_state(clientstate);
	clientstate->size = bytes;
	clientstate->eof = clientstate->size;
	clientstate->loc = 0;
	clientstate->data = (tdata_t)buffer;
	clientstate->flrealloc = 0;
	dump_state(clientstate);

    TIFFSetWarningHandler(NULL);
    TIFFSetWarningHandlerExt(NULL);

	if (clientstate->fp) {
		TRACE((""Opening using fd: %d\n"",clientstate->fp));
		lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.
		tiff = TIFFFdOpen(clientstate->fp, filename, mode);
	} else {
		TRACE((""Opening from string\n""));
		tiff = TIFFClientOpen(filename, mode,
							  (thandle_t) clientstate,
							  _tiffReadProc, _tiffWriteProc,
							  _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
							  _tiffMapProc, _tiffUnmapProc);
	}

	if (!tiff){
		TRACE((""Error, didn't get the tiff\n""));
		state->errcode = IMAGING_CODEC_BROKEN;
		return -1;
	}

    if (clientstate->ifd){
		int rv;
		unsigned int ifdoffset = clientstate->ifd;
		TRACE((""reading tiff ifd %d\n"", ifdoffset));
		rv = TIFFSetSubDirectory(tiff, ifdoffset);
		if (!rv){
			TRACE((""error in TIFFSetSubDirectory""));
			return -1;
		}
	}

	size = TIFFScanlineSize(tiff);
	TRACE((""ScanlineSize: %d \n"", size));
	if (size > state->bytes) {
		TRACE((""Error, scanline size > buffer size\n""));
		state->errcode = IMAGING_CODEC_BROKEN;
		TIFFClose(tiff);
		return -1;
	}

	// Have to do this row by row and shove stuff into the buffer that way,
	// with shuffle.  (or, just alloc a buffer myself, then figure out how to get it
	// back in. Can't use read encoded stripe.

	// This thing pretty much requires that I have the whole image in one shot.
	// Perhaps a stub version would work better???
	while(state->y < state->ysize){
		if (TIFFReadScanline(tiff, (tdata_t)state->buffer, (uint32)state->y, 0) == -1) {
			TRACE((""Decode Error, row %d\n"", state->y));
			state->errcode = IMAGING_CODEC_BROKEN;
			TIFFClose(tiff);
			return -1;
		}
		/* TRACE((""Decoded row %d \n"", state->y)); */
		state->shuffle((UINT8*) im->image[state->y + state->yoff] +
					       state->xoff * im->pixelsize,
					   state->buffer,
					   state->xsize);

		state->y++;
	}

	TIFFClose(tiff);
	TRACE((""Done Decoding, Returning \n""));
	// Returning -1 here to force ImageFile.load to break, rather than
	// even think about looping back around.
	return -1;
}","int ImagingLibTiffDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8* VAR_2, int VAR_3) {
	TIFFSTATE *VAR_4 = (TIFFSTATE *)VAR_1->context;
	char *VAR_5 = ""tempfile.tif"";
	char *VAR_6 = ""r"";
	TIFF *VAR_7;
	tsize_t VAR_8;


	/* COMMENT_0 */
	/* COMMENT_1 */

    TRACE((""in decoder: bytes %d\n"", VAR_3));
	TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", VAR_1->count, VAR_1->state,
		   VAR_1->x, VAR_1->y, VAR_1->ystep));
	TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", VAR_1->xsize, VAR_1->ysize,
		   VAR_1->xoff, VAR_1->yoff));
	TRACE((""State: bits %d, bytes %d \n"", VAR_1->bits, VAR_1->bytes));
	TRACE((""Buffer: %p: %c%c%c%c\n"", VAR_2, (char)VAR_2[0], (char)VAR_2[1],(char)VAR_2[2], (char)VAR_2[3]));
	TRACE((""State->Buffer: %c%c%c%c\n"", (char)VAR_1->buffer[0], (char)VAR_1->buffer[1],(char)VAR_1->buffer[2], (char)VAR_1->buffer[3]));
	TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
		   VAR_0->mode, VAR_0->type, VAR_0->bands, VAR_0->xsize, VAR_0->ysize));
	TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
		   VAR_0->image8, VAR_0->image32, VAR_0->image, VAR_0->block));
	TRACE((""Image: pixelsize: %d, linesize %d \n"",
		   VAR_0->pixelsize, VAR_0->linesize));

	dump_state(VAR_4);
	VAR_4->size = VAR_3;
	VAR_4->eof = VAR_4->size;
	VAR_4->loc = 0;
	VAR_4->data = (tdata_t)VAR_2;
	VAR_4->flrealloc = 0;
	dump_state(VAR_4);

    TIFFSetWarningHandler(NULL);
    TIFFSetWarningHandlerExt(NULL);

	if (VAR_4->fp) {
		TRACE((""Opening using fd: %d\n"",VAR_4->fp));
		lseek(VAR_4->fp,0,VAR_9); /* COMMENT_2 */
		VAR_7 = TIFFFdOpen(VAR_4->fp, VAR_5, VAR_6);
	} else {
		TRACE((""Opening from string\n""));
		VAR_7 = TIFFClientOpen(VAR_5, VAR_6,
							  (thandle_t) VAR_4,
							  VAR_10, VAR_11,
							  VAR_12, VAR_13, VAR_14,
							  VAR_15, VAR_16);
	}

	if (!VAR_7){
		TRACE((""Error, didn't get the tiff\n""));
		VAR_1->errcode = VAR_17;
		return -1;
	}

    if (VAR_4->ifd){
		int VAR_18;
		unsigned int VAR_19 = VAR_4->ifd;
		TRACE((""reading tiff ifd %d\n"", VAR_19));
		VAR_18 = TIFFSetSubDirectory(VAR_7, VAR_19);
		if (!VAR_18){
			TRACE((""error in TIFFSetSubDirectory""));
			return -1;
		}
	}

	VAR_8 = TIFFScanlineSize(VAR_7);
	TRACE((""ScanlineSize: %d \n"", VAR_8));
	if (VAR_8 > VAR_1->bytes) {
		TRACE((""Error, scanline size > buffer size\n""));
		VAR_1->errcode = VAR_17;
		TIFFClose(VAR_7);
		return -1;
	}

	/* COMMENT_3 */
	/* COMMENT_4 */
	/* COMMENT_5 */

	/* COMMENT_6 */
	/* COMMENT_7 */
	while(VAR_1->y < VAR_1->ysize){
		if (TIFFReadScanline(VAR_7, (tdata_t)VAR_1->buffer, (uint32)VAR_1->y, 0) == -1) {
			TRACE((""Decode Error, row %d\n"", VAR_1->y));
			VAR_1->errcode = VAR_17;
			TIFFClose(VAR_7);
			return -1;
		}
		/* COMMENT_8 */
		VAR_1->shuffle((UINT8*) VAR_0->image[VAR_1->y + VAR_1->yoff] +
					       VAR_1->xoff * VAR_0->pixelsize,
					   VAR_1->buffer,
					   VAR_1->xsize);

		VAR_1->y++;
	}

	TIFFClose(VAR_7);
	TRACE((""Done Decoding, Returning \n""));
	/* COMMENT_9 */
	/* COMMENT_10 */
	return -1;
}",python-pillow/Pillow/6dcbf5bd96b717c58d7b642949da8d323099928e/TiffDecode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	char *filename = ""tempfile.tif"";
 	char *mode = ""r"";
 	TIFF *tiff;
-	int size;
+	tsize_t size;
 
 
 	/* buffer is the encoded file, bytes is the length of the encoded file */","{'deleted_lines': ['\tint size;'], 'added_lines': ['\ttsize_t size;']}",True,Buffer overflow in the ImagingLibTiffDecode function in libImaging/TiffDecode.c in Pillow before 3.1.1 allows remote attackers to overwrite memory via a crafted TIFF file.,6.5,MEDIUM,1,valid,2016-01-14T12:59:19Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_memory_stat,"static int php_stream_memory_stat(php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC) 
{
time_t timestamp = 0;
php_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;
assert(ms != NULL);
memset(ssb, 0, sizeof(php_stream_statbuf));
ssb->sb.st_mode = ms->mode & TEMP_STREAM_READONLY ? 0444 : 0666;
ssb->sb.st_size = ms->fsize;
ssb->sb.st_mode |= S_IFREG; 
#ifdef NETWARE
ssb->sb.st_mtime.tv_sec = timestamp;
ssb->sb.st_atime.tv_sec = timestamp;
ssb->sb.st_ctime.tv_sec = timestamp;
#else
ssb->sb.st_mtime = timestamp;
ssb->sb.st_atime = timestamp;
ssb->sb.st_ctime = timestamp;
#endif
ssb->sb.st_nlink = 1;
ssb->sb.st_rdev = -1;
ssb->sb.st_dev = 0xC;
ssb->sb.st_ino = 0;
#ifndef PHP_WIN32
ssb->sb.st_blksize = -1;
#endif
#if !defined(PHP_WIN32) && !defined(__BEOS__)
ssb->sb.st_blocks = -1;
#endif
return 0;
}","static int php_stream_memory_stat(php_stream *VAR_0, php_stream_statbuf *VAR_1 TSRMLS_DC) 
{
time_t VAR_2 = 0;
php_stream_memory_data *VAR_3 = (php_stream_memory_data*)VAR_0->abstract;
assert(VAR_3 != NULL);
memset(VAR_1, 0, sizeof(php_stream_statbuf));
VAR_1->sb.st_mode = VAR_3->mode & VAR_4 ? 0444 : 0666;
VAR_1->sb.st_size = VAR_3->fsize;
VAR_1->sb.st_mode |= VAR_5; 
#ifdef VAR_6
VAR_1->sb.st_mtime.tv_sec = VAR_2;
VAR_1->sb.st_atime.tv_sec = VAR_2;
VAR_1->sb.st_ctime.tv_sec = VAR_2;
#else
VAR_1->sb.st_mtime = VAR_2;
VAR_1->sb.st_atime = VAR_2;
VAR_1->sb.st_ctime = VAR_2;
#endif
VAR_1->sb.st_nlink = 1;
VAR_1->sb.st_rdev = -1;
VAR_1->sb.st_dev = 0xC;
VAR_1->sb.st_ino = 0;
#ifndef VAR_7
VAR_1->sb.st_blksize = -1;
#endif
#if !defined(VAR_7) && !defined(VAR_8)
VAR_1->sb.st_blocks = -1;
#endif
return 0;
}",,"static int php_stream_memory_stat(php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC) /* {{{ */
{
	time_t timestamp = 0;
	php_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;
	assert(ms != NULL);

	memset(ssb, 0, sizeof(php_stream_statbuf));
	/* read-only across the board */

	ssb->sb.st_mode = ms->mode & TEMP_STREAM_READONLY ? 0444 : 0666;

	ssb->sb.st_size = ms->fsize;
	ssb->sb.st_mode |= S_IFREG; /* regular file */

#ifdef NETWARE
	ssb->sb.st_mtime.tv_sec = timestamp;
	ssb->sb.st_atime.tv_sec = timestamp;
	ssb->sb.st_ctime.tv_sec = timestamp;
#else
	ssb->sb.st_mtime = timestamp;
	ssb->sb.st_atime = timestamp;
	ssb->sb.st_ctime = timestamp;
#endif

	ssb->sb.st_nlink = 1;
	ssb->sb.st_rdev = -1;
	/* this is only for APC, so use /dev/null device - no chance of conflict there! */
	ssb->sb.st_dev = 0xC;
	/* generate unique inode number for alias/filename, so no phars will conflict */
	ssb->sb.st_ino = 0;

#ifndef PHP_WIN32
	ssb->sb.st_blksize = -1;
#endif

#if !defined(PHP_WIN32) && !defined(__BEOS__)
	ssb->sb.st_blocks = -1;
#endif

	return 0;
}","static int php_stream_memory_stat(php_stream *VAR_0, php_stream_statbuf *VAR_1 TSRMLS_DC) /* COMMENT_0 */
{
	time_t VAR_2 = 0;
	php_stream_memory_data *VAR_3 = (php_stream_memory_data*)VAR_0->abstract;
	assert(VAR_3 != NULL);

	memset(VAR_1, 0, sizeof(php_stream_statbuf));
	/* COMMENT_1 */

	VAR_1->sb.st_mode = VAR_3->mode & VAR_4 ? 0444 : 0666;

	VAR_1->sb.st_size = VAR_3->fsize;
	VAR_1->sb.st_mode |= VAR_5; /* COMMENT_2 */

#ifdef VAR_6
	VAR_1->sb.st_mtime.tv_sec = VAR_2;
	VAR_1->sb.st_atime.tv_sec = VAR_2;
	VAR_1->sb.st_ctime.tv_sec = VAR_2;
#else
	VAR_1->sb.st_mtime = VAR_2;
	VAR_1->sb.st_atime = VAR_2;
	VAR_1->sb.st_ctime = VAR_2;
#endif

	VAR_1->sb.st_nlink = 1;
	VAR_1->sb.st_rdev = -1;
	/* COMMENT_3 */
	VAR_1->sb.st_dev = 0xC;
	/* COMMENT_4 */
	VAR_1->sb.st_ino = 0;

#ifndef VAR_7
	VAR_1->sb.st_blksize = -1;
#endif

#if !defined(VAR_7) && !defined(VAR_8)
	VAR_1->sb.st_blocks = -1;
#endif

	return 0;
}",,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 
 	memset(ssb, 0, sizeof(php_stream_statbuf));
 	/* read-only across the board */
-	
+
 	ssb->sb.st_mode = ms->mode & TEMP_STREAM_READONLY ? 0444 : 0666;
 
 	ssb->sb.st_size = ms->fsize;","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,_php_stream_memory_create,"PHPAPI php_stream *_php_stream_memory_create(int mode STREAMS_DC TSRMLS_DC)
{
php_stream_memory_data *self;
php_stream *stream;
self = emalloc(sizeof(*self));
self->data = NULL;
self->fpos = 0;
self->fsize = 0;
self->smax = ~0u;
self->mode = mode;
stream = php_stream_alloc_rel(&php_stream_memory_ops, self, 0, mode & TEMP_STREAM_READONLY ? ""rb"" : ""w+b"");
stream->flags |= PHP_STREAM_FLAG_NO_BUFFER;
return stream;
}","PHPAPI VAR_0 *_php_stream_memory_create(int VAR_1 VAR_2 TSRMLS_DC)
{
php_stream_memory_data *VAR_3;
php_stream *VAR_4;
VAR_3 = emalloc(sizeof(*VAR_3));
VAR_3->data = NULL;
VAR_3->fpos = 0;
VAR_3->fsize = 0;
VAR_3->smax = ~0u;
VAR_3->mode = VAR_1;
VAR_4 = php_stream_alloc_rel(&VAR_5, VAR_3, 0, VAR_1 & VAR_6 ? ""rb"" : ""w+b"");
VAR_4->flags |= VAR_7;
return VAR_4;
}",,"PHPAPI php_stream *_php_stream_memory_create(int mode STREAMS_DC TSRMLS_DC)
{
	php_stream_memory_data *self;
	php_stream *stream;

	self = emalloc(sizeof(*self));
	self->data = NULL;
	self->fpos = 0;
	self->fsize = 0;
	self->smax = ~0u;
	self->mode = mode;

	stream = php_stream_alloc_rel(&php_stream_memory_ops, self, 0, mode & TEMP_STREAM_READONLY ? ""rb"" : ""w+b"");
	stream->flags |= PHP_STREAM_FLAG_NO_BUFFER;
	return stream;
}","PHPAPI VAR_0 *_php_stream_memory_create(int VAR_1 VAR_2 TSRMLS_DC)
{
	php_stream_memory_data *VAR_3;
	php_stream *VAR_4;

	VAR_3 = emalloc(sizeof(*VAR_3));
	VAR_3->data = NULL;
	VAR_3->fpos = 0;
	VAR_3->fsize = 0;
	VAR_3->smax = ~0u;
	VAR_3->mode = VAR_1;

	VAR_4 = php_stream_alloc_rel(&VAR_5, VAR_3, 0, VAR_1 & VAR_6 ? ""rb"" : ""w+b"");
	VAR_4->flags |= VAR_7;
	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 	self->fsize = 0;
 	self->smax = ~0u;
 	self->mode = mode;
-	
+
 	stream = php_stream_alloc_rel(&php_stream_memory_ops, self, 0, mode & TEMP_STREAM_READONLY ? ""rb"" : ""w+b"");
 	stream->flags |= PHP_STREAM_FLAG_NO_BUFFER;
 	return stream;","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_memory_set_option,"static int php_stream_memory_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) 
{
php_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;
size_t newsize;
switch(option) {
case PHP_STREAM_OPTION_TRUNCATE_API:
switch (value) {
case PHP_STREAM_TRUNCATE_SUPPORTED:
return PHP_STREAM_OPTION_RETURN_OK;
case PHP_STREAM_TRUNCATE_SET_SIZE:
if (ms->mode & TEMP_STREAM_READONLY) {
return PHP_STREAM_OPTION_RETURN_ERR;
}
newsize = *(size_t*)ptrparam;
if (newsize <= ms->fsize) {
if (newsize < ms->fpos) {
ms->fpos = newsize;
}
} else {
ms->data = erealloc(ms->data, newsize);
memset(ms->data+ms->fsize, 0, newsize - ms->fsize);
ms->fsize = newsize;
}
ms->fsize = newsize;
return PHP_STREAM_OPTION_RETURN_OK;
}
default:
return PHP_STREAM_OPTION_RETURN_NOTIMPL;
}
}","static int php_stream_memory_set_option(php_stream *VAR_0, int VAR_1, int VAR_2, void *VAR_3 TSRMLS_DC) 
{
php_stream_memory_data *VAR_4 = (php_stream_memory_data*)VAR_0->abstract;
size_t VAR_5;
switch(VAR_1) {
case VAR_6:
switch (VAR_2) {
case VAR_7:
return VAR_8;
case VAR_9:
if (VAR_4->mode & VAR_10) {
return VAR_11;
}
VAR_5 = *(size_t*)VAR_3;
if (VAR_5 <= VAR_4->fsize) {
if (VAR_5 < VAR_4->fpos) {
VAR_4->fpos = VAR_5;
}
} else {
VAR_4->data = erealloc(VAR_4->data, VAR_5);
memset(VAR_4->data+VAR_4->fsize, 0, VAR_5 - VAR_4->fsize);
VAR_4->fsize = VAR_5;
}
VAR_4->fsize = VAR_5;
return VAR_8;
}
default:
return VAR_12;
}
}",,"static int php_stream_memory_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */
{
	php_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;
	size_t newsize;

	switch(option) {
		case PHP_STREAM_OPTION_TRUNCATE_API:
			switch (value) {
				case PHP_STREAM_TRUNCATE_SUPPORTED:
					return PHP_STREAM_OPTION_RETURN_OK;

				case PHP_STREAM_TRUNCATE_SET_SIZE:
					if (ms->mode & TEMP_STREAM_READONLY) {
						return PHP_STREAM_OPTION_RETURN_ERR;
					}
					newsize = *(size_t*)ptrparam;
					if (newsize <= ms->fsize) {
						if (newsize < ms->fpos) {
							ms->fpos = newsize;
						}
					} else {
						ms->data = erealloc(ms->data, newsize);
						memset(ms->data+ms->fsize, 0, newsize - ms->fsize);
						ms->fsize = newsize;
					}
					ms->fsize = newsize;
					return PHP_STREAM_OPTION_RETURN_OK;
			}
		default:
			return PHP_STREAM_OPTION_RETURN_NOTIMPL;
	}
}","static int php_stream_memory_set_option(php_stream *VAR_0, int VAR_1, int VAR_2, void *VAR_3 TSRMLS_DC) /* COMMENT_0 */
{
	php_stream_memory_data *VAR_4 = (php_stream_memory_data*)VAR_0->abstract;
	size_t VAR_5;

	switch(VAR_1) {
		case VAR_6:
			switch (VAR_2) {
				case VAR_7:
					return VAR_8;

				case VAR_9:
					if (VAR_4->mode & VAR_10) {
						return VAR_11;
					}
					VAR_5 = *(size_t*)VAR_3;
					if (VAR_5 <= VAR_4->fsize) {
						if (VAR_5 < VAR_4->fpos) {
							VAR_4->fpos = VAR_5;
						}
					} else {
						VAR_4->data = erealloc(VAR_4->data, VAR_5);
						memset(VAR_4->data+VAR_4->fsize, 0, VAR_5 - VAR_4->fsize);
						VAR_4->fsize = VAR_5;
					}
					VAR_4->fsize = VAR_5;
					return VAR_8;
			}
		default:
			return VAR_12;
	}
}",,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
 	php_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;
 	size_t newsize;
-	
+
 	switch(option) {
 		case PHP_STREAM_OPTION_TRUNCATE_API:
 			switch (value) {","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,ext/standard/streamsfuncs.c,stream_array_from_fd_set,"static int stream_array_from_fd_set(zval *stream_array, fd_set *fds TSRMLS_DC)
{
zval **elem, **dest_elem;
php_stream *stream;
HashTable *new_hash;
int ret = 0;
if (Z_TYPE_P(stream_array) != IS_ARRAY) {
return 0;
}
ALLOC_HASHTABLE(new_hash);
zend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(stream_array)), NULL, ZVAL_PTR_DTOR, 0);
for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(stream_array));
zend_hash_has_more_elements(Z_ARRVAL_P(stream_array)) == SUCCESS;
zend_hash_move_forward(Z_ARRVAL_P(stream_array))) {
int type;
char *key;
uint key_len;
ulong num_ind;
int tmp_fd;
type = zend_hash_get_current_key_ex(Z_ARRVAL_P(stream_array),
&key, &key_len, &num_ind, 0, NULL);
if (type == HASH_KEY_NON_EXISTENT ||
zend_hash_get_current_data(Z_ARRVAL_P(stream_array), (void **) &elem) == FAILURE) {
continue; 
}
php_stream_from_zval_no_verify(stream, elem);
if (stream == NULL) {
continue;
}
if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&tmp_fd, 1) && tmp_fd != -1) {
php_socket_t this_fd = (php_socket_t)tmp_fd;
if (PHP_SAFE_FD_ISSET(this_fd, fds)) {
if (type == HASH_KEY_IS_LONG) {
zend_hash_index_update(new_hash, num_ind, (void *)elem, sizeof(zval *), (void **)&dest_elem);
} else { 
zend_hash_update(new_hash, key, key_len, (void *)elem, sizeof(zval *), (void **)&dest_elem);
}
if (dest_elem) {
zval_add_ref(dest_elem);
}
ret++;
continue;
}
}
}
zend_hash_destroy(Z_ARRVAL_P(stream_array));
efree(Z_ARRVAL_P(stream_array));
zend_hash_internal_pointer_reset(new_hash);
Z_ARRVAL_P(stream_array) = new_hash;
return ret;
}","static int stream_array_from_fd_set(zval *VAR_0, fd_set *VAR_1 TSRMLS_DC)
{
zval **VAR_2, **VAR_3;
php_stream *VAR_4;
HashTable *VAR_5;
int VAR_6 = 0;
if (Z_TYPE_P(VAR_0) != VAR_7) {
return 0;
}
ALLOC_HASHTABLE(VAR_5);
zend_hash_init(VAR_5, zend_hash_num_elements(Z_ARRVAL_P(VAR_0)), NULL, VAR_8, 0);
for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(VAR_0));
zend_hash_has_more_elements(Z_ARRVAL_P(VAR_0)) == VAR_9;
zend_hash_move_forward(Z_ARRVAL_P(VAR_0))) {
int VAR_10;
char *VAR_11;
uint VAR_12;
ulong VAR_13;
int VAR_14;
VAR_10 = zend_hash_get_current_key_ex(Z_ARRVAL_P(VAR_0),
&VAR_11, &VAR_12, &VAR_13, 0, NULL);
if (VAR_10 == VAR_15 ||
zend_hash_get_current_data(Z_ARRVAL_P(VAR_0), (void **) &VAR_2) == VAR_16) {
continue; 
}
php_stream_from_zval_no_verify(VAR_4, VAR_2);
if (VAR_4 == NULL) {
continue;
}
if (VAR_9 == php_stream_cast(VAR_4, VAR_17 | VAR_18, (void*)&VAR_14, 1) && VAR_14 != -1) {
php_socket_t VAR_19 = (php_socket_t)VAR_14;
if (PHP_SAFE_FD_ISSET(VAR_19, VAR_1)) {
if (VAR_10 == VAR_20) {
zend_hash_index_update(VAR_5, VAR_13, (void *)VAR_2, sizeof(zval *), (void **)&VAR_3);
} else { 
zend_hash_update(VAR_5, VAR_11, VAR_12, (void *)VAR_2, sizeof(zval *), (void **)&VAR_3);
}
if (VAR_3) {
zval_add_ref(VAR_3);
}
VAR_6++;
continue;
}
}
}
zend_hash_destroy(Z_ARRVAL_P(VAR_0));
efree(Z_ARRVAL_P(VAR_0));
zend_hash_internal_pointer_reset(VAR_5);
Z_ARRVAL_P(VAR_0) = VAR_5;
return VAR_6;
}",,"static int stream_array_from_fd_set(zval *stream_array, fd_set *fds TSRMLS_DC)
{
	zval **elem, **dest_elem;
	php_stream *stream;
	HashTable *new_hash;
	int ret = 0;

	if (Z_TYPE_P(stream_array) != IS_ARRAY) {
		return 0;
	}
	ALLOC_HASHTABLE(new_hash);
	zend_hash_init(new_hash, zend_hash_num_elements(Z_ARRVAL_P(stream_array)), NULL, ZVAL_PTR_DTOR, 0);

	for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(stream_array));
		 zend_hash_has_more_elements(Z_ARRVAL_P(stream_array)) == SUCCESS;
		 zend_hash_move_forward(Z_ARRVAL_P(stream_array))) {

		int type;
		char *key;
		uint key_len;
		ulong num_ind;
		/* Temporary int fd is needed for the STREAM data type on windows, passing this_fd directly to php_stream_cast()
			would eventually bring a wrong result on x64. php_stream_cast() casts to int internally, and this will leave
			the higher bits of a SOCKET variable uninitialized on systems with little endian. */
		int tmp_fd;


		type = zend_hash_get_current_key_ex(Z_ARRVAL_P(stream_array),
				&key, &key_len, &num_ind, 0, NULL);
		if (type == HASH_KEY_NON_EXISTENT ||
			zend_hash_get_current_data(Z_ARRVAL_P(stream_array), (void **) &elem) == FAILURE) {
			continue; /* should not happen */
		}

		php_stream_from_zval_no_verify(stream, elem);
		if (stream == NULL) {
			continue;
		}
		/* get the fd
		 * NB: Most other code will NOT use the PHP_STREAM_CAST_INTERNAL flag
		 * when casting.  It is only used here so that the buffered data warning
		 * is not displayed.
		 */
		if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL, (void*)&tmp_fd, 1) && tmp_fd != -1) {

			php_socket_t this_fd = (php_socket_t)tmp_fd;

			if (PHP_SAFE_FD_ISSET(this_fd, fds)) {
				if (type == HASH_KEY_IS_LONG) {
					zend_hash_index_update(new_hash, num_ind, (void *)elem, sizeof(zval *), (void **)&dest_elem);
				} else { /* HASH_KEY_IS_STRING */
					zend_hash_update(new_hash, key, key_len, (void *)elem, sizeof(zval *), (void **)&dest_elem);
				}

				if (dest_elem) {
					zval_add_ref(dest_elem);
				}
				ret++;
				continue;
			}
		}
	}

	/* destroy old array and add new one */
	zend_hash_destroy(Z_ARRVAL_P(stream_array));
	efree(Z_ARRVAL_P(stream_array));

	zend_hash_internal_pointer_reset(new_hash);
	Z_ARRVAL_P(stream_array) = new_hash;

	return ret;
}","static int stream_array_from_fd_set(zval *VAR_0, fd_set *VAR_1 TSRMLS_DC)
{
	zval **VAR_2, **VAR_3;
	php_stream *VAR_4;
	HashTable *VAR_5;
	int VAR_6 = 0;

	if (Z_TYPE_P(VAR_0) != VAR_7) {
		return 0;
	}
	ALLOC_HASHTABLE(VAR_5);
	zend_hash_init(VAR_5, zend_hash_num_elements(Z_ARRVAL_P(VAR_0)), NULL, VAR_8, 0);

	for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(VAR_0));
		 zend_hash_has_more_elements(Z_ARRVAL_P(VAR_0)) == VAR_9;
		 zend_hash_move_forward(Z_ARRVAL_P(VAR_0))) {

		int VAR_10;
		char *VAR_11;
		uint VAR_12;
		ulong VAR_13;
		/* COMMENT_0 */
                                                                                                               
                                                                                       
		int VAR_14;


		VAR_10 = zend_hash_get_current_key_ex(Z_ARRVAL_P(VAR_0),
				&VAR_11, &VAR_12, &VAR_13, 0, NULL);
		if (VAR_10 == VAR_15 ||
			zend_hash_get_current_data(Z_ARRVAL_P(VAR_0), (void **) &VAR_2) == VAR_16) {
			continue; /* COMMENT_3 */
		}

		php_stream_from_zval_no_verify(VAR_4, VAR_2);
		if (VAR_4 == NULL) {
			continue;
		}
		/* COMMENT_4 */
                                                                       
                                                                          
                      
     
		if (VAR_9 == php_stream_cast(VAR_4, VAR_17 | VAR_18, (void*)&VAR_14, 1) && VAR_14 != -1) {

			php_socket_t VAR_19 = (php_socket_t)VAR_14;

			if (PHP_SAFE_FD_ISSET(VAR_19, VAR_1)) {
				if (VAR_10 == VAR_20) {
					zend_hash_index_update(VAR_5, VAR_13, (void *)VAR_2, sizeof(zval *), (void **)&VAR_3);
				} else { /* COMMENT_9 */
					zend_hash_update(VAR_5, VAR_11, VAR_12, (void *)VAR_2, sizeof(zval *), (void **)&VAR_3);
				}

				if (VAR_3) {
					zval_add_ref(VAR_3);
				}
				VAR_6++;
				continue;
			}
		}
	}

	/* COMMENT_10 */
	zend_hash_destroy(Z_ARRVAL_P(VAR_0));
	efree(Z_ARRVAL_P(VAR_0));

	zend_hash_internal_pointer_reset(VAR_5);
	Z_ARRVAL_P(VAR_0) = VAR_5;

	return VAR_6;
}",,"--- func_before
+++ func_after
@@ -51,7 +51,7 @@
 				} else { /* HASH_KEY_IS_STRING */
 					zend_hash_update(new_hash, key, key_len, (void *)elem, sizeof(zval *), (void **)&dest_elem);
 				}
-				
+
 				if (dest_elem) {
 					zval_add_ref(dest_elem);
 				}","{'deleted_lines': ['\t\t\t\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_temp_close,"static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)
{
php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
int ret;
assert(ts != NULL);
if (ts->innerstream) {
ret = php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE | (close_handle ? 0 : PHP_STREAM_FREE_PRESERVE_HANDLE));
} else {
ret = 0;
}
if (ts->meta) {
zval_ptr_dtor(&ts->meta);
}
efree(ts);
return ret;
}","static int php_stream_temp_close(php_stream *VAR_0, int VAR_1 TSRMLS_DC)
{
php_stream_temp_data *VAR_2 = (php_stream_temp_data*)VAR_0->abstract;
int VAR_3;
assert(VAR_2 != NULL);
if (VAR_2->innerstream) {
VAR_3 = php_stream_free_enclosed(VAR_2->innerstream, VAR_4 | (VAR_1 ? 0 : VAR_5));
} else {
VAR_3 = 0;
}
if (VAR_2->meta) {
zval_ptr_dtor(&VAR_2->meta);
}
efree(VAR_2);
return VAR_3;
}",,"static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (ts->innerstream) {
		ret = php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE | (close_handle ? 0 : PHP_STREAM_FREE_PRESERVE_HANDLE));
	} else {
		ret = 0;
	}

	if (ts->meta) {
		zval_ptr_dtor(&ts->meta);
	}

	efree(ts);

	return ret;
}","static int php_stream_temp_close(php_stream *VAR_0, int VAR_1 TSRMLS_DC)
{
	php_stream_temp_data *VAR_2 = (php_stream_temp_data*)VAR_0->abstract;
	int VAR_3;

	assert(VAR_2 != NULL);

	if (VAR_2->innerstream) {
		VAR_3 = php_stream_free_enclosed(VAR_2->innerstream, VAR_4 | (VAR_1 ? 0 : VAR_5));
	} else {
		VAR_3 = 0;
	}

	if (VAR_2->meta) {
		zval_ptr_dtor(&VAR_2->meta);
	}

	efree(VAR_2);

	return VAR_3;
}",,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 	} else {
 		ret = 0;
 	}
-	
+
 	if (ts->meta) {
 		zval_ptr_dtor(&ts->meta);
 	}","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,_php_stream_memory_open,"PHPAPI php_stream *_php_stream_memory_open(int mode, char *buf, size_t length STREAMS_DC TSRMLS_DC)
{
php_stream *stream;
php_stream_memory_data *ms;
if ((stream = php_stream_memory_create_rel(mode)) != NULL) {
ms = (php_stream_memory_data*)stream->abstract;
if (mode == TEMP_STREAM_READONLY || mode == TEMP_STREAM_TAKE_BUFFER) {
ms->data = buf;
ms->fsize = length;
} else {
if (length) {
assert(buf != NULL);
php_stream_write(stream, buf, length);
}
}
}
return stream;
}","PHPAPI VAR_0 *_php_stream_memory_open(int VAR_1, char *VAR_2, size_t VAR_3 VAR_4 TSRMLS_DC)
{
php_stream *VAR_5;
php_stream_memory_data *VAR_6;
if ((VAR_5 = php_stream_memory_create_rel(VAR_1)) != NULL) {
VAR_6 = (php_stream_memory_data*)VAR_5->abstract;
if (VAR_1 == VAR_7 || VAR_1 == VAR_8) {
VAR_6->data = VAR_2;
VAR_6->fsize = VAR_3;
} else {
if (VAR_3) {
assert(VAR_2 != NULL);
php_stream_write(VAR_5, VAR_2, VAR_3);
}
}
}
return VAR_5;
}",,"PHPAPI php_stream *_php_stream_memory_open(int mode, char *buf, size_t length STREAMS_DC TSRMLS_DC)
{
	php_stream *stream;
	php_stream_memory_data *ms;

	if ((stream = php_stream_memory_create_rel(mode)) != NULL) {
		ms = (php_stream_memory_data*)stream->abstract;

		if (mode == TEMP_STREAM_READONLY || mode == TEMP_STREAM_TAKE_BUFFER) {
			/* use the buffer directly */
			ms->data = buf;
			ms->fsize = length;
		} else {
			if (length) {
				assert(buf != NULL);
				php_stream_write(stream, buf, length);
			}
		}
	}
	return stream;
}","PHPAPI VAR_0 *_php_stream_memory_open(int VAR_1, char *VAR_2, size_t VAR_3 VAR_4 TSRMLS_DC)
{
	php_stream *VAR_5;
	php_stream_memory_data *VAR_6;

	if ((VAR_5 = php_stream_memory_create_rel(VAR_1)) != NULL) {
		VAR_6 = (php_stream_memory_data*)VAR_5->abstract;

		if (VAR_1 == VAR_7 || VAR_1 == VAR_8) {
			/* COMMENT_0 */
			VAR_6->data = VAR_2;
			VAR_6->fsize = VAR_3;
		} else {
			if (VAR_3) {
				assert(VAR_2 != NULL);
				php_stream_write(VAR_5, VAR_2, VAR_3);
			}
		}
	}
	return VAR_5;
}",,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 
 	if ((stream = php_stream_memory_create_rel(mode)) != NULL) {
 		ms = (php_stream_memory_data*)stream->abstract;
-		
+
 		if (mode == TEMP_STREAM_READONLY || mode == TEMP_STREAM_TAKE_BUFFER) {
 			/* use the buffer directly */
 			ms->data = buf;","{'deleted_lines': ['\t\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_temp_read,"static size_t php_stream_temp_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)
{
php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
size_t got;
assert(ts != NULL);
if (!ts->innerstream) {
return -1;
}
got = php_stream_read(ts->innerstream, buf, count);
stream->eof = ts->innerstream->eof;
return got;
}","static size_t php_stream_temp_read(php_stream *VAR_0, char *VAR_1, size_t VAR_2 TSRMLS_DC)
{
php_stream_temp_data *VAR_3 = (php_stream_temp_data*)VAR_0->abstract;
size_t VAR_4;
assert(VAR_3 != NULL);
if (!VAR_3->innerstream) {
return -1;
}
VAR_4 = php_stream_read(VAR_3->innerstream, VAR_1, VAR_2);
VAR_0->eof = VAR_3->innerstream->eof;
return VAR_4;
}",,"static size_t php_stream_temp_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	size_t got;

	assert(ts != NULL);

	if (!ts->innerstream) {
		return -1;
	}

	got = php_stream_read(ts->innerstream, buf, count);

	stream->eof = ts->innerstream->eof;

	return got;
}","static size_t php_stream_temp_read(php_stream *VAR_0, char *VAR_1, size_t VAR_2 TSRMLS_DC)
{
	php_stream_temp_data *VAR_3 = (php_stream_temp_data*)VAR_0->abstract;
	size_t VAR_4;

	assert(VAR_3 != NULL);

	if (!VAR_3->innerstream) {
		return -1;
	}

	VAR_4 = php_stream_read(VAR_3->innerstream, VAR_1, VAR_2);

	VAR_0->eof = VAR_3->innerstream->eof;

	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -8,10 +8,10 @@
 	if (!ts->innerstream) {
 		return -1;
 	}
-	
+
 	got = php_stream_read(ts->innerstream, buf, count);
-	
+
 	stream->eof = ts->innerstream->eof;
-	
+
 	return got;
 }","{'deleted_lines': ['\t', '\t', '\t'], 'added_lines': ['', '', '']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_temp_set_option,"static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) 
{
php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
switch(option) {
case PHP_STREAM_OPTION_META_DATA_API:
if (ts->meta) {
zend_hash_copy(Z_ARRVAL_P((zval*)ptrparam), Z_ARRVAL_P(ts->meta), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval*));
}
return PHP_STREAM_OPTION_RETURN_OK;
default:
if (ts->innerstream) {
return php_stream_set_option(ts->innerstream, option, value, ptrparam);
}
return PHP_STREAM_OPTION_RETURN_NOTIMPL;
}
}","static int php_stream_temp_set_option(php_stream *VAR_0, int VAR_1, int VAR_2, void *VAR_3 TSRMLS_DC) 
{
php_stream_temp_data *VAR_4 = (php_stream_temp_data*)VAR_0->abstract;
switch(VAR_1) {
case VAR_5:
if (VAR_4->meta) {
zend_hash_copy(Z_ARRVAL_P((zval*)VAR_3), Z_ARRVAL_P(VAR_4->meta), (copy_ctor_func_t) VAR_6, NULL, sizeof(zval*));
}
return VAR_7;
default:
if (VAR_4->innerstream) {
return php_stream_set_option(VAR_4->innerstream, VAR_1, VAR_2, VAR_3);
}
return VAR_8;
}
}",,"static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;

	switch(option) {
		case PHP_STREAM_OPTION_META_DATA_API:
			if (ts->meta) {
				zend_hash_copy(Z_ARRVAL_P((zval*)ptrparam), Z_ARRVAL_P(ts->meta), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval*));
			}
			return PHP_STREAM_OPTION_RETURN_OK;
		default:
			if (ts->innerstream) {
				return php_stream_set_option(ts->innerstream, option, value, ptrparam);
			}
			return PHP_STREAM_OPTION_RETURN_NOTIMPL;
	}
}","static int php_stream_temp_set_option(php_stream *VAR_0, int VAR_1, int VAR_2, void *VAR_3 TSRMLS_DC) /* COMMENT_0 */
{
	php_stream_temp_data *VAR_4 = (php_stream_temp_data*)VAR_0->abstract;

	switch(VAR_1) {
		case VAR_5:
			if (VAR_4->meta) {
				zend_hash_copy(Z_ARRVAL_P((zval*)VAR_3), Z_ARRVAL_P(VAR_4->meta), (copy_ctor_func_t) VAR_6, NULL, sizeof(zval*));
			}
			return VAR_7;
		default:
			if (VAR_4->innerstream) {
				return php_stream_set_option(VAR_4->innerstream, VAR_1, VAR_2, VAR_3);
			}
			return VAR_8;
	}
}",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) /* {{{ */
 {
 	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
-	
+
 	switch(option) {
 		case PHP_STREAM_OPTION_META_DATA_API:
 			if (ts->meta) {","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_temp_cast,"static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRMLS_DC)
{
php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
php_stream *file;
size_t memsize;
char *membuf;
off_t pos;
assert(ts != NULL);
if (!ts->innerstream) {
return FAILURE;
}
if (php_stream_is(ts->innerstream, PHP_STREAM_IS_STDIO)) {
return php_stream_cast(ts->innerstream, castas, ret, 0);
}
if (ret == NULL && castas == PHP_STREAM_AS_STDIO) {
return SUCCESS;
}
if (ret == NULL) {
return FAILURE;
}
membuf = php_stream_memory_get_buffer(ts->innerstream, &memsize);
file = php_stream_fopen_tmpfile();
php_stream_write(file, membuf, memsize);
pos = php_stream_tell(ts->innerstream);
php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);
ts->innerstream = file;
php_stream_encloses(stream, ts->innerstream);
php_stream_seek(ts->innerstream, pos, SEEK_SET);
return php_stream_cast(ts->innerstream, castas, ret, 1);
}","static int php_stream_temp_cast(php_stream *VAR_0, int VAR_1, void **VAR_2 TSRMLS_DC)
{
php_stream_temp_data *VAR_3 = (php_stream_temp_data*)VAR_0->abstract;
php_stream *VAR_4;
size_t VAR_5;
char *VAR_6;
off_t VAR_7;
assert(VAR_3 != NULL);
if (!VAR_3->innerstream) {
return VAR_8;
}
if (php_stream_is(VAR_3->innerstream, VAR_9)) {
return php_stream_cast(VAR_3->innerstream, VAR_1, VAR_2, 0);
}
if (VAR_2 == NULL && VAR_1 == VAR_10) {
return VAR_11;
}
if (VAR_2 == NULL) {
return VAR_8;
}
VAR_6 = php_stream_memory_get_buffer(VAR_3->innerstream, &VAR_5);
VAR_4 = php_stream_fopen_tmpfile();
php_stream_write(VAR_4, VAR_6, VAR_5);
VAR_7 = php_stream_tell(VAR_3->innerstream);
php_stream_free_enclosed(VAR_3->innerstream, VAR_12);
VAR_3->innerstream = VAR_4;
php_stream_encloses(VAR_0, VAR_3->innerstream);
php_stream_seek(VAR_3->innerstream, VAR_7, VAR_13);
return php_stream_cast(VAR_3->innerstream, VAR_1, VAR_2, 1);
}",,"static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	php_stream *file;
	size_t memsize;
	char *membuf;
	off_t pos;

	assert(ts != NULL);

	if (!ts->innerstream) {
		return FAILURE;
	}
	if (php_stream_is(ts->innerstream, PHP_STREAM_IS_STDIO)) {
		return php_stream_cast(ts->innerstream, castas, ret, 0);
	}

	/* we are still using a memory based backing. If they are if we can be
	 * a FILE*, say yes because we can perform the conversion.
	 * If they actually want to perform the conversion, we need to switch
	 * the memory stream to a tmpfile stream */

	if (ret == NULL && castas == PHP_STREAM_AS_STDIO) {
		return SUCCESS;
	}

	/* say ""no"" to other stream forms */
	if (ret == NULL) {
		return FAILURE;
	}

	/* perform the conversion and then pass the request on to the innerstream */
	membuf = php_stream_memory_get_buffer(ts->innerstream, &memsize);
	file = php_stream_fopen_tmpfile();
	php_stream_write(file, membuf, memsize);
	pos = php_stream_tell(ts->innerstream);

	php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);
	ts->innerstream = file;
	php_stream_encloses(stream, ts->innerstream);
	php_stream_seek(ts->innerstream, pos, SEEK_SET);

	return php_stream_cast(ts->innerstream, castas, ret, 1);
}","static int php_stream_temp_cast(php_stream *VAR_0, int VAR_1, void **VAR_2 TSRMLS_DC)
{
	php_stream_temp_data *VAR_3 = (php_stream_temp_data*)VAR_0->abstract;
	php_stream *VAR_4;
	size_t VAR_5;
	char *VAR_6;
	off_t VAR_7;

	assert(VAR_3 != NULL);

	if (!VAR_3->innerstream) {
		return VAR_8;
	}
	if (php_stream_is(VAR_3->innerstream, VAR_9)) {
		return php_stream_cast(VAR_3->innerstream, VAR_1, VAR_2, 0);
	}

	/* COMMENT_0 */
                                                           
                                                                      
                                            

	if (VAR_2 == NULL && VAR_1 == VAR_10) {
		return VAR_11;
	}

	/* COMMENT_4 */
	if (VAR_2 == NULL) {
		return VAR_8;
	}

	/* COMMENT_5 */
	VAR_6 = php_stream_memory_get_buffer(VAR_3->innerstream, &VAR_5);
	VAR_4 = php_stream_fopen_tmpfile();
	php_stream_write(VAR_4, VAR_6, VAR_5);
	VAR_7 = php_stream_tell(VAR_3->innerstream);

	php_stream_free_enclosed(VAR_3->innerstream, VAR_12);
	VAR_3->innerstream = VAR_4;
	php_stream_encloses(VAR_0, VAR_3->innerstream);
	php_stream_seek(VAR_3->innerstream, VAR_7, VAR_13);

	return php_stream_cast(VAR_3->innerstream, VAR_1, VAR_2, 1);
}",,"--- func_before
+++ func_after
@@ -34,7 +34,7 @@
 	file = php_stream_fopen_tmpfile();
 	php_stream_write(file, membuf, memsize);
 	pos = php_stream_tell(ts->innerstream);
-	
+
 	php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);
 	ts->innerstream = file;
 	php_stream_encloses(stream, ts->innerstream);","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_url_wrap_rfc2397,"static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *wrapper, char *path, char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC) 
{
php_stream *stream;
php_stream_temp_data *ts;
char *comma, *semi, *sep, *key;
size_t mlen, dlen, plen, vlen;
off_t newoffs;
zval *meta = NULL;
int base64 = 0, ilen;
if (memcmp(path, ""data:"", 5)) {
return NULL;
}
path += 5;
dlen = strlen(path);
if (dlen >= 2 && path[0] == '/' && path[1] == '/') {
dlen -= 2;
path += 2;
}
if ((comma = memchr(path, ',', dlen)) == NULL) {
php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: no comma in URL"");
return NULL;
}
if (comma != path) {
mlen = comma - path;
dlen -= mlen;
semi = memchr(path, ';', mlen);
sep = memchr(path, '/', mlen);
if (!semi && !sep) {
php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal media type"");
return NULL;
}
MAKE_STD_ZVAL(meta);
array_init(meta);
if (!semi) { 
add_assoc_stringl(meta, ""mediatype"", path, mlen, 1);
mlen = 0;
} else if (sep && sep < semi) { 
plen = semi - path;
add_assoc_stringl(meta, ""mediatype"", path, plen, 1);
mlen -= plen;
path += plen;
} else if (semi != path || mlen != sizeof("";base64"")-1 || memcmp(path, "";base64"", sizeof("";base64"")-1)) { 
zval_ptr_dtor(&meta);
php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal media type"");
return NULL;
}
while(semi && (semi == path)) {
path++;
mlen--;
sep = memchr(path, '=', mlen);
semi = memchr(path, ';', mlen);
if (!sep || (semi && semi < sep)) { 
if (mlen != sizeof(""base64"")-1 || memcmp(path, ""base64"", sizeof(""base64"")-1)) {
zval_ptr_dtor(&meta);
php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal parameter"");
return NULL;
}
base64 = 1;
mlen -= sizeof(""base64"") - 1;
path += sizeof(""base64"") - 1;
break;
}
plen = sep - path;
vlen = (semi ? semi - sep : mlen - plen) - 1 ;
key = estrndup(path, plen);
add_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);
efree(key);
plen += vlen + 1;
mlen -= plen;
path += plen;
}
if (mlen) {
zval_ptr_dtor(&meta);
php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal URL"");
return NULL;
}
} else {
MAKE_STD_ZVAL(meta);
array_init(meta);
}
add_assoc_bool(meta, ""base64"", base64);
comma++;
dlen--;
if (base64) {
comma = (char*)php_base64_decode((const unsigned char *)comma, dlen, &ilen);
if (!comma) {
zval_ptr_dtor(&meta);
php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: unable to decode"");
return NULL;
}
} else {
comma = estrndup(comma, dlen);
ilen = dlen = php_url_decode(comma, dlen);
}
if ((stream = php_stream_temp_create_rel(0, ~0u)) != NULL) {
php_stream_temp_write(stream, comma, ilen TSRMLS_CC);
php_stream_temp_seek(stream, 0, SEEK_SET, &newoffs TSRMLS_CC);
vlen = strlen(mode);
if (vlen >= sizeof(stream->mode)) {
vlen = sizeof(stream->mode) - 1;
}
memcpy(stream->mode, mode, vlen);
stream->mode[vlen] = '\0';
stream->ops = &php_stream_rfc2397_ops;
ts = (php_stream_temp_data*)stream->abstract;
assert(ts != NULL);
ts->mode = mode && mode[0] == 'r' && mode[1] != '+' ? TEMP_STREAM_READONLY : 0;
ts->meta = meta;
}
efree(comma);
return stream;
}","static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *VAR_0, char *VAR_1, char *VAR_2, int VAR_3, char **VAR_4, php_stream_context *VAR_5 VAR_6 TSRMLS_DC) 
{
php_stream *VAR_7;
php_stream_temp_data *VAR_8;
char *VAR_9, *VAR_10, *VAR_11, *VAR_12;
size_t VAR_13, VAR_14, VAR_15, VAR_16;
off_t VAR_17;
zval *VAR_18 = NULL;
int VAR_19 = 0, VAR_20;
if (memcmp(VAR_1, ""data:"", 5)) {
return NULL;
}
VAR_1 += 5;
VAR_14 = strlen(VAR_1);
if (VAR_14 >= 2 && VAR_1[0] == '/' && VAR_1[1] == '/') {
VAR_14 -= 2;
VAR_1 += 2;
}
if ((VAR_9 = memchr(VAR_1, ',', VAR_14)) == NULL) {
php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: no comma in URL"");
return NULL;
}
if (VAR_9 != VAR_1) {
VAR_13 = VAR_9 - VAR_1;
VAR_14 -= VAR_13;
VAR_10 = memchr(VAR_1, ';', VAR_13);
VAR_11 = memchr(VAR_1, '/', VAR_13);
if (!VAR_10 && !VAR_11) {
php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal media type"");
return NULL;
}
MAKE_STD_ZVAL(VAR_18);
array_init(VAR_18);
if (!VAR_10) { 
add_assoc_stringl(VAR_18, ""mediatype"", VAR_1, VAR_13, 1);
VAR_13 = 0;
} else if (VAR_11 && VAR_11 < VAR_10) { 
VAR_15 = VAR_10 - VAR_1;
add_assoc_stringl(VAR_18, ""mediatype"", VAR_1, VAR_15, 1);
VAR_13 -= VAR_15;
VAR_1 += VAR_15;
} else if (VAR_10 != VAR_1 || VAR_13 != sizeof("";base64"")-1 || memcmp(VAR_1, "";base64"", sizeof("";base64"")-1)) { 
zval_ptr_dtor(&VAR_18);
php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal media type"");
return NULL;
}
while(VAR_10 && (VAR_10 == VAR_1)) {
VAR_1++;
VAR_13--;
VAR_11 = memchr(VAR_1, '=', VAR_13);
VAR_10 = memchr(VAR_1, ';', VAR_13);
if (!VAR_11 || (VAR_10 && VAR_10 < VAR_11)) { 
if (VAR_13 != sizeof(""base64"")-1 || memcmp(VAR_1, ""base64"", sizeof(""base64"")-1)) {
zval_ptr_dtor(&VAR_18);
php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal parameter"");
return NULL;
}
VAR_19 = 1;
VAR_13 -= sizeof(""base64"") - 1;
VAR_1 += sizeof(""base64"") - 1;
break;
}
VAR_15 = VAR_11 - VAR_1;
VAR_16 = (VAR_10 ? VAR_10 - VAR_11 : VAR_13 - VAR_15) - 1 ;
VAR_12 = estrndup(VAR_1, VAR_15);
add_assoc_stringl_ex(VAR_18, VAR_12, VAR_15 + 1, VAR_11 + 1, VAR_16, 1);
efree(VAR_12);
VAR_15 += VAR_16 + 1;
VAR_13 -= VAR_15;
VAR_1 += VAR_15;
}
if (VAR_13) {
zval_ptr_dtor(&VAR_18);
php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal URL"");
return NULL;
}
} else {
MAKE_STD_ZVAL(VAR_18);
array_init(VAR_18);
}
add_assoc_bool(VAR_18, ""base64"", VAR_19);
VAR_9++;
VAR_14--;
if (VAR_19) {
VAR_9 = (char*)php_base64_decode((const unsigned char *)VAR_9, VAR_14, &VAR_20);
if (!VAR_9) {
zval_ptr_dtor(&VAR_18);
php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: unable to decode"");
return NULL;
}
} else {
VAR_9 = estrndup(VAR_9, VAR_14);
VAR_20 = VAR_14 = php_url_decode(VAR_9, VAR_14);
}
if ((VAR_7 = php_stream_temp_create_rel(0, ~0u)) != NULL) {
php_stream_temp_write(VAR_7, VAR_9, VAR_20 VAR_21);
php_stream_temp_seek(VAR_7, 0, VAR_22, &VAR_17 VAR_21);
VAR_16 = strlen(VAR_2);
if (VAR_16 >= sizeof(VAR_7->mode)) {
VAR_16 = sizeof(VAR_7->mode) - 1;
}
memcpy(VAR_7->mode, VAR_2, VAR_16);
VAR_7->mode[VAR_16] = '\0';
VAR_7->ops = &VAR_23;
VAR_8 = (php_stream_temp_data*)VAR_7->abstract;
assert(VAR_8 != NULL);
VAR_8->mode = VAR_2 && VAR_2[0] == 'r' && VAR_2[1] != '+' ? VAR_24 : 0;
VAR_8->meta = VAR_18;
}
efree(VAR_9);
return VAR_7;
}",,"static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *wrapper, char *path, char *mode, int options, char **opened_path, php_stream_context *context STREAMS_DC TSRMLS_DC) /* {{{ */
{
	php_stream *stream;
	php_stream_temp_data *ts;
	char *comma, *semi, *sep, *key;
	size_t mlen, dlen, plen, vlen;
	off_t newoffs;
	zval *meta = NULL;
	int base64 = 0, ilen;

	if (memcmp(path, ""data:"", 5)) {
		return NULL;
	}

	path += 5;
	dlen = strlen(path);

	if (dlen >= 2 && path[0] == '/' && path[1] == '/') {
		dlen -= 2;
		path += 2;
	}

	if ((comma = memchr(path, ',', dlen)) == NULL) {
		php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: no comma in URL"");
		return NULL;
	}

	if (comma != path) {
		/* meta info */
		mlen = comma - path;
		dlen -= mlen;
		semi = memchr(path, ';', mlen);
		sep = memchr(path, '/', mlen);

		if (!semi && !sep) {
			php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal media type"");
			return NULL;
		}

		MAKE_STD_ZVAL(meta);
		array_init(meta);
		if (!semi) { /* there is only a mime type */
			add_assoc_stringl(meta, ""mediatype"", path, mlen, 1);
			mlen = 0;
		} else if (sep && sep < semi) { /* there is a mime type */
			plen = semi - path;
			add_assoc_stringl(meta, ""mediatype"", path, plen, 1);
			mlen -= plen;
			path += plen;
		} else if (semi != path || mlen != sizeof("";base64"")-1 || memcmp(path, "";base64"", sizeof("";base64"")-1)) { /* must be error since parameters are only allowed after mediatype */
			zval_ptr_dtor(&meta);
			php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal media type"");
			return NULL;
		}
		/* get parameters and potentially ';base64' */
		while(semi && (semi == path)) {
			path++;
			mlen--;
			sep = memchr(path, '=', mlen);
			semi = memchr(path, ';', mlen);
			if (!sep || (semi && semi < sep)) { /* must be ';base64' or failure */
				if (mlen != sizeof(""base64"")-1 || memcmp(path, ""base64"", sizeof(""base64"")-1)) {
					/* must be error since parameters are only allowed after mediatype and we have no '=' sign */
					zval_ptr_dtor(&meta);
					php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal parameter"");
					return NULL;
				}
				base64 = 1;
				mlen -= sizeof(""base64"") - 1;
				path += sizeof(""base64"") - 1;
				break;
			}
			/* found parameter ... the heart of cs ppl lies in +1/-1 or was it +2 this time? */
			plen = sep - path;
			vlen = (semi ? semi - sep : mlen - plen) - 1 /* '=' */;
			key = estrndup(path, plen);
			if (plen != sizeof(""mediatype"")-1 || memcmp(key, ""mediatype"", sizeof(""mediatype"")-1)) {
				add_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);
			}
			efree(key);
			plen += vlen + 1;
			mlen -= plen;
			path += plen;
		}
		if (mlen) {
			zval_ptr_dtor(&meta);
			php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal URL"");
			return NULL;
		}
	} else {
		MAKE_STD_ZVAL(meta);
		array_init(meta);
	}
	add_assoc_bool(meta, ""base64"", base64);

	/* skip ',' */
	comma++;
	dlen--;

	if (base64) {
		comma = (char*)php_base64_decode((const unsigned char *)comma, dlen, &ilen);
		if (!comma) {
			zval_ptr_dtor(&meta);
			php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: unable to decode"");
			return NULL;
		}
	} else {
		comma = estrndup(comma, dlen);
		ilen = dlen = php_url_decode(comma, dlen);
	}

	if ((stream = php_stream_temp_create_rel(0, ~0u)) != NULL) {
		/* store data */
		php_stream_temp_write(stream, comma, ilen TSRMLS_CC);
		php_stream_temp_seek(stream, 0, SEEK_SET, &newoffs TSRMLS_CC);
		/* set special stream stuff (enforce exact mode) */
		vlen = strlen(mode);
		if (vlen >= sizeof(stream->mode)) {
			vlen = sizeof(stream->mode) - 1;
		}
		memcpy(stream->mode, mode, vlen);
		stream->mode[vlen] = '\0';
		stream->ops = &php_stream_rfc2397_ops;
		ts = (php_stream_temp_data*)stream->abstract;
		assert(ts != NULL);
		ts->mode = mode && mode[0] == 'r' && mode[1] != '+' ? TEMP_STREAM_READONLY : 0;
		ts->meta = meta;
	}
	efree(comma);

	return stream;
}","static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *VAR_0, char *VAR_1, char *VAR_2, int VAR_3, char **VAR_4, php_stream_context *VAR_5 VAR_6 TSRMLS_DC) /* COMMENT_0 */
{
	php_stream *VAR_7;
	php_stream_temp_data *VAR_8;
	char *VAR_9, *VAR_10, *VAR_11, *VAR_12;
	size_t VAR_13, VAR_14, VAR_15, VAR_16;
	off_t VAR_17;
	zval *VAR_18 = NULL;
	int VAR_19 = 0, VAR_20;

	if (memcmp(VAR_1, ""data:"", 5)) {
		return NULL;
	}

	VAR_1 += 5;
	VAR_14 = strlen(VAR_1);

	if (VAR_14 >= 2 && VAR_1[0] == '/' && VAR_1[1] == '/') {
		VAR_14 -= 2;
		VAR_1 += 2;
	}

	if ((VAR_9 = memchr(VAR_1, ',', VAR_14)) == NULL) {
		php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: no comma in URL"");
		return NULL;
	}

	if (VAR_9 != VAR_1) {
		/* COMMENT_1 */
		VAR_13 = VAR_9 - VAR_1;
		VAR_14 -= VAR_13;
		VAR_10 = memchr(VAR_1, ';', VAR_13);
		VAR_11 = memchr(VAR_1, '/', VAR_13);

		if (!VAR_10 && !VAR_11) {
			php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal media type"");
			return NULL;
		}

		MAKE_STD_ZVAL(VAR_18);
		array_init(VAR_18);
		if (!VAR_10) { /* COMMENT_2 */
			add_assoc_stringl(VAR_18, ""mediatype"", VAR_1, VAR_13, 1);
			VAR_13 = 0;
		} else if (VAR_11 && VAR_11 < VAR_10) { /* COMMENT_3 */
			VAR_15 = VAR_10 - VAR_1;
			add_assoc_stringl(VAR_18, ""mediatype"", VAR_1, VAR_15, 1);
			VAR_13 -= VAR_15;
			VAR_1 += VAR_15;
		} else if (VAR_10 != VAR_1 || VAR_13 != sizeof("";base64"")-1 || memcmp(VAR_1, "";base64"", sizeof("";base64"")-1)) { /* COMMENT_4 */
			zval_ptr_dtor(&VAR_18);
			php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal media type"");
			return NULL;
		}
		/* COMMENT_5 */
		while(VAR_10 && (VAR_10 == VAR_1)) {
			VAR_1++;
			VAR_13--;
			VAR_11 = memchr(VAR_1, '=', VAR_13);
			VAR_10 = memchr(VAR_1, ';', VAR_13);
			if (!VAR_11 || (VAR_10 && VAR_10 < VAR_11)) { /* COMMENT_6 */
				if (VAR_13 != sizeof(""base64"")-1 || memcmp(VAR_1, ""base64"", sizeof(""base64"")-1)) {
					/* COMMENT_7 */
					zval_ptr_dtor(&VAR_18);
					php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal parameter"");
					return NULL;
				}
				VAR_19 = 1;
				VAR_13 -= sizeof(""base64"") - 1;
				VAR_1 += sizeof(""base64"") - 1;
				break;
			}
			/* COMMENT_8 */
			VAR_15 = VAR_11 - VAR_1;
			VAR_16 = (VAR_10 ? VAR_10 - VAR_11 : VAR_13 - VAR_15) - 1 /* COMMENT_9 */;
			VAR_12 = estrndup(VAR_1, VAR_15);
			if (VAR_15 != sizeof(""mediatype"")-1 || memcmp(VAR_12, ""mediatype"", sizeof(""mediatype"")-1)) {
				add_assoc_stringl_ex(VAR_18, VAR_12, VAR_15 + 1, VAR_11 + 1, VAR_16, 1);
			}
			efree(VAR_12);
			VAR_15 += VAR_16 + 1;
			VAR_13 -= VAR_15;
			VAR_1 += VAR_15;
		}
		if (VAR_13) {
			zval_ptr_dtor(&VAR_18);
			php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: illegal URL"");
			return NULL;
		}
	} else {
		MAKE_STD_ZVAL(VAR_18);
		array_init(VAR_18);
	}
	add_assoc_bool(VAR_18, ""base64"", VAR_19);

	/* COMMENT_10 */
	VAR_9++;
	VAR_14--;

	if (VAR_19) {
		VAR_9 = (char*)php_base64_decode((const unsigned char *)VAR_9, VAR_14, &VAR_20);
		if (!VAR_9) {
			zval_ptr_dtor(&VAR_18);
			php_stream_wrapper_log_error(VAR_0, VAR_3 VAR_21, ""rfc2397: unable to decode"");
			return NULL;
		}
	} else {
		VAR_9 = estrndup(VAR_9, VAR_14);
		VAR_20 = VAR_14 = php_url_decode(VAR_9, VAR_14);
	}

	if ((VAR_7 = php_stream_temp_create_rel(0, ~0u)) != NULL) {
		/* COMMENT_11 */
		php_stream_temp_write(VAR_7, VAR_9, VAR_20 VAR_21);
		php_stream_temp_seek(VAR_7, 0, VAR_22, &VAR_17 VAR_21);
		/* COMMENT_12 */
		VAR_16 = strlen(VAR_2);
		if (VAR_16 >= sizeof(VAR_7->mode)) {
			VAR_16 = sizeof(VAR_7->mode) - 1;
		}
		memcpy(VAR_7->mode, VAR_2, VAR_16);
		VAR_7->mode[VAR_16] = '\0';
		VAR_7->ops = &VAR_23;
		VAR_8 = (php_stream_temp_data*)VAR_7->abstract;
		assert(VAR_8 != NULL);
		VAR_8->mode = VAR_2 && VAR_2[0] == 'r' && VAR_2[1] != '+' ? VAR_24 : 0;
		VAR_8->meta = VAR_18;
	}
	efree(VAR_9);

	return VAR_7;
}",,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
 		dlen -= mlen;
 		semi = memchr(path, ';', mlen);
 		sep = memchr(path, '/', mlen);
-		
+
 		if (!semi && !sep) {
 			php_stream_wrapper_log_error(wrapper, options TSRMLS_CC, ""rfc2397: illegal media type"");
 			return NULL;
@@ -74,7 +74,9 @@
 			plen = sep - path;
 			vlen = (semi ? semi - sep : mlen - plen) - 1 /* '=' */;
 			key = estrndup(path, plen);
-			add_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);
+			if (plen != sizeof(""mediatype"")-1 || memcmp(key, ""mediatype"", sizeof(""mediatype"")-1)) {
+				add_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);
+			}
 			efree(key);
 			plen += vlen + 1;
 			mlen -= plen;","{'deleted_lines': ['\t\t', '\t\t\tadd_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);'], 'added_lines': ['', '\t\t\tif (plen != sizeof(""mediatype"")-1 || memcmp(key, ""mediatype"", sizeof(""mediatype"")-1)) {', '\t\t\t\tadd_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);', '\t\t\t}']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-10712,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fixed bug #71323 - Output of stream_get_meta_data can be falsified by its input,6297a117d77fa3a0df2e21ca926a92c231819cd5,https://github.com/php/php-src/commit/6297a117d77fa3a0df2e21ca926a92c231819cd5,main/streams/memory.c,php_stream_temp_seek,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
int ret;
assert(ts != NULL);
if (!ts->innerstream) {
*newoffs = -1;
return -1;
}
ret = php_stream_seek(ts->innerstream, offset, whence);
*newoffs = php_stream_tell(ts->innerstream);
stream->eof = ts->innerstream->eof;
return ret;
}","static int php_stream_temp_seek(php_stream *VAR_0, off_t VAR_1, int VAR_2, off_t *VAR_3 TSRMLS_DC)
{
php_stream_temp_data *VAR_4 = (php_stream_temp_data*)VAR_0->abstract;
int VAR_5;
assert(VAR_4 != NULL);
if (!VAR_4->innerstream) {
*VAR_3 = -1;
return -1;
}
VAR_5 = php_stream_seek(VAR_4->innerstream, VAR_1, VAR_2);
*VAR_3 = php_stream_tell(VAR_4->innerstream);
VAR_0->eof = VAR_4->innerstream->eof;
return VAR_5;
}",,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
	ret = php_stream_seek(ts->innerstream, offset, whence);
	*newoffs = php_stream_tell(ts->innerstream);
	stream->eof = ts->innerstream->eof;

	return ret;
}","static int php_stream_temp_seek(php_stream *VAR_0, off_t VAR_1, int VAR_2, off_t *VAR_3 TSRMLS_DC)
{
	php_stream_temp_data *VAR_4 = (php_stream_temp_data*)VAR_0->abstract;
	int VAR_5;

	assert(VAR_4 != NULL);

	if (!VAR_4->innerstream) {
		*VAR_3 = -1;
		return -1;
	}
	VAR_5 = php_stream_seek(VAR_4->innerstream, VAR_1, VAR_2);
	*VAR_3 = php_stream_tell(VAR_4->innerstream);
	VAR_0->eof = VAR_4->innerstream->eof;

	return VAR_5;
}",,"--- func_before
+++ func_after
@@ -12,6 +12,6 @@
 	ret = php_stream_seek(ts->innerstream, offset, whence);
 	*newoffs = php_stream_tell(ts->innerstream);
 	stream->eof = ts->innerstream->eof;
-	
+
 	return ret;
 }","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"In PHP before 5.5.32, 5.6.x before 5.6.18, and 7.x before 7.0.3, all of the return values of stream_get_meta_data can be controlled if the input can be controlled (e.g., during file uploads). For example, a ""$uri = stream_get_meta_data(fopen($file, ""r""))['uri']"" call mishandles the case where $file is data:text/plain;uri=eviluri, -- in other words, metadata can be set by an attacker.",7.5,HIGH,2,valid,2016-01-17T06:10:54Z,1
CVE-2016-2521,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,wireshark,"Switch from QLibrary to ws_load_library.

From the comments in qlibrary_win.cpp:

// We make the following attempts at locating the library:
[ ... ]
// Windows
// if (absolute)
//     fileName
//     fileName + "".dll""
// else
//     fileName + "".dll""
//     fileName

We were passing ""riched20.dll"" to QLibrary, which meant that it searched
for ""riched20.dll.dll"" first.

Switch to ws_load_library, which we use elsewhere and which has much
safer default behavior.

Change-Id: Ic8f0cf5686c9b1856d37e76be4404d6236c076e5
Reviewed-on: https://code.wireshark.org/review/13607
Reviewed-by: Gerald Combs <gerald@wireshark.org>
Petri-Dish: Gerald Combs <gerald@wireshark.org>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",4a79cf2e1ab056faaddd252aa56520435b318a56,https://github.com/wireshark/wireshark/commit/4a79cf2e1ab056faaddd252aa56520435b318a56,ui/gtk/main.c,WinMain,"int _stdcall
WinMain (struct HINSTANCE__ *hInstance,
struct HINSTANCE__ *hPrevInstance,
char               *lpszCmdLine,
int                 nCmdShow)
{
INITCOMMONCONTROLSEX comm_ctrl;
ws_init_dll_search_path();
memset (&comm_ctrl, 0, sizeof(comm_ctrl));
comm_ctrl.dwSize = sizeof(comm_ctrl);
comm_ctrl.dwICC = ICC_WIN95_CLASSES;
InitCommonControlsEx(&comm_ctrl);
ws_load_library(""riched20.dll"");
set_has_console(FALSE);
set_console_wait(FALSE);
return main (__argc, __argv);
}","int _stdcall
WinMain (struct HINSTANCE__ *VAR_0,
struct HINSTANCE__ *VAR_1,
char               *VAR_2,
int                 VAR_3)
{
INITCOMMONCONTROLSEX VAR_4;
ws_init_dll_search_path();
memset (&VAR_4, 0, sizeof(VAR_4));
VAR_4.dwSize = sizeof(VAR_4);
VAR_4.dwICC = VAR_5;
InitCommonControlsEx(&VAR_4);
ws_load_library(""riched20.dll"");
set_has_console(FALSE);
set_console_wait(FALSE);
return main (VAR_6, VAR_7);
}",,"int _stdcall
WinMain (struct HINSTANCE__ *hInstance,
         struct HINSTANCE__ *hPrevInstance,
         char               *lpszCmdLine,
         int                 nCmdShow)
{
    INITCOMMONCONTROLSEX comm_ctrl;

    /*
     * Initialize our DLL search path. MUST be called before LoadLibrary
     * or g_module_open.
     */
    ws_init_dll_search_path();

    /* Initialize our controls. Required for native Windows file dialogs. */
    memset (&comm_ctrl, 0, sizeof(comm_ctrl));
    comm_ctrl.dwSize = sizeof(comm_ctrl);
    /* Includes the animate, header, hot key, list view, progress bar,
     * status bar, tab, tooltip, toolbar, trackbar, tree view, and
     * up-down controls
     */
    comm_ctrl.dwICC = ICC_WIN95_CLASSES;
    InitCommonControlsEx(&comm_ctrl);

    /* RichEd20.DLL is needed for native file dialog filter entries. */
    ws_load_library(""riched20.dll"");

    set_has_console(FALSE);
    set_console_wait(FALSE);
    return main (__argc, __argv);
}","int _stdcall
WinMain (struct HINSTANCE__ *VAR_0,
         struct HINSTANCE__ *VAR_1,
         char               *VAR_2,
         int                 VAR_3)
{
    INITCOMMONCONTROLSEX VAR_4;

    /* COMMENT_0 */
                                                                        
                        
       
    ws_init_dll_search_path();

    /* COMMENT_4 */
    memset (&VAR_4, 0, sizeof(VAR_4));
    VAR_4.dwSize = sizeof(VAR_4);
    /* COMMENT_5 */
                                                                  
                       
       
    VAR_4.dwICC = VAR_5;
    InitCommonControlsEx(&VAR_4);

    /* COMMENT_9 */
    ws_load_library(""riched20.dll"");

    set_has_console(FALSE);
    set_console_wait(FALSE);
    return main (VAR_6, VAR_7);
}",,"--- func_before
+++ func_after
@@ -22,7 +22,7 @@
     comm_ctrl.dwICC = ICC_WIN95_CLASSES;
     InitCommonControlsEx(&comm_ctrl);
 
-    /* RichEd20.DLL is needed for filter entries. */
+    /* RichEd20.DLL is needed for native file dialog filter entries. */
     ws_load_library(""riched20.dll"");
 
     set_has_console(FALSE);","{'deleted_lines': ['    /* RichEd20.DLL is needed for filter entries. */'], 'added_lines': ['    /* RichEd20.DLL is needed for native file dialog filter entries. */']}",True,"Untrusted search path vulnerability in the WiresharkApplication class in ui/qt/wireshark_application.cpp in Wireshark 1.12.x before 1.12.10 and 2.0.x before 2.0.2 on Windows allows local users to gain privileges via a Trojan horse riched20.dll.dll file in the current working directory, related to use of QLibrary.",7.8,HIGH,2,valid,2016-01-29T18:26:28Z,1
CVE-2016-2521,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,wireshark,"Switch from QLibrary to ws_load_library.

From the comments in qlibrary_win.cpp:

// We make the following attempts at locating the library:
[ ... ]
// Windows
// if (absolute)
//     fileName
//     fileName + "".dll""
// else
//     fileName + "".dll""
//     fileName

We were passing ""riched20.dll"" to QLibrary, which meant that it searched
for ""riched20.dll.dll"" first.

Switch to ws_load_library, which we use elsewhere and which has much
safer default behavior.

Change-Id: Ic8f0cf5686c9b1856d37e76be4404d6236c076e5
Reviewed-on: https://code.wireshark.org/review/13607
Reviewed-by: Gerald Combs <gerald@wireshark.org>
Petri-Dish: Gerald Combs <gerald@wireshark.org>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",4a79cf2e1ab056faaddd252aa56520435b318a56,https://github.com/wireshark/wireshark/commit/4a79cf2e1ab056faaddd252aa56520435b318a56,ui/qt/wireshark_application.cpp,WiresharkApplication::WiresharkApplication,"WiresharkApplication::WiresharkApplication(int &argc,  char **argv) :
QApplication(argc, argv),
initialized_(false),
is_reloading_lua_(false),
if_notifier_(NULL),
active_captures_(0)
{
wsApp = this;
setApplicationName(""Wireshark"");
Q_INIT_RESOURCE(about);
Q_INIT_RESOURCE(i18n);
Q_INIT_RESOURCE(layout);
Q_INIT_RESOURCE(toolbar);
Q_INIT_RESOURCE(wsicon);
Q_INIT_RESOURCE(languages);
#ifdef Q_OS_WIN
if (QLibrary::isLibrary(""riched20.dll"")) {
QLibrary riched20(""riched20.dll"");
riched20.load();
if (!riched20.isLoaded()) {
qDebug() << riched20.errorString();
}
}
#endif 
#if (QT_VERSION >= QT_VERSION_CHECK(5, 1, 0))
setAttribute(Qt::AA_UseHighDpiPixmaps);
#endif
QList<int> icon_sizes = QList<int>() << 16 << 24 << 32 << 48 << 64 << 128 << 256 << 512 << 1024;
foreach (int icon_size, icon_sizes) {
QString icon_path = QString("":/wsicon/wsicon%1.png"").arg(icon_size);
normal_icon_.addFile(icon_path);
icon_path = QString("":/wsicon/wsiconcap%1.png"").arg(icon_size);
capture_icon_.addFile(icon_path);
}
recent_timer_.setParent(this);
connect(&recent_timer_, SIGNAL(timeout()), this, SLOT(refreshRecentFiles()));
recent_timer_.start(2000);
addr_resolv_timer_.setParent(this);
connect(&addr_resolv_timer_, SIGNAL(timeout()), this, SLOT(refreshAddressResolution()));
addr_resolv_timer_.start(1000);
tap_update_timer_.setParent(this);
tap_update_timer_.setInterval(TAP_UPDATE_DEFAULT_INTERVAL);
connect(this, SIGNAL(appInitialized()), &tap_update_timer_, SLOT(start()));
connect(&tap_update_timer_, SIGNAL(timeout()), this, SLOT(updateTaps()));
QString app_style_sheet = qApp->styleSheet();
#if defined(Q_OS_MAC) && QT_VERSION < QT_VERSION_CHECK(5, 6, 0)
app_style_sheet +=
""QSplitter::handle:vertical { height: 0px; }\n""
""QSplitter::handle:horizontal { width: 0px; }\n"";
#endif
qApp->setStyleSheet(app_style_sheet);
connect(qApp, SIGNAL(aboutToQuit()), this, SLOT(cleanup()));
}","WiresharkApplication::WiresharkApplication(int &VAR_0,  char **VAR_1) :
QApplication(VAR_0, VAR_1),
initialized_(false),
is_reloading_lua_(false),
if_notifier_(NULL),
active_captures_(0)
{
VAR_2 = this;
setApplicationName(""Wireshark"");
Q_INIT_RESOURCE(VAR_3);
Q_INIT_RESOURCE(VAR_4);
Q_INIT_RESOURCE(VAR_5);
Q_INIT_RESOURCE(VAR_6);
Q_INIT_RESOURCE(VAR_7);
Q_INIT_RESOURCE(VAR_8);
#ifdef VAR_9
if (QLibrary::isLibrary(""riched20.dll"")) {
QLibrary VAR_10(""riched20.dll"");
VAR_10.load();
if (!VAR_10.isLoaded()) {
qDebug() << VAR_10.errorString();
}
}
#endif 
#if (VAR_11 >= QT_VERSION_CHECK(5, 1, 0))
setAttribute(Qt::AA_UseHighDpiPixmaps);
#endif
QList<int> VAR_12 = QList<int>() << 16 << 24 << 32 << 48 << 64 << 128 << 256 << 512 << 1024;
foreach (int VAR_13, icon_sizes) {
QString VAR_14 = QString("":/wsicon/wsicon%1.png"").arg(VAR_13);
VAR_15.addFile(VAR_14);
VAR_14 = QString("":/wsicon/wsiconcap%1.png"").arg(VAR_13);
VAR_16.addFile(VAR_14);
}
VAR_17.setParent(this);
connect(&VAR_17, SIGNAL(timeout()), this, SLOT(refreshRecentFiles()));
VAR_17.start(2000);
VAR_18.setParent(this);
connect(&VAR_18, SIGNAL(timeout()), this, SLOT(refreshAddressResolution()));
VAR_18.start(1000);
VAR_19.setParent(this);
VAR_19.setInterval(VAR_20);
connect(this, SIGNAL(appInitialized()), &VAR_19, SLOT(start()));
connect(&VAR_19, SIGNAL(timeout()), this, SLOT(updateTaps()));
QString VAR_21 = VAR_22->styleSheet();
#if defined(VAR_23) && VAR_11 < QT_VERSION_CHECK(5, 6, 0)
VAR_21 +=
""QSplitter::handle:vertical { height: 0px; }\n""
""QSplitter::handle:horizontal { width: 0px; }\n"";
#endif
VAR_22->setStyleSheet(VAR_21);
connect(VAR_22, SIGNAL(aboutToQuit()), this, SLOT(cleanup()));
}",wireshark/4a79cf2e1ab056faaddd252aa56520435b318a56/wireshark_application.cpp/vul/before/0.json,"WiresharkApplication::WiresharkApplication(int &argc,  char **argv) :
    QApplication(argc, argv),
    initialized_(false),
    is_reloading_lua_(false),
    if_notifier_(NULL),
    active_captures_(0)
{
    wsApp = this;
    setApplicationName(""Wireshark"");

    Q_INIT_RESOURCE(about);
    Q_INIT_RESOURCE(i18n);
    Q_INIT_RESOURCE(layout);
    Q_INIT_RESOURCE(toolbar);
    Q_INIT_RESOURCE(wsicon);
    Q_INIT_RESOURCE(languages);

#ifdef Q_OS_WIN
    /* RichEd20.DLL is needed for native file dialog filter entries. */
    ws_load_library(""riched20.dll"");
#endif // Q_OS_WIN

#if (QT_VERSION >= QT_VERSION_CHECK(5, 1, 0))
    setAttribute(Qt::AA_UseHighDpiPixmaps);
#endif

    QList<int> icon_sizes = QList<int>() << 16 << 24 << 32 << 48 << 64 << 128 << 256 << 512 << 1024;
    foreach (int icon_size, icon_sizes) {
        QString icon_path = QString("":/wsicon/wsicon%1.png"").arg(icon_size);
        normal_icon_.addFile(icon_path);
        icon_path = QString("":/wsicon/wsiconcap%1.png"").arg(icon_size);
        capture_icon_.addFile(icon_path);
    }

    //
    // XXX - this means we try to check for the existence of all files
    // in the recent list every 2 seconds; that causes noticeable network
    // traffic if any of them are stored on file servers.
    //
    // QFileSystemWatcher should allow us to watch for files being
    // removed or renamed.  It uses kqueues and EVFILT_VNODE on FreeBSD,
    // NetBSD, FSEvents on OS X, inotify on Linux if available, and
    // FindFirstChagneNotification() on Windows.  On all other platforms,
    // it just periodically polls, as we're doing now.
    //
    // For unmounts:
    //
    // OS X and FreeBSD deliver NOTE_REVOKE notes for EVFILT_VNODE, and
    // QFileSystemWatcher delivers signals for them, just as it does for
    // NOTE_DELETE and NOTE_RENAME.
    //
    // On Linux, inotify:
    //
    //    http://man7.org/linux/man-pages/man7/inotify.7.html
    //
    // appears to deliver ""filesystem containing watched object was
    // unmounted"" events.  It looks as if Qt turns them into ""changed""
    // events.
    //
    // On Windows, it's not clearly documented what happens on a handle
    // opened with FindFirstChangeNotification() if the volume on which
    // the path handed to FindFirstChangeNotification() is removed, or
    // ejected, or whatever the Windowsese is for ""unmounted"".  The
    // handle obviously isn't valid any more, but whether it just hangs
    // around and never delivers any notifications or delivers an
    // event that turns into an error indication doesn't seem to be
    // documented.  If it just hangs around, I think our main loop will
    // receive a WM_DEVICECHANGE Windows message with DBT_DEVICEREMOVECOMPLETE
    // if an unmount occurs - even for network devices.  If we need to watch
    // for those, we can use the winEvent method of the QWidget for the
    // top-level window to get Windows messages.
    //
    // Note also that remote file systems might not report file
    // removal or renames if they're done on the server or done by
    // another client.  At least on OS X, they *will* get reported
    // if they're done on the machine running the program doing the
    // kqueue stuff, and, at least in newer versions, should get
    // reported on SMB-mounted (and AFP-mounted?) file systems
    // even if done on the server or another client.
    //
    // But, when push comes to shove, the file manager(s) on the
    // OSes in question probably use the same mechanisms to
    // monitor folders in folder windows or open/save dialogs or...,
    // so my inclination is just to use QFileSystemWatcher.
    //
    // However, that wouldn't catch files that become *re*-accessible
    // by virtue of a file system being re-mounted.  The only way to
    // catch *that* would be to watch for mounts and re-check all
    // marked-as-inaccessible files.
    //
    // OS X and FreeBSD also support EVFILT_FS events, which notify you
    // of file system mounts and unmounts.  We'd need to add our own
    // kqueue for that, if we can check those with QSocketNotifier.
    //
    // On Linux, at least as of 2006, you're supposed to poll /proc/mounts:
    //
    //    https://lkml.org/lkml/2006/2/22/169
    //
    // to discover mounts.
    //
    // On Windows, you'd probably have to watch for WM_DEVICECHANGE events.
    //
    // Then again, with an automounter, a file system containing a
    // recent capture might get unmounted automatically if you haven't
    // referred to anything on that file system for a while, and get
    // treated as inaccessible.  However, if you try to access it,
    // the automounter will attempt to re-mount it, so the access *will*
    // succeed if the automounter can remount the file.
    //
    // (Speaking of automounters, repeatedly polling recent files will
    // keep the file system from being unmounted, for what that's worth.)
    //
    // At least on OS X, you can determine whether a file is on an
    // automounted file system by calling statfs() on its path and
    // checking whether MNT_AUTOMOUNTED is set in f_flags.  FreeBSD
    // appears to support that flag as well, but no other *BSD appears
    // to.
    //
    // I'm not sure what can be done on Linux.
    //
    recent_timer_.setParent(this);
    connect(&recent_timer_, SIGNAL(timeout()), this, SLOT(refreshRecentFiles()));
    recent_timer_.start(2000);

    addr_resolv_timer_.setParent(this);
    connect(&addr_resolv_timer_, SIGNAL(timeout()), this, SLOT(refreshAddressResolution()));
    addr_resolv_timer_.start(1000);

    tap_update_timer_.setParent(this);
    tap_update_timer_.setInterval(TAP_UPDATE_DEFAULT_INTERVAL);
    connect(this, SIGNAL(appInitialized()), &tap_update_timer_, SLOT(start()));
    connect(&tap_update_timer_, SIGNAL(timeout()), this, SLOT(updateTaps()));

    // Application-wide style sheet
    QString app_style_sheet = qApp->styleSheet();
#if defined(Q_OS_MAC) && QT_VERSION < QT_VERSION_CHECK(5, 6, 0)
    // Qt uses the HITheme API to draw splitters. In recent versions of OS X
    // this looks particularly bad: https://bugreports.qt.io/browse/QTBUG-43425
    // This doesn't look native but it looks better than Yosemite's bit-rotten
    // rendering of HIThemeSplitterDrawInfo.
    app_style_sheet +=
            ""QSplitter::handle:vertical { height: 0px; }\n""
            ""QSplitter::handle:horizontal { width: 0px; }\n"";
#endif
    qApp->setStyleSheet(app_style_sheet);

    connect(qApp, SIGNAL(aboutToQuit()), this, SLOT(cleanup()));
}","WiresharkApplication::WiresharkApplication(int &VAR_0,  char **VAR_1) :
    QApplication(VAR_0, VAR_1),
    initialized_(false),
    is_reloading_lua_(false),
    if_notifier_(NULL),
    active_captures_(0)
{
    VAR_2 = this;
    setApplicationName(""Wireshark"");

    Q_INIT_RESOURCE(VAR_3);
    Q_INIT_RESOURCE(VAR_4);
    Q_INIT_RESOURCE(VAR_5);
    Q_INIT_RESOURCE(VAR_6);
    Q_INIT_RESOURCE(VAR_7);
    Q_INIT_RESOURCE(VAR_8);

#ifdef VAR_9
    /* COMMENT_0 */
    ws_load_library(""riched20.dll"");
#endif /* COMMENT_1 */

#if (VAR_10 >= QT_VERSION_CHECK(5, 1, 0))
    setAttribute(Qt::AA_UseHighDpiPixmaps);
#endif

    QList<int> VAR_11 = QList<int>() << 16 << 24 << 32 << 48 << 64 << 128 << 256 << 512 << 1024;
    foreach (int VAR_12, icon_sizes) {
        QString VAR_13 = QString("":/wsicon/wsicon%1.png"").arg(VAR_12);
        VAR_14.addFile(VAR_13);
        VAR_13 = QString("":/wsicon/wsiconcap%1.png"").arg(VAR_12);
        VAR_15.addFile(VAR_13);
    }

    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_2 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_2 */
    /* COMMENT_11 */
    /* COMMENT_2 */
    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_2 */
    /* COMMENT_15 */
    /* COMMENT_2 */
    /* COMMENT_16 */
    /* COMMENT_2 */
    /* COMMENT_17 */
    /* COMMENT_18 */
    /* COMMENT_19 */
    /* COMMENT_2 */
    /* COMMENT_20 */
    /* COMMENT_21 */
    /* COMMENT_22 */
    /* COMMENT_23 */
    /* COMMENT_24 */
    /* COMMENT_25 */
    /* COMMENT_26 */
    /* COMMENT_27 */
    /* COMMENT_28 */
    /* COMMENT_29 */
    /* COMMENT_30 */
    /* COMMENT_31 */
    /* COMMENT_2 */
    /* COMMENT_32 */
    /* COMMENT_33 */
    /* COMMENT_34 */
    /* COMMENT_35 */
    /* COMMENT_36 */
    /* COMMENT_37 */
    /* COMMENT_38 */
    /* COMMENT_2 */
    /* COMMENT_39 */
    /* COMMENT_40 */
    /* COMMENT_41 */
    /* COMMENT_42 */
    /* COMMENT_2 */
    /* COMMENT_43 */
    /* COMMENT_44 */
    /* COMMENT_45 */
    /* COMMENT_46 */
    /* COMMENT_2 */
    /* COMMENT_47 */
    /* COMMENT_48 */
    /* COMMENT_49 */
    /* COMMENT_2 */
    /* COMMENT_50 */
    /* COMMENT_2 */
    /* COMMENT_51 */
    /* COMMENT_2 */
    /* COMMENT_52 */
    /* COMMENT_2 */
    /* COMMENT_53 */
    /* COMMENT_2 */
    /* COMMENT_54 */
    /* COMMENT_55 */
    /* COMMENT_56 */
    /* COMMENT_57 */
    /* COMMENT_58 */
    /* COMMENT_59 */
    /* COMMENT_2 */
    /* COMMENT_60 */
    /* COMMENT_61 */
    /* COMMENT_2 */
    /* COMMENT_62 */
    /* COMMENT_63 */
    /* COMMENT_64 */
    /* COMMENT_65 */
    /* COMMENT_66 */
    /* COMMENT_2 */
    /* COMMENT_67 */
    /* COMMENT_2 */
    VAR_16.setParent(this);
    connect(&VAR_16, SIGNAL(timeout()), this, SLOT(refreshRecentFiles()));
    VAR_16.start(2000);

    VAR_17.setParent(this);
    connect(&VAR_17, SIGNAL(timeout()), this, SLOT(refreshAddressResolution()));
    VAR_17.start(1000);

    VAR_18.setParent(this);
    VAR_18.setInterval(VAR_19);
    connect(this, SIGNAL(appInitialized()), &VAR_18, SLOT(start()));
    connect(&VAR_18, SIGNAL(timeout()), this, SLOT(updateTaps()));

    /* COMMENT_68 */
    QString VAR_20 = VAR_21->styleSheet();
#if defined(VAR_22) && VAR_10 < QT_VERSION_CHECK(5, 6, 0)
    /* COMMENT_69 */
    /* COMMENT_70 */
    /* COMMENT_71 */
    /* COMMENT_72 */
    VAR_20 +=
            ""QSplitter::handle:vertical { height: 0px; }\n""
            ""QSplitter::handle:horizontal { width: 0px; }\n"";
#endif
    VAR_21->setStyleSheet(VAR_20);

    connect(VAR_21, SIGNAL(aboutToQuit()), this, SLOT(cleanup()));
}",wireshark/4a79cf2e1ab056faaddd252aa56520435b318a56/wireshark_application.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,13 +17,7 @@
 
 #ifdef Q_OS_WIN
     /* RichEd20.DLL is needed for native file dialog filter entries. */
-    if (QLibrary::isLibrary(""riched20.dll"")) {
-        QLibrary riched20(""riched20.dll"");
-        riched20.load();
-        if (!riched20.isLoaded()) {
-            qDebug() << riched20.errorString();
-        }
-    }
+    ws_load_library(""riched20.dll"");
 #endif // Q_OS_WIN
 
 #if (QT_VERSION >= QT_VERSION_CHECK(5, 1, 0))","{'deleted_lines': ['    if (QLibrary::isLibrary(""riched20.dll"")) {', '        QLibrary riched20(""riched20.dll"");', '        riched20.load();', '        if (!riched20.isLoaded()) {', '            qDebug() << riched20.errorString();', '        }', '    }'], 'added_lines': ['    ws_load_library(""riched20.dll"");']}",True,"Untrusted search path vulnerability in the WiresharkApplication class in ui/qt/wireshark_application.cpp in Wireshark 1.12.x before 1.12.10 and 2.0.x before 2.0.2 on Windows allows local users to gain privileges via a Trojan horse riched20.dll.dll file in the current working directory, related to use of QLibrary.",7.8,HIGH,2,valid,2016-01-29T18:26:28Z,1
CVE-2016-2532,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"llrp: limit recursion depth

LLRP defines fairly complex parameter nesting which we handle via recursion,
however this means a large crafted packet could cause very deep stacks and
potentially stack overflows. Limit our recursive depth to an arbitrary, which
should be more than enough for any legitimate packet (I hope).

Bug: 12048
Change-Id: I9ac31bddfa4ffd1a79809387d10d2261749b95e7
Reviewed-on: https://code.wireshark.org/review/13794
Reviewed-by: Evan Huus <eapache@gmail.com>",4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec,https://github.com/wireshark/wireshark/commit/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec,epan/dissectors/packet-llrp.c,dissect_llrp_impinj_parameter,"static guint
dissect_llrp_impinj_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *param_tree,
guint suboffset, const guint param_end)
{
guint32 subtype;
subtype = tvb_get_ntohl(tvb, suboffset);
proto_item_append_text(param_tree, "" (Impinj - %s)"",
val_to_str_ext(subtype, &impinj_param_type_ext, ""Unknown Type: %d""));
proto_tree_add_item(param_tree, hf_llrp_impinj_param_type, tvb, suboffset, 4, ENC_BIG_ENDIAN);
suboffset += 4;
switch(subtype) {
case LLRP_IMPINJ_PARAM_TAG_INFORMATION:
case LLRP_IMPINJ_PARAM_FORKLIFT_CONFIGURATION:
case LLRP_IMPINJ_PARAM_ACCESS_SPEC_CONFIGURATION:
case LLRP_IMPINJ_PARAM_TAG_REPORT_CONTENT_SELECTOR:
case LLRP_IMPINJ_PARAM_GPS_NMEA_SENTENCES:
case LLRP_IMPINJ_PARAM_HUB_VERSIONS:
break;
case LLRP_IMPINJ_PARAM_REQUESTED_DATA:
PARAM_TREE_ADD(impinj_req_data, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_SUBREGULATORY_REGION:
PARAM_TREE_ADD(impinj_reg_region, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_INVENTORY_SEARCH_MODE:
PARAM_TREE_ADD(impinj_search_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_TAG_DIRECTION_REPORTING:
PARAM_TREE_ADD(impinj_en_tag_dir, 2, ENC_NA);
PARAM_TREE_ADD(impinj_antenna_conf, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(rfu, 4, ENC_NA);
break;
case LLRP_IMPINJ_PARAM_TAG_DIRECTION:
PARAM_TREE_ADD(decision_time, 8, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(impinj_tag_dir, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(confidence, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_FIXED_FREQUENCY_LIST:
PARAM_TREE_ADD(impinj_fix_freq_mode, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(rfu, 2, ENC_NA);
suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
hf_llrp_num_channels, hf_llrp_channel, 2, suboffset);
break;
case LLRP_IMPINJ_PARAM_REDUCED_POWER_FREQUENCY_LIST:
PARAM_TREE_ADD(impinj_reduce_power_mode, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(rfu, 2, ENC_NA);
suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
hf_llrp_num_channels, hf_llrp_channel, 2, suboffset);
break;
case LLRP_IMPINJ_PARAM_LOW_DUTY_CYCLE:
PARAM_TREE_ADD(impinj_low_duty_mode, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(empty_field_timeout, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(field_ping_interval, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_DETAILED_VERSION:
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_model_name, suboffset);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_soft_ver, suboffset);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_fpga_ver, suboffset);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset);
break;
case LLRP_IMPINJ_PARAM_FREQUENCY_CAPABILITIES:
suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
hf_llrp_num_freqs, hf_llrp_frequency, 4, suboffset);
break;
case LLRP_IMPINJ_PARAM_FORKLIFT_HEIGHT_THRESHOLD:
PARAM_TREE_ADD(height_thresh, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_FORKLIFT_ZEROMOTION_TIME_THRESHOLD:
PARAM_TREE_ADD(zero_motion_thresh, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_FORKLIFT_COMPANION_BOARD_INFO:
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_board_manufacturer, suboffset);
PARAM_TREE_ADD(fw_ver_hex, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(hw_ver_hex, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_GPI_DEBOUNCE_CONFIGURATION:
PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(gpi_debounce, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_READER_TEMPERATURE:
PARAM_TREE_ADD(temperature, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_LINK_MONITOR_CONFIGURATION:
PARAM_TREE_ADD(impinj_link_monitor_mode, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(link_down_thresh, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_REPORT_BUFFER_CONFIGURATION:
PARAM_TREE_ADD(impinj_report_buff_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_BLOCK_WRITE_WORD_COUNT:
PARAM_TREE_ADD(word_count, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(mb, 1, ENC_NA);
PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(block_mask, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK_OPSPEC_RESULT:
PARAM_TREE_ADD(permalock_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(mb, 1, ENC_NA);
PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(block_range, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS_OPSPEC_RESULT:
PARAM_TREE_ADD(block_permalock_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_SET_QT_CONFIG:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA);
PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA);
PARAM_TREE_ADD(impinj_persistence, 1, ENC_NA);
PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_SET_QT_CONFIG_OPSPEC_RESULT:
PARAM_TREE_ADD(set_qt_config_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_GET_QT_CONFIG:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_GET_QT_CONFIG_OPSPEC_RESULT:
PARAM_TREE_ADD(get_qt_config_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA);
PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA);
PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ENABLE_SERIALIZED_TID:
PARAM_TREE_ADD(impinj_serialized_tid_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ENABLE_RF_PHASE_ANGLE:
PARAM_TREE_ADD(impinj_rf_phase_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ENABLE_PEAK_RSSI:
PARAM_TREE_ADD(impinj_peak_rssi_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ENABLE_GPS_COORDINATES:
PARAM_TREE_ADD(impinj_gps_coordinates_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_SERIALIZED_TID:
PARAM_TREE_ADD(impinj_tid, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_RF_PHASE_ANGLE:
PARAM_TREE_ADD(phase_angle, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_PEAK_RSSI:
PARAM_TREE_ADD(rssi, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_GPS_COORDINATES:
PARAM_TREE_ADD(latitude, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(longitude, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_LOOP_SPEC:
PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_GGA_SENTENCE:
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_gga_sentence, suboffset);
break;
case LLRP_IMPINJ_PARAM_RMC_SENTENCE:
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_rmc_sentence, suboffset);
break;
case LLRP_IMPINJ_PARAM_OPSPEC_RETRY_COUNT:
PARAM_TREE_ADD(retry_count, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ADVANCE_GPO_CONFIG:
PARAM_TREE_ADD(gpo_port, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(impinj_gpo_mode, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(gpo_pulse_dur, 4, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ENABLE_OPTIM_READ:
PARAM_TREE_ADD(impinj_optim_read_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ACCESS_SPEC_ORDERING:
PARAM_TREE_ADD(impinj_access_spec_ordering, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ENABLE_RF_DOPPLER_FREQ:
PARAM_TREE_ADD(impinj_rf_doppler_mode, 2, ENC_BIG_ENDIAN);
break;
case LLRP_IMPINJ_PARAM_ARRAY_VERSION:
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset);
break;
case LLRP_IMPINJ_PARAM_HUB_CONFIGURATION:
PARAM_TREE_ADD(impinj_hub_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(impinj_hub_connected_type, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(impinj_hub_fault_type, 2, ENC_BIG_ENDIAN);
break;
default:
return suboffset;
break;
}
return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
}","static guint
dissect_llrp_impinj_parameter(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
guint VAR_3, const guint VAR_4)
{
guint32 VAR_5;
VAR_5 = tvb_get_ntohl(VAR_0, VAR_3);
proto_item_append_text(VAR_2, "" (Impinj - %s)"",
val_to_str_ext(VAR_5, &VAR_6, ""Unknown Type: %d""));
proto_tree_add_item(VAR_2, VAR_7, VAR_0, VAR_3, 4, VAR_8);
VAR_3 += 4;
switch(VAR_5) {
case VAR_9:
case VAR_10:
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
break;
case VAR_15:
PARAM_TREE_ADD(VAR_16, 4, VAR_8);
break;
case VAR_17:
PARAM_TREE_ADD(VAR_18, 2, VAR_8);
break;
case VAR_19:
PARAM_TREE_ADD(VAR_20, 2, VAR_8);
break;
case VAR_21:
PARAM_TREE_ADD(VAR_22, 2, VAR_23);
PARAM_TREE_ADD(VAR_24, 2, VAR_8);
PARAM_TREE_ADD(VAR_25, 4, VAR_23);
break;
case VAR_26:
PARAM_TREE_ADD(VAR_27, 8, VAR_8);
PARAM_TREE_ADD(VAR_28, 2, VAR_8);
PARAM_TREE_ADD(VAR_29, 2, VAR_8);
break;
case VAR_30:
PARAM_TREE_ADD(VAR_31, 2, VAR_8);
PARAM_TREE_ADD(VAR_25, 2, VAR_23);
VAR_3 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_2,
VAR_32, VAR_33, 2, VAR_3);
break;
case VAR_34:
PARAM_TREE_ADD(VAR_35, 2, VAR_8);
PARAM_TREE_ADD(VAR_25, 2, VAR_23);
VAR_3 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_2,
VAR_32, VAR_33, 2, VAR_3);
break;
case VAR_36:
PARAM_TREE_ADD(VAR_37, 2, VAR_8);
PARAM_TREE_ADD(VAR_38, 2, VAR_8);
PARAM_TREE_ADD(VAR_39, 2, VAR_8);
break;
case VAR_40:
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_41, VAR_3);
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_42, VAR_3);
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_43, VAR_3);
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_44, VAR_3);
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_45, VAR_3);
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_46, VAR_3);
break;
case VAR_47:
VAR_3 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_2,
VAR_48, VAR_49, 4, VAR_3);
break;
case VAR_50:
PARAM_TREE_ADD(VAR_51, 2, VAR_8);
break;
case VAR_52:
PARAM_TREE_ADD(VAR_53, 2, VAR_8);
break;
case VAR_54:
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_55, VAR_3);
PARAM_TREE_ADD(VAR_56, 2, VAR_8);
PARAM_TREE_ADD(VAR_57, 2, VAR_8);
break;
case VAR_58:
PARAM_TREE_ADD(VAR_59, 2, VAR_8);
PARAM_TREE_ADD(VAR_60, 4, VAR_8);
break;
case VAR_61:
PARAM_TREE_ADD(VAR_62, 2, VAR_8);
break;
case VAR_63:
PARAM_TREE_ADD(VAR_64, 2, VAR_8);
PARAM_TREE_ADD(VAR_65, 2, VAR_8);
break;
case VAR_66:
PARAM_TREE_ADD(VAR_67, 2, VAR_8);
break;
case VAR_68:
PARAM_TREE_ADD(VAR_69, 2, VAR_8);
break;
case VAR_70:
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
PARAM_TREE_ADD(VAR_72, 4, VAR_8);
PARAM_TREE_ADD(VAR_73, 1, VAR_23);
PARAM_TREE_ADD(VAR_74, 2, VAR_8);
PARAM_TREE_ADD(VAR_75, 2, VAR_8);
break;
case VAR_76:
PARAM_TREE_ADD(VAR_77, 1, VAR_23);
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
break;
case VAR_78:
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
PARAM_TREE_ADD(VAR_72, 4, VAR_8);
PARAM_TREE_ADD(VAR_73, 1, VAR_23);
PARAM_TREE_ADD(VAR_74, 2, VAR_8);
PARAM_TREE_ADD(VAR_79, 2, VAR_8);
break;
case VAR_80:
PARAM_TREE_ADD(VAR_81, 1, VAR_23);
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
break;
case VAR_82:
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
PARAM_TREE_ADD(VAR_72, 4, VAR_8);
PARAM_TREE_ADD(VAR_83, 1, VAR_23);
PARAM_TREE_ADD(VAR_84, 1, VAR_23);
PARAM_TREE_ADD(VAR_85, 1, VAR_23);
PARAM_TREE_ADD(VAR_25, 4, VAR_8);
break;
case VAR_86:
PARAM_TREE_ADD(VAR_87, 1, VAR_23);
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
break;
case VAR_88:
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
PARAM_TREE_ADD(VAR_72, 4, VAR_8);
break;
case VAR_89:
PARAM_TREE_ADD(VAR_90, 1, VAR_23);
PARAM_TREE_ADD(VAR_71, 2, VAR_8);
PARAM_TREE_ADD(VAR_83, 1, VAR_23);
PARAM_TREE_ADD(VAR_84, 1, VAR_23);
PARAM_TREE_ADD(VAR_25, 4, VAR_8);
break;
case VAR_91:
PARAM_TREE_ADD(VAR_92, 2, VAR_8);
break;
case VAR_93:
PARAM_TREE_ADD(VAR_94, 2, VAR_8);
break;
case VAR_95:
PARAM_TREE_ADD(VAR_96, 2, VAR_8);
break;
case VAR_97:
PARAM_TREE_ADD(VAR_98, 2, VAR_8);
break;
case VAR_99:
PARAM_TREE_ADD(VAR_100, 2, VAR_8);
break;
case VAR_101:
PARAM_TREE_ADD(VAR_102, 2, VAR_8);
break;
case VAR_103:
PARAM_TREE_ADD(VAR_104, 2, VAR_8);
break;
case VAR_105:
PARAM_TREE_ADD(VAR_106, 4, VAR_8);
PARAM_TREE_ADD(VAR_107, 4, VAR_8);
break;
case VAR_108:
PARAM_TREE_ADD(VAR_109, 4, VAR_8);
break;
case VAR_110:
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_111, VAR_3);
break;
case VAR_112:
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_113, VAR_3);
break;
case VAR_114:
PARAM_TREE_ADD(VAR_115, 2, VAR_8);
break;
case VAR_116:
PARAM_TREE_ADD(VAR_117, 2, VAR_8);
PARAM_TREE_ADD(VAR_118, 2, VAR_8);
PARAM_TREE_ADD(VAR_119, 4, VAR_8);
break;
case VAR_120:
PARAM_TREE_ADD(VAR_121, 2, VAR_8);
break;
case VAR_122:
PARAM_TREE_ADD(VAR_123, 2, VAR_8);
break;
case VAR_124:
PARAM_TREE_ADD(VAR_125, 2, VAR_8);
break;
case VAR_126:
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_42, VAR_3);
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_44, VAR_3);
VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_46, VAR_3);
break;
case VAR_127:
PARAM_TREE_ADD(VAR_128, 2, VAR_8);
PARAM_TREE_ADD(VAR_129, 2, VAR_8);
PARAM_TREE_ADD(VAR_130, 2, VAR_8);
break;
default:
return VAR_3;
break;
}
return dissect_llrp_parameters(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4);
}",wireshark/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec/packet-llrp.c/vul/before/0.json,"static guint
dissect_llrp_impinj_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *param_tree,
        guint suboffset, const guint param_end)
{
    guint32 subtype;

    subtype = tvb_get_ntohl(tvb, suboffset);
    proto_item_append_text(param_tree, "" (Impinj - %s)"",
            val_to_str_ext(subtype, &impinj_param_type_ext, ""Unknown Type: %d""));
    proto_tree_add_item(param_tree, hf_llrp_impinj_param_type, tvb, suboffset, 4, ENC_BIG_ENDIAN);
    suboffset += 4;

    switch(subtype) {
    case LLRP_IMPINJ_PARAM_TAG_INFORMATION:
    case LLRP_IMPINJ_PARAM_FORKLIFT_CONFIGURATION:
    case LLRP_IMPINJ_PARAM_ACCESS_SPEC_CONFIGURATION:
    case LLRP_IMPINJ_PARAM_TAG_REPORT_CONTENT_SELECTOR:
    case LLRP_IMPINJ_PARAM_GPS_NMEA_SENTENCES:
    case LLRP_IMPINJ_PARAM_HUB_VERSIONS:
        /* Just parameters */
        break;
    case LLRP_IMPINJ_PARAM_REQUESTED_DATA:
        PARAM_TREE_ADD(impinj_req_data, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_SUBREGULATORY_REGION:
        PARAM_TREE_ADD(impinj_reg_region, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_INVENTORY_SEARCH_MODE:
        PARAM_TREE_ADD(impinj_search_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_TAG_DIRECTION_REPORTING:
        PARAM_TREE_ADD(impinj_en_tag_dir, 2, ENC_NA);
        PARAM_TREE_ADD(impinj_antenna_conf, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(rfu, 4, ENC_NA);
        break;
    case LLRP_IMPINJ_PARAM_TAG_DIRECTION:
        PARAM_TREE_ADD(decision_time, 8, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(impinj_tag_dir, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(confidence, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_FIXED_FREQUENCY_LIST:
        PARAM_TREE_ADD(impinj_fix_freq_mode, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(rfu, 2, ENC_NA);
        suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                hf_llrp_num_channels, hf_llrp_channel, 2, suboffset);
        break;
    case LLRP_IMPINJ_PARAM_REDUCED_POWER_FREQUENCY_LIST:
        PARAM_TREE_ADD(impinj_reduce_power_mode, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(rfu, 2, ENC_NA);
        suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                hf_llrp_num_channels, hf_llrp_channel, 2, suboffset);
        break;
    case LLRP_IMPINJ_PARAM_LOW_DUTY_CYCLE:
        PARAM_TREE_ADD(impinj_low_duty_mode, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(empty_field_timeout, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(field_ping_interval, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_DETAILED_VERSION:
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_model_name, suboffset);
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset);
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_soft_ver, suboffset);
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset);
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_fpga_ver, suboffset);
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset);
        break;
    case LLRP_IMPINJ_PARAM_FREQUENCY_CAPABILITIES:
        suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                hf_llrp_num_freqs, hf_llrp_frequency, 4, suboffset);
        break;
    case LLRP_IMPINJ_PARAM_FORKLIFT_HEIGHT_THRESHOLD:
        PARAM_TREE_ADD(height_thresh, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_FORKLIFT_ZEROMOTION_TIME_THRESHOLD:
        PARAM_TREE_ADD(zero_motion_thresh, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_FORKLIFT_COMPANION_BOARD_INFO:
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_board_manufacturer, suboffset);
        PARAM_TREE_ADD(fw_ver_hex, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(hw_ver_hex, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_GPI_DEBOUNCE_CONFIGURATION:
        PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(gpi_debounce, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_READER_TEMPERATURE:
        PARAM_TREE_ADD(temperature, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_LINK_MONITOR_CONFIGURATION:
        PARAM_TREE_ADD(impinj_link_monitor_mode, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(link_down_thresh, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_REPORT_BUFFER_CONFIGURATION:
        PARAM_TREE_ADD(impinj_report_buff_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_BLOCK_WRITE_WORD_COUNT:
        PARAM_TREE_ADD(word_count, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK:
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(mb, 1, ENC_NA);
        PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(block_mask, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK_OPSPEC_RESULT:
        PARAM_TREE_ADD(permalock_result, 1, ENC_NA);
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS:
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(mb, 1, ENC_NA);
        PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(block_range, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS_OPSPEC_RESULT:
        PARAM_TREE_ADD(block_permalock_result, 1, ENC_NA);
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_SET_QT_CONFIG:
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA);
        PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA);
        PARAM_TREE_ADD(impinj_persistence, 1, ENC_NA);
        PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_SET_QT_CONFIG_OPSPEC_RESULT:
        PARAM_TREE_ADD(set_qt_config_result, 1, ENC_NA);
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_GET_QT_CONFIG:
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_GET_QT_CONFIG_OPSPEC_RESULT:
        PARAM_TREE_ADD(get_qt_config_result, 1, ENC_NA);
        PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA);
        PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA);
        PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ENABLE_SERIALIZED_TID:
        PARAM_TREE_ADD(impinj_serialized_tid_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ENABLE_RF_PHASE_ANGLE:
        PARAM_TREE_ADD(impinj_rf_phase_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ENABLE_PEAK_RSSI:
        PARAM_TREE_ADD(impinj_peak_rssi_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ENABLE_GPS_COORDINATES:
        PARAM_TREE_ADD(impinj_gps_coordinates_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_SERIALIZED_TID:
        PARAM_TREE_ADD(impinj_tid, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_RF_PHASE_ANGLE:
        PARAM_TREE_ADD(phase_angle, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_PEAK_RSSI:
        PARAM_TREE_ADD(rssi, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_GPS_COORDINATES:
        PARAM_TREE_ADD(latitude, 4, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(longitude, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_LOOP_SPEC:
        PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_GGA_SENTENCE:
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_gga_sentence, suboffset);
        break;
    case LLRP_IMPINJ_PARAM_RMC_SENTENCE:
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_rmc_sentence, suboffset);
        break;
    case LLRP_IMPINJ_PARAM_OPSPEC_RETRY_COUNT:
        PARAM_TREE_ADD(retry_count, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ADVANCE_GPO_CONFIG:
        PARAM_TREE_ADD(gpo_port, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(impinj_gpo_mode, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(gpo_pulse_dur, 4, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ENABLE_OPTIM_READ:
        PARAM_TREE_ADD(impinj_optim_read_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ACCESS_SPEC_ORDERING:
        PARAM_TREE_ADD(impinj_access_spec_ordering, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ENABLE_RF_DOPPLER_FREQ:
        PARAM_TREE_ADD(impinj_rf_doppler_mode, 2, ENC_BIG_ENDIAN);
        break;
    case LLRP_IMPINJ_PARAM_ARRAY_VERSION:
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset);
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset);
        suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset);
        break;
    case LLRP_IMPINJ_PARAM_HUB_CONFIGURATION:
        PARAM_TREE_ADD(impinj_hub_id, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(impinj_hub_connected_type, 2, ENC_BIG_ENDIAN);
        PARAM_TREE_ADD(impinj_hub_fault_type, 2, ENC_BIG_ENDIAN);
        break;
    default:
        return suboffset;
        break;
    }
    /* Each custom parameters ends with optional custom parameter, disscect it */
    return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, 0);
}","static guint
dissect_llrp_impinj_parameter(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
        guint VAR_3, const guint VAR_4)
{
    guint32 VAR_5;

    VAR_5 = tvb_get_ntohl(VAR_0, VAR_3);
    proto_item_append_text(VAR_2, "" (Impinj - %s)"",
            val_to_str_ext(VAR_5, &VAR_6, ""Unknown Type: %d""));
    proto_tree_add_item(VAR_2, VAR_7, VAR_0, VAR_3, 4, VAR_8);
    VAR_3 += 4;

    switch(VAR_5) {
    case VAR_9:
    case VAR_10:
    case VAR_11:
    case VAR_12:
    case VAR_13:
    case VAR_14:
        /* COMMENT_0 */
        break;
    case VAR_15:
        PARAM_TREE_ADD(VAR_16, 4, VAR_8);
        break;
    case VAR_17:
        PARAM_TREE_ADD(VAR_18, 2, VAR_8);
        break;
    case VAR_19:
        PARAM_TREE_ADD(VAR_20, 2, VAR_8);
        break;
    case VAR_21:
        PARAM_TREE_ADD(VAR_22, 2, VAR_23);
        PARAM_TREE_ADD(VAR_24, 2, VAR_8);
        PARAM_TREE_ADD(VAR_25, 4, VAR_23);
        break;
    case VAR_26:
        PARAM_TREE_ADD(VAR_27, 8, VAR_8);
        PARAM_TREE_ADD(VAR_28, 2, VAR_8);
        PARAM_TREE_ADD(VAR_29, 2, VAR_8);
        break;
    case VAR_30:
        PARAM_TREE_ADD(VAR_31, 2, VAR_8);
        PARAM_TREE_ADD(VAR_25, 2, VAR_23);
        VAR_3 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_2,
                VAR_32, VAR_33, 2, VAR_3);
        break;
    case VAR_34:
        PARAM_TREE_ADD(VAR_35, 2, VAR_8);
        PARAM_TREE_ADD(VAR_25, 2, VAR_23);
        VAR_3 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_2,
                VAR_32, VAR_33, 2, VAR_3);
        break;
    case VAR_36:
        PARAM_TREE_ADD(VAR_37, 2, VAR_8);
        PARAM_TREE_ADD(VAR_38, 2, VAR_8);
        PARAM_TREE_ADD(VAR_39, 2, VAR_8);
        break;
    case VAR_40:
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_41, VAR_3);
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_42, VAR_3);
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_43, VAR_3);
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_44, VAR_3);
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_45, VAR_3);
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_46, VAR_3);
        break;
    case VAR_47:
        VAR_3 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_2,
                VAR_48, VAR_49, 4, VAR_3);
        break;
    case VAR_50:
        PARAM_TREE_ADD(VAR_51, 2, VAR_8);
        break;
    case VAR_52:
        PARAM_TREE_ADD(VAR_53, 2, VAR_8);
        break;
    case VAR_54:
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_55, VAR_3);
        PARAM_TREE_ADD(VAR_56, 2, VAR_8);
        PARAM_TREE_ADD(VAR_57, 2, VAR_8);
        break;
    case VAR_58:
        PARAM_TREE_ADD(VAR_59, 2, VAR_8);
        PARAM_TREE_ADD(VAR_60, 4, VAR_8);
        break;
    case VAR_61:
        PARAM_TREE_ADD(VAR_62, 2, VAR_8);
        break;
    case VAR_63:
        PARAM_TREE_ADD(VAR_64, 2, VAR_8);
        PARAM_TREE_ADD(VAR_65, 2, VAR_8);
        break;
    case VAR_66:
        PARAM_TREE_ADD(VAR_67, 2, VAR_8);
        break;
    case VAR_68:
        PARAM_TREE_ADD(VAR_69, 2, VAR_8);
        break;
    case VAR_70:
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        PARAM_TREE_ADD(VAR_72, 4, VAR_8);
        PARAM_TREE_ADD(VAR_73, 1, VAR_23);
        PARAM_TREE_ADD(VAR_74, 2, VAR_8);
        PARAM_TREE_ADD(VAR_75, 2, VAR_8);
        break;
    case VAR_76:
        PARAM_TREE_ADD(VAR_77, 1, VAR_23);
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        break;
    case VAR_78:
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        PARAM_TREE_ADD(VAR_72, 4, VAR_8);
        PARAM_TREE_ADD(VAR_73, 1, VAR_23);
        PARAM_TREE_ADD(VAR_74, 2, VAR_8);
        PARAM_TREE_ADD(VAR_79, 2, VAR_8);
        break;
    case VAR_80:
        PARAM_TREE_ADD(VAR_81, 1, VAR_23);
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        break;
    case VAR_82:
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        PARAM_TREE_ADD(VAR_72, 4, VAR_8);
        PARAM_TREE_ADD(VAR_83, 1, VAR_23);
        PARAM_TREE_ADD(VAR_84, 1, VAR_23);
        PARAM_TREE_ADD(VAR_85, 1, VAR_23);
        PARAM_TREE_ADD(VAR_25, 4, VAR_8);
        break;
    case VAR_86:
        PARAM_TREE_ADD(VAR_87, 1, VAR_23);
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        break;
    case VAR_88:
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        PARAM_TREE_ADD(VAR_72, 4, VAR_8);
        break;
    case VAR_89:
        PARAM_TREE_ADD(VAR_90, 1, VAR_23);
        PARAM_TREE_ADD(VAR_71, 2, VAR_8);
        PARAM_TREE_ADD(VAR_83, 1, VAR_23);
        PARAM_TREE_ADD(VAR_84, 1, VAR_23);
        PARAM_TREE_ADD(VAR_25, 4, VAR_8);
        break;
    case VAR_91:
        PARAM_TREE_ADD(VAR_92, 2, VAR_8);
        break;
    case VAR_93:
        PARAM_TREE_ADD(VAR_94, 2, VAR_8);
        break;
    case VAR_95:
        PARAM_TREE_ADD(VAR_96, 2, VAR_8);
        break;
    case VAR_97:
        PARAM_TREE_ADD(VAR_98, 2, VAR_8);
        break;
    case VAR_99:
        PARAM_TREE_ADD(VAR_100, 2, VAR_8);
        break;
    case VAR_101:
        PARAM_TREE_ADD(VAR_102, 2, VAR_8);
        break;
    case VAR_103:
        PARAM_TREE_ADD(VAR_104, 2, VAR_8);
        break;
    case VAR_105:
        PARAM_TREE_ADD(VAR_106, 4, VAR_8);
        PARAM_TREE_ADD(VAR_107, 4, VAR_8);
        break;
    case VAR_108:
        PARAM_TREE_ADD(VAR_109, 4, VAR_8);
        break;
    case VAR_110:
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_111, VAR_3);
        break;
    case VAR_112:
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_113, VAR_3);
        break;
    case VAR_114:
        PARAM_TREE_ADD(VAR_115, 2, VAR_8);
        break;
    case VAR_116:
        PARAM_TREE_ADD(VAR_117, 2, VAR_8);
        PARAM_TREE_ADD(VAR_118, 2, VAR_8);
        PARAM_TREE_ADD(VAR_119, 4, VAR_8);
        break;
    case VAR_120:
        PARAM_TREE_ADD(VAR_121, 2, VAR_8);
        break;
    case VAR_122:
        PARAM_TREE_ADD(VAR_123, 2, VAR_8);
        break;
    case VAR_124:
        PARAM_TREE_ADD(VAR_125, 2, VAR_8);
        break;
    case VAR_126:
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_42, VAR_3);
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_44, VAR_3);
        VAR_3 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_2, VAR_46, VAR_3);
        break;
    case VAR_127:
        PARAM_TREE_ADD(VAR_128, 2, VAR_8);
        PARAM_TREE_ADD(VAR_129, 2, VAR_8);
        PARAM_TREE_ADD(VAR_130, 2, VAR_8);
        break;
    default:
        return VAR_3;
        break;
    }
    /* COMMENT_1 */
    return dissect_llrp_parameters(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, 0);
}",wireshark/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec/packet-llrp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -206,5 +206,5 @@
         break;
     }
     /* Each custom parameters ends with optional custom parameter, disscect it */
-    return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+    return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, 0);
 }","{'deleted_lines': ['    return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);'], 'added_lines': ['    return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, 0);']}",True,"The dissect_llrp_parameters function in epan/dissectors/packet-llrp.c in the LLRP dissector in Wireshark 1.12.x before 1.12.10 and 2.0.x before 2.0.2 does not limit the recursion depth, which allows remote attackers to cause a denial of service (memory consumption or application crash) via a crafted packet.",5.9,MEDIUM,1,valid,2016-02-06T14:33:28Z,1
CVE-2016-2532,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"llrp: limit recursion depth

LLRP defines fairly complex parameter nesting which we handle via recursion,
however this means a large crafted packet could cause very deep stacks and
potentially stack overflows. Limit our recursive depth to an arbitrary, which
should be more than enough for any legitimate packet (I hope).

Bug: 12048
Change-Id: I9ac31bddfa4ffd1a79809387d10d2261749b95e7
Reviewed-on: https://code.wireshark.org/review/13794
Reviewed-by: Evan Huus <eapache@gmail.com>",4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec,https://github.com/wireshark/wireshark/commit/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec,epan/dissectors/packet-llrp.c,dissect_llrp_message,"static void
dissect_llrp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
guint16 type, guint offset)
{
gboolean    ends_with_parameters;
guint8      requested_data;
guint16     antenna_id, gpi_port, gpo_port;
guint32     spec_id, vendor;
proto_item *request_item, *antenna_item, *gpi_item, *gpo_item;
guint (*dissect_custom_message)(tvbuff_t *tvb,
packet_info *pinfo, proto_tree *tree, guint offset) = NULL;
ends_with_parameters = FALSE;
switch (type)
{
case LLRP_TYPE_CLOSE_CONNECTION_RESPONSE:
case LLRP_TYPE_GET_READER_CAPABILITIES_RESPONSE:
case LLRP_TYPE_ADD_ROSPEC:
case LLRP_TYPE_ADD_ROSPEC_RESPONSE:
case LLRP_TYPE_DELETE_ROSPEC_RESPONSE:
case LLRP_TYPE_START_ROSPEC_RESPONSE:
case LLRP_TYPE_STOP_ROSPEC_RESPONSE:
case LLRP_TYPE_ENABLE_ROSPEC_RESPONSE:
case LLRP_TYPE_DISABLE_ROSPEC_RESPONSE:
case LLRP_TYPE_GET_ROSPECS_RESPONSE:
case LLRP_TYPE_ADD_ACCESSSPEC:
case LLRP_TYPE_ADD_ACCESSSPEC_RESPONSE:
case LLRP_TYPE_DELETE_ACCESSSPEC_RESPONSE:
case LLRP_TYPE_ENABLE_ACCESSSPEC_RESPONSE:
case LLRP_TYPE_DISABLE_ACCESSSPEC_RESPONSE:
case LLRP_TYPE_GET_ACCESSSPECS:
case LLRP_TYPE_CLIENT_REQUEST_OP:
case LLRP_TYPE_CLIENT_RESQUEST_OP_RESPONSE:
case LLRP_TYPE_RO_ACCESS_REPORT:
case LLRP_TYPE_READER_EVENT_NOTIFICATION:
case LLRP_TYPE_ERROR_MESSAGE:
case LLRP_TYPE_GET_READER_CONFIG_RESPONSE:
case LLRP_TYPE_SET_READER_CONFIG_RESPONSE:
case LLRP_TYPE_SET_PROTOCOL_VERSION_RESPONSE:
case LLRP_TYPE_GET_ACCESSSPECS_RESPONSE:
case LLRP_TYPE_GET_REPORT:
case LLRP_TYPE_ENABLE_EVENTS_AND_REPORTS:
ends_with_parameters = TRUE;
break;
case LLRP_TYPE_START_ROSPEC:
case LLRP_TYPE_STOP_ROSPEC:
case LLRP_TYPE_ENABLE_ROSPEC:
case LLRP_TYPE_DISABLE_ROSPEC:
case LLRP_TYPE_DELETE_ROSPEC:
spec_id = tvb_get_ntohl(tvb, offset);
if (spec_id == LLRP_ROSPEC_ALL)
proto_tree_add_uint_format(tree, hf_llrp_rospec, tvb,
offset, 4, spec_id, ""All ROSpecs (%u)"", spec_id);
else
proto_tree_add_item(tree, hf_llrp_rospec, tvb,
offset, 4, ENC_BIG_ENDIAN);
offset += 4;
break;
case LLRP_TYPE_ENABLE_ACCESSSPEC:
case LLRP_TYPE_DELETE_ACCESSSPEC:
case LLRP_TYPE_DISABLE_ACCESSSPEC:
spec_id = tvb_get_ntohl(tvb, offset);
if (spec_id == LLRP_ACCESSSPEC_ALL)
proto_tree_add_uint_format(tree, hf_llrp_accessspec, tvb,
offset, 4, spec_id, ""All Access Specs (%u)"", spec_id);
else
proto_tree_add_item(tree, hf_llrp_accessspec, tvb,
offset, 4, ENC_BIG_ENDIAN);
offset += 4;
break;
case LLRP_TYPE_GET_READER_CAPABILITIES:
proto_tree_add_item(tree, hf_llrp_req_cap, tvb, offset, 1, ENC_BIG_ENDIAN);
offset++;
ends_with_parameters = TRUE;
break;
case LLRP_TYPE_GET_READER_CONFIG:
antenna_id = tvb_get_ntohs(tvb, offset);
if (antenna_id == LLRP_ANTENNA_ALL)
antenna_item = proto_tree_add_uint_format(tree, hf_llrp_antenna_id, tvb,
offset, 2, antenna_id, ""All Antennas (%u)"", antenna_id);
else
antenna_item = proto_tree_add_item(tree, hf_llrp_antenna_id, tvb,
offset, 2, ENC_BIG_ENDIAN);
offset += 2;
requested_data = tvb_get_guint8(tvb, offset);
request_item = proto_tree_add_item(tree, hf_llrp_req_conf, tvb,
offset, 1, ENC_BIG_ENDIAN);
offset++;
gpi_port = tvb_get_ntohs(tvb, offset);
if (gpi_port == LLRP_GPI_PORT_ALL)
gpi_item = proto_tree_add_uint_format(tree, hf_llrp_gpi_port, tvb,
offset, 2, gpi_port, ""All GPI Ports (%u)"", gpi_port);
else
gpi_item = proto_tree_add_item(tree, hf_llrp_gpi_port, tvb,
offset, 2, ENC_BIG_ENDIAN);
offset += 2;
gpo_port = tvb_get_ntohs(tvb, offset);
if (gpo_port == LLRP_GPO_PORT_ALL)
gpo_item = proto_tree_add_uint_format(tree, hf_llrp_gpo_port, tvb,
offset, 2, gpo_port, ""All GPO Ports (%u)"", gpo_port);
else
gpo_item = proto_tree_add_item(tree, hf_llrp_gpo_port, tvb,
offset, 2, ENC_BIG_ENDIAN);
offset += 2;
switch (requested_data)
{
case LLRP_CONF_ALL:
break;
case LLRP_CONF_ANTENNA_PROPERTIES:
case LLRP_CONF_ANTENNA_CONFIGURATION:
proto_item_append_text(gpi_item, "" (Ignored)"");
proto_item_append_text(gpo_item, "" (Ignored)"");
break;
case LLRP_CONF_IDENTIFICATION:
case LLRP_CONF_RO_REPORT_SPEC:
case LLRP_CONF_READER_EVENT_NOTIFICATION_SPEC:
case LLRP_CONF_ACCESS_REPORT_SPEC:
case LLRP_CONF_LLRP_CONFIGURATION_STATE:
case LLRP_CONF_KEEPALIVE_SPEC:
case LLRP_CONF_EVENTS_AND_REPORTS:
proto_item_append_text(antenna_item, "" (Ignored)"");
proto_item_append_text(gpi_item, "" (Ignored)"");
proto_item_append_text(gpo_item, "" (Ignored)"");
break;
case LLRP_CONF_GPI_PORT_CURRENT_STATE:
proto_item_append_text(antenna_item, "" (Ignored)"");
proto_item_append_text(gpo_item, "" (Ignored)"");
break;
case LLRP_CONF_GPO_WRITE_DATA:
proto_item_append_text(antenna_item, "" (Ignored)"");
proto_item_append_text(gpi_item, "" (Ignored)"");
break;
default:
proto_item_append_text(antenna_item, "" (Ignored)"");
expert_add_info_format(pinfo, request_item, &ei_llrp_req_conf,
""Unrecognized configuration request: %u"",
requested_data);
proto_item_append_text(gpi_item, "" (Ignored)"");
proto_item_append_text(gpo_item, "" (Ignored)"");
break;
};
ends_with_parameters = TRUE;
break;
case LLRP_TYPE_SET_READER_CONFIG:
proto_tree_add_item(tree, hf_llrp_rest_fact, tvb, offset, 1, ENC_NA);
offset++;
ends_with_parameters = TRUE;
break;
case LLRP_TYPE_SET_PROTOCOL_VERSION:
proto_tree_add_item(tree, hf_llrp_version, tvb, offset, 1, ENC_BIG_ENDIAN);
break;
case LLRP_TYPE_GET_SUPPORTED_VERSION_RESPONSE:
proto_tree_add_item(tree, hf_llrp_cur_ver, tvb, offset, 1, ENC_BIG_ENDIAN);
offset++;
proto_tree_add_item(tree, hf_llrp_sup_ver, tvb, offset, 1, ENC_BIG_ENDIAN);
offset++;
ends_with_parameters = TRUE;
break;
case LLRP_TYPE_CUSTOM_MESSAGE:
vendor = tvb_get_ntohl(tvb, offset);
proto_tree_add_item(tree, hf_llrp_vendor, tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
switch(vendor) {
case LLRP_VENDOR_IMPINJ:
dissect_custom_message = dissect_llrp_impinj_message;
ends_with_parameters = TRUE;
break;
}
if (dissect_custom_message)
offset = dissect_custom_message(tvb, pinfo, tree, offset);
break;
case LLRP_TYPE_KEEPALIVE:
case LLRP_TYPE_KEEPALIVE_ACK:
case LLRP_TYPE_CLOSE_CONNECTION:
case LLRP_TYPE_GET_ROSPECS:
case LLRP_TYPE_GET_SUPPORTED_VERSION:
break;
default:
DISSECTOR_ASSERT_NOT_REACHED();
};
if(ends_with_parameters) {
offset = dissect_llrp_parameters(tvb, pinfo, tree, offset, tvb_reported_length(tvb));
}
if(tvb_reported_length_remaining(tvb, offset) != 0) {
expert_add_info_format(pinfo, tree, &ei_llrp_invalid_length,
""Incorrect length of message: %u bytes decoded, but %u bytes available."",
offset, tvb_reported_length(tvb));
}
}","static void
dissect_llrp_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
guint16 VAR_3, guint VAR_4)
{
gboolean    VAR_5;
guint8      VAR_6;
guint16     VAR_7, VAR_8, VAR_9;
guint32     VAR_10, VAR_11;
proto_item *VAR_12, *VAR_13, *VAR_14, *VAR_15;
guint (*VAR_16)(tvbuff_t *VAR_0,
packet_info *VAR_1, proto_tree *VAR_2, guint VAR_4) = NULL;
VAR_5 = FALSE;
switch (VAR_3)
{
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
case VAR_33:
case VAR_34:
case VAR_35:
case VAR_36:
case VAR_37:
case VAR_38:
case VAR_39:
case VAR_40:
case VAR_41:
case VAR_42:
case VAR_43:
VAR_5 = TRUE;
break;
case VAR_44:
case VAR_45:
case VAR_46:
case VAR_47:
case VAR_48:
VAR_10 = tvb_get_ntohl(VAR_0, VAR_4);
if (VAR_10 == VAR_49)
proto_tree_add_uint_format(VAR_2, VAR_50, VAR_0,
VAR_4, 4, VAR_10, ""All ROSpecs (%u)"", VAR_10);
else
proto_tree_add_item(VAR_2, VAR_50, VAR_0,
VAR_4, 4, VAR_51);
VAR_4 += 4;
break;
case VAR_52:
case VAR_53:
case VAR_54:
VAR_10 = tvb_get_ntohl(VAR_0, VAR_4);
if (VAR_10 == VAR_55)
proto_tree_add_uint_format(VAR_2, VAR_56, VAR_0,
VAR_4, 4, VAR_10, ""All Access Specs (%u)"", VAR_10);
else
proto_tree_add_item(VAR_2, VAR_56, VAR_0,
VAR_4, 4, VAR_51);
VAR_4 += 4;
break;
case VAR_57:
proto_tree_add_item(VAR_2, VAR_58, VAR_0, VAR_4, 1, VAR_51);
VAR_4++;
VAR_5 = TRUE;
break;
case VAR_59:
VAR_7 = tvb_get_ntohs(VAR_0, VAR_4);
if (VAR_7 == VAR_60)
VAR_13 = proto_tree_add_uint_format(VAR_2, VAR_61, VAR_0,
VAR_4, 2, VAR_7, ""All Antennas (%u)"", VAR_7);
else
VAR_13 = proto_tree_add_item(VAR_2, VAR_61, VAR_0,
VAR_4, 2, VAR_51);
VAR_4 += 2;
VAR_6 = tvb_get_guint8(VAR_0, VAR_4);
VAR_12 = proto_tree_add_item(VAR_2, VAR_62, VAR_0,
VAR_4, 1, VAR_51);
VAR_4++;
VAR_8 = tvb_get_ntohs(VAR_0, VAR_4);
if (VAR_8 == VAR_63)
VAR_14 = proto_tree_add_uint_format(VAR_2, VAR_64, VAR_0,
VAR_4, 2, VAR_8, ""All GPI Ports (%u)"", VAR_8);
else
VAR_14 = proto_tree_add_item(VAR_2, VAR_64, VAR_0,
VAR_4, 2, VAR_51);
VAR_4 += 2;
VAR_9 = tvb_get_ntohs(VAR_0, VAR_4);
if (VAR_9 == VAR_65)
VAR_15 = proto_tree_add_uint_format(VAR_2, VAR_66, VAR_0,
VAR_4, 2, VAR_9, ""All GPO Ports (%u)"", VAR_9);
else
VAR_15 = proto_tree_add_item(VAR_2, VAR_66, VAR_0,
VAR_4, 2, VAR_51);
VAR_4 += 2;
switch (VAR_6)
{
case VAR_67:
break;
case VAR_68:
case VAR_69:
proto_item_append_text(VAR_14, "" (Ignored)"");
proto_item_append_text(VAR_15, "" (Ignored)"");
break;
case VAR_70:
case VAR_71:
case VAR_72:
case VAR_73:
case VAR_74:
case VAR_75:
case VAR_76:
proto_item_append_text(VAR_13, "" (Ignored)"");
proto_item_append_text(VAR_14, "" (Ignored)"");
proto_item_append_text(VAR_15, "" (Ignored)"");
break;
case VAR_77:
proto_item_append_text(VAR_13, "" (Ignored)"");
proto_item_append_text(VAR_15, "" (Ignored)"");
break;
case VAR_78:
proto_item_append_text(VAR_13, "" (Ignored)"");
proto_item_append_text(VAR_14, "" (Ignored)"");
break;
default:
proto_item_append_text(VAR_13, "" (Ignored)"");
expert_add_info_format(VAR_1, VAR_12, &VAR_79,
""Unrecognized configuration request: %u"",
VAR_6);
proto_item_append_text(VAR_14, "" (Ignored)"");
proto_item_append_text(VAR_15, "" (Ignored)"");
break;
};
VAR_5 = TRUE;
break;
case VAR_80:
proto_tree_add_item(VAR_2, VAR_81, VAR_0, VAR_4, 1, VAR_82);
VAR_4++;
VAR_5 = TRUE;
break;
case VAR_83:
proto_tree_add_item(VAR_2, VAR_84, VAR_0, VAR_4, 1, VAR_51);
break;
case VAR_85:
proto_tree_add_item(VAR_2, VAR_86, VAR_0, VAR_4, 1, VAR_51);
VAR_4++;
proto_tree_add_item(VAR_2, VAR_87, VAR_0, VAR_4, 1, VAR_51);
VAR_4++;
VAR_5 = TRUE;
break;
case VAR_88:
VAR_11 = tvb_get_ntohl(VAR_0, VAR_4);
proto_tree_add_item(VAR_2, VAR_89, VAR_0, VAR_4, 4, VAR_51);
VAR_4 += 4;
switch(VAR_11) {
case VAR_90:
VAR_16 = VAR_91;
VAR_5 = TRUE;
break;
}
if (VAR_16)
VAR_4 = VAR_16(VAR_0, VAR_1, VAR_2, VAR_4);
break;
case VAR_92:
case VAR_93:
case VAR_94:
case VAR_95:
case VAR_96:
break;
default:
DISSECTOR_ASSERT_NOT_REACHED();
};
if(VAR_5) {
VAR_4 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_2, VAR_4, tvb_reported_length(VAR_0));
}
if(tvb_reported_length_remaining(VAR_0, VAR_4) != 0) {
expert_add_info_format(VAR_1, VAR_2, &VAR_97,
""Incorrect length of message: %u bytes decoded, but %u bytes available."",
VAR_4, tvb_reported_length(VAR_0));
}
}",wireshark/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec/packet-llrp.c/vul/before/1.json,"static void
dissect_llrp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
        guint16 type, guint offset)
{
    gboolean    ends_with_parameters;
    guint8      requested_data;
    guint16     antenna_id, gpi_port, gpo_port;
    guint32     spec_id, vendor;
    proto_item *request_item, *antenna_item, *gpi_item, *gpo_item;
    guint (*dissect_custom_message)(tvbuff_t *tvb,
            packet_info *pinfo, proto_tree *tree, guint offset) = NULL;

    ends_with_parameters = FALSE;
    switch (type)
    {
        /* Simple cases just have normal TLV or TV parameters */
        case LLRP_TYPE_CLOSE_CONNECTION_RESPONSE:
        case LLRP_TYPE_GET_READER_CAPABILITIES_RESPONSE:
        case LLRP_TYPE_ADD_ROSPEC:
        case LLRP_TYPE_ADD_ROSPEC_RESPONSE:
        case LLRP_TYPE_DELETE_ROSPEC_RESPONSE:
        case LLRP_TYPE_START_ROSPEC_RESPONSE:
        case LLRP_TYPE_STOP_ROSPEC_RESPONSE:
        case LLRP_TYPE_ENABLE_ROSPEC_RESPONSE:
        case LLRP_TYPE_DISABLE_ROSPEC_RESPONSE:
        case LLRP_TYPE_GET_ROSPECS_RESPONSE:
        case LLRP_TYPE_ADD_ACCESSSPEC:
        case LLRP_TYPE_ADD_ACCESSSPEC_RESPONSE:
        case LLRP_TYPE_DELETE_ACCESSSPEC_RESPONSE:
        case LLRP_TYPE_ENABLE_ACCESSSPEC_RESPONSE:
        case LLRP_TYPE_DISABLE_ACCESSSPEC_RESPONSE:
        case LLRP_TYPE_GET_ACCESSSPECS:
        case LLRP_TYPE_CLIENT_REQUEST_OP:
        case LLRP_TYPE_CLIENT_RESQUEST_OP_RESPONSE:
        case LLRP_TYPE_RO_ACCESS_REPORT:
        case LLRP_TYPE_READER_EVENT_NOTIFICATION:
        case LLRP_TYPE_ERROR_MESSAGE:
        case LLRP_TYPE_GET_READER_CONFIG_RESPONSE:
        case LLRP_TYPE_SET_READER_CONFIG_RESPONSE:
        case LLRP_TYPE_SET_PROTOCOL_VERSION_RESPONSE:
        case LLRP_TYPE_GET_ACCESSSPECS_RESPONSE:
        case LLRP_TYPE_GET_REPORT:
        case LLRP_TYPE_ENABLE_EVENTS_AND_REPORTS:
            ends_with_parameters = TRUE;
            break;
        /* Some just have an ROSpec ID */
        case LLRP_TYPE_START_ROSPEC:
        case LLRP_TYPE_STOP_ROSPEC:
        case LLRP_TYPE_ENABLE_ROSPEC:
        case LLRP_TYPE_DISABLE_ROSPEC:
        case LLRP_TYPE_DELETE_ROSPEC:
            spec_id = tvb_get_ntohl(tvb, offset);
            if (spec_id == LLRP_ROSPEC_ALL)
                proto_tree_add_uint_format(tree, hf_llrp_rospec, tvb,
                        offset, 4, spec_id, ""All ROSpecs (%u)"", spec_id);
            else
                proto_tree_add_item(tree, hf_llrp_rospec, tvb,
                        offset, 4, ENC_BIG_ENDIAN);
            offset += 4;
            break;
        /* Some just have an AccessSpec ID */
        case LLRP_TYPE_ENABLE_ACCESSSPEC:
        case LLRP_TYPE_DELETE_ACCESSSPEC:
        case LLRP_TYPE_DISABLE_ACCESSSPEC:
            spec_id = tvb_get_ntohl(tvb, offset);
            if (spec_id == LLRP_ACCESSSPEC_ALL)
                proto_tree_add_uint_format(tree, hf_llrp_accessspec, tvb,
                        offset, 4, spec_id, ""All Access Specs (%u)"", spec_id);
            else
                proto_tree_add_item(tree, hf_llrp_accessspec, tvb,
                        offset, 4, ENC_BIG_ENDIAN);
            offset += 4;
            break;
        case LLRP_TYPE_GET_READER_CAPABILITIES:
            proto_tree_add_item(tree, hf_llrp_req_cap, tvb, offset, 1, ENC_BIG_ENDIAN);
            offset++;
            ends_with_parameters = TRUE;
            break;
        /* GET_READER_CONFIG is more complicated */
        case LLRP_TYPE_GET_READER_CONFIG:
            antenna_id = tvb_get_ntohs(tvb, offset);
            if (antenna_id == LLRP_ANTENNA_ALL)
                antenna_item = proto_tree_add_uint_format(tree, hf_llrp_antenna_id, tvb,
                        offset, 2, antenna_id, ""All Antennas (%u)"", antenna_id);
            else
                antenna_item = proto_tree_add_item(tree, hf_llrp_antenna_id, tvb,
                        offset, 2, ENC_BIG_ENDIAN);
            offset += 2;

            requested_data = tvb_get_guint8(tvb, offset);
            request_item = proto_tree_add_item(tree, hf_llrp_req_conf, tvb,
                    offset, 1, ENC_BIG_ENDIAN);
            offset++;

            gpi_port = tvb_get_ntohs(tvb, offset);
            if (gpi_port == LLRP_GPI_PORT_ALL)
                gpi_item = proto_tree_add_uint_format(tree, hf_llrp_gpi_port, tvb,
                        offset, 2, gpi_port, ""All GPI Ports (%u)"", gpi_port);
            else
                gpi_item = proto_tree_add_item(tree, hf_llrp_gpi_port, tvb,
                        offset, 2, ENC_BIG_ENDIAN);
            offset += 2;

            gpo_port = tvb_get_ntohs(tvb, offset);
            if (gpo_port == LLRP_GPO_PORT_ALL)
                gpo_item = proto_tree_add_uint_format(tree, hf_llrp_gpo_port, tvb,
                        offset, 2, gpo_port, ""All GPO Ports (%u)"", gpo_port);
            else
                gpo_item = proto_tree_add_item(tree, hf_llrp_gpo_port, tvb,
                        offset, 2, ENC_BIG_ENDIAN);
            offset += 2;

            switch (requested_data)
            {
                case LLRP_CONF_ALL:
                    break;
                case LLRP_CONF_ANTENNA_PROPERTIES:
                case LLRP_CONF_ANTENNA_CONFIGURATION:
                    /* Ignore both GPI and GPO ports */
                    proto_item_append_text(gpi_item, "" (Ignored)"");
                    proto_item_append_text(gpo_item, "" (Ignored)"");
                    break;
                case LLRP_CONF_IDENTIFICATION:
                case LLRP_CONF_RO_REPORT_SPEC:
                case LLRP_CONF_READER_EVENT_NOTIFICATION_SPEC:
                case LLRP_CONF_ACCESS_REPORT_SPEC:
                case LLRP_CONF_LLRP_CONFIGURATION_STATE:
                case LLRP_CONF_KEEPALIVE_SPEC:
                case LLRP_CONF_EVENTS_AND_REPORTS:
                    /* Ignore antenna ID */
                    proto_item_append_text(antenna_item, "" (Ignored)"");
                    /* Ignore both GPI and GPO ports */
                    proto_item_append_text(gpi_item, "" (Ignored)"");
                    proto_item_append_text(gpo_item, "" (Ignored)"");
                    break;
                case LLRP_CONF_GPI_PORT_CURRENT_STATE:
                    /* Ignore antenna ID */
                    proto_item_append_text(antenna_item, "" (Ignored)"");
                    /* Ignore GPO port */
                    proto_item_append_text(gpo_item, "" (Ignored)"");
                    break;
                case LLRP_CONF_GPO_WRITE_DATA:
                    /* Ignore antenna ID */
                    proto_item_append_text(antenna_item, "" (Ignored)"");
                    /* Ignore GPI port */
                    proto_item_append_text(gpi_item, "" (Ignored)"");
                    break;
                default:
                    /* Ignore antenna ID */
                    proto_item_append_text(antenna_item, "" (Ignored)"");
                    /* Tell the user that we are confused */
                    expert_add_info_format(pinfo, request_item, &ei_llrp_req_conf,
                            ""Unrecognized configuration request: %u"",
                            requested_data);
                    /* Ignore both GPI and GPO ports */
                    proto_item_append_text(gpi_item, "" (Ignored)"");
                    proto_item_append_text(gpo_item, "" (Ignored)"");
                    break;
            };
            ends_with_parameters = TRUE;
            break;
        /* END GET_READER_CONFIG */
        /* Misc */
        case LLRP_TYPE_SET_READER_CONFIG:
            proto_tree_add_item(tree, hf_llrp_rest_fact, tvb, offset, 1, ENC_NA);
            offset++;
            ends_with_parameters = TRUE;
            break;
        case LLRP_TYPE_SET_PROTOCOL_VERSION:
            proto_tree_add_item(tree, hf_llrp_version, tvb, offset, 1, ENC_BIG_ENDIAN);
            break;
        case LLRP_TYPE_GET_SUPPORTED_VERSION_RESPONSE:
            proto_tree_add_item(tree, hf_llrp_cur_ver, tvb, offset, 1, ENC_BIG_ENDIAN);
            offset++;
            proto_tree_add_item(tree, hf_llrp_sup_ver, tvb, offset, 1, ENC_BIG_ENDIAN);
            offset++;
            ends_with_parameters = TRUE;
            break;
        case LLRP_TYPE_CUSTOM_MESSAGE:
            vendor = tvb_get_ntohl(tvb, offset);
            proto_tree_add_item(tree, hf_llrp_vendor, tvb, offset, 4, ENC_BIG_ENDIAN);
            offset += 4;
            /* Do vendor specific dissection */
            switch(vendor) {
            case LLRP_VENDOR_IMPINJ:
                dissect_custom_message = dissect_llrp_impinj_message;
                ends_with_parameters = TRUE;
                break;
            }
            if (dissect_custom_message)
                offset = dissect_custom_message(tvb, pinfo, tree, offset);
            break;
        /* Some have no extra data expected */
        case LLRP_TYPE_KEEPALIVE:
        case LLRP_TYPE_KEEPALIVE_ACK:
        case LLRP_TYPE_CLOSE_CONNECTION:
        case LLRP_TYPE_GET_ROSPECS:
        case LLRP_TYPE_GET_SUPPORTED_VERSION:
            break;
        default:
            /* We shouldn't be called if we don't already recognize the value */
            DISSECTOR_ASSERT_NOT_REACHED();
    };
    if(ends_with_parameters) {
        offset = dissect_llrp_parameters(tvb, pinfo, tree, offset, tvb_reported_length(tvb), 0);
    }
    if(tvb_reported_length_remaining(tvb, offset) != 0) {
        /* Report problem */
        expert_add_info_format(pinfo, tree, &ei_llrp_invalid_length,
                ""Incorrect length of message: %u bytes decoded, but %u bytes available."",
                offset, tvb_reported_length(tvb));
    }
}","static void
dissect_llrp_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
        guint16 VAR_3, guint VAR_4)
{
    gboolean    VAR_5;
    guint8      VAR_6;
    guint16     VAR_7, VAR_8, VAR_9;
    guint32     VAR_10, VAR_11;
    proto_item *VAR_12, *VAR_13, *VAR_14, *VAR_15;
    guint (*VAR_16)(tvbuff_t *VAR_0,
            packet_info *VAR_1, proto_tree *VAR_2, guint VAR_4) = NULL;

    VAR_5 = FALSE;
    switch (VAR_3)
    {
        /* COMMENT_0 */
        case VAR_17:
        case VAR_18:
        case VAR_19:
        case VAR_20:
        case VAR_21:
        case VAR_22:
        case VAR_23:
        case VAR_24:
        case VAR_25:
        case VAR_26:
        case VAR_27:
        case VAR_28:
        case VAR_29:
        case VAR_30:
        case VAR_31:
        case VAR_32:
        case VAR_33:
        case VAR_34:
        case VAR_35:
        case VAR_36:
        case VAR_37:
        case VAR_38:
        case VAR_39:
        case VAR_40:
        case VAR_41:
        case VAR_42:
        case VAR_43:
            VAR_5 = TRUE;
            break;
        /* COMMENT_1 */
        case VAR_44:
        case VAR_45:
        case VAR_46:
        case VAR_47:
        case VAR_48:
            VAR_10 = tvb_get_ntohl(VAR_0, VAR_4);
            if (VAR_10 == VAR_49)
                proto_tree_add_uint_format(VAR_2, VAR_50, VAR_0,
                        VAR_4, 4, VAR_10, ""All ROSpecs (%u)"", VAR_10);
            else
                proto_tree_add_item(VAR_2, VAR_50, VAR_0,
                        VAR_4, 4, VAR_51);
            VAR_4 += 4;
            break;
        /* COMMENT_2 */
        case VAR_52:
        case VAR_53:
        case VAR_54:
            VAR_10 = tvb_get_ntohl(VAR_0, VAR_4);
            if (VAR_10 == VAR_55)
                proto_tree_add_uint_format(VAR_2, VAR_56, VAR_0,
                        VAR_4, 4, VAR_10, ""All Access Specs (%u)"", VAR_10);
            else
                proto_tree_add_item(VAR_2, VAR_56, VAR_0,
                        VAR_4, 4, VAR_51);
            VAR_4 += 4;
            break;
        case VAR_57:
            proto_tree_add_item(VAR_2, VAR_58, VAR_0, VAR_4, 1, VAR_51);
            VAR_4++;
            VAR_5 = TRUE;
            break;
        /* COMMENT_3 */
        case VAR_59:
            VAR_7 = tvb_get_ntohs(VAR_0, VAR_4);
            if (VAR_7 == VAR_60)
                VAR_13 = proto_tree_add_uint_format(VAR_2, VAR_61, VAR_0,
                        VAR_4, 2, VAR_7, ""All Antennas (%u)"", VAR_7);
            else
                VAR_13 = proto_tree_add_item(VAR_2, VAR_61, VAR_0,
                        VAR_4, 2, VAR_51);
            VAR_4 += 2;

            VAR_6 = tvb_get_guint8(VAR_0, VAR_4);
            VAR_12 = proto_tree_add_item(VAR_2, VAR_62, VAR_0,
                    VAR_4, 1, VAR_51);
            VAR_4++;

            VAR_8 = tvb_get_ntohs(VAR_0, VAR_4);
            if (VAR_8 == VAR_63)
                VAR_14 = proto_tree_add_uint_format(VAR_2, VAR_64, VAR_0,
                        VAR_4, 2, VAR_8, ""All GPI Ports (%u)"", VAR_8);
            else
                VAR_14 = proto_tree_add_item(VAR_2, VAR_64, VAR_0,
                        VAR_4, 2, VAR_51);
            VAR_4 += 2;

            VAR_9 = tvb_get_ntohs(VAR_0, VAR_4);
            if (VAR_9 == VAR_65)
                VAR_15 = proto_tree_add_uint_format(VAR_2, VAR_66, VAR_0,
                        VAR_4, 2, VAR_9, ""All GPO Ports (%u)"", VAR_9);
            else
                VAR_15 = proto_tree_add_item(VAR_2, VAR_66, VAR_0,
                        VAR_4, 2, VAR_51);
            VAR_4 += 2;

            switch (VAR_6)
            {
                case VAR_67:
                    break;
                case VAR_68:
                case VAR_69:
                    /* COMMENT_4 */
                    proto_item_append_text(VAR_14, "" (Ignored)"");
                    proto_item_append_text(VAR_15, "" (Ignored)"");
                    break;
                case VAR_70:
                case VAR_71:
                case VAR_72:
                case VAR_73:
                case VAR_74:
                case VAR_75:
                case VAR_76:
                    /* COMMENT_5 */
                    proto_item_append_text(VAR_13, "" (Ignored)"");
                    /* COMMENT_4 */
                    proto_item_append_text(VAR_14, "" (Ignored)"");
                    proto_item_append_text(VAR_15, "" (Ignored)"");
                    break;
                case VAR_77:
                    /* COMMENT_5 */
                    proto_item_append_text(VAR_13, "" (Ignored)"");
                    /* COMMENT_6 */
                    proto_item_append_text(VAR_15, "" (Ignored)"");
                    break;
                case VAR_78:
                    /* COMMENT_5 */
                    proto_item_append_text(VAR_13, "" (Ignored)"");
                    /* COMMENT_7 */
                    proto_item_append_text(VAR_14, "" (Ignored)"");
                    break;
                default:
                    /* COMMENT_5 */
                    proto_item_append_text(VAR_13, "" (Ignored)"");
                    /* COMMENT_8 */
                    expert_add_info_format(VAR_1, VAR_12, &VAR_79,
                            ""Unrecognized configuration request: %u"",
                            VAR_6);
                    /* COMMENT_4 */
                    proto_item_append_text(VAR_14, "" (Ignored)"");
                    proto_item_append_text(VAR_15, "" (Ignored)"");
                    break;
            };
            VAR_5 = TRUE;
            break;
        /* COMMENT_9 */
        /* COMMENT_10 */
        case VAR_80:
            proto_tree_add_item(VAR_2, VAR_81, VAR_0, VAR_4, 1, VAR_82);
            VAR_4++;
            VAR_5 = TRUE;
            break;
        case VAR_83:
            proto_tree_add_item(VAR_2, VAR_84, VAR_0, VAR_4, 1, VAR_51);
            break;
        case VAR_85:
            proto_tree_add_item(VAR_2, VAR_86, VAR_0, VAR_4, 1, VAR_51);
            VAR_4++;
            proto_tree_add_item(VAR_2, VAR_87, VAR_0, VAR_4, 1, VAR_51);
            VAR_4++;
            VAR_5 = TRUE;
            break;
        case VAR_88:
            VAR_11 = tvb_get_ntohl(VAR_0, VAR_4);
            proto_tree_add_item(VAR_2, VAR_89, VAR_0, VAR_4, 4, VAR_51);
            VAR_4 += 4;
            /* COMMENT_11 */
            switch(VAR_11) {
            case VAR_90:
                VAR_16 = VAR_91;
                VAR_5 = TRUE;
                break;
            }
            if (VAR_16)
                VAR_4 = VAR_16(VAR_0, VAR_1, VAR_2, VAR_4);
            break;
        /* COMMENT_12 */
        case VAR_92:
        case VAR_93:
        case VAR_94:
        case VAR_95:
        case VAR_96:
            break;
        default:
            /* COMMENT_13 */
            DISSECTOR_ASSERT_NOT_REACHED();
    };
    if(VAR_5) {
        VAR_4 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_2, VAR_4, tvb_reported_length(VAR_0), 0);
    }
    if(tvb_reported_length_remaining(VAR_0, VAR_4) != 0) {
        /* COMMENT_14 */
        expert_add_info_format(VAR_1, VAR_2, &VAR_97,
                ""Incorrect length of message: %u bytes decoded, but %u bytes available."",
                VAR_4, tvb_reported_length(VAR_0));
    }
}",wireshark/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec/packet-llrp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -202,7 +202,7 @@
             DISSECTOR_ASSERT_NOT_REACHED();
     };
     if(ends_with_parameters) {
-        offset = dissect_llrp_parameters(tvb, pinfo, tree, offset, tvb_reported_length(tvb));
+        offset = dissect_llrp_parameters(tvb, pinfo, tree, offset, tvb_reported_length(tvb), 0);
     }
     if(tvb_reported_length_remaining(tvb, offset) != 0) {
         /* Report problem */","{'deleted_lines': ['        offset = dissect_llrp_parameters(tvb, pinfo, tree, offset, tvb_reported_length(tvb));'], 'added_lines': ['        offset = dissect_llrp_parameters(tvb, pinfo, tree, offset, tvb_reported_length(tvb), 0);']}",True,"The dissect_llrp_parameters function in epan/dissectors/packet-llrp.c in the LLRP dissector in Wireshark 1.12.x before 1.12.10 and 2.0.x before 2.0.2 does not limit the recursion depth, which allows remote attackers to cause a denial of service (memory consumption or application crash) via a crafted packet.",5.9,MEDIUM,1,valid,2016-02-06T14:33:28Z,1
CVE-2016-2532,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"llrp: limit recursion depth

LLRP defines fairly complex parameter nesting which we handle via recursion,
however this means a large crafted packet could cause very deep stacks and
potentially stack overflows. Limit our recursive depth to an arbitrary, which
should be more than enough for any legitimate packet (I hope).

Bug: 12048
Change-Id: I9ac31bddfa4ffd1a79809387d10d2261749b95e7
Reviewed-on: https://code.wireshark.org/review/13794
Reviewed-by: Evan Huus <eapache@gmail.com>",4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec,https://github.com/wireshark/wireshark/commit/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec,epan/dissectors/packet-llrp.c,dissect_llrp_parameters,"static guint
dissect_llrp_parameters(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
guint offset, const guint end)
{
guint8      has_length;
guint16     len, type;
guint       real_len, param_end;
guint       suboffset;
guint       num;
proto_item *ti;
proto_tree *param_tree;
while (((gint)(end - offset)) > 0)
{
has_length = !(tvb_get_guint8(tvb, offset) & 0x80);
if (has_length)
{
type = tvb_get_ntohs(tvb, offset);
len = tvb_get_ntohs(tvb, offset + 2);
if (len < LLRP_TLV_LEN_MIN)
real_len = LLRP_TLV_LEN_MIN;
else if (len > tvb_reported_length_remaining(tvb, offset))
real_len = tvb_reported_length_remaining(tvb, offset);
else
real_len = len;
param_end = offset + real_len;
ti = proto_tree_add_none_format(tree, hf_llrp_param, tvb,
offset, real_len, ""TLV Parameter: %s"",
val_to_str_ext(type, &tlv_type_ext, ""Unknown Type: %d""));
param_tree = proto_item_add_subtree(ti, ett_llrp_param);
proto_tree_add_item(param_tree, hf_llrp_tlv_type, tvb,
offset, 2, ENC_BIG_ENDIAN);
offset += 2;
ti = proto_tree_add_item(param_tree, hf_llrp_tlv_len, tvb,
offset, 2, ENC_BIG_ENDIAN);
if (len != real_len)
expert_add_info_format(pinfo, ti, &ei_llrp_invalid_length,
""Invalid length field: claimed %u, should be %u."",
len, real_len);
offset += 2;
suboffset = offset;
switch(type) {
case LLRP_TLV_RO_BOUND_SPEC:
case LLRP_TLV_UHF_CAPABILITIES:
case LLRP_TLV_ACCESS_COMMAND:
case LLRP_TLV_TAG_REPORT_DATA:
case LLRP_TLV_RF_SURVEY_REPORT_DATA:
case LLRP_TLV_READER_EVENT_NOTI_SPEC:
case LLRP_TLV_READER_EVENT_NOTI_DATA:
case LLRP_TLV_C1G2_UHF_RF_MD_TBL:
case LLRP_TLV_C1G2_TAG_SPEC:
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_UTC_TIMESTAMP:
case LLRP_TLV_UPTIME:
PARAM_TREE_ADD(microseconds, 8, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_GENERAL_DEVICE_CAP:
PARAM_TREE_ADD_STAY(max_supported_antenna, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(can_set_antenna_prop, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(has_utc_clock, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(device_manufacturer, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(model, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firmware_version, suboffset);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_MAX_RECEIVE_SENSE:
PARAM_TREE_ADD(max_receive_sense, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_RECEIVE_SENSE_ENTRY:
PARAM_TREE_ADD(index, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(receive_sense, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_ANTENNA_RCV_SENSE_RANGE:
PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(receive_sense_index_min, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(receive_sense_index_max, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_ANTENNA_AIR_PROTO:
PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
hf_llrp_num_protocols, hf_llrp_protocol_id, 1, suboffset);
break;
case LLRP_TLV_GPIO_CAPABILITIES:
PARAM_TREE_ADD(num_gpi, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(num_gpo, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_LLRP_CAPABILITIES:
PARAM_TREE_ADD_STAY(can_do_survey, 1, ENC_NA);
PARAM_TREE_ADD_STAY(can_report_buffer_warning, 1, ENC_NA);
PARAM_TREE_ADD_STAY(support_client_opspec, 1, ENC_NA);
PARAM_TREE_ADD_STAY(can_stateaware, 1, ENC_NA);
PARAM_TREE_ADD(support_holding, 1, ENC_NA);
PARAM_TREE_ADD(max_priority_supported, 1, ENC_NA);
PARAM_TREE_ADD(client_opspec_timeout, 2, ENC_BIG_ENDIAN);
num = tvb_get_ntohl(tvb, suboffset);
if(num == LLRP_NO_LIMIT)
PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_rospec, 4, num, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(max_num_rospec, 4, ENC_BIG_ENDIAN);
suboffset += 4;
num = tvb_get_ntohl(tvb, suboffset);
if(num == LLRP_NO_LIMIT)
PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_spec_per_rospec, 4, num, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(max_num_spec_per_rospec, 4, ENC_BIG_ENDIAN);
suboffset += 4;
num = tvb_get_ntohl(tvb, suboffset);
if(num == LLRP_NO_LIMIT)
PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_inventory_per_aispec, 4, num, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(max_num_inventory_per_aispec, 4, ENC_BIG_ENDIAN);
suboffset += 4;
num = tvb_get_ntohl(tvb, suboffset);
if(num == LLRP_NO_LIMIT)
PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_accessspec, 4, num, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(max_num_accessspec, 4, ENC_BIG_ENDIAN);
suboffset += 4;
num = tvb_get_ntohl(tvb, suboffset);
if(num == LLRP_NO_LIMIT)
PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_opspec_per_accressspec, 4, num, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(max_num_opspec_per_accressspec, 4, ENC_BIG_ENDIAN);
suboffset += 4;
break;
case LLRP_TLV_REGU_CAPABILITIES:
PARAM_TREE_ADD(country_code, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(comm_standard, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_XMIT_POWER_LEVEL_ENTRY:
PARAM_TREE_ADD(index, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(transmit_power, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_FREQ_INFORMATION:
PARAM_TREE_ADD(hopping, 1, ENC_NA);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_FREQ_HOP_TABLE:
PARAM_TREE_ADD(hop_table_id, 1, ENC_NA);
PARAM_TREE_ADD(rfu, 1, ENC_NA);
suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
hf_llrp_num_hops, hf_llrp_frequency, 4, suboffset);
break;
case LLRP_TLV_FIXED_FREQ_TABLE:
suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
hf_llrp_num_freqs, hf_llrp_frequency, 4, suboffset);
break;
case LLRP_TLV_RF_SURVEY_FREQ_CAP:
PARAM_TREE_ADD(min_freq, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(max_freq, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_RO_SPEC:
PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(priority, 1, ENC_NA);
PARAM_TREE_ADD(cur_state, 1, ENC_NA);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_RO_SPEC_START_TRIGGER:
PARAM_TREE_ADD(rospec_start_trig_type, 1, ENC_NA);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_PER_TRIGGER_VAL:
PARAM_TREE_ADD(offset, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(period, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_GPI_TRIGGER_VAL:
PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(gpi_event, 1, ENC_NA);
PARAM_TREE_ADD(timeout, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_RO_SPEC_STOP_TRIGGER:
PARAM_TREE_ADD(rospec_stop_trig_type, 1, ENC_NA);
PARAM_TREE_ADD(duration_trig, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_AI_SPEC:
suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
hf_llrp_antenna_count, hf_llrp_antenna, 2, suboffset);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_AI_SPEC_STOP:
PARAM_TREE_ADD(aispec_stop_trig_type, 1, ENC_NA);
PARAM_TREE_ADD(duration_trig, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_TAG_OBSERV_TRIGGER:
PARAM_TREE_ADD(trig_type, 1, ENC_NA);
PARAM_TREE_ADD(rfu, 1, ENC_NA);
PARAM_TREE_ADD(number_of_tags, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(number_of_attempts, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(t, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(timeout, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_INVENTORY_PARAM_SPEC:
PARAM_TREE_ADD(inventory_spec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(protocol_id, 1, ENC_NA);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_RF_SURVEY_SPEC:
PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(start_freq, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(stop_freq, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_RF_SURVEY_SPEC_STOP_TR:
PARAM_TREE_ADD(stop_trig_type, 1, ENC_NA);
PARAM_TREE_ADD(duration, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(n_4, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_LOOP_SPEC:
PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_ACCESS_SPEC:
PARAM_TREE_ADD(accessspec_id, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(protocol_id, 1, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_cur_state, 1, ENC_NA);
PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_ACCESS_SPEC_STOP_TRIG:
PARAM_TREE_ADD(access_stop_trig_type, 1, ENC_NA);
PARAM_TREE_ADD(operation_count, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_CLIENT_REQ_OP_SPEC:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_CLIENT_REQ_RESPONSE:
PARAM_TREE_ADD(accessspec_id, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_LLRP_CONF_STATE_VAL:
PARAM_TREE_ADD(conf_value, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_IDENT:
PARAM_TREE_ADD(id_type, 1, ENC_NA);
num = tvb_get_ntohs(tvb, suboffset);
PARAM_TREE_ADD(reader_id, 2, ENC_BIG_ENDIAN);
suboffset += num;
break;
case LLRP_TLV_GPO_WRITE_DATA:
PARAM_TREE_ADD(gpo_port, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(gpo_data, 1, ENC_NA);
break;
case LLRP_TLV_KEEPALIVE_SPEC:
PARAM_TREE_ADD(keepalive_trig_type, 1, ENC_NA);
PARAM_TREE_ADD(time_iterval, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_ANTENNA_PROPS:
PARAM_TREE_ADD(antenna_connected, 1, ENC_NA);
PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(antenna_gain, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_ANTENNA_CONF:
PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_RF_RECEIVER:
PARAM_TREE_ADD(receiver_sense, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_RF_TRANSMITTER:
PARAM_TREE_ADD(hop_table_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(channel_idx, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(transmit_power, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_GPI_PORT_CURRENT_STATE:
PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(gpi_config, 1, ENC_NA);
PARAM_TREE_ADD(gpi_state, 1, ENC_NA);
break;
case LLRP_TLV_EVENTS_AND_REPORTS:
PARAM_TREE_ADD(hold_events_and_reports, 1, ENC_NA);
break;
case LLRP_TLV_RO_REPORT_SPEC:
PARAM_TREE_ADD(ro_report_trig, 1, ENC_NA);
PARAM_TREE_ADD(n_2, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_TAG_REPORT_CONTENT_SEL:
PARAM_TREE_ADD_STAY(enable_rospec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_spec_idx, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_inv_spec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_antenna_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_channel_idx, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_peak_rssi, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_first_seen, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_last_seen, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(enable_seen_count, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(enable_accessspec_id, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_ACCESS_REPORT_SPEC:
PARAM_TREE_ADD(access_report_trig, 1, ENC_NA);
break;
case LLRP_TLV_EPC_DATA:
suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_epc, suboffset);
break;
case LLRP_TLV_FREQ_RSSI_LEVEL_ENTRY:
PARAM_TREE_ADD(frequency, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(bandwidth, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(average_rssi, 1, ENC_NA);
PARAM_TREE_ADD(peak_rssi, 1, ENC_NA);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_EVENT_NOTIF_STATE:
PARAM_TREE_ADD(event_type, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(notif_state, 1, ENC_NA);
break;
case LLRP_TLV_HOPPING_EVENT:
PARAM_TREE_ADD(hop_table_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(next_chan_idx, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_GPI_EVENT:
PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(gpi_event, 1, ENC_NA);
break;
case LLRP_TLV_RO_SPEC_EVENT:
PARAM_TREE_ADD(roevent_type, 1, ENC_NA);
PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(prem_rospec_id, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_REPORT_BUF_LEVEL_WARN:
PARAM_TREE_ADD(buffer_full_percentage, 1, ENC_NA);
break;
case LLRP_TLV_REPORT_BUF_OVERFLOW_ERR:
break;
case LLRP_TLV_READER_EXCEPTION_EVENT:
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_message, suboffset);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_RF_SURVEY_EVENT:
PARAM_TREE_ADD(rfevent_type, 1, ENC_NA);
PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(spec_idx, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_AI_SPEC_EVENT:
PARAM_TREE_ADD(aievent_type, 1, ENC_NA);
PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(spec_idx, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_ANTENNA_EVENT:
PARAM_TREE_ADD(antenna_event_type, 1, ENC_NA);
PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_CONN_ATTEMPT_EVENT:
PARAM_TREE_ADD(conn_status, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_CONN_CLOSE_EVENT:
break;
case LLRP_TLV_SPEC_LOOP_EVENT:
PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_LLRP_STATUS:
PARAM_TREE_ADD(status_code, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_error_desc, suboffset);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_FIELD_ERROR:
PARAM_TREE_ADD(field_num, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(error_code, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_PARAM_ERROR:
PARAM_TREE_ADD(parameter_type, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(error_code, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_C1G2_LLRP_CAP:
PARAM_TREE_ADD_STAY(can_support_block_erase, 1, ENC_NA);
PARAM_TREE_ADD_STAY(can_support_block_write, 1, ENC_NA);
PARAM_TREE_ADD_STAY(can_support_block_permalock, 1, ENC_NA);
PARAM_TREE_ADD_STAY(can_support_tag_recomm, 1, ENC_NA);
PARAM_TREE_ADD_STAY(can_support_UMI_method2, 1, ENC_NA);
PARAM_TREE_ADD(can_support_XPC, 1, ENC_NA);
num = tvb_get_ntohs(tvb, suboffset);
if(num == LLRP_NO_LIMIT)
PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_filter_per_query, 2, num, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(max_num_filter_per_query, 2, ENC_BIG_ENDIAN);
suboffset += 2;
break;
case LLRP_TLV_C1G2_UHF_RF_MD_TBL_ENT:
PARAM_TREE_ADD(mode_ident, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(DR, 1, ENC_NA);
PARAM_TREE_ADD(hag_conformance, 1, ENC_NA);
PARAM_TREE_ADD(mod, 1, ENC_NA);
PARAM_TREE_ADD(flm, 1, ENC_NA);
PARAM_TREE_ADD(m, 1, ENC_NA);
PARAM_TREE_ADD(bdr, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(pie, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(min_tari, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(max_tari, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(step_tari, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_C1G2_INVENTORY_COMMAND:
PARAM_TREE_ADD(inventory_state_aware, 1, ENC_NA);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_C1G2_FILTER:
PARAM_TREE_ADD(trunc, 1, ENC_NA);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_C1G2_TAG_INV_MASK:
PARAM_TREE_ADD(mb, 1, ENC_NA);
PARAM_TREE_ADD(pointer, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_tag_mask, suboffset);
break;
case LLRP_TLV_C1G2_TAG_INV_AWARE_FLTR:
PARAM_TREE_ADD(aware_filter_target, 1, ENC_NA);
PARAM_TREE_ADD(aware_filter_action, 1, ENC_NA);
break;
case LLRP_TLV_C1G2_TAG_INV_UNAWR_FLTR:
PARAM_TREE_ADD(unaware_filter_action, 1, ENC_NA);
break;
case LLRP_TLV_C1G2_RF_CONTROL:
PARAM_TREE_ADD(mode_idx, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(tari, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_C1G2_SINGULATION_CTRL:
PARAM_TREE_ADD(session, 1, ENC_NA);
PARAM_TREE_ADD(tag_population, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(tag_transit_time, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_C1G2_TAG_INV_AWARE_SING:
PARAM_TREE_ADD_STAY(sing_i, 1, ENC_NA);
PARAM_TREE_ADD_STAY(sing_s, 1, ENC_NA);
PARAM_TREE_ADD(sing_a, 1, ENC_NA);
break;
case LLRP_TLV_C1G2_TARGET_TAG:
PARAM_TREE_ADD_STAY(mb, 1, ENC_NA);
PARAM_TREE_ADD(match, 1, ENC_NA);
PARAM_TREE_ADD(pointer, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_tag_mask, suboffset);
suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_tag_data, suboffset);
break;
case LLRP_TLV_C1G2_READ:
case LLRP_TLV_C1G2_BLK_ERASE:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(mb, 1, ENC_NA);
PARAM_TREE_ADD(word_pointer, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(word_count, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_C1G2_WRITE:
case LLRP_TLV_C1G2_BLK_WRITE:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(mb, 1, ENC_NA);
PARAM_TREE_ADD(word_pointer, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_write_data, suboffset);
break;
case LLRP_TLV_C1G2_KILL:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(kill_pass, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_C1G2_RECOMMISSION:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(kill_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD_STAY(kill_3, 1, ENC_NA);
PARAM_TREE_ADD_STAY(kill_2, 1, ENC_NA);
PARAM_TREE_ADD(kill_l, 1, ENC_NA);
break;
case LLRP_TLV_C1G2_LOCK:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
break;
case LLRP_TLV_C1G2_LOCK_PAYLOAD:
PARAM_TREE_ADD(privilege, 1, ENC_NA);
PARAM_TREE_ADD(data_field, 1, ENC_NA);
break;
case LLRP_TLV_C1G2_BLK_PERMALOCK:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(mb, 1, ENC_NA);
PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_block_mask, suboffset);
break;
case LLRP_TLV_C1G2_GET_BLK_PERMALOCK:
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(mb, 1, ENC_NA);
PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(block_range, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_C1G2_EPC_MEMORY_SLCTOR:
PARAM_TREE_ADD_STAY(enable_crc, 1, ENC_NA);
PARAM_TREE_ADD_STAY(enable_pc, 1, ENC_NA);
PARAM_TREE_ADD(enable_xpc, 1, ENC_NA);
break;
case LLRP_TLV_C1G2_READ_OP_SPEC_RES:
PARAM_TREE_ADD(access_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_read_data, suboffset);
break;
case LLRP_TLV_C1G2_WRT_OP_SPEC_RES:
case LLRP_TLV_C1G2_BLK_WRT_OP_SPC_RES:
PARAM_TREE_ADD(access_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
PARAM_TREE_ADD(num_words_written, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_C1G2_KILL_OP_SPEC_RES:
case LLRP_TLV_C1G2_RECOM_OP_SPEC_RES:
case LLRP_TLV_C1G2_LOCK_OP_SPEC_RES:
case LLRP_TLV_C1G2_BLK_ERS_OP_SPC_RES:
case LLRP_TLV_C1G2_BLK_PRL_OP_SPC_RES:
PARAM_TREE_ADD(access_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TLV_C1G2_BLK_PRL_STAT_RES:
PARAM_TREE_ADD(access_result, 1, ENC_NA);
PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_permlock_status, suboffset);
break;
case LLRP_TLV_CUSTOM_PARAMETER:
num = tvb_get_ntohl(tvb, suboffset);
PARAM_TREE_ADD(vendor_id, 4, ENC_BIG_ENDIAN);
switch(num) {
case LLRP_VENDOR_IMPINJ:
suboffset = dissect_llrp_impinj_parameter(tvb, pinfo, param_tree, suboffset, param_end);
break;
}
break;
}
if(suboffset != param_end) {
expert_add_info_format(pinfo, param_tree, &ei_llrp_invalid_length,
""Incorrect length of parameter: %u bytes decoded, but %u bytes claimed."",
suboffset - offset + 4, real_len);
}
offset += real_len - 4;
}
else
{
type = tvb_get_guint8(tvb, offset) & 0x7F;
switch (type)
{
case LLRP_TV_ANTENNA_ID:
real_len = LLRP_TV_LEN_ANTENNA_ID; break;
case LLRP_TV_FIRST_SEEN_TIME_UTC:
real_len = LLRP_TV_LEN_FIRST_SEEN_TIME_UTC; break;
case LLRP_TV_FIRST_SEEN_TIME_UPTIME:
real_len = LLRP_TV_LEN_FIRST_SEEN_TIME_UPTIME; break;
case LLRP_TV_LAST_SEEN_TIME_UTC:
real_len = LLRP_TV_LEN_LAST_SEEN_TIME_UTC; break;
case LLRP_TV_LAST_SEEN_TIME_UPTIME:
real_len = LLRP_TV_LEN_LAST_SEEN_TIME_UPTIME; break;
case LLRP_TV_PEAK_RSSI:
real_len = LLRP_TV_LEN_PEAK_RSSI; break;
case LLRP_TV_CHANNEL_INDEX:
real_len = LLRP_TV_LEN_CHANNEL_INDEX; break;
case LLRP_TV_TAG_SEEN_COUNT:
real_len = LLRP_TV_LEN_TAG_SEEN_COUNT; break;
case LLRP_TV_RO_SPEC_ID:
real_len = LLRP_TV_LEN_RO_SPEC_ID; break;
case LLRP_TV_INVENTORY_PARAM_SPEC_ID:
real_len = LLRP_TV_LEN_INVENTORY_PARAM_SPEC_ID; break;
case LLRP_TV_C1G2_CRC:
real_len = LLRP_TV_LEN_C1G2_CRC; break;
case LLRP_TV_C1G2_PC:
real_len = LLRP_TV_LEN_C1G2_PC; break;
case LLRP_TV_EPC96:
real_len = LLRP_TV_LEN_EPC96; break;
case LLRP_TV_SPEC_INDEX:
real_len = LLRP_TV_LEN_SPEC_INDEX; break;
case LLRP_TV_CLIENT_REQ_OP_SPEC_RES:
real_len = LLRP_TV_LEN_CLIENT_REQ_OP_SPEC_RES; break;
case LLRP_TV_ACCESS_SPEC_ID:
real_len = LLRP_TV_LEN_ACCESS_SPEC_ID; break;
case LLRP_TV_OP_SPEC_ID:
real_len = LLRP_TV_LEN_OP_SPEC_ID; break;
case LLRP_TV_C1G2_SINGULATION_DET:
real_len = LLRP_TV_LEN_C1G2_SINGULATION_DET; break;
case LLRP_TV_C1G2_XPC_W1:
real_len = LLRP_TV_LEN_C1G2_XPC_W1; break;
case LLRP_TV_C1G2_XPC_W2:
real_len = LLRP_TV_LEN_C1G2_XPC_W2; break;
default:
real_len = 0;
break;
};
ti = proto_tree_add_none_format(tree, hf_llrp_param, tvb,
offset, real_len + 1, ""TV Parameter : %s"",
val_to_str_ext(type, &tv_type_ext, ""Unknown Type: %d""));
param_tree = proto_item_add_subtree(ti, ett_llrp_param);
proto_tree_add_item(param_tree, hf_llrp_tv_type, tvb,
offset, 1, ENC_BIG_ENDIAN);
offset++;
suboffset = offset;
switch (type)
{
case LLRP_TV_ANTENNA_ID:
PARAM_TREE_ADD_STAY(antenna_id, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TV_FIRST_SEEN_TIME_UTC:
case LLRP_TV_FIRST_SEEN_TIME_UPTIME:
case LLRP_TV_LAST_SEEN_TIME_UTC:
case LLRP_TV_LAST_SEEN_TIME_UPTIME:
PARAM_TREE_ADD_STAY(microseconds, 8, ENC_BIG_ENDIAN);
break;
case LLRP_TV_PEAK_RSSI:
PARAM_TREE_ADD_STAY(peak_rssi, 1, ENC_NA);
break;
case LLRP_TV_CHANNEL_INDEX:
PARAM_TREE_ADD_STAY(channel_idx, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TV_TAG_SEEN_COUNT:
PARAM_TREE_ADD_STAY(tag_count, 2, ENC_BIG_ENDIAN);
break;
case LLRP_TV_RO_SPEC_ID:
PARAM_TREE_ADD_STAY(rospec_id, 4, ENC_BIG_ENDIAN);
break;
case LLRP_TV_INVENTORY_PARAM_SPEC_ID:
PARAM_TREE_ADD_STAY(inventory_spec_id, 2, ENC_BIG_ENDIAN);
bre","static guint
dissect_llrp_parameters(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
guint VAR_3, const guint VAR_4)
{
guint8      VAR_5;
guint16     VAR_6, VAR_7;
guint       VAR_8, VAR_9;
guint       VAR_10;
guint       VAR_11;
proto_item *VAR_12;
proto_tree *VAR_13;
while (((VAR_14)(VAR_4 - VAR_3)) > 0)
{
VAR_5 = !(tvb_get_guint8(VAR_0, VAR_3) & 0x80);
if (VAR_5)
{
VAR_7 = tvb_get_ntohs(VAR_0, VAR_3);
VAR_6 = tvb_get_ntohs(VAR_0, VAR_3 + 2);
if (VAR_6 < VAR_15)
VAR_8 = VAR_15;
else if (VAR_6 > tvb_reported_length_remaining(VAR_0, VAR_3))
VAR_8 = tvb_reported_length_remaining(VAR_0, VAR_3);
else
VAR_8 = VAR_6;
VAR_9 = VAR_3 + VAR_8;
VAR_12 = proto_tree_add_none_format(VAR_2, VAR_16, VAR_0,
VAR_3, VAR_8, ""TLV Parameter: %s"",
val_to_str_ext(VAR_7, &VAR_17, ""Unknown Type: %d""));
VAR_13 = proto_item_add_subtree(VAR_12, VAR_18);
proto_tree_add_item(VAR_13, VAR_19, VAR_0,
VAR_3, 2, VAR_20);
VAR_3 += 2;
VAR_12 = proto_tree_add_item(VAR_13, VAR_21, VAR_0,
VAR_3, 2, VAR_20);
if (VAR_6 != VAR_8)
expert_add_info_format(VAR_1, VAR_12, &VAR_22,
""Invalid length field: claimed %u, should be %u."",
VAR_6, VAR_8);
VAR_3 += 2;
VAR_10 = VAR_3;
switch(VAR_7) {
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
case VAR_29:
case VAR_30:
case VAR_31:
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_32:
case VAR_33:
PARAM_TREE_ADD(VAR_34, 8, VAR_20);
break;
case VAR_35:
PARAM_TREE_ADD_STAY(VAR_36, 2, VAR_20);
PARAM_TREE_ADD(VAR_37, 2, VAR_20);
PARAM_TREE_ADD(VAR_38, 2, VAR_20);
PARAM_TREE_ADD(VAR_39, 4, VAR_20);
PARAM_TREE_ADD(VAR_40, 4, VAR_20);
VAR_10 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_13, VAR_41, VAR_10);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_42:
PARAM_TREE_ADD(VAR_43, 2, VAR_20);
break;
case VAR_44:
PARAM_TREE_ADD(VAR_45, 2, VAR_20);
PARAM_TREE_ADD(VAR_46, 2, VAR_20);
break;
case VAR_47:
PARAM_TREE_ADD(VAR_48, 2, VAR_20);
PARAM_TREE_ADD(VAR_49, 2, VAR_20);
PARAM_TREE_ADD(VAR_50, 2, VAR_20);
break;
case VAR_51:
PARAM_TREE_ADD(VAR_48, 2, VAR_20);
VAR_10 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_13,
VAR_52, VAR_53, 1, VAR_10);
break;
case VAR_54:
PARAM_TREE_ADD(VAR_55, 2, VAR_20);
PARAM_TREE_ADD(VAR_56, 2, VAR_20);
break;
case VAR_57:
PARAM_TREE_ADD_STAY(VAR_58, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_60, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_61, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_62, 1, VAR_59);
PARAM_TREE_ADD(VAR_63, 1, VAR_59);
PARAM_TREE_ADD(VAR_64, 1, VAR_59);
PARAM_TREE_ADD(VAR_65, 2, VAR_20);
VAR_11 = tvb_get_ntohl(VAR_0, VAR_10);
if(VAR_11 == VAR_66)
PARAM_TREE_ADD_SPEC_STAY(VAR_67, VAR_68, 4, VAR_11, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(VAR_68, 4, VAR_20);
VAR_10 += 4;
VAR_11 = tvb_get_ntohl(VAR_0, VAR_10);
if(VAR_11 == VAR_66)
PARAM_TREE_ADD_SPEC_STAY(VAR_67, VAR_69, 4, VAR_11, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(VAR_69, 4, VAR_20);
VAR_10 += 4;
VAR_11 = tvb_get_ntohl(VAR_0, VAR_10);
if(VAR_11 == VAR_66)
PARAM_TREE_ADD_SPEC_STAY(VAR_67, VAR_70, 4, VAR_11, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(VAR_70, 4, VAR_20);
VAR_10 += 4;
VAR_11 = tvb_get_ntohl(VAR_0, VAR_10);
if(VAR_11 == VAR_66)
PARAM_TREE_ADD_SPEC_STAY(VAR_67, VAR_71, 4, VAR_11, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(VAR_71, 4, VAR_20);
VAR_10 += 4;
VAR_11 = tvb_get_ntohl(VAR_0, VAR_10);
if(VAR_11 == VAR_66)
PARAM_TREE_ADD_SPEC_STAY(VAR_67, VAR_72, 4, VAR_11, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(VAR_72, 4, VAR_20);
VAR_10 += 4;
break;
case VAR_73:
PARAM_TREE_ADD(VAR_74, 2, VAR_20);
PARAM_TREE_ADD(VAR_75, 2, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_76:
PARAM_TREE_ADD(VAR_45, 2, VAR_20);
PARAM_TREE_ADD(VAR_77, 2, VAR_20);
break;
case VAR_78:
PARAM_TREE_ADD(VAR_79, 1, VAR_59);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_80:
PARAM_TREE_ADD(VAR_81, 1, VAR_59);
PARAM_TREE_ADD(VAR_82, 1, VAR_59);
VAR_10 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_13,
VAR_83, VAR_84, 4, VAR_10);
break;
case VAR_85:
VAR_10 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_13,
VAR_86, VAR_84, 4, VAR_10);
break;
case VAR_87:
PARAM_TREE_ADD(VAR_88, 4, VAR_20);
PARAM_TREE_ADD(VAR_89, 4, VAR_20);
break;
case VAR_90:
PARAM_TREE_ADD(VAR_91, 4, VAR_20);
PARAM_TREE_ADD(VAR_92, 1, VAR_59);
PARAM_TREE_ADD(VAR_93, 1, VAR_59);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_94:
PARAM_TREE_ADD(VAR_95, 1, VAR_59);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_96:
PARAM_TREE_ADD(VAR_3, 4, VAR_20);
PARAM_TREE_ADD(VAR_97, 4, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_98:
PARAM_TREE_ADD(VAR_99, 2, VAR_20);
PARAM_TREE_ADD(VAR_100, 1, VAR_59);
PARAM_TREE_ADD(VAR_101, 4, VAR_20);
break;
case VAR_102:
PARAM_TREE_ADD(VAR_103, 1, VAR_59);
PARAM_TREE_ADD(VAR_104, 4, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_105:
VAR_10 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_13,
VAR_106, VAR_107, 2, VAR_10);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_108:
PARAM_TREE_ADD(VAR_109, 1, VAR_59);
PARAM_TREE_ADD(VAR_104, 4, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_110:
PARAM_TREE_ADD(VAR_111, 1, VAR_59);
PARAM_TREE_ADD(VAR_82, 1, VAR_59);
PARAM_TREE_ADD(VAR_112, 2, VAR_20);
PARAM_TREE_ADD(VAR_113, 2, VAR_20);
PARAM_TREE_ADD(VAR_114, 2, VAR_20);
PARAM_TREE_ADD(VAR_101, 4, VAR_20);
break;
case VAR_115:
PARAM_TREE_ADD(VAR_116, 2, VAR_20);
PARAM_TREE_ADD(VAR_117, 1, VAR_59);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_118:
PARAM_TREE_ADD(VAR_48, 2, VAR_20);
PARAM_TREE_ADD(VAR_119, 4, VAR_20);
PARAM_TREE_ADD(VAR_120, 4, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_121:
PARAM_TREE_ADD(VAR_122, 1, VAR_59);
PARAM_TREE_ADD(VAR_123, 4, VAR_20);
PARAM_TREE_ADD(VAR_124, 4, VAR_20);
break;
case VAR_125:
PARAM_TREE_ADD(VAR_126, 4, VAR_20);
break;
case VAR_127:
PARAM_TREE_ADD(VAR_128, 4, VAR_20);
PARAM_TREE_ADD(VAR_48, 2, VAR_20);
PARAM_TREE_ADD(VAR_117, 1, VAR_20);
PARAM_TREE_ADD(VAR_129, 1, VAR_59);
PARAM_TREE_ADD(VAR_91, 4, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_130:
PARAM_TREE_ADD(VAR_131, 1, VAR_59);
PARAM_TREE_ADD(VAR_132, 2, VAR_20);
break;
case VAR_133:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
break;
case VAR_135:
PARAM_TREE_ADD(VAR_128, 2, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_136:
PARAM_TREE_ADD(VAR_137, 4, VAR_20);
break;
case VAR_138:
PARAM_TREE_ADD(VAR_139, 1, VAR_59);
VAR_11 = tvb_get_ntohs(VAR_0, VAR_10);
PARAM_TREE_ADD(VAR_140, 2, VAR_20);
VAR_10 += VAR_11;
break;
case VAR_141:
PARAM_TREE_ADD(VAR_142, 2, VAR_20);
PARAM_TREE_ADD(VAR_143, 1, VAR_59);
break;
case VAR_144:
PARAM_TREE_ADD(VAR_145, 1, VAR_59);
PARAM_TREE_ADD(VAR_146, 4, VAR_20);
break;
case VAR_147:
PARAM_TREE_ADD(VAR_148, 1, VAR_59);
PARAM_TREE_ADD(VAR_48, 2, VAR_20);
PARAM_TREE_ADD(VAR_149, 2, VAR_20);
break;
case VAR_150:
PARAM_TREE_ADD(VAR_48, 2, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_151:
PARAM_TREE_ADD(VAR_152, 2, VAR_20);
break;
case VAR_153:
PARAM_TREE_ADD(VAR_81, 2, VAR_20);
PARAM_TREE_ADD(VAR_154, 2, VAR_20);
PARAM_TREE_ADD(VAR_77, 2, VAR_20);
break;
case VAR_155:
PARAM_TREE_ADD(VAR_99, 2, VAR_20);
PARAM_TREE_ADD(VAR_156, 1, VAR_59);
PARAM_TREE_ADD(VAR_157, 1, VAR_59);
break;
case VAR_158:
PARAM_TREE_ADD(VAR_159, 1, VAR_59);
break;
case VAR_160:
PARAM_TREE_ADD(VAR_161, 1, VAR_59);
PARAM_TREE_ADD(VAR_162, 2, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_163:
PARAM_TREE_ADD_STAY(VAR_164, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_165, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_166, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_167, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_168, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_169, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_170, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_171, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_172, 2, VAR_20);
PARAM_TREE_ADD(VAR_173, 2, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_174:
PARAM_TREE_ADD(VAR_175, 1, VAR_59);
break;
case VAR_176:
VAR_10 = dissect_llrp_bit_field(VAR_0, VAR_13, VAR_177, VAR_10);
break;
case VAR_178:
PARAM_TREE_ADD(VAR_179, 4, VAR_20);
PARAM_TREE_ADD(VAR_180, 4, VAR_20);
PARAM_TREE_ADD(VAR_181, 1, VAR_59);
PARAM_TREE_ADD(VAR_182, 1, VAR_59);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_183:
PARAM_TREE_ADD(VAR_184, 2, VAR_20);
PARAM_TREE_ADD(VAR_185, 1, VAR_59);
break;
case VAR_186:
PARAM_TREE_ADD(VAR_81, 2, VAR_20);
PARAM_TREE_ADD(VAR_187, 2, VAR_20);
break;
case VAR_188:
PARAM_TREE_ADD(VAR_99, 2, VAR_20);
PARAM_TREE_ADD(VAR_100, 1, VAR_59);
break;
case VAR_189:
PARAM_TREE_ADD(VAR_190, 1, VAR_59);
PARAM_TREE_ADD(VAR_91, 4, VAR_20);
PARAM_TREE_ADD(VAR_191, 4, VAR_20);
break;
case VAR_192:
PARAM_TREE_ADD(VAR_193, 1, VAR_59);
break;
case VAR_194:
break;
case VAR_195:
VAR_10 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_13, VAR_196, VAR_10);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_197:
PARAM_TREE_ADD(VAR_198, 1, VAR_59);
PARAM_TREE_ADD(VAR_91, 4, VAR_20);
PARAM_TREE_ADD(VAR_199, 2, VAR_20);
break;
case VAR_200:
PARAM_TREE_ADD(VAR_201, 1, VAR_59);
PARAM_TREE_ADD(VAR_91, 4, VAR_20);
PARAM_TREE_ADD(VAR_199, 2, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_202:
PARAM_TREE_ADD(VAR_203, 1, VAR_59);
PARAM_TREE_ADD(VAR_48, 2, VAR_20);
break;
case VAR_204:
PARAM_TREE_ADD(VAR_205, 2, VAR_20);
break;
case VAR_206:
break;
case VAR_207:
PARAM_TREE_ADD(VAR_91, 4, VAR_20);
PARAM_TREE_ADD(VAR_126, 4, VAR_20);
break;
case VAR_208:
PARAM_TREE_ADD(VAR_209, 2, VAR_20);
VAR_10 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_13, VAR_210, VAR_10);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_211:
PARAM_TREE_ADD(VAR_212, 2, VAR_20);
PARAM_TREE_ADD(VAR_213, 2, VAR_20);
break;
case VAR_214:
PARAM_TREE_ADD(VAR_215, 2, VAR_20);
PARAM_TREE_ADD(VAR_213, 2, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_216:
PARAM_TREE_ADD_STAY(VAR_217, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_218, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_219, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_220, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_221, 1, VAR_59);
PARAM_TREE_ADD(VAR_222, 1, VAR_59);
VAR_11 = tvb_get_ntohs(VAR_0, VAR_10);
if(VAR_11 == VAR_66)
PARAM_TREE_ADD_SPEC_STAY(VAR_67, VAR_223, 2, VAR_11, ""No limit (%u)"");
else
PARAM_TREE_ADD_STAY(VAR_223, 2, VAR_20);
VAR_10 += 2;
break;
case VAR_224:
PARAM_TREE_ADD(VAR_225, 4, VAR_20);
PARAM_TREE_ADD_STAY(VAR_226, 1, VAR_59);
PARAM_TREE_ADD(VAR_227, 1, VAR_59);
PARAM_TREE_ADD(VAR_228, 1, VAR_59);
PARAM_TREE_ADD(VAR_229, 1, VAR_59);
PARAM_TREE_ADD(VAR_230, 1, VAR_59);
PARAM_TREE_ADD(VAR_231, 4, VAR_20);
PARAM_TREE_ADD(VAR_232, 4, VAR_20);
PARAM_TREE_ADD(VAR_233, 4, VAR_20);
PARAM_TREE_ADD(VAR_234, 4, VAR_20);
PARAM_TREE_ADD(VAR_235, 4, VAR_20);
break;
case VAR_236:
PARAM_TREE_ADD(VAR_237, 1, VAR_59);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_238:
PARAM_TREE_ADD(VAR_239, 1, VAR_59);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_240:
PARAM_TREE_ADD(VAR_241, 1, VAR_59);
PARAM_TREE_ADD(VAR_242, 2, VAR_20);
VAR_10 = dissect_llrp_bit_field(VAR_0, VAR_13, VAR_243, VAR_10);
break;
case VAR_244:
PARAM_TREE_ADD(VAR_245, 1, VAR_59);
PARAM_TREE_ADD(VAR_246, 1, VAR_59);
break;
case VAR_247:
PARAM_TREE_ADD(VAR_248, 1, VAR_59);
break;
case VAR_249:
PARAM_TREE_ADD(VAR_250, 2, VAR_20);
PARAM_TREE_ADD(VAR_251, 2, VAR_20);
break;
case VAR_252:
PARAM_TREE_ADD(VAR_253, 1, VAR_59);
PARAM_TREE_ADD(VAR_254, 2, VAR_20);
PARAM_TREE_ADD(VAR_255, 4, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_256:
PARAM_TREE_ADD_STAY(VAR_257, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_258, 1, VAR_59);
PARAM_TREE_ADD(VAR_259, 1, VAR_59);
break;
case VAR_260:
PARAM_TREE_ADD_STAY(VAR_241, 1, VAR_59);
PARAM_TREE_ADD(VAR_261, 1, VAR_59);
PARAM_TREE_ADD(VAR_242, 2, VAR_20);
VAR_10 = dissect_llrp_bit_field(VAR_0, VAR_13, VAR_243, VAR_10);
VAR_10 = dissect_llrp_bit_field(VAR_0, VAR_13, VAR_262, VAR_10);
break;
case VAR_263:
case VAR_264:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_265, 4, VAR_20);
PARAM_TREE_ADD(VAR_241, 1, VAR_59);
PARAM_TREE_ADD(VAR_266, 2, VAR_20);
PARAM_TREE_ADD(VAR_267, 2, VAR_20);
break;
case VAR_268:
case VAR_269:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_265, 4, VAR_20);
PARAM_TREE_ADD(VAR_241, 1, VAR_59);
PARAM_TREE_ADD(VAR_266, 2, VAR_20);
VAR_10 = dissect_llrp_word_array(VAR_0, VAR_13, VAR_270, VAR_10);
break;
case VAR_271:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_272, 4, VAR_20);
break;
case VAR_273:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_272, 4, VAR_20);
PARAM_TREE_ADD_STAY(VAR_274, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_275, 1, VAR_59);
PARAM_TREE_ADD(VAR_276, 1, VAR_59);
break;
case VAR_277:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_265, 4, VAR_20);
VAR_10 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
case VAR_278:
PARAM_TREE_ADD(VAR_279, 1, VAR_59);
PARAM_TREE_ADD(VAR_280, 1, VAR_59);
break;
case VAR_281:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_265, 4, VAR_20);
PARAM_TREE_ADD(VAR_241, 1, VAR_59);
PARAM_TREE_ADD(VAR_282, 2, VAR_20);
VAR_10 = dissect_llrp_word_array(VAR_0, VAR_13, VAR_283, VAR_10);
break;
case VAR_284:
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_265, 4, VAR_20);
PARAM_TREE_ADD(VAR_241, 1, VAR_59);
PARAM_TREE_ADD(VAR_282, 2, VAR_20);
PARAM_TREE_ADD(VAR_285, 2, VAR_20);
break;
case VAR_286:
PARAM_TREE_ADD_STAY(VAR_287, 1, VAR_59);
PARAM_TREE_ADD_STAY(VAR_288, 1, VAR_59);
PARAM_TREE_ADD(VAR_289, 1, VAR_59);
break;
case VAR_290:
PARAM_TREE_ADD(VAR_291, 1, VAR_59);
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
VAR_10 = dissect_llrp_word_array(VAR_0, VAR_13, VAR_292, VAR_10);
break;
case VAR_293:
case VAR_294:
PARAM_TREE_ADD(VAR_291, 1, VAR_59);
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
PARAM_TREE_ADD(VAR_295, 2, VAR_20);
break;
case VAR_296:
case VAR_297:
case VAR_298:
case VAR_299:
case VAR_300:
PARAM_TREE_ADD(VAR_291, 1, VAR_59);
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
break;
case VAR_301:
PARAM_TREE_ADD(VAR_291, 1, VAR_59);
PARAM_TREE_ADD(VAR_134, 2, VAR_20);
VAR_10 = dissect_llrp_word_array(VAR_0, VAR_13, VAR_302, VAR_10);
break;
case VAR_303:
VAR_11 = tvb_get_ntohl(VAR_0, VAR_10);
PARAM_TREE_ADD(VAR_304, 4, VAR_20);
switch(VAR_11) {
case VAR_305:
VAR_10 = dissect_llrp_impinj_parameter(VAR_0, VAR_1, VAR_13, VAR_10, VAR_9);
break;
}
break;
}
if(VAR_10 != VAR_9) {
expert_add_info_format(VAR_1, VAR_13, &VAR_22,
""Incorrect length of parameter: %u bytes decoded, but %u bytes claimed."",
VAR_10 - VAR_3 + 4, VAR_8);
}
VAR_3 += VAR_8 - 4;
}
else
{
VAR_7 = tvb_get_guint8(VAR_0, VAR_3) & 0x7F;
switch (VAR_7)
{
case VAR_306:
VAR_8 = VAR_307; break;
case VAR_308:
VAR_8 = VAR_309; break;
case VAR_310:
VAR_8 = VAR_311; break;
case VAR_312:
VAR_8 = VAR_313; break;
case VAR_314:
VAR_8 = VAR_315; break;
case VAR_316:
VAR_8 = VAR_317; break;
case VAR_318:
VAR_8 = VAR_319; break;
case VAR_320:
VAR_8 = VAR_321; break;
case VAR_322:
VAR_8 = VAR_323; break;
case VAR_324:
VAR_8 = VAR_325; break;
case VAR_326:
VAR_8 = VAR_327; break;
case VAR_328:
VAR_8 = VAR_329; break;
case VAR_330:
VAR_8 = VAR_331; break;
case VAR_332:
VAR_8 = VAR_333; break;
case VAR_334:
VAR_8 = VAR_335; break;
case VAR_336:
VAR_8 = VAR_337; break;
case VAR_338:
VAR_8 = VAR_339; break;
case VAR_340:
VAR_8 = VAR_341; break;
case VAR_342:
VAR_8 = VAR_343; break;
case VAR_344:
VAR_8 = VAR_345; break;
default:
VAR_8 = 0;
break;
};
VAR_12 = proto_tree_add_none_format(VAR_2, VAR_16, VAR_0,
VAR_3, VAR_8 + 1, ""TV Parameter : %s"",
val_to_str_ext(VAR_7, &VAR_346, ""Unknown Type: %d""));
VAR_13 = proto_item_add_subtree(VAR_12, VAR_18);
proto_tree_add_item(VAR_13, VAR_347, VAR_0,
VAR_3, 1, VAR_20);
VAR_3++;
VAR_10 = VAR_3;
switch (VAR_7)
{
case VAR_306:
PARAM_TREE_ADD_STAY(VAR_48, 2, VAR_20);
break;
case VAR_308:
case VAR_310:
case VAR_312:
case VAR_314:
PARAM_TREE_ADD_STAY(VAR_34, 8, VAR_20);
break;
case VAR_316:
PARAM_TREE_ADD_STAY(VAR_182, 1, VAR_59);
break;
case VAR_318:
PARAM_TREE_ADD_STAY(VAR_154, 2, VAR_20);
break;
case VAR_320:
PARAM_TREE_ADD_STAY(VAR_348, 2, VAR_20);
break;
case VAR_322:
PARAM_TREE_ADD_STAY(VAR_91, 4, VAR_20);
break;
case VAR_324:
PARAM_TREE_ADD_STAY(VAR_116, 2, VAR_20);
break;
case VAR_326:
PARAM_TREE_ADD_STAY(VAR_349, 2, VAR_20);
break;
case VAR_328:
PARAM_TREE_ADD_STAY(VAR_350, 2, VAR_20);
break;
case VAR_330:
PARAM_TREE_ADD_STAY(VAR_351, 96/8, VAR_59);
break;
case VAR_332:
PARAM_TREE_ADD_STAY(VAR_199, 2, VAR_20);
break;
case VAR_334:
PARAM_TREE_ADD_STAY(VAR_134, 2, VAR_20);
break;
case VAR_336:
PARAM_TREE_ADD_STAY(VAR_128, 4, VAR_20);
break;
case VAR_338:
PARAM_TREE_ADD_STAY(VAR_134, 2, VAR_20);
break;
case VAR_340:
PARAM_TREE_ADD_STAY(VAR_352, 2, VAR_20);
PARAM_TREE_ADD_STAY(VAR_353, 2, VAR_20);
break;
case VAR_342:
PARAM_TREE_ADD_STAY(VAR_354, 2, VAR_20);
break;
case VAR_344:
PARAM_TREE_ADD_STAY(VAR_355, 2, VAR_20);
break;
};
VAR_3 += VAR_8;
}
}
return VAR_3;
}",wireshark/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec/packet-llrp.c/vul/before/2.json,"static guint
dissect_llrp_parameters(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
        guint offset, const guint end, const guint depth)
{
    guint8      has_length;
    guint16     len, type;
    guint       real_len, param_end;
    guint       suboffset;
    guint       num;
    proto_item *ti;
    proto_tree *param_tree;

    while (((gint)(end - offset)) > 0)
    {
        has_length = !(tvb_get_guint8(tvb, offset) & 0x80);

        if (has_length)
        {
            type = tvb_get_ntohs(tvb, offset);
            len = tvb_get_ntohs(tvb, offset + 2);

            if (len < LLRP_TLV_LEN_MIN)
                real_len = LLRP_TLV_LEN_MIN;
            else if (len > tvb_reported_length_remaining(tvb, offset))
                real_len = tvb_reported_length_remaining(tvb, offset);
            else
                real_len = len;

            param_end = offset + real_len;

            if (depth > 16) {
                return param_end;
            }

            ti = proto_tree_add_none_format(tree, hf_llrp_param, tvb,
                    offset, real_len, ""TLV Parameter: %s"",
                    val_to_str_ext(type, &tlv_type_ext, ""Unknown Type: %d""));
            param_tree = proto_item_add_subtree(ti, ett_llrp_param);

            proto_tree_add_item(param_tree, hf_llrp_tlv_type, tvb,
                    offset, 2, ENC_BIG_ENDIAN);
            offset += 2;

            ti = proto_tree_add_item(param_tree, hf_llrp_tlv_len, tvb,
                    offset, 2, ENC_BIG_ENDIAN);
            if (len != real_len)
                expert_add_info_format(pinfo, ti, &ei_llrp_invalid_length,
                        ""Invalid length field: claimed %u, should be %u."",
                        len, real_len);
            offset += 2;

            suboffset = offset;
            switch(type) {
            case LLRP_TLV_RO_BOUND_SPEC:
            case LLRP_TLV_UHF_CAPABILITIES:
            case LLRP_TLV_ACCESS_COMMAND:
            case LLRP_TLV_TAG_REPORT_DATA:
            case LLRP_TLV_RF_SURVEY_REPORT_DATA:
            case LLRP_TLV_READER_EVENT_NOTI_SPEC:
            case LLRP_TLV_READER_EVENT_NOTI_DATA:
            case LLRP_TLV_C1G2_UHF_RF_MD_TBL:
            case LLRP_TLV_C1G2_TAG_SPEC:
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_UTC_TIMESTAMP:
            case LLRP_TLV_UPTIME:
                PARAM_TREE_ADD(microseconds, 8, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_GENERAL_DEVICE_CAP:
                PARAM_TREE_ADD_STAY(max_supported_antenna, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(can_set_antenna_prop, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(has_utc_clock, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(device_manufacturer, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(model, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firmware_version, suboffset);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_MAX_RECEIVE_SENSE:
                PARAM_TREE_ADD(max_receive_sense, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_RECEIVE_SENSE_ENTRY:
                PARAM_TREE_ADD(index, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(receive_sense, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_ANTENNA_RCV_SENSE_RANGE:
                PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(receive_sense_index_min, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(receive_sense_index_max, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_ANTENNA_AIR_PROTO:
                PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                        hf_llrp_num_protocols, hf_llrp_protocol_id, 1, suboffset);
                break;
            case LLRP_TLV_GPIO_CAPABILITIES:
                PARAM_TREE_ADD(num_gpi, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(num_gpo, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_LLRP_CAPABILITIES:
                PARAM_TREE_ADD_STAY(can_do_survey, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(can_report_buffer_warning, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(support_client_opspec, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(can_stateaware, 1, ENC_NA);
                PARAM_TREE_ADD(support_holding, 1, ENC_NA);
                PARAM_TREE_ADD(max_priority_supported, 1, ENC_NA);
                PARAM_TREE_ADD(client_opspec_timeout, 2, ENC_BIG_ENDIAN);
                num = tvb_get_ntohl(tvb, suboffset);
                if(num == LLRP_NO_LIMIT)
                    PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_rospec, 4, num, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(max_num_rospec, 4, ENC_BIG_ENDIAN);
                suboffset += 4;
                num = tvb_get_ntohl(tvb, suboffset);
                if(num == LLRP_NO_LIMIT)
                    PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_spec_per_rospec, 4, num, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(max_num_spec_per_rospec, 4, ENC_BIG_ENDIAN);
                suboffset += 4;
                num = tvb_get_ntohl(tvb, suboffset);
                if(num == LLRP_NO_LIMIT)
                    PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_inventory_per_aispec, 4, num, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(max_num_inventory_per_aispec, 4, ENC_BIG_ENDIAN);
                suboffset += 4;
                num = tvb_get_ntohl(tvb, suboffset);
                if(num == LLRP_NO_LIMIT)
                    PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_accessspec, 4, num, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(max_num_accessspec, 4, ENC_BIG_ENDIAN);
                suboffset += 4;
                num = tvb_get_ntohl(tvb, suboffset);
                if(num == LLRP_NO_LIMIT)
                    PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_opspec_per_accressspec, 4, num, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(max_num_opspec_per_accressspec, 4, ENC_BIG_ENDIAN);
                suboffset += 4;
                break;
            case LLRP_TLV_REGU_CAPABILITIES:
                PARAM_TREE_ADD(country_code, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(comm_standard, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_XMIT_POWER_LEVEL_ENTRY:
                PARAM_TREE_ADD(index, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(transmit_power, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_FREQ_INFORMATION:
                PARAM_TREE_ADD(hopping, 1, ENC_NA);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_FREQ_HOP_TABLE:
                PARAM_TREE_ADD(hop_table_id, 1, ENC_NA);
                PARAM_TREE_ADD(rfu, 1, ENC_NA);
                suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                        hf_llrp_num_hops, hf_llrp_frequency, 4, suboffset);
                break;
            case LLRP_TLV_FIXED_FREQ_TABLE:
                suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                        hf_llrp_num_freqs, hf_llrp_frequency, 4, suboffset);
                break;
            case LLRP_TLV_RF_SURVEY_FREQ_CAP:
                PARAM_TREE_ADD(min_freq, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(max_freq, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_RO_SPEC:
                PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(priority, 1, ENC_NA);
                PARAM_TREE_ADD(cur_state, 1, ENC_NA);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_RO_SPEC_START_TRIGGER:
                PARAM_TREE_ADD(rospec_start_trig_type, 1, ENC_NA);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_PER_TRIGGER_VAL:
                PARAM_TREE_ADD(offset, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(period, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_GPI_TRIGGER_VAL:
                PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(gpi_event, 1, ENC_NA);
                PARAM_TREE_ADD(timeout, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_RO_SPEC_STOP_TRIGGER:
                PARAM_TREE_ADD(rospec_stop_trig_type, 1, ENC_NA);
                PARAM_TREE_ADD(duration_trig, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_AI_SPEC:
                suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                        hf_llrp_antenna_count, hf_llrp_antenna, 2, suboffset);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_AI_SPEC_STOP:
                PARAM_TREE_ADD(aispec_stop_trig_type, 1, ENC_NA);
                PARAM_TREE_ADD(duration_trig, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_TAG_OBSERV_TRIGGER:
                PARAM_TREE_ADD(trig_type, 1, ENC_NA);
                PARAM_TREE_ADD(rfu, 1, ENC_NA);
                PARAM_TREE_ADD(number_of_tags, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(number_of_attempts, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(t, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(timeout, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_INVENTORY_PARAM_SPEC:
                PARAM_TREE_ADD(inventory_spec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(protocol_id, 1, ENC_NA);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_RF_SURVEY_SPEC:
                PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(start_freq, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(stop_freq, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_RF_SURVEY_SPEC_STOP_TR:
                PARAM_TREE_ADD(stop_trig_type, 1, ENC_NA);
                PARAM_TREE_ADD(duration, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(n_4, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_LOOP_SPEC:
                PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_ACCESS_SPEC:
                PARAM_TREE_ADD(accessspec_id, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(protocol_id, 1, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(access_cur_state, 1, ENC_NA);
                PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_ACCESS_SPEC_STOP_TRIG:
                PARAM_TREE_ADD(access_stop_trig_type, 1, ENC_NA);
                PARAM_TREE_ADD(operation_count, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_CLIENT_REQ_OP_SPEC:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_CLIENT_REQ_RESPONSE:
                PARAM_TREE_ADD(accessspec_id, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_LLRP_CONF_STATE_VAL:
                PARAM_TREE_ADD(conf_value, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_IDENT:
                PARAM_TREE_ADD(id_type, 1, ENC_NA);
                num = tvb_get_ntohs(tvb, suboffset);
                PARAM_TREE_ADD(reader_id, 2, ENC_BIG_ENDIAN);
                suboffset += num;
                break;
            case LLRP_TLV_GPO_WRITE_DATA:
                PARAM_TREE_ADD(gpo_port, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(gpo_data, 1, ENC_NA);
                break;
            case LLRP_TLV_KEEPALIVE_SPEC:
                PARAM_TREE_ADD(keepalive_trig_type, 1, ENC_NA);
                PARAM_TREE_ADD(time_iterval, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_ANTENNA_PROPS:
                PARAM_TREE_ADD(antenna_connected, 1, ENC_NA);
                PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(antenna_gain, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_ANTENNA_CONF:
                PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_RF_RECEIVER:
                PARAM_TREE_ADD(receiver_sense, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_RF_TRANSMITTER:
                PARAM_TREE_ADD(hop_table_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(channel_idx, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(transmit_power, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_GPI_PORT_CURRENT_STATE:
                PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(gpi_config, 1, ENC_NA);
                PARAM_TREE_ADD(gpi_state, 1, ENC_NA);
                break;
            case LLRP_TLV_EVENTS_AND_REPORTS:
                PARAM_TREE_ADD(hold_events_and_reports, 1, ENC_NA);
                break;
            case LLRP_TLV_RO_REPORT_SPEC:
                PARAM_TREE_ADD(ro_report_trig, 1, ENC_NA);
                PARAM_TREE_ADD(n_2, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_TAG_REPORT_CONTENT_SEL:
                PARAM_TREE_ADD_STAY(enable_rospec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_spec_idx, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_inv_spec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_antenna_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_channel_idx, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_peak_rssi, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_first_seen, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_last_seen, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(enable_seen_count, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(enable_accessspec_id, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_ACCESS_REPORT_SPEC:
                PARAM_TREE_ADD(access_report_trig, 1, ENC_NA);
                break;
            case LLRP_TLV_EPC_DATA:
                suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_epc, suboffset);
                break;
            case LLRP_TLV_FREQ_RSSI_LEVEL_ENTRY:
                PARAM_TREE_ADD(frequency, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(bandwidth, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(average_rssi, 1, ENC_NA);
                PARAM_TREE_ADD(peak_rssi, 1, ENC_NA);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_EVENT_NOTIF_STATE:
                PARAM_TREE_ADD(event_type, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(notif_state, 1, ENC_NA);
                break;
            case LLRP_TLV_HOPPING_EVENT:
                PARAM_TREE_ADD(hop_table_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(next_chan_idx, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_GPI_EVENT:
                PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(gpi_event, 1, ENC_NA);
                break;
            case LLRP_TLV_RO_SPEC_EVENT:
                PARAM_TREE_ADD(roevent_type, 1, ENC_NA);
                PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(prem_rospec_id, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_REPORT_BUF_LEVEL_WARN:
                PARAM_TREE_ADD(buffer_full_percentage, 1, ENC_NA);
                break;
            case LLRP_TLV_REPORT_BUF_OVERFLOW_ERR: break;
            case LLRP_TLV_READER_EXCEPTION_EVENT:
                suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_message, suboffset);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_RF_SURVEY_EVENT:
                PARAM_TREE_ADD(rfevent_type, 1, ENC_NA);
                PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(spec_idx, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_AI_SPEC_EVENT:
                PARAM_TREE_ADD(aievent_type, 1, ENC_NA);
                PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(spec_idx, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_ANTENNA_EVENT:
                PARAM_TREE_ADD(antenna_event_type, 1, ENC_NA);
                PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_CONN_ATTEMPT_EVENT:
                PARAM_TREE_ADD(conn_status, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_CONN_CLOSE_EVENT:
                break;
            case LLRP_TLV_SPEC_LOOP_EVENT:
                PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_LLRP_STATUS:
                PARAM_TREE_ADD(status_code, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_error_desc, suboffset);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_FIELD_ERROR:
                PARAM_TREE_ADD(field_num, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(error_code, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_PARAM_ERROR:
                PARAM_TREE_ADD(parameter_type, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(error_code, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_C1G2_LLRP_CAP:
                PARAM_TREE_ADD_STAY(can_support_block_erase, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(can_support_block_write, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(can_support_block_permalock, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(can_support_tag_recomm, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(can_support_UMI_method2, 1, ENC_NA);
                PARAM_TREE_ADD(can_support_XPC, 1, ENC_NA);
                num = tvb_get_ntohs(tvb, suboffset);
                if(num == LLRP_NO_LIMIT)
                    PARAM_TREE_ADD_SPEC_STAY(uint_format_value, max_num_filter_per_query, 2, num, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(max_num_filter_per_query, 2, ENC_BIG_ENDIAN);
                suboffset += 2;
                break;
            case LLRP_TLV_C1G2_UHF_RF_MD_TBL_ENT:
                PARAM_TREE_ADD(mode_ident, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(DR, 1, ENC_NA);
                PARAM_TREE_ADD(hag_conformance, 1, ENC_NA);
                PARAM_TREE_ADD(mod, 1, ENC_NA);
                PARAM_TREE_ADD(flm, 1, ENC_NA);
                PARAM_TREE_ADD(m, 1, ENC_NA);
                PARAM_TREE_ADD(bdr, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(pie, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(min_tari, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(max_tari, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(step_tari, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_C1G2_INVENTORY_COMMAND:
                PARAM_TREE_ADD(inventory_state_aware, 1, ENC_NA);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_C1G2_FILTER:
                PARAM_TREE_ADD(trunc, 1, ENC_NA);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_C1G2_TAG_INV_MASK:
                PARAM_TREE_ADD(mb, 1, ENC_NA);
                PARAM_TREE_ADD(pointer, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_tag_mask, suboffset);
                break;
            case LLRP_TLV_C1G2_TAG_INV_AWARE_FLTR:
                PARAM_TREE_ADD(aware_filter_target, 1, ENC_NA);
                PARAM_TREE_ADD(aware_filter_action, 1, ENC_NA);
                break;
            case LLRP_TLV_C1G2_TAG_INV_UNAWR_FLTR:
                PARAM_TREE_ADD(unaware_filter_action, 1, ENC_NA);
                break;
            case LLRP_TLV_C1G2_RF_CONTROL:
                PARAM_TREE_ADD(mode_idx, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(tari, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_C1G2_SINGULATION_CTRL:
                PARAM_TREE_ADD(session, 1, ENC_NA);
                PARAM_TREE_ADD(tag_population, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(tag_transit_time, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_C1G2_TAG_INV_AWARE_SING:
                PARAM_TREE_ADD_STAY(sing_i, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(sing_s, 1, ENC_NA);
                PARAM_TREE_ADD(sing_a, 1, ENC_NA);
                break;
            case LLRP_TLV_C1G2_TARGET_TAG:
                PARAM_TREE_ADD_STAY(mb, 1, ENC_NA);
                PARAM_TREE_ADD(match, 1, ENC_NA);
                PARAM_TREE_ADD(pointer, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_tag_mask, suboffset);
                suboffset = dissect_llrp_bit_field(tvb, param_tree, hf_llrp_tag_data, suboffset);
                break;
            case LLRP_TLV_C1G2_READ:
            case LLRP_TLV_C1G2_BLK_ERASE:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(mb, 1, ENC_NA);
                PARAM_TREE_ADD(word_pointer, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(word_count, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_C1G2_WRITE:
            case LLRP_TLV_C1G2_BLK_WRITE:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(mb, 1, ENC_NA);
                PARAM_TREE_ADD(word_pointer, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_write_data, suboffset);
                break;
            case LLRP_TLV_C1G2_KILL:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(kill_pass, 4, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_C1G2_RECOMMISSION:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(kill_pass, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD_STAY(kill_3, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(kill_2, 1, ENC_NA);
                PARAM_TREE_ADD(kill_l, 1, ENC_NA);
                break;
            case LLRP_TLV_C1G2_LOCK:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                break;
            case LLRP_TLV_C1G2_LOCK_PAYLOAD:
                PARAM_TREE_ADD(privilege, 1, ENC_NA);
                PARAM_TREE_ADD(data_field, 1, ENC_NA);
                break;
            case LLRP_TLV_C1G2_BLK_PERMALOCK:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(mb, 1, ENC_NA);
                PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_block_mask, suboffset);
                break;
            case LLRP_TLV_C1G2_GET_BLK_PERMALOCK:
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(mb, 1, ENC_NA);
                PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(block_range, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_C1G2_EPC_MEMORY_SLCTOR:
                PARAM_TREE_ADD_STAY(enable_crc, 1, ENC_NA);
                PARAM_TREE_ADD_STAY(enable_pc, 1, ENC_NA);
                PARAM_TREE_ADD(enable_xpc, 1, ENC_NA);
                break;
            case LLRP_TLV_C1G2_READ_OP_SPEC_RES:
                PARAM_TREE_ADD(access_result, 1, ENC_NA);
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_read_data, suboffset);
                break;
            case LLRP_TLV_C1G2_WRT_OP_SPEC_RES:
            case LLRP_TLV_C1G2_BLK_WRT_OP_SPC_RES:
                PARAM_TREE_ADD(access_result, 1, ENC_NA);
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                PARAM_TREE_ADD(num_words_written, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_C1G2_KILL_OP_SPEC_RES:
            case LLRP_TLV_C1G2_RECOM_OP_SPEC_RES:
            case LLRP_TLV_C1G2_LOCK_OP_SPEC_RES:
            case LLRP_TLV_C1G2_BLK_ERS_OP_SPC_RES:
            case LLRP_TLV_C1G2_BLK_PRL_OP_SPC_RES:
                PARAM_TREE_ADD(access_result, 1, ENC_NA);
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                break;
            case LLRP_TLV_C1G2_BLK_PRL_STAT_RES:
                PARAM_TREE_ADD(access_result, 1, ENC_NA);
                PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                suboffset = dissect_llrp_word_array(tvb, param_tree, hf_llrp_permlock_status, suboffset);
                break;
            case LLRP_TLV_CUSTOM_PARAMETER:
                num = tvb_get_ntohl(tvb, suboffset);
                PARAM_TREE_ADD(vendor_id, 4, ENC_BIG_ENDIAN);
                switch(num) {
                case LLRP_VENDOR_IMPINJ:
                    suboffset = dissect_llrp_impinj_parameter(tvb, pinfo, param_tree, suboffset, param_end);
                    break;
                }
                break;
            }
            /* Have we decoded exactly the number of bytes declared in the parameter? */
            if(suboffset != param_end) {
                /* Report problem */
                expert_add_info_format(pinfo, param_tree, &ei_llrp_invalid_length,
                        ""Incorrect length of parameter: %u bytes decoded, but %u bytes claimed."",
                        suboffset - offset + 4, real_len);
            }
            /* The len field includes the 4-byte parameter header that we've
             * already accounted for in offset */
            offset += real_len - 4;
        }
        else
        {
            type = tvb_get_guint8(tvb, offset) & 0x7F;

            switch (type)
            {
                case LLRP_TV_ANTENNA_ID:
                    real_len = LLRP_TV_LEN_ANTENNA_ID; break;
                case LLRP_TV_FIRST_SEEN_TIME_UTC:
                    real_len = LLRP_TV_LEN_FIRST_SEEN_TIME_UTC; break;
                case LLRP_TV_FIRST_SEEN_TIME_UPTIME:
                    real_len = LLRP_TV_LEN_FIRST_SEEN_TIME_UPTIME; break;
                case LLRP_TV_LAST_SEEN_TIME_UTC:
                    real_len = LLRP_TV_LEN_LAST_SEEN_TIME_UTC; break;
                case LLRP_TV_LAST_SEEN_TIME_UPTIME:
                    real_len = LLRP_TV_LEN_LAST_SEEN_TIME_UPTIME; break;
                case LLRP_TV_PEAK_RSSI:
                    real_len = LLRP_TV_LEN_PEAK_RSSI; break;
                case LLRP_TV_CHANNEL_INDEX:
                    real_len = LLRP_TV_LEN_CHANNEL_INDEX; break;
                case LLRP_TV_TAG_SEEN_COUNT:
                    real_len = LLRP_TV_LEN_TAG_SEEN_COUNT; break;
                case LLRP_TV_RO_SPEC_ID:
                    real_len = LLRP_TV_LEN_RO_SPEC_ID; break;
                case LLRP_TV_INVENTORY_PARAM_SPEC_ID:
                    real_len = LLRP_TV_LEN_INVENTORY_PARAM_SPEC_ID; break;
                case LLRP_TV_C1G2_CRC:
                    real_len = LLRP_TV_LEN_C1G2_CRC; break;
                case LLRP_TV_C1G2_PC:
                    real_len = LLRP_TV_LEN_C1G2_PC; break;
                case LLRP_TV_EPC96:
                    real_len = LLRP_TV_LEN_EPC96; break;
                case LLRP_TV_SPEC_INDEX:
                    real_len = LLRP_TV_LEN_SPEC_INDEX; break;
                case LLRP_TV_CLIENT_REQ_OP_SPEC_RES:
                    real_len = LLRP_TV_LEN_CLIENT_REQ_OP_SPEC_RES; break;
                case LLRP_TV_ACCESS_SPEC_ID:
                    real_len = LLRP_TV_LEN_ACCESS_SPEC_ID; break;
                case LLRP_TV_OP_SPEC_ID:
                    real_len = LLRP_TV_LEN_OP_SPEC_ID; break;
                case LLRP_TV_C1G2_SINGULATION_DET:
                    real_len = LLRP_TV_LEN_C1G2_SINGULATION_DET; break;
                case LLRP_TV_C1G2_XPC_W1:
                    real_len = LLRP_TV_LEN_C1G2_XPC_W1; break;
                case LLRP_TV_C1G2_XPC_W2:
                    real_len = LLRP_TV_LEN_C1G2_XPC_W2; break;
                default:
                    /* ???
                     * No need to mark it, since the hf_llrp_tv_type field
                     * will already show up as 'unknown'. */
                    real_len = 0;
                    break;
            };

            ti = proto_tree_add_none_format(tree, hf_llrp_param, tvb,
                    offset, real_len + 1, ""TV Parameter : %s"",
                    val_to_str_ext(type, &tv_type_ext, ""Unknown Type: %d""));
            param_tree = proto_item_add_subtree(ti, ett_llrp_param);

            proto_tree_add_item(param_tree, hf_llrp_tv_type, tvb,
                    offset, 1, ENC_BIG_ENDIAN);
            offset++;

            suboffset = offset;
            switch (type)
            {
                case LLRP_TV_ANTENNA_ID:
                    PARAM_TREE_ADD_STAY(antenna_id, 2, ENC_BIG_ENDIAN);
                    break;
                case LLRP_TV_FIRST_SEEN_TIME_UTC:
                case LLRP_TV_FIRST_SEEN_TIME_UPTIME:
                case LLRP_TV_LAST_SEEN_TIME_UTC:
                case LLRP_TV_LAST_SEEN_TIME_UPTIME:
                    PARAM_TREE_ADD_STAY(microseconds, 8, ENC_BIG_ENDIAN);
                    break;
                case LLRP_TV_PEAK_RSSI:
                    PARAM_TREE_ADD_STAY(peak_rssi, 1, ENC_NA);
                    break;
                case LLRP_TV_CHANNEL_INDEX:
                    PARAM_TREE_ADD_STAY(channel_idx, 2, ENC_BIG_ENDIAN);
                    break;
                case LLRP_TV_TAG_SEEN_COUNT:
                    PARAM_TREE_ADD_STAY(tag_count, 2, ENC_BIG_ENDIAN);
      ","static guint
dissect_llrp_parameters(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
        guint VAR_3, const guint VAR_4, const guint VAR_5)
{
    guint8      VAR_6;
    guint16     VAR_7, VAR_8;
    guint       VAR_9, VAR_10;
    guint       VAR_11;
    guint       VAR_12;
    proto_item *VAR_13;
    proto_tree *VAR_14;

    while (((VAR_15)(VAR_4 - VAR_3)) > 0)
    {
        VAR_6 = !(tvb_get_guint8(VAR_0, VAR_3) & 0x80);

        if (VAR_6)
        {
            VAR_8 = tvb_get_ntohs(VAR_0, VAR_3);
            VAR_7 = tvb_get_ntohs(VAR_0, VAR_3 + 2);

            if (VAR_7 < VAR_16)
                VAR_9 = VAR_16;
            else if (VAR_7 > tvb_reported_length_remaining(VAR_0, VAR_3))
                VAR_9 = tvb_reported_length_remaining(VAR_0, VAR_3);
            else
                VAR_9 = VAR_7;

            VAR_10 = VAR_3 + VAR_9;

            if (VAR_5 > 16) {
                return VAR_10;
            }

            VAR_13 = proto_tree_add_none_format(VAR_2, VAR_17, VAR_0,
                    VAR_3, VAR_9, ""TLV Parameter: %s"",
                    val_to_str_ext(VAR_8, &VAR_18, ""Unknown Type: %d""));
            VAR_14 = proto_item_add_subtree(VAR_13, VAR_19);

            proto_tree_add_item(VAR_14, VAR_20, VAR_0,
                    VAR_3, 2, VAR_21);
            VAR_3 += 2;

            VAR_13 = proto_tree_add_item(VAR_14, VAR_22, VAR_0,
                    VAR_3, 2, VAR_21);
            if (VAR_7 != VAR_9)
                expert_add_info_format(VAR_1, VAR_13, &VAR_23,
                        ""Invalid length field: claimed %u, should be %u."",
                        VAR_7, VAR_9);
            VAR_3 += 2;

            VAR_11 = VAR_3;
            switch(VAR_8) {
            case VAR_24:
            case VAR_25:
            case VAR_26:
            case VAR_27:
            case VAR_28:
            case VAR_29:
            case VAR_30:
            case VAR_31:
            case VAR_32:
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_33:
            case VAR_34:
                PARAM_TREE_ADD(VAR_35, 8, VAR_21);
                break;
            case VAR_36:
                PARAM_TREE_ADD_STAY(VAR_37, 2, VAR_21);
                PARAM_TREE_ADD(VAR_38, 2, VAR_21);
                PARAM_TREE_ADD(VAR_39, 2, VAR_21);
                PARAM_TREE_ADD(VAR_40, 4, VAR_21);
                PARAM_TREE_ADD(VAR_41, 4, VAR_21);
                VAR_11 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_14, VAR_42, VAR_11);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_43:
                PARAM_TREE_ADD(VAR_44, 2, VAR_21);
                break;
            case VAR_45:
                PARAM_TREE_ADD(VAR_46, 2, VAR_21);
                PARAM_TREE_ADD(VAR_47, 2, VAR_21);
                break;
            case VAR_48:
                PARAM_TREE_ADD(VAR_49, 2, VAR_21);
                PARAM_TREE_ADD(VAR_50, 2, VAR_21);
                PARAM_TREE_ADD(VAR_51, 2, VAR_21);
                break;
            case VAR_52:
                PARAM_TREE_ADD(VAR_49, 2, VAR_21);
                VAR_11 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_14,
                        VAR_53, VAR_54, 1, VAR_11);
                break;
            case VAR_55:
                PARAM_TREE_ADD(VAR_56, 2, VAR_21);
                PARAM_TREE_ADD(VAR_57, 2, VAR_21);
                break;
            case VAR_58:
                PARAM_TREE_ADD_STAY(VAR_59, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_61, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_62, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_63, 1, VAR_60);
                PARAM_TREE_ADD(VAR_64, 1, VAR_60);
                PARAM_TREE_ADD(VAR_65, 1, VAR_60);
                PARAM_TREE_ADD(VAR_66, 2, VAR_21);
                VAR_12 = tvb_get_ntohl(VAR_0, VAR_11);
                if(VAR_12 == VAR_67)
                    PARAM_TREE_ADD_SPEC_STAY(VAR_68, VAR_69, 4, VAR_12, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(VAR_69, 4, VAR_21);
                VAR_11 += 4;
                VAR_12 = tvb_get_ntohl(VAR_0, VAR_11);
                if(VAR_12 == VAR_67)
                    PARAM_TREE_ADD_SPEC_STAY(VAR_68, VAR_70, 4, VAR_12, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(VAR_70, 4, VAR_21);
                VAR_11 += 4;
                VAR_12 = tvb_get_ntohl(VAR_0, VAR_11);
                if(VAR_12 == VAR_67)
                    PARAM_TREE_ADD_SPEC_STAY(VAR_68, VAR_71, 4, VAR_12, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(VAR_71, 4, VAR_21);
                VAR_11 += 4;
                VAR_12 = tvb_get_ntohl(VAR_0, VAR_11);
                if(VAR_12 == VAR_67)
                    PARAM_TREE_ADD_SPEC_STAY(VAR_68, VAR_72, 4, VAR_12, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(VAR_72, 4, VAR_21);
                VAR_11 += 4;
                VAR_12 = tvb_get_ntohl(VAR_0, VAR_11);
                if(VAR_12 == VAR_67)
                    PARAM_TREE_ADD_SPEC_STAY(VAR_68, VAR_73, 4, VAR_12, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(VAR_73, 4, VAR_21);
                VAR_11 += 4;
                break;
            case VAR_74:
                PARAM_TREE_ADD(VAR_75, 2, VAR_21);
                PARAM_TREE_ADD(VAR_76, 2, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_77:
                PARAM_TREE_ADD(VAR_46, 2, VAR_21);
                PARAM_TREE_ADD(VAR_78, 2, VAR_21);
                break;
            case VAR_79:
                PARAM_TREE_ADD(VAR_80, 1, VAR_60);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_81:
                PARAM_TREE_ADD(VAR_82, 1, VAR_60);
                PARAM_TREE_ADD(VAR_83, 1, VAR_60);
                VAR_11 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_14,
                        VAR_84, VAR_85, 4, VAR_11);
                break;
            case VAR_86:
                VAR_11 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_14,
                        VAR_87, VAR_85, 4, VAR_11);
                break;
            case VAR_88:
                PARAM_TREE_ADD(VAR_89, 4, VAR_21);
                PARAM_TREE_ADD(VAR_90, 4, VAR_21);
                break;
            case VAR_91:
                PARAM_TREE_ADD(VAR_92, 4, VAR_21);
                PARAM_TREE_ADD(VAR_93, 1, VAR_60);
                PARAM_TREE_ADD(VAR_94, 1, VAR_60);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_95:
                PARAM_TREE_ADD(VAR_96, 1, VAR_60);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_97:
                PARAM_TREE_ADD(VAR_3, 4, VAR_21);
                PARAM_TREE_ADD(VAR_98, 4, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_99:
                PARAM_TREE_ADD(VAR_100, 2, VAR_21);
                PARAM_TREE_ADD(VAR_101, 1, VAR_60);
                PARAM_TREE_ADD(VAR_102, 4, VAR_21);
                break;
            case VAR_103:
                PARAM_TREE_ADD(VAR_104, 1, VAR_60);
                PARAM_TREE_ADD(VAR_105, 4, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_106:
                VAR_11 = dissect_llrp_item_array(VAR_0, VAR_1, VAR_14,
                        VAR_107, VAR_108, 2, VAR_11);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_109:
                PARAM_TREE_ADD(VAR_110, 1, VAR_60);
                PARAM_TREE_ADD(VAR_105, 4, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_111:
                PARAM_TREE_ADD(VAR_112, 1, VAR_60);
                PARAM_TREE_ADD(VAR_83, 1, VAR_60);
                PARAM_TREE_ADD(VAR_113, 2, VAR_21);
                PARAM_TREE_ADD(VAR_114, 2, VAR_21);
                PARAM_TREE_ADD(VAR_115, 2, VAR_21);
                PARAM_TREE_ADD(VAR_102, 4, VAR_21);
                break;
            case VAR_116:
                PARAM_TREE_ADD(VAR_117, 2, VAR_21);
                PARAM_TREE_ADD(VAR_118, 1, VAR_60);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_119:
                PARAM_TREE_ADD(VAR_49, 2, VAR_21);
                PARAM_TREE_ADD(VAR_120, 4, VAR_21);
                PARAM_TREE_ADD(VAR_121, 4, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_122:
                PARAM_TREE_ADD(VAR_123, 1, VAR_60);
                PARAM_TREE_ADD(VAR_124, 4, VAR_21);
                PARAM_TREE_ADD(VAR_125, 4, VAR_21);
                break;
            case VAR_126:
                PARAM_TREE_ADD(VAR_127, 4, VAR_21);
                break;
            case VAR_128:
                PARAM_TREE_ADD(VAR_129, 4, VAR_21);
                PARAM_TREE_ADD(VAR_49, 2, VAR_21);
                PARAM_TREE_ADD(VAR_118, 1, VAR_21);
                PARAM_TREE_ADD(VAR_130, 1, VAR_60);
                PARAM_TREE_ADD(VAR_92, 4, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_131:
                PARAM_TREE_ADD(VAR_132, 1, VAR_60);
                PARAM_TREE_ADD(VAR_133, 2, VAR_21);
                break;
            case VAR_134:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                break;
            case VAR_136:
                PARAM_TREE_ADD(VAR_129, 2, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_137:
                PARAM_TREE_ADD(VAR_138, 4, VAR_21);
                break;
            case VAR_139:
                PARAM_TREE_ADD(VAR_140, 1, VAR_60);
                VAR_12 = tvb_get_ntohs(VAR_0, VAR_11);
                PARAM_TREE_ADD(VAR_141, 2, VAR_21);
                VAR_11 += VAR_12;
                break;
            case VAR_142:
                PARAM_TREE_ADD(VAR_143, 2, VAR_21);
                PARAM_TREE_ADD(VAR_144, 1, VAR_60);
                break;
            case VAR_145:
                PARAM_TREE_ADD(VAR_146, 1, VAR_60);
                PARAM_TREE_ADD(VAR_147, 4, VAR_21);
                break;
            case VAR_148:
                PARAM_TREE_ADD(VAR_149, 1, VAR_60);
                PARAM_TREE_ADD(VAR_49, 2, VAR_21);
                PARAM_TREE_ADD(VAR_150, 2, VAR_21);
                break;
            case VAR_151:
                PARAM_TREE_ADD(VAR_49, 2, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_152:
                PARAM_TREE_ADD(VAR_153, 2, VAR_21);
                break;
            case VAR_154:
                PARAM_TREE_ADD(VAR_82, 2, VAR_21);
                PARAM_TREE_ADD(VAR_155, 2, VAR_21);
                PARAM_TREE_ADD(VAR_78, 2, VAR_21);
                break;
            case VAR_156:
                PARAM_TREE_ADD(VAR_100, 2, VAR_21);
                PARAM_TREE_ADD(VAR_157, 1, VAR_60);
                PARAM_TREE_ADD(VAR_158, 1, VAR_60);
                break;
            case VAR_159:
                PARAM_TREE_ADD(VAR_160, 1, VAR_60);
                break;
            case VAR_161:
                PARAM_TREE_ADD(VAR_162, 1, VAR_60);
                PARAM_TREE_ADD(VAR_163, 2, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_164:
                PARAM_TREE_ADD_STAY(VAR_165, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_166, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_167, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_168, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_169, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_170, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_171, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_172, 2, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_173, 2, VAR_21);
                PARAM_TREE_ADD(VAR_174, 2, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_175:
                PARAM_TREE_ADD(VAR_176, 1, VAR_60);
                break;
            case VAR_177:
                VAR_11 = dissect_llrp_bit_field(VAR_0, VAR_14, VAR_178, VAR_11);
                break;
            case VAR_179:
                PARAM_TREE_ADD(VAR_180, 4, VAR_21);
                PARAM_TREE_ADD(VAR_181, 4, VAR_21);
                PARAM_TREE_ADD(VAR_182, 1, VAR_60);
                PARAM_TREE_ADD(VAR_183, 1, VAR_60);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_184:
                PARAM_TREE_ADD(VAR_185, 2, VAR_21);
                PARAM_TREE_ADD(VAR_186, 1, VAR_60);
                break;
            case VAR_187:
                PARAM_TREE_ADD(VAR_82, 2, VAR_21);
                PARAM_TREE_ADD(VAR_188, 2, VAR_21);
                break;
            case VAR_189:
                PARAM_TREE_ADD(VAR_100, 2, VAR_21);
                PARAM_TREE_ADD(VAR_101, 1, VAR_60);
                break;
            case VAR_190:
                PARAM_TREE_ADD(VAR_191, 1, VAR_60);
                PARAM_TREE_ADD(VAR_92, 4, VAR_21);
                PARAM_TREE_ADD(VAR_192, 4, VAR_21);
                break;
            case VAR_193:
                PARAM_TREE_ADD(VAR_194, 1, VAR_60);
                break;
            case VAR_195: break;
            case VAR_196:
                VAR_11 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_14, VAR_197, VAR_11);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_198:
                PARAM_TREE_ADD(VAR_199, 1, VAR_60);
                PARAM_TREE_ADD(VAR_92, 4, VAR_21);
                PARAM_TREE_ADD(VAR_200, 2, VAR_21);
                break;
            case VAR_201:
                PARAM_TREE_ADD(VAR_202, 1, VAR_60);
                PARAM_TREE_ADD(VAR_92, 4, VAR_21);
                PARAM_TREE_ADD(VAR_200, 2, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_203:
                PARAM_TREE_ADD(VAR_204, 1, VAR_60);
                PARAM_TREE_ADD(VAR_49, 2, VAR_21);
                break;
            case VAR_205:
                PARAM_TREE_ADD(VAR_206, 2, VAR_21);
                break;
            case VAR_207:
                break;
            case VAR_208:
                PARAM_TREE_ADD(VAR_92, 4, VAR_21);
                PARAM_TREE_ADD(VAR_127, 4, VAR_21);
                break;
            case VAR_209:
                PARAM_TREE_ADD(VAR_210, 2, VAR_21);
                VAR_11 = dissect_llrp_utf8_parameter(VAR_0, VAR_1, VAR_14, VAR_211, VAR_11);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_212:
                PARAM_TREE_ADD(VAR_213, 2, VAR_21);
                PARAM_TREE_ADD(VAR_214, 2, VAR_21);
                break;
            case VAR_215:
                PARAM_TREE_ADD(VAR_216, 2, VAR_21);
                PARAM_TREE_ADD(VAR_214, 2, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_217:
                PARAM_TREE_ADD_STAY(VAR_218, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_219, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_220, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_221, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_222, 1, VAR_60);
                PARAM_TREE_ADD(VAR_223, 1, VAR_60);
                VAR_12 = tvb_get_ntohs(VAR_0, VAR_11);
                if(VAR_12 == VAR_67)
                    PARAM_TREE_ADD_SPEC_STAY(VAR_68, VAR_224, 2, VAR_12, ""No limit (%u)"");
                else
                    PARAM_TREE_ADD_STAY(VAR_224, 2, VAR_21);
                VAR_11 += 2;
                break;
            case VAR_225:
                PARAM_TREE_ADD(VAR_226, 4, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_227, 1, VAR_60);
                PARAM_TREE_ADD(VAR_228, 1, VAR_60);
                PARAM_TREE_ADD(VAR_229, 1, VAR_60);
                PARAM_TREE_ADD(VAR_230, 1, VAR_60);
                PARAM_TREE_ADD(VAR_231, 1, VAR_60);
                PARAM_TREE_ADD(VAR_232, 4, VAR_21);
                PARAM_TREE_ADD(VAR_233, 4, VAR_21);
                PARAM_TREE_ADD(VAR_234, 4, VAR_21);
                PARAM_TREE_ADD(VAR_235, 4, VAR_21);
                PARAM_TREE_ADD(VAR_236, 4, VAR_21);
                break;
            case VAR_237:
                PARAM_TREE_ADD(VAR_238, 1, VAR_60);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_239:
                PARAM_TREE_ADD(VAR_240, 1, VAR_60);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_241:
                PARAM_TREE_ADD(VAR_242, 1, VAR_60);
                PARAM_TREE_ADD(VAR_243, 2, VAR_21);
                VAR_11 = dissect_llrp_bit_field(VAR_0, VAR_14, VAR_244, VAR_11);
                break;
            case VAR_245:
                PARAM_TREE_ADD(VAR_246, 1, VAR_60);
                PARAM_TREE_ADD(VAR_247, 1, VAR_60);
                break;
            case VAR_248:
                PARAM_TREE_ADD(VAR_249, 1, VAR_60);
                break;
            case VAR_250:
                PARAM_TREE_ADD(VAR_251, 2, VAR_21);
                PARAM_TREE_ADD(VAR_252, 2, VAR_21);
                break;
            case VAR_253:
                PARAM_TREE_ADD(VAR_254, 1, VAR_60);
                PARAM_TREE_ADD(VAR_255, 2, VAR_21);
                PARAM_TREE_ADD(VAR_256, 4, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_257:
                PARAM_TREE_ADD_STAY(VAR_258, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_259, 1, VAR_60);
                PARAM_TREE_ADD(VAR_260, 1, VAR_60);
                break;
            case VAR_261:
                PARAM_TREE_ADD_STAY(VAR_242, 1, VAR_60);
                PARAM_TREE_ADD(VAR_262, 1, VAR_60);
                PARAM_TREE_ADD(VAR_243, 2, VAR_21);
                VAR_11 = dissect_llrp_bit_field(VAR_0, VAR_14, VAR_244, VAR_11);
                VAR_11 = dissect_llrp_bit_field(VAR_0, VAR_14, VAR_263, VAR_11);
                break;
            case VAR_264:
            case VAR_265:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_266, 4, VAR_21);
                PARAM_TREE_ADD(VAR_242, 1, VAR_60);
                PARAM_TREE_ADD(VAR_267, 2, VAR_21);
                PARAM_TREE_ADD(VAR_268, 2, VAR_21);
                break;
            case VAR_269:
            case VAR_270:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_266, 4, VAR_21);
                PARAM_TREE_ADD(VAR_242, 1, VAR_60);
                PARAM_TREE_ADD(VAR_267, 2, VAR_21);
                VAR_11 = dissect_llrp_word_array(VAR_0, VAR_14, VAR_271, VAR_11);
                break;
            case VAR_272:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_273, 4, VAR_21);
                break;
            case VAR_274:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_273, 4, VAR_21);
                PARAM_TREE_ADD_STAY(VAR_275, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_276, 1, VAR_60);
                PARAM_TREE_ADD(VAR_277, 1, VAR_60);
                break;
            case VAR_278:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_266, 4, VAR_21);
                VAR_11 = dissect_llrp_parameters(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10, VAR_5+1);
                break;
            case VAR_279:
                PARAM_TREE_ADD(VAR_280, 1, VAR_60);
                PARAM_TREE_ADD(VAR_281, 1, VAR_60);
                break;
            case VAR_282:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_266, 4, VAR_21);
                PARAM_TREE_ADD(VAR_242, 1, VAR_60);
                PARAM_TREE_ADD(VAR_283, 2, VAR_21);
                VAR_11 = dissect_llrp_word_array(VAR_0, VAR_14, VAR_284, VAR_11);
                break;
            case VAR_285:
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_266, 4, VAR_21);
                PARAM_TREE_ADD(VAR_242, 1, VAR_60);
                PARAM_TREE_ADD(VAR_283, 2, VAR_21);
                PARAM_TREE_ADD(VAR_286, 2, VAR_21);
                break;
            case VAR_287:
                PARAM_TREE_ADD_STAY(VAR_288, 1, VAR_60);
                PARAM_TREE_ADD_STAY(VAR_289, 1, VAR_60);
                PARAM_TREE_ADD(VAR_290, 1, VAR_60);
                break;
            case VAR_291:
                PARAM_TREE_ADD(VAR_292, 1, VAR_60);
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                VAR_11 = dissect_llrp_word_array(VAR_0, VAR_14, VAR_293, VAR_11);
                break;
            case VAR_294:
            case VAR_295:
                PARAM_TREE_ADD(VAR_292, 1, VAR_60);
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                PARAM_TREE_ADD(VAR_296, 2, VAR_21);
                break;
            case VAR_297:
            case VAR_298:
            case VAR_299:
            case VAR_300:
            case VAR_301:
                PARAM_TREE_ADD(VAR_292, 1, VAR_60);
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                break;
            case VAR_302:
                PARAM_TREE_ADD(VAR_292, 1, VAR_60);
                PARAM_TREE_ADD(VAR_135, 2, VAR_21);
                VAR_11 = dissect_llrp_word_array(VAR_0, VAR_14, VAR_303, VAR_11);
                break;
            case VAR_304:
                VAR_12 = tvb_get_ntohl(VAR_0, VAR_11);
                PARAM_TREE_ADD(VAR_305, 4, VAR_21);
                switch(VAR_12) {
                case VAR_306:
                    VAR_11 = dissect_llrp_impinj_parameter(VAR_0, VAR_1, VAR_14, VAR_11, VAR_10);
                    break;
                }
                break;
            }
            /* COMMENT_0 */
            if(VAR_11 != VAR_10) {
                /* COMMENT_1 */
                expert_add_info_format(VAR_1, VAR_14, &VAR_23,
                        ""Incorrect length of parameter: %u bytes decoded, but %u bytes claimed."",
                        VAR_11 - VAR_3 + 4, VAR_9);
            }
            /* COMMENT_2 */
                                                 
            VAR_3 += VAR_9 - 4;
        }
        else
        {
            VAR_8 = tvb_get_guint8(VAR_0, VAR_3) & 0x7F;

            switch (VAR_8)
            {
                case VAR_307:
                    VAR_9 = VAR_308; break;
                case VAR_309:
                    VAR_9 = VAR_310; break;
                case VAR_311:
                    VAR_9 = VAR_312; break;
                case VAR_313:
                    VAR_9 = VAR_314; break;
                case VAR_315:
                    VAR_9 = VAR_316; break;
                case VAR_317:
                    VAR_9 = VAR_318; break;
                case VAR_319:
                    VAR_9 = VAR_320; break;
                case VAR_321:
                    VAR_9 = VAR_322; break;
                case VAR_323:
                    VAR_9 = VAR_324; break;
                case VAR_325:
                    VAR_9 = VAR_326; break;
                case VAR_327:
                    VAR_9 = VAR_328; break;
                case VAR_329:
                    VAR_9 = VAR_330; break;
                case VAR_331:
                    VAR_9 = VAR_332; break;
                case VAR_333:
                    VAR_9 = VAR_334; break;
                case VAR_335:
                    VAR_9 = VAR_336; break;
                case VAR_337:
                    VAR_9 = VAR_338; break;
                case VAR_339:
                    VAR_9 = VAR_340; break;
                case VAR_341:
                    VAR_9 = VAR_342; break;
                case VAR_343:
                    VAR_9 = VAR_344; break;
                case VAR_345:
                    VAR_9 = VAR_346; break;
                default:
                    /* COMMENT_4 */
                                                                          
                                                            
                    VAR_9 = 0;
                    break;
            };

            VAR_13 = proto_tree_add_none_format(VAR_2, VAR_17, VAR_0,
                    VAR_3, VAR_9 + 1, ""TV Parameter : %s"",
                    val_to_str_ext(VAR_8, &VAR_347, ""Unknown Type: %d""));
            VAR_14 = proto_item_add_subtree(VAR_13, VAR_19);

            proto_tree_add_item(VAR_14, VAR_348, VAR_0,
                    VAR_3, 1, VAR_21);
            VAR_3++;

            VAR_11 = VAR_3;
            switch (VAR_8)
            {
                case VAR_307:
                    PARAM_TREE_ADD_STAY(VAR_49, 2, VAR_21);
                    break;
                case VAR_309:
                case VAR_311:
                case VAR_313:
                case VAR_315:
                    PARAM_TREE_ADD_STAY(VAR_35, 8, VAR_21);
                    break;
                case VAR_317:
                    PARAM_TREE_ADD_STAY(VAR_183, 1, VAR_60);
                    break;
                case VAR_319:
                    PARAM_TREE_ADD_STAY(VAR_155, 2, VAR_21);
                    break;
                case VAR_321:
                    PARAM_TREE_ADD_STAY(VAR_349, 2, VAR_21);
                    break;
                case VAR_323:
                    PARAM_TREE_ADD_STAY(VAR_92, 4, VAR_21);
                    break;
                case VAR_325:
                    PARAM_TREE_ADD_STAY(VAR_117, 2, VAR_21);
                    break;
                case VAR_327:
                    PARAM_TREE_ADD_STAY(VAR_350, 2, VAR_21);
                    break;
                case VAR_329:
                    PARAM_TREE_ADD_STAY(VAR_351, 2, VAR_21);
                    break;
                case VAR_331:
                    PARAM_TREE_ADD_STAY(VAR_352, 96/8, VAR_60);
                    break;
                case VAR_333:
                    PARAM_TREE_ADD_STAY(VAR_200, 2, VAR_21);
                    break;
                case VAR_335:
                    PARAM_TREE_ADD_STAY(VAR_135, 2, VAR_21);
                    break;
                case VAR_337:
                    PARAM_TREE_ADD_STAY(VAR_129, 4, VAR_21);
                    break;
                case VAR_339:
                    PARAM_TREE_ADD_STAY(VAR_135, 2, VAR_21);
                    break;
                case VAR_341:
                    PARAM_TREE_ADD_STAY(VAR_353, 2, VAR_21);
                    PARAM_TREE_ADD_STAY(VAR_354, 2, VAR_21);
                    break;
                case VAR_343:
                    PARAM_TREE_ADD_STAY(VAR_355, 2, VAR_21);
                    break;
                case VAR_345:
                    PARAM_TREE_ADD_STAY(VAR_356, 2, VAR_21);
                    break;
            };
            /* COMMENT_7 */
                                                                       
            VAR_3 += VAR_9;
        }
    }
    return VAR_3;
}",wireshark/4a2cd6c79ecbf2cb21f985f01ce1c1e3030285ec/packet-llrp.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static guint
 dissect_llrp_parameters(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
-        guint offset, const guint end)
+        guint offset, const guint end, const guint depth)
 {
     guint8      has_length;
     guint16     len, type;
@@ -27,6 +27,10 @@
                 real_len = len;
 
             param_end = offset + real_len;
+
+            if (depth > 16) {
+                return param_end;
+            }
 
             ti = proto_tree_add_none_format(tree, hf_llrp_param, tvb,
                     offset, real_len, ""TLV Parameter: %s"",
@@ -56,7 +60,7 @@
             case LLRP_TLV_READER_EVENT_NOTI_DATA:
             case LLRP_TLV_C1G2_UHF_RF_MD_TBL:
             case LLRP_TLV_C1G2_TAG_SPEC:
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_UTC_TIMESTAMP:
             case LLRP_TLV_UPTIME:
@@ -69,7 +73,7 @@
                 PARAM_TREE_ADD(device_manufacturer, 4, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(model, 4, ENC_BIG_ENDIAN);
                 suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firmware_version, suboffset);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_MAX_RECEIVE_SENSE:
                 PARAM_TREE_ADD(max_receive_sense, 2, ENC_BIG_ENDIAN);
@@ -134,7 +138,7 @@
             case LLRP_TLV_REGU_CAPABILITIES:
                 PARAM_TREE_ADD(country_code, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(comm_standard, 2, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_XMIT_POWER_LEVEL_ENTRY:
                 PARAM_TREE_ADD(index, 2, ENC_BIG_ENDIAN);
@@ -142,7 +146,7 @@
                 break;
             case LLRP_TLV_FREQ_INFORMATION:
                 PARAM_TREE_ADD(hopping, 1, ENC_NA);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_FREQ_HOP_TABLE:
                 PARAM_TREE_ADD(hop_table_id, 1, ENC_NA);
@@ -162,16 +166,16 @@
                 PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(priority, 1, ENC_NA);
                 PARAM_TREE_ADD(cur_state, 1, ENC_NA);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_RO_SPEC_START_TRIGGER:
                 PARAM_TREE_ADD(rospec_start_trig_type, 1, ENC_NA);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_PER_TRIGGER_VAL:
                 PARAM_TREE_ADD(offset, 4, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(period, 4, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_GPI_TRIGGER_VAL:
                 PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN);
@@ -181,17 +185,17 @@
             case LLRP_TLV_RO_SPEC_STOP_TRIGGER:
                 PARAM_TREE_ADD(rospec_stop_trig_type, 1, ENC_NA);
                 PARAM_TREE_ADD(duration_trig, 4, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_AI_SPEC:
                 suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree,
                         hf_llrp_antenna_count, hf_llrp_antenna, 2, suboffset);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_AI_SPEC_STOP:
                 PARAM_TREE_ADD(aispec_stop_trig_type, 1, ENC_NA);
                 PARAM_TREE_ADD(duration_trig, 4, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_TAG_OBSERV_TRIGGER:
                 PARAM_TREE_ADD(trig_type, 1, ENC_NA);
@@ -204,13 +208,13 @@
             case LLRP_TLV_INVENTORY_PARAM_SPEC:
                 PARAM_TREE_ADD(inventory_spec_id, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(protocol_id, 1, ENC_NA);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_RF_SURVEY_SPEC:
                 PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(start_freq, 4, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(stop_freq, 4, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_RF_SURVEY_SPEC_STOP_TR:
                 PARAM_TREE_ADD(stop_trig_type, 1, ENC_NA);
@@ -226,7 +230,7 @@
                 PARAM_TREE_ADD(protocol_id, 1, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(access_cur_state, 1, ENC_NA);
                 PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_ACCESS_SPEC_STOP_TRIG:
                 PARAM_TREE_ADD(access_stop_trig_type, 1, ENC_NA);
@@ -237,7 +241,7 @@
                 break;
             case LLRP_TLV_CLIENT_REQ_RESPONSE:
                 PARAM_TREE_ADD(accessspec_id, 2, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_LLRP_CONF_STATE_VAL:
                 PARAM_TREE_ADD(conf_value, 4, ENC_BIG_ENDIAN);
@@ -263,7 +267,7 @@
                 break;
             case LLRP_TLV_ANTENNA_CONF:
                 PARAM_TREE_ADD(antenna_id, 2, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_RF_RECEIVER:
                 PARAM_TREE_ADD(receiver_sense, 2, ENC_BIG_ENDIAN);
@@ -284,7 +288,7 @@
             case LLRP_TLV_RO_REPORT_SPEC:
                 PARAM_TREE_ADD(ro_report_trig, 1, ENC_NA);
                 PARAM_TREE_ADD(n_2, 2, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_TAG_REPORT_CONTENT_SEL:
                 PARAM_TREE_ADD_STAY(enable_rospec_id, 2, ENC_BIG_ENDIAN);
@@ -297,7 +301,7 @@
                 PARAM_TREE_ADD_STAY(enable_last_seen, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD_STAY(enable_seen_count, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(enable_accessspec_id, 2, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_ACCESS_REPORT_SPEC:
                 PARAM_TREE_ADD(access_report_trig, 1, ENC_NA);
@@ -310,7 +314,7 @@
                 PARAM_TREE_ADD(bandwidth, 4, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(average_rssi, 1, ENC_NA);
                 PARAM_TREE_ADD(peak_rssi, 1, ENC_NA);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_EVENT_NOTIF_STATE:
                 PARAM_TREE_ADD(event_type, 2, ENC_BIG_ENDIAN);
@@ -332,11 +336,10 @@
             case LLRP_TLV_REPORT_BUF_LEVEL_WARN:
                 PARAM_TREE_ADD(buffer_full_percentage, 1, ENC_NA);
                 break;
-            case LLRP_TLV_REPORT_BUF_OVERFLOW_ERR:
-                break;
+            case LLRP_TLV_REPORT_BUF_OVERFLOW_ERR: break;
             case LLRP_TLV_READER_EXCEPTION_EVENT:
                 suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_message, suboffset);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_RF_SURVEY_EVENT:
                 PARAM_TREE_ADD(rfevent_type, 1, ENC_NA);
@@ -347,7 +350,7 @@
                 PARAM_TREE_ADD(aievent_type, 1, ENC_NA);
                 PARAM_TREE_ADD(rospec_id, 4, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(spec_idx, 2, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_ANTENNA_EVENT:
                 PARAM_TREE_ADD(antenna_event_type, 1, ENC_NA);
@@ -365,7 +368,7 @@
             case LLRP_TLV_LLRP_STATUS:
                 PARAM_TREE_ADD(status_code, 2, ENC_BIG_ENDIAN);
                 suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_error_desc, suboffset);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_FIELD_ERROR:
                 PARAM_TREE_ADD(field_num, 2, ENC_BIG_ENDIAN);
@@ -374,7 +377,7 @@
             case LLRP_TLV_PARAM_ERROR:
                 PARAM_TREE_ADD(parameter_type, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(error_code, 2, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_C1G2_LLRP_CAP:
                 PARAM_TREE_ADD_STAY(can_support_block_erase, 1, ENC_NA);
@@ -405,11 +408,11 @@
                 break;
             case LLRP_TLV_C1G2_INVENTORY_COMMAND:
                 PARAM_TREE_ADD(inventory_state_aware, 1, ENC_NA);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_C1G2_FILTER:
                 PARAM_TREE_ADD(trunc, 1, ENC_NA);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_C1G2_TAG_INV_MASK:
                 PARAM_TREE_ADD(mb, 1, ENC_NA);
@@ -431,7 +434,7 @@
                 PARAM_TREE_ADD(session, 1, ENC_NA);
                 PARAM_TREE_ADD(tag_population, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(tag_transit_time, 4, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_C1G2_TAG_INV_AWARE_SING:
                 PARAM_TREE_ADD_STAY(sing_i, 1, ENC_NA);
@@ -475,7 +478,7 @@
             case LLRP_TLV_C1G2_LOCK:
                 PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN);
                 PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN);
-                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);
+                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);
                 break;
             case LLRP_TLV_C1G2_LOCK_PAYLOAD:
                 PARAM_TREE_ADD(privilege, 1, ENC_NA);","{'deleted_lines': ['        guint offset, const guint end)', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '            case LLRP_TLV_REPORT_BUF_OVERFLOW_ERR:', '                break;', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end);'], 'added_lines': ['        guint offset, const guint end, const guint depth)', '', '            if (depth > 16) {', '                return param_end;', '            }', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '            case LLRP_TLV_REPORT_BUF_OVERFLOW_ERR: break;', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);', '                suboffset = dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end, depth+1);']}",True,"The dissect_llrp_parameters function in epan/dissectors/packet-llrp.c in the LLRP dissector in Wireshark 1.12.x before 1.12.10 and 2.0.x before 2.0.2 does not limit the recursion depth, which allows remote attackers to cause a denial of service (memory consumption or application crash) via a crafted packet.",5.9,MEDIUM,1,valid,2016-02-06T14:33:28Z,1
CVE-2016-2145,"['CWE-119', 'CWE-20']",AV:N/AC:L/Au:N/C:N/I:N/A:P,0,Uninett/mod_auth_mellon,Handle ap_get_client_block() error in am_read_post_data(),5f03a632c9652687c7dac1ea44f334b9983ab268,https://github.com/Uninett/mod_auth_mellon/commit/5f03a632c9652687c7dac1ea44f334b9983ab268,auth_mellon_util.c,am_read_post_data,"int am_read_post_data(request_rec *r, char **data, apr_size_t *length)
{
apr_size_t bytes_read;
apr_size_t bytes_left;
apr_size_t len;
long read_length;
int rc;
rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);
if (rc != OK) {
return rc;
}
if (!ap_should_client_block(r)) {
len = 0;
} else {
len = r->remaining;
}
if (length != NULL) {
*length = len;
}
*data = (char *)apr_palloc(r->pool, len + 1);
(*data)[len] = '\0';
bytes_read = 0;
bytes_left = len;
while (bytes_left > 0) {
read_length = ap_get_client_block(r, &(*data)[bytes_read],
bytes_left);
if (read_length == 0) {
ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
""Failed to read POST data from client."");
return HTTP_INTERNAL_SERVER_ERROR;
}
bytes_read += read_length;
bytes_left -= read_length;
}
return OK;
}","int am_read_post_data(request_rec *VAR_0, char **VAR_1, apr_size_t *VAR_2)
{
apr_size_t VAR_3;
apr_size_t VAR_4;
apr_size_t VAR_5;
long VAR_6;
int VAR_7;
VAR_7 = ap_setup_client_block(VAR_0, VAR_8);
if (VAR_7 != VAR_9) {
return VAR_7;
}
if (!ap_should_client_block(VAR_0)) {
VAR_5 = 0;
} else {
VAR_5 = VAR_0->remaining;
}
if (VAR_2 != NULL) {
*VAR_2 = VAR_5;
}
*VAR_1 = (char *)apr_palloc(VAR_0->pool, VAR_5 + 1);
(*VAR_1)[VAR_5] = '\0';
VAR_3 = 0;
VAR_4 = VAR_5;
while (VAR_4 > 0) {
VAR_6 = ap_get_client_block(VAR_0, &(*VAR_1)[VAR_3],
VAR_4);
if (VAR_6 == 0) {
ap_log_rerror(VAR_10, VAR_11, 0, VAR_0,
""Failed to read POST data from client."");
return VAR_12;
}
VAR_3 += VAR_6;
VAR_4 -= VAR_6;
}
return VAR_9;
}",Uninett/mod_auth_mellon/5f03a632c9652687c7dac1ea44f334b9983ab268/auth_mellon_util.c/vul/before/0.json,"int am_read_post_data(request_rec *r, char **data, apr_size_t *length)
{
    apr_size_t bytes_read;
    apr_size_t bytes_left;
    apr_size_t len;
    long read_length;
    int rc;

    /* Prepare to receive data from the client. We request that apache
     * dechunks data if it is chunked.
     */
    rc = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK);
    if (rc != OK) {
        return rc;
    }

    /* This function will send a 100 Continue response if the client is
     * waiting for that. If the client isn't going to send data, then this
     * function will return 0.
     */
    if (!ap_should_client_block(r)) {
        len = 0;
    } else {
        len = r->remaining;
    }

    if (length != NULL) {
        *length = len;
    }

    *data = (char *)apr_palloc(r->pool, len + 1);

    /* Make sure that the data is null-terminated.  */
    (*data)[len] = '\0';

    bytes_read = 0;
    bytes_left = len;

    while (bytes_left > 0) {
        /* Read data from the client. Returns 0 on EOF and -1 on
         * error, the number of bytes otherwise.
         */
        read_length = ap_get_client_block(r, &(*data)[bytes_read],
                                          bytes_left);
        if (read_length == 0) {
            /* got the EOF */
            (*data)[bytes_read] = '\0';

            if (length != NULL) {
                *length = bytes_read;
            }
            break;
        }
        else if (read_length < 0) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                          ""Failed to read POST data from client."");
            return HTTP_INTERNAL_SERVER_ERROR;
        }

        bytes_read += read_length;
        bytes_left -= read_length;
    }

    return OK;
}","int am_read_post_data(request_rec *VAR_0, char **VAR_1, apr_size_t *VAR_2)
{
    apr_size_t VAR_3;
    apr_size_t VAR_4;
    apr_size_t VAR_5;
    long VAR_6;
    int VAR_7;

    /* COMMENT_0 */
                                      
       
    VAR_7 = ap_setup_client_block(VAR_0, VAR_8);
    if (VAR_7 != VAR_9) {
        return VAR_7;
    }

    /* COMMENT_3 */
                                                                          
                              
       
    if (!ap_should_client_block(VAR_0)) {
        VAR_5 = 0;
    } else {
        VAR_5 = VAR_0->remaining;
    }

    if (VAR_2 != NULL) {
        *VAR_2 = VAR_5;
    }

    *VAR_1 = (char *)apr_palloc(VAR_0->pool, VAR_5 + 1);

    /* COMMENT_7 */
    (*VAR_1)[VAR_5] = '\0';

    VAR_3 = 0;
    VAR_4 = VAR_5;

    while (VAR_4 > 0) {
        /* COMMENT_8 */
                                                
           
        VAR_6 = ap_get_client_block(VAR_0, &(*VAR_1)[VAR_3],
                                          VAR_4);
        if (VAR_6 == 0) {
            /* COMMENT_11 */
            (*VAR_1)[VAR_3] = '\0';

            if (VAR_2 != NULL) {
                *VAR_2 = VAR_3;
            }
            break;
        }
        else if (VAR_6 < 0) {
            ap_log_rerror(VAR_10, VAR_11, 0, VAR_0,
                          ""Failed to read POST data from client."");
            return VAR_12;
        }

        VAR_3 += VAR_6;
        VAR_4 -= VAR_6;
    }

    return VAR_9;
}",Uninett/mod_auth_mellon/5f03a632c9652687c7dac1ea44f334b9983ab268/auth_mellon_util.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,12 +37,21 @@
     bytes_left = len;
 
     while (bytes_left > 0) {
-        /* Read data from the client. Returns 0 on EOF or error, the
-         * number of bytes otherwise.
+        /* Read data from the client. Returns 0 on EOF and -1 on
+         * error, the number of bytes otherwise.
          */
         read_length = ap_get_client_block(r, &(*data)[bytes_read],
                                           bytes_left);
         if (read_length == 0) {
+            /* got the EOF */
+            (*data)[bytes_read] = '\0';
+
+            if (length != NULL) {
+                *length = bytes_read;
+            }
+            break;
+        }
+        else if (read_length < 0) {
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                           ""Failed to read POST data from client."");
             return HTTP_INTERNAL_SERVER_ERROR;","{'deleted_lines': ['        /* Read data from the client. Returns 0 on EOF or error, the', '         * number of bytes otherwise.'], 'added_lines': ['        /* Read data from the client. Returns 0 on EOF and -1 on', '         * error, the number of bytes otherwise.', '            /* got the EOF */', ""            (*data)[bytes_read] = '\\0';"", '', '            if (length != NULL) {', '                *length = bytes_read;', '            }', '            break;', '        }', '        else if (read_length < 0) {']}",True,"The am_read_post_data function in mod_auth_mellon before 0.11.1 does not check if the ap_get_client_block function returns an error, which allows remote attackers to cause a denial of service (segmentation fault and process crash) via a crafted POST data.",7.5,HIGH,2,valid,2016-03-02T10:05:14Z,1
CVE-2016-1834,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,GNOME/libxml2,"Bug 763071: heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>

* xmlstring.c:
(xmlStrncat): Return NULL if xmlStrlen returns a negative length.
(xmlStrncatNew): Ditto.",8fbbf5513d609c1770b391b99e33314cd0742704,https://github.com/GNOME/libxml2/commit/8fbbf5513d609c1770b391b99e33314cd0742704,xmlstring.c,xmlStrncatNew,"xmlChar *
xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {
int size;
xmlChar *ret;
if (len < 0)
len = xmlStrlen(str2);
if ((str2 == NULL) || (len == 0))
return(xmlStrdup(str1));
if (str1 == NULL)
return(xmlStrndup(str2, len));
size = xmlStrlen(str1);
ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
if (ret == NULL) {
xmlErrMemory(NULL, NULL);
return(xmlStrndup(str1, size));
}
memcpy(ret, str1, size * sizeof(xmlChar));
memcpy(&ret[size], str2, len * sizeof(xmlChar));
ret[size + len] = 0;
return(ret);
}","xmlChar *
xmlStrncatNew(const xmlChar *VAR_0, const xmlChar *VAR_1, int VAR_2) {
int VAR_3;
xmlChar *VAR_4;
if (VAR_2 < 0)
VAR_2 = xmlStrlen(VAR_1);
if ((VAR_1 == NULL) || (VAR_2 == 0))
return(xmlStrdup(VAR_0));
if (VAR_0 == NULL)
return(xmlStrndup(VAR_1, VAR_2));
VAR_3 = xmlStrlen(VAR_0);
VAR_4 = (xmlChar *) xmlMalloc((VAR_3 + VAR_2 + 1) * sizeof(xmlChar));
if (VAR_4 == NULL) {
xmlErrMemory(NULL, NULL);
return(xmlStrndup(VAR_0, VAR_3));
}
memcpy(VAR_4, VAR_0, VAR_3 * sizeof(xmlChar));
memcpy(&VAR_4[VAR_3], VAR_1, VAR_2 * sizeof(xmlChar));
VAR_4[VAR_3 + VAR_2] = 0;
return(VAR_4);
}",GNOME/libxml2/8fbbf5513d609c1770b391b99e33314cd0742704/xmlstring.c/vul/before/0.json,"xmlChar *
xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {
    int size;
    xmlChar *ret;

    if (len < 0) {
        len = xmlStrlen(str2);
        if (len < 0)
            return(NULL);
    }
    if ((str2 == NULL) || (len == 0))
        return(xmlStrdup(str1));
    if (str1 == NULL)
        return(xmlStrndup(str2, len));

    size = xmlStrlen(str1);
    if (size < 0)
        return(NULL);
    ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
    if (ret == NULL) {
        xmlErrMemory(NULL, NULL);
        return(xmlStrndup(str1, size));
    }
    memcpy(ret, str1, size * sizeof(xmlChar));
    memcpy(&ret[size], str2, len * sizeof(xmlChar));
    ret[size + len] = 0;
    return(ret);
}","xmlChar *
xmlStrncatNew(const xmlChar *VAR_0, const xmlChar *VAR_1, int VAR_2) {
    int VAR_3;
    xmlChar *VAR_4;

    if (VAR_2 < 0) {
        VAR_2 = xmlStrlen(VAR_1);
        if (VAR_2 < 0)
            return(NULL);
    }
    if ((VAR_1 == NULL) || (VAR_2 == 0))
        return(xmlStrdup(VAR_0));
    if (VAR_0 == NULL)
        return(xmlStrndup(VAR_1, VAR_2));

    VAR_3 = xmlStrlen(VAR_0);
    if (VAR_3 < 0)
        return(NULL);
    VAR_4 = (xmlChar *) xmlMalloc((VAR_3 + VAR_2 + 1) * sizeof(xmlChar));
    if (VAR_4 == NULL) {
        xmlErrMemory(NULL, NULL);
        return(xmlStrndup(VAR_0, VAR_3));
    }
    memcpy(VAR_4, VAR_0, VAR_3 * sizeof(xmlChar));
    memcpy(&VAR_4[VAR_3], VAR_1, VAR_2 * sizeof(xmlChar));
    VAR_4[VAR_3 + VAR_2] = 0;
    return(VAR_4);
}",GNOME/libxml2/8fbbf5513d609c1770b391b99e33314cd0742704/xmlstring.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,14 +3,19 @@
     int size;
     xmlChar *ret;
 
-    if (len < 0)
+    if (len < 0) {
         len = xmlStrlen(str2);
+        if (len < 0)
+            return(NULL);
+    }
     if ((str2 == NULL) || (len == 0))
         return(xmlStrdup(str1));
     if (str1 == NULL)
         return(xmlStrndup(str2, len));
 
     size = xmlStrlen(str1);
+    if (size < 0)
+        return(NULL);
     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
     if (ret == NULL) {
         xmlErrMemory(NULL, NULL);","{'deleted_lines': ['    if (len < 0)'], 'added_lines': ['    if (len < 0) {', '        if (len < 0)', '            return(NULL);', '    }', '    if (size < 0)', '        return(NULL);']}",True,"Heap-based buffer overflow in the xmlStrncat function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.",7.8,HIGH,2,valid,2016-03-09T01:29:00Z,1
CVE-2016-1834,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,GNOME/libxml2,"Bug 763071: heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>

* xmlstring.c:
(xmlStrncat): Return NULL if xmlStrlen returns a negative length.
(xmlStrncatNew): Ditto.",8fbbf5513d609c1770b391b99e33314cd0742704,https://github.com/GNOME/libxml2/commit/8fbbf5513d609c1770b391b99e33314cd0742704,xmlstring.c,xmlStrncat,"xmlChar *
xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
int size;
xmlChar *ret;
if ((add == NULL) || (len == 0))
return(cur);
if (len < 0)
return(NULL);
if (cur == NULL)
return(xmlStrndup(add, len));
size = xmlStrlen(cur);
ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));
if (ret == NULL) {
xmlErrMemory(NULL, NULL);
return(cur);
}
memcpy(&ret[size], add, len * sizeof(xmlChar));
ret[size + len] = 0;
return(ret);
}","xmlChar *
xmlStrncat(xmlChar *VAR_0, const xmlChar *VAR_1, int VAR_2) {
int VAR_3;
xmlChar *VAR_4;
if ((VAR_1 == NULL) || (VAR_2 == 0))
return(VAR_0);
if (VAR_2 < 0)
return(NULL);
if (VAR_0 == NULL)
return(xmlStrndup(VAR_1, VAR_2));
VAR_3 = xmlStrlen(VAR_0);
VAR_4 = (xmlChar *) xmlRealloc(VAR_0, (VAR_3 + VAR_2 + 1) * sizeof(xmlChar));
if (VAR_4 == NULL) {
xmlErrMemory(NULL, NULL);
return(VAR_0);
}
memcpy(&VAR_4[VAR_3], VAR_1, VAR_2 * sizeof(xmlChar));
VAR_4[VAR_3 + VAR_2] = 0;
return(VAR_4);
}",GNOME/libxml2/8fbbf5513d609c1770b391b99e33314cd0742704/xmlstring.c/vul/before/1.json,"xmlChar *
xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
    int size;
    xmlChar *ret;

    if ((add == NULL) || (len == 0))
        return(cur);
    if (len < 0)
	return(NULL);
    if (cur == NULL)
        return(xmlStrndup(add, len));

    size = xmlStrlen(cur);
    if (size < 0)
        return(NULL);
    ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));
    if (ret == NULL) {
        xmlErrMemory(NULL, NULL);
        return(cur);
    }
    memcpy(&ret[size], add, len * sizeof(xmlChar));
    ret[size + len] = 0;
    return(ret);
}","xmlChar *
xmlStrncat(xmlChar *VAR_0, const xmlChar *VAR_1, int VAR_2) {
    int VAR_3;
    xmlChar *VAR_4;

    if ((VAR_1 == NULL) || (VAR_2 == 0))
        return(VAR_0);
    if (VAR_2 < 0)
	return(NULL);
    if (VAR_0 == NULL)
        return(xmlStrndup(VAR_1, VAR_2));

    VAR_3 = xmlStrlen(VAR_0);
    if (VAR_3 < 0)
        return(NULL);
    VAR_4 = (xmlChar *) xmlRealloc(VAR_0, (VAR_3 + VAR_2 + 1) * sizeof(xmlChar));
    if (VAR_4 == NULL) {
        xmlErrMemory(NULL, NULL);
        return(VAR_0);
    }
    memcpy(&VAR_4[VAR_3], VAR_1, VAR_2 * sizeof(xmlChar));
    VAR_4[VAR_3 + VAR_2] = 0;
    return(VAR_4);
}",GNOME/libxml2/8fbbf5513d609c1770b391b99e33314cd0742704/xmlstring.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -11,6 +11,8 @@
         return(xmlStrndup(add, len));
 
     size = xmlStrlen(cur);
+    if (size < 0)
+        return(NULL);
     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));
     if (ret == NULL) {
         xmlErrMemory(NULL, NULL);","{'deleted_lines': [], 'added_lines': ['    if (size < 0)', '        return(NULL);']}",True,"Heap-based buffer overflow in the xmlStrncat function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.",7.8,HIGH,2,valid,2016-03-09T01:29:00Z,1
CVE-2016-2186,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Input: powermate - fix oops with malicious USB descriptors

The powermate driver expects at least one valid USB endpoint in its
probe function.  If given malicious descriptors that specify 0 for
the number of endpoints, it will crash.  Validate the number of
endpoints on the interface before using them.

The full report for this issue can be found here:
http://seclists.org/bugtraq/2016/Mar/85

Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Josh Boyer <jwboyer@fedoraproject.org>
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",9c6ba456711687b794dcf285856fc14e2c76074f,https://github.com/torvalds/linux/commit/9c6ba456711687b794dcf285856fc14e2c76074f,drivers/input/misc/powermate.c,powermate_probe,"static int powermate_probe(struct usb_interface *intf, const struct usb_device_id *id)
{
struct usb_device *udev = interface_to_usbdev (intf);
struct usb_host_interface *interface;
struct usb_endpoint_descriptor *endpoint;
struct powermate_device *pm;
struct input_dev *input_dev;
int pipe, maxp;
int error = -ENOMEM;
interface = intf->cur_altsetting;
endpoint = &interface->endpoint[0].desc;
if (!usb_endpoint_is_int_in(endpoint))
return -EIO;
usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
0, interface->desc.bInterfaceNumber, NULL, 0,
USB_CTRL_SET_TIMEOUT);
pm = kzalloc(sizeof(struct powermate_device), GFP_KERNEL);
input_dev = input_allocate_device();
if (!pm || !input_dev)
goto fail1;
if (powermate_alloc_buffers(udev, pm))
goto fail2;
pm->irq = usb_alloc_urb(0, GFP_KERNEL);
if (!pm->irq)
goto fail2;
pm->config = usb_alloc_urb(0, GFP_KERNEL);
if (!pm->config)
goto fail3;
pm->udev = udev;
pm->intf = intf;
pm->input = input_dev;
usb_make_path(udev, pm->phys, sizeof(pm->phys));
strlcat(pm->phys, ""/input0"", sizeof(pm->phys));
spin_lock_init(&pm->lock);
switch (le16_to_cpu(udev->descriptor.idProduct)) {
case POWERMATE_PRODUCT_NEW:
input_dev->name = pm_name_powermate;
break;
case POWERMATE_PRODUCT_OLD:
input_dev->name = pm_name_soundknob;
break;
default:
input_dev->name = pm_name_soundknob;
printk(KERN_WARNING ""powermate: unknown product id %04x\n"",
le16_to_cpu(udev->descriptor.idProduct));
}
input_dev->phys = pm->phys;
usb_to_input_id(udev, &input_dev->id);
input_dev->dev.parent = &intf->dev;
input_set_drvdata(input_dev, pm);
input_dev->event = powermate_input_event;
input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |
BIT_MASK(EV_MSC);
input_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
input_dev->relbit[BIT_WORD(REL_DIAL)] = BIT_MASK(REL_DIAL);
input_dev->mscbit[BIT_WORD(MSC_PULSELED)] = BIT_MASK(MSC_PULSELED);
pipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);
maxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));
if (maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX) {
printk(KERN_WARNING ""powermate: Expected payload of %d--%d bytes, found %d bytes!\n"",
POWERMATE_PAYLOAD_SIZE_MIN, POWERMATE_PAYLOAD_SIZE_MAX, maxp);
maxp = POWERMATE_PAYLOAD_SIZE_MAX;
}
usb_fill_int_urb(pm->irq, udev, pipe, pm->data,
maxp, powermate_irq,
pm, endpoint->bInterval);
pm->irq->transfer_dma = pm->data_dma;
pm->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
if (usb_submit_urb(pm->irq, GFP_KERNEL)) {
error = -EIO;
goto fail4;
}
error = input_register_device(pm->input);
if (error)
goto fail5;
pm->requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS;
powermate_pulse_led(pm, 0x80, 255, 0, 1, 0); 
usb_set_intfdata(intf, pm);
return 0;
fail5:usb_kill_urb(pm->irq);
fail4:usb_free_urb(pm->config);
fail3:usb_free_urb(pm->irq);
fail2:powermate_free_buffers(udev, pm);
fail1:input_free_device(input_dev);
kfree(pm);
return error;
}","static int powermate_probe(struct usb_interface *VAR_0, const struct usb_device_id *VAR_1)
{
struct usb_device *VAR_2 = interface_to_usbdev (VAR_0);
struct usb_host_interface *VAR_3;
struct usb_endpoint_descriptor *VAR_4;
struct powermate_device *VAR_5;
struct input_dev *input_dev;
int VAR_6, VAR_7;
int VAR_8 = -VAR_9;
VAR_3 = VAR_0->cur_altsetting;
VAR_4 = &VAR_3->endpoint[0].desc;
if (!usb_endpoint_is_int_in(VAR_4))
return -VAR_10;
usb_control_msg(VAR_2, usb_sndctrlpipe(VAR_2, 0),
0x0a, VAR_11 | VAR_12,
0, VAR_3->desc.bInterfaceNumber, NULL, 0,
VAR_13);
VAR_5 = kzalloc(sizeof(struct powermate_device), VAR_14);
input_dev = input_allocate_device();
if (!VAR_5 || !input_dev)
goto fail1;
if (powermate_alloc_buffers(VAR_2, VAR_5))
goto fail2;
VAR_5->irq = usb_alloc_urb(0, VAR_14);
if (!VAR_5->irq)
goto fail2;
VAR_5->config = usb_alloc_urb(0, VAR_14);
if (!VAR_5->config)
goto fail3;
VAR_5->udev = VAR_2;
VAR_5->intf = VAR_0;
VAR_5->input = input_dev;
usb_make_path(VAR_2, VAR_5->phys, sizeof(VAR_5->phys));
strlcat(VAR_5->phys, ""/input0"", sizeof(VAR_5->phys));
spin_lock_init(&VAR_5->lock);
switch (le16_to_cpu(VAR_2->descriptor.idProduct)) {
case VAR_15:
input_dev->name = VAR_16;
break;
case VAR_17:
input_dev->name = VAR_18;
break;
default:
input_dev->name = VAR_18;
printk(KERN_WARNING ""powermate: unknown product id %04x\n"",
le16_to_cpu(VAR_2->descriptor.idProduct));
}
input_dev->phys = VAR_5->phys;
usb_to_input_id(VAR_2, &input_dev->id);
input_dev->dev.parent = &VAR_0->dev;
input_set_drvdata(input_dev, VAR_5);
input_dev->event = VAR_19;
input_dev->evbit[0] = BIT_MASK(VAR_20) | BIT_MASK(VAR_21) |
BIT_MASK(VAR_22);
input_dev->keybit[BIT_WORD(VAR_23)] = BIT_MASK(VAR_23);
input_dev->relbit[BIT_WORD(VAR_24)] = BIT_MASK(VAR_24);
input_dev->mscbit[BIT_WORD(VAR_25)] = BIT_MASK(VAR_25);
VAR_6 = usb_rcvintpipe(VAR_2, VAR_4->bEndpointAddress);
VAR_7 = usb_maxpacket(VAR_2, VAR_6, usb_pipeout(VAR_6));
if (VAR_7 < VAR_26 || VAR_7 > VAR_27) {
printk(KERN_WARNING ""powermate: Expected payload of %d--%d bytes, found %d bytes!\n"",
VAR_26, VAR_27, VAR_7);
VAR_7 = VAR_27;
}
usb_fill_int_urb(VAR_5->irq, VAR_2, VAR_6, VAR_5->data,
VAR_7, VAR_28,
VAR_5, VAR_4->bInterval);
VAR_5->irq->transfer_dma = VAR_5->data_dma;
VAR_5->irq->transfer_flags |= VAR_29;
if (usb_submit_urb(VAR_5->irq, VAR_14)) {
VAR_8 = -VAR_10;
goto fail4;
}
VAR_8 = input_register_device(VAR_5->input);
if (VAR_8)
goto fail5;
VAR_5->requires_update = VAR_30 | VAR_31 | VAR_32 | VAR_33;
powermate_pulse_led(VAR_5, 0x80, 255, 0, 1, 0); 
usb_set_intfdata(VAR_0, VAR_5);
return 0;
fail5:usb_kill_urb(VAR_5->irq);
fail4:usb_free_urb(VAR_5->config);
fail3:usb_free_urb(VAR_5->irq);
fail2:powermate_free_buffers(VAR_2, VAR_5);
fail1:input_free_device(input_dev);
kfree(VAR_5);
return VAR_8;
}",torvalds/linux/9c6ba456711687b794dcf285856fc14e2c76074f/powermate.c/vul/before/0.json,"static int powermate_probe(struct usb_interface *intf, const struct usb_device_id *id)
{
	struct usb_device *udev = interface_to_usbdev (intf);
	struct usb_host_interface *interface;
	struct usb_endpoint_descriptor *endpoint;
	struct powermate_device *pm;
	struct input_dev *input_dev;
	int pipe, maxp;
	int error = -ENOMEM;

	interface = intf->cur_altsetting;
	if (interface->desc.bNumEndpoints < 1)
		return -EINVAL;

	endpoint = &interface->endpoint[0].desc;
	if (!usb_endpoint_is_int_in(endpoint))
		return -EIO;

	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
		0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
		0, interface->desc.bInterfaceNumber, NULL, 0,
		USB_CTRL_SET_TIMEOUT);

	pm = kzalloc(sizeof(struct powermate_device), GFP_KERNEL);
	input_dev = input_allocate_device();
	if (!pm || !input_dev)
		goto fail1;

	if (powermate_alloc_buffers(udev, pm))
		goto fail2;

	pm->irq = usb_alloc_urb(0, GFP_KERNEL);
	if (!pm->irq)
		goto fail2;

	pm->config = usb_alloc_urb(0, GFP_KERNEL);
	if (!pm->config)
		goto fail3;

	pm->udev = udev;
	pm->intf = intf;
	pm->input = input_dev;

	usb_make_path(udev, pm->phys, sizeof(pm->phys));
	strlcat(pm->phys, ""/input0"", sizeof(pm->phys));

	spin_lock_init(&pm->lock);

	switch (le16_to_cpu(udev->descriptor.idProduct)) {
	case POWERMATE_PRODUCT_NEW:
		input_dev->name = pm_name_powermate;
		break;
	case POWERMATE_PRODUCT_OLD:
		input_dev->name = pm_name_soundknob;
		break;
	default:
		input_dev->name = pm_name_soundknob;
		printk(KERN_WARNING ""powermate: unknown product id %04x\n"",
		       le16_to_cpu(udev->descriptor.idProduct));
	}

	input_dev->phys = pm->phys;
	usb_to_input_id(udev, &input_dev->id);
	input_dev->dev.parent = &intf->dev;

	input_set_drvdata(input_dev, pm);

	input_dev->event = powermate_input_event;

	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |
		BIT_MASK(EV_MSC);
	input_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
	input_dev->relbit[BIT_WORD(REL_DIAL)] = BIT_MASK(REL_DIAL);
	input_dev->mscbit[BIT_WORD(MSC_PULSELED)] = BIT_MASK(MSC_PULSELED);

	/* get a handle to the interrupt data pipe */
	pipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);
	maxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));

	if (maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX) {
		printk(KERN_WARNING ""powermate: Expected payload of %d--%d bytes, found %d bytes!\n"",
			POWERMATE_PAYLOAD_SIZE_MIN, POWERMATE_PAYLOAD_SIZE_MAX, maxp);
		maxp = POWERMATE_PAYLOAD_SIZE_MAX;
	}

	usb_fill_int_urb(pm->irq, udev, pipe, pm->data,
			 maxp, powermate_irq,
			 pm, endpoint->bInterval);
	pm->irq->transfer_dma = pm->data_dma;
	pm->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;

	/* register our interrupt URB with the USB system */
	if (usb_submit_urb(pm->irq, GFP_KERNEL)) {
		error = -EIO;
		goto fail4;
	}

	error = input_register_device(pm->input);
	if (error)
		goto fail5;


	/* force an update of everything */
	pm->requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS;
	powermate_pulse_led(pm, 0x80, 255, 0, 1, 0); // set default pulse parameters

	usb_set_intfdata(intf, pm);
	return 0;

 fail5:	usb_kill_urb(pm->irq);
 fail4:	usb_free_urb(pm->config);
 fail3:	usb_free_urb(pm->irq);
 fail2:	powermate_free_buffers(udev, pm);
 fail1:	input_free_device(input_dev);
	kfree(pm);
	return error;
}","static int powermate_probe(struct usb_interface *VAR_0, const struct usb_device_id *VAR_1)
{
	struct usb_device *VAR_2 = interface_to_usbdev (VAR_0);
	struct usb_host_interface *VAR_3;
	struct usb_endpoint_descriptor *VAR_4;
	struct powermate_device *VAR_5;
	struct input_dev *input_dev;
	int VAR_6, VAR_7;
	int VAR_8 = -VAR_9;

	VAR_3 = VAR_0->cur_altsetting;
	if (VAR_3->desc.bNumEndpoints < 1)
		return -VAR_10;

	VAR_4 = &VAR_3->endpoint[0].desc;
	if (!usb_endpoint_is_int_in(VAR_4))
		return -VAR_11;

	usb_control_msg(VAR_2, usb_sndctrlpipe(VAR_2, 0),
		0x0a, VAR_12 | VAR_13,
		0, VAR_3->desc.bInterfaceNumber, NULL, 0,
		VAR_14);

	VAR_5 = kzalloc(sizeof(struct powermate_device), VAR_15);
	input_dev = input_allocate_device();
	if (!VAR_5 || !input_dev)
		goto fail1;

	if (powermate_alloc_buffers(VAR_2, VAR_5))
		goto fail2;

	VAR_5->irq = usb_alloc_urb(0, VAR_15);
	if (!VAR_5->irq)
		goto fail2;

	VAR_5->config = usb_alloc_urb(0, VAR_15);
	if (!VAR_5->config)
		goto fail3;

	VAR_5->udev = VAR_2;
	VAR_5->intf = VAR_0;
	VAR_5->input = input_dev;

	usb_make_path(VAR_2, VAR_5->phys, sizeof(VAR_5->phys));
	strlcat(VAR_5->phys, ""/input0"", sizeof(VAR_5->phys));

	spin_lock_init(&VAR_5->lock);

	switch (le16_to_cpu(VAR_2->descriptor.idProduct)) {
	case VAR_16:
		input_dev->name = VAR_17;
		break;
	case VAR_18:
		input_dev->name = VAR_19;
		break;
	default:
		input_dev->name = VAR_19;
		printk(KERN_WARNING ""powermate: unknown product id %04x\n"",
		       le16_to_cpu(VAR_2->descriptor.idProduct));
	}

	input_dev->phys = VAR_5->phys;
	usb_to_input_id(VAR_2, &input_dev->id);
	input_dev->dev.parent = &VAR_0->dev;

	input_set_drvdata(input_dev, VAR_5);

	input_dev->event = VAR_20;

	input_dev->evbit[0] = BIT_MASK(VAR_21) | BIT_MASK(VAR_22) |
		BIT_MASK(VAR_23);
	input_dev->keybit[BIT_WORD(VAR_24)] = BIT_MASK(VAR_24);
	input_dev->relbit[BIT_WORD(VAR_25)] = BIT_MASK(VAR_25);
	input_dev->mscbit[BIT_WORD(VAR_26)] = BIT_MASK(VAR_26);

	/* COMMENT_0 */
	VAR_6 = usb_rcvintpipe(VAR_2, VAR_4->bEndpointAddress);
	VAR_7 = usb_maxpacket(VAR_2, VAR_6, usb_pipeout(VAR_6));

	if (VAR_7 < VAR_27 || VAR_7 > VAR_28) {
		printk(KERN_WARNING ""powermate: Expected payload of %d--%d bytes, found %d bytes!\n"",
			VAR_27, VAR_28, VAR_7);
		VAR_7 = VAR_28;
	}

	usb_fill_int_urb(VAR_5->irq, VAR_2, VAR_6, VAR_5->data,
			 VAR_7, VAR_29,
			 VAR_5, VAR_4->bInterval);
	VAR_5->irq->transfer_dma = VAR_5->data_dma;
	VAR_5->irq->transfer_flags |= VAR_30;

	/* COMMENT_1 */
	if (usb_submit_urb(VAR_5->irq, VAR_15)) {
		VAR_8 = -VAR_11;
		goto fail4;
	}

	VAR_8 = input_register_device(VAR_5->input);
	if (VAR_8)
		goto fail5;


	/* COMMENT_2 */
	VAR_5->requires_update = VAR_31 | VAR_32 | VAR_33 | VAR_34;
	powermate_pulse_led(VAR_5, 0x80, 255, 0, 1, 0); /* COMMENT_3 */

	usb_set_intfdata(VAR_0, VAR_5);
	return 0;

 fail5:	usb_kill_urb(VAR_5->irq);
 fail4:	usb_free_urb(VAR_5->config);
 fail3:	usb_free_urb(VAR_5->irq);
 fail2:	powermate_free_buffers(VAR_2, VAR_5);
 fail1:	input_free_device(input_dev);
	kfree(VAR_5);
	return VAR_8;
}",torvalds/linux/9c6ba456711687b794dcf285856fc14e2c76074f/powermate.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,9 @@
 	int error = -ENOMEM;
 
 	interface = intf->cur_altsetting;
+	if (interface->desc.bNumEndpoints < 1)
+		return -EINVAL;
+
 	endpoint = &interface->endpoint[0].desc;
 	if (!usb_endpoint_is_int_in(endpoint))
 		return -EIO;","{'deleted_lines': [], 'added_lines': ['\tif (interface->desc.bNumEndpoints < 1)', '\t\treturn -EINVAL;', '']}",True,The powermate_probe function in drivers/input/misc/powermate.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.,4.6,MEDIUM,1,valid,2016-03-14T16:33:40Z,1
CVE-2016-4081,['CWE-284'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"IAX2: fix an infinite loop

Bug: 12260
Change-Id: I29b23ff2d862027fd44c6dd4de3cbb304664fd05
Reviewed-on: https://code.wireshark.org/review/14473
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",42f299be6abb302f32cec78b1c0812364c9f9285,https://github.com/wireshark/wireshark/commit/42f299be6abb302f32cec78b1c0812364c9f9285,epan/dissectors/packet-iax2.c,iax2_add_ts_fields,"static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)
{
guint32     longts =shortts;
nstime_t    ts;
proto_item *item;
if (iax_packet->call_data == NULL) {
return;
}
if (iax_packet->abstime.secs == -1) {
time_t start_secs = iax_packet->call_data->start_time.secs;
gint32 abs_secs = (gint32)(start_secs + longts/1000);
while(abs_secs < pinfo->abs_ts.secs - 16) {
longts += 32768;
abs_secs = (gint32)(start_secs + longts/1000);
}
iax_packet->abstime.secs=abs_secs;
iax_packet->abstime.nsecs=iax_packet->call_data->start_time.nsecs + (longts % 1000) * 1000000;
if (iax_packet->abstime.nsecs >= 1000000000) {
iax_packet->abstime.nsecs -= 1000000000;
iax_packet->abstime.secs ++;
}
}
iax2_info->timestamp = longts;
if (iax2_tree) {
item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);
PROTO_ITEM_SET_GENERATED(item);
ts  = pinfo->abs_ts;
nstime_delta(&ts, &ts, &iax_packet->abstime);
item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);
PROTO_ITEM_SET_GENERATED(item);
}
}","static void iax2_add_ts_fields(packet_info *VAR_0, proto_tree *VAR_1, iax_packet_data *VAR_2, guint16 VAR_3)
{
guint32     VAR_4 =VAR_3;
nstime_t    VAR_5;
proto_item *VAR_6;
if (VAR_2->call_data == NULL) {
return;
}
if (VAR_2->abstime.secs == -1) {
time_t VAR_7 = VAR_2->call_data->start_time.secs;
gint32 VAR_8 = (gint32)(VAR_7 + VAR_4/1000);
while(VAR_8 < VAR_0->abs_ts.secs - 16) {
VAR_4 += 32768;
VAR_8 = (gint32)(VAR_7 + VAR_4/1000);
}
VAR_2->abstime.secs=VAR_8;
VAR_2->abstime.nsecs=VAR_2->call_data->start_time.nsecs + (VAR_4 % 1000) * 1000000;
if (VAR_2->abstime.nsecs >= 1000000000) {
VAR_2->abstime.nsecs -= 1000000000;
VAR_2->abstime.secs ++;
}
}
VAR_9->timestamp = VAR_4;
if (VAR_1) {
VAR_6 = proto_tree_add_time(VAR_1, VAR_10, NULL, 0, 0, &VAR_2->abstime);
PROTO_ITEM_SET_GENERATED(VAR_6);
VAR_5  = VAR_0->abs_ts;
nstime_delta(&VAR_5, &VAR_5, &VAR_2->abstime);
VAR_6 = proto_tree_add_time(VAR_1, VAR_11, NULL, 0, 0, &VAR_5);
PROTO_ITEM_SET_GENERATED(VAR_6);
}
}",wireshark/42f299be6abb302f32cec78b1c0812364c9f9285/packet-iax2.c/vul/before/0.json,"static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)
{
  guint32     longts =shortts;
  nstime_t    ts;
  proto_item *item;

  if (iax_packet->call_data == NULL) {
    /* no call info for this frame; perhaps we missed the NEW packet */
    return;
  }

  if (iax_packet->abstime.secs == -1) {
    time_t start_secs = iax_packet->call_data->start_time.secs;
    time_t abs_secs = start_secs + longts/1000;

    /* deal with short timestamps by assuming that packets are never more than
     * 16 seconds late */
    while(abs_secs < pinfo->abs_ts.secs - 16) {
      longts += 32768;
      abs_secs = start_secs + longts/1000;
    }

    iax_packet->abstime.secs=abs_secs;
    iax_packet->abstime.nsecs=iax_packet->call_data->start_time.nsecs + (longts % 1000) * 1000000;
    if (iax_packet->abstime.nsecs >= 1000000000) {
      iax_packet->abstime.nsecs -= 1000000000;
      iax_packet->abstime.secs ++;
    }
  }
  iax2_info->timestamp = longts;

  if (iax2_tree) {
    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);
    PROTO_ITEM_SET_GENERATED(item);

    ts  = pinfo->abs_ts;
    nstime_delta(&ts, &ts, &iax_packet->abstime);

    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);
    PROTO_ITEM_SET_GENERATED(item);
  }
}","static void iax2_add_ts_fields(packet_info *VAR_0, proto_tree *VAR_1, iax_packet_data *VAR_2, guint16 VAR_3)
{
  guint32     VAR_4 =VAR_3;
  nstime_t    VAR_5;
  proto_item *VAR_6;

  if (VAR_2->call_data == NULL) {
    /* COMMENT_0 */
    return;
  }

  if (VAR_2->abstime.secs == -1) {
    time_t VAR_7 = VAR_2->call_data->start_time.secs;
    time_t VAR_8 = VAR_7 + VAR_4/1000;

    /* COMMENT_1 */
                         
    while(VAR_8 < VAR_0->abs_ts.secs - 16) {
      VAR_4 += 32768;
      VAR_8 = VAR_7 + VAR_4/1000;
    }

    VAR_2->abstime.secs=VAR_8;
    VAR_2->abstime.nsecs=VAR_2->call_data->start_time.nsecs + (VAR_4 % 1000) * 1000000;
    if (VAR_2->abstime.nsecs >= 1000000000) {
      VAR_2->abstime.nsecs -= 1000000000;
      VAR_2->abstime.secs ++;
    }
  }
  VAR_9->timestamp = VAR_4;

  if (VAR_1) {
    VAR_6 = proto_tree_add_time(VAR_1, VAR_10, NULL, 0, 0, &VAR_2->abstime);
    PROTO_ITEM_SET_GENERATED(VAR_6);

    VAR_5  = VAR_0->abs_ts;
    nstime_delta(&VAR_5, &VAR_5, &VAR_2->abstime);

    VAR_6 = proto_tree_add_time(VAR_1, VAR_11, NULL, 0, 0, &VAR_5);
    PROTO_ITEM_SET_GENERATED(VAR_6);
  }
}",wireshark/42f299be6abb302f32cec78b1c0812364c9f9285/packet-iax2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,13 +11,13 @@
 
   if (iax_packet->abstime.secs == -1) {
     time_t start_secs = iax_packet->call_data->start_time.secs;
-    gint32 abs_secs = (gint32)(start_secs + longts/1000);
+    time_t abs_secs = start_secs + longts/1000;
 
     /* deal with short timestamps by assuming that packets are never more than
      * 16 seconds late */
     while(abs_secs < pinfo->abs_ts.secs - 16) {
       longts += 32768;
-      abs_secs = (gint32)(start_secs + longts/1000);
+      abs_secs = start_secs + longts/1000;
     }
 
     iax_packet->abstime.secs=abs_secs;","{'deleted_lines': ['    gint32 abs_secs = (gint32)(start_secs + longts/1000);', '      abs_secs = (gint32)(start_secs + longts/1000);'], 'added_lines': ['    time_t abs_secs = start_secs + longts/1000;', '      abs_secs = start_secs + longts/1000;']}",True,"epan/dissectors/packet-iax2.c in the IAX2 dissector in Wireshark 1.12.x before 1.12.11 and 2.0.x before 2.0.3 uses an incorrect integer data type, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet.",5.9,MEDIUM,1,valid,2016-03-14T22:35:56Z,1
CVE-2016-4079,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"PKTC must be stricter with its Kerberos application choices.

The PKTC dissector calls the Kerberos dissector assuming certain application values.  Because different application values can have different ""private"" data, corruption can occur.
Ensure the Kerberos application values match the preceding comments by checking the ber identifier before calling the Kerberos dissector.

Bug: 12206
Change-Id: I9b04837f93a56681cae3816278315cf01da17544
Reviewed-on: https://code.wireshark.org/review/14520
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>",4cdc9eeba58f866bd5f273e9c5b3876857a7a4bf,https://github.com/wireshark/wireshark/commit/4cdc9eeba58f866bd5f273e9c5b3876857a7a4bf,epan/dissectors/packet-pktc.c,proto_register_pktc_mtafqdn,"void
proto_register_pktc_mtafqdn(void)
{
static hf_register_info hf[] = {
{ &hf_pktc_mtafqdn_msgtype, {
""Message Type"", ""pktc.mtafqdn.msgtype"", FT_UINT8, BASE_DEC,
VALS(pktc_mtafqdn_msgtype_vals), 0, ""MTA FQDN Message Type"", HFILL }},
{ &hf_pktc_mtafqdn_enterprise, {
""Enterprise Number"", ""pktc.mtafqdn.enterprise"", FT_UINT32, BASE_DEC,
NULL, 0, NULL, HFILL }},
{ &hf_pktc_mtafqdn_version, {
""Protocol Version"", ""pktc.mtafqdn.version"", FT_UINT8, BASE_DEC,
NULL, 0, ""MTA FQDN Protocol Version"", HFILL }},
{ &hf_pktc_mtafqdn_mac, {
""MTA MAC address"", ""pktc.mtafqdn.mac"", FT_ETHER, BASE_NONE,
NULL, 0, NULL, HFILL }},
{ &hf_pktc_mtafqdn_pub_key_hash, {
""MTA Public Key Hash"", ""pktc.mtafqdn.pub_key_hash"", FT_BYTES, BASE_NONE,
NULL, 0, ""MTA Public Key Hash (SHA-1)"", HFILL }},
{ &hf_pktc_mtafqdn_manu_cert_revoked, {
""Manufacturer Cert Revocation Time"", ""pktc.mtafqdn.manu_cert_revoked"", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,
NULL, 0, ""Manufacturer Cert Revocation Time (UTC) or 0 if not revoked"", HFILL }},
{ &hf_pktc_mtafqdn_fqdn, {
""MTA FQDN"", ""pktc.mtafqdn.fqdn"", FT_STRING, BASE_NONE,
NULL, 0, NULL, HFILL }},
{ &hf_pktc_mtafqdn_ip, {
""MTA IP Address"", ""pktc.mtafqdn.ip"", FT_IPv4, BASE_NONE,
NULL, 0, ""MTA IP Address (all zeros if not supplied)"", HFILL }},
};
static gint *ett[] = {
&ett_pktc_mtafqdn,
};
static ei_register_info ei[] = {
{ &ei_pktc_unknown_kmmid, { ""pktc.mtafqdn.unknown_kmmid"", PI_PROTOCOL, PI_WARN, ""Unknown KMMID"", EXPFILL }},
{ &ei_pktc_unknown_doi, { ""pktc.mtafqdn.unknown_doi"", PI_PROTOCOL, PI_WARN, ""Unknown DOI"", EXPFILL }},
};
expert_module_t* expert_pktc;
proto_pktc_mtafqdn = proto_register_protocol(""PacketCable MTA FQDN"", ""PKTC MTA FQDN"", ""pktc.mtafqdn"");
proto_register_field_array(proto_pktc_mtafqdn, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
expert_pktc = expert_register_protocol(proto_pktc_mtafqdn);
expert_register_field_array(expert_pktc, ei, array_length(ei));
}","void
proto_register_pktc_mtafqdn(void)
{
static hf_register_info VAR_0[] = {
{ &VAR_1, {
""Message Type"", ""pktc.mtafqdn.msgtype"", VAR_2, VAR_3,
VALS(VAR_4), 0, ""MTA FQDN Message Type"", VAR_5 }},
{ &VAR_6, {
""Enterprise Number"", ""pktc.mtafqdn.enterprise"", VAR_7, VAR_3,
NULL, 0, NULL, VAR_5 }},
{ &VAR_8, {
""Protocol Version"", ""pktc.mtafqdn.version"", VAR_2, VAR_3,
NULL, 0, ""MTA FQDN Protocol Version"", VAR_5 }},
{ &VAR_9, {
""MTA MAC address"", ""pktc.mtafqdn.mac"", VAR_10, VAR_11,
NULL, 0, NULL, VAR_5 }},
{ &VAR_12, {
""MTA Public Key Hash"", ""pktc.mtafqdn.pub_key_hash"", VAR_13, VAR_11,
NULL, 0, ""MTA Public Key Hash (SHA-1)"", VAR_5 }},
{ &VAR_14, {
""Manufacturer Cert Revocation Time"", ""pktc.mtafqdn.manu_cert_revoked"", VAR_15, VAR_16,
NULL, 0, ""Manufacturer Cert Revocation Time (UTC) or 0 if not revoked"", VAR_5 }},
{ &VAR_17, {
""MTA FQDN"", ""pktc.mtafqdn.fqdn"", VAR_18, VAR_11,
NULL, 0, NULL, VAR_5 }},
{ &VAR_19, {
""MTA IP Address"", ""pktc.mtafqdn.ip"", VAR_20, VAR_11,
NULL, 0, ""MTA IP Address (all zeros if not supplied)"", VAR_5 }},
};
static gint *VAR_21[] = {
&VAR_22,
};
static ei_register_info VAR_23[] = {
{ &VAR_24, { ""pktc.mtafqdn.unknown_kmmid"", VAR_25, VAR_26, ""Unknown KMMID"", VAR_27 }},
{ &VAR_28, { ""pktc.mtafqdn.unknown_doi"", VAR_25, VAR_26, ""Unknown DOI"", VAR_27 }},
};
expert_module_t* VAR_29;
VAR_30 = proto_register_protocol(""PacketCable MTA FQDN"", ""PKTC MTA FQDN"", ""pktc.mtafqdn"");
proto_register_field_array(VAR_30, VAR_0, array_length(VAR_0));
proto_register_subtree_array(VAR_21, array_length(VAR_21));
VAR_29 = expert_register_protocol(VAR_30);
expert_register_field_array(VAR_29, VAR_23, array_length(VAR_23));
}",wireshark/4cdc9eeba58f866bd5f273e9c5b3876857a7a4bf/packet-pktc.c/vul/before/0.json,"void
proto_register_pktc_mtafqdn(void)
{
    static hf_register_info hf[] = {
       { &hf_pktc_mtafqdn_msgtype, {
           ""Message Type"", ""pktc.mtafqdn.msgtype"", FT_UINT8, BASE_DEC,
           VALS(pktc_mtafqdn_msgtype_vals), 0, ""MTA FQDN Message Type"", HFILL }},
       { &hf_pktc_mtafqdn_enterprise, {
           ""Enterprise Number"", ""pktc.mtafqdn.enterprise"", FT_UINT32, BASE_DEC,
           NULL, 0, NULL, HFILL }},
       { &hf_pktc_mtafqdn_version, {
           ""Protocol Version"", ""pktc.mtafqdn.version"", FT_UINT8, BASE_DEC,
           NULL, 0, ""MTA FQDN Protocol Version"", HFILL }},
       /* MTA FQDN REQ */
       { &hf_pktc_mtafqdn_mac, {
           ""MTA MAC address"", ""pktc.mtafqdn.mac"", FT_ETHER, BASE_NONE,
           NULL, 0, NULL, HFILL }},
       { &hf_pktc_mtafqdn_pub_key_hash, {
           ""MTA Public Key Hash"", ""pktc.mtafqdn.pub_key_hash"", FT_BYTES, BASE_NONE,
           NULL, 0, ""MTA Public Key Hash (SHA-1)"", HFILL }},
       { &hf_pktc_mtafqdn_manu_cert_revoked, {
           ""Manufacturer Cert Revocation Time"", ""pktc.mtafqdn.manu_cert_revoked"", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,
           NULL, 0, ""Manufacturer Cert Revocation Time (UTC) or 0 if not revoked"", HFILL }},
       /* MTA FQDN REP */
       { &hf_pktc_mtafqdn_fqdn, {
           ""MTA FQDN"", ""pktc.mtafqdn.fqdn"", FT_STRING, BASE_NONE,
           NULL, 0, NULL, HFILL }},
       { &hf_pktc_mtafqdn_ip, {
           ""MTA IP Address"", ""pktc.mtafqdn.ip"", FT_IPv4, BASE_NONE,
           NULL, 0, ""MTA IP Address (all zeros if not supplied)"", HFILL }},
    };
    static gint *ett[] = {
        &ett_pktc_mtafqdn,
    };

    static ei_register_info ei[] = {
        { &ei_pktc_unknown_kmmid, { ""pktc.mtafqdn.unknown_kmmid"", PI_PROTOCOL, PI_WARN, ""Unknown KMMID"", EXPFILL }},
        { &ei_pktc_unknown_doi, { ""pktc.mtafqdn.unknown_doi"", PI_PROTOCOL, PI_WARN, ""Unknown DOI"", EXPFILL }},
        { &ei_pktc_unknown_kerberos_application, { ""pktc.mtafqdn.unknown_kerberos_application"", PI_PROTOCOL, PI_WARN, ""Unknown Kerberos application"", EXPFILL }},
    };

    expert_module_t* expert_pktc;

    proto_pktc_mtafqdn = proto_register_protocol(""PacketCable MTA FQDN"", ""PKTC MTA FQDN"", ""pktc.mtafqdn"");

    proto_register_field_array(proto_pktc_mtafqdn, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));
    expert_pktc = expert_register_protocol(proto_pktc_mtafqdn);
    expert_register_field_array(expert_pktc, ei, array_length(ei));
}","void
proto_register_pktc_mtafqdn(void)
{
    static hf_register_info VAR_0[] = {
       { &VAR_1, {
           ""Message Type"", ""pktc.mtafqdn.msgtype"", VAR_2, VAR_3,
           VALS(VAR_4), 0, ""MTA FQDN Message Type"", VAR_5 }},
       { &VAR_6, {
           ""Enterprise Number"", ""pktc.mtafqdn.enterprise"", VAR_7, VAR_3,
           NULL, 0, NULL, VAR_5 }},
       { &VAR_8, {
           ""Protocol Version"", ""pktc.mtafqdn.version"", VAR_2, VAR_3,
           NULL, 0, ""MTA FQDN Protocol Version"", VAR_5 }},
       /* COMMENT_0 */
       { &VAR_9, {
           ""MTA MAC address"", ""pktc.mtafqdn.mac"", VAR_10, VAR_11,
           NULL, 0, NULL, VAR_5 }},
       { &VAR_12, {
           ""MTA Public Key Hash"", ""pktc.mtafqdn.pub_key_hash"", VAR_13, VAR_11,
           NULL, 0, ""MTA Public Key Hash (SHA-1)"", VAR_5 }},
       { &VAR_14, {
           ""Manufacturer Cert Revocation Time"", ""pktc.mtafqdn.manu_cert_revoked"", VAR_15, VAR_16,
           NULL, 0, ""Manufacturer Cert Revocation Time (UTC) or 0 if not revoked"", VAR_5 }},
       /* COMMENT_1 */
       { &VAR_17, {
           ""MTA FQDN"", ""pktc.mtafqdn.fqdn"", VAR_18, VAR_11,
           NULL, 0, NULL, VAR_5 }},
       { &VAR_19, {
           ""MTA IP Address"", ""pktc.mtafqdn.ip"", VAR_20, VAR_11,
           NULL, 0, ""MTA IP Address (all zeros if not supplied)"", VAR_5 }},
    };
    static gint *VAR_21[] = {
        &VAR_22,
    };

    static ei_register_info VAR_23[] = {
        { &VAR_24, { ""pktc.mtafqdn.unknown_kmmid"", VAR_25, VAR_26, ""Unknown KMMID"", VAR_27 }},
        { &VAR_28, { ""pktc.mtafqdn.unknown_doi"", VAR_25, VAR_26, ""Unknown DOI"", VAR_27 }},
        { &VAR_29, { ""pktc.mtafqdn.unknown_kerberos_application"", VAR_25, VAR_26, ""Unknown Kerberos application"", VAR_27 }},
    };

    expert_module_t* VAR_30;

    VAR_31 = proto_register_protocol(""PacketCable MTA FQDN"", ""PKTC MTA FQDN"", ""pktc.mtafqdn"");

    proto_register_field_array(VAR_31, VAR_0, array_length(VAR_0));
    proto_register_subtree_array(VAR_21, array_length(VAR_21));
    VAR_30 = expert_register_protocol(VAR_31);
    expert_register_field_array(VAR_30, VAR_23, array_length(VAR_23));
}",wireshark/4cdc9eeba58f866bd5f273e9c5b3876857a7a4bf/packet-pktc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,6 +36,7 @@
     static ei_register_info ei[] = {
         { &ei_pktc_unknown_kmmid, { ""pktc.mtafqdn.unknown_kmmid"", PI_PROTOCOL, PI_WARN, ""Unknown KMMID"", EXPFILL }},
         { &ei_pktc_unknown_doi, { ""pktc.mtafqdn.unknown_doi"", PI_PROTOCOL, PI_WARN, ""Unknown DOI"", EXPFILL }},
+        { &ei_pktc_unknown_kerberos_application, { ""pktc.mtafqdn.unknown_kerberos_application"", PI_PROTOCOL, PI_WARN, ""Unknown Kerberos application"", EXPFILL }},
     };
 
     expert_module_t* expert_pktc;","{'deleted_lines': [], 'added_lines': ['        { &ei_pktc_unknown_kerberos_application, { ""pktc.mtafqdn.unknown_kerberos_application"", PI_PROTOCOL, PI_WARN, ""Unknown Kerberos application"", EXPFILL }},']}",True,"epan/dissectors/packet-pktc.c in the PKTC dissector in Wireshark 1.12.x before 1.12.11 and 2.0.x before 2.0.3 does not verify BER identifiers, which allows remote attackers to cause a denial of service (out-of-bounds write and application crash) via a crafted packet.",5.9,MEDIUM,1,valid,2016-03-19T01:06:51Z,1
CVE-2016-4079,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"PKTC must be stricter with its Kerberos application choices.

The PKTC dissector calls the Kerberos dissector assuming certain application values.  Because different application values can have different ""private"" data, corruption can occur.
Ensure the Kerberos application values match the preceding comments by checking the ber identifier before calling the Kerberos dissector.

Bug: 12206
Change-Id: I9b04837f93a56681cae3816278315cf01da17544
Reviewed-on: https://code.wireshark.org/review/14520
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>",4cdc9eeba58f866bd5f273e9c5b3876857a7a4bf,https://github.com/wireshark/wireshark/commit/4cdc9eeba58f866bd5f273e9c5b3876857a7a4bf,epan/dissectors/packet-pktc.c,dissect_pktc_mtafqdn,"static int
dissect_pktc_mtafqdn(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
int offset=0;
proto_tree *pktc_mtafqdn_tree;
proto_item *item;
tvbuff_t *pktc_mtafqdn_tvb;
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PKTC"");
item = proto_tree_add_item(tree, proto_pktc, tvb, 0, 0, ENC_NA);
pktc_mtafqdn_tree = proto_item_add_subtree(item, ett_pktc_mtafqdn);
col_add_fstr(pinfo->cinfo, COL_INFO, ""MTA FQDN %s"",
pinfo->srcport == pinfo->match_uint ? ""Reply"":""Request"");
pktc_mtafqdn_tvb = tvb_new_subset_remaining(tvb, offset);
offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, NULL);
pktc_mtafqdn_tvb = tvb_new_subset_remaining(tvb, offset);
offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, cb);
proto_item_set_len(item, offset);
return tvb_captured_length(tvb);
}","static int
dissect_pktc_mtafqdn(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void* VAR_3 _U_)
{
int VAR_4=0;
proto_tree *VAR_5;
proto_item *VAR_6;
tvbuff_t *VAR_7;
col_set_str(VAR_1->cinfo, VAR_8, ""PKTC"");
VAR_6 = proto_tree_add_item(VAR_2, VAR_9, VAR_0, 0, 0, VAR_10);
VAR_5 = proto_item_add_subtree(VAR_6, VAR_11);
col_add_fstr(VAR_1->cinfo, VAR_12, ""MTA FQDN %s"",
VAR_1->srcport == VAR_1->match_uint ? ""Reply"":""Request"");
VAR_7 = tvb_new_subset_remaining(VAR_0, VAR_4);
VAR_4 += dissect_kerberos_main(VAR_7, VAR_1, VAR_5, FALSE, NULL);
VAR_7 = tvb_new_subset_remaining(VAR_0, VAR_4);
VAR_4 += dissect_kerberos_main(VAR_7, VAR_1, VAR_5, FALSE, VAR_13);
proto_item_set_len(VAR_6, VAR_4);
return tvb_captured_length(VAR_0);
}",,"static int
dissect_pktc_mtafqdn(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    int offset=0;
    proto_tree *pktc_mtafqdn_tree;
    proto_item *item;
    tvbuff_t *pktc_mtafqdn_tvb;
    gint8              ber_class;
    gboolean           pc;
    gint32             tag;

    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PKTC"");

    item = proto_tree_add_item(tree, proto_pktc, tvb, 0, 0, ENC_NA);
    pktc_mtafqdn_tree = proto_item_add_subtree(item, ett_pktc_mtafqdn);

    col_add_fstr(pinfo->cinfo, COL_INFO, ""MTA FQDN %s"",
                    pinfo->srcport == pinfo->match_uint ? ""Reply"":""Request"");

    /* KRB_AP_RE[QP] */
    pktc_mtafqdn_tvb = tvb_new_subset_remaining(tvb, offset);
    get_ber_identifier(pktc_mtafqdn_tvb, 0, &ber_class, &pc, &tag);
    if ((tag == 10) || (tag == 11)) {
        offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, NULL);
    } else {
        expert_add_info_format(pinfo, item, &ei_pktc_unknown_kerberos_application, ""Unknown Kerberos application (%d), expected 10 or 11"", tag);
        return tvb_captured_length(tvb);
    }

    /* KRB_SAFE */
    pktc_mtafqdn_tvb = tvb_new_subset_remaining(tvb, offset);
    get_ber_identifier(pktc_mtafqdn_tvb, 0, &ber_class, &pc, &tag);
    if (tag == 20) {
        offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, cb);
    } else {
        expert_add_info_format(pinfo, item, &ei_pktc_unknown_kerberos_application, ""Unknown Kerberos application (%d), expected 20"", tag);
    }

    proto_item_set_len(item, offset);
    return tvb_captured_length(tvb);
}","static int
dissect_pktc_mtafqdn(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void* VAR_3 _U_)
{
    int VAR_4=0;
    proto_tree *VAR_5;
    proto_item *VAR_6;
    tvbuff_t *VAR_7;
    gint8              VAR_8;
    gboolean           VAR_9;
    gint32             VAR_10;

    col_set_str(VAR_1->cinfo, VAR_11, ""PKTC"");

    VAR_6 = proto_tree_add_item(VAR_2, VAR_12, VAR_0, 0, 0, VAR_13);
    VAR_5 = proto_item_add_subtree(VAR_6, VAR_14);

    col_add_fstr(VAR_1->cinfo, VAR_15, ""MTA FQDN %s"",
                    VAR_1->srcport == VAR_1->match_uint ? ""Reply"":""Request"");

    /* COMMENT_0 */
    VAR_7 = tvb_new_subset_remaining(VAR_0, VAR_4);
    get_ber_identifier(VAR_7, 0, &VAR_8, &VAR_9, &VAR_10);
    if ((VAR_10 == 10) || (VAR_10 == 11)) {
        VAR_4 += dissect_kerberos_main(VAR_7, VAR_1, VAR_5, FALSE, NULL);
    } else {
        expert_add_info_format(VAR_1, VAR_6, &VAR_16, ""Unknown Kerberos application (%d), expected 10 or 11"", VAR_10);
        return tvb_captured_length(VAR_0);
    }

    /* COMMENT_1 */
    VAR_7 = tvb_new_subset_remaining(VAR_0, VAR_4);
    get_ber_identifier(VAR_7, 0, &VAR_8, &VAR_9, &VAR_10);
    if (VAR_10 == 20) {
        VAR_4 += dissect_kerberos_main(VAR_7, VAR_1, VAR_5, FALSE, VAR_17);
    } else {
        expert_add_info_format(VAR_1, VAR_6, &VAR_16, ""Unknown Kerberos application (%d), expected 20"", VAR_10);
    }

    proto_item_set_len(VAR_6, VAR_4);
    return tvb_captured_length(VAR_0);
}",,"--- func_before
+++ func_after
@@ -5,6 +5,9 @@
     proto_tree *pktc_mtafqdn_tree;
     proto_item *item;
     tvbuff_t *pktc_mtafqdn_tvb;
+    gint8              ber_class;
+    gboolean           pc;
+    gint32             tag;
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PKTC"");
 
@@ -16,11 +19,22 @@
 
     /* KRB_AP_RE[QP] */
     pktc_mtafqdn_tvb = tvb_new_subset_remaining(tvb, offset);
-    offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, NULL);
+    get_ber_identifier(pktc_mtafqdn_tvb, 0, &ber_class, &pc, &tag);
+    if ((tag == 10) || (tag == 11)) {
+        offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, NULL);
+    } else {
+        expert_add_info_format(pinfo, item, &ei_pktc_unknown_kerberos_application, ""Unknown Kerberos application (%d), expected 10 or 11"", tag);
+        return tvb_captured_length(tvb);
+    }
 
     /* KRB_SAFE */
     pktc_mtafqdn_tvb = tvb_new_subset_remaining(tvb, offset);
-    offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, cb);
+    get_ber_identifier(pktc_mtafqdn_tvb, 0, &ber_class, &pc, &tag);
+    if (tag == 20) {
+        offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, cb);
+    } else {
+        expert_add_info_format(pinfo, item, &ei_pktc_unknown_kerberos_application, ""Unknown Kerberos application (%d), expected 20"", tag);
+    }
 
     proto_item_set_len(item, offset);
     return tvb_captured_length(tvb);","{'deleted_lines': ['    offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, NULL);', '    offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, cb);'], 'added_lines': ['    gint8              ber_class;', '    gboolean           pc;', '    gint32             tag;', '    get_ber_identifier(pktc_mtafqdn_tvb, 0, &ber_class, &pc, &tag);', '    if ((tag == 10) || (tag == 11)) {', '        offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, NULL);', '    } else {', '        expert_add_info_format(pinfo, item, &ei_pktc_unknown_kerberos_application, ""Unknown Kerberos application (%d), expected 10 or 11"", tag);', '        return tvb_captured_length(tvb);', '    }', '    get_ber_identifier(pktc_mtafqdn_tvb, 0, &ber_class, &pc, &tag);', '    if (tag == 20) {', '        offset += dissect_kerberos_main(pktc_mtafqdn_tvb, pinfo, pktc_mtafqdn_tree, FALSE, cb);', '    } else {', '        expert_add_info_format(pinfo, item, &ei_pktc_unknown_kerberos_application, ""Unknown Kerberos application (%d), expected 20"", tag);', '    }']}",True,"epan/dissectors/packet-pktc.c in the PKTC dissector in Wireshark 1.12.x before 1.12.11 and 2.0.x before 2.0.3 does not verify BER identifiers, which allows remote attackers to cause a denial of service (out-of-bounds write and application crash) via a crafted packet.",5.9,MEDIUM,1,valid,2016-03-19T01:06:51Z,1
CVE-2016-2185,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Input: ati_remote2 - fix crashes on detecting device with invalid descriptor

The ati_remote2 driver expects at least two interfaces with one
endpoint each. If given malicious descriptor that specify one
interface or no endpoints, it will crash in the probe function.
Ensure there is at least two interfaces and one endpoint for each
interface before using it.

The full disclosure: http://seclists.org/bugtraq/2016/Mar/90

Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
Signed-off-by: Vladis Dronov <vdronov@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d,https://github.com/torvalds/linux/commit/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d,drivers/input/misc/ati_remote2.c,ati_remote2_probe,"static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)
{
struct usb_device *udev = interface_to_usbdev(interface);
struct usb_host_interface *alt = interface->cur_altsetting;
struct ati_remote2 *ar2;
int r;
if (alt->desc.bInterfaceNumber)
return -ENODEV;
ar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);
if (!ar2)
return -ENOMEM;
ar2->udev = udev;
ar2->intf[0] = interface;
ar2->ep[0] = &alt->endpoint[0].desc;
ar2->intf[1] = usb_ifnum_to_if(udev, 1);
r = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);
if (r)
goto fail1;
alt = ar2->intf[1]->cur_altsetting;
ar2->ep[1] = &alt->endpoint[0].desc;
r = ati_remote2_urb_init(ar2);
if (r)
goto fail2;
ar2->channel_mask = channel_mask;
ar2->mode_mask = mode_mask;
r = ati_remote2_setup(ar2, ar2->channel_mask);
if (r)
goto fail2;
usb_make_path(udev, ar2->phys, sizeof(ar2->phys));
strlcat(ar2->phys, ""/input0"", sizeof(ar2->phys));
strlcat(ar2->name, ""ATI Remote Wonder II"", sizeof(ar2->name));
r = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);
if (r)
goto fail2;
r = ati_remote2_input_init(ar2);
if (r)
goto fail3;
usb_set_intfdata(interface, ar2);
interface->needs_remote_wakeup = 1;
return 0;
fail3:
sysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);
fail2:
ati_remote2_urb_cleanup(ar2);
usb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);
fail1:
kfree(ar2);
return r;
}","static int ati_remote2_probe(struct usb_interface *VAR_0, const struct usb_device_id *VAR_1)
{
struct usb_device *VAR_2 = interface_to_usbdev(VAR_0);
struct usb_host_interface *VAR_3 = VAR_0->cur_altsetting;
struct ati_remote2 *VAR_4;
int VAR_5;
if (VAR_3->desc.bInterfaceNumber)
return -VAR_6;
VAR_4 = kzalloc(sizeof (struct ati_remote2), VAR_7);
if (!VAR_4)
return -VAR_8;
VAR_4->udev = VAR_2;
VAR_4->intf[0] = VAR_0;
VAR_4->ep[0] = &VAR_3->endpoint[0].desc;
VAR_4->intf[1] = usb_ifnum_to_if(VAR_2, 1);
VAR_5 = usb_driver_claim_interface(&VAR_9, VAR_4->intf[1], VAR_4);
if (VAR_5)
goto fail1;
VAR_3 = VAR_4->intf[1]->cur_altsetting;
VAR_4->ep[1] = &VAR_3->endpoint[0].desc;
VAR_5 = ati_remote2_urb_init(VAR_4);
if (VAR_5)
goto fail2;
VAR_4->channel_mask = VAR_10;
VAR_4->mode_mask = VAR_11;
VAR_5 = ati_remote2_setup(VAR_4, VAR_4->channel_mask);
if (VAR_5)
goto fail2;
usb_make_path(VAR_2, VAR_4->phys, sizeof(VAR_4->phys));
strlcat(VAR_4->phys, ""/input0"", sizeof(VAR_4->phys));
strlcat(VAR_4->name, ""ATI Remote Wonder II"", sizeof(VAR_4->name));
VAR_5 = sysfs_create_group(&VAR_2->dev.kobj, &VAR_12);
if (VAR_5)
goto fail2;
VAR_5 = ati_remote2_input_init(VAR_4);
if (VAR_5)
goto fail3;
usb_set_intfdata(VAR_0, VAR_4);
VAR_0->needs_remote_wakeup = 1;
return 0;
fail3:
sysfs_remove_group(&VAR_2->dev.kobj, &VAR_12);
fail2:
ati_remote2_urb_cleanup(VAR_4);
usb_driver_release_interface(&VAR_9, VAR_4->intf[1]);
fail1:
kfree(VAR_4);
return VAR_5;
}",torvalds/linux/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d/ati_remote2.c/vul/before/0.json,"static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)
{
	struct usb_device *udev = interface_to_usbdev(interface);
	struct usb_host_interface *alt = interface->cur_altsetting;
	struct ati_remote2 *ar2;
	int r;

	if (alt->desc.bInterfaceNumber)
		return -ENODEV;

	ar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);
	if (!ar2)
		return -ENOMEM;

	ar2->udev = udev;

	/* Sanity check, first interface must have an endpoint */
	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
		dev_err(&interface->dev,
			""%s(): interface 0 must have an endpoint\n"", __func__);
		r = -ENODEV;
		goto fail1;
	}
	ar2->intf[0] = interface;
	ar2->ep[0] = &alt->endpoint[0].desc;

	/* Sanity check, the device must have two interfaces */
	ar2->intf[1] = usb_ifnum_to_if(udev, 1);
	if ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {
		dev_err(&interface->dev, ""%s(): need 2 interfaces, found %d\n"",
			__func__, udev->actconfig->desc.bNumInterfaces);
		r = -ENODEV;
		goto fail1;
	}

	r = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);
	if (r)
		goto fail1;

	/* Sanity check, second interface must have an endpoint */
	alt = ar2->intf[1]->cur_altsetting;
	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
		dev_err(&interface->dev,
			""%s(): interface 1 must have an endpoint\n"", __func__);
		r = -ENODEV;
		goto fail2;
	}
	ar2->ep[1] = &alt->endpoint[0].desc;

	r = ati_remote2_urb_init(ar2);
	if (r)
		goto fail3;

	ar2->channel_mask = channel_mask;
	ar2->mode_mask = mode_mask;

	r = ati_remote2_setup(ar2, ar2->channel_mask);
	if (r)
		goto fail3;

	usb_make_path(udev, ar2->phys, sizeof(ar2->phys));
	strlcat(ar2->phys, ""/input0"", sizeof(ar2->phys));

	strlcat(ar2->name, ""ATI Remote Wonder II"", sizeof(ar2->name));

	r = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);
	if (r)
		goto fail3;

	r = ati_remote2_input_init(ar2);
	if (r)
		goto fail4;

	usb_set_intfdata(interface, ar2);

	interface->needs_remote_wakeup = 1;

	return 0;

 fail4:
	sysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);
 fail3:
	ati_remote2_urb_cleanup(ar2);
 fail2:
	usb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);
 fail1:
	kfree(ar2);

	return r;
}","static int ati_remote2_probe(struct usb_interface *VAR_0, const struct usb_device_id *VAR_1)
{
	struct usb_device *VAR_2 = interface_to_usbdev(VAR_0);
	struct usb_host_interface *VAR_3 = VAR_0->cur_altsetting;
	struct ati_remote2 *VAR_4;
	int VAR_5;

	if (VAR_3->desc.bInterfaceNumber)
		return -VAR_6;

	VAR_4 = kzalloc(sizeof (struct ati_remote2), VAR_7);
	if (!VAR_4)
		return -VAR_8;

	VAR_4->udev = VAR_2;

	/* COMMENT_0 */
	if (VAR_3->desc.bNumEndpoints < 1 || !VAR_3->endpoint) {
		dev_err(&VAR_0->dev,
			""%s(): interface 0 must have an endpoint\n"", VAR_9);
		VAR_5 = -VAR_6;
		goto fail1;
	}
	VAR_4->intf[0] = VAR_0;
	VAR_4->ep[0] = &VAR_3->endpoint[0].desc;

	/* COMMENT_1 */
	VAR_4->intf[1] = usb_ifnum_to_if(VAR_2, 1);
	if ((VAR_2->actconfig->desc.bNumInterfaces < 2) || !VAR_4->intf[1]) {
		dev_err(&VAR_0->dev, ""%s(): need 2 interfaces, found %d\n"",
			VAR_9, VAR_2->actconfig->desc.bNumInterfaces);
		VAR_5 = -VAR_6;
		goto fail1;
	}

	VAR_5 = usb_driver_claim_interface(&VAR_10, VAR_4->intf[1], VAR_4);
	if (VAR_5)
		goto fail1;

	/* COMMENT_2 */
	VAR_3 = VAR_4->intf[1]->cur_altsetting;
	if (VAR_3->desc.bNumEndpoints < 1 || !VAR_3->endpoint) {
		dev_err(&VAR_0->dev,
			""%s(): interface 1 must have an endpoint\n"", VAR_9);
		VAR_5 = -VAR_6;
		goto fail2;
	}
	VAR_4->ep[1] = &VAR_3->endpoint[0].desc;

	VAR_5 = ati_remote2_urb_init(VAR_4);
	if (VAR_5)
		goto fail3;

	VAR_4->channel_mask = VAR_11;
	VAR_4->mode_mask = VAR_12;

	VAR_5 = ati_remote2_setup(VAR_4, VAR_4->channel_mask);
	if (VAR_5)
		goto fail3;

	usb_make_path(VAR_2, VAR_4->phys, sizeof(VAR_4->phys));
	strlcat(VAR_4->phys, ""/input0"", sizeof(VAR_4->phys));

	strlcat(VAR_4->name, ""ATI Remote Wonder II"", sizeof(VAR_4->name));

	VAR_5 = sysfs_create_group(&VAR_2->dev.kobj, &VAR_13);
	if (VAR_5)
		goto fail3;

	VAR_5 = ati_remote2_input_init(VAR_4);
	if (VAR_5)
		goto fail4;

	usb_set_intfdata(VAR_0, VAR_4);

	VAR_0->needs_remote_wakeup = 1;

	return 0;

 fail4:
	sysfs_remove_group(&VAR_2->dev.kobj, &VAR_13);
 fail3:
	ati_remote2_urb_cleanup(VAR_4);
 fail2:
	usb_driver_release_interface(&VAR_10, VAR_4->intf[1]);
 fail1:
	kfree(VAR_4);

	return VAR_5;
}",torvalds/linux/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d/ati_remote2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,26 +14,49 @@
 
 	ar2->udev = udev;
 
+	/* Sanity check, first interface must have an endpoint */
+	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
+		dev_err(&interface->dev,
+			""%s(): interface 0 must have an endpoint\n"", __func__);
+		r = -ENODEV;
+		goto fail1;
+	}
 	ar2->intf[0] = interface;
 	ar2->ep[0] = &alt->endpoint[0].desc;
 
+	/* Sanity check, the device must have two interfaces */
 	ar2->intf[1] = usb_ifnum_to_if(udev, 1);
+	if ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {
+		dev_err(&interface->dev, ""%s(): need 2 interfaces, found %d\n"",
+			__func__, udev->actconfig->desc.bNumInterfaces);
+		r = -ENODEV;
+		goto fail1;
+	}
+
 	r = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);
 	if (r)
 		goto fail1;
+
+	/* Sanity check, second interface must have an endpoint */
 	alt = ar2->intf[1]->cur_altsetting;
+	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
+		dev_err(&interface->dev,
+			""%s(): interface 1 must have an endpoint\n"", __func__);
+		r = -ENODEV;
+		goto fail2;
+	}
 	ar2->ep[1] = &alt->endpoint[0].desc;
 
 	r = ati_remote2_urb_init(ar2);
 	if (r)
-		goto fail2;
+		goto fail3;
 
 	ar2->channel_mask = channel_mask;
 	ar2->mode_mask = mode_mask;
 
 	r = ati_remote2_setup(ar2, ar2->channel_mask);
 	if (r)
-		goto fail2;
+		goto fail3;
 
 	usb_make_path(udev, ar2->phys, sizeof(ar2->phys));
 	strlcat(ar2->phys, ""/input0"", sizeof(ar2->phys));
@@ -42,11 +65,11 @@
 
 	r = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);
 	if (r)
-		goto fail2;
+		goto fail3;
 
 	r = ati_remote2_input_init(ar2);
 	if (r)
-		goto fail3;
+		goto fail4;
 
 	usb_set_intfdata(interface, ar2);
 
@@ -54,10 +77,11 @@
 
 	return 0;
 
+ fail4:
+	sysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);
  fail3:
-	sysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);
+	ati_remote2_urb_cleanup(ar2);
  fail2:
-	ati_remote2_urb_cleanup(ar2);
 	usb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);
  fail1:
 	kfree(ar2);","{'deleted_lines': ['\t\tgoto fail2;', '\t\tgoto fail2;', '\t\tgoto fail2;', '\t\tgoto fail3;', '\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);', '\tati_remote2_urb_cleanup(ar2);'], 'added_lines': ['\t/* Sanity check, first interface must have an endpoint */', '\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {', '\t\tdev_err(&interface->dev,', '\t\t\t""%s(): interface 0 must have an endpoint\\n"", __func__);', '\t\tr = -ENODEV;', '\t\tgoto fail1;', '\t}', '\t/* Sanity check, the device must have two interfaces */', '\tif ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {', '\t\tdev_err(&interface->dev, ""%s(): need 2 interfaces, found %d\\n"",', '\t\t\t__func__, udev->actconfig->desc.bNumInterfaces);', '\t\tr = -ENODEV;', '\t\tgoto fail1;', '\t}', '', '', '\t/* Sanity check, second interface must have an endpoint */', '\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {', '\t\tdev_err(&interface->dev,', '\t\t\t""%s(): interface 1 must have an endpoint\\n"", __func__);', '\t\tr = -ENODEV;', '\t\tgoto fail2;', '\t}', '\t\tgoto fail3;', '\t\tgoto fail3;', '\t\tgoto fail3;', '\t\tgoto fail4;', ' fail4:', '\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);', '\tati_remote2_urb_cleanup(ar2);']}",True,The ati_remote2_probe function in drivers/input/misc/ati_remote2.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.,4.6,MEDIUM,1,valid,2016-03-23T18:53:46Z,1
CVE-2016-10197,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,libevent,"evdns: fix searching empty hostnames

From #332:
  Here follows a bug report by **Guido Vranken** via the _Tor bug bounty program_. Please credit Guido accordingly.

  ## Bug report

  The DNS code of Libevent contains this rather obvious OOB read:

  ```c
  static char *
  search_make_new(const struct search_state *const state, int n, const char *const base_name) {
      const size_t base_len = strlen(base_name);
      const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
  ```

  If the length of ```base_name``` is 0, then line 3125 reads 1 byte before the buffer. This will trigger a crash on ASAN-protected builds.

  To reproduce:

  Build libevent with ASAN:
  ```
  $ CFLAGS='-fomit-frame-pointer -fsanitize=address' ./configure && make -j4
  ```
  Put the attached ```resolv.conf``` and ```poc.c``` in the source directory and then do:

  ```
  $ gcc -fsanitize=address -fomit-frame-pointer poc.c .libs/libevent.a
  $ ./a.out
  =================================================================
  ==22201== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60060000efdf at pc 0x4429da bp 0x7ffe1ed47300 sp 0x7ffe1ed472f8
  READ of size 1 at 0x60060000efdf thread T0
  ```

P.S. we can add a check earlier, but since this is very uncommon, I didn't add it.

Fixes: #332",ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,evdns.c,search_make_new,"static char *
search_make_new(const struct search_state *const state, int n, const char *const base_name) {
const size_t base_len = strlen(base_name);
const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
struct search_domain *dom;
for (dom = state->head; dom; dom = dom->next) {
if (!n--) {
const u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);
const int postfix_len = dom->len;
char *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);
if (!newname) return NULL;
memcpy(newname, base_name, base_len);
if (need_to_append_dot) newname[base_len] = '.';
memcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);
newname[base_len + need_to_append_dot + postfix_len] = 0;
return newname;
}
}
EVUTIL_ASSERT(0);
return NULL; 
}","static char *
search_make_new(const struct search_state *const VAR_0, int VAR_1, const char *const VAR_2) {
const size_t VAR_3 = strlen(VAR_2);
const char VAR_4 = VAR_2[VAR_3 - 1] == '.' ? 0 : 1;
struct search_domain *VAR_5;
for (VAR_5 = VAR_0->head; VAR_5; VAR_5 = VAR_5->next) {
if (!VAR_1--) {
const u8 *const VAR_6 = ((u8 *) VAR_5) + sizeof(struct search_domain);
const int VAR_7 = VAR_5->len;
char *const VAR_8 = (char *) mm_malloc(VAR_3 + VAR_4 + VAR_7 + 1);
if (!VAR_8) return NULL;
memcpy(VAR_8, VAR_2, VAR_3);
if (VAR_4) VAR_8[VAR_3] = '.';
memcpy(VAR_8 + VAR_3 + VAR_4, VAR_6, VAR_7);
VAR_8[VAR_3 + VAR_4 + VAR_7] = 0;
return VAR_8;
}
}
EVUTIL_ASSERT(0);
return NULL; 
}",libevent/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e/evdns.c/vul/before/0.json,"static char *
search_make_new(const struct search_state *const state, int n, const char *const base_name) {
	const size_t base_len = strlen(base_name);
	char need_to_append_dot;
	struct search_domain *dom;

	if (!base_len) return NULL;
	need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;

	for (dom = state->head; dom; dom = dom->next) {
		if (!n--) {
			/* this is the postfix we want */
			/* the actual postfix string is kept at the end of the structure */
			const u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);
			const int postfix_len = dom->len;
			char *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);
			if (!newname) return NULL;
			memcpy(newname, base_name, base_len);
			if (need_to_append_dot) newname[base_len] = '.';
			memcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);
			newname[base_len + need_to_append_dot + postfix_len] = 0;
			return newname;
		}
	}

	/* we ran off the end of the list and still didn't find the requested string */
	EVUTIL_ASSERT(0);
	return NULL; /* unreachable; stops warnings in some compilers. */
}","static char *
search_make_new(const struct search_state *const VAR_0, int VAR_1, const char *const VAR_2) {
	const size_t VAR_3 = strlen(VAR_2);
	char VAR_4;
	struct search_domain *VAR_5;

	if (!VAR_3) return NULL;
	VAR_4 = VAR_2[VAR_3 - 1] == '.' ? 0 : 1;

	for (VAR_5 = VAR_0->head; VAR_5; VAR_5 = VAR_5->next) {
		if (!VAR_1--) {
			/* COMMENT_0 */
			/* COMMENT_1 */
			const u8 *const VAR_6 = ((u8 *) VAR_5) + sizeof(struct search_domain);
			const int VAR_7 = VAR_5->len;
			char *const VAR_8 = (char *) mm_malloc(VAR_3 + VAR_4 + VAR_7 + 1);
			if (!VAR_8) return NULL;
			memcpy(VAR_8, VAR_2, VAR_3);
			if (VAR_4) VAR_8[VAR_3] = '.';
			memcpy(VAR_8 + VAR_3 + VAR_4, VAR_6, VAR_7);
			VAR_8[VAR_3 + VAR_4 + VAR_7] = 0;
			return VAR_8;
		}
	}

	/* COMMENT_2 */
	EVUTIL_ASSERT(0);
	return NULL; /* COMMENT_3 */
}",libevent/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e/evdns.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,11 @@
 static char *
 search_make_new(const struct search_state *const state, int n, const char *const base_name) {
 	const size_t base_len = strlen(base_name);
-	const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
+	char need_to_append_dot;
 	struct search_domain *dom;
+
+	if (!base_len) return NULL;
+	need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
 
 	for (dom = state->head; dom; dom = dom->next) {
 		if (!n--) {","{'deleted_lines': [""\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;""], 'added_lines': ['\tchar need_to_append_dot;', '', '\tif (!base_len) return NULL;', ""\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;""]}",True,The search_make_new function in evdns.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (out-of-bounds read) via an empty hostname.,7.5,HIGH,2,valid,2016-03-24T21:33:47Z,1
CVE-2016-4082,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"GSM CBCH: fix an out of bounds access

As explained by Guy, we should use new_slots[i] and not new_slots[k]

Bug: 12278
Change-Id: Ifae44f9d5948bed5c4ee0442510724016e307dee
Reviewed-on: https://code.wireshark.org/review/14678
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Anders Broman <a.broman58@gmail.com>",0fe522dfc689c3ebd119f2a6775d1f275c5f04d8,https://github.com/wireshark/wireshark/commit/0fe522dfc689c3ebd119f2a6775d1f275c5f04d8,epan/dissectors/packet-gsm_cbch.c,dissect_schedule_message,"static void
dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree)
{
guint       len, offset  = 0;
guint8      octet1, i, k = 0;
guint8      sched_begin, sched_end, new_slots[48];
gboolean    valid_message   = TRUE;
guint16     other_slots[48];
proto_item *item            = NULL, *schedule_item = NULL;
proto_tree *sched_tree      = NULL, *sched_subtree = NULL;
len = tvb_reported_length(tvb);
col_append_str(pinfo->cinfo, COL_INFO, "" CBCH Schedule Message "");
schedule_item = proto_tree_add_protocol_format(top_tree, proto_cbch, tvb, 0, -1,
""GSM CBCH Schedule Message"");
sched_tree = proto_item_add_subtree(schedule_item, ett_schedule_msg);
proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_type, tvb, offset, 1, ENC_BIG_ENDIAN);
octet1 = tvb_get_guint8(tvb, offset);
if (0 == (octet1 & 0xC0))
{
proto_item* slot_item;
sched_begin = octet1 & 0x3F;
proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_begin_slot, tvb, offset++, 1, ENC_BIG_ENDIAN);
if ((sched_begin < 1) || (sched_begin > 48))
{
valid_message = FALSE;
}
proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_spare, tvb, offset, 1, ENC_BIG_ENDIAN);
sched_end = tvb_get_guint8(tvb, offset);
slot_item = proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_end_slot, tvb, offset++, 1, ENC_BIG_ENDIAN);
if (sched_end < sched_begin)
{
expert_add_info(pinfo, slot_item, &ei_gsm_cbch_sched_end_slot);
valid_message = FALSE;
}
if (valid_message)
{
memset(&new_slots,   0xFF, sizeof(new_slots));
memset(&other_slots, 0xFF, sizeof(other_slots));
for (i=0; i<6; i++)
{
guint8 j;
octet1 = tvb_get_guint8(tvb, offset++);
for (j=0; j<8; j++)
{
if (octet1 & (0x80>>j))
{
new_slots[k++] = (i<<3) + j + 1;
}
}
}
sched_subtree = proto_tree_add_subtree_format(sched_tree, tvb, offset-6, 6, ett_schedule_new_msg, &item,
""This schedule contains %d slots with new messages"", k);
for (i=0; i<k; i++)
{
DISSECTOR_ASSERT(new_slots[i] <= 48);
octet1 = tvb_get_guint8(tvb, offset);
if ((octet1 & 0x80) == 0x80)
{
guint8 octet2;
guint16 msg_id;
octet2 = tvb_get_guint8(tvb, offset + 1);
msg_id = ((octet1 &0x7F) << 8) + octet2;
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 2, new_slots[i],
""%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period"",
new_slots[i], msg_id);
offset +=2;
other_slots[new_slots[i] - 1] = msg_id;
}
else if ((octet1 & 0xC0) == 0)
{
if (octet1 == 0)
{
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
""%d, Repeat of non-existant slot %d"",
new_slots[i], octet1);
}
else if (octet1 < new_slots[i])
{
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
""%d, Message ID: %d, Repeat of Slot %d"",
new_slots[i], other_slots[octet1 - 1], octet1);
other_slots[new_slots[i] - 1] = other_slots[octet1 - 1];
}
else
{
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
""%d, Apparent forward reference to slot %d"",
new_slots[i], octet1);
}
}
else if (octet1 == 0x40)
{
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[k],
""%d Free Message Slot, optional reading"", new_slots[k]);
other_slots[new_slots[i] - 1] = 0xFFFE;
}
else if (octet1 == 0x41)
{
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[k],
""%d Free Message Slot, reading advised"", new_slots[k]);
other_slots[new_slots[i] - 1] = 0xFFFE;
}
else
{
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, new_slots[k],
""%d reserved MDT: %x"", new_slots[k], octet1);
other_slots[new_slots[i] - 1] = 0xFFFE;
}
}
proto_item_set_end(item, tvb, offset);
sched_subtree = proto_tree_add_subtree(sched_tree, tvb, offset, 0,
ett_schedule_new_msg, &item, ""Other message slots in this schedule"");
for (k=0; offset < len; )
{
guint8  octet2;
guint16 msg_id;
octet2 = tvb_get_guint8(tvb, offset + 1);
msg_id = ((octet1 &0x7F) << 8) + octet2;
other_slots[k] = msg_id;
k++;
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 2, k,
""%d, Message: %d, First transmission of an SMSCB within the Schedule Period"",
k, msg_id);
offset +=2;
}
else
{
++k;
}
}
else if (octet1 && ((octet1 & 0xC0) == 0))
{
if (octet1 < k)
{
other_slots[k] = other_slots[octet1 - 1];
k++;
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
""%d, Message ID: %d, Repeat of Slot %d"",
k, other_slots[octet1 - 1], octet1);
}
else
{
k++;
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
""%d, Apparent forward reference to slot %d"",
k, octet1);
}
}
else if (octet1 == 0x40)
{
k++;
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
""%d Free Message Slot, optional reading"", k);
}
else if (octet1 == 0x41)
{
k++;
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
""%d Free Message Slot, reading advised"", k);
}
else
{
k++;
proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, k,
""%d reserved MDT: %x"", k, octet1);
}
}
proto_item_set_end(item, tvb, offset);
proto_tree_add_item(sched_tree, hf_gsm_cbch_padding, tvb, offset, -1, ENC_NA);
}
}
}","static void
dissect_schedule_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2)
{
guint       VAR_3, VAR_4  = 0;
guint8      VAR_5, VAR_6, VAR_7 = 0;
guint8      VAR_8, VAR_9, VAR_10[48];
gboolean    VAR_11   = TRUE;
guint16     VAR_12[48];
proto_item *VAR_13            = NULL, *VAR_14 = NULL;
proto_tree *VAR_15      = NULL, *VAR_16 = NULL;
VAR_3 = tvb_reported_length(VAR_0);
col_append_str(VAR_1->cinfo, VAR_17, "" CBCH Schedule Message "");
VAR_14 = proto_tree_add_protocol_format(VAR_2, VAR_18, VAR_0, 0, -1,
""GSM CBCH Schedule Message"");
VAR_15 = proto_item_add_subtree(VAR_14, VAR_19);
proto_tree_add_item(VAR_15, VAR_20, VAR_0, VAR_4, 1, VAR_21);
VAR_5 = tvb_get_guint8(VAR_0, VAR_4);
if (0 == (VAR_5 & 0xC0))
{
proto_item* VAR_22;
VAR_8 = VAR_5 & 0x3F;
proto_tree_add_item(VAR_15, VAR_23, VAR_0, VAR_4++, 1, VAR_21);
if ((VAR_8 < 1) || (VAR_8 > 48))
{
VAR_11 = FALSE;
}
proto_tree_add_item(VAR_15, VAR_24, VAR_0, VAR_4, 1, VAR_21);
VAR_9 = tvb_get_guint8(VAR_0, VAR_4);
VAR_22 = proto_tree_add_item(VAR_15, VAR_25, VAR_0, VAR_4++, 1, VAR_21);
if (VAR_9 < VAR_8)
{
expert_add_info(VAR_1, VAR_22, &VAR_26);
VAR_11 = FALSE;
}
if (VAR_11)
{
memset(&VAR_10,   0xFF, sizeof(VAR_10));
memset(&VAR_12, 0xFF, sizeof(VAR_12));
for (VAR_6=0; VAR_6<6; VAR_6++)
{
guint8 VAR_27;
VAR_5 = tvb_get_guint8(VAR_0, VAR_4++);
for (VAR_27=0; VAR_27<8; VAR_27++)
{
if (VAR_5 & (0x80>>VAR_27))
{
VAR_10[VAR_7++] = (VAR_6<<3) + VAR_27 + 1;
}
}
}
VAR_16 = proto_tree_add_subtree_format(VAR_15, VAR_0, VAR_4-6, 6, VAR_28, &VAR_13,
""This schedule contains %d slots with new messages"", VAR_7);
for (VAR_6=0; VAR_6<VAR_7; VAR_6++)
{
DISSECTOR_ASSERT(VAR_10[VAR_6] <= 48);
VAR_5 = tvb_get_guint8(VAR_0, VAR_4);
if ((VAR_5 & 0x80) == 0x80)
{
guint8 VAR_29;
guint16 VAR_30;
VAR_29 = tvb_get_guint8(VAR_0, VAR_4 + 1);
VAR_30 = ((VAR_5 &0x7F) << 8) + VAR_29;
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 2, VAR_10[VAR_6],
""%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period"",
VAR_10[VAR_6], VAR_30);
VAR_4 +=2;
VAR_12[VAR_10[VAR_6] - 1] = VAR_30;
}
else if ((VAR_5 & 0xC0) == 0)
{
if (VAR_5 == 0)
{
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
""%d, Repeat of non-existant slot %d"",
VAR_10[VAR_6], VAR_5);
}
else if (VAR_5 < VAR_10[VAR_6])
{
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
""%d, Message ID: %d, Repeat of Slot %d"",
VAR_10[VAR_6], VAR_12[VAR_5 - 1], VAR_5);
VAR_12[VAR_10[VAR_6] - 1] = VAR_12[VAR_5 - 1];
}
else
{
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
""%d, Apparent forward reference to slot %d"",
VAR_10[VAR_6], VAR_5);
}
}
else if (VAR_5 == 0x40)
{
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_7],
""%d Free Message Slot, optional reading"", VAR_10[VAR_7]);
VAR_12[VAR_10[VAR_6] - 1] = 0xFFFE;
}
else if (VAR_5 == 0x41)
{
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_7],
""%d Free Message Slot, reading advised"", VAR_10[VAR_7]);
VAR_12[VAR_10[VAR_6] - 1] = 0xFFFE;
}
else
{
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 1, VAR_10[VAR_7],
""%d reserved MDT: %x"", VAR_10[VAR_7], VAR_5);
VAR_12[VAR_10[VAR_6] - 1] = 0xFFFE;
}
}
proto_item_set_end(VAR_13, VAR_0, VAR_4);
VAR_16 = proto_tree_add_subtree(VAR_15, VAR_0, VAR_4, 0,
VAR_28, &VAR_13, ""Other message slots in this schedule"");
for (VAR_7=0; VAR_4 < VAR_3; )
{
if (VAR_9 > 48)
VAR_9 = 48;
while ((VAR_7<VAR_9) && (VAR_12[VAR_7]!=0xFFFF))
{
VAR_7++;
}
if (VAR_7 >= VAR_9)
break;
VAR_5 = tvb_get_guint8(VAR_0, VAR_4);
if ((VAR_5 & 0x80) == 0x80)
{
if ((VAR_4+1)<VAR_3)
{
guint8  VAR_29;
guint16 VAR_30;
VAR_29 = tvb_get_guint8(VAR_0, VAR_4 + 1);
VAR_30 = ((VAR_5 &0x7F) << 8) + VAR_29;
VAR_12[VAR_7] = VAR_30;
VAR_7++;
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 2, VAR_7,
""%d, Message: %d, First transmission of an SMSCB within the Schedule Period"",
VAR_7, VAR_30);
VAR_4 +=2;
}
else
{
++VAR_7;
}
}
else if (VAR_5 && ((VAR_5 & 0xC0) == 0))
{
if (VAR_5 < VAR_7)
{
VAR_12[VAR_7] = VAR_12[VAR_5 - 1];
VAR_7++;
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
""%d, Message ID: %d, Repeat of Slot %d"",
VAR_7, VAR_12[VAR_5 - 1], VAR_5);
}
else
{
VAR_7++;
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
""%d, Apparent forward reference to slot %d"",
VAR_7, VAR_5);
}
}
else if (VAR_5 == 0x40)
{
VAR_7++;
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
""%d Free Message Slot, optional reading"", VAR_7);
}
else if (VAR_5 == 0x41)
{
VAR_7++;
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
""%d Free Message Slot, reading advised"", VAR_7);
}
else
{
VAR_7++;
proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 1, VAR_7,
""%d reserved MDT: %x"", VAR_7, VAR_5);
}
}
proto_item_set_end(VAR_13, VAR_0, VAR_4);
proto_tree_add_item(VAR_15, VAR_32, VAR_0, VAR_4, -1, VAR_33);
}
}
}",wireshark/0fe522dfc689c3ebd119f2a6775d1f275c5f04d8/packet-gsm_cbch.c/vul/before/0.json,"static void
dissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree)
{
    guint       len, offset  = 0;
    guint8      octet1, i, k = 0;
    guint8      sched_begin, sched_end, new_slots[48];
    gboolean    valid_message   = TRUE;
    guint16     other_slots[48];
    proto_item *item            = NULL, *schedule_item = NULL;
    proto_tree *sched_tree      = NULL, *sched_subtree = NULL;

    len = tvb_reported_length(tvb);

    col_append_str(pinfo->cinfo, COL_INFO, "" CBCH Schedule Message "");

    schedule_item = proto_tree_add_protocol_format(top_tree, proto_cbch, tvb, 0, -1,
                                                   ""GSM CBCH Schedule Message"");

    sched_tree = proto_item_add_subtree(schedule_item, ett_schedule_msg);

    proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_type, tvb, offset, 1, ENC_BIG_ENDIAN);
    octet1 = tvb_get_guint8(tvb, offset);
    if (0 == (octet1 & 0xC0))
    {
        proto_item* slot_item;
        sched_begin = octet1 & 0x3F;
        proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_begin_slot, tvb, offset++, 1, ENC_BIG_ENDIAN);
        if ((sched_begin < 1) || (sched_begin > 48))
        {
            valid_message = FALSE;
        }
        proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_spare, tvb, offset, 1, ENC_BIG_ENDIAN);
        sched_end = tvb_get_guint8(tvb, offset);
        slot_item = proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_end_slot, tvb, offset++, 1, ENC_BIG_ENDIAN);
        if (sched_end < sched_begin)
        {
            expert_add_info(pinfo, slot_item, &ei_gsm_cbch_sched_end_slot);
            valid_message = FALSE;
        }

        if (valid_message)
        {
            /* build an array of new messages */
            memset(&new_slots,   0xFF, sizeof(new_slots));
            memset(&other_slots, 0xFF, sizeof(other_slots));

            /* iterate over the octets */
            for (i=0; i<6; i++)
            {
                guint8 j;
                octet1 = tvb_get_guint8(tvb, offset++);

                /* iterate over the bits */
                for (j=0; j<8; j++)
                {
                    if (octet1 & (0x80>>j))
                    {
                        new_slots[k++] = (i<<3) + j + 1;
                    }
                }
            }
            /* print the array of new messages */
            sched_subtree = proto_tree_add_subtree_format(sched_tree, tvb, offset-6, 6, ett_schedule_new_msg, &item,
                                                            ""This schedule contains %d slots with new messages"", k);
            for (i=0; i<k; i++)
            {
                DISSECTOR_ASSERT(new_slots[i] <= 48);
                octet1 = tvb_get_guint8(tvb, offset);
                if ((octet1 & 0x80) == 0x80)
                {
                    /* MDT 1 */
                    guint8 octet2;
                    guint16 msg_id;

                    octet2 = tvb_get_guint8(tvb, offset + 1);
                    msg_id = ((octet1 &0x7F) << 8) + octet2;
                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 2, new_slots[i],
                                        ""%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period"",
                                        new_slots[i], msg_id);
                    offset +=2;
                    other_slots[new_slots[i] - 1] = msg_id;
                }
                else if ((octet1 & 0xC0) == 0)
                {
                    /* MDT 00 */
                    if (octet1 == 0)
                    {
                        proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
                                            ""%d, Repeat of non-existant slot %d"",
                                            new_slots[i], octet1);
                    }
                    else if (octet1 < new_slots[i])
                    {
                        proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
                                            ""%d, Message ID: %d, Repeat of Slot %d"",
                                            new_slots[i], other_slots[octet1 - 1], octet1);
                        other_slots[new_slots[i] - 1] = other_slots[octet1 - 1];
                    }
                    else
                    {
                        proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
                                            ""%d, Apparent forward reference to slot %d"",
                                            new_slots[i], octet1);
                    }
                }
                else if (octet1 == 0x40)
                {
                    /* MDT 010000000 */
                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
                                    ""%d Free Message Slot, optional reading"", new_slots[i]);
                    other_slots[new_slots[i] - 1] = 0xFFFE;
                }
                else if (octet1 == 0x41)
                {
                    /* MDT 010000001 */
                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
                                     ""%d Free Message Slot, reading advised"", new_slots[i]);
                    other_slots[new_slots[i] - 1] = 0xFFFE;
                }
                else
                {
                    /* reserved MDT */
                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, new_slots[i],
                                     ""%d reserved MDT: %x"", new_slots[i], octet1);
                    other_slots[new_slots[i] - 1] = 0xFFFE;
                }
            }
            proto_item_set_end(item, tvb, offset);

            /* print schedule of other messages */
            sched_subtree = proto_tree_add_subtree(sched_tree, tvb, offset, 0,
                                ett_schedule_new_msg, &item, ""Other message slots in this schedule"");
            for (k=0; offset < len; )
            {
                /* XXX I don't know if a message can validly contain more than
                 * 48 slots, but that's the size of the array we create so cap
                 * it there to avoid uninitialized memory errors (see bug
                 * https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=9270) */
                if (sched_end > 48)
                    sched_end = 48;
                while ((k<sched_end) && (other_slots[k]!=0xFFFF))
                {
                    k++;
                }
                if (k >= sched_end)
                    break;

                octet1 = tvb_get_guint8(tvb, offset);
                if ((octet1 & 0x80) == 0x80)
                {
                    if ((offset+1)<len)
                    {
                        /* MDT 1 */
                        guint8  octet2;
                        guint16 msg_id;

                        octet2 = tvb_get_guint8(tvb, offset + 1);
                        msg_id = ((octet1 &0x7F) << 8) + octet2;
                        other_slots[k] = msg_id;
                        k++;
                        proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 2, k,
                                            ""%d, Message: %d, First transmission of an SMSCB within the Schedule Period"",
                                            k, msg_id);
                        offset +=2;
                    }
                    else
                    {
                        /* I'm not sure what's supposed to be dissected in this
                         * case. Perhaps just an expert info is appropriate?
                         * Regardless, we need to increment k to prevent an
                         * infinite loop, see
                         * https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=8730
                         */
                        ++k;
                    }
                }
                else if (octet1 && ((octet1 & 0xC0) == 0))
                {
                    /* MDT 00 */
                    if (octet1 < k)
                    {
                        other_slots[k] = other_slots[octet1 - 1];
                        k++;
                        proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
                                            ""%d, Message ID: %d, Repeat of Slot %d"",
                                            k, other_slots[octet1 - 1], octet1);
                    }
                    else
                    {
                        k++;
                        proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
                                            ""%d, Apparent forward reference to slot %d"",
                                            k, octet1);
                    }
                }
                else if (octet1 == 0x40)
                {
                    /* MDT 010000000 */
                    k++;
                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
                            ""%d Free Message Slot, optional reading"", k);
                }
                else if (octet1 == 0x41)
                {
                    /* MDT 010000001 */
                    k++;
                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,
                            ""%d Free Message Slot, reading advised"", k);
                }
                else
                {
                    /* reserved MDT */
                    k++;
                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, k,
                            ""%d reserved MDT: %x"", k, octet1);
                }
            }
            proto_item_set_end(item, tvb, offset);
            proto_tree_add_item(sched_tree, hf_gsm_cbch_padding, tvb, offset, -1, ENC_NA);
        }
    }
}","static void
dissect_schedule_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2)
{
    guint       VAR_3, VAR_4  = 0;
    guint8      VAR_5, VAR_6, VAR_7 = 0;
    guint8      VAR_8, VAR_9, VAR_10[48];
    gboolean    VAR_11   = TRUE;
    guint16     VAR_12[48];
    proto_item *VAR_13            = NULL, *VAR_14 = NULL;
    proto_tree *VAR_15      = NULL, *VAR_16 = NULL;

    VAR_3 = tvb_reported_length(VAR_0);

    col_append_str(VAR_1->cinfo, VAR_17, "" CBCH Schedule Message "");

    VAR_14 = proto_tree_add_protocol_format(VAR_2, VAR_18, VAR_0, 0, -1,
                                                   ""GSM CBCH Schedule Message"");

    VAR_15 = proto_item_add_subtree(VAR_14, VAR_19);

    proto_tree_add_item(VAR_15, VAR_20, VAR_0, VAR_4, 1, VAR_21);
    VAR_5 = tvb_get_guint8(VAR_0, VAR_4);
    if (0 == (VAR_5 & 0xC0))
    {
        proto_item* VAR_22;
        VAR_8 = VAR_5 & 0x3F;
        proto_tree_add_item(VAR_15, VAR_23, VAR_0, VAR_4++, 1, VAR_21);
        if ((VAR_8 < 1) || (VAR_8 > 48))
        {
            VAR_11 = FALSE;
        }
        proto_tree_add_item(VAR_15, VAR_24, VAR_0, VAR_4, 1, VAR_21);
        VAR_9 = tvb_get_guint8(VAR_0, VAR_4);
        VAR_22 = proto_tree_add_item(VAR_15, VAR_25, VAR_0, VAR_4++, 1, VAR_21);
        if (VAR_9 < VAR_8)
        {
            expert_add_info(VAR_1, VAR_22, &VAR_26);
            VAR_11 = FALSE;
        }

        if (VAR_11)
        {
            /* COMMENT_0 */
            memset(&VAR_10,   0xFF, sizeof(VAR_10));
            memset(&VAR_12, 0xFF, sizeof(VAR_12));

            /* COMMENT_1 */
            for (VAR_6=0; VAR_6<6; VAR_6++)
            {
                guint8 VAR_27;
                VAR_5 = tvb_get_guint8(VAR_0, VAR_4++);

                /* COMMENT_2 */
                for (VAR_27=0; VAR_27<8; VAR_27++)
                {
                    if (VAR_5 & (0x80>>VAR_27))
                    {
                        VAR_10[VAR_7++] = (VAR_6<<3) + VAR_27 + 1;
                    }
                }
            }
            /* COMMENT_3 */
            VAR_16 = proto_tree_add_subtree_format(VAR_15, VAR_0, VAR_4-6, 6, VAR_28, &VAR_13,
                                                            ""This schedule contains %d slots with new messages"", VAR_7);
            for (VAR_6=0; VAR_6<VAR_7; VAR_6++)
            {
                DISSECTOR_ASSERT(VAR_10[VAR_6] <= 48);
                VAR_5 = tvb_get_guint8(VAR_0, VAR_4);
                if ((VAR_5 & 0x80) == 0x80)
                {
                    /* COMMENT_4 */
                    guint8 VAR_29;
                    guint16 VAR_30;

                    VAR_29 = tvb_get_guint8(VAR_0, VAR_4 + 1);
                    VAR_30 = ((VAR_5 &0x7F) << 8) + VAR_29;
                    proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 2, VAR_10[VAR_6],
                                        ""%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period"",
                                        VAR_10[VAR_6], VAR_30);
                    VAR_4 +=2;
                    VAR_12[VAR_10[VAR_6] - 1] = VAR_30;
                }
                else if ((VAR_5 & 0xC0) == 0)
                {
                    /* COMMENT_5 */
                    if (VAR_5 == 0)
                    {
                        proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
                                            ""%d, Repeat of non-existant slot %d"",
                                            VAR_10[VAR_6], VAR_5);
                    }
                    else if (VAR_5 < VAR_10[VAR_6])
                    {
                        proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
                                            ""%d, Message ID: %d, Repeat of Slot %d"",
                                            VAR_10[VAR_6], VAR_12[VAR_5 - 1], VAR_5);
                        VAR_12[VAR_10[VAR_6] - 1] = VAR_12[VAR_5 - 1];
                    }
                    else
                    {
                        proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
                                            ""%d, Apparent forward reference to slot %d"",
                                            VAR_10[VAR_6], VAR_5);
                    }
                }
                else if (VAR_5 == 0x40)
                {
                    /* COMMENT_6 */
                    proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
                                    ""%d Free Message Slot, optional reading"", VAR_10[VAR_6]);
                    VAR_12[VAR_10[VAR_6] - 1] = 0xFFFE;
                }
                else if (VAR_5 == 0x41)
                {
                    /* COMMENT_7 */
                    proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_10[VAR_6],
                                     ""%d Free Message Slot, reading advised"", VAR_10[VAR_6]);
                    VAR_12[VAR_10[VAR_6] - 1] = 0xFFFE;
                }
                else
                {
                    /* COMMENT_8 */
                    proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 1, VAR_10[VAR_6],
                                     ""%d reserved MDT: %x"", VAR_10[VAR_6], VAR_5);
                    VAR_12[VAR_10[VAR_6] - 1] = 0xFFFE;
                }
            }
            proto_item_set_end(VAR_13, VAR_0, VAR_4);

            /* COMMENT_9 */
            VAR_16 = proto_tree_add_subtree(VAR_15, VAR_0, VAR_4, 0,
                                VAR_28, &VAR_13, ""Other message slots in this schedule"");
            for (VAR_7=0; VAR_4 < VAR_3; )
            {
                /* COMMENT_10 */
                                                                              
                                                                         
                                                                               
                if (VAR_9 > 48)
                    VAR_9 = 48;
                while ((VAR_7<VAR_9) && (VAR_12[VAR_7]!=0xFFFF))
                {
                    VAR_7++;
                }
                if (VAR_7 >= VAR_9)
                    break;

                VAR_5 = tvb_get_guint8(VAR_0, VAR_4);
                if ((VAR_5 & 0x80) == 0x80)
                {
                    if ((VAR_4+1)<VAR_3)
                    {
                        /* COMMENT_4 */
                        guint8  VAR_29;
                        guint16 VAR_30;

                        VAR_29 = tvb_get_guint8(VAR_0, VAR_4 + 1);
                        VAR_30 = ((VAR_5 &0x7F) << 8) + VAR_29;
                        VAR_12[VAR_7] = VAR_30;
                        VAR_7++;
                        proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 2, VAR_7,
                                            ""%d, Message: %d, First transmission of an SMSCB within the Schedule Period"",
                                            VAR_7, VAR_30);
                        VAR_4 +=2;
                    }
                    else
                    {
                        /* COMMENT_14 */
                                                                            
                                                                           
                                             
                                                                                   
                           
                        ++VAR_7;
                    }
                }
                else if (VAR_5 && ((VAR_5 & 0xC0) == 0))
                {
                    /* COMMENT_5 */
                    if (VAR_5 < VAR_7)
                    {
                        VAR_12[VAR_7] = VAR_12[VAR_5 - 1];
                        VAR_7++;
                        proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
                                            ""%d, Message ID: %d, Repeat of Slot %d"",
                                            VAR_7, VAR_12[VAR_5 - 1], VAR_5);
                    }
                    else
                    {
                        VAR_7++;
                        proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
                                            ""%d, Apparent forward reference to slot %d"",
                                            VAR_7, VAR_5);
                    }
                }
                else if (VAR_5 == 0x40)
                {
                    /* COMMENT_6 */
                    VAR_7++;
                    proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
                            ""%d Free Message Slot, optional reading"", VAR_7);
                }
                else if (VAR_5 == 0x41)
                {
                    /* COMMENT_7 */
                    VAR_7++;
                    proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4++, 1, VAR_7,
                            ""%d Free Message Slot, reading advised"", VAR_7);
                }
                else
                {
                    /* COMMENT_8 */
                    VAR_7++;
                    proto_tree_add_uint_format_value(VAR_16, VAR_31, VAR_0, VAR_4, 1, VAR_7,
                            ""%d reserved MDT: %x"", VAR_7, VAR_5);
                }
            }
            proto_item_set_end(VAR_13, VAR_0, VAR_4);
            proto_tree_add_item(VAR_15, VAR_32, VAR_0, VAR_4, -1, VAR_33);
        }
    }
}",wireshark/0fe522dfc689c3ebd119f2a6775d1f275c5f04d8/packet-gsm_cbch.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -106,22 +106,22 @@
                 else if (octet1 == 0x40)
                 {
                     /* MDT 010000000 */
-                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[k],
-                                    ""%d Free Message Slot, optional reading"", new_slots[k]);
+                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
+                                    ""%d Free Message Slot, optional reading"", new_slots[i]);
                     other_slots[new_slots[i] - 1] = 0xFFFE;
                 }
                 else if (octet1 == 0x41)
                 {
                     /* MDT 010000001 */
-                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[k],
-                                     ""%d Free Message Slot, reading advised"", new_slots[k]);
+                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],
+                                     ""%d Free Message Slot, reading advised"", new_slots[i]);
                     other_slots[new_slots[i] - 1] = 0xFFFE;
                 }
                 else
                 {
                     /* reserved MDT */
-                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, new_slots[k],
-                                     ""%d reserved MDT: %x"", new_slots[k], octet1);
+                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, new_slots[i],
+                                     ""%d reserved MDT: %x"", new_slots[i], octet1);
                     other_slots[new_slots[i] - 1] = 0xFFFE;
                 }
             }","{'deleted_lines': ['                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[k],', '                                    ""%d Free Message Slot, optional reading"", new_slots[k]);', '                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[k],', '                                     ""%d Free Message Slot, reading advised"", new_slots[k]);', '                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, new_slots[k],', '                                     ""%d reserved MDT: %x"", new_slots[k], octet1);'], 'added_lines': ['                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],', '                                    ""%d Free Message Slot, optional reading"", new_slots[i]);', '                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],', '                                     ""%d Free Message Slot, reading advised"", new_slots[i]);', '                    proto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, new_slots[i],', '                                     ""%d reserved MDT: %x"", new_slots[i], octet1);']}",True,"epan/dissectors/packet-gsm_cbch.c in the GSM CBCH dissector in Wireshark 1.12.x before 1.12.11 and 2.0.x before 2.0.3 uses the wrong variable to index an array, which allows remote attackers to cause a denial of service (out-of-bounds access and application crash) via a crafted packet.",5.9,MEDIUM,1,valid,2016-03-28T14:30:55Z,1
CVE-2016-6271,['CWE-254'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,BelledonneCommunications/bzrtp,Add ZRTP Commit packet hvi check on DHPart2 packet reception,bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,src/packetParser.c,bzrtp_packetParser,"int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {
int i;
uint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);
switch (zrtpPacket->messageType) {
case MSGTYPE_HELLO : 
{
bzrtpHelloMessage_t *messageData;
messageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));
memcpy(messageData->version, messageContent, 4);
messageContent +=4;
memcpy(messageData->clientIdentifier, messageContent, 16);
messageContent +=16;
memcpy(messageData->H3, messageContent, 32);
messageContent +=32;
memcpy(messageData->ZID, messageContent, 12);
messageContent +=12;
messageData->S = ((*messageContent)>>6)&0x01;
messageData->M = ((*messageContent)>>5)&0x01;
messageData->P = ((*messageContent)>>4)&0x01;
messageContent +=1;
messageData->hc = MIN((*messageContent)&0x0F, 7);
messageContent +=1;
messageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);
messageData->ac = MIN((*messageContent)&0x0F, 7);
messageContent +=1;
messageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);
messageData->sc = MIN((*messageContent)&0x0F, 7);
messageContent +=1;
if (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {
free(messageData);
return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
}
for (i=0; i<messageData->hc; i++) {
messageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
messageContent +=4;
}
for (i=0; i<messageData->cc; i++) {
messageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
messageContent +=4;
}
for (i=0; i<messageData->ac; i++) {
messageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
messageContent +=4;
}
for (i=0; i<messageData->kc; i++) {
messageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
messageContent +=4;
}
for (i=0; i<messageData->sc; i++) {
messageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
messageContent +=4;
}
addMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);
addMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);
addMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);
addMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);
addMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);
memcpy(messageData->MAC, messageContent, 8);
zrtpPacket->messageData = (void *)messageData;
zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
memcpy(zrtpPacket->packetString, input, inputLength); 
}
break; 
case MSGTYPE_HELLOACK :
{
if (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {
return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
}
}
break; 
case MSGTYPE_COMMIT:
{
uint8_t checkH3[32];
uint8_t checkMAC[32];
bzrtpHelloMessage_t *peerHelloMessageData;
uint16_t variableLength = 0;
bzrtpCommitMessage_t *messageData;
messageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));
memcpy(messageData->H2, messageContent, 32);
messageContent +=32;
if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
free (messageData);
return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
}
peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
bctoolbox_sha256(messageData->H2, 32, 32, checkH3);
if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
}
bctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
}
memcpy(messageData->ZID, messageContent, 12);
messageContent +=12;
messageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
messageContent += 4;
messageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
messageContent += 4;
messageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
messageContent += 4;
messageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
messageContent += 4;
switch(messageData->keyAgreementAlgo) {
case ZRTP_KEYAGREEMENT_DH2k :
case ZRTP_KEYAGREEMENT_EC25 :
case ZRTP_KEYAGREEMENT_DH3k :
case ZRTP_KEYAGREEMENT_EC38 :
case ZRTP_KEYAGREEMENT_EC52 :
variableLength = 32; 
break;
case ZRTP_KEYAGREEMENT_Prsh :
variableLength = 24; 
break;
case ZRTP_KEYAGREEMENT_Mult :
variableLength = 16; 
break;
default:
free(messageData);
return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
}
if (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {
free(messageData);
return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
}
messageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
messageContent += 4;
if ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {
memcpy(messageData->nonce, messageContent, 16);
messageContent +=16;
if (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {
memcpy(messageData->keyID, messageContent, 8);
messageContent +=8;
}
} else { 
memcpy(messageData->hvi, messageContent, 32);
messageContent +=32;
}
memcpy(messageData->MAC, messageContent, 8);
zrtpPacket->messageData = (void *)messageData;
zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
memcpy(zrtpPacket->packetString, input, inputLength); 
}
break; 
case MSGTYPE_DHPART1 :
case MSGTYPE_DHPART2 :
{
bzrtpDHPartMessage_t *messageData;
uint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);
if (pvLength == 0) {
return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
}
if (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {
return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
}
messageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
messageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));
memcpy(messageData->H1, messageContent, 32);
messageContent +=32;
if ( zrtpChannelContext->role == RESPONDER) { 
uint8_t checkH2[32];
uint8_t checkMAC[32];
bzrtpCommitMessage_t *peerCommitMessageData;
if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
free (messageData);
return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
}
peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
}
bctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
}
} else { 
uint8_t checkH2[32];
uint8_t checkH3[32];
uint8_t checkMAC[32];
bzrtpHelloMessage_t *peerHelloMessageData;
if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
free (messageData);
return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
}
peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
bctoolbox_sha256(checkH2, 32, 32, checkH3);
if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
}
bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
}
}
memcpy(messageData->rs1ID, messageContent, 8);
messageContent +=8;
memcpy(messageData->rs2ID, messageContent, 8);
messageContent +=8;
memcpy(messageData->auxsecretID, messageContent, 8);
messageContent +=8;
memcpy(messageData->pbxsecretID, messageContent, 8);
messageContent +=8;
memcpy(messageData->pv, messageContent, pvLength);
messageContent +=pvLength;
memcpy(messageData->MAC, messageContent, 8);
zrtpPacket->messageData = (void *)messageData;
zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
memcpy(zrtpPacket->packetString, input, inputLength); 
}
break; 
case MSGTYPE_CONFIRM1:
case MSGTYPE_CONFIRM2:
{
uint8_t *confirmMessageKey = NULL;
uint8_t *confirmMessageMacKey = NULL;
bzrtpConfirmMessage_t *messageData;
uint16_t cipherTextLength;
uint8_t computedHmac[8];
uint8_t *confirmPlainMessageBuffer;
uint8_t *confirmPlainMessage;
if (zrtpChannelContext->role == RESPONDER) { 
if ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {
return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
}
confirmMessageKey = zrtpChannelContext->zrtpkeyi;
confirmMessageMacKey = zrtpChannelContext->mackeyi;
}
if (zrtpChannelContext->role == INITIATOR) { 
if ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {
return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
}
confirmMessageKey = zrtpChannelContext->zrtpkeyr;
confirmMessageMacKey = zrtpChannelContext->mackeyr;
}
messageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));
memcpy(messageData->confirm_mac, messageContent, 8);
messageContent +=8;
memcpy(messageData->CFBIV, messageContent, 16);
messageContent +=16;
cipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; 
zrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);
if (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { 
free(messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;
}
confirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));
zrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);
confirmPlainMessage = confirmPlainMessageBuffer; 
memcpy(messageData->H0, confirmPlainMessage, 32);
confirmPlainMessage +=33; 
if (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {
uint8_t checkH1[32];
bctoolbox_sha256(messageData->H0, 32, 32, checkH1);
if ( zrtpChannelContext->role == RESPONDER) {
uint8_t checkH2[32];
uint8_t checkMAC[32];
bzrtpCommitMessage_t *peerCommitMessageData;
if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
free (messageData);
return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
}
peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
bctoolbox_sha256(checkH1, 32, 32, checkH2);
if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
}
bctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
}
} else { 
uint8_t checkH2[32];
uint8_t checkH3[32];
uint8_t checkMAC[32];
bzrtpHelloMessage_t *peerHelloMessageData;
if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
free (messageData);
return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
}
peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
bctoolbox_sha256(checkH1, 32, 32, checkH2);
bctoolbox_sha256(checkH2, 32, 32, checkH3);
if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
}
bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
}
}
} else { 
uint8_t checkH1[32];
uint8_t checkMAC[32];
bzrtpDHPartMessage_t *peerDHPartMessageData;
if (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {
free (messageData);
return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
}
peerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;
bctoolbox_sha256(messageData->H0, 32, 32, checkH1);
if (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
}
bctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
if (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {
free (messageData);
return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
}
}
messageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);
confirmPlainMessage += 2;
messageData->E = ((*confirmPlainMessage)&0x08)>>3;
messageData->V = ((*confirmPlainMessage)&0x04)>>2;
messageData->A = ((*confirmPlainMessage)&0x02)>>1;
messageData->D = (*confirmPlainMessage)&0x01;
confirmPlainMessage += 1;
messageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);
confirmPlainMessage += 4;
if (messageData->sig_len>0) {
memcpy(messageData->signatureBlockType, confirmPlainMessage, 4);
confirmPlainMessage += 4;
messageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));
memcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));
} else {
messageData->signatureBlock  = NULL;
}
free(confirmPlainMessageBuffer);
zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
memcpy(zrtpPacket->packetString, input, inputLength); 
zrtpPacket->messageData = (void *)messageData;
}
break; 
case MSGTYPE_CONF2ACK:
break; 
case MSGTYPE_PING:
{
bzrtpPingMessage_t *messageData;
messageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));
memcpy(messageData->version, messageContent, 4);
messageContent +=4;
memcpy(messageData->endpointHash, messageContent, 8);
zrtpPacket->messageData = (void *)messageData;
}
break; 
}
return 0;
}","int bzrtp_packetParser(bzrtpContext_t *VAR_0, bzrtpChannelContext_t *VAR_1, const uint8_t * VAR_2, uint16_t VAR_3, bzrtpPacket_t *VAR_4) {
int VAR_5;
uint8_t *VAR_6 = (uint8_t *)(VAR_2+VAR_7+VAR_8);
switch (VAR_4->messageType) {
case VAR_9 : 
{
bzrtpHelloMessage_t *VAR_10;
VAR_10 = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));
memcpy(VAR_10->version, VAR_6, 4);
VAR_6 +=4;
memcpy(VAR_10->clientIdentifier, VAR_6, 16);
VAR_6 +=16;
memcpy(VAR_10->H3, VAR_6, 32);
VAR_6 +=32;
memcpy(VAR_10->ZID, VAR_6, 12);
VAR_6 +=12;
VAR_10->S = ((*VAR_6)>>6)&0x01;
VAR_10->M = ((*VAR_6)>>5)&0x01;
VAR_10->P = ((*VAR_6)>>4)&0x01;
VAR_6 +=1;
VAR_10->hc = MIN((*VAR_6)&0x0F, 7);
VAR_6 +=1;
VAR_10->cc = MIN(((*VAR_6)>>4)&0x0F, 7);
VAR_10->ac = MIN((*VAR_6)&0x0F, 7);
VAR_6 +=1;
VAR_10->kc = MIN(((*VAR_6)>>4)&0x0F, 7);
VAR_10->sc = MIN((*VAR_6)&0x0F, 7);
VAR_6 +=1;
if (VAR_4->messageLength != VAR_11 + 4*((uint16_t)(VAR_10->hc)+(uint16_t)(VAR_10->cc)+(uint16_t)(VAR_10->ac)+(uint16_t)(VAR_10->kc)+(uint16_t)(VAR_10->sc))) {
free(VAR_10);
return VAR_12;
}
for (VAR_5=0; VAR_5<VAR_10->hc; VAR_5++) {
VAR_10->supportedHash[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_13);
VAR_6 +=4;
}
for (VAR_5=0; VAR_5<VAR_10->cc; VAR_5++) {
VAR_10->supportedCipher[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_14);
VAR_6 +=4;
}
for (VAR_5=0; VAR_5<VAR_10->ac; VAR_5++) {
VAR_10->supportedAuthTag[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_15);
VAR_6 +=4;
}
for (VAR_5=0; VAR_5<VAR_10->kc; VAR_5++) {
VAR_10->supportedKeyAgreement[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_16);
VAR_6 +=4;
}
for (VAR_5=0; VAR_5<VAR_10->sc; VAR_5++) {
VAR_10->supportedSas[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_17);
VAR_6 +=4;
}
addMandatoryCryptoTypesIfNeeded(VAR_13, VAR_10->supportedHash, &VAR_10->hc);
addMandatoryCryptoTypesIfNeeded(VAR_14, VAR_10->supportedCipher, &VAR_10->cc);
addMandatoryCryptoTypesIfNeeded(VAR_15, VAR_10->supportedAuthTag, &VAR_10->ac);
addMandatoryCryptoTypesIfNeeded(VAR_16, VAR_10->supportedKeyAgreement, &VAR_10->kc);
addMandatoryCryptoTypesIfNeeded(VAR_17, VAR_10->supportedSas, &VAR_10->sc);
memcpy(VAR_10->MAC, VAR_6, 8);
VAR_4->messageData = (void *)VAR_10;
VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
memcpy(VAR_4->packetString, VAR_2, VAR_3); 
}
break; 
case VAR_18 :
{
if (VAR_4->messageLength != VAR_19) {
return VAR_12;
}
}
break; 
case VAR_20:
{
uint8_t VAR_21[32];
uint8_t VAR_22[32];
bzrtpHelloMessage_t *VAR_23;
uint16_t VAR_24 = 0;
bzrtpCommitMessage_t *VAR_10;
VAR_10 = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));
memcpy(VAR_10->H2, VAR_6, 32);
VAR_6 +=32;
if (VAR_1->peerPackets[VAR_25] == NULL) {
free (VAR_10);
return VAR_26;
}
VAR_23 = (bzrtpHelloMessage_t *)VAR_1->peerPackets[VAR_25]->messageData;
bctoolbox_sha256(VAR_10->H2, 32, 32, VAR_21);
if (memcmp(VAR_21, VAR_23->H3, 32) != 0) {
free (VAR_10);
return VAR_27;
}
bctoolbox_hmacSha256(VAR_10->H2, 32, VAR_1->peerPackets[VAR_25]->packetString+VAR_7, VAR_1->peerPackets[VAR_25]->messageLength-8, 8, VAR_22);
if (memcmp(VAR_22, VAR_23->MAC, 8) != 0) {
free (VAR_10);
return VAR_28;
}
memcpy(VAR_10->ZID, VAR_6, 12);
VAR_6 +=12;
VAR_10->hashAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_13);
VAR_6 += 4;
VAR_10->cipherAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_14);
VAR_6 += 4;
VAR_10->authTagAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_15);
VAR_6 += 4;
VAR_10->keyAgreementAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_16);
VAR_6 += 4;
switch(VAR_10->keyAgreementAlgo) {
case VAR_29 :
case VAR_30 :
case VAR_31 :
case VAR_32 :
case VAR_33 :
VAR_24 = 32; 
break;
case VAR_34 :
VAR_24 = 24; 
break;
case VAR_35 :
VAR_24 = 16; 
break;
default:
free(VAR_10);
return VAR_12;
}
if (VAR_4->messageLength != VAR_36 + VAR_24) {
free(VAR_10);
return VAR_12;
}
VAR_10->sasAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_17);
VAR_6 += 4;
if ((VAR_10->keyAgreementAlgo == VAR_34) || (VAR_10->keyAgreementAlgo == VAR_35)) {
memcpy(VAR_10->nonce, VAR_6, 16);
VAR_6 +=16;
if (VAR_10->keyAgreementAlgo == VAR_34) {
memcpy(VAR_10->keyID, VAR_6, 8);
VAR_6 +=8;
}
} else { 
memcpy(VAR_10->hvi, VAR_6, 32);
VAR_6 +=32;
}
memcpy(VAR_10->MAC, VAR_6, 8);
VAR_4->messageData = (void *)VAR_10;
VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
memcpy(VAR_4->packetString, VAR_2, VAR_3); 
}
break; 
case VAR_37 :
case VAR_38 :
{
bzrtpDHPartMessage_t *VAR_10;
uint16_t VAR_39 = computeKeyAgreementPrivateValueLength(VAR_1->keyAgreementAlgo);
if (VAR_39 == 0) {
return VAR_40;
}
if (VAR_4->messageLength != VAR_41+VAR_39) {
return VAR_12;
}
VAR_10 = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
VAR_10->pv = (uint8_t *)malloc(VAR_39*sizeof(uint8_t));
memcpy(VAR_10->H1, VAR_6, 32);
VAR_6 +=32;
if ( VAR_1->role == VAR_42) { 
uint8_t VAR_43[32];
uint8_t VAR_22[32];
bzrtpCommitMessage_t *VAR_44;
if (VAR_1->peerPackets[VAR_45] == NULL) {
free (VAR_10);
return VAR_26;
}
VAR_44 = (bzrtpCommitMessage_t *)VAR_1->peerPackets[VAR_45]->messageData;
bctoolbox_sha256(VAR_10->H1, 32, 32, VAR_43);
if (memcmp(VAR_43, VAR_44->H2, 32) != 0) {
free (VAR_10);
return VAR_27;
}
bctoolbox_hmacSha256(VAR_10->H1, 32, VAR_1->peerPackets[VAR_45]->packetString+VAR_7, VAR_1->peerPackets[VAR_45]->messageLength-8, 8, VAR_22);
if (memcmp(VAR_22, VAR_44->MAC, 8) != 0) {
free (VAR_10);
return VAR_28;
}
} else { 
uint8_t VAR_43[32];
uint8_t VAR_21[32];
uint8_t VAR_22[32];
bzrtpHelloMessage_t *VAR_23;
if (VAR_1->peerPackets[VAR_25] == NULL) {
free (VAR_10);
return VAR_26;
}
VAR_23 = (bzrtpHelloMessage_t *)VAR_1->peerPackets[VAR_25]->messageData;
bctoolbox_sha256(VAR_10->H1, 32, 32, VAR_43);
bctoolbox_sha256(VAR_43, 32, 32, VAR_21);
if (memcmp(VAR_21, VAR_23->H3, 32) != 0) {
free (VAR_10);
return VAR_27;
}
bctoolbox_hmacSha256(VAR_43, 32, VAR_1->peerPackets[VAR_25]->packetString+VAR_7, VAR_1->peerPackets[VAR_25]->messageLength-8, 8, VAR_22);
if (memcmp(VAR_22, VAR_23->MAC, 8) != 0) {
free (VAR_10);
return VAR_28;
}
}
memcpy(VAR_10->rs1ID, VAR_6, 8);
VAR_6 +=8;
memcpy(VAR_10->rs2ID, VAR_6, 8);
VAR_6 +=8;
memcpy(VAR_10->auxsecretID, VAR_6, 8);
VAR_6 +=8;
memcpy(VAR_10->pbxsecretID, VAR_6, 8);
VAR_6 +=8;
memcpy(VAR_10->pv, VAR_6, VAR_39);
VAR_6 +=VAR_39;
memcpy(VAR_10->MAC, VAR_6, 8);
VAR_4->messageData = (void *)VAR_10;
VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
memcpy(VAR_4->packetString, VAR_2, VAR_3); 
}
break; 
case VAR_46:
case VAR_47:
{
uint8_t *VAR_48 = NULL;
uint8_t *VAR_49 = NULL;
bzrtpConfirmMessage_t *VAR_10;
uint16_t VAR_50;
uint8_t VAR_51[8];
uint8_t *VAR_52;
uint8_t *VAR_53;
if (VAR_1->role == VAR_42) { 
if ((VAR_1->zrtpkeyi == NULL) || (VAR_1->mackeyi == NULL)) {
return VAR_40;
}
VAR_48 = VAR_1->zrtpkeyi;
VAR_49 = VAR_1->mackeyi;
}
if (VAR_1->role == VAR_54) { 
if ((VAR_1->zrtpkeyr == NULL) || (VAR_1->mackeyr == NULL)) {
return VAR_40;
}
VAR_48 = VAR_1->zrtpkeyr;
VAR_49 = VAR_1->mackeyr;
}
VAR_10 = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));
memcpy(VAR_10->confirm_mac, VAR_6, 8);
VAR_6 +=8;
memcpy(VAR_10->CFBIV, VAR_6, 16);
VAR_6 +=16;
VAR_50 = VAR_4->messageLength - VAR_8 - 24; 
VAR_1->hmacFunction(VAR_49, VAR_1->hashLength, VAR_6, VAR_50, 8, VAR_51);
if (memcmp(VAR_51, VAR_10->confirm_mac, 8) != 0) { 
free(VAR_10);
return VAR_55;
}
VAR_52 = (uint8_t *)malloc(VAR_50*sizeof(uint8_t));
VAR_1->cipherDecryptionFunction(VAR_48, VAR_10->CFBIV, VAR_6, VAR_50, VAR_52);
VAR_53 = VAR_52; 
memcpy(VAR_10->H0, VAR_53, 32);
VAR_53 +=33; 
if (VAR_1->keyAgreementAlgo == VAR_34 || VAR_1->keyAgreementAlgo == VAR_35) {
uint8_t VAR_56[32];
bctoolbox_sha256(VAR_10->H0, 32, 32, VAR_56);
if ( VAR_1->role == VAR_42) {
uint8_t VAR_43[32];
uint8_t VAR_22[32];
bzrtpCommitMessage_t *VAR_44;
if (VAR_1->peerPackets[VAR_45] == NULL) {
free (VAR_10);
return VAR_26;
}
VAR_44 = (bzrtpCommitMessage_t *)VAR_1->peerPackets[VAR_45]->messageData;
bctoolbox_sha256(VAR_56, 32, 32, VAR_43);
if (memcmp(VAR_43, VAR_44->H2, 32) != 0) {
free (VAR_10);
return VAR_27;
}
bctoolbox_hmacSha256(VAR_56, 32, VAR_1->peerPackets[VAR_45]->packetString+VAR_7, VAR_1->peerPackets[VAR_45]->messageLength-8, 8, VAR_22);
if (memcmp(VAR_22, VAR_44->MAC, 8) != 0) {
free (VAR_10);
return VAR_28;
}
} else { 
uint8_t VAR_43[32];
uint8_t VAR_21[32];
uint8_t VAR_22[32];
bzrtpHelloMessage_t *VAR_23;
if (VAR_1->peerPackets[VAR_25] == NULL) {
free (VAR_10);
return VAR_26;
}
VAR_23 = (bzrtpHelloMessage_t *)VAR_1->peerPackets[VAR_25]->messageData;
bctoolbox_sha256(VAR_56, 32, 32, VAR_43);
bctoolbox_sha256(VAR_43, 32, 32, VAR_21);
if (memcmp(VAR_21, VAR_23->H3, 32) != 0) {
free (VAR_10);
return VAR_27;
}
bctoolbox_hmacSha256(VAR_43, 32, VAR_1->peerPackets[VAR_25]->packetString+VAR_7, VAR_1->peerPackets[VAR_25]->messageLength-8, 8, VAR_22);
if (memcmp(VAR_22, VAR_23->MAC, 8) != 0) {
free (VAR_10);
return VAR_28;
}
}
} else { 
uint8_t VAR_56[32];
uint8_t VAR_22[32];
bzrtpDHPartMessage_t *VAR_57;
if (VAR_1->peerPackets[VAR_58] == NULL) {
free (VAR_10);
return VAR_26;
}
VAR_57 = (bzrtpDHPartMessage_t *)VAR_1->peerPackets[VAR_58]->messageData;
bctoolbox_sha256(VAR_10->H0, 32, 32, VAR_56);
if (memcmp(VAR_56, VAR_57->H1, 32) != 0) {
free (VAR_10);
return VAR_27;
}
bctoolbox_hmacSha256(VAR_10->H0, 32, VAR_1->peerPackets[VAR_58]->packetString+VAR_7, VAR_1->peerPackets[VAR_58]->messageLength-8, 8, VAR_22);
if (memcmp(VAR_22, VAR_57->MAC, 8) != 0) {
free (VAR_10);
return VAR_28;
}
}
VAR_10->sig_len = ((uint16_t)(VAR_53[0]&0x01))<<8 | (((uint16_t)VAR_53[1])&0x00FF);
VAR_53 += 2;
VAR_10->E = ((*VAR_53)&0x08)>>3;
VAR_10->V = ((*VAR_53)&0x04)>>2;
VAR_10->A = ((*VAR_53)&0x02)>>1;
VAR_10->D = (*VAR_53)&0x01;
VAR_53 += 1;
VAR_10->cacheExpirationInterval = (((uint32_t)VAR_53[0])<<24) | (((uint32_t)VAR_53[1])<<16) | (((uint32_t)VAR_53[2])<<8) | ((uint32_t)VAR_53[3]);
VAR_53 += 4;
if (VAR_10->sig_len>0) {
memcpy(VAR_10->signatureBlockType, VAR_53, 4);
VAR_53 += 4;
VAR_10->signatureBlock = (uint8_t *)malloc(4*(VAR_10->sig_len-1)*sizeof(uint8_t));
memcpy(VAR_10->signatureBlock, VAR_53, 4*(VAR_10->sig_len-1));
} else {
VAR_10->signatureBlock  = NULL;
}
free(VAR_52);
VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
memcpy(VAR_4->packetString, VAR_2, VAR_3); 
VAR_4->messageData = (void *)VAR_10;
}
break; 
case VAR_59:
break; 
case VAR_60:
{
bzrtpPingMessage_t *VAR_10;
VAR_10 = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));
memcpy(VAR_10->version, VAR_6, 4);
VAR_6 +=4;
memcpy(VAR_10->endpointHash, VAR_6, 8);
VAR_4->messageData = (void *)VAR_10;
}
break; 
}
return 0;
}",BelledonneCommunications/bzrtp/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/packetParser.c/vul/before/0.json,"int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {

	int i;

	/* now allocate and fill the correct message structure according to the message type */
	/* messageContent points to the begining of the ZRTP message */
	uint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);

	switch (zrtpPacket->messageType) {
		case MSGTYPE_HELLO : 
			{
				/* allocate a Hello message structure */
				bzrtpHelloMessage_t *messageData;
				messageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));

				/* fill it */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->clientIdentifier, messageContent, 16);
				messageContent +=16;
				memcpy(messageData->H3, messageContent, 32);
				messageContent +=32;
				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->S = ((*messageContent)>>6)&0x01;
				messageData->M = ((*messageContent)>>5)&0x01;
				messageData->P = ((*messageContent)>>4)&0x01;
				messageContent +=1;
				messageData->hc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->ac = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->sc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;

				/* Check message length according to value in hc, cc, ac, kc and sc */
				if (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* parse the variable length part: algorithms types */
				for (i=0; i<messageData->hc; i++) {
					messageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->cc; i++) {
					messageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->ac; i++) {
					messageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->kc; i++) {
					messageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->sc; i++) {
					messageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
					messageContent +=4;
				}

				addMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);
				addMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);

				memcpy(messageData->MAC, messageContent, 8);
				
				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_HELLO */

		case MSGTYPE_HELLOACK :
			{
				/* check message length */
				if (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}


			}
			break; /* MSGTYPE_HELLOACK */

		case MSGTYPE_COMMIT:
			{
				uint8_t checkH3[32];
				uint8_t checkMAC[32];
				bzrtpHelloMessage_t *peerHelloMessageData;
				uint16_t variableLength = 0;

				/* allocate a commit message structure */
				bzrtpCommitMessage_t *messageData;
				messageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));

				/* fill the structure */
				memcpy(messageData->H2, messageContent, 32);
				messageContent +=32;

				/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */
				if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
					free (messageData);
					/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */
					return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
				}
				peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
				/* Check H3 = SHA256(H2) */
				bctoolbox_sha256(messageData->H2, 32, 32, checkH3);
				if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
				}
				/* Check the hello MAC message. 
				 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
				bctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
				if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
				}

				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
				messageContent += 4;
				messageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
				messageContent += 4;
				messageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
				messageContent += 4;
				messageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
				messageContent += 4;
				/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */
				switch(messageData->keyAgreementAlgo) {
					case ZRTP_KEYAGREEMENT_DH2k :
					case ZRTP_KEYAGREEMENT_EC25 :
					case ZRTP_KEYAGREEMENT_DH3k :
					case ZRTP_KEYAGREEMENT_EC38 :
					case ZRTP_KEYAGREEMENT_EC52 :
						variableLength = 32; /* hvi is 32 bytes length in DH Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Prsh :
						variableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */
						break;
					case ZRTP_KEYAGREEMENT_Mult :
						variableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */
						break;
					default:
						free(messageData);
						return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				if (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}
				messageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
				messageContent += 4;

				/* if it is a multistream or preshared commit, get the 16 bytes nonce */
				if ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {
					memcpy(messageData->nonce, messageContent, 16);
					messageContent +=16;

					/* and the keyID for preshared commit only */
					if (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {
						memcpy(messageData->keyID, messageContent, 8);
						messageContent +=8;
					}
				} else { /* it's a DH commit message, get the hvi */
					memcpy(messageData->hvi, messageContent, 32);
					messageContent +=32;
				}

				/* get the MAC and attach the message data to the packet structure */
				memcpy(messageData->MAC, messageContent, 8);
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed commit packet must be saved as it is used to generate the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_COMMIT */
		case MSGTYPE_DHPART1 :
		case MSGTYPE_DHPART2 :
			{
				bzrtpDHPartMessage_t *messageData;

				/*check message length, depends on the selected key agreement algo set in zrtpContext */
				uint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);
				if (pvLength == 0) {
					return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
				}

				if (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				/* allocate a DHPart message structure and pv */
				messageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
				messageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));

				/* fill the structure */
				memcpy(messageData->H1, messageContent, 32);
				messageContent +=32;

				/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */
				if ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */
					uint8_t checkH2[32];
					uint8_t checkMAC[32];
					bzrtpCommitMessage_t *peerCommitMessageData;

					if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
					/* Check H2 = SHA256(H1) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the Commit MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}

					/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/
					/* First compute the expected hvi */
					/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */
					/* create a string with the messages concatenated */
					{
						uint8_t computedHvi[32];
						uint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;
						uint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;

						uint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));

						memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
						memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);

						zrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);

						free(DHPartHelloMessageString);

						/* Compare computed and received hvi */
						if (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHVI;
						}
					}

				} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
					uint8_t checkH2[32];
					uint8_t checkH3[32];
					uint8_t checkMAC[32];
					bzrtpHelloMessage_t *peerHelloMessageData;

					if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
					/* Check H3 = SHA256(SHA256(H1)) */
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					bctoolbox_sha256(checkH2, 32, 32, checkH3);
					if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the hello MAC message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}

				}

				memcpy(messageData->rs1ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->rs2ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->auxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pbxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pv, messageContent, pvLength);
				messageContent +=pvLength;
				memcpy(messageData->MAC, messageContent, 8);

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;

				/* the parsed packet must be saved as it is used to generate the total_hash */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
			}
			break; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */
		case MSGTYPE_CONFIRM1:
		case MSGTYPE_CONFIRM2:
			{
				uint8_t *confirmMessageKey = NULL;
				uint8_t *confirmMessageMacKey = NULL;
				bzrtpConfirmMessage_t *messageData;
				uint16_t cipherTextLength;
				uint8_t computedHmac[8];
				uint8_t *confirmPlainMessageBuffer;
				uint8_t *confirmPlainMessage;

				/* we shall first decrypt and validate the message, check we have the keys to do it */
				if (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyi;
					confirmMessageMacKey = zrtpChannelContext->mackeyi;
				}

				if (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */
					if ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyr;
					confirmMessageMacKey = zrtpChannelContext->mackeyr;
				}
				
				/* allocate a confirm message structure */
				messageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));

				/* get the mac and the IV */
				memcpy(messageData->confirm_mac, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->CFBIV, messageContent, 16);
				messageContent +=16;


				
				/* get the cipher text length */
				cipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */

				/* validate the mac over the cipher text */
				zrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);
				
				if (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */
					free(messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;
				}

				/* get plain message */
				confirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));
				zrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);
				confirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */

				/* parse it */
				memcpy(messageData->H0, confirmPlainMessage, 32);
				confirmPlainMessage +=33; /* +33 because next 8 bits are unused */

				/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */
				if (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {
					/* compute the H1=SHA256(H0) we never received */
					uint8_t checkH1[32];
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);

					/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */
					if ( zrtpChannelContext->role == RESPONDER) {
						uint8_t checkH2[32];
						uint8_t checkMAC[32];
						bzrtpCommitMessage_t *peerCommitMessageData;

						if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
						/* Check H2 = SHA256(H1) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the Commit MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
					} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
						uint8_t checkH2[32];
						uint8_t checkH3[32];
						uint8_t checkMAC[32];
						bzrtpHelloMessage_t *peerHelloMessageData;

						if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
						/* Check H3 = SHA256(SHA256(H1)) */
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						bctoolbox_sha256(checkH2, 32, 32, checkH3);
						if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						/* Check the hello MAC message. 
						 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
						bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
	
					}
				} else { /* we are in DHM mode */
					/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */
					uint8_t checkH1[32];
					uint8_t checkMAC[32];
					bzrtpDHPartMessage_t *peerDHPartMessageData;

					if (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;
					/* Check H1 = SHA256(H0) */
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);
					if (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					/* Check the DHPart message. 
					 * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */
					bctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}
				}

				messageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);
				confirmPlainMessage += 2;
				messageData->E = ((*confirmPlainMessage)&0x08)>>3;
				messageData->V = ((*confirmPlainMessage)&0x04)>>2;
				messageData->A = ((*confirmPlainMessage)&0x02)>>1;
				messageData->D = (*confirmPlainMessage)&0x01;
				confirmPlainMessage += 1;

				messageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);
				confirmPlainMessage += 4;


				/* if sig_len indicate a signature, parse it */
				if (messageData->sig_len>0) {
					memcpy(messageData->signatureBlockType, confirmPlainMessage, 4);
					confirmPlainMessage += 4;
					/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */
					messageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));
					memcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));
				} else {
					messageData->signatureBlock  = NULL;
				}

				/* free plain buffer */
				free(confirmPlainMessageBuffer);

				/* the parsed commit packet must be saved as it is used to check correct packet repetition */
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */

		case MSGTYPE_CONF2ACK:
			/* nothing to do for this one */
			break; /* MSGTYPE_CONF2ACK */
		
		case MSGTYPE_PING:
			{
				/* allocate a ping message structure */
				bzrtpPingMessage_t *messageData;
				messageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));

				/* fill the structure */
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->endpointHash, messageContent, 8);

				/* attach the message structure to the packet one */
				zrtpPacket->messageData = (void *)messageData;
			}
			break; /* MSGTYPE_PING */

	}

	return 0;
}","int bzrtp_packetParser(bzrtpContext_t *VAR_0, bzrtpChannelContext_t *VAR_1, const uint8_t * VAR_2, uint16_t VAR_3, bzrtpPacket_t *VAR_4) {

	int VAR_5;

	/* COMMENT_0 */
	/* COMMENT_1 */
	uint8_t *VAR_6 = (uint8_t *)(VAR_2+VAR_7+VAR_8);

	switch (VAR_4->messageType) {
		case VAR_9 : 
			{
				/* COMMENT_2 */
				bzrtpHelloMessage_t *VAR_10;
				VAR_10 = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));

				/* COMMENT_3 */
				memcpy(VAR_10->version, VAR_6, 4);
				VAR_6 +=4;
				memcpy(VAR_10->clientIdentifier, VAR_6, 16);
				VAR_6 +=16;
				memcpy(VAR_10->H3, VAR_6, 32);
				VAR_6 +=32;
				memcpy(VAR_10->ZID, VAR_6, 12);
				VAR_6 +=12;
				VAR_10->S = ((*VAR_6)>>6)&0x01;
				VAR_10->M = ((*VAR_6)>>5)&0x01;
				VAR_10->P = ((*VAR_6)>>4)&0x01;
				VAR_6 +=1;
				VAR_10->hc = MIN((*VAR_6)&0x0F, 7);
				VAR_6 +=1;
				VAR_10->cc = MIN(((*VAR_6)>>4)&0x0F, 7);
				VAR_10->ac = MIN((*VAR_6)&0x0F, 7);
				VAR_6 +=1;
				VAR_10->kc = MIN(((*VAR_6)>>4)&0x0F, 7);
				VAR_10->sc = MIN((*VAR_6)&0x0F, 7);
				VAR_6 +=1;

				/* COMMENT_4 */
				if (VAR_4->messageLength != VAR_11 + 4*((uint16_t)(VAR_10->hc)+(uint16_t)(VAR_10->cc)+(uint16_t)(VAR_10->ac)+(uint16_t)(VAR_10->kc)+(uint16_t)(VAR_10->sc))) {
					free(VAR_10);
					return VAR_12;
				}

				/* COMMENT_5 */
				for (VAR_5=0; VAR_5<VAR_10->hc; VAR_5++) {
					VAR_10->supportedHash[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_13);
					VAR_6 +=4;
				}
				for (VAR_5=0; VAR_5<VAR_10->cc; VAR_5++) {
					VAR_10->supportedCipher[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_14);
					VAR_6 +=4;
				}
				for (VAR_5=0; VAR_5<VAR_10->ac; VAR_5++) {
					VAR_10->supportedAuthTag[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_15);
					VAR_6 +=4;
				}
				for (VAR_5=0; VAR_5<VAR_10->kc; VAR_5++) {
					VAR_10->supportedKeyAgreement[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_16);
					VAR_6 +=4;
				}
				for (VAR_5=0; VAR_5<VAR_10->sc; VAR_5++) {
					VAR_10->supportedSas[VAR_5] = cryptoAlgoTypeStringToInt(VAR_6, VAR_17);
					VAR_6 +=4;
				}

				addMandatoryCryptoTypesIfNeeded(VAR_13, VAR_10->supportedHash, &VAR_10->hc);
				addMandatoryCryptoTypesIfNeeded(VAR_14, VAR_10->supportedCipher, &VAR_10->cc);
				addMandatoryCryptoTypesIfNeeded(VAR_15, VAR_10->supportedAuthTag, &VAR_10->ac);
				addMandatoryCryptoTypesIfNeeded(VAR_16, VAR_10->supportedKeyAgreement, &VAR_10->kc);
				addMandatoryCryptoTypesIfNeeded(VAR_17, VAR_10->supportedSas, &VAR_10->sc);

				memcpy(VAR_10->MAC, VAR_6, 8);
				
				/* COMMENT_6 */
				VAR_4->messageData = (void *)VAR_10;

				/* COMMENT_7 */
				VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
				memcpy(VAR_4->packetString, VAR_2, VAR_3); /* COMMENT_8 */
			}
			break; /* COMMENT_9 */

		case VAR_18 :
			{
				/* COMMENT_10 */
				if (VAR_4->messageLength != VAR_19) {
					return VAR_12;
				}


			}
			break; /* COMMENT_11 */

		case VAR_20:
			{
				uint8_t VAR_21[32];
				uint8_t VAR_22[32];
				bzrtpHelloMessage_t *VAR_23;
				uint16_t VAR_24 = 0;

				/* COMMENT_12 */
				bzrtpCommitMessage_t *VAR_10;
				VAR_10 = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));

				/* COMMENT_13 */
				memcpy(VAR_10->H2, VAR_6, 32);
				VAR_6 +=32;

				/* COMMENT_14 */
				if (VAR_1->peerPackets[VAR_25] == NULL) {
					free (VAR_10);
					/* COMMENT_15 */
					return VAR_26;
				}
				VAR_23 = (bzrtpHelloMessage_t *)VAR_1->peerPackets[VAR_25]->messageData;
				/* COMMENT_16 */
				bctoolbox_sha256(VAR_10->H2, 32, 32, VAR_21);
				if (memcmp(VAR_21, VAR_23->H3, 32) != 0) {
					free (VAR_10);
					return VAR_27;
				}
				/* COMMENT_17 */
                                                                                                                                                   
				bctoolbox_hmacSha256(VAR_10->H2, 32, VAR_1->peerPackets[VAR_25]->packetString+VAR_7, VAR_1->peerPackets[VAR_25]->messageLength-8, 8, VAR_22);
				if (memcmp(VAR_22, VAR_23->MAC, 8) != 0) {
					free (VAR_10);
					return VAR_28;
				}

				memcpy(VAR_10->ZID, VAR_6, 12);
				VAR_6 +=12;
				VAR_10->hashAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_13);
				VAR_6 += 4;
				VAR_10->cipherAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_14);
				VAR_6 += 4;
				VAR_10->authTagAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_15);
				VAR_6 += 4;
				VAR_10->keyAgreementAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_16);
				VAR_6 += 4;
				/* COMMENT_19 */
				switch(VAR_10->keyAgreementAlgo) {
					case VAR_29 :
					case VAR_30 :
					case VAR_31 :
					case VAR_32 :
					case VAR_33 :
						VAR_24 = 32; /* COMMENT_20 */
						break;
					case VAR_34 :
						VAR_24 = 24; /* COMMENT_21 */
						break;
					case VAR_35 :
						VAR_24 = 16; /* COMMENT_22 */
						break;
					default:
						free(VAR_10);
						return VAR_12;
				}

				if (VAR_4->messageLength != VAR_36 + VAR_24) {
					free(VAR_10);
					return VAR_12;
				}
				VAR_10->sasAlgo = cryptoAlgoTypeStringToInt(VAR_6, VAR_17);
				VAR_6 += 4;

				/* COMMENT_23 */
				if ((VAR_10->keyAgreementAlgo == VAR_34) || (VAR_10->keyAgreementAlgo == VAR_35)) {
					memcpy(VAR_10->nonce, VAR_6, 16);
					VAR_6 +=16;

					/* COMMENT_24 */
					if (VAR_10->keyAgreementAlgo == VAR_34) {
						memcpy(VAR_10->keyID, VAR_6, 8);
						VAR_6 +=8;
					}
				} else { /* COMMENT_25 */
					memcpy(VAR_10->hvi, VAR_6, 32);
					VAR_6 +=32;
				}

				/* COMMENT_26 */
				memcpy(VAR_10->MAC, VAR_6, 8);
				VAR_4->messageData = (void *)VAR_10;

				/* COMMENT_27 */
				VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
				memcpy(VAR_4->packetString, VAR_2, VAR_3); /* COMMENT_8 */
			}
			break; /* COMMENT_28 */
		case VAR_37 :
		case VAR_38 :
			{
				bzrtpDHPartMessage_t *VAR_10;

				/* COMMENT_29 */
				uint16_t VAR_39 = computeKeyAgreementPrivateValueLength(VAR_1->keyAgreementAlgo);
				if (VAR_39 == 0) {
					return VAR_40;
				}

				if (VAR_4->messageLength != VAR_41+VAR_39) {
					return VAR_12;
				}

				/* COMMENT_30 */
				VAR_10 = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
				VAR_10->pv = (uint8_t *)malloc(VAR_39*sizeof(uint8_t));

				/* COMMENT_13 */
				memcpy(VAR_10->H1, VAR_6, 32);
				VAR_6 +=32;

				/* COMMENT_31 */
				if ( VAR_1->role == VAR_42) { /* COMMENT_32 */
					uint8_t VAR_43[32];
					uint8_t VAR_22[32];
					bzrtpCommitMessage_t *VAR_44;

					if (VAR_1->peerPackets[VAR_45] == NULL) {
						free (VAR_10);
						/* COMMENT_33 */
						return VAR_26;
					}
					VAR_44 = (bzrtpCommitMessage_t *)VAR_1->peerPackets[VAR_45]->messageData;
					/* COMMENT_34 */
					bctoolbox_sha256(VAR_10->H1, 32, 32, VAR_43);
					if (memcmp(VAR_43, VAR_44->H2, 32) != 0) {
						free (VAR_10);
						return VAR_27;
					}
					/* COMMENT_35 */
                                                                                                                                                    
					bctoolbox_hmacSha256(VAR_10->H1, 32, VAR_1->peerPackets[VAR_45]->packetString+VAR_7, VAR_1->peerPackets[VAR_45]->messageLength-8, 8, VAR_22);
					if (memcmp(VAR_22, VAR_44->MAC, 8) != 0) {
						free (VAR_10);
						return VAR_28;
					}

					/* COMMENT_37 */
					/* COMMENT_38 */
					/* COMMENT_39 */
					/* COMMENT_40 */
					{
						uint8_t VAR_46[32];
						uint16_t VAR_47 = VAR_1->selfPackets[VAR_25]->messageLength;
						uint16_t VAR_48 = VAR_4->messageLength + VAR_47;

						uint8_t *VAR_49 = (uint8_t *)malloc(VAR_48*sizeof(uint8_t));

						memcpy(VAR_49, VAR_2+VAR_7, VAR_4->messageLength);
						memcpy(VAR_49+VAR_4->messageLength, VAR_1->selfPackets[VAR_25]->packetString+VAR_7, VAR_47);

						VAR_1->hashFunction(VAR_49, VAR_48, 32, VAR_46);

						free(VAR_49);

						/* COMMENT_41 */
						if (memcmp(VAR_46, VAR_44->hvi, 32)!=0) {
							free (VAR_10);
							return VAR_50;
						}
					}

				} else { /* COMMENT_42 */
					uint8_t VAR_43[32];
					uint8_t VAR_21[32];
					uint8_t VAR_22[32];
					bzrtpHelloMessage_t *VAR_23;

					if (VAR_1->peerPackets[VAR_25] == NULL) {
						free (VAR_10);
						/* COMMENT_43 */
						return VAR_26;
					}
					VAR_23 = (bzrtpHelloMessage_t *)VAR_1->peerPackets[VAR_25]->messageData;
					/* COMMENT_44 */
					bctoolbox_sha256(VAR_10->H1, 32, 32, VAR_43);
					bctoolbox_sha256(VAR_43, 32, 32, VAR_21);
					if (memcmp(VAR_21, VAR_23->H3, 32) != 0) {
						free (VAR_10);
						return VAR_27;
					}
					/* COMMENT_45 */
                                                                                                                                                    
					bctoolbox_hmacSha256(VAR_43, 32, VAR_1->peerPackets[VAR_25]->packetString+VAR_7, VAR_1->peerPackets[VAR_25]->messageLength-8, 8, VAR_22);
					if (memcmp(VAR_22, VAR_23->MAC, 8) != 0) {
						free (VAR_10);
						return VAR_28;
					}

				}

				memcpy(VAR_10->rs1ID, VAR_6, 8);
				VAR_6 +=8;
				memcpy(VAR_10->rs2ID, VAR_6, 8);
				VAR_6 +=8;
				memcpy(VAR_10->auxsecretID, VAR_6, 8);
				VAR_6 +=8;
				memcpy(VAR_10->pbxsecretID, VAR_6, 8);
				VAR_6 +=8;
				memcpy(VAR_10->pv, VAR_6, VAR_39);
				VAR_6 +=VAR_39;
				memcpy(VAR_10->MAC, VAR_6, 8);

				/* COMMENT_6 */
				VAR_4->messageData = (void *)VAR_10;

				/* COMMENT_47 */
				VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
				memcpy(VAR_4->packetString, VAR_2, VAR_3); /* COMMENT_8 */
			}
			break; /* COMMENT_48 */
		case VAR_51:
		case VAR_52:
			{
				uint8_t *VAR_53 = NULL;
				uint8_t *VAR_54 = NULL;
				bzrtpConfirmMessage_t *VAR_10;
				uint16_t VAR_55;
				uint8_t VAR_56[8];
				uint8_t *VAR_57;
				uint8_t *VAR_58;

				/* COMMENT_49 */
				if (VAR_1->role == VAR_42) { /* COMMENT_50 */
					if ((VAR_1->zrtpkeyi == NULL) || (VAR_1->mackeyi == NULL)) {
						return VAR_40;
					}
					VAR_53 = VAR_1->zrtpkeyi;
					VAR_54 = VAR_1->mackeyi;
				}

				if (VAR_1->role == VAR_59) { /* COMMENT_51 */
					if ((VAR_1->zrtpkeyr == NULL) || (VAR_1->mackeyr == NULL)) {
						return VAR_40;
					}
					VAR_53 = VAR_1->zrtpkeyr;
					VAR_54 = VAR_1->mackeyr;
				}
				
				/* COMMENT_52 */
				VAR_10 = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));

				/* COMMENT_53 */
				memcpy(VAR_10->confirm_mac, VAR_6, 8);
				VAR_6 +=8;
				memcpy(VAR_10->CFBIV, VAR_6, 16);
				VAR_6 +=16;


				
				/* COMMENT_54 */
				VAR_55 = VAR_4->messageLength - VAR_8 - 24; /* COMMENT_55 */

				/* COMMENT_56 */
				VAR_1->hmacFunction(VAR_54, VAR_1->hashLength, VAR_6, VAR_55, 8, VAR_56);
				
				if (memcmp(VAR_56, VAR_10->confirm_mac, 8) != 0) { /* COMMENT_57 */
					free(VAR_10);
					return VAR_60;
				}

				/* COMMENT_58 */
				VAR_57 = (uint8_t *)malloc(VAR_55*sizeof(uint8_t));
				VAR_1->cipherDecryptionFunction(VAR_53, VAR_10->CFBIV, VAR_6, VAR_55, VAR_57);
				VAR_58 = VAR_57; /* COMMENT_59 */

				/* COMMENT_60 */
				memcpy(VAR_10->H0, VAR_58, 32);
				VAR_58 +=33; /* COMMENT_61 */

				/* COMMENT_62 */
				if (VAR_1->keyAgreementAlgo == VAR_34 || VAR_1->keyAgreementAlgo == VAR_35) {
					/* COMMENT_63 */
					uint8_t VAR_61[32];
					bctoolbox_sha256(VAR_10->H0, 32, 32, VAR_61);

					/* COMMENT_64 */
					if ( VAR_1->role == VAR_42) {
						uint8_t VAR_43[32];
						uint8_t VAR_22[32];
						bzrtpCommitMessage_t *VAR_44;

						if (VAR_1->peerPackets[VAR_45] == NULL) {
							free (VAR_10);
							/* COMMENT_65 */
							return VAR_26;
						}
						VAR_44 = (bzrtpCommitMessage_t *)VAR_1->peerPackets[VAR_45]->messageData;
						/* COMMENT_34 */
						bctoolbox_sha256(VAR_61, 32, 32, VAR_43);
						if (memcmp(VAR_43, VAR_44->H2, 32) != 0) {
							free (VAR_10);
							return VAR_27;
						}
						/* COMMENT_66 */
                                                                                                                                                     
						bctoolbox_hmacSha256(VAR_61, 32, VAR_1->peerPackets[VAR_45]->packetString+VAR_7, VAR_1->peerPackets[VAR_45]->messageLength-8, 8, VAR_22);
						if (memcmp(VAR_22, VAR_44->MAC, 8) != 0) {
							free (VAR_10);
							return VAR_28;
						}
					} else { /* COMMENT_42 */
						uint8_t VAR_43[32];
						uint8_t VAR_21[32];
						uint8_t VAR_22[32];
						bzrtpHelloMessage_t *VAR_23;

						if (VAR_1->peerPackets[VAR_25] == NULL) {
							free (VAR_10);
							/* COMMENT_68 */
							return VAR_26;
						}
						VAR_23 = (bzrtpHelloMessage_t *)VAR_1->peerPackets[VAR_25]->messageData;
						/* COMMENT_44 */
						bctoolbox_sha256(VAR_61, 32, 32, VAR_43);
						bctoolbox_sha256(VAR_43, 32, 32, VAR_21);
						if (memcmp(VAR_21, VAR_23->H3, 32) != 0) {
							free (VAR_10);
							return VAR_27;
						}
						/* COMMENT_69 */
                                                                                                                                                     
						bctoolbox_hmacSha256(VAR_43, 32, VAR_1->peerPackets[VAR_25]->packetString+VAR_7, VAR_1->peerPackets[VAR_25]->messageLength-8, 8, VAR_22);
						if (memcmp(VAR_22, VAR_23->MAC, 8) != 0) {
							free (VAR_10);
							return VAR_28;
						}
	
					}
				} else { /* COMMENT_71 */
					/* COMMENT_72 */
					uint8_t VAR_61[32];
					uint8_t VAR_22[32];
					bzrtpDHPartMessage_t *VAR_62;

					if (VAR_1->peerPackets[VAR_63] == NULL) {
						free (VAR_10);
						/* COMMENT_73 */
						return VAR_26;
					}
					VAR_62 = (bzrtpDHPartMessage_t *)VAR_1->peerPackets[VAR_63]->messageData;
					/* COMMENT_74 */
					bctoolbox_sha256(VAR_10->H0, 32, 32, VAR_61);
					if (memcmp(VAR_61, VAR_62->H1, 32) != 0) {
						free (VAR_10);
						return VAR_27;
					}
					/* COMMENT_75 */
                                                                                                                                                    
					bctoolbox_hmacSha256(VAR_10->H0, 32, VAR_1->peerPackets[VAR_63]->packetString+VAR_7, VAR_1->peerPackets[VAR_63]->messageLength-8, 8, VAR_22);
					if (memcmp(VAR_22, VAR_62->MAC, 8) != 0) {
						free (VAR_10);
						return VAR_28;
					}
				}

				VAR_10->sig_len = ((uint16_t)(VAR_58[0]&0x01))<<8 | (((uint16_t)VAR_58[1])&0x00FF);
				VAR_58 += 2;
				VAR_10->E = ((*VAR_58)&0x08)>>3;
				VAR_10->V = ((*VAR_58)&0x04)>>2;
				VAR_10->A = ((*VAR_58)&0x02)>>1;
				VAR_10->D = (*VAR_58)&0x01;
				VAR_58 += 1;

				VAR_10->cacheExpirationInterval = (((uint32_t)VAR_58[0])<<24) | (((uint32_t)VAR_58[1])<<16) | (((uint32_t)VAR_58[2])<<8) | ((uint32_t)VAR_58[3]);
				VAR_58 += 4;


				/* COMMENT_77 */
				if (VAR_10->sig_len>0) {
					memcpy(VAR_10->signatureBlockType, VAR_58, 4);
					VAR_58 += 4;
					/* COMMENT_78 */
					VAR_10->signatureBlock = (uint8_t *)malloc(4*(VAR_10->sig_len-1)*sizeof(uint8_t));
					memcpy(VAR_10->signatureBlock, VAR_58, 4*(VAR_10->sig_len-1));
				} else {
					VAR_10->signatureBlock  = NULL;
				}

				/* COMMENT_79 */
				free(VAR_57);

				/* COMMENT_80 */
				VAR_4->packetString = (uint8_t *)malloc(VAR_3*sizeof(uint8_t));
				memcpy(VAR_4->packetString, VAR_2, VAR_3); /* COMMENT_8 */

				/* COMMENT_6 */
				VAR_4->messageData = (void *)VAR_10;
			}
			break; /* COMMENT_81 */

		case VAR_64:
			/* COMMENT_82 */
			break; /* COMMENT_83 */
		
		case VAR_65:
			{
				/* COMMENT_84 */
				bzrtpPingMessage_t *VAR_10;
				VAR_10 = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));

				/* COMMENT_13 */
				memcpy(VAR_10->version, VAR_6, 4);
				VAR_6 +=4;
				memcpy(VAR_10->endpointHash, VAR_6, 8);

				/* COMMENT_6 */
				VAR_4->messageData = (void *)VAR_10;
			}
			break; /* COMMENT_85 */

	}

	return 0;
}",BelledonneCommunications/bzrtp/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b/packetParser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -236,6 +236,32 @@
 						free (messageData);
 						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
 					}
+
+					/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/
+					/* First compute the expected hvi */
+					/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */
+					/* create a string with the messages concatenated */
+					{
+						uint8_t computedHvi[32];
+						uint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;
+						uint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;
+
+						uint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));
+
+						memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
+						memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);
+
+						zrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);
+
+						free(DHPartHelloMessageString);
+
+						/* Compare computed and received hvi */
+						if (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {
+							free (messageData);
+							return BZRTP_PARSER_ERROR_UNMATCHINGHVI;
+						}
+					}
+
 				} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */
 					uint8_t checkH2[32];
 					uint8_t checkH3[32];
@@ -280,7 +306,7 @@
 				/* attach the message structure to the packet one */
 				zrtpPacket->messageData = (void *)messageData;
 
-				/* the parsed commit packet must be saved as it is used to generate the total_hash */
+				/* the parsed packet must be saved as it is used to generate the total_hash */
 				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
 				memcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */
 			}","{'deleted_lines': ['\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */'], 'added_lines': ['', '\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/', '\t\t\t\t\t/* First compute the expected hvi */', ""\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */"", '\t\t\t\t\t/* create a string with the messages concatenated */', '\t\t\t\t\t{', '\t\t\t\t\t\tuint8_t computedHvi[32];', '\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;', '\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;', '', '\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));', '', '\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);', '\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);', '', '\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);', '', '\t\t\t\t\t\tfree(DHPartHelloMessageString);', '', '\t\t\t\t\t\t/* Compare computed and received hvi */', '\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {', '\t\t\t\t\t\t\tfree (messageData);', '\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;', '\t\t\t\t\t\t}', '\t\t\t\t\t}', '', '\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */']}",True,The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.,7.5,HIGH,2,valid,2016-03-31T15:42:30Z,1
CVE-2016-3136,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"USB: mct_u232: add sanity checking in probe

An attack using the lack of sanity checking in probe is known. This
patch checks for the existence of a second port.

CVE-2016-3136

Signed-off-by: Oliver Neukum <ONeukum@suse.com>
CC: stable@vger.kernel.org
[johan: add error message ]
Signed-off-by: Johan Hovold <johan@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",4e9a0b05257f29cf4b75f3209243ed71614d062e,https://github.com/torvalds/linux/commit/4e9a0b05257f29cf4b75f3209243ed71614d062e,drivers/usb/serial/mct_u232.c,mct_u232_port_probe,"static int mct_u232_port_probe(struct usb_serial_port *port)
{
struct mct_u232_private *priv;
priv = kzalloc(sizeof(*priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;
priv->read_urb = port->serial->port[1]->interrupt_in_urb;
priv->read_urb->context = port;
spin_lock_init(&priv->lock);
usb_set_serial_port_data(port, priv);
return 0;
}","static int mct_u232_port_probe(struct usb_serial_port *VAR_0)
{
struct mct_u232_private *VAR_1;
VAR_1 = kzalloc(sizeof(*VAR_1), VAR_2);
if (!VAR_1)
return -VAR_3;
VAR_1->read_urb = VAR_0->serial->port[1]->interrupt_in_urb;
VAR_1->read_urb->context = VAR_0;
spin_lock_init(&VAR_1->lock);
usb_set_serial_port_data(VAR_0, VAR_1);
return 0;
}",torvalds/linux/4e9a0b05257f29cf4b75f3209243ed71614d062e/mct_u232.c/vul/before/0.json,"static int mct_u232_port_probe(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct mct_u232_private *priv;

	/* check first to simplify error handling */
	if (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {
		dev_err(&port->dev, ""expected endpoint missing\n"");
		return -ENODEV;
	}

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	/* Use second interrupt-in endpoint for reading. */
	priv->read_urb = serial->port[1]->interrupt_in_urb;
	priv->read_urb->context = port;

	spin_lock_init(&priv->lock);

	usb_set_serial_port_data(port, priv);

	return 0;
}","static int mct_u232_port_probe(struct usb_serial_port *VAR_0)
{
	struct usb_serial *VAR_1 = VAR_0->serial;
	struct mct_u232_private *VAR_2;

	/* COMMENT_0 */
	if (!VAR_1->port[1] || !VAR_1->port[1]->interrupt_in_urb) {
		dev_err(&VAR_0->dev, ""expected endpoint missing\n"");
		return -VAR_3;
	}

	VAR_2 = kzalloc(sizeof(*VAR_2), VAR_4);
	if (!VAR_2)
		return -VAR_5;

	/* COMMENT_1 */
	VAR_2->read_urb = VAR_1->port[1]->interrupt_in_urb;
	VAR_2->read_urb->context = VAR_0;

	spin_lock_init(&VAR_2->lock);

	usb_set_serial_port_data(VAR_0, VAR_2);

	return 0;
}",torvalds/linux/4e9a0b05257f29cf4b75f3209243ed71614d062e/mct_u232.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,13 +1,20 @@
 static int mct_u232_port_probe(struct usb_serial_port *port)
 {
+	struct usb_serial *serial = port->serial;
 	struct mct_u232_private *priv;
+
+	/* check first to simplify error handling */
+	if (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {
+		dev_err(&port->dev, ""expected endpoint missing\n"");
+		return -ENODEV;
+	}
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
 	/* Use second interrupt-in endpoint for reading. */
-	priv->read_urb = port->serial->port[1]->interrupt_in_urb;
+	priv->read_urb = serial->port[1]->interrupt_in_urb;
 	priv->read_urb->context = port;
 
 	spin_lock_init(&priv->lock);","{'deleted_lines': ['\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;'], 'added_lines': ['\tstruct usb_serial *serial = port->serial;', '', '\t/* check first to simplify error handling */', '\tif (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {', '\t\tdev_err(&port->dev, ""expected endpoint missing\\n"");', '\t\treturn -ENODEV;', '\t}', '\tpriv->read_urb = serial->port[1]->interrupt_in_urb;']}",True,The mct_u232_msr_to_state function in drivers/usb/serial/mct_u232.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted USB device without two interrupt-in endpoint descriptors.,4.6,MEDIUM,1,valid,2016-03-31T16:04:24Z,1
CVE-2016-3137,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"USB: cypress_m8: add endpoint sanity check

An attack using missing endpoints exists.

CVE-2016-3137

Signed-off-by: Oliver Neukum <ONeukum@suse.com>
CC: stable@vger.kernel.org
Signed-off-by: Johan Hovold <johan@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,https://github.com/torvalds/linux/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,drivers/usb/serial/cypress_m8.c,cypress_open,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
struct cypress_private *priv = usb_get_serial_port_data(port);
struct usb_serial *serial = port->serial;
unsigned long flags;
int result = 0;
if (!priv->comm_is_ok)
return -EIO;
usb_clear_halt(serial->dev, 0x81);
usb_clear_halt(serial->dev, 0x02);
spin_lock_irqsave(&priv->lock, flags);
priv->bytes_in = 0;
priv->bytes_out = 0;
priv->cmd_count = 0;
priv->rx_flags = 0;
spin_unlock_irqrestore(&priv->lock, flags);
cypress_send(port);
if (tty)
cypress_set_termios(tty, port, &priv->tmp_termios);
if (!port->interrupt_in_urb) {
dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
__func__);
return -1;
}
usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
port->interrupt_in_urb->transfer_buffer,
port->interrupt_in_urb->transfer_buffer_length,
cypress_read_int_callback, port, priv->read_urb_interval);
result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
if (result) {
dev_err(&port->dev,
""%s - failed submitting read urb, error %d\n"",
__func__, result);
cypress_set_dead(port);
}
return result;
}","static int cypress_open(struct tty_struct *VAR_0, struct usb_serial_port *VAR_1)
{
struct cypress_private *VAR_2 = usb_get_serial_port_data(VAR_1);
struct usb_serial *VAR_3 = VAR_1->serial;
unsigned long VAR_4;
int VAR_5 = 0;
if (!VAR_2->comm_is_ok)
return -VAR_6;
usb_clear_halt(VAR_3->dev, 0x81);
usb_clear_halt(VAR_3->dev, 0x02);
spin_lock_irqsave(&VAR_2->lock, VAR_4);
VAR_2->bytes_in = 0;
VAR_2->bytes_out = 0;
VAR_2->cmd_count = 0;
VAR_2->rx_flags = 0;
spin_unlock_irqrestore(&VAR_2->lock, VAR_4);
cypress_send(VAR_1);
if (VAR_0)
cypress_set_termios(VAR_0, VAR_1, &VAR_2->tmp_termios);
if (!VAR_1->interrupt_in_urb) {
dev_err(&VAR_1->dev, ""%s - interrupt_in_urb is empty!\n"",
VAR_7);
return -1;
}
usb_fill_int_urb(VAR_1->interrupt_in_urb, VAR_3->dev,
usb_rcvintpipe(VAR_3->dev, VAR_1->interrupt_in_endpointAddress),
VAR_1->interrupt_in_urb->transfer_buffer,
VAR_1->interrupt_in_urb->transfer_buffer_length,
VAR_8, VAR_1, VAR_2->read_urb_interval);
VAR_5 = usb_submit_urb(VAR_1->interrupt_in_urb, VAR_9);
if (VAR_5) {
dev_err(&VAR_1->dev,
""%s - failed submitting read urb, error %d\n"",
VAR_7, VAR_5);
cypress_set_dead(VAR_1);
}
return VAR_5;
}",torvalds/linux/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754/cypress_m8.c/vul/before/0.json,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;

	if (!priv->comm_is_ok)
		return -EIO;

	/* clear halts before open */
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);

	spin_lock_irqsave(&priv->lock, flags);
	/* reset read/write statistics */
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);

	/* Set termios */
	cypress_send(port);

	if (tty)
		cypress_set_termios(tty, port, &priv->tmp_termios);

	/* setup the port and start reading from the device */
	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);

	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}

	return result;
}","static int cypress_open(struct tty_struct *VAR_0, struct usb_serial_port *VAR_1)
{
	struct cypress_private *VAR_2 = usb_get_serial_port_data(VAR_1);
	struct usb_serial *VAR_3 = VAR_1->serial;
	unsigned long VAR_4;
	int VAR_5 = 0;

	if (!VAR_2->comm_is_ok)
		return -VAR_6;

	/* COMMENT_0 */
	usb_clear_halt(VAR_3->dev, 0x81);
	usb_clear_halt(VAR_3->dev, 0x02);

	spin_lock_irqsave(&VAR_2->lock, VAR_4);
	/* COMMENT_1 */
	VAR_2->bytes_in = 0;
	VAR_2->bytes_out = 0;
	VAR_2->cmd_count = 0;
	VAR_2->rx_flags = 0;
	spin_unlock_irqrestore(&VAR_2->lock, VAR_4);

	/* COMMENT_2 */
	cypress_send(VAR_1);

	if (VAR_0)
		cypress_set_termios(VAR_0, VAR_1, &VAR_2->tmp_termios);

	/* COMMENT_3 */
	usb_fill_int_urb(VAR_1->interrupt_in_urb, VAR_3->dev,
		usb_rcvintpipe(VAR_3->dev, VAR_1->interrupt_in_endpointAddress),
		VAR_1->interrupt_in_urb->transfer_buffer,
		VAR_1->interrupt_in_urb->transfer_buffer_length,
		VAR_7, VAR_1, VAR_2->read_urb_interval);
	VAR_5 = usb_submit_urb(VAR_1->interrupt_in_urb, VAR_8);

	if (VAR_5) {
		dev_err(&VAR_1->dev,
			""%s - failed submitting read urb, error %d\n"",
							VAR_9, VAR_5);
		cypress_set_dead(VAR_1);
	}

	return VAR_5;
}",torvalds/linux/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754/cypress_m8.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,12 +27,6 @@
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	/* setup the port and start reading from the device */
-	if (!port->interrupt_in_urb) {
-		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
-			__func__);
-		return -1;
-	}
-
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,","{'deleted_lines': ['\tif (!port->interrupt_in_urb) {', '\t\tdev_err(&port->dev, ""%s - interrupt_in_urb is empty!\\n"",', '\t\t\t__func__);', '\t\treturn -1;', '\t}', ''], 'added_lines': []}",True,"drivers/usb/serial/cypress_m8.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both an interrupt-in and an interrupt-out endpoint descriptor, related to the cypress_generic_port_probe and cypress_open functions.",4.6,MEDIUM,1,valid,2016-03-31T16:04:25Z,1
CVE-2016-3137,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"USB: cypress_m8: add endpoint sanity check

An attack using missing endpoints exists.

CVE-2016-3137

Signed-off-by: Oliver Neukum <ONeukum@suse.com>
CC: stable@vger.kernel.org
Signed-off-by: Johan Hovold <johan@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,https://github.com/torvalds/linux/commit/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754,drivers/usb/serial/cypress_m8.c,cypress_generic_port_probe,"static int cypress_generic_port_probe(struct usb_serial_port *port)
{
struct usb_serial *serial = port->serial;
struct cypress_private *priv;
priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
if (!priv)
return -ENOMEM;
priv->comm_is_ok = !0;
spin_lock_init(&priv->lock);
if (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {
kfree(priv);
return -ENOMEM;
}
if (!is_frwd(serial->dev))
usb_reset_configuration(serial->dev);
priv->cmd_ctrl = 0;
priv->line_control = 0;
priv->termios_initialized = 0;
priv->rx_flags = 0;
if (port->interrupt_out_size > 9)
priv->pkt_fmt = packet_format_1;
else
priv->pkt_fmt = packet_format_2;
if (interval > 0) {
priv->write_urb_interval = interval;
priv->read_urb_interval = interval;
dev_dbg(&port->dev, ""%s - read & write intervals forced to %d\n"",
__func__, interval);
} else {
priv->write_urb_interval = port->interrupt_out_urb->interval;
priv->read_urb_interval = port->interrupt_in_urb->interval;
dev_dbg(&port->dev, ""%s - intervals: read=%d write=%d\n"",
__func__, priv->read_urb_interval,
priv->write_urb_interval);
}
usb_set_serial_port_data(port, priv);
port->port.drain_delay = 256;
return 0;
}","static int cypress_generic_port_probe(struct usb_serial_port *VAR_0)
{
struct usb_serial *VAR_1 = VAR_0->serial;
struct cypress_private *VAR_2;
VAR_2 = kzalloc(sizeof(struct cypress_private), VAR_3);
if (!VAR_2)
return -VAR_4;
VAR_2->comm_is_ok = !0;
spin_lock_init(&VAR_2->lock);
if (kfifo_alloc(&VAR_2->write_fifo, VAR_5, VAR_3)) {
kfree(VAR_2);
return -VAR_4;
}
if (!is_frwd(VAR_1->dev))
usb_reset_configuration(VAR_1->dev);
VAR_2->cmd_ctrl = 0;
VAR_2->line_control = 0;
VAR_2->termios_initialized = 0;
VAR_2->rx_flags = 0;
if (VAR_0->interrupt_out_size > 9)
VAR_2->pkt_fmt = VAR_6;
else
VAR_2->pkt_fmt = VAR_7;
if (VAR_8 > 0) {
VAR_2->write_urb_interval = VAR_8;
VAR_2->read_urb_interval = VAR_8;
dev_dbg(&VAR_0->dev, ""%s - read & write intervals forced to %d\n"",
VAR_9, VAR_8);
} else {
VAR_2->write_urb_interval = VAR_0->interrupt_out_urb->interval;
VAR_2->read_urb_interval = VAR_0->interrupt_in_urb->interval;
dev_dbg(&VAR_0->dev, ""%s - intervals: read=%d write=%d\n"",
VAR_9, VAR_2->read_urb_interval,
VAR_2->write_urb_interval);
}
usb_set_serial_port_data(VAR_0, VAR_2);
VAR_0->port.drain_delay = 256;
return 0;
}",torvalds/linux/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754/cypress_m8.c/vul/before/1.json,"static int cypress_generic_port_probe(struct usb_serial_port *port)
{
	struct usb_serial *serial = port->serial;
	struct cypress_private *priv;

	if (!port->interrupt_out_urb || !port->interrupt_in_urb) {
		dev_err(&port->dev, ""required endpoint is missing\n"");
		return -ENODEV;
	}

	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	priv->comm_is_ok = !0;
	spin_lock_init(&priv->lock);
	if (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {
		kfree(priv);
		return -ENOMEM;
	}

	/* Skip reset for FRWD device. It is a workaound:
	   device hangs if it receives SET_CONFIGURE in Configured
	   state. */
	if (!is_frwd(serial->dev))
		usb_reset_configuration(serial->dev);

	priv->cmd_ctrl = 0;
	priv->line_control = 0;
	priv->termios_initialized = 0;
	priv->rx_flags = 0;
	/* Default packet format setting is determined by packet size.
	   Anything with a size larger then 9 must have a separate
	   count field since the 3 bit count field is otherwise too
	   small.  Otherwise we can use the slightly more compact
	   format.  This is in accordance with the cypress_m8 serial
	   converter app note. */
	if (port->interrupt_out_size > 9)
		priv->pkt_fmt = packet_format_1;
	else
		priv->pkt_fmt = packet_format_2;

	if (interval > 0) {
		priv->write_urb_interval = interval;
		priv->read_urb_interval = interval;
		dev_dbg(&port->dev, ""%s - read & write intervals forced to %d\n"",
			__func__, interval);
	} else {
		priv->write_urb_interval = port->interrupt_out_urb->interval;
		priv->read_urb_interval = port->interrupt_in_urb->interval;
		dev_dbg(&port->dev, ""%s - intervals: read=%d write=%d\n"",
			__func__, priv->read_urb_interval,
			priv->write_urb_interval);
	}
	usb_set_serial_port_data(port, priv);

	port->port.drain_delay = 256;

	return 0;
}","static int cypress_generic_port_probe(struct usb_serial_port *VAR_0)
{
	struct usb_serial *VAR_1 = VAR_0->serial;
	struct cypress_private *VAR_2;

	if (!VAR_0->interrupt_out_urb || !VAR_0->interrupt_in_urb) {
		dev_err(&VAR_0->dev, ""required endpoint is missing\n"");
		return -VAR_3;
	}

	VAR_2 = kzalloc(sizeof(struct cypress_private), VAR_4);
	if (!VAR_2)
		return -VAR_5;

	VAR_2->comm_is_ok = !0;
	spin_lock_init(&VAR_2->lock);
	if (kfifo_alloc(&VAR_2->write_fifo, VAR_6, VAR_4)) {
		kfree(VAR_2);
		return -VAR_5;
	}

	/* COMMENT_0 */
                                                           
             
	if (!is_frwd(VAR_1->dev))
		usb_reset_configuration(VAR_1->dev);

	VAR_2->cmd_ctrl = 0;
	VAR_2->line_control = 0;
	VAR_2->termios_initialized = 0;
	VAR_2->rx_flags = 0;
	/* COMMENT_3 */
                                                           
                                                            
                                                          
                                                             
                          
	if (VAR_0->interrupt_out_size > 9)
		VAR_2->pkt_fmt = VAR_7;
	else
		VAR_2->pkt_fmt = VAR_8;

	if (VAR_9 > 0) {
		VAR_2->write_urb_interval = VAR_9;
		VAR_2->read_urb_interval = VAR_9;
		dev_dbg(&VAR_0->dev, ""%s - read & write intervals forced to %d\n"",
			VAR_10, VAR_9);
	} else {
		VAR_2->write_urb_interval = VAR_0->interrupt_out_urb->interval;
		VAR_2->read_urb_interval = VAR_0->interrupt_in_urb->interval;
		dev_dbg(&VAR_0->dev, ""%s - intervals: read=%d write=%d\n"",
			VAR_10, VAR_2->read_urb_interval,
			VAR_2->write_urb_interval);
	}
	usb_set_serial_port_data(VAR_0, VAR_2);

	VAR_0->port.drain_delay = 256;

	return 0;
}",torvalds/linux/c55aee1bf0e6b6feec8b2927b43f7a09a6d5f754/cypress_m8.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,11 @@
 {
 	struct usb_serial *serial = port->serial;
 	struct cypress_private *priv;
+
+	if (!port->interrupt_out_urb || !port->interrupt_in_urb) {
+		dev_err(&port->dev, ""required endpoint is missing\n"");
+		return -ENODEV;
+	}
 
 	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
 	if (!priv)","{'deleted_lines': [], 'added_lines': ['', '\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {', '\t\tdev_err(&port->dev, ""required endpoint is missing\\n"");', '\t\treturn -ENODEV;', '\t}']}",True,"drivers/usb/serial/cypress_m8.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both an interrupt-in and an interrupt-out endpoint descriptor, related to the cypress_generic_port_probe and cypress_open functions.",4.6,MEDIUM,1,valid,2016-03-31T16:04:25Z,1
CVE-2016-1684,['CWE-Other'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,GNOME/libxslt,"Lower and upper bound for format token ""i""

Handle xsl:number with format ""i"" and value 0 according to XSLT 2.0.

Also introduce an upper bound to fix a denial of service.",91d0540ac9beaa86719a05b749219a69baa0dd8d,https://github.com/GNOME/libxslt/commit/91d0540ac9beaa86719a05b749219a69baa0dd8d,libxslt/numbers.c,xsltNumberFormatInsertNumbers,"static void
xsltNumberFormatInsertNumbers(xsltNumberDataPtr data,
double *numbers,
int numbers_max,
xsltFormatPtr tokens,
xmlBufferPtr buffer)
{
int i = 0;
double number;
xsltFormatTokenPtr token;
if (tokens->start != NULL)
xmlBufferCat(buffer, tokens->start);
for (i = 0; i < numbers_max; i++) {
number = numbers[(numbers_max - 1) - i];
number = floor(number + 0.5);
if (number < 0.0) {
xsltTransformError(NULL, NULL, NULL,
""xsl-number : negative value\n"");
number = 0.0;
}
if (i < tokens->nTokens) {
token = &(tokens->tokens[i]);
} else if (tokens->nTokens > 0) {
token = &(tokens->tokens[tokens->nTokens - 1]);
} else {
token = &default_token;
}
if (i > 0) {
if (token->separator != NULL)
xmlBufferCat(buffer, token->separator);
else
xmlBufferCCat(buffer, DEFAULT_SEPARATOR);
}
switch (xmlXPathIsInf(number)) {
case -1:
xmlBufferCCat(buffer, ""-Infinity"");
break;
case 1:
xmlBufferCCat(buffer, ""Infinity"");
break;
default:
if (xmlXPathIsNaN(number)) {
xmlBufferCCat(buffer, ""NaN"");
} else {
switch (token->token) {
case 'A':
xsltNumberFormatAlpha(data, buffer, number, TRUE);
break;
case 'a':
xsltNumberFormatAlpha(data, buffer, number, FALSE);
break;
case 'I':
xsltNumberFormatRoman(buffer,
number,
TRUE);
break;
case 'i':
xsltNumberFormatRoman(buffer,
number,
FALSE);
break;
default:
if (IS_DIGIT_ZERO(token->token)) {
xsltNumberFormatDecimal(buffer,
number,
token->token,
token->width,
data->digitsPerGroup,
data->groupingCharacter,
data->groupingCharacterLen);
}
break;
}
}
}
}
if (tokens->end != NULL)
xmlBufferCat(buffer, tokens->end);
}","static void
xsltNumberFormatInsertNumbers(xsltNumberDataPtr VAR_0,
double *VAR_1,
int VAR_2,
xsltFormatPtr VAR_3,
xmlBufferPtr VAR_4)
{
int VAR_5 = 0;
double VAR_6;
xsltFormatTokenPtr VAR_7;
if (VAR_3->start != NULL)
xmlBufferCat(VAR_4, VAR_3->start);
for (VAR_5 = 0; VAR_5 < VAR_2; VAR_5++) {
VAR_6 = VAR_1[(VAR_2 - 1) - VAR_5];
VAR_6 = floor(VAR_6 + 0.5);
if (VAR_6 < 0.0) {
xsltTransformError(NULL, NULL, NULL,
""xsl-number : negative value\n"");
VAR_6 = 0.0;
}
if (VAR_5 < VAR_3->nTokens) {
VAR_7 = &(VAR_3->tokens[VAR_5]);
} else if (VAR_3->nTokens > 0) {
VAR_7 = &(VAR_3->tokens[VAR_3->nTokens - 1]);
} else {
VAR_7 = &VAR_8;
}
if (VAR_5 > 0) {
if (VAR_7->separator != NULL)
xmlBufferCat(VAR_4, VAR_7->separator);
else
xmlBufferCCat(VAR_4, VAR_9);
}
switch (xmlXPathIsInf(VAR_6)) {
case -1:
xmlBufferCCat(VAR_4, ""-Infinity"");
break;
case 1:
xmlBufferCCat(VAR_4, ""Infinity"");
break;
default:
if (xmlXPathIsNaN(VAR_6)) {
xmlBufferCCat(VAR_4, ""NaN"");
} else {
switch (VAR_7->token) {
case 'A':
xsltNumberFormatAlpha(VAR_0, VAR_4, VAR_6, TRUE);
break;
case 'a':
xsltNumberFormatAlpha(VAR_0, VAR_4, VAR_6, FALSE);
break;
case 'I':
xsltNumberFormatRoman(VAR_4,
VAR_6,
TRUE);
break;
case 'i':
xsltNumberFormatRoman(VAR_4,
VAR_6,
FALSE);
break;
default:
if (IS_DIGIT_ZERO(VAR_7->token)) {
xsltNumberFormatDecimal(VAR_4,
VAR_6,
VAR_7->token,
VAR_7->width,
VAR_0->digitsPerGroup,
VAR_0->groupingCharacter,
VAR_0->groupingCharacterLen);
}
break;
}
}
}
}
if (VAR_3->end != NULL)
xmlBufferCat(VAR_4, VAR_3->end);
}",GNOME/libxslt/91d0540ac9beaa86719a05b749219a69baa0dd8d/numbers.c/vul/before/0.json,"static void
xsltNumberFormatInsertNumbers(xsltNumberDataPtr data,
			      double *numbers,
			      int numbers_max,
			      xsltFormatPtr tokens,
			      xmlBufferPtr buffer)
{
    int i = 0;
    double number;
    xsltFormatTokenPtr token;

    /*
     * Handle initial non-alphanumeric token
     */
    if (tokens->start != NULL)
	 xmlBufferCat(buffer, tokens->start);

    for (i = 0; i < numbers_max; i++) {
	/* Insert number */
	number = numbers[(numbers_max - 1) - i];
        /* Round to nearest like XSLT 2.0 */
        number = floor(number + 0.5);
        /*
         * XSLT 1.0 isn't clear on how to handle negative numbers, but XSLT
         * 2.0 says:
         *
         *     It is a non-recoverable dynamic error if any undiscarded item
         *     in the atomized sequence supplied as the value of the value
         *     attribute of xsl:number cannot be converted to an integer, or
         *     if the resulting integer is less than 0 (zero).
         */
        if (number < 0.0) {
            xsltTransformError(NULL, NULL, NULL,
                    ""xsl-number : negative value\n"");
            /* Recover by treating negative values as zero. */
            number = 0.0;
        }
	if (i < tokens->nTokens) {
	  /*
	   * The ""n""th format token will be used to format the ""n""th
	   * number in the list
	   */
	  token = &(tokens->tokens[i]);
	} else if (tokens->nTokens > 0) {
	  /*
	   * If there are more numbers than format tokens, then the
	   * last format token will be used to format the remaining
	   * numbers.
	   */
	  token = &(tokens->tokens[tokens->nTokens - 1]);
	} else {
	  /*
	   * If there are no format tokens, then a format token of
	   * 1 is used to format all numbers.
	   */
	  token = &default_token;
	}

	/* Print separator, except for the first number */
	if (i > 0) {
	    if (token->separator != NULL)
		xmlBufferCat(buffer, token->separator);
	    else
		xmlBufferCCat(buffer, DEFAULT_SEPARATOR);
	}

	switch (xmlXPathIsInf(number)) {
	case -1:
	    xmlBufferCCat(buffer, ""-Infinity"");
	    break;
	case 1:
	    xmlBufferCCat(buffer, ""Infinity"");
	    break;
	default:
	    if (xmlXPathIsNaN(number)) {
		xmlBufferCCat(buffer, ""NaN"");
	    } else {

		switch (token->token) {
		case 'A':
		    xsltNumberFormatAlpha(data, buffer, number, TRUE);
		    break;
		case 'a':
		    xsltNumberFormatAlpha(data, buffer, number, FALSE);
		    break;
		case 'I':
		    xsltNumberFormatRoman(data, buffer, number, TRUE);
		    break;
		case 'i':
		    xsltNumberFormatRoman(data, buffer, number, FALSE);
		    break;
		default:
		    if (IS_DIGIT_ZERO(token->token)) {
			xsltNumberFormatDecimal(buffer,
						number,
						token->token,
						token->width,
						data->digitsPerGroup,
						data->groupingCharacter,
						data->groupingCharacterLen);
		    }
		    break;
		}
	    }

	}
    }

    /*
     * Handle final non-alphanumeric token
     */
    if (tokens->end != NULL)
	 xmlBufferCat(buffer, tokens->end);

}","static void
xsltNumberFormatInsertNumbers(xsltNumberDataPtr VAR_0,
			      double *VAR_1,
			      int VAR_2,
			      xsltFormatPtr VAR_3,
			      xmlBufferPtr VAR_4)
{
    int VAR_5 = 0;
    double VAR_6;
    xsltFormatTokenPtr VAR_7;

    /* COMMENT_0 */
                                            
       
    if (VAR_3->start != NULL)
	 xmlBufferCat(VAR_4, VAR_3->start);

    for (VAR_5 = 0; VAR_5 < VAR_2; VAR_5++) {
	/* COMMENT_3 */
	VAR_6 = VAR_1[(VAR_2 - 1) - VAR_5];
        /* COMMENT_4 */
        VAR_6 = floor(VAR_6 + 0.5);
        /* COMMENT_5 */
                                                                           
                    
          
                                                                            
                                                                          
                                                                            
                                                              
           
        if (VAR_6 < 0.0) {
            xsltTransformError(NULL, NULL, NULL,
                    ""xsl-number : negative value\n"");
            /* COMMENT_14 */
            VAR_6 = 0.0;
        }
	if (VAR_5 < VAR_3->nTokens) {
	  /* COMMENT_15 */
                                                             
                        
      
	  VAR_7 = &(VAR_3->tokens[VAR_5]);
	} else if (VAR_3->nTokens > 0) {
	  /* COMMENT_19 */
                                                            
                                                            
              
      
	  VAR_7 = &(VAR_3->tokens[VAR_3->nTokens - 1]);
	} else {
	  /* COMMENT_24 */
                                                           
                                      
      
	  VAR_7 = &VAR_8;
	}

	/* COMMENT_28 */
	if (VAR_5 > 0) {
	    if (VAR_7->separator != NULL)
		xmlBufferCat(VAR_4, VAR_7->separator);
	    else
		xmlBufferCCat(VAR_4, VAR_9);
	}

	switch (xmlXPathIsInf(VAR_6)) {
	case -1:
	    xmlBufferCCat(VAR_4, ""-Infinity"");
	    break;
	case 1:
	    xmlBufferCCat(VAR_4, ""Infinity"");
	    break;
	default:
	    if (xmlXPathIsNaN(VAR_6)) {
		xmlBufferCCat(VAR_4, ""NaN"");
	    } else {

		switch (VAR_7->token) {
		case 'A':
		    xsltNumberFormatAlpha(VAR_0, VAR_4, VAR_6, TRUE);
		    break;
		case 'a':
		    xsltNumberFormatAlpha(VAR_0, VAR_4, VAR_6, FALSE);
		    break;
		case 'I':
		    xsltNumberFormatRoman(VAR_0, VAR_4, VAR_6, TRUE);
		    break;
		case 'i':
		    xsltNumberFormatRoman(VAR_0, VAR_4, VAR_6, FALSE);
		    break;
		default:
		    if (IS_DIGIT_ZERO(VAR_7->token)) {
			xsltNumberFormatDecimal(VAR_4,
						VAR_6,
						VAR_7->token,
						VAR_7->width,
						VAR_0->digitsPerGroup,
						VAR_0->groupingCharacter,
						VAR_0->groupingCharacterLen);
		    }
		    break;
		}
	    }

	}
    }

    /* COMMENT_29 */
                                          
       
    if (VAR_3->end != NULL)
	 xmlBufferCat(VAR_4, VAR_3->end);

}",GNOME/libxslt/91d0540ac9beaa86719a05b749219a69baa0dd8d/numbers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -84,16 +84,10 @@
 		    xsltNumberFormatAlpha(data, buffer, number, FALSE);
 		    break;
 		case 'I':
-		    xsltNumberFormatRoman(buffer,
-					  number,
-					  TRUE);
-
+		    xsltNumberFormatRoman(data, buffer, number, TRUE);
 		    break;
 		case 'i':
-		    xsltNumberFormatRoman(buffer,
-					  number,
-					  FALSE);
-
+		    xsltNumberFormatRoman(data, buffer, number, FALSE);
 		    break;
 		default:
 		    if (IS_DIGIT_ZERO(token->token)) {","{'deleted_lines': ['\t\t    xsltNumberFormatRoman(buffer,', '\t\t\t\t\t  number,', '\t\t\t\t\t  TRUE);', '', '\t\t    xsltNumberFormatRoman(buffer,', '\t\t\t\t\t  number,', '\t\t\t\t\t  FALSE);', ''], 'added_lines': ['\t\t    xsltNumberFormatRoman(data, buffer, number, TRUE);', '\t\t    xsltNumberFormatRoman(data, buffer, number, FALSE);']}",True,"numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles the i format token for xsl:number data, which allows remote attackers to cause a denial of service (integer overflow or resource consumption) or possibly have unspecified other impact via a crafted document.",7.5,HIGH,2,valid,2016-04-10T11:12:28Z,1
CVE-2016-1684,['CWE-Other'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,GNOME/libxslt,"Lower and upper bound for format token ""i""

Handle xsl:number with format ""i"" and value 0 according to XSLT 2.0.

Also introduce an upper bound to fix a denial of service.",91d0540ac9beaa86719a05b749219a69baa0dd8d,https://github.com/GNOME/libxslt/commit/91d0540ac9beaa86719a05b749219a69baa0dd8d,libxslt/numbers.c,xsltNumberFormatRoman,"static void
xsltNumberFormatRoman(xmlBufferPtr buffer,
double number,
int is_upper)
{
while (number >= 1000.0) {
xmlBufferCCat(buffer, (is_upper) ? ""M"" : ""m"");
number -= 1000.0;
}
if (number >= 900.0) {
xmlBufferCCat(buffer, (is_upper) ? ""CM"" : ""cm"");
number -= 900.0;
}
while (number >= 500.0) {
xmlBufferCCat(buffer, (is_upper) ? ""D"" : ""d"");
number -= 500.0;
}
if (number >= 400.0) {
xmlBufferCCat(buffer, (is_upper) ? ""CD"" : ""cd"");
number -= 400.0;
}
while (number >= 100.0) {
xmlBufferCCat(buffer, (is_upper) ? ""C"" : ""c"");
number -= 100.0;
}
if (number >= 90.0) {
xmlBufferCCat(buffer, (is_upper) ? ""XC"" : ""xc"");
number -= 90.0;
}
while (number >= 50.0) {
xmlBufferCCat(buffer, (is_upper) ? ""L"" : ""l"");
number -= 50.0;
}
if (number >= 40.0) {
xmlBufferCCat(buffer, (is_upper) ? ""XL"" : ""xl"");
number -= 40.0;
}
while (number >= 10.0) {
xmlBufferCCat(buffer, (is_upper) ? ""X"" : ""x"");
number -= 10.0;
}
if (number >= 9.0) {
xmlBufferCCat(buffer, (is_upper) ? ""IX"" : ""ix"");
number -= 9.0;
}
while (number >= 5.0) {
xmlBufferCCat(buffer, (is_upper) ? ""V"" : ""v"");
number -= 5.0;
}
if (number >= 4.0) {
xmlBufferCCat(buffer, (is_upper) ? ""IV"" : ""iv"");
number -= 4.0;
}
while (number >= 1.0) {
xmlBufferCCat(buffer, (is_upper) ? ""I"" : ""i"");
number--;
}
}","static void
xsltNumberFormatRoman(xmlBufferPtr VAR_0,
double VAR_1,
int VAR_2)
{
while (VAR_1 >= 1000.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""M"" : ""m"");
VAR_1 -= 1000.0;
}
if (VAR_1 >= 900.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""CM"" : ""cm"");
VAR_1 -= 900.0;
}
while (VAR_1 >= 500.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""D"" : ""d"");
VAR_1 -= 500.0;
}
if (VAR_1 >= 400.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""CD"" : ""cd"");
VAR_1 -= 400.0;
}
while (VAR_1 >= 100.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""C"" : ""c"");
VAR_1 -= 100.0;
}
if (VAR_1 >= 90.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""XC"" : ""xc"");
VAR_1 -= 90.0;
}
while (VAR_1 >= 50.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""L"" : ""l"");
VAR_1 -= 50.0;
}
if (VAR_1 >= 40.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""XL"" : ""xl"");
VAR_1 -= 40.0;
}
while (VAR_1 >= 10.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""X"" : ""x"");
VAR_1 -= 10.0;
}
if (VAR_1 >= 9.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""IX"" : ""ix"");
VAR_1 -= 9.0;
}
while (VAR_1 >= 5.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""V"" : ""v"");
VAR_1 -= 5.0;
}
if (VAR_1 >= 4.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""IV"" : ""iv"");
VAR_1 -= 4.0;
}
while (VAR_1 >= 1.0) {
xmlBufferCCat(VAR_0, (VAR_2) ? ""I"" : ""i"");
VAR_1--;
}
}",GNOME/libxslt/91d0540ac9beaa86719a05b749219a69baa0dd8d/numbers.c/vul/before/1.json,"static void
xsltNumberFormatRoman(xsltNumberDataPtr data,
		      xmlBufferPtr buffer,
		      double number,
		      int is_upper)
{
    /*
     * See discussion in xsltNumberFormatAlpha. Also use a reasonable upper
     * bound to avoid denial of service.
     */
    if (number < 1.0 || number > 5000.0) {
        xsltNumberFormatDecimal(buffer, number, '0', 1,
                                data->digitsPerGroup,
                                data->groupingCharacter,
                                data->groupingCharacterLen);
        return;
    }

    /*
     * Based on an example by Jim Walsh
     */
    while (number >= 1000.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""M"" : ""m"");
	number -= 1000.0;
    }
    if (number >= 900.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""CM"" : ""cm"");
	number -= 900.0;
    }
    while (number >= 500.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""D"" : ""d"");
	number -= 500.0;
    }
    if (number >= 400.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""CD"" : ""cd"");
	number -= 400.0;
    }
    while (number >= 100.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""C"" : ""c"");
	number -= 100.0;
    }
    if (number >= 90.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""XC"" : ""xc"");
	number -= 90.0;
    }
    while (number >= 50.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""L"" : ""l"");
	number -= 50.0;
    }
    if (number >= 40.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""XL"" : ""xl"");
	number -= 40.0;
    }
    while (number >= 10.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""X"" : ""x"");
	number -= 10.0;
    }
    if (number >= 9.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""IX"" : ""ix"");
	number -= 9.0;
    }
    while (number >= 5.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""V"" : ""v"");
	number -= 5.0;
    }
    if (number >= 4.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""IV"" : ""iv"");
	number -= 4.0;
    }
    while (number >= 1.0) {
	xmlBufferCCat(buffer, (is_upper) ? ""I"" : ""i"");
	number--;
    }
}","static void
xsltNumberFormatRoman(xsltNumberDataPtr VAR_0,
		      xmlBufferPtr VAR_1,
		      double VAR_2,
		      int VAR_3)
{
    /* COMMENT_0 */
                                                                           
                                        
       
    if (VAR_2 < 1.0 || VAR_2 > 5000.0) {
        xsltNumberFormatDecimal(VAR_1, VAR_2, '0', 1,
                                VAR_0->digitsPerGroup,
                                VAR_0->groupingCharacter,
                                VAR_0->groupingCharacterLen);
        return;
    }

    /* COMMENT_4 */
                                       
       
    while (VAR_2 >= 1000.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""M"" : ""m"");
	VAR_2 -= 1000.0;
    }
    if (VAR_2 >= 900.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""CM"" : ""cm"");
	VAR_2 -= 900.0;
    }
    while (VAR_2 >= 500.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""D"" : ""d"");
	VAR_2 -= 500.0;
    }
    if (VAR_2 >= 400.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""CD"" : ""cd"");
	VAR_2 -= 400.0;
    }
    while (VAR_2 >= 100.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""C"" : ""c"");
	VAR_2 -= 100.0;
    }
    if (VAR_2 >= 90.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""XC"" : ""xc"");
	VAR_2 -= 90.0;
    }
    while (VAR_2 >= 50.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""L"" : ""l"");
	VAR_2 -= 50.0;
    }
    if (VAR_2 >= 40.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""XL"" : ""xl"");
	VAR_2 -= 40.0;
    }
    while (VAR_2 >= 10.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""X"" : ""x"");
	VAR_2 -= 10.0;
    }
    if (VAR_2 >= 9.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""IX"" : ""ix"");
	VAR_2 -= 9.0;
    }
    while (VAR_2 >= 5.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""V"" : ""v"");
	VAR_2 -= 5.0;
    }
    if (VAR_2 >= 4.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""IV"" : ""iv"");
	VAR_2 -= 4.0;
    }
    while (VAR_2 >= 1.0) {
	xmlBufferCCat(VAR_1, (VAR_3) ? ""I"" : ""i"");
	VAR_2--;
    }
}",GNOME/libxslt/91d0540ac9beaa86719a05b749219a69baa0dd8d/numbers.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,8 +1,21 @@
 static void
-xsltNumberFormatRoman(xmlBufferPtr buffer,
+xsltNumberFormatRoman(xsltNumberDataPtr data,
+		      xmlBufferPtr buffer,
 		      double number,
 		      int is_upper)
 {
+    /*
+     * See discussion in xsltNumberFormatAlpha. Also use a reasonable upper
+     * bound to avoid denial of service.
+     */
+    if (number < 1.0 || number > 5000.0) {
+        xsltNumberFormatDecimal(buffer, number, '0', 1,
+                                data->digitsPerGroup,
+                                data->groupingCharacter,
+                                data->groupingCharacterLen);
+        return;
+    }
+
     /*
      * Based on an example by Jim Walsh
      */","{'deleted_lines': ['xsltNumberFormatRoman(xmlBufferPtr buffer,'], 'added_lines': ['xsltNumberFormatRoman(xsltNumberDataPtr data,', '\t\t      xmlBufferPtr buffer,', '    /*', '     * See discussion in xsltNumberFormatAlpha. Also use a reasonable upper', '     * bound to avoid denial of service.', '     */', '    if (number < 1.0 || number > 5000.0) {', ""        xsltNumberFormatDecimal(buffer, number, '0', 1,"", '                                data->digitsPerGroup,', '                                data->groupingCharacter,', '                                data->groupingCharacterLen);', '        return;', '    }', '']}",True,"numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles the i format token for xsl:number data, which allows remote attackers to cause a denial of service (integer overflow or resource consumption) or possibly have unspecified other impact via a crafted document.",7.5,HIGH,2,valid,2016-04-10T11:12:28Z,1
CVE-2016-4021,['CWE-399'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,kazu-yamamoto/pgpdump,fix endless loop on invalid 2 Byte input \xa3\x03 (SYSS-16-030),ece39ddefd102dce7ce84c11580f32a03da568ed,https://github.com/kazu-yamamoto/pgpdump/commit/ece39ddefd102dce7ce84c11580f32a03da568ed,buffer.c,read_binary,"private int
read_binary(byte *p, unsigned int max)
{
return fread(p, sizeof(byte), max, stdin);
}","private VAR_0
read_binary(byte *VAR_1, unsigned int VAR_2)
{
return fread(VAR_1, sizeof(byte), VAR_2, VAR_3);
}",,"private int
read_binary(byte *p, unsigned int max)
{
	size_t ret = fread(p, sizeof(byte), max, stdin);
	if (feof(stdin) | ferror(stdin)) {
		warn_exit(""error in read_binary, maybe preliminary EOF?"");
	}
	return ret;
}","private VAR_0
read_binary(byte *VAR_1, unsigned int VAR_2)
{
	size_t VAR_3 = fread(VAR_1, sizeof(byte), VAR_2, VAR_4);
	if (feof(VAR_4) | ferror(VAR_4)) {
		warn_exit(""error in read_binary, maybe preliminary EOF?"");
	}
	return VAR_3;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,9 @@
 private int
 read_binary(byte *p, unsigned int max)
 {
-	/* errno */
-	return fread(p, sizeof(byte), max, stdin);
+	size_t ret = fread(p, sizeof(byte), max, stdin);
+	if (feof(stdin) | ferror(stdin)) {
+		warn_exit(""error in read_binary, maybe preliminary EOF?"");
+	}
+	return ret;
 }","{'deleted_lines': ['\t/* errno */', '\treturn fread(p, sizeof(byte), max, stdin);'], 'added_lines': ['\tsize_t ret = fread(p, sizeof(byte), max, stdin);', '\tif (feof(stdin) | ferror(stdin)) {', '\t\twarn_exit(""error in read_binary, maybe preliminary EOF?"");', '\t}', '\treturn ret;']}",True,"The read_binary function in buffer.c in pgpdump before 0.30 allows context-dependent attackers to cause a denial of service (infinite loop and CPU consumption) via crafted input, as demonstrated by the \xa3\x03 string.",7.5,HIGH,2,valid,2016-04-12T13:51:39Z,1
CVE-2016-4425,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,akheron/jansson,"Fix for issue #282

The fix limits recursion depths when parsing arrays and objects.
The limit is configurable via the `JSON_PARSER_MAX_DEPTH` setting
within `jansson_config.h` and is set by default to 2048.

Update the RFC conformance document to note the limit; the RFC
allows limits to be set by the implementation so nothing has
actually changed w.r.t. conformance state.

Reported by Gustavo Grieco.",64ce0ad3731ebd77e02897b07920eadd0e2cc318,https://github.com/akheron/jansson/commit/64ce0ad3731ebd77e02897b07920eadd0e2cc318,src/load.c,parse_json,"static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)
{
json_t *result;
lex_scan(lex, error);
if(!(flags & JSON_DECODE_ANY)) {
if(lex->token != '[' && lex->token != '{') {
error_set(error, lex, ""'[' or '{' expected"");
return NULL;
}
}
result = parse_value(lex, flags, error);
if(!result)
return NULL;
if(!(flags & JSON_DISABLE_EOF_CHECK)) {
lex_scan(lex, error);
if(lex->token != TOKEN_EOF) {
error_set(error, lex, ""end of file expected"");
json_decref(result);
return NULL;
}
}
if(error) {
error->position = (int)lex->stream.position;
}
return result;
}","static json_t *parse_json(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)
{
json_t *VAR_3;
lex_scan(VAR_0, VAR_2);
if(!(VAR_1 & VAR_4)) {
if(VAR_0->token != '[' && VAR_0->token != '{') {
error_set(VAR_2, VAR_0, ""'[' or '{' expected"");
return NULL;
}
}
VAR_3 = parse_value(VAR_0, VAR_1, VAR_2);
if(!VAR_3)
return NULL;
if(!(VAR_1 & VAR_5)) {
lex_scan(VAR_0, VAR_2);
if(VAR_0->token != VAR_6) {
error_set(VAR_2, VAR_0, ""end of file expected"");
json_decref(VAR_3);
return NULL;
}
}
if(VAR_2) {
VAR_2->position = (int)VAR_0->stream.position;
}
return VAR_3;
}",akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/before/0.json,"static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)
{
    json_t *result;

    lex->depth = 0;

    lex_scan(lex, error);
    if(!(flags & JSON_DECODE_ANY)) {
        if(lex->token != '[' && lex->token != '{') {
            error_set(error, lex, ""'[' or '{' expected"");
            return NULL;
        }
    }

    result = parse_value(lex, flags, error);
    if(!result)
        return NULL;

    if(!(flags & JSON_DISABLE_EOF_CHECK)) {
        lex_scan(lex, error);
        if(lex->token != TOKEN_EOF) {
            error_set(error, lex, ""end of file expected"");
            json_decref(result);
            return NULL;
        }
    }

    if(error) {
        /* Save the position even though there was no error */
        error->position = (int)lex->stream.position;
    }

    return result;
}","static json_t *parse_json(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)
{
    json_t *VAR_3;

    VAR_0->depth = 0;

    lex_scan(VAR_0, VAR_2);
    if(!(VAR_1 & VAR_4)) {
        if(VAR_0->token != '[' && VAR_0->token != '{') {
            error_set(VAR_2, VAR_0, ""'[' or '{' expected"");
            return NULL;
        }
    }

    VAR_3 = parse_value(VAR_0, VAR_1, VAR_2);
    if(!VAR_3)
        return NULL;

    if(!(VAR_1 & VAR_5)) {
        lex_scan(VAR_0, VAR_2);
        if(VAR_0->token != VAR_6) {
            error_set(VAR_2, VAR_0, ""end of file expected"");
            json_decref(VAR_3);
            return NULL;
        }
    }

    if(VAR_2) {
        /* COMMENT_0 */
        VAR_2->position = (int)VAR_0->stream.position;
    }

    return VAR_3;
}",akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)
 {
     json_t *result;
+
+    lex->depth = 0;
 
     lex_scan(lex, error);
     if(!(flags & JSON_DECODE_ANY)) {","{'deleted_lines': [], 'added_lines': ['', '    lex->depth = 0;']}",True,"Jansson 2.7 and earlier allows context-dependent attackers to cause a denial of service (deep recursion, stack consumption, and crash) via crafted JSON data.",7.5,HIGH,2,valid,2016-05-02T11:59:26Z,1
CVE-2016-4425,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,akheron/jansson,"Fix for issue #282

The fix limits recursion depths when parsing arrays and objects.
The limit is configurable via the `JSON_PARSER_MAX_DEPTH` setting
within `jansson_config.h` and is set by default to 2048.

Update the RFC conformance document to note the limit; the RFC
allows limits to be set by the implementation so nothing has
actually changed w.r.t. conformance state.

Reported by Gustavo Grieco.",64ce0ad3731ebd77e02897b07920eadd0e2cc318,https://github.com/akheron/jansson/commit/64ce0ad3731ebd77e02897b07920eadd0e2cc318,src/load.c,parse_value,"static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)
{
json_t *json;
switch(lex->token) {
case TOKEN_STRING: {
const char *value = lex->value.string.val;
size_t len = lex->value.string.len;
if(!(flags & JSON_ALLOW_NUL)) {
if(memchr(value, '\0', len)) {
error_set(error, lex, ""\\u0000 is not allowed without JSON_ALLOW_NUL"");
return NULL;
}
}
json = jsonp_stringn_nocheck_own(value, len);
if(json) {
lex->value.string.val = NULL;
lex->value.string.len = 0;
}
break;
}
case TOKEN_INTEGER: {
json = json_integer(lex->value.integer);
break;
}
case TOKEN_REAL: {
json = json_real(lex->value.real);
break;
}
case TOKEN_TRUE:
json = json_true();
break;
case TOKEN_FALSE:
json = json_false();
break;
case TOKEN_NULL:
json = json_null();
break;
case '{':
json = parse_object(lex, flags, error);
break;
case '[':
json = parse_array(lex, flags, error);
break;
case TOKEN_INVALID:
error_set(error, lex, ""invalid token"");
return NULL;
default:
error_set(error, lex, ""unexpected token"");
return NULL;
}
if(!json)
return NULL;
return json;
}","static json_t *parse_value(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)
{
json_t *VAR_3;
switch(VAR_0->token) {
case VAR_4: {
const char *VAR_5 = VAR_0->value.string.val;
size_t VAR_6 = VAR_0->value.string.len;
if(!(VAR_1 & VAR_7)) {
if(memchr(VAR_5, '\0', VAR_6)) {
error_set(VAR_2, VAR_0, ""\\u0000 is not allowed without JSON_ALLOW_NUL"");
return NULL;
}
}
VAR_3 = jsonp_stringn_nocheck_own(VAR_5, VAR_6);
if(VAR_3) {
VAR_0->value.string.val = NULL;
VAR_0->value.string.len = 0;
}
break;
}
case VAR_8: {
VAR_3 = json_integer(VAR_0->value.integer);
break;
}
case VAR_9: {
VAR_3 = json_real(VAR_0->value.real);
break;
}
case VAR_10:
VAR_3 = json_true();
break;
case VAR_11:
VAR_3 = json_false();
break;
case VAR_12:
VAR_3 = json_null();
break;
case '{':
VAR_3 = parse_object(VAR_0, VAR_1, VAR_2);
break;
case '[':
VAR_3 = parse_array(VAR_0, VAR_1, VAR_2);
break;
case VAR_13:
error_set(VAR_2, VAR_0, ""invalid token"");
return NULL;
default:
error_set(VAR_2, VAR_0, ""unexpected token"");
return NULL;
}
if(!VAR_3)
return NULL;
return VAR_3;
}",akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/before/1.json,"static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)
{
    json_t *json;

    lex->depth++;
    if(lex->depth > JSON_PARSER_MAX_DEPTH) {
        error_set(error, lex, ""maximum parsing depth reached"");
        return NULL;
    }

    switch(lex->token) {
        case TOKEN_STRING: {
            const char *value = lex->value.string.val;
            size_t len = lex->value.string.len;

            if(!(flags & JSON_ALLOW_NUL)) {
                if(memchr(value, '\0', len)) {
                    error_set(error, lex, ""\\u0000 is not allowed without JSON_ALLOW_NUL"");
                    return NULL;
                }
            }

            json = jsonp_stringn_nocheck_own(value, len);
            if(json) {
                lex->value.string.val = NULL;
                lex->value.string.len = 0;
            }
            break;
        }

        case TOKEN_INTEGER: {
            json = json_integer(lex->value.integer);
            break;
        }

        case TOKEN_REAL: {
            json = json_real(lex->value.real);
            break;
        }

        case TOKEN_TRUE:
            json = json_true();
            break;

        case TOKEN_FALSE:
            json = json_false();
            break;

        case TOKEN_NULL:
            json = json_null();
            break;

        case '{':
            json = parse_object(lex, flags, error);
            break;

        case '[':
            json = parse_array(lex, flags, error);
            break;

        case TOKEN_INVALID:
            error_set(error, lex, ""invalid token"");
            return NULL;

        default:
            error_set(error, lex, ""unexpected token"");
            return NULL;
    }

    if(!json)
        return NULL;

    lex->depth--;
    return json;
}","static json_t *parse_value(lex_t *VAR_0, size_t VAR_1, json_error_t *VAR_2)
{
    json_t *VAR_3;

    VAR_0->depth++;
    if(VAR_0->depth > VAR_4) {
        error_set(VAR_2, VAR_0, ""maximum parsing depth reached"");
        return NULL;
    }

    switch(VAR_0->token) {
        case VAR_5: {
            const char *VAR_6 = VAR_0->value.string.val;
            size_t VAR_7 = VAR_0->value.string.len;

            if(!(VAR_1 & VAR_8)) {
                if(memchr(VAR_6, '\0', VAR_7)) {
                    error_set(VAR_2, VAR_0, ""\\u0000 is not allowed without JSON_ALLOW_NUL"");
                    return NULL;
                }
            }

            VAR_3 = jsonp_stringn_nocheck_own(VAR_6, VAR_7);
            if(VAR_3) {
                VAR_0->value.string.val = NULL;
                VAR_0->value.string.len = 0;
            }
            break;
        }

        case VAR_9: {
            VAR_3 = json_integer(VAR_0->value.integer);
            break;
        }

        case VAR_10: {
            VAR_3 = json_real(VAR_0->value.real);
            break;
        }

        case VAR_11:
            VAR_3 = json_true();
            break;

        case VAR_12:
            VAR_3 = json_false();
            break;

        case VAR_13:
            VAR_3 = json_null();
            break;

        case '{':
            VAR_3 = parse_object(VAR_0, VAR_1, VAR_2);
            break;

        case '[':
            VAR_3 = parse_array(VAR_0, VAR_1, VAR_2);
            break;

        case VAR_14:
            error_set(VAR_2, VAR_0, ""invalid token"");
            return NULL;

        default:
            error_set(VAR_2, VAR_0, ""unexpected token"");
            return NULL;
    }

    if(!VAR_3)
        return NULL;

    VAR_0->depth--;
    return VAR_3;
}",akheron/jansson/64ce0ad3731ebd77e02897b07920eadd0e2cc318/load.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,12 @@
 static json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)
 {
     json_t *json;
+
+    lex->depth++;
+    if(lex->depth > JSON_PARSER_MAX_DEPTH) {
+        error_set(error, lex, ""maximum parsing depth reached"");
+        return NULL;
+    }
 
     switch(lex->token) {
         case TOKEN_STRING: {
@@ -64,5 +70,6 @@
     if(!json)
         return NULL;
 
+    lex->depth--;
     return json;
 }","{'deleted_lines': [], 'added_lines': ['', '    lex->depth++;', '    if(lex->depth > JSON_PARSER_MAX_DEPTH) {', '        error_set(error, lex, ""maximum parsing depth reached"");', '        return NULL;', '    }', '    lex->depth--;']}",True,"Jansson 2.7 and earlier allows context-dependent attackers to cause a denial of service (deep recursion, stack consumption, and crash) via crafted JSON data.",7.5,HIGH,2,valid,2016-05-02T11:59:26Z,1
CVE-2016-10152,['CWE-264'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,achernya/hesiod,"Remove hard-coded defaults for LHS and RHS

Don't fall back to using a default LHS or RHS when the configuration
file can't be read.  Instead, return an error.
Original report from https://bugzilla.redhat.com/show_bug.cgi?id=1332493",247e2ce1f2aff40040657acaae7f1a1d673d6618,https://github.com/achernya/hesiod/commit/247e2ce1f2aff40040657acaae7f1a1d673d6618,src/lib/hesiod.c,read_config_file,"static int read_config_file(struct hesiod_p *ctx, const char *filename)
{
char *key, *data, *p, **which;
char buf[MAXDNAME + 7];
FILE *fp;
fp = fopen(filename, ""r"");
if (!fp)
{
ctx->lhs = malloc(strlen(DEF_LHS) + 1);
ctx->rhs = malloc(strlen(DEF_RHS) + 1);
if (ctx->lhs && ctx->rhs)
{
strcpy(ctx->lhs, DEF_LHS);
strcpy(ctx->rhs, DEF_RHS);
return 0;
}
else
{
errno = ENOMEM;
return -1;
}
}
ctx->lhs = NULL;
ctx->rhs = NULL;
while (fgets(buf, sizeof(buf), fp) != NULL)
{
p = buf;
if (*p == '#' || *p == '\n' || *p == '\r')
continue;
while(*p == ' ' || *p == '\t')
p++;
key = p;
while(*p != ' ' && *p != '\t' && *p != '=')
p++;
*p++ = 0;
while(isspace((unsigned char)*p) || *p == '=')
p++;
data = p;
while(!isspace((unsigned char)*p))
p++;
*p = 0;
if (cistrcmp(key, ""lhs"") == 0 || cistrcmp(key, ""rhs"") == 0)
{
which = (cistrcmp(key, ""lhs"") == 0) ? &ctx->lhs : &ctx->rhs;
*which = malloc(strlen(data) + 1);
if (!*which)
{
errno = ENOMEM;
return -1;
}
strcpy(*which, data);
}
}
fclose(fp);
if (!ctx->rhs)
{
errno = ENOEXEC;
return -1;
}
return 0;
}","static int read_config_file(struct hesiod_p *VAR_0, const char *VAR_1)
{
char *VAR_2, *VAR_3, *VAR_4, **VAR_5;
char VAR_6[VAR_7 + 7];
FILE *VAR_8;
VAR_8 = fopen(VAR_1, ""r"");
if (!VAR_8)
{
VAR_0->lhs = malloc(strlen(VAR_9) + 1);
VAR_0->rhs = malloc(strlen(VAR_10) + 1);
if (VAR_0->lhs && VAR_0->rhs)
{
strcpy(VAR_0->lhs, VAR_9);
strcpy(VAR_0->rhs, VAR_10);
return 0;
}
else
{
VAR_11 = VAR_12;
return -1;
}
}
VAR_0->lhs = NULL;
VAR_0->rhs = NULL;
while (fgets(VAR_6, sizeof(VAR_6), VAR_8) != NULL)
{
VAR_4 = VAR_6;
if (*VAR_4 == '#' || *VAR_4 == '\n' || *VAR_4 == '\r')
continue;
while(*VAR_4 == ' ' || *VAR_4 == '\t')
VAR_4++;
VAR_2 = VAR_4;
while(*VAR_4 != ' ' && *VAR_4 != '\t' && *VAR_4 != '=')
VAR_4++;
*VAR_4++ = 0;
while(isspace((unsigned char)*VAR_4) || *VAR_4 == '=')
VAR_4++;
VAR_3 = VAR_4;
while(!isspace((unsigned char)*VAR_4))
VAR_4++;
*VAR_4 = 0;
if (cistrcmp(VAR_2, ""lhs"") == 0 || cistrcmp(VAR_2, ""rhs"") == 0)
{
VAR_5 = (cistrcmp(VAR_2, ""lhs"") == 0) ? &VAR_0->lhs : &VAR_0->rhs;
*VAR_5 = malloc(strlen(VAR_3) + 1);
if (!*VAR_5)
{
VAR_11 = VAR_12;
return -1;
}
strcpy(*VAR_5, VAR_3);
}
}
fclose(VAR_8);
if (!VAR_0->rhs)
{
VAR_11 = VAR_13;
return -1;
}
return 0;
}",achernya/hesiod/247e2ce1f2aff40040657acaae7f1a1d673d6618/hesiod.c/vul/before/0.json,"static int read_config_file(struct hesiod_p *ctx, const char *filename)
{
  char *key, *data, *p, **which;
  char buf[MAXDNAME + 7];
  FILE *fp;

  /* Try to open the configuration file. */
  fp = fopen(filename, ""r"");
  if (!fp)
    return -1;

  ctx->lhs = NULL;
  ctx->rhs = NULL;
  while (fgets(buf, sizeof(buf), fp) != NULL)
    {
      p = buf;
      if (*p == '#' || *p == '\n' || *p == '\r')
	continue;
      while(*p == ' ' || *p == '\t')
	p++;
      key = p;
      while(*p != ' ' && *p != '\t' && *p != '=')
	p++;
      *p++ = 0;
		
      while(isspace((unsigned char)*p) || *p == '=')
	p++;
      data = p;
      while(!isspace((unsigned char)*p))
	p++;
      *p = 0;

      if (cistrcmp(key, ""lhs"") == 0 || cistrcmp(key, ""rhs"") == 0)
	{
	  which = (cistrcmp(key, ""lhs"") == 0) ? &ctx->lhs : &ctx->rhs;
	  *which = malloc(strlen(data) + 1);
	  if (!*which)
	    {
	      errno = ENOMEM;
	      return -1;
	    }
	  strcpy(*which, data);
	}
    }
  fclose(fp);

  /* Make sure that the rhs is set. */
  if (!ctx->rhs)
    {
      errno = ENOEXEC;
      return -1;
    }

  return 0;
}","static int read_config_file(struct hesiod_p *VAR_0, const char *VAR_1)
{
  char *VAR_2, *VAR_3, *VAR_4, **VAR_5;
  char VAR_6[VAR_7 + 7];
  FILE *VAR_8;

  /* COMMENT_0 */
  VAR_8 = fopen(VAR_1, ""r"");
  if (!VAR_8)
    return -1;

  VAR_0->lhs = NULL;
  VAR_0->rhs = NULL;
  while (fgets(VAR_6, sizeof(VAR_6), VAR_8) != NULL)
    {
      VAR_4 = VAR_6;
      if (*VAR_4 == '#' || *VAR_4 == '\n' || *VAR_4 == '\r')
	continue;
      while(*VAR_4 == ' ' || *VAR_4 == '\t')
	VAR_4++;
      VAR_2 = VAR_4;
      while(*VAR_4 != ' ' && *VAR_4 != '\t' && *VAR_4 != '=')
	VAR_4++;
      *VAR_4++ = 0;
		
      while(isspace((unsigned char)*VAR_4) || *VAR_4 == '=')
	VAR_4++;
      VAR_3 = VAR_4;
      while(!isspace((unsigned char)*VAR_4))
	VAR_4++;
      *VAR_4 = 0;

      if (cistrcmp(VAR_2, ""lhs"") == 0 || cistrcmp(VAR_2, ""rhs"") == 0)
	{
	  VAR_5 = (cistrcmp(VAR_2, ""lhs"") == 0) ? &VAR_0->lhs : &VAR_0->rhs;
	  *VAR_5 = malloc(strlen(VAR_3) + 1);
	  if (!*VAR_5)
	    {
	      VAR_9 = VAR_10;
	      return -1;
	    }
	  strcpy(*VAR_5, VAR_3);
	}
    }
  fclose(VAR_8);

  /* COMMENT_1 */
  if (!VAR_0->rhs)
    {
      VAR_9 = VAR_11;
      return -1;
    }

  return 0;
}",achernya/hesiod/247e2ce1f2aff40040657acaae7f1a1d673d6618/hesiod.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,22 +7,7 @@
   /* Try to open the configuration file. */
   fp = fopen(filename, ""r"");
   if (!fp)
-    {
-      /* Use compiled in default domain names. */
-      ctx->lhs = malloc(strlen(DEF_LHS) + 1);
-      ctx->rhs = malloc(strlen(DEF_RHS) + 1);
-      if (ctx->lhs && ctx->rhs)
-	{
-	  strcpy(ctx->lhs, DEF_LHS);
-	  strcpy(ctx->rhs, DEF_RHS);
-	  return 0;
-	}
-      else
-	{
-	  errno = ENOMEM;
-	  return -1;
-	}
-    }
+    return -1;
 
   ctx->lhs = NULL;
   ctx->rhs = NULL;","{'deleted_lines': ['    {', '      /* Use compiled in default domain names. */', '      ctx->lhs = malloc(strlen(DEF_LHS) + 1);', '      ctx->rhs = malloc(strlen(DEF_RHS) + 1);', '      if (ctx->lhs && ctx->rhs)', '\t{', '\t  strcpy(ctx->lhs, DEF_LHS);', '\t  strcpy(ctx->rhs, DEF_RHS);', '\t  return 0;', '\t}', '      else', '\t{', '\t  errno = ENOMEM;', '\t  return -1;', '\t}', '    }'], 'added_lines': ['    return -1;']}",True,"The read_config_file function in lib/hesiod.c in Hesiod 3.2.1 falls back to the "".athena.mit.edu"" default domain when opening the configuration file fails, which allows remote attackers to gain root privileges by poisoning the DNS cache.",9.8,CRITICAL,3,valid,2016-05-03T17:34:32Z,1
CVE-2016-4480,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/mm: fully honor PS bits in guest page table walks

In L4 entries it is currently unconditionally reserved (and hence
should, when set, always result in a reserved bit page fault), and is
reserved on hardware not supporting 1Gb pages (and hence should, when
set, similarly cause a reserved bit page fault on such hardware).

This is CVE-2016-4480 / XSA-176.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>",46699c7393bd991234b5642763c5c24b6b39a6c4,https://github.com/xen-project/xen/commit/46699c7393bd991234b5642763c5c24b6b39a6c4,xen/arch/x86/mm/guest_walk.c,guest_walk_tables,"uint32_t
guest_walk_tables(struct vcpu *v, struct p2m_domain *p2m,
unsigned long va, walk_t *gw, 
uint32_t pfec, mfn_t top_mfn, void *top_map)
{
struct domain *d = v->domain;
p2m_type_t p2mt;
guest_l1e_t *l1p = NULL;
guest_l2e_t *l2p = NULL;
#if GUEST_PAGING_LEVELS >= 4 
guest_l3e_t *l3p = NULL;
guest_l4e_t *l4p;
#endif
unsigned int pkey;
uint32_t gflags, mflags, iflags, rc = 0;
bool_t smep = 0, smap = 0;
bool_t pse1G = 0, pse2M = 0;
p2m_query_t qt = P2M_ALLOC | P2M_UNSHARE;
perfc_incr(guest_walk);
memset(gw, 0, sizeof(*gw));
gw->va = va;
mflags = mandatory_flags(v, pfec);
iflags = (_PAGE_NX_BIT | _PAGE_INVALID_BITS);
if ( is_hvm_domain(d) && !(pfec & PFEC_user_mode) )
{
struct segment_register seg;
const struct cpu_user_regs *regs = guest_cpu_user_regs();
smep =  hvm_smep_enabled(v) && (pfec & PFEC_insn_fetch);
switch ( v->arch.smap_check_policy )
{
case SMAP_CHECK_HONOR_CPL_AC:
hvm_get_segment_register(v, x86_seg_ss, &seg);
smap = hvm_smap_enabled(v) &&
((seg.attr.fields.dpl == 3) ||
!(regs->eflags & X86_EFLAGS_AC));
break;
case SMAP_CHECK_ENABLED:
smap = hvm_smap_enabled(v);
break;
default:
ASSERT(v->arch.smap_check_policy == SMAP_CHECK_DISABLED);
break;
}
}
if ( smep || smap )
mflags |= _PAGE_USER;
#if GUEST_PAGING_LEVELS >= 3 
#if GUEST_PAGING_LEVELS >= 4 
gw->l4mfn = top_mfn;
l4p = (guest_l4e_t *) top_map;
gw->l4e = l4p[guest_l4_table_offset(va)];
gflags = guest_l4e_get_flags(gw->l4e) ^ iflags;
if ( !(gflags & _PAGE_PRESENT) ) {
rc |= _PAGE_PRESENT;
goto out;
}
rc |= ((gflags & mflags) ^ mflags);
l3p = map_domain_gfn(p2m, 
guest_l4e_get_gfn(gw->l4e), 
&gw->l3mfn,
&p2mt,
qt,
&rc); 
if(l3p == NULL)
goto out;
gw->l3e = l3p[guest_l3_table_offset(va)];
pkey = guest_l3e_get_pkey(gw->l3e);
gflags = guest_l3e_get_flags(gw->l3e) ^ iflags;
if ( !(gflags & _PAGE_PRESENT) ) {
rc |= _PAGE_PRESENT;
goto out;
}
rc |= ((gflags & mflags) ^ mflags);
pse1G = (gflags & _PAGE_PSE) && guest_supports_1G_superpages(v); 
if ( pse1G )
{
gfn_t start = guest_l3e_get_gfn(gw->l3e);
int flags = (_PAGE_PRESENT|_PAGE_USER|_PAGE_RW|
_PAGE_ACCESSED|_PAGE_DIRTY);
flags |= (guest_l3e_get_flags(gw->l3e)
& (_PAGE_PAT|_PAGE_PWT|_PAGE_PCD));
if ( !(gfn_x(start) & 1) )
flags &= ~_PAGE_PAT;
if ( gfn_x(start) & GUEST_L3_GFN_MASK & ~0x1 )
rc |= _PAGE_INVALID_BITS;
start = _gfn((gfn_x(start) & ~GUEST_L3_GFN_MASK) +
((va >> PAGE_SHIFT) & GUEST_L3_GFN_MASK));
gw->l1e = guest_l1e_from_gfn(start, flags);
gw->l2mfn = gw->l1mfn = _mfn(INVALID_MFN);
goto set_ad;
}
#else 
gw->l3e = ((guest_l3e_t *) top_map)[guest_l3_table_offset(va)];
if ( !(guest_l3e_get_flags(gw->l3e) & _PAGE_PRESENT) ) 
{
rc |= _PAGE_PRESENT;
goto out;
}
#endif 
l2p = map_domain_gfn(p2m, 
guest_l3e_get_gfn(gw->l3e), 
&gw->l2mfn,
&p2mt, 
qt,
&rc); 
if(l2p == NULL)
goto out;
gw->l2e = l2p[guest_l2_table_offset(va)];
#else 
gw->l2mfn = top_mfn;
l2p = (guest_l2e_t *) top_map;
gw->l2e = l2p[guest_l2_table_offset(va)];
#endif 
pkey = guest_l2e_get_pkey(gw->l2e);
gflags = guest_l2e_get_flags(gw->l2e) ^ iflags;
if ( !(gflags & _PAGE_PRESENT) ) {
rc |= _PAGE_PRESENT;
goto out;
}
rc |= ((gflags & mflags) ^ mflags);
pse2M = (gflags & _PAGE_PSE) && guest_supports_superpages(v); 
if ( pse2M )
{
gfn_t start = guest_l2e_get_gfn(gw->l2e);
int flags = (_PAGE_PRESENT|_PAGE_USER|_PAGE_RW|
_PAGE_ACCESSED|_PAGE_DIRTY);
flags |= (guest_l2e_get_flags(gw->l2e)
& (_PAGE_PAT|_PAGE_PWT|_PAGE_PCD));
if ( !(gfn_x(start) & 1) )
flags &= ~_PAGE_PAT;
if ( gfn_x(start) & GUEST_L2_GFN_MASK & ~0x1 )
rc |= _PAGE_INVALID_BITS;
start = _gfn((gfn_x(start) & ~GUEST_L2_GFN_MASK) +
guest_l1_table_offset(va));
gw->l1e = guest_l1e_from_gfn(start, flags);
gw->l1mfn = _mfn(INVALID_MFN);
} 
else 
{
l1p = map_domain_gfn(p2m, 
guest_l2e_get_gfn(gw->l2e), 
&gw->l1mfn,
&p2mt,
qt,
&rc);
if(l1p == NULL)
goto out;
gw->l1e = l1p[guest_l1_table_offset(va)];
pkey = guest_l1e_get_pkey(gw->l1e);
gflags = guest_l1e_get_flags(gw->l1e) ^ iflags;
if ( !(gflags & _PAGE_PRESENT) ) {
rc |= _PAGE_PRESENT;
goto out;
}
rc |= ((gflags & mflags) ^ mflags);
}
#if GUEST_PAGING_LEVELS >= 4 
set_ad:
if ( pkey_fault(v, pfec, gflags, pkey) )
rc |= _PAGE_PKEY_BITS;
#endif
if ( smep || smap )
rc ^= _PAGE_USER;
if ( rc == 0 ) 
{
#if GUEST_PAGING_LEVELS == 4 
if ( set_ad_bits(l4p + guest_l4_table_offset(va), &gw->l4e, 0) )
paging_mark_dirty(d, mfn_x(gw->l4mfn));
if ( set_ad_bits(l3p + guest_l3_table_offset(va), &gw->l3e,
(pse1G && (pfec & PFEC_write_access))) )
paging_mark_dirty(d, mfn_x(gw->l3mfn));
#endif
if ( !pse1G ) 
{
if ( set_ad_bits(l2p + guest_l2_table_offset(va), &gw->l2e,
(pse2M && (pfec & PFEC_write_access))) )
paging_mark_dirty(d, mfn_x(gw->l2mfn));            
if ( !pse2M ) 
{
if ( set_ad_bits(l1p + guest_l1_table_offset(va), &gw->l1e, 
(pfec & PFEC_write_access)) )
paging_mark_dirty(d, mfn_x(gw->l1mfn));
}
}
}
out:
#if GUEST_PAGING_LEVELS == 4
if ( l3p ) 
{
unmap_domain_page(l3p);
put_page(mfn_to_page(mfn_x(gw->l3mfn)));
}
#endif
#if GUEST_PAGING_LEVELS >= 3
if ( l2p ) 
{
unmap_domain_page(l2p);
put_page(mfn_to_page(mfn_x(gw->l2mfn)));
}
#endif
if ( l1p ) 
{
unmap_domain_page(l1p);
put_page(mfn_to_page(mfn_x(gw->l1mfn)));
}
if ( !(rc & _PAGE_PRESENT)
&& gfn_x(guest_l1e_get_gfn(gw->l1e)) >> d->arch.paging.gfn_bits )
rc |= _PAGE_INVALID_BITS;
return rc;
}","uint32_t
guest_walk_tables(struct vcpu *VAR_0, struct p2m_domain *VAR_1,
unsigned long VAR_2, walk_t *VAR_3, 
uint32_t VAR_4, mfn_t VAR_5, void *VAR_6)
{
struct domain *VAR_7 = VAR_0->domain;
p2m_type_t VAR_8;
guest_l1e_t *VAR_9 = NULL;
guest_l2e_t *VAR_10 = NULL;
#if VAR_11 >= 4 
guest_l3e_t *VAR_12 = NULL;
guest_l4e_t *VAR_13;
#endif
unsigned int VAR_14;
uint32_t VAR_15, VAR_16, VAR_17, VAR_18 = 0;
bool_t VAR_19 = 0, VAR_20 = 0;
bool_t VAR_21 = 0, VAR_22 = 0;
p2m_query_t VAR_23 = VAR_24 | VAR_25;
perfc_incr(VAR_26);
memset(VAR_3, 0, sizeof(*VAR_3));
VAR_3->va = VAR_2;
VAR_16 = mandatory_flags(VAR_0, VAR_4);
VAR_17 = (VAR_27 | VAR_28);
if ( is_hvm_domain(VAR_7) && !(VAR_4 & VAR_29) )
{
struct segment_register VAR_30;
const struct cpu_user_regs *VAR_31 = guest_cpu_user_regs();
VAR_19 =  hvm_smep_enabled(VAR_0) && (VAR_4 & VAR_32);
switch ( VAR_0->arch.smap_check_policy )
{
case VAR_33:
hvm_get_segment_register(VAR_0, VAR_34, &VAR_30);
VAR_20 = hvm_smap_enabled(VAR_0) &&
((VAR_30.attr.fields.dpl == 3) ||
!(VAR_31->eflags & VAR_35));
break;
case VAR_36:
VAR_20 = hvm_smap_enabled(VAR_0);
break;
default:
ASSERT(VAR_0->arch.smap_check_policy == VAR_37);
break;
}
}
if ( VAR_19 || VAR_20 )
VAR_16 |= VAR_38;
#if VAR_11 >= 3 
#if VAR_11 >= 4 
VAR_3->l4mfn = VAR_5;
VAR_13 = (guest_l4e_t *) VAR_6;
VAR_3->l4e = VAR_13[guest_l4_table_offset(VAR_2)];
VAR_15 = guest_l4e_get_flags(VAR_3->l4e) ^ VAR_17;
if ( !(VAR_15 & VAR_39) ) {
VAR_18 |= VAR_39;
goto out;
}
VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);
VAR_12 = map_domain_gfn(VAR_1, 
guest_l4e_get_gfn(VAR_3->l4e), 
&VAR_3->l3mfn,
&VAR_8,
VAR_23,
&VAR_18); 
if(VAR_12 == NULL)
goto out;
VAR_3->l3e = VAR_12[guest_l3_table_offset(VAR_2)];
VAR_14 = guest_l3e_get_pkey(VAR_3->l3e);
VAR_15 = guest_l3e_get_flags(VAR_3->l3e) ^ VAR_17;
if ( !(VAR_15 & VAR_39) ) {
VAR_18 |= VAR_39;
goto out;
}
VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);
VAR_21 = (VAR_15 & VAR_40) && guest_supports_1G_superpages(VAR_0); 
if ( VAR_21 )
{
gfn_t VAR_41 = guest_l3e_get_gfn(VAR_3->l3e);
int VAR_42 = (VAR_39|VAR_38|VAR_43|
VAR_44|VAR_45);
VAR_42 |= (guest_l3e_get_flags(VAR_3->l3e)
& (VAR_46|VAR_47|VAR_48));
if ( !(gfn_x(VAR_41) & 1) )
VAR_42 &= ~VAR_46;
if ( gfn_x(VAR_41) & VAR_49 & ~0x1 )
VAR_18 |= VAR_28;
VAR_41 = _gfn((gfn_x(VAR_41) & ~VAR_49) +
((VAR_2 >> VAR_50) & VAR_49));
VAR_3->l1e = guest_l1e_from_gfn(VAR_41, VAR_42);
VAR_3->l2mfn = VAR_3->l1mfn = _mfn(VAR_51);
goto set_ad;
}
#else 
VAR_3->l3e = ((guest_l3e_t *) VAR_6)[guest_l3_table_offset(VAR_2)];
if ( !(guest_l3e_get_flags(VAR_3->l3e) & VAR_39) ) 
{
VAR_18 |= VAR_39;
goto out;
}
#endif 
VAR_10 = map_domain_gfn(VAR_1, 
guest_l3e_get_gfn(VAR_3->l3e), 
&VAR_3->l2mfn,
&VAR_8, 
VAR_23,
&VAR_18); 
if(VAR_10 == NULL)
goto out;
VAR_3->l2e = VAR_10[guest_l2_table_offset(VAR_2)];
#else 
VAR_3->l2mfn = VAR_5;
VAR_10 = (guest_l2e_t *) VAR_6;
VAR_3->l2e = VAR_10[guest_l2_table_offset(VAR_2)];
#endif 
VAR_14 = guest_l2e_get_pkey(VAR_3->l2e);
VAR_15 = guest_l2e_get_flags(VAR_3->l2e) ^ VAR_17;
if ( !(VAR_15 & VAR_39) ) {
VAR_18 |= VAR_39;
goto out;
}
VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);
VAR_22 = (VAR_15 & VAR_40) && guest_supports_superpages(VAR_0); 
if ( VAR_22 )
{
gfn_t VAR_41 = guest_l2e_get_gfn(VAR_3->l2e);
int VAR_42 = (VAR_39|VAR_38|VAR_43|
VAR_44|VAR_45);
VAR_42 |= (guest_l2e_get_flags(VAR_3->l2e)
& (VAR_46|VAR_47|VAR_48));
if ( !(gfn_x(VAR_41) & 1) )
VAR_42 &= ~VAR_46;
if ( gfn_x(VAR_41) & VAR_52 & ~0x1 )
VAR_18 |= VAR_28;
VAR_41 = _gfn((gfn_x(VAR_41) & ~VAR_52) +
guest_l1_table_offset(VAR_2));
VAR_3->l1e = guest_l1e_from_gfn(VAR_41, VAR_42);
VAR_3->l1mfn = _mfn(VAR_51);
} 
else 
{
VAR_9 = map_domain_gfn(VAR_1, 
guest_l2e_get_gfn(VAR_3->l2e), 
&VAR_3->l1mfn,
&VAR_8,
VAR_23,
&VAR_18);
if(VAR_9 == NULL)
goto out;
VAR_3->l1e = VAR_9[guest_l1_table_offset(VAR_2)];
VAR_14 = guest_l1e_get_pkey(VAR_3->l1e);
VAR_15 = guest_l1e_get_flags(VAR_3->l1e) ^ VAR_17;
if ( !(VAR_15 & VAR_39) ) {
VAR_18 |= VAR_39;
goto out;
}
VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);
}
#if VAR_11 >= 4 
set_ad:
if ( pkey_fault(VAR_0, VAR_4, VAR_15, VAR_14) )
VAR_18 |= VAR_53;
#endif
if ( VAR_19 || VAR_20 )
VAR_18 ^= VAR_38;
if ( VAR_18 == 0 ) 
{
#if VAR_11 == 4 
if ( set_ad_bits(VAR_13 + guest_l4_table_offset(VAR_2), &VAR_3->l4e, 0) )
paging_mark_dirty(VAR_7, mfn_x(VAR_3->l4mfn));
if ( set_ad_bits(VAR_12 + guest_l3_table_offset(VAR_2), &VAR_3->l3e,
(VAR_21 && (VAR_4 & VAR_54))) )
paging_mark_dirty(VAR_7, mfn_x(VAR_3->l3mfn));
#endif
if ( !VAR_21 ) 
{
if ( set_ad_bits(VAR_10 + guest_l2_table_offset(VAR_2), &VAR_3->l2e,
(VAR_22 && (VAR_4 & VAR_54))) )
paging_mark_dirty(VAR_7, mfn_x(VAR_3->l2mfn));            
if ( !VAR_22 ) 
{
if ( set_ad_bits(VAR_9 + guest_l1_table_offset(VAR_2), &VAR_3->l1e, 
(VAR_4 & VAR_54)) )
paging_mark_dirty(VAR_7, mfn_x(VAR_3->l1mfn));
}
}
}
out:
#if VAR_11 == 4
if ( VAR_12 ) 
{
unmap_domain_page(VAR_12);
put_page(mfn_to_page(mfn_x(VAR_3->l3mfn)));
}
#endif
#if VAR_11 >= 3
if ( VAR_10 ) 
{
unmap_domain_page(VAR_10);
put_page(mfn_to_page(mfn_x(VAR_3->l2mfn)));
}
#endif
if ( VAR_9 ) 
{
unmap_domain_page(VAR_9);
put_page(mfn_to_page(mfn_x(VAR_3->l1mfn)));
}
if ( !(VAR_18 & VAR_39)
&& gfn_x(guest_l1e_get_gfn(VAR_3->l1e)) >> VAR_7->arch.paging.gfn_bits )
VAR_18 |= VAR_28;
return VAR_18;
}",xen-project/xen/46699c7393bd991234b5642763c5c24b6b39a6c4/guest_walk.c/vul/before/0.json,"uint32_t
guest_walk_tables(struct vcpu *v, struct p2m_domain *p2m,
                  unsigned long va, walk_t *gw, 
                  uint32_t pfec, mfn_t top_mfn, void *top_map)
{
    struct domain *d = v->domain;
    p2m_type_t p2mt;
    guest_l1e_t *l1p = NULL;
    guest_l2e_t *l2p = NULL;
#if GUEST_PAGING_LEVELS >= 4 /* 64-bit only... */
    guest_l3e_t *l3p = NULL;
    guest_l4e_t *l4p;
#endif
    unsigned int pkey;
    uint32_t gflags, mflags, iflags, rc = 0;
    bool_t smep = 0, smap = 0;
    bool_t pse1G = 0, pse2M = 0;
    p2m_query_t qt = P2M_ALLOC | P2M_UNSHARE;

    perfc_incr(guest_walk);
    memset(gw, 0, sizeof(*gw));
    gw->va = va;

    /* Mandatory bits that must be set in every entry.  We invert NX and
     * the invalid bits, to calculate as if there were an ""X"" bit that
     * allowed access.  We will accumulate, in rc, the set of flags that
     * are missing/unwanted. */
    mflags = mandatory_flags(v, pfec);
    iflags = (_PAGE_NX_BIT | _PAGE_INVALID_BITS);

    if ( is_hvm_domain(d) && !(pfec & PFEC_user_mode) )
    {
        struct segment_register seg;
        const struct cpu_user_regs *regs = guest_cpu_user_regs();

        /* SMEP: kernel-mode instruction fetches from user-mode mappings
         * should fault.  Unlike NX or invalid bits, we're looking for _all_
         * entries in the walk to have _PAGE_USER set, so we need to do the
         * whole walk as if it were a user-mode one and then invert the answer. */
        smep =  hvm_smep_enabled(v) && (pfec & PFEC_insn_fetch);

        switch ( v->arch.smap_check_policy )
        {
        case SMAP_CHECK_HONOR_CPL_AC:
            hvm_get_segment_register(v, x86_seg_ss, &seg);

            /*
             * SMAP: kernel-mode data accesses from user-mode mappings
             * should fault.
             * A fault is considered as a SMAP violation if the following
             * conditions come true:
             *   - X86_CR4_SMAP is set in CR4
             *   - A user page is accessed
             *   - CPL = 3 or X86_EFLAGS_AC is clear
             *   - Page fault in kernel mode
             */
            smap = hvm_smap_enabled(v) &&
                   ((seg.attr.fields.dpl == 3) ||
                    !(regs->eflags & X86_EFLAGS_AC));
            break;
        case SMAP_CHECK_ENABLED:
            smap = hvm_smap_enabled(v);
            break;
        default:
            ASSERT(v->arch.smap_check_policy == SMAP_CHECK_DISABLED);
            break;
        }
    }

    if ( smep || smap )
        mflags |= _PAGE_USER;

#if GUEST_PAGING_LEVELS >= 3 /* PAE or 64... */
#if GUEST_PAGING_LEVELS >= 4 /* 64-bit only... */

    /* Get the l4e from the top level table and check its flags*/
    gw->l4mfn = top_mfn;
    l4p = (guest_l4e_t *) top_map;
    gw->l4e = l4p[guest_l4_table_offset(va)];
    gflags = guest_l4e_get_flags(gw->l4e) ^ iflags;
    if ( !(gflags & _PAGE_PRESENT) ) {
        rc |= _PAGE_PRESENT;
        goto out;
    }
    if ( gflags & _PAGE_PSE )
    {
        rc |= _PAGE_PSE | _PAGE_INVALID_BIT;
        goto out;
    }
    rc |= ((gflags & mflags) ^ mflags);

    /* Map the l3 table */
    l3p = map_domain_gfn(p2m, 
                         guest_l4e_get_gfn(gw->l4e), 
                         &gw->l3mfn,
                         &p2mt,
                         qt,
                         &rc); 
    if(l3p == NULL)
        goto out;
    /* Get the l3e and check its flags*/
    gw->l3e = l3p[guest_l3_table_offset(va)];
    pkey = guest_l3e_get_pkey(gw->l3e);
    gflags = guest_l3e_get_flags(gw->l3e) ^ iflags;
    if ( !(gflags & _PAGE_PRESENT) ) {
        rc |= _PAGE_PRESENT;
        goto out;
    }
    rc |= ((gflags & mflags) ^ mflags);
    
    pse1G = !!(gflags & _PAGE_PSE);

    if ( pse1G )
    {
        /* Generate a fake l1 table entry so callers don't all 
         * have to understand superpages. */
        gfn_t start = guest_l3e_get_gfn(gw->l3e);
        /* Grant full access in the l1e, since all the guest entry's
         * access controls are enforced in the l3e. */
        int flags = (_PAGE_PRESENT|_PAGE_USER|_PAGE_RW|
                     _PAGE_ACCESSED|_PAGE_DIRTY);
        /* Import cache-control bits. Note that _PAGE_PAT is actually
         * _PAGE_PSE, and it is always set. We will clear it in case
         * _PAGE_PSE_PAT (bit 12, i.e. first bit of gfn) is clear. */
        flags |= (guest_l3e_get_flags(gw->l3e)
                  & (_PAGE_PAT|_PAGE_PWT|_PAGE_PCD));
        if ( !(gfn_x(start) & 1) )
            /* _PAGE_PSE_PAT not set: remove _PAGE_PAT from flags. */
            flags &= ~_PAGE_PAT;

        if ( !guest_supports_1G_superpages(v) )
            rc |= _PAGE_PSE | _PAGE_INVALID_BIT;
        if ( gfn_x(start) & GUEST_L3_GFN_MASK & ~0x1 )
            rc |= _PAGE_INVALID_BITS;

        /* Increment the pfn by the right number of 4k pages. */
        start = _gfn((gfn_x(start) & ~GUEST_L3_GFN_MASK) +
                     ((va >> PAGE_SHIFT) & GUEST_L3_GFN_MASK));
        gw->l1e = guest_l1e_from_gfn(start, flags);
        gw->l2mfn = gw->l1mfn = _mfn(INVALID_MFN);
        goto set_ad;
    }

#else /* PAE only... */

    /* Get the l3e and check its flag */
    gw->l3e = ((guest_l3e_t *) top_map)[guest_l3_table_offset(va)];
    if ( !(guest_l3e_get_flags(gw->l3e) & _PAGE_PRESENT) ) 
    {
        rc |= _PAGE_PRESENT;
        goto out;
    }

#endif /* PAE or 64... */

    /* Map the l2 table */
    l2p = map_domain_gfn(p2m, 
                         guest_l3e_get_gfn(gw->l3e), 
                         &gw->l2mfn,
                         &p2mt, 
                         qt,
                         &rc); 
    if(l2p == NULL)
        goto out;
    /* Get the l2e */
    gw->l2e = l2p[guest_l2_table_offset(va)];

#else /* 32-bit only... */

    /* Get l2e from the top level table */
    gw->l2mfn = top_mfn;
    l2p = (guest_l2e_t *) top_map;
    gw->l2e = l2p[guest_l2_table_offset(va)];

#endif /* All levels... */

    pkey = guest_l2e_get_pkey(gw->l2e);
    gflags = guest_l2e_get_flags(gw->l2e) ^ iflags;
    if ( !(gflags & _PAGE_PRESENT) ) {
        rc |= _PAGE_PRESENT;
        goto out;
    }
    rc |= ((gflags & mflags) ^ mflags);

    pse2M = (gflags & _PAGE_PSE) && guest_supports_superpages(v); 

    if ( pse2M )
    {
        /* Special case: this guest VA is in a PSE superpage, so there's
         * no guest l1e.  We make one up so that the propagation code
         * can generate a shadow l1 table.  Start with the gfn of the 
         * first 4k-page of the superpage. */
        gfn_t start = guest_l2e_get_gfn(gw->l2e);
        /* Grant full access in the l1e, since all the guest entry's 
         * access controls are enforced in the shadow l2e. */
        int flags = (_PAGE_PRESENT|_PAGE_USER|_PAGE_RW|
                     _PAGE_ACCESSED|_PAGE_DIRTY);
        /* Import cache-control bits. Note that _PAGE_PAT is actually
         * _PAGE_PSE, and it is always set. We will clear it in case
         * _PAGE_PSE_PAT (bit 12, i.e. first bit of gfn) is clear. */
        flags |= (guest_l2e_get_flags(gw->l2e)
                  & (_PAGE_PAT|_PAGE_PWT|_PAGE_PCD));
        if ( !(gfn_x(start) & 1) )
            /* _PAGE_PSE_PAT not set: remove _PAGE_PAT from flags. */
            flags &= ~_PAGE_PAT;

        if ( gfn_x(start) & GUEST_L2_GFN_MASK & ~0x1 )
            rc |= _PAGE_INVALID_BITS;

        /* Increment the pfn by the right number of 4k pages.  
         * Mask out PAT and invalid bits. */
        start = _gfn((gfn_x(start) & ~GUEST_L2_GFN_MASK) +
                     guest_l1_table_offset(va));
        gw->l1e = guest_l1e_from_gfn(start, flags);
        gw->l1mfn = _mfn(INVALID_MFN);
    } 
    else 
    {
        /* Not a superpage: carry on and find the l1e. */
        l1p = map_domain_gfn(p2m, 
                             guest_l2e_get_gfn(gw->l2e), 
                             &gw->l1mfn,
                             &p2mt,
                             qt,
                             &rc);
        if(l1p == NULL)
            goto out;
        gw->l1e = l1p[guest_l1_table_offset(va)];
        pkey = guest_l1e_get_pkey(gw->l1e);
        gflags = guest_l1e_get_flags(gw->l1e) ^ iflags;
        if ( !(gflags & _PAGE_PRESENT) ) {
            rc |= _PAGE_PRESENT;
            goto out;
        }
        rc |= ((gflags & mflags) ^ mflags);
    }

#if GUEST_PAGING_LEVELS >= 4 /* 64-bit only... */
set_ad:
    if ( pkey_fault(v, pfec, gflags, pkey) )
        rc |= _PAGE_PKEY_BITS;
#endif
    /* Now re-invert the user-mode requirement for SMEP and SMAP */
    if ( smep || smap )
        rc ^= _PAGE_USER;

    /* Go back and set accessed and dirty bits only if the walk was a
     * success.  Although the PRMs say higher-level _PAGE_ACCESSED bits
     * get set whenever a lower-level PT is used, at least some hardware
     * walkers behave this way. */
    if ( rc == 0 ) 
    {
#if GUEST_PAGING_LEVELS == 4 /* 64-bit only... */
        if ( set_ad_bits(l4p + guest_l4_table_offset(va), &gw->l4e, 0) )
            paging_mark_dirty(d, mfn_x(gw->l4mfn));
        if ( set_ad_bits(l3p + guest_l3_table_offset(va), &gw->l3e,
                         (pse1G && (pfec & PFEC_write_access))) )
            paging_mark_dirty(d, mfn_x(gw->l3mfn));
#endif
        if ( !pse1G ) 
        {
            if ( set_ad_bits(l2p + guest_l2_table_offset(va), &gw->l2e,
                             (pse2M && (pfec & PFEC_write_access))) )
                paging_mark_dirty(d, mfn_x(gw->l2mfn));            
            if ( !pse2M ) 
            {
                if ( set_ad_bits(l1p + guest_l1_table_offset(va), &gw->l1e, 
                                 (pfec & PFEC_write_access)) )
                    paging_mark_dirty(d, mfn_x(gw->l1mfn));
            }
        }
    }

 out:
#if GUEST_PAGING_LEVELS == 4
    if ( l3p ) 
    {
        unmap_domain_page(l3p);
        put_page(mfn_to_page(mfn_x(gw->l3mfn)));
    }
#endif
#if GUEST_PAGING_LEVELS >= 3
    if ( l2p ) 
    {
        unmap_domain_page(l2p);
        put_page(mfn_to_page(mfn_x(gw->l2mfn)));
    }
#endif
    if ( l1p ) 
    {
        unmap_domain_page(l1p);
        put_page(mfn_to_page(mfn_x(gw->l1mfn)));
    }

    /* If this guest has a restricted physical address space then the
     * target GFN must fit within it. */
    if ( !(rc & _PAGE_PRESENT)
         && gfn_x(guest_l1e_get_gfn(gw->l1e)) >> d->arch.paging.gfn_bits )
        rc |= _PAGE_INVALID_BITS;

    return rc;
}","uint32_t
guest_walk_tables(struct vcpu *VAR_0, struct p2m_domain *VAR_1,
                  unsigned long VAR_2, walk_t *VAR_3, 
                  uint32_t VAR_4, mfn_t VAR_5, void *VAR_6)
{
    struct domain *VAR_7 = VAR_0->domain;
    p2m_type_t VAR_8;
    guest_l1e_t *VAR_9 = NULL;
    guest_l2e_t *VAR_10 = NULL;
#if VAR_11 >= 4 /* COMMENT_0 */
    guest_l3e_t *VAR_12 = NULL;
    guest_l4e_t *VAR_13;
#endif
    unsigned int VAR_14;
    uint32_t VAR_15, VAR_16, VAR_17, VAR_18 = 0;
    bool_t VAR_19 = 0, VAR_20 = 0;
    bool_t VAR_21 = 0, VAR_22 = 0;
    p2m_query_t VAR_23 = VAR_24 | VAR_25;

    perfc_incr(VAR_26);
    memset(VAR_3, 0, sizeof(*VAR_3));
    VAR_3->va = VAR_2;

    /* COMMENT_1 */
                                                                      
                                                                        
                               
    VAR_16 = mandatory_flags(VAR_0, VAR_4);
    VAR_17 = (VAR_27 | VAR_28);

    if ( is_hvm_domain(VAR_7) && !(VAR_4 & VAR_29) )
    {
        struct segment_register VAR_30;
        const struct cpu_user_regs *VAR_31 = guest_cpu_user_regs();

        /* COMMENT_5 */
                                                                            
                                                                           
                                                                                  
        VAR_19 =  hvm_smep_enabled(VAR_0) && (VAR_4 & VAR_32);

        switch ( VAR_0->arch.smap_check_policy )
        {
        case VAR_33:
            hvm_get_segment_register(VAR_0, VAR_34, &VAR_30);

            /* COMMENT_9 */
                                                                      
                            
                                                                         
                                    
                                             
                                          
                                                    
                                            
               
            VAR_20 = hvm_smap_enabled(VAR_0) &&
                   ((VAR_30.attr.fields.dpl == 3) ||
                    !(VAR_31->eflags & VAR_35));
            break;
        case VAR_36:
            VAR_20 = hvm_smap_enabled(VAR_0);
            break;
        default:
            ASSERT(VAR_0->arch.smap_check_policy == VAR_37);
            break;
        }
    }

    if ( VAR_19 || VAR_20 )
        VAR_16 |= VAR_38;

#if VAR_11 >= 3 /* COMMENT_19 */
#if VAR_11 >= 4 /* COMMENT_0 */

    /* COMMENT_20 */
    VAR_3->l4mfn = VAR_5;
    VAR_13 = (guest_l4e_t *) VAR_6;
    VAR_3->l4e = VAR_13[guest_l4_table_offset(VAR_2)];
    VAR_15 = guest_l4e_get_flags(VAR_3->l4e) ^ VAR_17;
    if ( !(VAR_15 & VAR_39) ) {
        VAR_18 |= VAR_39;
        goto out;
    }
    if ( VAR_15 & VAR_40 )
    {
        VAR_18 |= VAR_40 | VAR_41;
        goto out;
    }
    VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);

    /* COMMENT_21 */
    VAR_12 = map_domain_gfn(VAR_1, 
                         guest_l4e_get_gfn(VAR_3->l4e), 
                         &VAR_3->l3mfn,
                         &VAR_8,
                         VAR_23,
                         &VAR_18); 
    if(VAR_12 == NULL)
        goto out;
    /* COMMENT_22 */
    VAR_3->l3e = VAR_12[guest_l3_table_offset(VAR_2)];
    VAR_14 = guest_l3e_get_pkey(VAR_3->l3e);
    VAR_15 = guest_l3e_get_flags(VAR_3->l3e) ^ VAR_17;
    if ( !(VAR_15 & VAR_39) ) {
        VAR_18 |= VAR_39;
        goto out;
    }
    VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);
    
    VAR_21 = !!(VAR_15 & VAR_40);

    if ( VAR_21 )
    {
        /* COMMENT_23 */
                                            
        gfn_t VAR_42 = guest_l3e_get_gfn(VAR_3->l3e);
        /* COMMENT_25 */
                                                      
        int VAR_43 = (VAR_39|VAR_38|VAR_44|
                     VAR_45|VAR_46);
        /* COMMENT_27 */
                                                                    
                                                                     
        VAR_43 |= (guest_l3e_get_flags(VAR_3->l3e)
                  & (VAR_47|VAR_48|VAR_49));
        if ( !(gfn_x(VAR_42) & 1) )
            /* COMMENT_30 */
            VAR_43 &= ~VAR_47;

        if ( !guest_supports_1G_superpages(VAR_0) )
            VAR_18 |= VAR_40 | VAR_41;
        if ( gfn_x(VAR_42) & VAR_50 & ~0x1 )
            VAR_18 |= VAR_28;

        /* COMMENT_31 */
        VAR_42 = _gfn((gfn_x(VAR_42) & ~VAR_50) +
                     ((VAR_2 >> VAR_51) & VAR_50));
        VAR_3->l1e = guest_l1e_from_gfn(VAR_42, VAR_43);
        VAR_3->l2mfn = VAR_3->l1mfn = _mfn(VAR_52);
        goto set_ad;
    }

#else /* COMMENT_32 */

    /* COMMENT_33 */
    VAR_3->l3e = ((guest_l3e_t *) VAR_6)[guest_l3_table_offset(VAR_2)];
    if ( !(guest_l3e_get_flags(VAR_3->l3e) & VAR_39) ) 
    {
        VAR_18 |= VAR_39;
        goto out;
    }

#endif /* COMMENT_19 */

    /* COMMENT_34 */
    VAR_10 = map_domain_gfn(VAR_1, 
                         guest_l3e_get_gfn(VAR_3->l3e), 
                         &VAR_3->l2mfn,
                         &VAR_8, 
                         VAR_23,
                         &VAR_18); 
    if(VAR_10 == NULL)
        goto out;
    /* COMMENT_35 */
    VAR_3->l2e = VAR_10[guest_l2_table_offset(VAR_2)];

#else /* COMMENT_36 */

    /* COMMENT_37 */
    VAR_3->l2mfn = VAR_5;
    VAR_10 = (guest_l2e_t *) VAR_6;
    VAR_3->l2e = VAR_10[guest_l2_table_offset(VAR_2)];

#endif /* COMMENT_38 */

    VAR_14 = guest_l2e_get_pkey(VAR_3->l2e);
    VAR_15 = guest_l2e_get_flags(VAR_3->l2e) ^ VAR_17;
    if ( !(VAR_15 & VAR_39) ) {
        VAR_18 |= VAR_39;
        goto out;
    }
    VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);

    VAR_22 = (VAR_15 & VAR_40) && guest_supports_superpages(VAR_0); 

    if ( VAR_22 )
    {
        /* COMMENT_39 */
                                                                     
                                                                      
                                             
        gfn_t VAR_42 = guest_l2e_get_gfn(VAR_3->l2e);
        /* COMMENT_43 */
                                                             
        int VAR_43 = (VAR_39|VAR_38|VAR_44|
                     VAR_45|VAR_46);
        /* COMMENT_45 */
                                                                    
                                                                     
        VAR_43 |= (guest_l2e_get_flags(VAR_3->l2e)
                  & (VAR_47|VAR_48|VAR_49));
        if ( !(gfn_x(VAR_42) & 1) )
            /* COMMENT_30 */
            VAR_43 &= ~VAR_47;

        if ( gfn_x(VAR_42) & VAR_53 & ~0x1 )
            VAR_18 |= VAR_28;

        /* COMMENT_48 */
                                            
        VAR_42 = _gfn((gfn_x(VAR_42) & ~VAR_53) +
                     guest_l1_table_offset(VAR_2));
        VAR_3->l1e = guest_l1e_from_gfn(VAR_42, VAR_43);
        VAR_3->l1mfn = _mfn(VAR_52);
    } 
    else 
    {
        /* COMMENT_50 */
        VAR_9 = map_domain_gfn(VAR_1, 
                             guest_l2e_get_gfn(VAR_3->l2e), 
                             &VAR_3->l1mfn,
                             &VAR_8,
                             VAR_23,
                             &VAR_18);
        if(VAR_9 == NULL)
            goto out;
        VAR_3->l1e = VAR_9[guest_l1_table_offset(VAR_2)];
        VAR_14 = guest_l1e_get_pkey(VAR_3->l1e);
        VAR_15 = guest_l1e_get_flags(VAR_3->l1e) ^ VAR_17;
        if ( !(VAR_15 & VAR_39) ) {
            VAR_18 |= VAR_39;
            goto out;
        }
        VAR_18 |= ((VAR_15 & VAR_16) ^ VAR_16);
    }

#if VAR_11 >= 4 /* COMMENT_0 */
set_ad:
    if ( pkey_fault(VAR_0, VAR_4, VAR_15, VAR_14) )
        VAR_18 |= VAR_54;
#endif
    /* COMMENT_51 */
    if ( VAR_19 || VAR_20 )
        VAR_18 ^= VAR_38;

    /* COMMENT_52 */
                                                                       
                                                                        
                                  
    if ( VAR_18 == 0 ) 
    {
#if VAR_11 == 4 /* COMMENT_0 */
        if ( set_ad_bits(VAR_13 + guest_l4_table_offset(VAR_2), &VAR_3->l4e, 0) )
            paging_mark_dirty(VAR_7, mfn_x(VAR_3->l4mfn));
        if ( set_ad_bits(VAR_12 + guest_l3_table_offset(VAR_2), &VAR_3->l3e,
                         (VAR_21 && (VAR_4 & VAR_55))) )
            paging_mark_dirty(VAR_7, mfn_x(VAR_3->l3mfn));
#endif
        if ( !VAR_21 ) 
        {
            if ( set_ad_bits(VAR_10 + guest_l2_table_offset(VAR_2), &VAR_3->l2e,
                             (VAR_22 && (VAR_4 & VAR_55))) )
                paging_mark_dirty(VAR_7, mfn_x(VAR_3->l2mfn));            
            if ( !VAR_22 ) 
            {
                if ( set_ad_bits(VAR_9 + guest_l1_table_offset(VAR_2), &VAR_3->l1e, 
                                 (VAR_4 & VAR_55)) )
                    paging_mark_dirty(VAR_7, mfn_x(VAR_3->l1mfn));
            }
        }
    }

 out:
#if VAR_11 == 4
    if ( VAR_12 ) 
    {
        unmap_domain_page(VAR_12);
        put_page(mfn_to_page(mfn_x(VAR_3->l3mfn)));
    }
#endif
#if VAR_11 >= 3
    if ( VAR_10 ) 
    {
        unmap_domain_page(VAR_10);
        put_page(mfn_to_page(mfn_x(VAR_3->l2mfn)));
    }
#endif
    if ( VAR_9 ) 
    {
        unmap_domain_page(VAR_9);
        put_page(mfn_to_page(mfn_x(VAR_3->l1mfn)));
    }

    /* COMMENT_56 */
                                        
    if ( !(VAR_18 & VAR_39)
         && gfn_x(guest_l1e_get_gfn(VAR_3->l1e)) >> VAR_7->arch.paging.gfn_bits )
        VAR_18 |= VAR_28;

    return VAR_18;
}",xen-project/xen/46699c7393bd991234b5642763c5c24b6b39a6c4/guest_walk.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -82,6 +82,11 @@
         rc |= _PAGE_PRESENT;
         goto out;
     }
+    if ( gflags & _PAGE_PSE )
+    {
+        rc |= _PAGE_PSE | _PAGE_INVALID_BIT;
+        goto out;
+    }
     rc |= ((gflags & mflags) ^ mflags);
 
     /* Map the l3 table */
@@ -103,7 +108,7 @@
     }
     rc |= ((gflags & mflags) ^ mflags);
     
-    pse1G = (gflags & _PAGE_PSE) && guest_supports_1G_superpages(v); 
+    pse1G = !!(gflags & _PAGE_PSE);
 
     if ( pse1G )
     {
@@ -123,6 +128,8 @@
             /* _PAGE_PSE_PAT not set: remove _PAGE_PAT from flags. */
             flags &= ~_PAGE_PAT;
 
+        if ( !guest_supports_1G_superpages(v) )
+            rc |= _PAGE_PSE | _PAGE_INVALID_BIT;
         if ( gfn_x(start) & GUEST_L3_GFN_MASK & ~0x1 )
             rc |= _PAGE_INVALID_BITS;
 ","{'deleted_lines': ['    pse1G = (gflags & _PAGE_PSE) && guest_supports_1G_superpages(v); '], 'added_lines': ['    if ( gflags & _PAGE_PSE )', '    {', '        rc |= _PAGE_PSE | _PAGE_INVALID_BIT;', '        goto out;', '    }', '    pse1G = !!(gflags & _PAGE_PSE);', '        if ( !guest_supports_1G_superpages(v) )', '            rc |= _PAGE_PSE | _PAGE_INVALID_BIT;']}",True,"The guest_walk_tables function in arch/x86/mm/guest_walk.c in Xen 4.6.x and earlier does not properly handle the Page Size (PS) page table entry bit at the L4 and L3 page table levels, which might allow local guest OS users to gain privileges via a crafted mapping of memory.",8.4,HIGH,2,valid,2016-05-17T12:41:14Z,1
CVE-2016-10067,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Suspend exception processing if there are too many exceptions,0474237508f39c4f783208123431815f1ededb76,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,coders/viff.c,ReadVIFFImage,"static Image *ReadVIFFImage(const ImageInfo *image_info,
ExceptionInfo *exception)
{
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9
typedef struct _ViffInfo
{
unsigned char
identifier,
file_type,
release,
version,
machine_dependency,
reserve[3];
char
comment[512];
unsigned int
rows,
columns,
subrows;
int
x_offset,
y_offset;
float
x_bits_per_pixel,
y_bits_per_pixel;
unsigned int
location_type,
location_dimension,
number_of_images,
number_data_bands,
data_storage_type,
data_encode_scheme,
map_scheme,
map_storage_type,
map_rows,
map_columns,
map_subrows,
map_enable,
maps_per_cycle,
color_space_model;
} ViffInfo;
double
min_value,
scale_factor,
value;
Image
*image;
int
bit;
MagickBooleanType
status;
MagickSizeType
number_pixels;
register IndexPacket
*indexes;
register ssize_t
x;
register PixelPacket
*q;
register ssize_t
i;
register unsigned char
*p;
size_t
bytes_per_pixel,
max_packets,
quantum;
ssize_t
count,
y;
unsigned char
*pixels;
unsigned long
lsb_first;
ViffInfo
viff_info;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
count=ReadBlob(image,1,&viff_info.identifier);
do
{
if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
(void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
(void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
(void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
(void) ReadBlob(image,sizeof(viff_info.machine_dependency),
&viff_info.machine_dependency);
(void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
(void) ReadBlob(image,512,(unsigned char *) viff_info.comment);
viff_info.comment[511]='\0';
if (strlen(viff_info.comment) > 4)
(void) SetImageProperty(image,""comment"",viff_info.comment);
if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
(viff_info.machine_dependency == VFF_DEP_NSORDER))
image->endian=LSBEndian;
else
image->endian=MSBEndian;
viff_info.rows=ReadBlobLong(image);
viff_info.columns=ReadBlobLong(image);
viff_info.subrows=ReadBlobLong(image);
viff_info.x_offset=ReadBlobSignedLong(image);
viff_info.y_offset=ReadBlobSignedLong(image);
viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
viff_info.location_type=ReadBlobLong(image);
viff_info.location_dimension=ReadBlobLong(image);
viff_info.number_of_images=ReadBlobLong(image);
viff_info.number_data_bands=ReadBlobLong(image);
viff_info.data_storage_type=ReadBlobLong(image);
viff_info.data_encode_scheme=ReadBlobLong(image);
viff_info.map_scheme=ReadBlobLong(image);
viff_info.map_storage_type=ReadBlobLong(image);
viff_info.map_rows=ReadBlobLong(image);
viff_info.map_columns=ReadBlobLong(image);
viff_info.map_subrows=ReadBlobLong(image);
viff_info.map_enable=ReadBlobLong(image);
viff_info.maps_per_cycle=ReadBlobLong(image);
viff_info.color_space_model=ReadBlobLong(image);
for (i=0; i < 420; i++)
(void) ReadBlobByte(image);
if (EOFBlob(image) != MagickFalse)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
image->columns=viff_info.rows;
image->rows=viff_info.columns;
image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
MAGICKCORE_QUANTUM_DEPTH;
number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
if (number_pixels != (size_t) number_pixels)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
if (number_pixels == 0)
ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
(viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
(viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
(viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
(viff_info.data_storage_type != VFF_TYP_FLOAT) &&
(viff_info.data_storage_type != VFF_TYP_DOUBLE))
ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
if (viff_info.data_encode_scheme != VFF_DES_RAW)
ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
(viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
(viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
(viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
(viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
(viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
if ((viff_info.color_space_model != VFF_CM_NONE) &&
(viff_info.color_space_model != VFF_CM_ntscRGB) &&
(viff_info.color_space_model != VFF_CM_genericRGB))
ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
if (viff_info.location_type != VFF_LOC_IMPLICIT)
ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
if (viff_info.number_of_images != 1)
ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
if (viff_info.map_rows == 0)
viff_info.map_scheme=VFF_MS_NONE;
switch ((int) viff_info.map_scheme)
{
case VFF_MS_NONE:
{
if (viff_info.number_data_bands < 3)
{
if (viff_info.data_storage_type == VFF_TYP_BIT)
image->colors=2;
else
if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
image->colors=256UL;
else
image->colors=image->depth <= 8 ? 256UL : 65536UL;
if (AcquireImageColormap(image,image->colors) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
break;
}
case VFF_MS_ONEPERBAND:
case VFF_MS_SHARED:
{
unsigned char
*viff_colormap;
switch ((int) viff_info.map_storage_type)
{
case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
default: bytes_per_pixel=1; break;
}
image->colors=viff_info.map_columns;
if (AcquireImageColormap(image,image->colors) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
if (viff_info.map_rows >
(viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
if (viff_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
viff_colormap);
lsb_first=1;
if (*(char *) &lsb_first &&
((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
(viff_info.machine_dependency != VFF_DEP_NSORDER)))
switch ((int) viff_info.map_storage_type)
{
case VFF_MAPTYP_2_BYTE:
{
MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
viff_info.map_rows));
break;
}
case VFF_MAPTYP_4_BYTE:
case VFF_MAPTYP_FLOAT:
{
MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
viff_info.map_rows));
break;
}
default: break;
}
for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
{
switch ((int) viff_info.map_storage_type)
{
case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
default: value=1.0*viff_colormap[i]; break;
}
if (i < (ssize_t) image->colors)
{
image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);
image->colormap[i].green=ScaleCharToQuantum((unsigned char)
value);
image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);
}
else
if (i < (ssize_t) (2*image->colors))
image->colormap[i % image->colors].green=ScaleCharToQuantum(
(unsigned char) value);
else
if (i < (ssize_t) (3*image->colors))
image->colormap[i % image->colors].blue=ScaleCharToQuantum(
(unsigned char) value);
}
viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
break;
}
default:
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
}
image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;
image->storage_class=
(viff_info.number_data_bands < 3 ? PseudoClass : DirectClass);
image->columns=viff_info.rows;
image->rows=viff_info.columns;
if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
switch ((int) viff_info.data_storage_type)
{
case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
default: bytes_per_pixel=1; break;
}
if (viff_info.data_storage_type == VFF_TYP_BIT)
{
if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
max_packets=((image->columns+7UL) >> 3UL)*image->rows;
}
else
{
if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
}
pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
max_packets),bytes_per_pixel*sizeof(*pixels));
if (pixels == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);
lsb_first=1;
if (*(char *) &lsb_first &&
((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
(viff_info.machine_dependency != VFF_DEP_NSORDER)))
switch ((int) viff_info.data_storage_type)
{
case VFF_TYP_2_BYTE:
{
MSBOrderShort(pixels,bytes_per_pixel*max_packets);
break;
}
case VFF_TYP_4_BYTE:
case VFF_TYP_FLOAT:
{
MSBOrderLong(pixels,bytes_per_pixel*max_packets);
break;
}
default: break;
}
min_value=0.0;
scale_factor=1.0;
if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
(viff_info.map_scheme == VFF_MS_NONE))
{
double
max_value;
switch ((int) viff_info.data_storage_type)
{
case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
default: value=1.0*pixels[0]; break;
}
max_value=value;
min_value=value;
for (i=0; i < (ssize_t) max_packets; i++)
{
switch ((int) viff_info.data_storage_type)
{
case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
default: value=1.0*pixels[i]; break;
}
if (value > max_value)
max_value=value;
else
if (value < min_value)
min_value=value;
}
if ((min_value == 0) && (max_value == 0))
scale_factor=0;
else
if (min_value == max_value)
{
scale_factor=(MagickRealType) QuantumRange/min_value;
min_value=0;
}
else
scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);
}
p=(unsigned char *) pixels;
for (i=0; i < (ssize_t) max_packets; i++)
{
switch ((int) viff_info.data_storage_type)
{
case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
default: value=1.0*pixels[i]; break;
}
if (viff_info.map_scheme == VFF_MS_NONE)
{
value=(value-min_value)*scale_factor;
if (value > QuantumRange)
value=QuantumRange;
else
if (value < 0)
value=0;
}
*p=(unsigned char) ((Quantum) value);
p++;
}
p=(unsigned char *) pixels;
if (viff_info.data_storage_type == VFF_TYP_BIT)
{
if (image->storage_class != PseudoClass)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
for (x=0; x < (ssize_t) (image->columns-7); x+=8)
{
for (bit=0; bit < 8; bit++)
{
quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);
SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);
SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);
if (image->storage_class == PseudoClass)
SetPixelIndex(indexes+x+bit,quantum);
}
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=0; bit < (int) (image->columns % 8); bit++)
{
quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);
SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);
SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);
if (image->storage_class == PseudoClass)
SetPixelIndex(indexes+x+bit,quantum);
}
p++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
if (image->storage_class == PseudoClass)
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
for (x=0; x < (ssize_t) image->columns; x++)
SetPixelIndex(indexes+x,*p++);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
else
{
number_pixels=(MagickSizeType) image->columns*image->rows;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelRed(q,ScaleCharToQuantum(*p));
SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));
SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));
if (image->colors != 0)
{
ssize_t
index;
index=(ssize_t) GetPixelRed(q);
SetPixelRed(q,image->colormap[(ssize_t)
ConstrainColormapIndex(image,index)].red);
index=(ssize_t) GetPixelGreen(q);
SetPixelGreen(q,image->colormap[(ssize_t)
ConstrainColormapIndex(image,index)].green);
index=(ssize_t) GetPixelRed(q);
SetPixelBlue(q,image->colormap[(ssize_t)
ConstrainColormapIndex(image,index)].blue);
}
SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-
ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);
p++;
q++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
if (image->storage_class == PseudoClass)
(void) SyncImage(image);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
count=ReadBlob(image,1,&viff_info.identifier);
if ((count != 0) && (viff_info.identifier == 0xab))
{
AcquireNextImage(image_info,image);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while ((count != 0) && (viff_info.identifier == 0xab));
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadVIFFImage(const ImageInfo *VAR_0,
ExceptionInfo *VAR_1)
{
#define VAR_2  15
#define VAR_3  1
#define VAR_4  0
#define VAR_5  0x4
#define VAR_6  0x8
#define VAR_7  0
#define VAR_8  1
#define VAR_9  0
#define VAR_10  1
#define VAR_11  2
#define VAR_12  4
#define VAR_13  5
#define VAR_14  7
#define VAR_15  0
#define VAR_16  1
#define VAR_17  3
#define VAR_18  0
#define VAR_19  1
#define VAR_20  2
#define VAR_21  4
#define VAR_22  5
#define VAR_23  9
typedef struct _ViffInfo
{
unsigned char
identifier,
file_type,
release,
version,
machine_dependency,
reserve[3];
char
comment[512];
unsigned int
rows,
columns,
subrows;
int
x_offset,
y_offset;
float
x_bits_per_pixel,
y_bits_per_pixel;
unsigned int
location_type,
location_dimension,
number_of_images,
number_data_bands,
data_storage_type,
data_encode_scheme,
map_scheme,
map_storage_type,
map_rows,
map_columns,
map_subrows,
map_enable,
maps_per_cycle,
color_space_model;
} ViffInfo;
double
VAR_24,
VAR_25,
VAR_26;
Image
*VAR_27;
int
VAR_28;
MagickBooleanType
VAR_29;
MagickSizeType
VAR_30;
register IndexPacket
*VAR_31;
register ssize_t
VAR_32;
register PixelPacket
*VAR_33;
register ssize_t
VAR_34;
register unsigned char
*VAR_35;
size_t
VAR_36,
VAR_37,
VAR_38;
ssize_t
VAR_39,
VAR_40;
unsigned char
*VAR_41;
unsigned long
VAR_42;
ViffInfo
VAR_43;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_44);
if (VAR_0->debug != VAR_45)
(void) LogMagickEvent(VAR_46,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_44);
VAR_27=AcquireImage(VAR_0);
VAR_29=OpenBlob(VAR_0,VAR_27,VAR_47,VAR_1);
if (VAR_29 == VAR_45)
{
VAR_27=DestroyImageList(VAR_27);
return((Image *) NULL);
}
VAR_39=ReadBlob(VAR_27,1,&VAR_43.identifier);
do
{
if ((VAR_39 != 1) || ((unsigned char) VAR_43.identifier != 0xab))
ThrowReaderException(VAR_48,""NotAVIFFImage"");
(void) ReadBlob(VAR_27,sizeof(VAR_43.file_type),&VAR_43.file_type);
(void) ReadBlob(VAR_27,sizeof(VAR_43.release),&VAR_43.release);
(void) ReadBlob(VAR_27,sizeof(VAR_43.version),&VAR_43.version);
(void) ReadBlob(VAR_27,sizeof(VAR_43.machine_dependency),
&VAR_43.machine_dependency);
(void) ReadBlob(VAR_27,sizeof(VAR_43.reserve),VAR_43.reserve);
(void) ReadBlob(VAR_27,512,(unsigned char *) VAR_43.comment);
VAR_43.comment[511]='\0';
if (strlen(VAR_43.comment) > 4)
(void) SetImageProperty(VAR_27,""comment"",VAR_43.comment);
if ((VAR_43.machine_dependency == VAR_5) ||
(VAR_43.machine_dependency == VAR_6))
VAR_27->endian=VAR_49;
else
VAR_27->endian=VAR_50;
VAR_43.rows=ReadBlobLong(VAR_27);
VAR_43.columns=ReadBlobLong(VAR_27);
VAR_43.subrows=ReadBlobLong(VAR_27);
VAR_43.x_offset=ReadBlobSignedLong(VAR_27);
VAR_43.y_offset=ReadBlobSignedLong(VAR_27);
VAR_43.x_bits_per_pixel=(float) ReadBlobLong(VAR_27);
VAR_43.y_bits_per_pixel=(float) ReadBlobLong(VAR_27);
VAR_43.location_type=ReadBlobLong(VAR_27);
VAR_43.location_dimension=ReadBlobLong(VAR_27);
VAR_43.number_of_images=ReadBlobLong(VAR_27);
VAR_43.number_data_bands=ReadBlobLong(VAR_27);
VAR_43.data_storage_type=ReadBlobLong(VAR_27);
VAR_43.data_encode_scheme=ReadBlobLong(VAR_27);
VAR_43.map_scheme=ReadBlobLong(VAR_27);
VAR_43.map_storage_type=ReadBlobLong(VAR_27);
VAR_43.map_rows=ReadBlobLong(VAR_27);
VAR_43.map_columns=ReadBlobLong(VAR_27);
VAR_43.map_subrows=ReadBlobLong(VAR_27);
VAR_43.map_enable=ReadBlobLong(VAR_27);
VAR_43.maps_per_cycle=ReadBlobLong(VAR_27);
VAR_43.color_space_model=ReadBlobLong(VAR_27);
for (VAR_34=0; VAR_34 < 420; VAR_34++)
(void) ReadBlobByte(VAR_27);
if (EOFBlob(VAR_27) != VAR_45)
ThrowReaderException(VAR_48,""UnexpectedEndOfFile"");
VAR_27->columns=VAR_43.rows;
VAR_27->rows=VAR_43.columns;
VAR_27->depth=VAR_43.x_bits_per_pixel <= 8 ? 8UL :
VAR_51;
VAR_30=(MagickSizeType) VAR_43.columns*VAR_43.rows;
if (VAR_30 != (size_t) VAR_30)
ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
if (VAR_30 == 0)
ThrowReaderException(VAR_53,""ImageColumnOrRowSizeIsNotSupported"");
if ((VAR_43.number_data_bands < 1) || (VAR_43.number_data_bands > 4))
ThrowReaderException(VAR_48,""ImproperImageHeader"");
if ((VAR_43.data_storage_type != VAR_18) &&
(VAR_43.data_storage_type != VAR_19) &&
(VAR_43.data_storage_type != VAR_20) &&
(VAR_43.data_storage_type != VAR_21) &&
(VAR_43.data_storage_type != VAR_22) &&
(VAR_43.data_storage_type != VAR_23))
ThrowReaderException(VAR_53,""DataStorageTypeIsNotSupported"");
if (VAR_43.data_encode_scheme != VAR_7)
ThrowReaderException(VAR_53,""DataEncodingSchemeIsNotSupported"");
if ((VAR_43.map_storage_type != VAR_9) &&
(VAR_43.map_storage_type != VAR_10) &&
(VAR_43.map_storage_type != VAR_11) &&
(VAR_43.map_storage_type != VAR_12) &&
(VAR_43.map_storage_type != VAR_13) &&
(VAR_43.map_storage_type != VAR_14))
ThrowReaderException(VAR_53,""MapStorageTypeIsNotSupported"");
if ((VAR_43.color_space_model != VAR_4) &&
(VAR_43.color_space_model != VAR_3) &&
(VAR_43.color_space_model != VAR_2))
ThrowReaderException(VAR_53,""ColorspaceModelIsNotSupported"");
if (VAR_43.location_type != VAR_8)
ThrowReaderException(VAR_53,""LocationTypeIsNotSupported"");
if (VAR_43.number_of_images != 1)
ThrowReaderException(VAR_53,""NumberOfImagesIsNotSupported"");
if (VAR_43.map_rows == 0)
VAR_43.map_scheme=VAR_15;
switch ((int) VAR_43.map_scheme)
{
case VAR_15:
{
if (VAR_43.number_data_bands < 3)
{
if (VAR_43.data_storage_type == VAR_18)
VAR_27->colors=2;
else
if (VAR_43.data_storage_type == VAR_10)
VAR_27->colors=256UL;
else
VAR_27->colors=VAR_27->depth <= 8 ? 256UL : 65536UL;
if (AcquireImageColormap(VAR_27,VAR_27->colors) == VAR_45)
ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
}
break;
}
case VAR_16:
case VAR_17:
{
unsigned char
*VAR_54;
switch ((int) VAR_43.map_storage_type)
{
case VAR_10: VAR_36=1; break;
case VAR_11: VAR_36=2; break;
case VAR_12: VAR_36=4; break;
case VAR_13: VAR_36=4; break;
case VAR_14: VAR_36=8; break;
default: VAR_36=1; break;
}
VAR_27->colors=VAR_43.map_columns;
if (AcquireImageColormap(VAR_27,VAR_27->colors) == VAR_45)
ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
if (VAR_43.map_rows >
(VAR_43.map_rows*VAR_36*sizeof(*VAR_54)))
ThrowReaderException(VAR_48,""ImproperImageHeader"");
VAR_54=(unsigned char *) AcquireQuantumMemory(VAR_27->colors,
VAR_43.map_rows*VAR_36*sizeof(*VAR_54));
if (VAR_54 == (unsigned char *) NULL)
ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
(void) ReadBlob(VAR_27,VAR_36*VAR_27->colors*VAR_43.map_rows,
VAR_54);
VAR_42=1;
if (*(char *) &VAR_42 &&
((VAR_43.machine_dependency != VAR_5) &&
(VAR_43.machine_dependency != VAR_6)))
switch ((int) VAR_43.map_storage_type)
{
case VAR_11:
{
MSBOrderShort(VAR_54,(VAR_36*VAR_27->colors*
VAR_43.map_rows));
break;
}
case VAR_12:
case VAR_13:
{
MSBOrderLong(VAR_54,(VAR_36*VAR_27->colors*
VAR_43.map_rows));
break;
}
default: break;
}
for (VAR_34=0; VAR_34 < (ssize_t) (VAR_43.map_rows*VAR_27->colors); VAR_34++)
{
switch ((int) VAR_43.map_storage_type)
{
case VAR_11: VAR_26=1.0*((short *) VAR_54)[VAR_34]; break;
case VAR_12: VAR_26=1.0*((int *) VAR_54)[VAR_34]; break;
case VAR_13: VAR_26=((float *) VAR_54)[VAR_34]; break;
case VAR_14: VAR_26=((double *) VAR_54)[VAR_34]; break;
default: VAR_26=1.0*VAR_54[VAR_34]; break;
}
if (VAR_34 < (ssize_t) VAR_27->colors)
{
VAR_27->colormap[VAR_34].red=ScaleCharToQuantum((unsigned char) VAR_26);
VAR_27->colormap[VAR_34].green=ScaleCharToQuantum((unsigned char)
VAR_26);
VAR_27->colormap[VAR_34].blue=ScaleCharToQuantum((unsigned char) VAR_26);
}
else
if (VAR_34 < (ssize_t) (2*VAR_27->colors))
VAR_27->colormap[VAR_34 % VAR_27->colors].green=ScaleCharToQuantum(
(unsigned char) VAR_26);
else
if (VAR_34 < (ssize_t) (3*VAR_27->colors))
VAR_27->colormap[VAR_34 % VAR_27->colors].blue=ScaleCharToQuantum(
(unsigned char) VAR_26);
}
VAR_54=(unsigned char *) RelinquishMagickMemory(VAR_54);
break;
}
default:
ThrowReaderException(VAR_53,""ColormapTypeNotSupported"");
}
VAR_27->matte=VAR_43.number_data_bands == 4 ? VAR_55 : VAR_45;
VAR_27->storage_class=
(VAR_43.number_data_bands < 3 ? VAR_56 : VAR_57);
VAR_27->columns=VAR_43.rows;
VAR_27->rows=VAR_43.columns;
if ((VAR_0->ping != VAR_45) && (VAR_0->number_scenes != 0))
if (VAR_27->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_29=SetImageExtent(VAR_27,VAR_27->columns,VAR_27->rows);
if (VAR_29 == VAR_45)
{
InheritException(VAR_1,&VAR_27->exception);
return(DestroyImageList(VAR_27));
}
switch ((int) VAR_43.data_storage_type)
{
case VAR_20: VAR_36=2; break;
case VAR_21: VAR_36=4; break;
case VAR_22: VAR_36=4; break;
case VAR_23: VAR_36=8; break;
default: VAR_36=1; break;
}
if (VAR_43.data_storage_type == VAR_18)
{
if (CheckMemoryOverflow((VAR_27->columns+7UL) >> 3UL,VAR_27->rows) != VAR_45)
ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
VAR_37=((VAR_27->columns+7UL) >> 3UL)*VAR_27->rows;
}
else
{
if (CheckMemoryOverflow(VAR_30,VAR_43.number_data_bands) != VAR_45)
ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
VAR_37=(size_t) (VAR_30*VAR_43.number_data_bands);
}
VAR_41=(unsigned char *) AcquireQuantumMemory(MagickMax(VAR_30,
VAR_37),VAR_36*sizeof(*VAR_41));
if (VAR_41 == (unsigned char *) NULL)
ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
(void) ReadBlob(VAR_27,VAR_36*VAR_37,VAR_41);
VAR_42=1;
if (*(char *) &VAR_42 &&
((VAR_43.machine_dependency != VAR_5) &&
(VAR_43.machine_dependency != VAR_6)))
switch ((int) VAR_43.data_storage_type)
{
case VAR_20:
{
MSBOrderShort(VAR_41,VAR_36*VAR_37);
break;
}
case VAR_21:
case VAR_22:
{
MSBOrderLong(VAR_41,VAR_36*VAR_37);
break;
}
default: break;
}
VAR_24=0.0;
VAR_25=1.0;
if ((VAR_43.data_storage_type != VAR_19) &&
(VAR_43.map_scheme == VAR_15))
{
double
VAR_58;
switch ((int) VAR_43.data_storage_type)
{
case VAR_20: VAR_26=1.0*((short *) VAR_41)[0]; break;
case VAR_21: VAR_26=1.0*((int *) VAR_41)[0]; break;
case VAR_22: VAR_26=((float *) VAR_41)[0]; break;
case VAR_23: VAR_26=((double *) VAR_41)[0]; break;
default: VAR_26=1.0*VAR_41[0]; break;
}
VAR_58=VAR_26;
VAR_24=VAR_26;
for (VAR_34=0; VAR_34 < (ssize_t) VAR_37; VAR_34++)
{
switch ((int) VAR_43.data_storage_type)
{
case VAR_20: VAR_26=1.0*((short *) VAR_41)[VAR_34]; break;
case VAR_21: VAR_26=1.0*((int *) VAR_41)[VAR_34]; break;
case VAR_22: VAR_26=((float *) VAR_41)[VAR_34]; break;
case VAR_23: VAR_26=((double *) VAR_41)[VAR_34]; break;
default: VAR_26=1.0*VAR_41[VAR_34]; break;
}
if (VAR_26 > VAR_58)
VAR_58=VAR_26;
else
if (VAR_26 < VAR_24)
VAR_24=VAR_26;
}
if ((VAR_24 == 0) && (VAR_58 == 0))
VAR_25=0;
else
if (VAR_24 == VAR_58)
{
VAR_25=(MagickRealType) VAR_59/VAR_24;
VAR_24=0;
}
else
VAR_25=(MagickRealType) VAR_59/(VAR_58-VAR_24);
}
VAR_35=(unsigned char *) VAR_41;
for (VAR_34=0; VAR_34 < (ssize_t) VAR_37; VAR_34++)
{
switch ((int) VAR_43.data_storage_type)
{
case VAR_20: VAR_26=1.0*((short *) VAR_41)[VAR_34]; break;
case VAR_21: VAR_26=1.0*((int *) VAR_41)[VAR_34]; break;
case VAR_22: VAR_26=((float *) VAR_41)[VAR_34]; break;
case VAR_23: VAR_26=((double *) VAR_41)[VAR_34]; break;
default: VAR_26=1.0*VAR_41[VAR_34]; break;
}
if (VAR_43.map_scheme == VAR_15)
{
VAR_26=(VAR_26-VAR_24)*VAR_25;
if (VAR_26 > VAR_59)
VAR_26=VAR_59;
else
if (VAR_26 < 0)
VAR_26=0;
}
*VAR_35=(unsigned char) ((Quantum) VAR_26);
VAR_35++;
}
VAR_35=(unsigned char *) VAR_41;
if (VAR_43.data_storage_type == VAR_18)
{
if (VAR_27->storage_class != VAR_56)
ThrowReaderException(VAR_48,""ImproperImageHeader"");
for (VAR_40=0; VAR_40 < (ssize_t) VAR_27->rows; VAR_40++)
{
VAR_33=QueueAuthenticPixels(VAR_27,0,VAR_40,VAR_27->columns,1,VAR_1);
if (VAR_33 == (PixelPacket *) NULL)
break;
VAR_31=GetAuthenticIndexQueue(VAR_27);
for (VAR_32=0; VAR_32 < (ssize_t) (VAR_27->columns-7); VAR_32+=8)
{
for (VAR_28=0; VAR_28 < 8; VAR_28++)
{
VAR_38=(size_t) ((*VAR_35) & (0x01 << VAR_28) ? 0 : 1);
SetPixelRed(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
SetPixelGreen(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
SetPixelBlue(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
if (VAR_27->storage_class == VAR_56)
SetPixelIndex(VAR_31+VAR_32+VAR_28,VAR_38);
}
VAR_35++;
}
if ((VAR_27->columns % 8) != 0)
{
for (VAR_28=0; VAR_28 < (int) (VAR_27->columns % 8); VAR_28++)
{
VAR_38=(size_t) ((*VAR_35) & (0x01 << VAR_28) ? 0 : 1);
SetPixelRed(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
SetPixelGreen(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
SetPixelBlue(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
if (VAR_27->storage_class == VAR_56)
SetPixelIndex(VAR_31+VAR_32+VAR_28,VAR_38);
}
VAR_35++;
}
if (SyncAuthenticPixels(VAR_27,VAR_1) == VAR_45)
break;
if (VAR_27->previous == (Image *) NULL)
{
VAR_29=SetImageProgress(VAR_27,VAR_60,(MagickOffsetType) VAR_40,
VAR_27->rows);
if (VAR_29 == VAR_45)
break;
}
}
}
else
if (VAR_27->storage_class == VAR_56)
for (VAR_40=0; VAR_40 < (ssize_t) VAR_27->rows; VAR_40++)
{
VAR_33=QueueAuthenticPixels(VAR_27,0,VAR_40,VAR_27->columns,1,VAR_1);
if (VAR_33 == (PixelPacket *) NULL)
break;
VAR_31=GetAuthenticIndexQueue(VAR_27);
for (VAR_32=0; VAR_32 < (ssize_t) VAR_27->columns; VAR_32++)
SetPixelIndex(VAR_31+VAR_32,*VAR_35++);
if (SyncAuthenticPixels(VAR_27,VAR_1) == VAR_45)
break;
if (VAR_27->previous == (Image *) NULL)
{
VAR_29=SetImageProgress(VAR_27,VAR_60,(MagickOffsetType) VAR_40,
VAR_27->rows);
if (VAR_29 == VAR_45)
break;
}
}
else
{
VAR_30=(MagickSizeType) VAR_27->columns*VAR_27->rows;
for (VAR_40=0; VAR_40 < (ssize_t) VAR_27->rows; VAR_40++)
{
VAR_33=QueueAuthenticPixels(VAR_27,0,VAR_40,VAR_27->columns,1,VAR_1);
if (VAR_33 == (PixelPacket *) NULL)
break;
for (VAR_32=0; VAR_32 < (ssize_t) VAR_27->columns; VAR_32++)
{
SetPixelRed(VAR_33,ScaleCharToQuantum(*VAR_35));
SetPixelGreen(VAR_33,ScaleCharToQuantum(*(VAR_35+VAR_30)));
SetPixelBlue(VAR_33,ScaleCharToQuantum(*(VAR_35+2*VAR_30)));
if (VAR_27->colors != 0)
{
ssize_t
VAR_61;
VAR_61=(ssize_t) GetPixelRed(VAR_33);
SetPixelRed(VAR_33,VAR_27->colormap[(ssize_t)
ConstrainColormapIndex(VAR_27,VAR_61)].red);
VAR_61=(ssize_t) GetPixelGreen(VAR_33);
SetPixelGreen(VAR_33,VAR_27->colormap[(ssize_t)
ConstrainColormapIndex(VAR_27,VAR_61)].green);
VAR_61=(ssize_t) GetPixelRed(VAR_33);
SetPixelBlue(VAR_33,VAR_27->colormap[(ssize_t)
ConstrainColormapIndex(VAR_27,VAR_61)].blue);
}
SetPixelOpacity(VAR_33,VAR_27->matte != VAR_45 ? VAR_59-
ScaleCharToQuantum(*(VAR_35+VAR_30*3)) : VAR_62);
VAR_35++;
VAR_33++;
}
if (SyncAuthenticPixels(VAR_27,VAR_1) == VAR_45)
break;
if (VAR_27->previous == (Image *) NULL)
{
VAR_29=SetImageProgress(VAR_27,VAR_60,(MagickOffsetType) VAR_40,
VAR_27->rows);
if (VAR_29 == VAR_45)
break;
}
}
}
VAR_41=(unsigned char *) RelinquishMagickMemory(VAR_41);
if (VAR_27->storage_class == VAR_56)
(void) SyncImage(VAR_27);
if (EOFBlob(VAR_27) != VAR_45)
{
ThrowFileException(VAR_1,VAR_48,""UnexpectedEndOfFile"",
VAR_27->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_27->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_39=ReadBlob(VAR_27,1,&VAR_43.identifier);
if ((VAR_39 != 0) && (VAR_43.identifier == 0xab))
{
AcquireNextImage(VAR_0,VAR_27);
if (GetNextImageInList(VAR_27) == (Image *) NULL)
{
VAR_27=DestroyImageList(VAR_27);
return((Image *) NULL);
}
VAR_27=SyncNextImageInList(VAR_27);
VAR_29=SetImageProgress(VAR_27,VAR_63,TellBlob(VAR_27),
GetBlobSize(VAR_27));
if (VAR_29 == VAR_45)
break;
}
} while ((VAR_39 != 0) && (VAR_43.identifier == 0xab));
(void) CloseBlob(VAR_27);
return(GetFirstImageInList(VAR_27));
}",ImageMagick/0474237508f39c4f783208123431815f1ededb76/viff.c/vul/before/0.json,"static Image *ReadVIFFImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    min_value,
    scale_factor,
    value;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register IndexPacket
    *indexes;

  register ssize_t
    x;

  register PixelPacket
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_pixel,
    max_packets,
    quantum;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned long
    lsb_first;

  ViffInfo
    viff_info;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read VIFF header (1024 bytes).
  */
  count=ReadBlob(image,1,&viff_info.identifier);
  do
  {
    /*
      Verify VIFF identifier.
    */
    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
      ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
    /*
      Initialize VIFF image.
    */
    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),
      &viff_info.machine_dependency);
    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
    (void) ReadBlob(image,512,(unsigned char *) viff_info.comment);
    viff_info.comment[511]='\0';
    if (strlen(viff_info.comment) > 4)
      (void) SetImageProperty(image,""comment"",viff_info.comment);
    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
        (viff_info.machine_dependency == VFF_DEP_NSORDER))
      image->endian=LSBEndian;
    else
      image->endian=MSBEndian;
    viff_info.rows=ReadBlobLong(image);
    viff_info.columns=ReadBlobLong(image);
    viff_info.subrows=ReadBlobLong(image);
    viff_info.x_offset=ReadBlobSignedLong(image);
    viff_info.y_offset=ReadBlobSignedLong(image);
    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.location_type=ReadBlobLong(image);
    viff_info.location_dimension=ReadBlobLong(image);
    viff_info.number_of_images=ReadBlobLong(image);
    viff_info.number_data_bands=ReadBlobLong(image);
    viff_info.data_storage_type=ReadBlobLong(image);
    viff_info.data_encode_scheme=ReadBlobLong(image);
    viff_info.map_scheme=ReadBlobLong(image);
    viff_info.map_storage_type=ReadBlobLong(image);
    viff_info.map_rows=ReadBlobLong(image);
    viff_info.map_columns=ReadBlobLong(image);
    viff_info.map_subrows=ReadBlobLong(image);
    viff_info.map_enable=ReadBlobLong(image);
    viff_info.maps_per_cycle=ReadBlobLong(image);
    viff_info.color_space_model=ReadBlobLong(image);
    for (i=0; i < 420; i++)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
      MAGICKCORE_QUANTUM_DEPTH;
    /*
      Verify that we can read this VIFF image.
    */
    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
    if (number_pixels != (size_t) number_pixels)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    if (number_pixels == 0)
      ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&
        (viff_info.data_storage_type != VFF_TYP_DOUBLE))
      ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
    if (viff_info.data_encode_scheme != VFF_DES_RAW)
      ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
      ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
    if ((viff_info.color_space_model != VFF_CM_NONE) &&
        (viff_info.color_space_model != VFF_CM_ntscRGB) &&
        (viff_info.color_space_model != VFF_CM_genericRGB))
      ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
    if (viff_info.location_type != VFF_LOC_IMPLICIT)
      ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
    if (viff_info.number_of_images != 1)
      ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
    if (viff_info.map_rows == 0)
      viff_info.map_scheme=VFF_MS_NONE;
    switch ((int) viff_info.map_scheme)
    {
      case VFF_MS_NONE:
      {
        if (viff_info.number_data_bands < 3)
          {
            /*
              Create linear color ramp.
            */
            if (viff_info.data_storage_type == VFF_TYP_BIT)
              image->colors=2;
            else
              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
                image->colors=256UL;
              else
                image->colors=image->depth <= 8 ? 256UL : 65536UL;
            if (AcquireImageColormap(image,image->colors) == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case VFF_MS_ONEPERBAND:
      case VFF_MS_SHARED:
      {
        unsigned char
          *viff_colormap;

        /*
          Allocate VIFF colormap.
        */
        switch ((int) viff_info.map_storage_type)
        {
          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
          default: bytes_per_pixel=1; break;
        }
        image->colors=viff_info.map_columns;
        if (AcquireImageColormap(image,image->colors) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if (viff_info.map_rows >
            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
        if (viff_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        /*
          Read VIFF raster colormap.
        */
        (void) ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
          viff_colormap);
        lsb_first=1;
        if (*(char *) &lsb_first &&
            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
             (viff_info.machine_dependency != VFF_DEP_NSORDER)))
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE:
            {
              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            case VFF_MAPTYP_4_BYTE:
            case VFF_MAPTYP_FLOAT:
            {
              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            default: break;
          }
        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
        {
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
            default: value=1.0*viff_colormap[i]; break;
          }
          if (i < (ssize_t) image->colors)
            {
              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                value);
              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);
            }
          else
            if (i < (ssize_t) (2*image->colors))
              image->colormap[i % image->colors].green=ScaleCharToQuantum(
                (unsigned char) value);
            else
              if (i < (ssize_t) (3*image->colors))
                image->colormap[i % image->colors].blue=ScaleCharToQuantum(
                  (unsigned char) value);
        }
        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
    /*
      Initialize image structure.
    */
    image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;
    image->storage_class=
      (viff_info.number_data_bands < 3 ? PseudoClass : DirectClass);
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    /*
      Allocate VIFF pixels.
    */
    switch ((int) viff_info.data_storage_type)
    {
      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
      default: bytes_per_pixel=1; break;
    }
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=((image->columns+7UL) >> 3UL)*image->rows;
      }
    else
      {
        if (HeapOverflowSanityCheck(number_pixels,viff_info.number_data_bands) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
      }
    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
      max_packets),bytes_per_pixel*sizeof(*pixels));
    if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);
    lsb_first=1;
    if (*(char *) &lsb_first &&
        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
         (viff_info.machine_dependency != VFF_DEP_NSORDER)))
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE:
        {
          MSBOrderShort(pixels,bytes_per_pixel*max_packets);
          break;
        }
        case VFF_TYP_4_BYTE:
        case VFF_TYP_FLOAT:
        {
          MSBOrderLong(pixels,bytes_per_pixel*max_packets);
          break;
        }
        default: break;
      }
    min_value=0.0;
    scale_factor=1.0;
    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.map_scheme == VFF_MS_NONE))
      {
        double
          max_value;

        /*
          Determine scale factor.
        */
        switch ((int) viff_info.data_storage_type)
        {
          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
          default: value=1.0*pixels[0]; break;
        }
        max_value=value;
        min_value=value;
        for (i=0; i < (ssize_t) max_packets; i++)
        {
          switch ((int) viff_info.data_storage_type)
          {
            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
            default: value=1.0*pixels[i]; break;
          }
          if (value > max_value)
            max_value=value;
          else
            if (value < min_value)
              min_value=value;
        }
        if ((min_value == 0) && (max_value == 0))
          scale_factor=0;
        else
          if (min_value == max_value)
            {
              scale_factor=(MagickRealType) QuantumRange/min_value;
              min_value=0;
            }
          else
            scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);
      }
    /*
      Convert pixels to Quantum size.
    */
    p=(unsigned char *) pixels;
    for (i=0; i < (ssize_t) max_packets; i++)
    {
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
        default: value=1.0*pixels[i]; break;
      }
      if (viff_info.map_scheme == VFF_MS_NONE)
        {
          value=(value-min_value)*scale_factor;
          if (value > QuantumRange)
            value=QuantumRange;
          else
            if (value < 0)
              value=0;
        }
      *p=(unsigned char) ((Quantum) value);
      p++;
    }
    /*
      Convert VIFF raster image to pixel packets.
    */
    p=(unsigned char *) pixels;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        /*
          Convert bitmap scanline.
        */
        if (image->storage_class != PseudoClass)
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (PixelPacket *) NULL)
            break;
          indexes=GetAuthenticIndexQueue(image);
          for (x=0; x < (ssize_t) (image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
              SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);
              SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);
              SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);
              if (image->storage_class == PseudoClass)
                SetPixelIndex(indexes+x+bit,quantum);
             }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (int) (image->columns % 8); bit++)
              {
                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
                SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);
                SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);
                SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);
                if (image->storage_class == PseudoClass)
                  SetPixelIndex(indexes+x+bit,quantum);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      if (image->storage_class == PseudoClass)
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (PixelPacket *) NULL)
            break;
          indexes=GetAuthenticIndexQueue(image);
          for (x=0; x < (ssize_t) image->columns; x++)
            SetPixelIndex(indexes+x,*p++);
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      else
        {
          /*
            Convert DirectColor scanline.
          */
          number_pixels=(MagickSizeType) image->columns*image->rows;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (PixelPacket *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleCharToQuantum(*p));
              SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));
              SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));
              if (image->colors != 0)
                {
                  ssize_t
                    index;

                  index=(ssize_t) GetPixelRed(q);
                  SetPixelRed(q,image->colormap[(ssize_t)
                    ConstrainColormapIndex(image,index)].red);
                  index=(ssize_t) GetPixelGreen(q);
                  SetPixelGreen(q,image->colormap[(ssize_t)
                    ConstrainColormapIndex(image,index)].green);
                  index=(ssize_t) GetPixelRed(q);
                  SetPixelBlue(q,image->colormap[(ssize_t)
                    ConstrainColormapIndex(image,index)].blue);
                }
              SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-
                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);
              p++;
              q++;
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    count=ReadBlob(image,1,&viff_info.identifier);
    if ((count != 0) && (viff_info.identifier == 0xab))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (viff_info.identifier == 0xab));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadVIFFImage(const ImageInfo *VAR_0,
  ExceptionInfo *VAR_1)
{
#define VAR_2  15
#define VAR_3  1
#define VAR_4  0
#define VAR_5  0x4
#define VAR_6  0x8
#define VAR_7  0
#define VAR_8  1
#define VAR_9  0
#define VAR_10  1
#define VAR_11  2
#define VAR_12  4
#define VAR_13  5
#define VAR_14  7
#define VAR_15  0
#define VAR_16  1
#define VAR_17  3
#define VAR_18  0
#define VAR_19  1
#define VAR_20  2
#define VAR_21  4
#define VAR_22  5
#define VAR_23  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    VAR_24,
    VAR_25,
    VAR_26;

  Image
    *VAR_27;

  int
    VAR_28;

  MagickBooleanType
    VAR_29;

  MagickSizeType
    VAR_30;

  register IndexPacket
    *VAR_31;

  register ssize_t
    VAR_32;

  register PixelPacket
    *VAR_33;

  register ssize_t
    VAR_34;

  register unsigned char
    *VAR_35;

  size_t
    VAR_36,
    VAR_37,
    VAR_38;

  ssize_t
    VAR_39,
    VAR_40;

  unsigned char
    *VAR_41;

  unsigned long
    VAR_42;

  ViffInfo
    VAR_43;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_44);
  if (VAR_0->debug != VAR_45)
    (void) LogMagickEvent(VAR_46,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_44);
  VAR_27=AcquireImage(VAR_0);
  VAR_29=OpenBlob(VAR_0,VAR_27,VAR_47,VAR_1);
  if (VAR_29 == VAR_45)
    {
      VAR_27=DestroyImageList(VAR_27);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                                  
    
  VAR_39=ReadBlob(VAR_27,1,&VAR_43.identifier);
  do
  {
    /* COMMENT_6 */
                             
      
    if ((VAR_39 != 1) || ((unsigned char) VAR_43.identifier != 0xab))
      ThrowReaderException(VAR_48,""NotAVIFFImage"");
    /* COMMENT_9 */
                            
      
    (void) ReadBlob(VAR_27,sizeof(VAR_43.file_type),&VAR_43.file_type);
    (void) ReadBlob(VAR_27,sizeof(VAR_43.release),&VAR_43.release);
    (void) ReadBlob(VAR_27,sizeof(VAR_43.version),&VAR_43.version);
    (void) ReadBlob(VAR_27,sizeof(VAR_43.machine_dependency),
      &VAR_43.machine_dependency);
    (void) ReadBlob(VAR_27,sizeof(VAR_43.reserve),VAR_43.reserve);
    (void) ReadBlob(VAR_27,512,(unsigned char *) VAR_43.comment);
    VAR_43.comment[511]='\0';
    if (strlen(VAR_43.comment) > 4)
      (void) SetImageProperty(VAR_27,""comment"",VAR_43.comment);
    if ((VAR_43.machine_dependency == VAR_5) ||
        (VAR_43.machine_dependency == VAR_6))
      VAR_27->endian=VAR_49;
    else
      VAR_27->endian=VAR_50;
    VAR_43.rows=ReadBlobLong(VAR_27);
    VAR_43.columns=ReadBlobLong(VAR_27);
    VAR_43.subrows=ReadBlobLong(VAR_27);
    VAR_43.x_offset=ReadBlobSignedLong(VAR_27);
    VAR_43.y_offset=ReadBlobSignedLong(VAR_27);
    VAR_43.x_bits_per_pixel=(float) ReadBlobLong(VAR_27);
    VAR_43.y_bits_per_pixel=(float) ReadBlobLong(VAR_27);
    VAR_43.location_type=ReadBlobLong(VAR_27);
    VAR_43.location_dimension=ReadBlobLong(VAR_27);
    VAR_43.number_of_images=ReadBlobLong(VAR_27);
    VAR_43.number_data_bands=ReadBlobLong(VAR_27);
    VAR_43.data_storage_type=ReadBlobLong(VAR_27);
    VAR_43.data_encode_scheme=ReadBlobLong(VAR_27);
    VAR_43.map_scheme=ReadBlobLong(VAR_27);
    VAR_43.map_storage_type=ReadBlobLong(VAR_27);
    VAR_43.map_rows=ReadBlobLong(VAR_27);
    VAR_43.map_columns=ReadBlobLong(VAR_27);
    VAR_43.map_subrows=ReadBlobLong(VAR_27);
    VAR_43.map_enable=ReadBlobLong(VAR_27);
    VAR_43.maps_per_cycle=ReadBlobLong(VAR_27);
    VAR_43.color_space_model=ReadBlobLong(VAR_27);
    for (VAR_34=0; VAR_34 < 420; VAR_34++)
      (void) ReadBlobByte(VAR_27);
    if (EOFBlob(VAR_27) != VAR_45)
      ThrowReaderException(VAR_48,""UnexpectedEndOfFile"");
    VAR_27->columns=VAR_43.rows;
    VAR_27->rows=VAR_43.columns;
    VAR_27->depth=VAR_43.x_bits_per_pixel <= 8 ? 8UL :
      VAR_51;
    /* COMMENT_12 */
                                              
      
    VAR_30=(MagickSizeType) VAR_43.columns*VAR_43.rows;
    if (VAR_30 != (size_t) VAR_30)
      ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
    if (VAR_30 == 0)
      ThrowReaderException(VAR_53,""ImageColumnOrRowSizeIsNotSupported"");
    if ((VAR_43.number_data_bands < 1) || (VAR_43.number_data_bands > 4))
      ThrowReaderException(VAR_48,""ImproperImageHeader"");
    if ((VAR_43.data_storage_type != VAR_18) &&
        (VAR_43.data_storage_type != VAR_19) &&
        (VAR_43.data_storage_type != VAR_20) &&
        (VAR_43.data_storage_type != VAR_21) &&
        (VAR_43.data_storage_type != VAR_22) &&
        (VAR_43.data_storage_type != VAR_23))
      ThrowReaderException(VAR_53,""DataStorageTypeIsNotSupported"");
    if (VAR_43.data_encode_scheme != VAR_7)
      ThrowReaderException(VAR_53,""DataEncodingSchemeIsNotSupported"");
    if ((VAR_43.map_storage_type != VAR_9) &&
        (VAR_43.map_storage_type != VAR_10) &&
        (VAR_43.map_storage_type != VAR_11) &&
        (VAR_43.map_storage_type != VAR_12) &&
        (VAR_43.map_storage_type != VAR_13) &&
        (VAR_43.map_storage_type != VAR_14))
      ThrowReaderException(VAR_53,""MapStorageTypeIsNotSupported"");
    if ((VAR_43.color_space_model != VAR_4) &&
        (VAR_43.color_space_model != VAR_3) &&
        (VAR_43.color_space_model != VAR_2))
      ThrowReaderException(VAR_53,""ColorspaceModelIsNotSupported"");
    if (VAR_43.location_type != VAR_8)
      ThrowReaderException(VAR_53,""LocationTypeIsNotSupported"");
    if (VAR_43.number_of_images != 1)
      ThrowReaderException(VAR_53,""NumberOfImagesIsNotSupported"");
    if (VAR_43.map_rows == 0)
      VAR_43.map_scheme=VAR_15;
    switch ((int) VAR_43.map_scheme)
    {
      case VAR_15:
      {
        if (VAR_43.number_data_bands < 3)
          {
            /* COMMENT_15 */
                                       
              
            if (VAR_43.data_storage_type == VAR_18)
              VAR_27->colors=2;
            else
              if (VAR_43.data_storage_type == VAR_10)
                VAR_27->colors=256UL;
              else
                VAR_27->colors=VAR_27->depth <= 8 ? 256UL : 65536UL;
            if (AcquireImageColormap(VAR_27,VAR_27->colors) == VAR_45)
              ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
          }
        break;
      }
      case VAR_16:
      case VAR_17:
      {
        unsigned char
          *VAR_54;

        /* COMMENT_18 */
                                 
          
        switch ((int) VAR_43.map_storage_type)
        {
          case VAR_10: VAR_36=1; break;
          case VAR_11: VAR_36=2; break;
          case VAR_12: VAR_36=4; break;
          case VAR_13: VAR_36=4; break;
          case VAR_14: VAR_36=8; break;
          default: VAR_36=1; break;
        }
        VAR_27->colors=VAR_43.map_columns;
        if (AcquireImageColormap(VAR_27,VAR_27->colors) == VAR_45)
          ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
        if (VAR_43.map_rows >
            (VAR_43.map_rows*VAR_36*sizeof(*VAR_54)))
          ThrowReaderException(VAR_48,""ImproperImageHeader"");
        VAR_54=(unsigned char *) AcquireQuantumMemory(VAR_27->colors,
          VAR_43.map_rows*VAR_36*sizeof(*VAR_54));
        if (VAR_54 == (unsigned char *) NULL)
          ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
        /* COMMENT_21 */
                                    
          
        (void) ReadBlob(VAR_27,VAR_36*VAR_27->colors*VAR_43.map_rows,
          VAR_54);
        VAR_42=1;
        if (*(char *) &VAR_42 &&
            ((VAR_43.machine_dependency != VAR_5) &&
             (VAR_43.machine_dependency != VAR_6)))
          switch ((int) VAR_43.map_storage_type)
          {
            case VAR_11:
            {
              MSBOrderShort(VAR_54,(VAR_36*VAR_27->colors*
                VAR_43.map_rows));
              break;
            }
            case VAR_12:
            case VAR_13:
            {
              MSBOrderLong(VAR_54,(VAR_36*VAR_27->colors*
                VAR_43.map_rows));
              break;
            }
            default: break;
          }
        for (VAR_34=0; VAR_34 < (ssize_t) (VAR_43.map_rows*VAR_27->colors); VAR_34++)
        {
          switch ((int) VAR_43.map_storage_type)
          {
            case VAR_11: VAR_26=1.0*((short *) VAR_54)[VAR_34]; break;
            case VAR_12: VAR_26=1.0*((int *) VAR_54)[VAR_34]; break;
            case VAR_13: VAR_26=((float *) VAR_54)[VAR_34]; break;
            case VAR_14: VAR_26=((double *) VAR_54)[VAR_34]; break;
            default: VAR_26=1.0*VAR_54[VAR_34]; break;
          }
          if (VAR_34 < (ssize_t) VAR_27->colors)
            {
              VAR_27->colormap[VAR_34].red=ScaleCharToQuantum((unsigned char) VAR_26);
              VAR_27->colormap[VAR_34].green=ScaleCharToQuantum((unsigned char)
                VAR_26);
              VAR_27->colormap[VAR_34].blue=ScaleCharToQuantum((unsigned char) VAR_26);
            }
          else
            if (VAR_34 < (ssize_t) (2*VAR_27->colors))
              VAR_27->colormap[VAR_34 % VAR_27->colors].green=ScaleCharToQuantum(
                (unsigned char) VAR_26);
            else
              if (VAR_34 < (ssize_t) (3*VAR_27->colors))
                VAR_27->colormap[VAR_34 % VAR_27->colors].blue=ScaleCharToQuantum(
                  (unsigned char) VAR_26);
        }
        VAR_54=(unsigned char *) RelinquishMagickMemory(VAR_54);
        break;
      }
      default:
        ThrowReaderException(VAR_53,""ColormapTypeNotSupported"");
    }
    /* COMMENT_24 */
                                 
      
    VAR_27->matte=VAR_43.number_data_bands == 4 ? VAR_55 : VAR_45;
    VAR_27->storage_class=
      (VAR_43.number_data_bands < 3 ? VAR_56 : VAR_57);
    VAR_27->columns=VAR_43.rows;
    VAR_27->rows=VAR_43.columns;
    if ((VAR_0->ping != VAR_45) && (VAR_0->number_scenes != 0))
      if (VAR_27->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_29=SetImageExtent(VAR_27,VAR_27->columns,VAR_27->rows);
    if (VAR_29 == VAR_45)
      {
        InheritException(VAR_1,&VAR_27->exception);
        return(DestroyImageList(VAR_27));
      }
    /* COMMENT_27 */
                           
      
    switch ((int) VAR_43.data_storage_type)
    {
      case VAR_20: VAR_36=2; break;
      case VAR_21: VAR_36=4; break;
      case VAR_22: VAR_36=4; break;
      case VAR_23: VAR_36=8; break;
      default: VAR_36=1; break;
    }
    if (VAR_43.data_storage_type == VAR_18)
      {
        if (HeapOverflowSanityCheck((VAR_27->columns+7UL) >> 3UL,VAR_27->rows) != VAR_45)
          ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
        VAR_37=((VAR_27->columns+7UL) >> 3UL)*VAR_27->rows;
      }
    else
      {
        if (HeapOverflowSanityCheck(VAR_30,VAR_43.number_data_bands) != VAR_45)
          ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
        VAR_37=(size_t) (VAR_30*VAR_43.number_data_bands);
      }
    VAR_41=(unsigned char *) AcquireQuantumMemory(MagickMax(VAR_30,
      VAR_37),VAR_36*sizeof(*VAR_41));
    if (VAR_41 == (unsigned char *) NULL)
      ThrowReaderException(VAR_52,""MemoryAllocationFailed"");
    (void) ReadBlob(VAR_27,VAR_36*VAR_37,VAR_41);
    VAR_42=1;
    if (*(char *) &VAR_42 &&
        ((VAR_43.machine_dependency != VAR_5) &&
         (VAR_43.machine_dependency != VAR_6)))
      switch ((int) VAR_43.data_storage_type)
      {
        case VAR_20:
        {
          MSBOrderShort(VAR_41,VAR_36*VAR_37);
          break;
        }
        case VAR_21:
        case VAR_22:
        {
          MSBOrderLong(VAR_41,VAR_36*VAR_37);
          break;
        }
        default: break;
      }
    VAR_24=0.0;
    VAR_25=1.0;
    if ((VAR_43.data_storage_type != VAR_19) &&
        (VAR_43.map_scheme == VAR_15))
      {
        double
          VAR_58;

        /* COMMENT_30 */
                                 
          
        switch ((int) VAR_43.data_storage_type)
        {
          case VAR_20: VAR_26=1.0*((short *) VAR_41)[0]; break;
          case VAR_21: VAR_26=1.0*((int *) VAR_41)[0]; break;
          case VAR_22: VAR_26=((float *) VAR_41)[0]; break;
          case VAR_23: VAR_26=((double *) VAR_41)[0]; break;
          default: VAR_26=1.0*VAR_41[0]; break;
        }
        VAR_58=VAR_26;
        VAR_24=VAR_26;
        for (VAR_34=0; VAR_34 < (ssize_t) VAR_37; VAR_34++)
        {
          switch ((int) VAR_43.data_storage_type)
          {
            case VAR_20: VAR_26=1.0*((short *) VAR_41)[VAR_34]; break;
            case VAR_21: VAR_26=1.0*((int *) VAR_41)[VAR_34]; break;
            case VAR_22: VAR_26=((float *) VAR_41)[VAR_34]; break;
            case VAR_23: VAR_26=((double *) VAR_41)[VAR_34]; break;
            default: VAR_26=1.0*VAR_41[VAR_34]; break;
          }
          if (VAR_26 > VAR_58)
            VAR_58=VAR_26;
          else
            if (VAR_26 < VAR_24)
              VAR_24=VAR_26;
        }
        if ((VAR_24 == 0) && (VAR_58 == 0))
          VAR_25=0;
        else
          if (VAR_24 == VAR_58)
            {
              VAR_25=(MagickRealType) VAR_59/VAR_24;
              VAR_24=0;
            }
          else
            VAR_25=(MagickRealType) VAR_59/(VAR_58-VAR_24);
      }
    /* COMMENT_33 */
                                     
      
    VAR_35=(unsigned char *) VAR_41;
    for (VAR_34=0; VAR_34 < (ssize_t) VAR_37; VAR_34++)
    {
      switch ((int) VAR_43.data_storage_type)
      {
        case VAR_20: VAR_26=1.0*((short *) VAR_41)[VAR_34]; break;
        case VAR_21: VAR_26=1.0*((int *) VAR_41)[VAR_34]; break;
        case VAR_22: VAR_26=((float *) VAR_41)[VAR_34]; break;
        case VAR_23: VAR_26=((double *) VAR_41)[VAR_34]; break;
        default: VAR_26=1.0*VAR_41[VAR_34]; break;
      }
      if (VAR_43.map_scheme == VAR_15)
        {
          VAR_26=(VAR_26-VAR_24)*VAR_25;
          if (VAR_26 > VAR_59)
            VAR_26=VAR_59;
          else
            if (VAR_26 < 0)
              VAR_26=0;
        }
      *VAR_35=(unsigned char) ((Quantum) VAR_26);
      VAR_35++;
    }
    /* COMMENT_36 */
                                                 
      
    VAR_35=(unsigned char *) VAR_41;
    if (VAR_43.data_storage_type == VAR_18)
      {
        /* COMMENT_39 */
                                  
          
        if (VAR_27->storage_class != VAR_56)
          ThrowReaderException(VAR_48,""ImproperImageHeader"");
        for (VAR_40=0; VAR_40 < (ssize_t) VAR_27->rows; VAR_40++)
        {
          VAR_33=QueueAuthenticPixels(VAR_27,0,VAR_40,VAR_27->columns,1,VAR_1);
          if (VAR_33 == (PixelPacket *) NULL)
            break;
          VAR_31=GetAuthenticIndexQueue(VAR_27);
          for (VAR_32=0; VAR_32 < (ssize_t) (VAR_27->columns-7); VAR_32+=8)
          {
            for (VAR_28=0; VAR_28 < 8; VAR_28++)
            {
              VAR_38=(size_t) ((*VAR_35) & (0x01 << VAR_28) ? 0 : 1);
              SetPixelRed(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
              SetPixelGreen(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
              SetPixelBlue(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
              if (VAR_27->storage_class == VAR_56)
                SetPixelIndex(VAR_31+VAR_32+VAR_28,VAR_38);
             }
            VAR_35++;
          }
          if ((VAR_27->columns % 8) != 0)
            {
              for (VAR_28=0; VAR_28 < (int) (VAR_27->columns % 8); VAR_28++)
              {
                VAR_38=(size_t) ((*VAR_35) & (0x01 << VAR_28) ? 0 : 1);
                SetPixelRed(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
                SetPixelGreen(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
                SetPixelBlue(VAR_33,VAR_38 == 0 ? 0 : VAR_59);
                if (VAR_27->storage_class == VAR_56)
                  SetPixelIndex(VAR_31+VAR_32+VAR_28,VAR_38);
              }
              VAR_35++;
            }
          if (SyncAuthenticPixels(VAR_27,VAR_1) == VAR_45)
            break;
          if (VAR_27->previous == (Image *) NULL)
            {
              VAR_29=SetImageProgress(VAR_27,VAR_60,(MagickOffsetType) VAR_40,
                VAR_27->rows);
              if (VAR_29 == VAR_45)
                break;
            }
        }
      }
    else
      if (VAR_27->storage_class == VAR_56)
        for (VAR_40=0; VAR_40 < (ssize_t) VAR_27->rows; VAR_40++)
        {
          VAR_33=QueueAuthenticPixels(VAR_27,0,VAR_40,VAR_27->columns,1,VAR_1);
          if (VAR_33 == (PixelPacket *) NULL)
            break;
          VAR_31=GetAuthenticIndexQueue(VAR_27);
          for (VAR_32=0; VAR_32 < (ssize_t) VAR_27->columns; VAR_32++)
            SetPixelIndex(VAR_31+VAR_32,*VAR_35++);
          if (SyncAuthenticPixels(VAR_27,VAR_1) == VAR_45)
            break;
          if (VAR_27->previous == (Image *) NULL)
            {
              VAR_29=SetImageProgress(VAR_27,VAR_60,(MagickOffsetType) VAR_40,
                VAR_27->rows);
              if (VAR_29 == VAR_45)
                break;
            }
        }
      else
        {
          /* COMMENT_42 */
                                         
            
          VAR_30=(MagickSizeType) VAR_27->columns*VAR_27->rows;
          for (VAR_40=0; VAR_40 < (ssize_t) VAR_27->rows; VAR_40++)
          {
            VAR_33=QueueAuthenticPixels(VAR_27,0,VAR_40,VAR_27->columns,1,VAR_1);
            if (VAR_33 == (PixelPacket *) NULL)
              break;
            for (VAR_32=0; VAR_32 < (ssize_t) VAR_27->columns; VAR_32++)
            {
              SetPixelRed(VAR_33,ScaleCharToQuantum(*VAR_35));
              SetPixelGreen(VAR_33,ScaleCharToQuantum(*(VAR_35+VAR_30)));
              SetPixelBlue(VAR_33,ScaleCharToQuantum(*(VAR_35+2*VAR_30)));
              if (VAR_27->colors != 0)
                {
                  ssize_t
                    VAR_61;

                  VAR_61=(ssize_t) GetPixelRed(VAR_33);
                  SetPixelRed(VAR_33,VAR_27->colormap[(ssize_t)
                    ConstrainColormapIndex(VAR_27,VAR_61)].red);
                  VAR_61=(ssize_t) GetPixelGreen(VAR_33);
                  SetPixelGreen(VAR_33,VAR_27->colormap[(ssize_t)
                    ConstrainColormapIndex(VAR_27,VAR_61)].green);
                  VAR_61=(ssize_t) GetPixelRed(VAR_33);
                  SetPixelBlue(VAR_33,VAR_27->colormap[(ssize_t)
                    ConstrainColormapIndex(VAR_27,VAR_61)].blue);
                }
              SetPixelOpacity(VAR_33,VAR_27->matte != VAR_45 ? VAR_59-
                ScaleCharToQuantum(*(VAR_35+VAR_30*3)) : VAR_62);
              VAR_35++;
              VAR_33++;
            }
            if (SyncAuthenticPixels(VAR_27,VAR_1) == VAR_45)
              break;
            if (VAR_27->previous == (Image *) NULL)
              {
                VAR_29=SetImageProgress(VAR_27,VAR_60,(MagickOffsetType) VAR_40,
                VAR_27->rows);
                if (VAR_29 == VAR_45)
                  break;
              }
          }
        }
    VAR_41=(unsigned char *) RelinquishMagickMemory(VAR_41);
    if (VAR_27->storage_class == VAR_56)
      (void) SyncImage(VAR_27);
    if (EOFBlob(VAR_27) != VAR_45)
      {
        ThrowFileException(VAR_1,VAR_48,""UnexpectedEndOfFile"",
          VAR_27->filename);
        break;
      }
    /* COMMENT_45 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_27->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_39=ReadBlob(VAR_27,1,&VAR_43.identifier);
    if ((VAR_39 != 0) && (VAR_43.identifier == 0xab))
      {
        /* COMMENT_48 */
                                        
          
        AcquireNextImage(VAR_0,VAR_27);
        if (GetNextImageInList(VAR_27) == (Image *) NULL)
          {
            VAR_27=DestroyImageList(VAR_27);
            return((Image *) NULL);
          }
        VAR_27=SyncNextImageInList(VAR_27);
        VAR_29=SetImageProgress(VAR_27,VAR_63,TellBlob(VAR_27),
          GetBlobSize(VAR_27));
        if (VAR_29 == VAR_45)
          break;
      }
  } while ((VAR_39 != 0) && (VAR_43.identifier == 0xab));
  (void) CloseBlob(VAR_27);
  return(GetFirstImageInList(VAR_27));
}",ImageMagick/0474237508f39c4f783208123431815f1ededb76/viff.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -365,13 +365,13 @@
     }
     if (viff_info.data_storage_type == VFF_TYP_BIT)
       {
-        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
+        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         max_packets=((image->columns+7UL) >> 3UL)*image->rows;
       }
     else
       {
-        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)
+        if (HeapOverflowSanityCheck(number_pixels,viff_info.number_data_bands) != MagickFalse)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
       }","{'deleted_lines': ['        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)', '        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)'], 'added_lines': ['        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)', '        if (HeapOverflowSanityCheck(number_pixels,viff_info.number_data_bands) != MagickFalse)']}",True,"magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving ""too many exceptions,"" which trigger a buffer overflow.",7.5,HIGH,2,valid,2016-05-29T15:38:56Z,1
CVE-2016-10067,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Suspend exception processing if there are too many exceptions,0474237508f39c4f783208123431815f1ededb76,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,magick/memory.c,AcquireQuantumMemory,"MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)
{
size_t
extent;
if (CheckMemoryOverflow(count,quantum) != MagickFalse)
return((void *) NULL);
extent=count*quantum;
return(AcquireMagickMemory(extent));
}","MagickExport VAR_0 *AcquireQuantumMemory(const size_t VAR_1,const size_t VAR_2)
{
size_t
VAR_3;
if (CheckMemoryOverflow(VAR_1,VAR_2) != VAR_4)
return((void *) NULL);
VAR_3=VAR_1*VAR_2;
return(AcquireMagickMemory(VAR_3));
}",,"MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)
{
  size_t
    extent;

  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
    return((void *) NULL);
  extent=count*quantum;
  return(AcquireMagickMemory(extent));
}","MagickExport VAR_0 *AcquireQuantumMemory(const size_t VAR_1,const size_t VAR_2)
{
  size_t
    VAR_3;

  if (HeapOverflowSanityCheck(VAR_1,VAR_2) != VAR_4)
    return((void *) NULL);
  VAR_3=VAR_1*VAR_2;
  return(AcquireMagickMemory(VAR_3));
}",,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
   size_t
     extent;
 
-  if (CheckMemoryOverflow(count,quantum) != MagickFalse)
+  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
     return((void *) NULL);
   extent=count*quantum;
   return(AcquireMagickMemory(extent));","{'deleted_lines': ['  if (CheckMemoryOverflow(count,quantum) != MagickFalse)'], 'added_lines': ['  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)']}",True,"magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving ""too many exceptions,"" which trigger a buffer overflow.",7.5,HIGH,2,valid,2016-05-29T15:38:56Z,1
CVE-2016-10067,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Suspend exception processing if there are too many exceptions,0474237508f39c4f783208123431815f1ededb76,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,magick/memory.c,AcquireVirtualMemory,"MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,
const size_t quantum)
{
MemoryInfo
*memory_info;
size_t
extent;
if (CheckMemoryOverflow(count,quantum) != MagickFalse)
return((MemoryInfo *) NULL);
memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,
sizeof(*memory_info)));
if (memory_info == (MemoryInfo *) NULL)
ThrowFatalException(ResourceLimitFatalError,""MemoryAllocationFailed"");
(void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));
extent=count*quantum;
memory_info->length=extent;
memory_info->signature=MagickSignature;
if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)
{
memory_info->blob=AcquireAlignedMemory(1,extent);
if (memory_info->blob != NULL)
{
memory_info->type=AlignedVirtualMemory;
return(memory_info);
}
}
RelinquishMagickResource(MemoryResource,extent);
if (AcquireMagickResource(MapResource,extent) != MagickFalse)
{
memory_info->blob=MapBlob(-1,IOMode,0,extent);
if (memory_info->blob != NULL)
{
memory_info->type=MapVirtualMemory;
return(memory_info);
}
if (AcquireMagickResource(DiskResource,extent) != MagickFalse)
{
int
file;
file=AcquireUniqueFileResource(memory_info->filename);
if (file != -1)
{
MagickOffsetType
offset;
offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);
if ((offset == (MagickOffsetType) (extent-1)) &&
(write(file,"""",1) == 1))
{
memory_info->blob=MapBlob(file,IOMode,0,extent);
if (memory_info->blob != NULL)
{
(void) close(file);
memory_info->type=MapVirtualMemory;
return(memory_info);
}
}
(void) close(file);
(void) RelinquishUniqueFileResource(memory_info->filename);
*memory_info->filename='\0';
}
}
RelinquishMagickResource(DiskResource,extent);
}
RelinquishMagickResource(MapResource,extent);
if (memory_info->blob == NULL)
{
memory_info->blob=AcquireMagickMemory(extent);
if (memory_info->blob != NULL)
memory_info->type=UnalignedVirtualMemory;
}
if (memory_info->blob == NULL)
memory_info=RelinquishVirtualMemory(memory_info);
return(memory_info);
}","MagickExport VAR_0 *AcquireVirtualMemory(const size_t VAR_1,
const size_t VAR_2)
{
MemoryInfo
*VAR_3;
size_t
VAR_4;
if (CheckMemoryOverflow(VAR_1,VAR_2) != VAR_5)
return((MemoryInfo *) NULL);
VAR_3=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,
sizeof(*VAR_3)));
if (VAR_3 == (MemoryInfo *) NULL)
ThrowFatalException(VAR_6,""MemoryAllocationFailed"");
(void) ResetMagickMemory(VAR_3,0,sizeof(*VAR_3));
VAR_4=VAR_1*VAR_2;
VAR_3->length=VAR_4;
VAR_3->signature=VAR_7;
if (AcquireMagickResource(VAR_8,VAR_4) != VAR_5)
{
VAR_3->blob=AcquireAlignedMemory(1,VAR_4);
if (VAR_3->blob != NULL)
{
VAR_3->type=VAR_9;
return(VAR_3);
}
}
RelinquishMagickResource(VAR_8,VAR_4);
if (AcquireMagickResource(VAR_10,VAR_4) != VAR_5)
{
VAR_3->blob=MapBlob(-1,VAR_11,0,VAR_4);
if (VAR_3->blob != NULL)
{
VAR_3->type=VAR_12;
return(VAR_3);
}
if (AcquireMagickResource(VAR_13,VAR_4) != VAR_5)
{
int
VAR_14;
VAR_14=AcquireUniqueFileResource(VAR_3->filename);
if (VAR_14 != -1)
{
MagickOffsetType
VAR_15;
VAR_15=(MagickOffsetType) lseek(VAR_14,VAR_4-1,VAR_16);
if ((VAR_15 == (MagickOffsetType) (VAR_4-1)) &&
(write(VAR_14,"""",1) == 1))
{
VAR_3->blob=MapBlob(VAR_14,VAR_11,0,VAR_4);
if (VAR_3->blob != NULL)
{
(void) close(VAR_14);
VAR_3->type=VAR_12;
return(VAR_3);
}
}
(void) close(VAR_14);
(void) RelinquishUniqueFileResource(VAR_3->filename);
*VAR_3->filename='\0';
}
}
RelinquishMagickResource(VAR_13,VAR_4);
}
RelinquishMagickResource(VAR_10,VAR_4);
if (VAR_3->blob == NULL)
{
VAR_3->blob=AcquireMagickMemory(VAR_4);
if (VAR_3->blob != NULL)
VAR_3->type=VAR_17;
}
if (VAR_3->blob == NULL)
VAR_3=RelinquishVirtualMemory(VAR_3);
return(VAR_3);
}",,"MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,
  const size_t quantum)
{
  MemoryInfo
    *memory_info;

  size_t
    extent;

  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
    return((MemoryInfo *) NULL);
  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,
    sizeof(*memory_info)));
  if (memory_info == (MemoryInfo *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""MemoryAllocationFailed"");
  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));
  extent=count*quantum;
  memory_info->length=extent;
  memory_info->signature=MagickSignature;
  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)
    {
      memory_info->blob=AcquireAlignedMemory(1,extent);
      if (memory_info->blob != NULL)
        {
          memory_info->type=AlignedVirtualMemory;
          return(memory_info);
        }
    }
  RelinquishMagickResource(MemoryResource,extent);
  if (AcquireMagickResource(MapResource,extent) != MagickFalse)
    {
      /*
        Heap memory failed, try anonymous memory mapping.
      */
      memory_info->blob=MapBlob(-1,IOMode,0,extent);
      if (memory_info->blob != NULL)
        {
          memory_info->type=MapVirtualMemory;
          return(memory_info);
        }
      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)
        {
          int
            file;

          /*
            Anonymous memory mapping failed, try file-backed memory mapping.
            If the MapResource request failed, there is no point in trying
            file-backed memory mapping.
          */
          file=AcquireUniqueFileResource(memory_info->filename);
          if (file != -1)
            {
              MagickOffsetType
                offset;

              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);
              if ((offset == (MagickOffsetType) (extent-1)) &&
                  (write(file,"""",1) == 1))
                {
                  memory_info->blob=MapBlob(file,IOMode,0,extent);
                  if (memory_info->blob != NULL)
                    {
                      (void) close(file);
                      memory_info->type=MapVirtualMemory;
                      return(memory_info);
                    }
                }
              /*
                File-backed memory mapping failed, delete the temporary file.
              */
              (void) close(file);
              (void) RelinquishUniqueFileResource(memory_info->filename);
              *memory_info->filename='\0';
            }
        }
      RelinquishMagickResource(DiskResource,extent);
    }
  RelinquishMagickResource(MapResource,extent);
  if (memory_info->blob == NULL)
    {
      memory_info->blob=AcquireMagickMemory(extent);
      if (memory_info->blob != NULL)
        memory_info->type=UnalignedVirtualMemory;
    }
  if (memory_info->blob == NULL)
    memory_info=RelinquishVirtualMemory(memory_info);
  return(memory_info);
}","MagickExport VAR_0 *AcquireVirtualMemory(const size_t VAR_1,
  const size_t VAR_2)
{
  MemoryInfo
    *VAR_3;

  size_t
    VAR_4;

  if (HeapOverflowSanityCheck(VAR_1,VAR_2) != VAR_5)
    return((MemoryInfo *) NULL);
  VAR_3=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,
    sizeof(*VAR_3)));
  if (VAR_3 == (MemoryInfo *) NULL)
    ThrowFatalException(VAR_6,""MemoryAllocationFailed"");
  (void) ResetMagickMemory(VAR_3,0,sizeof(*VAR_3));
  VAR_4=VAR_1*VAR_2;
  VAR_3->length=VAR_4;
  VAR_3->signature=VAR_7;
  if (AcquireMagickResource(VAR_8,VAR_4) != VAR_5)
    {
      VAR_3->blob=AcquireAlignedMemory(1,VAR_4);
      if (VAR_3->blob != NULL)
        {
          VAR_3->type=VAR_9;
          return(VAR_3);
        }
    }
  RelinquishMagickResource(VAR_8,VAR_4);
  if (AcquireMagickResource(VAR_10,VAR_4) != VAR_5)
    {
      /* COMMENT_0 */
                                                         
        
      VAR_3->blob=MapBlob(-1,VAR_11,0,VAR_4);
      if (VAR_3->blob != NULL)
        {
          VAR_3->type=VAR_12;
          return(VAR_3);
        }
      if (AcquireMagickResource(VAR_13,VAR_4) != VAR_5)
        {
          int
            VAR_14;

          /* COMMENT_3 */
                                                                            
                                                                          
                                       
            
          VAR_14=AcquireUniqueFileResource(VAR_3->filename);
          if (VAR_14 != -1)
            {
              MagickOffsetType
                VAR_15;

              VAR_15=(MagickOffsetType) lseek(VAR_14,VAR_4-1,VAR_16);
              if ((VAR_15 == (MagickOffsetType) (VAR_4-1)) &&
                  (write(VAR_14,"""",1) == 1))
                {
                  VAR_3->blob=MapBlob(VAR_14,VAR_11,0,VAR_4);
                  if (VAR_3->blob != NULL)
                    {
                      (void) close(VAR_14);
                      VAR_3->type=VAR_12;
                      return(VAR_3);
                    }
                }
              /* COMMENT_8 */
                                                                             
                
              (void) close(VAR_14);
              (void) RelinquishUniqueFileResource(VAR_3->filename);
              *VAR_3->filename='\0';
            }
        }
      RelinquishMagickResource(VAR_13,VAR_4);
    }
  RelinquishMagickResource(VAR_10,VAR_4);
  if (VAR_3->blob == NULL)
    {
      VAR_3->blob=AcquireMagickMemory(VAR_4);
      if (VAR_3->blob != NULL)
        VAR_3->type=VAR_17;
    }
  if (VAR_3->blob == NULL)
    VAR_3=RelinquishVirtualMemory(VAR_3);
  return(VAR_3);
}",,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
   size_t
     extent;
 
-  if (CheckMemoryOverflow(count,quantum) != MagickFalse)
+  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
     return((MemoryInfo *) NULL);
   memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,
     sizeof(*memory_info)));","{'deleted_lines': ['  if (CheckMemoryOverflow(count,quantum) != MagickFalse)'], 'added_lines': ['  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)']}",True,"magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving ""too many exceptions,"" which trigger a buffer overflow.",7.5,HIGH,2,valid,2016-05-29T15:38:56Z,1
CVE-2016-10067,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Suspend exception processing if there are too many exceptions,0474237508f39c4f783208123431815f1ededb76,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,magick/memory.c,AcquireAlignedMemory,"MagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)
{
#define AlignedExtent(size,alignment) \
(((size)+((alignment)-1)) & ~((alignment)-1))
size_t
alignment,
extent,
size;
void
*memory;
if (CheckMemoryOverflow(count,quantum) != MagickFalse)
return((void *) NULL);
memory=NULL;
alignment=CACHE_LINE_SIZE;
size=count*quantum;
extent=AlignedExtent(size,alignment);
if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))
return((void *) NULL);
#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)
if (posix_memalign(&memory,alignment,extent) != 0)
memory=NULL;
#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)
memory=_aligned_malloc(extent,alignment);
#else
{
void
*p;
extent=(size+alignment-1)+sizeof(void *);
if (extent > size)
{
p=malloc(extent);
if (p != NULL)
{
memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);
*((void **) memory-1)=p;
}
}
}
#endif
return(memory);
}","MagickExport VAR_0 *AcquireAlignedMemory(const size_t VAR_1,const size_t VAR_2)
{
#define AlignedExtent(VAR_3,VAR_4) \
(((size)+((alignment)-1)) & ~((alignment)-1))
size_t
VAR_4,
VAR_5,
VAR_3;
void
*VAR_6;
if (CheckMemoryOverflow(VAR_1,VAR_2) != VAR_7)
return((void *) NULL);
VAR_6=NULL;
VAR_4=VAR_8;
VAR_3=VAR_1*VAR_2;
VAR_5=AlignedExtent(VAR_3,VAR_4);
if ((VAR_3 == 0) || (VAR_4 < sizeof(void *)) || (VAR_5 < VAR_3))
return((void *) NULL);
#if defined(VAR_9)
if (posix_memalign(&VAR_6,VAR_4,VAR_5) != 0)
VAR_6=NULL;
#elif defined(VAR_10)
VAR_6=_aligned_malloc(VAR_5,VAR_4);
#else
{
void
*VAR_11;
VAR_5=(VAR_3+VAR_4-1)+sizeof(void *);
if (VAR_5 > VAR_3)
{
VAR_11=malloc(VAR_5);
if (VAR_11 != NULL)
{
VAR_6=(void *) AlignedExtent((size_t) VAR_11+sizeof(void *),VAR_4);
*((void **) VAR_6-1)=VAR_11;
}
}
}
#endif
return(VAR_6);
}",,"MagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)
{
#define AlignedExtent(size,alignment) \
  (((size)+((alignment)-1)) & ~((alignment)-1))

  size_t
    alignment,
    extent,
    size;

  void
    *memory;

  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
    return((void *) NULL);
  memory=NULL;
  alignment=CACHE_LINE_SIZE;
  size=count*quantum;
  extent=AlignedExtent(size,alignment);
  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))
    return((void *) NULL);
#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)
  if (posix_memalign(&memory,alignment,extent) != 0)
    memory=NULL;
#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)
  memory=_aligned_malloc(extent,alignment);
#else
  {
    void
      *p;

    extent=(size+alignment-1)+sizeof(void *);
    if (extent > size)
      {
        p=malloc(extent);
        if (p != NULL)
          {
            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);
            *((void **) memory-1)=p;
          }
      }
  }
#endif
  return(memory);
}","MagickExport VAR_0 *AcquireAlignedMemory(const size_t VAR_1,const size_t VAR_2)
{
#define AlignedExtent(VAR_3,VAR_4) \
  (((size)+((alignment)-1)) & ~((alignment)-1))

  size_t
    VAR_4,
    VAR_5,
    VAR_3;

  void
    *VAR_6;

  if (HeapOverflowSanityCheck(VAR_1,VAR_2) != VAR_7)
    return((void *) NULL);
  VAR_6=NULL;
  VAR_4=VAR_8;
  VAR_3=VAR_1*VAR_2;
  VAR_5=AlignedExtent(VAR_3,VAR_4);
  if ((VAR_3 == 0) || (VAR_4 < sizeof(void *)) || (VAR_5 < VAR_3))
    return((void *) NULL);
#if defined(VAR_9)
  if (posix_memalign(&VAR_6,VAR_4,VAR_5) != 0)
    VAR_6=NULL;
#elif defined(VAR_10)
  VAR_6=_aligned_malloc(VAR_5,VAR_4);
#else
  {
    void
      *VAR_11;

    VAR_5=(VAR_3+VAR_4-1)+sizeof(void *);
    if (VAR_5 > VAR_3)
      {
        VAR_11=malloc(VAR_5);
        if (VAR_11 != NULL)
          {
            VAR_6=(void *) AlignedExtent((size_t) VAR_11+sizeof(void *),VAR_4);
            *((void **) VAR_6-1)=VAR_11;
          }
      }
  }
#endif
  return(VAR_6);
}",,"--- func_before
+++ func_after
@@ -11,7 +11,7 @@
   void
     *memory;
 
-  if (CheckMemoryOverflow(count,quantum) != MagickFalse)
+  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
     return((void *) NULL);
   memory=NULL;
   alignment=CACHE_LINE_SIZE;","{'deleted_lines': ['  if (CheckMemoryOverflow(count,quantum) != MagickFalse)'], 'added_lines': ['  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)']}",True,"magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving ""too many exceptions,"" which trigger a buffer overflow.",7.5,HIGH,2,valid,2016-05-29T15:38:56Z,1
CVE-2016-10067,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Suspend exception processing if there are too many exceptions,0474237508f39c4f783208123431815f1ededb76,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,magick/memory.c,ResizeQuantumMemory,"MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,
const size_t quantum)
{
size_t
extent;
if (CheckMemoryOverflow(count,quantum) != MagickFalse)
{
memory=RelinquishMagickMemory(memory);
return((void *) NULL);
}
extent=count*quantum;
return(ResizeMagickMemory(memory,extent));
}","MagickExport VAR_0 *ResizeQuantumMemory(void *VAR_1,const size_t VAR_2,
const size_t VAR_3)
{
size_t
VAR_4;
if (CheckMemoryOverflow(VAR_2,VAR_3) != VAR_5)
{
VAR_1=RelinquishMagickMemory(VAR_1);
return((void *) NULL);
}
VAR_4=VAR_2*VAR_3;
return(ResizeMagickMemory(VAR_1,VAR_4));
}",,"MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,
  const size_t quantum)
{
  size_t
    extent;

  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
    {
      memory=RelinquishMagickMemory(memory);
      return((void *) NULL);
    }
  extent=count*quantum;
  return(ResizeMagickMemory(memory,extent));
}","MagickExport VAR_0 *ResizeQuantumMemory(void *VAR_1,const size_t VAR_2,
  const size_t VAR_3)
{
  size_t
    VAR_4;

  if (HeapOverflowSanityCheck(VAR_2,VAR_3) != VAR_5)
    {
      VAR_1=RelinquishMagickMemory(VAR_1);
      return((void *) NULL);
    }
  VAR_4=VAR_2*VAR_3;
  return(ResizeMagickMemory(VAR_1,VAR_4));
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
   size_t
     extent;
 
-  if (CheckMemoryOverflow(count,quantum) != MagickFalse)
+  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)
     {
       memory=RelinquishMagickMemory(memory);
       return((void *) NULL);","{'deleted_lines': ['  if (CheckMemoryOverflow(count,quantum) != MagickFalse)'], 'added_lines': ['  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)']}",True,"magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving ""too many exceptions,"" which trigger a buffer overflow.",7.5,HIGH,2,valid,2016-05-29T15:38:56Z,1
CVE-2016-10067,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Suspend exception processing if there are too many exceptions,0474237508f39c4f783208123431815f1ededb76,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,magick/exception.c,CatchException,"MagickExport void CatchException(ExceptionInfo *exception)
{
register const ExceptionInfo
*p;
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
if (exception->exceptions  == (void *) NULL)
return;
LockSemaphoreInfo(exception->semaphore);
ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);
p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
exception->exceptions);
while (p != (const ExceptionInfo *) NULL)
{
if ((p->severity >= WarningException) && (p->severity < ErrorException))
MagickWarning(p->severity,p->reason,p->description);
if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))
MagickError(p->severity,p->reason,p->description);
if (p->severity >= FatalErrorException)
MagickFatalError(p->severity,p->reason,p->description);
p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
exception->exceptions);
}
UnlockSemaphoreInfo(exception->semaphore);
ClearMagickException(exception);
}","MagickExport VAR_0 CatchException(ExceptionInfo *VAR_1)
{
register const ExceptionInfo
*VAR_2;
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_3);
if (VAR_1->exceptions  == (void *) NULL)
return;
LockSemaphoreInfo(VAR_1->semaphore);
ResetLinkedListIterator((LinkedListInfo *) VAR_1->exceptions);
VAR_2=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
VAR_1->exceptions);
while (VAR_2 != (const ExceptionInfo *) NULL)
{
if ((VAR_2->severity >= VAR_4) && (VAR_2->severity < VAR_5))
MagickWarning(VAR_2->severity,VAR_2->reason,VAR_2->description);
if ((VAR_2->severity >= VAR_5) && (VAR_2->severity < VAR_6))
MagickError(VAR_2->severity,VAR_2->reason,VAR_2->description);
if (VAR_2->severity >= VAR_6)
MagickFatalError(VAR_2->severity,VAR_2->reason,VAR_2->description);
VAR_2=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
VAR_1->exceptions);
}
UnlockSemaphoreInfo(VAR_1->semaphore);
ClearMagickException(VAR_1);
}",,"MagickExport void CatchException(ExceptionInfo *exception)
{
  register const ExceptionInfo
    *p;

  ssize_t
    i;

  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  if (exception->exceptions  == (void *) NULL)
    return;
  LockSemaphoreInfo(exception->semaphore);
  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);
  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
    exception->exceptions);
  for (i=0; p != (const ExceptionInfo *) NULL; i++)
  {
    if (p->severity >= FatalErrorException)
      MagickFatalError(p->severity,p->reason,p->description);
    if (i < MaxExceptions)
      {
        if ((p->severity >= ErrorException) && 
            (p->severity < FatalErrorException))
          MagickError(p->severity,p->reason,p->description);
        if ((p->severity >= WarningException) && (p->severity < ErrorException))
          MagickWarning(p->severity,p->reason,p->description);
      }
    else
      if (i == MaxExceptions)
        MagickError(ResourceLimitError,""too many exceptions"",
          ""exception processing suspended"");
    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
      exception->exceptions);
  }
  UnlockSemaphoreInfo(exception->semaphore);
  ClearMagickException(exception);
}","MagickExport VAR_0 CatchException(ExceptionInfo *VAR_1)
{
  register const ExceptionInfo
    *VAR_2;

  ssize_t
    VAR_3;

  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_4);
  if (VAR_1->exceptions  == (void *) NULL)
    return;
  LockSemaphoreInfo(VAR_1->semaphore);
  ResetLinkedListIterator((LinkedListInfo *) VAR_1->exceptions);
  VAR_2=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
    VAR_1->exceptions);
  for (VAR_3=0; VAR_2 != (const ExceptionInfo *) NULL; VAR_3++)
  {
    if (VAR_2->severity >= VAR_5)
      MagickFatalError(VAR_2->severity,VAR_2->reason,VAR_2->description);
    if (VAR_3 < VAR_6)
      {
        if ((VAR_2->severity >= VAR_7) && 
            (VAR_2->severity < VAR_5))
          MagickError(VAR_2->severity,VAR_2->reason,VAR_2->description);
        if ((VAR_2->severity >= VAR_8) && (VAR_2->severity < VAR_7))
          MagickWarning(VAR_2->severity,VAR_2->reason,VAR_2->description);
      }
    else
      if (VAR_3 == VAR_6)
        MagickError(VAR_9,""too many exceptions"",
          ""exception processing suspended"");
    VAR_2=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
      VAR_1->exceptions);
  }
  UnlockSemaphoreInfo(VAR_1->semaphore);
  ClearMagickException(VAR_1);
}",,"--- func_before
+++ func_after
@@ -2,6 +2,9 @@
 {
   register const ExceptionInfo
     *p;
+
+  ssize_t
+    i;
 
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
@@ -11,14 +14,22 @@
   ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);
   p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
     exception->exceptions);
-  while (p != (const ExceptionInfo *) NULL)
+  for (i=0; p != (const ExceptionInfo *) NULL; i++)
   {
-    if ((p->severity >= WarningException) && (p->severity < ErrorException))
-      MagickWarning(p->severity,p->reason,p->description);
-    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))
-      MagickError(p->severity,p->reason,p->description);
     if (p->severity >= FatalErrorException)
       MagickFatalError(p->severity,p->reason,p->description);
+    if (i < MaxExceptions)
+      {
+        if ((p->severity >= ErrorException) && 
+            (p->severity < FatalErrorException))
+          MagickError(p->severity,p->reason,p->description);
+        if ((p->severity >= WarningException) && (p->severity < ErrorException))
+          MagickWarning(p->severity,p->reason,p->description);
+      }
+    else
+      if (i == MaxExceptions)
+        MagickError(ResourceLimitError,""too many exceptions"",
+          ""exception processing suspended"");
     p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)
       exception->exceptions);
   }","{'deleted_lines': ['  while (p != (const ExceptionInfo *) NULL)', '    if ((p->severity >= WarningException) && (p->severity < ErrorException))', '      MagickWarning(p->severity,p->reason,p->description);', '    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))', '      MagickError(p->severity,p->reason,p->description);'], 'added_lines': ['', '  ssize_t', '    i;', '  for (i=0; p != (const ExceptionInfo *) NULL; i++)', '    if (i < MaxExceptions)', '      {', '        if ((p->severity >= ErrorException) && ', '            (p->severity < FatalErrorException))', '          MagickError(p->severity,p->reason,p->description);', '        if ((p->severity >= WarningException) && (p->severity < ErrorException))', '          MagickWarning(p->severity,p->reason,p->description);', '      }', '    else', '      if (i == MaxExceptions)', '        MagickError(ResourceLimitError,""too many exceptions"",', '          ""exception processing suspended"");']}",True,"magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving ""too many exceptions,"" which trigger a buffer overflow.",7.5,HIGH,2,valid,2016-05-29T15:38:56Z,1
CVE-2016-10067,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Suspend exception processing if there are too many exceptions,0474237508f39c4f783208123431815f1ededb76,https://github.com/ImageMagick/ImageMagick/commit/0474237508f39c4f783208123431815f1ededb76,coders/label.c,ReadLABELImage,"static Image *ReadLABELImage(const ImageInfo *image_info,
ExceptionInfo *exception)
{
char
geometry[MaxTextExtent],
*property;
const char
*label;
DrawInfo
*draw_info;
Image
*image;
MagickBooleanType
status;
TypeMetric
metrics;
size_t
height,
width;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info);
(void) ResetImagePage(image,""0x0+0+0"");
property=InterpretImageProperties(image_info,image,image_info->filename);
(void) SetImageProperty(image,""label"",property);
property=DestroyString(property);
label=GetImageProperty(image,""label"");
draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
draw_info->text=ConstantString(label);
metrics.width=0;
metrics.ascent=0.0;
status=GetMultilineTypeMetrics(image,draw_info,&metrics);
if ((image->columns == 0) && (image->rows == 0))
{
image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
}
else
if (((image->columns == 0) || (image->rows == 0)) ||
(fabs(image_info->pointsize) < MagickEpsilon))
{
double
high,
low;
for ( ; ; draw_info->pointsize*=2.0)
{
(void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
-metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
(void) GetMultilineTypeMetrics(image,draw_info,&metrics);
width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
if ((image->columns != 0) && (image->rows != 0))
{
if ((width >= image->columns) && (height >= image->rows))
break;
}
else
if (((image->columns != 0) && (width >= image->columns)) ||
((image->rows != 0) && (height >= image->rows)))
break;
}
high=draw_info->pointsize;
for (low=1.0; (high-low) > 0.5; )
{
draw_info->pointsize=(low+high)/2.0;
(void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
-metrics.bounds.x1,metrics.ascent);
if (draw_info->gravity == UndefinedGravity)
(void) CloneString(&draw_info->geometry,geometry);
(void) GetMultilineTypeMetrics(image,draw_info,&metrics);
width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
if ((image->columns != 0) && (image->rows != 0))
{
if ((width < image->columns) && (height < image->rows))
low=draw_info->pointsize+0.5;
else
high=draw_info->pointsize-0.5;
}
else
if (((image->columns != 0) && (width < image->columns)) ||
((image->rows != 0) && (height < image->rows)))
low=draw_info->pointsize+0.5;
else
high=draw_info->pointsize-0.5;
}
draw_info->pointsize=(low+high)/2.0-0.5;
}
status=GetMultilineTypeMetrics(image,draw_info,&metrics);
if (status == MagickFalse)
{
draw_info=DestroyDrawInfo(draw_info);
InheritException(exception,&image->exception);
image=DestroyImageList(image);
return((Image *) NULL);
}
if (image->columns == 0)
image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
if (image->columns == 0)
image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
if (image->rows == 0)
image->rows=(size_t) (metrics.ascent-metrics.descent+
draw_info->stroke_width+0.5);
if (image->rows == 0)
image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
draw_info=DestroyDrawInfo(draw_info);
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
if (SetImageBackgroundColor(image) == MagickFalse)
{
draw_info=DestroyDrawInfo(draw_info);
InheritException(exception,&image->exception);
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
draw_info->direction == RightToLeftDirection ? image->columns-
metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?
metrics.ascent : 0.0);
draw_info->geometry=AcquireString(geometry);
status=AnnotateImage(image,draw_info);
if (image_info->pointsize == 0.0)
{
char
pointsize[MaxTextExtent];
(void) FormatLocaleString(pointsize,MaxTextExtent,""%.20g"",
draw_info->pointsize);
(void) SetImageProperty(image,""label:pointsize"",pointsize);
}
draw_info=DestroyDrawInfo(draw_info);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
return(GetFirstImageInList(image));
}","static Image *ReadLABELImage(const ImageInfo *VAR_0,
ExceptionInfo *VAR_1)
{
char
VAR_2[VAR_3],
*VAR_4;
const char
*VAR_5;
DrawInfo
*VAR_6;
Image
*VAR_7;
MagickBooleanType
VAR_8;
TypeMetric
VAR_9;
size_t
VAR_10,
VAR_11;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_12);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_14,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_12);
VAR_7=AcquireImage(VAR_0);
(void) ResetImagePage(VAR_7,""0x0+0+0"");
VAR_4=InterpretImageProperties(VAR_0,VAR_7,VAR_0->filename);
(void) SetImageProperty(VAR_7,""label"",VAR_4);
VAR_4=DestroyString(VAR_4);
VAR_5=GetImageProperty(VAR_7,""label"");
VAR_6=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
VAR_6->text=ConstantString(VAR_5);
VAR_9.width=0;
VAR_9.ascent=0.0;
VAR_8=GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
if ((VAR_7->columns == 0) && (VAR_7->rows == 0))
{
VAR_7->columns=(size_t) (VAR_9.width+VAR_6->stroke_width+0.5);
VAR_7->rows=(size_t) floor(VAR_9.height+VAR_6->stroke_width+0.5);
}
else
if (((VAR_7->columns == 0) || (VAR_7->rows == 0)) ||
(fabs(VAR_0->pointsize) < VAR_15))
{
double
VAR_16,
VAR_17;
for ( ; ; VAR_6->pointsize*=2.0)
{
(void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
-VAR_9.bounds.x1,VAR_9.ascent);
if (VAR_6->gravity == VAR_18)
(void) CloneString(&VAR_6->geometry,VAR_2);
(void) GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
VAR_11=(size_t) floor(VAR_9.width+VAR_6->stroke_width+0.5);
VAR_10=(size_t) floor(VAR_9.height+VAR_6->stroke_width+0.5);
if ((VAR_7->columns != 0) && (VAR_7->rows != 0))
{
if ((VAR_11 >= VAR_7->columns) && (VAR_10 >= VAR_7->rows))
break;
}
else
if (((VAR_7->columns != 0) && (VAR_11 >= VAR_7->columns)) ||
((VAR_7->rows != 0) && (VAR_10 >= VAR_7->rows)))
break;
}
VAR_16=VAR_6->pointsize;
for (VAR_17=1.0; (VAR_16-VAR_17) > 0.5; )
{
VAR_6->pointsize=(VAR_17+VAR_16)/2.0;
(void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
-VAR_9.bounds.x1,VAR_9.ascent);
if (VAR_6->gravity == VAR_18)
(void) CloneString(&VAR_6->geometry,VAR_2);
(void) GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
VAR_11=(size_t) floor(VAR_9.width+VAR_6->stroke_width+0.5);
VAR_10=(size_t) floor(VAR_9.height+VAR_6->stroke_width+0.5);
if ((VAR_7->columns != 0) && (VAR_7->rows != 0))
{
if ((VAR_11 < VAR_7->columns) && (VAR_10 < VAR_7->rows))
VAR_17=VAR_6->pointsize+0.5;
else
VAR_16=VAR_6->pointsize-0.5;
}
else
if (((VAR_7->columns != 0) && (VAR_11 < VAR_7->columns)) ||
((VAR_7->rows != 0) && (VAR_10 < VAR_7->rows)))
VAR_17=VAR_6->pointsize+0.5;
else
VAR_16=VAR_6->pointsize-0.5;
}
VAR_6->pointsize=(VAR_17+VAR_16)/2.0-0.5;
}
VAR_8=GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
if (VAR_8 == VAR_13)
{
VAR_6=DestroyDrawInfo(VAR_6);
InheritException(VAR_1,&VAR_7->exception);
VAR_7=DestroyImageList(VAR_7);
return((Image *) NULL);
}
if (VAR_7->columns == 0)
VAR_7->columns=(size_t) (VAR_9.width+VAR_6->stroke_width+0.5);
if (VAR_7->columns == 0)
VAR_7->columns=(size_t) (VAR_6->pointsize+VAR_6->stroke_width+0.5);
if (VAR_7->rows == 0)
VAR_7->rows=(size_t) (VAR_9.ascent-VAR_9.descent+
VAR_6->stroke_width+0.5);
if (VAR_7->rows == 0)
VAR_7->rows=(size_t) (VAR_6->pointsize+VAR_6->stroke_width+0.5);
VAR_8=SetImageExtent(VAR_7,VAR_7->columns,VAR_7->rows);
if (VAR_8 == VAR_13)
{
VAR_6=DestroyDrawInfo(VAR_6);
InheritException(VAR_1,&VAR_7->exception);
return(DestroyImageList(VAR_7));
}
if (SetImageBackgroundColor(VAR_7) == VAR_13)
{
VAR_6=DestroyDrawInfo(VAR_6);
InheritException(VAR_1,&VAR_7->exception);
VAR_7=DestroyImageList(VAR_7);
return((Image *) NULL);
}
(void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
VAR_6->direction == VAR_19 ? VAR_7->columns-
VAR_9.bounds.x2 : 0.0,VAR_6->gravity == VAR_18 ?
VAR_9.ascent : 0.0);
VAR_6->geometry=AcquireString(VAR_2);
VAR_8=AnnotateImage(VAR_7,VAR_6);
if (VAR_0->pointsize == 0.0)
{
char
VAR_20[VAR_3];
(void) FormatLocaleString(VAR_20,VAR_3,""%.20g"",
VAR_6->pointsize);
(void) SetImageProperty(VAR_7,""label:pointsize"",VAR_20);
}
VAR_6=DestroyDrawInfo(VAR_6);
if (VAR_8 == VAR_13)
{
VAR_7=DestroyImageList(VAR_7);
return((Image *) NULL);
}
return(GetFirstImageInList(VAR_7));
}",ImageMagick/0474237508f39c4f783208123431815f1ededb76/label.c/vul/before/0.json,"static Image *ReadLABELImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    geometry[MaxTextExtent],
    *property;

  const char
    *label;

  DrawInfo
    *draw_info;

  Image
    *image;

  MagickBooleanType
    status;

  TypeMetric
    metrics;

  size_t
    height,
    width;

  /*
    Initialize Image structure.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  (void) ResetImagePage(image,""0x0+0+0"");
  property=InterpretImageProperties(image_info,image,image_info->filename);
  (void) SetImageProperty(image,""label"",property);
  property=DestroyString(property);
  label=GetImageProperty(image,""label"");
  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
  draw_info->text=ConstantString(label);
  metrics.width=0;
  metrics.ascent=0.0;
  status=GetMultilineTypeMetrics(image,draw_info,&metrics);
  if ((image->columns == 0) && (image->rows == 0))
    {
      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
      image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
    }
  else
    if (((image->columns == 0) || (image->rows == 0)) ||
        (fabs(image_info->pointsize) < MagickEpsilon))
      {
        double
          high,
          low;

        /*
          Auto fit text into bounding box.
        */
        for ( ; ; draw_info->pointsize*=2.0)
        {
          (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
            -metrics.bounds.x1,metrics.ascent);
          if (draw_info->gravity == UndefinedGravity)
            (void) CloneString(&draw_info->geometry,geometry);
          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);
          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
          if ((image->columns != 0) && (image->rows != 0))
            {
              if ((width >= image->columns) && (height >= image->rows))
                break;
            }
          else
            if (((image->columns != 0) && (width >= image->columns)) ||
                ((image->rows != 0) && (height >= image->rows)))
              break;
        }
        high=draw_info->pointsize;
        for (low=1.0; (high-low) > 0.5; )
        {
          draw_info->pointsize=(low+high)/2.0;
          (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
            -metrics.bounds.x1,metrics.ascent);
          if (draw_info->gravity == UndefinedGravity)
            (void) CloneString(&draw_info->geometry,geometry);
          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);
          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
          if ((image->columns != 0) && (image->rows != 0))
            {
              if ((width < image->columns) && (height < image->rows))
                low=draw_info->pointsize+0.5;
              else
                high=draw_info->pointsize-0.5;
            }
          else
            if (((image->columns != 0) && (width < image->columns)) ||
                ((image->rows != 0) && (height < image->rows)))
              low=draw_info->pointsize+0.5;
            else
              high=draw_info->pointsize-0.5;
        }
        draw_info->pointsize=(low+high)/2.0-0.5;
      }
  status=GetMultilineTypeMetrics(image,draw_info,&metrics);
  if (status == MagickFalse)
    {
      draw_info=DestroyDrawInfo(draw_info);
      InheritException(exception,&image->exception);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  if (image->columns == 0)
    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
  if (image->columns == 0)
    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
      0.5);
  if (image->rows == 0)
    image->rows=(size_t) floor(metrics.ascent-metrics.descent+
      draw_info->stroke_width+0.5);
  if (image->rows == 0)
    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
      0.5);
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      draw_info=DestroyDrawInfo(draw_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if (SetImageBackgroundColor(image) == MagickFalse)
    {
      draw_info=DestroyDrawInfo(draw_info);
      InheritException(exception,&image->exception);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Draw label.
  */
  (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
    draw_info->direction == RightToLeftDirection ? image->columns-
    metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?
    metrics.ascent : 0.0);
  draw_info->geometry=AcquireString(geometry);
  status=AnnotateImage(image,draw_info);
  if (image_info->pointsize == 0.0)
    {
      char
        pointsize[MaxTextExtent];

      (void) FormatLocaleString(pointsize,MaxTextExtent,""%.20g"",
        draw_info->pointsize);
      (void) SetImageProperty(image,""label:pointsize"",pointsize);
    }
  draw_info=DestroyDrawInfo(draw_info);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  return(GetFirstImageInList(image));
}","static Image *ReadLABELImage(const ImageInfo *VAR_0,
  ExceptionInfo *VAR_1)
{
  char
    VAR_2[VAR_3],
    *VAR_4;

  const char
    *VAR_5;

  DrawInfo
    *VAR_6;

  Image
    *VAR_7;

  MagickBooleanType
    VAR_8;

  TypeMetric
    VAR_9;

  size_t
    VAR_10,
    VAR_11;

  /* COMMENT_0 */
                               
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_12);
  if (VAR_0->debug != VAR_13)
    (void) LogMagickEvent(VAR_14,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_12);
  VAR_7=AcquireImage(VAR_0);
  (void) ResetImagePage(VAR_7,""0x0+0+0"");
  VAR_4=InterpretImageProperties(VAR_0,VAR_7,VAR_0->filename);
  (void) SetImageProperty(VAR_7,""label"",VAR_4);
  VAR_4=DestroyString(VAR_4);
  VAR_5=GetImageProperty(VAR_7,""label"");
  VAR_6=CloneDrawInfo(VAR_0,(DrawInfo *) NULL);
  VAR_6->text=ConstantString(VAR_5);
  VAR_9.width=0;
  VAR_9.ascent=0.0;
  VAR_8=GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
  if ((VAR_7->columns == 0) && (VAR_7->rows == 0))
    {
      VAR_7->columns=(size_t) floor(VAR_9.width+VAR_6->stroke_width+0.5);
      VAR_7->rows=(size_t) floor(VAR_9.height+VAR_6->stroke_width+0.5);
    }
  else
    if (((VAR_7->columns == 0) || (VAR_7->rows == 0)) ||
        (fabs(VAR_0->pointsize) < VAR_15))
      {
        double
          VAR_16,
          VAR_17;

        /* COMMENT_3 */
                                          
          
        for ( ; ; VAR_6->pointsize*=2.0)
        {
          (void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
            -VAR_9.bounds.x1,VAR_9.ascent);
          if (VAR_6->gravity == VAR_18)
            (void) CloneString(&VAR_6->geometry,VAR_2);
          (void) GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
          VAR_11=(size_t) floor(VAR_9.width+VAR_6->stroke_width+0.5);
          VAR_10=(size_t) floor(VAR_9.height+VAR_6->stroke_width+0.5);
          if ((VAR_7->columns != 0) && (VAR_7->rows != 0))
            {
              if ((VAR_11 >= VAR_7->columns) && (VAR_10 >= VAR_7->rows))
                break;
            }
          else
            if (((VAR_7->columns != 0) && (VAR_11 >= VAR_7->columns)) ||
                ((VAR_7->rows != 0) && (VAR_10 >= VAR_7->rows)))
              break;
        }
        VAR_16=VAR_6->pointsize;
        for (VAR_17=1.0; (VAR_16-VAR_17) > 0.5; )
        {
          VAR_6->pointsize=(VAR_17+VAR_16)/2.0;
          (void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
            -VAR_9.bounds.x1,VAR_9.ascent);
          if (VAR_6->gravity == VAR_18)
            (void) CloneString(&VAR_6->geometry,VAR_2);
          (void) GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
          VAR_11=(size_t) floor(VAR_9.width+VAR_6->stroke_width+0.5);
          VAR_10=(size_t) floor(VAR_9.height+VAR_6->stroke_width+0.5);
          if ((VAR_7->columns != 0) && (VAR_7->rows != 0))
            {
              if ((VAR_11 < VAR_7->columns) && (VAR_10 < VAR_7->rows))
                VAR_17=VAR_6->pointsize+0.5;
              else
                VAR_16=VAR_6->pointsize-0.5;
            }
          else
            if (((VAR_7->columns != 0) && (VAR_11 < VAR_7->columns)) ||
                ((VAR_7->rows != 0) && (VAR_10 < VAR_7->rows)))
              VAR_17=VAR_6->pointsize+0.5;
            else
              VAR_16=VAR_6->pointsize-0.5;
        }
        VAR_6->pointsize=(VAR_17+VAR_16)/2.0-0.5;
      }
  VAR_8=GetMultilineTypeMetrics(VAR_7,VAR_6,&VAR_9);
  if (VAR_8 == VAR_13)
    {
      VAR_6=DestroyDrawInfo(VAR_6);
      InheritException(VAR_1,&VAR_7->exception);
      VAR_7=DestroyImageList(VAR_7);
      return((Image *) NULL);
    }
  if (VAR_7->columns == 0)
    VAR_7->columns=(size_t) floor(VAR_9.width+VAR_6->stroke_width+0.5);
  if (VAR_7->columns == 0)
    VAR_7->columns=(size_t) floor(VAR_6->pointsize+VAR_6->stroke_width+
      0.5);
  if (VAR_7->rows == 0)
    VAR_7->rows=(size_t) floor(VAR_9.ascent-VAR_9.descent+
      VAR_6->stroke_width+0.5);
  if (VAR_7->rows == 0)
    VAR_7->rows=(size_t) floor(VAR_6->pointsize+VAR_6->stroke_width+
      0.5);
  VAR_8=SetImageExtent(VAR_7,VAR_7->columns,VAR_7->rows);
  if (VAR_8 == VAR_13)
    {
      VAR_6=DestroyDrawInfo(VAR_6);
      InheritException(VAR_1,&VAR_7->exception);
      return(DestroyImageList(VAR_7));
    }
  if (SetImageBackgroundColor(VAR_7) == VAR_13)
    {
      VAR_6=DestroyDrawInfo(VAR_6);
      InheritException(VAR_1,&VAR_7->exception);
      VAR_7=DestroyImageList(VAR_7);
      return((Image *) NULL);
    }
  /* COMMENT_6 */
               
    
  (void) FormatLocaleString(VAR_2,VAR_3,""%+g%+g"",
    VAR_6->direction == VAR_19 ? VAR_7->columns-
    VAR_9.bounds.x2 : 0.0,VAR_6->gravity == VAR_18 ?
    VAR_9.ascent : 0.0);
  VAR_6->geometry=AcquireString(VAR_2);
  VAR_8=AnnotateImage(VAR_7,VAR_6);
  if (VAR_0->pointsize == 0.0)
    {
      char
        VAR_20[VAR_3];

      (void) FormatLocaleString(VAR_20,VAR_3,""%.20g"",
        VAR_6->pointsize);
      (void) SetImageProperty(VAR_7,""label:pointsize"",VAR_20);
    }
  VAR_6=DestroyDrawInfo(VAR_6);
  if (VAR_8 == VAR_13)
    {
      VAR_7=DestroyImageList(VAR_7);
      return((Image *) NULL);
    }
  return(GetFirstImageInList(VAR_7));
}",ImageMagick/0474237508f39c4f783208123431815f1ededb76/label.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,7 +47,7 @@
   status=GetMultilineTypeMetrics(image,draw_info,&metrics);
   if ((image->columns == 0) && (image->rows == 0))
     {
-      image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
+      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
       image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
     }
   else
@@ -116,14 +116,16 @@
       return((Image *) NULL);
     }
   if (image->columns == 0)
-    image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
+    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
   if (image->columns == 0)
-    image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
+    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
+      0.5);
   if (image->rows == 0)
-    image->rows=(size_t) (metrics.ascent-metrics.descent+
+    image->rows=(size_t) floor(metrics.ascent-metrics.descent+
       draw_info->stroke_width+0.5);
   if (image->rows == 0)
-    image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
+    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
+      0.5);
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {","{'deleted_lines': ['      image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);', '    image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);', '    image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);', '    image->rows=(size_t) (metrics.ascent-metrics.descent+', '    image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);'], 'added_lines': ['      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);', '    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);', '    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+', '      0.5);', '    image->rows=(size_t) floor(metrics.ascent-metrics.descent+', '    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+', '      0.5);']}",True,"magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving ""too many exceptions,"" which trigger a buffer overflow.",7.5,HIGH,2,valid,2016-05-29T15:38:56Z,1
CVE-2016-5301,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,arvidn/libtorrent,fixed crash on invalid input in http_parser,acd4e7b87537da82a7765b3b6d14a1ffddd7b480,https://github.com/arvidn/libtorrent/commit/acd4e7b87537da82a7765b3b6d14a1ffddd7b480,src/http_parser.cpp,http_parser::incoming,"boost::tuple<int, int> http_parser::incoming(
buffer::const_interval recv_buffer, bool& error)
{
TORRENT_ASSERT(recv_buffer.left() >= m_recv_buffer.left());
boost::tuple<int, int> ret(0, 0);
int start_pos = m_recv_buffer.left();
if (start_pos == recv_buffer.left()) return ret;
m_recv_buffer = recv_buffer;
if (m_state == error_state)
{
error = true;
return ret;
}
char const* pos = recv_buffer.begin + m_recv_pos;
restart_response:
if (m_state == read_status)
{
TORRENT_ASSERT(!m_finished);
char const* newline = std::find(pos, recv_buffer.end, '\n');
if (newline == recv_buffer.end)
{
boost::get<1>(ret) += m_recv_buffer.left() - start_pos;
return ret;
}
if (newline == pos)
{
m_state = error_state;
error = true;
return ret;
}
char const* line_end = newline;
if (pos != line_end && *(line_end - 1) == '\r') --line_end;
char const* line = pos;
++newline;
int incoming = int(newline - pos);
m_recv_pos += incoming;
boost::get<1>(ret) += newline - (m_recv_buffer.begin + start_pos);
pos = newline;
m_protocol = read_until(line, ' ', line_end);
if (m_protocol.substr(0, 5) == ""HTTP/"")
{
m_status_code = atoi(read_until(line, ' ', line_end).c_str());
m_server_message = read_until(line, '\r', line_end);
if (m_protocol == ""HTTP/1.0"") m_connection_close = true;
}
else
{
m_method = m_protocol;
std::transform(m_method.begin(), m_method.end(), m_method.begin(), &to_lower);
m_content_length = 0;
m_protocol.clear();
m_path = read_until(line, ' ', line_end);
m_protocol = read_until(line, ' ', line_end);
m_status_code = 0;
}
m_state = read_header;
start_pos = pos - recv_buffer.begin;
}
if (m_state == read_header)
{
TORRENT_ASSERT(!m_finished);
char const* newline = std::find(pos, recv_buffer.end, '\n');
std::string line;
while (newline != recv_buffer.end && m_state == read_header)
{
char const* line_end = newline;
if (pos != line_end && *(line_end - 1) == '\r') --line_end;
line.assign(pos, line_end);
++newline;
m_recv_pos += newline - pos;
pos = newline;
std::string::size_type separator = line.find(':');
if (separator == std::string::npos)
{
if (m_status_code == 100)
{
m_state = read_status;
goto restart_response;
}
m_state = read_body;
TORRENT_ASSERT(m_recv_pos < INT_MAX);
m_body_start_pos = int(m_recv_pos);
break;
}
std::string name = line.substr(0, separator);
std::transform(name.begin(), name.end(), name.begin(), &to_lower);
++separator;
while (separator < line.size()
&& (line[separator] == ' ' || line[separator] == '\t'))
++separator;
std::string value = line.substr(separator, std::string::npos);
m_header.insert(std::make_pair(name, value));
if (name == ""content-length"")
{
m_content_length = strtoll(value.c_str(), 0, 10);
}
else if (name == ""connection"")
{
m_connection_close = string_begins_no_case(""close"", value.c_str());
}
else if (name == ""content-range"")
{
bool success = true;
char const* ptr = value.c_str();
if (string_begins_no_case(""bytes "", ptr)) ptr += 6;
char* end;
m_range_start = strtoll(ptr, &end, 10);
if (end == ptr) success = false;
else if (*end != '-') success = false;
else
{
ptr = end + 1;
m_range_end = strtoll(ptr, &end, 10);
if (end == ptr) success = false;
}
if (!success || m_range_end < m_range_start)
{
m_state = error_state;
error = true;
return ret;
}
m_content_length = m_range_end - m_range_start + 1;
}
else if (name == ""transfer-encoding"")
{
m_chunked_encoding = string_begins_no_case(""chunked"", value.c_str());
}
TORRENT_ASSERT(m_recv_pos <= recv_buffer.left());
newline = std::find(pos, recv_buffer.end, '\n');
}
boost::get<1>(ret) += newline - (m_recv_buffer.begin + start_pos);
}
if (m_state == read_body)
{
int incoming = recv_buffer.end - pos;
if (m_chunked_encoding && (m_flags & dont_parse_chunks) == 0)
{
if (m_cur_chunk_end == -1)
m_cur_chunk_end = m_body_start_pos;
while (m_cur_chunk_end <= m_recv_pos + incoming && !m_finished && incoming > 0)
{
boost::int64_t payload = m_cur_chunk_end - m_recv_pos;
if (payload > 0)
{
TORRENT_ASSERT(payload < INT_MAX);
m_recv_pos += payload;
boost::get<0>(ret) += int(payload);
incoming -= int(payload);
}
buffer::const_interval buf(recv_buffer.begin + m_cur_chunk_end, recv_buffer.end);
boost::int64_t chunk_size;
int header_size;
if (parse_chunk_header(buf, &chunk_size, &header_size))
{
if (chunk_size > 0)
{
std::pair<boost::int64_t, boost::int64_t> chunk_range(m_cur_chunk_end + header_size
, m_cur_chunk_end + header_size + chunk_size);
m_chunked_ranges.push_back(chunk_range);
}
m_cur_chunk_end += header_size + chunk_size;
if (chunk_size == 0)
{
m_finished = true;
TORRENT_ASSERT(m_content_length < 0 || m_recv_pos - m_body_start_pos
- m_chunk_header_size == m_content_length);
}
header_size -= m_partial_chunk_header;
m_partial_chunk_header = 0;
}
else
{
m_partial_chunk_header += incoming;
header_size = incoming;
}
m_chunk_header_size += header_size;
m_recv_pos += header_size;
boost::get<1>(ret) += header_size;
incoming -= header_size;
}
if (incoming > 0)
{
m_recv_pos += incoming;
boost::get<0>(ret) += incoming;
}
}
else
{
boost::int64_t payload_received = m_recv_pos - m_body_start_pos + incoming;
if (payload_received > m_content_length
&& m_content_length >= 0)
{
TORRENT_ASSERT(m_content_length - m_recv_pos + m_body_start_pos < INT_MAX);
incoming = int(m_content_length - m_recv_pos + m_body_start_pos);
}
TORRENT_ASSERT(incoming >= 0);
m_recv_pos += incoming;
boost::get<0>(ret) += incoming;
}
if (m_content_length >= 0
&& !m_chunked_encoding
&& m_recv_pos - m_body_start_pos >= m_content_length)
{
m_finished = true;
}
}
return ret;
}","boost::tuple<int, int> http_parser::incoming(
buffer::const_interval VAR_0, bool& VAR_1)
{
TORRENT_ASSERT(VAR_0.left() >= VAR_2.left());
boost::tuple<int, int> VAR_3(0, 0);
int VAR_4 = VAR_2.left();
if (VAR_4 == VAR_0.left()) return VAR_3;
VAR_2 = VAR_0;
if (VAR_5 == VAR_6)
{
VAR_1 = true;
return VAR_3;
}
char const* VAR_7 = VAR_0.begin + VAR_8;
restart_response:
if (VAR_5 == VAR_9)
{
TORRENT_ASSERT(!VAR_10);
char const* VAR_11 = std::find(VAR_7, VAR_0.end, '\n');
if (VAR_11 == VAR_0.end)
{
boost::VAR_12<1>(VAR_3) += VAR_2.left() - VAR_4;
return VAR_3;
}
if (VAR_11 == VAR_7)
{
VAR_5 = VAR_6;
VAR_1 = true;
return VAR_3;
}
char const* VAR_13 = VAR_11;
if (VAR_7 != VAR_13 && *(VAR_13 - 1) == '\r') --VAR_13;
char const* VAR_14 = VAR_7;
++VAR_11;
int VAR_15 = int(VAR_11 - VAR_7);
VAR_8 += VAR_15;
boost::VAR_12<1>(VAR_3) += VAR_11 - (VAR_2.begin + VAR_4);
VAR_7 = VAR_11;
VAR_16 = read_until(VAR_14, ' ', VAR_13);
if (VAR_16.substr(0, 5) == ""HTTP/"")
{
VAR_17 = atoi(read_until(VAR_14, ' ', VAR_13).c_str());
VAR_18 = read_until(VAR_14, '\r', VAR_13);
if (VAR_16 == ""HTTP/1.0"") VAR_19 = true;
}
else
{
VAR_20 = VAR_16;
std::transform(VAR_20.begin(), VAR_20.end(), VAR_20.begin(), &VAR_21);
VAR_22 = 0;
VAR_16.clear();
VAR_23 = read_until(VAR_14, ' ', VAR_13);
VAR_16 = read_until(VAR_14, ' ', VAR_13);
VAR_17 = 0;
}
VAR_5 = VAR_24;
VAR_4 = VAR_7 - VAR_0.begin;
}
if (VAR_5 == VAR_24)
{
TORRENT_ASSERT(!VAR_10);
char const* VAR_11 = std::find(VAR_7, VAR_0.end, '\n');
std::string VAR_14;
while (VAR_11 != VAR_0.end && VAR_5 == VAR_24)
{
char const* VAR_13 = VAR_11;
if (VAR_7 != VAR_13 && *(VAR_13 - 1) == '\r') --VAR_13;
VAR_14.assign(VAR_7, VAR_13);
++VAR_11;
VAR_8 += VAR_11 - VAR_7;
VAR_7 = VAR_11;
std::string::size_type VAR_25 = VAR_14.find(':');
if (VAR_25 == std::string::npos)
{
if (VAR_17 == 100)
{
VAR_5 = VAR_9;
goto restart_response;
}
VAR_5 = VAR_26;
TORRENT_ASSERT(VAR_8 < VAR_27);
VAR_28 = int(VAR_8);
break;
}
std::string VAR_29 = VAR_14.substr(0, VAR_25);
std::transform(VAR_29.begin(), VAR_29.end(), VAR_29.begin(), &VAR_21);
++VAR_25;
while (VAR_25 < VAR_14.size()
&& (VAR_14[VAR_25] == ' ' || VAR_14[VAR_25] == '\t'))
++VAR_25;
std::string VAR_30 = VAR_14.substr(VAR_25, std::string::npos);
VAR_31.insert(std::make_pair(VAR_29, VAR_30));
if (VAR_29 == ""content-length"")
{
VAR_22 = strtoll(VAR_30.c_str(), 0, 10);
}
else if (VAR_29 == ""connection"")
{
VAR_19 = string_begins_no_case(""close"", VAR_30.c_str());
}
else if (VAR_29 == ""content-range"")
{
bool VAR_32 = true;
char const* VAR_33 = VAR_30.c_str();
if (string_begins_no_case(""bytes "", VAR_33)) VAR_33 += 6;
char* VAR_34;
VAR_35 = strtoll(VAR_33, &VAR_34, 10);
if (VAR_34 == VAR_33) VAR_32 = false;
else if (*VAR_34 != '-') VAR_32 = false;
else
{
VAR_33 = VAR_34 + 1;
VAR_36 = strtoll(VAR_33, &VAR_34, 10);
if (VAR_34 == VAR_33) VAR_32 = false;
}
if (!VAR_32 || VAR_36 < VAR_35)
{
VAR_5 = VAR_6;
VAR_1 = true;
return VAR_3;
}
VAR_22 = VAR_36 - VAR_35 + 1;
}
else if (VAR_29 == ""transfer-encoding"")
{
VAR_37 = string_begins_no_case(""chunked"", VAR_30.c_str());
}
TORRENT_ASSERT(VAR_8 <= VAR_0.left());
VAR_11 = std::find(VAR_7, VAR_0.end, '\n');
}
boost::VAR_12<1>(VAR_3) += VAR_11 - (VAR_2.begin + VAR_4);
}
if (VAR_5 == VAR_26)
{
int VAR_15 = VAR_0.end - VAR_7;
if (VAR_37 && (VAR_38 & VAR_39) == 0)
{
if (VAR_40 == -1)
VAR_40 = VAR_28;
while (VAR_40 <= VAR_8 + VAR_15 && !VAR_10 && VAR_15 > 0)
{
boost::int64_t VAR_41 = VAR_40 - VAR_8;
if (VAR_41 > 0)
{
TORRENT_ASSERT(VAR_41 < VAR_27);
VAR_8 += VAR_41;
boost::VAR_12<0>(VAR_3) += int(VAR_41);
VAR_15 -= int(VAR_41);
}
buffer::const_interval VAR_42(VAR_0.begin + VAR_40, VAR_0.end);
boost::int64_t VAR_43;
int VAR_44;
if (parse_chunk_header(VAR_42, &VAR_43, &VAR_44))
{
if (VAR_43 > 0)
{
std::pair<boost::int64_t, boost::int64_t> VAR_45(VAR_40 + VAR_44
, VAR_40 + VAR_44 + VAR_43);
VAR_46.push_back(VAR_45);
}
VAR_40 += VAR_44 + VAR_43;
if (VAR_43 == 0)
{
VAR_10 = true;
TORRENT_ASSERT(VAR_22 < 0 || VAR_8 - VAR_28
- VAR_47 == VAR_22);
}
VAR_44 -= VAR_48;
VAR_48 = 0;
}
else
{
VAR_48 += VAR_15;
VAR_44 = VAR_15;
}
VAR_47 += VAR_44;
VAR_8 += VAR_44;
boost::VAR_12<1>(VAR_3) += VAR_44;
VAR_15 -= VAR_44;
}
if (VAR_15 > 0)
{
VAR_8 += VAR_15;
boost::VAR_12<0>(VAR_3) += VAR_15;
}
}
else
{
boost::int64_t VAR_49 = VAR_8 - VAR_28 + VAR_15;
if (VAR_49 > VAR_22
&& VAR_22 >= 0)
{
TORRENT_ASSERT(VAR_22 - VAR_8 + VAR_28 < VAR_27);
VAR_15 = int(VAR_22 - VAR_8 + VAR_28);
}
TORRENT_ASSERT(VAR_15 >= 0);
VAR_8 += VAR_15;
boost::VAR_12<0>(VAR_3) += VAR_15;
}
if (VAR_22 >= 0
&& !VAR_37
&& VAR_8 - VAR_28 >= VAR_22)
{
VAR_10 = true;
}
}
return VAR_3;
}",arvidn/libtorrent/acd4e7b87537da82a7765b3b6d14a1ffddd7b480/http_parser.cpp/vul/before/0.json,"boost::tuple<int, int> http_parser::incoming(
		buffer::const_interval recv_buffer, bool& error)
	{
		TORRENT_ASSERT(recv_buffer.left() >= m_recv_buffer.left());
		boost::tuple<int, int> ret(0, 0);
		int start_pos = m_recv_buffer.left();

		// early exit if there's nothing new in the receive buffer
		if (start_pos == recv_buffer.left()) return ret;
		m_recv_buffer = recv_buffer;

		if (m_state == error_state)
		{
			error = true;
			return ret;
		}

		char const* pos = recv_buffer.begin + m_recv_pos;

restart_response:

		if (m_state == read_status)
		{
			TORRENT_ASSERT(!m_finished);
			TORRENT_ASSERT(pos <= recv_buffer.end);
			char const* newline = std::find(pos, recv_buffer.end, '\n');
			// if we don't have a full line yet, wait.
			if (newline == recv_buffer.end)
			{
				boost::get<1>(ret) += m_recv_buffer.left() - start_pos;
				return ret;
			}

			if (newline == pos)
			{
				m_state = error_state;
				error = true;
				return ret;
			}

			char const* line_end = newline;
			if (pos != line_end && *(line_end - 1) == '\r') --line_end;

			char const* line = pos;
			++newline;
			TORRENT_ASSERT(newline >= pos);
			int incoming = int(newline - pos);
			m_recv_pos += incoming;
			boost::get<1>(ret) += newline - (m_recv_buffer.begin + start_pos);
			pos = newline;

			m_protocol = read_until(line, ' ', line_end);
			if (m_protocol.substr(0, 5) == ""HTTP/"")
			{
				m_status_code = atoi(read_until(line, ' ', line_end).c_str());
				m_server_message = read_until(line, '\r', line_end);

				// HTTP 1.0 always closes the connection after
				// each request
				if (m_protocol == ""HTTP/1.0"") m_connection_close = true;
			}
			else
			{
				m_method = m_protocol;
				std::transform(m_method.begin(), m_method.end(), m_method.begin(), &to_lower);
				// the content length is assumed to be 0 for requests
				m_content_length = 0;
				m_protocol.clear();
				m_path = read_until(line, ' ', line_end);
				m_protocol = read_until(line, ' ', line_end);
				m_status_code = 0;
			}
			m_state = read_header;
			start_pos = pos - recv_buffer.begin;
		}

		if (m_state == read_header)
		{
			TORRENT_ASSERT(!m_finished);
			TORRENT_ASSERT(pos <= recv_buffer.end);
			char const* newline = std::find(pos, recv_buffer.end, '\n');
			std::string line;

			while (newline != recv_buffer.end && m_state == read_header)
			{
				// if the LF character is preceeded by a CR
				// charachter, don't copy it into the line string.
				char const* line_end = newline;
				if (pos != line_end && *(line_end - 1) == '\r') --line_end;
				line.assign(pos, line_end);
				++newline;
				m_recv_pos += newline - pos;
				pos = newline;

				std::string::size_type separator = line.find(':');
				if (separator == std::string::npos)
				{
					if (m_status_code == 100)
					{
						// for 100 Continue, we need to read another response header
						// before reading the body
						m_state = read_status;
						goto restart_response;
					}
					// this means we got a blank line,
					// the header is finished and the body
					// starts.
					m_state = read_body;
					// if this is a request (not a response)
					// we're done once we reach the end of the headers
//					if (!m_method.empty()) m_finished = true;
					// the HTTP header should always be < 2 GB
					TORRENT_ASSERT(m_recv_pos < INT_MAX);
					m_body_start_pos = int(m_recv_pos);
					break;
				}

				std::string name = line.substr(0, separator);
				std::transform(name.begin(), name.end(), name.begin(), &to_lower);
				++separator;
				// skip whitespace
				while (separator < line.size()
					&& (line[separator] == ' ' || line[separator] == '\t'))
					++separator;
				std::string value = line.substr(separator, std::string::npos);
				m_header.insert(std::make_pair(name, value));

				if (name == ""content-length"")
				{
					m_content_length = strtoll(value.c_str(), 0, 10);
					if (m_content_length < 0)
					{
						m_state = error_state;
						error = true;
						return ret;
					}
				}
				else if (name == ""connection"")
				{
					m_connection_close = string_begins_no_case(""close"", value.c_str());
				}
				else if (name == ""content-range"")
				{
					bool success = true;
					char const* ptr = value.c_str();

					// apparently some web servers do not send the ""bytes""
					// in their content-range. Don't treat it as an error
					// if we can't find it, just assume the byte counters
					// start immediately
					if (string_begins_no_case(""bytes "", ptr)) ptr += 6;
					char* end;
					m_range_start = strtoll(ptr, &end, 10);
					if (m_range_start < 0)
					{
						m_state = error_state;
						error = true;
						return ret;
					}
					if (end == ptr) success = false;
					else if (*end != '-') success = false;
					else
					{
						ptr = end + 1;
						m_range_end = strtoll(ptr, &end, 10);
						if (m_range_end < 0)
						{
							m_state = error_state;
							error = true;
							return ret;
						}
						if (end == ptr) success = false;
					}

					if (!success || m_range_end < m_range_start)
					{
						m_state = error_state;
						error = true;
						return ret;
					}
					// the http range is inclusive
					m_content_length = m_range_end - m_range_start + 1;
				}
				else if (name == ""transfer-encoding"")
				{
					m_chunked_encoding = string_begins_no_case(""chunked"", value.c_str());
				}

				TORRENT_ASSERT(m_recv_pos <= recv_buffer.left());
				TORRENT_ASSERT(pos <= recv_buffer.end);
				newline = std::find(pos, recv_buffer.end, '\n');
			}
			boost::get<1>(ret) += newline - (m_recv_buffer.begin + start_pos);
		}

		if (m_state == read_body)
		{
			int incoming = recv_buffer.end - pos;

			if (m_chunked_encoding && (m_flags & dont_parse_chunks) == 0)
			{
				if (m_cur_chunk_end == -1)
					m_cur_chunk_end = m_body_start_pos;

				while (m_cur_chunk_end <= m_recv_pos + incoming && !m_finished && incoming > 0)
				{
					boost::int64_t payload = m_cur_chunk_end - m_recv_pos;
					if (payload > 0)
					{
						TORRENT_ASSERT(payload < INT_MAX);
						m_recv_pos += payload;
						boost::get<0>(ret) += int(payload);
						incoming -= int(payload);
					}
					buffer::const_interval buf(recv_buffer.begin + m_cur_chunk_end, recv_buffer.end);
					boost::int64_t chunk_size;
					int header_size;
					if (parse_chunk_header(buf, &chunk_size, &header_size))
					{
						if (chunk_size < 0)
						{
							m_state = error_state;
							error = true;
							return ret;
						}
						if (chunk_size > 0)
						{
							std::pair<boost::int64_t, boost::int64_t> chunk_range(m_cur_chunk_end + header_size
								, m_cur_chunk_end + header_size + chunk_size);
							m_chunked_ranges.push_back(chunk_range);
						}
						m_cur_chunk_end += header_size + chunk_size;
						if (chunk_size == 0)
						{
							m_finished = true;
							TORRENT_ASSERT(m_content_length < 0 || m_recv_pos - m_body_start_pos
								- m_chunk_header_size == m_content_length);
						}
						header_size -= m_partial_chunk_header;
						m_partial_chunk_header = 0;
//						fprintf(stderr, ""parse_chunk_header(%d, -> %d, -> %d) -> %d\n""
//							""  incoming = %d\n  m_recv_pos = %d\n  m_cur_chunk_end = %d\n""
//							""  content-length = %d\n""
//							, buf.left(), int(chunk_size), header_size, 1, incoming, int(m_recv_pos)
//							, m_cur_chunk_end, int(m_content_length));
					}
					else
					{
						m_partial_chunk_header += incoming;
						header_size = incoming;
						
//						fprintf(stderr, ""parse_chunk_header(%d, -> %d, -> %d) -> %d\n""
//							""  incoming = %d\n  m_recv_pos = %d\n  m_cur_chunk_end = %d\n""
//							""  content-length = %d\n""
//							, buf.left(), int(chunk_size), header_size, 0, incoming, int(m_recv_pos)
//							, m_cur_chunk_end, int(m_content_length));
					}
					m_chunk_header_size += header_size;
					m_recv_pos += header_size;
					boost::get<1>(ret) += header_size;
					incoming -= header_size;
				}
				if (incoming > 0)
				{
					m_recv_pos += incoming;
					boost::get<0>(ret) += incoming;
//					incoming = 0;
				}
			}
			else
			{
				boost::int64_t payload_received = m_recv_pos - m_body_start_pos + incoming;
				if (payload_received > m_content_length
					&& m_content_length >= 0)
				{
					TORRENT_ASSERT(m_content_length - m_recv_pos + m_body_start_pos < INT_MAX);
					incoming = int(m_content_length - m_recv_pos + m_body_start_pos);
				}

				TORRENT_ASSERT(incoming >= 0);
				m_recv_pos += incoming;
				boost::get<0>(ret) += incoming;
			}

			if (m_content_length >= 0
				&& !m_chunked_encoding
				&& m_recv_pos - m_body_start_pos >= m_content_length)
			{
				m_finished = true;
			}
		}
		return ret;
	}","boost::tuple<int, int> http_parser::incoming(
		buffer::const_interval VAR_0, bool& VAR_1)
	{
		TORRENT_ASSERT(VAR_0.left() >= VAR_2.left());
		boost::tuple<int, int> VAR_3(0, 0);
		int VAR_4 = VAR_2.left();

		/* COMMENT_0 */
		if (VAR_4 == VAR_0.left()) return VAR_3;
		VAR_2 = VAR_0;

		if (VAR_5 == VAR_6)
		{
			VAR_1 = true;
			return VAR_3;
		}

		char const* VAR_7 = VAR_0.begin + VAR_8;

restart_response:

		if (VAR_5 == VAR_9)
		{
			TORRENT_ASSERT(!VAR_10);
			TORRENT_ASSERT(VAR_7 <= VAR_0.end);
			char const* VAR_11 = std::find(VAR_7, VAR_0.end, '\n');
			/* COMMENT_1 */
			if (VAR_11 == VAR_0.end)
			{
				boost::VAR_12<1>(VAR_3) += VAR_2.left() - VAR_4;
				return VAR_3;
			}

			if (VAR_11 == VAR_7)
			{
				VAR_5 = VAR_6;
				VAR_1 = true;
				return VAR_3;
			}

			char const* VAR_13 = VAR_11;
			if (VAR_7 != VAR_13 && *(VAR_13 - 1) == '\r') --VAR_13;

			char const* VAR_14 = VAR_7;
			++VAR_11;
			TORRENT_ASSERT(VAR_11 >= VAR_7);
			int VAR_15 = int(VAR_11 - VAR_7);
			VAR_8 += VAR_15;
			boost::VAR_12<1>(VAR_3) += VAR_11 - (VAR_2.begin + VAR_4);
			VAR_7 = VAR_11;

			VAR_16 = read_until(VAR_14, ' ', VAR_13);
			if (VAR_16.substr(0, 5) == ""HTTP/"")
			{
				VAR_17 = atoi(read_until(VAR_14, ' ', VAR_13).c_str());
				VAR_18 = read_until(VAR_14, '\r', VAR_13);

				/* COMMENT_2 */
				/* COMMENT_3 */
				if (VAR_16 == ""HTTP/1.0"") VAR_19 = true;
			}
			else
			{
				VAR_20 = VAR_16;
				std::transform(VAR_20.begin(), VAR_20.end(), VAR_20.begin(), &VAR_21);
				/* COMMENT_4 */
				VAR_22 = 0;
				VAR_16.clear();
				VAR_23 = read_until(VAR_14, ' ', VAR_13);
				VAR_16 = read_until(VAR_14, ' ', VAR_13);
				VAR_17 = 0;
			}
			VAR_5 = VAR_24;
			VAR_4 = VAR_7 - VAR_0.begin;
		}

		if (VAR_5 == VAR_24)
		{
			TORRENT_ASSERT(!VAR_10);
			TORRENT_ASSERT(VAR_7 <= VAR_0.end);
			char const* VAR_11 = std::find(VAR_7, VAR_0.end, '\n');
			std::string VAR_14;

			while (VAR_11 != VAR_0.end && VAR_5 == VAR_24)
			{
				/* COMMENT_5 */
				/* COMMENT_6 */
				char const* VAR_13 = VAR_11;
				if (VAR_7 != VAR_13 && *(VAR_13 - 1) == '\r') --VAR_13;
				VAR_14.assign(VAR_7, VAR_13);
				++VAR_11;
				VAR_8 += VAR_11 - VAR_7;
				VAR_7 = VAR_11;

				std::string::size_type VAR_25 = VAR_14.find(':');
				if (VAR_25 == std::string::npos)
				{
					if (VAR_17 == 100)
					{
						/* COMMENT_7 */
						/* COMMENT_8 */
						VAR_5 = VAR_9;
						goto restart_response;
					}
					/* COMMENT_9 */
					/* COMMENT_10 */
					/* COMMENT_11 */
					VAR_5 = VAR_26;
					/* COMMENT_12 */
					/* COMMENT_13 */
/* COMMENT_14 */
					/* COMMENT_15 */
					TORRENT_ASSERT(VAR_8 < VAR_27);
					VAR_28 = int(VAR_8);
					break;
				}

				std::string VAR_29 = VAR_14.substr(0, VAR_25);
				std::transform(VAR_29.begin(), VAR_29.end(), VAR_29.begin(), &VAR_21);
				++VAR_25;
				/* COMMENT_16 */
				while (VAR_25 < VAR_14.size()
					&& (VAR_14[VAR_25] == ' ' || VAR_14[VAR_25] == '\t'))
					++VAR_25;
				std::string VAR_30 = VAR_14.substr(VAR_25, std::string::npos);
				VAR_31.insert(std::make_pair(VAR_29, VAR_30));

				if (VAR_29 == ""content-length"")
				{
					VAR_22 = strtoll(VAR_30.c_str(), 0, 10);
					if (VAR_22 < 0)
					{
						VAR_5 = VAR_6;
						VAR_1 = true;
						return VAR_3;
					}
				}
				else if (VAR_29 == ""connection"")
				{
					VAR_19 = string_begins_no_case(""close"", VAR_30.c_str());
				}
				else if (VAR_29 == ""content-range"")
				{
					bool VAR_32 = true;
					char const* VAR_33 = VAR_30.c_str();

					/* COMMENT_17 */
					/* COMMENT_18 */
					/* COMMENT_19 */
					/* COMMENT_20 */
					if (string_begins_no_case(""bytes "", VAR_33)) VAR_33 += 6;
					char* VAR_34;
					VAR_35 = strtoll(VAR_33, &VAR_34, 10);
					if (VAR_35 < 0)
					{
						VAR_5 = VAR_6;
						VAR_1 = true;
						return VAR_3;
					}
					if (VAR_34 == VAR_33) VAR_32 = false;
					else if (*VAR_34 != '-') VAR_32 = false;
					else
					{
						VAR_33 = VAR_34 + 1;
						VAR_36 = strtoll(VAR_33, &VAR_34, 10);
						if (VAR_36 < 0)
						{
							VAR_5 = VAR_6;
							VAR_1 = true;
							return VAR_3;
						}
						if (VAR_34 == VAR_33) VAR_32 = false;
					}

					if (!VAR_32 || VAR_36 < VAR_35)
					{
						VAR_5 = VAR_6;
						VAR_1 = true;
						return VAR_3;
					}
					/* COMMENT_21 */
					VAR_22 = VAR_36 - VAR_35 + 1;
				}
				else if (VAR_29 == ""transfer-encoding"")
				{
					VAR_37 = string_begins_no_case(""chunked"", VAR_30.c_str());
				}

				TORRENT_ASSERT(VAR_8 <= VAR_0.left());
				TORRENT_ASSERT(VAR_7 <= VAR_0.end);
				VAR_11 = std::find(VAR_7, VAR_0.end, '\n');
			}
			boost::VAR_12<1>(VAR_3) += VAR_11 - (VAR_2.begin + VAR_4);
		}

		if (VAR_5 == VAR_26)
		{
			int VAR_15 = VAR_0.end - VAR_7;

			if (VAR_37 && (VAR_38 & VAR_39) == 0)
			{
				if (VAR_40 == -1)
					VAR_40 = VAR_28;

				while (VAR_40 <= VAR_8 + VAR_15 && !VAR_10 && VAR_15 > 0)
				{
					boost::int64_t VAR_41 = VAR_40 - VAR_8;
					if (VAR_41 > 0)
					{
						TORRENT_ASSERT(VAR_41 < VAR_27);
						VAR_8 += VAR_41;
						boost::VAR_12<0>(VAR_3) += int(VAR_41);
						VAR_15 -= int(VAR_41);
					}
					buffer::const_interval VAR_42(VAR_0.begin + VAR_40, VAR_0.end);
					boost::int64_t VAR_43;
					int VAR_44;
					if (parse_chunk_header(VAR_42, &VAR_43, &VAR_44))
					{
						if (VAR_43 < 0)
						{
							VAR_5 = VAR_6;
							VAR_1 = true;
							return VAR_3;
						}
						if (VAR_43 > 0)
						{
							std::pair<boost::int64_t, boost::int64_t> VAR_45(VAR_40 + VAR_44
								, VAR_40 + VAR_44 + VAR_43);
							VAR_46.push_back(VAR_45);
						}
						VAR_40 += VAR_44 + VAR_43;
						if (VAR_43 == 0)
						{
							VAR_10 = true;
							TORRENT_ASSERT(VAR_22 < 0 || VAR_8 - VAR_28
								- VAR_47 == VAR_22);
						}
						VAR_44 -= VAR_48;
						VAR_48 = 0;
/* COMMENT_22 */
/* COMMENT_23 */
/* COMMENT_24 */
/* COMMENT_25 */
/* COMMENT_26 */
					}
					else
					{
						VAR_48 += VAR_15;
						VAR_44 = VAR_15;
						
/* COMMENT_22 */
/* COMMENT_23 */
/* COMMENT_24 */
/* COMMENT_27 */
/* COMMENT_26 */
					}
					VAR_47 += VAR_44;
					VAR_8 += VAR_44;
					boost::VAR_12<1>(VAR_3) += VAR_44;
					VAR_15 -= VAR_44;
				}
				if (VAR_15 > 0)
				{
					VAR_8 += VAR_15;
					boost::VAR_12<0>(VAR_3) += VAR_15;
/* COMMENT_28 */
				}
			}
			else
			{
				boost::int64_t VAR_49 = VAR_8 - VAR_28 + VAR_15;
				if (VAR_49 > VAR_22
					&& VAR_22 >= 0)
				{
					TORRENT_ASSERT(VAR_22 - VAR_8 + VAR_28 < VAR_27);
					VAR_15 = int(VAR_22 - VAR_8 + VAR_28);
				}

				TORRENT_ASSERT(VAR_15 >= 0);
				VAR_8 += VAR_15;
				boost::VAR_12<0>(VAR_3) += VAR_15;
			}

			if (VAR_22 >= 0
				&& !VAR_37
				&& VAR_8 - VAR_28 >= VAR_22)
			{
				VAR_10 = true;
			}
		}
		return VAR_3;
	}",arvidn/libtorrent/acd4e7b87537da82a7765b3b6d14a1ffddd7b480/http_parser.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,7 @@
 		if (m_state == read_status)
 		{
 			TORRENT_ASSERT(!m_finished);
+			TORRENT_ASSERT(pos <= recv_buffer.end);
 			char const* newline = std::find(pos, recv_buffer.end, '\n');
 			// if we don't have a full line yet, wait.
 			if (newline == recv_buffer.end)
@@ -42,6 +43,7 @@
 
 			char const* line = pos;
 			++newline;
+			TORRENT_ASSERT(newline >= pos);
 			int incoming = int(newline - pos);
 			m_recv_pos += incoming;
 			boost::get<1>(ret) += newline - (m_recv_buffer.begin + start_pos);
@@ -75,6 +77,7 @@
 		if (m_state == read_header)
 		{
 			TORRENT_ASSERT(!m_finished);
+			TORRENT_ASSERT(pos <= recv_buffer.end);
 			char const* newline = std::find(pos, recv_buffer.end, '\n');
 			std::string line;
 
@@ -125,6 +128,12 @@
 				if (name == ""content-length"")
 				{
 					m_content_length = strtoll(value.c_str(), 0, 10);
+					if (m_content_length < 0)
+					{
+						m_state = error_state;
+						error = true;
+						return ret;
+					}
 				}
 				else if (name == ""connection"")
 				{
@@ -142,12 +151,24 @@
 					if (string_begins_no_case(""bytes "", ptr)) ptr += 6;
 					char* end;
 					m_range_start = strtoll(ptr, &end, 10);
+					if (m_range_start < 0)
+					{
+						m_state = error_state;
+						error = true;
+						return ret;
+					}
 					if (end == ptr) success = false;
 					else if (*end != '-') success = false;
 					else
 					{
 						ptr = end + 1;
 						m_range_end = strtoll(ptr, &end, 10);
+						if (m_range_end < 0)
+						{
+							m_state = error_state;
+							error = true;
+							return ret;
+						}
 						if (end == ptr) success = false;
 					}
 
@@ -166,6 +187,7 @@
 				}
 
 				TORRENT_ASSERT(m_recv_pos <= recv_buffer.left());
+				TORRENT_ASSERT(pos <= recv_buffer.end);
 				newline = std::find(pos, recv_buffer.end, '\n');
 			}
 			boost::get<1>(ret) += newline - (m_recv_buffer.begin + start_pos);
@@ -195,6 +217,12 @@
 					int header_size;
 					if (parse_chunk_header(buf, &chunk_size, &header_size))
 					{
+						if (chunk_size < 0)
+						{
+							m_state = error_state;
+							error = true;
+							return ret;
+						}
 						if (chunk_size > 0)
 						{
 							std::pair<boost::int64_t, boost::int64_t> chunk_range(m_cur_chunk_end + header_size","{'deleted_lines': [], 'added_lines': ['\t\t\tTORRENT_ASSERT(pos <= recv_buffer.end);', '\t\t\tTORRENT_ASSERT(newline >= pos);', '\t\t\tTORRENT_ASSERT(pos <= recv_buffer.end);', '\t\t\t\t\tif (m_content_length < 0)', '\t\t\t\t\t{', '\t\t\t\t\t\tm_state = error_state;', '\t\t\t\t\t\terror = true;', '\t\t\t\t\t\treturn ret;', '\t\t\t\t\t}', '\t\t\t\t\tif (m_range_start < 0)', '\t\t\t\t\t{', '\t\t\t\t\t\tm_state = error_state;', '\t\t\t\t\t\terror = true;', '\t\t\t\t\t\treturn ret;', '\t\t\t\t\t}', '\t\t\t\t\t\tif (m_range_end < 0)', '\t\t\t\t\t\t{', '\t\t\t\t\t\t\tm_state = error_state;', '\t\t\t\t\t\t\terror = true;', '\t\t\t\t\t\t\treturn ret;', '\t\t\t\t\t\t}', '\t\t\t\tTORRENT_ASSERT(pos <= recv_buffer.end);', '\t\t\t\t\t\tif (chunk_size < 0)', '\t\t\t\t\t\t{', '\t\t\t\t\t\t\tm_state = error_state;', '\t\t\t\t\t\t\terror = true;', '\t\t\t\t\t\t\treturn ret;', '\t\t\t\t\t\t}']}",True,The parse_chunk_header function in libtorrent before 1.1.1 allows remote attackers to cause a denial of service (crash) via a crafted (1) HTTP response or possibly a (2) UPnP broadcast.,7.5,HIGH,2,valid,2016-06-04T00:33:28Z,1
CVE-2016-5301,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,arvidn/libtorrent,fixed crash on invalid input in http_parser,acd4e7b87537da82a7765b3b6d14a1ffddd7b480,https://github.com/arvidn/libtorrent/commit/acd4e7b87537da82a7765b3b6d14a1ffddd7b480,src/http_parser.cpp,http_parser::parse_chunk_header,"bool http_parser::parse_chunk_header(buffer::const_interval buf
, boost::int64_t* chunk_size, int* header_size)
{
char const* pos = buf.begin;
if (pos < buf.end && pos[0] == '\r') ++pos;
if (pos < buf.end && pos[0] == '\n') ++pos;
if (pos == buf.end) return false;
char const* newline = std::find(pos, buf.end, '\n');
if (newline == buf.end) return false;
++newline;
*chunk_size = strtoll(pos, 0, 16);
if (*chunk_size != 0)
{
*header_size = newline - buf.begin;
TORRENT_ASSERT(newline - buf.begin > 2);
return true;
}
std::map<std::string, std::string> tail_headers;
pos = newline;
newline = std::find(pos, buf.end, '\n');
std::string line;
while (newline != buf.end)
{
char const* line_end = newline;
if (pos != line_end && *(line_end - 1) == '\r') --line_end;
line.assign(pos, line_end);
++newline;
pos = newline;
std::string::size_type separator = line.find(':');
if (separator == std::string::npos)
{
*header_size = newline - buf.begin;
TORRENT_ASSERT(newline - buf.begin > 2);
for (std::map<std::string, std::string>::const_iterator i = tail_headers.begin();
i != tail_headers.end(); ++i)
m_header.insert(std::make_pair(i->first, i->second));
return true;
}
std::string name = line.substr(0, separator);
std::transform(name.begin(), name.end(), name.begin(), &to_lower);
++separator;
while (separator < line.size()
&& (line[separator] == ' ' || line[separator] == '\t'))
++separator;
std::string value = line.substr(separator, std::string::npos);
tail_headers.insert(std::make_pair(name, value));
newline = std::find(pos, buf.end, '\n');
}
return false;
}","bool http_parser::parse_chunk_header(buffer::const_interval VAR_0
, boost::int64_t* VAR_1, int* VAR_2)
{
char const* VAR_3 = VAR_0.begin;
if (VAR_3 < VAR_0.end && VAR_3[0] == '\r') ++VAR_3;
if (VAR_3 < VAR_0.end && VAR_3[0] == '\n') ++VAR_3;
if (VAR_3 == VAR_0.end) return false;
char const* VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
if (VAR_4 == VAR_0.end) return false;
++VAR_4;
*VAR_1 = strtoll(VAR_3, 0, 16);
if (*VAR_1 != 0)
{
*VAR_2 = VAR_4 - VAR_0.begin;
TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);
return true;
}
std::map<std::string, std::string> VAR_5;
VAR_3 = VAR_4;
VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
std::string VAR_6;
while (VAR_4 != VAR_0.end)
{
char const* VAR_7 = VAR_4;
if (VAR_3 != VAR_7 && *(VAR_7 - 1) == '\r') --VAR_7;
VAR_6.assign(VAR_3, VAR_7);
++VAR_4;
VAR_3 = VAR_4;
std::string::size_type VAR_8 = VAR_6.find(':');
if (VAR_8 == std::string::npos)
{
*VAR_2 = VAR_4 - VAR_0.begin;
TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);
for (std::map<std::string, std::string>::const_iterator VAR_9 = VAR_5.begin();
VAR_9 != VAR_5.end(); ++VAR_9)
VAR_10.insert(std::make_pair(VAR_9->first, VAR_9->second));
return true;
}
std::string VAR_11 = VAR_6.substr(0, VAR_8);
std::transform(VAR_11.begin(), VAR_11.end(), VAR_11.begin(), &VAR_12);
++VAR_8;
while (VAR_8 < VAR_6.size()
&& (VAR_6[VAR_8] == ' ' || VAR_6[VAR_8] == '\t'))
++VAR_8;
std::string VAR_13 = VAR_6.substr(VAR_8, std::string::npos);
VAR_5.insert(std::make_pair(VAR_11, VAR_13));
VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
}
return false;
}",arvidn/libtorrent/acd4e7b87537da82a7765b3b6d14a1ffddd7b480/http_parser.cpp/vul/before/1.json,"bool http_parser::parse_chunk_header(buffer::const_interval buf
		, boost::int64_t* chunk_size, int* header_size)
	{
		TORRENT_ASSERT(buf.begin <= buf.end);
		char const* pos = buf.begin;

		// ignore one optional new-line. This is since each chunk
		// is terminated by a newline. we're likely to see one
		// before the actual header.

		if (pos < buf.end && pos[0] == '\r') ++pos;
		if (pos < buf.end && pos[0] == '\n') ++pos;
		if (pos == buf.end) return false;

		TORRENT_ASSERT(pos <= buf.end);
		char const* newline = std::find(pos, buf.end, '\n');
		if (newline == buf.end) return false;
		++newline;

		// the chunk header is a single line, a hex length of the
		// chunk followed by an optional semi-colon with a comment
		// in case the length is 0, the stream is terminated and
		// there are extra tail headers, which is terminated by an
		// empty line

		// first, read the chunk length
		*chunk_size = strtoll(pos, 0, 16);
		if (chunk_size < 0) return true;

		if (*chunk_size != 0)
		{
			*header_size = newline - buf.begin;
			// the newline alone is two bytes
			TORRENT_ASSERT(newline - buf.begin > 2);
			return true;
		}

		// this is the terminator of the stream. Also read headers
		std::map<std::string, std::string> tail_headers;
		pos = newline;
		newline = std::find(pos, buf.end, '\n');

		std::string line;
		while (newline != buf.end)
		{
			// if the LF character is preceeded by a CR
			// charachter, don't copy it into the line string.
			char const* line_end = newline;
			if (pos != line_end && *(line_end - 1) == '\r') --line_end;
			line.assign(pos, line_end);
			++newline;
			pos = newline;

			std::string::size_type separator = line.find(':');
			if (separator == std::string::npos)
			{
				// this means we got a blank line,
				// the header is finished and the body
				// starts.
				*header_size = newline - buf.begin;

				// the newline alone is two bytes
				TORRENT_ASSERT(newline - buf.begin > 2);

				// we were successfull in parsing the headers.
				// add them to the headers in the parser
				for (std::map<std::string, std::string>::const_iterator i = tail_headers.begin();
					i != tail_headers.end(); ++i)
					m_header.insert(std::make_pair(i->first, i->second));

				return true;
			}

			std::string name = line.substr(0, separator);
			std::transform(name.begin(), name.end(), name.begin(), &to_lower);
			++separator;
			// skip whitespace
			while (separator < line.size()
				&& (line[separator] == ' ' || line[separator] == '\t'))
				++separator;
			std::string value = line.substr(separator, std::string::npos);
			tail_headers.insert(std::make_pair(name, value));
//			fprintf(stderr, ""tail_header: %s: %s\n"", name.c_str(), value.c_str());

			newline = std::find(pos, buf.end, '\n');
		}
		return false;
	}","bool http_parser::parse_chunk_header(buffer::const_interval VAR_0
		, boost::int64_t* VAR_1, int* VAR_2)
	{
		TORRENT_ASSERT(VAR_0.begin <= VAR_0.end);
		char const* VAR_3 = VAR_0.begin;

		/* COMMENT_0 */
		/* COMMENT_1 */
		/* COMMENT_2 */

		if (VAR_3 < VAR_0.end && VAR_3[0] == '\r') ++VAR_3;
		if (VAR_3 < VAR_0.end && VAR_3[0] == '\n') ++VAR_3;
		if (VAR_3 == VAR_0.end) return false;

		TORRENT_ASSERT(VAR_3 <= VAR_0.end);
		char const* VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
		if (VAR_4 == VAR_0.end) return false;
		++VAR_4;

		/* COMMENT_3 */
		/* COMMENT_4 */
		/* COMMENT_5 */
		/* COMMENT_6 */
		/* COMMENT_7 */

		/* COMMENT_8 */
		*VAR_1 = strtoll(VAR_3, 0, 16);
		if (VAR_1 < 0) return true;

		if (*VAR_1 != 0)
		{
			*VAR_2 = VAR_4 - VAR_0.begin;
			/* COMMENT_9 */
			TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);
			return true;
		}

		/* COMMENT_10 */
		std::map<std::string, std::string> VAR_5;
		VAR_3 = VAR_4;
		VAR_4 = std::find(VAR_3, VAR_0.end, '\n');

		std::string VAR_6;
		while (VAR_4 != VAR_0.end)
		{
			/* COMMENT_11 */
			/* COMMENT_12 */
			char const* VAR_7 = VAR_4;
			if (VAR_3 != VAR_7 && *(VAR_7 - 1) == '\r') --VAR_7;
			VAR_6.assign(VAR_3, VAR_7);
			++VAR_4;
			VAR_3 = VAR_4;

			std::string::size_type VAR_8 = VAR_6.find(':');
			if (VAR_8 == std::string::npos)
			{
				/* COMMENT_13 */
				/* COMMENT_14 */
				/* COMMENT_15 */
				*VAR_2 = VAR_4 - VAR_0.begin;

				/* COMMENT_9 */
				TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);

				/* COMMENT_16 */
				/* COMMENT_17 */
				for (std::map<std::string, std::string>::const_iterator VAR_9 = VAR_5.begin();
					VAR_9 != VAR_5.end(); ++VAR_9)
					VAR_10.insert(std::make_pair(VAR_9->first, VAR_9->second));

				return true;
			}

			std::string VAR_11 = VAR_6.substr(0, VAR_8);
			std::transform(VAR_11.begin(), VAR_11.end(), VAR_11.begin(), &VAR_12);
			++VAR_8;
			/* COMMENT_18 */
			while (VAR_8 < VAR_6.size()
				&& (VAR_6[VAR_8] == ' ' || VAR_6[VAR_8] == '\t'))
				++VAR_8;
			std::string VAR_13 = VAR_6.substr(VAR_8, std::string::npos);
			VAR_5.insert(std::make_pair(VAR_11, VAR_13));
/* COMMENT_19 */

			VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
		}
		return false;
	}",arvidn/libtorrent/acd4e7b87537da82a7765b3b6d14a1ffddd7b480/http_parser.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 bool http_parser::parse_chunk_header(buffer::const_interval buf
 		, boost::int64_t* chunk_size, int* header_size)
 	{
+		TORRENT_ASSERT(buf.begin <= buf.end);
 		char const* pos = buf.begin;
 
 		// ignore one optional new-line. This is since each chunk
@@ -11,6 +12,7 @@
 		if (pos < buf.end && pos[0] == '\n') ++pos;
 		if (pos == buf.end) return false;
 
+		TORRENT_ASSERT(pos <= buf.end);
 		char const* newline = std::find(pos, buf.end, '\n');
 		if (newline == buf.end) return false;
 		++newline;
@@ -23,6 +25,8 @@
 
 		// first, read the chunk length
 		*chunk_size = strtoll(pos, 0, 16);
+		if (chunk_size < 0) return true;
+
 		if (*chunk_size != 0)
 		{
 			*header_size = newline - buf.begin;","{'deleted_lines': [], 'added_lines': ['\t\tTORRENT_ASSERT(buf.begin <= buf.end);', '\t\tTORRENT_ASSERT(pos <= buf.end);', '\t\tif (chunk_size < 0) return true;', '']}",True,The parse_chunk_header function in libtorrent before 1.1.1 allows remote attackers to cause a denial of service (crash) via a crafted (1) HTTP response or possibly a (2) UPnP broadcast.,7.5,HIGH,2,valid,2016-06-04T00:33:28Z,1
CVE-2016-5301,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,arvidn/libtorrent,fix typo,6edc10c189ddef2f4a6f5e89cfd6947da18539c3,https://github.com/arvidn/libtorrent/commit/6edc10c189ddef2f4a6f5e89cfd6947da18539c3,src/http_parser.cpp,http_parser::parse_chunk_header,"bool http_parser::parse_chunk_header(buffer::const_interval buf
, boost::int64_t* chunk_size, int* header_size)
{
TORRENT_ASSERT(buf.begin <= buf.end);
char const* pos = buf.begin;
if (pos < buf.end && pos[0] == '\r') ++pos;
if (pos < buf.end && pos[0] == '\n') ++pos;
if (pos == buf.end) return false;
TORRENT_ASSERT(pos <= buf.end);
char const* newline = std::find(pos, buf.end, '\n');
if (newline == buf.end) return false;
++newline;
*chunk_size = strtoll(pos, 0, 16);
if (chunk_size < 0) return true;
if (*chunk_size != 0)
{
*header_size = newline - buf.begin;
TORRENT_ASSERT(newline - buf.begin > 2);
return true;
}
std::map<std::string, std::string> tail_headers;
pos = newline;
newline = std::find(pos, buf.end, '\n');
std::string line;
while (newline != buf.end)
{
char const* line_end = newline;
if (pos != line_end && *(line_end - 1) == '\r') --line_end;
line.assign(pos, line_end);
++newline;
pos = newline;
std::string::size_type separator = line.find(':');
if (separator == std::string::npos)
{
*header_size = newline - buf.begin;
TORRENT_ASSERT(newline - buf.begin > 2);
for (std::map<std::string, std::string>::const_iterator i = tail_headers.begin();
i != tail_headers.end(); ++i)
m_header.insert(std::make_pair(i->first, i->second));
return true;
}
std::string name = line.substr(0, separator);
std::transform(name.begin(), name.end(), name.begin(), &to_lower);
++separator;
while (separator < line.size()
&& (line[separator] == ' ' || line[separator] == '\t'))
++separator;
std::string value = line.substr(separator, std::string::npos);
tail_headers.insert(std::make_pair(name, value));
newline = std::find(pos, buf.end, '\n');
}
return false;
}","bool http_parser::parse_chunk_header(buffer::const_interval VAR_0
, boost::int64_t* VAR_1, int* VAR_2)
{
TORRENT_ASSERT(VAR_0.begin <= VAR_0.end);
char const* VAR_3 = VAR_0.begin;
if (VAR_3 < VAR_0.end && VAR_3[0] == '\r') ++VAR_3;
if (VAR_3 < VAR_0.end && VAR_3[0] == '\n') ++VAR_3;
if (VAR_3 == VAR_0.end) return false;
TORRENT_ASSERT(VAR_3 <= VAR_0.end);
char const* VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
if (VAR_4 == VAR_0.end) return false;
++VAR_4;
*VAR_1 = strtoll(VAR_3, 0, 16);
if (VAR_1 < 0) return true;
if (*VAR_1 != 0)
{
*VAR_2 = VAR_4 - VAR_0.begin;
TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);
return true;
}
std::map<std::string, std::string> VAR_5;
VAR_3 = VAR_4;
VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
std::string VAR_6;
while (VAR_4 != VAR_0.end)
{
char const* VAR_7 = VAR_4;
if (VAR_3 != VAR_7 && *(VAR_7 - 1) == '\r') --VAR_7;
VAR_6.assign(VAR_3, VAR_7);
++VAR_4;
VAR_3 = VAR_4;
std::string::size_type VAR_8 = VAR_6.find(':');
if (VAR_8 == std::string::npos)
{
*VAR_2 = VAR_4 - VAR_0.begin;
TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);
for (std::map<std::string, std::string>::const_iterator VAR_9 = VAR_5.begin();
VAR_9 != VAR_5.end(); ++VAR_9)
VAR_10.insert(std::make_pair(VAR_9->first, VAR_9->second));
return true;
}
std::string VAR_11 = VAR_6.substr(0, VAR_8);
std::transform(VAR_11.begin(), VAR_11.end(), VAR_11.begin(), &VAR_12);
++VAR_8;
while (VAR_8 < VAR_6.size()
&& (VAR_6[VAR_8] == ' ' || VAR_6[VAR_8] == '\t'))
++VAR_8;
std::string VAR_13 = VAR_6.substr(VAR_8, std::string::npos);
VAR_5.insert(std::make_pair(VAR_11, VAR_13));
VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
}
return false;
}",arvidn/libtorrent/6edc10c189ddef2f4a6f5e89cfd6947da18539c3/http_parser.cpp/vul/before/0.json,"bool http_parser::parse_chunk_header(buffer::const_interval buf
		, boost::int64_t* chunk_size, int* header_size)
	{
		TORRENT_ASSERT(buf.begin <= buf.end);
		char const* pos = buf.begin;

		// ignore one optional new-line. This is since each chunk
		// is terminated by a newline. we're likely to see one
		// before the actual header.

		if (pos < buf.end && pos[0] == '\r') ++pos;
		if (pos < buf.end && pos[0] == '\n') ++pos;
		if (pos == buf.end) return false;

		TORRENT_ASSERT(pos <= buf.end);
		char const* newline = std::find(pos, buf.end, '\n');
		if (newline == buf.end) return false;
		++newline;

		// the chunk header is a single line, a hex length of the
		// chunk followed by an optional semi-colon with a comment
		// in case the length is 0, the stream is terminated and
		// there are extra tail headers, which is terminated by an
		// empty line

		// first, read the chunk length
		*chunk_size = strtoll(pos, 0, 16);
		if (*chunk_size < 0) return true;

		if (*chunk_size != 0)
		{
			*header_size = newline - buf.begin;
			// the newline alone is two bytes
			TORRENT_ASSERT(newline - buf.begin > 2);
			return true;
		}

		// this is the terminator of the stream. Also read headers
		std::map<std::string, std::string> tail_headers;
		pos = newline;
		newline = std::find(pos, buf.end, '\n');

		std::string line;
		while (newline != buf.end)
		{
			// if the LF character is preceeded by a CR
			// charachter, don't copy it into the line string.
			char const* line_end = newline;
			if (pos != line_end && *(line_end - 1) == '\r') --line_end;
			line.assign(pos, line_end);
			++newline;
			pos = newline;

			std::string::size_type separator = line.find(':');
			if (separator == std::string::npos)
			{
				// this means we got a blank line,
				// the header is finished and the body
				// starts.
				*header_size = newline - buf.begin;

				// the newline alone is two bytes
				TORRENT_ASSERT(newline - buf.begin > 2);

				// we were successfull in parsing the headers.
				// add them to the headers in the parser
				for (std::map<std::string, std::string>::const_iterator i = tail_headers.begin();
					i != tail_headers.end(); ++i)
					m_header.insert(std::make_pair(i->first, i->second));

				return true;
			}

			std::string name = line.substr(0, separator);
			std::transform(name.begin(), name.end(), name.begin(), &to_lower);
			++separator;
			// skip whitespace
			while (separator < line.size()
				&& (line[separator] == ' ' || line[separator] == '\t'))
				++separator;
			std::string value = line.substr(separator, std::string::npos);
			tail_headers.insert(std::make_pair(name, value));
//			fprintf(stderr, ""tail_header: %s: %s\n"", name.c_str(), value.c_str());

			newline = std::find(pos, buf.end, '\n');
		}
		return false;
	}","bool http_parser::parse_chunk_header(buffer::const_interval VAR_0
		, boost::int64_t* VAR_1, int* VAR_2)
	{
		TORRENT_ASSERT(VAR_0.begin <= VAR_0.end);
		char const* VAR_3 = VAR_0.begin;

		/* COMMENT_0 */
		/* COMMENT_1 */
		/* COMMENT_2 */

		if (VAR_3 < VAR_0.end && VAR_3[0] == '\r') ++VAR_3;
		if (VAR_3 < VAR_0.end && VAR_3[0] == '\n') ++VAR_3;
		if (VAR_3 == VAR_0.end) return false;

		TORRENT_ASSERT(VAR_3 <= VAR_0.end);
		char const* VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
		if (VAR_4 == VAR_0.end) return false;
		++VAR_4;

		/* COMMENT_3 */
		/* COMMENT_4 */
		/* COMMENT_5 */
		/* COMMENT_6 */
		/* COMMENT_7 */

		/* COMMENT_8 */
		*VAR_1 = strtoll(VAR_3, 0, 16);
		if (*VAR_1 < 0) return true;

		if (*VAR_1 != 0)
		{
			*VAR_2 = VAR_4 - VAR_0.begin;
			/* COMMENT_9 */
			TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);
			return true;
		}

		/* COMMENT_10 */
		std::map<std::string, std::string> VAR_5;
		VAR_3 = VAR_4;
		VAR_4 = std::find(VAR_3, VAR_0.end, '\n');

		std::string VAR_6;
		while (VAR_4 != VAR_0.end)
		{
			/* COMMENT_11 */
			/* COMMENT_12 */
			char const* VAR_7 = VAR_4;
			if (VAR_3 != VAR_7 && *(VAR_7 - 1) == '\r') --VAR_7;
			VAR_6.assign(VAR_3, VAR_7);
			++VAR_4;
			VAR_3 = VAR_4;

			std::string::size_type VAR_8 = VAR_6.find(':');
			if (VAR_8 == std::string::npos)
			{
				/* COMMENT_13 */
				/* COMMENT_14 */
				/* COMMENT_15 */
				*VAR_2 = VAR_4 - VAR_0.begin;

				/* COMMENT_9 */
				TORRENT_ASSERT(VAR_4 - VAR_0.begin > 2);

				/* COMMENT_16 */
				/* COMMENT_17 */
				for (std::map<std::string, std::string>::const_iterator VAR_9 = VAR_5.begin();
					VAR_9 != VAR_5.end(); ++VAR_9)
					VAR_10.insert(std::make_pair(VAR_9->first, VAR_9->second));

				return true;
			}

			std::string VAR_11 = VAR_6.substr(0, VAR_8);
			std::transform(VAR_11.begin(), VAR_11.end(), VAR_11.begin(), &VAR_12);
			++VAR_8;
			/* COMMENT_18 */
			while (VAR_8 < VAR_6.size()
				&& (VAR_6[VAR_8] == ' ' || VAR_6[VAR_8] == '\t'))
				++VAR_8;
			std::string VAR_13 = VAR_6.substr(VAR_8, std::string::npos);
			VAR_5.insert(std::make_pair(VAR_11, VAR_13));
/* COMMENT_19 */

			VAR_4 = std::find(VAR_3, VAR_0.end, '\n');
		}
		return false;
	}",arvidn/libtorrent/6edc10c189ddef2f4a6f5e89cfd6947da18539c3/http_parser.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,7 +25,7 @@
 
 		// first, read the chunk length
 		*chunk_size = strtoll(pos, 0, 16);
-		if (chunk_size < 0) return true;
+		if (*chunk_size < 0) return true;
 
 		if (*chunk_size != 0)
 		{","{'deleted_lines': ['\t\tif (chunk_size < 0) return true;'], 'added_lines': ['\t\tif (*chunk_size < 0) return true;']}",True,The parse_chunk_header function in libtorrent before 1.1.1 allows remote attackers to cause a denial of service (crash) via a crafted (1) HTTP response or possibly a (2) UPnP broadcast.,7.5,HIGH,2,valid,2016-06-04T03:12:27Z,1
CVE-2018-1000085,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Cisco-Talos/clamav,bb11588 - fix out of bounds read.,d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,https://github.com/Cisco-Talos/clamav/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,libclamav/xar.c,xar_hash_check,"static int xar_hash_check(int hash, const void * result, const void * expected)
{
int len;
if (!result || !expected)
return 1;
switch (hash) {
case XAR_CKSUM_SHA1:
len = SHA1_HASH_SIZE;
break;
case XAR_CKSUM_MD5:
len = CLI_HASH_MD5;
break;
case XAR_CKSUM_OTHER:
case XAR_CKSUM_NONE:
default:
return 1;
}
return memcmp(result, expected, len);
}","static int xar_hash_check(int VAR_0, const void * VAR_1, const void * VAR_2)
{
int VAR_3;
if (!VAR_1 || !VAR_2)
return 1;
switch (VAR_0) {
case VAR_4:
VAR_3 = VAR_5;
break;
case VAR_6:
VAR_3 = VAR_7;
break;
case VAR_8:
case VAR_9:
default:
return 1;
}
return memcmp(VAR_1, VAR_2, VAR_3);
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/before/1.json,"static int xar_hash_check(int hash, const void * result, const void * expected)
{
    int len;

    if (!result || !expected)
        return 1;
    switch (hash) {
    case XAR_CKSUM_SHA1:
        len = CLI_HASHLEN_SHA1;
        break;
    case XAR_CKSUM_MD5:
        len = CLI_HASHLEN_MD5;
        break;
    case XAR_CKSUM_OTHER:
    case XAR_CKSUM_NONE:
    default:
        return 1;
    }
    return memcmp(result, expected, len);
}","static int xar_hash_check(int VAR_0, const void * VAR_1, const void * VAR_2)
{
    int VAR_3;

    if (!VAR_1 || !VAR_2)
        return 1;
    switch (VAR_0) {
    case VAR_4:
        VAR_3 = VAR_5;
        break;
    case VAR_6:
        VAR_3 = VAR_7;
        break;
    case VAR_8:
    case VAR_9:
    default:
        return 1;
    }
    return memcmp(VAR_1, VAR_2, VAR_3);
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,10 +6,10 @@
         return 1;
     switch (hash) {
     case XAR_CKSUM_SHA1:
-        len = SHA1_HASH_SIZE;
+        len = CLI_HASHLEN_SHA1;
         break;
     case XAR_CKSUM_MD5:
-        len = CLI_HASH_MD5;
+        len = CLI_HASHLEN_MD5;
         break;
     case XAR_CKSUM_OTHER:
     case XAR_CKSUM_NONE:","{'deleted_lines': ['        len = SHA1_HASH_SIZE;', '        len = CLI_HASH_MD5;'], 'added_lines': ['        len = CLI_HASHLEN_SHA1;', '        len = CLI_HASHLEN_MD5;']}",True,"ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6.",5.5,MEDIUM,1,valid,2016-06-21T21:22:52Z,1
CVE-2018-1000085,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Cisco-Talos/clamav,bb11588 - fix out of bounds read.,d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,https://github.com/Cisco-Talos/clamav/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,libclamav/xar.c,xar_get_checksum_values,"static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)
{
xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)""style"");
const xmlChar * xmlval;
*hash = XAR_CKSUM_NONE;
if (style == NULL) {
cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
""for checksum element\n"");
} else {
cli_dbgmsg(""cli_scanxar: checksum algorithm is %s.\n"", style);        
if (0 == xmlStrcasecmp(style, (const xmlChar *)""sha1"")) {
*hash = XAR_CKSUM_SHA1;
} else if (0 == xmlStrcasecmp(style, (const xmlChar *)""md5"")) {
*hash = XAR_CKSUM_MD5;
} else {
cli_dbgmsg(""cli_scanxar: checksum algorithm %s is unsupported.\n"", style);
*hash = XAR_CKSUM_OTHER;
}
}
if (style != NULL)
xmlFree(style);
if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
xmlval = xmlTextReaderConstValue(reader);
if (xmlval) {
*cksum = xmlStrdup(xmlval); 
cli_dbgmsg(""cli_scanxar: checksum value is %s.\n"", *cksum);
} else {
*cksum = NULL;
cli_dbgmsg(""cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\n"");           
}
}
else
cli_dbgmsg(""cli_scanxar: No text for XML checksum element.\n"");
}","static void xar_get_checksum_values(xmlTextReaderPtr VAR_0, unsigned char ** VAR_1, int * VAR_2)
{
xmlChar * VAR_3 = xmlTextReaderGetAttribute(VAR_0, (const xmlChar *)""style"");
const xmlChar * VAR_4;
*VAR_2 = VAR_5;
if (VAR_3 == NULL) {
cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
""for checksum element\n"");
} else {
cli_dbgmsg(""cli_scanxar: checksum algorithm is %s.\n"", VAR_3);        
if (0 == xmlStrcasecmp(VAR_3, (const xmlChar *)""sha1"")) {
*VAR_2 = VAR_6;
} else if (0 == xmlStrcasecmp(VAR_3, (const xmlChar *)""md5"")) {
*VAR_2 = VAR_7;
} else {
cli_dbgmsg(""cli_scanxar: checksum algorithm %s is unsupported.\n"", VAR_3);
*VAR_2 = VAR_8;
}
}
if (VAR_3 != NULL)
xmlFree(VAR_3);
if (xmlTextReaderRead(VAR_0) == 1 && xmlTextReaderNodeType(VAR_0) == VAR_9) {
VAR_4 = xmlTextReaderConstValue(VAR_0);
if (VAR_4) {
*VAR_1 = xmlStrdup(VAR_4); 
cli_dbgmsg(""cli_scanxar: checksum value is %s.\n"", *VAR_1);
} else {
*VAR_1 = NULL;
cli_dbgmsg(""cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\n"");           
}
}
else
cli_dbgmsg(""cli_scanxar: No text for XML checksum element.\n"");
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/before/2.json,"static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)
{
    xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)""style"");
    const xmlChar * xmlval;

    *hash = XAR_CKSUM_NONE;
    if (style == NULL) {
        cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
                   ""for checksum element\n"");
    } else {
        cli_dbgmsg(""cli_scanxar: checksum algorithm is %s.\n"", style);        
        if (0 == xmlStrcasecmp(style, (const xmlChar *)""sha1"")) {
            *hash = XAR_CKSUM_SHA1;
        } else if (0 == xmlStrcasecmp(style, (const xmlChar *)""md5"")) {
            *hash = XAR_CKSUM_MD5;
        } else {
            cli_dbgmsg(""cli_scanxar: checksum algorithm %s is unsupported.\n"", style);
            *hash = XAR_CKSUM_OTHER;
        }
    }
    if (style != NULL)
        xmlFree(style);

    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
        xmlval = xmlTextReaderConstValue(reader);
        if (xmlval) {
            cli_dbgmsg(""cli_scanxar: checksum value is %s.\n"", xmlval);
            if (*hash == XAR_CKSUM_SHA1 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_SHA1 ||
                *hash == XAR_CKSUM_MD5 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_MD5)
                {
                    *cksum = xmlStrdup(xmlval); 
                } 
            else
                {
                    cli_dbgmsg(""cli_scanxar: checksum type is unknown or length is invalid.\n"");
                    *hash = XAR_CKSUM_OTHER;
                    *cksum = NULL;
                }
        } else {
            *cksum = NULL;
            cli_dbgmsg(""cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\n"");           
        }
    }
    else
        cli_dbgmsg(""cli_scanxar: No text for XML checksum element.\n"");
}","static void xar_get_checksum_values(xmlTextReaderPtr VAR_0, unsigned char ** VAR_1, int * VAR_2)
{
    xmlChar * VAR_3 = xmlTextReaderGetAttribute(VAR_0, (const xmlChar *)""style"");
    const xmlChar * VAR_4;

    *VAR_2 = VAR_5;
    if (VAR_3 == NULL) {
        cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
                   ""for checksum element\n"");
    } else {
        cli_dbgmsg(""cli_scanxar: checksum algorithm is %s.\n"", VAR_3);        
        if (0 == xmlStrcasecmp(VAR_3, (const xmlChar *)""sha1"")) {
            *VAR_2 = VAR_6;
        } else if (0 == xmlStrcasecmp(VAR_3, (const xmlChar *)""md5"")) {
            *VAR_2 = VAR_7;
        } else {
            cli_dbgmsg(""cli_scanxar: checksum algorithm %s is unsupported.\n"", VAR_3);
            *VAR_2 = VAR_8;
        }
    }
    if (VAR_3 != NULL)
        xmlFree(VAR_3);

    if (xmlTextReaderRead(VAR_0) == 1 && xmlTextReaderNodeType(VAR_0) == VAR_9) {
        VAR_4 = xmlTextReaderConstValue(VAR_0);
        if (VAR_4) {
            cli_dbgmsg(""cli_scanxar: checksum value is %s.\n"", VAR_4);
            if (*VAR_2 == VAR_6 && xmlStrlen(VAR_4) == 2 * VAR_10 ||
                *VAR_2 == VAR_7 && xmlStrlen(VAR_4) == 2 * VAR_11)
                {
                    *VAR_1 = xmlStrdup(VAR_4); 
                } 
            else
                {
                    cli_dbgmsg(""cli_scanxar: checksum type is unknown or length is invalid.\n"");
                    *VAR_2 = VAR_8;
                    *VAR_1 = NULL;
                }
        } else {
            *VAR_1 = NULL;
            cli_dbgmsg(""cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\n"");           
        }
    }
    else
        cli_dbgmsg(""cli_scanxar: No text for XML checksum element.\n"");
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -24,8 +24,18 @@
     if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
         xmlval = xmlTextReaderConstValue(reader);
         if (xmlval) {
-            *cksum = xmlStrdup(xmlval); 
-            cli_dbgmsg(""cli_scanxar: checksum value is %s.\n"", *cksum);
+            cli_dbgmsg(""cli_scanxar: checksum value is %s.\n"", xmlval);
+            if (*hash == XAR_CKSUM_SHA1 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_SHA1 ||
+                *hash == XAR_CKSUM_MD5 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_MD5)
+                {
+                    *cksum = xmlStrdup(xmlval); 
+                } 
+            else
+                {
+                    cli_dbgmsg(""cli_scanxar: checksum type is unknown or length is invalid.\n"");
+                    *hash = XAR_CKSUM_OTHER;
+                    *cksum = NULL;
+                }
         } else {
             *cksum = NULL;
             cli_dbgmsg(""cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\n"");           ","{'deleted_lines': ['            *cksum = xmlStrdup(xmlval); ', '            cli_dbgmsg(""cli_scanxar: checksum value is %s.\\n"", *cksum);'], 'added_lines': ['            cli_dbgmsg(""cli_scanxar: checksum value is %s.\\n"", xmlval);', '            if (*hash == XAR_CKSUM_SHA1 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_SHA1 ||', '                *hash == XAR_CKSUM_MD5 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_MD5)', '                {', '                    *cksum = xmlStrdup(xmlval); ', '                } ', '            else', '                {', '                    cli_dbgmsg(""cli_scanxar: checksum type is unknown or length is invalid.\\n"");', '                    *hash = XAR_CKSUM_OTHER;', '                    *cksum = NULL;', '                }']}",True,"ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6.",5.5,MEDIUM,1,valid,2016-06-21T21:22:52Z,1
CVE-2018-1000085,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Cisco-Talos/clamav,bb11588 - fix out of bounds read.,d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,https://github.com/Cisco-Talos/clamav/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,libclamav/xar.c,xar_get_toc_data_values,"static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,
unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)
{
const xmlChar *name;
int indata = 0, inea = 0;
int rc, gotoffset=0, gotlength=0, gotsize=0;
*a_cksum = NULL;
*a_hash = XAR_CKSUM_NONE;
*e_cksum = NULL;
*e_hash = XAR_CKSUM_NONE;
*encoding = CL_TYPE_ANY;
rc = xmlTextReaderRead(reader);
while (rc == 1) {
name = xmlTextReaderConstLocalName(reader);
if (indata || inea) {
if (xmlStrEqual(name, (const xmlChar *)""offset"") && 
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, offset))
gotoffset=1;
} else if (xmlStrEqual(name, (const xmlChar *)""length"") &&
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, length))
gotlength=1;
} else if (xmlStrEqual(name, (const xmlChar *)""size"") &&
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, size))
gotsize=1;
} else if (xmlStrEqual(name, (const xmlChar *)""archived-checksum"") &&
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
cli_dbgmsg(""cli_scanxar: <archived-checksum>:\n"");
xar_get_checksum_values(reader, a_cksum, a_hash);
} else if ((xmlStrEqual(name, (const xmlChar *)""extracted-checksum"") ||
xmlStrEqual(name, (const xmlChar *)""unarchived-checksum"")) &&
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
cli_dbgmsg(""cli_scanxar: <extracted-checksum>:\n"");
xar_get_checksum_values(reader, e_cksum, e_hash);
} else if (xmlStrEqual(name, (const xmlChar *)""encoding"") &&
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)""style"");
if (style == NULL) {
cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
""for encoding element\n"");
*encoding = CL_TYPE_ANY;
} else if (xmlStrEqual(style, (const xmlChar *)""application/x-gzip"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-gzip.\n"");
*encoding = CL_TYPE_GZ; 
} else if (xmlStrEqual(style, (const xmlChar *)""application/octet-stream"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/octet-stream.\n"");
*encoding = CL_TYPE_ANY; 
} else if (xmlStrEqual(style, (const xmlChar *)""application/x-bzip2"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-bzip2.\n"");
*encoding = CL_TYPE_BZ;
} else if (xmlStrEqual(style, (const xmlChar *)""application/x-lzma"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-lzma.\n"");
*encoding = CL_TYPE_7Z;
} else if (xmlStrEqual(style, (const xmlChar *)""application/x-xz"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-xz.\n"");
*encoding = CL_TYPE_XZ;
} else {
cli_dbgmsg(""cli_scaxar: unknown style value=%s for encoding element\n"", style);
*encoding = CL_TYPE_ANY;
}
if (style != NULL)
xmlFree(style);
} else if (indata && xmlStrEqual(name, (const xmlChar *)""data"") &&
xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {
break;
} else if (inea && xmlStrEqual(name, (const xmlChar *)""ea"") &&
xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {
break;
}
} else {
if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
if (xmlStrEqual(name, (const xmlChar *)""data"")) {
cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <data>\n"");
indata = 1;
} else if (xmlStrEqual(name, (const xmlChar *)""ea"")) {
cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <ea>\n"");
inea = 1;
}
} else if ((xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) &&
xmlStrEqual(name, (const xmlChar *)""xar"")) {
cli_dbgmsg(""cli_scanxar: finished parsing xar TOC.\n"");   
break;
}
}
rc = xmlTextReaderRead(reader);
}
if (gotoffset && gotlength && gotsize) {
rc = CL_SUCCESS;
}
else if (0 == gotoffset + gotlength + gotsize)
rc = CL_BREAK;
else
rc = CL_EFORMAT;
return rc;
}","static int xar_get_toc_data_values(xmlTextReaderPtr VAR_0, long *VAR_1, long *VAR_2, long *VAR_3, int *VAR_4,
unsigned char ** VAR_5, int * VAR_6, unsigned char ** VAR_7, int * VAR_8)
{
const xmlChar *VAR_9;
int VAR_10 = 0, VAR_11 = 0;
int VAR_12, VAR_13=0, VAR_14=0, VAR_15=0;
*VAR_5 = NULL;
*VAR_6 = VAR_16;
*VAR_7 = NULL;
*VAR_8 = VAR_16;
*VAR_4 = VAR_17;
VAR_12 = xmlTextReaderRead(VAR_0);
while (VAR_12 == 1) {
VAR_9 = xmlTextReaderConstLocalName(VAR_0);
if (VAR_10 || VAR_11) {
if (xmlStrEqual(VAR_9, (const xmlChar *)""offset"") && 
xmlTextReaderNodeType(VAR_0) == VAR_18) {
if (VAR_19 == xar_get_numeric_from_xml_element(VAR_0, VAR_2))
VAR_13=1;
} else if (xmlStrEqual(VAR_9, (const xmlChar *)""length"") &&
xmlTextReaderNodeType(VAR_0) == VAR_18) {
if (VAR_19 == xar_get_numeric_from_xml_element(VAR_0, VAR_1))
VAR_14=1;
} else if (xmlStrEqual(VAR_9, (const xmlChar *)""size"") &&
xmlTextReaderNodeType(VAR_0) == VAR_18) {
if (VAR_19 == xar_get_numeric_from_xml_element(VAR_0, VAR_3))
VAR_15=1;
} else if (xmlStrEqual(VAR_9, (const xmlChar *)""archived-checksum"") &&
xmlTextReaderNodeType(VAR_0) == VAR_18) {
cli_dbgmsg(""cli_scanxar: <archived-checksum>:\n"");
xar_get_checksum_values(VAR_0, VAR_5, VAR_6);
} else if ((xmlStrEqual(VAR_9, (const xmlChar *)""extracted-checksum"") ||
xmlStrEqual(VAR_9, (const xmlChar *)""unarchived-checksum"")) &&
xmlTextReaderNodeType(VAR_0) == VAR_18) {
cli_dbgmsg(""cli_scanxar: <extracted-checksum>:\n"");
xar_get_checksum_values(VAR_0, VAR_7, VAR_8);
} else if (xmlStrEqual(VAR_9, (const xmlChar *)""encoding"") &&
xmlTextReaderNodeType(VAR_0) == VAR_18) {
xmlChar * VAR_20 = xmlTextReaderGetAttribute(VAR_0, (const xmlChar *)""style"");
if (VAR_20 == NULL) {
cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
""for encoding element\n"");
*VAR_4 = VAR_17;
} else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-gzip"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-gzip.\n"");
*VAR_4 = VAR_21; 
} else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/octet-stream"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/octet-stream.\n"");
*VAR_4 = VAR_17; 
} else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-bzip2"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-bzip2.\n"");
*VAR_4 = VAR_22;
} else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-lzma"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-lzma.\n"");
*VAR_4 = VAR_23;
} else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-xz"")) {
cli_dbgmsg(""cli_scanxar: encoding = application/x-xz.\n"");
*VAR_4 = VAR_24;
} else {
cli_dbgmsg(""cli_scaxar: unknown style value=%s for encoding element\n"", VAR_20);
*VAR_4 = VAR_17;
}
if (VAR_20 != NULL)
xmlFree(VAR_20);
} else if (VAR_10 && xmlStrEqual(VAR_9, (const xmlChar *)""data"") &&
xmlTextReaderNodeType(VAR_0) == VAR_25) {
break;
} else if (VAR_11 && xmlStrEqual(VAR_9, (const xmlChar *)""ea"") &&
xmlTextReaderNodeType(VAR_0) == VAR_25) {
break;
}
} else {
if (xmlTextReaderNodeType(VAR_0) == VAR_18) {
if (xmlStrEqual(VAR_9, (const xmlChar *)""data"")) {
cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <data>\n"");
VAR_10 = 1;
} else if (xmlStrEqual(VAR_9, (const xmlChar *)""ea"")) {
cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <ea>\n"");
VAR_11 = 1;
}
} else if ((xmlTextReaderNodeType(VAR_0) == VAR_25) &&
xmlStrEqual(VAR_9, (const xmlChar *)""xar"")) {
cli_dbgmsg(""cli_scanxar: finished parsing xar TOC.\n"");   
break;
}
}
VAR_12 = xmlTextReaderRead(VAR_0);
}
if (VAR_13 && VAR_14 && VAR_15) {
VAR_12 = VAR_19;
}
else if (0 == VAR_13 + VAR_14 + VAR_15)
VAR_12 = VAR_26;
else
VAR_12 = VAR_27;
return VAR_12;
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/before/3.json,"static int xar_get_toc_data_values(xmlTextReaderPtr reader, size_t *length, size_t *offset, size_t *size, int *encoding,
                                   unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)
{
    const xmlChar *name;
    int indata = 0, inea = 0;
    int rc, gotoffset=0, gotlength=0, gotsize=0;

    *a_cksum = NULL;
    *a_hash = XAR_CKSUM_NONE;
    *e_cksum = NULL;
    *e_hash = XAR_CKSUM_NONE;
    *encoding = CL_TYPE_ANY;

    rc = xmlTextReaderRead(reader);
    while (rc == 1) {
        name = xmlTextReaderConstLocalName(reader);
        if (indata || inea) {
            /*  cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read %s\n"", name); */
            if (xmlStrEqual(name, (const xmlChar *)""offset"") && 
                xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, offset))
                    gotoffset=1;

            } else if (xmlStrEqual(name, (const xmlChar *)""length"") &&
                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, length))
                    gotlength=1;

            } else if (xmlStrEqual(name, (const xmlChar *)""size"") &&
                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, size))
                    gotsize=1;

            } else if (xmlStrEqual(name, (const xmlChar *)""archived-checksum"") &&
                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
                cli_dbgmsg(""cli_scanxar: <archived-checksum>:\n"");
                xar_get_checksum_values(reader, a_cksum, a_hash);
                
            } else if ((xmlStrEqual(name, (const xmlChar *)""extracted-checksum"") ||
                        xmlStrEqual(name, (const xmlChar *)""unarchived-checksum"")) &&
                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
                cli_dbgmsg(""cli_scanxar: <extracted-checksum>:\n"");
                xar_get_checksum_values(reader, e_cksum, e_hash);

            } else if (xmlStrEqual(name, (const xmlChar *)""encoding"") &&
                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
                xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)""style"");
                if (style == NULL) {
                    cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
                               ""for encoding element\n"");
                    *encoding = CL_TYPE_ANY;
                } else if (xmlStrEqual(style, (const xmlChar *)""application/x-gzip"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-gzip.\n"");
                    *encoding = CL_TYPE_GZ; 
                } else if (xmlStrEqual(style, (const xmlChar *)""application/octet-stream"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/octet-stream.\n"");
                    *encoding = CL_TYPE_ANY; 
                } else if (xmlStrEqual(style, (const xmlChar *)""application/x-bzip2"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-bzip2.\n"");
                    *encoding = CL_TYPE_BZ;
                } else if (xmlStrEqual(style, (const xmlChar *)""application/x-lzma"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-lzma.\n"");
                    *encoding = CL_TYPE_7Z;
                 } else if (xmlStrEqual(style, (const xmlChar *)""application/x-xz"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-xz.\n"");
                    *encoding = CL_TYPE_XZ;
                } else {
                    cli_dbgmsg(""cli_scaxar: unknown style value=%s for encoding element\n"", style);
                    *encoding = CL_TYPE_ANY;
                }
                if (style != NULL)
                    xmlFree(style);

           } else if (indata && xmlStrEqual(name, (const xmlChar *)""data"") &&
                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {
                break;

            } else if (inea && xmlStrEqual(name, (const xmlChar *)""ea"") &&
                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {
                break;
            }
            
        } else {
            if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {
                if (xmlStrEqual(name, (const xmlChar *)""data"")) {
                    cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <data>\n"");
                    indata = 1;
                } else if (xmlStrEqual(name, (const xmlChar *)""ea"")) {
                    cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <ea>\n"");
                    inea = 1;
                }
            } else if ((xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) &&
                       xmlStrEqual(name, (const xmlChar *)""xar"")) {
                cli_dbgmsg(""cli_scanxar: finished parsing xar TOC.\n"");   
                break;
            }
        }
        rc = xmlTextReaderRead(reader);
    }
    
    if (gotoffset && gotlength && gotsize) {
        rc = CL_SUCCESS;
    }
    else if (0 == gotoffset + gotlength + gotsize)
        rc = CL_BREAK;
    else
        rc = CL_EFORMAT;

    return rc;
}","static int xar_get_toc_data_values(xmlTextReaderPtr VAR_0, size_t *VAR_1, size_t *VAR_2, size_t *VAR_3, int *VAR_4,
                                   unsigned char ** VAR_5, int * VAR_6, unsigned char ** VAR_7, int * VAR_8)
{
    const xmlChar *VAR_9;
    int VAR_10 = 0, VAR_11 = 0;
    int VAR_12, VAR_13=0, VAR_14=0, VAR_15=0;

    *VAR_5 = NULL;
    *VAR_6 = VAR_16;
    *VAR_7 = NULL;
    *VAR_8 = VAR_16;
    *VAR_4 = VAR_17;

    VAR_12 = xmlTextReaderRead(VAR_0);
    while (VAR_12 == 1) {
        VAR_9 = xmlTextReaderConstLocalName(VAR_0);
        if (VAR_10 || VAR_11) {
            /* COMMENT_0 */
            if (xmlStrEqual(VAR_9, (const xmlChar *)""offset"") && 
                xmlTextReaderNodeType(VAR_0) == VAR_18) {
                if (VAR_19 == xar_get_numeric_from_xml_element(VAR_0, VAR_2))
                    VAR_13=1;

            } else if (xmlStrEqual(VAR_9, (const xmlChar *)""length"") &&
                       xmlTextReaderNodeType(VAR_0) == VAR_18) {
                if (VAR_19 == xar_get_numeric_from_xml_element(VAR_0, VAR_1))
                    VAR_14=1;

            } else if (xmlStrEqual(VAR_9, (const xmlChar *)""size"") &&
                       xmlTextReaderNodeType(VAR_0) == VAR_18) {
                if (VAR_19 == xar_get_numeric_from_xml_element(VAR_0, VAR_3))
                    VAR_15=1;

            } else if (xmlStrEqual(VAR_9, (const xmlChar *)""archived-checksum"") &&
                       xmlTextReaderNodeType(VAR_0) == VAR_18) {
                cli_dbgmsg(""cli_scanxar: <archived-checksum>:\n"");
                xar_get_checksum_values(VAR_0, VAR_5, VAR_6);
                
            } else if ((xmlStrEqual(VAR_9, (const xmlChar *)""extracted-checksum"") ||
                        xmlStrEqual(VAR_9, (const xmlChar *)""unarchived-checksum"")) &&
                       xmlTextReaderNodeType(VAR_0) == VAR_18) {
                cli_dbgmsg(""cli_scanxar: <extracted-checksum>:\n"");
                xar_get_checksum_values(VAR_0, VAR_7, VAR_8);

            } else if (xmlStrEqual(VAR_9, (const xmlChar *)""encoding"") &&
                       xmlTextReaderNodeType(VAR_0) == VAR_18) {
                xmlChar * VAR_20 = xmlTextReaderGetAttribute(VAR_0, (const xmlChar *)""style"");
                if (VAR_20 == NULL) {
                    cli_dbgmsg(""cli_scaxar: xmlTextReaderGetAttribute no style attribute ""
                               ""for encoding element\n"");
                    *VAR_4 = VAR_17;
                } else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-gzip"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-gzip.\n"");
                    *VAR_4 = VAR_21; 
                } else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/octet-stream"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/octet-stream.\n"");
                    *VAR_4 = VAR_17; 
                } else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-bzip2"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-bzip2.\n"");
                    *VAR_4 = VAR_22;
                } else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-lzma"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-lzma.\n"");
                    *VAR_4 = VAR_23;
                 } else if (xmlStrEqual(VAR_20, (const xmlChar *)""application/x-xz"")) {
                    cli_dbgmsg(""cli_scanxar: encoding = application/x-xz.\n"");
                    *VAR_4 = VAR_24;
                } else {
                    cli_dbgmsg(""cli_scaxar: unknown style value=%s for encoding element\n"", VAR_20);
                    *VAR_4 = VAR_17;
                }
                if (VAR_20 != NULL)
                    xmlFree(VAR_20);

           } else if (VAR_10 && xmlStrEqual(VAR_9, (const xmlChar *)""data"") &&
                       xmlTextReaderNodeType(VAR_0) == VAR_25) {
                break;

            } else if (VAR_11 && xmlStrEqual(VAR_9, (const xmlChar *)""ea"") &&
                       xmlTextReaderNodeType(VAR_0) == VAR_25) {
                break;
            }
            
        } else {
            if (xmlTextReaderNodeType(VAR_0) == VAR_18) {
                if (xmlStrEqual(VAR_9, (const xmlChar *)""data"")) {
                    cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <data>\n"");
                    VAR_10 = 1;
                } else if (xmlStrEqual(VAR_9, (const xmlChar *)""ea"")) {
                    cli_dbgmsg(""cli_scanxar: xmlTextReaderRead read <ea>\n"");
                    VAR_11 = 1;
                }
            } else if ((xmlTextReaderNodeType(VAR_0) == VAR_25) &&
                       xmlStrEqual(VAR_9, (const xmlChar *)""xar"")) {
                cli_dbgmsg(""cli_scanxar: finished parsing xar TOC.\n"");   
                break;
            }
        }
        VAR_12 = xmlTextReaderRead(VAR_0);
    }
    
    if (VAR_13 && VAR_14 && VAR_15) {
        VAR_12 = VAR_19;
    }
    else if (0 == VAR_13 + VAR_14 + VAR_15)
        VAR_12 = VAR_26;
    else
        VAR_12 = VAR_27;

    return VAR_12;
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,
+static int xar_get_toc_data_values(xmlTextReaderPtr reader, size_t *length, size_t *offset, size_t *size, int *encoding,
                                    unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)
 {
     const xmlChar *name;","{'deleted_lines': ['static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,'], 'added_lines': ['static int xar_get_toc_data_values(xmlTextReaderPtr reader, size_t *length, size_t *offset, size_t *size, int *encoding,']}",True,"ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6.",5.5,MEDIUM,1,valid,2016-06-21T21:22:52Z,1
CVE-2018-1000085,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Cisco-Talos/clamav,bb11588 - fix out of bounds read.,d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,https://github.com/Cisco-Talos/clamav/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,libclamav/xar.c,cli_scanxar,"int cli_scanxar(cli_ctx *ctx)
{
int rc = CL_SUCCESS;
unsigned int cksum_fails = 0;
unsigned int extract_errors = 0;
#if HAVE_LIBXML2
int fd = -1;
struct xar_header hdr;
fmap_t *map = *ctx->fmap;
long length, offset, size, at;
int encoding;
z_stream strm;
char *toc, *tmpname;
xmlTextReaderPtr reader = NULL;
int a_hash, e_hash;
unsigned char *a_cksum = NULL, *e_cksum = NULL;
void *a_hash_ctx = NULL, *e_hash_ctx = NULL;
char result[SHA1_HASH_SIZE];
memset(&strm, 0x00, sizeof(z_stream));
if (fmap_readn(*ctx->fmap, &hdr, 0, sizeof(hdr)) != sizeof(hdr)) {
cli_dbgmsg(""cli_scanxar: Invalid header, too short.\n"");
return CL_EFORMAT;
}
hdr.magic = be32_to_host(hdr.magic);
if (hdr.magic == XAR_HEADER_MAGIC) {
cli_dbgmsg(""cli_scanxar: Matched magic\n"");
}
else {
cli_dbgmsg(""cli_scanxar: Invalid magic\n"");
return CL_EFORMAT;
}
hdr.size = be16_to_host(hdr.size);
hdr.version = be16_to_host(hdr.version);
hdr.toc_length_compressed = be64_to_host(hdr.toc_length_compressed);
hdr.toc_length_decompressed = be64_to_host(hdr.toc_length_decompressed);
hdr.chksum_alg = be32_to_host(hdr.chksum_alg);
strm.next_in = (unsigned char *)fmap_need_off_once(*ctx->fmap, hdr.size, hdr.toc_length_compressed);
if (strm.next_in == NULL) {
cli_dbgmsg(""cli_scanxar: fmap_need_off_once fails on TOC.\n"");
return CL_EREAD;
}
strm.avail_in = hdr.toc_length_compressed; 
toc = cli_malloc(hdr.toc_length_decompressed+1);
if (toc == NULL) {
cli_dbgmsg(""cli_scanxar: cli_malloc fails on TOC decompress buffer.\n"");
return CL_EMEM;
}
toc[hdr.toc_length_decompressed] = '\0';
strm.avail_out = hdr.toc_length_decompressed;
strm.next_out = (unsigned char *)toc;
rc = inflateInit(&strm);
if (rc != Z_OK) {
cli_dbgmsg(""cli_scanxar:inflateInit error %i \n"", rc);
rc = CL_EFORMAT;
goto exit_toc;
}    
rc = inflate(&strm, Z_SYNC_FLUSH);
if (rc != Z_OK && rc != Z_STREAM_END) {
cli_dbgmsg(""cli_scanxar:inflate error %i \n"", rc);
rc = CL_EFORMAT;
goto exit_toc;
}
rc = inflateEnd(&strm);
if (rc != Z_OK) {
cli_dbgmsg(""cli_scanxar:inflateEnd error %i \n"", rc);
rc = CL_EFORMAT;
goto exit_toc;
}
cli_dbgmsg(""cli_scanxar: scanning xar TOC xml in memory.\n""); 
rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);
if (rc != CL_SUCCESS) {
if (rc != CL_VIRUS || !SCAN_ALL)
goto exit_toc;        
}
if(ctx->engine->keeptmp) {
if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {
cli_dbgmsg(""cli_scanxar: Can't create temporary file for TOC.\n"");
goto exit_toc;
}
if (cli_writen(fd, toc, hdr.toc_length_decompressed) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error writing TOC.\n"");
rc = CL_EWRITE;
xar_cleanup_temp_file(ctx, fd, tmpname);
goto exit_toc;
}
rc = xar_cleanup_temp_file(ctx, fd, tmpname);
if (rc != CL_SUCCESS)
goto exit_toc;
}
reader = xmlReaderForMemory(toc, hdr.toc_length_decompressed, ""noname.xml"", NULL, CLAMAV_MIN_XMLREADER_FLAGS);
if (reader == NULL) {
cli_dbgmsg(""cli_scanxar: xmlReaderForMemory error for TOC\n"");
goto exit_toc;
}
rc = xar_scan_subdocuments(reader, ctx);
if (rc != CL_SUCCESS) {
cli_dbgmsg(""xar_scan_subdocuments returns %i.\n"", rc);
goto exit_reader;
}
fd = -1;
tmpname = NULL;
while (CL_SUCCESS == (rc = xar_get_toc_data_values(reader, &length, &offset, &size, &encoding,
&a_cksum, &a_hash, &e_cksum, &e_hash))) {
int do_extract_cksum = 1;
unsigned char * blockp;
void *a_sc, *e_sc;
void *a_mc, *e_mc;
char * expected;
if (fd > -1 && tmpname) {
rc = xar_cleanup_temp_file(ctx, fd, tmpname);
if (rc != CL_SUCCESS)
goto exit_reader;
}
at = offset + hdr.toc_length_compressed + hdr.size;
if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {
cli_dbgmsg(""cli_scanxar: Can't generate temporary file.\n"");
goto exit_reader;
}
cli_dbgmsg(""cli_scanxar: decompress into temp file:\n%s, size %li,\n""
""from xar heap offset %li length %li\n"",
tmpname, size, offset, length);
a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);
e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);
switch (encoding) {
case CL_TYPE_GZ:
memset(&strm, 0, sizeof(strm));
if ((rc = inflateInit(&strm)) != Z_OK) {
cli_dbgmsg(""cli_scanxar: InflateInit failed: %d\n"", rc);
rc = CL_EFORMAT;
extract_errors++;
break;
}
while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {
unsigned long avail_in;
void * next_in;
unsigned int bytes = MIN(map->len - at, map->pgsz);
bytes = MIN(length, bytes);
if(!(strm.next_in = next_in = (void*)fmap_need_off_once(map, at, bytes))) {
cli_dbgmsg(""cli_scanxar: Can't read %u bytes @ %lu.\n"", bytes, (long unsigned)at);
inflateEnd(&strm);
rc = CL_EREAD;
goto exit_tmpfile;
}
at += bytes;
strm.avail_in = avail_in = bytes;
do {
int inf, outsize = 0;
unsigned char buff[FILEBUFF];
strm.avail_out = sizeof(buff);
strm.next_out = buff;
inf = inflate(&strm, Z_SYNC_FLUSH);
if (inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR) {
cli_dbgmsg(""cli_scanxar: inflate error %i %s.\n"", inf, strm.msg?strm.msg:"""");
rc = CL_EFORMAT;
extract_errors++;
break;
}
bytes = sizeof(buff) - strm.avail_out;
if (e_hash_ctx != NULL)
xar_hash_update(e_hash_ctx, buff, bytes, e_hash);
if (cli_writen(fd, buff, bytes) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error file %s.\n"", tmpname);
inflateEnd(&strm);
rc = CL_EWRITE;
goto exit_tmpfile;
}
outsize += sizeof(buff) - strm.avail_out;
if (cli_checklimits(""cli_scanxar"", ctx, outsize, 0, 0) != CL_CLEAN) {
break;
}
if (inf == Z_STREAM_END) {
break;
}
} while (strm.avail_out == 0);
if (rc != CL_SUCCESS)
break;
avail_in -= strm.avail_in;
if (a_hash_ctx != NULL)
xar_hash_update(a_hash_ctx, next_in, avail_in, a_hash);
}
inflateEnd(&strm);
break;
case CL_TYPE_7Z:
#define CLI_LZMA_OBUF_SIZE 1024*1024
#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8
#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 
{
struct CLI_LZMA lz;
unsigned long in_remaining = length;
unsigned long out_size = 0;
unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);
int lret;
memset(&lz, 0, sizeof(lz));
if (buff == NULL) {
cli_dbgmsg(""cli_scanxar: memory request for lzma decompression buffer fails.\n"");
rc = CL_EMEM;
goto exit_tmpfile;
}
blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);
if (blockp == NULL) {
char errbuff[128];
cli_strerror(errno, errbuff, sizeof(errbuff));
cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno:%s.\n"",
length, at, errbuff);
rc = CL_EREAD;
__lzma_wrap_free(NULL, buff);
goto exit_tmpfile;
}
lz.next_in = blockp;
lz.avail_in = CLI_LZMA_HDR_SIZE;
if (a_hash_ctx != NULL)
xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);
lret = cli_LzmaInit(&lz, 0);
if (lret != LZMA_RESULT_OK) {
cli_dbgmsg(""cli_scanxar: cli_LzmaInit() fails: %i.\n"", lret);
rc = CL_EFORMAT;
__lzma_wrap_free(NULL, buff);
extract_errors++;
break;
}
at += CLI_LZMA_HDR_SIZE;
in_remaining -= CLI_LZMA_HDR_SIZE;
while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {
SizeT avail_in;
SizeT avail_out;
void * next_in;
unsigned long in_consumed;
lz.next_out = buff;
lz.avail_out = CLI_LZMA_OBUF_SIZE;
lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);
lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);
if (lz.next_in == NULL) {
char errbuff[128];
cli_strerror(errno, errbuff, sizeof(errbuff));
cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno: %s.\n"",
length, at, errbuff);
rc = CL_EREAD;
__lzma_wrap_free(NULL, buff);
cli_LzmaShutdown(&lz);
goto exit_tmpfile;
}
lret = cli_LzmaDecode(&lz);
if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {
cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() fails: %i.\n"", lret);
rc = CL_EFORMAT;
extract_errors++;
break;
}
in_consumed = avail_in - lz.avail_in;
in_remaining -= in_consumed;
at += in_consumed;
avail_out = CLI_LZMA_OBUF_SIZE - lz.avail_out;
if (avail_out == 0)
cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() produces no output for ""
""avail_in %llu, avail_out %llu.\n"",
(long long unsigned)avail_in, (long long unsigned)avail_out);
if (a_hash_ctx != NULL)
xar_hash_update(a_hash_ctx, next_in, in_consumed, a_hash);                    
if (e_hash_ctx != NULL)
xar_hash_update(e_hash_ctx, buff, avail_out, e_hash);
if (cli_writen(fd, buff, avail_out) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\n"",
(long long unsigned)avail_out);
__lzma_wrap_free(NULL, buff);
cli_LzmaShutdown(&lz);
rc = CL_EWRITE;
goto exit_tmpfile;
}
out_size += avail_out;
if (cli_checklimits(""cli_scanxar"", ctx, out_size, 0, 0) != CL_CLEAN) {
break;
}
if (lret == LZMA_STREAM_END)
break;
}
cli_LzmaShutdown(&lz);
__lzma_wrap_free(NULL, buff);
}
break; 
case CL_TYPE_ANY:
default:
case CL_TYPE_BZ:
case CL_TYPE_XZ:
do_extract_cksum = 0;
{
unsigned long write_len;
if (ctx->engine->maxfilesize)
write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);
else
write_len = length;
if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {
char errbuff[128];
cli_strerror(errno, errbuff, sizeof(errbuff));
cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno:%s.\n"",
length, at, errbuff);
rc = CL_EREAD;
goto exit_tmpfile;
}
if (a_hash_ctx != NULL)
xar_hash_update(a_hash_ctx, blockp, length, a_hash);
if (cli_writen(fd, blockp, write_len) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error %li bytes @ %li.\n"", length, at);
rc = CL_EWRITE;
goto exit_tmpfile;
}
}          
}
if (rc == CL_SUCCESS) {
if (a_hash_ctx != NULL) {
xar_hash_final(a_hash_ctx, result, a_hash);
a_hash_ctx = NULL;
} else {
cli_dbgmsg(""cli_scanxar: archived-checksum missing.\n"");
cksum_fails++;
}
if (a_cksum != NULL) {
expected = cli_hex2str((char *)a_cksum);
if (xar_hash_check(a_hash, result, expected) != 0) {
cli_dbgmsg(""cli_scanxar: archived-checksum mismatch.\n"");
cksum_fails++;
} else {
cli_dbgmsg(""cli_scanxar: archived-checksum matched.\n"");                
}
free(expected);
}
if (e_hash_ctx != NULL) {
xar_hash_final(e_hash_ctx, result, e_hash);
e_hash_ctx = NULL;
} else {
cli_dbgmsg(""cli_scanxar: extracted-checksum(unarchived-checksum) missing.\n"");
cksum_fails++;
}
if (e_cksum != NULL) {
if (do_extract_cksum) {
expected = cli_hex2str((char *)e_cksum);
if (xar_hash_check(e_hash, result, expected) != 0) {
cli_dbgmsg(""cli_scanxar: extracted-checksum mismatch.\n"");
cksum_fails++;
} else {
cli_dbgmsg(""cli_scanxar: extracted-checksum matched.\n"");                
}
free(expected);
}
}
rc = cli_magic_scandesc(fd, ctx);
if (rc != CL_SUCCESS) {
if (rc == CL_VIRUS) {
cli_dbgmsg(""cli_scanxar: Infected with %s\n"", cli_get_last_virus(ctx));
if (!SCAN_ALL)
goto exit_tmpfile;
} else if (rc != CL_BREAK) {
cli_dbgmsg(""cli_scanxar: cli_magic_scandesc error %i\n"", rc);
goto exit_tmpfile;
}
}
}
if (a_cksum != NULL) {
xmlFree(a_cksum);
a_cksum = NULL;
}
if (e_cksum != NULL) {
xmlFree(e_cksum);
e_cksum = NULL;
}
}
exit_tmpfile:
xar_cleanup_temp_file(ctx, fd, tmpname);
if (a_hash_ctx != NULL)
xar_hash_final(a_hash_ctx, result, a_hash);
if (e_hash_ctx != NULL)
xar_hash_final(e_hash_ctx, result, e_hash);
exit_reader:
if (a_cksum != NULL)
xmlFree(a_cksum);   
if (e_cksum != NULL)
xmlFree(e_cksum);
xmlTextReaderClose(reader);
xmlFreeTextReader(reader);
exit_toc:
free(toc);
if (rc == CL_BREAK)
rc = CL_SUCCESS;
#else
cli_dbgmsg(""cli_scanxar: can't scan xar files, need libxml2.\n"");
#endif
if (cksum_fails + extract_errors != 0) {
cli_warnmsg(""cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\n"",
cksum_fails, extract_errors);
}
return rc;
}","int cli_scanxar(cli_ctx *VAR_0)
{
int VAR_1 = VAR_2;
unsigned int VAR_3 = 0;
unsigned int VAR_4 = 0;
#if VAR_5
int VAR_6 = -1;
struct xar_header VAR_7;
fmap_t *VAR_8 = *VAR_0->fmap;
long VAR_9, VAR_10, VAR_11, VAR_12;
int VAR_13;
z_stream VAR_14;
char *VAR_15, *VAR_16;
xmlTextReaderPtr VAR_17 = NULL;
int VAR_18, VAR_19;
unsigned char *VAR_20 = NULL, *VAR_21 = NULL;
void *VAR_22 = NULL, *VAR_23 = NULL;
char VAR_24[VAR_25];
memset(&VAR_14, 0x00, sizeof(z_stream));
if (fmap_readn(*VAR_0->fmap, &VAR_7, 0, sizeof(VAR_7)) != sizeof(VAR_7)) {
cli_dbgmsg(""cli_scanxar: Invalid header, too short.\n"");
return VAR_26;
}
VAR_7.magic = be32_to_host(VAR_7.magic);
if (VAR_7.magic == VAR_27) {
cli_dbgmsg(""cli_scanxar: Matched magic\n"");
}
else {
cli_dbgmsg(""cli_scanxar: Invalid magic\n"");
return VAR_26;
}
VAR_7.size = be16_to_host(VAR_7.size);
VAR_7.version = be16_to_host(VAR_7.version);
VAR_7.toc_length_compressed = be64_to_host(VAR_7.toc_length_compressed);
VAR_7.toc_length_decompressed = be64_to_host(VAR_7.toc_length_decompressed);
VAR_7.chksum_alg = be32_to_host(VAR_7.chksum_alg);
VAR_14.next_in = (unsigned char *)fmap_need_off_once(*VAR_0->fmap, VAR_7.size, VAR_7.toc_length_compressed);
if (VAR_14.next_in == NULL) {
cli_dbgmsg(""cli_scanxar: fmap_need_off_once fails on TOC.\n"");
return VAR_28;
}
VAR_14.avail_in = VAR_7.toc_length_compressed; 
VAR_15 = cli_malloc(VAR_7.toc_length_decompressed+1);
if (VAR_15 == NULL) {
cli_dbgmsg(""cli_scanxar: cli_malloc fails on TOC decompress buffer.\n"");
return VAR_29;
}
VAR_15[VAR_7.toc_length_decompressed] = '\0';
VAR_14.avail_out = VAR_7.toc_length_decompressed;
VAR_14.next_out = (unsigned char *)VAR_15;
VAR_1 = inflateInit(&VAR_14);
if (VAR_1 != VAR_30) {
cli_dbgmsg(""cli_scanxar:inflateInit error %i \n"", VAR_1);
VAR_1 = VAR_26;
goto exit_toc;
}    
VAR_1 = inflate(&VAR_14, VAR_31);
if (VAR_1 != VAR_30 && VAR_1 != VAR_32) {
cli_dbgmsg(""cli_scanxar:inflate error %i \n"", VAR_1);
VAR_1 = VAR_26;
goto exit_toc;
}
VAR_1 = inflateEnd(&VAR_14);
if (VAR_1 != VAR_30) {
cli_dbgmsg(""cli_scanxar:inflateEnd error %i \n"", VAR_1);
VAR_1 = VAR_26;
goto exit_toc;
}
cli_dbgmsg(""cli_scanxar: scanning xar TOC xml in memory.\n""); 
VAR_1 = cli_mem_scandesc(VAR_15, VAR_7.toc_length_decompressed, VAR_0);
if (VAR_1 != VAR_2) {
if (VAR_1 != VAR_33 || !VAR_34)
goto exit_toc;        
}
if(VAR_0->engine->keeptmp) {
if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {
cli_dbgmsg(""cli_scanxar: Can't create temporary file for TOC.\n"");
goto exit_toc;
}
if (cli_writen(VAR_6, VAR_15, VAR_7.toc_length_decompressed) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error writing TOC.\n"");
VAR_1 = VAR_35;
xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
goto exit_toc;
}
VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
if (VAR_1 != VAR_2)
goto exit_toc;
}
VAR_17 = xmlReaderForMemory(VAR_15, VAR_7.toc_length_decompressed, ""noname.xml"", NULL, VAR_36);
if (VAR_17 == NULL) {
cli_dbgmsg(""cli_scanxar: xmlReaderForMemory error for TOC\n"");
goto exit_toc;
}
VAR_1 = xar_scan_subdocuments(VAR_17, VAR_0);
if (VAR_1 != VAR_2) {
cli_dbgmsg(""xar_scan_subdocuments returns %i.\n"", VAR_1);
goto exit_reader;
}
VAR_6 = -1;
VAR_16 = NULL;
while (VAR_2 == (VAR_1 = xar_get_toc_data_values(VAR_17, &VAR_9, &VAR_10, &VAR_11, &VAR_13,
&VAR_20, &VAR_18, &VAR_21, &VAR_19))) {
int VAR_37 = 1;
unsigned char * VAR_38;
void *VAR_39, *VAR_40;
void *VAR_41, *VAR_42;
char * VAR_43;
if (VAR_6 > -1 && VAR_16) {
VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
if (VAR_1 != VAR_2)
goto exit_reader;
}
VAR_12 = VAR_10 + VAR_7.toc_length_compressed + VAR_7.size;
if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {
cli_dbgmsg(""cli_scanxar: Can't generate temporary file.\n"");
goto exit_reader;
}
cli_dbgmsg(""cli_scanxar: decompress into temp file:\n%s, size %li,\n""
""from xar heap offset %li length %li\n"",
VAR_16, VAR_11, VAR_10, VAR_9);
VAR_22 = xar_hash_init(VAR_18, &VAR_39, &VAR_41);
VAR_23 = xar_hash_init(VAR_19, &VAR_40, &VAR_42);
switch (VAR_13) {
case VAR_44:
memset(&VAR_14, 0, sizeof(VAR_14));
if ((VAR_1 = inflateInit(&VAR_14)) != VAR_30) {
cli_dbgmsg(""cli_scanxar: InflateInit failed: %d\n"", VAR_1);
VAR_1 = VAR_26;
VAR_4++;
break;
}
while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {
unsigned long VAR_45;
void * VAR_46;
unsigned int VAR_47 = MIN(VAR_8->len - VAR_12, VAR_8->pgsz);
VAR_47 = MIN(VAR_9, VAR_47);
if(!(VAR_14.next_in = VAR_46 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_47))) {
cli_dbgmsg(""cli_scanxar: Can't read %u bytes @ %lu.\n"", VAR_47, (long unsigned)VAR_12);
inflateEnd(&VAR_14);
VAR_1 = VAR_28;
goto exit_tmpfile;
}
VAR_12 += VAR_47;
VAR_14.avail_in = VAR_45 = VAR_47;
do {
int VAR_48, VAR_49 = 0;
unsigned char VAR_50[VAR_51];
VAR_14.avail_out = sizeof(VAR_50);
VAR_14.next_out = VAR_50;
VAR_48 = inflate(&VAR_14, VAR_31);
if (VAR_48 != VAR_30 && VAR_48 != VAR_32 && VAR_48 != VAR_52) {
cli_dbgmsg(""cli_scanxar: inflate error %i %s.\n"", VAR_48, VAR_14.msg?VAR_14.msg:"""");
VAR_1 = VAR_26;
VAR_4++;
break;
}
VAR_47 = sizeof(VAR_50) - VAR_14.avail_out;
if (VAR_23 != NULL)
xar_hash_update(VAR_23, VAR_50, VAR_47, VAR_19);
if (cli_writen(VAR_6, VAR_50, VAR_47) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error file %s.\n"", VAR_16);
inflateEnd(&VAR_14);
VAR_1 = VAR_35;
goto exit_tmpfile;
}
VAR_49 += sizeof(VAR_50) - VAR_14.avail_out;
if (cli_checklimits(""cli_scanxar"", VAR_0, VAR_49, 0, 0) != VAR_53) {
break;
}
if (VAR_48 == VAR_32) {
break;
}
} while (VAR_14.avail_out == 0);
if (VAR_1 != VAR_2)
break;
VAR_45 -= VAR_14.avail_in;
if (VAR_22 != NULL)
xar_hash_update(VAR_22, VAR_46, VAR_45, VAR_18);
}
inflateEnd(&VAR_14);
break;
case VAR_54:
#define VAR_55 1024*1024
#define VAR_56 LZMA_PROPS_SIZE+8
#define VAR_57 CLI_LZMA_OBUF_SIZE>>2 
{
struct CLI_LZMA VAR_58;
unsigned long VAR_59 = VAR_9;
unsigned long VAR_60 = 0;
unsigned char * VAR_50 = __lzma_wrap_alloc(NULL, VAR_55);
int VAR_61;
memset(&VAR_58, 0, sizeof(VAR_58));
if (VAR_50 == NULL) {
cli_dbgmsg(""cli_scanxar: memory request for lzma decompression buffer fails.\n"");
VAR_1 = VAR_29;
goto exit_tmpfile;
}
VAR_38 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_56);
if (VAR_38 == NULL) {
char VAR_62[128];
cli_strerror(VAR_63, VAR_62, sizeof(VAR_62));
cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno:%s.\n"",
VAR_9, VAR_12, VAR_62);
VAR_1 = VAR_28;
__lzma_wrap_free(NULL, VAR_50);
goto exit_tmpfile;
}
VAR_58.next_in = VAR_38;
VAR_58.avail_in = VAR_56;
if (VAR_22 != NULL)
xar_hash_update(VAR_22, VAR_38, VAR_56, VAR_18);
VAR_61 = cli_LzmaInit(&VAR_58, 0);
if (VAR_61 != VAR_64) {
cli_dbgmsg(""cli_scanxar: cli_LzmaInit() fails: %i.\n"", VAR_61);
VAR_1 = VAR_26;
__lzma_wrap_free(NULL, VAR_50);
VAR_4++;
break;
}
VAR_12 += VAR_56;
VAR_59 -= VAR_56;
while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {
SizeT VAR_45;
SizeT VAR_65;
void * VAR_46;
unsigned long VAR_66;
VAR_58.next_out = VAR_50;
VAR_58.avail_out = VAR_55;
VAR_58.avail_in = VAR_45 = MIN(VAR_57, VAR_59);
VAR_58.next_in = VAR_46 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_58.avail_in);
if (VAR_58.next_in == NULL) {
char VAR_62[128];
cli_strerror(VAR_63, VAR_62, sizeof(VAR_62));
cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno: %s.\n"",
VAR_9, VAR_12, VAR_62);
VAR_1 = VAR_28;
__lzma_wrap_free(NULL, VAR_50);
cli_LzmaShutdown(&VAR_58);
goto exit_tmpfile;
}
VAR_61 = cli_LzmaDecode(&VAR_58);
if (VAR_61 != VAR_64 && VAR_61 != VAR_67) {
cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() fails: %i.\n"", VAR_61);
VAR_1 = VAR_26;
VAR_4++;
break;
}
VAR_66 = VAR_45 - VAR_58.avail_in;
VAR_59 -= VAR_66;
VAR_12 += VAR_66;
VAR_65 = VAR_55 - VAR_58.avail_out;
if (VAR_65 == 0)
cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() produces no output for ""
""avail_in %llu, avail_out %llu.\n"",
(long long unsigned)VAR_45, (long long unsigned)VAR_65);
if (VAR_22 != NULL)
xar_hash_update(VAR_22, VAR_46, VAR_66, VAR_18);                    
if (VAR_23 != NULL)
xar_hash_update(VAR_23, VAR_50, VAR_65, VAR_19);
if (cli_writen(VAR_6, VAR_50, VAR_65) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\n"",
(long long unsigned)VAR_65);
__lzma_wrap_free(NULL, VAR_50);
cli_LzmaShutdown(&VAR_58);
VAR_1 = VAR_35;
goto exit_tmpfile;
}
VAR_60 += VAR_65;
if (cli_checklimits(""cli_scanxar"", VAR_0, VAR_60, 0, 0) != VAR_53) {
break;
}
if (VAR_61 == VAR_67)
break;
}
cli_LzmaShutdown(&VAR_58);
__lzma_wrap_free(NULL, VAR_50);
}
break; 
case VAR_68:
default:
case VAR_69:
case VAR_70:
VAR_37 = 0;
{
unsigned long VAR_71;
if (VAR_0->engine->maxfilesize)
VAR_71 = MIN((size_t)(VAR_0->engine->maxfilesize), (size_t)VAR_9);
else
VAR_71 = VAR_9;
if (!(VAR_38 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_9))) {
char VAR_62[128];
cli_strerror(VAR_63, VAR_62, sizeof(VAR_62));
cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno:%s.\n"",
VAR_9, VAR_12, VAR_62);
VAR_1 = VAR_28;
goto exit_tmpfile;
}
if (VAR_22 != NULL)
xar_hash_update(VAR_22, VAR_38, VAR_9, VAR_18);
if (cli_writen(VAR_6, VAR_38, VAR_71) < 0) {
cli_dbgmsg(""cli_scanxar: cli_writen error %li bytes @ %li.\n"", VAR_9, VAR_12);
VAR_1 = VAR_35;
goto exit_tmpfile;
}
}          
}
if (VAR_1 == VAR_2) {
if (VAR_22 != NULL) {
xar_hash_final(VAR_22, VAR_24, VAR_18);
VAR_22 = NULL;
} else {
cli_dbgmsg(""cli_scanxar: archived-checksum missing.\n"");
VAR_3++;
}
if (VAR_20 != NULL) {
VAR_43 = cli_hex2str((char *)VAR_20);
if (xar_hash_check(VAR_18, VAR_24, VAR_43) != 0) {
cli_dbgmsg(""cli_scanxar: archived-checksum mismatch.\n"");
VAR_3++;
} else {
cli_dbgmsg(""cli_scanxar: archived-checksum matched.\n"");                
}
free(VAR_43);
}
if (VAR_23 != NULL) {
xar_hash_final(VAR_23, VAR_24, VAR_19);
VAR_23 = NULL;
} else {
cli_dbgmsg(""cli_scanxar: extracted-checksum(unarchived-checksum) missing.\n"");
VAR_3++;
}
if (VAR_21 != NULL) {
if (VAR_37) {
VAR_43 = cli_hex2str((char *)VAR_21);
if (xar_hash_check(VAR_19, VAR_24, VAR_43) != 0) {
cli_dbgmsg(""cli_scanxar: extracted-checksum mismatch.\n"");
VAR_3++;
} else {
cli_dbgmsg(""cli_scanxar: extracted-checksum matched.\n"");                
}
free(VAR_43);
}
}
VAR_1 = cli_magic_scandesc(VAR_6, VAR_0);
if (VAR_1 != VAR_2) {
if (VAR_1 == VAR_33) {
cli_dbgmsg(""cli_scanxar: Infected with %s\n"", cli_get_last_virus(VAR_0));
if (!VAR_34)
goto exit_tmpfile;
} else if (VAR_1 != VAR_72) {
cli_dbgmsg(""cli_scanxar: cli_magic_scandesc error %i\n"", VAR_1);
goto exit_tmpfile;
}
}
}
if (VAR_20 != NULL) {
xmlFree(VAR_20);
VAR_20 = NULL;
}
if (VAR_21 != NULL) {
xmlFree(VAR_21);
VAR_21 = NULL;
}
}
exit_tmpfile:
xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
if (VAR_22 != NULL)
xar_hash_final(VAR_22, VAR_24, VAR_18);
if (VAR_23 != NULL)
xar_hash_final(VAR_23, VAR_24, VAR_19);
exit_reader:
if (VAR_20 != NULL)
xmlFree(VAR_20);   
if (VAR_21 != NULL)
xmlFree(VAR_21);
xmlTextReaderClose(VAR_17);
xmlFreeTextReader(VAR_17);
exit_toc:
free(VAR_15);
if (VAR_1 == VAR_72)
VAR_1 = VAR_2;
#else
cli_dbgmsg(""cli_scanxar: can't scan xar files, need libxml2.\n"");
#endif
if (VAR_3 + VAR_4 != 0) {
cli_warnmsg(""cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\n"",
VAR_3, VAR_4);
}
return VAR_1;
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/before/0.json,"int cli_scanxar(cli_ctx *ctx)
{
    int rc = CL_SUCCESS;
    unsigned int cksum_fails = 0;
    unsigned int extract_errors = 0;
#if HAVE_LIBXML2
    int fd = -1;
    struct xar_header hdr;
    fmap_t *map = *ctx->fmap;
    size_t length, offset, size, at;
    int encoding;
    z_stream strm;
    char *toc, *tmpname;
    xmlTextReaderPtr reader = NULL;
    int a_hash, e_hash;
    unsigned char *a_cksum = NULL, *e_cksum = NULL;
    void *a_hash_ctx = NULL, *e_hash_ctx = NULL;
    char result[SHA1_HASH_SIZE];

    memset(&strm, 0x00, sizeof(z_stream));

    /* retrieve xar header */
    if (fmap_readn(*ctx->fmap, &hdr, 0, sizeof(hdr)) != sizeof(hdr)) {
        cli_dbgmsg(""cli_scanxar: Invalid header, too short.\n"");
        return CL_EFORMAT;
    }
    hdr.magic = be32_to_host(hdr.magic);

    if (hdr.magic == XAR_HEADER_MAGIC) {
        cli_dbgmsg(""cli_scanxar: Matched magic\n"");
    }
    else {
        cli_dbgmsg(""cli_scanxar: Invalid magic\n"");
        return CL_EFORMAT;
    }
    hdr.size = be16_to_host(hdr.size);
    hdr.version = be16_to_host(hdr.version);
    hdr.toc_length_compressed = be64_to_host(hdr.toc_length_compressed);
    hdr.toc_length_decompressed = be64_to_host(hdr.toc_length_decompressed);
    hdr.chksum_alg = be32_to_host(hdr.chksum_alg);

    /* cli_dbgmsg(""hdr.magic %x\n"", hdr.magic); */
    /* cli_dbgmsg(""hdr.size %i\n"", hdr.size); */
    /* cli_dbgmsg(""hdr.version %i\n"", hdr.version); */
    /* cli_dbgmsg(""hdr.toc_length_compressed %lu\n"", hdr.toc_length_compressed); */
    /* cli_dbgmsg(""hdr.toc_length_decompressed %lu\n"", hdr.toc_length_decompressed); */
    /* cli_dbgmsg(""hdr.chksum_alg %i\n"", hdr.chksum_alg); */
 
    /* Uncompress TOC */
    strm.next_in = (unsigned char *)fmap_need_off_once(*ctx->fmap, hdr.size, hdr.toc_length_compressed);
    if (strm.next_in == NULL) {
        cli_dbgmsg(""cli_scanxar: fmap_need_off_once fails on TOC.\n"");
        return CL_EREAD;
    }
    strm.avail_in = hdr.toc_length_compressed; 
    toc = cli_malloc(hdr.toc_length_decompressed+1);
    if (toc == NULL) {
        cli_dbgmsg(""cli_scanxar: cli_malloc fails on TOC decompress buffer.\n"");
        return CL_EMEM;
    }
    toc[hdr.toc_length_decompressed] = '\0';
    strm.avail_out = hdr.toc_length_decompressed;
    strm.next_out = (unsigned char *)toc;
    rc = inflateInit(&strm);
    if (rc != Z_OK) {
        cli_dbgmsg(""cli_scanxar:inflateInit error %i \n"", rc);
        rc = CL_EFORMAT;
        goto exit_toc;
    }    
    rc = inflate(&strm, Z_SYNC_FLUSH);
    if (rc != Z_OK && rc != Z_STREAM_END) {
        cli_dbgmsg(""cli_scanxar:inflate error %i \n"", rc);
        rc = CL_EFORMAT;
        goto exit_toc;
    }
    rc = inflateEnd(&strm);
    if (rc != Z_OK) {
        cli_dbgmsg(""cli_scanxar:inflateEnd error %i \n"", rc);
        rc = CL_EFORMAT;
        goto exit_toc;
    }

    if (hdr.toc_length_decompressed != strm.total_out) {
        cli_dbgmsg(""TOC decompress length %"" PRIu64 "" does not match amount decompressed %lu\n"",
                   hdr.toc_length_decompressed, strm.total_out);
        toc[strm.total_out] = '\0';
        hdr.toc_length_decompressed = strm.total_out;
    }

    /* cli_dbgmsg(""cli_scanxar: TOC xml:\n%s\n"", toc); */
    /* printf(""cli_scanxar: TOC xml:\n%s\n"", toc); */
    /* cli_dbgmsg(""cli_scanxar: TOC end:\n""); */
    /* printf(""cli_scanxar: TOC end:\n""); */

    /* scan the xml */
    cli_dbgmsg(""cli_scanxar: scanning xar TOC xml in memory.\n""); 
    rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);
    if (rc != CL_SUCCESS) {
        if (rc != CL_VIRUS || !SCAN_ALL)
            goto exit_toc;        
    }

    /* make a file to leave if --leave-temps in effect */
    if(ctx->engine->keeptmp) {
        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {
            cli_dbgmsg(""cli_scanxar: Can't create temporary file for TOC.\n"");
            goto exit_toc;
        }
        if (cli_writen(fd, toc, hdr.toc_length_decompressed) < 0) {
            cli_dbgmsg(""cli_scanxar: cli_writen error writing TOC.\n"");
            rc = CL_EWRITE;
            xar_cleanup_temp_file(ctx, fd, tmpname);
            goto exit_toc;
        }
        rc = xar_cleanup_temp_file(ctx, fd, tmpname);
        if (rc != CL_SUCCESS)
            goto exit_toc;
    }

    reader = xmlReaderForMemory(toc, hdr.toc_length_decompressed, ""noname.xml"", NULL, CLAMAV_MIN_XMLREADER_FLAGS);
    if (reader == NULL) {
        cli_dbgmsg(""cli_scanxar: xmlReaderForMemory error for TOC\n"");
        goto exit_toc;
    }

    rc = xar_scan_subdocuments(reader, ctx);
    if (rc != CL_SUCCESS) {
        cli_dbgmsg(""xar_scan_subdocuments returns %i.\n"", rc);
        goto exit_reader;
    }

    /* Walk the TOC XML and extract files */
    fd = -1;
    tmpname = NULL;
    while (CL_SUCCESS == (rc = xar_get_toc_data_values(reader, &length, &offset, &size, &encoding,
                                                       &a_cksum, &a_hash, &e_cksum, &e_hash))) {
        int do_extract_cksum = 1;
        unsigned char * blockp;
        void *a_sc, *e_sc;
        void *a_mc, *e_mc;
        char * expected;

        /* clean up temp file from previous loop iteration */
        if (fd > -1 && tmpname) {
            rc = xar_cleanup_temp_file(ctx, fd, tmpname);
            if (rc != CL_SUCCESS)
                goto exit_reader;
        }

        at = offset + hdr.toc_length_compressed + hdr.size;

        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {
            cli_dbgmsg(""cli_scanxar: Can't generate temporary file.\n"");
            goto exit_reader;
        }

        cli_dbgmsg(""cli_scanxar: decompress into temp file:\n%s, size %zu,\n""
                   ""from xar heap offset %zu length %zu\n"",
                   tmpname, size, offset, length);


        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);
        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);

        switch (encoding) {
        case CL_TYPE_GZ:
            /* inflate gzip directly because file segments do not contain magic */
            memset(&strm, 0, sizeof(strm));
            if ((rc = inflateInit(&strm)) != Z_OK) {
                cli_dbgmsg(""cli_scanxar: InflateInit failed: %d\n"", rc);
                rc = CL_EFORMAT;
                extract_errors++;
                break;
            }
            
            while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {
                unsigned long avail_in;
                void * next_in;
                unsigned int bytes = MIN(map->len - at, map->pgsz);
                bytes = MIN(length, bytes);
                if(!(strm.next_in = next_in = (void*)fmap_need_off_once(map, at, bytes))) {
                    cli_dbgmsg(""cli_scanxar: Can't read %u bytes @ %lu.\n"", bytes, (long unsigned)at);
                    inflateEnd(&strm);
                    rc = CL_EREAD;
                    goto exit_tmpfile;
                }
                at += bytes;
                strm.avail_in = avail_in = bytes;
                do {
                    int inf, outsize = 0;
                    unsigned char buff[FILEBUFF];
                    strm.avail_out = sizeof(buff);
                    strm.next_out = buff;
                    inf = inflate(&strm, Z_SYNC_FLUSH);
                    if (inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR) {
                        cli_dbgmsg(""cli_scanxar: inflate error %i %s.\n"", inf, strm.msg?strm.msg:"""");
                        rc = CL_EFORMAT;
                        extract_errors++;
                        break;
                    }

                    bytes = sizeof(buff) - strm.avail_out;

                    if (e_hash_ctx != NULL)
                        xar_hash_update(e_hash_ctx, buff, bytes, e_hash);
                   
                    if (cli_writen(fd, buff, bytes) < 0) {
                        cli_dbgmsg(""cli_scanxar: cli_writen error file %s.\n"", tmpname);
                        inflateEnd(&strm);
                        rc = CL_EWRITE;
                        goto exit_tmpfile;
                    }
                    outsize += sizeof(buff) - strm.avail_out;
                    if (cli_checklimits(""cli_scanxar"", ctx, outsize, 0, 0) != CL_CLEAN) {
                        break;
                    }
                    if (inf == Z_STREAM_END) {
                        break;
                    }
                } while (strm.avail_out == 0);

                if (rc != CL_SUCCESS)
                    break;

                avail_in -= strm.avail_in;
                if (a_hash_ctx != NULL)
                    xar_hash_update(a_hash_ctx, next_in, avail_in, a_hash);
            }

            inflateEnd(&strm);
            break;
        case CL_TYPE_7Z:
#define CLI_LZMA_OBUF_SIZE 1024*1024
#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8
#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */
            {
                struct CLI_LZMA lz;
                unsigned long in_remaining = MIN(length, map->len - at);
                unsigned long out_size = 0;
                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);
                int lret;

                if (length > in_remaining)
                    length = in_remaining;

                memset(&lz, 0, sizeof(lz));
                if (buff == NULL) {
                    cli_dbgmsg(""cli_scanxar: memory request for lzma decompression buffer fails.\n"");
                    rc = CL_EMEM;
                    goto exit_tmpfile;
                    
                }

                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);
                if (blockp == NULL) {
                    char errbuff[128];
                    cli_strerror(errno, errbuff, sizeof(errbuff));
                    cli_dbgmsg(""cli_scanxar: Can't read %i bytes @ %li, errno:%s.\n"",
                               CLI_LZMA_HDR_SIZE, at, errbuff);
                    rc = CL_EREAD;
                    __lzma_wrap_free(NULL, buff);
                    goto exit_tmpfile;
                }

                lz.next_in = blockp;
                lz.avail_in = CLI_LZMA_HDR_SIZE;

                if (a_hash_ctx != NULL)
                    xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);

                lret = cli_LzmaInit(&lz, 0);
                if (lret != LZMA_RESULT_OK) {
                    cli_dbgmsg(""cli_scanxar: cli_LzmaInit() fails: %i.\n"", lret);
                    rc = CL_EFORMAT;
                    __lzma_wrap_free(NULL, buff);
                    extract_errors++;
                    break;
                }

                at += CLI_LZMA_HDR_SIZE;
                in_remaining -= CLI_LZMA_HDR_SIZE;
                while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {
                    SizeT avail_in;
                    SizeT avail_out;
                    void * next_in;
                    unsigned long in_consumed;

                    lz.next_out = buff;
                    lz.avail_out = CLI_LZMA_OBUF_SIZE;
                    lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);
                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);
                    if (lz.next_in == NULL) {
                        char errbuff[128];
                        cli_strerror(errno, errbuff, sizeof(errbuff));
                        cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno: %s.\n"",
                                   lz.avail_in, at, errbuff);
                        rc = CL_EREAD;
                        __lzma_wrap_free(NULL, buff);
                        cli_LzmaShutdown(&lz);
                        goto exit_tmpfile;
                    }

                    lret = cli_LzmaDecode(&lz);
                    if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {
                        cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() fails: %i.\n"", lret);
                        rc = CL_EFORMAT;
                        extract_errors++;
                        break;
                    }

                    in_consumed = avail_in - lz.avail_in;
                    in_remaining -= in_consumed;
                    at += in_consumed;
                    avail_out = CLI_LZMA_OBUF_SIZE - lz.avail_out;
                    
                    if (avail_out == 0)
                        cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() produces no output for ""
                                   ""avail_in %llu, avail_out %llu.\n"",
                                   (long long unsigned)avail_in, (long long unsigned)avail_out);

                    if (a_hash_ctx != NULL)
                        xar_hash_update(a_hash_ctx, next_in, in_consumed, a_hash);                    
                    if (e_hash_ctx != NULL)
                        xar_hash_update(e_hash_ctx, buff, avail_out, e_hash);

                    /* Write a decompressed block. */
                    /* cli_dbgmsg(""Writing %li bytes to LZMA decompress temp file, "" */
                    /*            ""consumed %li of %li available compressed bytes.\n"", */
                    /*            avail_out, in_consumed, avail_in); */

                    if (cli_writen(fd, buff, avail_out) < 0) {
                        cli_dbgmsg(""cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\n"",
                                   (long long unsigned)avail_out);
                        __lzma_wrap_free(NULL, buff);
                        cli_LzmaShutdown(&lz);
                        rc = CL_EWRITE;
                        goto exit_tmpfile;
                    }

                    /* Check file size limitation. */
                    out_size += avail_out;
                    if (cli_checklimits(""cli_scanxar"", ctx, out_size, 0, 0) != CL_CLEAN) {
                        break;
                    }

                    if (lret == LZMA_STREAM_END)
                        break;
                }

                cli_LzmaShutdown(&lz);
                __lzma_wrap_free(NULL, buff);
            }
            break; 
        case CL_TYPE_ANY:
        default:
        case CL_TYPE_BZ:
        case CL_TYPE_XZ:
            /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */
            do_extract_cksum = 0;
            {
                size_t writelen = MIN(map->len - at, length);

                if (ctx->engine->maxfilesize)
                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);
                    
                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {
                    char errbuff[128];
                    cli_strerror(errno, errbuff, sizeof(errbuff));
                    cli_dbgmsg(""cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\n"",
                               writelen, at, errbuff);
                    rc = CL_EREAD;
                    goto exit_tmpfile;
                }
                
                if (a_hash_ctx != NULL)
                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);
                
                if (cli_writen(fd, blockp, writelen) < 0) {
                    cli_dbgmsg(""cli_scanxar: cli_writen error %zu bytes @ %li.\n"", writelen, at);
                    rc = CL_EWRITE;
                    goto exit_tmpfile;
                }
                /*break;*/
            }          
        } /* end of switch */

        if (rc == CL_SUCCESS) {
            if (a_hash_ctx != NULL) {
                xar_hash_final(a_hash_ctx, result, a_hash);
                a_hash_ctx = NULL;
            } else {
                cli_dbgmsg(""cli_scanxar: archived-checksum missing.\n"");
                cksum_fails++;
            }
            if (a_cksum != NULL) {
                expected = cli_hex2str((char *)a_cksum);
                if (xar_hash_check(a_hash, result, expected) != 0) {
                    cli_dbgmsg(""cli_scanxar: archived-checksum mismatch.\n"");
                    cksum_fails++;
                } else {
                    cli_dbgmsg(""cli_scanxar: archived-checksum matched.\n"");                
                }
                free(expected);
            }

            if (e_hash_ctx != NULL) {
                xar_hash_final(e_hash_ctx, result, e_hash);
                e_hash_ctx = NULL;
            } else {
                cli_dbgmsg(""cli_scanxar: extracted-checksum(unarchived-checksum) missing.\n"");
                cksum_fails++;
            }
            if (e_cksum != NULL) {
                if (do_extract_cksum) {
                    expected = cli_hex2str((char *)e_cksum);
                    if (xar_hash_check(e_hash, result, expected) != 0) {
                        cli_dbgmsg(""cli_scanxar: extracted-checksum mismatch.\n"");
                        cksum_fails++;
                    } else {
                        cli_dbgmsg(""cli_scanxar: extracted-checksum matched.\n"");                
                    }
                    free(expected);
                }
            }
        
            rc = cli_magic_scandesc(fd, ctx);
            if (rc != CL_SUCCESS) {
                if (rc == CL_VIRUS) {
                    cli_dbgmsg(""cli_scanxar: Infected with %s\n"", cli_get_last_virus(ctx));
                    if (!SCAN_ALL)
                        goto exit_tmpfile;
                } else if (rc != CL_BREAK) {
                    cli_dbgmsg(""cli_scanxar: cli_magic_scandesc error %i\n"", rc);
                    goto exit_tmpfile;
                }
            }
        }
        
        if (a_cksum != NULL) {
            xmlFree(a_cksum);
            a_cksum = NULL;
        }
        if (e_cksum != NULL) {
            xmlFree(e_cksum);
            e_cksum = NULL;
        }
    }

 exit_tmpfile:
    xar_cleanup_temp_file(ctx, fd, tmpname);
    if (a_hash_ctx != NULL)
        xar_hash_final(a_hash_ctx, result, a_hash);
    if (e_hash_ctx != NULL)
        xar_hash_final(e_hash_ctx, result, e_hash);
 
 exit_reader:
    if (a_cksum != NULL)
        xmlFree(a_cksum);   
    if (e_cksum != NULL)
        xmlFree(e_cksum);
    xmlTextReaderClose(reader);
    xmlFreeTextReader(reader);

 exit_toc:
    free(toc);
    if (rc == CL_BREAK)
        rc = CL_SUCCESS;
#else
    cli_dbgmsg(""cli_scanxar: can't scan xar files, need libxml2.\n"");
#endif
    if (cksum_fails + extract_errors != 0) {
        cli_dbgmsg(""cli_scanxar: %u checksum errors and %u extraction errors.\n"",
                    cksum_fails, extract_errors);
    }

    return rc;
}","int cli_scanxar(cli_ctx *VAR_0)
{
    int VAR_1 = VAR_2;
    unsigned int VAR_3 = 0;
    unsigned int VAR_4 = 0;
#if VAR_5
    int VAR_6 = -1;
    struct xar_header VAR_7;
    fmap_t *VAR_8 = *VAR_0->fmap;
    size_t VAR_9, VAR_10, VAR_11, VAR_12;
    int VAR_13;
    z_stream VAR_14;
    char *VAR_15, *VAR_16;
    xmlTextReaderPtr VAR_17 = NULL;
    int VAR_18, VAR_19;
    unsigned char *VAR_20 = NULL, *VAR_21 = NULL;
    void *VAR_22 = NULL, *VAR_23 = NULL;
    char VAR_24[VAR_25];

    memset(&VAR_14, 0x00, sizeof(z_stream));

    /* COMMENT_0 */
    if (fmap_readn(*VAR_0->fmap, &VAR_7, 0, sizeof(VAR_7)) != sizeof(VAR_7)) {
        cli_dbgmsg(""cli_scanxar: Invalid header, too short.\n"");
        return VAR_26;
    }
    VAR_7.magic = be32_to_host(VAR_7.magic);

    if (VAR_7.magic == VAR_27) {
        cli_dbgmsg(""cli_scanxar: Matched magic\n"");
    }
    else {
        cli_dbgmsg(""cli_scanxar: Invalid magic\n"");
        return VAR_26;
    }
    VAR_7.size = be16_to_host(VAR_7.size);
    VAR_7.version = be16_to_host(VAR_7.version);
    VAR_7.toc_length_compressed = be64_to_host(VAR_7.toc_length_compressed);
    VAR_7.toc_length_decompressed = be64_to_host(VAR_7.toc_length_decompressed);
    VAR_7.chksum_alg = be32_to_host(VAR_7.chksum_alg);

    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
 
    /* COMMENT_7 */
    VAR_14.next_in = (unsigned char *)fmap_need_off_once(*VAR_0->fmap, VAR_7.size, VAR_7.toc_length_compressed);
    if (VAR_14.next_in == NULL) {
        cli_dbgmsg(""cli_scanxar: fmap_need_off_once fails on TOC.\n"");
        return VAR_28;
    }
    VAR_14.avail_in = VAR_7.toc_length_compressed; 
    VAR_15 = cli_malloc(VAR_7.toc_length_decompressed+1);
    if (VAR_15 == NULL) {
        cli_dbgmsg(""cli_scanxar: cli_malloc fails on TOC decompress buffer.\n"");
        return VAR_29;
    }
    VAR_15[VAR_7.toc_length_decompressed] = '\0';
    VAR_14.avail_out = VAR_7.toc_length_decompressed;
    VAR_14.next_out = (unsigned char *)VAR_15;
    VAR_1 = inflateInit(&VAR_14);
    if (VAR_1 != VAR_30) {
        cli_dbgmsg(""cli_scanxar:inflateInit error %i \n"", VAR_1);
        VAR_1 = VAR_26;
        goto exit_toc;
    }    
    VAR_1 = inflate(&VAR_14, VAR_31);
    if (VAR_1 != VAR_30 && VAR_1 != VAR_32) {
        cli_dbgmsg(""cli_scanxar:inflate error %i \n"", VAR_1);
        VAR_1 = VAR_26;
        goto exit_toc;
    }
    VAR_1 = inflateEnd(&VAR_14);
    if (VAR_1 != VAR_30) {
        cli_dbgmsg(""cli_scanxar:inflateEnd error %i \n"", VAR_1);
        VAR_1 = VAR_26;
        goto exit_toc;
    }

    if (VAR_7.toc_length_decompressed != VAR_14.total_out) {
        cli_dbgmsg(""TOC decompress length %"" VAR_33 "" does not match amount decompressed %lu\n"",
                   VAR_7.toc_length_decompressed, VAR_14.total_out);
        VAR_15[VAR_14.total_out] = '\0';
        VAR_7.toc_length_decompressed = VAR_14.total_out;
    }

    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_11 */

    /* COMMENT_12 */
    cli_dbgmsg(""cli_scanxar: scanning xar TOC xml in memory.\n""); 
    VAR_1 = cli_mem_scandesc(VAR_15, VAR_7.toc_length_decompressed, VAR_0);
    if (VAR_1 != VAR_2) {
        if (VAR_1 != VAR_34 || !VAR_35)
            goto exit_toc;        
    }

    /* COMMENT_13 */
    if(VAR_0->engine->keeptmp) {
        if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {
            cli_dbgmsg(""cli_scanxar: Can't create temporary file for TOC.\n"");
            goto exit_toc;
        }
        if (cli_writen(VAR_6, VAR_15, VAR_7.toc_length_decompressed) < 0) {
            cli_dbgmsg(""cli_scanxar: cli_writen error writing TOC.\n"");
            VAR_1 = VAR_36;
            xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
            goto exit_toc;
        }
        VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
        if (VAR_1 != VAR_2)
            goto exit_toc;
    }

    VAR_17 = xmlReaderForMemory(VAR_15, VAR_7.toc_length_decompressed, ""noname.xml"", NULL, VAR_37);
    if (VAR_17 == NULL) {
        cli_dbgmsg(""cli_scanxar: xmlReaderForMemory error for TOC\n"");
        goto exit_toc;
    }

    VAR_1 = xar_scan_subdocuments(VAR_17, VAR_0);
    if (VAR_1 != VAR_2) {
        cli_dbgmsg(""xar_scan_subdocuments returns %i.\n"", VAR_1);
        goto exit_reader;
    }

    /* COMMENT_14 */
    VAR_6 = -1;
    VAR_16 = NULL;
    while (VAR_2 == (VAR_1 = xar_get_toc_data_values(VAR_17, &VAR_9, &VAR_10, &VAR_11, &VAR_13,
                                                       &VAR_20, &VAR_18, &VAR_21, &VAR_19))) {
        int VAR_38 = 1;
        unsigned char * VAR_39;
        void *VAR_40, *VAR_41;
        void *VAR_42, *VAR_43;
        char * VAR_44;

        /* COMMENT_15 */
        if (VAR_6 > -1 && VAR_16) {
            VAR_1 = xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
            if (VAR_1 != VAR_2)
                goto exit_reader;
        }

        VAR_12 = VAR_10 + VAR_7.toc_length_compressed + VAR_7.size;

        if ((VAR_1 = cli_gentempfd(VAR_0->engine->tmpdir, &VAR_16, &VAR_6)) != VAR_2) {
            cli_dbgmsg(""cli_scanxar: Can't generate temporary file.\n"");
            goto exit_reader;
        }

        cli_dbgmsg(""cli_scanxar: decompress into temp file:\n%s, size %zu,\n""
                   ""from xar heap offset %zu length %zu\n"",
                   VAR_16, VAR_11, VAR_10, VAR_9);


        VAR_22 = xar_hash_init(VAR_18, &VAR_40, &VAR_42);
        VAR_23 = xar_hash_init(VAR_19, &VAR_41, &VAR_43);

        switch (VAR_13) {
        case VAR_45:
            /* COMMENT_16 */
            memset(&VAR_14, 0, sizeof(VAR_14));
            if ((VAR_1 = inflateInit(&VAR_14)) != VAR_30) {
                cli_dbgmsg(""cli_scanxar: InflateInit failed: %d\n"", VAR_1);
                VAR_1 = VAR_26;
                VAR_4++;
                break;
            }
            
            while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {
                unsigned long VAR_46;
                void * VAR_47;
                unsigned int VAR_48 = MIN(VAR_8->len - VAR_12, VAR_8->pgsz);
                VAR_48 = MIN(VAR_9, VAR_48);
                if(!(VAR_14.next_in = VAR_47 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_48))) {
                    cli_dbgmsg(""cli_scanxar: Can't read %u bytes @ %lu.\n"", VAR_48, (long unsigned)VAR_12);
                    inflateEnd(&VAR_14);
                    VAR_1 = VAR_28;
                    goto exit_tmpfile;
                }
                VAR_12 += VAR_48;
                VAR_14.avail_in = VAR_46 = VAR_48;
                do {
                    int VAR_49, VAR_50 = 0;
                    unsigned char VAR_51[VAR_52];
                    VAR_14.avail_out = sizeof(VAR_51);
                    VAR_14.next_out = VAR_51;
                    VAR_49 = inflate(&VAR_14, VAR_31);
                    if (VAR_49 != VAR_30 && VAR_49 != VAR_32 && VAR_49 != VAR_53) {
                        cli_dbgmsg(""cli_scanxar: inflate error %i %s.\n"", VAR_49, VAR_14.msg?VAR_14.msg:"""");
                        VAR_1 = VAR_26;
                        VAR_4++;
                        break;
                    }

                    VAR_48 = sizeof(VAR_51) - VAR_14.avail_out;

                    if (VAR_23 != NULL)
                        xar_hash_update(VAR_23, VAR_51, VAR_48, VAR_19);
                   
                    if (cli_writen(VAR_6, VAR_51, VAR_48) < 0) {
                        cli_dbgmsg(""cli_scanxar: cli_writen error file %s.\n"", VAR_16);
                        inflateEnd(&VAR_14);
                        VAR_1 = VAR_36;
                        goto exit_tmpfile;
                    }
                    VAR_50 += sizeof(VAR_51) - VAR_14.avail_out;
                    if (cli_checklimits(""cli_scanxar"", VAR_0, VAR_50, 0, 0) != VAR_54) {
                        break;
                    }
                    if (VAR_49 == VAR_32) {
                        break;
                    }
                } while (VAR_14.avail_out == 0);

                if (VAR_1 != VAR_2)
                    break;

                VAR_46 -= VAR_14.avail_in;
                if (VAR_22 != NULL)
                    xar_hash_update(VAR_22, VAR_47, VAR_46, VAR_18);
            }

            inflateEnd(&VAR_14);
            break;
        case VAR_55:
#define VAR_56 1024*1024
#define VAR_57 LZMA_PROPS_SIZE+8
#define VAR_58 CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */
            {
                struct CLI_LZMA VAR_59;
                unsigned long VAR_60 = MIN(VAR_9, VAR_8->len - VAR_12);
                unsigned long VAR_61 = 0;
                unsigned char * VAR_51 = __lzma_wrap_alloc(NULL, VAR_56);
                int VAR_62;

                if (VAR_9 > VAR_60)
                    VAR_9 = VAR_60;

                memset(&VAR_59, 0, sizeof(VAR_59));
                if (VAR_51 == NULL) {
                    cli_dbgmsg(""cli_scanxar: memory request for lzma decompression buffer fails.\n"");
                    VAR_1 = VAR_29;
                    goto exit_tmpfile;
                    
                }

                VAR_39 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_57);
                if (VAR_39 == NULL) {
                    char VAR_63[128];
                    cli_strerror(VAR_64, VAR_63, sizeof(VAR_63));
                    cli_dbgmsg(""cli_scanxar: Can't read %i bytes @ %li, errno:%s.\n"",
                               VAR_57, VAR_12, VAR_63);
                    VAR_1 = VAR_28;
                    __lzma_wrap_free(NULL, VAR_51);
                    goto exit_tmpfile;
                }

                VAR_59.next_in = VAR_39;
                VAR_59.avail_in = VAR_57;

                if (VAR_22 != NULL)
                    xar_hash_update(VAR_22, VAR_39, VAR_57, VAR_18);

                VAR_62 = cli_LzmaInit(&VAR_59, 0);
                if (VAR_62 != VAR_65) {
                    cli_dbgmsg(""cli_scanxar: cli_LzmaInit() fails: %i.\n"", VAR_62);
                    VAR_1 = VAR_26;
                    __lzma_wrap_free(NULL, VAR_51);
                    VAR_4++;
                    break;
                }

                VAR_12 += VAR_57;
                VAR_60 -= VAR_57;
                while ((size_t)VAR_12 < VAR_8->len && (unsigned long)VAR_12 < VAR_10+VAR_7.toc_length_compressed+VAR_7.size+VAR_9) {
                    SizeT VAR_46;
                    SizeT VAR_66;
                    void * VAR_47;
                    unsigned long VAR_67;

                    VAR_59.next_out = VAR_51;
                    VAR_59.avail_out = VAR_56;
                    VAR_59.avail_in = VAR_46 = MIN(VAR_58, VAR_60);
                    VAR_59.next_in = VAR_47 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_59.avail_in);
                    if (VAR_59.next_in == NULL) {
                        char VAR_63[128];
                        cli_strerror(VAR_64, VAR_63, sizeof(VAR_63));
                        cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno: %s.\n"",
                                   VAR_59.avail_in, VAR_12, VAR_63);
                        VAR_1 = VAR_28;
                        __lzma_wrap_free(NULL, VAR_51);
                        cli_LzmaShutdown(&VAR_59);
                        goto exit_tmpfile;
                    }

                    VAR_62 = cli_LzmaDecode(&VAR_59);
                    if (VAR_62 != VAR_65 && VAR_62 != VAR_68) {
                        cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() fails: %i.\n"", VAR_62);
                        VAR_1 = VAR_26;
                        VAR_4++;
                        break;
                    }

                    VAR_67 = VAR_46 - VAR_59.avail_in;
                    VAR_60 -= VAR_67;
                    VAR_12 += VAR_67;
                    VAR_66 = VAR_56 - VAR_59.avail_out;
                    
                    if (VAR_66 == 0)
                        cli_dbgmsg(""cli_scanxar: cli_LzmaDecode() produces no output for ""
                                   ""avail_in %llu, avail_out %llu.\n"",
                                   (long long unsigned)VAR_46, (long long unsigned)VAR_66);

                    if (VAR_22 != NULL)
                        xar_hash_update(VAR_22, VAR_47, VAR_67, VAR_18);                    
                    if (VAR_23 != NULL)
                        xar_hash_update(VAR_23, VAR_51, VAR_66, VAR_19);

                    /* COMMENT_17 */
                    /* COMMENT_18 */
                    /* COMMENT_19 */
                    /* COMMENT_20 */

                    if (cli_writen(VAR_6, VAR_51, VAR_66) < 0) {
                        cli_dbgmsg(""cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\n"",
                                   (long long unsigned)VAR_66);
                        __lzma_wrap_free(NULL, VAR_51);
                        cli_LzmaShutdown(&VAR_59);
                        VAR_1 = VAR_36;
                        goto exit_tmpfile;
                    }

                    /* COMMENT_21 */
                    VAR_61 += VAR_66;
                    if (cli_checklimits(""cli_scanxar"", VAR_0, VAR_61, 0, 0) != VAR_54) {
                        break;
                    }

                    if (VAR_62 == VAR_68)
                        break;
                }

                cli_LzmaShutdown(&VAR_59);
                __lzma_wrap_free(NULL, VAR_51);
            }
            break; 
        case VAR_69:
        default:
        case VAR_70:
        case VAR_71:
            /* COMMENT_22 */
            VAR_38 = 0;
            {
                size_t VAR_72 = MIN(VAR_8->len - VAR_12, VAR_9);

                if (VAR_0->engine->maxfilesize)
                    VAR_72 = MIN((size_t)(VAR_0->engine->maxfilesize), VAR_72);
                    
                if (!(VAR_39 = (void*)fmap_need_off_once(VAR_8, VAR_12, VAR_72))) {
                    char VAR_63[128];
                    cli_strerror(VAR_64, VAR_63, sizeof(VAR_63));
                    cli_dbgmsg(""cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\n"",
                               VAR_72, VAR_12, VAR_63);
                    VAR_1 = VAR_28;
                    goto exit_tmpfile;
                }
                
                if (VAR_22 != NULL)
                    xar_hash_update(VAR_22, VAR_39, VAR_72, VAR_18);
                
                if (cli_writen(VAR_6, VAR_39, VAR_72) < 0) {
                    cli_dbgmsg(""cli_scanxar: cli_writen error %zu bytes @ %li.\n"", VAR_72, VAR_12);
                    VAR_1 = VAR_36;
                    goto exit_tmpfile;
                }
                /* COMMENT_23 */
            }          
        } /* COMMENT_24 */

        if (VAR_1 == VAR_2) {
            if (VAR_22 != NULL) {
                xar_hash_final(VAR_22, VAR_24, VAR_18);
                VAR_22 = NULL;
            } else {
                cli_dbgmsg(""cli_scanxar: archived-checksum missing.\n"");
                VAR_3++;
            }
            if (VAR_20 != NULL) {
                VAR_44 = cli_hex2str((char *)VAR_20);
                if (xar_hash_check(VAR_18, VAR_24, VAR_44) != 0) {
                    cli_dbgmsg(""cli_scanxar: archived-checksum mismatch.\n"");
                    VAR_3++;
                } else {
                    cli_dbgmsg(""cli_scanxar: archived-checksum matched.\n"");                
                }
                free(VAR_44);
            }

            if (VAR_23 != NULL) {
                xar_hash_final(VAR_23, VAR_24, VAR_19);
                VAR_23 = NULL;
            } else {
                cli_dbgmsg(""cli_scanxar: extracted-checksum(unarchived-checksum) missing.\n"");
                VAR_3++;
            }
            if (VAR_21 != NULL) {
                if (VAR_38) {
                    VAR_44 = cli_hex2str((char *)VAR_21);
                    if (xar_hash_check(VAR_19, VAR_24, VAR_44) != 0) {
                        cli_dbgmsg(""cli_scanxar: extracted-checksum mismatch.\n"");
                        VAR_3++;
                    } else {
                        cli_dbgmsg(""cli_scanxar: extracted-checksum matched.\n"");                
                    }
                    free(VAR_44);
                }
            }
        
            VAR_1 = cli_magic_scandesc(VAR_6, VAR_0);
            if (VAR_1 != VAR_2) {
                if (VAR_1 == VAR_34) {
                    cli_dbgmsg(""cli_scanxar: Infected with %s\n"", cli_get_last_virus(VAR_0));
                    if (!VAR_35)
                        goto exit_tmpfile;
                } else if (VAR_1 != VAR_73) {
                    cli_dbgmsg(""cli_scanxar: cli_magic_scandesc error %i\n"", VAR_1);
                    goto exit_tmpfile;
                }
            }
        }
        
        if (VAR_20 != NULL) {
            xmlFree(VAR_20);
            VAR_20 = NULL;
        }
        if (VAR_21 != NULL) {
            xmlFree(VAR_21);
            VAR_21 = NULL;
        }
    }

 exit_tmpfile:
    xar_cleanup_temp_file(VAR_0, VAR_6, VAR_16);
    if (VAR_22 != NULL)
        xar_hash_final(VAR_22, VAR_24, VAR_18);
    if (VAR_23 != NULL)
        xar_hash_final(VAR_23, VAR_24, VAR_19);
 
 exit_reader:
    if (VAR_20 != NULL)
        xmlFree(VAR_20);   
    if (VAR_21 != NULL)
        xmlFree(VAR_21);
    xmlTextReaderClose(VAR_17);
    xmlFreeTextReader(VAR_17);

 exit_toc:
    free(VAR_15);
    if (VAR_1 == VAR_73)
        VAR_1 = VAR_2;
#else
    cli_dbgmsg(""cli_scanxar: can't scan xar files, need libxml2.\n"");
#endif
    if (VAR_3 + VAR_4 != 0) {
        cli_dbgmsg(""cli_scanxar: %u checksum errors and %u extraction errors.\n"",
                    VAR_3, VAR_4);
    }

    return VAR_1;
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
     int fd = -1;
     struct xar_header hdr;
     fmap_t *map = *ctx->fmap;
-    long length, offset, size, at;
+    size_t length, offset, size, at;
     int encoding;
     z_stream strm;
     char *toc, *tmpname;
@@ -80,6 +80,13 @@
         goto exit_toc;
     }
 
+    if (hdr.toc_length_decompressed != strm.total_out) {
+        cli_dbgmsg(""TOC decompress length %"" PRIu64 "" does not match amount decompressed %lu\n"",
+                   hdr.toc_length_decompressed, strm.total_out);
+        toc[strm.total_out] = '\0';
+        hdr.toc_length_decompressed = strm.total_out;
+    }
+
     /* cli_dbgmsg(""cli_scanxar: TOC xml:\n%s\n"", toc); */
     /* printf(""cli_scanxar: TOC xml:\n%s\n"", toc); */
     /* cli_dbgmsg(""cli_scanxar: TOC end:\n""); */
@@ -147,8 +154,8 @@
             goto exit_reader;
         }
 
-        cli_dbgmsg(""cli_scanxar: decompress into temp file:\n%s, size %li,\n""
-                   ""from xar heap offset %li length %li\n"",
+        cli_dbgmsg(""cli_scanxar: decompress into temp file:\n%s, size %zu,\n""
+                   ""from xar heap offset %zu length %zu\n"",
                    tmpname, size, offset, length);
 
 
@@ -228,11 +235,14 @@
 #define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */
             {
                 struct CLI_LZMA lz;
-                unsigned long in_remaining = length;
+                unsigned long in_remaining = MIN(length, map->len - at);
                 unsigned long out_size = 0;
                 unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);
                 int lret;
-                
+
+                if (length > in_remaining)
+                    length = in_remaining;
+
                 memset(&lz, 0, sizeof(lz));
                 if (buff == NULL) {
                     cli_dbgmsg(""cli_scanxar: memory request for lzma decompression buffer fails.\n"");
@@ -245,8 +255,8 @@
                 if (blockp == NULL) {
                     char errbuff[128];
                     cli_strerror(errno, errbuff, sizeof(errbuff));
-                    cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno:%s.\n"",
-                               length, at, errbuff);
+                    cli_dbgmsg(""cli_scanxar: Can't read %i bytes @ %li, errno:%s.\n"",
+                               CLI_LZMA_HDR_SIZE, at, errbuff);
                     rc = CL_EREAD;
                     __lzma_wrap_free(NULL, buff);
                     goto exit_tmpfile;
@@ -283,7 +293,7 @@
                         char errbuff[128];
                         cli_strerror(errno, errbuff, sizeof(errbuff));
                         cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno: %s.\n"",
-                                   length, at, errbuff);
+                                   lz.avail_in, at, errbuff);
                         rc = CL_EREAD;
                         __lzma_wrap_free(NULL, buff);
                         cli_LzmaShutdown(&lz);
@@ -348,33 +358,31 @@
             /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */
             do_extract_cksum = 0;
             {
-                unsigned long write_len;
-                
+                size_t writelen = MIN(map->len - at, length);
+
                 if (ctx->engine->maxfilesize)
-                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);
-                else
-                    write_len = length;
+                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);
                     
-                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {
+                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {
                     char errbuff[128];
                     cli_strerror(errno, errbuff, sizeof(errbuff));
-                    cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno:%s.\n"",
-                               length, at, errbuff);
+                    cli_dbgmsg(""cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\n"",
+                               writelen, at, errbuff);
                     rc = CL_EREAD;
                     goto exit_tmpfile;
                 }
                 
                 if (a_hash_ctx != NULL)
-                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);
+                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);
                 
-                if (cli_writen(fd, blockp, write_len) < 0) {
-                    cli_dbgmsg(""cli_scanxar: cli_writen error %li bytes @ %li.\n"", length, at);
+                if (cli_writen(fd, blockp, writelen) < 0) {
+                    cli_dbgmsg(""cli_scanxar: cli_writen error %zu bytes @ %li.\n"", writelen, at);
                     rc = CL_EWRITE;
                     goto exit_tmpfile;
                 }
                 /*break;*/
             }          
-        }
+        } /* end of switch */
 
         if (rc == CL_SUCCESS) {
             if (a_hash_ctx != NULL) {
@@ -461,7 +469,7 @@
     cli_dbgmsg(""cli_scanxar: can't scan xar files, need libxml2.\n"");
 #endif
     if (cksum_fails + extract_errors != 0) {
-        cli_warnmsg(""cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\n"",
+        cli_dbgmsg(""cli_scanxar: %u checksum errors and %u extraction errors.\n"",
                     cksum_fails, extract_errors);
     }
 ","{'deleted_lines': ['    long length, offset, size, at;', '        cli_dbgmsg(""cli_scanxar: decompress into temp file:\\n%s, size %li,\\n""', '                   ""from xar heap offset %li length %li\\n"",', '                unsigned long in_remaining = length;', '                ', '                    cli_dbgmsg(""cli_scanxar: Can\'t read %li bytes @ %li, errno:%s.\\n"",', '                               length, at, errbuff);', '                                   length, at, errbuff);', '                unsigned long write_len;', '                ', '                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);', '                else', '                    write_len = length;', '                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {', '                    cli_dbgmsg(""cli_scanxar: Can\'t read %li bytes @ %li, errno:%s.\\n"",', '                               length, at, errbuff);', '                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);', '                if (cli_writen(fd, blockp, write_len) < 0) {', '                    cli_dbgmsg(""cli_scanxar: cli_writen error %li bytes @ %li.\\n"", length, at);', '        }', '        cli_warnmsg(""cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n"",'], 'added_lines': ['    size_t length, offset, size, at;', '    if (hdr.toc_length_decompressed != strm.total_out) {', '        cli_dbgmsg(""TOC decompress length %"" PRIu64 "" does not match amount decompressed %lu\\n"",', '                   hdr.toc_length_decompressed, strm.total_out);', ""        toc[strm.total_out] = '\\0';"", '        hdr.toc_length_decompressed = strm.total_out;', '    }', '', '        cli_dbgmsg(""cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n""', '                   ""from xar heap offset %zu length %zu\\n"",', '                unsigned long in_remaining = MIN(length, map->len - at);', '', '                if (length > in_remaining)', '                    length = in_remaining;', '', '                    cli_dbgmsg(""cli_scanxar: Can\'t read %i bytes @ %li, errno:%s.\\n"",', '                               CLI_LZMA_HDR_SIZE, at, errbuff);', '                                   lz.avail_in, at, errbuff);', '                size_t writelen = MIN(map->len - at, length);', '', '                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);', '                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {', '                    cli_dbgmsg(""cli_scanxar: Can\'t read %zu bytes @ %zu, errno:%s.\\n"",', '                               writelen, at, errbuff);', '                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);', '                if (cli_writen(fd, blockp, writelen) < 0) {', '                    cli_dbgmsg(""cli_scanxar: cli_writen error %zu bytes @ %li.\\n"", writelen, at);', '        } /* end of switch */', '        cli_dbgmsg(""cli_scanxar: %u checksum errors and %u extraction errors.\\n"",']}",True,"ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6.",5.5,MEDIUM,1,valid,2016-06-21T21:22:52Z,1
CVE-2018-1000085,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Cisco-Talos/clamav,bb11588 - fix out of bounds read.,d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,https://github.com/Cisco-Talos/clamav/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,libclamav/xar.c,xar_get_numeric_from_xml_element,"static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)
{
const xmlChar * numstr;
if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
numstr = xmlTextReaderConstValue(reader);
if (numstr) {
*value = atol((const char *)numstr);
if (*value < 0) {
cli_dbgmsg(""cli_scanxar: XML element value %li\n"", *value);
return CL_EFORMAT;
}
return CL_SUCCESS;
}
}
cli_dbgmsg(""cli_scanxar: No text for XML element\n"");
return CL_EFORMAT;
}","static int xar_get_numeric_from_xml_element(xmlTextReaderPtr VAR_0, long * VAR_1)
{
const xmlChar * VAR_2;
if (xmlTextReaderRead(VAR_0) == 1 && xmlTextReaderNodeType(VAR_0) == VAR_3) {
VAR_2 = xmlTextReaderConstValue(VAR_0);
if (VAR_2) {
*VAR_1 = atol((const char *)VAR_2);
if (*VAR_1 < 0) {
cli_dbgmsg(""cli_scanxar: XML element value %li\n"", *VAR_1);
return VAR_4;
}
return VAR_5;
}
}
cli_dbgmsg(""cli_scanxar: No text for XML element\n"");
return VAR_4;
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/before/4.json,"static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, size_t * value)
{
    const xmlChar * numstr;
    ssize_t numval;

    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
        numstr = xmlTextReaderConstValue(reader);
        if (numstr) {
            numval = atol((const char *)numstr);
            if (numval < 0) {
                cli_dbgmsg(""cli_scanxar: XML element value %li\n"", *value);
                return CL_EFORMAT;
            }
            *value = numval;
            return CL_SUCCESS;
        }
    }
    cli_dbgmsg(""cli_scanxar: No text for XML element\n"");
    return CL_EFORMAT;
}","static int xar_get_numeric_from_xml_element(xmlTextReaderPtr VAR_0, size_t * VAR_1)
{
    const xmlChar * VAR_2;
    ssize_t VAR_3;

    if (xmlTextReaderRead(VAR_0) == 1 && xmlTextReaderNodeType(VAR_0) == VAR_4) {
        VAR_2 = xmlTextReaderConstValue(VAR_0);
        if (VAR_2) {
            VAR_3 = atol((const char *)VAR_2);
            if (VAR_3 < 0) {
                cli_dbgmsg(""cli_scanxar: XML element value %li\n"", *VAR_1);
                return VAR_5;
            }
            *VAR_1 = VAR_3;
            return VAR_6;
        }
    }
    cli_dbgmsg(""cli_scanxar: No text for XML element\n"");
    return VAR_5;
}",Cisco-Talos/clamav/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6/xar.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,14 +1,17 @@
-static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)
+static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, size_t * value)
 {
     const xmlChar * numstr;
+    ssize_t numval;
+
     if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
         numstr = xmlTextReaderConstValue(reader);
         if (numstr) {
-            *value = atol((const char *)numstr);
-            if (*value < 0) {
+            numval = atol((const char *)numstr);
+            if (numval < 0) {
                 cli_dbgmsg(""cli_scanxar: XML element value %li\n"", *value);
                 return CL_EFORMAT;
             }
+            *value = numval;
             return CL_SUCCESS;
         }
     }","{'deleted_lines': ['static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)', '            *value = atol((const char *)numstr);', '            if (*value < 0) {'], 'added_lines': ['static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, size_t * value)', '    ssize_t numval;', '', '            numval = atol((const char *)numstr);', '            if (numval < 0) {', '            *value = numval;']}",True,"ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6.",5.5,MEDIUM,1,valid,2016-06-21T21:22:52Z,1
CVE-2016-5426,['CWE-399'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,PowerDNS/pdns,"Reject qname's wirelength > 255, `chopOff()` handle dot inside labels",881b5b03a590198d03008e4200dd00cc537712f3,https://github.com/PowerDNS/pdns/commit/881b5b03a590198d03008e4200dd00cc537712f3,pdns/dnsparser.cc,PacketReader::getLabelFromContent,"void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) 
{
if(recurs > 100)     throw MOADNSException(""Loop"");
int pos = frompos;
for(;;) {
unsigned char labellen=content.at(frompos++);
if(!labellen) {
if(ret.empty())
ret.append(1,'.');
break;
}
else if((labellen & 0xc0) == 0xc0) {
uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);
if(offset >= pos)
throw MOADNSException(""forward reference during label decompression"");
return getLabelFromContent(content, offset, ret, ++recurs);
}
else if(labellen > 63) 
throw MOADNSException(""Overly long label during label decompression (""+lexical_cast<string>((unsigned int)labellen)+"")"");
else {
for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {
if(content.at(frompos)=='.' || content.at(frompos)=='\\') {
ret.append(1, '\\');
ret.append(1, content[frompos]);
}
else if(content.at(frompos)==' ') {
ret+=""\\032"";
}
else 
ret.append(1, content[frompos]);
}
ret.append(1,'.');
}
if (ret.length() > 1024)
throw MOADNSException(""Total name too long"");
}
}","void PacketReader::getLabelFromContent(const vector<uint8_t>& VAR_0, uint16_t& VAR_1, string& VAR_2, int VAR_3) 
{
if(VAR_3 > 100) 
throw MOADNSException(""Loop"");
int VAR_4 = VAR_1;
for(;;) {
unsigned char VAR_5=VAR_0.at(VAR_1++);
if(!VAR_5) {
if(VAR_2.empty())
VAR_2.append(1,'.');
break;
}
else if((VAR_5 & 0xc0) == 0xc0) {
uint16_t VAR_6=256*(VAR_5 & ~0xc0) + (unsigned int)VAR_0.at(VAR_1++) - sizeof(VAR_7);
if(VAR_6 >= VAR_4)
throw MOADNSException(""forward reference during label decompression"");
return getLabelFromContent(VAR_0, VAR_6, VAR_2, ++VAR_3);
}
else if(VAR_5 > 63) 
throw MOADNSException(""Overly long label during label decompression (""+VAR_8<string>((unsigned int)VAR_5)+"")"");
else {
for(string::size_type VAR_9 = 0 ; VAR_9 < VAR_5; ++VAR_9, VAR_1++) {
if(VAR_0.at(VAR_1)=='.' || VAR_0.at(VAR_1)=='\\') {
VAR_2.append(1, '\\');
VAR_2.append(1, VAR_0[VAR_1]);
}
else if(VAR_0.at(VAR_1)==' ') {
VAR_2+=""\\032"";
}
else 
VAR_2.append(1, VAR_0[VAR_1]);
}
VAR_2.append(1,'.');
}
if (VAR_2.length() > 1024)
throw MOADNSException(""Total name too long"");
}
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/dnsparser.cc/vul/before/1.json,"void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs, size_t& wirelength)
{
  if(recurs > 100) // the forward reference-check below should make this test 100% obsolete
    throw MOADNSException(""Loop"");

  int pos = frompos;
  // it is tempting to call reserve on ret, but it turns out it creates a malloc/free storm in the loop
  for(;;) {
    unsigned char labellen=content.at(frompos++);
    wirelength++;
    if (wirelength > 255) {
      throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");
    }

    if(!labellen) {
      if(ret.empty())
              ret.append(1,'.');
      break;
    }
    else if((labellen & 0xc0) == 0xc0) {
      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);
      //        cout<<""This is an offset, need to go to: ""<<offset<<endl;

      if(offset >= pos)
        throw MOADNSException(""forward reference during label decompression"");
      /* the compression pointer does not count into the wire length */
      return getLabelFromContent(content, offset, ret, ++recurs, --wirelength);
    }
    else if(labellen > 63) 
      throw MOADNSException(""Overly long label during label decompression (""+lexical_cast<string>((unsigned int)labellen)+"")"");
    else {
      if (wirelength + labellen > 255) {
        throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");
      }
      wirelength += labellen;
      // XXX FIXME THIS MIGHT BE VERY SLOW!
      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {
        if(content.at(frompos)=='.' || content.at(frompos)=='\\') {
          ret.append(1, '\\');
          ret.append(1, content[frompos]);
        }
        else if(content.at(frompos)==' ') {
          ret+=""\\032"";
        }
        else 
          ret.append(1, content[frompos]);
      }
      ret.append(1,'.');
    }
    if (ret.length() > 1024)
      throw MOADNSException(""Total name too long"");
  }
}","void PacketReader::getLabelFromContent(const vector<uint8_t>& VAR_0, uint16_t& VAR_1, string& VAR_2, int VAR_3, size_t& VAR_4)
{
  if(VAR_3 > 100) /* COMMENT_0 */
    throw MOADNSException(""Loop"");

  int VAR_5 = VAR_1;
  /* COMMENT_1 */
  for(;;) {
    unsigned char VAR_6=VAR_0.at(VAR_1++);
    VAR_4++;
    if (VAR_4 > 255) {
      throw MOADNSException(""Overly long DNS name (""+VAR_7<string>(VAR_4)+"")"");
    }

    if(!VAR_6) {
      if(VAR_2.empty())
              VAR_2.append(1,'.');
      break;
    }
    else if((VAR_6 & 0xc0) == 0xc0) {
      uint16_t VAR_8=256*(VAR_6 & ~0xc0) + (unsigned int)VAR_0.at(VAR_1++) - sizeof(VAR_9);
      /* COMMENT_2 */

      if(VAR_8 >= VAR_5)
        throw MOADNSException(""forward reference during label decompression"");
      /* COMMENT_3 */
      return getLabelFromContent(VAR_0, VAR_8, VAR_2, ++VAR_3, --VAR_4);
    }
    else if(VAR_6 > 63) 
      throw MOADNSException(""Overly long label during label decompression (""+VAR_7<string>((unsigned int)VAR_6)+"")"");
    else {
      if (VAR_4 + VAR_6 > 255) {
        throw MOADNSException(""Overly long DNS name (""+VAR_7<string>(VAR_4)+"")"");
      }
      VAR_4 += VAR_6;
      /* COMMENT_4 */
      for(string::size_type VAR_10 = 0 ; VAR_10 < VAR_6; ++VAR_10, VAR_1++) {
        if(VAR_0.at(VAR_1)=='.' || VAR_0.at(VAR_1)=='\\') {
          VAR_2.append(1, '\\');
          VAR_2.append(1, VAR_0[VAR_1]);
        }
        else if(VAR_0.at(VAR_1)==' ') {
          VAR_2+=""\\032"";
        }
        else 
          VAR_2.append(1, VAR_0[VAR_1]);
      }
      VAR_2.append(1,'.');
    }
    if (VAR_2.length() > 1024)
      throw MOADNSException(""Total name too long"");
  }
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/dnsparser.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) 
+void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs, size_t& wirelength)
 {
   if(recurs > 100) // the forward reference-check below should make this test 100% obsolete
     throw MOADNSException(""Loop"");
@@ -7,6 +7,10 @@
   // it is tempting to call reserve on ret, but it turns out it creates a malloc/free storm in the loop
   for(;;) {
     unsigned char labellen=content.at(frompos++);
+    wirelength++;
+    if (wirelength > 255) {
+      throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");
+    }
 
     if(!labellen) {
       if(ret.empty())
@@ -19,13 +23,17 @@
 
       if(offset >= pos)
         throw MOADNSException(""forward reference during label decompression"");
-      return getLabelFromContent(content, offset, ret, ++recurs);
+      /* the compression pointer does not count into the wire length */
+      return getLabelFromContent(content, offset, ret, ++recurs, --wirelength);
     }
     else if(labellen > 63) 
       throw MOADNSException(""Overly long label during label decompression (""+lexical_cast<string>((unsigned int)labellen)+"")"");
     else {
+      if (wirelength + labellen > 255) {
+        throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");
+      }
+      wirelength += labellen;
       // XXX FIXME THIS MIGHT BE VERY SLOW!
-
       for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {
         if(content.at(frompos)=='.' || content.at(frompos)=='\\') {
           ret.append(1, '\\');","{'deleted_lines': ['void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) ', '      return getLabelFromContent(content, offset, ret, ++recurs);', ''], 'added_lines': ['void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs, size_t& wirelength)', '    wirelength++;', '    if (wirelength > 255) {', '      throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");', '    }', '      /* the compression pointer does not count into the wire length */', '      return getLabelFromContent(content, offset, ret, ++recurs, --wirelength);', '      if (wirelength + labellen > 255) {', '        throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");', '      }', '      wirelength += labellen;']}",True,PowerDNS (aka pdns) Authoritative Server before 3.4.10 allows remote attackers to cause a denial of service (backend CPU consumption) via a long qname.,7.5,HIGH,2,valid,2016-07-01T13:30:20Z,1
CVE-2016-5426,['CWE-399'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,PowerDNS/pdns,"Reject qname's wirelength > 255, `chopOff()` handle dot inside labels",881b5b03a590198d03008e4200dd00cc537712f3,https://github.com/PowerDNS/pdns/commit/881b5b03a590198d03008e4200dd00cc537712f3,pdns/misc.cc,chopOff,"bool chopOff(string &domain) 
{
if(domain.empty())
return false;
string::size_type fdot=domain.find('.');
if(fdot==string::npos) 
domain="""";
else {
string::size_type remain = domain.length() - (fdot + 1);
char tmp[remain];
memcpy(tmp, domain.c_str()+fdot+1, remain);
domain.assign(tmp, remain);   }
return true;
}","bool chopOff(string &VAR_0) 
{
if(VAR_0.empty())
return false;
string::size_type VAR_1=VAR_0.find('.');
if(VAR_1==string::npos) 
VAR_0="""";
else {
string::size_type VAR_2 = VAR_0.length() - (VAR_1 + 1);
char VAR_3[VAR_2];
memcpy(VAR_3, VAR_0.c_str()+VAR_1+1, VAR_2);
VAR_0.assign(VAR_3, VAR_2); 
}
return true;
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/misc.cc/vul/before/0.json,"bool chopOff(string &domain) 
{
  if(domain.empty())
    return false;

  bool escaped = false;
  const string::size_type domainLen = domain.length();
  for (size_t fdot = 0; fdot < domainLen; fdot++)
  {
    if (domain[fdot] == '.' && !escaped) {
      string::size_type remain = domainLen - (fdot + 1);
      char tmp[remain];
      memcpy(tmp, domain.c_str()+fdot+1, remain);
      domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)

      return true;
    }
    else if (domain[fdot] == '\\' && !escaped) {
      escaped = true;
    }
    else {
      escaped = false;
    }
  }

  domain = """";
  return true;
}","bool chopOff(string &VAR_0) 
{
  if(VAR_0.empty())
    return false;

  bool VAR_1 = false;
  const string::size_type VAR_2 = VAR_0.length();
  for (size_t VAR_3 = 0; VAR_3 < VAR_2; VAR_3++)
  {
    if (VAR_0[VAR_3] == '.' && !VAR_1) {
      string::size_type VAR_4 = VAR_2 - (VAR_3 + 1);
      char VAR_5[VAR_4];
      memcpy(VAR_5, VAR_0.c_str()+VAR_3+1, VAR_4);
      VAR_0.assign(VAR_5, VAR_4); /* COMMENT_0 */

      return true;
    }
    else if (VAR_0[VAR_3] == '\\' && !VAR_1) {
      VAR_1 = true;
    }
    else {
      VAR_1 = false;
    }
  }

  VAR_0 = """";
  return true;
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/misc.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,15 +3,26 @@
   if(domain.empty())
     return false;
 
-  string::size_type fdot=domain.find('.');
+  bool escaped = false;
+  const string::size_type domainLen = domain.length();
+  for (size_t fdot = 0; fdot < domainLen; fdot++)
+  {
+    if (domain[fdot] == '.' && !escaped) {
+      string::size_type remain = domainLen - (fdot + 1);
+      char tmp[remain];
+      memcpy(tmp, domain.c_str()+fdot+1, remain);
+      domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)
 
-  if(fdot==string::npos) 
-    domain="""";
-  else {
-    string::size_type remain = domain.length() - (fdot + 1);
-    char tmp[remain];
-    memcpy(tmp, domain.c_str()+fdot+1, remain);
-    domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)
+      return true;
+    }
+    else if (domain[fdot] == '\\' && !escaped) {
+      escaped = true;
+    }
+    else {
+      escaped = false;
+    }
   }
+
+  domain = """";
   return true;
 }","{'deleted_lines': [""  string::size_type fdot=domain.find('.');"", '  if(fdot==string::npos) ', '    domain="""";', '  else {', '    string::size_type remain = domain.length() - (fdot + 1);', '    char tmp[remain];', '    memcpy(tmp, domain.c_str()+fdot+1, remain);', ""    domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)""], 'added_lines': ['  bool escaped = false;', '  const string::size_type domainLen = domain.length();', '  for (size_t fdot = 0; fdot < domainLen; fdot++)', '  {', ""    if (domain[fdot] == '.' && !escaped) {"", '      string::size_type remain = domainLen - (fdot + 1);', '      char tmp[remain];', '      memcpy(tmp, domain.c_str()+fdot+1, remain);', ""      domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)"", '      return true;', '    }', ""    else if (domain[fdot] == '\\\\' && !escaped) {"", '      escaped = true;', '    }', '    else {', '      escaped = false;', '    }', '', '  domain = """";']}",True,PowerDNS (aka pdns) Authoritative Server before 3.4.10 allows remote attackers to cause a denial of service (backend CPU consumption) via a long qname.,7.5,HIGH,2,valid,2016-07-01T13:30:20Z,1
CVE-2016-5426,['CWE-399'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,PowerDNS/pdns,"Reject qname's wirelength > 255, `chopOff()` handle dot inside labels",881b5b03a590198d03008e4200dd00cc537712f3,https://github.com/PowerDNS/pdns/commit/881b5b03a590198d03008e4200dd00cc537712f3,pdns/dnsparser.cc,PacketReader::getLabel,"string PacketReader::getLabel(unsigned int recurs)
{
string ret;
ret.reserve(40);
getLabelFromContent(d_content, d_pos, ret, recurs++);
return ret;
}","string PacketReader::getLabel(unsigned int VAR_0)
{
string VAR_1;
VAR_1.reserve(40);
getLabelFromContent(VAR_2, VAR_3, VAR_1, VAR_0++);
return VAR_1;
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/dnsparser.cc/vul/before/0.json,"string PacketReader::getLabel(unsigned int recurs)
{
  string ret;
  size_t wirelength = 0;
  ret.reserve(40);
  getLabelFromContent(d_content, d_pos, ret, recurs++, wirelength);
  return ret;
}","string PacketReader::getLabel(unsigned int VAR_0)
{
  string VAR_1;
  size_t VAR_2 = 0;
  VAR_1.reserve(40);
  getLabelFromContent(VAR_3, VAR_4, VAR_1, VAR_0++, VAR_2);
  return VAR_1;
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/dnsparser.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,8 @@
 string PacketReader::getLabel(unsigned int recurs)
 {
   string ret;
+  size_t wirelength = 0;
   ret.reserve(40);
-  getLabelFromContent(d_content, d_pos, ret, recurs++);
+  getLabelFromContent(d_content, d_pos, ret, recurs++, wirelength);
   return ret;
 }","{'deleted_lines': ['  getLabelFromContent(d_content, d_pos, ret, recurs++);'], 'added_lines': ['  size_t wirelength = 0;', '  getLabelFromContent(d_content, d_pos, ret, recurs++, wirelength);']}",True,PowerDNS (aka pdns) Authoritative Server before 3.4.10 allows remote attackers to cause a denial of service (backend CPU consumption) via a long qname.,7.5,HIGH,2,valid,2016-07-01T13:30:20Z,1
CVE-2016-5426,['CWE-399'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,PowerDNS/pdns,"Reject qname's wirelength > 255, `chopOff()` handle dot inside labels",881b5b03a590198d03008e4200dd00cc537712f3,https://github.com/PowerDNS/pdns/commit/881b5b03a590198d03008e4200dd00cc537712f3,pdns/misc.cc,chopOffDotted,"bool chopOffDotted(string &domain)
{
if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
return false;
string::size_type fdot=domain.find('.');
if(fdot == string::npos)
return false;
if(fdot==domain.size()-1) 
domain=""."";
else  {
string::size_type remain = domain.length() - (fdot + 1);
char tmp[remain];
memcpy(tmp, domain.c_str()+fdot+1, remain);
domain.assign(tmp, remain);
}
return true;
}","bool chopOffDotted(string &VAR_0)
{
if(VAR_0.empty() || (VAR_0.size()==1 && VAR_0[0]=='.'))
return false;
string::size_type VAR_1=VAR_0.find('.');
if(VAR_1 == string::npos)
return false;
if(VAR_1==VAR_0.size()-1) 
VAR_0=""."";
else  {
string::size_type VAR_2 = VAR_0.length() - (VAR_1 + 1);
char VAR_3[VAR_2];
memcpy(VAR_3, VAR_0.c_str()+VAR_1+1, VAR_2);
VAR_0.assign(VAR_3, VAR_2);
}
return true;
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/misc.cc/vul/before/1.json,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;

  bool escaped = false;
  const string::size_type domainLen = domain.length();
  for (size_t fdot = 0; fdot < domainLen; fdot++)
  {
    if (domain[fdot] == '.' && !escaped) {
      if (fdot==domain.size()-1) {
        domain=""."";
      }
      else {
        string::size_type remain = domainLen - (fdot + 1);
        char tmp[remain];
        memcpy(tmp, domain.c_str()+fdot+1, remain);
        domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)
      }
      return true;
    }
    else if (domain[fdot] == '\\' && !escaped) {
      escaped = true;
    }
    else {
      escaped = false;
    }
  }

  return false;
}","bool chopOffDotted(string &VAR_0)
{
  if(VAR_0.empty() || (VAR_0.size()==1 && VAR_0[0]=='.'))
    return false;

  bool VAR_1 = false;
  const string::size_type VAR_2 = VAR_0.length();
  for (size_t VAR_3 = 0; VAR_3 < VAR_2; VAR_3++)
  {
    if (VAR_0[VAR_3] == '.' && !VAR_1) {
      if (VAR_3==VAR_0.size()-1) {
        VAR_0=""."";
      }
      else {
        string::size_type VAR_4 = VAR_2 - (VAR_3 + 1);
        char VAR_5[VAR_4];
        memcpy(VAR_5, VAR_0.c_str()+VAR_3+1, VAR_4);
        VAR_0.assign(VAR_5, VAR_4); /* COMMENT_0 */
      }
      return true;
    }
    else if (VAR_0[VAR_3] == '\\' && !VAR_1) {
      VAR_1 = true;
    }
    else {
      VAR_1 = false;
    }
  }

  return false;
}",PowerDNS/pdns/881b5b03a590198d03008e4200dd00cc537712f3/misc.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,17 +3,29 @@
   if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
     return false;
 
-  string::size_type fdot=domain.find('.');
-  if(fdot == string::npos)
-    return false;
+  bool escaped = false;
+  const string::size_type domainLen = domain.length();
+  for (size_t fdot = 0; fdot < domainLen; fdot++)
+  {
+    if (domain[fdot] == '.' && !escaped) {
+      if (fdot==domain.size()-1) {
+        domain=""."";
+      }
+      else {
+        string::size_type remain = domainLen - (fdot + 1);
+        char tmp[remain];
+        memcpy(tmp, domain.c_str()+fdot+1, remain);
+        domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)
+      }
+      return true;
+    }
+    else if (domain[fdot] == '\\' && !escaped) {
+      escaped = true;
+    }
+    else {
+      escaped = false;
+    }
+  }
 
-  if(fdot==domain.size()-1) 
-    domain=""."";
-  else  {
-    string::size_type remain = domain.length() - (fdot + 1);
-    char tmp[remain];
-    memcpy(tmp, domain.c_str()+fdot+1, remain);
-    domain.assign(tmp, remain);
-  }
-  return true;
+  return false;
 }","{'deleted_lines': [""  string::size_type fdot=domain.find('.');"", '  if(fdot == string::npos)', '    return false;', '  if(fdot==domain.size()-1) ', '    domain=""."";', '  else  {', '    string::size_type remain = domain.length() - (fdot + 1);', '    char tmp[remain];', '    memcpy(tmp, domain.c_str()+fdot+1, remain);', '    domain.assign(tmp, remain);', '  }', '  return true;'], 'added_lines': ['  bool escaped = false;', '  const string::size_type domainLen = domain.length();', '  for (size_t fdot = 0; fdot < domainLen; fdot++)', '  {', ""    if (domain[fdot] == '.' && !escaped) {"", '      if (fdot==domain.size()-1) {', '        domain=""."";', '      }', '      else {', '        string::size_type remain = domainLen - (fdot + 1);', '        char tmp[remain];', '        memcpy(tmp, domain.c_str()+fdot+1, remain);', ""        domain.assign(tmp, remain); // don't dare to do this w/o tmp holder :-)"", '      }', '      return true;', '    }', ""    else if (domain[fdot] == '\\\\' && !escaped) {"", '      escaped = true;', '    }', '    else {', '      escaped = false;', '    }', '  }', '  return false;']}",True,PowerDNS (aka pdns) Authoritative Server before 3.4.10 allows remote attackers to cause a denial of service (backend CPU consumption) via a long qname.,7.5,HIGH,2,valid,2016-07-01T13:30:20Z,1
CVE-2016-6187,"['CWE-119', 'CWE-264']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"apparmor: fix oops, validate buffer size in apparmor_setprocattr()

When proc_pid_attr_write() was changed to use memdup_user apparmor's
(interface violating) assumption that the setprocattr buffer was always
a single page was violated.

The size test is not strictly speaking needed as proc_pid_attr_write()
will reject anything larger, but for the sake of robustness we can keep
it in.

SMACK and SELinux look safe to me, but somebody else should probably
have a look just in case.

Based on original patch from Vegard Nossum <vegard.nossum@oracle.com>
modified for the case that apparmor provides null termination.

Fixes: bb646cdb12e75d82258c2f2e7746d5952d3e321a
Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: John Johansen <john.johansen@canonical.com>
Cc: Paul Moore <paul@paul-moore.com>
Cc: Stephen Smalley <sds@tycho.nsa.gov>
Cc: Eric Paris <eparis@parisplace.org>
Cc: Casey Schaufler <casey@schaufler-ca.com>
Cc: stable@kernel.org
Signed-off-by: John Johansen <john.johansen@canonical.com>
Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
Signed-off-by: James Morris <james.l.morris@oracle.com>",30a46a4647fd1df9cf52e43bf467f0d9265096ca,https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca,security/apparmor/lsm.c,apparmor_setprocattr,"static int apparmor_setprocattr(struct task_struct *task, char *name,
void *value, size_t size)
{
struct common_audit_data sa;
struct apparmor_audit_data aad = {0,};
char *command, *args = value;
size_t arg_size;
int error;
if (size == 0)
return -EINVAL;
if (args[size - 1] != '\0') {
if (size == PAGE_SIZE)
return -EINVAL;
args[size] = '\0';
}
if (current != task)
return -EACCES;
args = value;
args = strim(args);
command = strsep(&args, "" "");
if (!args)
return -EINVAL;
args = skip_spaces(args);
if (!*args)
return -EINVAL;
arg_size = size - (args - (char *) value);
if (strcmp(name, ""current"") == 0) {
if (strcmp(command, ""changehat"") == 0) {
error = aa_setprocattr_changehat(args, arg_size,
!AA_DO_TEST);
} else if (strcmp(command, ""permhat"") == 0) {
error = aa_setprocattr_changehat(args, arg_size,
AA_DO_TEST);
} else if (strcmp(command, ""changeprofile"") == 0) {
error = aa_setprocattr_changeprofile(args, !AA_ONEXEC,
!AA_DO_TEST);
} else if (strcmp(command, ""permprofile"") == 0) {
error = aa_setprocattr_changeprofile(args, !AA_ONEXEC,
AA_DO_TEST);
} else
goto fail;
} else if (strcmp(name, ""exec"") == 0) {
if (strcmp(command, ""exec"") == 0)
error = aa_setprocattr_changeprofile(args, AA_ONEXEC,
!AA_DO_TEST);
else
goto fail;
} else
return -EINVAL;
if (!error)
error = size;
return error;
fail:
sa.type = LSM_AUDIT_DATA_NONE;
sa.aad = &aad;
aad.profile = aa_current_profile();
aad.op = OP_SETPROCATTR;
aad.info = name;
aad.error = -EINVAL;
aa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);
return -EINVAL;
}","static int apparmor_setprocattr(struct task_struct *VAR_0, char *VAR_1,
void *VAR_2, size_t VAR_3)
{
struct common_audit_data VAR_4;
struct apparmor_audit_data VAR_5 = {0,};
char *VAR_6, *VAR_7 = VAR_2;
size_t VAR_8;
int VAR_9;
if (VAR_3 == 0)
return -VAR_10;
if (VAR_7[VAR_3 - 1] != '\0') {
if (VAR_3 == VAR_11)
return -VAR_10;
VAR_7[VAR_3] = '\0';
}
if (VAR_12 != VAR_0)
return -VAR_13;
VAR_7 = VAR_2;
VAR_7 = strim(VAR_7);
VAR_6 = strsep(&VAR_7, "" "");
if (!VAR_7)
return -VAR_10;
VAR_7 = skip_spaces(VAR_7);
if (!*VAR_7)
return -VAR_10;
VAR_8 = VAR_3 - (VAR_7 - (char *) VAR_2);
if (strcmp(VAR_1, ""current"") == 0) {
if (strcmp(VAR_6, ""changehat"") == 0) {
VAR_9 = aa_setprocattr_changehat(VAR_7, VAR_8,
!VAR_14);
} else if (strcmp(VAR_6, ""permhat"") == 0) {
VAR_9 = aa_setprocattr_changehat(VAR_7, VAR_8,
VAR_14);
} else if (strcmp(VAR_6, ""changeprofile"") == 0) {
VAR_9 = aa_setprocattr_changeprofile(VAR_7, !VAR_15,
!VAR_14);
} else if (strcmp(VAR_6, ""permprofile"") == 0) {
VAR_9 = aa_setprocattr_changeprofile(VAR_7, !VAR_15,
VAR_14);
} else
goto fail;
} else if (strcmp(VAR_1, ""exec"") == 0) {
if (strcmp(VAR_6, ""exec"") == 0)
VAR_9 = aa_setprocattr_changeprofile(VAR_7, VAR_15,
!VAR_14);
else
goto fail;
} else
return -VAR_10;
if (!VAR_9)
VAR_9 = VAR_3;
return VAR_9;
fail:
VAR_4.type = VAR_16;
VAR_4.aad = &VAR_5;
VAR_5.profile = aa_current_profile();
VAR_5.op = VAR_17;
VAR_5.info = VAR_1;
VAR_5.error = -VAR_10;
aa_audit_msg(VAR_18, &VAR_4, NULL);
return -VAR_10;
}",torvalds/linux/30a46a4647fd1df9cf52e43bf467f0d9265096ca/lsm.c/vul/before/0.json,"static int apparmor_setprocattr(struct task_struct *task, char *name,
				void *value, size_t size)
{
	struct common_audit_data sa;
	struct apparmor_audit_data aad = {0,};
	char *command, *largs = NULL, *args = value;
	size_t arg_size;
	int error;

	if (size == 0)
		return -EINVAL;
	/* task can only write its own attributes */
	if (current != task)
		return -EACCES;

	/* AppArmor requires that the buffer must be null terminated atm */
	if (args[size - 1] != '\0') {
		/* null terminate */
		largs = args = kmalloc(size + 1, GFP_KERNEL);
		if (!args)
			return -ENOMEM;
		memcpy(args, value, size);
		args[size] = '\0';
	}

	error = -EINVAL;
	args = strim(args);
	command = strsep(&args, "" "");
	if (!args)
		goto out;
	args = skip_spaces(args);
	if (!*args)
		goto out;

	arg_size = size - (args - (char *) value);
	if (strcmp(name, ""current"") == 0) {
		if (strcmp(command, ""changehat"") == 0) {
			error = aa_setprocattr_changehat(args, arg_size,
							 !AA_DO_TEST);
		} else if (strcmp(command, ""permhat"") == 0) {
			error = aa_setprocattr_changehat(args, arg_size,
							 AA_DO_TEST);
		} else if (strcmp(command, ""changeprofile"") == 0) {
			error = aa_setprocattr_changeprofile(args, !AA_ONEXEC,
							     !AA_DO_TEST);
		} else if (strcmp(command, ""permprofile"") == 0) {
			error = aa_setprocattr_changeprofile(args, !AA_ONEXEC,
							     AA_DO_TEST);
		} else
			goto fail;
	} else if (strcmp(name, ""exec"") == 0) {
		if (strcmp(command, ""exec"") == 0)
			error = aa_setprocattr_changeprofile(args, AA_ONEXEC,
							     !AA_DO_TEST);
		else
			goto fail;
	} else
		/* only support the ""current"" and ""exec"" process attributes */
		goto fail;

	if (!error)
		error = size;
out:
	kfree(largs);
	return error;

fail:
	sa.type = LSM_AUDIT_DATA_NONE;
	sa.aad = &aad;
	aad.profile = aa_current_profile();
	aad.op = OP_SETPROCATTR;
	aad.info = name;
	aad.error = error = -EINVAL;
	aa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);
	goto out;
}","static int apparmor_setprocattr(struct task_struct *VAR_0, char *VAR_1,
				void *VAR_2, size_t VAR_3)
{
	struct common_audit_data VAR_4;
	struct apparmor_audit_data VAR_5 = {0,};
	char *VAR_6, *VAR_7 = NULL, *VAR_8 = VAR_2;
	size_t VAR_9;
	int VAR_10;

	if (VAR_3 == 0)
		return -VAR_11;
	/* COMMENT_0 */
	if (VAR_12 != VAR_0)
		return -VAR_13;

	/* COMMENT_1 */
	if (VAR_8[VAR_3 - 1] != '\0') {
		/* COMMENT_2 */
		VAR_7 = VAR_8 = kmalloc(VAR_3 + 1, VAR_14);
		if (!VAR_8)
			return -VAR_15;
		memcpy(VAR_8, VAR_2, VAR_3);
		VAR_8[VAR_3] = '\0';
	}

	VAR_10 = -VAR_11;
	VAR_8 = strim(VAR_8);
	VAR_6 = strsep(&VAR_8, "" "");
	if (!VAR_8)
		goto out;
	VAR_8 = skip_spaces(VAR_8);
	if (!*VAR_8)
		goto out;

	VAR_9 = VAR_3 - (VAR_8 - (char *) VAR_2);
	if (strcmp(VAR_1, ""current"") == 0) {
		if (strcmp(VAR_6, ""changehat"") == 0) {
			VAR_10 = aa_setprocattr_changehat(VAR_8, VAR_9,
							 !VAR_16);
		} else if (strcmp(VAR_6, ""permhat"") == 0) {
			VAR_10 = aa_setprocattr_changehat(VAR_8, VAR_9,
							 VAR_16);
		} else if (strcmp(VAR_6, ""changeprofile"") == 0) {
			VAR_10 = aa_setprocattr_changeprofile(VAR_8, !VAR_17,
							     !VAR_16);
		} else if (strcmp(VAR_6, ""permprofile"") == 0) {
			VAR_10 = aa_setprocattr_changeprofile(VAR_8, !VAR_17,
							     VAR_16);
		} else
			goto fail;
	} else if (strcmp(VAR_1, ""exec"") == 0) {
		if (strcmp(VAR_6, ""exec"") == 0)
			VAR_10 = aa_setprocattr_changeprofile(VAR_8, VAR_17,
							     !VAR_16);
		else
			goto fail;
	} else
		/* COMMENT_3 */
		goto fail;

	if (!VAR_10)
		VAR_10 = VAR_3;
out:
	kfree(VAR_7);
	return VAR_10;

fail:
	VAR_4.type = VAR_18;
	VAR_4.aad = &VAR_5;
	VAR_5.profile = aa_current_profile();
	VAR_5.op = VAR_19;
	VAR_5.info = VAR_1;
	VAR_5.error = VAR_10 = -VAR_11;
	aa_audit_msg(VAR_20, &VAR_4, NULL);
	goto out;
}",torvalds/linux/30a46a4647fd1df9cf52e43bf467f0d9265096ca/lsm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,34 +3,34 @@
 {
 	struct common_audit_data sa;
 	struct apparmor_audit_data aad = {0,};
-	char *command, *args = value;
+	char *command, *largs = NULL, *args = value;
 	size_t arg_size;
 	int error;
 
 	if (size == 0)
 		return -EINVAL;
-	/* args points to a PAGE_SIZE buffer, AppArmor requires that
-	 * the buffer must be null terminated or have size <= PAGE_SIZE -1
-	 * so that AppArmor can null terminate them
-	 */
-	if (args[size - 1] != '\0') {
-		if (size == PAGE_SIZE)
-			return -EINVAL;
-		args[size] = '\0';
-	}
-
 	/* task can only write its own attributes */
 	if (current != task)
 		return -EACCES;
 
-	args = value;
+	/* AppArmor requires that the buffer must be null terminated atm */
+	if (args[size - 1] != '\0') {
+		/* null terminate */
+		largs = args = kmalloc(size + 1, GFP_KERNEL);
+		if (!args)
+			return -ENOMEM;
+		memcpy(args, value, size);
+		args[size] = '\0';
+	}
+
+	error = -EINVAL;
 	args = strim(args);
 	command = strsep(&args, "" "");
 	if (!args)
-		return -EINVAL;
+		goto out;
 	args = skip_spaces(args);
 	if (!*args)
-		return -EINVAL;
+		goto out;
 
 	arg_size = size - (args - (char *) value);
 	if (strcmp(name, ""current"") == 0) {
@@ -56,10 +56,12 @@
 			goto fail;
 	} else
 		/* only support the ""current"" and ""exec"" process attributes */
-		return -EINVAL;
+		goto fail;
 
 	if (!error)
 		error = size;
+out:
+	kfree(largs);
 	return error;
 
 fail:
@@ -68,7 +70,7 @@
 	aad.profile = aa_current_profile();
 	aad.op = OP_SETPROCATTR;
 	aad.info = name;
-	aad.error = -EINVAL;
+	aad.error = error = -EINVAL;
 	aa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);
-	return -EINVAL;
+	goto out;
 }","{'deleted_lines': ['\tchar *command, *args = value;', '\t/* args points to a PAGE_SIZE buffer, AppArmor requires that', '\t * the buffer must be null terminated or have size <= PAGE_SIZE -1', '\t * so that AppArmor can null terminate them', '\t */', ""\tif (args[size - 1] != '\\0') {"", '\t\tif (size == PAGE_SIZE)', '\t\t\treturn -EINVAL;', ""\t\targs[size] = '\\0';"", '\t}', '', '\targs = value;', '\t\treturn -EINVAL;', '\t\treturn -EINVAL;', '\t\treturn -EINVAL;', '\taad.error = -EINVAL;', '\treturn -EINVAL;'], 'added_lines': ['\tchar *command, *largs = NULL, *args = value;', '\t/* AppArmor requires that the buffer must be null terminated atm */', ""\tif (args[size - 1] != '\\0') {"", '\t\t/* null terminate */', '\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);', '\t\tif (!args)', '\t\t\treturn -ENOMEM;', '\t\tmemcpy(args, value, size);', ""\t\targs[size] = '\\0';"", '\t}', '', '\terror = -EINVAL;', '\t\tgoto out;', '\t\tgoto out;', '\t\tgoto fail;', 'out:', '\tkfree(largs);', '\taad.error = error = -EINVAL;', '\tgoto out;']}",True,"The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 4.6.5 does not validate the buffer size, which allows local users to gain privileges by triggering an AppArmor setprocattr hook.",7.8,HIGH,2,valid,2016-07-07T20:41:11Z,1
CVE-2016-2180,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"Fix OOB read in TS_OBJ_print_bio().

TS_OBJ_print_bio() misuses OBJ_txt2obj: it should print the result
as a null terminated buffer. The length value returned is the total
length the complete text reprsentation would need not the amount of
data written.

CVE-2016-2180

Thanks to Shi Lei for reporting this bug.

Reviewed-by: Matt Caswell <matt@openssl.org>",0ed26acce328ec16a3aa635f1ca37365e8c7403a,https://github.com/openssl/openssl/commit/0ed26acce328ec16a3aa635f1ca37365e8c7403a,crypto/ts/ts_lib.c,TS_OBJ_print_bio,"int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)
{
char obj_txt[128];
int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);
BIO_write(bio, obj_txt, len);
BIO_write(bio, ""\n"", 1);
return 1;
}","int TS_OBJ_print_bio(BIO *VAR_0, const ASN1_OBJECT *VAR_1)
{
char VAR_2[128];
int VAR_3 = OBJ_obj2txt(VAR_2, sizeof(VAR_2), VAR_1, 0);
BIO_write(VAR_0, VAR_2, VAR_3);
BIO_write(VAR_0, ""\n"", 1);
return 1;
}",openssl/0ed26acce328ec16a3aa635f1ca37365e8c7403a/ts_lib.c/vul/before/0.json,"int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)
{
    char obj_txt[128];

    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);
    BIO_printf(bio, ""%s\n"", obj_txt);

    return 1;
}","int TS_OBJ_print_bio(BIO *VAR_0, const ASN1_OBJECT *VAR_1)
{
    char VAR_2[128];

    OBJ_obj2txt(VAR_2, sizeof(VAR_2), VAR_1, 0);
    BIO_printf(VAR_0, ""%s\n"", VAR_2);

    return 1;
}",openssl/0ed26acce328ec16a3aa635f1ca37365e8c7403a/ts_lib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,9 +2,8 @@
 {
     char obj_txt[128];
 
-    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);
-    BIO_write(bio, obj_txt, len);
-    BIO_write(bio, ""\n"", 1);
+    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);
+    BIO_printf(bio, ""%s\n"", obj_txt);
 
     return 1;
 }","{'deleted_lines': ['    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);', '    BIO_write(bio, obj_txt, len);', '    BIO_write(bio, ""\\n"", 1);'], 'added_lines': ['    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);', '    BIO_printf(bio, ""%s\\n"", obj_txt);']}",True,"The TS_OBJ_print_bio function in crypto/ts/ts_lib.c in the X.509 Public Key Infrastructure Time-Stamp Protocol (TSP) implementation in OpenSSL through 1.0.2h allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted time-stamp file that is mishandled by the ""openssl ts"" command.",7.5,HIGH,2,valid,2016-07-21T14:24:16Z,1
CVE-2016-6520,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,ImageMagick,Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report from Ibrahim M. El-Sayed),76401e172ea3a55182be2b8e2aca4d07270f6da6,https://github.com/ImageMagick/ImageMagick/commit/76401e172ea3a55182be2b8e2aca4d07270f6da6,MagickCore/enhance.c,EqualizeImage,"MagickExport MagickBooleanType EqualizeImage(Image *image,
ExceptionInfo *exception)
{
#define EqualizeImageTag  ""Equalize/Image""
CacheView
*image_view;
double
black[CompositePixelChannel+1],
*equalize_map,
*histogram,
*map,
white[CompositePixelChannel+1];
MagickBooleanType
status;
MagickOffsetType
progress;
register ssize_t
i;
ssize_t
y;
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
#if defined(MAGICKCORE_OPENCL_SUPPORT)
if (AccelerateEqualizeImage(image,exception) != MagickFalse)
return(MagickTrue);
#endif
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
equalize_map=(double *) AcquireQuantumMemory(MaxMap+1UL,
GetPixelChannels(image)*sizeof(*equalize_map));
histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*
sizeof(*histogram));
map=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*
sizeof(*map));
if ((equalize_map == (double *) NULL) || (histogram == (double *) NULL) ||
(map == (double *) NULL))
{
if (map != (double *) NULL)
map=(double *) RelinquishMagickMemory(map);
if (histogram != (double *) NULL)
histogram=(double *) RelinquishMagickMemory(histogram);
if (equalize_map != (double *) NULL)
equalize_map=(double *) RelinquishMagickMemory(equalize_map);
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
status=MagickTrue;
(void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
sizeof(*histogram));
image_view=AcquireVirtualCacheView(image,exception);
for (y=0; y < (ssize_t) image->rows; y++)
{
register const Quantum
*magick_restrict p;
register ssize_t
x;
if (status == MagickFalse)
continue;
p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
{
status=MagickFalse;
continue;
}
for (x=0; x < (ssize_t) image->columns; x++)
{
for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
{
double
intensity;
intensity=p[i];
if ((image->channel_mask & SyncChannels) != 0)
intensity=GetPixelIntensity(image,p);
histogram[GetPixelChannels(image)*ScaleQuantumToMap(intensity)+i]++;
}
p+=GetPixelChannels(image);
}
}
image_view=DestroyCacheView(image_view);
for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
{
double
intensity;
register ssize_t
j;
intensity=0.0;
for (j=0; j <= (ssize_t) MaxMap; j++)
{
intensity+=histogram[GetPixelChannels(image)*j+i];
map[GetPixelChannels(image)*j+i]=intensity;
}
}
(void) ResetMagickMemory(equalize_map,0,(MaxMap+1)*GetPixelChannels(image)*
sizeof(*equalize_map));
(void) ResetMagickMemory(black,0,sizeof(*black));
(void) ResetMagickMemory(white,0,sizeof(*white));
for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
{
register ssize_t
j;
black[i]=map[i];
white[i]=map[GetPixelChannels(image)*MaxMap+i];
if (black[i] != white[i])
for (j=0; j <= (ssize_t) MaxMap; j++)
equalize_map[GetPixelChannels(image)*j+i]=(double)
ScaleMapToQuantum((double) ((MaxMap*(map[
GetPixelChannels(image)*j+i]-black[i]))/(white[i]-black[i])));
}
histogram=(double *) RelinquishMagickMemory(histogram);
map=(double *) RelinquishMagickMemory(map);
if (image->storage_class == PseudoClass)
{
register ssize_t
j;
for (j=0; j < (ssize_t) image->colors; j++)
{
if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
{
PixelChannel channel=GetPixelChannelChannel(image,RedPixelChannel);
if (black[channel] != white[channel])
image->colormap[j].red=equalize_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+
channel];
}
if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
{
PixelChannel channel=GetPixelChannelChannel(image,
GreenPixelChannel);
if (black[channel] != white[channel])
image->colormap[j].green=equalize_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+
channel];
}
if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
{
PixelChannel channel=GetPixelChannelChannel(image,BluePixelChannel);
if (black[channel] != white[channel])
image->colormap[j].blue=equalize_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+
channel];
}
if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
{
PixelChannel channel=GetPixelChannelChannel(image,
AlphaPixelChannel);
if (black[channel] != white[channel])
image->colormap[j].alpha=equalize_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+
channel];
}
}
}
progress=0;
image_view=AcquireAuthenticCacheView(image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp parallel for schedule(static,4) shared(progress,status) \
magick_threads(image,image,image->rows,1)
#endif
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;
register ssize_t
x;
if (status == MagickFalse)
continue;
q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
{
status=MagickFalse;
continue;
}
for (x=0; x < (ssize_t) image->columns; x++)
{
register ssize_t
j;
if (GetPixelReadMask(image,q) == 0)
{
q+=GetPixelChannels(image);
continue;
}
for (j=0; j < (ssize_t) GetPixelChannels(image); j++)
{
PixelChannel channel=GetPixelChannelChannel(image,j);
PixelTrait traits=GetPixelChannelTraits(image,channel);
if (((traits & UpdatePixelTrait) == 0) || (black[j] == white[j]))
continue;
q[j]=ClampToQuantum(equalize_map[GetPixelChannels(image)*
ScaleQuantumToMap(q[j])+j]);
}
q+=GetPixelChannels(image);
}
if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
status=MagickFalse;
if (image->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
proceed;
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp critical (MagickCore_EqualizeImage)
#endif
proceed=SetImageProgress(image,EqualizeImageTag,progress++,image->rows);
if (proceed == MagickFalse)
status=MagickFalse;
}
}
image_view=DestroyCacheView(image_view);
equalize_map=(double *) RelinquishMagickMemory(equalize_map);
return(status);
}","MagickExport VAR_0 EqualizeImage(Image *VAR_1,
ExceptionInfo *VAR_2)
{
#define VAR_3  ""Equalize/Image""
CacheView
*VAR_4;
double
VAR_5[VAR_6+1],
*VAR_7,
*VAR_8,
*VAR_9,
VAR_10[VAR_6+1];
MagickBooleanType
VAR_11;
MagickOffsetType
VAR_12;
register ssize_t
VAR_13;
ssize_t
VAR_14;
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_15);
#if defined(VAR_16)
if (AccelerateEqualizeImage(VAR_1,VAR_2) != VAR_17)
return(VAR_18);
#endif
if (VAR_1->debug != VAR_17)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",VAR_1->filename);
VAR_7=(double *) AcquireQuantumMemory(VAR_20+1UL,
GetPixelChannels(VAR_1)*sizeof(*VAR_7));
VAR_8=(double *) AcquireQuantumMemory(VAR_20+1UL,GetPixelChannels(VAR_1)*
sizeof(*VAR_8));
VAR_9=(double *) AcquireQuantumMemory(VAR_20+1UL,GetPixelChannels(VAR_1)*
sizeof(*VAR_9));
if ((VAR_7 == (double *) NULL) || (VAR_8 == (double *) NULL) ||
(VAR_9 == (double *) NULL))
{
if (VAR_9 != (double *) NULL)
VAR_9=(double *) RelinquishMagickMemory(VAR_9);
if (VAR_8 != (double *) NULL)
VAR_8=(double *) RelinquishMagickMemory(VAR_8);
if (VAR_7 != (double *) NULL)
VAR_7=(double *) RelinquishMagickMemory(VAR_7);
ThrowBinaryException(VAR_21,""MemoryAllocationFailed"",
VAR_1->filename);
}
VAR_11=VAR_18;
(void) ResetMagickMemory(VAR_8,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
sizeof(*VAR_8));
VAR_4=AcquireVirtualCacheView(VAR_1,VAR_2);
for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
{
register const Quantum
*magick_restrict VAR_22;
register ssize_t
VAR_23;
if (VAR_11 == VAR_17)
continue;
VAR_22=GetCacheViewVirtualPixels(VAR_4,0,VAR_14,VAR_1->columns,1,VAR_2);
if (VAR_22 == (const Quantum *) NULL)
{
VAR_11=VAR_17;
continue;
}
for (VAR_23=0; VAR_23 < (ssize_t) VAR_1->columns; VAR_23++)
{
for (VAR_13=0; VAR_13 < (ssize_t) GetPixelChannels(VAR_1); VAR_13++)
{
double
VAR_24;
VAR_24=VAR_22[VAR_13];
if ((VAR_1->channel_mask & VAR_25) != 0)
VAR_24=GetPixelIntensity(VAR_1,VAR_22);
VAR_8[GetPixelChannels(VAR_1)*ScaleQuantumToMap(VAR_24)+VAR_13]++;
}
VAR_22+=GetPixelChannels(VAR_1);
}
}
VAR_4=DestroyCacheView(VAR_4);
for (VAR_13=0; VAR_13 < (ssize_t) GetPixelChannels(VAR_1); VAR_13++)
{
double
VAR_24;
register ssize_t
VAR_26;
VAR_24=0.0;
for (VAR_26=0; VAR_26 <= (ssize_t) VAR_20; VAR_26++)
{
VAR_24+=VAR_8[GetPixelChannels(VAR_1)*VAR_26+VAR_13];
VAR_9[GetPixelChannels(VAR_1)*VAR_26+VAR_13]=VAR_24;
}
}
(void) ResetMagickMemory(VAR_7,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
sizeof(*VAR_7));
(void) ResetMagickMemory(VAR_5,0,sizeof(*VAR_5));
(void) ResetMagickMemory(VAR_10,0,sizeof(*VAR_10));
for (VAR_13=0; VAR_13 < (ssize_t) GetPixelChannels(VAR_1); VAR_13++)
{
register ssize_t
VAR_26;
VAR_5[VAR_13]=VAR_9[VAR_13];
VAR_10[VAR_13]=VAR_9[GetPixelChannels(VAR_1)*VAR_20+VAR_13];
if (VAR_5[VAR_13] != VAR_10[VAR_13])
for (VAR_26=0; VAR_26 <= (ssize_t) VAR_20; VAR_26++)
VAR_7[GetPixelChannels(VAR_1)*VAR_26+VAR_13]=(double)
ScaleMapToQuantum((double) ((VAR_20*(VAR_9[
GetPixelChannels(VAR_1)*VAR_26+VAR_13]-VAR_5[VAR_13]))/(VAR_10[VAR_13]-VAR_5[VAR_13])));
}
VAR_8=(double *) RelinquishMagickMemory(VAR_8);
VAR_9=(double *) RelinquishMagickMemory(VAR_9);
if (VAR_1->storage_class == VAR_27)
{
register ssize_t
VAR_26;
for (VAR_26=0; VAR_26 < (ssize_t) VAR_1->colors; VAR_26++)
{
if ((GetPixelRedTraits(VAR_1) & VAR_28) != 0)
{
PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,VAR_30);
if (VAR_5[VAR_29] != VAR_10[VAR_29])
VAR_1->colormap[VAR_26].red=VAR_7[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].red))+
VAR_29];
}
if ((GetPixelGreenTraits(VAR_1) & VAR_28) != 0)
{
PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,
VAR_31);
if (VAR_5[VAR_29] != VAR_10[VAR_29])
VAR_1->colormap[VAR_26].green=VAR_7[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].green))+
VAR_29];
}
if ((GetPixelBlueTraits(VAR_1) & VAR_28) != 0)
{
PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,VAR_32);
if (VAR_5[VAR_29] != VAR_10[VAR_29])
VAR_1->colormap[VAR_26].blue=VAR_7[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].blue))+
VAR_29];
}
if ((GetPixelAlphaTraits(VAR_1) & VAR_28) != 0)
{
PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,
VAR_33);
if (VAR_5[VAR_29] != VAR_10[VAR_29])
VAR_1->colormap[VAR_26].alpha=VAR_7[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].alpha))+
VAR_29];
}
}
}
VAR_12=0;
VAR_4=AcquireAuthenticCacheView(VAR_1,VAR_2);
#if defined(VAR_34)
#pragma omp parallel for schedule(static,4) shared(progress,status) \
magick_threads(image,image,image->rows,1)
#endif
for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
{
register Quantum
*magick_restrict VAR_35;
register ssize_t
VAR_23;
if (VAR_11 == VAR_17)
continue;
VAR_35=GetCacheViewAuthenticPixels(VAR_4,0,VAR_14,VAR_1->columns,1,VAR_2);
if (VAR_35 == (Quantum *) NULL)
{
VAR_11=VAR_17;
continue;
}
for (VAR_23=0; VAR_23 < (ssize_t) VAR_1->columns; VAR_23++)
{
register ssize_t
VAR_26;
if (GetPixelReadMask(VAR_1,VAR_35) == 0)
{
VAR_35+=GetPixelChannels(VAR_1);
continue;
}
for (VAR_26=0; VAR_26 < (ssize_t) GetPixelChannels(VAR_1); VAR_26++)
{
PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,VAR_26);
PixelTrait VAR_36=GetPixelChannelTraits(VAR_1,VAR_29);
if (((VAR_36 & VAR_28) == 0) || (VAR_5[VAR_26] == VAR_10[VAR_26]))
continue;
VAR_35[VAR_26]=ClampToQuantum(VAR_7[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(VAR_35[VAR_26])+VAR_26]);
}
VAR_35+=GetPixelChannels(VAR_1);
}
if (SyncCacheViewAuthenticPixels(VAR_4,VAR_2) == VAR_17)
VAR_11=VAR_17;
if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
VAR_37;
#if defined(VAR_34)
#pragma omp critical (MagickCore_EqualizeImage)
#endif
VAR_37=SetImageProgress(VAR_1,VAR_3,VAR_12++,VAR_1->rows);
if (VAR_37 == VAR_17)
VAR_11=VAR_17;
}
}
VAR_4=DestroyCacheView(VAR_4);
VAR_7=(double *) RelinquishMagickMemory(VAR_7);
return(VAR_11);
}",,"MagickExport MagickBooleanType EqualizeImage(Image *image,
  ExceptionInfo *exception)
{
#define EqualizeImageTag  ""Equalize/Image""

  CacheView
    *image_view;

  double
    black[CompositePixelChannel+1],
    *equalize_map,
    *histogram,
    *map,
    white[CompositePixelChannel+1];

  MagickBooleanType
    status;

  MagickOffsetType
    progress;

  register ssize_t
    i;

  ssize_t
    y;

  /*
    Allocate and initialize histogram arrays.
  */
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
#if defined(MAGICKCORE_OPENCL_SUPPORT)
  if (AccelerateEqualizeImage(image,exception) != MagickFalse)
    return(MagickTrue);
#endif
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (SyncImagePixelCache(image,exception) == MagickFalse)
    return(MagickFalse);
  equalize_map=(double *) AcquireQuantumMemory(MaxMap+1UL,
    GetPixelChannels(image)*sizeof(*equalize_map));
  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*
    sizeof(*histogram));
  map=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*
    sizeof(*map));
  if ((equalize_map == (double *) NULL) || (histogram == (double *) NULL) ||
      (map == (double *) NULL))
    {
      if (map != (double *) NULL)
        map=(double *) RelinquishMagickMemory(map);
      if (histogram != (double *) NULL)
        histogram=(double *) RelinquishMagickMemory(histogram);
      if (equalize_map != (double *) NULL)
        equalize_map=(double *) RelinquishMagickMemory(equalize_map);
      ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
        image->filename);
    }
  /*
    Form histogram.
  */
  status=MagickTrue;
  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
    sizeof(*histogram));
  image_view=AcquireVirtualCacheView(image,exception);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register const Quantum
      *magick_restrict p;

    register ssize_t
      x;

    if (status == MagickFalse)
      continue;
    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
      {
        double
          intensity;

        intensity=p[i];
        if ((image->channel_mask & SyncChannels) != 0)
          intensity=GetPixelIntensity(image,p);
        histogram[GetPixelChannels(image)*ScaleQuantumToMap(intensity)+i]++;
      }
      p+=GetPixelChannels(image);
    }
  }
  image_view=DestroyCacheView(image_view);
  /*
    Integrate the histogram to get the equalization map.
  */
  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
  {
    double
      intensity;

    register ssize_t
      j;

    intensity=0.0;
    for (j=0; j <= (ssize_t) MaxMap; j++)
    {
      intensity+=histogram[GetPixelChannels(image)*j+i];
      map[GetPixelChannels(image)*j+i]=intensity;
    }
  }
  (void) ResetMagickMemory(equalize_map,0,(MaxMap+1)*GetPixelChannels(image)*
    sizeof(*equalize_map));
  (void) ResetMagickMemory(black,0,sizeof(*black));
  (void) ResetMagickMemory(white,0,sizeof(*white));
  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
  {
    register ssize_t
      j;

    black[i]=map[i];
    white[i]=map[GetPixelChannels(image)*MaxMap+i];
    if (black[i] != white[i])
      for (j=0; j <= (ssize_t) MaxMap; j++)
        equalize_map[GetPixelChannels(image)*j+i]=(double)
          ScaleMapToQuantum((double) ((MaxMap*(map[
          GetPixelChannels(image)*j+i]-black[i]))/(white[i]-black[i])));
  }
  histogram=(double *) RelinquishMagickMemory(histogram);
  map=(double *) RelinquishMagickMemory(map);
  if (image->storage_class == PseudoClass)
    {
      register ssize_t
        j;

      /*
        Equalize colormap.
      */
      for (j=0; j < (ssize_t) image->colors; j++)
      {
        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
          {
            PixelChannel channel=GetPixelChannelChannel(image,RedPixelChannel);
            if (black[channel] != white[channel])
              image->colormap[j].red=equalize_map[GetPixelChannels(image)*
                ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+
                channel];
          }
        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
          {
            PixelChannel channel=GetPixelChannelChannel(image,
              GreenPixelChannel);
            if (black[channel] != white[channel])
              image->colormap[j].green=equalize_map[GetPixelChannels(image)*
                ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+
                channel];
          }
        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
          {
            PixelChannel channel=GetPixelChannelChannel(image,BluePixelChannel);
            if (black[channel] != white[channel])
              image->colormap[j].blue=equalize_map[GetPixelChannels(image)*
                ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+
                channel];
          }
        if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
          {
            PixelChannel channel=GetPixelChannelChannel(image,
              AlphaPixelChannel);
            if (black[channel] != white[channel])
              image->colormap[j].alpha=equalize_map[GetPixelChannels(image)*
                ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+
                channel];
          }
      }
    }
  /*
    Equalize image.
  */
  progress=0;
  image_view=AcquireAuthenticCacheView(image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
  #pragma omp parallel for schedule(static,4) shared(progress,status) \
    magick_threads(image,image,image->rows,1)
#endif
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    if (status == MagickFalse)
      continue;
    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      register ssize_t
        j;

      if (GetPixelReadMask(image,q) == 0)
        {
          q+=GetPixelChannels(image);
          continue;
        }
      for (j=0; j < (ssize_t) GetPixelChannels(image); j++)
      {
        PixelChannel channel=GetPixelChannelChannel(image,j);
        PixelTrait traits=GetPixelChannelTraits(image,channel);
        if (((traits & UpdatePixelTrait) == 0) || (black[j] == white[j]))
          continue;
        q[j]=ClampToQuantum(equalize_map[GetPixelChannels(image)*
          ScaleQuantumToMap(q[j])+j]);
      }
      q+=GetPixelChannels(image);
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
    if (image->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          proceed;

#if defined(MAGICKCORE_OPENMP_SUPPORT)
        #pragma omp critical (MagickCore_EqualizeImage)
#endif
        proceed=SetImageProgress(image,EqualizeImageTag,progress++,image->rows);
        if (proceed == MagickFalse)
          status=MagickFalse;
      }
  }
  image_view=DestroyCacheView(image_view);
  equalize_map=(double *) RelinquishMagickMemory(equalize_map);
  return(status);
}","MagickExport VAR_0 EqualizeImage(Image *VAR_1,
  ExceptionInfo *VAR_2)
{
#define VAR_3  ""Equalize/Image""

  CacheView
    *VAR_4;

  double
    VAR_5[VAR_6+1],
    *VAR_7,
    *VAR_8,
    *VAR_9,
    VAR_10[VAR_6+1];

  MagickBooleanType
    VAR_11;

  MagickOffsetType
    VAR_12;

  register ssize_t
    VAR_13;

  ssize_t
    VAR_14;

  /* COMMENT_0 */
                                             
    
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_15);
#if defined(VAR_16)
  if (AccelerateEqualizeImage(VAR_1,VAR_2) != VAR_17)
    return(VAR_18);
#endif
  if (VAR_1->debug != VAR_17)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",VAR_1->filename);
  if (SyncImagePixelCache(VAR_1,VAR_2) == VAR_17)
    return(VAR_17);
  VAR_7=(double *) AcquireQuantumMemory(VAR_20+1UL,
    GetPixelChannels(VAR_1)*sizeof(*VAR_7));
  VAR_8=(double *) AcquireQuantumMemory(VAR_20+1UL,GetPixelChannels(VAR_1)*
    sizeof(*VAR_8));
  VAR_9=(double *) AcquireQuantumMemory(VAR_20+1UL,GetPixelChannels(VAR_1)*
    sizeof(*VAR_9));
  if ((VAR_7 == (double *) NULL) || (VAR_8 == (double *) NULL) ||
      (VAR_9 == (double *) NULL))
    {
      if (VAR_9 != (double *) NULL)
        VAR_9=(double *) RelinquishMagickMemory(VAR_9);
      if (VAR_8 != (double *) NULL)
        VAR_8=(double *) RelinquishMagickMemory(VAR_8);
      if (VAR_7 != (double *) NULL)
        VAR_7=(double *) RelinquishMagickMemory(VAR_7);
      ThrowBinaryException(VAR_21,""MemoryAllocationFailed"",
        VAR_1->filename);
    }
  /* COMMENT_3 */
                   
    
  VAR_11=VAR_18;
  (void) ResetMagickMemory(VAR_8,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
    sizeof(*VAR_8));
  VAR_4=AcquireVirtualCacheView(VAR_1,VAR_2);
  for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
  {
    register const Quantum
      *magick_restrict VAR_22;

    register ssize_t
      VAR_23;

    if (VAR_11 == VAR_17)
      continue;
    VAR_22=GetCacheViewVirtualPixels(VAR_4,0,VAR_14,VAR_1->columns,1,VAR_2);
    if (VAR_22 == (const Quantum *) NULL)
      {
        VAR_11=VAR_17;
        continue;
      }
    for (VAR_23=0; VAR_23 < (ssize_t) VAR_1->columns; VAR_23++)
    {
      for (VAR_13=0; VAR_13 < (ssize_t) GetPixelChannels(VAR_1); VAR_13++)
      {
        double
          VAR_24;

        VAR_24=VAR_22[VAR_13];
        if ((VAR_1->channel_mask & VAR_25) != 0)
          VAR_24=GetPixelIntensity(VAR_1,VAR_22);
        VAR_8[GetPixelChannels(VAR_1)*ScaleQuantumToMap(VAR_24)+VAR_13]++;
      }
      VAR_22+=GetPixelChannels(VAR_1);
    }
  }
  VAR_4=DestroyCacheView(VAR_4);
  /* COMMENT_6 */
                                                        
    
  for (VAR_13=0; VAR_13 < (ssize_t) GetPixelChannels(VAR_1); VAR_13++)
  {
    double
      VAR_24;

    register ssize_t
      VAR_26;

    VAR_24=0.0;
    for (VAR_26=0; VAR_26 <= (ssize_t) VAR_20; VAR_26++)
    {
      VAR_24+=VAR_8[GetPixelChannels(VAR_1)*VAR_26+VAR_13];
      VAR_9[GetPixelChannels(VAR_1)*VAR_26+VAR_13]=VAR_24;
    }
  }
  (void) ResetMagickMemory(VAR_7,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
    sizeof(*VAR_7));
  (void) ResetMagickMemory(VAR_5,0,sizeof(*VAR_5));
  (void) ResetMagickMemory(VAR_10,0,sizeof(*VAR_10));
  for (VAR_13=0; VAR_13 < (ssize_t) GetPixelChannels(VAR_1); VAR_13++)
  {
    register ssize_t
      VAR_26;

    VAR_5[VAR_13]=VAR_9[VAR_13];
    VAR_10[VAR_13]=VAR_9[GetPixelChannels(VAR_1)*VAR_20+VAR_13];
    if (VAR_5[VAR_13] != VAR_10[VAR_13])
      for (VAR_26=0; VAR_26 <= (ssize_t) VAR_20; VAR_26++)
        VAR_7[GetPixelChannels(VAR_1)*VAR_26+VAR_13]=(double)
          ScaleMapToQuantum((double) ((VAR_20*(VAR_9[
          GetPixelChannels(VAR_1)*VAR_26+VAR_13]-VAR_5[VAR_13]))/(VAR_10[VAR_13]-VAR_5[VAR_13])));
  }
  VAR_8=(double *) RelinquishMagickMemory(VAR_8);
  VAR_9=(double *) RelinquishMagickMemory(VAR_9);
  if (VAR_1->storage_class == VAR_27)
    {
      register ssize_t
        VAR_26;

      /* COMMENT_9 */
                          
        
      for (VAR_26=0; VAR_26 < (ssize_t) VAR_1->colors; VAR_26++)
      {
        if ((GetPixelRedTraits(VAR_1) & VAR_28) != 0)
          {
            PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,VAR_30);
            if (VAR_5[VAR_29] != VAR_10[VAR_29])
              VAR_1->colormap[VAR_26].red=VAR_7[GetPixelChannels(VAR_1)*
                ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].red))+
                VAR_29];
          }
        if ((GetPixelGreenTraits(VAR_1) & VAR_28) != 0)
          {
            PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,
              VAR_31);
            if (VAR_5[VAR_29] != VAR_10[VAR_29])
              VAR_1->colormap[VAR_26].green=VAR_7[GetPixelChannels(VAR_1)*
                ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].green))+
                VAR_29];
          }
        if ((GetPixelBlueTraits(VAR_1) & VAR_28) != 0)
          {
            PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,VAR_32);
            if (VAR_5[VAR_29] != VAR_10[VAR_29])
              VAR_1->colormap[VAR_26].blue=VAR_7[GetPixelChannels(VAR_1)*
                ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].blue))+
                VAR_29];
          }
        if ((GetPixelAlphaTraits(VAR_1) & VAR_28) != 0)
          {
            PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,
              VAR_33);
            if (VAR_5[VAR_29] != VAR_10[VAR_29])
              VAR_1->colormap[VAR_26].alpha=VAR_7[GetPixelChannels(VAR_1)*
                ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_26].alpha))+
                VAR_29];
          }
      }
    }
  /* COMMENT_12 */
                   
    
  VAR_12=0;
  VAR_4=AcquireAuthenticCacheView(VAR_1,VAR_2);
#if defined(VAR_34)
  #pragma omp parallel for schedule(static,4) shared(progress,status) \
    magick_threads(image,image,image->rows,1)
#endif
  for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
  {
    register Quantum
      *magick_restrict VAR_35;

    register ssize_t
      VAR_23;

    if (VAR_11 == VAR_17)
      continue;
    VAR_35=GetCacheViewAuthenticPixels(VAR_4,0,VAR_14,VAR_1->columns,1,VAR_2);
    if (VAR_35 == (Quantum *) NULL)
      {
        VAR_11=VAR_17;
        continue;
      }
    for (VAR_23=0; VAR_23 < (ssize_t) VAR_1->columns; VAR_23++)
    {
      register ssize_t
        VAR_26;

      if (GetPixelReadMask(VAR_1,VAR_35) == 0)
        {
          VAR_35+=GetPixelChannels(VAR_1);
          continue;
        }
      for (VAR_26=0; VAR_26 < (ssize_t) GetPixelChannels(VAR_1); VAR_26++)
      {
        PixelChannel VAR_29=GetPixelChannelChannel(VAR_1,VAR_26);
        PixelTrait VAR_36=GetPixelChannelTraits(VAR_1,VAR_29);
        if (((VAR_36 & VAR_28) == 0) || (VAR_5[VAR_26] == VAR_10[VAR_26]))
          continue;
        VAR_35[VAR_26]=ClampToQuantum(VAR_7[GetPixelChannels(VAR_1)*
          ScaleQuantumToMap(VAR_35[VAR_26])+VAR_26]);
      }
      VAR_35+=GetPixelChannels(VAR_1);
    }
    if (SyncCacheViewAuthenticPixels(VAR_4,VAR_2) == VAR_17)
      VAR_11=VAR_17;
    if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          VAR_37;

#if defined(VAR_34)
        #pragma omp critical (MagickCore_EqualizeImage)
#endif
        VAR_37=SetImageProgress(VAR_1,VAR_3,VAR_12++,VAR_1->rows);
        if (VAR_37 == VAR_17)
          VAR_11=VAR_17;
      }
  }
  VAR_4=DestroyCacheView(VAR_4);
  VAR_7=(double *) RelinquishMagickMemory(VAR_7);
  return(VAR_11);
}",,"--- func_before
+++ func_after
@@ -36,6 +36,8 @@
 #endif
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
+  if (SyncImagePixelCache(image,exception) == MagickFalse)
+    return(MagickFalse);
   equalize_map=(double *) AcquireQuantumMemory(MaxMap+1UL,
     GetPixelChannels(image)*sizeof(*equalize_map));
   histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*","{'deleted_lines': [], 'added_lines': ['  if (SyncImagePixelCache(image,exception) == MagickFalse)', '    return(MagickFalse);']}",True,Buffer overflow in MagickCore/enhance.c in ImageMagick before 7.0.2-7 allows remote attackers to have unspecified impact via vectors related to pixel cache morphology.,9.1,CRITICAL,3,valid,2016-08-01T16:16:49Z,1
CVE-2016-6520,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,ImageMagick,Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report from Ibrahim M. El-Sayed),76401e172ea3a55182be2b8e2aca4d07270f6da6,https://github.com/ImageMagick/ImageMagick/commit/76401e172ea3a55182be2b8e2aca4d07270f6da6,MagickCore/enhance.c,ContrastStretchImage,"MagickExport MagickBooleanType ContrastStretchImage(Image *image,
const double black_point,const double white_point,ExceptionInfo *exception)
{
#define MaxRange(color)  ((double) ScaleQuantumToMap((Quantum) (color)))
#define ContrastStretchImageTag  ""ContrastStretch/Image""
CacheView
*image_view;
double
*black,
*histogram,
*stretch_map,
*white;
MagickBooleanType
status;
MagickOffsetType
progress;
register ssize_t
i;
ssize_t
y;
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
if (SetImageGray(image,exception) != MagickFalse)
(void) SetImageColorspace(image,GRAYColorspace,exception);
black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));
white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white));
histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*
sizeof(*histogram));
stretch_map=(double *) AcquireQuantumMemory(MaxMap+1UL,
GetPixelChannels(image)*sizeof(*stretch_map));
if ((black == (double *) NULL) || (white == (double *) NULL) ||
(histogram == (double *) NULL) || (stretch_map == (double *) NULL))
{
if (stretch_map != (double *) NULL)
stretch_map=(double *) RelinquishMagickMemory(stretch_map);
if (histogram != (double *) NULL)
histogram=(double *) RelinquishMagickMemory(histogram);
if (white != (double *) NULL)
white=(double *) RelinquishMagickMemory(white);
if (black != (double *) NULL)
black=(double *) RelinquishMagickMemory(black);
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
status=MagickTrue;
(void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
sizeof(*histogram));
image_view=AcquireVirtualCacheView(image,exception);
for (y=0; y < (ssize_t) image->rows; y++)
{
register const Quantum
*magick_restrict p;
register ssize_t
x;
if (status == MagickFalse)
continue;
p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
{
status=MagickFalse;
continue;
}
for (x=0; x < (ssize_t) image->columns; x++)
{
double
pixel;
pixel=GetPixelIntensity(image,p);
for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
{
if (image->channel_mask != DefaultChannels)
pixel=(double) p[i];
histogram[GetPixelChannels(image)*ScaleQuantumToMap(
ClampToQuantum(pixel))+i]++;
}
p+=GetPixelChannels(image);
}
}
image_view=DestroyCacheView(image_view);
for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
{
double
intensity;
register ssize_t
j;
black[i]=0.0;
white[i]=MaxRange(QuantumRange);
intensity=0.0;
for (j=0; j <= (ssize_t) MaxMap; j++)
{
intensity+=histogram[GetPixelChannels(image)*j+i];
if (intensity > black_point)
break;
}
black[i]=(double) j;
intensity=0.0;
for (j=(ssize_t) MaxMap; j != 0; j--)
{
intensity+=histogram[GetPixelChannels(image)*j+i];
if (intensity > ((double) image->columns*image->rows-white_point))
break;
}
white[i]=(double) j;
}
histogram=(double *) RelinquishMagickMemory(histogram);
(void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)*
sizeof(*stretch_map));
for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
{
register ssize_t
j;
for (j=0; j <= (ssize_t) MaxMap; j++)
{
double
gamma;
gamma=PerceptibleReciprocal(white[i]-black[i]);
if (j < (ssize_t) black[i])
stretch_map[GetPixelChannels(image)*j+i]=0.0;
else
if (j > (ssize_t) white[i])
stretch_map[GetPixelChannels(image)*j+i]=(double) QuantumRange;
else
stretch_map[GetPixelChannels(image)*j+i]=(double) ScaleMapToQuantum(
(double) (MaxMap*gamma*(j-black[i])));
}
}
if (image->storage_class == PseudoClass)
{
register ssize_t
j;
for (j=0; j < (ssize_t) image->colors; j++)
{
if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
{
i=GetPixelChannelOffset(image,RedPixelChannel);
image->colormap[j].red=stretch_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+i];
}
if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
{
i=GetPixelChannelOffset(image,GreenPixelChannel);
image->colormap[j].green=stretch_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+i];
}
if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
{
i=GetPixelChannelOffset(image,BluePixelChannel);
image->colormap[j].blue=stretch_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+i];
}
if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
{
i=GetPixelChannelOffset(image,AlphaPixelChannel);
image->colormap[j].alpha=stretch_map[GetPixelChannels(image)*
ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+i];
}
}
}
status=MagickTrue;
progress=0;
image_view=AcquireAuthenticCacheView(image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp parallel for schedule(static,4) shared(progress,status) \
magick_threads(image,image,image->rows,1)
#endif
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;
register ssize_t
x;
if (status == MagickFalse)
continue;
q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
{
status=MagickFalse;
continue;
}
for (x=0; x < (ssize_t) image->columns; x++)
{
register ssize_t
j;
if (GetPixelReadMask(image,q) == 0)
{
q+=GetPixelChannels(image);
continue;
}
for (j=0; j < (ssize_t) GetPixelChannels(image); j++)
{
PixelChannel channel=GetPixelChannelChannel(image,j);
PixelTrait traits=GetPixelChannelTraits(image,channel);
if ((traits & UpdatePixelTrait) == 0)
continue;
q[j]=ClampToQuantum(stretch_map[GetPixelChannels(image)*
ScaleQuantumToMap(q[j])+j]);
}
q+=GetPixelChannels(image);
}
if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
status=MagickFalse;
if (image->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
proceed;
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp critical (MagickCore_ContrastStretchImage)
#endif
proceed=SetImageProgress(image,ContrastStretchImageTag,progress++,
image->rows);
if (proceed == MagickFalse)
status=MagickFalse;
}
}
image_view=DestroyCacheView(image_view);
stretch_map=(double *) RelinquishMagickMemory(stretch_map);
white=(double *) RelinquishMagickMemory(white);
black=(double *) RelinquishMagickMemory(black);
return(status);
}","MagickExport VAR_0 ContrastStretchImage(Image *VAR_1,
const double VAR_2,const double VAR_3,ExceptionInfo *VAR_4)
{
#define MaxRange(VAR_5)  ((double) ScaleQuantumToMap((Quantum) (color)))
#define VAR_6  ""ContrastStretch/Image""
CacheView
*VAR_7;
double
*VAR_8,
*VAR_9,
*VAR_10,
*VAR_11;
MagickBooleanType
VAR_12;
MagickOffsetType
VAR_13;
register ssize_t
VAR_14;
ssize_t
VAR_15;
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_16);
if (VAR_1->debug != VAR_17)
(void) LogMagickEvent(VAR_18,GetMagickModule(),""%s"",VAR_1->filename);
if (SetImageGray(VAR_1,VAR_4) != VAR_17)
(void) SetImageColorspace(VAR_1,VAR_19,VAR_4);
VAR_8=(double *) AcquireQuantumMemory(GetPixelChannels(VAR_1),sizeof(*VAR_8));
VAR_11=(double *) AcquireQuantumMemory(GetPixelChannels(VAR_1),sizeof(*VAR_11));
VAR_9=(double *) AcquireQuantumMemory(VAR_20+1UL,GetPixelChannels(VAR_1)*
sizeof(*VAR_9));
VAR_10=(double *) AcquireQuantumMemory(VAR_20+1UL,
GetPixelChannels(VAR_1)*sizeof(*VAR_10));
if ((VAR_8 == (double *) NULL) || (VAR_11 == (double *) NULL) ||
(VAR_9 == (double *) NULL) || (VAR_10 == (double *) NULL))
{
if (VAR_10 != (double *) NULL)
VAR_10=(double *) RelinquishMagickMemory(VAR_10);
if (VAR_9 != (double *) NULL)
VAR_9=(double *) RelinquishMagickMemory(VAR_9);
if (VAR_11 != (double *) NULL)
VAR_11=(double *) RelinquishMagickMemory(VAR_11);
if (VAR_8 != (double *) NULL)
VAR_8=(double *) RelinquishMagickMemory(VAR_8);
ThrowBinaryException(VAR_21,""MemoryAllocationFailed"",
VAR_1->filename);
}
VAR_12=VAR_22;
(void) ResetMagickMemory(VAR_9,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
sizeof(*VAR_9));
VAR_7=AcquireVirtualCacheView(VAR_1,VAR_4);
for (VAR_15=0; VAR_15 < (ssize_t) VAR_1->rows; VAR_15++)
{
register const Quantum
*magick_restrict VAR_23;
register ssize_t
VAR_24;
if (VAR_12 == VAR_17)
continue;
VAR_23=GetCacheViewVirtualPixels(VAR_7,0,VAR_15,VAR_1->columns,1,VAR_4);
if (VAR_23 == (const Quantum *) NULL)
{
VAR_12=VAR_17;
continue;
}
for (VAR_24=0; VAR_24 < (ssize_t) VAR_1->columns; VAR_24++)
{
double
VAR_25;
VAR_25=GetPixelIntensity(VAR_1,VAR_23);
for (VAR_14=0; VAR_14 < (ssize_t) GetPixelChannels(VAR_1); VAR_14++)
{
if (VAR_1->channel_mask != VAR_26)
VAR_25=(double) VAR_23[VAR_14];
VAR_9[GetPixelChannels(VAR_1)*ScaleQuantumToMap(
ClampToQuantum(VAR_25))+VAR_14]++;
}
VAR_23+=GetPixelChannels(VAR_1);
}
}
VAR_7=DestroyCacheView(VAR_7);
for (VAR_14=0; VAR_14 < (ssize_t) GetPixelChannels(VAR_1); VAR_14++)
{
double
VAR_27;
register ssize_t
VAR_28;
VAR_8[VAR_14]=0.0;
VAR_11[VAR_14]=MaxRange(VAR_29);
VAR_27=0.0;
for (VAR_28=0; VAR_28 <= (ssize_t) VAR_20; VAR_28++)
{
VAR_27+=VAR_9[GetPixelChannels(VAR_1)*VAR_28+VAR_14];
if (VAR_27 > VAR_2)
break;
}
VAR_8[VAR_14]=(double) VAR_28;
VAR_27=0.0;
for (VAR_28=(ssize_t) VAR_20; VAR_28 != 0; VAR_28--)
{
VAR_27+=VAR_9[GetPixelChannels(VAR_1)*VAR_28+VAR_14];
if (VAR_27 > ((double) VAR_1->columns*VAR_1->rows-VAR_3))
break;
}
VAR_11[VAR_14]=(double) VAR_28;
}
VAR_9=(double *) RelinquishMagickMemory(VAR_9);
(void) ResetMagickMemory(VAR_10,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
sizeof(*VAR_10));
for (VAR_14=0; VAR_14 < (ssize_t) GetPixelChannels(VAR_1); VAR_14++)
{
register ssize_t
VAR_28;
for (VAR_28=0; VAR_28 <= (ssize_t) VAR_20; VAR_28++)
{
double
VAR_30;
VAR_30=PerceptibleReciprocal(VAR_11[VAR_14]-VAR_8[VAR_14]);
if (VAR_28 < (ssize_t) VAR_8[VAR_14])
VAR_10[GetPixelChannels(VAR_1)*VAR_28+VAR_14]=0.0;
else
if (VAR_28 > (ssize_t) VAR_11[VAR_14])
VAR_10[GetPixelChannels(VAR_1)*VAR_28+VAR_14]=(double) VAR_29;
else
VAR_10[GetPixelChannels(VAR_1)*VAR_28+VAR_14]=(double) ScaleMapToQuantum(
(double) (VAR_20*VAR_30*(VAR_28-VAR_8[VAR_14])));
}
}
if (VAR_1->storage_class == VAR_31)
{
register ssize_t
VAR_28;
for (VAR_28=0; VAR_28 < (ssize_t) VAR_1->colors; VAR_28++)
{
if ((GetPixelRedTraits(VAR_1) & VAR_32) != 0)
{
VAR_14=GetPixelChannelOffset(VAR_1,VAR_33);
VAR_1->colormap[VAR_28].red=VAR_10[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].red))+VAR_14];
}
if ((GetPixelGreenTraits(VAR_1) & VAR_32) != 0)
{
VAR_14=GetPixelChannelOffset(VAR_1,VAR_34);
VAR_1->colormap[VAR_28].green=VAR_10[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].green))+VAR_14];
}
if ((GetPixelBlueTraits(VAR_1) & VAR_32) != 0)
{
VAR_14=GetPixelChannelOffset(VAR_1,VAR_35);
VAR_1->colormap[VAR_28].blue=VAR_10[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].blue))+VAR_14];
}
if ((GetPixelAlphaTraits(VAR_1) & VAR_32) != 0)
{
VAR_14=GetPixelChannelOffset(VAR_1,VAR_36);
VAR_1->colormap[VAR_28].alpha=VAR_10[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].alpha))+VAR_14];
}
}
}
VAR_12=VAR_22;
VAR_13=0;
VAR_7=AcquireAuthenticCacheView(VAR_1,VAR_4);
#if defined(VAR_37)
#pragma omp parallel for schedule(static,4) shared(progress,status) \
magick_threads(image,image,image->rows,1)
#endif
for (VAR_15=0; VAR_15 < (ssize_t) VAR_1->rows; VAR_15++)
{
register Quantum
*magick_restrict VAR_38;
register ssize_t
VAR_24;
if (VAR_12 == VAR_17)
continue;
VAR_38=GetCacheViewAuthenticPixels(VAR_7,0,VAR_15,VAR_1->columns,1,VAR_4);
if (VAR_38 == (Quantum *) NULL)
{
VAR_12=VAR_17;
continue;
}
for (VAR_24=0; VAR_24 < (ssize_t) VAR_1->columns; VAR_24++)
{
register ssize_t
VAR_28;
if (GetPixelReadMask(VAR_1,VAR_38) == 0)
{
VAR_38+=GetPixelChannels(VAR_1);
continue;
}
for (VAR_28=0; VAR_28 < (ssize_t) GetPixelChannels(VAR_1); VAR_28++)
{
PixelChannel VAR_39=GetPixelChannelChannel(VAR_1,VAR_28);
PixelTrait VAR_40=GetPixelChannelTraits(VAR_1,VAR_39);
if ((VAR_40 & VAR_32) == 0)
continue;
VAR_38[VAR_28]=ClampToQuantum(VAR_10[GetPixelChannels(VAR_1)*
ScaleQuantumToMap(VAR_38[VAR_28])+VAR_28]);
}
VAR_38+=GetPixelChannels(VAR_1);
}
if (SyncCacheViewAuthenticPixels(VAR_7,VAR_4) == VAR_17)
VAR_12=VAR_17;
if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
VAR_41;
#if defined(VAR_37)
#pragma omp critical (MagickCore_ContrastStretchImage)
#endif
VAR_41=SetImageProgress(VAR_1,VAR_6,VAR_13++,
VAR_1->rows);
if (VAR_41 == VAR_17)
VAR_12=VAR_17;
}
}
VAR_7=DestroyCacheView(VAR_7);
VAR_10=(double *) RelinquishMagickMemory(VAR_10);
VAR_11=(double *) RelinquishMagickMemory(VAR_11);
VAR_8=(double *) RelinquishMagickMemory(VAR_8);
return(VAR_12);
}",,"MagickExport MagickBooleanType ContrastStretchImage(Image *image,
  const double black_point,const double white_point,ExceptionInfo *exception)
{
#define MaxRange(color)  ((double) ScaleQuantumToMap((Quantum) (color)))
#define ContrastStretchImageTag  ""ContrastStretch/Image""

  CacheView
    *image_view;

  double
    *black,
    *histogram,
    *stretch_map,
    *white;

  MagickBooleanType
    status;

  MagickOffsetType
    progress;

  register ssize_t
    i;

  ssize_t
    y;

  /*
    Allocate histogram and stretch map.
  */
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (SetImageGray(image,exception) != MagickFalse)
    (void) SetImageColorspace(image,GRAYColorspace,exception);
  if (SyncImagePixelCache(image,exception) == MagickFalse)
    return(MagickFalse);
  black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));
  white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white));
  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*
    sizeof(*histogram));
  stretch_map=(double *) AcquireQuantumMemory(MaxMap+1UL,
    GetPixelChannels(image)*sizeof(*stretch_map));
  if ((black == (double *) NULL) || (white == (double *) NULL) ||
      (histogram == (double *) NULL) || (stretch_map == (double *) NULL))
    {
      if (stretch_map != (double *) NULL)
        stretch_map=(double *) RelinquishMagickMemory(stretch_map);
      if (histogram != (double *) NULL)
        histogram=(double *) RelinquishMagickMemory(histogram);
      if (white != (double *) NULL)
        white=(double *) RelinquishMagickMemory(white);
      if (black != (double *) NULL)
        black=(double *) RelinquishMagickMemory(black);
      ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
        image->filename);
    }
  /*
    Form histogram.
  */
  status=MagickTrue;
  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
    sizeof(*histogram));
  image_view=AcquireVirtualCacheView(image,exception);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register const Quantum
      *magick_restrict p;

    register ssize_t
      x;

    if (status == MagickFalse)
      continue;
    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      double
        pixel;

      pixel=GetPixelIntensity(image,p);
      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
      {
        if (image->channel_mask != DefaultChannels)
          pixel=(double) p[i];
        histogram[GetPixelChannels(image)*ScaleQuantumToMap(
          ClampToQuantum(pixel))+i]++;
      }
      p+=GetPixelChannels(image);
    }
  }
  image_view=DestroyCacheView(image_view);
  /*
    Find the histogram boundaries by locating the black/white levels.
  */
  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
  {
    double
      intensity;

    register ssize_t
      j;

    black[i]=0.0;
    white[i]=MaxRange(QuantumRange);
    intensity=0.0;
    for (j=0; j <= (ssize_t) MaxMap; j++)
    {
      intensity+=histogram[GetPixelChannels(image)*j+i];
      if (intensity > black_point)
        break;
    }
    black[i]=(double) j;
    intensity=0.0;
    for (j=(ssize_t) MaxMap; j != 0; j--)
    {
      intensity+=histogram[GetPixelChannels(image)*j+i];
      if (intensity > ((double) image->columns*image->rows-white_point))
        break;
    }
    white[i]=(double) j;
  }
  histogram=(double *) RelinquishMagickMemory(histogram);
  /*
    Stretch the histogram to create the stretched image mapping.
  */
  (void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)*
    sizeof(*stretch_map));
  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
  {
    register ssize_t
      j;

    for (j=0; j <= (ssize_t) MaxMap; j++)
    {
      double
        gamma;

      gamma=PerceptibleReciprocal(white[i]-black[i]);
      if (j < (ssize_t) black[i])
        stretch_map[GetPixelChannels(image)*j+i]=0.0;
      else
        if (j > (ssize_t) white[i])
          stretch_map[GetPixelChannels(image)*j+i]=(double) QuantumRange;
        else
          stretch_map[GetPixelChannels(image)*j+i]=(double) ScaleMapToQuantum(
            (double) (MaxMap*gamma*(j-black[i])));
    }
  }
  if (image->storage_class == PseudoClass)
    {
      register ssize_t
        j;

      /*
        Stretch-contrast colormap.
      */
      for (j=0; j < (ssize_t) image->colors; j++)
      {
        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
          {
            i=GetPixelChannelOffset(image,RedPixelChannel);
            image->colormap[j].red=stretch_map[GetPixelChannels(image)*
              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+i];
          }
        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
          {
            i=GetPixelChannelOffset(image,GreenPixelChannel);
            image->colormap[j].green=stretch_map[GetPixelChannels(image)*
              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+i];
          }
        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
          {
            i=GetPixelChannelOffset(image,BluePixelChannel);
            image->colormap[j].blue=stretch_map[GetPixelChannels(image)*
              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+i];
          }
        if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
          {
            i=GetPixelChannelOffset(image,AlphaPixelChannel);
            image->colormap[j].alpha=stretch_map[GetPixelChannels(image)*
              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+i];
          }
      }
    }
  /*
    Stretch-contrast image.
  */
  status=MagickTrue;
  progress=0;
  image_view=AcquireAuthenticCacheView(image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
  #pragma omp parallel for schedule(static,4) shared(progress,status) \
    magick_threads(image,image,image->rows,1)
#endif
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    if (status == MagickFalse)
      continue;
    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      register ssize_t
        j;

      if (GetPixelReadMask(image,q) == 0)
        {
          q+=GetPixelChannels(image);
          continue;
        }
      for (j=0; j < (ssize_t) GetPixelChannels(image); j++)
      {
        PixelChannel channel=GetPixelChannelChannel(image,j);
        PixelTrait traits=GetPixelChannelTraits(image,channel);
        if ((traits & UpdatePixelTrait) == 0)
          continue;
        q[j]=ClampToQuantum(stretch_map[GetPixelChannels(image)*
          ScaleQuantumToMap(q[j])+j]);
      }
      q+=GetPixelChannels(image);
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
    if (image->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          proceed;

#if defined(MAGICKCORE_OPENMP_SUPPORT)
        #pragma omp critical (MagickCore_ContrastStretchImage)
#endif
        proceed=SetImageProgress(image,ContrastStretchImageTag,progress++,
          image->rows);
        if (proceed == MagickFalse)
          status=MagickFalse;
      }
  }
  image_view=DestroyCacheView(image_view);
  stretch_map=(double *) RelinquishMagickMemory(stretch_map);
  white=(double *) RelinquishMagickMemory(white);
  black=(double *) RelinquishMagickMemory(black);
  return(status);
}","MagickExport VAR_0 ContrastStretchImage(Image *VAR_1,
  const double VAR_2,const double VAR_3,ExceptionInfo *VAR_4)
{
#define MaxRange(VAR_5)  ((double) ScaleQuantumToMap((Quantum) (color)))
#define VAR_6  ""ContrastStretch/Image""

  CacheView
    *VAR_7;

  double
    *VAR_8,
    *VAR_9,
    *VAR_10,
    *VAR_11;

  MagickBooleanType
    VAR_12;

  MagickOffsetType
    VAR_13;

  register ssize_t
    VAR_14;

  ssize_t
    VAR_15;

  /* COMMENT_0 */
                                       
    
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_16);
  if (VAR_1->debug != VAR_17)
    (void) LogMagickEvent(VAR_18,GetMagickModule(),""%s"",VAR_1->filename);
  if (SetImageGray(VAR_1,VAR_4) != VAR_17)
    (void) SetImageColorspace(VAR_1,VAR_19,VAR_4);
  if (SyncImagePixelCache(VAR_1,VAR_4) == VAR_17)
    return(VAR_17);
  VAR_8=(double *) AcquireQuantumMemory(GetPixelChannels(VAR_1),sizeof(*VAR_8));
  VAR_11=(double *) AcquireQuantumMemory(GetPixelChannels(VAR_1),sizeof(*VAR_11));
  VAR_9=(double *) AcquireQuantumMemory(VAR_20+1UL,GetPixelChannels(VAR_1)*
    sizeof(*VAR_9));
  VAR_10=(double *) AcquireQuantumMemory(VAR_20+1UL,
    GetPixelChannels(VAR_1)*sizeof(*VAR_10));
  if ((VAR_8 == (double *) NULL) || (VAR_11 == (double *) NULL) ||
      (VAR_9 == (double *) NULL) || (VAR_10 == (double *) NULL))
    {
      if (VAR_10 != (double *) NULL)
        VAR_10=(double *) RelinquishMagickMemory(VAR_10);
      if (VAR_9 != (double *) NULL)
        VAR_9=(double *) RelinquishMagickMemory(VAR_9);
      if (VAR_11 != (double *) NULL)
        VAR_11=(double *) RelinquishMagickMemory(VAR_11);
      if (VAR_8 != (double *) NULL)
        VAR_8=(double *) RelinquishMagickMemory(VAR_8);
      ThrowBinaryException(VAR_21,""MemoryAllocationFailed"",
        VAR_1->filename);
    }
  /* COMMENT_3 */
                   
    
  VAR_12=VAR_22;
  (void) ResetMagickMemory(VAR_9,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
    sizeof(*VAR_9));
  VAR_7=AcquireVirtualCacheView(VAR_1,VAR_4);
  for (VAR_15=0; VAR_15 < (ssize_t) VAR_1->rows; VAR_15++)
  {
    register const Quantum
      *magick_restrict VAR_23;

    register ssize_t
      VAR_24;

    if (VAR_12 == VAR_17)
      continue;
    VAR_23=GetCacheViewVirtualPixels(VAR_7,0,VAR_15,VAR_1->columns,1,VAR_4);
    if (VAR_23 == (const Quantum *) NULL)
      {
        VAR_12=VAR_17;
        continue;
      }
    for (VAR_24=0; VAR_24 < (ssize_t) VAR_1->columns; VAR_24++)
    {
      double
        VAR_25;

      VAR_25=GetPixelIntensity(VAR_1,VAR_23);
      for (VAR_14=0; VAR_14 < (ssize_t) GetPixelChannels(VAR_1); VAR_14++)
      {
        if (VAR_1->channel_mask != VAR_26)
          VAR_25=(double) VAR_23[VAR_14];
        VAR_9[GetPixelChannels(VAR_1)*ScaleQuantumToMap(
          ClampToQuantum(VAR_25))+VAR_14]++;
      }
      VAR_23+=GetPixelChannels(VAR_1);
    }
  }
  VAR_7=DestroyCacheView(VAR_7);
  /* COMMENT_6 */
                                                                     
    
  for (VAR_14=0; VAR_14 < (ssize_t) GetPixelChannels(VAR_1); VAR_14++)
  {
    double
      VAR_27;

    register ssize_t
      VAR_28;

    VAR_8[VAR_14]=0.0;
    VAR_11[VAR_14]=MaxRange(VAR_29);
    VAR_27=0.0;
    for (VAR_28=0; VAR_28 <= (ssize_t) VAR_20; VAR_28++)
    {
      VAR_27+=VAR_9[GetPixelChannels(VAR_1)*VAR_28+VAR_14];
      if (VAR_27 > VAR_2)
        break;
    }
    VAR_8[VAR_14]=(double) VAR_28;
    VAR_27=0.0;
    for (VAR_28=(ssize_t) VAR_20; VAR_28 != 0; VAR_28--)
    {
      VAR_27+=VAR_9[GetPixelChannels(VAR_1)*VAR_28+VAR_14];
      if (VAR_27 > ((double) VAR_1->columns*VAR_1->rows-VAR_3))
        break;
    }
    VAR_11[VAR_14]=(double) VAR_28;
  }
  VAR_9=(double *) RelinquishMagickMemory(VAR_9);
  /* COMMENT_9 */
                                                                
    
  (void) ResetMagickMemory(VAR_10,0,(VAR_20+1)*GetPixelChannels(VAR_1)*
    sizeof(*VAR_10));
  for (VAR_14=0; VAR_14 < (ssize_t) GetPixelChannels(VAR_1); VAR_14++)
  {
    register ssize_t
      VAR_28;

    for (VAR_28=0; VAR_28 <= (ssize_t) VAR_20; VAR_28++)
    {
      double
        VAR_30;

      VAR_30=PerceptibleReciprocal(VAR_11[VAR_14]-VAR_8[VAR_14]);
      if (VAR_28 < (ssize_t) VAR_8[VAR_14])
        VAR_10[GetPixelChannels(VAR_1)*VAR_28+VAR_14]=0.0;
      else
        if (VAR_28 > (ssize_t) VAR_11[VAR_14])
          VAR_10[GetPixelChannels(VAR_1)*VAR_28+VAR_14]=(double) VAR_29;
        else
          VAR_10[GetPixelChannels(VAR_1)*VAR_28+VAR_14]=(double) ScaleMapToQuantum(
            (double) (VAR_20*VAR_30*(VAR_28-VAR_8[VAR_14])));
    }
  }
  if (VAR_1->storage_class == VAR_31)
    {
      register ssize_t
        VAR_28;

      /* COMMENT_12 */
                                  
        
      for (VAR_28=0; VAR_28 < (ssize_t) VAR_1->colors; VAR_28++)
      {
        if ((GetPixelRedTraits(VAR_1) & VAR_32) != 0)
          {
            VAR_14=GetPixelChannelOffset(VAR_1,VAR_33);
            VAR_1->colormap[VAR_28].red=VAR_10[GetPixelChannels(VAR_1)*
              ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].red))+VAR_14];
          }
        if ((GetPixelGreenTraits(VAR_1) & VAR_32) != 0)
          {
            VAR_14=GetPixelChannelOffset(VAR_1,VAR_34);
            VAR_1->colormap[VAR_28].green=VAR_10[GetPixelChannels(VAR_1)*
              ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].green))+VAR_14];
          }
        if ((GetPixelBlueTraits(VAR_1) & VAR_32) != 0)
          {
            VAR_14=GetPixelChannelOffset(VAR_1,VAR_35);
            VAR_1->colormap[VAR_28].blue=VAR_10[GetPixelChannels(VAR_1)*
              ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].blue))+VAR_14];
          }
        if ((GetPixelAlphaTraits(VAR_1) & VAR_32) != 0)
          {
            VAR_14=GetPixelChannelOffset(VAR_1,VAR_36);
            VAR_1->colormap[VAR_28].alpha=VAR_10[GetPixelChannels(VAR_1)*
              ScaleQuantumToMap(ClampToQuantum(VAR_1->colormap[VAR_28].alpha))+VAR_14];
          }
      }
    }
  /* COMMENT_15 */
                           
    
  VAR_12=VAR_22;
  VAR_13=0;
  VAR_7=AcquireAuthenticCacheView(VAR_1,VAR_4);
#if defined(VAR_37)
  #pragma omp parallel for schedule(static,4) shared(progress,status) \
    magick_threads(image,image,image->rows,1)
#endif
  for (VAR_15=0; VAR_15 < (ssize_t) VAR_1->rows; VAR_15++)
  {
    register Quantum
      *magick_restrict VAR_38;

    register ssize_t
      VAR_24;

    if (VAR_12 == VAR_17)
      continue;
    VAR_38=GetCacheViewAuthenticPixels(VAR_7,0,VAR_15,VAR_1->columns,1,VAR_4);
    if (VAR_38 == (Quantum *) NULL)
      {
        VAR_12=VAR_17;
        continue;
      }
    for (VAR_24=0; VAR_24 < (ssize_t) VAR_1->columns; VAR_24++)
    {
      register ssize_t
        VAR_28;

      if (GetPixelReadMask(VAR_1,VAR_38) == 0)
        {
          VAR_38+=GetPixelChannels(VAR_1);
          continue;
        }
      for (VAR_28=0; VAR_28 < (ssize_t) GetPixelChannels(VAR_1); VAR_28++)
      {
        PixelChannel VAR_39=GetPixelChannelChannel(VAR_1,VAR_28);
        PixelTrait VAR_40=GetPixelChannelTraits(VAR_1,VAR_39);
        if ((VAR_40 & VAR_32) == 0)
          continue;
        VAR_38[VAR_28]=ClampToQuantum(VAR_10[GetPixelChannels(VAR_1)*
          ScaleQuantumToMap(VAR_38[VAR_28])+VAR_28]);
      }
      VAR_38+=GetPixelChannels(VAR_1);
    }
    if (SyncCacheViewAuthenticPixels(VAR_7,VAR_4) == VAR_17)
      VAR_12=VAR_17;
    if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          VAR_41;

#if defined(VAR_37)
        #pragma omp critical (MagickCore_ContrastStretchImage)
#endif
        VAR_41=SetImageProgress(VAR_1,VAR_6,VAR_13++,
          VAR_1->rows);
        if (VAR_41 == VAR_17)
          VAR_12=VAR_17;
      }
  }
  VAR_7=DestroyCacheView(VAR_7);
  VAR_10=(double *) RelinquishMagickMemory(VAR_10);
  VAR_11=(double *) RelinquishMagickMemory(VAR_11);
  VAR_8=(double *) RelinquishMagickMemory(VAR_8);
  return(VAR_12);
}",,"--- func_before
+++ func_after
@@ -34,6 +34,8 @@
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   if (SetImageGray(image,exception) != MagickFalse)
     (void) SetImageColorspace(image,GRAYColorspace,exception);
+  if (SyncImagePixelCache(image,exception) == MagickFalse)
+    return(MagickFalse);
   black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));
   white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white));
   histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*","{'deleted_lines': [], 'added_lines': ['  if (SyncImagePixelCache(image,exception) == MagickFalse)', '    return(MagickFalse);']}",True,Buffer overflow in MagickCore/enhance.c in ImageMagick before 7.0.2-7 allows remote attackers to have unspecified impact via vectors related to pixel cache morphology.,9.1,CRITICAL,3,valid,2016-08-01T16:16:49Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static String HHVM_FUNCTION(bcsub, const String& left, const String& right,
int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second, result;
bc_init_num(&first);
bc_init_num(&second);
bc_init_num(&result);
php_str2num(&first, (char*)left.data());
php_str2num(&second, (char*)right.data());
bc_sub(first, second, &result, scale);
if (result->n_scale > scale) {
result->n_scale = scale;
}
String ret(bc_num2str(result), AttachString);
bc_free_num(&first);
bc_free_num(&second);
bc_free_num(&result);
return ret;
}","static String HHVM_FUNCTION(bcsub, const String& VAR_0, const String& VAR_1,
int64_t VAR_2 ) {
if (VAR_2 < 0) VAR_2 = BCG(VAR_3);
bc_num VAR_4, VAR_5, VAR_6;
bc_init_num(&VAR_4);
bc_init_num(&VAR_5);
bc_init_num(&VAR_6);
php_str2num(&VAR_4, (char*)VAR_0.data());
php_str2num(&VAR_5, (char*)VAR_1.data());
bc_sub(VAR_4, VAR_5, &VAR_6, VAR_2);
if (VAR_6->n_scale > VAR_2) {
VAR_6->n_scale = VAR_2;
}
String ret(bc_num2str(result), AttachString);
bc_free_num(&VAR_4);
bc_free_num(&VAR_5);
bc_free_num(&result);
return VAR_7;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/before/4.json,"static String HHVM_FUNCTION(bcsub, const String& left, const String& right,
                            int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num first, second, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&result);
  php_str2num(&first, (char*)left.data());
  php_str2num(&second, (char*)right.data());
  bc_sub(first, second, &result, scale);
  if (result->n_scale > scale) {
    result->n_scale = scale;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&first);
  bc_free_num(&second);
  bc_free_num(&result);
  return ret;
}","static String HHVM_FUNCTION(bcsub, const String& VAR_0, const String& VAR_1,
                            int64_t VAR_2 /* COMMENT_0 */) {
  VAR_2 = adjust_scale(VAR_2);
  bc_num VAR_3, VAR_4, VAR_5;
  bc_init_num(&VAR_3);
  bc_init_num(&VAR_4);
  bc_init_num(&VAR_5);
  php_str2num(&VAR_3, (char*)VAR_0.data());
  php_str2num(&VAR_4, (char*)VAR_1.data());
  bc_sub(VAR_3, VAR_4, &VAR_5, VAR_2);
  if (VAR_5->n_scale > VAR_2) {
    VAR_5->n_scale = VAR_2;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&VAR_3);
  bc_free_num(&VAR_4);
  bc_free_num(&result);
  return VAR_6;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static String HHVM_FUNCTION(bcsub, const String& left, const String& right,
                             int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static String HHVM_FUNCTION(bcmul, const String& left, const String& right,
int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second, result;
bc_init_num(&first);
bc_init_num(&second);
bc_init_num(&result);
php_str2num(&first, (char*)left.data());
php_str2num(&second, (char*)right.data());
bc_multiply(first, second, &result, scale);
if (result->n_scale > scale) {
result->n_scale = scale;
}
String ret(bc_num2str(result), AttachString);
bc_free_num(&first);
bc_free_num(&second);
bc_free_num(&result);
return ret;
}","static String HHVM_FUNCTION(bcmul, const String& VAR_0, const String& VAR_1,
int64_t VAR_2 ) {
if (VAR_2 < 0) VAR_2 = BCG(VAR_3);
bc_num VAR_4, VAR_5, VAR_6;
bc_init_num(&VAR_4);
bc_init_num(&VAR_5);
bc_init_num(&VAR_6);
php_str2num(&VAR_4, (char*)VAR_0.data());
php_str2num(&VAR_5, (char*)VAR_1.data());
bc_multiply(VAR_4, VAR_5, &VAR_6, VAR_2);
if (VAR_6->n_scale > VAR_2) {
VAR_6->n_scale = VAR_2;
}
String ret(bc_num2str(result), AttachString);
bc_free_num(&VAR_4);
bc_free_num(&VAR_5);
bc_free_num(&result);
return VAR_7;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/before/6.json,"static String HHVM_FUNCTION(bcmul, const String& left, const String& right,
                            int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num first, second, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&result);
  php_str2num(&first, (char*)left.data());
  php_str2num(&second, (char*)right.data());
  bc_multiply(first, second, &result, scale);
  if (result->n_scale > scale) {
    result->n_scale = scale;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&first);
  bc_free_num(&second);
  bc_free_num(&result);
  return ret;
}","static String HHVM_FUNCTION(bcmul, const String& VAR_0, const String& VAR_1,
                            int64_t VAR_2 /* COMMENT_0 */) {
  VAR_2 = adjust_scale(VAR_2);
  bc_num VAR_3, VAR_4, VAR_5;
  bc_init_num(&VAR_3);
  bc_init_num(&VAR_4);
  bc_init_num(&VAR_5);
  php_str2num(&VAR_3, (char*)VAR_0.data());
  php_str2num(&VAR_4, (char*)VAR_1.data());
  bc_multiply(VAR_3, VAR_4, &VAR_5, VAR_2);
  if (VAR_5->n_scale > VAR_2) {
    VAR_5->n_scale = VAR_2;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&VAR_3);
  bc_free_num(&VAR_4);
  bc_free_num(&result);
  return VAR_6;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/after/6.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static String HHVM_FUNCTION(bcmul, const String& left, const String& right,
                             int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static Variant HHVM_FUNCTION(bcdiv, const String& left, const String& right,
int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second, result;
bc_init_num(&first);
bc_init_num(&second);
bc_init_num(&result);
SCOPE_EXIT {
bc_free_num(&first);
bc_free_num(&second);
bc_free_num(&result);
}","static Variant HHVM_FUNCTION(bcdiv, const String& VAR_0, const String& VAR_1,
int64_t VAR_2 ) {
if (VAR_2 < 0) VAR_2 = BCG(VAR_3);
bc_num VAR_4, VAR_5, VAR_6;
bc_init_num(&VAR_4);
bc_init_num(&VAR_5);
bc_init_num(&VAR_6);
SCOPE_EXIT {
bc_free_num(&VAR_4);
bc_free_num(&VAR_5);
bc_free_num(&VAR_6);
}",,"static Variant HHVM_FUNCTION(bcdiv, const String& left, const String& right,
               int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num first, second, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&result);
  SCOPE_EXIT {
    bc_free_num(&first);
    bc_free_num(&second);
    bc_free_num(&result);
  }","static Variant HHVM_FUNCTION(bcdiv, const String& VAR_0, const String& VAR_1,
               int64_t VAR_2 /* COMMENT_0 */) {
  VAR_2 = adjust_scale(VAR_2);
  bc_num VAR_3, VAR_4, VAR_5;
  bc_init_num(&VAR_3);
  bc_init_num(&VAR_4);
  bc_init_num(&VAR_5);
  SCOPE_EXIT {
    bc_free_num(&VAR_3);
    bc_free_num(&VAR_4);
    bc_free_num(&VAR_5);
  }",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static Variant HHVM_FUNCTION(bcdiv, const String& left, const String& right,
                int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static Variant HHVM_FUNCTION(bcsqrt, const String& operand,
int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num result;
bc_init_num(&result);
SCOPE_EXIT {
bc_free_num(&result);
};
php_str2num(&result, (char*)operand.data());
Variant ret;
if (bc_sqrt(&result, scale) != 0) {
if (result->n_scale > scale) {
result->n_scale = scale;
}
ret = String(bc_num2str(result), AttachString);
} else {
raise_warning(""Square root of negative number"");
}
return ret;
}","static Variant HHVM_FUNCTION(bcsqrt, const String& VAR_0,
int64_t VAR_1 ) {
if (VAR_1 < 0) VAR_1 = BCG(VAR_2);
bc_num VAR_3;
bc_init_num(&VAR_3);
SCOPE_EXIT {
bc_free_num(&VAR_3);
};
php_str2num(&VAR_3, (char*)VAR_0.data());
Variant VAR_4;
if (bc_sqrt(&VAR_3, VAR_1) != 0) {
if (VAR_3->n_scale > VAR_1) {
VAR_3->n_scale = VAR_1;
}
VAR_4 = String(bc_num2str(VAR_3), VAR_5);
} else {
raise_warning(""Square root of negative number"");
}
return VAR_4;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/before/1.json,"static Variant HHVM_FUNCTION(bcsqrt, const String& operand,
                             int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num result;
  bc_init_num(&result);
  SCOPE_EXIT {
    bc_free_num(&result);
  };
  php_str2num(&result, (char*)operand.data());
  Variant ret;
  if (bc_sqrt(&result, scale) != 0) {
    if (result->n_scale > scale) {
      result->n_scale = scale;
    }
    ret = String(bc_num2str(result), AttachString);
  } else {
    raise_warning(""Square root of negative number"");
  }
  return ret;
}","static Variant HHVM_FUNCTION(bcsqrt, const String& VAR_0,
                             int64_t VAR_1 /* COMMENT_0 */) {
  VAR_1 = adjust_scale(VAR_1);
  bc_num VAR_2;
  bc_init_num(&VAR_2);
  SCOPE_EXIT {
    bc_free_num(&VAR_2);
  };
  php_str2num(&VAR_2, (char*)VAR_0.data());
  Variant VAR_3;
  if (bc_sqrt(&VAR_2, VAR_1) != 0) {
    if (VAR_2->n_scale > VAR_1) {
      VAR_2->n_scale = VAR_1;
    }
    VAR_3 = String(bc_num2str(VAR_2), VAR_4);
  } else {
    raise_warning(""Square root of negative number"");
  }
  return VAR_3;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static Variant HHVM_FUNCTION(bcsqrt, const String& operand,
                              int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num result;
   bc_init_num(&result);
   SCOPE_EXIT {","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second, result;
bc_init_num(&first);
bc_init_num(&second);
bc_init_num(&result);
php_str2num(&first, (char*)left.data());
php_str2num(&second, (char*)right.data());
bc_add(first, second, &result, scale);
if (result->n_scale > scale) {
result->n_scale = scale;
}
String ret(bc_num2str(result), AttachString);
bc_free_num(&first);
bc_free_num(&second);
bc_free_num(&result);
return ret;
}","static String HHVM_FUNCTION(bcadd, const String& VAR_0, const String& VAR_1,
int64_t VAR_2 ) {
if (VAR_2 < 0) VAR_2 = BCG(VAR_3);
bc_num VAR_4, VAR_5, VAR_6;
bc_init_num(&VAR_4);
bc_init_num(&VAR_5);
bc_init_num(&VAR_6);
php_str2num(&VAR_4, (char*)VAR_0.data());
php_str2num(&VAR_5, (char*)VAR_1.data());
bc_add(VAR_4, VAR_5, &VAR_6, VAR_2);
if (VAR_6->n_scale > VAR_2) {
VAR_6->n_scale = VAR_2;
}
String ret(bc_num2str(result), AttachString);
bc_free_num(&VAR_4);
bc_free_num(&VAR_5);
bc_free_num(&result);
return VAR_7;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/before/2.json,"static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
                            int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num first, second, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&result);
  php_str2num(&first, (char*)left.data());
  php_str2num(&second, (char*)right.data());
  bc_add(first, second, &result, scale);
  if (result->n_scale > scale) {
    result->n_scale = scale;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&first);
  bc_free_num(&second);
  bc_free_num(&result);
  return ret;
}","static String HHVM_FUNCTION(bcadd, const String& VAR_0, const String& VAR_1,
                            int64_t VAR_2 /* COMMENT_0 */) {
  VAR_2 = adjust_scale(VAR_2);
  bc_num VAR_3, VAR_4, VAR_5;
  bc_init_num(&VAR_3);
  bc_init_num(&VAR_4);
  bc_init_num(&VAR_5);
  php_str2num(&VAR_3, (char*)VAR_0.data());
  php_str2num(&VAR_4, (char*)VAR_1.data());
  bc_add(VAR_3, VAR_4, &VAR_5, VAR_2);
  if (VAR_5->n_scale > VAR_2) {
    VAR_5->n_scale = VAR_2;
  }
  String ret(bc_num2str(result), AttachString);
  bc_free_num(&VAR_3);
  bc_free_num(&VAR_4);
  bc_free_num(&result);
  return VAR_6;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
                             int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,
int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second;
bc_init_num(&first);
bc_init_num(&second);
bc_str2num(&first, (char*)left.data(), scale);
bc_str2num(&second, (char*)right.data(), scale);
int64_t ret = bc_compare(first, second);
bc_free_num(&first);
bc_free_num(&second);
return ret;
}","static int64_t HHVM_FUNCTION(bccomp, const String& VAR_0, const String& VAR_1,
int64_t VAR_2 ) {
if (VAR_2 < 0) VAR_2 = BCG(VAR_3);
bc_num VAR_4, VAR_5;
bc_init_num(&VAR_4);
bc_init_num(&VAR_5);
bc_str2num(&VAR_4, (char*)VAR_0.data(), VAR_2);
bc_str2num(&VAR_5, (char*)VAR_1.data(), VAR_2);
int64_t VAR_6 = bc_compare(VAR_4, VAR_5);
bc_free_num(&VAR_4);
bc_free_num(&VAR_5);
return VAR_6;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/before/5.json,"static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,
                             int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num first, second;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_str2num(&first, (char*)left.data(), scale);
  bc_str2num(&second, (char*)right.data(), scale);
  int64_t ret = bc_compare(first, second);
  bc_free_num(&first);
  bc_free_num(&second);
  return ret;
}","static int64_t HHVM_FUNCTION(bccomp, const String& VAR_0, const String& VAR_1,
                             int64_t VAR_2 /* COMMENT_0 */) {
  VAR_2 = adjust_scale(VAR_2);
  bc_num VAR_3, VAR_4;
  bc_init_num(&VAR_3);
  bc_init_num(&VAR_4);
  bc_str2num(&VAR_3, (char*)VAR_0.data(), VAR_2);
  bc_str2num(&VAR_4, (char*)VAR_1.data(), VAR_2);
  int64_t VAR_5 = bc_compare(VAR_3, VAR_4);
  bc_free_num(&VAR_3);
  bc_free_num(&VAR_4);
  return VAR_5;
}",facebook/hhvm/c00fc9d3003eb06226b58b6a48555f1456ee2475/ext_bcmath.cpp/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,
                              int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num first, second;
   bc_init_num(&first);
   bc_init_num(&second);","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static String HHVM_FUNCTION(bcpow, const String& left, const String& right,
int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second, result;
bc_init_num(&first);
bc_init_num(&second);
bc_init_num(&result);
SCOPE_EXIT {
bc_free_num(&first);
bc_free_num(&second);
bc_free_num(&result);
}","static String HHVM_FUNCTION(bcpow, const String& VAR_0, const String& VAR_1,
int64_t VAR_2 ) {
if (VAR_2 < 0) VAR_2 = BCG(VAR_3);
bc_num VAR_4, VAR_5, VAR_6;
bc_init_num(&VAR_4);
bc_init_num(&VAR_5);
bc_init_num(&VAR_6);
SCOPE_EXIT {
bc_free_num(&VAR_4);
bc_free_num(&VAR_5);
bc_free_num(&VAR_6);
}",,"static String HHVM_FUNCTION(bcpow, const String& left, const String& right,
                           int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num first, second, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&result);
  SCOPE_EXIT {
    bc_free_num(&first);
    bc_free_num(&second);
    bc_free_num(&result);
  }","static String HHVM_FUNCTION(bcpow, const String& VAR_0, const String& VAR_1,
                           int64_t VAR_2 /* COMMENT_0 */) {
  VAR_2 = adjust_scale(VAR_2);
  bc_num VAR_3, VAR_4, VAR_5;
  bc_init_num(&VAR_3);
  bc_init_num(&VAR_4);
  bc_init_num(&VAR_5);
  SCOPE_EXIT {
    bc_free_num(&VAR_3);
    bc_free_num(&VAR_4);
    bc_free_num(&VAR_5);
  }",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static String HHVM_FUNCTION(bcpow, const String& left, const String& right,
                            int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-6871,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,facebook/hhvm,"Fix buffer overrun due to integer overflow in bcmath

Summary: scale gets passed around as an int inside the library.

Reviewed By: mxw

Differential Revision: D3624520

fbshipit-source-id: d39927413cec24fda2e475a296ad5d9019ccef0a",c00fc9d3003eb06226b58b6a48555f1456ee2475,https://github.com/facebook/hhvm/commit/c00fc9d3003eb06226b58b6a48555f1456ee2475,hphp/runtime/ext/bcmath/ext_bcmath.cpp,HHVM_FUNCTION,"static Variant HHVM_FUNCTION(bcpowmod, const String& left, const String& right,
const String& modulus, int64_t scale ) {
if (scale < 0) scale = BCG(bc_precision);
bc_num first, second, mod, result;
bc_init_num(&first);
bc_init_num(&second);
bc_init_num(&mod);
bc_init_num(&result);
SCOPE_EXIT {
bc_free_num(&first);
bc_free_num(&second);
bc_free_num(&mod);
bc_free_num(&result);
}","static Variant HHVM_FUNCTION(bcpowmod, const String& VAR_0, const String& VAR_1,
const String& VAR_2, int64_t VAR_3 ) {
if (VAR_3 < 0) VAR_3 = BCG(VAR_4);
bc_num VAR_5, VAR_6, VAR_7, VAR_8;
bc_init_num(&VAR_5);
bc_init_num(&VAR_6);
bc_init_num(&VAR_7);
bc_init_num(&VAR_8);
SCOPE_EXIT {
bc_free_num(&VAR_5);
bc_free_num(&VAR_6);
bc_free_num(&VAR_7);
bc_free_num(&VAR_8);
}",,"static Variant HHVM_FUNCTION(bcpowmod, const String& left, const String& right,
                             const String& modulus, int64_t scale /* = -1 */) {
  scale = adjust_scale(scale);
  bc_num first, second, mod, result;
  bc_init_num(&first);
  bc_init_num(&second);
  bc_init_num(&mod);
  bc_init_num(&result);
  SCOPE_EXIT {
    bc_free_num(&first);
    bc_free_num(&second);
    bc_free_num(&mod);
    bc_free_num(&result);
  }","static Variant HHVM_FUNCTION(bcpowmod, const String& VAR_0, const String& VAR_1,
                             const String& VAR_2, int64_t VAR_3 /* COMMENT_0 */) {
  VAR_3 = adjust_scale(VAR_3);
  bc_num VAR_4, VAR_5, VAR_6, VAR_7;
  bc_init_num(&VAR_4);
  bc_init_num(&VAR_5);
  bc_init_num(&VAR_6);
  bc_init_num(&VAR_7);
  SCOPE_EXIT {
    bc_free_num(&VAR_4);
    bc_free_num(&VAR_5);
    bc_free_num(&VAR_6);
    bc_free_num(&VAR_7);
  }",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static Variant HHVM_FUNCTION(bcpowmod, const String& left, const String& right,
                              const String& modulus, int64_t scale /* = -1 */) {
-  if (scale < 0) scale = BCG(bc_precision);
+  scale = adjust_scale(scale);
   bc_num first, second, mod, result;
   bc_init_num(&first);
   bc_init_num(&second);","{'deleted_lines': ['  if (scale < 0) scale = BCG(bc_precision);'], 'added_lines': ['  scale = adjust_scale(scale);']}",True,"Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.",9.8,CRITICAL,3,valid,2016-08-01T22:13:10Z,1
CVE-2016-7124,['CWE-502'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72663 - destroy broken object when unserializing,c1cfd6a9fe23765191ea2f654790c7b127d4b797,https://github.com/php/php-src/commit/c1cfd6a9fe23765191ea2f654790c7b127d4b797,ext/standard/var_unserializer.c,object_common1,"static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
{
long elements;
elements = parse_iv2((*p) + 2, p);
(*p) += 2;
if (ce->serialize == NULL) {
object_init_ex(*rval, ce);
} else {
zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name);
return 0;
}
return elements;
}","static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *VAR_0)
{
long VAR_1;
VAR_1 = parse_iv2((*VAR_2) + 2, VAR_2);
(*VAR_2) += 2;
if (VAR_0->serialize == NULL) {
object_init_ex(*VAR_3, VAR_0);
} else {
zend_error(VAR_4, ""Erroneous data format for unserializing '%s'"", VAR_0->name);
return 0;
}
return VAR_1;
}",php/php-src/c1cfd6a9fe23765191ea2f654790c7b127d4b797/var_unserializer.c/vul/before/0.json,"static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
{
	long elements;

	elements = parse_iv2((*p) + 2, p);

	(*p) += 2;

	if (ce->serialize == NULL) {
		object_init_ex(*rval, ce);
	} else {
		/* If this class implements Serializable, it should not land here but in object_custom(). The passed string
		obviously doesn't descend from the regular serializer. */
		zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name);
		return 0;
	}

	return elements;
}","static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *VAR_0)
{
	long VAR_1;

	VAR_1 = parse_iv2((*VAR_2) + 2, VAR_2);

	(*VAR_2) += 2;

	if (VAR_0->serialize == NULL) {
		object_init_ex(*VAR_3, VAR_0);
	} else {
		/* COMMENT_0 */
                                                           
		zend_error(VAR_4, ""Erroneous data format for unserializing '%s'"", VAR_0->name);
		return 0;
	}

	return VAR_1;
}",php/php-src/c1cfd6a9fe23765191ea2f654790c7b127d4b797/var_unserializer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	elements = parse_iv2((*p) + 2, p);
 
 	(*p) += 2;
-	
+
 	if (ce->serialize == NULL) {
 		object_init_ex(*rval, ce);
 	} else {","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",9.8,CRITICAL,3,valid,2016-08-02T08:08:42Z,1
CVE-2016-7124,['CWE-502'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72663 - destroy broken object when unserializing,448c9be157f4147e121f1a2a524536c75c9c6059,https://github.com/php/php-src/commit/448c9be157f4147e121f1a2a524536c75c9c6059,ext/standard/var_unserializer.c,object_common2,"static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)
{
zval *retval_ptr = NULL;
zval fname;
if (Z_TYPE_PP(rval) != IS_OBJECT) {
return 0;
}
if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
return 0;
}
if (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&
zend_hash_exists(&Z_OBJCE_PP(rval)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
INIT_PZVAL(&fname);
ZVAL_STRINGL(&fname, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
BG(serialize_lock)++;
call_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);
BG(serialize_lock)--;
}
if (retval_ptr) {
zval_ptr_dtor(&retval_ptr);
}
if (EG(exception)) {
return 0;
}
return finish_nested_data(UNSERIALIZE_PASSTHRU);
}","static inline int object_common2(UNSERIALIZE_PARAMETER, long VAR_0)
{
zval *VAR_1 = NULL;
zval VAR_2;
if (Z_TYPE_PP(VAR_3) != VAR_4) {
return 0;
}
if (!process_nested_data(VAR_5, Z_OBJPROP_PP(VAR_3), VAR_0, 1)) {
return 0;
}
if (Z_OBJCE_PP(VAR_3) != VAR_6 &&
zend_hash_exists(&Z_OBJCE_PP(VAR_3)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
INIT_PZVAL(&VAR_2);
ZVAL_STRINGL(&VAR_2, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
BG(VAR_7)++;
call_user_function_ex(CG(VAR_8), VAR_3, &VAR_2, &VAR_1, 0, 0, 1, NULL VAR_9);
BG(VAR_7)--;
}
if (VAR_1) {
zval_ptr_dtor(&VAR_1);
}
if (EG(VAR_10)) {
return 0;
}
return finish_nested_data(VAR_5);
}",php/php-src/448c9be157f4147e121f1a2a524536c75c9c6059/var_unserializer.c/vul/before/1.json,"static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)
{
	zval *retval_ptr = NULL;
	zval fname;

	if (Z_TYPE_PP(rval) != IS_OBJECT) {
		return 0;
	}

	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
	    /* We've got partially constructed object on our hands here. Wipe it */
	    zend_hash_clean(Z_OBJPROP_PP(rval));
	    ZVAL_NULL(*rval);
		return 0;
	}

	if (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&
		zend_hash_exists(&Z_OBJCE_PP(rval)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
		INIT_PZVAL(&fname);
		ZVAL_STRINGL(&fname, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
		BG(serialize_lock)++;
		call_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);
		BG(serialize_lock)--;
	}

	if (retval_ptr) {
		zval_ptr_dtor(&retval_ptr);
	}

	if (EG(exception)) {
		return 0;
	}

	return finish_nested_data(UNSERIALIZE_PASSTHRU);

}","static inline int object_common2(UNSERIALIZE_PARAMETER, long VAR_0)
{
	zval *VAR_1 = NULL;
	zval VAR_2;

	if (Z_TYPE_PP(VAR_3) != VAR_4) {
		return 0;
	}

	if (!process_nested_data(VAR_5, Z_OBJPROP_PP(VAR_3), VAR_0, 1)) {
	    /* COMMENT_0 */
	    zend_hash_clean(Z_OBJPROP_PP(VAR_3));
	    ZVAL_NULL(*VAR_3);
		return 0;
	}

	if (Z_OBJCE_PP(VAR_3) != VAR_6 &&
		zend_hash_exists(&Z_OBJCE_PP(VAR_3)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
		INIT_PZVAL(&VAR_2);
		ZVAL_STRINGL(&VAR_2, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
		BG(VAR_7)++;
		call_user_function_ex(CG(VAR_8), VAR_3, &VAR_2, &VAR_1, 0, 0, 1, NULL VAR_9);
		BG(VAR_7)--;
	}

	if (VAR_1) {
		zval_ptr_dtor(&VAR_1);
	}

	if (EG(VAR_10)) {
		return 0;
	}

	return finish_nested_data(VAR_5);

}",php/php-src/448c9be157f4147e121f1a2a524536c75c9c6059/var_unserializer.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
 	}
 
 	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
+	    /* We've got partially constructed object on our hands here. Wipe it */
+	    zend_hash_clean(Z_OBJPROP_PP(rval));
+	    ZVAL_NULL(*rval);
 		return 0;
 	}
 ","{'deleted_lines': [], 'added_lines': [""\t    /* We've got partially constructed object on our hands here. Wipe it */"", '\t    zend_hash_clean(Z_OBJPROP_PP(rval));', '\t    ZVAL_NULL(*rval);']}",True,"ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",9.8,CRITICAL,3,valid,2016-08-02T08:08:42Z,1
CVE-2016-7124,['CWE-502'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72663 - destroy broken object when unserializing,c1cfd6a9fe23765191ea2f654790c7b127d4b797,https://github.com/php/php-src/commit/c1cfd6a9fe23765191ea2f654790c7b127d4b797,ext/standard/var_unserializer.c,object_common2,"static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)
{
zval *retval_ptr = NULL;
zval fname;
if (Z_TYPE_PP(rval) != IS_OBJECT) {
return 0;
}
if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
return 0;
}
if (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&
zend_hash_exists(&Z_OBJCE_PP(rval)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
INIT_PZVAL(&fname);
ZVAL_STRINGL(&fname, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
BG(serialize_lock)++;
call_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);
BG(serialize_lock)--;
}
if (retval_ptr) {
zval_ptr_dtor(&retval_ptr);
}
if (EG(exception)) {
return 0;
}
return finish_nested_data(UNSERIALIZE_PASSTHRU);
}","static inline int object_common2(UNSERIALIZE_PARAMETER, long VAR_0)
{
zval *VAR_1 = NULL;
zval VAR_2;
if (Z_TYPE_PP(VAR_3) != VAR_4) {
return 0;
}
if (!process_nested_data(VAR_5, Z_OBJPROP_PP(VAR_3), VAR_0, 1)) {
return 0;
}
if (Z_OBJCE_PP(VAR_3) != VAR_6 &&
zend_hash_exists(&Z_OBJCE_PP(VAR_3)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
INIT_PZVAL(&VAR_2);
ZVAL_STRINGL(&VAR_2, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
BG(VAR_7)++;
call_user_function_ex(CG(VAR_8), VAR_3, &VAR_2, &VAR_1, 0, 0, 1, NULL VAR_9);
BG(VAR_7)--;
}
if (VAR_1) {
zval_ptr_dtor(&VAR_1);
}
if (EG(VAR_10)) {
return 0;
}
return finish_nested_data(VAR_5);
}",php/php-src/c1cfd6a9fe23765191ea2f654790c7b127d4b797/var_unserializer.c/vul/before/1.json,"static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)
{
	zval *retval_ptr = NULL;
	zval fname;

	if (Z_TYPE_PP(rval) != IS_OBJECT) {
		return 0;
	}

	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
	    /* We've got partially constructed object on our hands here. Wipe it */
	    zend_hash_clean(Z_OBJPROP_PP(rval));
	    ZVAL_NULL(*rval);
		return 0;
	}

	if (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&
		zend_hash_exists(&Z_OBJCE_PP(rval)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
		INIT_PZVAL(&fname);
		ZVAL_STRINGL(&fname, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
		BG(serialize_lock)++;
		call_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);
		BG(serialize_lock)--;
	}

	if (retval_ptr) {
		zval_ptr_dtor(&retval_ptr);
	}

	if (EG(exception)) {
		return 0;
	}

	return finish_nested_data(UNSERIALIZE_PASSTHRU);

}","static inline int object_common2(UNSERIALIZE_PARAMETER, long VAR_0)
{
	zval *VAR_1 = NULL;
	zval VAR_2;

	if (Z_TYPE_PP(VAR_3) != VAR_4) {
		return 0;
	}

	if (!process_nested_data(VAR_5, Z_OBJPROP_PP(VAR_3), VAR_0, 1)) {
	    /* COMMENT_0 */
	    zend_hash_clean(Z_OBJPROP_PP(VAR_3));
	    ZVAL_NULL(*VAR_3);
		return 0;
	}

	if (Z_OBJCE_PP(VAR_3) != VAR_6 &&
		zend_hash_exists(&Z_OBJCE_PP(VAR_3)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
		INIT_PZVAL(&VAR_2);
		ZVAL_STRINGL(&VAR_2, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
		BG(VAR_7)++;
		call_user_function_ex(CG(VAR_8), VAR_3, &VAR_2, &VAR_1, 0, 0, 1, NULL VAR_9);
		BG(VAR_7)--;
	}

	if (VAR_1) {
		zval_ptr_dtor(&VAR_1);
	}

	if (EG(VAR_10)) {
		return 0;
	}

	return finish_nested_data(VAR_5);

}",php/php-src/c1cfd6a9fe23765191ea2f654790c7b127d4b797/var_unserializer.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
 	}
 
 	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
+	    /* We've got partially constructed object on our hands here. Wipe it */
+	    zend_hash_clean(Z_OBJPROP_PP(rval));
+	    ZVAL_NULL(*rval);
 		return 0;
 	}
 ","{'deleted_lines': [], 'added_lines': [""\t    /* We've got partially constructed object on our hands here. Wipe it */"", '\t    zend_hash_clean(Z_OBJPROP_PP(rval));', '\t    ZVAL_NULL(*rval);']}",True,"ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",9.8,CRITICAL,3,valid,2016-08-02T08:08:42Z,1
CVE-2016-7124,['CWE-502'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72663 - destroy broken object when unserializing,448c9be157f4147e121f1a2a524536c75c9c6059,https://github.com/php/php-src/commit/448c9be157f4147e121f1a2a524536c75c9c6059,ext/standard/var_unserializer.c,object_common1,"static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
{
long elements;
elements = parse_iv2((*p) + 2, p);
(*p) += 2;
if (ce->serialize == NULL) {
object_init_ex(*rval, ce);
} else {
zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name);
return 0;
}
return elements;
}","static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *VAR_0)
{
long VAR_1;
VAR_1 = parse_iv2((*VAR_2) + 2, VAR_2);
(*VAR_2) += 2;
if (VAR_0->serialize == NULL) {
object_init_ex(*VAR_3, VAR_0);
} else {
zend_error(VAR_4, ""Erroneous data format for unserializing '%s'"", VAR_0->name);
return 0;
}
return VAR_1;
}",php/php-src/448c9be157f4147e121f1a2a524536c75c9c6059/var_unserializer.c/vul/before/0.json,"static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
{
	long elements;

	elements = parse_iv2((*p) + 2, p);

	(*p) += 2;

	if (ce->serialize == NULL) {
		object_init_ex(*rval, ce);
	} else {
		/* If this class implements Serializable, it should not land here but in object_custom(). The passed string
		obviously doesn't descend from the regular serializer. */
		zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name);
		return 0;
	}

	return elements;
}","static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *VAR_0)
{
	long VAR_1;

	VAR_1 = parse_iv2((*VAR_2) + 2, VAR_2);

	(*VAR_2) += 2;

	if (VAR_0->serialize == NULL) {
		object_init_ex(*VAR_3, VAR_0);
	} else {
		/* COMMENT_0 */
                                                           
		zend_error(VAR_4, ""Erroneous data format for unserializing '%s'"", VAR_0->name);
		return 0;
	}

	return VAR_1;
}",php/php-src/448c9be157f4147e121f1a2a524536c75c9c6059/var_unserializer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	elements = parse_iv2((*p) + 2, p);
 
 	(*p) += 2;
-	
+
 	if (ce->serialize == NULL) {
 		object_init_ex(*rval, ce);
 	} else {","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",9.8,CRITICAL,3,valid,2016-08-02T08:08:42Z,1
CVE-2016-10051,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,Prevent memory use after free,548701354191a3dda5cffc6d415374b35b01d0b9,https://github.com/ImageMagick/ImageMagick/commit/548701354191a3dda5cffc6d415374b35b01d0b9,coders/pwp.c,ReadPWPImage,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
FILE
*file;
Image
*image,
*next_image,
*pwp_image;
ImageInfo
*read_info;
int
c,
unique_file;
MagickBooleanType
status;
register Image
*p;
register ssize_t
i;
size_t
filesize,
length;
ssize_t
count;
unsigned char
magick[MagickPathExtent];
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
pwp_image=AcquireImage(image_info,exception);
image=pwp_image;
status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
return((Image *) NULL);
count=ReadBlob(pwp_image,5,magick);
if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
read_info=CloneImageInfo(image_info);
(void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
(void *) NULL);
SetImageInfoBlob(read_info,(void *) NULL,0);
unique_file=AcquireUniqueFileResource(read_info->filename);
for ( ; ; )
{
for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
{
for (i=0; i < 17; i++)
magick[i]=magick[i+1];
magick[17]=(unsigned char) c;
if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
break;
}
if (c == EOF)
break;
if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
{
(void) RelinquishUniqueFileResource(read_info->filename);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
file=(FILE *) NULL;
if (unique_file != -1)
file=fdopen(unique_file,""wb"");
if ((unique_file == -1) || (file == (FILE *) NULL))
{
(void) RelinquishUniqueFileResource(read_info->filename);
ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
image->filename);
image=DestroyImageList(image);
return((Image *) NULL);
}
length=fwrite(""SFW94A"",1,6,file);
(void) length;
filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
for (i=0; i < (ssize_t) filesize; i++)
{
c=ReadBlobByte(pwp_image);
(void) fputc(c,file);
}
(void) fclose(file);
next_image=ReadImage(read_info,exception);
if (next_image == (Image *) NULL)
break;
(void) FormatLocaleString(next_image->filename,MagickPathExtent,
""slide_%02ld.sfw"",(long) next_image->scene);
if (image == (Image *) NULL)
image=next_image;
else
{
for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
next_image->previous=p;
next_image->scene=p->scene+1;
p->next=next_image;
}
if (image_info->number_scenes != 0)
if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
GetBlobSize(pwp_image));
if (status == MagickFalse)
break;
}
if (unique_file != -1)
(void) close(unique_file);
(void) RelinquishUniqueFileResource(read_info->filename);
read_info=DestroyImageInfo(read_info);
(void) CloseBlob(pwp_image);
pwp_image=DestroyImage(pwp_image);
if (EOFBlob(image) != MagickFalse)
{
char
*message;
message=GetExceptionMessage(errno);
(void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
message=DestroyString(message);
}
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadPWPImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
FILE
*VAR_2;
Image
*VAR_3,
*VAR_4,
*VAR_5;
ImageInfo
*VAR_6;
int
VAR_7,
VAR_8;
MagickBooleanType
VAR_9;
register Image
*VAR_10;
register ssize_t
VAR_11;
size_t
VAR_12,
VAR_13;
ssize_t
VAR_14;
unsigned char
VAR_15[VAR_16];
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_17);
if (VAR_0->debug != VAR_18)
(void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_17);
VAR_5=AcquireImage(VAR_0,VAR_1);
VAR_3=VAR_5;
VAR_9=OpenBlob(VAR_0,VAR_5,VAR_20,VAR_1);
if (VAR_9 == VAR_18)
return((Image *) NULL);
VAR_14=ReadBlob(VAR_5,5,VAR_15);
if ((VAR_14 != 5) || (LocaleNCompare((char *) VAR_15,""SFW95"",5) != 0))
ThrowReaderException(VAR_21,""ImproperImageHeader"");
VAR_6=CloneImageInfo(VAR_0);
(void) SetImageInfoProgressMonitor(VAR_6,(MagickProgressMonitor) NULL,
(void *) NULL);
SetImageInfoBlob(VAR_6,(void *) NULL,0);
VAR_8=AcquireUniqueFileResource(VAR_6->filename);
for ( ; ; )
{
for (VAR_7=ReadBlobByte(VAR_5); VAR_7 != VAR_22; VAR_7=ReadBlobByte(VAR_5))
{
for (VAR_11=0; VAR_11 < 17; VAR_11++)
VAR_15[VAR_11]=VAR_15[VAR_11+1];
VAR_15[17]=(unsigned char) VAR_7;
if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) == 0)
break;
}
if (VAR_7 == VAR_22)
break;
if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) != 0)
{
(void) RelinquishUniqueFileResource(VAR_6->filename);
ThrowReaderException(VAR_21,""ImproperImageHeader"");
}
VAR_2=(FILE *) NULL;
if (VAR_8 != -1)
VAR_2=fdopen(VAR_8,""wb"");
if ((VAR_8 == -1) || (VAR_2 == (FILE *) NULL))
{
(void) RelinquishUniqueFileResource(VAR_6->filename);
ThrowFileException(VAR_1,VAR_23,""UnableToWriteFile"",
VAR_3->filename);
VAR_3=DestroyImageList(VAR_3);
return((Image *) NULL);
}
VAR_13=fwrite(""SFW94A"",1,6,VAR_2);
(void) VAR_13;
VAR_12=65535UL*VAR_15[2]+256L*VAR_15[1]+VAR_15[0];
for (VAR_11=0; VAR_11 < (ssize_t) VAR_12; VAR_11++)
{
VAR_7=ReadBlobByte(VAR_5);
(void) fputc(VAR_7,VAR_2);
}
(void) fclose(VAR_2);
VAR_4=ReadImage(VAR_6,VAR_1);
if (VAR_4 == (Image *) NULL)
break;
(void) FormatLocaleString(VAR_4->filename,VAR_16,
""slide_%02ld.sfw"",(long) VAR_4->scene);
if (VAR_3 == (Image *) NULL)
VAR_3=VAR_4;
else
{
for (VAR_10=VAR_3; VAR_10->next != (Image *) NULL; VAR_10=GetNextImageInList(VAR_10)) ;
VAR_4->previous=VAR_10;
VAR_4->scene=VAR_10->scene+1;
VAR_10->next=VAR_4;
}
if (VAR_0->number_scenes != 0)
if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_9=SetImageProgress(VAR_3,VAR_24,TellBlob(VAR_5),
GetBlobSize(VAR_5));
if (VAR_9 == VAR_18)
break;
}
if (VAR_8 != -1)
(void) close(VAR_8);
(void) RelinquishUniqueFileResource(VAR_6->filename);
VAR_6=DestroyImageInfo(VAR_6);
(void) CloseBlob(VAR_5);
VAR_5=DestroyImage(VAR_5);
if (EOFBlob(VAR_3) != VAR_18)
{
char
*VAR_25;
VAR_25=GetExceptionMessage(VAR_26);
(void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_21,
""UnexpectedEndOfFile"",""`%s': %s"",VAR_3->filename,VAR_25);
VAR_25=DestroyString(VAR_25);
}
(void) CloseBlob(VAR_3);
return(GetFirstImageInList(VAR_3));
}",ImageMagick/548701354191a3dda5cffc6d415374b35b01d0b9/pwp.c/vul/before/0.json,"static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  FILE
    *file;

  Image
    *image,
    *next_image,
    *pwp_image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register Image
    *p;

  register ssize_t
    i;

  size_t
    filesize,
    length;

  ssize_t
    count;

  unsigned char
    magick[MagickPathExtent];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  pwp_image=AcquireImage(image_info,exception);
  image=pwp_image;
  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return((Image *) NULL);
  count=ReadBlob(pwp_image,5,magick);
  if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  read_info=CloneImageInfo(image_info);
  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  unique_file=AcquireUniqueFileResource(read_info->filename);
  for ( ; ; )
  {
    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))
    {
      for (i=0; i < 17; i++)
        magick[i]=magick[i+1];
      magick[17]=(unsigned char) c;
      if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0)
        break;
    }
    if (c == EOF)
      break;
    if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      }
    /*
      Dump SFW image to a temporary file.
    */
    file=(FILE *) NULL;
    if (unique_file != -1)
      file=fdopen(unique_file,""wb"");
    if ((unique_file == -1) || (file == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(read_info->filename);
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    length=fwrite(""SFW94A"",1,6,file);
    (void) length;
    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];
    for (i=0; i < (ssize_t) filesize; i++)
    {
      c=ReadBlobByte(pwp_image);
      (void) fputc(c,file);
    }
    (void) fclose(file);
    next_image=ReadImage(read_info,exception);
    if (next_image == (Image *) NULL)
      break;
    (void) FormatLocaleString(next_image->filename,MagickPathExtent,
      ""slide_%02ld.sfw"",(long) next_image->scene);
    if (image == (Image *) NULL)
      image=next_image;
    else
      {
        /*
          Link image into image list.
        */
        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;
        next_image->previous=p;
        next_image->scene=p->scene+1;
        p->next=next_image;
      }
    if (image_info->number_scenes != 0)
      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),
      GetBlobSize(pwp_image));
    if (status == MagickFalse)
      break;
  }
  if (unique_file != -1)
    (void) close(unique_file);
  (void) RelinquishUniqueFileResource(read_info->filename);
  read_info=DestroyImageInfo(read_info);
  if (EOFBlob(image) != MagickFalse)
    {
      char
        *message;

      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
        ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadPWPImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  FILE
    *VAR_2;

  Image
    *VAR_3,
    *VAR_4,
    *VAR_5;

  ImageInfo
    *VAR_6;

  int
    VAR_7,
    VAR_8;

  MagickBooleanType
    VAR_9;

  register Image
    *VAR_10;

  register ssize_t
    VAR_11;

  size_t
    VAR_12,
    VAR_13;

  ssize_t
    VAR_14;

  unsigned char
    VAR_15[VAR_16];

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  if (VAR_0->debug != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_17);
  VAR_5=AcquireImage(VAR_0,VAR_1);
  VAR_3=VAR_5;
  VAR_9=OpenBlob(VAR_0,VAR_5,VAR_20,VAR_1);
  if (VAR_9 == VAR_18)
    return((Image *) NULL);
  VAR_14=ReadBlob(VAR_5,5,VAR_15);
  if ((VAR_14 != 5) || (LocaleNCompare((char *) VAR_15,""SFW95"",5) != 0))
    ThrowReaderException(VAR_21,""ImproperImageHeader"");
  VAR_6=CloneImageInfo(VAR_0);
  (void) SetImageInfoProgressMonitor(VAR_6,(MagickProgressMonitor) NULL,
    (void *) NULL);
  SetImageInfoBlob(VAR_6,(void *) NULL,0);
  VAR_8=AcquireUniqueFileResource(VAR_6->filename);
  for ( ; ; )
  {
    for (VAR_7=ReadBlobByte(VAR_5); VAR_7 != VAR_22; VAR_7=ReadBlobByte(VAR_5))
    {
      for (VAR_11=0; VAR_11 < 17; VAR_11++)
        VAR_15[VAR_11]=VAR_15[VAR_11+1];
      VAR_15[17]=(unsigned char) VAR_7;
      if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) == 0)
        break;
    }
    if (VAR_7 == VAR_22)
      break;
    if (LocaleNCompare((char *) (VAR_15+12),""SFW94A"",6) != 0)
      {
        (void) RelinquishUniqueFileResource(VAR_6->filename);
        ThrowReaderException(VAR_21,""ImproperImageHeader"");
      }
    /* COMMENT_3 */
                                         
      
    VAR_2=(FILE *) NULL;
    if (VAR_8 != -1)
      VAR_2=fdopen(VAR_8,""wb"");
    if ((VAR_8 == -1) || (VAR_2 == (FILE *) NULL))
      {
        (void) RelinquishUniqueFileResource(VAR_6->filename);
        ThrowFileException(VAR_1,VAR_23,""UnableToWriteFile"",
          VAR_3->filename);
        VAR_3=DestroyImageList(VAR_3);
        return((Image *) NULL);
      }
    VAR_13=fwrite(""SFW94A"",1,6,VAR_2);
    (void) VAR_13;
    VAR_12=65535UL*VAR_15[2]+256L*VAR_15[1]+VAR_15[0];
    for (VAR_11=0; VAR_11 < (ssize_t) VAR_12; VAR_11++)
    {
      VAR_7=ReadBlobByte(VAR_5);
      (void) fputc(VAR_7,VAR_2);
    }
    (void) fclose(VAR_2);
    VAR_4=ReadImage(VAR_6,VAR_1);
    if (VAR_4 == (Image *) NULL)
      break;
    (void) FormatLocaleString(VAR_4->filename,VAR_16,
      ""slide_%02ld.sfw"",(long) VAR_4->scene);
    if (VAR_3 == (Image *) NULL)
      VAR_3=VAR_4;
    else
      {
        /* COMMENT_6 */
                                     
          
        for (VAR_10=VAR_3; VAR_10->next != (Image *) NULL; VAR_10=GetNextImageInList(VAR_10)) ;
        VAR_4->previous=VAR_10;
        VAR_4->scene=VAR_10->scene+1;
        VAR_10->next=VAR_4;
      }
    if (VAR_0->number_scenes != 0)
      if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_9=SetImageProgress(VAR_3,VAR_24,TellBlob(VAR_5),
      GetBlobSize(VAR_5));
    if (VAR_9 == VAR_18)
      break;
  }
  if (VAR_8 != -1)
    (void) close(VAR_8);
  (void) RelinquishUniqueFileResource(VAR_6->filename);
  VAR_6=DestroyImageInfo(VAR_6);
  if (EOFBlob(VAR_3) != VAR_18)
    {
      char
        *VAR_25;

      VAR_25=GetExceptionMessage(VAR_26);
      (void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_21,
        ""UnexpectedEndOfFile"",""`%s': %s"",VAR_3->filename,VAR_25);
      VAR_25=DestroyString(VAR_25);
    }
  (void) CloseBlob(VAR_3);
  return(GetFirstImageInList(VAR_3));
}",ImageMagick/548701354191a3dda5cffc6d415374b35b01d0b9/pwp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -126,8 +126,6 @@
     (void) close(unique_file);
   (void) RelinquishUniqueFileResource(read_info->filename);
   read_info=DestroyImageInfo(read_info);
-  (void) CloseBlob(pwp_image);
-  pwp_image=DestroyImage(pwp_image);
   if (EOFBlob(image) != MagickFalse)
     {
       char","{'deleted_lines': ['  (void) CloseBlob(pwp_image);', '  pwp_image=DestroyImage(pwp_image);'], 'added_lines': []}",True,Use-after-free vulnerability in the ReadPWPImage function in coders/pwp.c in ImageMagick 6.9.5-5 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.,7.8,HIGH,2,valid,2016-08-05T20:35:07Z,1
CVE-2016-7175,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"qnet6: fix display of MAC addresses and avoid overflow

The MAC address is binary data, do not use tvb_get_string_enc since it
substituted some bytes by a Unicode replacement character. Use FT_ETHER
instead of FT_STRING to fix the display.

Bug: 11850
Change-Id: I3f02cfa13e8fccc18a199e4e293580c183eeddd1
Reviewed-on: https://code.wireshark.org/review/16965
Petri-Dish: Peter Wu <peter@lekensteyn.nl>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
Reviewed-by: Anders Broman <a.broman58@gmail.com>",1396f6ad555178f6b81cc1a65f9cb37b2d99aebf,https://github.com/wireshark/wireshark/commit/1396f6ad555178f6b81cc1a65f9cb37b2d99aebf,epan/dissectors/packet-qnet6.c,dissect_qnet6_lr,"static int
dissect_qnet6_lr(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, gint * poffset, guint encoding)
{
#define QNET6_LR_PAIRS 6
proto_item   *ti;
proto_tree   *stree, *srctree, *dstree, *sstree = NULL;
guint32       total_len, off, len, rlen;
gint          lr_start, i, hf_index_off = -1, hf_index_len = -1, hf_index = -1;
guint8        type;
guint8 const *p, *name[QNET6_LR_PAIRS];
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""QNET_LR"");
rlen = tvb_reported_length_remaining(tvb, *poffset + QNX_QNET6_LR_PKT_SIZE);
lr_start = *poffset;
ti = proto_tree_add_item(tree, proto_qnet6_lr, tvb, *poffset, -1, ENC_NA);
stree = proto_item_add_subtree(ti, ett_qnet6_lr);
proto_tree_add_item(stree, hf_qnet6_lr_ver, tvb, (*poffset)++, 1, ENC_BIG_ENDIAN);
(*poffset)++; 
type = tvb_get_guint8(tvb, *poffset);
proto_tree_add_item(stree, hf_qnet6_lr_type, tvb, (*poffset)++, 1, ENC_BIG_ENDIAN);
(*poffset)++; 
total_len = tvb_get_guint32(tvb, *poffset, encoding);
proto_tree_add_uint(stree, hf_qnet6_lr_total_len, tvb, *poffset, 4, total_len);
*poffset += 4;
ti = proto_tree_add_string(stree, hf_qnet6_lr_src, tvb, *poffset, 4 * 6, ""source node information"");
srctree = proto_item_add_subtree(ti, ett_qnet6_lr_src);
ti = proto_tree_add_string(stree, hf_qnet6_lr_dst, tvb, *poffset + 4 * 6, 4 * 6, ""destination node information"");
dstree = proto_item_add_subtree(ti, ett_qnet6_lr_dst);
rlen = MIN(rlen, total_len);
for (i = 0; i < QNET6_LR_PAIRS; i++)
{
if (i < 3)
stree = srctree;
else
stree = dstree;
switch (i)
{
case 0:
hf_index_off = hf_qnet6_lr_src_name_off;
hf_index_len = hf_qnet6_lr_src_name_len;
hf_index = hf_qnet6_lr_src_name_generated;
sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
ett_qnet6_lr_src_name_subtree, NULL, ""name"");
break;
case 1:
hf_index_off = hf_qnet6_lr_src_domain_off;
hf_index_len = hf_qnet6_lr_src_domain_len;
hf_index = hf_qnet6_lr_src_domain_generated;
sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
ett_qnet6_lr_src_name_subtree, NULL, ""domain"");
break;
case 2:
hf_index_off = hf_qnet6_lr_src_addr_off;
hf_index_len = hf_qnet6_lr_src_addr_len;
hf_index = hf_qnet6_lr_src_addr_generated;
sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
ett_qnet6_lr_src_name_subtree, NULL, ""address"");
break;
case 3:
hf_index_off = hf_qnet6_lr_dst_name_off;
hf_index_len = hf_qnet6_lr_dst_name_len;
hf_index = hf_qnet6_lr_dst_name_generated;
sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
ett_qnet6_lr_src_name_subtree, NULL, ""name"");
break;
case 4:
hf_index_off = hf_qnet6_lr_dst_domain_off;
hf_index_len = hf_qnet6_lr_dst_domain_len;
hf_index = hf_qnet6_lr_dst_domain_generated;
sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
ett_qnet6_lr_src_name_subtree, NULL, ""domain"");
break;
case QNET6_LR_PAIRS - 1:
hf_index_off = hf_qnet6_lr_dst_addr_off;
hf_index_len = hf_qnet6_lr_dst_addr_len;
hf_index = hf_qnet6_lr_dst_addr_generated;
sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
ett_qnet6_lr_src_name_subtree, NULL, ""address"");
break;
}
off = tvb_get_guint32(tvb, *poffset, encoding);
proto_tree_add_item(sstree, hf_index_off, tvb, *poffset, 4, encoding);
*poffset += 4;
len = tvb_get_guint32(tvb, *poffset, encoding);
proto_tree_add_item(sstree, hf_index_len, tvb, *poffset, 4, encoding);
*poffset += 4;
if ((off <= rlen) && (len <= rlen))
{ 
name[i] = tvb_get_string_enc(wmem_packet_scope(),
tvb,
lr_start + off + QNX_QNET6_LR_PKT_SIZE ,
len,
ENC_ASCII|ENC_NA);
if (i != 2 && i != QNET6_LR_PAIRS - 1)
{
ti = proto_tree_add_string(sstree, hf_index, tvb, lr_start + off + QNX_QNET6_LR_PKT_SIZE, len, name[i]);
PROTO_ITEM_SET_GENERATED(ti);
}
else
{
p = name[i];
if (strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))
{
ti = proto_tree_add_string(sstree, hf_index, tvb, lr_start + off + QNX_QNET6_LR_PKT_SIZE, len, p+2);
PROTO_ITEM_SET_GENERATED(ti);
}
}
}
else
{
name[i] = NULL;
}
}
switch (type)
{
case QNET_LR_TYPE_REQUEST:
p = name[2];
if (p && strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))
{
col_add_fstr(pinfo->cinfo, COL_INFO,
""Who is \""%s.%s\""? Tell \""%s.%s\""@%02x:%02x:%02x:%02x:%02x:%02x"",
name[3] ? (const char*)name[3] : ""?"", name[4] ? (const char*)name[4] : ""?"",
name[0] ? (const char*)name[0] : ""?"", name[1] ? (const char*)name[1] : ""?"",
*(p + 2), *(p + 3), *(p + 4),
*(p + 5), *(p + 6), *(p + 7));
}
break;
case QNET_LR_TYPE_REPLY:
p = name[2];
if (p && strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))
{
col_add_fstr(pinfo->cinfo, COL_INFO,
""To \""%s.%s\"", \""%s.%s\"" is at %02x:%02x:%02x:%02x:%02x:%02x"",
name[3] ? (const char*)name[3] : ""?"", name[4] ? (const char*)name[4] : ""?"",
name[0] ? (const char*)name[0] : ""?"", name[1] ? (const char*)name[1] : ""?"",
*(p + 2), *(p + 3), *(p + 4),
*(p + 5), *(p + 6), *(p + 7));
}
break;
default:
col_add_fstr(pinfo->cinfo, COL_INFO, ""Unknown LR Type"");
}
return *poffset - lr_start;
}","static int
dissect_qnet6_lr(tvbuff_t * VAR_0, packet_info * VAR_1, proto_tree * VAR_2, gint * VAR_3, guint VAR_4)
{
#define VAR_5 6
proto_item   *VAR_6;
proto_tree   *VAR_7, *VAR_8, *VAR_9, *VAR_10 = NULL;
guint32       VAR_11, VAR_12, VAR_13, VAR_14;
gint          VAR_15, VAR_16, VAR_17 = -1, VAR_18 = -1, VAR_19 = -1;
guint8        VAR_20;
guint8 const *VAR_21, *VAR_22[VAR_5];
col_set_str(VAR_1->cinfo, VAR_23, ""QNET_LR"");
VAR_14 = tvb_reported_length_remaining(VAR_0, *VAR_3 + VAR_24);
VAR_15 = *VAR_3;
VAR_6 = proto_tree_add_item(VAR_2, VAR_25, VAR_0, *VAR_3, -1, VAR_26);
VAR_7 = proto_item_add_subtree(VAR_6, VAR_27);
proto_tree_add_item(VAR_7, VAR_28, VAR_0, (*VAR_3)++, 1, VAR_29);
(*VAR_3)++; 
VAR_20 = tvb_get_guint8(VAR_0, *VAR_3);
proto_tree_add_item(VAR_7, VAR_30, VAR_0, (*VAR_3)++, 1, VAR_29);
(*VAR_3)++; 
VAR_11 = tvb_get_guint32(VAR_0, *VAR_3, VAR_4);
proto_tree_add_uint(VAR_7, VAR_31, VAR_0, *VAR_3, 4, VAR_11);
*VAR_3 += 4;
VAR_6 = proto_tree_add_string(VAR_7, VAR_32, VAR_0, *VAR_3, 4 * 6, ""source node information"");
VAR_8 = proto_item_add_subtree(VAR_6, VAR_33);
VAR_6 = proto_tree_add_string(VAR_7, VAR_34, VAR_0, *VAR_3 + 4 * 6, 4 * 6, ""destination node information"");
VAR_9 = proto_item_add_subtree(VAR_6, VAR_35);
VAR_14 = MIN(VAR_14, VAR_11);
for (VAR_16 = 0; VAR_16 < VAR_5; VAR_16++)
{
if (VAR_16 < 3)
VAR_7 = VAR_8;
else
VAR_7 = VAR_9;
switch (VAR_16)
{
case 0:
VAR_17 = VAR_36;
VAR_18 = VAR_37;
VAR_19 = VAR_38;
VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
VAR_39, NULL, ""name"");
break;
case 1:
VAR_17 = VAR_40;
VAR_18 = VAR_41;
VAR_19 = VAR_42;
VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
VAR_39, NULL, ""domain"");
break;
case 2:
VAR_17 = VAR_43;
VAR_18 = VAR_44;
VAR_19 = VAR_45;
VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
VAR_39, NULL, ""address"");
break;
case 3:
VAR_17 = VAR_46;
VAR_18 = VAR_47;
VAR_19 = VAR_48;
VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
VAR_39, NULL, ""name"");
break;
case 4:
VAR_17 = VAR_49;
VAR_18 = VAR_50;
VAR_19 = VAR_51;
VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
VAR_39, NULL, ""domain"");
break;
case VAR_5 - 1:
VAR_17 = VAR_52;
VAR_18 = VAR_53;
VAR_19 = VAR_54;
VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
VAR_39, NULL, ""address"");
break;
}
VAR_12 = tvb_get_guint32(VAR_0, *VAR_3, VAR_4);
proto_tree_add_item(VAR_10, VAR_17, VAR_0, *VAR_3, 4, VAR_4);
*VAR_3 += 4;
VAR_13 = tvb_get_guint32(VAR_0, *VAR_3, VAR_4);
proto_tree_add_item(VAR_10, VAR_18, VAR_0, *VAR_3, 4, VAR_4);
*VAR_3 += 4;
if ((VAR_12 <= VAR_14) && (VAR_13 <= VAR_14))
{ 
VAR_22[VAR_16] = tvb_get_string_enc(wmem_packet_scope(),
VAR_0,
VAR_15 + VAR_12 + VAR_24 ,
VAR_13,
VAR_55|VAR_26);
if (VAR_16 != 2 && VAR_16 != VAR_5 - 1)
{
VAR_6 = proto_tree_add_string(VAR_10, VAR_19, VAR_0, VAR_15 + VAR_12 + VAR_24, VAR_13, VAR_22[VAR_16]);
PROTO_ITEM_SET_GENERATED(VAR_6);
}
else
{
VAR_21 = VAR_22[VAR_16];
if (strlen(VAR_21) && (*(VAR_21 + 1) == VAR_56))
{
VAR_6 = proto_tree_add_string(VAR_10, VAR_19, VAR_0, VAR_15 + VAR_12 + VAR_24, VAR_13, VAR_21+2);
PROTO_ITEM_SET_GENERATED(VAR_6);
}
}
}
else
{
VAR_22[VAR_16] = NULL;
}
}
switch (VAR_20)
{
case VAR_57:
VAR_21 = VAR_22[2];
if (VAR_21 && strlen(VAR_21) && (*(VAR_21 + 1) == VAR_56))
{
col_add_fstr(VAR_1->cinfo, VAR_58,
""Who is \""%s.%s\""? Tell \""%s.%s\""@%02x:%02x:%02x:%02x:%02x:%02x"",
VAR_22[3] ? (const char*)VAR_22[3] : ""?"", VAR_22[4] ? (const char*)VAR_22[4] : ""?"",
VAR_22[0] ? (const char*)VAR_22[0] : ""?"", VAR_22[1] ? (const char*)VAR_22[1] : ""?"",
*(VAR_21 + 2), *(VAR_21 + 3), *(VAR_21 + 4),
*(VAR_21 + 5), *(VAR_21 + 6), *(VAR_21 + 7));
}
break;
case VAR_59:
VAR_21 = VAR_22[2];
if (VAR_21 && strlen(VAR_21) && (*(VAR_21 + 1) == VAR_56))
{
col_add_fstr(VAR_1->cinfo, VAR_58,
""To \""%s.%s\"", \""%s.%s\"" is at %02x:%02x:%02x:%02x:%02x:%02x"",
VAR_22[3] ? (const char*)VAR_22[3] : ""?"", VAR_22[4] ? (const char*)VAR_22[4] : ""?"",
VAR_22[0] ? (const char*)VAR_22[0] : ""?"", VAR_22[1] ? (const char*)VAR_22[1] : ""?"",
*(VAR_21 + 2), *(VAR_21 + 3), *(VAR_21 + 4),
*(VAR_21 + 5), *(VAR_21 + 6), *(VAR_21 + 7));
}
break;
default:
col_add_fstr(VAR_1->cinfo, VAR_58, ""Unknown LR Type"");
}
return *VAR_3 - VAR_15;
}",wireshark/1396f6ad555178f6b81cc1a65f9cb37b2d99aebf/packet-qnet6.c/vul/before/0.json,"static int
dissect_qnet6_lr(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, gint * poffset, guint encoding)
{
#define QNET6_LR_PAIRS 6
  proto_item   *ti;
  proto_tree   *stree, *srctree, *dstree, *sstree = NULL;
  guint32       total_len, off, len, rlen;
  gint          lr_start, i, hf_index_off = -1, hf_index_len = -1, hf_index = -1;
  guint8        type;
  guint8 const *p, *name[QNET6_LR_PAIRS];

  col_set_str(pinfo->cinfo, COL_PROTOCOL, ""QNET_LR"");

  /*
   * now rlen is the length of data behind qnet6_lr_pkt + qnet6_lr_pkt
   */
  rlen = tvb_reported_length_remaining(tvb, *poffset + QNX_QNET6_LR_PKT_SIZE);

  lr_start = *poffset;
  ti = proto_tree_add_item(tree, proto_qnet6_lr, tvb, *poffset, -1, ENC_NA);
  stree = proto_item_add_subtree(ti, ett_qnet6_lr);

  /*
   * version
   */
  proto_tree_add_item(stree, hf_qnet6_lr_ver, tvb, (*poffset)++, 1, ENC_BIG_ENDIAN);
  (*poffset)++; /* skip spare byte */
  /*
   * type
   */
  type = tvb_get_guint8(tvb, *poffset);
  proto_tree_add_item(stree, hf_qnet6_lr_type, tvb, (*poffset)++, 1, ENC_BIG_ENDIAN);
  (*poffset)++; /* skip another spare byte */

  /*
   * total length which includes this header and name payload
   */
  total_len = tvb_get_guint32(tvb, *poffset, encoding);
  proto_tree_add_uint(stree, hf_qnet6_lr_total_len, tvb, *poffset, 4, total_len);
  *poffset += 4;

  ti = proto_tree_add_string(stree, hf_qnet6_lr_src, tvb, *poffset, 4 * 6, ""source node information"");
  srctree = proto_item_add_subtree(ti, ett_qnet6_lr_src);
  ti = proto_tree_add_string(stree, hf_qnet6_lr_dst, tvb, *poffset + 4 * 6, 4 * 6, ""destination node information"");
  dstree = proto_item_add_subtree(ti, ett_qnet6_lr_dst);
  rlen = MIN(rlen, total_len);

  for (i = 0; i < QNET6_LR_PAIRS; i++)
    {
      if (i < 3)
        stree = srctree;
      else
        stree = dstree;

      switch (i)
        {
        case 0:
          hf_index_off = hf_qnet6_lr_src_name_off;
          hf_index_len = hf_qnet6_lr_src_name_len;
          hf_index = hf_qnet6_lr_src_name_generated;
          sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
              ett_qnet6_lr_src_name_subtree, NULL, ""name"");
          break;
        case 1:
          hf_index_off = hf_qnet6_lr_src_domain_off;
          hf_index_len = hf_qnet6_lr_src_domain_len;
          hf_index = hf_qnet6_lr_src_domain_generated;
          sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
              ett_qnet6_lr_src_name_subtree, NULL, ""domain"");
          break;
        case 2:
          hf_index_off = hf_qnet6_lr_src_addr_off;
          hf_index_len = hf_qnet6_lr_src_addr_len;
          hf_index = hf_qnet6_lr_src_addr_generated;
          sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
              ett_qnet6_lr_src_name_subtree, NULL, ""address"");
          break;
        case 3:
          hf_index_off = hf_qnet6_lr_dst_name_off;
          hf_index_len = hf_qnet6_lr_dst_name_len;
          hf_index = hf_qnet6_lr_dst_name_generated;
          sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
              ett_qnet6_lr_src_name_subtree, NULL, ""name"");
          break;
        case 4:
          hf_index_off = hf_qnet6_lr_dst_domain_off;
          hf_index_len = hf_qnet6_lr_dst_domain_len;
          hf_index = hf_qnet6_lr_dst_domain_generated;
          sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
              ett_qnet6_lr_src_name_subtree, NULL, ""domain"");
          break;
        case 5:
          hf_index_off = hf_qnet6_lr_dst_addr_off;
          hf_index_len = hf_qnet6_lr_dst_addr_len;
          hf_index = hf_qnet6_lr_dst_addr_generated;
          sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
              ett_qnet6_lr_src_name_subtree, NULL, ""address"");
          break;
        }

      off = tvb_get_guint32(tvb, *poffset, encoding);
      proto_tree_add_item(sstree, hf_index_off, tvb, *poffset, 4, encoding);
      *poffset += 4;

      len = tvb_get_guint32(tvb, *poffset, encoding);
      proto_tree_add_item(sstree, hf_index_len, tvb, *poffset, 4, encoding);
      *poffset += 4;

      if ((off <= rlen) && (len <= rlen))
        {
          guint addr_data_offset = lr_start + off + QNX_QNET6_LR_PKT_SIZE /* sizeof(struct qnet6_lr_pkt) */;
          /*
           * struct qnet6_lr_pkt is 64 bit aligned
           */
          if (i != 2 && i != 5)
            {
            name[i] = tvb_get_string_enc(wmem_packet_scope(),
                                         tvb,
                                         addr_data_offset,
                                         len,
                                         ENC_ASCII|ENC_NA);
                ti = proto_tree_add_string(sstree, hf_index, tvb, addr_data_offset, len, name[i]);
                PROTO_ITEM_SET_GENERATED(ti);
            }
          else
            {
              if (tvb_get_guint8(tvb, addr_data_offset + 1) == QNET_LR_SA_FAMILY_MAC && len >= 2 + 6)
                {
                  name[i] = tvb_ether_to_str(tvb, addr_data_offset + 2);
                  ti = proto_tree_add_item(sstree, hf_index, tvb, addr_data_offset + 2, 6, ENC_NA);
                  PROTO_ITEM_SET_GENERATED(ti);
                }
              else
                {
                  /* The comment above suggests that value '2' means interface
                   * name, but this was not observed in the provided pcap, so
                   * let's ignore that possibility for now. */
                  name[i] = NULL;
                }
            }
        }
      else
        {
          name[i] = NULL;
        }
    }

  switch (type)
    {
    case QNET_LR_TYPE_REQUEST:
      p = name[2];
      if (p)
        {
          col_add_fstr(pinfo->cinfo, COL_INFO,
                        ""Who is \""%s.%s\""? Tell \""%s.%s\""@%s"",
                        name[3] ? (const char*)name[3] : ""?"", name[4] ? (const char*)name[4] : ""?"",
                        name[0] ? (const char*)name[0] : ""?"", name[1] ? (const char*)name[1] : ""?"",
                        p);
        }
      break;
    case QNET_LR_TYPE_REPLY:
      p = name[2];
      if (p)
        {
          col_add_fstr(pinfo->cinfo, COL_INFO,
                        ""To \""%s.%s\"", \""%s.%s\"" is at %s"",
                        name[3] ? (const char*)name[3] : ""?"", name[4] ? (const char*)name[4] : ""?"",
                        name[0] ? (const char*)name[0] : ""?"", name[1] ? (const char*)name[1] : ""?"",
                        p);
        }
      break;
    default:
      col_add_fstr(pinfo->cinfo, COL_INFO, ""Unknown LR Type"");
    }

  return *poffset - lr_start;
}","static int
dissect_qnet6_lr(tvbuff_t * VAR_0, packet_info * VAR_1, proto_tree * VAR_2, gint * VAR_3, guint VAR_4)
{
#define VAR_5 6
  proto_item   *VAR_6;
  proto_tree   *VAR_7, *VAR_8, *VAR_9, *VAR_10 = NULL;
  guint32       VAR_11, VAR_12, VAR_13, VAR_14;
  gint          VAR_15, VAR_16, VAR_17 = -1, VAR_18 = -1, VAR_19 = -1;
  guint8        VAR_20;
  guint8 const *VAR_21, *VAR_22[VAR_5];

  col_set_str(VAR_1->cinfo, VAR_23, ""QNET_LR"");

  /* COMMENT_0 */
                                                                      
     
  VAR_14 = tvb_reported_length_remaining(VAR_0, *VAR_3 + VAR_24);

  VAR_15 = *VAR_3;
  VAR_6 = proto_tree_add_item(VAR_2, VAR_25, VAR_0, *VAR_3, -1, VAR_26);
  VAR_7 = proto_item_add_subtree(VAR_6, VAR_27);

  /* COMMENT_3 */
            
     
  proto_tree_add_item(VAR_7, VAR_28, VAR_0, (*VAR_3)++, 1, VAR_29);
  (*VAR_3)++; /* COMMENT_6 */
  /* COMMENT_7 */
         
     
  VAR_20 = tvb_get_guint8(VAR_0, *VAR_3);
  proto_tree_add_item(VAR_7, VAR_30, VAR_0, (*VAR_3)++, 1, VAR_29);
  (*VAR_3)++; /* COMMENT_10 */

  /* COMMENT_11 */
                                                             
     
  VAR_11 = tvb_get_guint32(VAR_0, *VAR_3, VAR_4);
  proto_tree_add_uint(VAR_7, VAR_31, VAR_0, *VAR_3, 4, VAR_11);
  *VAR_3 += 4;

  VAR_6 = proto_tree_add_string(VAR_7, VAR_32, VAR_0, *VAR_3, 4 * 6, ""source node information"");
  VAR_8 = proto_item_add_subtree(VAR_6, VAR_33);
  VAR_6 = proto_tree_add_string(VAR_7, VAR_34, VAR_0, *VAR_3 + 4 * 6, 4 * 6, ""destination node information"");
  VAR_9 = proto_item_add_subtree(VAR_6, VAR_35);
  VAR_14 = MIN(VAR_14, VAR_11);

  for (VAR_16 = 0; VAR_16 < VAR_5; VAR_16++)
    {
      if (VAR_16 < 3)
        VAR_7 = VAR_8;
      else
        VAR_7 = VAR_9;

      switch (VAR_16)
        {
        case 0:
          VAR_17 = VAR_36;
          VAR_18 = VAR_37;
          VAR_19 = VAR_38;
          VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
              VAR_39, NULL, ""name"");
          break;
        case 1:
          VAR_17 = VAR_40;
          VAR_18 = VAR_41;
          VAR_19 = VAR_42;
          VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
              VAR_39, NULL, ""domain"");
          break;
        case 2:
          VAR_17 = VAR_43;
          VAR_18 = VAR_44;
          VAR_19 = VAR_45;
          VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
              VAR_39, NULL, ""address"");
          break;
        case 3:
          VAR_17 = VAR_46;
          VAR_18 = VAR_47;
          VAR_19 = VAR_48;
          VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
              VAR_39, NULL, ""name"");
          break;
        case 4:
          VAR_17 = VAR_49;
          VAR_18 = VAR_50;
          VAR_19 = VAR_51;
          VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
              VAR_39, NULL, ""domain"");
          break;
        case 5:
          VAR_17 = VAR_52;
          VAR_18 = VAR_53;
          VAR_19 = VAR_54;
          VAR_10 = proto_tree_add_subtree(VAR_7, VAR_0, *VAR_3, 4 * 2,
              VAR_39, NULL, ""address"");
          break;
        }

      VAR_12 = tvb_get_guint32(VAR_0, *VAR_3, VAR_4);
      proto_tree_add_item(VAR_10, VAR_17, VAR_0, *VAR_3, 4, VAR_4);
      *VAR_3 += 4;

      VAR_13 = tvb_get_guint32(VAR_0, *VAR_3, VAR_4);
      proto_tree_add_item(VAR_10, VAR_18, VAR_0, *VAR_3, 4, VAR_4);
      *VAR_3 += 4;

      if ((VAR_12 <= VAR_14) && (VAR_13 <= VAR_14))
        {
          guint VAR_55 = VAR_15 + VAR_12 + VAR_24 /* COMMENT_14 */;
          /* COMMENT_15 */
                                                  
             
          if (VAR_16 != 2 && VAR_16 != 5)
            {
            VAR_22[VAR_16] = tvb_get_string_enc(wmem_packet_scope(),
                                         VAR_0,
                                         VAR_55,
                                         VAR_13,
                                         VAR_56|VAR_26);
                VAR_6 = proto_tree_add_string(VAR_10, VAR_19, VAR_0, VAR_55, VAR_13, VAR_22[VAR_16]);
                PROTO_ITEM_SET_GENERATED(VAR_6);
            }
          else
            {
              if (tvb_get_guint8(VAR_0, VAR_55 + 1) == VAR_57 && VAR_13 >= 2 + 6)
                {
                  VAR_22[VAR_16] = tvb_ether_to_str(VAR_0, VAR_55 + 2);
                  VAR_6 = proto_tree_add_item(VAR_10, VAR_19, VAR_0, VAR_55 + 2, 6, VAR_26);
                  PROTO_ITEM_SET_GENERATED(VAR_6);
                }
              else
                {
                  /* COMMENT_18 */
                                                                             
                                                              
                  VAR_22[VAR_16] = NULL;
                }
            }
        }
      else
        {
          VAR_22[VAR_16] = NULL;
        }
    }

  switch (VAR_20)
    {
    case VAR_58:
      VAR_21 = VAR_22[2];
      if (VAR_21)
        {
          col_add_fstr(VAR_1->cinfo, VAR_59,
                        ""Who is \""%s.%s\""? Tell \""%s.%s\""@%s"",
                        VAR_22[3] ? (const char*)VAR_22[3] : ""?"", VAR_22[4] ? (const char*)VAR_22[4] : ""?"",
                        VAR_22[0] ? (const char*)VAR_22[0] : ""?"", VAR_22[1] ? (const char*)VAR_22[1] : ""?"",
                        VAR_21);
        }
      break;
    case VAR_60:
      VAR_21 = VAR_22[2];
      if (VAR_21)
        {
          col_add_fstr(VAR_1->cinfo, VAR_59,
                        ""To \""%s.%s\"", \""%s.%s\"" is at %s"",
                        VAR_22[3] ? (const char*)VAR_22[3] : ""?"", VAR_22[4] ? (const char*)VAR_22[4] : ""?"",
                        VAR_22[0] ? (const char*)VAR_22[0] : ""?"", VAR_22[1] ? (const char*)VAR_22[1] : ""?"",
                        VAR_21);
        }
      break;
    default:
      col_add_fstr(VAR_1->cinfo, VAR_59, ""Unknown LR Type"");
    }

  return *VAR_3 - VAR_15;
}",wireshark/1396f6ad555178f6b81cc1a65f9cb37b2d99aebf/packet-qnet6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -89,7 +89,7 @@
           sstree = proto_tree_add_subtree(stree, tvb, *poffset, 4 * 2,
               ett_qnet6_lr_src_name_subtree, NULL, ""domain"");
           break;
-        case QNET6_LR_PAIRS - 1:
+        case 5:
           hf_index_off = hf_qnet6_lr_dst_addr_off;
           hf_index_len = hf_qnet6_lr_dst_addr_len;
           hf_index = hf_qnet6_lr_dst_addr_generated;
@@ -107,27 +107,35 @@
       *poffset += 4;
 
       if ((off <= rlen) && (len <= rlen))
-        { /* bad value of source * name */
-          name[i] = tvb_get_string_enc(wmem_packet_scope(),
-                                       tvb,
-                                       lr_start + off + QNX_QNET6_LR_PKT_SIZE /* sizeof(struct qnet6_lr_pkt) */,
-                                       len,
-                                       ENC_ASCII|ENC_NA);
+        {
+          guint addr_data_offset = lr_start + off + QNX_QNET6_LR_PKT_SIZE /* sizeof(struct qnet6_lr_pkt) */;
           /*
            * struct qnet6_lr_pkt is 64 bit aligned
            */
-          if (i != 2 && i != QNET6_LR_PAIRS - 1)
+          if (i != 2 && i != 5)
             {
-              ti = proto_tree_add_string(sstree, hf_index, tvb, lr_start + off + QNX_QNET6_LR_PKT_SIZE, len, name[i]);
-              PROTO_ITEM_SET_GENERATED(ti);
+            name[i] = tvb_get_string_enc(wmem_packet_scope(),
+                                         tvb,
+                                         addr_data_offset,
+                                         len,
+                                         ENC_ASCII|ENC_NA);
+                ti = proto_tree_add_string(sstree, hf_index, tvb, addr_data_offset, len, name[i]);
+                PROTO_ITEM_SET_GENERATED(ti);
             }
           else
             {
-              p = name[i];
-              if (strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))
+              if (tvb_get_guint8(tvb, addr_data_offset + 1) == QNET_LR_SA_FAMILY_MAC && len >= 2 + 6)
                 {
-                  ti = proto_tree_add_string(sstree, hf_index, tvb, lr_start + off + QNX_QNET6_LR_PKT_SIZE, len, p+2);
+                  name[i] = tvb_ether_to_str(tvb, addr_data_offset + 2);
+                  ti = proto_tree_add_item(sstree, hf_index, tvb, addr_data_offset + 2, 6, ENC_NA);
                   PROTO_ITEM_SET_GENERATED(ti);
+                }
+              else
+                {
+                  /* The comment above suggests that value '2' means interface
+                   * name, but this was not observed in the provided pcap, so
+                   * let's ignore that possibility for now. */
+                  name[i] = NULL;
                 }
             }
         }
@@ -141,26 +149,24 @@
     {
     case QNET_LR_TYPE_REQUEST:
       p = name[2];
-      if (p && strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))
+      if (p)
         {
           col_add_fstr(pinfo->cinfo, COL_INFO,
-                        ""Who is \""%s.%s\""? Tell \""%s.%s\""@%02x:%02x:%02x:%02x:%02x:%02x"",
+                        ""Who is \""%s.%s\""? Tell \""%s.%s\""@%s"",
                         name[3] ? (const char*)name[3] : ""?"", name[4] ? (const char*)name[4] : ""?"",
                         name[0] ? (const char*)name[0] : ""?"", name[1] ? (const char*)name[1] : ""?"",
-                        *(p + 2), *(p + 3), *(p + 4),
-                        *(p + 5), *(p + 6), *(p + 7));
+                        p);
         }
       break;
     case QNET_LR_TYPE_REPLY:
       p = name[2];
-      if (p && strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))
+      if (p)
         {
           col_add_fstr(pinfo->cinfo, COL_INFO,
-                        ""To \""%s.%s\"", \""%s.%s\"" is at %02x:%02x:%02x:%02x:%02x:%02x"",
+                        ""To \""%s.%s\"", \""%s.%s\"" is at %s"",
                         name[3] ? (const char*)name[3] : ""?"", name[4] ? (const char*)name[4] : ""?"",
                         name[0] ? (const char*)name[0] : ""?"", name[1] ? (const char*)name[1] : ""?"",
-                        *(p + 2), *(p + 3), *(p + 4),
-                        *(p + 5), *(p + 6), *(p + 7));
+                        p);
         }
       break;
     default:","{'deleted_lines': ['        case QNET6_LR_PAIRS - 1:', '        { /* bad value of source * name */', '          name[i] = tvb_get_string_enc(wmem_packet_scope(),', '                                       tvb,', '                                       lr_start + off + QNX_QNET6_LR_PKT_SIZE /* sizeof(struct qnet6_lr_pkt) */,', '                                       len,', '                                       ENC_ASCII|ENC_NA);', '          if (i != 2 && i != QNET6_LR_PAIRS - 1)', '              ti = proto_tree_add_string(sstree, hf_index, tvb, lr_start + off + QNX_QNET6_LR_PKT_SIZE, len, name[i]);', '              PROTO_ITEM_SET_GENERATED(ti);', '              p = name[i];', '              if (strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))', '                  ti = proto_tree_add_string(sstree, hf_index, tvb, lr_start + off + QNX_QNET6_LR_PKT_SIZE, len, p+2);', '      if (p && strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))', '                        ""Who is \\""%s.%s\\""? Tell \\""%s.%s\\""@%02x:%02x:%02x:%02x:%02x:%02x"",', '                        *(p + 2), *(p + 3), *(p + 4),', '                        *(p + 5), *(p + 6), *(p + 7));', '      if (p && strlen(p) && (*(p + 1) == QNET_LR_SA_FAMILY_MAC))', '                        ""To \\""%s.%s\\"", \\""%s.%s\\"" is at %02x:%02x:%02x:%02x:%02x:%02x"",', '                        *(p + 2), *(p + 3), *(p + 4),', '                        *(p + 5), *(p + 6), *(p + 7));'], 'added_lines': ['        case 5:', '        {', '          guint addr_data_offset = lr_start + off + QNX_QNET6_LR_PKT_SIZE /* sizeof(struct qnet6_lr_pkt) */;', '          if (i != 2 && i != 5)', '            name[i] = tvb_get_string_enc(wmem_packet_scope(),', '                                         tvb,', '                                         addr_data_offset,', '                                         len,', '                                         ENC_ASCII|ENC_NA);', '                ti = proto_tree_add_string(sstree, hf_index, tvb, addr_data_offset, len, name[i]);', '                PROTO_ITEM_SET_GENERATED(ti);', '              if (tvb_get_guint8(tvb, addr_data_offset + 1) == QNET_LR_SA_FAMILY_MAC && len >= 2 + 6)', '                  name[i] = tvb_ether_to_str(tvb, addr_data_offset + 2);', '                  ti = proto_tree_add_item(sstree, hf_index, tvb, addr_data_offset + 2, 6, ENC_NA);', '                }', '              else', '                {', ""                  /* The comment above suggests that value '2' means interface"", '                   * name, but this was not observed in the provided pcap, so', ""                   * let's ignore that possibility for now. */"", '                  name[i] = NULL;', '      if (p)', '                        ""Who is \\""%s.%s\\""? Tell \\""%s.%s\\""@%s"",', '                        p);', '      if (p)', '                        ""To \\""%s.%s\\"", \\""%s.%s\\"" is at %s"",', '                        p);']}",True,"epan/dissectors/packet-qnet6.c in the QNX6 QNET dissector in Wireshark 2.x before 2.0.6 mishandles MAC address data, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted packet.",5.9,MEDIUM,1,valid,2016-08-08T21:43:24Z,1
CVE-2016-10165,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,mm2/Little-CMS,"Added an extra check to MLU bounds

Thanks to Ibrahim el-sayed for spotting the bug",5ca71a7bc18b6897ab21d815d15e218e204581e2,https://github.com/mm2/Little-CMS/commit/5ca71a7bc18b6897ab21d815d15e218e204581e2,src/cmstypes.c,Type_MLU_Read,"static
void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
{
cmsMLU* mlu;
cmsUInt32Number Count, RecLen, NumOfWchar;
cmsUInt32Number SizeOfHeader;
cmsUInt32Number  Len, Offset;
cmsUInt32Number  i;
wchar_t*         Block;
cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;
*nItems = 0;
if (!_cmsReadUInt32Number(io, &Count)) return NULL;
if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;
if (RecLen != 12) {
cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, ""multiLocalizedUnicodeType of len != 12 is not supported."");
return NULL;
}
mlu = cmsMLUalloc(self ->ContextID, Count);
if (mlu == NULL) return NULL;
mlu ->UsedEntries = Count;
SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);
LargestPosition = 0;
for (i=0; i < Count; i++) {
if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;
if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;
if (!_cmsReadUInt32Number(io, &Len)) goto Error;
if (!_cmsReadUInt32Number(io, &Offset)) goto Error;
if (Offset < (SizeOfHeader + 8)) goto Error;
BeginOfThisString = Offset - SizeOfHeader - 8;
mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
EndOfThisString = BeginOfThisString + Len;
if (EndOfThisString > LargestPosition)
LargestPosition = EndOfThisString;
}
SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
if (SizeOfTag == 0)
{
Block = NULL;
NumOfWchar = 0;
}
else
{
Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);
if (Block == NULL) goto Error;
NumOfWchar = SizeOfTag / sizeof(wchar_t);
if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;
}
mlu ->MemPool  = Block;
mlu ->PoolSize = SizeOfTag;
mlu ->PoolUsed = SizeOfTag;
*nItems = 1;
return (void*) mlu;
Error:
if (mlu) cmsMLUfree(mlu);
return NULL;
}","static
void *Type_MLU_Read(struct _cms_typehandler_struct* VAR_0, cmsIOHANDLER* VAR_1, cmsUInt32Number* VAR_2, cmsUInt32Number VAR_3)
{
cmsMLU* VAR_4;
cmsUInt32Number VAR_5, VAR_6, VAR_7;
cmsUInt32Number VAR_8;
cmsUInt32Number  VAR_9, VAR_10;
cmsUInt32Number  VAR_11;
wchar_t*         VAR_12;
cmsUInt32Number  VAR_13, VAR_14, VAR_15;
*VAR_2 = 0;
if (!_cmsReadUInt32Number(VAR_1, &VAR_5)) return NULL;
if (!_cmsReadUInt32Number(VAR_1, &VAR_6)) return NULL;
if (VAR_6 != 12) {
cmsSignalError(VAR_0->ContextID, VAR_16, ""multiLocalizedUnicodeType of len != 12 is not supported."");
return NULL;
}
VAR_4 = cmsMLUalloc(VAR_0 ->ContextID, VAR_5);
if (VAR_4 == NULL) return NULL;
VAR_4 ->UsedEntries = VAR_5;
VAR_8 = 12 * VAR_5 + sizeof(VAR_17);
VAR_15 = 0;
for (VAR_11=0; VAR_11 < VAR_5; VAR_11++) {
if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Language)) goto Error;
if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Country))  goto Error;
if (!_cmsReadUInt32Number(VAR_1, &VAR_9)) goto Error;
if (!_cmsReadUInt32Number(VAR_1, &VAR_10)) goto Error;
if (VAR_10 < (VAR_8 + 8)) goto Error;
VAR_13 = VAR_10 - VAR_8 - 8;
VAR_4 ->Entries[VAR_11].Len = (VAR_9 * sizeof(wchar_t)) / sizeof(VAR_18);
VAR_4 ->Entries[VAR_11].StrW = (VAR_13 * sizeof(wchar_t)) / sizeof(VAR_18);
VAR_14 = VAR_13 + VAR_9;
if (VAR_14 > VAR_15)
VAR_15 = VAR_14;
}
VAR_3   = (VAR_15 * sizeof(wchar_t)) / sizeof(VAR_18);
if (VAR_3 == 0)
{
VAR_12 = NULL;
VAR_7 = 0;
}
else
{
VAR_12 = (wchar_t*) _cmsMalloc(VAR_0 ->ContextID, VAR_3);
if (VAR_12 == NULL) goto Error;
VAR_7 = VAR_3 / sizeof(wchar_t);
if (!_cmsReadWCharArray(VAR_1, VAR_7, VAR_12)) goto Error;
}
VAR_4 ->MemPool  = VAR_12;
VAR_4 ->PoolSize = VAR_3;
VAR_4 ->PoolUsed = VAR_3;
*VAR_2 = 1;
return (void*) VAR_4;
Error:
if (VAR_4) cmsMLUfree(VAR_4);
return NULL;
}",mm2/Little-CMS/5ca71a7bc18b6897ab21d815d15e218e204581e2/cmstypes.c/vul/before/0.json,"static
void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)
{
    cmsMLU* mlu;
    cmsUInt32Number Count, RecLen, NumOfWchar;
    cmsUInt32Number SizeOfHeader;
    cmsUInt32Number  Len, Offset;
    cmsUInt32Number  i;
    wchar_t*         Block;
    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;

    *nItems = 0;
    if (!_cmsReadUInt32Number(io, &Count)) return NULL;
    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;

    if (RecLen != 12) {

        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, ""multiLocalizedUnicodeType of len != 12 is not supported."");
        return NULL;
    }

    mlu = cmsMLUalloc(self ->ContextID, Count);
    if (mlu == NULL) return NULL;

    mlu ->UsedEntries = Count;

    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);
    LargestPosition = 0;

    for (i=0; i < Count; i++) {

        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;
        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;

        // Now deal with Len and offset.
        if (!_cmsReadUInt32Number(io, &Len)) goto Error;
        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;

        // Check for overflow
        if (Offset < (SizeOfHeader + 8)) goto Error;
        if ((Offset + Len) > SizeOfTag + 8) goto Error;

        // True begin of the string
        BeginOfThisString = Offset - SizeOfHeader - 8;

        // Ajust to wchar_t elements
        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);

        // To guess maximum size, add offset + len
        EndOfThisString = BeginOfThisString + Len;
        if (EndOfThisString > LargestPosition)
            LargestPosition = EndOfThisString;
    }

    // Now read the remaining of tag and fill all strings. Subtract the directory
    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);
    if (SizeOfTag == 0)
    {
        Block = NULL;
        NumOfWchar = 0;

    }
    else
    {
        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);
        if (Block == NULL) goto Error;
        NumOfWchar = SizeOfTag / sizeof(wchar_t);
        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;
    }

    mlu ->MemPool  = Block;
    mlu ->PoolSize = SizeOfTag;
    mlu ->PoolUsed = SizeOfTag;

    *nItems = 1;
    return (void*) mlu;

Error:
    if (mlu) cmsMLUfree(mlu);
    return NULL;
}","static
void *Type_MLU_Read(struct _cms_typehandler_struct* VAR_0, cmsIOHANDLER* VAR_1, cmsUInt32Number* VAR_2, cmsUInt32Number VAR_3)
{
    cmsMLU* VAR_4;
    cmsUInt32Number VAR_5, VAR_6, VAR_7;
    cmsUInt32Number VAR_8;
    cmsUInt32Number  VAR_9, VAR_10;
    cmsUInt32Number  VAR_11;
    wchar_t*         VAR_12;
    cmsUInt32Number  VAR_13, VAR_14, VAR_15;

    *VAR_2 = 0;
    if (!_cmsReadUInt32Number(VAR_1, &VAR_5)) return NULL;
    if (!_cmsReadUInt32Number(VAR_1, &VAR_6)) return NULL;

    if (VAR_6 != 12) {

        cmsSignalError(VAR_0->ContextID, VAR_16, ""multiLocalizedUnicodeType of len != 12 is not supported."");
        return NULL;
    }

    VAR_4 = cmsMLUalloc(VAR_0 ->ContextID, VAR_5);
    if (VAR_4 == NULL) return NULL;

    VAR_4 ->UsedEntries = VAR_5;

    VAR_8 = 12 * VAR_5 + sizeof(VAR_17);
    VAR_15 = 0;

    for (VAR_11=0; VAR_11 < VAR_5; VAR_11++) {

        if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Language)) goto Error;
        if (!_cmsReadUInt16Number(VAR_1, &VAR_4 ->Entries[VAR_11].Country))  goto Error;

        /* COMMENT_0 */
        if (!_cmsReadUInt32Number(VAR_1, &VAR_9)) goto Error;
        if (!_cmsReadUInt32Number(VAR_1, &VAR_10)) goto Error;

        /* COMMENT_1 */
        if (VAR_10 < (VAR_8 + 8)) goto Error;
        if ((VAR_10 + VAR_9) > VAR_3 + 8) goto Error;

        /* COMMENT_2 */
        VAR_13 = VAR_10 - VAR_8 - 8;

        /* COMMENT_3 */
        VAR_4 ->Entries[VAR_11].Len = (VAR_9 * sizeof(wchar_t)) / sizeof(VAR_18);
        VAR_4 ->Entries[VAR_11].StrW = (VAR_13 * sizeof(wchar_t)) / sizeof(VAR_18);

        /* COMMENT_4 */
        VAR_14 = VAR_13 + VAR_9;
        if (VAR_14 > VAR_15)
            VAR_15 = VAR_14;
    }

    /* COMMENT_5 */
    VAR_3   = (VAR_15 * sizeof(wchar_t)) / sizeof(VAR_18);
    if (VAR_3 == 0)
    {
        VAR_12 = NULL;
        VAR_7 = 0;

    }
    else
    {
        VAR_12 = (wchar_t*) _cmsMalloc(VAR_0 ->ContextID, VAR_3);
        if (VAR_12 == NULL) goto Error;
        VAR_7 = VAR_3 / sizeof(wchar_t);
        if (!_cmsReadWCharArray(VAR_1, VAR_7, VAR_12)) goto Error;
    }

    VAR_4 ->MemPool  = VAR_12;
    VAR_4 ->PoolSize = VAR_3;
    VAR_4 ->PoolUsed = VAR_3;

    *VAR_2 = 1;
    return (void*) VAR_4;

Error:
    if (VAR_4) cmsMLUfree(VAR_4);
    return NULL;
}",mm2/Little-CMS/5ca71a7bc18b6897ab21d815d15e218e204581e2/cmstypes.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,6 +38,7 @@
 
         // Check for overflow
         if (Offset < (SizeOfHeader + 8)) goto Error;
+        if ((Offset + Len) > SizeOfTag + 8) goto Error;
 
         // True begin of the string
         BeginOfThisString = Offset - SizeOfHeader - 8;","{'deleted_lines': [], 'added_lines': ['        if ((Offset + Len) > SizeOfTag + 8) goto Error;']}",True,"The Type_MLU_Read function in cmstypes.c in Little CMS (aka lcms2) allows remote attackers to obtain sensitive information or cause a denial of service via an image with a crafted ICC profile, which triggers an out-of-bounds heap read.",7.1,HIGH,2,valid,2016-08-15T21:31:39Z,1
CVE-2016-6888,['CWE-190'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu,"net: vmxnet: use g_new for pkt initialisation

When network transport abstraction layer initialises pkt, the maximum
fragmentation count is not checked. This could lead to an integer
overflow causing a NULL pointer dereference. Replace g_malloc() with
g_new() to catch the multiplication overflow.

Reported-by: Li Qiang <liqiang6-s@360.cn>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
Acked-by: Dmitry Fleytman <dmitry@daynix.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>",47882fa4975bf0b58dd74474329fdd7154e8f04c,https://github.com/qemu/qemu/commit/47882fa4975bf0b58dd74474329fdd7154e8f04c,hw/net/net_tx_pkt.c,net_tx_pkt_init,"void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,
uint32_t max_frags, bool has_virt_hdr)
{
struct NetTxPkt *p = g_malloc0(sizeof *p);
p->pci_dev = pci_dev;
p->vec = g_malloc((sizeof *p->vec) *
(max_frags + NET_TX_PKT_PL_START_FRAG));
p->raw = g_malloc((sizeof *p->raw) * max_frags);
p->max_payload_frags = max_frags;
p->max_raw_frags = max_frags;
p->has_virt_hdr = has_virt_hdr;
p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;
p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =
p->has_virt_hdr ? sizeof p->virt_hdr : 0;
p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;
p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;
*pkt = p;
}","void net_tx_pkt_init(struct NetTxPkt **VAR_0, PCIDevice *VAR_1,
uint32_t VAR_2, bool VAR_3)
{
struct NetTxPkt *VAR_4 = g_malloc0(sizeof *VAR_4);
VAR_4->pci_dev = VAR_1;
VAR_4->vec = g_malloc((sizeof *VAR_4->vec) *
(VAR_2 + VAR_5));
VAR_4->raw = g_malloc((sizeof *VAR_4->raw) * VAR_2);
VAR_4->max_payload_frags = VAR_2;
VAR_4->max_raw_frags = VAR_2;
VAR_4->has_virt_hdr = VAR_3;
VAR_4->vec[VAR_6].iov_base = &VAR_4->virt_hdr;
VAR_4->vec[VAR_6].iov_len =
VAR_4->has_virt_hdr ? sizeof VAR_4->virt_hdr : 0;
VAR_4->vec[VAR_7].iov_base = &VAR_4->l2_hdr;
VAR_4->vec[VAR_8].iov_base = &VAR_4->l3_hdr;
*VAR_0 = VAR_4;
}",qemu/47882fa4975bf0b58dd74474329fdd7154e8f04c/net_tx_pkt.c/vul/before/0.json,"void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,
    uint32_t max_frags, bool has_virt_hdr)
{
    struct NetTxPkt *p = g_malloc0(sizeof *p);

    p->pci_dev = pci_dev;

    p->vec = g_new(struct iovec, max_frags + NET_TX_PKT_PL_START_FRAG);

    p->raw = g_new(struct iovec, max_frags);

    p->max_payload_frags = max_frags;
    p->max_raw_frags = max_frags;
    p->has_virt_hdr = has_virt_hdr;
    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;
    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =
        p->has_virt_hdr ? sizeof p->virt_hdr : 0;
    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;
    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;

    *pkt = p;
}","void net_tx_pkt_init(struct NetTxPkt **VAR_0, PCIDevice *VAR_1,
    uint32_t VAR_2, bool VAR_3)
{
    struct NetTxPkt *VAR_4 = g_malloc0(sizeof *VAR_4);

    VAR_4->pci_dev = VAR_1;

    VAR_4->vec = g_new(struct VAR_5, VAR_2 + VAR_6);

    VAR_4->raw = g_new(struct VAR_5, VAR_2);

    VAR_4->max_payload_frags = VAR_2;
    VAR_4->max_raw_frags = VAR_2;
    VAR_4->has_virt_hdr = VAR_3;
    VAR_4->vec[VAR_7].iov_base = &VAR_4->virt_hdr;
    VAR_4->vec[VAR_7].iov_len =
        VAR_4->has_virt_hdr ? sizeof VAR_4->virt_hdr : 0;
    VAR_4->vec[VAR_8].iov_base = &VAR_4->l2_hdr;
    VAR_4->vec[VAR_9].iov_base = &VAR_4->l3_hdr;

    *VAR_0 = VAR_4;
}",qemu/47882fa4975bf0b58dd74474329fdd7154e8f04c/net_tx_pkt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,10 +5,9 @@
 
     p->pci_dev = pci_dev;
 
-    p->vec = g_malloc((sizeof *p->vec) *
-        (max_frags + NET_TX_PKT_PL_START_FRAG));
+    p->vec = g_new(struct iovec, max_frags + NET_TX_PKT_PL_START_FRAG);
 
-    p->raw = g_malloc((sizeof *p->raw) * max_frags);
+    p->raw = g_new(struct iovec, max_frags);
 
     p->max_payload_frags = max_frags;
     p->max_raw_frags = max_frags;","{'deleted_lines': ['    p->vec = g_malloc((sizeof *p->vec) *', '        (max_frags + NET_TX_PKT_PL_START_FRAG));', '    p->raw = g_malloc((sizeof *p->raw) * max_frags);'], 'added_lines': ['    p->vec = g_new(struct iovec, max_frags + NET_TX_PKT_PL_START_FRAG);', '    p->raw = g_new(struct iovec, max_frags);']}",True,"Integer overflow in the net_tx_pkt_init function in hw/net/net_tx_pkt.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (QEMU process crash) via the maximum fragmentation count, which triggers an unchecked multiplication and NULL pointer dereference.",4.4,MEDIUM,1,valid,2016-08-16T11:28:01Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,mysql/mysql-server,"Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE

During REPAIR TABLE of a MyISAM table, a temporary data file (.TMD)
is created. When repair finishes, this file is renamed to the original
.MYD file. The problem was that during this rename, we copied the
stats from the old file to the new file with chmod/chown. If a user
managed to replace the temporary file before chmod/chown was executed,
it was possible to get an arbitrary file with the privileges of the
mysql user.

This patch fixes the problem by not copying stats from the old
file to the new file. This is not needed as the new file was
created with the correct stats. This fix only changes server
behavior - external utilities such as myisamchk still does
chmod/chown.

No test case provided since the problem involves synchronization
with file system operations.",4e5473862e6852b0f3802b0cd0c6fa10b5253291,https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,storage/myisam/mi_check.c,mi_repair_by_sort,"int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info,
const char * name, int rep_quick)
{
int got_error;
uint i;
ulong length;
ha_rows start_records;
my_off_t new_header_length,del;
File new_file;
MI_SORT_PARAM sort_param;
MYISAM_SHARE *share=info->s;
HA_KEYSEG *keyseg;
ulong   *rec_per_key_part;
char llbuff[22];
SORT_INFO sort_info;
ulonglong UNINIT_VAR(key_map);
DBUG_ENTER(""mi_repair_by_sort"");
start_records=info->state->records;
got_error=1;
new_file= -1;
new_header_length=(param->testflag & T_UNPACK) ? 0 :
share->pack.header_length;
if (!(param->testflag & T_SILENT))
{
printf(""- recovering (with sort) MyISAM-table '%s'\n"",name);
printf(""Data records: %s\n"", llstr(start_records,llbuff));
}
param->testflag|=T_REP; 
if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))
param->testflag|=T_CALC_CHECKSUM;
bzero((char*)&sort_info,sizeof(sort_info));
bzero((char *)&sort_param, sizeof(sort_param));
if (!(sort_info.key_block=
alloc_key_blocks(param,
(uint) param->sort_key_blocks,
share->base.max_key_block_length))
|| init_io_cache(&param->read_cache,info->dfile,
(uint) param->read_buffer_length,
READ_CACHE,share->pack.header_length,1,MYF(MY_WME)) ||
(! rep_quick &&
init_io_cache(&info->rec_cache,info->dfile,
(uint) param->write_buffer_length,
WRITE_CACHE,new_header_length,1,
MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw)))
goto err;
sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks;
info->opt_flag|=WRITE_CACHE_USED;
info->rec_cache.file=info->dfile;
if (!mi_alloc_rec_buff(info, -1, &sort_param.record) ||
!mi_alloc_rec_buff(info, -1, &sort_param.rec_buff))
{
mi_check_print_error(param, ""Not enough memory for extra record"");
goto err;
}
if (!rep_quick)
{
if ((new_file= mysql_file_create(mi_key_file_datatmp,
fn_format(param->temp_filename,
share->data_file_name, """",
DATA_TMP_EXT, 2+4),
0, param->tmpfile_createflag,
MYF(0))) < 0)
{
mi_check_print_error(param,""Can't create new tempfile: '%s'"",
param->temp_filename);
goto err;
}
if (new_header_length &&
filecopy(param, new_file,info->dfile,0L,new_header_length,
""datafile-header""))
goto err;
if (param->testflag & T_UNPACK)
{
share->options&= ~HA_OPTION_COMPRESS_RECORD;
mi_int2store(share->state.header.options,share->options);
}
share->state.dellink= HA_OFFSET_ERROR;
info->rec_cache.file=new_file;
}
info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);
mi_drop_all_indexes(param, info, FALSE);
key_map= share->state.key_map;
if (param->testflag & T_CREATE_MISSING_KEYS)
{
key_map= ~key_map;
}
sort_info.info=info;
sort_info.param = param;
set_data_file_type(&sort_info, share);
sort_param.filepos=new_header_length;
sort_info.dupp=0;
sort_info.buff=0;
param->read_cache.end_of_file=sort_info.filelength=
mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0));
sort_param.wordlist=NULL;
init_alloc_root(&sort_param.wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);
if (share->data_file_type == DYNAMIC_RECORD)
length=max(share->base.min_pack_length+1,share->base.min_block_length);
else if (share->data_file_type == COMPRESSED_RECORD)
length=share->base.min_block_length;
else
length=share->base.pack_reclength;
sort_info.max_records=
((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records :
(ha_rows) (sort_info.filelength/length+1));
sort_param.key_cmp=sort_key_cmp;
sort_param.lock_in_memory=lock_memory;
sort_param.tmpdir=param->tmpdir;
sort_param.sort_info=&sort_info;
sort_param.fix_datafile= (my_bool) (! rep_quick);
sort_param.master =1;
del=info->state->del;
param->glob_crc=0;
if (param->testflag & T_CALC_CHECKSUM)
sort_param.calc_checksum= 1;
rec_per_key_part= param->rec_per_key_part;
for (sort_param.key=0 ; sort_param.key < share->base.keys ;
rec_per_key_part+=sort_param.keyinfo->keysegs, sort_param.key++)
{
sort_param.read_cache=param->read_cache;
sort_param.keyinfo=share->keyinfo+sort_param.key;
sort_param.seg=sort_param.keyinfo->seg;
if (! mi_is_key_active(key_map, sort_param.key))
{
memcpy((char*) rec_per_key_part,
(char*) (share->state.rec_per_key_part +
(uint) (rec_per_key_part - param->rec_per_key_part)),
sort_param.keyinfo->keysegs*sizeof(*rec_per_key_part));
DBUG_PRINT(""repair"", (""skipping seemingly disabled index #: %u"",
sort_param.key));
continue;
}
if ((!(param->testflag & T_SILENT)))
printf (""- Fixing index %d\n"",sort_param.key+1);
sort_param.max_pos=sort_param.pos=share->pack.header_length;
keyseg=sort_param.seg;
bzero((char*) sort_param.unique,sizeof(sort_param.unique));
sort_param.key_length=share->rec_reflength;
for (i=0 ; keyseg[i].type != HA_KEYTYPE_END; i++)
{
sort_param.key_length+=keyseg[i].length;
if (keyseg[i].flag & HA_SPACE_PACK)
sort_param.key_length+=get_pack_length(keyseg[i].length);
if (keyseg[i].flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART))
sort_param.key_length+=2 + test(keyseg[i].length >= 127);
if (keyseg[i].flag & HA_NULL_PART)
sort_param.key_length++;
}
info->state->records=info->state->del=share->state.split=0;
info->state->empty=0;
if (sort_param.keyinfo->flag & HA_FULLTEXT)
{
uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT*
sort_param.keyinfo->seg->charset->mbmaxlen;
sort_param.key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN;
if (sort_param.keyinfo->parser == &ft_default_parser)
{
sort_info.max_records=
(ha_rows) (sort_info.filelength/ft_min_word_len+1);
}
else
{
sort_info.max_records= 10 *
max(param->sort_buffer_length, MIN_SORT_BUFFER) /
sort_param.key_length;
}
sort_param.key_read=sort_ft_key_read;
sort_param.key_write=sort_ft_key_write;
}
else
{
sort_param.key_read=sort_key_read;
sort_param.key_write=sort_key_write;
}
if (_create_index_by_sort(&sort_param,
(my_bool) (!(param->testflag & T_VERBOSE)),
param->sort_buffer_length))
{
param->retry_repair=1;
goto err;
}
sort_param.calc_checksum= 0;
free_root(&sort_param.wordroot, MYF(0));
sort_info.max_records= (ha_rows) info->state->records;
if (param->testflag & T_STATISTICS)
update_key_parts(sort_param.keyinfo, rec_per_key_part, sort_param.unique,
param->stats_method == MI_STATS_METHOD_IGNORE_NULLS?
sort_param.notnull: NULL,
(ulonglong) info->state->records);
mi_set_key_active(share->state.key_map, sort_param.key);
DBUG_PRINT(""repair"", (""set enabled index #: %u"", sort_param.key));
if (sort_param.fix_datafile)
{
param->read_cache.end_of_file=sort_param.filepos;
if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache))
goto err;
if (param->testflag & T_SAFE_REPAIR)
{
if (info->state->records+1 < start_records)
{
info->state->records=start_records;
goto err;
}
}
share->state.state.data_file_length = info->state->data_file_length=
sort_param.filepos;
share->state.version=(ulong) time((time_t*) 0);
mysql_file_close(info->dfile, MYF(0));
info->dfile=new_file;
share->data_file_type=sort_info.new_data_file_type;
share->pack.header_length=(ulong) new_header_length;
sort_param.fix_datafile=0;
}
else
info->state->data_file_length=sort_param.max_pos;
param->read_cache.file=info->dfile;
reinit_io_cache(&param->read_cache,READ_CACHE,share->pack.header_length,
1,1);
}
if (param->testflag & T_WRITE_LOOP)
{
(void) fputs(""          \r"",stdout); (void) fflush(stdout);
}
if (rep_quick && del+sort_info.dupp != info->state->del)
{
mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
mi_check_print_error(param,""Run recovery again without -q"");
got_error=1;
param->retry_repair=1;
param->testflag|=T_RETRY_WITHOUT_QUICK;
goto err;
}
if (rep_quick & T_FORCE_UNIQUENESS)
{
my_off_t skr=info->state->data_file_length+
(share->options & HA_OPTION_COMPRESS_RECORD ?
MEMMAP_EXTRA_MARGIN : 0);
#ifdef USE_RELOC
if (share->data_file_type == STATIC_RECORD &&
skr < share->base.reloc*share->base.min_pack_length)
skr=share->base.reloc*share->base.min_pack_length;
#endif
if (skr != sort_info.filelength)
if (mysql_file_chsize(info->dfile, skr, 0, MYF(0)))
mi_check_print_warning(param,
""Can't change size of datafile,  error: %d"",
my_errno);
}
if (param->testflag & T_CALC_CHECKSUM)
info->state->checksum=param->glob_crc;
if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))
mi_check_print_warning(param,
""Can't change size of indexfile, error: %d"",
my_errno);
if (!(param->testflag & T_SILENT))
{
if (start_records != info->state->records)
printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
if (sort_info.dupp)
mi_check_print_warning(param,
""%s records have been removed"",
llstr(sort_info.dupp,llbuff));
}
got_error=0;
if (&share->state.state != info->state)
memcpy( &share->state.state, info->state, sizeof(*info->state));
err:
got_error|= flush_blocks(param, share->key_cache, share->kfile);
(void) end_io_cache(&info->rec_cache);
if (!got_error)
{
if (new_file >= 0)
{
mysql_file_close(new_file, MYF(0));
info->dfile=new_file= -1;
if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,
(param->testflag & T_BACKUP_DATA ?
MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||
mi_open_datafile(info,share,name,-1))
got_error=1;
}
}
if (got_error)
{
if (! param->error_printed)
mi_check_print_error(param,""%d when fixing table"",my_errno);
if (new_file >= 0)
{
(void) mysql_file_close(new_file, MYF(0));
(void) mysql_file_delete(mi_key_file_datatmp,
param->temp_filename, MYF(MY_WME));
if (info->dfile == new_file) 
if (unlikely(mi_open_datafile(info, share, name, -1)))
param->retry_repair= 0; 
}
mi_mark_crashed_on_repair(info);
}
else if (key_map == share->state.key_map)
share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS;
share->state.changed|=STATE_NOT_SORTED_PAGES;
my_free(mi_get_rec_buff_ptr(info, sort_param.rec_buff));
my_free(mi_get_rec_buff_ptr(info, sort_param.record));
my_free(sort_info.key_block);
my_free(sort_info.ft_buf);
my_free(sort_info.buff);
(void) end_io_cache(&param->read_cache);
info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);
if (!got_error && (param->testflag & T_UNPACK))
{
share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;
share->pack.header_length=0;
}
DBUG_RETURN(got_error);
}","int mi_repair_by_sort(MI_CHECK *VAR_0, register MI_INFO *VAR_1,
const char * VAR_2, int VAR_3)
{
int VAR_4;
uint VAR_5;
ulong VAR_6;
ha_rows VAR_7;
my_off_t VAR_8,VAR_9;
File VAR_10;
MI_SORT_PARAM VAR_11;
MYISAM_SHARE *VAR_12=VAR_1->s;
HA_KEYSEG *VAR_13;
ulong   *VAR_14;
char VAR_15[22];
SORT_INFO VAR_16;
ulonglong UNINIT_VAR(key_map);
DBUG_ENTER(""mi_repair_by_sort"");
VAR_7=VAR_1->state->records;
VAR_4=1;
VAR_10= -1;
VAR_8=(VAR_0->testflag & VAR_17) ? 0 :
VAR_12->pack.header_length;
if (!(VAR_0->testflag & VAR_18))
{
printf(""- recovering (with sort) MyISAM-table '%s'\n"",VAR_2);
printf(""Data records: %s\n"", llstr(VAR_7,VAR_15));
}
VAR_0->testflag|=VAR_19; 
if (VAR_1->s->options & (VAR_20 | VAR_21))
VAR_0->testflag|=VAR_22;
bzero((char*)&VAR_16,sizeof(VAR_16));
bzero((char *)&VAR_11, sizeof(VAR_11));
if (!(VAR_16.key_block=
alloc_key_blocks(VAR_0,
(uint) VAR_0->sort_key_blocks,
VAR_12->base.max_key_block_length))
|| init_io_cache(&VAR_0->read_cache,VAR_1->dfile,
(uint) VAR_0->read_buffer_length,
VAR_23,VAR_12->pack.header_length,1,MYF(VAR_24)) ||
(! VAR_3 &&
init_io_cache(&VAR_1->rec_cache,VAR_1->dfile,
(uint) VAR_0->write_buffer_length,
VAR_25,VAR_8,1,
MYF(VAR_24 | VAR_26) & VAR_0->myf_rw)))
goto err;
VAR_16.key_block_end=VAR_16.key_block+VAR_0->sort_key_blocks;
VAR_1->opt_flag|=VAR_27;
VAR_1->rec_cache.file=VAR_1->dfile;
if (!mi_alloc_rec_buff(VAR_1, -1, &VAR_11.record) ||
!mi_alloc_rec_buff(VAR_1, -1, &VAR_11.rec_buff))
{
mi_check_print_error(VAR_0, ""Not enough memory for extra record"");
goto err;
}
if (!VAR_3)
{
if ((VAR_10= mysql_file_create(VAR_28,
fn_format(VAR_0->temp_filename,
VAR_12->data_file_name, """",
VAR_29, 2+4),
0, VAR_0->tmpfile_createflag,
MYF(0))) < 0)
{
mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
VAR_0->temp_filename);
goto err;
}
if (VAR_8 &&
filecopy(VAR_0, VAR_10,VAR_1->dfile,0L,VAR_8,
""datafile-header""))
goto err;
if (VAR_0->testflag & VAR_17)
{
VAR_12->options&= ~VAR_21;
mi_int2store(VAR_12->state.header.options,VAR_12->options);
}
VAR_12->state.dellink= VAR_30;
VAR_1->rec_cache.file=VAR_10;
}
VAR_1->update= (short) (VAR_31 | VAR_32);
mi_drop_all_indexes(VAR_0, VAR_1, FALSE);
key_map= VAR_12->state.key_map;
if (VAR_0->testflag & VAR_33)
{
key_map= ~key_map;
}
VAR_16.info=VAR_1;
VAR_16.param = VAR_0;
set_data_file_type(&VAR_16, VAR_12);
VAR_11.filepos=VAR_8;
VAR_16.dupp=0;
VAR_16.buff=0;
VAR_0->read_cache.end_of_file=VAR_16.filelength=
mysql_file_seek(VAR_0->read_cache.file, 0L, VAR_34, MYF(0));
VAR_11.wordlist=NULL;
init_alloc_root(&VAR_11.wordroot, VAR_35, 0);
if (VAR_12->data_file_type == VAR_36)
VAR_6=max(VAR_12->base.min_pack_length+1,VAR_12->base.min_block_length);
else if (VAR_12->data_file_type == VAR_37)
VAR_6=VAR_12->base.min_block_length;
else
VAR_6=VAR_12->base.pack_reclength;
VAR_16.max_records=
((VAR_0->testflag & VAR_33) ? VAR_1->state->records :
(ha_rows) (VAR_16.filelength/VAR_6+1));
VAR_11.key_cmp=VAR_38;
VAR_11.lock_in_memory=VAR_39;
VAR_11.tmpdir=VAR_0->tmpdir;
VAR_11.sort_info=&VAR_16;
VAR_11.fix_datafile= (VAR_40) (! VAR_3);
VAR_11.master =1;
VAR_9=VAR_1->state->del;
VAR_0->glob_crc=0;
if (VAR_0->testflag & VAR_22)
VAR_11.calc_checksum= 1;
VAR_14= VAR_0->rec_per_key_part;
for (VAR_11.key=0 ; VAR_11.key < VAR_12->base.keys ;
VAR_14+=VAR_11.keyinfo->keysegs, VAR_11.key++)
{
VAR_11.read_cache=VAR_0->read_cache;
VAR_11.keyinfo=VAR_12->keyinfo+VAR_11.key;
VAR_11.seg=VAR_11.keyinfo->seg;
if (! mi_is_key_active(key_map, VAR_11.key))
{
memcpy((char*) VAR_14,
(char*) (VAR_12->state.rec_per_key_part +
(uint) (VAR_14 - VAR_0->rec_per_key_part)),
VAR_11.keyinfo->keysegs*sizeof(*VAR_14));
DBUG_PRINT(""repair"", (""skipping seemingly disabled index #: %u"",
VAR_11.key));
continue;
}
if ((!(VAR_0->testflag & VAR_18)))
printf (""- Fixing index %d\n"",VAR_11.key+1);
VAR_11.max_pos=VAR_11.pos=VAR_12->pack.header_length;
VAR_13=VAR_11.seg;
bzero((char*) VAR_11.unique,sizeof(VAR_11.unique));
VAR_11.key_length=VAR_12->rec_reflength;
for (VAR_5=0 ; VAR_13[VAR_5].type != VAR_41; VAR_5++)
{
VAR_11.key_length+=VAR_13[VAR_5].length;
if (VAR_13[VAR_5].flag & VAR_42)
VAR_11.key_length+=get_pack_length(VAR_13[VAR_5].length);
if (VAR_13[VAR_5].flag & (VAR_43 | VAR_44))
VAR_11.key_length+=2 + test(VAR_13[VAR_5].length >= 127);
if (VAR_13[VAR_5].flag & VAR_45)
VAR_11.key_length++;
}
VAR_1->state->records=VAR_1->state->del=VAR_12->state.split=0;
VAR_1->state->empty=0;
if (VAR_11.keyinfo->flag & VAR_46)
{
uint VAR_47=VAR_48*
VAR_11.keyinfo->seg->charset->mbmaxlen;
VAR_11.key_length+=VAR_47-VAR_49;
if (VAR_11.keyinfo->parser == &VAR_50)
{
VAR_16.max_records=
(ha_rows) (VAR_16.filelength/VAR_51+1);
}
else
{
VAR_16.max_records= 10 *
max(VAR_0->sort_buffer_length, VAR_52) /
VAR_11.key_length;
}
VAR_11.key_read=VAR_53;
VAR_11.key_write=VAR_54;
}
else
{
VAR_11.key_read=VAR_55;
VAR_11.key_write=VAR_56;
}
if (_create_index_by_sort(&VAR_11,
(VAR_40) (!(VAR_0->testflag & VAR_57)),
VAR_0->sort_buffer_length))
{
VAR_0->retry_repair=1;
goto err;
}
VAR_11.calc_checksum= 0;
free_root(&VAR_11.wordroot, MYF(0));
VAR_16.max_records= (ha_rows) VAR_1->state->records;
if (VAR_0->testflag & VAR_58)
update_key_parts(VAR_11.keyinfo, VAR_14, VAR_11.unique,
VAR_0->stats_method == VAR_59?
VAR_11.notnull: NULL,
(ulonglong) VAR_1->state->records);
mi_set_key_active(VAR_12->state.key_map, VAR_11.key);
DBUG_PRINT(""repair"", (""set enabled index #: %u"", VAR_11.key));
if (VAR_11.fix_datafile)
{
VAR_0->read_cache.end_of_file=VAR_11.filepos;
if (write_data_suffix(&VAR_16,1) || end_io_cache(&VAR_1->rec_cache))
goto err;
if (VAR_0->testflag & VAR_60)
{
if (VAR_1->state->records+1 < VAR_7)
{
VAR_1->state->records=VAR_7;
goto err;
}
}
VAR_12->state.state.data_file_length = VAR_1->state->data_file_length=
VAR_11.filepos;
VAR_12->state.version=(ulong) time((time_t*) 0);
mysql_file_close(VAR_1->dfile, MYF(0));
VAR_1->dfile=VAR_10;
VAR_12->data_file_type=VAR_16.new_data_file_type;
VAR_12->pack.header_length=(ulong) VAR_8;
VAR_11.fix_datafile=0;
}
else
VAR_1->state->data_file_length=VAR_11.max_pos;
VAR_0->read_cache.file=VAR_1->dfile;
reinit_io_cache(&VAR_0->read_cache,VAR_23,VAR_12->pack.header_length,
1,1);
}
if (VAR_0->testflag & VAR_61)
{
(void) fputs(""          \r"",VAR_62); (void) fflush(VAR_62);
}
if (VAR_3 && VAR_9+VAR_16.dupp != VAR_1->state->del)
{
mi_check_print_error(VAR_0,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
mi_check_print_error(VAR_0,""Run recovery again without -q"");
VAR_4=1;
VAR_0->retry_repair=1;
VAR_0->testflag|=VAR_63;
goto err;
}
if (VAR_3 & VAR_64)
{
my_off_t VAR_65=VAR_1->state->data_file_length+
(VAR_12->options & VAR_21 ?
VAR_66 : 0);
#ifdef VAR_67
if (VAR_12->data_file_type == VAR_68 &&
VAR_65 < VAR_12->base.reloc*VAR_12->base.min_pack_length)
VAR_65=VAR_12->base.reloc*VAR_12->base.min_pack_length;
#endif
if (VAR_65 != VAR_16.filelength)
if (mysql_file_chsize(VAR_1->dfile, VAR_65, 0, MYF(0)))
mi_check_print_warning(VAR_0,
""Can't change size of datafile,  error: %d"",
VAR_69);
}
if (VAR_0->testflag & VAR_22)
VAR_1->state->checksum=VAR_0->glob_crc;
if (mysql_file_chsize(VAR_12->kfile, VAR_1->state->key_file_length, 0, MYF(0)))
mi_check_print_warning(VAR_0,
""Can't change size of indexfile, error: %d"",
VAR_69);
if (!(VAR_0->testflag & VAR_18))
{
if (VAR_7 != VAR_1->state->records)
printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_15));
if (VAR_16.dupp)
mi_check_print_warning(VAR_0,
""%s records have been removed"",
llstr(VAR_16.dupp,VAR_15));
}
VAR_4=0;
if (&VAR_12->state.state != VAR_1->state)
memcpy( &VAR_12->state.state, VAR_1->state, sizeof(*VAR_1->state));
err:
VAR_4|= flush_blocks(VAR_0, VAR_12->key_cache, VAR_12->kfile);
(void) end_io_cache(&VAR_1->rec_cache);
if (!VAR_4)
{
if (VAR_10 >= 0)
{
mysql_file_close(VAR_10, MYF(0));
VAR_1->dfile=VAR_10= -1;
if (change_to_newfile(VAR_12->data_file_name,VAR_70, VAR_29,
(VAR_0->testflag & VAR_71 ?
MYF(VAR_72): MYF(0))) ||
mi_open_datafile(VAR_1,VAR_12,VAR_2,-1))
VAR_4=1;
}
}
if (VAR_4)
{
if (! VAR_0->error_printed)
mi_check_print_error(VAR_0,""%d when fixing table"",VAR_69);
if (VAR_10 >= 0)
{
(void) mysql_file_close(VAR_10, MYF(0));
(void) mysql_file_delete(VAR_28,
VAR_0->temp_filename, MYF(VAR_24));
if (VAR_1->dfile == VAR_10) 
if (unlikely(mi_open_datafile(VAR_1, VAR_12, VAR_2, -1)))
VAR_0->retry_repair= 0; 
}
mi_mark_crashed_on_repair(VAR_1);
}
else if (key_map == VAR_12->state.key_map)
VAR_12->state.changed&= ~VAR_73;
VAR_12->state.changed|=VAR_74;
my_free(mi_get_rec_buff_ptr(VAR_1, VAR_11.rec_buff));
my_free(mi_get_rec_buff_ptr(VAR_1, VAR_11.record));
my_free(VAR_16.key_block);
my_free(VAR_16.ft_buf);
my_free(VAR_16.buff);
(void) end_io_cache(&VAR_0->read_cache);
VAR_1->opt_flag&= ~(VAR_75 | VAR_27);
if (!VAR_4 && (VAR_0->testflag & VAR_17))
{
VAR_12->state.header.options[0]&= (uchar) ~VAR_21;
VAR_12->pack.header_length=0;
}
DBUG_RETURN(VAR_4);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/before/3.json,"int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info,
		      const char * name, int rep_quick, my_bool no_copy_stat)
{
  int got_error;
  uint i;
  ulong length;
  ha_rows start_records;
  my_off_t new_header_length,del;
  File new_file;
  MI_SORT_PARAM sort_param;
  MYISAM_SHARE *share=info->s;
  HA_KEYSEG *keyseg;
  ulong   *rec_per_key_part;
  char llbuff[22];
  SORT_INFO sort_info;
  ulonglong UNINIT_VAR(key_map);
  DBUG_ENTER(""mi_repair_by_sort"");

  start_records=info->state->records;
  got_error=1;
  new_file= -1;
  new_header_length=(param->testflag & T_UNPACK) ? 0 :
    share->pack.header_length;
  if (!(param->testflag & T_SILENT))
  {
    printf(""- recovering (with sort) MyISAM-table '%s'\n"",name);
    printf(""Data records: %s\n"", llstr(start_records,llbuff));
  }
  param->testflag|=T_REP; /* for easy checking */

  if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))
    param->testflag|=T_CALC_CHECKSUM;

  bzero((char*)&sort_info,sizeof(sort_info));
  bzero((char *)&sort_param, sizeof(sort_param));
  if (!(sort_info.key_block=
	alloc_key_blocks(param,
			 (uint) param->sort_key_blocks,
			 share->base.max_key_block_length))
      || init_io_cache(&param->read_cache,info->dfile,
		       (uint) param->read_buffer_length,
		       READ_CACHE,share->pack.header_length,1,MYF(MY_WME)) ||
      (! rep_quick &&
       init_io_cache(&info->rec_cache,info->dfile,
		     (uint) param->write_buffer_length,
		     WRITE_CACHE,new_header_length,1,
		     MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw)))
    goto err;
  sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks;
  info->opt_flag|=WRITE_CACHE_USED;
  info->rec_cache.file=info->dfile;		/* for sort_delete_record */

  if (!mi_alloc_rec_buff(info, -1, &sort_param.record) ||
      !mi_alloc_rec_buff(info, -1, &sort_param.rec_buff))
  {
    mi_check_print_error(param, ""Not enough memory for extra record"");
    goto err;
  }
  if (!rep_quick)
  {
    /* Get real path for data file */
    if ((new_file= mysql_file_create(mi_key_file_datatmp,
                                     fn_format(param->temp_filename,
                                               share->data_file_name, """",
                                               DATA_TMP_EXT, 2+4),
                                     0, param->tmpfile_createflag,
                                     MYF(0))) < 0)
    {
      mi_check_print_error(param,""Can't create new tempfile: '%s'"",
			   param->temp_filename);
      goto err;
    }
    if (new_header_length &&
        filecopy(param, new_file,info->dfile,0L,new_header_length,
		 ""datafile-header""))
      goto err;
    if (param->testflag & T_UNPACK)
    {
      share->options&= ~HA_OPTION_COMPRESS_RECORD;
      mi_int2store(share->state.header.options,share->options);
    }
    share->state.dellink= HA_OFFSET_ERROR;
    info->rec_cache.file=new_file;
  }

  info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);

  /* Optionally drop indexes and optionally modify the key_map. */
  mi_drop_all_indexes(param, info, FALSE);
  key_map= share->state.key_map;
  if (param->testflag & T_CREATE_MISSING_KEYS)
  {
    /* Invert the copied key_map to recreate all disabled indexes. */
    key_map= ~key_map;
  }

  sort_info.info=info;
  sort_info.param = param;

  set_data_file_type(&sort_info, share);
  sort_param.filepos=new_header_length;
  sort_info.dupp=0;
  sort_info.buff=0;
  param->read_cache.end_of_file=sort_info.filelength=
    mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0));

  sort_param.wordlist=NULL;
  init_alloc_root(&sort_param.wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);

  if (share->data_file_type == DYNAMIC_RECORD)
    length=max(share->base.min_pack_length+1,share->base.min_block_length);
  else if (share->data_file_type == COMPRESSED_RECORD)
    length=share->base.min_block_length;
  else
    length=share->base.pack_reclength;
  sort_info.max_records=
    ((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records :
     (ha_rows) (sort_info.filelength/length+1));
  sort_param.key_cmp=sort_key_cmp;
  sort_param.lock_in_memory=lock_memory;
  sort_param.tmpdir=param->tmpdir;
  sort_param.sort_info=&sort_info;
  sort_param.fix_datafile= (my_bool) (! rep_quick);
  sort_param.master =1;
  
  del=info->state->del;
  param->glob_crc=0;
  if (param->testflag & T_CALC_CHECKSUM)
    sort_param.calc_checksum= 1;

  rec_per_key_part= param->rec_per_key_part;
  for (sort_param.key=0 ; sort_param.key < share->base.keys ;
       rec_per_key_part+=sort_param.keyinfo->keysegs, sort_param.key++)
  {
    sort_param.read_cache=param->read_cache;
    sort_param.keyinfo=share->keyinfo+sort_param.key;
    sort_param.seg=sort_param.keyinfo->seg;
    /*
      Skip this index if it is marked disabled in the copied
      (and possibly inverted) key_map.
    */
    if (! mi_is_key_active(key_map, sort_param.key))
    {
      /* Remember old statistics for key */
      memcpy((char*) rec_per_key_part,
	     (char*) (share->state.rec_per_key_part +
		      (uint) (rec_per_key_part - param->rec_per_key_part)),
	     sort_param.keyinfo->keysegs*sizeof(*rec_per_key_part));
      DBUG_PRINT(""repair"", (""skipping seemingly disabled index #: %u"",
                            sort_param.key));
      continue;
    }

    if ((!(param->testflag & T_SILENT)))
      printf (""- Fixing index %d\n"",sort_param.key+1);
    sort_param.max_pos=sort_param.pos=share->pack.header_length;
    keyseg=sort_param.seg;
    bzero((char*) sort_param.unique,sizeof(sort_param.unique));
    sort_param.key_length=share->rec_reflength;
    for (i=0 ; keyseg[i].type != HA_KEYTYPE_END; i++)
    {
      sort_param.key_length+=keyseg[i].length;
      if (keyseg[i].flag & HA_SPACE_PACK)
	sort_param.key_length+=get_pack_length(keyseg[i].length);
      if (keyseg[i].flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART))
	sort_param.key_length+=2 + test(keyseg[i].length >= 127);
      if (keyseg[i].flag & HA_NULL_PART)
	sort_param.key_length++;
    }
    info->state->records=info->state->del=share->state.split=0;
    info->state->empty=0;

    if (sort_param.keyinfo->flag & HA_FULLTEXT)
    {
      uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT*
                                    sort_param.keyinfo->seg->charset->mbmaxlen;
      sort_param.key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN;
      /*
        fulltext indexes may have much more entries than the
        number of rows in the table. We estimate the number here.
      */
      if (sort_param.keyinfo->parser == &ft_default_parser)
      {
        /*
          for built-in parser the number of generated index entries
          cannot be larger than the size of the data file divided
          by the minimal word's length
        */
        sort_info.max_records=
          (ha_rows) (sort_info.filelength/ft_min_word_len+1);
      }
      else
      {
        /*
          for external plugin parser we cannot tell anything at all :(
          so, we'll use all the sort memory and start from ~10 buffpeks.
          (see _create_index_by_sort)
        */
        sort_info.max_records= 10 *
                               max(param->sort_buffer_length, MIN_SORT_BUFFER) /
                               sort_param.key_length;
      }

      sort_param.key_read=sort_ft_key_read;
      sort_param.key_write=sort_ft_key_write;
    }
    else
    {
      sort_param.key_read=sort_key_read;
      sort_param.key_write=sort_key_write;
    }

    if (_create_index_by_sort(&sort_param,
			      (my_bool) (!(param->testflag & T_VERBOSE)),
                              param->sort_buffer_length))
    {
      param->retry_repair=1;
      goto err;
    }
    /* No need to calculate checksum again. */
    sort_param.calc_checksum= 0;
    free_root(&sort_param.wordroot, MYF(0));

    /* Set for next loop */
    sort_info.max_records= (ha_rows) info->state->records;

    if (param->testflag & T_STATISTICS)
      update_key_parts(sort_param.keyinfo, rec_per_key_part, sort_param.unique,
                       param->stats_method == MI_STATS_METHOD_IGNORE_NULLS?
                       sort_param.notnull: NULL,
                       (ulonglong) info->state->records);
    /* Enable this index in the permanent (not the copied) key_map. */
    mi_set_key_active(share->state.key_map, sort_param.key);
    DBUG_PRINT(""repair"", (""set enabled index #: %u"", sort_param.key));

    if (sort_param.fix_datafile)
    {
      param->read_cache.end_of_file=sort_param.filepos;
      if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache))
	goto err;
      if (param->testflag & T_SAFE_REPAIR)
      {
	/* Don't repair if we loosed more than one row */
	if (info->state->records+1 < start_records)
	{
	  info->state->records=start_records;
	  goto err;
	}
      }
      share->state.state.data_file_length = info->state->data_file_length=
	sort_param.filepos;
      /* Only whole records */
      share->state.version=(ulong) time((time_t*) 0);
      mysql_file_close(info->dfile, MYF(0));
      info->dfile=new_file;
      share->data_file_type=sort_info.new_data_file_type;
      share->pack.header_length=(ulong) new_header_length;
      sort_param.fix_datafile=0;
    }
    else
      info->state->data_file_length=sort_param.max_pos;

    param->read_cache.file=info->dfile;		/* re-init read cache */
    reinit_io_cache(&param->read_cache,READ_CACHE,share->pack.header_length,
                    1,1);
  }

  if (param->testflag & T_WRITE_LOOP)
  {
    (void) fputs(""          \r"",stdout); (void) fflush(stdout);
  }

  if (rep_quick && del+sort_info.dupp != info->state->del)
  {
    mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
    mi_check_print_error(param,""Run recovery again without -q"");
    got_error=1;
    param->retry_repair=1;
    param->testflag|=T_RETRY_WITHOUT_QUICK;
    goto err;
  }

  if (rep_quick & T_FORCE_UNIQUENESS)
  {
    my_off_t skr=info->state->data_file_length+
      (share->options & HA_OPTION_COMPRESS_RECORD ?
       MEMMAP_EXTRA_MARGIN : 0);
#ifdef USE_RELOC
    if (share->data_file_type == STATIC_RECORD &&
	skr < share->base.reloc*share->base.min_pack_length)
      skr=share->base.reloc*share->base.min_pack_length;
#endif
    if (skr != sort_info.filelength)
      if (mysql_file_chsize(info->dfile, skr, 0, MYF(0)))
	mi_check_print_warning(param,
			       ""Can't change size of datafile,  error: %d"",
			       my_errno);
  }
  if (param->testflag & T_CALC_CHECKSUM)
    info->state->checksum=param->glob_crc;

  if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))
    mi_check_print_warning(param,
			   ""Can't change size of indexfile, error: %d"",
			   my_errno);

  if (!(param->testflag & T_SILENT))
  {
    if (start_records != info->state->records)
      printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
    if (sort_info.dupp)
      mi_check_print_warning(param,
			     ""%s records have been removed"",
			     llstr(sort_info.dupp,llbuff));
  }
  got_error=0;

  if (&share->state.state != info->state)
    memcpy( &share->state.state, info->state, sizeof(*info->state));

err:
  got_error|= flush_blocks(param, share->key_cache, share->kfile);
  (void) end_io_cache(&info->rec_cache);
  if (!got_error)
  {
    /* Replace the actual file with the temporary file */
    if (new_file >= 0)
    {
      myf flags= 0;
      if (param->testflag & T_BACKUP_DATA)
        flags |= MY_REDEL_MAKE_BACKUP;
      if (no_copy_stat)
        flags |= MY_REDEL_NO_COPY_STAT;
      mysql_file_close(new_file, MYF(0));
      info->dfile=new_file= -1;
      if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,
                            flags) ||
	  mi_open_datafile(info,share,name,-1))
	got_error=1;
    }
  }
  if (got_error)
  {
    if (! param->error_printed)
      mi_check_print_error(param,""%d when fixing table"",my_errno);
    if (new_file >= 0)
    {
      (void) mysql_file_close(new_file, MYF(0));
      (void) mysql_file_delete(mi_key_file_datatmp,
                               param->temp_filename, MYF(MY_WME));
      if (info->dfile == new_file) /* Retry with key cache */
        if (unlikely(mi_open_datafile(info, share, name, -1)))
          param->retry_repair= 0; /* Safety */
    }
    mi_mark_crashed_on_repair(info);
  }
  else if (key_map == share->state.key_map)
    share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS;
  share->state.changed|=STATE_NOT_SORTED_PAGES;

  my_free(mi_get_rec_buff_ptr(info, sort_param.rec_buff));
  my_free(mi_get_rec_buff_ptr(info, sort_param.record));
  my_free(sort_info.key_block);
  my_free(sort_info.ft_buf);
  my_free(sort_info.buff);
  (void) end_io_cache(&param->read_cache);
  info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);
  if (!got_error && (param->testflag & T_UNPACK))
  {
    share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;
    share->pack.header_length=0;
  }
  DBUG_RETURN(got_error);
}","int mi_repair_by_sort(MI_CHECK *VAR_0, register MI_INFO *VAR_1,
		      const char * VAR_2, int VAR_3, my_bool VAR_4)
{
  int VAR_5;
  uint VAR_6;
  ulong VAR_7;
  ha_rows VAR_8;
  my_off_t VAR_9,VAR_10;
  File VAR_11;
  MI_SORT_PARAM VAR_12;
  MYISAM_SHARE *VAR_13=VAR_1->s;
  HA_KEYSEG *VAR_14;
  ulong   *VAR_15;
  char VAR_16[22];
  SORT_INFO VAR_17;
  ulonglong UNINIT_VAR(key_map);
  DBUG_ENTER(""mi_repair_by_sort"");

  VAR_8=VAR_1->state->records;
  VAR_5=1;
  VAR_11= -1;
  VAR_9=(VAR_0->testflag & VAR_18) ? 0 :
    VAR_13->pack.header_length;
  if (!(VAR_0->testflag & VAR_19))
  {
    printf(""- recovering (with sort) MyISAM-table '%s'\n"",VAR_2);
    printf(""Data records: %s\n"", llstr(VAR_8,VAR_16));
  }
  VAR_0->testflag|=VAR_20; /* COMMENT_0 */

  if (VAR_1->s->options & (VAR_21 | VAR_22))
    VAR_0->testflag|=VAR_23;

  bzero((char*)&VAR_17,sizeof(VAR_17));
  bzero((char *)&VAR_12, sizeof(VAR_12));
  if (!(VAR_17.key_block=
	alloc_key_blocks(VAR_0,
			 (uint) VAR_0->sort_key_blocks,
			 VAR_13->base.max_key_block_length))
      || init_io_cache(&VAR_0->read_cache,VAR_1->dfile,
		       (uint) VAR_0->read_buffer_length,
		       VAR_24,VAR_13->pack.header_length,1,MYF(VAR_25)) ||
      (! VAR_3 &&
       init_io_cache(&VAR_1->rec_cache,VAR_1->dfile,
		     (uint) VAR_0->write_buffer_length,
		     VAR_26,VAR_9,1,
		     MYF(VAR_25 | VAR_27) & VAR_0->myf_rw)))
    goto err;
  VAR_17.key_block_end=VAR_17.key_block+VAR_0->sort_key_blocks;
  VAR_1->opt_flag|=VAR_28;
  VAR_1->rec_cache.file=VAR_1->dfile;		/* COMMENT_1 */

  if (!mi_alloc_rec_buff(VAR_1, -1, &VAR_12.record) ||
      !mi_alloc_rec_buff(VAR_1, -1, &VAR_12.rec_buff))
  {
    mi_check_print_error(VAR_0, ""Not enough memory for extra record"");
    goto err;
  }
  if (!VAR_3)
  {
    /* COMMENT_2 */
    if ((VAR_11= mysql_file_create(VAR_29,
                                     fn_format(VAR_0->temp_filename,
                                               VAR_13->data_file_name, """",
                                               VAR_30, 2+4),
                                     0, VAR_0->tmpfile_createflag,
                                     MYF(0))) < 0)
    {
      mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
			   VAR_0->temp_filename);
      goto err;
    }
    if (VAR_9 &&
        filecopy(VAR_0, VAR_11,VAR_1->dfile,0L,VAR_9,
		 ""datafile-header""))
      goto err;
    if (VAR_0->testflag & VAR_18)
    {
      VAR_13->options&= ~VAR_22;
      mi_int2store(VAR_13->state.header.options,VAR_13->options);
    }
    VAR_13->state.dellink= VAR_31;
    VAR_1->rec_cache.file=VAR_11;
  }

  VAR_1->update= (short) (VAR_32 | VAR_33);

  /* COMMENT_3 */
  mi_drop_all_indexes(VAR_0, VAR_1, FALSE);
  key_map= VAR_13->state.key_map;
  if (VAR_0->testflag & VAR_34)
  {
    /* COMMENT_4 */
    key_map= ~key_map;
  }

  VAR_17.info=VAR_1;
  VAR_17.param = VAR_0;

  set_data_file_type(&VAR_17, VAR_13);
  VAR_12.filepos=VAR_9;
  VAR_17.dupp=0;
  VAR_17.buff=0;
  VAR_0->read_cache.end_of_file=VAR_17.filelength=
    mysql_file_seek(VAR_0->read_cache.file, 0L, VAR_35, MYF(0));

  VAR_12.wordlist=NULL;
  init_alloc_root(&VAR_12.wordroot, VAR_36, 0);

  if (VAR_13->data_file_type == VAR_37)
    VAR_7=max(VAR_13->base.min_pack_length+1,VAR_13->base.min_block_length);
  else if (VAR_13->data_file_type == VAR_38)
    VAR_7=VAR_13->base.min_block_length;
  else
    VAR_7=VAR_13->base.pack_reclength;
  VAR_17.max_records=
    ((VAR_0->testflag & VAR_34) ? VAR_1->state->records :
     (ha_rows) (VAR_17.filelength/VAR_7+1));
  VAR_12.key_cmp=VAR_39;
  VAR_12.lock_in_memory=VAR_40;
  VAR_12.tmpdir=VAR_0->tmpdir;
  VAR_12.sort_info=&VAR_17;
  VAR_12.fix_datafile= (my_bool) (! VAR_3);
  VAR_12.master =1;
  
  VAR_10=VAR_1->state->del;
  VAR_0->glob_crc=0;
  if (VAR_0->testflag & VAR_23)
    VAR_12.calc_checksum= 1;

  VAR_15= VAR_0->rec_per_key_part;
  for (VAR_12.key=0 ; VAR_12.key < VAR_13->base.keys ;
       VAR_15+=VAR_12.keyinfo->keysegs, VAR_12.key++)
  {
    VAR_12.read_cache=VAR_0->read_cache;
    VAR_12.keyinfo=VAR_13->keyinfo+VAR_12.key;
    VAR_12.seg=VAR_12.keyinfo->seg;
    /* COMMENT_5 */
                                                            
                                      
      
    if (! mi_is_key_active(key_map, VAR_12.key))
    {
      /* COMMENT_9 */
      memcpy((char*) VAR_15,
	     (char*) (VAR_13->state.rec_per_key_part +
		      (uint) (VAR_15 - VAR_0->rec_per_key_part)),
	     VAR_12.keyinfo->keysegs*sizeof(*VAR_15));
      DBUG_PRINT(""repair"", (""skipping seemingly disabled index #: %u"",
                            VAR_12.key));
      continue;
    }

    if ((!(VAR_0->testflag & VAR_19)))
      printf (""- Fixing index %d\n"",VAR_12.key+1);
    VAR_12.max_pos=VAR_12.pos=VAR_13->pack.header_length;
    VAR_14=VAR_12.seg;
    bzero((char*) VAR_12.unique,sizeof(VAR_12.unique));
    VAR_12.key_length=VAR_13->rec_reflength;
    for (VAR_6=0 ; VAR_14[VAR_6].type != VAR_41; VAR_6++)
    {
      VAR_12.key_length+=VAR_14[VAR_6].length;
      if (VAR_14[VAR_6].flag & VAR_42)
	VAR_12.key_length+=get_pack_length(VAR_14[VAR_6].length);
      if (VAR_14[VAR_6].flag & (VAR_43 | VAR_44))
	VAR_12.key_length+=2 + test(VAR_14[VAR_6].length >= 127);
      if (VAR_14[VAR_6].flag & VAR_45)
	VAR_12.key_length++;
    }
    VAR_1->state->records=VAR_1->state->del=VAR_13->state.split=0;
    VAR_1->state->empty=0;

    if (VAR_12.keyinfo->flag & VAR_46)
    {
      uint VAR_47=VAR_48*
                                    VAR_12.keyinfo->seg->charset->mbmaxlen;
      VAR_12.key_length+=VAR_47-VAR_49;
      /* COMMENT_10 */
                                                            
                                                                 
        
      if (VAR_12.keyinfo->parser == &VAR_50)
      {
        /* COMMENT_14 */
                                                                   
                                                                 
                                      
          
        VAR_17.max_records=
          (ha_rows) (VAR_17.filelength/VAR_51+1);
      }
      else
      {
        /* COMMENT_19 */
                                                                      
                                                                        
                                     
          
        VAR_17.max_records= 10 *
                               max(VAR_0->sort_buffer_length, VAR_52) /
                               VAR_12.key_length;
      }

      VAR_12.key_read=VAR_53;
      VAR_12.key_write=VAR_54;
    }
    else
    {
      VAR_12.key_read=VAR_55;
      VAR_12.key_write=VAR_56;
    }

    if (_create_index_by_sort(&VAR_12,
			      (my_bool) (!(VAR_0->testflag & VAR_57)),
                              VAR_0->sort_buffer_length))
    {
      VAR_0->retry_repair=1;
      goto err;
    }
    /* COMMENT_24 */
    VAR_12.calc_checksum= 0;
    free_root(&VAR_12.wordroot, MYF(0));

    /* COMMENT_25 */
    VAR_17.max_records= (ha_rows) VAR_1->state->records;

    if (VAR_0->testflag & VAR_58)
      update_key_parts(VAR_12.keyinfo, VAR_15, VAR_12.unique,
                       VAR_0->stats_method == VAR_59?
                       VAR_12.notnull: NULL,
                       (ulonglong) VAR_1->state->records);
    /* COMMENT_26 */
    mi_set_key_active(VAR_13->state.key_map, VAR_12.key);
    DBUG_PRINT(""repair"", (""set enabled index #: %u"", VAR_12.key));

    if (VAR_12.fix_datafile)
    {
      VAR_0->read_cache.end_of_file=VAR_12.filepos;
      if (write_data_suffix(&VAR_17,1) || end_io_cache(&VAR_1->rec_cache))
	goto err;
      if (VAR_0->testflag & VAR_60)
      {
	/* COMMENT_27 */
	if (VAR_1->state->records+1 < VAR_8)
	{
	  VAR_1->state->records=VAR_8;
	  goto err;
	}
      }
      VAR_13->state.state.data_file_length = VAR_1->state->data_file_length=
	VAR_12.filepos;
      /* COMMENT_28 */
      VAR_13->state.version=(ulong) time((time_t*) 0);
      mysql_file_close(VAR_1->dfile, MYF(0));
      VAR_1->dfile=VAR_11;
      VAR_13->data_file_type=VAR_17.new_data_file_type;
      VAR_13->pack.header_length=(ulong) VAR_9;
      VAR_12.fix_datafile=0;
    }
    else
      VAR_1->state->data_file_length=VAR_12.max_pos;

    VAR_0->read_cache.file=VAR_1->dfile;		/* COMMENT_29 */
    reinit_io_cache(&VAR_0->read_cache,VAR_24,VAR_13->pack.header_length,
                    1,1);
  }

  if (VAR_0->testflag & VAR_61)
  {
    (void) fputs(""          \r"",VAR_62); (void) fflush(VAR_62);
  }

  if (VAR_3 && VAR_10+VAR_17.dupp != VAR_1->state->del)
  {
    mi_check_print_error(VAR_0,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
    mi_check_print_error(VAR_0,""Run recovery again without -q"");
    VAR_5=1;
    VAR_0->retry_repair=1;
    VAR_0->testflag|=VAR_63;
    goto err;
  }

  if (VAR_3 & VAR_64)
  {
    my_off_t VAR_65=VAR_1->state->data_file_length+
      (VAR_13->options & VAR_22 ?
       VAR_66 : 0);
#ifdef VAR_67
    if (VAR_13->data_file_type == VAR_68 &&
	VAR_65 < VAR_13->base.reloc*VAR_13->base.min_pack_length)
      VAR_65=VAR_13->base.reloc*VAR_13->base.min_pack_length;
#endif
    if (VAR_65 != VAR_17.filelength)
      if (mysql_file_chsize(VAR_1->dfile, VAR_65, 0, MYF(0)))
	mi_check_print_warning(VAR_0,
			       ""Can't change size of datafile,  error: %d"",
			       VAR_69);
  }
  if (VAR_0->testflag & VAR_23)
    VAR_1->state->checksum=VAR_0->glob_crc;

  if (mysql_file_chsize(VAR_13->kfile, VAR_1->state->key_file_length, 0, MYF(0)))
    mi_check_print_warning(VAR_0,
			   ""Can't change size of indexfile, error: %d"",
			   VAR_69);

  if (!(VAR_0->testflag & VAR_19))
  {
    if (VAR_8 != VAR_1->state->records)
      printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_16));
    if (VAR_17.dupp)
      mi_check_print_warning(VAR_0,
			     ""%s records have been removed"",
			     llstr(VAR_17.dupp,VAR_16));
  }
  VAR_5=0;

  if (&VAR_13->state.state != VAR_1->state)
    memcpy( &VAR_13->state.state, VAR_1->state, sizeof(*VAR_1->state));

err:
  VAR_5|= flush_blocks(VAR_0, VAR_13->key_cache, VAR_13->kfile);
  (void) end_io_cache(&VAR_1->rec_cache);
  if (!VAR_5)
  {
    /* COMMENT_30 */
    if (VAR_11 >= 0)
    {
      myf VAR_70= 0;
      if (VAR_0->testflag & VAR_71)
        VAR_70 |= VAR_72;
      if (VAR_4)
        VAR_70 |= VAR_73;
      mysql_file_close(VAR_11, MYF(0));
      VAR_1->dfile=VAR_11= -1;
      if (change_to_newfile(VAR_13->data_file_name,VAR_74, VAR_30,
                            VAR_70) ||
	  mi_open_datafile(VAR_1,VAR_13,VAR_2,-1))
	VAR_5=1;
    }
  }
  if (VAR_5)
  {
    if (! VAR_0->error_printed)
      mi_check_print_error(VAR_0,""%d when fixing table"",VAR_69);
    if (VAR_11 >= 0)
    {
      (void) mysql_file_close(VAR_11, MYF(0));
      (void) mysql_file_delete(VAR_29,
                               VAR_0->temp_filename, MYF(VAR_25));
      if (VAR_1->dfile == VAR_11) /* COMMENT_31 */
        if (unlikely(mi_open_datafile(VAR_1, VAR_13, VAR_2, -1)))
          VAR_0->retry_repair= 0; /* COMMENT_32 */
    }
    mi_mark_crashed_on_repair(VAR_1);
  }
  else if (key_map == VAR_13->state.key_map)
    VAR_13->state.changed&= ~VAR_75;
  VAR_13->state.changed|=VAR_76;

  my_free(mi_get_rec_buff_ptr(VAR_1, VAR_12.rec_buff));
  my_free(mi_get_rec_buff_ptr(VAR_1, VAR_12.record));
  my_free(VAR_17.key_block);
  my_free(VAR_17.ft_buf);
  my_free(VAR_17.buff);
  (void) end_io_cache(&VAR_0->read_cache);
  VAR_1->opt_flag&= ~(VAR_77 | VAR_28);
  if (!VAR_5 && (VAR_0->testflag & VAR_18))
  {
    VAR_13->state.header.options[0]&= (uchar) ~VAR_22;
    VAR_13->pack.header_length=0;
  }
  DBUG_RETURN(VAR_5);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info,
-		      const char * name, int rep_quick)
+		      const char * name, int rep_quick, my_bool no_copy_stat)
 {
   int got_error;
   uint i;
@@ -326,11 +326,15 @@
     /* Replace the actual file with the temporary file */
     if (new_file >= 0)
     {
+      myf flags= 0;
+      if (param->testflag & T_BACKUP_DATA)
+        flags |= MY_REDEL_MAKE_BACKUP;
+      if (no_copy_stat)
+        flags |= MY_REDEL_NO_COPY_STAT;
       mysql_file_close(new_file, MYF(0));
       info->dfile=new_file= -1;
       if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,
-			    (param->testflag & T_BACKUP_DATA ?
-			     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||
+                            flags) ||
 	  mi_open_datafile(info,share,name,-1))
 	got_error=1;
     }","{'deleted_lines': ['\t\t      const char * name, int rep_quick)', '\t\t\t    (param->testflag & T_BACKUP_DATA ?', '\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||'], 'added_lines': ['\t\t      const char * name, int rep_quick, my_bool no_copy_stat)', '      myf flags= 0;', '      if (param->testflag & T_BACKUP_DATA)', '        flags |= MY_REDEL_MAKE_BACKUP;', '      if (no_copy_stat)', '        flags |= MY_REDEL_NO_COPY_STAT;', '                            flags) ||']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-08-16T13:35:19Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,mysql/mysql-server,"Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE

During REPAIR TABLE of a MyISAM table, a temporary data file (.TMD)
is created. When repair finishes, this file is renamed to the original
.MYD file. The problem was that during this rename, we copied the
stats from the old file to the new file with chmod/chown. If a user
managed to replace the temporary file before chmod/chown was executed,
it was possible to get an arbitrary file with the privileges of the
mysql user.

This patch fixes the problem by not copying stats from the old
file to the new file. This is not needed as the new file was
created with the correct stats. This fix only changes server
behavior - external utilities such as myisamchk still does
chmod/chown.

No test case provided since the problem involves synchronization
with file system operations.",4e5473862e6852b0f3802b0cd0c6fa10b5253291,https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,mysys/my_redel.c,my_redel,"int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)
{
int error=1;
DBUG_ENTER(""my_redel"");
DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
org_name,tmp_name,MyFlags));
if (my_copystat(org_name,tmp_name,MyFlags) < 0)
goto end;
if (MyFlags & MY_REDEL_MAKE_BACKUP)
{
char name_buff[FN_REFLEN+20];    
char ext[20];
ext[0]='-';
get_date(ext+1,2+4,(time_t) 0);
strmov(strend(ext),REDEL_EXT);
if (my_rename(org_name, fn_format(name_buff, org_name, """", ext, 2),
MyFlags))
goto end;
}
else if (my_delete_allow_opened(org_name, MyFlags))
goto end;
if (my_rename(tmp_name,org_name,MyFlags))
goto end;
error=0;
end:
DBUG_RETURN(error);
}","int my_redel(const char *VAR_0, const char *VAR_1, myf VAR_2)
{
int VAR_3=1;
DBUG_ENTER(""my_redel"");
DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
VAR_0,VAR_1,VAR_2));
if (my_copystat(VAR_0,VAR_1,VAR_2) < 0)
goto end;
if (VAR_2 & VAR_4)
{
char VAR_5[VAR_6+20];    
char VAR_7[20];
VAR_7[0]='-';
get_date(VAR_7+1,2+4,(time_t) 0);
strmov(strend(VAR_7),VAR_8);
if (my_rename(VAR_0, fn_format(VAR_5, VAR_0, """", VAR_7, 2),
VAR_2))
goto end;
}
else if (my_delete_allow_opened(VAR_0, VAR_2))
goto end;
if (my_rename(VAR_1,VAR_0,VAR_2))
goto end;
VAR_3=0;
end:
DBUG_RETURN(VAR_3);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/my_redel.c/vul/before/0.json,"int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)
{
  int error=1;
  DBUG_ENTER(""my_redel"");
  DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
		   org_name,tmp_name,MyFlags));

  if (!(MyFlags & MY_REDEL_NO_COPY_STAT))
  {
    if (my_copystat(org_name,tmp_name,MyFlags) < 0)
      goto end;
  }
  if (MyFlags & MY_REDEL_MAKE_BACKUP)
  {
    char name_buff[FN_REFLEN+20];    
    char ext[20];
    ext[0]='-';
    get_date(ext+1,2+4,(time_t) 0);
    strmov(strend(ext),REDEL_EXT);
    if (my_rename(org_name, fn_format(name_buff, org_name, """", ext, 2),
		  MyFlags))
      goto end;
  }
  else if (my_delete_allow_opened(org_name, MyFlags))
      goto end;
  if (my_rename(tmp_name,org_name,MyFlags))
    goto end;

  error=0;
end:
  DBUG_RETURN(error);
}","int my_redel(const char *VAR_0, const char *VAR_1, myf VAR_2)
{
  int VAR_3=1;
  DBUG_ENTER(""my_redel"");
  DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
		   VAR_0,VAR_1,VAR_2));

  if (!(VAR_2 & VAR_4))
  {
    if (my_copystat(VAR_0,VAR_1,VAR_2) < 0)
      goto end;
  }
  if (VAR_2 & VAR_5)
  {
    char VAR_6[VAR_7+20];    
    char VAR_8[20];
    VAR_8[0]='-';
    get_date(VAR_8+1,2+4,(time_t) 0);
    strmov(strend(VAR_8),VAR_9);
    if (my_rename(VAR_0, fn_format(VAR_6, VAR_0, """", VAR_8, 2),
		  VAR_2))
      goto end;
  }
  else if (my_delete_allow_opened(VAR_0, VAR_2))
      goto end;
  if (my_rename(VAR_1,VAR_0,VAR_2))
    goto end;

  VAR_3=0;
end:
  DBUG_RETURN(VAR_3);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/my_redel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,8 +5,11 @@
   DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
 		   org_name,tmp_name,MyFlags));
 
-  if (my_copystat(org_name,tmp_name,MyFlags) < 0)
-    goto end;
+  if (!(MyFlags & MY_REDEL_NO_COPY_STAT))
+  {
+    if (my_copystat(org_name,tmp_name,MyFlags) < 0)
+      goto end;
+  }
   if (MyFlags & MY_REDEL_MAKE_BACKUP)
   {
     char name_buff[FN_REFLEN+20];    ","{'deleted_lines': ['  if (my_copystat(org_name,tmp_name,MyFlags) < 0)', '    goto end;'], 'added_lines': ['  if (!(MyFlags & MY_REDEL_NO_COPY_STAT))', '  {', '    if (my_copystat(org_name,tmp_name,MyFlags) < 0)', '      goto end;', '  }']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-08-16T13:35:19Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,mysql/mysql-server,"Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE

During REPAIR TABLE of a MyISAM table, a temporary data file (.TMD)
is created. When repair finishes, this file is renamed to the original
.MYD file. The problem was that during this rename, we copied the
stats from the old file to the new file with chmod/chown. If a user
managed to replace the temporary file before chmod/chown was executed,
it was possible to get an arbitrary file with the privileges of the
mysql user.

This patch fixes the problem by not copying stats from the old
file to the new file. This is not needed as the new file was
created with the correct stats. This fix only changes server
behavior - external utilities such as myisamchk still does
chmod/chown.

No test case provided since the problem involves synchronization
with file system operations.",4e5473862e6852b0f3802b0cd0c6fa10b5253291,https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,storage/myisam/myisamchk.c,myisamchk,"static int myisamchk(MI_CHECK *param, char * filename)
{
int error,lock_type,recreate;
int rep_quick= param->testflag & (T_QUICK | T_FORCE_UNIQUENESS);
MI_INFO *info;
File datafile;
char llbuff[22],llbuff2[22];
my_bool state_updated=0;
MYISAM_SHARE *share;
DBUG_ENTER(""myisamchk"");
param->out_flag=error=param->warning_printed=param->error_printed=
recreate=0;
datafile=0;
param->isam_file_name=filename;
if (!(info=mi_open(filename,
(param->testflag & (T_DESCRIPT | T_READONLY)) ?
O_RDONLY : O_RDWR,
HA_OPEN_FOR_REPAIR |
((param->testflag & T_WAIT_FOREVER) ?
HA_OPEN_WAIT_IF_LOCKED :
(param->testflag & T_DESCRIPT) ?
HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED))))
{
param->error_printed=1;
switch (my_errno) {
case HA_ERR_CRASHED:
mi_check_print_error(param,""'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair"",filename);
break;
case HA_ERR_NOT_A_TABLE:
mi_check_print_error(param,""'%s' is not a MyISAM-table"",filename);
break;
case HA_ERR_CRASHED_ON_USAGE:
mi_check_print_error(param,""'%s' is marked as crashed"",filename);
break;
case HA_ERR_CRASHED_ON_REPAIR:
mi_check_print_error(param,""'%s' is marked as crashed after last repair"",filename);
break;
case HA_ERR_OLD_FILE:
mi_check_print_error(param,""'%s' is an old type of MyISAM-table"", filename);
break;
case HA_ERR_END_OF_FILE:
mi_check_print_error(param,""Couldn't read complete header from '%s'"", filename);
break;
case EAGAIN:
mi_check_print_error(param,""'%s' is locked. Use -w to wait until unlocked"",filename);
break;
case ENOENT:
mi_check_print_error(param,""File '%s' doesn't exist"",filename);
break;
case EACCES:
mi_check_print_error(param,""You don't have permission to use '%s'"",filename);
break;
default:
mi_check_print_error(param,""%d when opening MyISAM-table '%s'"",
my_errno,filename);
break;
}
DBUG_RETURN(1);
}
share=info->s;
share->options&= ~HA_OPTION_READ_ONLY_DATA; 
share->tot_locks-= share->r_locks;
share->r_locks=0;
if (param->testflag & (T_FAST | T_CHECK_ONLY_CHANGED))
{
my_bool need_to_check= mi_is_crashed(info) || share->state.open_count != 0;
if ((param->testflag & (T_REP_ANY | T_SORT_RECORDS)) &&
((share->state.changed & (STATE_CHANGED | STATE_CRASHED |
STATE_CRASHED_ON_REPAIR) ||
!(param->testflag & T_CHECK_ONLY_CHANGED))))
need_to_check=1;
if (info->s->base.keys && info->state->records)
{
if ((param->testflag & T_STATISTICS) &&
(share->state.changed & STATE_NOT_ANALYZED))
need_to_check=1;
if ((param->testflag & T_SORT_INDEX) &&
(share->state.changed & STATE_NOT_SORTED_PAGES))
need_to_check=1;
if ((param->testflag & T_REP_BY_SORT) &&
(share->state.changed & STATE_NOT_OPTIMIZED_KEYS))
need_to_check=1;
}
if ((param->testflag & T_CHECK_ONLY_CHANGED) &&
(share->state.changed & (STATE_CHANGED | STATE_CRASHED |
STATE_CRASHED_ON_REPAIR)))
need_to_check=1;
if (!need_to_check)
{
if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)
printf(""MyISAM file: %s is already checked\n"",filename);
if (mi_close(info))
{
mi_check_print_error(param,""%d when closing MyISAM-table '%s'"",
my_errno,filename);
DBUG_RETURN(1);
}
DBUG_RETURN(0);
}
}
if ((param->testflag & (T_REP_ANY | T_STATISTICS |
T_SORT_RECORDS | T_SORT_INDEX)) &&
(((param->testflag & T_UNPACK) &&
share->data_file_type == COMPRESSED_RECORD) ||
mi_uint2korr(share->state.header.state_info_length) !=
MI_STATE_INFO_SIZE ||
mi_uint2korr(share->state.header.base_info_length) !=
MI_BASE_INFO_SIZE ||
mi_is_any_intersect_keys_active(param->keys_in_use, share->base.keys,
~share->state.key_map) ||
test_if_almost_full(info) ||
info->s->state.header.file_version[3] != myisam_file_magic[3] ||
(set_collation &&
set_collation->number != share->state.header.language) ||
myisam_block_size != MI_KEY_BLOCK_LENGTH))
{
if (set_collation)
param->language= set_collation->number;
if (recreate_table(param, &info,filename))
{
(void) fprintf(stderr,
""MyISAM-table '%s' is not fixed because of errors\n"",
filename);
return(-1);
}
recreate=1;
if (!(param->testflag & T_REP_ANY))
{
param->testflag|=T_REP_BY_SORT;
if (!(param->testflag & T_SILENT))
printf(""- '%s' has old table-format. Recreating index\n"",filename);
rep_quick|=T_QUICK;
}
share=info->s;
share->tot_locks-= share->r_locks;
share->r_locks=0;
}
if (param->testflag & T_DESCRIPT)
{
param->total_files++;
param->total_records+=info->state->records;
param->total_deleted+=info->state->del;
descript(param, info, filename);
}
else
{
if (!stopwords_inited++)
ft_init_stopwords();
if (!(param->testflag & T_READONLY))
lock_type = F_WRLCK;
else
lock_type= F_RDLCK;
if (info->lock_type == F_RDLCK)
info->lock_type=F_UNLCK;
if (_mi_readinfo(info,lock_type,0))
{
mi_check_print_error(param,""Can't lock indexfile of '%s', error: %d"",
filename,my_errno);
param->error_printed=0;
goto end2;
}
mi_lock_database(info, F_EXTRA_LCK);
datafile=info->dfile;
if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))
{
if (param->testflag & T_REP_ANY)
{
ulonglong tmp=share->state.key_map;
mi_copy_keys_active(share->state.key_map, share->base.keys,
param->keys_in_use);
if (tmp != share->state.key_map)
info->update|=HA_STATE_CHANGED;
}
if (rep_quick && chk_del(param, info, param->testflag & ~T_VERBOSE))
{
if (param->testflag & T_FORCE_CREATE)
{
rep_quick=0;
mi_check_print_info(param,""Creating new data file\n"");
}
else
{
error=1;
mi_check_print_error(param,
""Quick-recover aborted; Run recovery without switch 'q'"");
}
}
if (!error)
{
if ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&
(mi_is_any_key_active(share->state.key_map) ||
(rep_quick && !param->keys_in_use && !recreate)) &&
mi_test_if_sort_rep(info, info->state->records,
info->s->state.key_map,
param->force_sort))
{
if (param->testflag & T_REP_BY_SORT)
error=mi_repair_by_sort(param,info,filename,rep_quick);
else
error=mi_repair_parallel(param,info,filename,rep_quick);
state_updated=1;
}
else if (param->testflag & T_REP_ANY)
error=mi_repair(param, info,filename,rep_quick);
}
if (!error && param->testflag & T_SORT_RECORDS)
{
#ifndef TO_BE_REMOVED
if (param->out_flag & O_NEW_DATA)
{
(void) my_close(info->dfile,MYF(MY_WME)); 
error|=change_to_newfile(filename, MI_NAME_DEXT, DATA_TMP_EXT, MYF(0));
if (mi_open_datafile(info,info->s, NULL, -1))
error=1;
param->out_flag&= ~O_NEW_DATA; 
param->read_cache.file=info->dfile;
}
#endif
if (! error)
{
uint key;
my_bool update_index=1;
for (key=0 ; key < share->base.keys; key++)
if (share->keyinfo[key].flag & (HA_BINARY_PACK_KEY|HA_FULLTEXT))
update_index=0;
error=mi_sort_records(param,info,filename,param->opt_sort_key,
(my_bool) !(param->testflag & T_REP),
update_index);
datafile=info->dfile;
if (!error && !update_index)
{
if (param->verbose)
puts(""Table had a compressed index;  We must now recreate the index"");
error=mi_repair_by_sort(param,info,filename,1);
}
}
}
if (!error && param->testflag & T_SORT_INDEX)
error=mi_sort_index(param,info,filename);
if (!error)
share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |
STATE_CRASHED_ON_REPAIR);
else
mi_mark_crashed(info);
}
else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))
{
if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)
printf(""Checking MyISAM file: %s\n"",filename);
if (!(param->testflag & T_SILENT))
printf(""Data records: %7s   Deleted blocks: %7s\n"",
llstr(info->state->records,llbuff),
llstr(info->state->del,llbuff2));
error =chk_status(param,info);
mi_intersect_keys_active(share->state.key_map, param->keys_in_use);
error =chk_size(param,info);
if (!error || !(param->testflag & (T_FAST | T_FORCE_CREATE)))
error|=chk_del(param, info,param->testflag);
if ((!error || (!(param->testflag & (T_FAST | T_FORCE_CREATE)) &&
!param->start_check_pos)))
{
error|=chk_key(param, info);
if (!error && (param->testflag & (T_STATISTICS | T_AUTO_INC)))
error=update_state_info(param, info,
((param->testflag & T_STATISTICS) ?
UPDATE_STAT : 0) |
((param->testflag & T_AUTO_INC) ?
UPDATE_AUTO_INC : 0));
}
if ((!rep_quick && !error) ||
!(param->testflag & (T_FAST | T_FORCE_CREATE)))
{
if (param->testflag & (T_EXTEND | T_MEDIUM))
(void) init_key_cache(dflt_key_cache,opt_key_cache_block_size,
param->use_buffers, 0, 0);
(void) init_io_cache(&param->read_cache,datafile,
(uint) param->read_buffer_length,
READ_CACHE,
(param->start_check_pos ?
param->start_check_pos :
share->pack.header_length),
1,
MYF(MY_WME));
lock_memory(param);
if ((info->s->options & (HA_OPTION_PACK_RECORD |
HA_OPTION_COMPRESS_RECORD)) ||
(param->testflag & (T_EXTEND | T_MEDIUM)))
error|=chk_data_link(param, info, param->testflag & T_EXTEND);
error|=flush_blocks(param, share->key_cache, share->kfile);
(void) end_io_cache(&param->read_cache);
}
if (!error)
{
if ((share->state.changed & STATE_CHANGED) &&
(param->testflag & T_UPDATE_STATE))
info->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |
STATE_CRASHED_ON_REPAIR);
}
else if (!mi_is_crashed(info) &&
(param->testflag & T_UPDATE_STATE))
{
mi_mark_crashed(info);
info->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
}
}
}
if ((param->testflag & T_AUTO_INC) ||
((param->testflag & T_REP_ANY) && info->s->base.auto_key))
update_auto_increment_key(param, info,
(my_bool) !test(param->testflag & T_AUTO_INC));
if (!(param->testflag & T_DESCRIPT))
{
if (info->update & HA_STATE_CHANGED && ! (param->testflag & T_READONLY))
error|=update_state_info(param, info,
UPDATE_OPEN_COUNT |
(((param->testflag & T_REP_ANY) ?
UPDATE_TIME : 0) |
(state_updated ? UPDATE_STAT : 0) |
((param->testflag & T_SORT_RECORDS) ?
UPDATE_SORT : 0)));
(void) lock_file(param, share->kfile,0L,F_UNLCK,""indexfile"",filename);
info->update&= ~HA_STATE_CHANGED;
}
mi_lock_database(info, F_UNLCK);
end2:
if (mi_close(info))
{
mi_check_print_error(param,""%d when closing MyISAM-table '%s'"",my_errno,filename);
DBUG_RETURN(1);
}
if (error == 0)
{
if (param->out_flag & O_NEW_DATA)
error|=change_to_newfile(filename,MI_NAME_DEXT,DATA_TMP_EXT,
((param->testflag & T_BACKUP_DATA) ?
MYF(MY_REDEL_MAKE_BACKUP) : MYF(0)));
if (param->out_flag & O_NEW_INDEX)
error|=change_to_newfile(filename, MI_NAME_IEXT, INDEX_TMP_EXT, MYF(0));
}
(void) fflush(stdout); (void) fflush(stderr);
if (param->error_printed)
{
if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))
{
(void) fprintf(stderr,
""MyISAM-table '%s' is not fixed because of errors\n"",
filename);
if (param->testflag & T_REP_ANY)
(void) fprintf(stderr,
""Try fixing it by using the --safe-recover (-o), the --force (-f) option or by not using the --quick (-q) flag\n"");
}
else if (!(param->error_printed & 2) &&
!(param->testflag & T_FORCE_CREATE))
(void) fprintf(stderr,
""MyISAM-table '%s' is corrupted\nFix it using switch \""-r\"" or \""-o\""\n"",
filename);
}
else if (param->warning_printed &&
! (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX |
T_FORCE_CREATE)))
(void) fprintf(stderr, ""MyISAM-table '%s' is usable but should be fixed\n"",
filename);
(void) fflush(stderr);
DBUG_RETURN(error);
}","static int myisamchk(MI_CHECK *VAR_0, char * VAR_1)
{
int VAR_2,VAR_3,VAR_4;
int VAR_5= VAR_0->testflag & (VAR_6 | VAR_7);
MI_INFO *VAR_8;
File VAR_9;
char VAR_10[22],VAR_11[22];
my_bool VAR_12=0;
MYISAM_SHARE *VAR_13;
DBUG_ENTER(""myisamchk"");
VAR_0->out_flag=VAR_2=VAR_0->warning_printed=VAR_0->error_printed=
VAR_4=0;
VAR_9=0;
VAR_0->isam_file_name=VAR_1;
if (!(VAR_8=mi_open(VAR_1,
(VAR_0->testflag & (VAR_14 | VAR_15)) ?
VAR_16 : VAR_17,
VAR_18 |
((VAR_0->testflag & VAR_19) ?
VAR_20 :
(VAR_0->testflag & VAR_14) ?
VAR_21 : VAR_22))))
{
VAR_0->error_printed=1;
switch (VAR_23) {
case VAR_24:
mi_check_print_error(VAR_0,""'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair"",VAR_1);
break;
case VAR_25:
mi_check_print_error(VAR_0,""'%s' is not a MyISAM-table"",VAR_1);
break;
case VAR_26:
mi_check_print_error(VAR_0,""'%s' is marked as crashed"",VAR_1);
break;
case VAR_27:
mi_check_print_error(VAR_0,""'%s' is marked as crashed after last repair"",VAR_1);
break;
case VAR_28:
mi_check_print_error(VAR_0,""'%s' is an old type of MyISAM-table"", VAR_1);
break;
case VAR_29:
mi_check_print_error(VAR_0,""Couldn't read complete header from '%s'"", VAR_1);
break;
case VAR_30:
mi_check_print_error(VAR_0,""'%s' is locked. Use -w to wait until unlocked"",VAR_1);
break;
case VAR_31:
mi_check_print_error(VAR_0,""File '%s' doesn't exist"",VAR_1);
break;
case VAR_32:
mi_check_print_error(VAR_0,""You don't have permission to use '%s'"",VAR_1);
break;
default:
mi_check_print_error(VAR_0,""%d when opening MyISAM-table '%s'"",
VAR_23,VAR_1);
break;
}
DBUG_RETURN(1);
}
VAR_13=VAR_8->s;
VAR_13->options&= ~VAR_33; 
VAR_13->tot_locks-= VAR_13->r_locks;
VAR_13->r_locks=0;
if (VAR_0->testflag & (VAR_34 | VAR_35))
{
my_bool VAR_36= mi_is_crashed(VAR_8) || VAR_13->state.open_count != 0;
if ((VAR_0->testflag & (VAR_37 | VAR_38)) &&
((VAR_13->state.changed & (VAR_39 | VAR_40 |
VAR_41) ||
!(VAR_0->testflag & VAR_35))))
VAR_36=1;
if (VAR_8->s->base.keys && VAR_8->state->records)
{
if ((VAR_0->testflag & VAR_42) &&
(VAR_13->state.changed & VAR_43))
VAR_36=1;
if ((VAR_0->testflag & VAR_44) &&
(VAR_13->state.changed & VAR_45))
VAR_36=1;
if ((VAR_0->testflag & VAR_46) &&
(VAR_13->state.changed & VAR_47))
VAR_36=1;
}
if ((VAR_0->testflag & VAR_35) &&
(VAR_13->state.changed & (VAR_39 | VAR_40 |
VAR_41)))
VAR_36=1;
if (!VAR_36)
{
if (!(VAR_0->testflag & VAR_48) || VAR_0->testflag & VAR_49)
printf(""MyISAM file: %s is already checked\n"",VAR_1);
if (mi_close(VAR_8))
{
mi_check_print_error(VAR_0,""%d when closing MyISAM-table '%s'"",
VAR_23,VAR_1);
DBUG_RETURN(1);
}
DBUG_RETURN(0);
}
}
if ((VAR_0->testflag & (VAR_37 | VAR_42 |
VAR_38 | VAR_44)) &&
(((VAR_0->testflag & VAR_50) &&
VAR_13->data_file_type == VAR_51) ||
mi_uint2korr(VAR_13->state.header.state_info_length) !=
VAR_52 ||
mi_uint2korr(VAR_13->state.header.base_info_length) !=
VAR_53 ||
mi_is_any_intersect_keys_active(VAR_0->keys_in_use, VAR_13->base.keys,
~VAR_13->state.key_map) ||
test_if_almost_full(VAR_8) ||
VAR_8->s->state.header.file_version[3] != VAR_54[3] ||
(VAR_55 &&
VAR_55->number != VAR_13->state.header.language) ||
VAR_56 != VAR_57))
{
if (VAR_55)
VAR_0->language= VAR_55->number;
if (recreate_table(VAR_0, &VAR_8,VAR_1))
{
(void) fprintf(VAR_58,
""MyISAM-table '%s' is not fixed because of errors\n"",
VAR_1);
return(-1);
}
VAR_4=1;
if (!(VAR_0->testflag & VAR_37))
{
VAR_0->testflag|=VAR_46;
if (!(VAR_0->testflag & VAR_48))
printf(""- '%s' has old table-format. Recreating index\n"",VAR_1);
VAR_5|=VAR_6;
}
VAR_13=VAR_8->s;
VAR_13->tot_locks-= VAR_13->r_locks;
VAR_13->r_locks=0;
}
if (VAR_0->testflag & VAR_14)
{
VAR_0->total_files++;
VAR_0->total_records+=VAR_8->state->records;
VAR_0->total_deleted+=VAR_8->state->del;
descript(VAR_0, VAR_8, VAR_1);
}
else
{
if (!VAR_59++)
ft_init_stopwords();
if (!(VAR_0->testflag & VAR_15))
VAR_3 = VAR_60;
else
VAR_3= VAR_61;
if (VAR_8->lock_type == VAR_61)
VAR_8->lock_type=VAR_62;
if (_mi_readinfo(VAR_8,VAR_3,0))
{
mi_check_print_error(VAR_0,""Can't lock indexfile of '%s', error: %d"",
VAR_1,VAR_23);
VAR_0->error_printed=0;
goto end2;
}
mi_lock_database(VAR_8, VAR_63);
VAR_9=VAR_8->dfile;
if (VAR_0->testflag & (VAR_37 | VAR_38 | VAR_44))
{
if (VAR_0->testflag & VAR_37)
{
ulonglong VAR_64=VAR_13->state.key_map;
mi_copy_keys_active(VAR_13->state.key_map, VAR_13->base.keys,
VAR_0->keys_in_use);
if (VAR_64 != VAR_13->state.key_map)
VAR_8->update|=VAR_65;
}
if (VAR_5 && chk_del(VAR_0, VAR_8, VAR_0->testflag & ~VAR_66))
{
if (VAR_0->testflag & VAR_67)
{
VAR_5=0;
mi_check_print_info(VAR_0,""Creating new data file\n"");
}
else
{
VAR_2=1;
mi_check_print_error(VAR_0,
""Quick-recover aborted; Run recovery without switch 'q'"");
}
}
if (!VAR_2)
{
if ((VAR_0->testflag & (VAR_46 | VAR_68)) &&
(mi_is_any_key_active(VAR_13->state.key_map) ||
(VAR_5 && !VAR_0->keys_in_use && !VAR_4)) &&
mi_test_if_sort_rep(VAR_8, VAR_8->state->records,
VAR_8->s->state.key_map,
VAR_0->force_sort))
{
if (VAR_0->testflag & VAR_46)
VAR_2=mi_repair_by_sort(VAR_0,VAR_8,VAR_1,VAR_5);
else
VAR_2=mi_repair_parallel(VAR_0,VAR_8,VAR_1,VAR_5);
VAR_12=1;
}
else if (VAR_0->testflag & VAR_37)
VAR_2=mi_repair(VAR_0, VAR_8,VAR_1,VAR_5);
}
if (!VAR_2 && VAR_0->testflag & VAR_38)
{
#ifndef VAR_69
if (VAR_0->out_flag & VAR_70)
{
(void) my_close(VAR_8->dfile,MYF(VAR_71)); 
VAR_2|=change_to_newfile(VAR_1, VAR_72, VAR_73, MYF(0));
if (mi_open_datafile(VAR_8,VAR_8->s, NULL, -1))
VAR_2=1;
VAR_0->out_flag&= ~VAR_70; 
VAR_0->read_cache.file=VAR_8->dfile;
}
#endif
if (! VAR_2)
{
uint VAR_74;
my_bool VAR_75=1;
for (VAR_74=0 ; VAR_74 < VAR_13->base.keys; VAR_74++)
if (VAR_13->keyinfo[VAR_74].flag & (VAR_76|VAR_77))
VAR_75=0;
VAR_2=mi_sort_records(VAR_0,VAR_8,VAR_1,VAR_0->opt_sort_key,
(my_bool) !(VAR_0->testflag & VAR_78),
VAR_75);
VAR_9=VAR_8->dfile;
if (!VAR_2 && !VAR_75)
{
if (VAR_0->verbose)
puts(""Table had a compressed index;  We must now recreate the index"");
VAR_2=mi_repair_by_sort(VAR_0,VAR_8,VAR_1,1);
}
}
}
if (!VAR_2 && VAR_0->testflag & VAR_44)
VAR_2=mi_sort_index(VAR_0,VAR_8,VAR_1);
if (!VAR_2)
VAR_13->state.changed&= ~(VAR_39 | VAR_40 |
VAR_41);
else
mi_mark_crashed(VAR_8);
}
else if ((VAR_0->testflag & VAR_79) || !(VAR_0->testflag & VAR_80))
{
if (!(VAR_0->testflag & VAR_48) || VAR_0->testflag & VAR_49)
printf(""Checking MyISAM file: %s\n"",VAR_1);
if (!(VAR_0->testflag & VAR_48))
printf(""Data records: %7s   Deleted blocks: %7s\n"",
llstr(VAR_8->state->records,VAR_10),
llstr(VAR_8->state->del,VAR_11));
VAR_2 =chk_status(VAR_0,VAR_8);
mi_intersect_keys_active(VAR_13->state.key_map, VAR_0->keys_in_use);
VAR_2 =chk_size(VAR_0,VAR_8);
if (!VAR_2 || !(VAR_0->testflag & (VAR_34 | VAR_67)))
VAR_2|=chk_del(VAR_0, VAR_8,VAR_0->testflag);
if ((!VAR_2 || (!(VAR_0->testflag & (VAR_34 | VAR_67)) &&
!VAR_0->start_check_pos)))
{
VAR_2|=chk_key(VAR_0, VAR_8);
if (!VAR_2 && (VAR_0->testflag & (VAR_42 | VAR_80)))
VAR_2=update_state_info(VAR_0, VAR_8,
((VAR_0->testflag & VAR_42) ?
VAR_81 : 0) |
((VAR_0->testflag & VAR_80) ?
VAR_82 : 0));
}
if ((!VAR_5 && !VAR_2) ||
!(VAR_0->testflag & (VAR_34 | VAR_67)))
{
if (VAR_0->testflag & (VAR_83 | VAR_84))
(void) init_key_cache(VAR_85,VAR_86,
VAR_0->use_buffers, 0, 0);
(void) init_io_cache(&VAR_0->read_cache,VAR_9,
(uint) VAR_0->read_buffer_length,
VAR_87,
(VAR_0->start_check_pos ?
VAR_0->start_check_pos :
VAR_13->pack.header_length),
1,
MYF(VAR_71));
lock_memory(VAR_0);
if ((VAR_8->s->options & (VAR_88 |
VAR_89)) ||
(VAR_0->testflag & (VAR_83 | VAR_84)))
VAR_2|=chk_data_link(VAR_0, VAR_8, VAR_0->testflag & VAR_83);
VAR_2|=flush_blocks(VAR_0, VAR_13->key_cache, VAR_13->kfile);
(void) end_io_cache(&VAR_0->read_cache);
}
if (!VAR_2)
{
if ((VAR_13->state.changed & VAR_39) &&
(VAR_0->testflag & VAR_90))
VAR_8->update|=VAR_65 | VAR_91;
VAR_13->state.changed&= ~(VAR_39 | VAR_40 |
VAR_41);
}
else if (!mi_is_crashed(VAR_8) &&
(VAR_0->testflag & VAR_90))
{
mi_mark_crashed(VAR_8);
VAR_8->update|=VAR_65 | VAR_91;
}
}
}
if ((VAR_0->testflag & VAR_80) ||
((VAR_0->testflag & VAR_37) && VAR_8->s->base.auto_key))
update_auto_increment_key(VAR_0, VAR_8,
(my_bool) !test(VAR_0->testflag & VAR_80));
if (!(VAR_0->testflag & VAR_14))
{
if (VAR_8->update & VAR_65 && ! (VAR_0->testflag & VAR_15))
VAR_2|=update_state_info(VAR_0, VAR_8,
VAR_92 |
(((VAR_0->testflag & VAR_37) ?
VAR_93 : 0) |
(VAR_12 ? VAR_81 : 0) |
((VAR_0->testflag & VAR_38) ?
VAR_94 : 0)));
(void) lock_file(VAR_0, VAR_13->kfile,0L,VAR_62,""indexfile"",VAR_1);
VAR_8->update&= ~VAR_65;
}
mi_lock_database(VAR_8, VAR_62);
end2:
if (mi_close(VAR_8))
{
mi_check_print_error(VAR_0,""%d when closing MyISAM-table '%s'"",VAR_23,VAR_1);
DBUG_RETURN(1);
}
if (VAR_2 == 0)
{
if (VAR_0->out_flag & VAR_70)
VAR_2|=change_to_newfile(VAR_1,VAR_72,VAR_73,
((VAR_0->testflag & VAR_95) ?
MYF(VAR_96) : MYF(0)));
if (VAR_0->out_flag & VAR_97)
VAR_2|=change_to_newfile(VAR_1, VAR_98, VAR_99, MYF(0));
}
(void) fflush(VAR_100); (void) fflush(VAR_58);
if (VAR_0->error_printed)
{
if (VAR_0->testflag & (VAR_37 | VAR_38 | VAR_44))
{
(void) fprintf(VAR_58,
""MyISAM-table '%s' is not fixed because of errors\n"",
VAR_1);
if (VAR_0->testflag & VAR_37)
(void) fprintf(VAR_58,
""Try fixing it by using the --safe-recover (-o), the --force (-f) option or by not using the --quick (-q) flag\n"");
}
else if (!(VAR_0->error_printed & 2) &&
!(VAR_0->testflag & VAR_67))
(void) fprintf(VAR_58,
""MyISAM-table '%s' is corrupted\nFix it using switch \""-r\"" or \""-o\""\n"",
VAR_1);
}
else if (VAR_0->warning_printed &&
! (VAR_0->testflag & (VAR_37 | VAR_38 | VAR_44 |
VAR_67)))
(void) fprintf(VAR_58, ""MyISAM-table '%s' is usable but should be fixed\n"",
VAR_1);
(void) fflush(VAR_58);
DBUG_RETURN(VAR_2);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/myisamchk.c/vul/before/0.json,"static int myisamchk(MI_CHECK *param, char * filename)
{
  int error,lock_type,recreate;
  int rep_quick= param->testflag & (T_QUICK | T_FORCE_UNIQUENESS);
  MI_INFO *info;
  File datafile;
  char llbuff[22],llbuff2[22];
  my_bool state_updated=0;
  MYISAM_SHARE *share;
  DBUG_ENTER(""myisamchk"");

  param->out_flag=error=param->warning_printed=param->error_printed=
    recreate=0;
  datafile=0;
  param->isam_file_name=filename;		/* For error messages */
  if (!(info=mi_open(filename,
		     (param->testflag & (T_DESCRIPT | T_READONLY)) ?
		     O_RDONLY : O_RDWR,
		     HA_OPEN_FOR_REPAIR |
		     ((param->testflag & T_WAIT_FOREVER) ?
		      HA_OPEN_WAIT_IF_LOCKED :
		      (param->testflag & T_DESCRIPT) ?
		      HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED))))
  {
    /* Avoid twice printing of isam file name */
    param->error_printed=1;
    switch (my_errno) {
    case HA_ERR_CRASHED:
      mi_check_print_error(param,""'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair"",filename);
      break;
    case HA_ERR_NOT_A_TABLE:
      mi_check_print_error(param,""'%s' is not a MyISAM-table"",filename);
      break;
    case HA_ERR_CRASHED_ON_USAGE:
      mi_check_print_error(param,""'%s' is marked as crashed"",filename);
      break;
    case HA_ERR_CRASHED_ON_REPAIR:
      mi_check_print_error(param,""'%s' is marked as crashed after last repair"",filename);
      break;
    case HA_ERR_OLD_FILE:
      mi_check_print_error(param,""'%s' is an old type of MyISAM-table"", filename);
      break;
    case HA_ERR_END_OF_FILE:
      mi_check_print_error(param,""Couldn't read complete header from '%s'"", filename);
      break;
    case EAGAIN:
      mi_check_print_error(param,""'%s' is locked. Use -w to wait until unlocked"",filename);
      break;
    case ENOENT:
      mi_check_print_error(param,""File '%s' doesn't exist"",filename);
      break;
    case EACCES:
      mi_check_print_error(param,""You don't have permission to use '%s'"",filename);
      break;
    default:
      mi_check_print_error(param,""%d when opening MyISAM-table '%s'"",
		  my_errno,filename);
      break;
    }
    DBUG_RETURN(1);
  }
  share=info->s;
  share->options&= ~HA_OPTION_READ_ONLY_DATA; /* We are modifing it */
  share->tot_locks-= share->r_locks;
  share->r_locks=0;

  /*
    Skip the checking of the file if:
    We are using --fast and the table is closed properly
    We are using --check-only-changed-tables and the table hasn't changed
  */
  if (param->testflag & (T_FAST | T_CHECK_ONLY_CHANGED))
  {
    my_bool need_to_check= mi_is_crashed(info) || share->state.open_count != 0;

    if ((param->testflag & (T_REP_ANY | T_SORT_RECORDS)) &&
	((share->state.changed & (STATE_CHANGED | STATE_CRASHED |
				  STATE_CRASHED_ON_REPAIR) ||
	  !(param->testflag & T_CHECK_ONLY_CHANGED))))
      need_to_check=1;

    if (info->s->base.keys && info->state->records)
    {
      if ((param->testflag & T_STATISTICS) &&
          (share->state.changed & STATE_NOT_ANALYZED))
        need_to_check=1;
      if ((param->testflag & T_SORT_INDEX) &&
          (share->state.changed & STATE_NOT_SORTED_PAGES))
        need_to_check=1;
      if ((param->testflag & T_REP_BY_SORT) &&
          (share->state.changed & STATE_NOT_OPTIMIZED_KEYS))
        need_to_check=1;
    }
    if ((param->testflag & T_CHECK_ONLY_CHANGED) &&
	(share->state.changed & (STATE_CHANGED | STATE_CRASHED |
				 STATE_CRASHED_ON_REPAIR)))
      need_to_check=1;
    if (!need_to_check)
    {
      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)
	printf(""MyISAM file: %s is already checked\n"",filename);
      if (mi_close(info))
      {
	mi_check_print_error(param,""%d when closing MyISAM-table '%s'"",
			     my_errno,filename);
	DBUG_RETURN(1);
      }
      DBUG_RETURN(0);
    }
  }
  if ((param->testflag & (T_REP_ANY | T_STATISTICS |
			  T_SORT_RECORDS | T_SORT_INDEX)) &&
      (((param->testflag & T_UNPACK) &&
	share->data_file_type == COMPRESSED_RECORD) ||
       mi_uint2korr(share->state.header.state_info_length) !=
       MI_STATE_INFO_SIZE ||
       mi_uint2korr(share->state.header.base_info_length) !=
       MI_BASE_INFO_SIZE ||
       mi_is_any_intersect_keys_active(param->keys_in_use, share->base.keys,
                                       ~share->state.key_map) ||
       test_if_almost_full(info) ||
       info->s->state.header.file_version[3] != myisam_file_magic[3] ||
       (set_collation &&
        set_collation->number != share->state.header.language) ||
       myisam_block_size != MI_KEY_BLOCK_LENGTH))
  {
    if (set_collation)
      param->language= set_collation->number;
    if (recreate_table(param, &info,filename))
    {
      (void) fprintf(stderr,
		   ""MyISAM-table '%s' is not fixed because of errors\n"",
	      filename);
      return(-1);
    }
    recreate=1;
    if (!(param->testflag & T_REP_ANY))
    {
      param->testflag|=T_REP_BY_SORT;		/* if only STATISTICS */
      if (!(param->testflag & T_SILENT))
	printf(""- '%s' has old table-format. Recreating index\n"",filename);
      rep_quick|=T_QUICK;
    }
    share=info->s;
    share->tot_locks-= share->r_locks;
    share->r_locks=0;
  }

  if (param->testflag & T_DESCRIPT)
  {
    param->total_files++;
    param->total_records+=info->state->records;
    param->total_deleted+=info->state->del;
    descript(param, info, filename);
  }
  else
  {
    if (!stopwords_inited++)
      ft_init_stopwords();

    if (!(param->testflag & T_READONLY))
      lock_type = F_WRLCK;			/* table is changed */
    else
      lock_type= F_RDLCK;
    if (info->lock_type == F_RDLCK)
      info->lock_type=F_UNLCK;			/* Read only table */
    if (_mi_readinfo(info,lock_type,0))
    {
      mi_check_print_error(param,""Can't lock indexfile of '%s', error: %d"",
		  filename,my_errno);
      param->error_printed=0;
      goto end2;
    }
    /*
      _mi_readinfo() has locked the table.
      We mark the table as locked (without doing file locks) to be able to
      use functions that only works on locked tables (like row caching).
    */
    mi_lock_database(info, F_EXTRA_LCK);
    datafile=info->dfile;

    if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))
    {
      if (param->testflag & T_REP_ANY)
      {
	ulonglong tmp=share->state.key_map;
	mi_copy_keys_active(share->state.key_map, share->base.keys,
                            param->keys_in_use);
	if (tmp != share->state.key_map)
	  info->update|=HA_STATE_CHANGED;
      }
      if (rep_quick && chk_del(param, info, param->testflag & ~T_VERBOSE))
      {
	if (param->testflag & T_FORCE_CREATE)
	{
	  rep_quick=0;
	  mi_check_print_info(param,""Creating new data file\n"");
	}
	else
	{
	  error=1;
	  mi_check_print_error(param,
			       ""Quick-recover aborted; Run recovery without switch 'q'"");
	}
      }
      if (!error)
      {
	if ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&
	    (mi_is_any_key_active(share->state.key_map) ||
	     (rep_quick && !param->keys_in_use && !recreate)) &&
	    mi_test_if_sort_rep(info, info->state->records,
				info->s->state.key_map,
				param->force_sort))
	{
          /*
            The new file might not be created with the right stats depending
            on how myisamchk is run, so we must copy file stats from old to new.
          */
          if (param->testflag & T_REP_BY_SORT)
            error= mi_repair_by_sort(param, info, filename, rep_quick, FALSE);
          else
            error= mi_repair_parallel(param, info, filename, rep_quick, FALSE);
	  state_updated=1;
	}
	else if (param->testflag & T_REP_ANY)
	  error= mi_repair(param, info, filename, rep_quick, FALSE);
      }
      if (!error && param->testflag & T_SORT_RECORDS)
      {
	/*
	  The data file is nowadays reopened in the repair code so we should
	  soon remove the following reopen-code
	*/
#ifndef TO_BE_REMOVED
	if (param->out_flag & O_NEW_DATA)
	{			/* Change temp file to org file */
	  (void) my_close(info->dfile,MYF(MY_WME)); /* Close new file */
	  error|=change_to_newfile(filename, MI_NAME_DEXT, DATA_TMP_EXT, MYF(0));
	  if (mi_open_datafile(info,info->s, NULL, -1))
	    error=1;
	  param->out_flag&= ~O_NEW_DATA; /* We are using new datafile */
	  param->read_cache.file=info->dfile;
	}
#endif
	if (! error)
	{
	  uint key;
	  /*
	    We can't update the index in mi_sort_records if we have a
	    prefix compressed or fulltext index
	  */
	  my_bool update_index=1;
	  for (key=0 ; key < share->base.keys; key++)
	    if (share->keyinfo[key].flag & (HA_BINARY_PACK_KEY|HA_FULLTEXT))
	      update_index=0;

	  error=mi_sort_records(param,info,filename,param->opt_sort_key,
                             /* what is the following parameter for ? */
				(my_bool) !(param->testflag & T_REP),
				update_index);
	  datafile=info->dfile;	/* This is now locked */
	  if (!error && !update_index)
	  {
	    if (param->verbose)
	      puts(""Table had a compressed index;  We must now recreate the index"");
	    error= mi_repair_by_sort(param, info, filename, 1, FALSE);
	  }
	}
      }
      if (!error && param->testflag & T_SORT_INDEX)
	error= mi_sort_index(param, info, filename, FALSE);
      if (!error)
	share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |
				 STATE_CRASHED_ON_REPAIR);
      else
	mi_mark_crashed(info);
    }
    else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))
    {
      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)
	printf(""Checking MyISAM file: %s\n"",filename);
      if (!(param->testflag & T_SILENT))
	printf(""Data records: %7s   Deleted blocks: %7s\n"",
	       llstr(info->state->records,llbuff),
	       llstr(info->state->del,llbuff2));
      error =chk_status(param,info);
      mi_intersect_keys_active(share->state.key_map, param->keys_in_use);
      error =chk_size(param,info);
      if (!error || !(param->testflag & (T_FAST | T_FORCE_CREATE)))
	error|=chk_del(param, info,param->testflag);
      if ((!error || (!(param->testflag & (T_FAST | T_FORCE_CREATE)) &&
		      !param->start_check_pos)))
      {
	error|=chk_key(param, info);
	if (!error && (param->testflag & (T_STATISTICS | T_AUTO_INC)))
	  error=update_state_info(param, info,
				  ((param->testflag & T_STATISTICS) ?
				   UPDATE_STAT : 0) |
				  ((param->testflag & T_AUTO_INC) ?
				   UPDATE_AUTO_INC : 0));
      }
      if ((!rep_quick && !error) ||
	  !(param->testflag & (T_FAST | T_FORCE_CREATE)))
      {
	if (param->testflag & (T_EXTEND | T_MEDIUM))
	  (void) init_key_cache(dflt_key_cache,opt_key_cache_block_size,
                              param->use_buffers, 0, 0);
	(void) init_io_cache(&param->read_cache,datafile,
			   (uint) param->read_buffer_length,
			   READ_CACHE,
			   (param->start_check_pos ?
			    param->start_check_pos :
			    share->pack.header_length),
			   1,
			   MYF(MY_WME));
	lock_memory(param);
	if ((info->s->options & (HA_OPTION_PACK_RECORD |
				 HA_OPTION_COMPRESS_RECORD)) ||
	    (param->testflag & (T_EXTEND | T_MEDIUM)))
	  error|=chk_data_link(param, info, param->testflag & T_EXTEND);
	error|=flush_blocks(param, share->key_cache, share->kfile);
	(void) end_io_cache(&param->read_cache);
      }
      if (!error)
      {
	if ((share->state.changed & STATE_CHANGED) &&
	    (param->testflag & T_UPDATE_STATE))
	  info->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
	share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |
				 STATE_CRASHED_ON_REPAIR);
      }
      else if (!mi_is_crashed(info) &&
	       (param->testflag & T_UPDATE_STATE))
      {						/* Mark crashed */
	mi_mark_crashed(info);
	info->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
      }
    }
  }
  if ((param->testflag & T_AUTO_INC) ||
      ((param->testflag & T_REP_ANY) && info->s->base.auto_key))
    update_auto_increment_key(param, info,
			      (my_bool) !test(param->testflag & T_AUTO_INC));

  if (!(param->testflag & T_DESCRIPT))
  {
    if (info->update & HA_STATE_CHANGED && ! (param->testflag & T_READONLY))
      error|=update_state_info(param, info,
			       UPDATE_OPEN_COUNT |
			       (((param->testflag & T_REP_ANY) ?
				 UPDATE_TIME : 0) |
				(state_updated ? UPDATE_STAT : 0) |
				((param->testflag & T_SORT_RECORDS) ?
				 UPDATE_SORT : 0)));
    (void) lock_file(param, share->kfile,0L,F_UNLCK,""indexfile"",filename);
    info->update&= ~HA_STATE_CHANGED;
  }
  mi_lock_database(info, F_UNLCK);
end2:
  if (mi_close(info))
  {
    mi_check_print_error(param,""%d when closing MyISAM-table '%s'"",my_errno,filename);
    DBUG_RETURN(1);
  }
  if (error == 0)
  {
    if (param->out_flag & O_NEW_DATA)
      error|=change_to_newfile(filename,MI_NAME_DEXT,DATA_TMP_EXT,
			       ((param->testflag & T_BACKUP_DATA) ?
				MYF(MY_REDEL_MAKE_BACKUP) : MYF(0)));
    if (param->out_flag & O_NEW_INDEX)
      error|=change_to_newfile(filename, MI_NAME_IEXT, INDEX_TMP_EXT, MYF(0));
  }
  (void) fflush(stdout); (void) fflush(stderr);
  if (param->error_printed)
  {
    if (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX))
    {
      (void) fprintf(stderr,
		   ""MyISAM-table '%s' is not fixed because of errors\n"",
		   filename);
      if (param->testflag & T_REP_ANY)
	(void) fprintf(stderr,
		     ""Try fixing it by using the --safe-recover (-o), the --force (-f) option or by not using the --quick (-q) flag\n"");
    }
    else if (!(param->error_printed & 2) &&
	     !(param->testflag & T_FORCE_CREATE))
      (void) fprintf(stderr,
      ""MyISAM-table '%s' is corrupted\nFix it using switch \""-r\"" or \""-o\""\n"",
	      filename);
  }
  else if (param->warning_printed &&
	   ! (param->testflag & (T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX |
			  T_FORCE_CREATE)))
    (void) fprintf(stderr, ""MyISAM-table '%s' is usable but should be fixed\n"",
		 filename);
  (void) fflush(stderr);
  DBUG_RETURN(error);
}","static int myisamchk(MI_CHECK *VAR_0, char * VAR_1)
{
  int VAR_2,VAR_3,VAR_4;
  int VAR_5= VAR_0->testflag & (VAR_6 | VAR_7);
  MI_INFO *VAR_8;
  File VAR_9;
  char VAR_10[22],VAR_11[22];
  my_bool VAR_12=0;
  MYISAM_SHARE *VAR_13;
  DBUG_ENTER(""myisamchk"");

  VAR_0->out_flag=VAR_2=VAR_0->warning_printed=VAR_0->error_printed=
    VAR_4=0;
  VAR_9=0;
  VAR_0->isam_file_name=VAR_1;		/* COMMENT_0 */
  if (!(VAR_8=mi_open(VAR_1,
		     (VAR_0->testflag & (VAR_14 | VAR_15)) ?
		     VAR_16 : VAR_17,
		     VAR_18 |
		     ((VAR_0->testflag & VAR_19) ?
		      VAR_20 :
		      (VAR_0->testflag & VAR_14) ?
		      VAR_21 : VAR_22))))
  {
    /* COMMENT_1 */
    VAR_0->error_printed=1;
    switch (VAR_23) {
    case VAR_24:
      mi_check_print_error(VAR_0,""'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair"",VAR_1);
      break;
    case VAR_25:
      mi_check_print_error(VAR_0,""'%s' is not a MyISAM-table"",VAR_1);
      break;
    case VAR_26:
      mi_check_print_error(VAR_0,""'%s' is marked as crashed"",VAR_1);
      break;
    case VAR_27:
      mi_check_print_error(VAR_0,""'%s' is marked as crashed after last repair"",VAR_1);
      break;
    case VAR_28:
      mi_check_print_error(VAR_0,""'%s' is an old type of MyISAM-table"", VAR_1);
      break;
    case VAR_29:
      mi_check_print_error(VAR_0,""Couldn't read complete header from '%s'"", VAR_1);
      break;
    case VAR_30:
      mi_check_print_error(VAR_0,""'%s' is locked. Use -w to wait until unlocked"",VAR_1);
      break;
    case VAR_31:
      mi_check_print_error(VAR_0,""File '%s' doesn't exist"",VAR_1);
      break;
    case VAR_32:
      mi_check_print_error(VAR_0,""You don't have permission to use '%s'"",VAR_1);
      break;
    default:
      mi_check_print_error(VAR_0,""%d when opening MyISAM-table '%s'"",
		  VAR_23,VAR_1);
      break;
    }
    DBUG_RETURN(1);
  }
  VAR_13=VAR_8->s;
  VAR_13->options&= ~VAR_33; /* COMMENT_2 */
  VAR_13->tot_locks-= VAR_13->r_locks;
  VAR_13->r_locks=0;

  /* COMMENT_3 */
                                     
                                                        
                                                                         
    
  if (VAR_0->testflag & (VAR_34 | VAR_35))
  {
    my_bool VAR_36= mi_is_crashed(VAR_8) || VAR_13->state.open_count != 0;

    if ((VAR_0->testflag & (VAR_37 | VAR_38)) &&
	((VAR_13->state.changed & (VAR_39 | VAR_40 |
				  VAR_41) ||
	  !(VAR_0->testflag & VAR_35))))
      VAR_36=1;

    if (VAR_8->s->base.keys && VAR_8->state->records)
    {
      if ((VAR_0->testflag & VAR_42) &&
          (VAR_13->state.changed & VAR_43))
        VAR_36=1;
      if ((VAR_0->testflag & VAR_44) &&
          (VAR_13->state.changed & VAR_45))
        VAR_36=1;
      if ((VAR_0->testflag & VAR_46) &&
          (VAR_13->state.changed & VAR_47))
        VAR_36=1;
    }
    if ((VAR_0->testflag & VAR_35) &&
	(VAR_13->state.changed & (VAR_39 | VAR_40 |
				 VAR_41)))
      VAR_36=1;
    if (!VAR_36)
    {
      if (!(VAR_0->testflag & VAR_48) || VAR_0->testflag & VAR_49)
	printf(""MyISAM file: %s is already checked\n"",VAR_1);
      if (mi_close(VAR_8))
      {
	mi_check_print_error(VAR_0,""%d when closing MyISAM-table '%s'"",
			     VAR_23,VAR_1);
	DBUG_RETURN(1);
      }
      DBUG_RETURN(0);
    }
  }
  if ((VAR_0->testflag & (VAR_37 | VAR_42 |
			  VAR_38 | VAR_44)) &&
      (((VAR_0->testflag & VAR_50) &&
	VAR_13->data_file_type == VAR_51) ||
       mi_uint2korr(VAR_13->state.header.state_info_length) !=
       VAR_52 ||
       mi_uint2korr(VAR_13->state.header.base_info_length) !=
       VAR_53 ||
       mi_is_any_intersect_keys_active(VAR_0->keys_in_use, VAR_13->base.keys,
                                       ~VAR_13->state.key_map) ||
       test_if_almost_full(VAR_8) ||
       VAR_8->s->state.header.file_version[3] != VAR_54[3] ||
       (VAR_55 &&
        VAR_55->number != VAR_13->state.header.language) ||
       VAR_56 != VAR_57))
  {
    if (VAR_55)
      VAR_0->language= VAR_55->number;
    if (recreate_table(VAR_0, &VAR_8,VAR_1))
    {
      (void) fprintf(VAR_58,
		   ""MyISAM-table '%s' is not fixed because of errors\n"",
	      VAR_1);
      return(-1);
    }
    VAR_4=1;
    if (!(VAR_0->testflag & VAR_37))
    {
      VAR_0->testflag|=VAR_46;		/* COMMENT_8 */
      if (!(VAR_0->testflag & VAR_48))
	printf(""- '%s' has old table-format. Recreating index\n"",VAR_1);
      VAR_5|=VAR_6;
    }
    VAR_13=VAR_8->s;
    VAR_13->tot_locks-= VAR_13->r_locks;
    VAR_13->r_locks=0;
  }

  if (VAR_0->testflag & VAR_14)
  {
    VAR_0->total_files++;
    VAR_0->total_records+=VAR_8->state->records;
    VAR_0->total_deleted+=VAR_8->state->del;
    descript(VAR_0, VAR_8, VAR_1);
  }
  else
  {
    if (!VAR_59++)
      ft_init_stopwords();

    if (!(VAR_0->testflag & VAR_15))
      VAR_3 = VAR_60;			/* COMMENT_9 */
    else
      VAR_3= VAR_61;
    if (VAR_8->lock_type == VAR_61)
      VAR_8->lock_type=VAR_62;			/* COMMENT_10 */
    if (_mi_readinfo(VAR_8,VAR_3,0))
    {
      mi_check_print_error(VAR_0,""Can't lock indexfile of '%s', error: %d"",
		  VAR_1,VAR_23);
      VAR_0->error_printed=0;
      goto end2;
    }
    /* COMMENT_11 */
                                          
                                                                          
                                                                        
      
    mi_lock_database(VAR_8, VAR_63);
    VAR_9=VAR_8->dfile;

    if (VAR_0->testflag & (VAR_37 | VAR_38 | VAR_44))
    {
      if (VAR_0->testflag & VAR_37)
      {
	ulonglong VAR_64=VAR_13->state.key_map;
	mi_copy_keys_active(VAR_13->state.key_map, VAR_13->base.keys,
                            VAR_0->keys_in_use);
	if (VAR_64 != VAR_13->state.key_map)
	  VAR_8->update|=VAR_65;
      }
      if (VAR_5 && chk_del(VAR_0, VAR_8, VAR_0->testflag & ~VAR_66))
      {
	if (VAR_0->testflag & VAR_67)
	{
	  VAR_5=0;
	  mi_check_print_info(VAR_0,""Creating new data file\n"");
	}
	else
	{
	  VAR_2=1;
	  mi_check_print_error(VAR_0,
			       ""Quick-recover aborted; Run recovery without switch 'q'"");
	}
      }
      if (!VAR_2)
      {
	if ((VAR_0->testflag & (VAR_46 | VAR_68)) &&
	    (mi_is_any_key_active(VAR_13->state.key_map) ||
	     (VAR_5 && !VAR_0->keys_in_use && !VAR_4)) &&
	    mi_test_if_sort_rep(VAR_8, VAR_8->state->records,
				VAR_8->s->state.key_map,
				VAR_0->force_sort))
	{
          /* COMMENT_16 */
                                                                            
                                                                                
            
          if (VAR_0->testflag & VAR_46)
            VAR_2= mi_repair_by_sort(VAR_0, VAR_8, VAR_1, VAR_5, FALSE);
          else
            VAR_2= mi_repair_parallel(VAR_0, VAR_8, VAR_1, VAR_5, FALSE);
	  VAR_12=1;
	}
	else if (VAR_0->testflag & VAR_37)
	  VAR_2= mi_repair(VAR_0, VAR_8, VAR_1, VAR_5, FALSE);
      }
      if (!VAR_2 && VAR_0->testflag & VAR_38)
      {
	/* COMMENT_20 */
                                                                     
                                        
   
#ifndef VAR_69
	if (VAR_0->out_flag & VAR_70)
	{			/* COMMENT_24 */
	  (void) my_close(VAR_8->dfile,MYF(VAR_71)); /* COMMENT_25 */
	  VAR_2|=change_to_newfile(VAR_1, VAR_72, VAR_73, MYF(0));
	  if (mi_open_datafile(VAR_8,VAR_8->s, NULL, -1))
	    VAR_2=1;
	  VAR_0->out_flag&= ~VAR_70; /* COMMENT_26 */
	  VAR_0->read_cache.file=VAR_8->dfile;
	}
#endif
	if (! VAR_2)
	{
	  uint VAR_74;
	  /* COMMENT_27 */
                                                              
                                        
     
	  my_bool VAR_75=1;
	  for (VAR_74=0 ; VAR_74 < VAR_13->base.keys; VAR_74++)
	    if (VAR_13->keyinfo[VAR_74].flag & (VAR_76|VAR_77))
	      VAR_75=0;

	  VAR_2=mi_sort_records(VAR_0,VAR_8,VAR_1,VAR_0->opt_sort_key,
                             /* COMMENT_31 */
				(my_bool) !(VAR_0->testflag & VAR_78),
				VAR_75);
	  VAR_9=VAR_8->dfile;	/* COMMENT_32 */
	  if (!VAR_2 && !VAR_75)
	  {
	    if (VAR_0->verbose)
	      puts(""Table had a compressed index;  We must now recreate the index"");
	    VAR_2= mi_repair_by_sort(VAR_0, VAR_8, VAR_1, 1, FALSE);
	  }
	}
      }
      if (!VAR_2 && VAR_0->testflag & VAR_44)
	VAR_2= mi_sort_index(VAR_0, VAR_8, VAR_1, FALSE);
      if (!VAR_2)
	VAR_13->state.changed&= ~(VAR_39 | VAR_40 |
				 VAR_41);
      else
	mi_mark_crashed(VAR_8);
    }
    else if ((VAR_0->testflag & VAR_79) || !(VAR_0->testflag & VAR_80))
    {
      if (!(VAR_0->testflag & VAR_48) || VAR_0->testflag & VAR_49)
	printf(""Checking MyISAM file: %s\n"",VAR_1);
      if (!(VAR_0->testflag & VAR_48))
	printf(""Data records: %7s   Deleted blocks: %7s\n"",
	       llstr(VAR_8->state->records,VAR_10),
	       llstr(VAR_8->state->del,VAR_11));
      VAR_2 =chk_status(VAR_0,VAR_8);
      mi_intersect_keys_active(VAR_13->state.key_map, VAR_0->keys_in_use);
      VAR_2 =chk_size(VAR_0,VAR_8);
      if (!VAR_2 || !(VAR_0->testflag & (VAR_34 | VAR_67)))
	VAR_2|=chk_del(VAR_0, VAR_8,VAR_0->testflag);
      if ((!VAR_2 || (!(VAR_0->testflag & (VAR_34 | VAR_67)) &&
		      !VAR_0->start_check_pos)))
      {
	VAR_2|=chk_key(VAR_0, VAR_8);
	if (!VAR_2 && (VAR_0->testflag & (VAR_42 | VAR_80)))
	  VAR_2=update_state_info(VAR_0, VAR_8,
				  ((VAR_0->testflag & VAR_42) ?
				   VAR_81 : 0) |
				  ((VAR_0->testflag & VAR_80) ?
				   VAR_82 : 0));
      }
      if ((!VAR_5 && !VAR_2) ||
	  !(VAR_0->testflag & (VAR_34 | VAR_67)))
      {
	if (VAR_0->testflag & (VAR_83 | VAR_84))
	  (void) init_key_cache(VAR_85,VAR_86,
                              VAR_0->use_buffers, 0, 0);
	(void) init_io_cache(&VAR_0->read_cache,VAR_9,
			   (uint) VAR_0->read_buffer_length,
			   VAR_87,
			   (VAR_0->start_check_pos ?
			    VAR_0->start_check_pos :
			    VAR_13->pack.header_length),
			   1,
			   MYF(VAR_71));
	lock_memory(VAR_0);
	if ((VAR_8->s->options & (VAR_88 |
				 VAR_89)) ||
	    (VAR_0->testflag & (VAR_83 | VAR_84)))
	  VAR_2|=chk_data_link(VAR_0, VAR_8, VAR_0->testflag & VAR_83);
	VAR_2|=flush_blocks(VAR_0, VAR_13->key_cache, VAR_13->kfile);
	(void) end_io_cache(&VAR_0->read_cache);
      }
      if (!VAR_2)
      {
	if ((VAR_13->state.changed & VAR_39) &&
	    (VAR_0->testflag & VAR_90))
	  VAR_8->update|=VAR_65 | VAR_91;
	VAR_13->state.changed&= ~(VAR_39 | VAR_40 |
				 VAR_41);
      }
      else if (!mi_is_crashed(VAR_8) &&
	       (VAR_0->testflag & VAR_90))
      {						/* COMMENT_33 */
	mi_mark_crashed(VAR_8);
	VAR_8->update|=VAR_65 | VAR_91;
      }
    }
  }
  if ((VAR_0->testflag & VAR_80) ||
      ((VAR_0->testflag & VAR_37) && VAR_8->s->base.auto_key))
    update_auto_increment_key(VAR_0, VAR_8,
			      (my_bool) !test(VAR_0->testflag & VAR_80));

  if (!(VAR_0->testflag & VAR_14))
  {
    if (VAR_8->update & VAR_65 && ! (VAR_0->testflag & VAR_15))
      VAR_2|=update_state_info(VAR_0, VAR_8,
			       VAR_92 |
			       (((VAR_0->testflag & VAR_37) ?
				 VAR_93 : 0) |
				(VAR_12 ? VAR_81 : 0) |
				((VAR_0->testflag & VAR_38) ?
				 VAR_94 : 0)));
    (void) lock_file(VAR_0, VAR_13->kfile,0L,VAR_62,""indexfile"",VAR_1);
    VAR_8->update&= ~VAR_65;
  }
  mi_lock_database(VAR_8, VAR_62);
end2:
  if (mi_close(VAR_8))
  {
    mi_check_print_error(VAR_0,""%d when closing MyISAM-table '%s'"",VAR_23,VAR_1);
    DBUG_RETURN(1);
  }
  if (VAR_2 == 0)
  {
    if (VAR_0->out_flag & VAR_70)
      VAR_2|=change_to_newfile(VAR_1,VAR_72,VAR_73,
			       ((VAR_0->testflag & VAR_95) ?
				MYF(VAR_96) : MYF(0)));
    if (VAR_0->out_flag & VAR_97)
      VAR_2|=change_to_newfile(VAR_1, VAR_98, VAR_99, MYF(0));
  }
  (void) fflush(VAR_100); (void) fflush(VAR_58);
  if (VAR_0->error_printed)
  {
    if (VAR_0->testflag & (VAR_37 | VAR_38 | VAR_44))
    {
      (void) fprintf(VAR_58,
		   ""MyISAM-table '%s' is not fixed because of errors\n"",
		   VAR_1);
      if (VAR_0->testflag & VAR_37)
	(void) fprintf(VAR_58,
		     ""Try fixing it by using the --safe-recover (-o), the --force (-f) option or by not using the --quick (-q) flag\n"");
    }
    else if (!(VAR_0->error_printed & 2) &&
	     !(VAR_0->testflag & VAR_67))
      (void) fprintf(VAR_58,
      ""MyISAM-table '%s' is corrupted\nFix it using switch \""-r\"" or \""-o\""\n"",
	      VAR_1);
  }
  else if (VAR_0->warning_printed &&
	   ! (VAR_0->testflag & (VAR_37 | VAR_38 | VAR_44 |
			  VAR_67)))
    (void) fprintf(VAR_58, ""MyISAM-table '%s' is usable but should be fixed\n"",
		 VAR_1);
  (void) fflush(VAR_58);
  DBUG_RETURN(VAR_2);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/myisamchk.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -212,14 +212,18 @@
 				info->s->state.key_map,
 				param->force_sort))
 	{
+          /*
+            The new file might not be created with the right stats depending
+            on how myisamchk is run, so we must copy file stats from old to new.
+          */
           if (param->testflag & T_REP_BY_SORT)
-            error=mi_repair_by_sort(param,info,filename,rep_quick);
+            error= mi_repair_by_sort(param, info, filename, rep_quick, FALSE);
           else
-            error=mi_repair_parallel(param,info,filename,rep_quick);
+            error= mi_repair_parallel(param, info, filename, rep_quick, FALSE);
 	  state_updated=1;
 	}
 	else if (param->testflag & T_REP_ANY)
-	  error=mi_repair(param, info,filename,rep_quick);
+	  error= mi_repair(param, info, filename, rep_quick, FALSE);
       }
       if (!error && param->testflag & T_SORT_RECORDS)
       {
@@ -259,12 +263,12 @@
 	  {
 	    if (param->verbose)
 	      puts(""Table had a compressed index;  We must now recreate the index"");
-	    error=mi_repair_by_sort(param,info,filename,1);
+	    error= mi_repair_by_sort(param, info, filename, 1, FALSE);
 	  }
 	}
       }
       if (!error && param->testflag & T_SORT_INDEX)
-	error=mi_sort_index(param,info,filename);
+	error= mi_sort_index(param, info, filename, FALSE);
       if (!error)
 	share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |
 				 STATE_CRASHED_ON_REPAIR);","{'deleted_lines': ['            error=mi_repair_by_sort(param,info,filename,rep_quick);', '            error=mi_repair_parallel(param,info,filename,rep_quick);', '\t  error=mi_repair(param, info,filename,rep_quick);', '\t    error=mi_repair_by_sort(param,info,filename,1);', '\terror=mi_sort_index(param,info,filename);'], 'added_lines': ['          /*', '            The new file might not be created with the right stats depending', '            on how myisamchk is run, so we must copy file stats from old to new.', '          */', '            error= mi_repair_by_sort(param, info, filename, rep_quick, FALSE);', '            error= mi_repair_parallel(param, info, filename, rep_quick, FALSE);', '\t  error= mi_repair(param, info, filename, rep_quick, FALSE);', '\t    error= mi_repair_by_sort(param, info, filename, 1, FALSE);', '\terror= mi_sort_index(param, info, filename, FALSE);']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-08-16T13:35:19Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,mysql/mysql-server,"Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE

During REPAIR TABLE of a MyISAM table, a temporary data file (.TMD)
is created. When repair finishes, this file is renamed to the original
.MYD file. The problem was that during this rename, we copied the
stats from the old file to the new file with chmod/chown. If a user
managed to replace the temporary file before chmod/chown was executed,
it was possible to get an arbitrary file with the privileges of the
mysql user.

This patch fixes the problem by not copying stats from the old
file to the new file. This is not needed as the new file was
created with the correct stats. This fix only changes server
behavior - external utilities such as myisamchk still does
chmod/chown.

No test case provided since the problem involves synchronization
with file system operations.",4e5473862e6852b0f3802b0cd0c6fa10b5253291,https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,storage/myisam/ha_myisam.cc,ha_myisam::repair,"int ha_myisam::repair(THD *thd, MI_CHECK &param, bool do_optimize)
{
int error=0;
uint local_testflag=param.testflag;
bool optimize_done= !do_optimize, statistics_done=0;
const char *old_proc_info=thd->proc_info;
char fixed_name[FN_REFLEN];
MYISAM_SHARE* share = file->s;
ha_rows rows= file->state->records;
DBUG_ENTER(""ha_myisam::repair"");
param.db_name=    table->s->db.str;
param.table_name= table->alias;
param.using_global_keycache = 1;
param.thd= thd;
param.tmpdir= &mysql_tmpdir_list;
param.out_flag= 0;
strmov(fixed_name,file->filename);
ha_release_temporary_latches(thd);
if (! thd->locked_tables_mode &&
mi_lock_database(file, table->s->tmp_table ? F_EXTRA_LCK : F_WRLCK))
{
mi_check_print_error(&param,ER(ER_CANT_LOCK),my_errno);
DBUG_RETURN(HA_ADMIN_FAILED);
}
if (!do_optimize ||
((file->state->del || share->state.split != file->state->records) &&
(!(param.testflag & T_QUICK) ||
!(share->state.changed & STATE_NOT_OPTIMIZED_KEYS))))
{
ulonglong key_map= ((local_testflag & T_CREATE_MISSING_KEYS) ?
mi_get_mask_all_keys_active(share->base.keys) :
share->state.key_map);
uint testflag=param.testflag;
#ifdef HAVE_MMAP
bool remap= test(share->file_map);
if (remap)
mi_munmap_file(file);
#endif
if (mi_test_if_sort_rep(file,file->state->records,key_map,0) &&
(local_testflag & T_REP_BY_SORT))
{
local_testflag|= T_STATISTICS;
param.testflag|= T_STATISTICS;      statistics_done=1;
if (THDVAR(thd, repair_threads)>1)
{
char buf[40];
my_snprintf(buf, 40, ""Repair with %d threads"", my_count_bits(key_map));
thd_proc_info(thd, buf);
error = mi_repair_parallel(&param, file, fixed_name,
param.testflag & T_QUICK);
thd_proc_info(thd, ""Repair done"");                                             }
else
{
thd_proc_info(thd, ""Repair by sorting"");
error = mi_repair_by_sort(&param, file, fixed_name,
param.testflag & T_QUICK);
}
}
else
{
thd_proc_info(thd, ""Repair with keycache"");
param.testflag &= ~T_REP_BY_SORT;
error=  mi_repair(&param, file, fixed_name,
param.testflag & T_QUICK);
}
#ifdef HAVE_MMAP
if (remap)
mi_dynmap_file(file, file->state->data_file_length);
#endif
param.testflag=testflag;
optimize_done=1;
}
if (!error)
{
if ((local_testflag & T_SORT_INDEX) &&
(share->state.changed & STATE_NOT_SORTED_PAGES))
{
optimize_done=1;
thd_proc_info(thd, ""Sorting index"");
error=mi_sort_index(&param,file,fixed_name);
}
if (!statistics_done && (local_testflag & T_STATISTICS))
{
if (share->state.changed & STATE_NOT_ANALYZED)
{
optimize_done=1;
thd_proc_info(thd, ""Analyzing"");
error = chk_key(&param, file);
}
else
local_testflag&= ~T_STATISTICS;    }
}
thd_proc_info(thd, ""Saving state"");
if (!error)
{
if ((share->state.changed & STATE_CHANGED) || mi_is_crashed(file))
{
share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |
STATE_CRASHED_ON_REPAIR);
file->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
}
if (file->state != &file->s->state.state)
file->s->state.state = *file->state;
if (file->s->base.auto_key)
update_auto_increment_key(&param, file, 1);
if (optimize_done)
error = update_state_info(&param, file,
UPDATE_TIME | UPDATE_OPEN_COUNT |
(local_testflag &
T_STATISTICS ? UPDATE_STAT : 0));
info(HA_STATUS_NO_LOCK | HA_STATUS_TIME | HA_STATUS_VARIABLE |
HA_STATUS_CONST);
if (rows != file->state->records && ! (param.testflag & T_VERY_SILENT))
{
char llbuff[22],llbuff2[22];
mi_check_print_warning(&param,""Number of rows changed from %s to %s"",
llstr(rows,llbuff),
llstr(file->state->records,llbuff2));
}
}
else
{
mi_mark_crashed_on_repair(file);
file->update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
update_state_info(&param, file, 0);
}
thd_proc_info(thd, old_proc_info);
if (! thd->locked_tables_mode)
mi_lock_database(file,F_UNLCK);
DBUG_RETURN(error ? HA_ADMIN_FAILED :
!optimize_done ? HA_ADMIN_ALREADY_DONE : HA_ADMIN_OK);
}","int ha_myisam::repair(THD *VAR_0, MI_CHECK &VAR_1, bool VAR_2)
{
int VAR_3=0;
uint VAR_4=VAR_1.testflag;
bool VAR_5= !VAR_2, VAR_6=0;
const char *VAR_7=VAR_0->proc_info;
char VAR_8[VAR_9];
MYISAM_SHARE* VAR_10 = VAR_11->s;
ha_rows VAR_12= VAR_11->state->records;
DBUG_ENTER(""ha_myisam::repair"");
VAR_1.db_name=    VAR_13->s->db.str;
VAR_1.table_name= VAR_13->alias;
VAR_1.using_global_keycache = 1;
VAR_1.thd= VAR_0;
VAR_1.tmpdir= &VAR_14;
VAR_1.out_flag= 0;
strmov(VAR_8,VAR_11->filename);
ha_release_temporary_latches(VAR_0);
if (! VAR_0->locked_tables_mode &&
mi_lock_database(VAR_11, VAR_13->s->tmp_table ? VAR_15 : VAR_16))
{
mi_check_print_error(&VAR_1,ER(VAR_17),VAR_18);
DBUG_RETURN(VAR_19);
}
if (!VAR_2 ||
((VAR_11->state->del || VAR_10->state.split != VAR_11->state->records) &&
(!(VAR_1.testflag & VAR_20) ||
!(VAR_10->state.changed & VAR_21))))
{
ulonglong VAR_22= ((VAR_4 & VAR_23) ?
mi_get_mask_all_keys_active(VAR_10->base.keys) :
VAR_10->state.key_map);
uint VAR_24=VAR_1.testflag;
#ifdef VAR_25
bool VAR_26= test(VAR_10->file_map);
if (VAR_26)
mi_munmap_file(VAR_11);
#endif
if (mi_test_if_sort_rep(VAR_11,VAR_11->state->records,VAR_22,0) &&
(VAR_4 & VAR_27))
{
VAR_4|= VAR_28;
VAR_1.testflag|= VAR_28;
VAR_6=1;
if (THDVAR(VAR_0, VAR_29)>1)
{
char VAR_30[40];
my_snprintf(VAR_30, 40, ""Repair with %d threads"", my_count_bits(VAR_22));
thd_proc_info(VAR_0, VAR_30);
VAR_3 = mi_repair_parallel(&VAR_1, VAR_11, VAR_8,
VAR_1.testflag & VAR_20);
thd_proc_info(VAR_0, ""Repair done""); 
}
else
{
thd_proc_info(VAR_0, ""Repair by sorting"");
VAR_3 = mi_repair_by_sort(&VAR_1, VAR_11, VAR_8,
VAR_1.testflag & VAR_20);
}
}
else
{
thd_proc_info(VAR_0, ""Repair with keycache"");
VAR_1.testflag &= ~VAR_27;
VAR_3=  mi_repair(&VAR_1, VAR_11, VAR_8,
VAR_1.testflag & VAR_20);
}
#ifdef VAR_25
if (VAR_26)
mi_dynmap_file(VAR_11, VAR_11->state->data_file_length);
#endif
VAR_1.testflag=VAR_24;
VAR_5=1;
}
if (!VAR_3)
{
if ((VAR_4 & VAR_31) &&
(VAR_10->state.changed & VAR_32))
{
VAR_5=1;
thd_proc_info(VAR_0, ""Sorting index"");
VAR_3=mi_sort_index(&VAR_1,VAR_11,VAR_8);
}
if (!VAR_6 && (VAR_4 & VAR_28))
{
if (VAR_10->state.changed & VAR_33)
{
VAR_5=1;
thd_proc_info(VAR_0, ""Analyzing"");
VAR_3 = chk_key(&VAR_1, VAR_11);
}
else
VAR_4&= ~VAR_28;
}
}
thd_proc_info(VAR_0, ""Saving state"");
if (!VAR_3)
{
if ((VAR_10->state.changed & VAR_34) || mi_is_crashed(VAR_11))
{
VAR_10->state.changed&= ~(VAR_34 | VAR_35 |
VAR_36);
VAR_11->update|=VAR_37 | VAR_38;
}
if (VAR_11->state != &VAR_11->s->state.state)
VAR_11->s->state.state = *VAR_11->state;
if (VAR_11->s->base.auto_key)
update_auto_increment_key(&VAR_1, VAR_11, 1);
if (VAR_5)
VAR_3 = update_state_info(&VAR_1, VAR_11,
VAR_39 | VAR_40 |
(VAR_4 &
VAR_28 ? VAR_41 : 0));
info(VAR_42 | VAR_43 | VAR_44 |
VAR_45);
if (VAR_12 != VAR_11->state->records && ! (VAR_1.testflag & VAR_46))
{
char VAR_47[22],VAR_48[22];
mi_check_print_warning(&VAR_1,""Number of rows changed from %s to %s"",
llstr(VAR_12,VAR_47),
llstr(VAR_11->state->records,VAR_48));
}
}
else
{
mi_mark_crashed_on_repair(VAR_11);
VAR_11->update |= VAR_37 | VAR_38;
update_state_info(&VAR_1, VAR_11, 0);
}
thd_proc_info(VAR_0, VAR_7);
if (! VAR_0->locked_tables_mode)
mi_lock_database(VAR_11,VAR_49);
DBUG_RETURN(VAR_3 ? VAR_19 :
!VAR_5 ? VAR_50 : VAR_51);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/ha_myisam.cc/vul/before/0.json,"int ha_myisam::repair(THD *thd, MI_CHECK &param, bool do_optimize)
{
  int error=0;
  uint local_testflag=param.testflag;
  bool optimize_done= !do_optimize, statistics_done=0;
  const char *old_proc_info=thd->proc_info;
  char fixed_name[FN_REFLEN];
  MYISAM_SHARE* share = file->s;
  ha_rows rows= file->state->records;
  DBUG_ENTER(""ha_myisam::repair"");

  param.db_name=    table->s->db.str;
  param.table_name= table->alias;
  param.using_global_keycache = 1;
  param.thd= thd;
  param.tmpdir= &mysql_tmpdir_list;
  param.out_flag= 0;
  strmov(fixed_name,file->filename);

  // Release latches since this can take a long time
  ha_release_temporary_latches(thd);

  // Don't lock tables if we have used LOCK TABLE
  if (! thd->locked_tables_mode &&
      mi_lock_database(file, table->s->tmp_table ? F_EXTRA_LCK : F_WRLCK))
  {
    mi_check_print_error(&param,ER(ER_CANT_LOCK),my_errno);
    DBUG_RETURN(HA_ADMIN_FAILED);
  }

  if (!do_optimize ||
      ((file->state->del || share->state.split != file->state->records) &&
       (!(param.testflag & T_QUICK) ||
	!(share->state.changed & STATE_NOT_OPTIMIZED_KEYS))))
  {
    ulonglong key_map= ((local_testflag & T_CREATE_MISSING_KEYS) ?
			mi_get_mask_all_keys_active(share->base.keys) :
			share->state.key_map);
    uint testflag=param.testflag;
#ifdef HAVE_MMAP
    bool remap= test(share->file_map);
    /*
      mi_repair*() functions family use file I/O even if memory
      mapping is available.

      Since mixing mmap I/O and file I/O may cause various artifacts,
      memory mapping must be disabled.
    */
    if (remap)
      mi_munmap_file(file);
#endif
    if (mi_test_if_sort_rep(file,file->state->records,key_map,0) &&
	(local_testflag & T_REP_BY_SORT))
    {
      local_testflag|= T_STATISTICS;
      param.testflag|= T_STATISTICS;		// We get this for free
      statistics_done=1;
      if (THDVAR(thd, repair_threads)>1)
      {
        char buf[40];
        /* TODO: respect myisam_repair_threads variable */
        my_snprintf(buf, 40, ""Repair with %d threads"", my_count_bits(key_map));
        thd_proc_info(thd, buf);
        /*
          The new file is created with the right stats, so we can skip
          copying file stats from old to new.
        */
        error = mi_repair_parallel(&param, file, fixed_name,
                                   param.testflag & T_QUICK, TRUE);
        thd_proc_info(thd, ""Repair done""); // to reset proc_info, as
                                      // it was pointing to local buffer
      }
      else
      {
        thd_proc_info(thd, ""Repair by sorting"");
        /*
          The new file is created with the right stats, so we can skip
          copying file stats from old to new.
        */
        error = mi_repair_by_sort(&param, file, fixed_name,
                                  param.testflag & T_QUICK, TRUE);
      }
    }
    else
    {
      thd_proc_info(thd, ""Repair with keycache"");
      param.testflag &= ~T_REP_BY_SORT;
      /*
        The new file is created with the right stats, so we can skip
        copying file stats from old to new.
      */
      error=  mi_repair(&param, file, fixed_name,
			param.testflag & T_QUICK, TRUE);
    }
#ifdef HAVE_MMAP
    if (remap)
      mi_dynmap_file(file, file->state->data_file_length);
#endif
    param.testflag=testflag;
    optimize_done=1;
  }
  if (!error)
  {
    if ((local_testflag & T_SORT_INDEX) &&
	(share->state.changed & STATE_NOT_SORTED_PAGES))
    {
      optimize_done=1;
      thd_proc_info(thd, ""Sorting index"");
      /*
        The new file is created with the right stats, so we can skip
        copying file stats from old to new.
      */
      error=mi_sort_index(&param,file,fixed_name, TRUE);
    }
    if (!statistics_done && (local_testflag & T_STATISTICS))
    {
      if (share->state.changed & STATE_NOT_ANALYZED)
      {
	optimize_done=1;
	thd_proc_info(thd, ""Analyzing"");
	error = chk_key(&param, file);
      }
      else
	local_testflag&= ~T_STATISTICS;		// Don't update statistics
    }
  }
  thd_proc_info(thd, ""Saving state"");
  if (!error)
  {
    if ((share->state.changed & STATE_CHANGED) || mi_is_crashed(file))
    {
      share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |
			       STATE_CRASHED_ON_REPAIR);
      file->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
    }
    /*
      the following 'if', thought conceptually wrong,
      is a useful optimization nevertheless.
    */
    if (file->state != &file->s->state.state)
      file->s->state.state = *file->state;
    if (file->s->base.auto_key)
      update_auto_increment_key(&param, file, 1);
    if (optimize_done)
      error = update_state_info(&param, file,
				UPDATE_TIME | UPDATE_OPEN_COUNT |
				(local_testflag &
				 T_STATISTICS ? UPDATE_STAT : 0));
    info(HA_STATUS_NO_LOCK | HA_STATUS_TIME | HA_STATUS_VARIABLE |
	 HA_STATUS_CONST);
    if (rows != file->state->records && ! (param.testflag & T_VERY_SILENT))
    {
      char llbuff[22],llbuff2[22];
      mi_check_print_warning(&param,""Number of rows changed from %s to %s"",
			     llstr(rows,llbuff),
			     llstr(file->state->records,llbuff2));
    }
  }
  else
  {
    mi_mark_crashed_on_repair(file);
    file->update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED;
    update_state_info(&param, file, 0);
  }
  thd_proc_info(thd, old_proc_info);
  if (! thd->locked_tables_mode)
    mi_lock_database(file,F_UNLCK);
  DBUG_RETURN(error ? HA_ADMIN_FAILED :
	      !optimize_done ? HA_ADMIN_ALREADY_DONE : HA_ADMIN_OK);
}","int ha_myisam::repair(THD *VAR_0, MI_CHECK &VAR_1, bool VAR_2)
{
  int VAR_3=0;
  uint VAR_4=VAR_1.testflag;
  bool VAR_5= !VAR_2, VAR_6=0;
  const char *VAR_7=VAR_0->proc_info;
  char VAR_8[VAR_9];
  MYISAM_SHARE* VAR_10 = VAR_11->s;
  ha_rows VAR_12= VAR_11->state->records;
  DBUG_ENTER(""ha_myisam::repair"");

  VAR_1.db_name=    VAR_13->s->db.str;
  VAR_1.table_name= VAR_13->alias;
  VAR_1.using_global_keycache = 1;
  VAR_1.thd= VAR_0;
  VAR_1.tmpdir= &VAR_14;
  VAR_1.out_flag= 0;
  strmov(VAR_8,VAR_11->filename);

  /* COMMENT_0 */
  ha_release_temporary_latches(VAR_0);

  /* COMMENT_1 */
  if (! VAR_0->locked_tables_mode &&
      mi_lock_database(VAR_11, VAR_13->s->tmp_table ? VAR_15 : VAR_16))
  {
    mi_check_print_error(&VAR_1,ER(VAR_17),VAR_18);
    DBUG_RETURN(VAR_19);
  }

  if (!VAR_2 ||
      ((VAR_11->state->del || VAR_10->state.split != VAR_11->state->records) &&
       (!(VAR_1.testflag & VAR_20) ||
	!(VAR_10->state.changed & VAR_21))))
  {
    ulonglong VAR_22= ((VAR_4 & VAR_23) ?
			mi_get_mask_all_keys_active(VAR_10->base.keys) :
			VAR_10->state.key_map);
    uint VAR_24=VAR_1.testflag;
#ifdef VAR_25
    bool VAR_26= test(VAR_10->file_map);
    /* COMMENT_2 */
                                                               
                           

                                                                     
                                      
      
    if (VAR_26)
      mi_munmap_file(VAR_11);
#endif
    if (mi_test_if_sort_rep(VAR_11,VAR_11->state->records,VAR_22,0) &&
	(VAR_4 & VAR_27))
    {
      VAR_4|= VAR_28;
      VAR_1.testflag|= VAR_28;		/* COMMENT_9 */
      VAR_6=1;
      if (THDVAR(VAR_0, VAR_29)>1)
      {
        char VAR_30[40];
        /* COMMENT_10 */
        my_snprintf(VAR_30, 40, ""Repair with %d threads"", my_count_bits(VAR_22));
        thd_proc_info(VAR_0, VAR_30);
        /* COMMENT_11 */
                                                                      
                                             
          
        VAR_3 = mi_repair_parallel(&VAR_1, VAR_11, VAR_8,
                                   VAR_1.testflag & VAR_20, TRUE);
        thd_proc_info(VAR_0, ""Repair done""); /* COMMENT_15 */
                                      /* COMMENT_16 */
      }
      else
      {
        thd_proc_info(VAR_0, ""Repair by sorting"");
        /* COMMENT_17 */
                                                                      
                                             
          
        VAR_3 = mi_repair_by_sort(&VAR_1, VAR_11, VAR_8,
                                  VAR_1.testflag & VAR_20, TRUE);
      }
    }
    else
    {
      thd_proc_info(VAR_0, ""Repair with keycache"");
      VAR_1.testflag &= ~VAR_27;
      /* COMMENT_21 */
                                                                    
                                           
        
      VAR_3=  mi_repair(&VAR_1, VAR_11, VAR_8,
			VAR_1.testflag & VAR_20, TRUE);
    }
#ifdef VAR_25
    if (VAR_26)
      mi_dynmap_file(VAR_11, VAR_11->state->data_file_length);
#endif
    VAR_1.testflag=VAR_24;
    VAR_5=1;
  }
  if (!VAR_3)
  {
    if ((VAR_4 & VAR_31) &&
	(VAR_10->state.changed & VAR_32))
    {
      VAR_5=1;
      thd_proc_info(VAR_0, ""Sorting index"");
      /* COMMENT_25 */
                                                                    
                                           
        
      VAR_3=mi_sort_index(&VAR_1,VAR_11,VAR_8, TRUE);
    }
    if (!VAR_6 && (VAR_4 & VAR_28))
    {
      if (VAR_10->state.changed & VAR_33)
      {
	VAR_5=1;
	thd_proc_info(VAR_0, ""Analyzing"");
	VAR_3 = chk_key(&VAR_1, VAR_11);
      }
      else
	VAR_4&= ~VAR_28;		/* COMMENT_29 */
    }
  }
  thd_proc_info(VAR_0, ""Saving state"");
  if (!VAR_3)
  {
    if ((VAR_10->state.changed & VAR_34) || mi_is_crashed(VAR_11))
    {
      VAR_10->state.changed&= ~(VAR_34 | VAR_35 |
			       VAR_36);
      VAR_11->update|=VAR_37 | VAR_38;
    }
    /* COMMENT_30 */
                                                     
                                            
      
    if (VAR_11->state != &VAR_11->s->state.state)
      VAR_11->s->state.state = *VAR_11->state;
    if (VAR_11->s->base.auto_key)
      update_auto_increment_key(&VAR_1, VAR_11, 1);
    if (VAR_5)
      VAR_3 = update_state_info(&VAR_1, VAR_11,
				VAR_39 | VAR_40 |
				(VAR_4 &
				 VAR_28 ? VAR_41 : 0));
    info(VAR_42 | VAR_43 | VAR_44 |
	 VAR_45);
    if (VAR_12 != VAR_11->state->records && ! (VAR_1.testflag & VAR_46))
    {
      char VAR_47[22],VAR_48[22];
      mi_check_print_warning(&VAR_1,""Number of rows changed from %s to %s"",
			     llstr(VAR_12,VAR_47),
			     llstr(VAR_11->state->records,VAR_48));
    }
  }
  else
  {
    mi_mark_crashed_on_repair(VAR_11);
    VAR_11->update |= VAR_37 | VAR_38;
    update_state_info(&VAR_1, VAR_11, 0);
  }
  thd_proc_info(VAR_0, VAR_7);
  if (! VAR_0->locked_tables_mode)
    mi_lock_database(VAR_11,VAR_49);
  DBUG_RETURN(VAR_3 ? VAR_19 :
	      !VAR_5 ? VAR_50 : VAR_51);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/ha_myisam.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -61,24 +61,36 @@
         /* TODO: respect myisam_repair_threads variable */
         my_snprintf(buf, 40, ""Repair with %d threads"", my_count_bits(key_map));
         thd_proc_info(thd, buf);
+        /*
+          The new file is created with the right stats, so we can skip
+          copying file stats from old to new.
+        */
         error = mi_repair_parallel(&param, file, fixed_name,
-            param.testflag & T_QUICK);
+                                   param.testflag & T_QUICK, TRUE);
         thd_proc_info(thd, ""Repair done""); // to reset proc_info, as
                                       // it was pointing to local buffer
       }
       else
       {
         thd_proc_info(thd, ""Repair by sorting"");
+        /*
+          The new file is created with the right stats, so we can skip
+          copying file stats from old to new.
+        */
         error = mi_repair_by_sort(&param, file, fixed_name,
-            param.testflag & T_QUICK);
+                                  param.testflag & T_QUICK, TRUE);
       }
     }
     else
     {
       thd_proc_info(thd, ""Repair with keycache"");
       param.testflag &= ~T_REP_BY_SORT;
+      /*
+        The new file is created with the right stats, so we can skip
+        copying file stats from old to new.
+      */
       error=  mi_repair(&param, file, fixed_name,
-			param.testflag & T_QUICK);
+			param.testflag & T_QUICK, TRUE);
     }
 #ifdef HAVE_MMAP
     if (remap)
@@ -94,7 +106,11 @@
     {
       optimize_done=1;
       thd_proc_info(thd, ""Sorting index"");
-      error=mi_sort_index(&param,file,fixed_name);
+      /*
+        The new file is created with the right stats, so we can skip
+        copying file stats from old to new.
+      */
+      error=mi_sort_index(&param,file,fixed_name, TRUE);
     }
     if (!statistics_done && (local_testflag & T_STATISTICS))
     {","{'deleted_lines': ['            param.testflag & T_QUICK);', '            param.testflag & T_QUICK);', '\t\t\tparam.testflag & T_QUICK);', '      error=mi_sort_index(&param,file,fixed_name);'], 'added_lines': ['        /*', '          The new file is created with the right stats, so we can skip', '          copying file stats from old to new.', '        */', '                                   param.testflag & T_QUICK, TRUE);', '        /*', '          The new file is created with the right stats, so we can skip', '          copying file stats from old to new.', '        */', '                                  param.testflag & T_QUICK, TRUE);', '      /*', '        The new file is created with the right stats, so we can skip', '        copying file stats from old to new.', '      */', '\t\t\tparam.testflag & T_QUICK, TRUE);', '      /*', '        The new file is created with the right stats, so we can skip', '        copying file stats from old to new.', '      */', '      error=mi_sort_index(&param,file,fixed_name, TRUE);']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-08-16T13:35:19Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,mysql/mysql-server,"Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE

During REPAIR TABLE of a MyISAM table, a temporary data file (.TMD)
is created. When repair finishes, this file is renamed to the original
.MYD file. The problem was that during this rename, we copied the
stats from the old file to the new file with chmod/chown. If a user
managed to replace the temporary file before chmod/chown was executed,
it was possible to get an arbitrary file with the privileges of the
mysql user.

This patch fixes the problem by not copying stats from the old
file to the new file. This is not needed as the new file was
created with the correct stats. This fix only changes server
behavior - external utilities such as myisamchk still does
chmod/chown.

No test case provided since the problem involves synchronization
with file system operations.",4e5473862e6852b0f3802b0cd0c6fa10b5253291,https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,storage/myisam/mi_check.c,mi_repair_parallel,"int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,
const char * name, int rep_quick)
{
int got_error;
uint i,key, total_key_length, istep;
ulong rec_length;
ha_rows start_records;
my_off_t new_header_length,del;
File new_file;
MI_SORT_PARAM *sort_param=0;
MYISAM_SHARE *share=info->s;
ulong   *rec_per_key_part;
HA_KEYSEG *keyseg;
char llbuff[22];
IO_CACHE new_data_cache; 
IO_CACHE_SHARE io_share;
SORT_INFO sort_info;
ulonglong UNINIT_VAR(key_map);
pthread_attr_t thr_attr;
ulong max_pack_reclength;
int error;
DBUG_ENTER(""mi_repair_parallel"");
start_records=info->state->records;
got_error=1;
new_file= -1;
new_header_length=(param->testflag & T_UNPACK) ? 0 :
share->pack.header_length;
if (!(param->testflag & T_SILENT))
{
printf(""- parallel recovering (with sort) MyISAM-table '%s'\n"",name);
printf(""Data records: %s\n"", llstr(start_records,llbuff));
}
param->testflag|=T_REP; 
if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))
param->testflag|=T_CALC_CHECKSUM;
DBUG_PRINT(""info"", (""is quick repair: %d"", rep_quick));
bzero((char*)&sort_info,sizeof(sort_info));
mysql_mutex_init(mi_key_mutex_MI_SORT_INFO_mutex,
&sort_info.mutex, MY_MUTEX_INIT_FAST);
mysql_cond_init(mi_key_cond_MI_SORT_INFO_cond, &sort_info.cond, 0);
mysql_mutex_init(mi_key_mutex_MI_CHECK_print_msg,
&param->print_msg_mutex, MY_MUTEX_INIT_FAST);
param->need_print_msg_lock= 1;
if (!(sort_info.key_block=
alloc_key_blocks(param, (uint) param->sort_key_blocks,
share->base.max_key_block_length)) ||
init_io_cache(&param->read_cache, info->dfile,
(uint) param->read_buffer_length,
READ_CACHE, share->pack.header_length, 1, MYF(MY_WME)) ||
(!rep_quick &&
(init_io_cache(&info->rec_cache, info->dfile,
(uint) param->write_buffer_length,
WRITE_CACHE, new_header_length, 1,
MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw) ||
init_io_cache(&new_data_cache, -1,
(uint) param->write_buffer_length,
READ_CACHE, new_header_length, 1,
MYF(MY_WME | MY_DONT_CHECK_FILESIZE)))))
goto err;
sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks;
info->opt_flag|=WRITE_CACHE_USED;
info->rec_cache.file=info->dfile;         
if (!rep_quick)
{
if ((new_file= mysql_file_create(mi_key_file_datatmp,
fn_format(param->temp_filename,
share->data_file_name, """",
DATA_TMP_EXT, 2+4),
0, param->tmpfile_createflag,
MYF(0))) < 0)
{
mi_check_print_error(param,""Can't create new tempfile: '%s'"",
param->temp_filename);
goto err;
}
if (new_header_length &&
filecopy(param, new_file,info->dfile,0L,new_header_length,
""datafile-header""))
goto err;
if (param->testflag & T_UNPACK)
{
share->options&= ~HA_OPTION_COMPRESS_RECORD;
mi_int2store(share->state.header.options,share->options);
}
share->state.dellink= HA_OFFSET_ERROR;
info->rec_cache.file=new_file;
}
info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);
mi_drop_all_indexes(param, info, FALSE);
key_map= share->state.key_map;
if (param->testflag & T_CREATE_MISSING_KEYS)
{
key_map= ~key_map;
}
sort_info.info=info;
sort_info.param = param;
set_data_file_type(&sort_info, share);
sort_info.dupp=0;
sort_info.buff=0;
param->read_cache.end_of_file=sort_info.filelength=
mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0));
if (share->data_file_type == DYNAMIC_RECORD)
rec_length=max(share->base.min_pack_length+1,share->base.min_block_length);
else if (share->data_file_type == COMPRESSED_RECORD)
rec_length=share->base.min_block_length;
else
rec_length=share->base.pack_reclength;
sort_info.max_records=
((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records + 1:
(ha_rows) (sort_info.filelength/rec_length+1));
del=info->state->del;
param->glob_crc=0;
max_pack_reclength= share->base.pack_reclength;
if (share->options & HA_OPTION_COMPRESS_RECORD)
set_if_bigger(max_pack_reclength, share->max_pack_length);
if (!(sort_param=(MI_SORT_PARAM *)
my_malloc((uint) share->base.keys *
(sizeof(MI_SORT_PARAM) + max_pack_reclength),
MYF(MY_ZEROFILL))))
{
mi_check_print_error(param,""Not enough memory for key!"");
goto err;
}
total_key_length=0;
rec_per_key_part= param->rec_per_key_part;
info->state->records=info->state->del=share->state.split=0;
info->state->empty=0;
for (i=key=0, istep=1 ; key < share->base.keys ;
rec_per_key_part+=sort_param[i].keyinfo->keysegs, i+=istep, key++)
{
sort_param[i].key=key;
sort_param[i].keyinfo=share->keyinfo+key;
sort_param[i].seg=sort_param[i].keyinfo->seg;
if (! mi_is_key_active(key_map, key))
{
memcpy((char*) rec_per_key_part,
(char*) (share->state.rec_per_key_part+
(uint) (rec_per_key_part - param->rec_per_key_part)),
sort_param[i].keyinfo->keysegs*sizeof(*rec_per_key_part));
istep=0;
continue;
}
istep=1;
if ((!(param->testflag & T_SILENT)))
printf (""- Fixing index %d\n"",key+1);
if (sort_param[i].keyinfo->flag & HA_FULLTEXT)
{
sort_param[i].key_read=sort_ft_key_read;
sort_param[i].key_write=sort_ft_key_write;
}
else
{
sort_param[i].key_read=sort_key_read;
sort_param[i].key_write=sort_key_write;
}
sort_param[i].key_cmp=sort_key_cmp;
sort_param[i].lock_in_memory=lock_memory;
sort_param[i].tmpdir=param->tmpdir;
sort_param[i].sort_info=&sort_info;
sort_param[i].master=0;
sort_param[i].fix_datafile=0;
sort_param[i].calc_checksum= 0;
sort_param[i].filepos=new_header_length;
sort_param[i].max_pos=sort_param[i].pos=share->pack.header_length;
sort_param[i].record= (((uchar *)(sort_param+share->base.keys))+
(max_pack_reclength * i));
if (!mi_alloc_rec_buff(info, -1, &sort_param[i].rec_buff))
{
mi_check_print_error(param,""Not enough memory!"");
goto err;
}
sort_param[i].key_length=share->rec_reflength;
for (keyseg=sort_param[i].seg; keyseg->type != HA_KEYTYPE_END;
keyseg++)
{
sort_param[i].key_length+=keyseg->length;
if (keyseg->flag & HA_SPACE_PACK)
sort_param[i].key_length+=get_pack_length(keyseg->length);
if (keyseg->flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART))
sort_param[i].key_length+=2 + test(keyseg->length >= 127);
if (keyseg->flag & HA_NULL_PART)
sort_param[i].key_length++;
}
total_key_length+=sort_param[i].key_length;
if (sort_param[i].keyinfo->flag & HA_FULLTEXT)
{
uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT*
sort_param[i].keyinfo->seg->charset->mbmaxlen;
sort_param[i].key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN;
init_alloc_root(&sort_param[i].wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);
}
}
sort_info.total_keys=i;
sort_param[0].master= 1;
sort_param[0].fix_datafile= (my_bool)(! rep_quick);
sort_param[0].calc_checksum= test(param->testflag & T_CALC_CHECKSUM);
if (!ftparser_alloc_param(info))
goto err;
sort_info.got_error=0;
mysql_mutex_lock(&sort_info.mutex);
if (i > 1)
{
if (rep_quick)
init_io_cache_share(&param->read_cache, &io_share, NULL, i);
else
init_io_cache_share(&new_data_cache, &io_share, &info->rec_cache, i);
}
else
io_share.total_threads= 0; 
(void) pthread_attr_init(&thr_attr);
(void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED);
for (i=0 ; i < sort_info.total_keys ; i++)
{
sort_param[i].read_cache= ((rep_quick || !i) ? param->read_cache :
new_data_cache);
DBUG_PRINT(""io_cache_share"", (""thread: %u  read_cache: 0x%lx"",
i, (long) &sort_param[i].read_cache));
sort_param[i].sortbuff_size=
#ifndef USING_SECOND_APPROACH
param->sort_buffer_length/sort_info.total_keys;
#else
param->sort_buffer_length*sort_param[i].key_length/total_key_length;
#endif
if ((error= mysql_thread_create(mi_key_thread_find_all_keys,
&sort_param[i].thr, &thr_attr,
thr_find_all_keys,
(void *) (sort_param+i))))
{
mi_check_print_error(param,""Cannot start a repair thread (errno= %d)"",
error);
if (io_share.total_threads)
remove_io_thread(&sort_param[i].read_cache);
DBUG_PRINT(""error"", (""Cannot start a repair thread""));
sort_info.got_error=1;
}
else
sort_info.threads_running++;
}
(void) pthread_attr_destroy(&thr_attr);
while (sort_info.threads_running)
mysql_cond_wait(&sort_info.cond, &sort_info.mutex);
mysql_mutex_unlock(&sort_info.mutex);
if ((got_error= thr_write_keys(sort_param)))
{
param->retry_repair=1;
goto err;
}
got_error=1;
if (sort_param[0].fix_datafile)
{
if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache))
goto err;
if (param->testflag & T_SAFE_REPAIR)
{
if (info->state->records+1 < start_records)
{
info->state->records=start_records;
goto err;
}
}
share->state.state.data_file_length= info->state->data_file_length=
sort_param->filepos;
share->state.version=(ulong) time((time_t*) 0);
mysql_file_close(info->dfile, MYF(0));
info->dfile=new_file;
share->data_file_type=sort_info.new_data_file_type;
share->pack.header_length=(ulong) new_header_length;
}
else
info->state->data_file_length=sort_param->max_pos;
if (rep_quick && del+sort_info.dupp != info->state->del)
{
mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
mi_check_print_error(param,""Run recovery again without -q"");
param->retry_repair=1;
param->testflag|=T_RETRY_WITHOUT_QUICK;
goto err;
}
if (rep_quick & T_FORCE_UNIQUENESS)
{
my_off_t skr=info->state->data_file_length+
(share->options & HA_OPTION_COMPRESS_RECORD ?
MEMMAP_EXTRA_MARGIN : 0);
#ifdef USE_RELOC
if (share->data_file_type == STATIC_RECORD &&
skr < share->base.reloc*share->base.min_pack_length)
skr=share->base.reloc*share->base.min_pack_length;
#endif
if (skr != sort_info.filelength)
if (mysql_file_chsize(info->dfile, skr, 0, MYF(0)))
mi_check_print_warning(param,
""Can't change size of datafile,  error: %d"",
my_errno);
}
if (param->testflag & T_CALC_CHECKSUM)
info->state->checksum=param->glob_crc;
if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))
mi_check_print_warning(param,
""Can't change size of indexfile, error: %d"", my_errno);
if (!(param->testflag & T_SILENT))
{
if (start_records != info->state->records)
printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
if (sort_info.dupp)
mi_check_print_warning(param,
""%s records have been removed"",
llstr(sort_info.dupp,llbuff));
}
got_error=0;
if (&share->state.state != info->state)
memcpy(&share->state.state, info->state, sizeof(*info->state));
err:
got_error|= flush_blocks(param, share->key_cache, share->kfile);
(void) end_io_cache(&info->rec_cache);
if (!rep_quick)
(void) end_io_cache(&new_data_cache);
if (!got_error)
{
if (new_file >= 0)
{
mysql_file_close(new_file, MYF(0));
info->dfile=new_file= -1;
if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,
(param->testflag & T_BACKUP_DATA ?
MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||
mi_open_datafile(info,share,name,-1))
got_error=1;
}
}
if (got_error)
{
if (! param->error_printed)
mi_check_print_error(param,""%d when fixing table"",my_errno);
if (new_file >= 0)
{
(void) mysql_file_close(new_file, MYF(0));
(void) mysql_file_delete(mi_key_file_datatmp,
param->temp_filename, MYF(MY_WME));
if (info->dfile == new_file) 
if (unlikely(mi_open_datafile(info, share, name, -1)))
param->retry_repair= 0; 
}
mi_mark_crashed_on_repair(info);
}
else if (key_map == share->state.key_map)
share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS;
share->state.changed|=STATE_NOT_SORTED_PAGES;
mysql_cond_destroy(&sort_info.cond);
mysql_mutex_destroy(&sort_info.mutex);
mysql_mutex_destroy(&param->print_msg_mutex);
param->need_print_msg_lock= 0;
my_free(sort_info.ft_buf);
my_free(sort_info.key_block);
my_free(sort_param);
my_free(sort_info.buff);
(void) end_io_cache(&param->read_cache);
info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);
if (!got_error && (param->testflag & T_UNPACK))
{
share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;
share->pack.header_length=0;
}
DBUG_RETURN(got_error);
}","int mi_repair_parallel(MI_CHECK *VAR_0, register MI_INFO *VAR_1,
const char * VAR_2, int VAR_3)
{
int VAR_4;
uint VAR_5,VAR_6, VAR_7, VAR_8;
ulong VAR_9;
ha_rows VAR_10;
my_off_t VAR_11,VAR_12;
File VAR_13;
MI_SORT_PARAM *VAR_14=0;
MYISAM_SHARE *VAR_15=VAR_1->s;
ulong   *VAR_16;
HA_KEYSEG *VAR_17;
char VAR_18[22];
IO_CACHE VAR_19; 
IO_CACHE_SHARE VAR_20;
SORT_INFO VAR_21;
ulonglong UNINIT_VAR(key_map);
pthread_attr_t VAR_22;
ulong VAR_23;
int VAR_24;
DBUG_ENTER(""mi_repair_parallel"");
VAR_10=VAR_1->state->records;
VAR_4=1;
VAR_13= -1;
VAR_11=(VAR_0->testflag & VAR_25) ? 0 :
VAR_15->pack.header_length;
if (!(VAR_0->testflag & VAR_26))
{
printf(""- parallel recovering (with sort) MyISAM-table '%s'\n"",VAR_2);
printf(""Data records: %s\n"", llstr(VAR_10,VAR_18));
}
VAR_0->testflag|=VAR_27; 
if (VAR_1->s->options & (VAR_28 | VAR_29))
VAR_0->testflag|=VAR_30;
DBUG_PRINT(""info"", (""is quick repair: %d"", VAR_3));
bzero((char*)&VAR_21,sizeof(VAR_21));
mysql_mutex_init(VAR_31,
&VAR_21.mutex, VAR_32);
mysql_cond_init(VAR_33, &VAR_21.cond, 0);
mysql_mutex_init(VAR_34,
&VAR_0->print_msg_mutex, VAR_32);
VAR_0->need_print_msg_lock= 1;
if (!(VAR_21.key_block=
alloc_key_blocks(VAR_0, (uint) VAR_0->sort_key_blocks,
VAR_15->base.max_key_block_length)) ||
init_io_cache(&VAR_0->read_cache, VAR_1->dfile,
(uint) VAR_0->read_buffer_length,
VAR_35, VAR_15->pack.header_length, 1, MYF(VAR_36)) ||
(!VAR_3 &&
(init_io_cache(&VAR_1->rec_cache, VAR_1->dfile,
(uint) VAR_0->write_buffer_length,
VAR_37, VAR_11, 1,
MYF(VAR_36 | VAR_38) & VAR_0->myf_rw) ||
init_io_cache(&VAR_19, -1,
(uint) VAR_0->write_buffer_length,
VAR_35, VAR_11, 1,
MYF(VAR_36 | VAR_39)))))
goto err;
VAR_21.key_block_end=VAR_21.key_block+VAR_0->sort_key_blocks;
VAR_1->opt_flag|=VAR_40;
VAR_1->rec_cache.file=VAR_1->dfile;         
if (!VAR_3)
{
if ((VAR_13= mysql_file_create(VAR_41,
fn_format(VAR_0->temp_filename,
VAR_15->data_file_name, """",
VAR_42, 2+4),
0, VAR_0->tmpfile_createflag,
MYF(0))) < 0)
{
mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
VAR_0->temp_filename);
goto err;
}
if (VAR_11 &&
filecopy(VAR_0, VAR_13,VAR_1->dfile,0L,VAR_11,
""datafile-header""))
goto err;
if (VAR_0->testflag & VAR_25)
{
VAR_15->options&= ~VAR_29;
mi_int2store(VAR_15->state.header.options,VAR_15->options);
}
VAR_15->state.dellink= VAR_43;
VAR_1->rec_cache.file=VAR_13;
}
VAR_1->update= (short) (VAR_44 | VAR_45);
mi_drop_all_indexes(VAR_0, VAR_1, FALSE);
key_map= VAR_15->state.key_map;
if (VAR_0->testflag & VAR_46)
{
key_map= ~key_map;
}
VAR_21.info=VAR_1;
VAR_21.param = VAR_0;
set_data_file_type(&VAR_21, VAR_15);
VAR_21.dupp=0;
VAR_21.buff=0;
VAR_0->read_cache.end_of_file=VAR_21.filelength=
mysql_file_seek(VAR_0->read_cache.file, 0L, VAR_47, MYF(0));
if (VAR_15->data_file_type == VAR_48)
VAR_9=max(VAR_15->base.min_pack_length+1,VAR_15->base.min_block_length);
else if (VAR_15->data_file_type == VAR_49)
VAR_9=VAR_15->base.min_block_length;
else
VAR_9=VAR_15->base.pack_reclength;
VAR_21.max_records=
((VAR_0->testflag & VAR_46) ? VAR_1->state->records + 1:
(ha_rows) (VAR_21.filelength/VAR_9+1));
VAR_12=VAR_1->state->del;
VAR_0->glob_crc=0;
VAR_23= VAR_15->base.pack_reclength;
if (VAR_15->options & VAR_29)
set_if_bigger(VAR_23, VAR_15->max_pack_length);
if (!(VAR_14=(MI_SORT_PARAM *)
my_malloc((uint) VAR_15->base.keys *
(sizeof(MI_SORT_PARAM) + VAR_23),
MYF(VAR_50))))
{
mi_check_print_error(VAR_0,""Not enough memory for key!"");
goto err;
}
VAR_7=0;
VAR_16= VAR_0->rec_per_key_part;
VAR_1->state->records=VAR_1->state->del=VAR_15->state.split=0;
VAR_1->state->empty=0;
for (VAR_5=VAR_6=0, VAR_8=1 ; VAR_6 < VAR_15->base.keys ;
VAR_16+=VAR_14[VAR_5].keyinfo->keysegs, VAR_5+=VAR_8, VAR_6++)
{
VAR_14[VAR_5].key=VAR_6;
VAR_14[VAR_5].keyinfo=VAR_15->keyinfo+VAR_6;
VAR_14[VAR_5].seg=VAR_14[VAR_5].keyinfo->seg;
if (! mi_is_key_active(key_map, VAR_6))
{
memcpy((char*) VAR_16,
(char*) (VAR_15->state.rec_per_key_part+
(uint) (VAR_16 - VAR_0->rec_per_key_part)),
VAR_14[VAR_5].keyinfo->keysegs*sizeof(*VAR_16));
VAR_8=0;
continue;
}
VAR_8=1;
if ((!(VAR_0->testflag & VAR_26)))
printf (""- Fixing index %d\n"",VAR_6+1);
if (VAR_14[VAR_5].keyinfo->flag & VAR_51)
{
VAR_14[VAR_5].key_read=VAR_52;
VAR_14[VAR_5].key_write=VAR_53;
}
else
{
VAR_14[VAR_5].key_read=VAR_54;
VAR_14[VAR_5].key_write=VAR_55;
}
VAR_14[VAR_5].key_cmp=VAR_56;
VAR_14[VAR_5].lock_in_memory=VAR_57;
VAR_14[VAR_5].tmpdir=VAR_0->tmpdir;
VAR_14[VAR_5].sort_info=&VAR_21;
VAR_14[VAR_5].master=0;
VAR_14[VAR_5].fix_datafile=0;
VAR_14[VAR_5].calc_checksum= 0;
VAR_14[VAR_5].filepos=VAR_11;
VAR_14[VAR_5].max_pos=VAR_14[VAR_5].pos=VAR_15->pack.header_length;
VAR_14[VAR_5].record= (((uchar *)(VAR_14+VAR_15->base.keys))+
(VAR_23 * VAR_5));
if (!mi_alloc_rec_buff(VAR_1, -1, &VAR_14[VAR_5].rec_buff))
{
mi_check_print_error(VAR_0,""Not enough memory!"");
goto err;
}
VAR_14[VAR_5].key_length=VAR_15->rec_reflength;
for (VAR_17=VAR_14[VAR_5].seg; VAR_17->type != VAR_58;
VAR_17++)
{
VAR_14[VAR_5].key_length+=VAR_17->length;
if (VAR_17->flag & VAR_59)
VAR_14[VAR_5].key_length+=get_pack_length(VAR_17->length);
if (VAR_17->flag & (VAR_60 | VAR_61))
VAR_14[VAR_5].key_length+=2 + test(VAR_17->length >= 127);
if (VAR_17->flag & VAR_62)
VAR_14[VAR_5].key_length++;
}
VAR_7+=VAR_14[VAR_5].key_length;
if (VAR_14[VAR_5].keyinfo->flag & VAR_51)
{
uint VAR_63=VAR_64*
VAR_14[VAR_5].keyinfo->seg->charset->mbmaxlen;
VAR_14[VAR_5].key_length+=VAR_63-VAR_65;
init_alloc_root(&VAR_14[VAR_5].wordroot, VAR_66, 0);
}
}
VAR_21.total_keys=VAR_5;
VAR_14[0].master= 1;
VAR_14[0].fix_datafile= (VAR_67)(! VAR_3);
VAR_14[0].calc_checksum= test(VAR_0->testflag & VAR_30);
if (!ftparser_alloc_param(VAR_1))
goto err;
VAR_21.got_error=0;
mysql_mutex_lock(&VAR_21.mutex);
if (VAR_5 > 1)
{
if (VAR_3)
init_io_cache_share(&VAR_0->read_cache, &VAR_20, NULL, VAR_5);
else
init_io_cache_share(&VAR_19, &VAR_20, &VAR_1->rec_cache, VAR_5);
}
else
VAR_20.total_threads= 0; 
(void) pthread_attr_init(&VAR_22);
(void) pthread_attr_setdetachstate(&VAR_22,VAR_68);
for (VAR_5=0 ; VAR_5 < VAR_21.total_keys ; VAR_5++)
{
VAR_14[VAR_5].read_cache= ((VAR_3 || !VAR_5) ? VAR_0->read_cache :
VAR_19);
DBUG_PRINT(""io_cache_share"", (""thread: %u  read_cache: 0x%lx"",
VAR_5, (long) &VAR_14[VAR_5].read_cache));
VAR_14[VAR_5].sortbuff_size=
#ifndef VAR_69
VAR_0->sort_buffer_length/VAR_21.total_keys;
#else
VAR_0->sort_buffer_length*VAR_14[VAR_5].key_length/VAR_7;
#endif
if ((VAR_24= mysql_thread_create(VAR_70,
&VAR_14[VAR_5].thr, &VAR_22,
VAR_71,
(void *) (VAR_14+VAR_5))))
{
mi_check_print_error(VAR_0,""Cannot start a repair thread (errno= %d)"",
VAR_24);
if (VAR_20.total_threads)
remove_io_thread(&VAR_14[VAR_5].read_cache);
DBUG_PRINT(""error"", (""Cannot start a repair thread""));
VAR_21.got_error=1;
}
else
VAR_21.threads_running++;
}
(void) pthread_attr_destroy(&VAR_22);
while (VAR_21.threads_running)
mysql_cond_wait(&VAR_21.cond, &VAR_21.mutex);
mysql_mutex_unlock(&VAR_21.mutex);
if ((VAR_4= thr_write_keys(VAR_14)))
{
VAR_0->retry_repair=1;
goto err;
}
VAR_4=1;
if (VAR_14[0].fix_datafile)
{
if (write_data_suffix(&VAR_21,1) || end_io_cache(&VAR_1->rec_cache))
goto err;
if (VAR_0->testflag & VAR_72)
{
if (VAR_1->state->records+1 < VAR_10)
{
VAR_1->state->records=VAR_10;
goto err;
}
}
VAR_15->state.state.data_file_length= VAR_1->state->data_file_length=
VAR_14->filepos;
VAR_15->state.version=(ulong) time((time_t*) 0);
mysql_file_close(VAR_1->dfile, MYF(0));
VAR_1->dfile=VAR_13;
VAR_15->data_file_type=VAR_21.new_data_file_type;
VAR_15->pack.header_length=(ulong) VAR_11;
}
else
VAR_1->state->data_file_length=VAR_14->max_pos;
if (VAR_3 && VAR_12+VAR_21.dupp != VAR_1->state->del)
{
mi_check_print_error(VAR_0,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
mi_check_print_error(VAR_0,""Run recovery again without -q"");
VAR_0->retry_repair=1;
VAR_0->testflag|=VAR_73;
goto err;
}
if (VAR_3 & VAR_74)
{
my_off_t VAR_75=VAR_1->state->data_file_length+
(VAR_15->options & VAR_29 ?
VAR_76 : 0);
#ifdef VAR_77
if (VAR_15->data_file_type == VAR_78 &&
VAR_75 < VAR_15->base.reloc*VAR_15->base.min_pack_length)
VAR_75=VAR_15->base.reloc*VAR_15->base.min_pack_length;
#endif
if (VAR_75 != VAR_21.filelength)
if (mysql_file_chsize(VAR_1->dfile, VAR_75, 0, MYF(0)))
mi_check_print_warning(VAR_0,
""Can't change size of datafile,  error: %d"",
VAR_79);
}
if (VAR_0->testflag & VAR_30)
VAR_1->state->checksum=VAR_0->glob_crc;
if (mysql_file_chsize(VAR_15->kfile, VAR_1->state->key_file_length, 0, MYF(0)))
mi_check_print_warning(VAR_0,
""Can't change size of indexfile, error: %d"", VAR_79);
if (!(VAR_0->testflag & VAR_26))
{
if (VAR_10 != VAR_1->state->records)
printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_18));
if (VAR_21.dupp)
mi_check_print_warning(VAR_0,
""%s records have been removed"",
llstr(VAR_21.dupp,VAR_18));
}
VAR_4=0;
if (&VAR_15->state.state != VAR_1->state)
memcpy(&VAR_15->state.state, VAR_1->state, sizeof(*VAR_1->state));
err:
VAR_4|= flush_blocks(VAR_0, VAR_15->key_cache, VAR_15->kfile);
(void) end_io_cache(&VAR_1->rec_cache);
if (!VAR_3)
(void) end_io_cache(&VAR_19);
if (!VAR_4)
{
if (VAR_13 >= 0)
{
mysql_file_close(VAR_13, MYF(0));
VAR_1->dfile=VAR_13= -1;
if (change_to_newfile(VAR_15->data_file_name, VAR_80, VAR_42,
(VAR_0->testflag & VAR_81 ?
MYF(VAR_82): MYF(0))) ||
mi_open_datafile(VAR_1,VAR_15,VAR_2,-1))
VAR_4=1;
}
}
if (VAR_4)
{
if (! VAR_0->error_printed)
mi_check_print_error(VAR_0,""%d when fixing table"",VAR_79);
if (VAR_13 >= 0)
{
(void) mysql_file_close(VAR_13, MYF(0));
(void) mysql_file_delete(VAR_41,
VAR_0->temp_filename, MYF(VAR_36));
if (VAR_1->dfile == VAR_13) 
if (unlikely(mi_open_datafile(VAR_1, VAR_15, VAR_2, -1)))
VAR_0->retry_repair= 0; 
}
mi_mark_crashed_on_repair(VAR_1);
}
else if (key_map == VAR_15->state.key_map)
VAR_15->state.changed&= ~VAR_83;
VAR_15->state.changed|=VAR_84;
mysql_cond_destroy(&VAR_21.cond);
mysql_mutex_destroy(&VAR_21.mutex);
mysql_mutex_destroy(&VAR_0->print_msg_mutex);
VAR_0->need_print_msg_lock= 0;
my_free(VAR_21.ft_buf);
my_free(VAR_21.key_block);
my_free(VAR_14);
my_free(VAR_21.buff);
(void) end_io_cache(&VAR_0->read_cache);
VAR_1->opt_flag&= ~(VAR_85 | VAR_40);
if (!VAR_4 && (VAR_0->testflag & VAR_25))
{
VAR_15->state.header.options[0]&= (uchar) ~VAR_29;
VAR_15->pack.header_length=0;
}
DBUG_RETURN(VAR_4);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/before/0.json,"int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,
                       const char * name, int rep_quick, my_bool no_copy_stat)
{
  int got_error;
  uint i,key, total_key_length, istep;
  ulong rec_length;
  ha_rows start_records;
  my_off_t new_header_length,del;
  File new_file;
  MI_SORT_PARAM *sort_param=0;
  MYISAM_SHARE *share=info->s;
  ulong   *rec_per_key_part;
  HA_KEYSEG *keyseg;
  char llbuff[22];
  IO_CACHE new_data_cache; /* For non-quick repair. */
  IO_CACHE_SHARE io_share;
  SORT_INFO sort_info;
  ulonglong UNINIT_VAR(key_map);
  pthread_attr_t thr_attr;
  ulong max_pack_reclength;
  int error;
  DBUG_ENTER(""mi_repair_parallel"");

  start_records=info->state->records;
  got_error=1;
  new_file= -1;
  new_header_length=(param->testflag & T_UNPACK) ? 0 :
    share->pack.header_length;
  if (!(param->testflag & T_SILENT))
  {
    printf(""- parallel recovering (with sort) MyISAM-table '%s'\n"",name);
    printf(""Data records: %s\n"", llstr(start_records,llbuff));
  }
  param->testflag|=T_REP; /* for easy checking */

  if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))
    param->testflag|=T_CALC_CHECKSUM;

  /*
    Quick repair (not touching data file, rebuilding indexes):
    {
      Read  cache is (MI_CHECK *param)->read_cache using info->dfile.
    }

    Non-quick repair (rebuilding data file and indexes):
    {
      Master thread:

        Read  cache is (MI_CHECK *param)->read_cache using info->dfile.
        Write cache is (MI_INFO   *info)->rec_cache  using new_file.

      Slave threads:

        Read  cache is new_data_cache synced to master rec_cache.

      The final assignment of the filedescriptor for rec_cache is done
      after the cache creation.

      Don't check file size on new_data_cache, as the resulting file size
      is not known yet.

      As rec_cache and new_data_cache are synced, write_buffer_length is
      used for the read cache 'new_data_cache'. Both start at the same
      position 'new_header_length'.
    }
  */
  DBUG_PRINT(""info"", (""is quick repair: %d"", rep_quick));
  bzero((char*)&sort_info,sizeof(sort_info));
  /* Initialize pthread structures before goto err. */
  mysql_mutex_init(mi_key_mutex_MI_SORT_INFO_mutex,
                   &sort_info.mutex, MY_MUTEX_INIT_FAST);
  mysql_cond_init(mi_key_cond_MI_SORT_INFO_cond, &sort_info.cond, 0);
  mysql_mutex_init(mi_key_mutex_MI_CHECK_print_msg,
                   &param->print_msg_mutex, MY_MUTEX_INIT_FAST);
  param->need_print_msg_lock= 1;

  if (!(sort_info.key_block=
	alloc_key_blocks(param, (uint) param->sort_key_blocks,
			 share->base.max_key_block_length)) ||
      init_io_cache(&param->read_cache, info->dfile,
                    (uint) param->read_buffer_length,
                    READ_CACHE, share->pack.header_length, 1, MYF(MY_WME)) ||
      (!rep_quick &&
       (init_io_cache(&info->rec_cache, info->dfile,
                      (uint) param->write_buffer_length,
                      WRITE_CACHE, new_header_length, 1,
                      MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw) ||
        init_io_cache(&new_data_cache, -1,
                      (uint) param->write_buffer_length,
                      READ_CACHE, new_header_length, 1,
                      MYF(MY_WME | MY_DONT_CHECK_FILESIZE)))))
    goto err;
  sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks;
  info->opt_flag|=WRITE_CACHE_USED;
  info->rec_cache.file=info->dfile;         /* for sort_delete_record */

  if (!rep_quick)
  {
    /* Get real path for data file */
    if ((new_file= mysql_file_create(mi_key_file_datatmp,
                                     fn_format(param->temp_filename,
                                               share->data_file_name, """",
                                               DATA_TMP_EXT, 2+4),
                                     0, param->tmpfile_createflag,
                                     MYF(0))) < 0)
    {
      mi_check_print_error(param,""Can't create new tempfile: '%s'"",
			   param->temp_filename);
      goto err;
    }
    if (new_header_length &&
        filecopy(param, new_file,info->dfile,0L,new_header_length,
		 ""datafile-header""))
      goto err;
    if (param->testflag & T_UNPACK)
    {
      share->options&= ~HA_OPTION_COMPRESS_RECORD;
      mi_int2store(share->state.header.options,share->options);
    }
    share->state.dellink= HA_OFFSET_ERROR;
    info->rec_cache.file=new_file;
  }

  info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);

  /* Optionally drop indexes and optionally modify the key_map. */
  mi_drop_all_indexes(param, info, FALSE);
  key_map= share->state.key_map;
  if (param->testflag & T_CREATE_MISSING_KEYS)
  {
    /* Invert the copied key_map to recreate all disabled indexes. */
    key_map= ~key_map;
  }

  sort_info.info=info;
  sort_info.param = param;

  set_data_file_type(&sort_info, share);
  sort_info.dupp=0;
  sort_info.buff=0;
  param->read_cache.end_of_file=sort_info.filelength=
    mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0));

  if (share->data_file_type == DYNAMIC_RECORD)
    rec_length=max(share->base.min_pack_length+1,share->base.min_block_length);
  else if (share->data_file_type == COMPRESSED_RECORD)
    rec_length=share->base.min_block_length;
  else
    rec_length=share->base.pack_reclength;
  /*
    +1 below is required hack for parallel repair mode.
    The info->state->records value, that is compared later
    to sort_info.max_records and cannot exceed it, is
    increased in sort_key_write. In mi_repair_by_sort, sort_key_write
    is called after sort_key_read, where the comparison is performed,
    but in parallel mode master thread can call sort_key_write
    before some other repair thread calls sort_key_read.
    Furthermore I'm not even sure +1 would be enough.
    May be sort_info.max_records shold be always set to max value in
    parallel mode.
  */
  sort_info.max_records=
    ((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records + 1:
     (ha_rows) (sort_info.filelength/rec_length+1));

  del=info->state->del;
  param->glob_crc=0;
  /* for compressed tables */
  max_pack_reclength= share->base.pack_reclength;
  if (share->options & HA_OPTION_COMPRESS_RECORD)
    set_if_bigger(max_pack_reclength, share->max_pack_length);
  if (!(sort_param=(MI_SORT_PARAM *)
        my_malloc((uint) share->base.keys *
		  (sizeof(MI_SORT_PARAM) + max_pack_reclength),
		  MYF(MY_ZEROFILL))))
  {
    mi_check_print_error(param,""Not enough memory for key!"");
    goto err;
  }
  total_key_length=0;
  rec_per_key_part= param->rec_per_key_part;
  info->state->records=info->state->del=share->state.split=0;
  info->state->empty=0;

  for (i=key=0, istep=1 ; key < share->base.keys ;
       rec_per_key_part+=sort_param[i].keyinfo->keysegs, i+=istep, key++)
  {
    sort_param[i].key=key;
    sort_param[i].keyinfo=share->keyinfo+key;
    sort_param[i].seg=sort_param[i].keyinfo->seg;
    /*
      Skip this index if it is marked disabled in the copied
      (and possibly inverted) key_map.
    */
    if (! mi_is_key_active(key_map, key))
    {
      /* Remember old statistics for key */
      memcpy((char*) rec_per_key_part,
	     (char*) (share->state.rec_per_key_part+
		      (uint) (rec_per_key_part - param->rec_per_key_part)),
	     sort_param[i].keyinfo->keysegs*sizeof(*rec_per_key_part));
      istep=0;
      continue;
    }
    istep=1;
    if ((!(param->testflag & T_SILENT)))
      printf (""- Fixing index %d\n"",key+1);
    if (sort_param[i].keyinfo->flag & HA_FULLTEXT)
    {
      sort_param[i].key_read=sort_ft_key_read;
      sort_param[i].key_write=sort_ft_key_write;
    }
    else
    {
      sort_param[i].key_read=sort_key_read;
      sort_param[i].key_write=sort_key_write;
    }
    sort_param[i].key_cmp=sort_key_cmp;
    sort_param[i].lock_in_memory=lock_memory;
    sort_param[i].tmpdir=param->tmpdir;
    sort_param[i].sort_info=&sort_info;
    sort_param[i].master=0;
    sort_param[i].fix_datafile=0;
    sort_param[i].calc_checksum= 0;

    sort_param[i].filepos=new_header_length;
    sort_param[i].max_pos=sort_param[i].pos=share->pack.header_length;

    sort_param[i].record= (((uchar *)(sort_param+share->base.keys))+
			   (max_pack_reclength * i));
    if (!mi_alloc_rec_buff(info, -1, &sort_param[i].rec_buff))
    {
      mi_check_print_error(param,""Not enough memory!"");
      goto err;
    }

    sort_param[i].key_length=share->rec_reflength;
    for (keyseg=sort_param[i].seg; keyseg->type != HA_KEYTYPE_END;
	 keyseg++)
    {
      sort_param[i].key_length+=keyseg->length;
      if (keyseg->flag & HA_SPACE_PACK)
        sort_param[i].key_length+=get_pack_length(keyseg->length);
      if (keyseg->flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART))
        sort_param[i].key_length+=2 + test(keyseg->length >= 127);
      if (keyseg->flag & HA_NULL_PART)
        sort_param[i].key_length++;
    }
    total_key_length+=sort_param[i].key_length;

    if (sort_param[i].keyinfo->flag & HA_FULLTEXT)
    {
      uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT*
                                    sort_param[i].keyinfo->seg->charset->mbmaxlen;
      sort_param[i].key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN;
      init_alloc_root(&sort_param[i].wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0);
    }
  }
  sort_info.total_keys=i;
  sort_param[0].master= 1;
  sort_param[0].fix_datafile= (my_bool)(! rep_quick);
  sort_param[0].calc_checksum= test(param->testflag & T_CALC_CHECKSUM);

  if (!ftparser_alloc_param(info))
    goto err;

  sort_info.got_error=0;
  mysql_mutex_lock(&sort_info.mutex);

  /*
    Initialize the I/O cache share for use with the read caches and, in
    case of non-quick repair, the write cache. When all threads join on
    the cache lock, the writer copies the write cache contents to the
    read caches.
  */
  if (i > 1)
  {
    if (rep_quick)
      init_io_cache_share(&param->read_cache, &io_share, NULL, i);
    else
      init_io_cache_share(&new_data_cache, &io_share, &info->rec_cache, i);
  }
  else
    io_share.total_threads= 0; /* share not used */

  (void) pthread_attr_init(&thr_attr);
  (void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED);

  for (i=0 ; i < sort_info.total_keys ; i++)
  {
    /*
      Copy the properly initialized IO_CACHE structure so that every
      thread has its own copy. In quick mode param->read_cache is shared
      for use by all threads. In non-quick mode all threads but the
      first copy the shared new_data_cache, which is synchronized to the
      write cache of the first thread. The first thread copies
      param->read_cache, which is not shared.
    */
    sort_param[i].read_cache= ((rep_quick || !i) ? param->read_cache :
                               new_data_cache);
    DBUG_PRINT(""io_cache_share"", (""thread: %u  read_cache: 0x%lx"",
                                  i, (long) &sort_param[i].read_cache));

    /*
      two approaches: the same amount of memory for each thread
      or the memory for the same number of keys for each thread...
      In the second one all the threads will fill their sort_buffers
      (and call write_keys) at the same time, putting more stress on i/o.
    */
    sort_param[i].sortbuff_size=
#ifndef USING_SECOND_APPROACH
      param->sort_buffer_length/sort_info.total_keys;
#else
      param->sort_buffer_length*sort_param[i].key_length/total_key_length;
#endif
    if ((error= mysql_thread_create(mi_key_thread_find_all_keys,
                                    &sort_param[i].thr, &thr_attr,
                                    thr_find_all_keys,
                                    (void *) (sort_param+i))))
    {
      mi_check_print_error(param,""Cannot start a repair thread (errno= %d)"",
                           error);
      /* Cleanup: Detach from the share. Avoid others to be blocked. */
      if (io_share.total_threads)
        remove_io_thread(&sort_param[i].read_cache);
      DBUG_PRINT(""error"", (""Cannot start a repair thread""));
      sort_info.got_error=1;
    }
    else
      sort_info.threads_running++;
  }
  (void) pthread_attr_destroy(&thr_attr);

  /* waiting for all threads to finish */
  while (sort_info.threads_running)
    mysql_cond_wait(&sort_info.cond, &sort_info.mutex);
  mysql_mutex_unlock(&sort_info.mutex);

  if ((got_error= thr_write_keys(sort_param)))
  {
    param->retry_repair=1;
    goto err;
  }
  got_error=1;				/* Assume the following may go wrong */

  if (sort_param[0].fix_datafile)
  {
    /*
      Append some nuls to the end of a memory mapped file. Destroy the
      write cache. The master thread did already detach from the share
      by remove_io_thread() in sort.c:thr_find_all_keys().
    */
    if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache))
      goto err;
    if (param->testflag & T_SAFE_REPAIR)
    {
      /* Don't repair if we loosed more than one row */
      if (info->state->records+1 < start_records)
      {
        info->state->records=start_records;
        goto err;
      }
    }
    share->state.state.data_file_length= info->state->data_file_length=
      sort_param->filepos;
    /* Only whole records */
    share->state.version=(ulong) time((time_t*) 0);

    /*
      Exchange the data file descriptor of the table, so that we use the
      new file from now on.
     */
    mysql_file_close(info->dfile, MYF(0));
    info->dfile=new_file;

    share->data_file_type=sort_info.new_data_file_type;
    share->pack.header_length=(ulong) new_header_length;
  }
  else
    info->state->data_file_length=sort_param->max_pos;

  if (rep_quick && del+sort_info.dupp != info->state->del)
  {
    mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
    mi_check_print_error(param,""Run recovery again without -q"");
    param->retry_repair=1;
    param->testflag|=T_RETRY_WITHOUT_QUICK;
    goto err;
  }

  if (rep_quick & T_FORCE_UNIQUENESS)
  {
    my_off_t skr=info->state->data_file_length+
      (share->options & HA_OPTION_COMPRESS_RECORD ?
       MEMMAP_EXTRA_MARGIN : 0);
#ifdef USE_RELOC
    if (share->data_file_type == STATIC_RECORD &&
	skr < share->base.reloc*share->base.min_pack_length)
      skr=share->base.reloc*share->base.min_pack_length;
#endif
    if (skr != sort_info.filelength)
      if (mysql_file_chsize(info->dfile, skr, 0, MYF(0)))
	mi_check_print_warning(param,
			       ""Can't change size of datafile,  error: %d"",
			       my_errno);
  }
  if (param->testflag & T_CALC_CHECKSUM)
    info->state->checksum=param->glob_crc;

  if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))
    mi_check_print_warning(param,
			   ""Can't change size of indexfile, error: %d"", my_errno);

  if (!(param->testflag & T_SILENT))
  {
    if (start_records != info->state->records)
      printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
    if (sort_info.dupp)
      mi_check_print_warning(param,
			     ""%s records have been removed"",
			     llstr(sort_info.dupp,llbuff));
  }
  got_error=0;

  if (&share->state.state != info->state)
    memcpy(&share->state.state, info->state, sizeof(*info->state));

err:
  got_error|= flush_blocks(param, share->key_cache, share->kfile);
  /*
    Destroy the write cache. The master thread did already detach from
    the share by remove_io_thread() or it was not yet started (if the
    error happend before creating the thread).
  */
  (void) end_io_cache(&info->rec_cache);
  /*
    Destroy the new data cache in case of non-quick repair. All slave
    threads did either detach from the share by remove_io_thread()
    already or they were not yet started (if the error happend before
    creating the threads).
  */
  if (!rep_quick)
    (void) end_io_cache(&new_data_cache);
  if (!got_error)
  {
    /* Replace the actual file with the temporary file */
    if (new_file >= 0)
    {
      myf flags= 0;
      if (param->testflag & T_BACKUP_DATA)
        flags |= MY_REDEL_MAKE_BACKUP;
      if (no_copy_stat)
        flags |= MY_REDEL_NO_COPY_STAT;
      mysql_file_close(new_file, MYF(0));
      info->dfile=new_file= -1;
      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,
			    flags) ||
	  mi_open_datafile(info,share,name,-1))
	got_error=1;
    }
  }
  if (got_error)
  {
    if (! param->error_printed)
      mi_check_print_error(param,""%d when fixing table"",my_errno);
    if (new_file >= 0)
    {
      (void) mysql_file_close(new_file, MYF(0));
      (void) mysql_file_delete(mi_key_file_datatmp,
                               param->temp_filename, MYF(MY_WME));
      if (info->dfile == new_file) /* Retry with key cache */
        if (unlikely(mi_open_datafile(info, share, name, -1)))
          param->retry_repair= 0; /* Safety */
    }
    mi_mark_crashed_on_repair(info);
  }
  else if (key_map == share->state.key_map)
    share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS;
  share->state.changed|=STATE_NOT_SORTED_PAGES;

  mysql_cond_destroy(&sort_info.cond);
  mysql_mutex_destroy(&sort_info.mutex);
  mysql_mutex_destroy(&param->print_msg_mutex);
  param->need_print_msg_lock= 0;

  my_free(sort_info.ft_buf);
  my_free(sort_info.key_block);
  my_free(sort_param);
  my_free(sort_info.buff);
  (void) end_io_cache(&param->read_cache);
  info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);
  if (!got_error && (param->testflag & T_UNPACK))
  {
    share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;
    share->pack.header_length=0;
  }
  DBUG_RETURN(got_error);
}","int mi_repair_parallel(MI_CHECK *VAR_0, register MI_INFO *VAR_1,
                       const char * VAR_2, int VAR_3, my_bool VAR_4)
{
  int VAR_5;
  uint VAR_6,VAR_7, VAR_8, VAR_9;
  ulong VAR_10;
  ha_rows VAR_11;
  my_off_t VAR_12,VAR_13;
  File VAR_14;
  MI_SORT_PARAM *VAR_15=0;
  MYISAM_SHARE *VAR_16=VAR_1->s;
  ulong   *VAR_17;
  HA_KEYSEG *VAR_18;
  char VAR_19[22];
  IO_CACHE VAR_20; /* COMMENT_0 */
  IO_CACHE_SHARE VAR_21;
  SORT_INFO VAR_22;
  ulonglong UNINIT_VAR(key_map);
  pthread_attr_t VAR_23;
  ulong VAR_24;
  int VAR_25;
  DBUG_ENTER(""mi_repair_parallel"");

  VAR_11=VAR_1->state->records;
  VAR_5=1;
  VAR_14= -1;
  VAR_12=(VAR_0->testflag & VAR_26) ? 0 :
    VAR_16->pack.header_length;
  if (!(VAR_0->testflag & VAR_27))
  {
    printf(""- parallel recovering (with sort) MyISAM-table '%s'\n"",VAR_2);
    printf(""Data records: %s\n"", llstr(VAR_11,VAR_19));
  }
  VAR_0->testflag|=VAR_28; /* COMMENT_1 */

  if (VAR_1->s->options & (VAR_29 | VAR_30))
    VAR_0->testflag|=VAR_31;

  /* COMMENT_2 */
                                                              
     
                                                                     
     

                                                        
     
                    

                                                                       
                                                                    

                    

                                                                 

                                                                      
                               

                                                                         
                       

                                                                        
                                                                      
                                   
     
    
  DBUG_PRINT(""info"", (""is quick repair: %d"", VAR_3));
  bzero((char*)&VAR_22,sizeof(VAR_22));
  /* COMMENT_22 */
  mysql_mutex_init(VAR_32,
                   &VAR_22.mutex, VAR_33);
  mysql_cond_init(VAR_34, &VAR_22.cond, 0);
  mysql_mutex_init(VAR_35,
                   &VAR_0->print_msg_mutex, VAR_33);
  VAR_0->need_print_msg_lock= 1;

  if (!(VAR_22.key_block=
	alloc_key_blocks(VAR_0, (uint) VAR_0->sort_key_blocks,
			 VAR_16->base.max_key_block_length)) ||
      init_io_cache(&VAR_0->read_cache, VAR_1->dfile,
                    (uint) VAR_0->read_buffer_length,
                    VAR_36, VAR_16->pack.header_length, 1, MYF(VAR_37)) ||
      (!VAR_3 &&
       (init_io_cache(&VAR_1->rec_cache, VAR_1->dfile,
                      (uint) VAR_0->write_buffer_length,
                      VAR_38, VAR_12, 1,
                      MYF(VAR_37 | VAR_39) & VAR_0->myf_rw) ||
        init_io_cache(&VAR_20, -1,
                      (uint) VAR_0->write_buffer_length,
                      VAR_36, VAR_12, 1,
                      MYF(VAR_37 | VAR_40)))))
    goto err;
  VAR_22.key_block_end=VAR_22.key_block+VAR_0->sort_key_blocks;
  VAR_1->opt_flag|=VAR_41;
  VAR_1->rec_cache.file=VAR_1->dfile;         /* COMMENT_23 */

  if (!VAR_3)
  {
    /* COMMENT_24 */
    if ((VAR_14= mysql_file_create(VAR_42,
                                     fn_format(VAR_0->temp_filename,
                                               VAR_16->data_file_name, """",
                                               VAR_43, 2+4),
                                     0, VAR_0->tmpfile_createflag,
                                     MYF(0))) < 0)
    {
      mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
			   VAR_0->temp_filename);
      goto err;
    }
    if (VAR_12 &&
        filecopy(VAR_0, VAR_14,VAR_1->dfile,0L,VAR_12,
		 ""datafile-header""))
      goto err;
    if (VAR_0->testflag & VAR_26)
    {
      VAR_16->options&= ~VAR_30;
      mi_int2store(VAR_16->state.header.options,VAR_16->options);
    }
    VAR_16->state.dellink= VAR_44;
    VAR_1->rec_cache.file=VAR_14;
  }

  VAR_1->update= (short) (VAR_45 | VAR_46);

  /* COMMENT_25 */
  mi_drop_all_indexes(VAR_0, VAR_1, FALSE);
  key_map= VAR_16->state.key_map;
  if (VAR_0->testflag & VAR_47)
  {
    /* COMMENT_26 */
    key_map= ~key_map;
  }

  VAR_22.info=VAR_1;
  VAR_22.param = VAR_0;

  set_data_file_type(&VAR_22, VAR_16);
  VAR_22.dupp=0;
  VAR_22.buff=0;
  VAR_0->read_cache.end_of_file=VAR_22.filelength=
    mysql_file_seek(VAR_0->read_cache.file, 0L, VAR_48, MYF(0));

  if (VAR_16->data_file_type == VAR_49)
    VAR_10=max(VAR_16->base.min_pack_length+1,VAR_16->base.min_block_length);
  else if (VAR_16->data_file_type == VAR_50)
    VAR_10=VAR_16->base.min_block_length;
  else
    VAR_10=VAR_16->base.pack_reclength;
  /* COMMENT_27 */
                                                       
                                                          
                                                     
                                                                     
                                                                     
                                                              
                                                        
                                                     
                                                                    
                  
    
  VAR_22.max_records=
    ((VAR_0->testflag & VAR_47) ? VAR_1->state->records + 1:
     (ha_rows) (VAR_22.filelength/VAR_10+1));

  VAR_13=VAR_1->state->del;
  VAR_0->glob_crc=0;
  /* COMMENT_39 */
  VAR_24= VAR_16->base.pack_reclength;
  if (VAR_16->options & VAR_30)
    set_if_bigger(VAR_24, VAR_16->max_pack_length);
  if (!(VAR_15=(MI_SORT_PARAM *)
        my_malloc((uint) VAR_16->base.keys *
		  (sizeof(MI_SORT_PARAM) + VAR_24),
		  MYF(VAR_51))))
  {
    mi_check_print_error(VAR_0,""Not enough memory for key!"");
    goto err;
  }
  VAR_8=0;
  VAR_17= VAR_0->rec_per_key_part;
  VAR_1->state->records=VAR_1->state->del=VAR_16->state.split=0;
  VAR_1->state->empty=0;

  for (VAR_6=VAR_7=0, VAR_9=1 ; VAR_7 < VAR_16->base.keys ;
       VAR_17+=VAR_15[VAR_6].keyinfo->keysegs, VAR_6+=VAR_9, VAR_7++)
  {
    VAR_15[VAR_6].key=VAR_7;
    VAR_15[VAR_6].keyinfo=VAR_16->keyinfo+VAR_7;
    VAR_15[VAR_6].seg=VAR_15[VAR_6].keyinfo->seg;
    /* COMMENT_40 */
                                                            
                                      
      
    if (! mi_is_key_active(key_map, VAR_7))
    {
      /* COMMENT_44 */
      memcpy((char*) VAR_17,
	     (char*) (VAR_16->state.rec_per_key_part+
		      (uint) (VAR_17 - VAR_0->rec_per_key_part)),
	     VAR_15[VAR_6].keyinfo->keysegs*sizeof(*VAR_17));
      VAR_9=0;
      continue;
    }
    VAR_9=1;
    if ((!(VAR_0->testflag & VAR_27)))
      printf (""- Fixing index %d\n"",VAR_7+1);
    if (VAR_15[VAR_6].keyinfo->flag & VAR_52)
    {
      VAR_15[VAR_6].key_read=VAR_53;
      VAR_15[VAR_6].key_write=VAR_54;
    }
    else
    {
      VAR_15[VAR_6].key_read=VAR_55;
      VAR_15[VAR_6].key_write=VAR_56;
    }
    VAR_15[VAR_6].key_cmp=VAR_57;
    VAR_15[VAR_6].lock_in_memory=VAR_58;
    VAR_15[VAR_6].tmpdir=VAR_0->tmpdir;
    VAR_15[VAR_6].sort_info=&VAR_22;
    VAR_15[VAR_6].master=0;
    VAR_15[VAR_6].fix_datafile=0;
    VAR_15[VAR_6].calc_checksum= 0;

    VAR_15[VAR_6].filepos=VAR_12;
    VAR_15[VAR_6].max_pos=VAR_15[VAR_6].pos=VAR_16->pack.header_length;

    VAR_15[VAR_6].record= (((uchar *)(VAR_15+VAR_16->base.keys))+
			   (VAR_24 * VAR_6));
    if (!mi_alloc_rec_buff(VAR_1, -1, &VAR_15[VAR_6].rec_buff))
    {
      mi_check_print_error(VAR_0,""Not enough memory!"");
      goto err;
    }

    VAR_15[VAR_6].key_length=VAR_16->rec_reflength;
    for (VAR_18=VAR_15[VAR_6].seg; VAR_18->type != VAR_59;
	 VAR_18++)
    {
      VAR_15[VAR_6].key_length+=VAR_18->length;
      if (VAR_18->flag & VAR_60)
        VAR_15[VAR_6].key_length+=get_pack_length(VAR_18->length);
      if (VAR_18->flag & (VAR_61 | VAR_62))
        VAR_15[VAR_6].key_length+=2 + test(VAR_18->length >= 127);
      if (VAR_18->flag & VAR_63)
        VAR_15[VAR_6].key_length++;
    }
    VAR_8+=VAR_15[VAR_6].key_length;

    if (VAR_15[VAR_6].keyinfo->flag & VAR_52)
    {
      uint VAR_64=VAR_65*
                                    VAR_15[VAR_6].keyinfo->seg->charset->mbmaxlen;
      VAR_15[VAR_6].key_length+=VAR_64-VAR_66;
      init_alloc_root(&VAR_15[VAR_6].wordroot, VAR_67, 0);
    }
  }
  VAR_22.total_keys=VAR_6;
  VAR_15[0].master= 1;
  VAR_15[0].fix_datafile= (my_bool)(! VAR_3);
  VAR_15[0].calc_checksum= test(VAR_0->testflag & VAR_31);

  if (!ftparser_alloc_param(VAR_1))
    goto err;

  VAR_22.got_error=0;
  mysql_mutex_lock(&VAR_22.mutex);

  /* COMMENT_45 */
                                                                       
                                                                       
                                                                     
                
    
  if (VAR_6 > 1)
  {
    if (VAR_3)
      init_io_cache_share(&VAR_0->read_cache, &VAR_21, NULL, VAR_6);
    else
      init_io_cache_share(&VAR_20, &VAR_21, &VAR_1->rec_cache, VAR_6);
  }
  else
    VAR_21.total_threads= 0; /* COMMENT_51 */

  (void) pthread_attr_init(&VAR_23);
  (void) pthread_attr_setdetachstate(&VAR_23,VAR_68);

  for (VAR_6=0 ; VAR_6 < VAR_22.total_keys ; VAR_6++)
  {
    /* COMMENT_52 */
                                                                    
                                                                        
                                                                   
                                                                        
                                                              
                                             
      
    VAR_15[VAR_6].read_cache= ((VAR_3 || !VAR_6) ? VAR_0->read_cache :
                               VAR_20);
    DBUG_PRINT(""io_cache_share"", (""thread: %u  read_cache: 0x%lx"",
                                  VAR_6, (long) &VAR_15[VAR_6].read_cache));

    /* COMMENT_60 */
                                                               
                                                                  
                                                                    
                                                                         
      
    VAR_15[VAR_6].sortbuff_size=
#ifndef VAR_69
      VAR_0->sort_buffer_length/VAR_22.total_keys;
#else
      VAR_0->sort_buffer_length*VAR_15[VAR_6].key_length/VAR_8;
#endif
    if ((VAR_25= mysql_thread_create(VAR_70,
                                    &VAR_15[VAR_6].thr, &VAR_23,
                                    VAR_71,
                                    (void *) (VAR_15+VAR_6))))
    {
      mi_check_print_error(VAR_0,""Cannot start a repair thread (errno= %d)"",
                           VAR_25);
      /* COMMENT_66 */
      if (VAR_21.total_threads)
        remove_io_thread(&VAR_15[VAR_6].read_cache);
      DBUG_PRINT(""error"", (""Cannot start a repair thread""));
      VAR_22.got_error=1;
    }
    else
      VAR_22.threads_running++;
  }
  (void) pthread_attr_destroy(&VAR_23);

  /* COMMENT_67 */
  while (VAR_22.threads_running)
    mysql_cond_wait(&VAR_22.cond, &VAR_22.mutex);
  mysql_mutex_unlock(&VAR_22.mutex);

  if ((VAR_5= thr_write_keys(VAR_15)))
  {
    VAR_0->retry_repair=1;
    goto err;
  }
  VAR_5=1;				/* COMMENT_68 */

  if (VAR_15[0].fix_datafile)
  {
    /* COMMENT_69 */
                                                                      
                                                                      
                                                          
      
    if (write_data_suffix(&VAR_22,1) || end_io_cache(&VAR_1->rec_cache))
      goto err;
    if (VAR_0->testflag & VAR_72)
    {
      /* COMMENT_74 */
      if (VAR_1->state->records+1 < VAR_11)
      {
        VAR_1->state->records=VAR_11;
        goto err;
      }
    }
    VAR_16->state.state.data_file_length= VAR_1->state->data_file_length=
      VAR_15->filepos;
    /* COMMENT_75 */
    VAR_16->state.version=(ulong) time((time_t*) 0);

    /* COMMENT_76 */
                                                                        
                           
       
    mysql_file_close(VAR_1->dfile, MYF(0));
    VAR_1->dfile=VAR_14;

    VAR_16->data_file_type=VAR_22.new_data_file_type;
    VAR_16->pack.header_length=(ulong) VAR_12;
  }
  else
    VAR_1->state->data_file_length=VAR_15->max_pos;

  if (VAR_3 && VAR_13+VAR_22.dupp != VAR_1->state->del)
  {
    mi_check_print_error(VAR_0,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
    mi_check_print_error(VAR_0,""Run recovery again without -q"");
    VAR_0->retry_repair=1;
    VAR_0->testflag|=VAR_73;
    goto err;
  }

  if (VAR_3 & VAR_74)
  {
    my_off_t VAR_75=VAR_1->state->data_file_length+
      (VAR_16->options & VAR_30 ?
       VAR_76 : 0);
#ifdef VAR_77
    if (VAR_16->data_file_type == VAR_78 &&
	VAR_75 < VAR_16->base.reloc*VAR_16->base.min_pack_length)
      VAR_75=VAR_16->base.reloc*VAR_16->base.min_pack_length;
#endif
    if (VAR_75 != VAR_22.filelength)
      if (mysql_file_chsize(VAR_1->dfile, VAR_75, 0, MYF(0)))
	mi_check_print_warning(VAR_0,
			       ""Can't change size of datafile,  error: %d"",
			       VAR_79);
  }
  if (VAR_0->testflag & VAR_31)
    VAR_1->state->checksum=VAR_0->glob_crc;

  if (mysql_file_chsize(VAR_16->kfile, VAR_1->state->key_file_length, 0, MYF(0)))
    mi_check_print_warning(VAR_0,
			   ""Can't change size of indexfile, error: %d"", VAR_79);

  if (!(VAR_0->testflag & VAR_27))
  {
    if (VAR_11 != VAR_1->state->records)
      printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_19));
    if (VAR_22.dupp)
      mi_check_print_warning(VAR_0,
			     ""%s records have been removed"",
			     llstr(VAR_22.dupp,VAR_19));
  }
  VAR_5=0;

  if (&VAR_16->state.state != VAR_1->state)
    memcpy(&VAR_16->state.state, VAR_1->state, sizeof(*VAR_1->state));

err:
  VAR_5|= flush_blocks(VAR_0, VAR_16->key_cache, VAR_16->kfile);
  /* COMMENT_80 */
                                                                      
                                                                     
                                              
    
  (void) end_io_cache(&VAR_1->rec_cache);
  /* COMMENT_85 */
                                                                     
                                                                  
                                                                     
                          
    
  if (!VAR_3)
    (void) end_io_cache(&VAR_20);
  if (!VAR_5)
  {
    /* COMMENT_91 */
    if (VAR_14 >= 0)
    {
      myf VAR_80= 0;
      if (VAR_0->testflag & VAR_81)
        VAR_80 |= VAR_82;
      if (VAR_4)
        VAR_80 |= VAR_83;
      mysql_file_close(VAR_14, MYF(0));
      VAR_1->dfile=VAR_14= -1;
      if (change_to_newfile(VAR_16->data_file_name, VAR_84, VAR_43,
			    VAR_80) ||
	  mi_open_datafile(VAR_1,VAR_16,VAR_2,-1))
	VAR_5=1;
    }
  }
  if (VAR_5)
  {
    if (! VAR_0->error_printed)
      mi_check_print_error(VAR_0,""%d when fixing table"",VAR_79);
    if (VAR_14 >= 0)
    {
      (void) mysql_file_close(VAR_14, MYF(0));
      (void) mysql_file_delete(VAR_42,
                               VAR_0->temp_filename, MYF(VAR_37));
      if (VAR_1->dfile == VAR_14) /* COMMENT_92 */
        if (unlikely(mi_open_datafile(VAR_1, VAR_16, VAR_2, -1)))
          VAR_0->retry_repair= 0; /* COMMENT_93 */
    }
    mi_mark_crashed_on_repair(VAR_1);
  }
  else if (key_map == VAR_16->state.key_map)
    VAR_16->state.changed&= ~VAR_85;
  VAR_16->state.changed|=VAR_86;

  mysql_cond_destroy(&VAR_22.cond);
  mysql_mutex_destroy(&VAR_22.mutex);
  mysql_mutex_destroy(&VAR_0->print_msg_mutex);
  VAR_0->need_print_msg_lock= 0;

  my_free(VAR_22.ft_buf);
  my_free(VAR_22.key_block);
  my_free(VAR_15);
  my_free(VAR_22.buff);
  (void) end_io_cache(&VAR_0->read_cache);
  VAR_1->opt_flag&= ~(VAR_87 | VAR_41);
  if (!VAR_5 && (VAR_0->testflag & VAR_26))
  {
    VAR_16->state.header.options[0]&= (uchar) ~VAR_30;
    VAR_16->pack.header_length=0;
  }
  DBUG_RETURN(VAR_5);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,
-			const char * name, int rep_quick)
+                       const char * name, int rep_quick, my_bool no_copy_stat)
 {
   int got_error;
   uint i,key, total_key_length, istep;
@@ -446,11 +446,15 @@
     /* Replace the actual file with the temporary file */
     if (new_file >= 0)
     {
+      myf flags= 0;
+      if (param->testflag & T_BACKUP_DATA)
+        flags |= MY_REDEL_MAKE_BACKUP;
+      if (no_copy_stat)
+        flags |= MY_REDEL_NO_COPY_STAT;
       mysql_file_close(new_file, MYF(0));
       info->dfile=new_file= -1;
       if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,
-			    (param->testflag & T_BACKUP_DATA ?
-			     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||
+			    flags) ||
 	  mi_open_datafile(info,share,name,-1))
 	got_error=1;
     }","{'deleted_lines': ['\t\t\tconst char * name, int rep_quick)', '\t\t\t    (param->testflag & T_BACKUP_DATA ?', '\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||'], 'added_lines': ['                       const char * name, int rep_quick, my_bool no_copy_stat)', '      myf flags= 0;', '      if (param->testflag & T_BACKUP_DATA)', '        flags |= MY_REDEL_MAKE_BACKUP;', '      if (no_copy_stat)', '        flags |= MY_REDEL_NO_COPY_STAT;', '\t\t\t    flags) ||']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-08-16T13:35:19Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,mysql/mysql-server,"Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE

During REPAIR TABLE of a MyISAM table, a temporary data file (.TMD)
is created. When repair finishes, this file is renamed to the original
.MYD file. The problem was that during this rename, we copied the
stats from the old file to the new file with chmod/chown. If a user
managed to replace the temporary file before chmod/chown was executed,
it was possible to get an arbitrary file with the privileges of the
mysql user.

This patch fixes the problem by not copying stats from the old
file to the new file. This is not needed as the new file was
created with the correct stats. This fix only changes server
behavior - external utilities such as myisamchk still does
chmod/chown.

No test case provided since the problem involves synchronization
with file system operations.",4e5473862e6852b0f3802b0cd0c6fa10b5253291,https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,storage/myisam/mi_check.c,mi_repair,"int mi_repair(MI_CHECK *param, register MI_INFO *info,
char * name, int rep_quick)
{
int error,got_error;
ha_rows start_records,new_header_length;
my_off_t del;
File new_file;
MYISAM_SHARE *share=info->s;
char llbuff[22],llbuff2[22];
SORT_INFO sort_info;
MI_SORT_PARAM sort_param;
DBUG_ENTER(""mi_repair"");
bzero((char *)&sort_info, sizeof(sort_info));
bzero((char *)&sort_param, sizeof(sort_param));
start_records=info->state->records;
new_header_length=(param->testflag & T_UNPACK) ? 0L :
share->pack.header_length;
got_error=1;
new_file= -1;
sort_param.sort_info=&sort_info;
if (!(param->testflag & T_SILENT))
{
printf(""- recovering (with keycache) MyISAM-table '%s'\n"",name);
printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
}
param->testflag|=T_REP; 
if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))
param->testflag|=T_CALC_CHECKSUM;
DBUG_ASSERT(param->use_buffers < SIZE_T_MAX);
if (!param->using_global_keycache)
(void) init_key_cache(dflt_key_cache, param->key_cache_block_size,
param->use_buffers, 0, 0);
if (init_io_cache(&param->read_cache,info->dfile,
(uint) param->read_buffer_length,
READ_CACHE,share->pack.header_length,1,MYF(MY_WME)))
{
bzero(&info->rec_cache,sizeof(info->rec_cache));
goto err;
}
if (!rep_quick)
if (init_io_cache(&info->rec_cache,-1,(uint) param->write_buffer_length,
WRITE_CACHE, new_header_length, 1,
MYF(MY_WME | MY_WAIT_IF_FULL)))
goto err;
info->opt_flag|=WRITE_CACHE_USED;
if (!mi_alloc_rec_buff(info, -1, &sort_param.record) ||
!mi_alloc_rec_buff(info, -1, &sort_param.rec_buff))
{
mi_check_print_error(param, ""Not enough memory for extra record"");
goto err;
}
if (!rep_quick)
{
if ((new_file= mysql_file_create(mi_key_file_datatmp,
fn_format(param->temp_filename,
share->data_file_name, """",
DATA_TMP_EXT, 2+4),
0, param->tmpfile_createflag,
MYF(0))) < 0)
{
mi_check_print_error(param,""Can't create new tempfile: '%s'"",
param->temp_filename);
goto err;
}
if (new_header_length &&
filecopy(param,new_file,info->dfile,0L,new_header_length,
""datafile-header""))
goto err;
info->s->state.dellink= HA_OFFSET_ERROR;
info->rec_cache.file=new_file;
if (param->testflag & T_UNPACK)
{
share->options&= ~HA_OPTION_COMPRESS_RECORD;
mi_int2store(share->state.header.options,share->options);
}
}
sort_info.info=info;
sort_info.param = param;
sort_param.read_cache=param->read_cache;
sort_param.pos=sort_param.max_pos=share->pack.header_length;
sort_param.filepos=new_header_length;
param->read_cache.end_of_file=sort_info.filelength=
mysql_file_seek(info->dfile, 0L, MY_SEEK_END, MYF(0));
sort_info.dupp=0;
sort_param.fix_datafile= (my_bool) (! rep_quick);
sort_param.master=1;
sort_info.max_records= ~(ha_rows) 0;
set_data_file_type(&sort_info, share);
del=info->state->del;
info->state->records=info->state->del=share->state.split=0;
info->state->empty=0;
param->glob_crc=0;
if (param->testflag & T_CALC_CHECKSUM)
sort_param.calc_checksum= 1;
info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);
if (param->testflag & T_CREATE_MISSING_KEYS)
mi_set_all_keys_active(share->state.key_map, share->base.keys);
mi_drop_all_indexes(param, info, TRUE);
lock_memory(param);
while (!(error=sort_get_next_record(&sort_param)))
{
if (writekeys(&sort_param))
{
if (my_errno != HA_ERR_FOUND_DUPP_KEY)
goto err;
DBUG_DUMP(""record"",(uchar*) sort_param.record,share->base.pack_reclength);
mi_check_print_info(param,""Duplicate key %2d for record at %10s against new record at %10s"",
info->errkey+1,
llstr(sort_param.start_recpos,llbuff),
llstr(info->dupp_key_pos,llbuff2));
if (param->testflag & T_VERBOSE)
{
(void) _mi_make_key(info,(uint) info->errkey,info->lastkey,
sort_param.record,0L);
_mi_print_key(stdout,share->keyinfo[info->errkey].seg,info->lastkey,
USE_WHOLE_KEY);
}
sort_info.dupp++;
if ((param->testflag & (T_FORCE_UNIQUENESS|T_QUICK)) == T_QUICK)
{
param->testflag|=T_RETRY_WITHOUT_QUICK;
param->error_printed=1;
goto err;
}
continue;
}
if (sort_write_record(&sort_param))
goto err;
}
if (error > 0 || write_data_suffix(&sort_info, (my_bool)!rep_quick) ||
flush_io_cache(&info->rec_cache) || param->read_cache.error < 0)
goto err;
if (param->testflag & T_WRITE_LOOP)
{
(void) fputs(""          \r"",stdout); (void) fflush(stdout);
}
if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))
{
mi_check_print_warning(param,
""Can't change size of indexfile, error: %d"",
my_errno);
goto err;
}
if (rep_quick && del+sort_info.dupp != info->state->del)
{
mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
mi_check_print_error(param,""Run recovery again without -q"");
got_error=1;
param->retry_repair=1;
param->testflag|=T_RETRY_WITHOUT_QUICK;
goto err;
}
if (param->testflag & T_SAFE_REPAIR)
{
if (info->state->records+1 < start_records)
{
info->state->records=start_records;
got_error=1;
goto err;
}
}
if (!rep_quick)
{
mysql_file_close(info->dfile, MYF(0));
info->dfile=new_file;
info->state->data_file_length=sort_param.filepos;
share->state.version=(ulong) time((time_t*) 0);
}
else
{
info->state->data_file_length=sort_param.max_pos;
}
if (param->testflag & T_CALC_CHECKSUM)
info->state->checksum=param->glob_crc;
if (!(param->testflag & T_SILENT))
{
if (start_records != info->state->records)
printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
if (sort_info.dupp)
mi_check_print_warning(param,
""%s records have been removed"",
llstr(sort_info.dupp,llbuff));
}
got_error=0;
if (&share->state.state != info->state)
memcpy( &share->state.state, info->state, sizeof(*info->state));
err:
if (!got_error)
{
if (new_file >= 0)
{
mysql_file_close(new_file, MYF(0));
info->dfile=new_file= -1;
if (info->s->file_map)
{
(void) my_munmap((char*) info->s->file_map,
(size_t) info->s->mmaped_length);
info->s->file_map= NULL;
}
if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,
(param->testflag & T_BACKUP_DATA ?
MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||
mi_open_datafile(info,share,name,-1))
got_error=1;
param->retry_repair= 0;
}
}
if (got_error)
{
if (! param->error_printed)
mi_check_print_error(param,""%d for record at pos %s"",my_errno,
llstr(sort_param.start_recpos,llbuff));
if (new_file >= 0)
{
(void) mysql_file_close(new_file, MYF(0));
(void) mysql_file_delete(mi_key_file_datatmp,
param->temp_filename, MYF(MY_WME));
info->rec_cache.file=-1; 
}
mi_mark_crashed_on_repair(info);
}
my_free(mi_get_rec_buff_ptr(info, sort_param.rec_buff));
my_free(mi_get_rec_buff_ptr(info, sort_param.record));
my_free(sort_info.buff);
(void) end_io_cache(&param->read_cache);
info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);
(void) end_io_cache(&info->rec_cache);
got_error|=flush_blocks(param, share->key_cache, share->kfile);
if (!got_error && param->testflag & T_UNPACK)
{
share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;
share->pack.header_length=0;
share->data_file_type=sort_info.new_data_file_type;
}
share->state.changed|= (STATE_NOT_OPTIMIZED_KEYS | STATE_NOT_SORTED_PAGES |
STATE_NOT_ANALYZED);
DBUG_RETURN(got_error);
}","int mi_repair(MI_CHECK *VAR_0, register MI_INFO *VAR_1,
char * VAR_2, int VAR_3)
{
int VAR_4,VAR_5;
ha_rows VAR_6,VAR_7;
my_off_t VAR_8;
File VAR_9;
MYISAM_SHARE *VAR_10=VAR_1->s;
char VAR_11[22],VAR_12[22];
SORT_INFO VAR_13;
MI_SORT_PARAM VAR_14;
DBUG_ENTER(""mi_repair"");
bzero((char *)&VAR_13, sizeof(VAR_13));
bzero((char *)&VAR_14, sizeof(VAR_14));
VAR_6=VAR_1->state->records;
VAR_7=(VAR_0->testflag & VAR_15) ? 0L :
VAR_10->pack.header_length;
VAR_5=1;
VAR_9= -1;
VAR_14.sort_info=&VAR_13;
if (!(VAR_0->testflag & VAR_16))
{
printf(""- recovering (with keycache) MyISAM-table '%s'\n"",VAR_2);
printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_11));
}
VAR_0->testflag|=VAR_17; 
if (VAR_1->s->options & (VAR_18 | VAR_19))
VAR_0->testflag|=VAR_20;
DBUG_ASSERT(VAR_0->use_buffers < VAR_21);
if (!VAR_0->using_global_keycache)
(void) init_key_cache(VAR_22, VAR_0->key_cache_block_size,
VAR_0->use_buffers, 0, 0);
if (init_io_cache(&VAR_0->read_cache,VAR_1->dfile,
(uint) VAR_0->read_buffer_length,
VAR_23,VAR_10->pack.header_length,1,MYF(VAR_24)))
{
bzero(&VAR_1->rec_cache,sizeof(VAR_1->rec_cache));
goto err;
}
if (!VAR_3)
if (init_io_cache(&VAR_1->rec_cache,-1,(uint) VAR_0->write_buffer_length,
VAR_25, VAR_7, 1,
MYF(VAR_24 | VAR_26)))
goto err;
VAR_1->opt_flag|=VAR_27;
if (!mi_alloc_rec_buff(VAR_1, -1, &VAR_14.record) ||
!mi_alloc_rec_buff(VAR_1, -1, &VAR_14.rec_buff))
{
mi_check_print_error(VAR_0, ""Not enough memory for extra record"");
goto err;
}
if (!VAR_3)
{
if ((VAR_9= mysql_file_create(VAR_28,
fn_format(VAR_0->temp_filename,
VAR_10->data_file_name, """",
VAR_29, 2+4),
0, VAR_0->tmpfile_createflag,
MYF(0))) < 0)
{
mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
VAR_0->temp_filename);
goto err;
}
if (VAR_7 &&
filecopy(VAR_0,VAR_9,VAR_1->dfile,0L,VAR_7,
""datafile-header""))
goto err;
VAR_1->s->state.dellink= VAR_30;
VAR_1->rec_cache.file=VAR_9;
if (VAR_0->testflag & VAR_15)
{
VAR_10->options&= ~VAR_19;
mi_int2store(VAR_10->state.header.options,VAR_10->options);
}
}
VAR_13.info=VAR_1;
VAR_13.param = VAR_0;
VAR_14.read_cache=VAR_0->read_cache;
VAR_14.pos=VAR_14.max_pos=VAR_10->pack.header_length;
VAR_14.filepos=VAR_7;
VAR_0->read_cache.end_of_file=VAR_13.filelength=
mysql_file_seek(VAR_1->dfile, 0L, VAR_31, MYF(0));
VAR_13.dupp=0;
VAR_14.fix_datafile= (VAR_32) (! VAR_3);
VAR_14.master=1;
VAR_13.max_records= ~(ha_rows) 0;
set_data_file_type(&VAR_13, VAR_10);
VAR_8=VAR_1->state->del;
VAR_1->state->records=VAR_1->state->del=VAR_10->state.split=0;
VAR_1->state->empty=0;
VAR_0->glob_crc=0;
if (VAR_0->testflag & VAR_20)
VAR_14.calc_checksum= 1;
VAR_1->update= (short) (VAR_33 | VAR_34);
if (VAR_0->testflag & VAR_35)
mi_set_all_keys_active(VAR_10->state.key_map, VAR_10->base.keys);
mi_drop_all_indexes(VAR_0, VAR_1, TRUE);
lock_memory(VAR_0);
while (!(VAR_4=sort_get_next_record(&VAR_14)))
{
if (writekeys(&VAR_14))
{
if (VAR_36 != VAR_37)
goto err;
DBUG_DUMP(""record"",(uchar*) VAR_14.record,VAR_10->base.pack_reclength);
mi_check_print_info(VAR_0,""Duplicate key %2d for record at %10s against new record at %10s"",
VAR_1->errkey+1,
llstr(VAR_14.start_recpos,VAR_11),
llstr(VAR_1->dupp_key_pos,VAR_12));
if (VAR_0->testflag & VAR_38)
{
(void) _mi_make_key(VAR_1,(uint) VAR_1->errkey,VAR_1->lastkey,
VAR_14.record,0L);
_mi_print_key(VAR_39,VAR_10->keyinfo[VAR_1->errkey].seg,VAR_1->lastkey,
VAR_40);
}
VAR_13.dupp++;
if ((VAR_0->testflag & (VAR_41|VAR_42)) == VAR_42)
{
VAR_0->testflag|=VAR_43;
VAR_0->error_printed=1;
goto err;
}
continue;
}
if (sort_write_record(&VAR_14))
goto err;
}
if (VAR_4 > 0 || write_data_suffix(&VAR_13, (my_bool)!VAR_3) ||
flush_io_cache(&VAR_1->rec_cache) || VAR_0->read_cache.error < 0)
goto err;
if (VAR_0->testflag & VAR_44)
{
(void) fputs(""          \r"",VAR_39); (void) fflush(VAR_39);
}
if (mysql_file_chsize(VAR_10->kfile, VAR_1->state->key_file_length, 0, MYF(0)))
{
mi_check_print_warning(VAR_0,
""Can't change size of indexfile, error: %d"",
VAR_36);
goto err;
}
if (VAR_3 && VAR_8+VAR_13.dupp != VAR_1->state->del)
{
mi_check_print_error(VAR_0,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
mi_check_print_error(VAR_0,""Run recovery again without -q"");
VAR_5=1;
VAR_0->retry_repair=1;
VAR_0->testflag|=VAR_43;
goto err;
}
if (VAR_0->testflag & VAR_45)
{
if (VAR_1->state->records+1 < VAR_6)
{
VAR_1->state->records=VAR_6;
VAR_5=1;
goto err;
}
}
if (!VAR_3)
{
mysql_file_close(VAR_1->dfile, MYF(0));
VAR_1->dfile=VAR_9;
VAR_1->state->data_file_length=VAR_14.filepos;
VAR_10->state.version=(ulong) time((time_t*) 0);
}
else
{
VAR_1->state->data_file_length=VAR_14.max_pos;
}
if (VAR_0->testflag & VAR_20)
VAR_1->state->checksum=VAR_0->glob_crc;
if (!(VAR_0->testflag & VAR_16))
{
if (VAR_6 != VAR_1->state->records)
printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_11));
if (VAR_13.dupp)
mi_check_print_warning(VAR_0,
""%s records have been removed"",
llstr(VAR_13.dupp,VAR_11));
}
VAR_5=0;
if (&VAR_10->state.state != VAR_1->state)
memcpy( &VAR_10->state.state, VAR_1->state, sizeof(*VAR_1->state));
err:
if (!VAR_5)
{
if (VAR_9 >= 0)
{
mysql_file_close(VAR_9, MYF(0));
VAR_1->dfile=VAR_9= -1;
if (VAR_1->s->file_map)
{
(void) my_munmap((char*) VAR_1->s->file_map,
(size_t) VAR_1->s->mmaped_length);
VAR_1->s->file_map= NULL;
}
if (change_to_newfile(VAR_10->data_file_name, VAR_46, VAR_29,
(VAR_0->testflag & VAR_47 ?
MYF(VAR_48): MYF(0))) ||
mi_open_datafile(VAR_1,VAR_10,VAR_2,-1))
VAR_5=1;
VAR_0->retry_repair= 0;
}
}
if (VAR_5)
{
if (! VAR_0->error_printed)
mi_check_print_error(VAR_0,""%d for record at pos %s"",VAR_36,
llstr(VAR_14.start_recpos,VAR_11));
if (VAR_9 >= 0)
{
(void) mysql_file_close(VAR_9, MYF(0));
(void) mysql_file_delete(VAR_28,
VAR_0->temp_filename, MYF(VAR_24));
VAR_1->rec_cache.file=-1; 
}
mi_mark_crashed_on_repair(VAR_1);
}
my_free(mi_get_rec_buff_ptr(VAR_1, VAR_14.rec_buff));
my_free(mi_get_rec_buff_ptr(VAR_1, VAR_14.record));
my_free(VAR_13.buff);
(void) end_io_cache(&VAR_0->read_cache);
VAR_1->opt_flag&= ~(VAR_49 | VAR_27);
(void) end_io_cache(&VAR_1->rec_cache);
VAR_5|=flush_blocks(VAR_0, VAR_10->key_cache, VAR_10->kfile);
if (!VAR_5 && VAR_0->testflag & VAR_15)
{
VAR_10->state.header.options[0]&= (uchar) ~VAR_19;
VAR_10->pack.header_length=0;
VAR_10->data_file_type=VAR_13.new_data_file_type;
}
VAR_10->state.changed|= (VAR_50 | VAR_51 |
VAR_52);
DBUG_RETURN(VAR_5);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/before/1.json,"int mi_repair(MI_CHECK *param, register MI_INFO *info,
	      char * name, int rep_quick, my_bool no_copy_stat)
{
  int error,got_error;
  ha_rows start_records,new_header_length;
  my_off_t del;
  File new_file;
  MYISAM_SHARE *share=info->s;
  char llbuff[22],llbuff2[22];
  SORT_INFO sort_info;
  MI_SORT_PARAM sort_param;
  DBUG_ENTER(""mi_repair"");

  bzero((char *)&sort_info, sizeof(sort_info));
  bzero((char *)&sort_param, sizeof(sort_param));
  start_records=info->state->records;
  new_header_length=(param->testflag & T_UNPACK) ? 0L :
    share->pack.header_length;
  got_error=1;
  new_file= -1;
  sort_param.sort_info=&sort_info;

  if (!(param->testflag & T_SILENT))
  {
    printf(""- recovering (with keycache) MyISAM-table '%s'\n"",name);
    printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
  }
  param->testflag|=T_REP; /* for easy checking */

  if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD))
    param->testflag|=T_CALC_CHECKSUM;

  DBUG_ASSERT(param->use_buffers < SIZE_T_MAX);

  if (!param->using_global_keycache)
    (void) init_key_cache(dflt_key_cache, param->key_cache_block_size,
                        param->use_buffers, 0, 0);

  if (init_io_cache(&param->read_cache,info->dfile,
		    (uint) param->read_buffer_length,
		    READ_CACHE,share->pack.header_length,1,MYF(MY_WME)))
  {
    bzero(&info->rec_cache,sizeof(info->rec_cache));
    goto err;
  }
  if (!rep_quick)
    if (init_io_cache(&info->rec_cache,-1,(uint) param->write_buffer_length,
		      WRITE_CACHE, new_header_length, 1,
		      MYF(MY_WME | MY_WAIT_IF_FULL)))
      goto err;
  info->opt_flag|=WRITE_CACHE_USED;
  if (!mi_alloc_rec_buff(info, -1, &sort_param.record) ||
      !mi_alloc_rec_buff(info, -1, &sort_param.rec_buff))
  {
    mi_check_print_error(param, ""Not enough memory for extra record"");
    goto err;
  }

  if (!rep_quick)
  {
    /* Get real path for data file */
    if ((new_file= mysql_file_create(mi_key_file_datatmp,
                                     fn_format(param->temp_filename,
                                               share->data_file_name, """",
                                               DATA_TMP_EXT, 2+4),
                                     0, param->tmpfile_createflag,
                                     MYF(0))) < 0)
    {
      mi_check_print_error(param,""Can't create new tempfile: '%s'"",
			   param->temp_filename);
      goto err;
    }
    if (new_header_length &&
        filecopy(param,new_file,info->dfile,0L,new_header_length,
		 ""datafile-header""))
      goto err;
    info->s->state.dellink= HA_OFFSET_ERROR;
    info->rec_cache.file=new_file;
    if (param->testflag & T_UNPACK)
    {
      share->options&= ~HA_OPTION_COMPRESS_RECORD;
      mi_int2store(share->state.header.options,share->options);
    }
  }
  sort_info.info=info;
  sort_info.param = param;
  sort_param.read_cache=param->read_cache;
  sort_param.pos=sort_param.max_pos=share->pack.header_length;
  sort_param.filepos=new_header_length;
  param->read_cache.end_of_file=sort_info.filelength=
    mysql_file_seek(info->dfile, 0L, MY_SEEK_END, MYF(0));
  sort_info.dupp=0;
  sort_param.fix_datafile= (my_bool) (! rep_quick);
  sort_param.master=1;
  sort_info.max_records= ~(ha_rows) 0;

  set_data_file_type(&sort_info, share);
  del=info->state->del;
  info->state->records=info->state->del=share->state.split=0;
  info->state->empty=0;
  param->glob_crc=0;
  if (param->testflag & T_CALC_CHECKSUM)
    sort_param.calc_checksum= 1;

  info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);

  /* This function always recreates all enabled indexes. */
  if (param->testflag & T_CREATE_MISSING_KEYS)
    mi_set_all_keys_active(share->state.key_map, share->base.keys);
  mi_drop_all_indexes(param, info, TRUE);

  lock_memory(param);			/* Everything is alloced */

  /* Re-create all keys, which are set in key_map. */
  while (!(error=sort_get_next_record(&sort_param)))
  {
    if (writekeys(&sort_param))
    {
      if (my_errno != HA_ERR_FOUND_DUPP_KEY)
	goto err;
      DBUG_DUMP(""record"",(uchar*) sort_param.record,share->base.pack_reclength);
      mi_check_print_info(param,""Duplicate key %2d for record at %10s against new record at %10s"",
			  info->errkey+1,
			  llstr(sort_param.start_recpos,llbuff),
			  llstr(info->dupp_key_pos,llbuff2));
      if (param->testflag & T_VERBOSE)
      {
	(void) _mi_make_key(info,(uint) info->errkey,info->lastkey,
			  sort_param.record,0L);
	_mi_print_key(stdout,share->keyinfo[info->errkey].seg,info->lastkey,
		      USE_WHOLE_KEY);
      }
      sort_info.dupp++;
      if ((param->testflag & (T_FORCE_UNIQUENESS|T_QUICK)) == T_QUICK)
      {
        param->testflag|=T_RETRY_WITHOUT_QUICK;
	param->error_printed=1;
	goto err;
      }
      continue;
    }
    if (sort_write_record(&sort_param))
      goto err;
  }
  if (error > 0 || write_data_suffix(&sort_info, (my_bool)!rep_quick) ||
      flush_io_cache(&info->rec_cache) || param->read_cache.error < 0)
    goto err;

  if (param->testflag & T_WRITE_LOOP)
  {
    (void) fputs(""          \r"",stdout); (void) fflush(stdout);
  }
  if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0)))
  {
    mi_check_print_warning(param,
			   ""Can't change size of indexfile, error: %d"",
			   my_errno);
    goto err;
  }

  if (rep_quick && del+sort_info.dupp != info->state->del)
  {
    mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
    mi_check_print_error(param,""Run recovery again without -q"");
    got_error=1;
    param->retry_repair=1;
    param->testflag|=T_RETRY_WITHOUT_QUICK;
    goto err;
  }
  if (param->testflag & T_SAFE_REPAIR)
  {
    /* Don't repair if we loosed more than one row */
    if (info->state->records+1 < start_records)
    {
      info->state->records=start_records;
      got_error=1;
      goto err;
    }
  }

  if (!rep_quick)
  {
    mysql_file_close(info->dfile, MYF(0));
    info->dfile=new_file;
    info->state->data_file_length=sort_param.filepos;
    share->state.version=(ulong) time((time_t*) 0);	/* Force reopen */
  }
  else
  {
    info->state->data_file_length=sort_param.max_pos;
  }
  if (param->testflag & T_CALC_CHECKSUM)
    info->state->checksum=param->glob_crc;

  if (!(param->testflag & T_SILENT))
  {
    if (start_records != info->state->records)
      printf(""Data records: %s\n"", llstr(info->state->records,llbuff));
    if (sort_info.dupp)
      mi_check_print_warning(param,
			     ""%s records have been removed"",
			     llstr(sort_info.dupp,llbuff));
  }

  got_error=0;
  /* If invoked by external program that uses thr_lock */
  if (&share->state.state != info->state)
    memcpy( &share->state.state, info->state, sizeof(*info->state));

err:
  if (!got_error)
  {
    /* Replace the actual file with the temporary file */
    if (new_file >= 0)
    {
      myf flags= 0;
      if (param->testflag & T_BACKUP_DATA)
        flags |= MY_REDEL_MAKE_BACKUP;
      if (no_copy_stat)
        flags |= MY_REDEL_NO_COPY_STAT;
      mysql_file_close(new_file, MYF(0));
      info->dfile=new_file= -1;
      /*
        On Windows, the old data file cannot be deleted if it is either
        open, or memory mapped. Closing the file won't remove the memory
        map implicilty on Windows. We closed the data file, but we keep
        the MyISAM table open. A memory map will be closed on the final
        mi_close() only. So we need to unmap explicitly here. After
        renaming the new file under the hook, we couldn't use the map of
        the old file any more anyway.
      */
      if (info->s->file_map)
      {
        (void) my_munmap((char*) info->s->file_map,
                         (size_t) info->s->mmaped_length);
        info->s->file_map= NULL;
      }
      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,
                            flags) ||
	  mi_open_datafile(info,share,name,-1))
	got_error=1;

      param->retry_repair= 0;
    }
  }
  if (got_error)
  {
    if (! param->error_printed)
      mi_check_print_error(param,""%d for record at pos %s"",my_errno,
		  llstr(sort_param.start_recpos,llbuff));
    if (new_file >= 0)
    {
      (void) mysql_file_close(new_file, MYF(0));
      (void) mysql_file_delete(mi_key_file_datatmp,
                               param->temp_filename, MYF(MY_WME));
      info->rec_cache.file=-1; /* don't flush data to new_file, it's closed */
    }
    mi_mark_crashed_on_repair(info);
  }
  my_free(mi_get_rec_buff_ptr(info, sort_param.rec_buff));
  my_free(mi_get_rec_buff_ptr(info, sort_param.record));
  my_free(sort_info.buff);
  (void) end_io_cache(&param->read_cache);
  info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED);
  (void) end_io_cache(&info->rec_cache);
  got_error|=flush_blocks(param, share->key_cache, share->kfile);
  if (!got_error && param->testflag & T_UNPACK)
  {
    share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD;
    share->pack.header_length=0;
    share->data_file_type=sort_info.new_data_file_type;
  }
  share->state.changed|= (STATE_NOT_OPTIMIZED_KEYS | STATE_NOT_SORTED_PAGES |
			  STATE_NOT_ANALYZED);
  DBUG_RETURN(got_error);
}","int mi_repair(MI_CHECK *VAR_0, register MI_INFO *VAR_1,
	      char * VAR_2, int VAR_3, my_bool VAR_4)
{
  int VAR_5,VAR_6;
  ha_rows VAR_7,VAR_8;
  my_off_t VAR_9;
  File VAR_10;
  MYISAM_SHARE *VAR_11=VAR_1->s;
  char VAR_12[22],VAR_13[22];
  SORT_INFO VAR_14;
  MI_SORT_PARAM VAR_15;
  DBUG_ENTER(""mi_repair"");

  bzero((char *)&VAR_14, sizeof(VAR_14));
  bzero((char *)&VAR_15, sizeof(VAR_15));
  VAR_7=VAR_1->state->records;
  VAR_8=(VAR_0->testflag & VAR_16) ? 0L :
    VAR_11->pack.header_length;
  VAR_6=1;
  VAR_10= -1;
  VAR_15.sort_info=&VAR_14;

  if (!(VAR_0->testflag & VAR_17))
  {
    printf(""- recovering (with keycache) MyISAM-table '%s'\n"",VAR_2);
    printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_12));
  }
  VAR_0->testflag|=VAR_18; /* COMMENT_0 */

  if (VAR_1->s->options & (VAR_19 | VAR_20))
    VAR_0->testflag|=VAR_21;

  DBUG_ASSERT(VAR_0->use_buffers < VAR_22);

  if (!VAR_0->using_global_keycache)
    (void) init_key_cache(VAR_23, VAR_0->key_cache_block_size,
                        VAR_0->use_buffers, 0, 0);

  if (init_io_cache(&VAR_0->read_cache,VAR_1->dfile,
		    (uint) VAR_0->read_buffer_length,
		    VAR_24,VAR_11->pack.header_length,1,MYF(VAR_25)))
  {
    bzero(&VAR_1->rec_cache,sizeof(VAR_1->rec_cache));
    goto err;
  }
  if (!VAR_3)
    if (init_io_cache(&VAR_1->rec_cache,-1,(uint) VAR_0->write_buffer_length,
		      VAR_26, VAR_8, 1,
		      MYF(VAR_25 | VAR_27)))
      goto err;
  VAR_1->opt_flag|=VAR_28;
  if (!mi_alloc_rec_buff(VAR_1, -1, &VAR_15.record) ||
      !mi_alloc_rec_buff(VAR_1, -1, &VAR_15.rec_buff))
  {
    mi_check_print_error(VAR_0, ""Not enough memory for extra record"");
    goto err;
  }

  if (!VAR_3)
  {
    /* COMMENT_1 */
    if ((VAR_10= mysql_file_create(VAR_29,
                                     fn_format(VAR_0->temp_filename,
                                               VAR_11->data_file_name, """",
                                               VAR_30, 2+4),
                                     0, VAR_0->tmpfile_createflag,
                                     MYF(0))) < 0)
    {
      mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
			   VAR_0->temp_filename);
      goto err;
    }
    if (VAR_8 &&
        filecopy(VAR_0,VAR_10,VAR_1->dfile,0L,VAR_8,
		 ""datafile-header""))
      goto err;
    VAR_1->s->state.dellink= VAR_31;
    VAR_1->rec_cache.file=VAR_10;
    if (VAR_0->testflag & VAR_16)
    {
      VAR_11->options&= ~VAR_20;
      mi_int2store(VAR_11->state.header.options,VAR_11->options);
    }
  }
  VAR_14.info=VAR_1;
  VAR_14.param = VAR_0;
  VAR_15.read_cache=VAR_0->read_cache;
  VAR_15.pos=VAR_15.max_pos=VAR_11->pack.header_length;
  VAR_15.filepos=VAR_8;
  VAR_0->read_cache.end_of_file=VAR_14.filelength=
    mysql_file_seek(VAR_1->dfile, 0L, VAR_32, MYF(0));
  VAR_14.dupp=0;
  VAR_15.fix_datafile= (my_bool) (! VAR_3);
  VAR_15.master=1;
  VAR_14.max_records= ~(ha_rows) 0;

  set_data_file_type(&VAR_14, VAR_11);
  VAR_9=VAR_1->state->del;
  VAR_1->state->records=VAR_1->state->del=VAR_11->state.split=0;
  VAR_1->state->empty=0;
  VAR_0->glob_crc=0;
  if (VAR_0->testflag & VAR_21)
    VAR_15.calc_checksum= 1;

  VAR_1->update= (short) (VAR_33 | VAR_34);

  /* COMMENT_2 */
  if (VAR_0->testflag & VAR_35)
    mi_set_all_keys_active(VAR_11->state.key_map, VAR_11->base.keys);
  mi_drop_all_indexes(VAR_0, VAR_1, TRUE);

  lock_memory(VAR_0);			/* COMMENT_3 */

  /* COMMENT_4 */
  while (!(VAR_5=sort_get_next_record(&VAR_15)))
  {
    if (writekeys(&VAR_15))
    {
      if (VAR_36 != VAR_37)
	goto err;
      DBUG_DUMP(""record"",(uchar*) VAR_15.record,VAR_11->base.pack_reclength);
      mi_check_print_info(VAR_0,""Duplicate key %2d for record at %10s against new record at %10s"",
			  VAR_1->errkey+1,
			  llstr(VAR_15.start_recpos,VAR_12),
			  llstr(VAR_1->dupp_key_pos,VAR_13));
      if (VAR_0->testflag & VAR_38)
      {
	(void) _mi_make_key(VAR_1,(uint) VAR_1->errkey,VAR_1->lastkey,
			  VAR_15.record,0L);
	_mi_print_key(VAR_39,VAR_11->keyinfo[VAR_1->errkey].seg,VAR_1->lastkey,
		      VAR_40);
      }
      VAR_14.dupp++;
      if ((VAR_0->testflag & (VAR_41|VAR_42)) == VAR_42)
      {
        VAR_0->testflag|=VAR_43;
	VAR_0->error_printed=1;
	goto err;
      }
      continue;
    }
    if (sort_write_record(&VAR_15))
      goto err;
  }
  if (VAR_5 > 0 || write_data_suffix(&VAR_14, (my_bool)!VAR_3) ||
      flush_io_cache(&VAR_1->rec_cache) || VAR_0->read_cache.error < 0)
    goto err;

  if (VAR_0->testflag & VAR_44)
  {
    (void) fputs(""          \r"",VAR_39); (void) fflush(VAR_39);
  }
  if (mysql_file_chsize(VAR_11->kfile, VAR_1->state->key_file_length, 0, MYF(0)))
  {
    mi_check_print_warning(VAR_0,
			   ""Can't change size of indexfile, error: %d"",
			   VAR_36);
    goto err;
  }

  if (VAR_3 && VAR_9+VAR_14.dupp != VAR_1->state->del)
  {
    mi_check_print_error(VAR_0,""Couldn't fix table with quick recovery: Found wrong number of deleted records"");
    mi_check_print_error(VAR_0,""Run recovery again without -q"");
    VAR_6=1;
    VAR_0->retry_repair=1;
    VAR_0->testflag|=VAR_43;
    goto err;
  }
  if (VAR_0->testflag & VAR_45)
  {
    /* COMMENT_5 */
    if (VAR_1->state->records+1 < VAR_7)
    {
      VAR_1->state->records=VAR_7;
      VAR_6=1;
      goto err;
    }
  }

  if (!VAR_3)
  {
    mysql_file_close(VAR_1->dfile, MYF(0));
    VAR_1->dfile=VAR_10;
    VAR_1->state->data_file_length=VAR_15.filepos;
    VAR_11->state.version=(ulong) time((time_t*) 0);	/* COMMENT_6 */
  }
  else
  {
    VAR_1->state->data_file_length=VAR_15.max_pos;
  }
  if (VAR_0->testflag & VAR_21)
    VAR_1->state->checksum=VAR_0->glob_crc;

  if (!(VAR_0->testflag & VAR_17))
  {
    if (VAR_7 != VAR_1->state->records)
      printf(""Data records: %s\n"", llstr(VAR_1->state->records,VAR_12));
    if (VAR_14.dupp)
      mi_check_print_warning(VAR_0,
			     ""%s records have been removed"",
			     llstr(VAR_14.dupp,VAR_12));
  }

  VAR_6=0;
  /* COMMENT_7 */
  if (&VAR_11->state.state != VAR_1->state)
    memcpy( &VAR_11->state.state, VAR_1->state, sizeof(*VAR_1->state));

err:
  if (!VAR_6)
  {
    /* COMMENT_8 */
    if (VAR_10 >= 0)
    {
      myf VAR_46= 0;
      if (VAR_0->testflag & VAR_47)
        VAR_46 |= VAR_48;
      if (VAR_4)
        VAR_46 |= VAR_49;
      mysql_file_close(VAR_10, MYF(0));
      VAR_1->dfile=VAR_10= -1;
      /* COMMENT_9 */
                                                                       
                                                                        
                                                                       
                                                                       
                                                                   
                                                                        
                                     
        
      if (VAR_1->s->file_map)
      {
        (void) my_munmap((char*) VAR_1->s->file_map,
                         (size_t) VAR_1->s->mmaped_length);
        VAR_1->s->file_map= NULL;
      }
      if (change_to_newfile(VAR_11->data_file_name, VAR_50, VAR_30,
                            VAR_46) ||
	  mi_open_datafile(VAR_1,VAR_11,VAR_2,-1))
	VAR_6=1;

      VAR_0->retry_repair= 0;
    }
  }
  if (VAR_6)
  {
    if (! VAR_0->error_printed)
      mi_check_print_error(VAR_0,""%d for record at pos %s"",VAR_36,
		  llstr(VAR_15.start_recpos,VAR_12));
    if (VAR_10 >= 0)
    {
      (void) mysql_file_close(VAR_10, MYF(0));
      (void) mysql_file_delete(VAR_29,
                               VAR_0->temp_filename, MYF(VAR_25));
      VAR_1->rec_cache.file=-1; /* COMMENT_18 */
    }
    mi_mark_crashed_on_repair(VAR_1);
  }
  my_free(mi_get_rec_buff_ptr(VAR_1, VAR_15.rec_buff));
  my_free(mi_get_rec_buff_ptr(VAR_1, VAR_15.record));
  my_free(VAR_14.buff);
  (void) end_io_cache(&VAR_0->read_cache);
  VAR_1->opt_flag&= ~(VAR_51 | VAR_28);
  (void) end_io_cache(&VAR_1->rec_cache);
  VAR_6|=flush_blocks(VAR_0, VAR_11->key_cache, VAR_11->kfile);
  if (!VAR_6 && VAR_0->testflag & VAR_16)
  {
    VAR_11->state.header.options[0]&= (uchar) ~VAR_20;
    VAR_11->pack.header_length=0;
    VAR_11->data_file_type=VAR_14.new_data_file_type;
  }
  VAR_11->state.changed|= (VAR_52 | VAR_53 |
			  VAR_54);
  DBUG_RETURN(VAR_6);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 int mi_repair(MI_CHECK *param, register MI_INFO *info,
-	      char * name, int rep_quick)
+	      char * name, int rep_quick, my_bool no_copy_stat)
 {
   int error,got_error;
   ha_rows start_records,new_header_length;
@@ -213,6 +213,11 @@
     /* Replace the actual file with the temporary file */
     if (new_file >= 0)
     {
+      myf flags= 0;
+      if (param->testflag & T_BACKUP_DATA)
+        flags |= MY_REDEL_MAKE_BACKUP;
+      if (no_copy_stat)
+        flags |= MY_REDEL_NO_COPY_STAT;
       mysql_file_close(new_file, MYF(0));
       info->dfile=new_file= -1;
       /*
@@ -231,8 +236,7 @@
         info->s->file_map= NULL;
       }
       if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,
-			    (param->testflag & T_BACKUP_DATA ?
-			     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||
+                            flags) ||
 	  mi_open_datafile(info,share,name,-1))
 	got_error=1;
 ","{'deleted_lines': ['\t      char * name, int rep_quick)', '\t\t\t    (param->testflag & T_BACKUP_DATA ?', '\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||'], 'added_lines': ['\t      char * name, int rep_quick, my_bool no_copy_stat)', '      myf flags= 0;', '      if (param->testflag & T_BACKUP_DATA)', '        flags |= MY_REDEL_MAKE_BACKUP;', '      if (no_copy_stat)', '        flags |= MY_REDEL_NO_COPY_STAT;', '                            flags) ||']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-08-16T13:35:19Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,mysql/mysql-server,"Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE

During REPAIR TABLE of a MyISAM table, a temporary data file (.TMD)
is created. When repair finishes, this file is renamed to the original
.MYD file. The problem was that during this rename, we copied the
stats from the old file to the new file with chmod/chown. If a user
managed to replace the temporary file before chmod/chown was executed,
it was possible to get an arbitrary file with the privileges of the
mysql user.

This patch fixes the problem by not copying stats from the old
file to the new file. This is not needed as the new file was
created with the correct stats. This fix only changes server
behavior - external utilities such as myisamchk still does
chmod/chown.

No test case provided since the problem involves synchronization
with file system operations.",4e5473862e6852b0f3802b0cd0c6fa10b5253291,https://github.com/mysql/mysql-server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,storage/myisam/mi_check.c,mi_sort_index,"int mi_sort_index(MI_CHECK *param, register MI_INFO *info, char * name)
{
reg2 uint key;
reg1 MI_KEYDEF *keyinfo;
File new_file;
my_off_t index_pos[HA_MAX_POSSIBLE_KEY];
uint r_locks,w_locks;
int old_lock;
MYISAM_SHARE *share=info->s;
MI_STATE_INFO old_state;
DBUG_ENTER(""mi_sort_index"");
for (key= 0,keyinfo= &share->keyinfo[0]; key < share->base.keys ;
key++,keyinfo++)
if (keyinfo->key_alg == HA_KEY_ALG_RTREE)
DBUG_RETURN(0);
if (!(param->testflag & T_SILENT))
printf(""- Sorting index for MyISAM-table '%s'\n"",name);
fn_format(param->temp_filename,name,"""", MI_NAME_IEXT,2+4+32);
if ((new_file= mysql_file_create(mi_key_file_datatmp,
fn_format(param->temp_filename,
param->temp_filename,
"""", INDEX_TMP_EXT, 2+4),
0, param->tmpfile_createflag, MYF(0))) <= 0)
{
mi_check_print_error(param,""Can't create new tempfile: '%s'"",
param->temp_filename);
DBUG_RETURN(-1);
}
if (filecopy(param, new_file,share->kfile,0L,
(ulong) share->base.keystart, ""headerblock""))
goto err;
param->new_file_pos=share->base.keystart;
for (key= 0,keyinfo= &share->keyinfo[0]; key < share->base.keys ;
key++,keyinfo++)
{
if (! mi_is_key_active(info->s->state.key_map, key))
continue;
if (share->state.key_root[key] != HA_OFFSET_ERROR)
{
index_pos[key]=param->new_file_pos;
if (sort_one_index(param,info,keyinfo,share->state.key_root[key],
new_file))
goto err;
}
else
index_pos[key]= HA_OFFSET_ERROR;
}
flush_key_blocks(share->key_cache,share->kfile, FLUSH_IGNORE_CHANGED);
share->state.version=(ulong) time((time_t*) 0);
old_state= share->state;
r_locks=   share->r_locks;
w_locks=   share->w_locks;
old_lock=  info->lock_type;
share->r_locks= share->w_locks= share->tot_locks= 0;
(void) _mi_writeinfo(info,WRITEINFO_UPDATE_KEYFILE);
(void) mysql_file_close(share->kfile, MYF(MY_WME));
share->kfile = -1;
(void) mysql_file_close(new_file, MYF(MY_WME));
if (change_to_newfile(share->index_file_name, MI_NAME_IEXT, INDEX_TMP_EXT,
MYF(0)) ||
mi_open_keyfile(share))
goto err2;
info->lock_type= F_UNLCK;
_mi_readinfo(info,F_WRLCK,0);
info->lock_type=  old_lock;
share->r_locks=   r_locks;
share->w_locks=   w_locks;
share->tot_locks= r_locks+w_locks;
share->state=     old_state;
info->state->key_file_length=param->new_file_pos;
info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);
for (key=0 ; key < info->s->base.keys ; key++)
info->s->state.key_root[key]=index_pos[key];
for (key=0 ; key < info->s->state.header.max_block_size_index ; key++)
info->s->state.key_del[key]=  HA_OFFSET_ERROR;
info->s->state.changed&= ~STATE_NOT_SORTED_PAGES;
DBUG_RETURN(0);
err:
(void) mysql_file_close(new_file, MYF(MY_WME));
err2:
(void) mysql_file_delete(mi_key_file_datatmp,
param->temp_filename, MYF(MY_WME));
DBUG_RETURN(-1);
}","int mi_sort_index(MI_CHECK *VAR_0, register MI_INFO *VAR_1, char * VAR_2)
{
reg2 VAR_3 VAR_4;
reg1 VAR_5 *VAR_6;
File VAR_7;
my_off_t VAR_8[VAR_9];
uint VAR_10,VAR_11;
int VAR_12;
MYISAM_SHARE *VAR_13=VAR_1->s;
MI_STATE_INFO VAR_14;
DBUG_ENTER(""mi_sort_index"");
for (VAR_4= 0,VAR_6= &VAR_13->keyinfo[0]; VAR_4 < VAR_13->base.keys ;
VAR_4++,VAR_6++)
if (VAR_6->key_alg == VAR_15)
DBUG_RETURN(0);
if (!(VAR_0->testflag & VAR_16))
printf(""- Sorting index for MyISAM-table '%s'\n"",VAR_2);
fn_format(VAR_0->temp_filename,VAR_2,"""", VAR_17,2+4+32);
if ((VAR_7= mysql_file_create(VAR_18,
fn_format(VAR_0->temp_filename,
VAR_0->temp_filename,
"""", VAR_19, 2+4),
0, VAR_0->tmpfile_createflag, MYF(0))) <= 0)
{
mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
VAR_0->temp_filename);
DBUG_RETURN(-1);
}
if (filecopy(VAR_0, VAR_7,VAR_13->kfile,0L,
(ulong) VAR_13->base.keystart, ""headerblock""))
goto err;
VAR_0->new_file_pos=VAR_13->base.keystart;
for (VAR_4= 0,VAR_6= &VAR_13->keyinfo[0]; VAR_4 < VAR_13->base.keys ;
VAR_4++,VAR_6++)
{
if (! mi_is_key_active(VAR_1->s->state.key_map, VAR_4))
continue;
if (VAR_13->state.key_root[VAR_4] != VAR_20)
{
VAR_8[VAR_4]=VAR_0->new_file_pos;
if (sort_one_index(VAR_0,VAR_1,VAR_6,VAR_13->state.key_root[VAR_4],
VAR_7))
goto err;
}
else
VAR_8[VAR_4]= VAR_20;
}
flush_key_blocks(VAR_13->key_cache,VAR_13->kfile, VAR_21);
VAR_13->state.version=(ulong) time((time_t*) 0);
VAR_14= VAR_13->state;
VAR_10=   VAR_13->r_locks;
VAR_11=   VAR_13->w_locks;
VAR_12=  VAR_1->lock_type;
VAR_13->r_locks= VAR_13->w_locks= VAR_13->tot_locks= 0;
(void) _mi_writeinfo(VAR_1,VAR_22);
(void) mysql_file_close(VAR_13->kfile, MYF(VAR_23));
VAR_13->kfile = -1;
(void) mysql_file_close(VAR_7, MYF(VAR_23));
if (change_to_newfile(VAR_13->index_file_name, VAR_17, VAR_19,
MYF(0)) ||
mi_open_keyfile(VAR_13))
goto err2;
VAR_1->lock_type= VAR_24;
_mi_readinfo(VAR_1,VAR_25,0);
VAR_1->lock_type=  VAR_12;
VAR_13->r_locks=   VAR_10;
VAR_13->w_locks=   VAR_11;
VAR_13->tot_locks= VAR_10+VAR_11;
VAR_13->state=     VAR_14;
VAR_1->state->key_file_length=VAR_0->new_file_pos;
VAR_1->update= (short) (VAR_26 | VAR_27);
for (VAR_4=0 ; VAR_4 < VAR_1->s->base.keys ; VAR_4++)
VAR_1->s->state.key_root[VAR_4]=VAR_8[VAR_4];
for (VAR_4=0 ; VAR_4 < VAR_1->s->state.header.max_block_size_index ; VAR_4++)
VAR_1->s->state.key_del[VAR_4]=  VAR_20;
VAR_1->s->state.changed&= ~VAR_28;
DBUG_RETURN(0);
err:
(void) mysql_file_close(VAR_7, MYF(VAR_23));
err2:
(void) mysql_file_delete(VAR_18,
VAR_0->temp_filename, MYF(VAR_23));
DBUG_RETURN(-1);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/before/2.json,"int mi_sort_index(MI_CHECK *param, register MI_INFO *info, char * name,
                  my_bool no_copy_stat)
{
  reg2 uint key;
  reg1 MI_KEYDEF *keyinfo;
  File new_file;
  my_off_t index_pos[HA_MAX_POSSIBLE_KEY];
  uint r_locks,w_locks;
  int old_lock;
  MYISAM_SHARE *share=info->s;
  MI_STATE_INFO old_state;
  DBUG_ENTER(""mi_sort_index"");

  /* cannot sort index files with R-tree indexes */
  for (key= 0,keyinfo= &share->keyinfo[0]; key < share->base.keys ;
       key++,keyinfo++)
    if (keyinfo->key_alg == HA_KEY_ALG_RTREE)
      DBUG_RETURN(0);

  if (!(param->testflag & T_SILENT))
    printf(""- Sorting index for MyISAM-table '%s'\n"",name);

  /* Get real path for index file */
  fn_format(param->temp_filename,name,"""", MI_NAME_IEXT,2+4+32);
  if ((new_file= mysql_file_create(mi_key_file_datatmp,
                                   fn_format(param->temp_filename,
                                             param->temp_filename,
                                             """", INDEX_TMP_EXT, 2+4),
                                   0, param->tmpfile_createflag, MYF(0))) <= 0)
  {
    mi_check_print_error(param,""Can't create new tempfile: '%s'"",
			 param->temp_filename);
    DBUG_RETURN(-1);
  }
  if (filecopy(param, new_file,share->kfile,0L,
	       (ulong) share->base.keystart, ""headerblock""))
    goto err;

  param->new_file_pos=share->base.keystart;
  for (key= 0,keyinfo= &share->keyinfo[0]; key < share->base.keys ;
       key++,keyinfo++)
  {
    if (! mi_is_key_active(info->s->state.key_map, key))
      continue;

    if (share->state.key_root[key] != HA_OFFSET_ERROR)
    {
      index_pos[key]=param->new_file_pos;	/* Write first block here */
      if (sort_one_index(param,info,keyinfo,share->state.key_root[key],
			 new_file))
	goto err;
    }
    else
      index_pos[key]= HA_OFFSET_ERROR;		/* No blocks */
  }

  /* Flush key cache for this file if we are calling this outside myisamchk */
  flush_key_blocks(share->key_cache,share->kfile, FLUSH_IGNORE_CHANGED);

  share->state.version=(ulong) time((time_t*) 0);
  old_state= share->state;			/* save state if not stored */
  r_locks=   share->r_locks;
  w_locks=   share->w_locks;
  old_lock=  info->lock_type;

	/* Put same locks as old file */
  share->r_locks= share->w_locks= share->tot_locks= 0;
  (void) _mi_writeinfo(info,WRITEINFO_UPDATE_KEYFILE);
  (void) mysql_file_close(share->kfile, MYF(MY_WME));
  share->kfile = -1;
  (void) mysql_file_close(new_file, MYF(MY_WME));
  if (change_to_newfile(share->index_file_name, MI_NAME_IEXT, INDEX_TMP_EXT,
			no_copy_stat ? MYF(MY_REDEL_NO_COPY_STAT) : MYF(0)) ||
      mi_open_keyfile(share))
    goto err2;
  info->lock_type= F_UNLCK;			/* Force mi_readinfo to lock */
  _mi_readinfo(info,F_WRLCK,0);			/* Will lock the table */
  info->lock_type=  old_lock;
  share->r_locks=   r_locks;
  share->w_locks=   w_locks;
  share->tot_locks= r_locks+w_locks;
  share->state=     old_state;			/* Restore old state */

  info->state->key_file_length=param->new_file_pos;
  info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED);
  for (key=0 ; key < info->s->base.keys ; key++)
    info->s->state.key_root[key]=index_pos[key];
  for (key=0 ; key < info->s->state.header.max_block_size_index ; key++)
    info->s->state.key_del[key]=  HA_OFFSET_ERROR;

  info->s->state.changed&= ~STATE_NOT_SORTED_PAGES;
  DBUG_RETURN(0);

err:
  (void) mysql_file_close(new_file, MYF(MY_WME));
err2:
  (void) mysql_file_delete(mi_key_file_datatmp,
                           param->temp_filename, MYF(MY_WME));
  DBUG_RETURN(-1);
}","int mi_sort_index(MI_CHECK *VAR_0, register MI_INFO *VAR_1, char * VAR_2,
                  my_bool VAR_3)
{
  reg2 VAR_4 VAR_5;
  reg1 VAR_6 *VAR_7;
  File VAR_8;
  my_off_t VAR_9[VAR_10];
  uint VAR_11,VAR_12;
  int VAR_13;
  MYISAM_SHARE *VAR_14=VAR_1->s;
  MI_STATE_INFO VAR_15;
  DBUG_ENTER(""mi_sort_index"");

  /* COMMENT_0 */
  for (VAR_5= 0,VAR_7= &VAR_14->keyinfo[0]; VAR_5 < VAR_14->base.keys ;
       VAR_5++,VAR_7++)
    if (VAR_7->key_alg == VAR_16)
      DBUG_RETURN(0);

  if (!(VAR_0->testflag & VAR_17))
    printf(""- Sorting index for MyISAM-table '%s'\n"",VAR_2);

  /* COMMENT_1 */
  fn_format(VAR_0->temp_filename,VAR_2,"""", VAR_18,2+4+32);
  if ((VAR_8= mysql_file_create(VAR_19,
                                   fn_format(VAR_0->temp_filename,
                                             VAR_0->temp_filename,
                                             """", VAR_20, 2+4),
                                   0, VAR_0->tmpfile_createflag, MYF(0))) <= 0)
  {
    mi_check_print_error(VAR_0,""Can't create new tempfile: '%s'"",
			 VAR_0->temp_filename);
    DBUG_RETURN(-1);
  }
  if (filecopy(VAR_0, VAR_8,VAR_14->kfile,0L,
	       (ulong) VAR_14->base.keystart, ""headerblock""))
    goto err;

  VAR_0->new_file_pos=VAR_14->base.keystart;
  for (VAR_5= 0,VAR_7= &VAR_14->keyinfo[0]; VAR_5 < VAR_14->base.keys ;
       VAR_5++,VAR_7++)
  {
    if (! mi_is_key_active(VAR_1->s->state.key_map, VAR_5))
      continue;

    if (VAR_14->state.key_root[VAR_5] != VAR_21)
    {
      VAR_9[VAR_5]=VAR_0->new_file_pos;	/* COMMENT_2 */
      if (sort_one_index(VAR_0,VAR_1,VAR_7,VAR_14->state.key_root[VAR_5],
			 VAR_8))
	goto err;
    }
    else
      VAR_9[VAR_5]= VAR_21;		/* COMMENT_3 */
  }

  /* COMMENT_4 */
  flush_key_blocks(VAR_14->key_cache,VAR_14->kfile, VAR_22);

  VAR_14->state.version=(ulong) time((time_t*) 0);
  VAR_15= VAR_14->state;			/* COMMENT_5 */
  VAR_11=   VAR_14->r_locks;
  VAR_12=   VAR_14->w_locks;
  VAR_13=  VAR_1->lock_type;

	/* COMMENT_6 */
  VAR_14->r_locks= VAR_14->w_locks= VAR_14->tot_locks= 0;
  (void) _mi_writeinfo(VAR_1,VAR_23);
  (void) mysql_file_close(VAR_14->kfile, MYF(VAR_24));
  VAR_14->kfile = -1;
  (void) mysql_file_close(VAR_8, MYF(VAR_24));
  if (change_to_newfile(VAR_14->index_file_name, VAR_18, VAR_20,
			VAR_3 ? MYF(VAR_25) : MYF(0)) ||
      mi_open_keyfile(VAR_14))
    goto err2;
  VAR_1->lock_type= VAR_26;			/* COMMENT_7 */
  _mi_readinfo(VAR_1,VAR_27,0);			/* COMMENT_8 */
  VAR_1->lock_type=  VAR_13;
  VAR_14->r_locks=   VAR_11;
  VAR_14->w_locks=   VAR_12;
  VAR_14->tot_locks= VAR_11+VAR_12;
  VAR_14->state=     VAR_15;			/* COMMENT_9 */

  VAR_1->state->key_file_length=VAR_0->new_file_pos;
  VAR_1->update= (short) (VAR_28 | VAR_29);
  for (VAR_5=0 ; VAR_5 < VAR_1->s->base.keys ; VAR_5++)
    VAR_1->s->state.key_root[VAR_5]=VAR_9[VAR_5];
  for (VAR_5=0 ; VAR_5 < VAR_1->s->state.header.max_block_size_index ; VAR_5++)
    VAR_1->s->state.key_del[VAR_5]=  VAR_21;

  VAR_1->s->state.changed&= ~VAR_30;
  DBUG_RETURN(0);

err:
  (void) mysql_file_close(VAR_8, MYF(VAR_24));
err2:
  (void) mysql_file_delete(VAR_19,
                           VAR_0->temp_filename, MYF(VAR_24));
  DBUG_RETURN(-1);
}",mysql/mysql-server/4e5473862e6852b0f3802b0cd0c6fa10b5253291/mi_check.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
-int mi_sort_index(MI_CHECK *param, register MI_INFO *info, char * name)
+int mi_sort_index(MI_CHECK *param, register MI_INFO *info, char * name,
+                  my_bool no_copy_stat)
 {
   reg2 uint key;
   reg1 MI_KEYDEF *keyinfo;
@@ -69,7 +70,7 @@
   share->kfile = -1;
   (void) mysql_file_close(new_file, MYF(MY_WME));
   if (change_to_newfile(share->index_file_name, MI_NAME_IEXT, INDEX_TMP_EXT,
-			MYF(0)) ||
+			no_copy_stat ? MYF(MY_REDEL_NO_COPY_STAT) : MYF(0)) ||
       mi_open_keyfile(share))
     goto err2;
   info->lock_type= F_UNLCK;			/* Force mi_readinfo to lock */","{'deleted_lines': ['int mi_sort_index(MI_CHECK *param, register MI_INFO *info, char * name)', '\t\t\tMYF(0)) ||'], 'added_lines': ['int mi_sort_index(MI_CHECK *param, register MI_INFO *info, char * name,', '                  my_bool no_copy_stat)', '\t\t\tno_copy_stat ? MYF(MY_REDEL_NO_COPY_STAT) : MYF(0)) ||']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-08-16T13:35:19Z,1
CVE-2016-6906,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libgd,"Fix OOB reads of the TGA decompression buffer

It is possible to craft TGA files which will overflow the decompression
buffer, but not the image's bitmap. Therefore we augment the check for the
bitmap's overflow with a check for the buffer's overflow.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org.

CVE-2016-6906",fb0e0cce0b9f25389ab56604c3547351617e1415,https://github.com/libgd/libgd/commit/fb0e0cce0b9f25389ab56604c3547351617e1415,src/gd_tga.c,read_image_tga,"int read_image_tga( gdIOCtx *ctx, oTga *tga )
{
int pixel_block_size = (tga->bits / 8);
int image_block_size = (tga->width * tga->height) * pixel_block_size;
int* decompression_buffer = NULL;
unsigned char* conversion_buffer = NULL;
int buffer_caret = 0;
int bitmap_caret = 0;
int i = 0;
int encoded_pixels;
int rle_size;
if(overflow2(tga->width, tga->height)) {
return -1;
}
if(overflow2(tga->width * tga->height, pixel_block_size)) {
return -1;
}
if(overflow2(image_block_size, sizeof(int))) {
return -1;
}
if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)
return -1;
tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));
if (tga->bitmap == NULL)
return -1;
switch (tga->imagetype) {
case TGA_TYPE_RGB:
conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
if (conversion_buffer == NULL) {
return -1;
}
if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree(conversion_buffer);
return -1;
}
while (buffer_caret < image_block_size) {
tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];
buffer_caret++;
}
gdFree(conversion_buffer);
break;
case TGA_TYPE_RGB_RLE:
decompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));
if (decompression_buffer == NULL) {
return -1;
}
conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
if (conversion_buffer == NULL) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree( decompression_buffer );
return -1;
}
rle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);
if (rle_size <= 0) {
gdFree(conversion_buffer);
gdFree(decompression_buffer);
return -1;
}
buffer_caret = 0;
while( buffer_caret < rle_size) {
decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];
buffer_caret++;
}
buffer_caret = 0;
while( bitmap_caret < image_block_size ) {
if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
buffer_caret++;
if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {
gdFree( decompression_buffer );
gdFree( conversion_buffer );
return -1;
}
for (i = 0; i < encoded_pixels; i++) {
memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));
bitmap_caret += pixel_block_size;
}
buffer_caret += pixel_block_size;
} else {
encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
buffer_caret++;
if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {
gdFree( decompression_buffer );
gdFree( conversion_buffer );
return -1;
}
memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));
bitmap_caret += (encoded_pixels * pixel_block_size);
buffer_caret += (encoded_pixels * pixel_block_size);
}
}
gdFree( decompression_buffer );
gdFree( conversion_buffer );
break;
}
return 1;
}","int read_image_tga( gdIOCtx *VAR_0, oTga *VAR_1 )
{
int VAR_2 = (VAR_1->bits / 8);
int VAR_3 = (VAR_1->width * VAR_1->height) * VAR_2;
int* VAR_4 = NULL;
unsigned char* VAR_5 = NULL;
int VAR_6 = 0;
int VAR_7 = 0;
int VAR_8 = 0;
int VAR_9;
int VAR_10;
if(overflow2(VAR_1->width, VAR_1->height)) {
return -1;
}
if(overflow2(VAR_1->width * VAR_1->height, VAR_2)) {
return -1;
}
if(overflow2(VAR_3, sizeof(int))) {
return -1;
}
if (VAR_1->imagetype != VAR_11 && VAR_1->imagetype != VAR_12)
return -1;
VAR_1->bitmap = (int *) gdMalloc(VAR_3 * sizeof(int));
if (VAR_1->bitmap == NULL)
return -1;
switch (VAR_1->imagetype) {
case VAR_11:
VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
if (VAR_5 == NULL) {
return -1;
}
if (gdGetBuf(VAR_5, VAR_3, VAR_0) != VAR_3) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree(VAR_5);
return -1;
}
while (VAR_6 < VAR_3) {
VAR_1->bitmap[VAR_6] = (int) VAR_5[VAR_6];
VAR_6++;
}
gdFree(VAR_5);
break;
case VAR_12:
VAR_4 = (int*) gdMalloc(VAR_3 * sizeof(int));
if (VAR_4 == NULL) {
return -1;
}
VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
if (VAR_5 == NULL) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree( VAR_4 );
return -1;
}
VAR_10 = gdGetBuf(VAR_5, VAR_3, VAR_0);
if (VAR_10 <= 0) {
gdFree(VAR_5);
gdFree(VAR_4);
return -1;
}
VAR_6 = 0;
while( VAR_6 < VAR_10) {
VAR_4[VAR_6] = (int)VAR_5[VAR_6];
VAR_6++;
}
VAR_6 = 0;
while( VAR_7 < VAR_3 ) {
if ((VAR_4[VAR_6] & VAR_13) == VAR_13) {
VAR_9 = ( ( VAR_4[ VAR_6 ] & ~VAR_13 ) + 1 );
VAR_6++;
if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3) {
gdFree( VAR_4 );
gdFree( VAR_5 );
return -1;
}
for (VAR_8 = 0; VAR_8 < VAR_9; VAR_8++) {
memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_2 * sizeof(int));
VAR_7 += VAR_2;
}
VAR_6 += VAR_2;
} else {
VAR_9 = VAR_4[ VAR_6 ] + 1;
VAR_6++;
if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3) {
gdFree( VAR_4 );
gdFree( VAR_5 );
return -1;
}
memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_9 * VAR_2 * sizeof(int));
VAR_7 += (VAR_9 * VAR_2);
VAR_6 += (VAR_9 * VAR_2);
}
}
gdFree( VAR_4 );
gdFree( VAR_5 );
break;
}
return 1;
}",libgd/fb0e0cce0b9f25389ab56604c3547351617e1415/gd_tga.c/vul/before/0.json,"int read_image_tga( gdIOCtx *ctx, oTga *tga )
{
	int pixel_block_size = (tga->bits / 8);
	int image_block_size = (tga->width * tga->height) * pixel_block_size;
	int* decompression_buffer = NULL;
	unsigned char* conversion_buffer = NULL;
	int buffer_caret = 0;
	int bitmap_caret = 0;
	int i = 0;
	int encoded_pixels;
	int rle_size;

	if(overflow2(tga->width, tga->height)) {
		return -1;
	}

	if(overflow2(tga->width * tga->height, pixel_block_size)) {
		return -1;
	}

	if(overflow2(image_block_size, sizeof(int))) {
		return -1;
	}

	/*! \todo Add more image type support.
	 */
	if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)
		return -1;

	/*!	\brief Allocate memmory for image block
	 *  Allocate a chunk of memory for the image block to be passed into.
	 */
	tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));
	if (tga->bitmap == NULL)
		return -1;

	switch (tga->imagetype) {
	case TGA_TYPE_RGB:
		/*! \brief Read in uncompressed RGB TGA
		 *  Chunk load the pixel data from an uncompressed RGB type TGA.
		 */
		conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
		if (conversion_buffer == NULL) {
			return -1;
		}

		if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree(conversion_buffer);
			return -1;
		}

		while (buffer_caret < image_block_size) {
			tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];
			buffer_caret++;
		}

		gdFree(conversion_buffer);
		break;

	case TGA_TYPE_RGB_RLE:
		/*! \brief Read in RLE compressed RGB TGA
		 *  Chunk load the pixel data from an RLE compressed RGB type TGA.
		 */
		decompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));
		if (decompression_buffer == NULL) {
			return -1;
		}
		conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
		if (conversion_buffer == NULL) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree( decompression_buffer );
			return -1;
		}

		rle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);
		if (rle_size <= 0) {
			gdFree(conversion_buffer);
			gdFree(decompression_buffer);
			return -1;
		}

		buffer_caret = 0;

		while( buffer_caret < rle_size) {
			decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];
			buffer_caret++;
		}

		buffer_caret = 0;

		while( bitmap_caret < image_block_size ) {
			
			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
				buffer_caret++;

				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
						|| buffer_caret + pixel_block_size > rle_size) {
					gdFree( decompression_buffer );
					gdFree( conversion_buffer );
					return -1;
				}

				for (i = 0; i < encoded_pixels; i++) {
					memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));
					bitmap_caret += pixel_block_size;
				}
				buffer_caret += pixel_block_size;

			} else {
				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
				buffer_caret++;

				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
						|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {
					gdFree( decompression_buffer );
					gdFree( conversion_buffer );
					return -1;
				}

				memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));
				bitmap_caret += (encoded_pixels * pixel_block_size);
				buffer_caret += (encoded_pixels * pixel_block_size);
			}
		}
		gdFree( decompression_buffer );
		gdFree( conversion_buffer );
		break;
	}

	return 1;
}","int read_image_tga( gdIOCtx *VAR_0, oTga *VAR_1 )
{
	int VAR_2 = (VAR_1->bits / 8);
	int VAR_3 = (VAR_1->width * VAR_1->height) * VAR_2;
	int* VAR_4 = NULL;
	unsigned char* VAR_5 = NULL;
	int VAR_6 = 0;
	int VAR_7 = 0;
	int VAR_8 = 0;
	int VAR_9;
	int VAR_10;

	if(overflow2(VAR_1->width, VAR_1->height)) {
		return -1;
	}

	if(overflow2(VAR_1->width * VAR_1->height, VAR_2)) {
		return -1;
	}

	if(overflow2(VAR_3, sizeof(int))) {
		return -1;
	}

	/* COMMENT_0 */
    
	if (VAR_1->imagetype != VAR_11 && VAR_1->imagetype != VAR_12)
		return -1;

	/* COMMENT_2 */
                                                                      
    
	VAR_1->bitmap = (int *) gdMalloc(VAR_3 * sizeof(int));
	if (VAR_1->bitmap == NULL)
		return -1;

	switch (VAR_1->imagetype) {
	case VAR_11:
		/* COMMENT_5 */
                                                                  
     
		VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
		if (VAR_5 == NULL) {
			return -1;
		}

		if (gdGetBuf(VAR_5, VAR_3, VAR_0) != VAR_3) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree(VAR_5);
			return -1;
		}

		while (VAR_6 < VAR_3) {
			VAR_1->bitmap[VAR_6] = (int) VAR_5[VAR_6];
			VAR_6++;
		}

		gdFree(VAR_5);
		break;

	case VAR_12:
		/* COMMENT_8 */
                                                                    
     
		VAR_4 = (int*) gdMalloc(VAR_3 * sizeof(int));
		if (VAR_4 == NULL) {
			return -1;
		}
		VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
		if (VAR_5 == NULL) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree( VAR_4 );
			return -1;
		}

		VAR_10 = gdGetBuf(VAR_5, VAR_3, VAR_0);
		if (VAR_10 <= 0) {
			gdFree(VAR_5);
			gdFree(VAR_4);
			return -1;
		}

		VAR_6 = 0;

		while( VAR_6 < VAR_10) {
			VAR_4[VAR_6] = (int)VAR_5[VAR_6];
			VAR_6++;
		}

		VAR_6 = 0;

		while( VAR_7 < VAR_3 ) {
			
			if ((VAR_4[VAR_6] & VAR_13) == VAR_13) {
				VAR_9 = ( ( VAR_4[ VAR_6 ] & ~VAR_13 ) + 1 );
				VAR_6++;

				if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3
						|| VAR_6 + VAR_2 > VAR_10) {
					gdFree( VAR_4 );
					gdFree( VAR_5 );
					return -1;
				}

				for (VAR_8 = 0; VAR_8 < VAR_9; VAR_8++) {
					memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_2 * sizeof(int));
					VAR_7 += VAR_2;
				}
				VAR_6 += VAR_2;

			} else {
				VAR_9 = VAR_4[ VAR_6 ] + 1;
				VAR_6++;

				if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3
						|| VAR_6 + (VAR_9 * VAR_2) > VAR_10) {
					gdFree( VAR_4 );
					gdFree( VAR_5 );
					return -1;
				}

				memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_9 * VAR_2 * sizeof(int));
				VAR_7 += (VAR_9 * VAR_2);
				VAR_6 += (VAR_9 * VAR_2);
			}
		}
		gdFree( VAR_4 );
		gdFree( VAR_5 );
		break;
	}

	return 1;
}",libgd/fb0e0cce0b9f25389ab56604c3547351617e1415/gd_tga.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -95,7 +95,8 @@
 				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
 				buffer_caret++;
 
-				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {
+				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
+						|| buffer_caret + pixel_block_size > rle_size) {
 					gdFree( decompression_buffer );
 					gdFree( conversion_buffer );
 					return -1;
@@ -111,7 +112,8 @@
 				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
 				buffer_caret++;
 
-				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {
+				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
+						|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {
 					gdFree( decompression_buffer );
 					gdFree( conversion_buffer );
 					return -1;","{'deleted_lines': ['\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {', '\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {'], 'added_lines': ['\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size', '\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {', '\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size', '\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {']}",True,"The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file, related to the decompression buffer.",5.5,MEDIUM,1,valid,2016-08-16T14:26:19Z,1
CVE-2016-6906,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libgd,"Fix OOB reads of the TGA decompression buffer

It is possible to craft TGA files which will overflow the decompression
buffer, but not the image's bitmap. Therefore we also have to check for
potential decompression buffer overflows.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org;
a modified case exposing an off-by-one error of the first patch had been
provided by Konrad Beckmann.

This commit is an amendment to commit fb0e0cce, so we use CVE-2016-6906
as well.",58b6dde319c301b0eae27d12e2a659e067d80558,https://github.com/libgd/libgd/commit/58b6dde319c301b0eae27d12e2a659e067d80558,src/gd_tga.c,read_image_tga,"int read_image_tga( gdIOCtx *ctx, oTga *tga )
{
int pixel_block_size = (tga->bits / 8);
int image_block_size = (tga->width * tga->height) * pixel_block_size;
int* decompression_buffer = NULL;
unsigned char* conversion_buffer = NULL;
int buffer_caret = 0;
int bitmap_caret = 0;
int i = 0;
int encoded_pixels;
int rle_size;
if(overflow2(tga->width, tga->height)) {
return -1;
}
if(overflow2(tga->width * tga->height, pixel_block_size)) {
return -1;
}
if(overflow2(image_block_size, sizeof(int))) {
return -1;
}
if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)
return -1;
tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));
if (tga->bitmap == NULL)
return -1;
switch (tga->imagetype) {
case TGA_TYPE_RGB:
conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
if (conversion_buffer == NULL) {
return -1;
}
if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree(conversion_buffer);
return -1;
}
while (buffer_caret < image_block_size) {
tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];
buffer_caret++;
}
gdFree(conversion_buffer);
break;
case TGA_TYPE_RGB_RLE:
decompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));
if (decompression_buffer == NULL) {
return -1;
}
conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
if (conversion_buffer == NULL) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree( decompression_buffer );
return -1;
}
rle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);
if (rle_size <= 0) {
gdFree(conversion_buffer);
gdFree(decompression_buffer);
return -1;
}
buffer_caret = 0;
while( buffer_caret < rle_size) {
decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];
buffer_caret++;
}
buffer_caret = 0;
while( bitmap_caret < image_block_size ) {
if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
buffer_caret++;
if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
|| buffer_caret + pixel_block_size > rle_size) {
gdFree( decompression_buffer );
gdFree( conversion_buffer );
return -1;
}
for (i = 0; i < encoded_pixels; i++) {
memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));
bitmap_caret += pixel_block_size;
}
buffer_caret += pixel_block_size;
} else {
encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
buffer_caret++;
if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {
gdFree( decompression_buffer );
gdFree( conversion_buffer );
return -1;
}
memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));
bitmap_caret += (encoded_pixels * pixel_block_size);
buffer_caret += (encoded_pixels * pixel_block_size);
}
}
gdFree( decompression_buffer );
gdFree( conversion_buffer );
break;
}
return 1;
}","int read_image_tga( gdIOCtx *VAR_0, oTga *VAR_1 )
{
int VAR_2 = (VAR_1->bits / 8);
int VAR_3 = (VAR_1->width * VAR_1->height) * VAR_2;
int* VAR_4 = NULL;
unsigned char* VAR_5 = NULL;
int VAR_6 = 0;
int VAR_7 = 0;
int VAR_8 = 0;
int VAR_9;
int VAR_10;
if(overflow2(VAR_1->width, VAR_1->height)) {
return -1;
}
if(overflow2(VAR_1->width * VAR_1->height, VAR_2)) {
return -1;
}
if(overflow2(VAR_3, sizeof(int))) {
return -1;
}
if (VAR_1->imagetype != VAR_11 && VAR_1->imagetype != VAR_12)
return -1;
VAR_1->bitmap = (int *) gdMalloc(VAR_3 * sizeof(int));
if (VAR_1->bitmap == NULL)
return -1;
switch (VAR_1->imagetype) {
case VAR_11:
VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
if (VAR_5 == NULL) {
return -1;
}
if (gdGetBuf(VAR_5, VAR_3, VAR_0) != VAR_3) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree(VAR_5);
return -1;
}
while (VAR_6 < VAR_3) {
VAR_1->bitmap[VAR_6] = (int) VAR_5[VAR_6];
VAR_6++;
}
gdFree(VAR_5);
break;
case VAR_12:
VAR_4 = (int*) gdMalloc(VAR_3 * sizeof(int));
if (VAR_4 == NULL) {
return -1;
}
VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
if (VAR_5 == NULL) {
gd_error(""gd-tga: premature end of image data\n"");
gdFree( VAR_4 );
return -1;
}
VAR_10 = gdGetBuf(VAR_5, VAR_3, VAR_0);
if (VAR_10 <= 0) {
gdFree(VAR_5);
gdFree(VAR_4);
return -1;
}
VAR_6 = 0;
while( VAR_6 < VAR_10) {
VAR_4[VAR_6] = (int)VAR_5[VAR_6];
VAR_6++;
}
VAR_6 = 0;
while( VAR_7 < VAR_3 ) {
if ((VAR_4[VAR_6] & VAR_13) == VAR_13) {
VAR_9 = ( ( VAR_4[ VAR_6 ] & ~VAR_13 ) + 1 );
VAR_6++;
if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3
|| VAR_6 + VAR_2 > VAR_10) {
gdFree( VAR_4 );
gdFree( VAR_5 );
return -1;
}
for (VAR_8 = 0; VAR_8 < VAR_9; VAR_8++) {
memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_2 * sizeof(int));
VAR_7 += VAR_2;
}
VAR_6 += VAR_2;
} else {
VAR_9 = VAR_4[ VAR_6 ] + 1;
VAR_6++;
if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3
|| VAR_6 + (VAR_9 * VAR_2) > VAR_10) {
gdFree( VAR_4 );
gdFree( VAR_5 );
return -1;
}
memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_9 * VAR_2 * sizeof(int));
VAR_7 += (VAR_9 * VAR_2);
VAR_6 += (VAR_9 * VAR_2);
}
}
gdFree( VAR_4 );
gdFree( VAR_5 );
break;
}
return 1;
}",libgd/58b6dde319c301b0eae27d12e2a659e067d80558/gd_tga.c/vul/before/0.json,"int read_image_tga( gdIOCtx *ctx, oTga *tga )
{
	int pixel_block_size = (tga->bits / 8);
	int image_block_size = (tga->width * tga->height) * pixel_block_size;
	int* decompression_buffer = NULL;
	unsigned char* conversion_buffer = NULL;
	int buffer_caret = 0;
	int bitmap_caret = 0;
	int i = 0;
	int encoded_pixels;
	int rle_size;

	if(overflow2(tga->width, tga->height)) {
		return -1;
	}

	if(overflow2(tga->width * tga->height, pixel_block_size)) {
		return -1;
	}

	if(overflow2(image_block_size, sizeof(int))) {
		return -1;
	}

	/*! \todo Add more image type support.
	 */
	if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)
		return -1;

	/*!	\brief Allocate memmory for image block
	 *  Allocate a chunk of memory for the image block to be passed into.
	 */
	tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));
	if (tga->bitmap == NULL)
		return -1;

	switch (tga->imagetype) {
	case TGA_TYPE_RGB:
		/*! \brief Read in uncompressed RGB TGA
		 *  Chunk load the pixel data from an uncompressed RGB type TGA.
		 */
		conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
		if (conversion_buffer == NULL) {
			return -1;
		}

		if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree(conversion_buffer);
			return -1;
		}

		while (buffer_caret < image_block_size) {
			tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];
			buffer_caret++;
		}

		gdFree(conversion_buffer);
		break;

	case TGA_TYPE_RGB_RLE:
		/*! \brief Read in RLE compressed RGB TGA
		 *  Chunk load the pixel data from an RLE compressed RGB type TGA.
		 */
		decompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));
		if (decompression_buffer == NULL) {
			return -1;
		}
		conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
		if (conversion_buffer == NULL) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree( decompression_buffer );
			return -1;
		}

		rle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);
		if (rle_size <= 0) {
			gdFree(conversion_buffer);
			gdFree(decompression_buffer);
			return -1;
		}

		buffer_caret = 0;

		while( buffer_caret < rle_size) {
			decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];
			buffer_caret++;
		}

		buffer_caret = 0;

		while( bitmap_caret < image_block_size ) {

			if (buffer_caret + pixel_block_size > rle_size) {
				gdFree( decompression_buffer );
				gdFree( conversion_buffer );
				return -1;
			}

			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
				buffer_caret++;

				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
						|| buffer_caret + pixel_block_size > rle_size) {
					gdFree( decompression_buffer );
					gdFree( conversion_buffer );
					return -1;
				}

				for (i = 0; i < encoded_pixels; i++) {
					memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));
					bitmap_caret += pixel_block_size;
				}
				buffer_caret += pixel_block_size;

			} else {
				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
				buffer_caret++;

				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
						|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {
					gdFree( decompression_buffer );
					gdFree( conversion_buffer );
					return -1;
				}

				memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));
				bitmap_caret += (encoded_pixels * pixel_block_size);
				buffer_caret += (encoded_pixels * pixel_block_size);
			}
		}
		gdFree( decompression_buffer );
		gdFree( conversion_buffer );
		break;
	}

	return 1;
}","int read_image_tga( gdIOCtx *VAR_0, oTga *VAR_1 )
{
	int VAR_2 = (VAR_1->bits / 8);
	int VAR_3 = (VAR_1->width * VAR_1->height) * VAR_2;
	int* VAR_4 = NULL;
	unsigned char* VAR_5 = NULL;
	int VAR_6 = 0;
	int VAR_7 = 0;
	int VAR_8 = 0;
	int VAR_9;
	int VAR_10;

	if(overflow2(VAR_1->width, VAR_1->height)) {
		return -1;
	}

	if(overflow2(VAR_1->width * VAR_1->height, VAR_2)) {
		return -1;
	}

	if(overflow2(VAR_3, sizeof(int))) {
		return -1;
	}

	/* COMMENT_0 */
    
	if (VAR_1->imagetype != VAR_11 && VAR_1->imagetype != VAR_12)
		return -1;

	/* COMMENT_2 */
                                                                      
    
	VAR_1->bitmap = (int *) gdMalloc(VAR_3 * sizeof(int));
	if (VAR_1->bitmap == NULL)
		return -1;

	switch (VAR_1->imagetype) {
	case VAR_11:
		/* COMMENT_5 */
                                                                  
     
		VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
		if (VAR_5 == NULL) {
			return -1;
		}

		if (gdGetBuf(VAR_5, VAR_3, VAR_0) != VAR_3) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree(VAR_5);
			return -1;
		}

		while (VAR_6 < VAR_3) {
			VAR_1->bitmap[VAR_6] = (int) VAR_5[VAR_6];
			VAR_6++;
		}

		gdFree(VAR_5);
		break;

	case VAR_12:
		/* COMMENT_8 */
                                                                    
     
		VAR_4 = (int*) gdMalloc(VAR_3 * sizeof(int));
		if (VAR_4 == NULL) {
			return -1;
		}
		VAR_5 = (unsigned char *) gdMalloc(VAR_3 * sizeof(unsigned char));
		if (VAR_5 == NULL) {
			gd_error(""gd-tga: premature end of image data\n"");
			gdFree( VAR_4 );
			return -1;
		}

		VAR_10 = gdGetBuf(VAR_5, VAR_3, VAR_0);
		if (VAR_10 <= 0) {
			gdFree(VAR_5);
			gdFree(VAR_4);
			return -1;
		}

		VAR_6 = 0;

		while( VAR_6 < VAR_10) {
			VAR_4[VAR_6] = (int)VAR_5[VAR_6];
			VAR_6++;
		}

		VAR_6 = 0;

		while( VAR_7 < VAR_3 ) {

			if (VAR_6 + VAR_2 > VAR_10) {
				gdFree( VAR_4 );
				gdFree( VAR_5 );
				return -1;
			}

			if ((VAR_4[VAR_6] & VAR_13) == VAR_13) {
				VAR_9 = ( ( VAR_4[ VAR_6 ] & ~VAR_13 ) + 1 );
				VAR_6++;

				if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3
						|| VAR_6 + VAR_2 > VAR_10) {
					gdFree( VAR_4 );
					gdFree( VAR_5 );
					return -1;
				}

				for (VAR_8 = 0; VAR_8 < VAR_9; VAR_8++) {
					memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_2 * sizeof(int));
					VAR_7 += VAR_2;
				}
				VAR_6 += VAR_2;

			} else {
				VAR_9 = VAR_4[ VAR_6 ] + 1;
				VAR_6++;

				if ((VAR_7 + (VAR_9 * VAR_2)) > VAR_3
						|| VAR_6 + (VAR_9 * VAR_2) > VAR_10) {
					gdFree( VAR_4 );
					gdFree( VAR_5 );
					return -1;
				}

				memcpy(VAR_1->bitmap + VAR_7, VAR_4 + VAR_6, VAR_9 * VAR_2 * sizeof(int));
				VAR_7 += (VAR_9 * VAR_2);
				VAR_6 += (VAR_9 * VAR_2);
			}
		}
		gdFree( VAR_4 );
		gdFree( VAR_5 );
		break;
	}

	return 1;
}",libgd/58b6dde319c301b0eae27d12e2a659e067d80558/gd_tga.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -90,7 +90,13 @@
 		buffer_caret = 0;
 
 		while( bitmap_caret < image_block_size ) {
-			
+
+			if (buffer_caret + pixel_block_size > rle_size) {
+				gdFree( decompression_buffer );
+				gdFree( conversion_buffer );
+				return -1;
+			}
+
 			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
 				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
 				buffer_caret++;","{'deleted_lines': ['\t\t\t'], 'added_lines': ['', '\t\t\tif (buffer_caret + pixel_block_size > rle_size) {', '\t\t\t\tgdFree( decompression_buffer );', '\t\t\t\tgdFree( conversion_buffer );', '\t\t\t\treturn -1;', '\t\t\t}', '']}",True,"The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file, related to the decompression buffer.",5.5,MEDIUM,1,valid,2016-08-16T14:26:19Z,1
CVE-2016-9433,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,tats/w3m,"Prevent segfault when iso2022 parsing

Bug-Debian: https://github.com/tats/w3m/issues/14",9cf6926c5d947371dc9e44f32bc7a2fbfca5d469,https://github.com/tats/w3m/commit/9cf6926c5d947371dc9e44f32bc7a2fbfca5d469,libwc/iso2022.c,wc_push_to_iso2022,"void
wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status *st)
{
wc_uchar g = 0;
wc_bool is_wide = WC_FALSE, retry = WC_FALSE;
wc_wchar_t cc2;
while (1) {
switch (WC_CCS_TYPE(cc.ccs)) {
case WC_CCS_A_CS94:
if (cc.ccs == WC_CCS_US_ASCII)
cc.ccs = st->g0_ccs;
g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
break;
case WC_CCS_A_CS94W:
is_wide = 1;
switch (cc.ccs) {
#ifdef USE_UNICODE
case WC_CCS_JIS_X_0212:
if (!WcOption.use_jisx0212 && WcOption.use_jisx0213 &&
WcOption.ucs_conv) {
cc2 = wc_jisx0212_to_jisx0213(cc);
if (cc2.ccs == WC_CCS_JIS_X_0213_1 ||
cc2.ccs == WC_CCS_JIS_X_0213_2) {
cc = cc2;
continue;
}
}
break;
case WC_CCS_JIS_X_0213_1:
case WC_CCS_JIS_X_0213_2:
if (!WcOption.use_jisx0213 && WcOption.use_jisx0212 &&
WcOption.ucs_conv) {
cc2 = wc_jisx0213_to_jisx0212(cc);
if (cc2.ccs == WC_CCS_JIS_X_0212) {
cc = cc2;
continue;
}
}
break;
#endif
}
g = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
break;
case WC_CCS_A_CS96:
g = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
break;
case WC_CCS_A_CS96W:
is_wide = 1;
g = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
break;
case WC_CCS_A_CS942:
g = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
break;
case WC_CCS_A_UNKNOWN_W:
if (WcOption.no_replace)
return;
is_wide = 1;
cc.ccs = WC_CCS_US_ASCII;
g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
cc.code = ((wc_uint32)WC_REPLACE_W[0] << 8) | WC_REPLACE_W[1];
break;
case WC_CCS_A_UNKNOWN:
if (WcOption.no_replace)
return;
cc.ccs = WC_CCS_US_ASCII;
g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
cc.code = (wc_uint32)WC_REPLACE[0];
break;
default:
if ((cc.ccs == WC_CCS_JOHAB || cc.ccs == WC_CCS_JOHAB_1 ||
cc.ccs == WC_CCS_JOHAB_2 || cc.ccs == WC_CCS_JOHAB_3) &&
cs94w_gmap[WC_F_KS_X_1001 - WC_F_ISO_BASE]) {
wc_wchar_t cc2 = wc_johab_to_ksx1001(cc);
if (cc2.ccs == WC_CCS_KS_X_1001) {
cc = cc2;
continue;
}
}
#ifdef USE_UNICODE
if (WcOption.ucs_conv)
cc = wc_any_to_iso2022(cc, st);
else
#endif
cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN;
continue;
}
if (! g) {
#ifdef USE_UNICODE
if (WcOption.ucs_conv && ! retry)
cc = wc_any_to_any_ces(cc, st);
else
#endif
cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN;
retry = WC_TRUE;
continue;
}
wc_push_iso2022_esc(os, cc.ccs, g, 1, st);
if (is_wide)
Strcat_char(os, (char)((cc.code >> 8) & 0x7f));
Strcat_char(os, (char)(cc.code & 0x7f));
return;
}
}","void
wc_push_to_iso2022(Str VAR_0, wc_wchar_t VAR_1, wc_status *VAR_2)
{
wc_uchar VAR_3 = 0;
wc_bool VAR_4 = VAR_5, VAR_6 = VAR_5;
wc_wchar_t VAR_7;
while (1) {
switch (WC_CCS_TYPE(VAR_1.ccs)) {
case VAR_8:
if (VAR_1.ccs == VAR_9)
VAR_1.ccs = VAR_2->g0_ccs;
VAR_3 = VAR_10[WC_CCS_INDEX(VAR_1.ccs) - VAR_11];
break;
case VAR_12:
VAR_4 = 1;
switch (VAR_1.ccs) {
#ifdef VAR_13
case VAR_14:
if (!VAR_15.use_jisx0212 && VAR_15.use_jisx0213 &&
VAR_15.ucs_conv) {
VAR_7 = wc_jisx0212_to_jisx0213(VAR_1);
if (VAR_7.ccs == VAR_16 ||
VAR_7.ccs == VAR_17) {
VAR_1 = VAR_7;
continue;
}
}
break;
case VAR_16:
case VAR_17:
if (!VAR_15.use_jisx0213 && VAR_15.use_jisx0212 &&
VAR_15.ucs_conv) {
VAR_7 = wc_jisx0213_to_jisx0212(VAR_1);
if (VAR_7.ccs == VAR_14) {
VAR_1 = VAR_7;
continue;
}
}
break;
#endif
}
VAR_3 = VAR_18[WC_CCS_INDEX(VAR_1.ccs) - VAR_11];
break;
case VAR_19:
VAR_3 = VAR_20[WC_CCS_INDEX(VAR_1.ccs) - VAR_11];
break;
case VAR_21:
VAR_4 = 1;
VAR_3 = VAR_22[WC_CCS_INDEX(VAR_1.ccs) - VAR_11];
break;
case VAR_23:
VAR_3 = VAR_24[WC_CCS_INDEX(VAR_1.ccs) - VAR_11];
break;
case VAR_25:
if (VAR_15.no_replace)
return;
VAR_4 = 1;
VAR_1.ccs = VAR_9;
VAR_3 = VAR_10[WC_CCS_INDEX(VAR_1.ccs) - VAR_11];
VAR_1.code = ((wc_uint32)VAR_26[0] << 8) | VAR_26[1];
break;
case VAR_27:
if (VAR_15.no_replace)
return;
VAR_1.ccs = VAR_9;
VAR_3 = VAR_10[WC_CCS_INDEX(VAR_1.ccs) - VAR_11];
VAR_1.code = (wc_uint32)VAR_28[0];
break;
default:
if ((VAR_1.ccs == VAR_29 || VAR_1.ccs == VAR_30 ||
VAR_1.ccs == VAR_31 || VAR_1.ccs == VAR_32) &&
VAR_18[VAR_33 - VAR_11]) {
wc_wchar_t VAR_7 = wc_johab_to_ksx1001(VAR_1);
if (VAR_7.ccs == VAR_34) {
VAR_1 = VAR_7;
continue;
}
}
#ifdef VAR_13
if (VAR_15.ucs_conv)
VAR_1 = wc_any_to_iso2022(VAR_1, VAR_2);
else
#endif
VAR_1.ccs = WC_CCS_IS_WIDE(VAR_1.ccs) ? VAR_35 : VAR_36;
continue;
}
if (! VAR_3) {
#ifdef VAR_13
if (VAR_15.ucs_conv && ! VAR_6)
VAR_1 = wc_any_to_any_ces(VAR_1, VAR_2);
else
#endif
VAR_1.ccs = WC_CCS_IS_WIDE(VAR_1.ccs) ? VAR_35 : VAR_36;
VAR_6 = VAR_37;
continue;
}
wc_push_iso2022_esc(VAR_0, VAR_1.ccs, VAR_3, 1, VAR_2);
if (VAR_4)
Strcat_char(VAR_0, (char)((VAR_1.code >> 8) & 0x7f));
Strcat_char(VAR_0, (char)(VAR_1.code & 0x7f));
return;
}
}",tats/w3m/9cf6926c5d947371dc9e44f32bc7a2fbfca5d469/iso2022.c/vul/before/0.json,"void
wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status *st)
{
    wc_uchar g = 0;
    wc_bool is_wide = WC_FALSE, retry = WC_FALSE;
    wc_wchar_t cc2;

  while (1) {
    switch (WC_CCS_TYPE(cc.ccs)) {
    case WC_CCS_A_CS94:
	if (cc.ccs == WC_CCS_US_ASCII)
	    cc.ccs = st->g0_ccs;
	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
	    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
	break;
    case WC_CCS_A_CS94W:
	is_wide = 1;
	switch (cc.ccs) {
#ifdef USE_UNICODE
	case WC_CCS_JIS_X_0212:
	    if (!WcOption.use_jisx0212 && WcOption.use_jisx0213 &&
		WcOption.ucs_conv) {
		cc2 = wc_jisx0212_to_jisx0213(cc);
		if (cc2.ccs == WC_CCS_JIS_X_0213_1 ||
		    cc2.ccs == WC_CCS_JIS_X_0213_2) {
		    cc = cc2;
		    continue;
		}
	    }
	    break;
	case WC_CCS_JIS_X_0213_1:
	case WC_CCS_JIS_X_0213_2:
	    if (!WcOption.use_jisx0213 && WcOption.use_jisx0212 &&
		WcOption.ucs_conv) {
		cc2 = wc_jisx0213_to_jisx0212(cc);
		if (cc2.ccs == WC_CCS_JIS_X_0212) {
		    cc = cc2;
		    continue;
		}
	    }
	    break;
#endif
	}
	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
	    g = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
	break;
    case WC_CCS_A_CS96:
	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
	    g = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
	break;
    case WC_CCS_A_CS96W:
	is_wide = 1;
	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
	    g = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
	break;
    case WC_CCS_A_CS942:
	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
	    g = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
	break;
    case WC_CCS_A_UNKNOWN_W:
	if (WcOption.no_replace)
	    return;
	is_wide = 1;
	cc.ccs = WC_CCS_US_ASCII;
	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
	    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
	cc.code = ((wc_uint32)WC_REPLACE_W[0] << 8) | WC_REPLACE_W[1];
	break;
    case WC_CCS_A_UNKNOWN:
	if (WcOption.no_replace)
	    return;
	cc.ccs = WC_CCS_US_ASCII;
	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
	    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
	cc.code = (wc_uint32)WC_REPLACE[0];
	break;
    default:
	if ((cc.ccs == WC_CCS_JOHAB || cc.ccs == WC_CCS_JOHAB_1 ||
		cc.ccs == WC_CCS_JOHAB_2 || cc.ccs == WC_CCS_JOHAB_3) &&
		cs94w_gmap[WC_F_KS_X_1001 - WC_F_ISO_BASE]) {
	    wc_wchar_t cc2 = wc_johab_to_ksx1001(cc);
	    if (cc2.ccs == WC_CCS_KS_X_1001) {
		cc = cc2;
		continue;
	    }
	}
#ifdef USE_UNICODE
	if (WcOption.ucs_conv)
	    cc = wc_any_to_iso2022(cc, st);
	else
#endif
	    cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN;
	continue;
    }
    if (! g) {
#ifdef USE_UNICODE
	if (WcOption.ucs_conv && ! retry)
	    cc = wc_any_to_any_ces(cc, st);
	else
#endif
	    cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN;
	retry = WC_TRUE;
	continue;
    }

    wc_push_iso2022_esc(os, cc.ccs, g, 1, st);
    if (is_wide)
	Strcat_char(os, (char)((cc.code >> 8) & 0x7f));
    Strcat_char(os, (char)(cc.code & 0x7f));
    return;
  }
}","void
wc_push_to_iso2022(Str VAR_0, wc_wchar_t VAR_1, wc_status *VAR_2)
{
    wc_uchar VAR_3 = 0;
    wc_bool VAR_4 = VAR_5, VAR_6 = VAR_5;
    wc_wchar_t VAR_7;

  while (1) {
    switch (WC_CCS_TYPE(VAR_1.ccs)) {
    case VAR_8:
	if (VAR_1.ccs == VAR_9)
	    VAR_1.ccs = VAR_2->g0_ccs;
	if (WC_CCS_INDEX(VAR_1.ccs) >= VAR_10)
	    VAR_3 = VAR_11[WC_CCS_INDEX(VAR_1.ccs) - VAR_10];
	break;
    case VAR_12:
	VAR_4 = 1;
	switch (VAR_1.ccs) {
#ifdef VAR_13
	case VAR_14:
	    if (!VAR_15.use_jisx0212 && VAR_15.use_jisx0213 &&
		VAR_15.ucs_conv) {
		VAR_7 = wc_jisx0212_to_jisx0213(VAR_1);
		if (VAR_7.ccs == VAR_16 ||
		    VAR_7.ccs == VAR_17) {
		    VAR_1 = VAR_7;
		    continue;
		}
	    }
	    break;
	case VAR_16:
	case VAR_17:
	    if (!VAR_15.use_jisx0213 && VAR_15.use_jisx0212 &&
		VAR_15.ucs_conv) {
		VAR_7 = wc_jisx0213_to_jisx0212(VAR_1);
		if (VAR_7.ccs == VAR_14) {
		    VAR_1 = VAR_7;
		    continue;
		}
	    }
	    break;
#endif
	}
	if (WC_CCS_INDEX(VAR_1.ccs) >= VAR_10)
	    VAR_3 = VAR_18[WC_CCS_INDEX(VAR_1.ccs) - VAR_10];
	break;
    case VAR_19:
	if (WC_CCS_INDEX(VAR_1.ccs) >= VAR_10)
	    VAR_3 = VAR_20[WC_CCS_INDEX(VAR_1.ccs) - VAR_10];
	break;
    case VAR_21:
	VAR_4 = 1;
	if (WC_CCS_INDEX(VAR_1.ccs) >= VAR_10)
	    VAR_3 = VAR_22[WC_CCS_INDEX(VAR_1.ccs) - VAR_10];
	break;
    case VAR_23:
	if (WC_CCS_INDEX(VAR_1.ccs) >= VAR_10)
	    VAR_3 = VAR_24[WC_CCS_INDEX(VAR_1.ccs) - VAR_10];
	break;
    case VAR_25:
	if (VAR_15.no_replace)
	    return;
	VAR_4 = 1;
	VAR_1.ccs = VAR_9;
	if (WC_CCS_INDEX(VAR_1.ccs) >= VAR_10)
	    VAR_3 = VAR_11[WC_CCS_INDEX(VAR_1.ccs) - VAR_10];
	VAR_1.code = ((wc_uint32)VAR_26[0] << 8) | VAR_26[1];
	break;
    case VAR_27:
	if (VAR_15.no_replace)
	    return;
	VAR_1.ccs = VAR_9;
	if (WC_CCS_INDEX(VAR_1.ccs) >= VAR_10)
	    VAR_3 = VAR_11[WC_CCS_INDEX(VAR_1.ccs) - VAR_10];
	VAR_1.code = (wc_uint32)VAR_28[0];
	break;
    default:
	if ((VAR_1.ccs == VAR_29 || VAR_1.ccs == VAR_30 ||
		VAR_1.ccs == VAR_31 || VAR_1.ccs == VAR_32) &&
		VAR_18[VAR_33 - VAR_10]) {
	    wc_wchar_t VAR_7 = wc_johab_to_ksx1001(VAR_1);
	    if (VAR_7.ccs == VAR_34) {
		VAR_1 = VAR_7;
		continue;
	    }
	}
#ifdef VAR_13
	if (VAR_15.ucs_conv)
	    VAR_1 = wc_any_to_iso2022(VAR_1, VAR_2);
	else
#endif
	    VAR_1.ccs = WC_CCS_IS_WIDE(VAR_1.ccs) ? VAR_35 : VAR_36;
	continue;
    }
    if (! VAR_3) {
#ifdef VAR_13
	if (VAR_15.ucs_conv && ! VAR_6)
	    VAR_1 = wc_any_to_any_ces(VAR_1, VAR_2);
	else
#endif
	    VAR_1.ccs = WC_CCS_IS_WIDE(VAR_1.ccs) ? VAR_35 : VAR_36;
	VAR_6 = VAR_37;
	continue;
    }

    wc_push_iso2022_esc(VAR_0, VAR_1.ccs, VAR_3, 1, VAR_2);
    if (VAR_4)
	Strcat_char(VAR_0, (char)((VAR_1.code >> 8) & 0x7f));
    Strcat_char(VAR_0, (char)(VAR_1.code & 0x7f));
    return;
  }
}",tats/w3m/9cf6926c5d947371dc9e44f32bc7a2fbfca5d469/iso2022.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,8 @@
     case WC_CCS_A_CS94:
 	if (cc.ccs == WC_CCS_US_ASCII)
 	    cc.ccs = st->g0_ccs;
-	g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
+	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
+	    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
 	break;
     case WC_CCS_A_CS94W:
 	is_wide = 1;
@@ -40,31 +41,37 @@
 	    break;
 #endif
 	}
-	g = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
+	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
+	    g = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
 	break;
     case WC_CCS_A_CS96:
-	g = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
+	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
+	    g = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
 	break;
     case WC_CCS_A_CS96W:
 	is_wide = 1;
-	g = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
+	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
+	    g = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
 	break;
     case WC_CCS_A_CS942:
-	g = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
+	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
+	    g = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
 	break;
     case WC_CCS_A_UNKNOWN_W:
 	if (WcOption.no_replace)
 	    return;
 	is_wide = 1;
 	cc.ccs = WC_CCS_US_ASCII;
-	g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
+	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
+	    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
 	cc.code = ((wc_uint32)WC_REPLACE_W[0] << 8) | WC_REPLACE_W[1];
 	break;
     case WC_CCS_A_UNKNOWN:
 	if (WcOption.no_replace)
 	    return;
 	cc.ccs = WC_CCS_US_ASCII;
-	g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
+	if (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)
+	    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];
 	cc.code = (wc_uint32)WC_REPLACE[0];
 	break;
     default:","{'deleted_lines': ['\tg = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tg = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tg = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tg = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tg = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tg = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tg = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];'], 'added_lines': ['\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)', '\t    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)', '\t    g = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)', '\t    g = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)', '\t    g = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)', '\t    g = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)', '\t    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];', '\tif (WC_CCS_INDEX(cc.ccs) >= WC_F_ISO_BASE)', '\t    g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE];']}",True,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (out-of-bounds array access) via a crafted HTML page.,6.5,MEDIUM,1,valid,2016-08-17T12:30:50Z,1
CVE-2016-9434,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,tats/w3m,"Prevent segfault with incorrect form_int fid

Bug-Debian: https://github.com/tats/w3m/issues/15",3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b,https://github.com/tats/w3m/commit/3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b,file.c,process_form_int,"static Str
process_form_int(struct parsed_tag *tag, int fid)
{
char *p, *q, *r, *s, *tg, *n;
p = ""get"";
parsedtag_get_value(tag, ATTR_METHOD, &p);
q = ""!CURRENT_URL!"";
parsedtag_get_value(tag, ATTR_ACTION, &q);
q = url_encode(remove_space(q), cur_baseURL, cur_document_charset);
r = NULL;
#ifdef USE_M17N
if (parsedtag_get_value(tag, ATTR_ACCEPT_CHARSET, &r))
r = check_accept_charset(r);
if (!r && parsedtag_get_value(tag, ATTR_CHARSET, &r))
r = check_charset(r);
#endif
s = NULL;
parsedtag_get_value(tag, ATTR_ENCTYPE, &s);
tg = NULL;
parsedtag_get_value(tag, ATTR_TARGET, &tg);
n = NULL;
parsedtag_get_value(tag, ATTR_NAME, &n);
if (fid < 0) {
form_max++;
form_sp++;
fid = form_max;
}
else {
if (form_max < fid)
form_max = fid;
form_sp = fid;
}
if (forms_size == 0) {
forms_size = INITIAL_FORM_SIZE;
forms = New_N(FormList *, forms_size);
form_stack = NewAtom_N(int, forms_size);
}
else if (forms_size <= form_max) {
forms_size += form_max;
forms = New_Reuse(FormList *, forms, forms_size);
form_stack = New_Reuse(int, form_stack, forms_size);
}
form_stack[form_sp] = fid;
if (w3m_halfdump) {
Str tmp = Sprintf(""<form_int fid=\""%d\"" action=\""%s\"" method=\""%s\"""",
fid, html_quote(q), html_quote(p));
if (s)
Strcat(tmp, Sprintf("" enctype=\""%s\"""", html_quote(s)));
if (tg)
Strcat(tmp, Sprintf("" target=\""%s\"""", html_quote(tg)));
if (n)
Strcat(tmp, Sprintf("" name=\""%s\"""", html_quote(n)));
#ifdef USE_M17N
if (r)
Strcat(tmp, Sprintf("" accept-charset=\""%s\"""", html_quote(r)));
#endif
Strcat_charp(tmp, "">"");
return tmp;
}
forms[fid] = newFormList(q, p, r, s, tg, n, NULL);
return NULL;
}","static Str
process_form_int(struct parsed_tag *VAR_0, int VAR_1)
{
char *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7;
VAR_2 = ""get"";
parsedtag_get_value(VAR_0, VAR_8, &VAR_2);
VAR_3 = ""!CURRENT_URL!"";
parsedtag_get_value(VAR_0, VAR_9, &VAR_3);
VAR_3 = url_encode(remove_space(VAR_3), VAR_10, VAR_11);
VAR_4 = NULL;
#ifdef VAR_12
if (parsedtag_get_value(VAR_0, VAR_13, &VAR_4))
VAR_4 = check_accept_charset(VAR_4);
if (!VAR_4 && parsedtag_get_value(VAR_0, VAR_14, &VAR_4))
VAR_4 = check_charset(VAR_4);
#endif
VAR_5 = NULL;
parsedtag_get_value(VAR_0, VAR_15, &VAR_5);
VAR_6 = NULL;
parsedtag_get_value(VAR_0, VAR_16, &VAR_6);
VAR_7 = NULL;
parsedtag_get_value(VAR_0, VAR_17, &VAR_7);
if (VAR_1 < 0) {
VAR_18++;
VAR_19++;
VAR_1 = VAR_18;
}
else {
if (VAR_18 < VAR_1)
VAR_18 = VAR_1;
VAR_19 = VAR_1;
}
if (VAR_20 == 0) {
VAR_20 = VAR_21;
VAR_22 = New_N(VAR_23 *, VAR_20);
VAR_24 = NewAtom_N(int, VAR_20);
}
else if (VAR_20 <= VAR_18) {
VAR_20 += VAR_18;
VAR_22 = New_Reuse(VAR_23 *, VAR_22, VAR_20);
VAR_24 = New_Reuse(int, VAR_24, VAR_20);
}
VAR_24[VAR_19] = VAR_1;
if (VAR_25) {
Str VAR_26 = Sprintf(""<form_int fid=\""%d\"" action=\""%s\"" method=\""%s\"""",
VAR_1, html_quote(VAR_3), html_quote(VAR_2));
if (VAR_5)
Strcat(VAR_26, Sprintf("" enctype=\""%s\"""", html_quote(VAR_5)));
if (VAR_6)
Strcat(VAR_26, Sprintf("" target=\""%s\"""", html_quote(VAR_6)));
if (VAR_7)
Strcat(VAR_26, Sprintf("" name=\""%s\"""", html_quote(VAR_7)));
#ifdef VAR_12
if (VAR_4)
Strcat(VAR_26, Sprintf("" accept-charset=\""%s\"""", html_quote(VAR_4)));
#endif
Strcat_charp(VAR_26, "">"");
return VAR_26;
}
VAR_22[VAR_1] = newFormList(VAR_3, VAR_2, VAR_4, VAR_5, VAR_6, VAR_7, NULL);
return NULL;
}",tats/w3m/3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b/file.c/vul/before/0.json,"static Str
process_form_int(struct parsed_tag *tag, int fid)
{
    char *p, *q, *r, *s, *tg, *n;

    p = ""get"";
    parsedtag_get_value(tag, ATTR_METHOD, &p);
    q = ""!CURRENT_URL!"";
    parsedtag_get_value(tag, ATTR_ACTION, &q);
    q = url_encode(remove_space(q), cur_baseURL, cur_document_charset);
    r = NULL;
#ifdef USE_M17N
    if (parsedtag_get_value(tag, ATTR_ACCEPT_CHARSET, &r))
	r = check_accept_charset(r);
    if (!r && parsedtag_get_value(tag, ATTR_CHARSET, &r))
	r = check_charset(r);
#endif
    s = NULL;
    parsedtag_get_value(tag, ATTR_ENCTYPE, &s);
    tg = NULL;
    parsedtag_get_value(tag, ATTR_TARGET, &tg);
    n = NULL;
    parsedtag_get_value(tag, ATTR_NAME, &n);

    if (fid < 0) {
	form_max++;
	form_sp++;
	fid = form_max;
    }
    else {			/* <form_int> */
	if (form_max < fid)
	    form_max = fid;
	form_sp = fid;
    }
    if (forms_size == 0) {
	forms_size = INITIAL_FORM_SIZE;
	forms = New_N(FormList *, forms_size);
	form_stack = NewAtom_N(int, forms_size);
    }
    if (forms_size <= form_max) {
	forms_size += form_max;
	forms = New_Reuse(FormList *, forms, forms_size);
	form_stack = New_Reuse(int, form_stack, forms_size);
    }
    form_stack[form_sp] = fid;

    if (w3m_halfdump) {
	Str tmp = Sprintf(""<form_int fid=\""%d\"" action=\""%s\"" method=\""%s\"""",
			  fid, html_quote(q), html_quote(p));
	if (s)
	    Strcat(tmp, Sprintf("" enctype=\""%s\"""", html_quote(s)));
	if (tg)
	    Strcat(tmp, Sprintf("" target=\""%s\"""", html_quote(tg)));
	if (n)
	    Strcat(tmp, Sprintf("" name=\""%s\"""", html_quote(n)));
#ifdef USE_M17N
	if (r)
	    Strcat(tmp, Sprintf("" accept-charset=\""%s\"""", html_quote(r)));
#endif
	Strcat_charp(tmp, "">"");
	return tmp;
    }

    forms[fid] = newFormList(q, p, r, s, tg, n, NULL);
    return NULL;
}","static Str
process_form_int(struct parsed_tag *VAR_0, int VAR_1)
{
    char *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6, *VAR_7;

    VAR_2 = ""get"";
    parsedtag_get_value(VAR_0, VAR_8, &VAR_2);
    VAR_3 = ""!CURRENT_URL!"";
    parsedtag_get_value(VAR_0, VAR_9, &VAR_3);
    VAR_3 = url_encode(remove_space(VAR_3), VAR_10, VAR_11);
    VAR_4 = NULL;
#ifdef VAR_12
    if (parsedtag_get_value(VAR_0, VAR_13, &VAR_4))
	VAR_4 = check_accept_charset(VAR_4);
    if (!VAR_4 && parsedtag_get_value(VAR_0, VAR_14, &VAR_4))
	VAR_4 = check_charset(VAR_4);
#endif
    VAR_5 = NULL;
    parsedtag_get_value(VAR_0, VAR_15, &VAR_5);
    VAR_6 = NULL;
    parsedtag_get_value(VAR_0, VAR_16, &VAR_6);
    VAR_7 = NULL;
    parsedtag_get_value(VAR_0, VAR_17, &VAR_7);

    if (VAR_1 < 0) {
	VAR_18++;
	VAR_19++;
	VAR_1 = VAR_18;
    }
    else {			/* COMMENT_0 */
	if (VAR_18 < VAR_1)
	    VAR_18 = VAR_1;
	VAR_19 = VAR_1;
    }
    if (VAR_20 == 0) {
	VAR_20 = VAR_21;
	VAR_22 = New_N(VAR_23 *, VAR_20);
	VAR_24 = NewAtom_N(int, VAR_20);
    }
    if (VAR_20 <= VAR_18) {
	VAR_20 += VAR_18;
	VAR_22 = New_Reuse(VAR_23 *, VAR_22, VAR_20);
	VAR_24 = New_Reuse(int, VAR_24, VAR_20);
    }
    VAR_24[VAR_19] = VAR_1;

    if (VAR_25) {
	Str VAR_26 = Sprintf(""<form_int fid=\""%d\"" action=\""%s\"" method=\""%s\"""",
			  VAR_1, html_quote(VAR_3), html_quote(VAR_2));
	if (VAR_5)
	    Strcat(VAR_26, Sprintf("" enctype=\""%s\"""", html_quote(VAR_5)));
	if (VAR_6)
	    Strcat(VAR_26, Sprintf("" target=\""%s\"""", html_quote(VAR_6)));
	if (VAR_7)
	    Strcat(VAR_26, Sprintf("" name=\""%s\"""", html_quote(VAR_7)));
#ifdef VAR_12
	if (VAR_4)
	    Strcat(VAR_26, Sprintf("" accept-charset=\""%s\"""", html_quote(VAR_4)));
#endif
	Strcat_charp(VAR_26, "">"");
	return VAR_26;
    }

    VAR_22[VAR_1] = newFormList(VAR_3, VAR_2, VAR_4, VAR_5, VAR_6, VAR_7, NULL);
    return NULL;
}",tats/w3m/3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b/file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,7 +37,7 @@
 	forms = New_N(FormList *, forms_size);
 	form_stack = NewAtom_N(int, forms_size);
     }
-    else if (forms_size <= form_max) {
+    if (forms_size <= form_max) {
 	forms_size += form_max;
 	forms = New_Reuse(FormList *, forms, forms_size);
 	form_stack = New_Reuse(int, form_stack, forms_size);","{'deleted_lines': ['    else if (forms_size <= form_max) {'], 'added_lines': ['    if (forms_size <= form_max) {']}",True,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,6.5,MEDIUM,1,valid,2016-08-17T13:34:40Z,1
CVE-2016-9434,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,tats/w3m,"Prevent segfault with incorrect form_int fid

Bug-Debian: https://github.com/tats/w3m/issues/15",3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b,https://github.com/tats/w3m/commit/3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b,file.c,HTMLlineproc2body,"static void
HTMLlineproc2body(Buffer *buf, Str (*feed) (), int llimit)
{
static char *outc = NULL;
static Lineprop *outp = NULL;
static int out_size = 0;
Anchor *a_href = NULL, *a_img = NULL, *a_form = NULL;
char *p, *q, *r, *s, *t, *str;
Lineprop mode, effect, ex_effect;
int pos;
int nlines;
#ifdef DEBUG
FILE *debug = NULL;
#endif
struct frameset *frameset_s[FRAMESTACK_SIZE];
int frameset_sp = -1;
union frameset_element *idFrame = NULL;
char *id = NULL;
int hseq, form_id;
Str line;
char *endp;
char symbol = '\0';
int internal = 0;
Anchor **a_textarea = NULL;
#ifdef MENU_SELECT
Anchor **a_select = NULL;
#endif
#if defined(USE_M17N) || defined(USE_IMAGE)
ParsedURL *base = baseURL(buf);
#endif
#ifdef USE_M17N
wc_ces name_charset = url_to_charset(NULL, &buf->currentURL,
buf->document_charset);
#endif
if (out_size == 0) {
out_size = LINELEN;
outc = NewAtom_N(char, out_size);
outp = NewAtom_N(Lineprop, out_size);
}
n_textarea = -1;
if (!max_textarea) {
max_textarea = MAX_TEXTAREA;
textarea_str = New_N(Str, max_textarea);
a_textarea = New_N(Anchor *, max_textarea);
}
#ifdef MENU_SELECT
n_select = -1;
if (!max_select) {
max_select = MAX_SELECT;
select_option = New_N(FormSelectOption, max_select);
a_select = New_N(Anchor *, max_select);
}
#endif
#ifdef DEBUG
if (w3m_debug)
debug = fopen(""zzzerr"", ""a"");
#endif
effect = 0;
ex_effect = 0;
nlines = 0;
while ((line = feed()) != NULL) {
#ifdef DEBUG
if (w3m_debug) {
Strfputs(line, debug);
fputc('\n', debug);
}
#endif
if (n_textarea >= 0 && *(line->ptr) != '<') {
Strcat(textarea_str[n_textarea], line);
continue;
}
proc_again:
if (++nlines == llimit)
break;
pos = 0;
#ifdef ENABLE_REMOVE_TRAILINGSPACES
Strremovetrailingspaces(line);
#endif
str = line->ptr;
endp = str + line->length;
while (str < endp) {
PSIZE;
mode = get_mctype(str);
if ((effect | ex_efct(ex_effect)) & PC_SYMBOL && *str != '<') {
#ifdef USE_M17N
char **buf = set_symbol(symbol_width0);
int len;
p = buf[(int)symbol];
len = get_mclen(p);
mode = get_mctype(p);
PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
if (--len) {
mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
while (len--) {
PSIZE;
PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
}
}
#else
PPUSH(PC_ASCII | effect | ex_efct(ex_effect), SYMBOL_BASE + symbol);
#endif
str += symbol_width;
}
#ifdef USE_M17N
else if (mode == PC_CTRL || mode == PC_UNDEF) {
#else
else if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
str++;
}
#ifdef USE_M17N
else if (mode & PC_UNKNOWN) {
PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
str += get_mclen(str);
}
#endif
else if (*str != '<' && *str != '&') {
#ifdef USE_M17N
int len = get_mclen(str);
#endif
PPUSH(mode | effect | ex_efct(ex_effect), *(str++));
#ifdef USE_M17N
if (--len) {
mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
while (len--) {
PSIZE;
PPUSH(mode | effect | ex_efct(ex_effect), *(str++));
}
}
#endif
}
else if (*str == '&') {
p = getescapecmd(&str);
while (*p) {
PSIZE;
mode = get_mctype((unsigned char *)p);
#ifdef USE_M17N
if (mode == PC_CTRL || mode == PC_UNDEF) {
#else
if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
p++;
}
#ifdef USE_M17N
else if (mode & PC_UNKNOWN) {
PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
p += get_mclen(p);
}
#endif
else {
#ifdef USE_M17N
int len = get_mclen(p);
#endif
PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
#ifdef USE_M17N
if (--len) {
mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
while (len--) {
PSIZE;
PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
}
}
#endif
}
}
}
else {
struct parsed_tag *tag;
if (!(tag = parse_tag(&str, TRUE)))
continue;
switch (tag->tagid) {
case HTML_B:
effect |= PE_BOLD;
break;
case HTML_N_B:
effect &= ~PE_BOLD;
break;
case HTML_I:
ex_effect |= PE_EX_ITALIC;
break;
case HTML_N_I:
ex_effect &= ~PE_EX_ITALIC;
break;
case HTML_INS:
ex_effect |= PE_EX_INSERT;
break;
case HTML_N_INS:
ex_effect &= ~PE_EX_INSERT;
break;
case HTML_U:
effect |= PE_UNDER;
break;
case HTML_N_U:
effect &= ~PE_UNDER;
break;
case HTML_S:
ex_effect |= PE_EX_STRIKE;
break;
case HTML_N_S:
ex_effect &= ~PE_EX_STRIKE;
break;
case HTML_A:
if (renderFrameSet &&
parsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {
p = url_quote_conv(p, buf->document_charset);
if (!idFrame || strcmp(idFrame->body->name, p)) {
idFrame = search_frame(renderFrameSet, p);
if (idFrame && idFrame->body->attr != F_BODY)
idFrame = NULL;
}
}
p = r = s = NULL;
q = buf->baseTarget;
t = """";
hseq = 0;
id = NULL;
if (parsedtag_get_value(tag, ATTR_NAME, &id)) {
id = url_quote_conv(id, name_charset);
registerName(buf, id, currentLn(buf), pos);
}
if (parsedtag_get_value(tag, ATTR_HREF, &p))
p = url_encode(remove_space(p), base,
buf->document_charset);
if (parsedtag_get_value(tag, ATTR_TARGET, &q))
q = url_quote_conv(q, buf->document_charset);
if (parsedtag_get_value(tag, ATTR_REFERER, &r))
r = url_encode(r, base,
buf->document_charset);
parsedtag_get_value(tag, ATTR_TITLE, &s);
parsedtag_get_value(tag, ATTR_ACCESSKEY, &t);
parsedtag_get_value(tag, ATTR_HSEQ, &hseq);
if (hseq > 0)
buf->hmarklist =
putHmarker(buf->hmarklist, currentLn(buf),
pos, hseq - 1);
else if (hseq < 0) {
int h = -hseq - 1;
if (buf->hmarklist &&
h < buf->hmarklist->nmark &&
buf->hmarklist->marks[h].invalid) {
buf->hmarklist->marks[h].pos = pos;
buf->hmarklist->marks[h].line = currentLn(buf);
buf->hmarklist->marks[h].invalid = 0;
hseq = -hseq;
}
}
if (id && idFrame)
idFrame->body->nameList =
putAnchor(idFrame->body->nameList, id, NULL,
(Anchor **)NULL, NULL, NULL, '\0',
currentLn(buf), pos);
if (p) {
effect |= PE_ANCHOR;
a_href = registerHref(buf, p, q, r, s,
*t, currentLn(buf), pos);
a_href->hseq = ((hseq > 0) ? hseq : -hseq) - 1;
a_href->slave = (hseq > 0) ? FALSE : TRUE;
}
break;
case HTML_N_A:
effect &= ~PE_ANCHOR;
if (a_href) {
a_href->end.line = currentLn(buf);
a_href->end.pos = pos;
if (a_href->start.line == a_href->end.line &&
a_href->start.pos == a_href->end.pos) {
if (buf->hmarklist &&
a_href->hseq < buf->hmarklist->nmark)
buf->hmarklist->marks[a_href->hseq].invalid = 1;
a_href->hseq = -1;
}
a_href = NULL;
}
break;
case HTML_LINK:
addLink(buf, tag);
break;
case HTML_IMG_ALT:
if (parsedtag_get_value(tag, ATTR_SRC, &p)) {
#ifdef USE_IMAGE
int w = -1, h = -1, iseq = 0, ismap = 0;
int xoffset = 0, yoffset = 0, top = 0, bottom = 0;
parsedtag_get_value(tag, ATTR_HSEQ, &iseq);
parsedtag_get_value(tag, ATTR_WIDTH, &w);
parsedtag_get_value(tag, ATTR_HEIGHT, &h);
parsedtag_get_value(tag, ATTR_XOFFSET, &xoffset);
parsedtag_get_value(tag, ATTR_YOFFSET, &yoffset);
parsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);
parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);
if (parsedtag_exists(tag, ATTR_ISMAP))
ismap = 1;
q = NULL;
parsedtag_get_value(tag, ATTR_USEMAP, &q);
if (iseq > 0) {
buf->imarklist = putHmarker(buf->imarklist,
currentLn(buf), pos,
iseq - 1);
}
#endif
s = NULL;
parsedtag_get_value(tag, ATTR_TITLE, &s);
p = url_quote_conv(remove_space(p),
buf->document_charset);
a_img = registerImg(buf, p, s, currentLn(buf), pos);
#ifdef USE_IMAGE
a_img->hseq = iseq;
a_img->image = NULL;
if (iseq > 0) {
ParsedURL u;
Image *image;
parseURL2(a_img->url, &u, base);
a_img->image = image = New(Image);
image->url = parsedURL2Str(&u)->ptr;
if (!uncompressed_file_type(u.file, &image->ext))
image->ext = filename_extension(u.file, TRUE);
image->cache = NULL;
image->width =
(w > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : w;
image->height =
(h > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : h;
image->xoffset = xoffset;
image->yoffset = yoffset;
image->y = currentLn(buf) - top;
if (image->xoffset < 0 && pos == 0)
image->xoffset = 0;
if (image->yoffset < 0 && image->y == 1)
image->yoffset = 0;
image->rows = 1 + top + bottom;
image->map = q;
image->ismap = ismap;
image->touch = 0;
image->cache = getImage(image, base,
IMG_FLAG_SKIP);
}
else if (iseq < 0) {
BufferPoint *po = buf->imarklist->marks - iseq - 1;
Anchor *a = retrieveAnchor(buf->img,
po->line, po->pos);
if (a) {
a_img->url = a->url;
a_img->image = a->image;
}
}
#endif
}
effect |= PE_IMAGE;
break;
case HTML_N_IMG_ALT:
effect &= ~PE_IMAGE;
if (a_img) {
a_img->end.line = currentLn(buf);
a_img->end.pos = pos;
}
a_img = NULL;
break;
case HTML_INPUT_ALT:
{
FormList *form;
int top = 0, bottom = 0;
int textareanumber = -1;
#ifdef MENU_SELECT
int selectnumber = -1;
#endif
hseq = 0;
form_id = -1;
parsedtag_get_value(tag, ATTR_HSEQ, &hseq);
parsedtag_get_value(tag, ATTR_FID, &form_id);
parsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);
parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);
if (form_id < 0 || form_id > form_max || forms == NULL)
break;
form = forms[form_id];
if (hseq > 0) {
int hpos = pos;
if (*str == '[')
hpos++;
buf->hmarklist =
putHmarker(buf->hmarklist, currentLn(buf),
hpos, hseq - 1);
}
else if (hseq < 0) {
int h = -hseq - 1;
int hpos = pos;
if (*str == '[')
hpos++;
if (buf->hmarklist &&
h < buf->hmarklist->nmark &&
buf->hmarklist->marks[h].invalid) {
buf->hmarklist->marks[h].pos = hpos;
buf->hmarklist->marks[h].line = currentLn(buf);
buf->hmarklist->marks[h].invalid = 0;
hseq = -hseq;
}
}
if (!form->target)
form->target = buf->baseTarget;
if (a_textarea &&
parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,
&textareanumber)) {
if (textareanumber >= max_textarea) {
max_textarea = 2 * textareanumber;
textarea_str = New_Reuse(Str, textarea_str,
max_textarea);
a_textarea = New_Reuse(Anchor *, a_textarea,
max_textarea);
}
}
#ifdef MENU_SELECT
if (a_select &&
parsedtag_get_value(tag, ATTR_SELECTNUMBER,
&selectnumber)) {
if (selectnumber >= max_select) {
max_select = 2 * selectnumber;
select_option = New_Reuse(FormSelectOption,
select_option,
max_select);
a_select = New_Reuse(Anchor *, a_select,
max_select);
}
}
#endif
a_form =
registerForm(buf, form, tag, currentLn(buf), pos);
if (a_textarea && textareanumber >= 0)
a_textarea[textareanumber] = a_form;
#ifdef MENU_SELECT
if (a_select && selectnumber >= 0)
a_select[selectnumber] = a_form;
#endif
if (a_form) {
a_form->hseq = hseq - 1;
a_form->y = currentLn(buf) - top;
a_form->rows = 1 + top + bottom;
if (!parsedtag_exists(tag, ATTR_NO_EFFECT))
effect |= PE_FORM;
break;
}
}
case HTML_N_INPUT_ALT:
effect &= ~PE_FORM;
if (a_form) {
a_form->end.line = currentLn(buf);
a_form->end.pos = pos;
if (a_form->start.line == a_form->end.line &&
a_form->start.pos == a_form->end.pos)
a_form->hseq = -1;
}
a_form = NULL;
break;
case HTML_MAP:
if (parsedtag_get_value(tag, ATTR_NAME, &p)) {
MapList *m = New(MapList);
m->name = Strnew_charp(p);
m->area = newGeneralList();
m->next = buf->maplist;
buf->maplist = m;
}
break;
case HTML_N_MAP:
break;
case HTML_AREA:
if (buf->maplist == NULL)
break;
if (parsedtag_get_value(tag, ATTR_HREF, &p)) {
MapArea *a;
p = url_encode(remove_space(p), base,
buf->document_charset);
t = NULL;
parsedtag_get_value(tag, ATTR_TARGET, &t);
q = """";
parsedtag_get_value(tag, ATTR_ALT, &q);
r = NULL;
s = NULL;
#ifdef USE_IMAGE
parsedtag_get_value(tag, ATTR_SHAPE, &r);
parsedtag_get_value(tag, ATTR_COORDS, &s);
#endif
a = newMapArea(p, t, q, r, s);
pushValue(buf->maplist->area, (void *)a);
}
break;
case HTML_FRAMESET:
frameset_sp++;
if (frameset_sp >= FRAMESTACK_SIZE)
break;
frameset_s[frameset_sp] = newFrameSet(tag);
if (frameset_s[frameset_sp] == NULL)
break;
if (frameset_sp == 0) {
if (buf->frameset == NULL) {
buf->frameset = frameset_s[frameset_sp];
}
else
pushFrameTree(&(buf->frameQ),
frameset_s[frameset_sp], NULL);
}
else
addFrameSetElement(frameset_s[frameset_sp - 1],
*(union frameset_element *)
&frameset_s[frameset_sp]);
break;
case HTML_N_FRAMESET:
if (frameset_sp >= 0)
frameset_sp--;
break;
case HTML_FRAME:
if (frameset_sp >= 0 && frameset_sp < FRAMESTACK_SIZE) {
union frameset_element element;
element.body = newFrame(tag, buf);
addFrameSetElement(frameset_s[frameset_sp], element);
}
break;
case HTML_BASE:
if (parsedtag_get_value(tag, ATTR_HREF, &p)) {
p = url_encode(remove_space(p), NULL,
buf->document_charset);
if (!buf->baseURL)
buf->baseURL = New(ParsedURL);
parseURL(p, buf->baseURL, NULL);
#if defined(USE_M17N) || defined(USE_IMAGE)
base = buf->baseURL;
#endif
}
if (parsedtag_get_value(tag, ATTR_TARGET, &p))
buf->baseTarget =
url_quote_conv(p, buf->document_charset);
break;
case HTML_META:
p = q = NULL;
parsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);
parsedtag_get_value(tag, ATTR_CONTENT, &q);
if (p && q && !strcasecmp(p, ""refresh"") && MetaRefresh) {
Str tmp = NULL;
int refresh_interval = getMetaRefreshParam(q, &tmp);
#ifdef USE_ALARM
if (tmp) {
p = url_encode(remove_space(tmp->ptr), base,
buf->document_charset);
buf->event = setAlarmEvent(buf->event,
refresh_interval,
AL_IMPLICIT_ONCE,
FUNCNAME_gorURL, p);
}
else if (refresh_interval > 0)
buf->event = setAlarmEvent(buf->event,
refresh_interval,
AL_IMPLICIT,
FUNCNAME_reload, NULL);
#else
if (tmp && refresh_interval == 0) {
p = url_encode(remove_space(tmp->ptr), base,
buf->document_charset);
pushEvent(FUNCNAME_gorURL, p);
}
#endif
}
break;
case HTML_INTERNAL:
internal = HTML_INTERNAL;
break;
case HTML_N_INTERNAL:
internal = HTML_N_INTERNAL;
break;
case HTML_FORM_INT:
if (parsedtag_get_value(tag, ATTR_FID, &form_id))
process_form_int(tag, form_id);
break;
case HTML_TEXTAREA_INT:
if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,
&n_textarea)
&& n_textarea >= 0 && n_textarea < max_textarea) {
textarea_str[n_textarea] = Strnew();
}
else
n_textarea = -1;
break;
case HTML_N_TEXTAREA_INT:
if (n_textarea >= 0) {
FormItemList *item =
(FormItemList *)a_textarea[n_textarea]->url;
item->init_value = item->value =
textarea_str[n_textarea];
}
break;
#ifdef MENU_SELECT
case HTML_SELECT_INT:
if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &n_select)
&& n_select >= 0 && n_select < max_select) {
select_option[n_select].first = NULL;
select_option[n_select].last = NULL;
}
else
n_select = -1;
break;
case HTML_N_SELECT_INT:
if (n_select >= 0) {
FormItemList *item =
(FormItemList *)a_select[n_select]->url;
item->select_option = select_option[n_select].first;
chooseSelectOption(item, item->select_option);
item->init_selected = item->selected;
item->init_value = item->value;
item->init_label = item->label;
}
break;
case HTML_OPTION_INT:
if (n_select >= 0) {
int selected;
q = """";
parsedtag_get_value(tag, ATTR_LABEL, &q);
p = q;
parsedtag_get_value(tag, ATTR_VALUE, &p);
selected = parsedtag_exists(tag, ATTR_SELECTED);
addSelectOption(&select_option[n_select],
Strnew_charp(p), Strnew_charp(q),
selected);
}
break;
#endif
case HTML_TITLE_ALT:
if (parsedtag_get_value(tag, ATTR_TITLE, &p))
buf->buffername = html_unquote(p);
break;
case HTML_SYMBOL:
effect |= PC_SYMBOL;
if (parsedtag_get_value(tag, ATTR_TYPE, &p))
symbol = (char)atoi(p);
break;
case HTML_N_SYMBOL:
effect &= ~PC_SYMBOL;
break;
}
#ifdefID_EXT
id = NULL;
if (parsedtag_get_value(tag, ATTR_ID, &id)) {
id = url_quote_conv(id, name_charset);
registerName(buf, id, currentLn(buf), pos);
}
if (renderFrameSet &&
parsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {
p = url_quote_conv(p, buf->document_charset);
if (!idFrame || strcmp(idFrame->body->name, p)) {
idFrame = search_frame(renderFrameSet, p);
if (idFrame && idFrame->body->attr != F_BODY)
idFrame = NULL;
}
}
if (id && idFrame)
idFrame->body->nameList =
putAnchor(idFrame->body->nameList, id, NULL,
(Anchor **)NULL, NULL, NULL, '\0',
currentLn(buf), pos);
#endif
}
}
if (!internal)
addnewline(buf, outc, outp, NULL, pos, -1, nlines);
if (internal == HTML_N_INTERNAL)
internal = 0;
if (str != endp) {
line = Strsubstr(line, str - line->ptr, endp - str);
goto proc_again;
}
}
#ifdef DEBUG
if (w3m_debug)
fclose(debug);
#endif
for (form_id = 1; form_id <= form_max; form_id++)
forms[form_id]->next = forms[form_id - 1];
buf->formlist = (form_max >= 0) ? forms[form_max] : NULL;
if (n_textarea)
addMultirowsForm(buf, buf->formitem);
#ifdef USE_IMAGE
addMultirowsImg(buf, buf->img);
#endif
}","static void
HTMLlineproc2body(Buffer *VAR_0, Str (*VAR_1) (), int VAR_2)
{
static char *VAR_3 = NULL;
static Lineprop *VAR_4 = NULL;
static int VAR_5 = 0;
Anchor *VAR_6 = NULL, *VAR_7 = NULL, *VAR_8 = NULL;
char *VAR_9, *VAR_10, *VAR_11, *VAR_12, *VAR_13, *VAR_14;
Lineprop VAR_15, VAR_16, VAR_17;
int VAR_18;
int VAR_19;
#ifdef VAR_20
FILE *VAR_21 = NULL;
#endif
struct frameset *VAR_22[VAR_23];
int VAR_24 = -1;
union frameset_element *VAR_25 = NULL;
char *VAR_26 = NULL;
int VAR_27, VAR_28;
Str VAR_29;
char *VAR_30;
char VAR_31 = '\0';
int VAR_32 = 0;
Anchor **VAR_33 = NULL;
#ifdef VAR_34
Anchor **VAR_35 = NULL;
#endif
#if defined(VAR_36) || defined(VAR_37)
ParsedURL *VAR_38 = baseURL(VAR_0);
#endif
#ifdef VAR_36
wc_ces VAR_39 = url_to_charset(NULL, &VAR_0->currentURL,
VAR_0->document_charset);
#endif
if (VAR_5 == 0) {
VAR_5 = VAR_40;
VAR_3 = NewAtom_N(char, VAR_5);
VAR_4 = NewAtom_N(Lineprop, VAR_5);
}
VAR_41 = -1;
if (!VAR_42) {
VAR_42 = VAR_43;
VAR_44 = New_N(Str, VAR_42);
VAR_33 = New_N(Anchor *, VAR_42);
}
#ifdef VAR_34
VAR_45 = -1;
if (!VAR_46) {
VAR_46 = VAR_47;
VAR_48 = New_N(VAR_49, VAR_46);
VAR_35 = New_N(Anchor *, VAR_46);
}
#endif
#ifdef VAR_20
if (VAR_50)
VAR_21 = fopen(""zzzerr"", ""a"");
#endif
VAR_16 = 0;
VAR_17 = 0;
VAR_19 = 0;
while ((VAR_29 = VAR_1()) != NULL) {
#ifdef VAR_20
if (VAR_50) {
Strfputs(VAR_29, VAR_21);
fputc('\n', VAR_21);
}
#endif
if (VAR_41 >= 0 && *(VAR_29->ptr) != '<') {
Strcat(VAR_44[VAR_41], VAR_29);
continue;
}
proc_again:
if (++VAR_19 == VAR_2)
break;
VAR_18 = 0;
#ifdef VAR_51
Strremovetrailingspaces(VAR_29);
#endif
VAR_14 = VAR_29->ptr;
VAR_30 = VAR_14 + VAR_29->length;
while (VAR_14 < VAR_30) {
VAR_52;
VAR_15 = get_mctype(VAR_14);
if ((VAR_16 | ex_efct(VAR_17)) & VAR_53 && *VAR_14 != '<') {
#ifdef VAR_36
char **VAR_0 = set_symbol(VAR_54);
int VAR_55;
VAR_9 = VAR_0[(int)VAR_31];
VAR_55 = get_mclen(VAR_9);
VAR_15 = get_mctype(VAR_9);
PPUSH(VAR_15 | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
if (--VAR_55) {
VAR_15 = (VAR_15 & ~VAR_56) | VAR_57;
while (VAR_55--) {
VAR_52;
PPUSH(VAR_15 | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
}
}
#else
PPUSH(VAR_58 | VAR_16 | ex_efct(VAR_17), VAR_59 + VAR_31);
#endif
VAR_14 += VAR_60;
}
#ifdef VAR_36
else if (mode == VAR_61 || mode == VAR_62) {
#else
else if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
VAR_14++;
}
#ifdef VAR_36
else if (mode & VAR_63) {
PPUSH(VAR_58 | VAR_16 | ex_efct(VAR_17), ' ');
VAR_14 += get_mclen(VAR_14);
}
#endif
else if (*VAR_14 != '<' && *VAR_14 != '&') {
#ifdef VAR_36
int VAR_55 = get_mclen(VAR_14);
#endif
PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_14++));
#ifdef VAR_36
if (--VAR_55) {
mode = (mode & ~VAR_56) | VAR_57;
while (VAR_55--) {
VAR_52;
PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_14++));
}
}
#endif
}
else if (*str == '&') {
VAR_9 = getescapecmd(&str);
while (*VAR_9) {
VAR_52;
mode = get_mctype((unsigned char *)VAR_9);
#ifdef VAR_36
if (mode == VAR_61 || mode == VAR_62) {
#else
if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
VAR_9++;
}
#ifdef VAR_36
else if (mode & VAR_63) {
PPUSH(VAR_58 | VAR_16 | ex_efct(VAR_17), ' ');
VAR_9 += get_mclen(VAR_9);
}
#endif
else {
#ifdef VAR_36
int VAR_55 = get_mclen(VAR_9);
#endif
PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
#ifdef VAR_36
if (--VAR_55) {
mode = (mode & ~VAR_56) | VAR_57;
while (VAR_55--) {
VAR_52;
PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
}
}
#endif
}
}
}
else {
struct parsed_tag *VAR_64;
if (!(VAR_64 = parse_tag(&str, TRUE)))
continue;
switch (VAR_64->tagid) {
case VAR_65:
VAR_16 |= VAR_66;
break;
case VAR_67:
VAR_16 &= ~VAR_66;
break;
case VAR_68:
VAR_17 |= VAR_69;
break;
case VAR_70:
VAR_17 &= ~VAR_69;
break;
case VAR_71:
VAR_17 |= VAR_72;
break;
case VAR_73:
VAR_17 &= ~VAR_72;
break;
case VAR_74:
VAR_16 |= VAR_75;
break;
case VAR_76:
VAR_16 &= ~VAR_75;
break;
case VAR_77:
VAR_17 |= VAR_78;
break;
case VAR_79:
VAR_17 &= ~VAR_78;
break;
case VAR_80:
if (VAR_81 &&
parsedtag_get_value(VAR_64, VAR_82, &VAR_9)) {
VAR_9 = url_quote_conv(VAR_9, VAR_0->document_charset);
if (!VAR_25 || strcmp(VAR_25->body->name, VAR_9)) {
VAR_25 = search_frame(VAR_81, VAR_9);
if (VAR_25 && VAR_25->body->attr != VAR_83)
VAR_25 = NULL;
}
}
VAR_9 = VAR_11 = VAR_12 = NULL;
VAR_10 = VAR_0->baseTarget;
VAR_13 = """";
VAR_27 = 0;
VAR_26 = NULL;
if (parsedtag_get_value(VAR_64, VAR_84, &VAR_26)) {
VAR_26 = url_quote_conv(VAR_26, VAR_39);
registerName(VAR_0, VAR_26, currentLn(VAR_0), VAR_18);
}
if (parsedtag_get_value(VAR_64, VAR_85, &VAR_9))
VAR_9 = url_encode(remove_space(VAR_9), VAR_38,
VAR_0->document_charset);
if (parsedtag_get_value(VAR_64, VAR_86, &VAR_10))
VAR_10 = url_quote_conv(VAR_10, VAR_0->document_charset);
if (parsedtag_get_value(VAR_64, VAR_87, &VAR_11))
VAR_11 = url_encode(VAR_11, VAR_38,
VAR_0->document_charset);
parsedtag_get_value(VAR_64, VAR_88, &VAR_12);
parsedtag_get_value(VAR_64, VAR_89, &VAR_13);
parsedtag_get_value(VAR_64, VAR_90, &VAR_27);
if (VAR_27 > 0)
VAR_0->hmarklist =
putHmarker(VAR_0->hmarklist, currentLn(VAR_0),
VAR_18, VAR_27 - 1);
else if (VAR_27 < 0) {
int VAR_91 = -VAR_27 - 1;
if (VAR_0->hmarklist &&
VAR_91 < VAR_0->hmarklist->nmark &&
VAR_0->hmarklist->marks[VAR_91].invalid) {
VAR_0->hmarklist->marks[VAR_91].pos = VAR_18;
VAR_0->hmarklist->marks[VAR_91].line = currentLn(VAR_0);
VAR_0->hmarklist->marks[VAR_91].invalid = 0;
VAR_27 = -VAR_27;
}
}
if (VAR_26 && VAR_25)
VAR_25->body->nameList =
putAnchor(VAR_25->body->nameList, VAR_26, NULL,
(Anchor **)NULL, NULL, NULL, '\0',
currentLn(VAR_0), VAR_18);
if (VAR_9) {
VAR_16 |= VAR_92;
VAR_6 = registerHref(VAR_0, VAR_9, VAR_10, VAR_11, VAR_12,
*VAR_13, currentLn(VAR_0), VAR_18);
VAR_6->hseq = ((VAR_27 > 0) ? VAR_27 : -VAR_27) - 1;
VAR_6->slave = (VAR_27 > 0) ? FALSE : TRUE;
}
break;
case VAR_93:
VAR_16 &= ~VAR_92;
if (VAR_6) {
VAR_6->end.line = currentLn(VAR_0);
VAR_6->end.pos = VAR_18;
if (VAR_6->start.line == VAR_6->end.line &&
VAR_6->start.pos == VAR_6->end.pos) {
if (VAR_0->hmarklist &&
VAR_6->hseq < VAR_0->hmarklist->nmark)
VAR_0->hmarklist->marks[VAR_6->hseq].invalid = 1;
VAR_6->hseq = -1;
}
VAR_6 = NULL;
}
break;
case VAR_94:
addLink(VAR_0, VAR_64);
break;
case VAR_95:
if (parsedtag_get_value(VAR_64, VAR_96, &VAR_9)) {
#ifdef VAR_37
int VAR_97 = -1, VAR_91 = -1, VAR_98 = 0, VAR_99 = 0;
int VAR_100 = 0, VAR_101 = 0, VAR_102 = 0, VAR_103 = 0;
parsedtag_get_value(VAR_64, VAR_90, &VAR_98);
parsedtag_get_value(VAR_64, VAR_104, &VAR_97);
parsedtag_get_value(VAR_64, VAR_105, &VAR_91);
parsedtag_get_value(VAR_64, VAR_106, &VAR_100);
parsedtag_get_value(VAR_64, VAR_107, &VAR_101);
parsedtag_get_value(VAR_64, VAR_108, &VAR_102);
parsedtag_get_value(VAR_64, VAR_109, &VAR_103);
if (parsedtag_exists(VAR_64, VAR_110))
VAR_99 = 1;
VAR_10 = NULL;
parsedtag_get_value(VAR_64, VAR_111, &VAR_10);
if (VAR_98 > 0) {
VAR_0->imarklist = putHmarker(VAR_0->imarklist,
currentLn(VAR_0), VAR_18,
VAR_98 - 1);
}
#endif
VAR_12 = NULL;
parsedtag_get_value(VAR_64, VAR_88, &VAR_12);
VAR_9 = url_quote_conv(remove_space(VAR_9),
VAR_0->document_charset);
VAR_7 = registerImg(VAR_0, VAR_9, VAR_12, currentLn(VAR_0), VAR_18);
#ifdef VAR_37
VAR_7->hseq = VAR_98;
VAR_7->image = NULL;
if (VAR_98 > 0) {
ParsedURL VAR_112;
Image *VAR_113;
parseURL2(VAR_7->url, &VAR_112, VAR_38);
VAR_7->image = VAR_113 = New(Image);
VAR_113->url = parsedURL2Str(&VAR_112)->ptr;
if (!uncompressed_file_type(VAR_112.file, &VAR_113->ext))
VAR_113->ext = filename_extension(VAR_112.file, TRUE);
VAR_113->cache = NULL;
VAR_113->width =
(VAR_97 > VAR_114) ? VAR_114 : VAR_97;
VAR_113->height =
(VAR_91 > VAR_114) ? VAR_114 : VAR_91;
VAR_113->xoffset = VAR_100;
VAR_113->yoffset = VAR_101;
VAR_113->y = currentLn(VAR_0) - VAR_102;
if (VAR_113->xoffset < 0 && VAR_18 == 0)
VAR_113->xoffset = 0;
if (VAR_113->yoffset < 0 && VAR_113->y == 1)
VAR_113->yoffset = 0;
VAR_113->rows = 1 + VAR_102 + VAR_103;
VAR_113->map = VAR_10;
VAR_113->ismap = VAR_99;
VAR_113->touch = 0;
VAR_113->cache = getImage(VAR_113, VAR_38,
VAR_115);
}
else if (VAR_98 < 0) {
BufferPoint *VAR_116 = VAR_0->imarklist->marks - VAR_98 - 1;
Anchor *VAR_117 = retrieveAnchor(VAR_0->img,
VAR_116->line, VAR_116->pos);
if (VAR_117) {
VAR_7->url = VAR_117->url;
VAR_7->image = VAR_117->image;
}
}
#endif
}
VAR_16 |= VAR_118;
break;
case VAR_119:
VAR_16 &= ~VAR_118;
if (VAR_7) {
VAR_7->end.line = currentLn(VAR_0);
VAR_7->end.pos = VAR_18;
}
VAR_7 = NULL;
break;
case VAR_120:
{
FormList *VAR_121;
int VAR_102 = 0, VAR_103 = 0;
int VAR_122 = -1;
#ifdef VAR_34
int VAR_123 = -1;
#endif
VAR_27 = 0;
VAR_28 = -1;
parsedtag_get_value(VAR_64, VAR_90, &VAR_27);
parsedtag_get_value(VAR_64, VAR_124, &VAR_28);
parsedtag_get_value(VAR_64, VAR_108, &VAR_102);
parsedtag_get_value(VAR_64, VAR_109, &VAR_103);
if (VAR_28 < 0 || VAR_28 > VAR_125 || VAR_126 == NULL)
break;
VAR_121 = VAR_126[VAR_28];
if (VAR_27 > 0) {
int VAR_127 = VAR_18;
if (*str == '[')
VAR_127++;
VAR_0->hmarklist =
putHmarker(VAR_0->hmarklist, currentLn(VAR_0),
VAR_127, VAR_27 - 1);
}
else if (VAR_27 < 0) {
int VAR_91 = -VAR_27 - 1;
int VAR_127 = VAR_18;
if (*str == '[')
VAR_127++;
if (VAR_0->hmarklist &&
VAR_91 < VAR_0->hmarklist->nmark &&
VAR_0->hmarklist->marks[VAR_91].invalid) {
VAR_0->hmarklist->marks[VAR_91].pos = VAR_127;
VAR_0->hmarklist->marks[VAR_91].line = currentLn(VAR_0);
VAR_0->hmarklist->marks[VAR_91].invalid = 0;
VAR_27 = -VAR_27;
}
}
if (!VAR_121->target)
VAR_121->target = VAR_0->baseTarget;
if (VAR_33 &&
parsedtag_get_value(VAR_64, VAR_128,
&VAR_122)) {
if (VAR_122 >= VAR_42) {
VAR_42 = 2 * VAR_122;
VAR_44 = New_Reuse(Str, VAR_44,
VAR_42);
VAR_33 = New_Reuse(Anchor *, VAR_33,
VAR_42);
}
}
#ifdef VAR_34
if (VAR_35 &&
parsedtag_get_value(VAR_64, VAR_129,
&VAR_123)) {
if (VAR_123 >= VAR_46) {
VAR_46 = 2 * VAR_123;
VAR_48 = New_Reuse(VAR_49,
VAR_48,
VAR_46);
VAR_35 = New_Reuse(Anchor *, VAR_35,
VAR_46);
}
}
#endif
VAR_8 =
registerForm(VAR_0, VAR_121, VAR_64, currentLn(VAR_0), VAR_18);
if (VAR_33 && VAR_122 >= 0)
VAR_33[VAR_122] = VAR_8;
#ifdef VAR_34
if (VAR_35 && VAR_123 >= 0)
VAR_35[VAR_123] = VAR_8;
#endif
if (VAR_8) {
VAR_8->hseq = VAR_27 - 1;
VAR_8->y = currentLn(VAR_0) - VAR_102;
VAR_8->rows = 1 + VAR_102 + VAR_103;
if (!parsedtag_exists(VAR_64, VAR_130))
VAR_16 |= VAR_131;
break;
}
}
case VAR_132:
VAR_16 &= ~VAR_131;
if (VAR_8) {
VAR_8->end.line = currentLn(VAR_0);
VAR_8->end.pos = VAR_18;
if (VAR_8->start.line == VAR_8->end.line &&
VAR_8->start.pos == VAR_8->end.pos)
VAR_8->hseq = -1;
}
VAR_8 = NULL;
break;
case VAR_133:
if (parsedtag_get_value(VAR_64, VAR_84, &VAR_9)) {
MapList *VAR_134 = New(MapList);
VAR_134->name = Strnew_charp(VAR_9);
VAR_134->area = newGeneralList();
VAR_134->next = VAR_0->maplist;
VAR_0->maplist = VAR_134;
}
break;
case VAR_135:
break;
case VAR_136:
if (VAR_0->maplist == NULL)
break;
if (parsedtag_get_value(VAR_64, VAR_85, &VAR_9)) {
MapArea *VAR_117;
VAR_9 = url_encode(remove_space(VAR_9), VAR_38,
VAR_0->document_charset);
VAR_13 = NULL;
parsedtag_get_value(VAR_64, VAR_86, &VAR_13);
VAR_10 = """";
parsedtag_get_value(VAR_64, VAR_137, &VAR_10);
VAR_11 = NULL;
VAR_12 = NULL;
#ifdef VAR_37
parsedtag_get_value(VAR_64, VAR_138, &VAR_11);
parsedtag_get_value(VAR_64, VAR_139, &VAR_12);
#endif
VAR_117 = newMapArea(VAR_9, VAR_13, VAR_10, VAR_11, VAR_12);
pushValue(VAR_0->maplist->area, (void *)VAR_117);
}
break;
case VAR_140:
VAR_24++;
if (VAR_24 >= VAR_23)
break;
VAR_22[VAR_24] = newFrameSet(VAR_64);
if (VAR_22[VAR_24] == NULL)
break;
if (VAR_24 == 0) {
if (VAR_0->frameset == NULL) {
VAR_0->frameset = VAR_22[VAR_24];
}
else
pushFrameTree(&(VAR_0->frameQ),
VAR_22[VAR_24], NULL);
}
else
addFrameSetElement(VAR_22[VAR_24 - 1],
*(union frameset_element *)
&VAR_22[VAR_24]);
break;
case VAR_141:
if (VAR_24 >= 0)
VAR_24--;
break;
case VAR_142:
if (VAR_24 >= 0 && VAR_24 < VAR_23) {
union frameset_element VAR_143;
VAR_143.body = newFrame(VAR_64, VAR_0);
addFrameSetElement(VAR_22[VAR_24], VAR_143);
}
break;
case VAR_144:
if (parsedtag_get_value(VAR_64, VAR_85, &VAR_9)) {
VAR_9 = url_encode(remove_space(VAR_9), NULL,
VAR_0->document_charset);
if (!VAR_0->baseURL)
VAR_0->baseURL = New(ParsedURL);
parseURL(VAR_9, VAR_0->baseURL, NULL);
#if defined(VAR_36) || defined(VAR_37)
VAR_38 = VAR_0->baseURL;
#endif
}
if (parsedtag_get_value(VAR_64, VAR_86, &VAR_9))
VAR_0->baseTarget =
url_quote_conv(VAR_9, VAR_0->document_charset);
break;
case VAR_145:
VAR_9 = VAR_10 = NULL;
parsedtag_get_value(VAR_64, VAR_146, &VAR_9);
parsedtag_get_value(VAR_64, VAR_147, &VAR_10);
if (VAR_9 && VAR_10 && !strcasecmp(VAR_9, ""refresh"") && VAR_148) {
Str VAR_149 = NULL;
int VAR_150 = getMetaRefreshParam(VAR_10, &VAR_149);
#ifdef VAR_151
if (VAR_149) {
VAR_9 = url_encode(remove_space(VAR_149->ptr), VAR_38,
VAR_0->document_charset);
VAR_0->event = setAlarmEvent(VAR_0->event,
VAR_150,
VAR_152,
VAR_153, VAR_9);
}
else if (VAR_150 > 0)
VAR_0->event = setAlarmEvent(VAR_0->event,
VAR_150,
VAR_154,
VAR_155, NULL);
#else
if (VAR_149 && VAR_150 == 0) {
VAR_9 = url_encode(remove_space(VAR_149->ptr), VAR_38,
VAR_0->document_charset);
pushEvent(VAR_153, VAR_9);
}
#endif
}
break;
case VAR_156:
VAR_32 = VAR_156;
break;
case VAR_157:
VAR_32 = VAR_157;
break;
case VAR_158:
if (parsedtag_get_value(VAR_64, VAR_124, &VAR_28))
process_form_int(VAR_64, VAR_28);
break;
case VAR_159:
if (parsedtag_get_value(VAR_64, VAR_128,
&VAR_41)
&& VAR_41 >= 0 && VAR_41 < VAR_42) {
VAR_44[VAR_41] = Strnew();
}
else
VAR_41 = -1;
break;
case VAR_160:
if (VAR_41 >= 0) {
FormItemList *VAR_161 =
(FormItemList *)VAR_33[VAR_41]->url;
VAR_161->init_value = VAR_161->value =
VAR_44[VAR_41];
}
break;
#ifdef VAR_34
case VAR_162:
if (parsedtag_get_value(VAR_64, VAR_129, &VAR_45)
&& VAR_45 >= 0 && VAR_45 < VAR_46) {
VAR_48[VAR_45].first = NULL;
VAR_48[VAR_45].last = NULL;
}
else
VAR_45 = -1;
break;
case VAR_163:
if (VAR_45 >= 0) {
FormItemList *VAR_161 =
(FormItemList *)VAR_35[VAR_45]->url;
VAR_161->select_option = VAR_48[VAR_45].first;
chooseSelectOption(VAR_161, VAR_161->select_option);
VAR_161->init_selected = VAR_161->selected;
VAR_161->init_value = VAR_161->value;
VAR_161->init_label = VAR_161->label;
}
break;
case VAR_164:
if (VAR_45 >= 0) {
int VAR_165;
VAR_10 = """";
parsedtag_get_value(VAR_64, VAR_166, &VAR_10);
VAR_9 = VAR_10;
parsedtag_get_value(VAR_64, VAR_167, &VAR_9);
VAR_165 = parsedtag_exists(VAR_64, VAR_168);
addSelectOption(&VAR_48[VAR_45],
Strnew_charp(VAR_9), Strnew_charp(VAR_10),
VAR_165);
}
break;
#endif
case VAR_169:
if (parsedtag_get_value(VAR_64, VAR_88, &VAR_9))
VAR_0->buffername = html_unquote(VAR_9);
break;
case VAR_170:
VAR_16 |= VAR_53;
if (parsedtag_get_value(VAR_64, VAR_171, &VAR_9))
VAR_31 = (char)atoi(VAR_9);
break;
case VAR_172:
VAR_16 &= ~VAR_53;
break;
}
#ifdefVAR_173
VAR_26 = NULL;
if (parsedtag_get_value(VAR_64, VAR_174, &VAR_26)) {
VAR_26 = url_quote_conv(VAR_26, VAR_39);
registerName(VAR_0, VAR_26, currentLn(VAR_0), VAR_18);
}
if (VAR_81 &&
parsedtag_get_value(VAR_64, VAR_82, &VAR_9)) {
VAR_9 = url_quote_conv(VAR_9, VAR_0->document_charset);
if (!VAR_25 || strcmp(VAR_25->body->name, VAR_9)) {
VAR_25 = search_frame(VAR_81, VAR_9);
if (VAR_25 && VAR_25->body->attr != VAR_83)
VAR_25 = NULL;
}
}
if (VAR_26 && VAR_25)
VAR_25->body->nameList =
putAnchor(VAR_25->body->nameList, VAR_26, NULL,
(Anchor **)NULL, NULL, NULL, '\0',
currentLn(VAR_0), VAR_18);
#endif
}
}
if (!VAR_32)
addnewline(VAR_0, VAR_3, VAR_4, NULL, VAR_18, -1, VAR_19);
if (VAR_32 == VAR_157)
VAR_32 = 0;
if (str != VAR_30) {
VAR_29 = Strsubstr(VAR_29, str - VAR_29->ptr, VAR_30 - str);
goto proc_again;
}
}
#ifdef VAR_20
if (VAR_50)
fclose(VAR_21);
#endif
for (VAR_28 = 1; VAR_28 <= VAR_125; VAR_28++)
VAR_126[VAR_28]->next = VAR_126[VAR_28 - 1];
VAR_0->formlist = (VAR_125 >= 0) ? VAR_126[VAR_125] : NULL;
if (VAR_41)
addMultirowsForm(VAR_0, VAR_0->formitem);
#ifdef VAR_37
addMultirowsImg(VAR_0, VAR_0->img);
#endif
}",tats/w3m/3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b/file.c/vul/before/1.json,"static void
HTMLlineproc2body(Buffer *buf, Str (*feed) (), int llimit)
{
    static char *outc = NULL;
    static Lineprop *outp = NULL;
    static int out_size = 0;
    Anchor *a_href = NULL, *a_img = NULL, *a_form = NULL;
    char *p, *q, *r, *s, *t, *str;
    Lineprop mode, effect, ex_effect;
    int pos;
    int nlines;
#ifdef DEBUG
    FILE *debug = NULL;
#endif
    struct frameset *frameset_s[FRAMESTACK_SIZE];
    int frameset_sp = -1;
    union frameset_element *idFrame = NULL;
    char *id = NULL;
    int hseq, form_id;
    Str line;
    char *endp;
    char symbol = '\0';
    int internal = 0;
    Anchor **a_textarea = NULL;
#ifdef MENU_SELECT
    Anchor **a_select = NULL;
#endif
#if defined(USE_M17N) || defined(USE_IMAGE)
    ParsedURL *base = baseURL(buf);
#endif
#ifdef USE_M17N
    wc_ces name_charset = url_to_charset(NULL, &buf->currentURL,
					 buf->document_charset);
#endif

    if (out_size == 0) {
	out_size = LINELEN;
	outc = NewAtom_N(char, out_size);
	outp = NewAtom_N(Lineprop, out_size);
    }

    n_textarea = -1;
    if (!max_textarea) {	/* halfload */
	max_textarea = MAX_TEXTAREA;
	textarea_str = New_N(Str, max_textarea);
	a_textarea = New_N(Anchor *, max_textarea);
    }
#ifdef MENU_SELECT
    n_select = -1;
    if (!max_select) {		/* halfload */
	max_select = MAX_SELECT;
	select_option = New_N(FormSelectOption, max_select);
	a_select = New_N(Anchor *, max_select);
    }
#endif

#ifdef DEBUG
    if (w3m_debug)
	debug = fopen(""zzzerr"", ""a"");
#endif

    effect = 0;
    ex_effect = 0;
    nlines = 0;
    while ((line = feed()) != NULL) {
#ifdef DEBUG
	if (w3m_debug) {
	    Strfputs(line, debug);
	    fputc('\n', debug);
	}
#endif
	if (n_textarea >= 0 && *(line->ptr) != '<') {	/* halfload */
	    Strcat(textarea_str[n_textarea], line);
	    continue;
	}
      proc_again:
	if (++nlines == llimit)
	    break;
	pos = 0;
#ifdef ENABLE_REMOVE_TRAILINGSPACES
	Strremovetrailingspaces(line);
#endif
	str = line->ptr;
	endp = str + line->length;
	while (str < endp) {
	    PSIZE;
	    mode = get_mctype(str);
	    if ((effect | ex_efct(ex_effect)) & PC_SYMBOL && *str != '<') {
#ifdef USE_M17N
		char **buf = set_symbol(symbol_width0);
		int len;

		p = buf[(int)symbol];
		len = get_mclen(p);
		mode = get_mctype(p);
		PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
		if (--len) {
		    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
		    while (len--) {
			PSIZE;
			PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
		    }
		}
#else
		PPUSH(PC_ASCII | effect | ex_efct(ex_effect), SYMBOL_BASE + symbol);
#endif
		str += symbol_width;
	    }
#ifdef USE_M17N
	    else if (mode == PC_CTRL || mode == PC_UNDEF) {
#else
	    else if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
		PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
		str++;
	    }
#ifdef USE_M17N
	    else if (mode & PC_UNKNOWN) {
		PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
		str += get_mclen(str);
	    }
#endif
	    else if (*str != '<' && *str != '&') {
#ifdef USE_M17N
		int len = get_mclen(str);
#endif
		PPUSH(mode | effect | ex_efct(ex_effect), *(str++));
#ifdef USE_M17N
		if (--len) {
		    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
		    while (len--) {
			PSIZE;
			PPUSH(mode | effect | ex_efct(ex_effect), *(str++));
		    }
		}
#endif
	    }
	    else if (*str == '&') {
		/* 
		 * & escape processing
		 */
		p = getescapecmd(&str);
		while (*p) {
		    PSIZE;
		    mode = get_mctype((unsigned char *)p);
#ifdef USE_M17N
		    if (mode == PC_CTRL || mode == PC_UNDEF) {
#else
		    if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
			PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
			p++;
		    }
#ifdef USE_M17N
		    else if (mode & PC_UNKNOWN) {
			PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
			p += get_mclen(p);
		    }
#endif
		    else {
#ifdef USE_M17N
			int len = get_mclen(p);
#endif
			PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
#ifdef USE_M17N
			if (--len) {
			    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;
			    while (len--) {
				PSIZE;
				PPUSH(mode | effect | ex_efct(ex_effect), *(p++));
			    }
			}
#endif
		    }
		}
	    }
	    else {
		/* tag processing */
		struct parsed_tag *tag;
		if (!(tag = parse_tag(&str, TRUE)))
		    continue;
		switch (tag->tagid) {
		case HTML_B:
		    effect |= PE_BOLD;
		    break;
		case HTML_N_B:
		    effect &= ~PE_BOLD;
		    break;
		case HTML_I:
		    ex_effect |= PE_EX_ITALIC;
		    break;
		case HTML_N_I:
		    ex_effect &= ~PE_EX_ITALIC;
		    break;
		case HTML_INS:
		    ex_effect |= PE_EX_INSERT;
		    break;
		case HTML_N_INS:
		    ex_effect &= ~PE_EX_INSERT;
		    break;
		case HTML_U:
		    effect |= PE_UNDER;
		    break;
		case HTML_N_U:
		    effect &= ~PE_UNDER;
		    break;
		case HTML_S:
		    ex_effect |= PE_EX_STRIKE;
		    break;
		case HTML_N_S:
		    ex_effect &= ~PE_EX_STRIKE;
		    break;
		case HTML_A:
		    if (renderFrameSet &&
			parsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {
			p = url_quote_conv(p, buf->document_charset);
			if (!idFrame || strcmp(idFrame->body->name, p)) {
			    idFrame = search_frame(renderFrameSet, p);
			    if (idFrame && idFrame->body->attr != F_BODY)
				idFrame = NULL;
			}
		    }
		    p = r = s = NULL;
		    q = buf->baseTarget;
		    t = """";
		    hseq = 0;
		    id = NULL;
		    if (parsedtag_get_value(tag, ATTR_NAME, &id)) {
			id = url_quote_conv(id, name_charset);
			registerName(buf, id, currentLn(buf), pos);
		    }
		    if (parsedtag_get_value(tag, ATTR_HREF, &p))
			p = url_encode(remove_space(p), base,
				       buf->document_charset);
		    if (parsedtag_get_value(tag, ATTR_TARGET, &q))
			q = url_quote_conv(q, buf->document_charset);
		    if (parsedtag_get_value(tag, ATTR_REFERER, &r))
			r = url_encode(r, base,
				       buf->document_charset);
		    parsedtag_get_value(tag, ATTR_TITLE, &s);
		    parsedtag_get_value(tag, ATTR_ACCESSKEY, &t);
		    parsedtag_get_value(tag, ATTR_HSEQ, &hseq);
		    if (hseq > 0)
			buf->hmarklist =
			    putHmarker(buf->hmarklist, currentLn(buf),
				       pos, hseq - 1);
		    else if (hseq < 0) {
			int h = -hseq - 1;
			if (buf->hmarklist &&
			    h < buf->hmarklist->nmark &&
			    buf->hmarklist->marks[h].invalid) {
			    buf->hmarklist->marks[h].pos = pos;
			    buf->hmarklist->marks[h].line = currentLn(buf);
			    buf->hmarklist->marks[h].invalid = 0;
			    hseq = -hseq;
			}
		    }
		    if (id && idFrame)
			idFrame->body->nameList =
			    putAnchor(idFrame->body->nameList, id, NULL,
				      (Anchor **)NULL, NULL, NULL, '\0',
				      currentLn(buf), pos);
		    if (p) {
			effect |= PE_ANCHOR;
			a_href = registerHref(buf, p, q, r, s,
					      *t, currentLn(buf), pos);
			a_href->hseq = ((hseq > 0) ? hseq : -hseq) - 1;
			a_href->slave = (hseq > 0) ? FALSE : TRUE;
		    }
		    break;
		case HTML_N_A:
		    effect &= ~PE_ANCHOR;
		    if (a_href) {
			a_href->end.line = currentLn(buf);
			a_href->end.pos = pos;
			if (a_href->start.line == a_href->end.line &&
			    a_href->start.pos == a_href->end.pos) {
			    if (buf->hmarklist &&
				a_href->hseq < buf->hmarklist->nmark)
				buf->hmarklist->marks[a_href->hseq].invalid = 1;
			    a_href->hseq = -1;
			}
			a_href = NULL;
		    }
		    break;

		case HTML_LINK:
		    addLink(buf, tag);
		    break;

		case HTML_IMG_ALT:
		    if (parsedtag_get_value(tag, ATTR_SRC, &p)) {
#ifdef USE_IMAGE
			int w = -1, h = -1, iseq = 0, ismap = 0;
			int xoffset = 0, yoffset = 0, top = 0, bottom = 0;
			parsedtag_get_value(tag, ATTR_HSEQ, &iseq);
			parsedtag_get_value(tag, ATTR_WIDTH, &w);
			parsedtag_get_value(tag, ATTR_HEIGHT, &h);
			parsedtag_get_value(tag, ATTR_XOFFSET, &xoffset);
			parsedtag_get_value(tag, ATTR_YOFFSET, &yoffset);
			parsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);
			parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);
			if (parsedtag_exists(tag, ATTR_ISMAP))
			    ismap = 1;
			q = NULL;
			parsedtag_get_value(tag, ATTR_USEMAP, &q);
			if (iseq > 0) {
			    buf->imarklist = putHmarker(buf->imarklist,
							currentLn(buf), pos,
							iseq - 1);
			}
#endif
			s = NULL;
			parsedtag_get_value(tag, ATTR_TITLE, &s);
			p = url_quote_conv(remove_space(p),
					   buf->document_charset);
			a_img = registerImg(buf, p, s, currentLn(buf), pos);
#ifdef USE_IMAGE
			a_img->hseq = iseq;
			a_img->image = NULL;
			if (iseq > 0) {
			    ParsedURL u;
			    Image *image;

			    parseURL2(a_img->url, &u, base);
			    a_img->image = image = New(Image);
			    image->url = parsedURL2Str(&u)->ptr;
			    if (!uncompressed_file_type(u.file, &image->ext))
				image->ext = filename_extension(u.file, TRUE);
			    image->cache = NULL;
			    image->width =
				(w > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : w;
			    image->height =
				(h > MAX_IMAGE_SIZE) ? MAX_IMAGE_SIZE : h;
			    image->xoffset = xoffset;
			    image->yoffset = yoffset;
			    image->y = currentLn(buf) - top;
			    if (image->xoffset < 0 && pos == 0)
				image->xoffset = 0;
			    if (image->yoffset < 0 && image->y == 1)
				image->yoffset = 0;
			    image->rows = 1 + top + bottom;
			    image->map = q;
			    image->ismap = ismap;
			    image->touch = 0;
			    image->cache = getImage(image, base,
						    IMG_FLAG_SKIP);
			}
			else if (iseq < 0) {
			    BufferPoint *po = buf->imarklist->marks - iseq - 1;
			    Anchor *a = retrieveAnchor(buf->img,
						       po->line, po->pos);
			    if (a) {
				a_img->url = a->url;
				a_img->image = a->image;
			    }
			}
#endif
		    }
		    effect |= PE_IMAGE;
		    break;
		case HTML_N_IMG_ALT:
		    effect &= ~PE_IMAGE;
		    if (a_img) {
			a_img->end.line = currentLn(buf);
			a_img->end.pos = pos;
		    }
		    a_img = NULL;
		    break;
		case HTML_INPUT_ALT:
		    {
			FormList *form;
			int top = 0, bottom = 0;
			int textareanumber = -1;
#ifdef MENU_SELECT
			int selectnumber = -1;
#endif
			hseq = 0;
			form_id = -1;

			parsedtag_get_value(tag, ATTR_HSEQ, &hseq);
			parsedtag_get_value(tag, ATTR_FID, &form_id);
			parsedtag_get_value(tag, ATTR_TOP_MARGIN, &top);
			parsedtag_get_value(tag, ATTR_BOTTOM_MARGIN, &bottom);
			if (form_id < 0 || form_id > form_max || forms == NULL)
			    break;	/* outside of <form>..</form> */
			form = forms[form_id];
			if (hseq > 0) {
			    int hpos = pos;
			    if (*str == '[')
				hpos++;
			    buf->hmarklist =
				putHmarker(buf->hmarklist, currentLn(buf),
					   hpos, hseq - 1);
			}
			else if (hseq < 0) {
			    int h = -hseq - 1;
			    int hpos = pos;
			    if (*str == '[')
				hpos++;
			    if (buf->hmarklist &&
				h < buf->hmarklist->nmark &&
				buf->hmarklist->marks[h].invalid) {
				buf->hmarklist->marks[h].pos = hpos;
				buf->hmarklist->marks[h].line = currentLn(buf);
				buf->hmarklist->marks[h].invalid = 0;
				hseq = -hseq;
			    }
			}

			if (!form->target)
			    form->target = buf->baseTarget;
			if (a_textarea &&
			    parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,
						&textareanumber)) {
			    if (textareanumber >= max_textarea) {
				max_textarea = 2 * textareanumber;
				textarea_str = New_Reuse(Str, textarea_str,
							 max_textarea);
				a_textarea = New_Reuse(Anchor *, a_textarea,
						       max_textarea);
			    }
			}
#ifdef MENU_SELECT
			if (a_select &&
			    parsedtag_get_value(tag, ATTR_SELECTNUMBER,
						&selectnumber)) {
			    if (selectnumber >= max_select) {
				max_select = 2 * selectnumber;
				select_option = New_Reuse(FormSelectOption,
							  select_option,
							  max_select);
				a_select = New_Reuse(Anchor *, a_select,
						     max_select);
			    }
			}
#endif
			a_form =
			    registerForm(buf, form, tag, currentLn(buf), pos);
			if (a_textarea && textareanumber >= 0)
			    a_textarea[textareanumber] = a_form;
#ifdef MENU_SELECT
			if (a_select && selectnumber >= 0)
			    a_select[selectnumber] = a_form;
#endif
			if (a_form) {
			    a_form->hseq = hseq - 1;
			    a_form->y = currentLn(buf) - top;
			    a_form->rows = 1 + top + bottom;
			    if (!parsedtag_exists(tag, ATTR_NO_EFFECT))
				effect |= PE_FORM;
			    break;
			}
		    }
		case HTML_N_INPUT_ALT:
		    effect &= ~PE_FORM;
		    if (a_form) {
			a_form->end.line = currentLn(buf);
			a_form->end.pos = pos;
			if (a_form->start.line == a_form->end.line &&
			    a_form->start.pos == a_form->end.pos)
			    a_form->hseq = -1;
		    }
		    a_form = NULL;
		    break;
		case HTML_MAP:
		    if (parsedtag_get_value(tag, ATTR_NAME, &p)) {
			MapList *m = New(MapList);
			m->name = Strnew_charp(p);
			m->area = newGeneralList();
			m->next = buf->maplist;
			buf->maplist = m;
		    }
		    break;
		case HTML_N_MAP:
		    /* nothing to do */
		    break;
		case HTML_AREA:
		    if (buf->maplist == NULL)	/* outside of <map>..</map> */
			break;
		    if (parsedtag_get_value(tag, ATTR_HREF, &p)) {
			MapArea *a;
			p = url_encode(remove_space(p), base,
				       buf->document_charset);
			t = NULL;
			parsedtag_get_value(tag, ATTR_TARGET, &t);
			q = """";
			parsedtag_get_value(tag, ATTR_ALT, &q);
			r = NULL;
			s = NULL;
#ifdef USE_IMAGE
			parsedtag_get_value(tag, ATTR_SHAPE, &r);
			parsedtag_get_value(tag, ATTR_COORDS, &s);
#endif
			a = newMapArea(p, t, q, r, s);
			pushValue(buf->maplist->area, (void *)a);
		    }
		    break;
		case HTML_FRAMESET:
		    frameset_sp++;
		    if (frameset_sp >= FRAMESTACK_SIZE)
			break;
		    frameset_s[frameset_sp] = newFrameSet(tag);
		    if (frameset_s[frameset_sp] == NULL)
			break;
		    if (frameset_sp == 0) {
			if (buf->frameset == NULL) {
			    buf->frameset = frameset_s[frameset_sp];
			}
			else
			    pushFrameTree(&(buf->frameQ),
					  frameset_s[frameset_sp], NULL);
		    }
		    else
			addFrameSetElement(frameset_s[frameset_sp - 1],
					   *(union frameset_element *)
					   &frameset_s[frameset_sp]);
		    break;
		case HTML_N_FRAMESET:
		    if (frameset_sp >= 0)
			frameset_sp--;
		    break;
		case HTML_FRAME:
		    if (frameset_sp >= 0 && frameset_sp < FRAMESTACK_SIZE) {
			union frameset_element element;

			element.body = newFrame(tag, buf);
			addFrameSetElement(frameset_s[frameset_sp], element);
		    }
		    break;
		case HTML_BASE:
		    if (parsedtag_get_value(tag, ATTR_HREF, &p)) {
			p = url_encode(remove_space(p), NULL,
				       buf->document_charset);
			if (!buf->baseURL)
			    buf->baseURL = New(ParsedURL);
			parseURL(p, buf->baseURL, NULL);
#if defined(USE_M17N) || defined(USE_IMAGE)
			base = buf->baseURL;
#endif
		    }
		    if (parsedtag_get_value(tag, ATTR_TARGET, &p))
			buf->baseTarget =
			    url_quote_conv(p, buf->document_charset);
		    break;
		case HTML_META:
		    p = q = NULL;
		    parsedtag_get_value(tag, ATTR_HTTP_EQUIV, &p);
		    parsedtag_get_value(tag, ATTR_CONTENT, &q);
		    if (p && q && !strcasecmp(p, ""refresh"") && MetaRefresh) {
			Str tmp = NULL;
			int refresh_interval = getMetaRefreshParam(q, &tmp);
#ifdef USE_ALARM
			if (tmp) {
			    p = url_encode(remove_space(tmp->ptr), base,
					   buf->document_charset);
			    buf->event = setAlarmEvent(buf->event,
						       refresh_interval,
						       AL_IMPLICIT_ONCE,
						       FUNCNAME_gorURL, p);
			}
			else if (refresh_interval > 0)
			    buf->event = setAlarmEvent(buf->event,
						       refresh_interval,
						       AL_IMPLICIT,
						       FUNCNAME_reload, NULL);
#else
			if (tmp && refresh_interval == 0) {
			    p = url_encode(remove_space(tmp->ptr), base,
					   buf->document_charset);
			    pushEvent(FUNCNAME_gorURL, p);
			}
#endif
		    }
		    break;
		case HTML_INTERNAL:
		    internal = HTML_INTERNAL;
		    break;
		case HTML_N_INTERNAL:
		    internal = HTML_N_INTERNAL;
		    break;
		case HTML_FORM_INT:
		    if (parsedtag_get_value(tag, ATTR_FID, &form_id))
			process_form_int(tag, form_id);
		    break;
		case HTML_TEXTAREA_INT:
		    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER,
					    &n_textarea)
			&& n_textarea >= 0 && n_textarea < max_textarea) {
			textarea_str[n_textarea] = Strnew();
		    }
		    else
			n_textarea = -1;
		    break;
		case HTML_N_TEXTAREA_INT:
		    if (n_textarea >= 0) {
			FormItemList *item =
			    (FormItemList *)a_textarea[n_textarea]->url;
			item->init_value = item->value =
			    textarea_str[n_textarea];
		    }
		    break;
#ifdef MENU_SELECT
		case HTML_SELECT_INT:
		    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &n_select)
			&& n_select >= 0 && n_select < max_select) {
			select_option[n_select].first = NULL;
			select_option[n_select].last = NULL;
		    }
		    else
			n_select = -1;
		    break;
		case HTML_N_SELECT_INT:
		    if (n_select >= 0) {
			FormItemList *item =
			    (FormItemList *)a_select[n_select]->url;
			item->select_option = select_option[n_select].first;
			chooseSelectOption(item, item->select_option);
			item->init_selected = item->selected;
			item->init_value = item->value;
			item->init_label = item->label;
		    }
		    break;
		case HTML_OPTION_INT:
		    if (n_select >= 0) {
			int selected;
			q = """";
			parsedtag_get_value(tag, ATTR_LABEL, &q);
			p = q;
			parsedtag_get_value(tag, ATTR_VALUE, &p);
			selected = parsedtag_exists(tag, ATTR_SELECTED);
			addSelectOption(&select_option[n_select],
					Strnew_charp(p), Strnew_charp(q),
					selected);
		    }
		    break;
#endif
		case HTML_TITLE_ALT:
		    if (parsedtag_get_value(tag, ATTR_TITLE, &p))
			buf->buffername = html_unquote(p);
		    break;
		case HTML_SYMBOL:
		    effect |= PC_SYMBOL;
		    if (parsedtag_get_value(tag, ATTR_TYPE, &p))
			symbol = (char)atoi(p);
		    break;
		case HTML_N_SYMBOL:
		    effect &= ~PC_SYMBOL;
		    break;
		}
#ifdef	ID_EXT
		id = NULL;
		if (parsedtag_get_value(tag, ATTR_ID, &id)) {
		    id = url_quote_conv(id, name_charset);
		    registerName(buf, id, currentLn(buf), pos);
		}
		if (renderFrameSet &&
		    parsedtag_get_value(tag, ATTR_FRAMENAME, &p)) {
		    p = url_quote_conv(p, buf->document_charset);
		    if (!idFrame || strcmp(idFrame->body->name, p)) {
			idFrame = search_frame(renderFrameSet, p);
			if (idFrame && idFrame->body->attr != F_BODY)
			    idFrame = NULL;
		    }
		}
		if (id && idFrame)
		    idFrame->body->nameList =
			putAnchor(idFrame->body->nameList, id, NULL,
				  (Anchor **)NULL, NULL, NULL, '\0',
				  currentLn(buf), pos);
#endif				/* ID_EXT */
	    }
	}
	/* end of processing for one line */
	if (!internal)
	    addnewline(buf, outc, outp, NULL, pos, -1, nlines);
	if (internal == HTML_N_INTERNAL)
	    internal = 0;
	if (str != endp) {
	    line = Strsubstr(line, str - line->ptr, endp - str);
	    goto proc_again;
	}
    }
#ifdef DEBUG
    if (w3m_debug)
	fclose(debug);
#endif
    for (form_id = 1; form_id <= form_max; form_id++)
	if (forms[form_id])
	    forms[form_id]->next = forms[form_id - 1];
    buf->formlist = (form_max >= 0) ? forms[form_max] : NULL;
    if (n_textarea)
	addMultirowsForm(buf, buf->formitem);
#ifdef USE_IMAGE
    addMultirowsImg(buf, buf->img);
#endif
}","static void
HTMLlineproc2body(Buffer *VAR_0, Str (*VAR_1) (), int VAR_2)
{
    static char *VAR_3 = NULL;
    static Lineprop *VAR_4 = NULL;
    static int VAR_5 = 0;
    Anchor *VAR_6 = NULL, *VAR_7 = NULL, *VAR_8 = NULL;
    char *VAR_9, *VAR_10, *VAR_11, *VAR_12, *VAR_13, *VAR_14;
    Lineprop VAR_15, VAR_16, VAR_17;
    int VAR_18;
    int VAR_19;
#ifdef VAR_20
    FILE *VAR_21 = NULL;
#endif
    struct frameset *VAR_22[VAR_23];
    int VAR_24 = -1;
    union frameset_element *VAR_25 = NULL;
    char *VAR_26 = NULL;
    int VAR_27, VAR_28;
    Str VAR_29;
    char *VAR_30;
    char VAR_31 = '\0';
    int VAR_32 = 0;
    Anchor **VAR_33 = NULL;
#ifdef VAR_34
    Anchor **VAR_35 = NULL;
#endif
#if defined(VAR_36) || defined(VAR_37)
    ParsedURL *VAR_38 = baseURL(VAR_0);
#endif
#ifdef VAR_36
    wc_ces VAR_39 = url_to_charset(NULL, &VAR_0->currentURL,
					 VAR_0->document_charset);
#endif

    if (VAR_5 == 0) {
	VAR_5 = VAR_40;
	VAR_3 = NewAtom_N(char, VAR_5);
	VAR_4 = NewAtom_N(Lineprop, VAR_5);
    }

    VAR_41 = -1;
    if (!VAR_42) {	/* COMMENT_0 */
	VAR_42 = VAR_43;
	VAR_44 = New_N(Str, VAR_42);
	VAR_33 = New_N(Anchor *, VAR_42);
    }
#ifdef VAR_34
    VAR_45 = -1;
    if (!VAR_46) {		/* COMMENT_0 */
	VAR_46 = VAR_47;
	VAR_48 = New_N(VAR_49, VAR_46);
	VAR_35 = New_N(Anchor *, VAR_46);
    }
#endif

#ifdef VAR_20
    if (VAR_50)
	VAR_21 = fopen(""zzzerr"", ""a"");
#endif

    VAR_16 = 0;
    VAR_17 = 0;
    VAR_19 = 0;
    while ((VAR_29 = VAR_1()) != NULL) {
#ifdef VAR_20
	if (VAR_50) {
	    Strfputs(VAR_29, VAR_21);
	    fputc('\n', VAR_21);
	}
#endif
	if (VAR_41 >= 0 && *(VAR_29->ptr) != '<') {	/* COMMENT_0 */
	    Strcat(VAR_44[VAR_41], VAR_29);
	    continue;
	}
      proc_again:
	if (++VAR_19 == VAR_2)
	    break;
	VAR_18 = 0;
#ifdef VAR_51
	Strremovetrailingspaces(VAR_29);
#endif
	VAR_14 = VAR_29->ptr;
	VAR_30 = VAR_14 + VAR_29->length;
	while (VAR_14 < VAR_30) {
	    VAR_52;
	    VAR_15 = get_mctype(VAR_14);
	    if ((VAR_16 | ex_efct(VAR_17)) & VAR_53 && *VAR_14 != '<') {
#ifdef VAR_36
		char **VAR_0 = set_symbol(VAR_54);
		int VAR_55;

		VAR_9 = VAR_0[(int)VAR_31];
		VAR_55 = get_mclen(VAR_9);
		VAR_15 = get_mctype(VAR_9);
		PPUSH(VAR_15 | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
		if (--VAR_55) {
		    VAR_15 = (VAR_15 & ~VAR_56) | VAR_57;
		    while (VAR_55--) {
			VAR_52;
			PPUSH(VAR_15 | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
		    }
		}
#else
		PPUSH(VAR_58 | VAR_16 | ex_efct(VAR_17), VAR_59 + VAR_31);
#endif
		VAR_14 += VAR_60;
	    }
#ifdef VAR_36
	    else if (mode == VAR_61 || mode == VAR_62) {
#else
	    else if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
		PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
		VAR_14++;
	    }
#ifdef VAR_36
	    else if (mode & VAR_63) {
		PPUSH(VAR_58 | VAR_16 | ex_efct(VAR_17), ' ');
		VAR_14 += get_mclen(VAR_14);
	    }
#endif
	    else if (*VAR_14 != '<' && *VAR_14 != '&') {
#ifdef VAR_36
		int VAR_55 = get_mclen(VAR_14);
#endif
		PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_14++));
#ifdef VAR_36
		if (--VAR_55) {
		    mode = (mode & ~VAR_56) | VAR_57;
		    while (VAR_55--) {
			VAR_52;
			PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_14++));
		    }
		}
#endif
	    }
	    else if (*str == '&') {
		/* COMMENT_1 */
                        
     
		VAR_9 = getescapecmd(&str);
		while (*VAR_9) {
		    VAR_52;
		    mode = get_mctype((unsigned char *)VAR_9);
#ifdef VAR_36
		    if (mode == VAR_61 || mode == VAR_62) {
#else
		    if (mode == PC_CTRL || IS_INTSPACE(*str)) {
#endif
			PPUSH(PC_ASCII | effect | ex_efct(ex_effect), ' ');
			VAR_9++;
		    }
#ifdef VAR_36
		    else if (mode & VAR_63) {
			PPUSH(VAR_58 | VAR_16 | ex_efct(VAR_17), ' ');
			VAR_9 += get_mclen(VAR_9);
		    }
#endif
		    else {
#ifdef VAR_36
			int VAR_55 = get_mclen(VAR_9);
#endif
			PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
#ifdef VAR_36
			if (--VAR_55) {
			    mode = (mode & ~VAR_56) | VAR_57;
			    while (VAR_55--) {
				VAR_52;
				PPUSH(mode | VAR_16 | ex_efct(VAR_17), *(VAR_9++));
			    }
			}
#endif
		    }
		}
	    }
	    else {
		/* COMMENT_4 */
		struct parsed_tag *VAR_64;
		if (!(VAR_64 = parse_tag(&str, TRUE)))
		    continue;
		switch (VAR_64->tagid) {
		case VAR_65:
		    VAR_16 |= VAR_66;
		    break;
		case VAR_67:
		    VAR_16 &= ~VAR_66;
		    break;
		case VAR_68:
		    VAR_17 |= VAR_69;
		    break;
		case VAR_70:
		    VAR_17 &= ~VAR_69;
		    break;
		case VAR_71:
		    VAR_17 |= VAR_72;
		    break;
		case VAR_73:
		    VAR_17 &= ~VAR_72;
		    break;
		case VAR_74:
		    VAR_16 |= VAR_75;
		    break;
		case VAR_76:
		    VAR_16 &= ~VAR_75;
		    break;
		case VAR_77:
		    VAR_17 |= VAR_78;
		    break;
		case VAR_79:
		    VAR_17 &= ~VAR_78;
		    break;
		case VAR_80:
		    if (VAR_81 &&
			parsedtag_get_value(VAR_64, VAR_82, &VAR_9)) {
			VAR_9 = url_quote_conv(VAR_9, VAR_0->document_charset);
			if (!VAR_25 || strcmp(VAR_25->body->name, VAR_9)) {
			    VAR_25 = search_frame(VAR_81, VAR_9);
			    if (VAR_25 && VAR_25->body->attr != VAR_83)
				VAR_25 = NULL;
			}
		    }
		    VAR_9 = VAR_11 = VAR_12 = NULL;
		    VAR_10 = VAR_0->baseTarget;
		    VAR_13 = """";
		    VAR_27 = 0;
		    VAR_26 = NULL;
		    if (parsedtag_get_value(VAR_64, VAR_84, &VAR_26)) {
			VAR_26 = url_quote_conv(VAR_26, VAR_39);
			registerName(VAR_0, VAR_26, currentLn(VAR_0), VAR_18);
		    }
		    if (parsedtag_get_value(VAR_64, VAR_85, &VAR_9))
			VAR_9 = url_encode(remove_space(VAR_9), VAR_38,
				       VAR_0->document_charset);
		    if (parsedtag_get_value(VAR_64, VAR_86, &VAR_10))
			VAR_10 = url_quote_conv(VAR_10, VAR_0->document_charset);
		    if (parsedtag_get_value(VAR_64, VAR_87, &VAR_11))
			VAR_11 = url_encode(VAR_11, VAR_38,
				       VAR_0->document_charset);
		    parsedtag_get_value(VAR_64, VAR_88, &VAR_12);
		    parsedtag_get_value(VAR_64, VAR_89, &VAR_13);
		    parsedtag_get_value(VAR_64, VAR_90, &VAR_27);
		    if (VAR_27 > 0)
			VAR_0->hmarklist =
			    putHmarker(VAR_0->hmarklist, currentLn(VAR_0),
				       VAR_18, VAR_27 - 1);
		    else if (VAR_27 < 0) {
			int VAR_91 = -VAR_27 - 1;
			if (VAR_0->hmarklist &&
			    VAR_91 < VAR_0->hmarklist->nmark &&
			    VAR_0->hmarklist->marks[VAR_91].invalid) {
			    VAR_0->hmarklist->marks[VAR_91].pos = VAR_18;
			    VAR_0->hmarklist->marks[VAR_91].line = currentLn(VAR_0);
			    VAR_0->hmarklist->marks[VAR_91].invalid = 0;
			    VAR_27 = -VAR_27;
			}
		    }
		    if (VAR_26 && VAR_25)
			VAR_25->body->nameList =
			    putAnchor(VAR_25->body->nameList, VAR_26, NULL,
				      (Anchor **)NULL, NULL, NULL, '\0',
				      currentLn(VAR_0), VAR_18);
		    if (VAR_9) {
			VAR_16 |= VAR_92;
			VAR_6 = registerHref(VAR_0, VAR_9, VAR_10, VAR_11, VAR_12,
					      *VAR_13, currentLn(VAR_0), VAR_18);
			VAR_6->hseq = ((VAR_27 > 0) ? VAR_27 : -VAR_27) - 1;
			VAR_6->slave = (VAR_27 > 0) ? FALSE : TRUE;
		    }
		    break;
		case VAR_93:
		    VAR_16 &= ~VAR_92;
		    if (VAR_6) {
			VAR_6->end.line = currentLn(VAR_0);
			VAR_6->end.pos = VAR_18;
			if (VAR_6->start.line == VAR_6->end.line &&
			    VAR_6->start.pos == VAR_6->end.pos) {
			    if (VAR_0->hmarklist &&
				VAR_6->hseq < VAR_0->hmarklist->nmark)
				VAR_0->hmarklist->marks[VAR_6->hseq].invalid = 1;
			    VAR_6->hseq = -1;
			}
			VAR_6 = NULL;
		    }
		    break;

		case VAR_94:
		    addLink(VAR_0, VAR_64);
		    break;

		case VAR_95:
		    if (parsedtag_get_value(VAR_64, VAR_96, &VAR_9)) {
#ifdef VAR_37
			int VAR_97 = -1, VAR_91 = -1, VAR_98 = 0, VAR_99 = 0;
			int VAR_100 = 0, VAR_101 = 0, VAR_102 = 0, VAR_103 = 0;
			parsedtag_get_value(VAR_64, VAR_90, &VAR_98);
			parsedtag_get_value(VAR_64, VAR_104, &VAR_97);
			parsedtag_get_value(VAR_64, VAR_105, &VAR_91);
			parsedtag_get_value(VAR_64, VAR_106, &VAR_100);
			parsedtag_get_value(VAR_64, VAR_107, &VAR_101);
			parsedtag_get_value(VAR_64, VAR_108, &VAR_102);
			parsedtag_get_value(VAR_64, VAR_109, &VAR_103);
			if (parsedtag_exists(VAR_64, VAR_110))
			    VAR_99 = 1;
			VAR_10 = NULL;
			parsedtag_get_value(VAR_64, VAR_111, &VAR_10);
			if (VAR_98 > 0) {
			    VAR_0->imarklist = putHmarker(VAR_0->imarklist,
							currentLn(VAR_0), VAR_18,
							VAR_98 - 1);
			}
#endif
			VAR_12 = NULL;
			parsedtag_get_value(VAR_64, VAR_88, &VAR_12);
			VAR_9 = url_quote_conv(remove_space(VAR_9),
					   VAR_0->document_charset);
			VAR_7 = registerImg(VAR_0, VAR_9, VAR_12, currentLn(VAR_0), VAR_18);
#ifdef VAR_37
			VAR_7->hseq = VAR_98;
			VAR_7->image = NULL;
			if (VAR_98 > 0) {
			    ParsedURL VAR_112;
			    Image *VAR_113;

			    parseURL2(VAR_7->url, &VAR_112, VAR_38);
			    VAR_7->image = VAR_113 = New(Image);
			    VAR_113->url = parsedURL2Str(&VAR_112)->ptr;
			    if (!uncompressed_file_type(VAR_112.file, &VAR_113->ext))
				VAR_113->ext = filename_extension(VAR_112.file, TRUE);
			    VAR_113->cache = NULL;
			    VAR_113->width =
				(VAR_97 > VAR_114) ? VAR_114 : VAR_97;
			    VAR_113->height =
				(VAR_91 > VAR_114) ? VAR_114 : VAR_91;
			    VAR_113->xoffset = VAR_100;
			    VAR_113->yoffset = VAR_101;
			    VAR_113->y = currentLn(VAR_0) - VAR_102;
			    if (VAR_113->xoffset < 0 && VAR_18 == 0)
				VAR_113->xoffset = 0;
			    if (VAR_113->yoffset < 0 && VAR_113->y == 1)
				VAR_113->yoffset = 0;
			    VAR_113->rows = 1 + VAR_102 + VAR_103;
			    VAR_113->map = VAR_10;
			    VAR_113->ismap = VAR_99;
			    VAR_113->touch = 0;
			    VAR_113->cache = getImage(VAR_113, VAR_38,
						    VAR_115);
			}
			else if (VAR_98 < 0) {
			    BufferPoint *VAR_116 = VAR_0->imarklist->marks - VAR_98 - 1;
			    Anchor *VAR_117 = retrieveAnchor(VAR_0->img,
						       VAR_116->line, VAR_116->pos);
			    if (VAR_117) {
				VAR_7->url = VAR_117->url;
				VAR_7->image = VAR_117->image;
			    }
			}
#endif
		    }
		    VAR_16 |= VAR_118;
		    break;
		case VAR_119:
		    VAR_16 &= ~VAR_118;
		    if (VAR_7) {
			VAR_7->end.line = currentLn(VAR_0);
			VAR_7->end.pos = VAR_18;
		    }
		    VAR_7 = NULL;
		    break;
		case VAR_120:
		    {
			FormList *VAR_121;
			int VAR_102 = 0, VAR_103 = 0;
			int VAR_122 = -1;
#ifdef VAR_34
			int VAR_123 = -1;
#endif
			VAR_27 = 0;
			VAR_28 = -1;

			parsedtag_get_value(VAR_64, VAR_90, &VAR_27);
			parsedtag_get_value(VAR_64, VAR_124, &VAR_28);
			parsedtag_get_value(VAR_64, VAR_108, &VAR_102);
			parsedtag_get_value(VAR_64, VAR_109, &VAR_103);
			if (VAR_28 < 0 || VAR_28 > VAR_125 || VAR_126 == NULL)
			    break;	/* COMMENT_5 */
			VAR_121 = VAR_126[VAR_28];
			if (VAR_27 > 0) {
			    int VAR_127 = VAR_18;
			    if (*str == '[')
				VAR_127++;
			    VAR_0->hmarklist =
				putHmarker(VAR_0->hmarklist, currentLn(VAR_0),
					   VAR_127, VAR_27 - 1);
			}
			else if (VAR_27 < 0) {
			    int VAR_91 = -VAR_27 - 1;
			    int VAR_127 = VAR_18;
			    if (*str == '[')
				VAR_127++;
			    if (VAR_0->hmarklist &&
				VAR_91 < VAR_0->hmarklist->nmark &&
				VAR_0->hmarklist->marks[VAR_91].invalid) {
				VAR_0->hmarklist->marks[VAR_91].pos = VAR_127;
				VAR_0->hmarklist->marks[VAR_91].line = currentLn(VAR_0);
				VAR_0->hmarklist->marks[VAR_91].invalid = 0;
				VAR_27 = -VAR_27;
			    }
			}

			if (!VAR_121->target)
			    VAR_121->target = VAR_0->baseTarget;
			if (VAR_33 &&
			    parsedtag_get_value(VAR_64, VAR_128,
						&VAR_122)) {
			    if (VAR_122 >= VAR_42) {
				VAR_42 = 2 * VAR_122;
				VAR_44 = New_Reuse(Str, VAR_44,
							 VAR_42);
				VAR_33 = New_Reuse(Anchor *, VAR_33,
						       VAR_42);
			    }
			}
#ifdef VAR_34
			if (VAR_35 &&
			    parsedtag_get_value(VAR_64, VAR_129,
						&VAR_123)) {
			    if (VAR_123 >= VAR_46) {
				VAR_46 = 2 * VAR_123;
				VAR_48 = New_Reuse(VAR_49,
							  VAR_48,
							  VAR_46);
				VAR_35 = New_Reuse(Anchor *, VAR_35,
						     VAR_46);
			    }
			}
#endif
			VAR_8 =
			    registerForm(VAR_0, VAR_121, VAR_64, currentLn(VAR_0), VAR_18);
			if (VAR_33 && VAR_122 >= 0)
			    VAR_33[VAR_122] = VAR_8;
#ifdef VAR_34
			if (VAR_35 && VAR_123 >= 0)
			    VAR_35[VAR_123] = VAR_8;
#endif
			if (VAR_8) {
			    VAR_8->hseq = VAR_27 - 1;
			    VAR_8->y = currentLn(VAR_0) - VAR_102;
			    VAR_8->rows = 1 + VAR_102 + VAR_103;
			    if (!parsedtag_exists(VAR_64, VAR_130))
				VAR_16 |= VAR_131;
			    break;
			}
		    }
		case VAR_132:
		    VAR_16 &= ~VAR_131;
		    if (VAR_8) {
			VAR_8->end.line = currentLn(VAR_0);
			VAR_8->end.pos = VAR_18;
			if (VAR_8->start.line == VAR_8->end.line &&
			    VAR_8->start.pos == VAR_8->end.pos)
			    VAR_8->hseq = -1;
		    }
		    VAR_8 = NULL;
		    break;
		case VAR_133:
		    if (parsedtag_get_value(VAR_64, VAR_84, &VAR_9)) {
			MapList *VAR_134 = New(MapList);
			VAR_134->name = Strnew_charp(VAR_9);
			VAR_134->area = newGeneralList();
			VAR_134->next = VAR_0->maplist;
			VAR_0->maplist = VAR_134;
		    }
		    break;
		case VAR_135:
		    /* COMMENT_6 */
		    break;
		case VAR_136:
		    if (VAR_0->maplist == NULL)	/* COMMENT_7 */
			break;
		    if (parsedtag_get_value(VAR_64, VAR_85, &VAR_9)) {
			MapArea *VAR_117;
			VAR_9 = url_encode(remove_space(VAR_9), VAR_38,
				       VAR_0->document_charset);
			VAR_13 = NULL;
			parsedtag_get_value(VAR_64, VAR_86, &VAR_13);
			VAR_10 = """";
			parsedtag_get_value(VAR_64, VAR_137, &VAR_10);
			VAR_11 = NULL;
			VAR_12 = NULL;
#ifdef VAR_37
			parsedtag_get_value(VAR_64, VAR_138, &VAR_11);
			parsedtag_get_value(VAR_64, VAR_139, &VAR_12);
#endif
			VAR_117 = newMapArea(VAR_9, VAR_13, VAR_10, VAR_11, VAR_12);
			pushValue(VAR_0->maplist->area, (void *)VAR_117);
		    }
		    break;
		case VAR_140:
		    VAR_24++;
		    if (VAR_24 >= VAR_23)
			break;
		    VAR_22[VAR_24] = newFrameSet(VAR_64);
		    if (VAR_22[VAR_24] == NULL)
			break;
		    if (VAR_24 == 0) {
			if (VAR_0->frameset == NULL) {
			    VAR_0->frameset = VAR_22[VAR_24];
			}
			else
			    pushFrameTree(&(VAR_0->frameQ),
					  VAR_22[VAR_24], NULL);
		    }
		    else
			addFrameSetElement(VAR_22[VAR_24 - 1],
					   *(union frameset_element *)
					   &VAR_22[VAR_24]);
		    break;
		case VAR_141:
		    if (VAR_24 >= 0)
			VAR_24--;
		    break;
		case VAR_142:
		    if (VAR_24 >= 0 && VAR_24 < VAR_23) {
			union frameset_element VAR_143;

			VAR_143.body = newFrame(VAR_64, VAR_0);
			addFrameSetElement(VAR_22[VAR_24], VAR_143);
		    }
		    break;
		case VAR_144:
		    if (parsedtag_get_value(VAR_64, VAR_85, &VAR_9)) {
			VAR_9 = url_encode(remove_space(VAR_9), NULL,
				       VAR_0->document_charset);
			if (!VAR_0->baseURL)
			    VAR_0->baseURL = New(ParsedURL);
			parseURL(VAR_9, VAR_0->baseURL, NULL);
#if defined(VAR_36) || defined(VAR_37)
			VAR_38 = VAR_0->baseURL;
#endif
		    }
		    if (parsedtag_get_value(VAR_64, VAR_86, &VAR_9))
			VAR_0->baseTarget =
			    url_quote_conv(VAR_9, VAR_0->document_charset);
		    break;
		case VAR_145:
		    VAR_9 = VAR_10 = NULL;
		    parsedtag_get_value(VAR_64, VAR_146, &VAR_9);
		    parsedtag_get_value(VAR_64, VAR_147, &VAR_10);
		    if (VAR_9 && VAR_10 && !strcasecmp(VAR_9, ""refresh"") && VAR_148) {
			Str VAR_149 = NULL;
			int VAR_150 = getMetaRefreshParam(VAR_10, &VAR_149);
#ifdef VAR_151
			if (VAR_149) {
			    VAR_9 = url_encode(remove_space(VAR_149->ptr), VAR_38,
					   VAR_0->document_charset);
			    VAR_0->event = setAlarmEvent(VAR_0->event,
						       VAR_150,
						       VAR_152,
						       VAR_153, VAR_9);
			}
			else if (VAR_150 > 0)
			    VAR_0->event = setAlarmEvent(VAR_0->event,
						       VAR_150,
						       VAR_154,
						       VAR_155, NULL);
#else
			if (VAR_149 && VAR_150 == 0) {
			    VAR_9 = url_encode(remove_space(VAR_149->ptr), VAR_38,
					   VAR_0->document_charset);
			    pushEvent(VAR_153, VAR_9);
			}
#endif
		    }
		    break;
		case VAR_156:
		    VAR_32 = VAR_156;
		    break;
		case VAR_157:
		    VAR_32 = VAR_157;
		    break;
		case VAR_158:
		    if (parsedtag_get_value(VAR_64, VAR_124, &VAR_28))
			process_form_int(VAR_64, VAR_28);
		    break;
		case VAR_159:
		    if (parsedtag_get_value(VAR_64, VAR_128,
					    &VAR_41)
			&& VAR_41 >= 0 && VAR_41 < VAR_42) {
			VAR_44[VAR_41] = Strnew();
		    }
		    else
			VAR_41 = -1;
		    break;
		case VAR_160:
		    if (VAR_41 >= 0) {
			FormItemList *VAR_161 =
			    (FormItemList *)VAR_33[VAR_41]->url;
			VAR_161->init_value = VAR_161->value =
			    VAR_44[VAR_41];
		    }
		    break;
#ifdef VAR_34
		case VAR_162:
		    if (parsedtag_get_value(VAR_64, VAR_129, &VAR_45)
			&& VAR_45 >= 0 && VAR_45 < VAR_46) {
			VAR_48[VAR_45].first = NULL;
			VAR_48[VAR_45].last = NULL;
		    }
		    else
			VAR_45 = -1;
		    break;
		case VAR_163:
		    if (VAR_45 >= 0) {
			FormItemList *VAR_161 =
			    (FormItemList *)VAR_35[VAR_45]->url;
			VAR_161->select_option = VAR_48[VAR_45].first;
			chooseSelectOption(VAR_161, VAR_161->select_option);
			VAR_161->init_selected = VAR_161->selected;
			VAR_161->init_value = VAR_161->value;
			VAR_161->init_label = VAR_161->label;
		    }
		    break;
		case VAR_164:
		    if (VAR_45 >= 0) {
			int VAR_165;
			VAR_10 = """";
			parsedtag_get_value(VAR_64, VAR_166, &VAR_10);
			VAR_9 = VAR_10;
			parsedtag_get_value(VAR_64, VAR_167, &VAR_9);
			VAR_165 = parsedtag_exists(VAR_64, VAR_168);
			addSelectOption(&VAR_48[VAR_45],
					Strnew_charp(VAR_9), Strnew_charp(VAR_10),
					VAR_165);
		    }
		    break;
#endif
		case VAR_169:
		    if (parsedtag_get_value(VAR_64, VAR_88, &VAR_9))
			VAR_0->buffername = html_unquote(VAR_9);
		    break;
		case VAR_170:
		    VAR_16 |= VAR_53;
		    if (parsedtag_get_value(VAR_64, VAR_171, &VAR_9))
			VAR_31 = (char)atoi(VAR_9);
		    break;
		case VAR_172:
		    VAR_16 &= ~VAR_53;
		    break;
		}
#ifdef	VAR_173
		VAR_26 = NULL;
		if (parsedtag_get_value(VAR_64, VAR_174, &VAR_26)) {
		    VAR_26 = url_quote_conv(VAR_26, VAR_39);
		    registerName(VAR_0, VAR_26, currentLn(VAR_0), VAR_18);
		}
		if (VAR_81 &&
		    parsedtag_get_value(VAR_64, VAR_82, &VAR_9)) {
		    VAR_9 = url_quote_conv(VAR_9, VAR_0->document_charset);
		    if (!VAR_25 || strcmp(VAR_25->body->name, VAR_9)) {
			VAR_25 = search_frame(VAR_81, VAR_9);
			if (VAR_25 && VAR_25->body->attr != VAR_83)
			    VAR_25 = NULL;
		    }
		}
		if (VAR_26 && VAR_25)
		    VAR_25->body->nameList =
			putAnchor(VAR_25->body->nameList, VAR_26, NULL,
				  (Anchor **)NULL, NULL, NULL, '\0',
				  currentLn(VAR_0), VAR_18);
#endif				/* COMMENT_8 */
	    }
	}
	/* COMMENT_9 */
	if (!VAR_32)
	    addnewline(VAR_0, VAR_3, VAR_4, NULL, VAR_18, -1, VAR_19);
	if (VAR_32 == VAR_157)
	    VAR_32 = 0;
	if (str != VAR_30) {
	    VAR_29 = Strsubstr(VAR_29, str - VAR_29->ptr, VAR_30 - str);
	    goto proc_again;
	}
    }
#ifdef VAR_20
    if (VAR_50)
	fclose(VAR_21);
#endif
    for (VAR_28 = 1; VAR_28 <= VAR_125; VAR_28++)
	if (VAR_126[VAR_28])
	    VAR_126[VAR_28]->next = VAR_126[VAR_28 - 1];
    VAR_0->formlist = (VAR_125 >= 0) ? VAR_126[VAR_125] : NULL;
    if (VAR_41)
	addMultirowsForm(VAR_0, VAR_0->formitem);
#ifdef VAR_37
    addMultirowsImg(VAR_0, VAR_0->img);
#endif
}",tats/w3m/3d4eeda9ec0cb91e23bab7dc260d4c515119eb4b/file.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -686,7 +686,8 @@
 	fclose(debug);
 #endif
     for (form_id = 1; form_id <= form_max; form_id++)
-	forms[form_id]->next = forms[form_id - 1];
+	if (forms[form_id])
+	    forms[form_id]->next = forms[form_id - 1];
     buf->formlist = (form_max >= 0) ? forms[form_max] : NULL;
     if (n_textarea)
 	addMultirowsForm(buf, buf->formitem);","{'deleted_lines': ['\tforms[form_id]->next = forms[form_id - 1];'], 'added_lines': ['\tif (forms[form_id])', '\t    forms[form_id]->next = forms[form_id - 1];']}",True,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,6.5,MEDIUM,1,valid,2016-08-17T13:34:40Z,1
CVE-2016-9437,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,tats/w3m,"Prevent segfault with incorrect button type

Bug-Debian: https://github.com/tats/w3m/issues/17 [CVE-2016-9437]
Origin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=67be73b03a5ad581e331ec97cb275cd8a52719ed",f59dac7e6d9f0aad961c5686fe832d95ec1e7b6c,https://github.com/tats/w3m/commit/f59dac7e6d9f0aad961c5686fe832d95ec1e7b6c,file.c,process_button,"Str
process_button(struct parsed_tag *tag)
{
Str tmp = NULL;
char *p, *q, *r, *qq = """";
int qlen, v;
if (cur_form_id < 0) {
char *s = ""<form_int method=internal action=none>"";
tmp = process_form(parse_tag(&s, TRUE));
}
if (tmp == NULL)
tmp = Strnew();
p = ""submit"";
parsedtag_get_value(tag, ATTR_TYPE, &p);
q = NULL;
parsedtag_get_value(tag, ATTR_VALUE, &q);
r = """";
parsedtag_get_value(tag, ATTR_NAME, &r);
v = formtype(p);
if (v == FORM_UNKNOWN)
return NULL;
if (!q) {
switch (v) {
case FORM_INPUT_SUBMIT:
case FORM_INPUT_BUTTON:
q = ""SUBMIT"";
break;
case FORM_INPUT_RESET:
q = ""RESET"";
break;
}
}
if (q) {
qq = html_quote(q);
qlen = strlen(q);
}
Strcat(tmp, Sprintf(""<input_alt hseq=\""%d\"" fid=\""%d\"" type=\""%s\"" ""
""name=\""%s\"" value=\""%s\"">"",
cur_hseq++, cur_form_id, html_quote(p),
html_quote(r), qq));
return tmp;
}","Str
process_button(struct parsed_tag *VAR_0)
{
Str VAR_1 = NULL;
char *VAR_2, *VAR_3, *VAR_4, *VAR_5 = """";
int VAR_6, VAR_7;
if (VAR_8 < 0) {
char *VAR_9 = ""<form_int method=internal action=none>"";
VAR_1 = process_form(parse_tag(&VAR_9, TRUE));
}
if (VAR_1 == NULL)
VAR_1 = Strnew();
VAR_2 = ""submit"";
parsedtag_get_value(VAR_0, VAR_10, &VAR_2);
VAR_3 = NULL;
parsedtag_get_value(VAR_0, VAR_11, &VAR_3);
VAR_4 = """";
parsedtag_get_value(VAR_0, VAR_12, &VAR_4);
VAR_7 = formtype(VAR_2);
if (VAR_7 == VAR_13)
return NULL;
if (!VAR_3) {
switch (VAR_7) {
case VAR_14:
case VAR_15:
VAR_3 = ""SUBMIT"";
break;
case VAR_16:
VAR_3 = ""RESET"";
break;
}
}
if (VAR_3) {
VAR_5 = html_quote(VAR_3);
VAR_6 = strlen(VAR_3);
}
Strcat(VAR_1, Sprintf(""<input_alt hseq=\""%d\"" fid=\""%d\"" type=\""%s\"" ""
""name=\""%s\"" value=\""%s\"">"",
VAR_17++, VAR_8, html_quote(VAR_2),
html_quote(VAR_4), VAR_5));
return VAR_1;
}",tats/w3m/f59dac7e6d9f0aad961c5686fe832d95ec1e7b6c/file.c/vul/before/0.json,"Str
process_button(struct parsed_tag *tag)
{
    Str tmp = NULL;
    char *p, *q, *r, *qq = """";
    int qlen, v;

    if (cur_form_id < 0) {
       char *s = ""<form_int method=internal action=none>"";
       tmp = process_form(parse_tag(&s, TRUE));
    }
    if (tmp == NULL)
       tmp = Strnew();

    p = ""submit"";
    parsedtag_get_value(tag, ATTR_TYPE, &p);
    q = NULL;
    parsedtag_get_value(tag, ATTR_VALUE, &q);
    r = """";
    parsedtag_get_value(tag, ATTR_NAME, &r);

    v = formtype(p);
    if (v == FORM_UNKNOWN)
       return NULL;

    switch (v) {
    case FORM_INPUT_SUBMIT:
    case FORM_INPUT_BUTTON:
    case FORM_INPUT_RESET:
	break;
    default:
	p = ""submit"";
	v = FORM_INPUT_SUBMIT;
	break;
    }

    if (!q) {
       switch (v) {
       case FORM_INPUT_SUBMIT:
       case FORM_INPUT_BUTTON:
           q = ""SUBMIT"";
           break;
       case FORM_INPUT_RESET:
           q = ""RESET"";
           break;
       }
    }
    if (q) {
       qq = html_quote(q);
       qlen = strlen(q);
    }

    //    Strcat_charp(tmp, ""<pre_int>"");
    Strcat(tmp, Sprintf(""<input_alt hseq=\""%d\"" fid=\""%d\"" type=\""%s\"" ""
                       ""name=\""%s\"" value=\""%s\"">"",
                       cur_hseq++, cur_form_id, html_quote(p),
                       html_quote(r), qq));
    return tmp;
}","Str
process_button(struct parsed_tag *VAR_0)
{
    Str VAR_1 = NULL;
    char *VAR_2, *VAR_3, *VAR_4, *VAR_5 = """";
    int VAR_6, VAR_7;

    if (VAR_8 < 0) {
       char *VAR_9 = ""<form_int method=internal action=none>"";
       VAR_1 = process_form(parse_tag(&VAR_9, TRUE));
    }
    if (VAR_1 == NULL)
       VAR_1 = Strnew();

    VAR_2 = ""submit"";
    parsedtag_get_value(VAR_0, VAR_10, &VAR_2);
    VAR_3 = NULL;
    parsedtag_get_value(VAR_0, VAR_11, &VAR_3);
    VAR_4 = """";
    parsedtag_get_value(VAR_0, VAR_12, &VAR_4);

    VAR_7 = formtype(VAR_2);
    if (VAR_7 == VAR_13)
       return NULL;

    switch (VAR_7) {
    case VAR_14:
    case VAR_15:
    case VAR_16:
	break;
    default:
	VAR_2 = ""submit"";
	VAR_7 = VAR_14;
	break;
    }

    if (!VAR_3) {
       switch (VAR_7) {
       case VAR_14:
       case VAR_15:
           VAR_3 = ""SUBMIT"";
           break;
       case VAR_16:
           VAR_3 = ""RESET"";
           break;
       }
    }
    if (VAR_3) {
       VAR_5 = html_quote(VAR_3);
       VAR_6 = strlen(VAR_3);
    }

    /* COMMENT_0 */
    Strcat(VAR_1, Sprintf(""<input_alt hseq=\""%d\"" fid=\""%d\"" type=\""%s\"" ""
                       ""name=\""%s\"" value=\""%s\"">"",
                       VAR_17++, VAR_8, html_quote(VAR_2),
                       html_quote(VAR_4), VAR_5));
    return VAR_1;
}",tats/w3m/f59dac7e6d9f0aad961c5686fe832d95ec1e7b6c/file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,6 +23,17 @@
     if (v == FORM_UNKNOWN)
        return NULL;
 
+    switch (v) {
+    case FORM_INPUT_SUBMIT:
+    case FORM_INPUT_BUTTON:
+    case FORM_INPUT_RESET:
+	break;
+    default:
+	p = ""submit"";
+	v = FORM_INPUT_SUBMIT;
+	break;
+    }
+
     if (!q) {
        switch (v) {
        case FORM_INPUT_SUBMIT:","{'deleted_lines': [], 'added_lines': ['    switch (v) {', '    case FORM_INPUT_SUBMIT:', '    case FORM_INPUT_BUTTON:', '    case FORM_INPUT_RESET:', '\tbreak;', '    default:', '\tp = ""submit"";', '\tv = FORM_INPUT_SUBMIT;', '\tbreak;', '    }', '']}",True,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) and possibly memory corruption via a crafted HTML page.,6.5,MEDIUM,1,valid,2016-08-17T15:16:18Z,1
CVE-2016-7414,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,"Fix bug #72928 - Out of bound when verify signature of zip phar in phar_parse_zipfile

(cherry picked from commit 19484ab77466f99c78fc0e677f7e03da0584d6a2)",0bfb970f43acd1e81d11be1154805f86655f15d5,https://github.com/php/php-src/commit/0bfb970f43acd1e81d11be1154805f86655f15d5,ext/phar/zip.c,phar_parse_zipfile,"int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error) 
{
phar_zip_dir_end locator;
char buf[sizeof(locator) + 65536];
zend_long size;
php_uint16 i;
phar_archive_data *mydata = NULL;
phar_entry_info entry = {0};
char *p = buf, *ext, *actual_alias = NULL;
char *metadata = NULL;
size = php_stream_tell(fp);
if (size > sizeof(locator) + 65536) {
size = sizeof(locator) + 65536;
if (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {
php_stream_close(fp);
if (error) {
spprintf(error, 4096, ""phar error: unable to search for end of central directory in zip-based phar \""%s\"""", fname);
}
return FAILURE;
}
} else {
php_stream_seek(fp, 0, SEEK_SET);
}
if (!php_stream_read(fp, buf, size)) {
php_stream_close(fp);
if (error) {
spprintf(error, 4096, ""phar error: unable to read in data to search for end of central directory in zip-based phar \""%s\"""", fname);
}
return FAILURE;
}
while ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {
if ((p - buf) + sizeof(locator) <= size && !memcmp(p + 1, ""K\5\6"", 3)) {
memcpy((void *)&locator, (void *) p, sizeof(locator));
if (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {
php_stream_close(fp);
if (error) {
spprintf(error, 4096, ""phar error: split archives spanning multiple zips cannot be processed in zip-based phar \""%s\"""", fname);
}
return FAILURE;
}
if (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {
if (error) {
spprintf(error, 4096, ""phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \""%s\"""", fname);
}
php_stream_close(fp);
return FAILURE;
}
mydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));
mydata->is_persistent = PHAR_G(persist);
if (PHAR_GET_16(locator.comment_len)) {
metadata = p + sizeof(locator);
if (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {
if (error) {
spprintf(error, 4096, ""phar error: corrupt zip archive, zip file comment truncated in zip-based phar \""%s\"""", fname);
}
php_stream_close(fp);
pefree(mydata, mydata->is_persistent);
return FAILURE;
}
mydata->metadata_len = PHAR_GET_16(locator.comment_len);
if (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len)) == FAILURE) {
mydata->metadata_len = 0;
ZVAL_NEW_STR(&mydata->metadata, zend_string_init(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent));
}
} else {
ZVAL_UNDEF(&mydata->metadata);
}
goto foundit;
}
}
php_stream_close(fp);
if (error) {
spprintf(error, 4096, ""phar error: end of central directory not found in zip-based phar \""%s\"""", fname);
}
return FAILURE;
foundit:
mydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);
#ifdef PHP_WIN32
phar_unixify_path_separators(mydata->fname, fname_len);
#endif
mydata->is_zip = 1;
mydata->fname_len = fname_len;
ext = strrchr(mydata->fname, '/');
if (ext) {
mydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);
if (mydata->ext == ext) {
mydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);
}
if (mydata->ext) {
mydata->ext_len = (mydata->fname + fname_len) - mydata->ext;
}
}
php_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);
zend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),
zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);
zend_hash_init(&mydata->mounted_dirs, 5,
zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
zend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,
zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
entry.phar = mydata;
entry.is_zip = 1;
entry.fp_type = PHAR_FP;
entry.is_persistent = mydata->is_persistent;
#define PHAR_ZIP_FAIL_FREE(errmsg, save) \
zend_hash_destroy(&mydata->manifest); \
mydata->manifest.u.flags = 0; \
zend_hash_destroy(&mydata->mounted_dirs); \
mydata->mounted_dirs.u.flags = 0; \
zend_hash_destroy(&mydata->virtual_dirs); \
mydata->virtual_dirs.u.flags = 0; \
php_stream_close(fp); \
zval_dtor(&mydata->metadata); \
if (mydata->signature) { \
efree(mydata->signature); \
} \
if (error) { \
spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
} \
pefree(mydata->fname, mydata->is_persistent); \
if (mydata->alias) { \
pefree(mydata->alias, mydata->is_persistent); \
} \
pefree(mydata, mydata->is_persistent); \
efree(save); \
return FAILURE;
#define PHAR_ZIP_FAIL(errmsg) \
zend_hash_destroy(&mydata->manifest); \
mydata->manifest.u.flags = 0; \
zend_hash_destroy(&mydata->mounted_dirs); \
mydata->mounted_dirs.u.flags = 0; \
zend_hash_destroy(&mydata->virtual_dirs); \
mydata->virtual_dirs.u.flags = 0; \
php_stream_close(fp); \
zval_dtor(&mydata->metadata); \
if (mydata->signature) { \
efree(mydata->signature); \
} \
if (error) { \
spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
} \
pefree(mydata->fname, mydata->is_persistent); \
if (mydata->alias) { \
pefree(mydata->alias, mydata->is_persistent); \
} \
pefree(mydata, mydata->is_persistent); \
return FAILURE;
for (i = 0; i < PHAR_GET_16(locator.count); ++i) {
phar_zip_central_dir_file zipentry;
zend_off_t beforeus = php_stream_tell(fp);
if (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {
PHAR_ZIP_FAIL(""unable to read central directory entry, truncated"");
}
if (memcmp(""PK\1\2"", zipentry.signature, 4)) {
PHAR_ZIP_FAIL(""corrupted central directory entry, no magic signature"");
}
if (entry.is_persistent) {
entry.manifest_pos = i;
}
entry.compressed_filesize = PHAR_GET_32(zipentry.compsize);
entry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);
entry.crc32 = PHAR_GET_32(zipentry.crc32);
entry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);
entry.flags = PHAR_ENT_PERM_DEF_FILE;
entry.header_offset = PHAR_GET_32(zipentry.offset);
entry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +
PHAR_GET_16(zipentry.extra_len);
if (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {
PHAR_ZIP_FAIL(""Cannot process encrypted zip files"");
}
if (!PHAR_GET_16(zipentry.filename_len)) {
PHAR_ZIP_FAIL(""Cannot process zips created from stdin (zero-length filename)"");
}
entry.filename_len = PHAR_GET_16(zipentry.filename_len);
entry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);
if (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unable to read in filename from central directory, truncated"");
}
entry.filename[entry.filename_len] = '\0';
if (entry.filename[entry.filename_len - 1] == '/') {
entry.is_dir = 1;
if(entry.filename_len > 1) {
entry.filename_len--;
}
entry.flags |= PHAR_ENT_PERM_DEF_DIR;
} else {
entry.is_dir = 0;
}
if (entry.filename_len == sizeof("".phar/signature.bin"")-1 && !strncmp(entry.filename, "".phar/signature.bin"", sizeof("".phar/signature.bin"")-1)) {
size_t read;
php_stream *sigfile;
zend_off_t now;
char *sig;
now = php_stream_tell(fp);
pefree(entry.filename, entry.is_persistent);
sigfile = php_stream_fopen_tmpfile();
if (!sigfile) {
PHAR_ZIP_FAIL(""couldn't open temporary file"");
}
php_stream_seek(fp, 0, SEEK_SET);
php_stream_copy_to_stream_ex(fp, sigfile, entry.header_offset, NULL);
php_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);
php_stream_copy_to_stream_ex(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);
if (metadata) {
php_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));
}
php_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);
sig = (char *) emalloc(entry.uncompressed_filesize);
read = php_stream_read(fp, sig, entry.uncompressed_filesize);
if (read != entry.uncompressed_filesize) {
php_stream_close(sigfile);
efree(sig);
PHAR_ZIP_FAIL(""signature cannot be read"");
}
mydata->sig_flags = PHAR_GET_32(sig);
if (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error)) {
efree(sig);
if (error) {
char *save;
php_stream_close(sigfile);
spprintf(&save, 4096, ""signature cannot be verified: %s"", *error);
efree(*error);
PHAR_ZIP_FAIL_FREE(save, save);
} else {
php_stream_close(sigfile);
PHAR_ZIP_FAIL(""signature cannot be verified"");
}
}
php_stream_close(sigfile);
efree(sig);
if (i != PHAR_GET_16(locator.count) - 1) {
PHAR_ZIP_FAIL(""entries exist after signature, invalid phar"");
}
continue;
}
phar_add_virtual_dirs(mydata, entry.filename, entry.filename_len);
if (PHAR_GET_16(zipentry.extra_len)) {
zend_off_t loc = php_stream_tell(fp);
if (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len))) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""Unable to process extra field header for file in central directory"");
}
php_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);
}
switch (PHAR_GET_16(zipentry.compressed)) {
case PHAR_ZIP_COMP_NONE :
break;
case PHAR_ZIP_COMP_DEFLATE :
entry.flags |= PHAR_ENT_COMPRESSED_GZ;
if (!PHAR_G(has_zlib)) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""zlib extension is required"");
}
break;
case PHAR_ZIP_COMP_BZIP2 :
entry.flags |= PHAR_ENT_COMPRESSED_BZ2;
if (!PHAR_G(has_bz2)) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""bzip2 extension is required"");
}
break;
case 1 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Shrunk) used in this zip"");
case 2 :
case 3 :
case 4 :
case 5 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Reduce) used in this zip"");
case 6 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Implode) used in this zip"");
case 7 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Tokenize) used in this zip"");
case 9 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Deflate64) used in this zip"");
case 10 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip"");
case 14 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (LZMA) used in this zip"");
case 18 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (IBM TERSE) used in this zip"");
case 19 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (IBM LZ77) used in this zip"");
case 97 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (WavPack) used in this zip"");
case 98 :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (PPMd) used in this zip"");
default :
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (unknown) used in this zip"");
}
if (PHAR_GET_16(zipentry.comment_len)) {
if (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unable to read in file comment, truncated"");
}
p = buf;
entry.metadata_len = PHAR_GET_16(zipentry.comment_len);
if (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len)) == FAILURE) {
entry.metadata_len = 0;
ZVAL_NEW_STR(&entry.metadata, zend_string_init(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent));
}
} else {
ZVAL_UNDEF(&entry.metadata);
}
if (!actual_alias && entry.filename_len == sizeof("".phar/alias.txt"")-1 && !strncmp(entry.filename, "".phar/alias.txt"", sizeof("".phar/alias.txt"")-1)) {
php_stream_filter *filter;
zend_off_t saveloc;
phar_zip_file_header local;
saveloc = php_stream_tell(fp);
php_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);
if (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (cannot read local file header for alias)"");
}
if (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (local header of alias does not match central directory)"");
}
entry.offset = entry.offset_abs =
sizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);
php_stream_seek(fp, entry.offset, SEEK_SET);
fp->writepos = 0;
fp->readpos = 0;
php_stream_seek(fp, entry.offset, SEEK_SET);
fp->writepos = 0;
fp->readpos = 0;
mydata->alias_len = entry.uncompressed_filesize;
if (entry.flags & PHAR_ENT_COMPRESSED_GZ) {
filter = php_stream_filter_create(""zlib.inflate"", NULL, php_stream_is_persistent(fp));
if (!filter) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unable to decompress alias, zlib filter creation failed"");
}
php_stream_filter_append(&fp->readfilters, filter);
{
zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
if (str) {
entry.uncompressed_filesize = ZSTR_LEN(str);
actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
zend_string_release(str);
} else {
actual_alias = NULL;
entry.uncompressed_filesize = 0;
}
}
if (!entry.uncompressed_filesize || !actual_alias) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
}
php_stream_filter_flush(filter, 1);
php_stream_filter_remove(filter, 1);
} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {
filter = php_stream_filter_create(""bzip2.decompress"", NULL, php_stream_is_persistent(fp));
if (!filter) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, bzip2 filter creation failed"");
}
php_stream_filter_append(&fp->readfilters, filter);
{
zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
if (str) {
entry.uncompressed_filesize = ZSTR_LEN(str);
actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
zend_string_release(str);
} else {
actual_alias = NULL;
entry.uncompressed_filesize = 0;
}
}
if (!entry.uncompressed_filesize || !actual_alias) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
}
php_stream_filter_flush(filter, 1);
php_stream_filter_remove(filter, 1);
} else {
{
zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
if (str) {
entry.uncompressed_filesize = ZSTR_LEN(str);
actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
zend_string_release(str);
} else {
actual_alias = NULL;
entry.uncompressed_filesize = 0;
}
}
if (!entry.uncompressed_filesize || !actual_alias) {
pefree(entry.filename, entry.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
}
}
php_stream_seek(fp, saveloc, SEEK_SET);
}
phar_set_inode(&entry);
zend_hash_str_add_mem(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry, sizeof(phar_entry_info));
}
mydata->fp = fp;
if (zend_hash_str_exists(&(mydata->manifest), "".phar/stub.php"", sizeof("".phar/stub.php"")-1)) {
mydata->is_data = 0;
} else {
mydata->is_data = 1;
}
zend_hash_str_add_ptr(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len, mydata);
if (actual_alias) {
phar_archive_data *fd_ptr;
if (!phar_validate_alias(actual_alias, mydata->alias_len)) {
if (error) {
spprintf(error, 4096, ""phar error: invalid alias \""%s\"" in zip-based phar \""%s\"""", actual_alias, fname);
}
efree(actual_alias);
zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
return FAILURE;
}
mydata->is_temporary_alias = 0;
if (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len))) {
if (SUCCESS != phar_free_alias(fd_ptr, actual_alias, mydata->alias_len)) {
if (error) {
spprintf(error, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with implicit alias, alias is already in use"", fname);
}
efree(actual_alias);
zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
return FAILURE;
}
}
mydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;
if (entry.is_persistent) {
efree(actual_alias);
}
zend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);
} else {
phar_archive_data *fd_ptr;
if (alias_len) {
if (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len))) {
if (SUCCESS != phar_free_alias(fd_ptr, alias, alias_len)) {
if (error) {
spprintf(error, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with explicit alias, alias is already in use"", fname);
}
zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
return FAILURE;
}
}
zend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);
mydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);
mydata->alias_len = alias_len;
} else {
mydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);
mydata->alias_len = fname_len;
}
mydata->is_temporary_alias = 1;
}
if (pphar) {
*pphar = mydata;
}
return SUCCESS;
}","int phar_parse_zipfile(php_stream *VAR_0, char *VAR_1, int VAR_2, char *VAR_3, int VAR_4, phar_archive_data** VAR_5, char **VAR_6) 
{
phar_zip_dir_end VAR_7;
char VAR_8[sizeof(VAR_7) + 65536];
zend_long VAR_9;
php_uint16 VAR_10;
phar_archive_data *VAR_11 = NULL;
phar_entry_info VAR_12 = {0};
char *VAR_13 = VAR_8, *VAR_14, *VAR_15 = NULL;
char *VAR_16 = NULL;
VAR_9 = php_stream_tell(VAR_0);
if (VAR_9 > sizeof(VAR_7) + 65536) {
VAR_9 = sizeof(VAR_7) + 65536;
if (VAR_17 == php_stream_seek(VAR_0, -VAR_9, VAR_18)) {
php_stream_close(VAR_0);
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: unable to search for end of central directory in zip-based phar \""%s\"""", VAR_1);
}
return VAR_17;
}
} else {
php_stream_seek(VAR_0, 0, VAR_19);
}
if (!php_stream_read(VAR_0, VAR_8, VAR_9)) {
php_stream_close(VAR_0);
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: unable to read in data to search for end of central directory in zip-based phar \""%s\"""", VAR_1);
}
return VAR_17;
}
while ((VAR_13=(char *) memchr(VAR_13 + 1, 'P', (size_t) (VAR_9 - (VAR_13 + 1 - VAR_8)))) != NULL) {
if ((VAR_13 - VAR_8) + sizeof(VAR_7) <= VAR_9 && !memcmp(VAR_13 + 1, ""K\5\6"", 3)) {
memcpy((void *)&VAR_7, (void *) VAR_13, sizeof(VAR_7));
if (PHAR_GET_16(VAR_7.centraldisk) != 0 || PHAR_GET_16(VAR_7.disknumber) != 0) {
php_stream_close(VAR_0);
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: split archives spanning multiple zips cannot be processed in zip-based phar \""%s\"""", VAR_1);
}
return VAR_17;
}
if (PHAR_GET_16(VAR_7.counthere) != PHAR_GET_16(VAR_7.count)) {
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \""%s\"""", VAR_1);
}
php_stream_close(VAR_0);
return VAR_17;
}
VAR_11 = pecalloc(1, sizeof(phar_archive_data), PHAR_G(VAR_20));
VAR_11->is_persistent = PHAR_G(VAR_20);
if (PHAR_GET_16(VAR_7.comment_len)) {
VAR_16 = VAR_13 + sizeof(VAR_7);
if (PHAR_GET_16(VAR_7.comment_len) != VAR_9 - (VAR_16 - VAR_8)) {
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: corrupt zip archive, zip file comment truncated in zip-based phar \""%s\"""", VAR_1);
}
php_stream_close(VAR_0);
pefree(VAR_11, VAR_11->is_persistent);
return VAR_17;
}
VAR_11->metadata_len = PHAR_GET_16(VAR_7.comment_len);
if (phar_parse_metadata(&VAR_16, &VAR_11->metadata, PHAR_GET_16(VAR_7.comment_len)) == VAR_17) {
VAR_11->metadata_len = 0;
ZVAL_NEW_STR(&VAR_11->metadata, zend_string_init(VAR_16, PHAR_GET_16(VAR_7.comment_len), VAR_11->is_persistent));
}
} else {
ZVAL_UNDEF(&VAR_11->metadata);
}
goto foundit;
}
}
php_stream_close(VAR_0);
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: end of central directory not found in zip-based phar \""%s\"""", VAR_1);
}
return VAR_17;
foundit:
VAR_11->fname = pestrndup(VAR_1, VAR_2, VAR_11->is_persistent);
#ifdef VAR_21
phar_unixify_path_separators(VAR_11->fname, VAR_2);
#endif
VAR_11->is_zip = 1;
VAR_11->fname_len = VAR_2;
VAR_14 = strrchr(VAR_11->fname, '/');
if (VAR_14) {
VAR_11->ext = memchr(VAR_14, '.', (VAR_11->fname + VAR_2) - VAR_14);
if (VAR_11->ext == VAR_14) {
VAR_11->ext = memchr(VAR_14 + 1, '.', (VAR_11->fname + VAR_2) - VAR_14 - 1);
}
if (VAR_11->ext) {
VAR_11->ext_len = (VAR_11->fname + VAR_2) - VAR_11->ext;
}
}
php_stream_seek(VAR_0, PHAR_GET_32(VAR_7.cdir_offset), VAR_19);
zend_hash_init(&VAR_11->manifest, PHAR_GET_16(VAR_7.count),
VAR_22, VAR_23, (zend_bool)VAR_11->is_persistent);
zend_hash_init(&VAR_11->mounted_dirs, 5,
VAR_22, NULL, (zend_bool)VAR_11->is_persistent);
zend_hash_init(&VAR_11->virtual_dirs, PHAR_GET_16(VAR_7.count) * 2,
VAR_22, NULL, (zend_bool)VAR_11->is_persistent);
VAR_12.phar = VAR_11;
VAR_12.is_zip = 1;
VAR_12.fp_type = VAR_24;
VAR_12.is_persistent = VAR_11->is_persistent;
#define PHAR_ZIP_FAIL_FREE(VAR_25, VAR_26) \
zend_hash_destroy(&mydata->manifest); \
mydata->manifest.u.flags = 0; \
zend_hash_destroy(&mydata->mounted_dirs); \
mydata->mounted_dirs.u.flags = 0; \
zend_hash_destroy(&mydata->virtual_dirs); \
mydata->virtual_dirs.u.flags = 0; \
php_stream_close(fp); \
zval_dtor(&mydata->metadata); \
if (mydata->signature) { \
efree(mydata->signature); \
} \
if (error) { \
spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
} \
pefree(mydata->fname, mydata->is_persistent); \
if (mydata->alias) { \
pefree(mydata->alias, mydata->is_persistent); \
} \
pefree(mydata, mydata->is_persistent); \
efree(save); \
return FAILURE;
#define PHAR_ZIP_FAIL(VAR_25) \
zend_hash_destroy(&mydata->manifest); \
mydata->manifest.u.flags = 0; \
zend_hash_destroy(&mydata->mounted_dirs); \
mydata->mounted_dirs.u.flags = 0; \
zend_hash_destroy(&mydata->virtual_dirs); \
mydata->virtual_dirs.u.flags = 0; \
php_stream_close(fp); \
zval_dtor(&mydata->metadata); \
if (mydata->signature) { \
efree(mydata->signature); \
} \
if (error) { \
spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
} \
pefree(mydata->fname, mydata->is_persistent); \
if (mydata->alias) { \
pefree(mydata->alias, mydata->is_persistent); \
} \
pefree(mydata, mydata->is_persistent); \
return FAILURE;
for (VAR_10 = 0; VAR_10 < PHAR_GET_16(VAR_7.count); ++VAR_10) {
phar_zip_central_dir_file VAR_27;
zend_off_t VAR_28 = php_stream_tell(VAR_0);
if (sizeof(VAR_27) != php_stream_read(VAR_0, (char *) &VAR_27, sizeof(VAR_27))) {
PHAR_ZIP_FAIL(""unable to read central directory entry, truncated"");
}
if (memcmp(""PK\1\2"", VAR_27.signature, 4)) {
PHAR_ZIP_FAIL(""corrupted central directory entry, no magic signature"");
}
if (VAR_12.is_persistent) {
VAR_12.manifest_pos = VAR_10;
}
VAR_12.compressed_filesize = PHAR_GET_32(VAR_27.compsize);
VAR_12.uncompressed_filesize = PHAR_GET_32(VAR_27.uncompsize);
VAR_12.crc32 = PHAR_GET_32(VAR_27.crc32);
VAR_12.timestamp = phar_zip_d2u_time(VAR_27.timestamp, VAR_27.datestamp);
VAR_12.flags = VAR_29;
VAR_12.header_offset = PHAR_GET_32(VAR_27.offset);
VAR_12.offset = VAR_12.offset_abs = PHAR_GET_32(VAR_27.offset) + sizeof(VAR_30) + PHAR_GET_16(VAR_27.filename_len) +
PHAR_GET_16(VAR_27.extra_len);
if (PHAR_GET_16(VAR_27.flags) & VAR_31) {
PHAR_ZIP_FAIL(""Cannot process encrypted zip files"");
}
if (!PHAR_GET_16(VAR_27.filename_len)) {
PHAR_ZIP_FAIL(""Cannot process zips created from stdin (zero-length filename)"");
}
VAR_12.filename_len = PHAR_GET_16(VAR_27.filename_len);
VAR_12.filename = (char *) pemalloc(VAR_12.filename_len + 1, VAR_12.is_persistent);
if (VAR_12.filename_len != php_stream_read(VAR_0, VAR_12.filename, VAR_12.filename_len)) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unable to read in filename from central directory, truncated"");
}
VAR_12.filename[VAR_12.filename_len] = '\0';
if (VAR_12.filename[VAR_12.filename_len - 1] == '/') {
VAR_12.is_dir = 1;
if(VAR_12.filename_len > 1) {
VAR_12.filename_len--;
}
VAR_12.flags |= VAR_32;
} else {
VAR_12.is_dir = 0;
}
if (VAR_12.filename_len == sizeof("".phar/signature.bin"")-1 && !strncmp(VAR_12.filename, "".phar/signature.bin"", sizeof("".phar/signature.bin"")-1)) {
size_t VAR_33;
php_stream *VAR_34;
zend_off_t VAR_35;
char *VAR_36;
VAR_35 = php_stream_tell(VAR_0);
pefree(VAR_12.filename, VAR_12.is_persistent);
VAR_34 = php_stream_fopen_tmpfile();
if (!VAR_34) {
PHAR_ZIP_FAIL(""couldn't open temporary file"");
}
php_stream_seek(VAR_0, 0, VAR_19);
php_stream_copy_to_stream_ex(VAR_0, VAR_34, VAR_12.header_offset, NULL);
php_stream_seek(VAR_0, PHAR_GET_32(VAR_7.cdir_offset), VAR_19);
php_stream_copy_to_stream_ex(VAR_0, VAR_34, VAR_28 - PHAR_GET_32(VAR_7.cdir_offset), NULL);
if (VAR_16) {
php_stream_write(VAR_34, VAR_16, PHAR_GET_16(VAR_7.comment_len));
}
php_stream_seek(VAR_0, sizeof(VAR_30) + VAR_12.header_offset + VAR_12.filename_len + PHAR_GET_16(VAR_27.extra_len), VAR_19);
VAR_36 = (char *) emalloc(VAR_12.uncompressed_filesize);
VAR_33 = php_stream_read(VAR_0, VAR_36, VAR_12.uncompressed_filesize);
if (VAR_33 != VAR_12.uncompressed_filesize) {
php_stream_close(VAR_34);
efree(VAR_36);
PHAR_ZIP_FAIL(""signature cannot be read"");
}
VAR_11->sig_flags = PHAR_GET_32(VAR_36);
if (VAR_17 == phar_verify_signature(VAR_34, php_stream_tell(VAR_34), VAR_11->sig_flags, VAR_36 + 8, VAR_12.uncompressed_filesize - 8, VAR_1, &VAR_11->signature, &VAR_11->sig_len, VAR_6)) {
efree(VAR_36);
if (VAR_6) {
char *VAR_26;
php_stream_close(VAR_34);
spprintf(&VAR_26, 4096, ""signature cannot be verified: %s"", *VAR_6);
efree(*VAR_6);
PHAR_ZIP_FAIL_FREE(VAR_26, VAR_26);
} else {
php_stream_close(VAR_34);
PHAR_ZIP_FAIL(""signature cannot be verified"");
}
}
php_stream_close(VAR_34);
efree(VAR_36);
if (VAR_10 != PHAR_GET_16(VAR_7.count) - 1) {
PHAR_ZIP_FAIL(""entries exist after signature, invalid phar"");
}
continue;
}
phar_add_virtual_dirs(VAR_11, VAR_12.filename, VAR_12.filename_len);
if (PHAR_GET_16(VAR_27.extra_len)) {
zend_off_t VAR_37 = php_stream_tell(VAR_0);
if (VAR_17 == phar_zip_process_extra(VAR_0, &VAR_12, PHAR_GET_16(VAR_27.extra_len))) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""Unable to process extra field header for file in central directory"");
}
php_stream_seek(VAR_0, VAR_37 + PHAR_GET_16(VAR_27.extra_len), VAR_19);
}
switch (PHAR_GET_16(VAR_27.compressed)) {
case VAR_38 :
break;
case VAR_39 :
VAR_12.flags |= VAR_40;
if (!PHAR_G(VAR_41)) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""zlib extension is required"");
}
break;
case VAR_42 :
VAR_12.flags |= VAR_43;
if (!PHAR_G(VAR_44)) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""bzip2 extension is required"");
}
break;
case 1 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Shrunk) used in this zip"");
case 2 :
case 3 :
case 4 :
case 5 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Reduce) used in this zip"");
case 6 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Implode) used in this zip"");
case 7 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Tokenize) used in this zip"");
case 9 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (Deflate64) used in this zip"");
case 10 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip"");
case 14 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (LZMA) used in this zip"");
case 18 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (IBM TERSE) used in this zip"");
case 19 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (IBM LZ77) used in this zip"");
case 97 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (WavPack) used in this zip"");
case 98 :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (PPMd) used in this zip"");
default :
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unsupported compression method (unknown) used in this zip"");
}
if (PHAR_GET_16(VAR_27.comment_len)) {
if (PHAR_GET_16(VAR_27.comment_len) != php_stream_read(VAR_0, VAR_8, PHAR_GET_16(VAR_27.comment_len))) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unable to read in file comment, truncated"");
}
VAR_13 = VAR_8;
VAR_12.metadata_len = PHAR_GET_16(VAR_27.comment_len);
if (phar_parse_metadata(&VAR_13, &(VAR_12.metadata), PHAR_GET_16(VAR_27.comment_len)) == VAR_17) {
VAR_12.metadata_len = 0;
ZVAL_NEW_STR(&VAR_12.metadata, zend_string_init(VAR_8, PHAR_GET_16(VAR_27.comment_len), VAR_12.is_persistent));
}
} else {
ZVAL_UNDEF(&VAR_12.metadata);
}
if (!VAR_15 && VAR_12.filename_len == sizeof("".phar/alias.txt"")-1 && !strncmp(VAR_12.filename, "".phar/alias.txt"", sizeof("".phar/alias.txt"")-1)) {
php_stream_filter *VAR_45;
zend_off_t VAR_46;
phar_zip_file_header VAR_47;
VAR_46 = php_stream_tell(VAR_0);
php_stream_seek(VAR_0, PHAR_GET_32(VAR_27.offset), VAR_19);
if (sizeof(VAR_47) != php_stream_read(VAR_0, (char *) &VAR_47, sizeof(VAR_47))) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (cannot read local file header for alias)"");
}
if (VAR_12.filename_len != PHAR_GET_16(VAR_47.filename_len) || VAR_12.crc32 != PHAR_GET_32(VAR_47.crc32) || VAR_12.uncompressed_filesize != PHAR_GET_32(VAR_47.uncompsize) || VAR_12.compressed_filesize != PHAR_GET_32(VAR_47.compsize)) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (local header of alias does not match central directory)"");
}
VAR_12.offset = VAR_12.offset_abs =
sizeof(VAR_47) + VAR_12.header_offset + PHAR_GET_16(VAR_47.filename_len) + PHAR_GET_16(VAR_47.extra_len);
php_stream_seek(VAR_0, VAR_12.offset, VAR_19);
VAR_0->writepos = 0;
VAR_0->readpos = 0;
php_stream_seek(VAR_0, VAR_12.offset, VAR_19);
VAR_0->writepos = 0;
VAR_0->readpos = 0;
VAR_11->alias_len = VAR_12.uncompressed_filesize;
if (VAR_12.flags & VAR_40) {
VAR_45 = php_stream_filter_create(""zlib.inflate"", NULL, php_stream_is_persistent(VAR_0));
if (!VAR_45) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unable to decompress alias, zlib filter creation failed"");
}
php_stream_filter_append(&VAR_0->readfilters, VAR_45);
{
zend_string *VAR_48 = php_stream_copy_to_mem(VAR_0, VAR_12.uncompressed_filesize, 0);
if (VAR_48) {
VAR_12.uncompressed_filesize = ZSTR_LEN(VAR_48);
VAR_15 = estrndup(ZSTR_VAL(VAR_48), ZSTR_LEN(VAR_48));
zend_string_release(VAR_48);
} else {
VAR_15 = NULL;
VAR_12.uncompressed_filesize = 0;
}
}
if (!VAR_12.uncompressed_filesize || !VAR_15) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
}
php_stream_filter_flush(VAR_45, 1);
php_stream_filter_remove(VAR_45, 1);
} else if (VAR_12.flags & VAR_43) {
VAR_45 = php_stream_filter_create(""bzip2.decompress"", NULL, php_stream_is_persistent(VAR_0));
if (!VAR_45) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, bzip2 filter creation failed"");
}
php_stream_filter_append(&VAR_0->readfilters, VAR_45);
{
zend_string *VAR_48 = php_stream_copy_to_mem(VAR_0, VAR_12.uncompressed_filesize, 0);
if (VAR_48) {
VAR_12.uncompressed_filesize = ZSTR_LEN(VAR_48);
VAR_15 = estrndup(ZSTR_VAL(VAR_48), ZSTR_LEN(VAR_48));
zend_string_release(VAR_48);
} else {
VAR_15 = NULL;
VAR_12.uncompressed_filesize = 0;
}
}
if (!VAR_12.uncompressed_filesize || !VAR_15) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
}
php_stream_filter_flush(VAR_45, 1);
php_stream_filter_remove(VAR_45, 1);
} else {
{
zend_string *VAR_48 = php_stream_copy_to_mem(VAR_0, VAR_12.uncompressed_filesize, 0);
if (VAR_48) {
VAR_12.uncompressed_filesize = ZSTR_LEN(VAR_48);
VAR_15 = estrndup(ZSTR_VAL(VAR_48), ZSTR_LEN(VAR_48));
zend_string_release(VAR_48);
} else {
VAR_15 = NULL;
VAR_12.uncompressed_filesize = 0;
}
}
if (!VAR_12.uncompressed_filesize || !VAR_15) {
pefree(VAR_12.filename, VAR_12.is_persistent);
PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
}
}
php_stream_seek(VAR_0, VAR_46, VAR_19);
}
phar_set_inode(&VAR_12);
zend_hash_str_add_mem(&VAR_11->manifest, VAR_12.filename, VAR_12.filename_len, (void *)&VAR_12, sizeof(phar_entry_info));
}
VAR_11->fp = VAR_0;
if (zend_hash_str_exists(&(VAR_11->manifest), "".phar/stub.php"", sizeof("".phar/stub.php"")-1)) {
VAR_11->is_data = 0;
} else {
VAR_11->is_data = 1;
}
zend_hash_str_add_ptr(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2, VAR_11);
if (VAR_15) {
phar_archive_data *VAR_50;
if (!phar_validate_alias(VAR_15, VAR_11->alias_len)) {
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: invalid alias \""%s\"" in zip-based phar \""%s\"""", VAR_15, VAR_1);
}
efree(VAR_15);
zend_hash_str_del(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2);
return VAR_17;
}
VAR_11->is_temporary_alias = 0;
if (NULL != (VAR_50 = zend_hash_str_find_ptr(&(PHAR_G(VAR_51)), VAR_15, VAR_11->alias_len))) {
if (VAR_52 != phar_free_alias(VAR_50, VAR_15, VAR_11->alias_len)) {
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with implicit alias, alias is already in use"", VAR_1);
}
efree(VAR_15);
zend_hash_str_del(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2);
return VAR_17;
}
}
VAR_11->alias = VAR_12.is_persistent ? pestrndup(VAR_15, VAR_11->alias_len, 1) : VAR_15;
if (VAR_12.is_persistent) {
efree(VAR_15);
}
zend_hash_str_add_ptr(&(PHAR_G(VAR_51)), VAR_15, VAR_11->alias_len, VAR_11);
} else {
phar_archive_data *VAR_50;
if (VAR_4) {
if (NULL != (VAR_50 = zend_hash_str_find_ptr(&(PHAR_G(VAR_51)), VAR_3, VAR_4))) {
if (VAR_52 != phar_free_alias(VAR_50, VAR_3, VAR_4)) {
if (VAR_6) {
spprintf(VAR_6, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with explicit alias, alias is already in use"", VAR_1);
}
zend_hash_str_del(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2);
return VAR_17;
}
}
zend_hash_str_add_ptr(&(PHAR_G(VAR_51)), VAR_15, VAR_11->alias_len, VAR_11);
VAR_11->alias = pestrndup(VAR_3, VAR_4, VAR_11->is_persistent);
VAR_11->alias_len = VAR_4;
} else {
VAR_11->alias = pestrndup(VAR_11->fname, VAR_2, VAR_11->is_persistent);
VAR_11->alias_len = VAR_2;
}
VAR_11->is_temporary_alias = 1;
}
if (VAR_5) {
*VAR_5 = VAR_11;
}
return VAR_52;
}",php/php-src/0bfb970f43acd1e81d11be1154805f86655f15d5/zip.c/vul/before/0.json,"int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error) /* {{{ */
{
	phar_zip_dir_end locator;
	char buf[sizeof(locator) + 65536];
	zend_long size;
	php_uint16 i;
	phar_archive_data *mydata = NULL;
	phar_entry_info entry = {0};
	char *p = buf, *ext, *actual_alias = NULL;
	char *metadata = NULL;

	size = php_stream_tell(fp);

	if (size > sizeof(locator) + 65536) {
		/* seek to max comment length + end of central directory record */
		size = sizeof(locator) + 65536;
		if (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {
			php_stream_close(fp);
			if (error) {
				spprintf(error, 4096, ""phar error: unable to search for end of central directory in zip-based phar \""%s\"""", fname);
			}
			return FAILURE;
		}
	} else {
		php_stream_seek(fp, 0, SEEK_SET);
	}

	if (!php_stream_read(fp, buf, size)) {
		php_stream_close(fp);
		if (error) {
			spprintf(error, 4096, ""phar error: unable to read in data to search for end of central directory in zip-based phar \""%s\"""", fname);
		}
		return FAILURE;
	}

	while ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {
		if ((p - buf) + sizeof(locator) <= size && !memcmp(p + 1, ""K\5\6"", 3)) {
			memcpy((void *)&locator, (void *) p, sizeof(locator));
			if (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {
				/* split archives not handled */
				php_stream_close(fp);
				if (error) {
					spprintf(error, 4096, ""phar error: split archives spanning multiple zips cannot be processed in zip-based phar \""%s\"""", fname);
				}
				return FAILURE;
			}

			if (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {
				if (error) {
					spprintf(error, 4096, ""phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \""%s\"""", fname);
				}
				php_stream_close(fp);
				return FAILURE;
			}

			mydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));
			mydata->is_persistent = PHAR_G(persist);

			/* read in archive comment, if any */
			if (PHAR_GET_16(locator.comment_len)) {

				metadata = p + sizeof(locator);

				if (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {
					if (error) {
						spprintf(error, 4096, ""phar error: corrupt zip archive, zip file comment truncated in zip-based phar \""%s\"""", fname);
					}
					php_stream_close(fp);
					pefree(mydata, mydata->is_persistent);
					return FAILURE;
				}

				mydata->metadata_len = PHAR_GET_16(locator.comment_len);

				if (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len)) == FAILURE) {
					mydata->metadata_len = 0;
					/* if not valid serialized data, it is a regular string */

					ZVAL_NEW_STR(&mydata->metadata, zend_string_init(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent));
				}
			} else {
				ZVAL_UNDEF(&mydata->metadata);
			}

			goto foundit;
		}
	}

	php_stream_close(fp);

	if (error) {
		spprintf(error, 4096, ""phar error: end of central directory not found in zip-based phar \""%s\"""", fname);
	}

	return FAILURE;
foundit:
	mydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);
#ifdef PHP_WIN32
	phar_unixify_path_separators(mydata->fname, fname_len);
#endif
	mydata->is_zip = 1;
	mydata->fname_len = fname_len;
	ext = strrchr(mydata->fname, '/');

	if (ext) {
		mydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);
		if (mydata->ext == ext) {
			mydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);
		}
		if (mydata->ext) {
			mydata->ext_len = (mydata->fname + fname_len) - mydata->ext;
		}
	}

	/* clean up on big-endian systems */
	/* seek to central directory */
	php_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);
	/* read in central directory */
	zend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),
		zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);
	zend_hash_init(&mydata->mounted_dirs, 5,
		zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
	zend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,
		zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
	entry.phar = mydata;
	entry.is_zip = 1;
	entry.fp_type = PHAR_FP;
	entry.is_persistent = mydata->is_persistent;
#define PHAR_ZIP_FAIL_FREE(errmsg, save) \
			zend_hash_destroy(&mydata->manifest); \
			mydata->manifest.u.flags = 0; \
			zend_hash_destroy(&mydata->mounted_dirs); \
			mydata->mounted_dirs.u.flags = 0; \
			zend_hash_destroy(&mydata->virtual_dirs); \
			mydata->virtual_dirs.u.flags = 0; \
			php_stream_close(fp); \
			zval_dtor(&mydata->metadata); \
			if (mydata->signature) { \
				efree(mydata->signature); \
			} \
			if (error) { \
				spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
			} \
			pefree(mydata->fname, mydata->is_persistent); \
			if (mydata->alias) { \
				pefree(mydata->alias, mydata->is_persistent); \
			} \
			pefree(mydata, mydata->is_persistent); \
			efree(save); \
			return FAILURE;
#define PHAR_ZIP_FAIL(errmsg) \
			zend_hash_destroy(&mydata->manifest); \
			mydata->manifest.u.flags = 0; \
			zend_hash_destroy(&mydata->mounted_dirs); \
			mydata->mounted_dirs.u.flags = 0; \
			zend_hash_destroy(&mydata->virtual_dirs); \
			mydata->virtual_dirs.u.flags = 0; \
			php_stream_close(fp); \
			zval_dtor(&mydata->metadata); \
			if (mydata->signature) { \
				efree(mydata->signature); \
			} \
			if (error) { \
				spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
			} \
			pefree(mydata->fname, mydata->is_persistent); \
			if (mydata->alias) { \
				pefree(mydata->alias, mydata->is_persistent); \
			} \
			pefree(mydata, mydata->is_persistent); \
			return FAILURE;

	/* add each central directory item to the manifest */
	for (i = 0; i < PHAR_GET_16(locator.count); ++i) {
		phar_zip_central_dir_file zipentry;
		zend_off_t beforeus = php_stream_tell(fp);

		if (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {
			PHAR_ZIP_FAIL(""unable to read central directory entry, truncated"");
		}

		/* clean up for bigendian systems */
		if (memcmp(""PK\1\2"", zipentry.signature, 4)) {
			/* corrupted entry */
			PHAR_ZIP_FAIL(""corrupted central directory entry, no magic signature"");
		}

		if (entry.is_persistent) {
			entry.manifest_pos = i;
		}

		entry.compressed_filesize = PHAR_GET_32(zipentry.compsize);
		entry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);
		entry.crc32 = PHAR_GET_32(zipentry.crc32);
		/* do not PHAR_GET_16 either on the next line */
		entry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);
		entry.flags = PHAR_ENT_PERM_DEF_FILE;
		entry.header_offset = PHAR_GET_32(zipentry.offset);
		entry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +
			PHAR_GET_16(zipentry.extra_len);

		if (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {
			PHAR_ZIP_FAIL(""Cannot process encrypted zip files"");
		}

		if (!PHAR_GET_16(zipentry.filename_len)) {
			PHAR_ZIP_FAIL(""Cannot process zips created from stdin (zero-length filename)"");
		}

		entry.filename_len = PHAR_GET_16(zipentry.filename_len);
		entry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);

		if (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {
			pefree(entry.filename, entry.is_persistent);
			PHAR_ZIP_FAIL(""unable to read in filename from central directory, truncated"");
		}

		entry.filename[entry.filename_len] = '\0';

		if (entry.filename[entry.filename_len - 1] == '/') {
			entry.is_dir = 1;
			if(entry.filename_len > 1) {
				entry.filename_len--;
			}
			entry.flags |= PHAR_ENT_PERM_DEF_DIR;
		} else {
			entry.is_dir = 0;
		}

		if (entry.filename_len == sizeof("".phar/signature.bin"")-1 && !strncmp(entry.filename, "".phar/signature.bin"", sizeof("".phar/signature.bin"")-1)) {
			size_t read;
			php_stream *sigfile;
			zend_off_t now;
			char *sig;

			now = php_stream_tell(fp);
			pefree(entry.filename, entry.is_persistent);
			sigfile = php_stream_fopen_tmpfile();
			if (!sigfile) {
				PHAR_ZIP_FAIL(""couldn't open temporary file"");
			}

			php_stream_seek(fp, 0, SEEK_SET);
			/* copy file contents + local headers and zip comment, if any, to be hashed for signature */
			php_stream_copy_to_stream_ex(fp, sigfile, entry.header_offset, NULL);
			/* seek to central directory */
			php_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);
			/* copy central directory header */
			php_stream_copy_to_stream_ex(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);
			if (metadata) {
				php_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));
			}
			php_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);
			sig = (char *) emalloc(entry.uncompressed_filesize);
			read = php_stream_read(fp, sig, entry.uncompressed_filesize);
			if (read != entry.uncompressed_filesize || read <= 8) {
				php_stream_close(sigfile);
				efree(sig);
				PHAR_ZIP_FAIL(""signature cannot be read"");
			}
			mydata->sig_flags = PHAR_GET_32(sig);
			if (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error)) {
				efree(sig);
				if (error) {
					char *save;
					php_stream_close(sigfile);
					spprintf(&save, 4096, ""signature cannot be verified: %s"", *error);
					efree(*error);
					PHAR_ZIP_FAIL_FREE(save, save);
				} else {
					php_stream_close(sigfile);
					PHAR_ZIP_FAIL(""signature cannot be verified"");
				}
			}
			php_stream_close(sigfile);
			efree(sig);
			/* signature checked out, let's ensure this is the last file in the phar */
			if (i != PHAR_GET_16(locator.count) - 1) {
				PHAR_ZIP_FAIL(""entries exist after signature, invalid phar"");
			}

			continue;
		}

		phar_add_virtual_dirs(mydata, entry.filename, entry.filename_len);

		if (PHAR_GET_16(zipentry.extra_len)) {
			zend_off_t loc = php_stream_tell(fp);
			if (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len))) {
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""Unable to process extra field header for file in central directory"");
			}
			php_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);
		}

		switch (PHAR_GET_16(zipentry.compressed)) {
			case PHAR_ZIP_COMP_NONE :
				/* compression flag already set */
				break;
			case PHAR_ZIP_COMP_DEFLATE :
				entry.flags |= PHAR_ENT_COMPRESSED_GZ;
				if (!PHAR_G(has_zlib)) {
					pefree(entry.filename, entry.is_persistent);
					PHAR_ZIP_FAIL(""zlib extension is required"");
				}
				break;
			case PHAR_ZIP_COMP_BZIP2 :
				entry.flags |= PHAR_ENT_COMPRESSED_BZ2;
				if (!PHAR_G(has_bz2)) {
					pefree(entry.filename, entry.is_persistent);
					PHAR_ZIP_FAIL(""bzip2 extension is required"");
				}
				break;
			case 1 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Shrunk) used in this zip"");
			case 2 :
			case 3 :
			case 4 :
			case 5 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Reduce) used in this zip"");
			case 6 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Implode) used in this zip"");
			case 7 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Tokenize) used in this zip"");
			case 9 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Deflate64) used in this zip"");
			case 10 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip"");
			case 14 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (LZMA) used in this zip"");
			case 18 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (IBM TERSE) used in this zip"");
			case 19 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (IBM LZ77) used in this zip"");
			case 97 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (WavPack) used in this zip"");
			case 98 :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (PPMd) used in this zip"");
			default :
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (unknown) used in this zip"");
		}

		/* get file metadata */
		if (PHAR_GET_16(zipentry.comment_len)) {
			if (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""unable to read in file comment, truncated"");
			}

			p = buf;
			entry.metadata_len = PHAR_GET_16(zipentry.comment_len);

			if (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len)) == FAILURE) {
				entry.metadata_len = 0;
				/* if not valid serialized data, it is a regular string */

				ZVAL_NEW_STR(&entry.metadata, zend_string_init(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent));
			}
		} else {
			ZVAL_UNDEF(&entry.metadata);
		}

		if (!actual_alias && entry.filename_len == sizeof("".phar/alias.txt"")-1 && !strncmp(entry.filename, "".phar/alias.txt"", sizeof("".phar/alias.txt"")-1)) {
			php_stream_filter *filter;
			zend_off_t saveloc;
			/* verify local file header */
			phar_zip_file_header local;

			/* archive alias found */
			saveloc = php_stream_tell(fp);
			php_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);

			if (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (cannot read local file header for alias)"");
			}

			/* verify local header */
			if (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {
				pefree(entry.filename, entry.is_persistent);
				PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (local header of alias does not match central directory)"");
			}

			/* construct actual offset to file start - local extra_len can be different from central extra_len */
			entry.offset = entry.offset_abs =
				sizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);
			php_stream_seek(fp, entry.offset, SEEK_SET);
			/* these next lines should be for php < 5.2.6 after 5.3 filters are fixed */
			fp->writepos = 0;
			fp->readpos = 0;
			php_stream_seek(fp, entry.offset, SEEK_SET);
			fp->writepos = 0;
			fp->readpos = 0;
			/* the above lines should be for php < 5.2.6 after 5.3 filters are fixed */

			mydata->alias_len = entry.uncompressed_filesize;
			if (entry.flags & PHAR_ENT_COMPRESSED_GZ) {
				filter = php_stream_filter_create(""zlib.inflate"", NULL, php_stream_is_persistent(fp));

				if (!filter) {
					pefree(entry.filename, entry.is_persistent);
					PHAR_ZIP_FAIL(""unable to decompress alias, zlib filter creation failed"");
				}

				php_stream_filter_append(&fp->readfilters, filter);

				// TODO: refactor to avoid reallocation ???
//???			entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)
				{
					zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
					if (str) {
						entry.uncompressed_filesize = ZSTR_LEN(str);
						actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
						zend_string_release(str);
					} else {
						actual_alias = NULL;
						entry.uncompressed_filesize = 0;
					}
				}

				if (!entry.uncompressed_filesize || !actual_alias) {
					pefree(entry.filename, entry.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
				}

				php_stream_filter_flush(filter, 1);
				php_stream_filter_remove(filter, 1);

			} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {
				filter = php_stream_filter_create(""bzip2.decompress"", NULL, php_stream_is_persistent(fp));

				if (!filter) {
					pefree(entry.filename, entry.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, bzip2 filter creation failed"");
				}

				php_stream_filter_append(&fp->readfilters, filter);

				// TODO: refactor to avoid reallocation ???
//???			entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)
				{
					zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
					if (str) {
						entry.uncompressed_filesize = ZSTR_LEN(str);
						actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
						zend_string_release(str);
					} else {
						actual_alias = NULL;
						entry.uncompressed_filesize = 0;
					}
				}

				if (!entry.uncompressed_filesize || !actual_alias) {
					pefree(entry.filename, entry.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
				}

				php_stream_filter_flush(filter, 1);
				php_stream_filter_remove(filter, 1);
			} else {
				// TODO: refactor to avoid reallocation ???
//???			entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)
				{
					zend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);
					if (str) {
						entry.uncompressed_filesize = ZSTR_LEN(str);
						actual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));
						zend_string_release(str);
					} else {
						actual_alias = NULL;
						entry.uncompressed_filesize = 0;
					}
				}

				if (!entry.uncompressed_filesize || !actual_alias) {
					pefree(entry.filename, entry.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
				}
			}

			/* return to central directory parsing */
			php_stream_seek(fp, saveloc, SEEK_SET);
		}

		phar_set_inode(&entry);
		zend_hash_str_add_mem(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry, sizeof(phar_entry_info));
	}

	mydata->fp = fp;

	if (zend_hash_str_exists(&(mydata->manifest), "".phar/stub.php"", sizeof("".phar/stub.php"")-1)) {
		mydata->is_data = 0;
	} else {
		mydata->is_data = 1;
	}

	zend_hash_str_add_ptr(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len, mydata);

	if (actual_alias) {
		phar_archive_data *fd_ptr;

		if (!phar_validate_alias(actual_alias, mydata->alias_len)) {
			if (error) {
				spprintf(error, 4096, ""phar error: invalid alias \""%s\"" in zip-based phar \""%s\"""", actual_alias, fname);
			}
			efree(actual_alias);
			zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
			return FAILURE;
		}

		mydata->is_temporary_alias = 0;

		if (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len))) {
			if (SUCCESS != phar_free_alias(fd_ptr, actual_alias, mydata->alias_len)) {
				if (error) {
					spprintf(error, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with implicit alias, alias is already in use"", fname);
				}
				efree(actual_alias);
				zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
				return FAILURE;
			}
		}

		mydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;

		if (entry.is_persistent) {
			efree(actual_alias);
		}

		zend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);
	} else {
		phar_archive_data *fd_ptr;

		if (alias_len) {
			if (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len))) {
				if (SUCCESS != phar_free_alias(fd_ptr, alias, alias_len)) {
					if (error) {
						spprintf(error, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with explicit alias, alias is already in use"", fname);
					}
					zend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);
					return FAILURE;
				}
			}

			zend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);
			mydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);
			mydata->alias_len = alias_len;
		} else {
			mydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);
			mydata->alias_len = fname_len;
		}

		mydata->is_temporary_alias = 1;
	}

	if (pphar) {
		*pphar = mydata;
	}

	return SUCCESS;
}","int phar_parse_zipfile(php_stream *VAR_0, char *VAR_1, int VAR_2, char *VAR_3, int VAR_4, phar_archive_data** VAR_5, char **VAR_6) /* COMMENT_0 */
{
	phar_zip_dir_end VAR_7;
	char VAR_8[sizeof(VAR_7) + 65536];
	zend_long VAR_9;
	php_uint16 VAR_10;
	phar_archive_data *VAR_11 = NULL;
	phar_entry_info VAR_12 = {0};
	char *VAR_13 = VAR_8, *VAR_14, *VAR_15 = NULL;
	char *VAR_16 = NULL;

	VAR_9 = php_stream_tell(VAR_0);

	if (VAR_9 > sizeof(VAR_7) + 65536) {
		/* COMMENT_1 */
		VAR_9 = sizeof(VAR_7) + 65536;
		if (VAR_17 == php_stream_seek(VAR_0, -VAR_9, VAR_18)) {
			php_stream_close(VAR_0);
			if (VAR_6) {
				spprintf(VAR_6, 4096, ""phar error: unable to search for end of central directory in zip-based phar \""%s\"""", VAR_1);
			}
			return VAR_17;
		}
	} else {
		php_stream_seek(VAR_0, 0, VAR_19);
	}

	if (!php_stream_read(VAR_0, VAR_8, VAR_9)) {
		php_stream_close(VAR_0);
		if (VAR_6) {
			spprintf(VAR_6, 4096, ""phar error: unable to read in data to search for end of central directory in zip-based phar \""%s\"""", VAR_1);
		}
		return VAR_17;
	}

	while ((VAR_13=(char *) memchr(VAR_13 + 1, 'P', (size_t) (VAR_9 - (VAR_13 + 1 - VAR_8)))) != NULL) {
		if ((VAR_13 - VAR_8) + sizeof(VAR_7) <= VAR_9 && !memcmp(VAR_13 + 1, ""K\5\6"", 3)) {
			memcpy((void *)&VAR_7, (void *) VAR_13, sizeof(VAR_7));
			if (PHAR_GET_16(VAR_7.centraldisk) != 0 || PHAR_GET_16(VAR_7.disknumber) != 0) {
				/* COMMENT_2 */
				php_stream_close(VAR_0);
				if (VAR_6) {
					spprintf(VAR_6, 4096, ""phar error: split archives spanning multiple zips cannot be processed in zip-based phar \""%s\"""", VAR_1);
				}
				return VAR_17;
			}

			if (PHAR_GET_16(VAR_7.counthere) != PHAR_GET_16(VAR_7.count)) {
				if (VAR_6) {
					spprintf(VAR_6, 4096, ""phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \""%s\"""", VAR_1);
				}
				php_stream_close(VAR_0);
				return VAR_17;
			}

			VAR_11 = pecalloc(1, sizeof(phar_archive_data), PHAR_G(VAR_20));
			VAR_11->is_persistent = PHAR_G(VAR_20);

			/* COMMENT_3 */
			if (PHAR_GET_16(VAR_7.comment_len)) {

				VAR_16 = VAR_13 + sizeof(VAR_7);

				if (PHAR_GET_16(VAR_7.comment_len) != VAR_9 - (VAR_16 - VAR_8)) {
					if (VAR_6) {
						spprintf(VAR_6, 4096, ""phar error: corrupt zip archive, zip file comment truncated in zip-based phar \""%s\"""", VAR_1);
					}
					php_stream_close(VAR_0);
					pefree(VAR_11, VAR_11->is_persistent);
					return VAR_17;
				}

				VAR_11->metadata_len = PHAR_GET_16(VAR_7.comment_len);

				if (phar_parse_metadata(&VAR_16, &VAR_11->metadata, PHAR_GET_16(VAR_7.comment_len)) == VAR_17) {
					VAR_11->metadata_len = 0;
					/* COMMENT_4 */

					ZVAL_NEW_STR(&VAR_11->metadata, zend_string_init(VAR_16, PHAR_GET_16(VAR_7.comment_len), VAR_11->is_persistent));
				}
			} else {
				ZVAL_UNDEF(&VAR_11->metadata);
			}

			goto foundit;
		}
	}

	php_stream_close(VAR_0);

	if (VAR_6) {
		spprintf(VAR_6, 4096, ""phar error: end of central directory not found in zip-based phar \""%s\"""", VAR_1);
	}

	return VAR_17;
foundit:
	VAR_11->fname = pestrndup(VAR_1, VAR_2, VAR_11->is_persistent);
#ifdef VAR_21
	phar_unixify_path_separators(VAR_11->fname, VAR_2);
#endif
	VAR_11->is_zip = 1;
	VAR_11->fname_len = VAR_2;
	VAR_14 = strrchr(VAR_11->fname, '/');

	if (VAR_14) {
		VAR_11->ext = memchr(VAR_14, '.', (VAR_11->fname + VAR_2) - VAR_14);
		if (VAR_11->ext == VAR_14) {
			VAR_11->ext = memchr(VAR_14 + 1, '.', (VAR_11->fname + VAR_2) - VAR_14 - 1);
		}
		if (VAR_11->ext) {
			VAR_11->ext_len = (VAR_11->fname + VAR_2) - VAR_11->ext;
		}
	}

	/* COMMENT_5 */
	/* COMMENT_6 */
	php_stream_seek(VAR_0, PHAR_GET_32(VAR_7.cdir_offset), VAR_19);
	/* COMMENT_7 */
	zend_hash_init(&VAR_11->manifest, PHAR_GET_16(VAR_7.count),
		VAR_22, VAR_23, (zend_bool)VAR_11->is_persistent);
	zend_hash_init(&VAR_11->mounted_dirs, 5,
		VAR_22, NULL, (zend_bool)VAR_11->is_persistent);
	zend_hash_init(&VAR_11->virtual_dirs, PHAR_GET_16(VAR_7.count) * 2,
		VAR_22, NULL, (zend_bool)VAR_11->is_persistent);
	VAR_12.phar = VAR_11;
	VAR_12.is_zip = 1;
	VAR_12.fp_type = VAR_24;
	VAR_12.is_persistent = VAR_11->is_persistent;
#define PHAR_ZIP_FAIL_FREE(VAR_25, VAR_26) \
			zend_hash_destroy(&mydata->manifest); \
			mydata->manifest.u.flags = 0; \
			zend_hash_destroy(&mydata->mounted_dirs); \
			mydata->mounted_dirs.u.flags = 0; \
			zend_hash_destroy(&mydata->virtual_dirs); \
			mydata->virtual_dirs.u.flags = 0; \
			php_stream_close(fp); \
			zval_dtor(&mydata->metadata); \
			if (mydata->signature) { \
				efree(mydata->signature); \
			} \
			if (error) { \
				spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
			} \
			pefree(mydata->fname, mydata->is_persistent); \
			if (mydata->alias) { \
				pefree(mydata->alias, mydata->is_persistent); \
			} \
			pefree(mydata, mydata->is_persistent); \
			efree(save); \
			return FAILURE;
#define PHAR_ZIP_FAIL(VAR_25) \
			zend_hash_destroy(&mydata->manifest); \
			mydata->manifest.u.flags = 0; \
			zend_hash_destroy(&mydata->mounted_dirs); \
			mydata->mounted_dirs.u.flags = 0; \
			zend_hash_destroy(&mydata->virtual_dirs); \
			mydata->virtual_dirs.u.flags = 0; \
			php_stream_close(fp); \
			zval_dtor(&mydata->metadata); \
			if (mydata->signature) { \
				efree(mydata->signature); \
			} \
			if (error) { \
				spprintf(error, 4096, ""phar error: %s in zip-based phar \""%s\"""", errmsg, mydata->fname); \
			} \
			pefree(mydata->fname, mydata->is_persistent); \
			if (mydata->alias) { \
				pefree(mydata->alias, mydata->is_persistent); \
			} \
			pefree(mydata, mydata->is_persistent); \
			return FAILURE;

	/* COMMENT_8 */
	for (VAR_10 = 0; VAR_10 < PHAR_GET_16(VAR_7.count); ++VAR_10) {
		phar_zip_central_dir_file VAR_27;
		zend_off_t VAR_28 = php_stream_tell(VAR_0);

		if (sizeof(VAR_27) != php_stream_read(VAR_0, (char *) &VAR_27, sizeof(VAR_27))) {
			PHAR_ZIP_FAIL(""unable to read central directory entry, truncated"");
		}

		/* COMMENT_9 */
		if (memcmp(""PK\1\2"", VAR_27.signature, 4)) {
			/* COMMENT_10 */
			PHAR_ZIP_FAIL(""corrupted central directory entry, no magic signature"");
		}

		if (VAR_12.is_persistent) {
			VAR_12.manifest_pos = VAR_10;
		}

		VAR_12.compressed_filesize = PHAR_GET_32(VAR_27.compsize);
		VAR_12.uncompressed_filesize = PHAR_GET_32(VAR_27.uncompsize);
		VAR_12.crc32 = PHAR_GET_32(VAR_27.crc32);
		/* COMMENT_11 */
		VAR_12.timestamp = phar_zip_d2u_time(VAR_27.timestamp, VAR_27.datestamp);
		VAR_12.flags = VAR_29;
		VAR_12.header_offset = PHAR_GET_32(VAR_27.offset);
		VAR_12.offset = VAR_12.offset_abs = PHAR_GET_32(VAR_27.offset) + sizeof(VAR_30) + PHAR_GET_16(VAR_27.filename_len) +
			PHAR_GET_16(VAR_27.extra_len);

		if (PHAR_GET_16(VAR_27.flags) & VAR_31) {
			PHAR_ZIP_FAIL(""Cannot process encrypted zip files"");
		}

		if (!PHAR_GET_16(VAR_27.filename_len)) {
			PHAR_ZIP_FAIL(""Cannot process zips created from stdin (zero-length filename)"");
		}

		VAR_12.filename_len = PHAR_GET_16(VAR_27.filename_len);
		VAR_12.filename = (char *) pemalloc(VAR_12.filename_len + 1, VAR_12.is_persistent);

		if (VAR_12.filename_len != php_stream_read(VAR_0, VAR_12.filename, VAR_12.filename_len)) {
			pefree(VAR_12.filename, VAR_12.is_persistent);
			PHAR_ZIP_FAIL(""unable to read in filename from central directory, truncated"");
		}

		VAR_12.filename[VAR_12.filename_len] = '\0';

		if (VAR_12.filename[VAR_12.filename_len - 1] == '/') {
			VAR_12.is_dir = 1;
			if(VAR_12.filename_len > 1) {
				VAR_12.filename_len--;
			}
			VAR_12.flags |= VAR_32;
		} else {
			VAR_12.is_dir = 0;
		}

		if (VAR_12.filename_len == sizeof("".phar/signature.bin"")-1 && !strncmp(VAR_12.filename, "".phar/signature.bin"", sizeof("".phar/signature.bin"")-1)) {
			size_t VAR_33;
			php_stream *VAR_34;
			zend_off_t VAR_35;
			char *VAR_36;

			VAR_35 = php_stream_tell(VAR_0);
			pefree(VAR_12.filename, VAR_12.is_persistent);
			VAR_34 = php_stream_fopen_tmpfile();
			if (!VAR_34) {
				PHAR_ZIP_FAIL(""couldn't open temporary file"");
			}

			php_stream_seek(VAR_0, 0, VAR_19);
			/* COMMENT_12 */
			php_stream_copy_to_stream_ex(VAR_0, VAR_34, VAR_12.header_offset, NULL);
			/* COMMENT_6 */
			php_stream_seek(VAR_0, PHAR_GET_32(VAR_7.cdir_offset), VAR_19);
			/* COMMENT_13 */
			php_stream_copy_to_stream_ex(VAR_0, VAR_34, VAR_28 - PHAR_GET_32(VAR_7.cdir_offset), NULL);
			if (VAR_16) {
				php_stream_write(VAR_34, VAR_16, PHAR_GET_16(VAR_7.comment_len));
			}
			php_stream_seek(VAR_0, sizeof(VAR_30) + VAR_12.header_offset + VAR_12.filename_len + PHAR_GET_16(VAR_27.extra_len), VAR_19);
			VAR_36 = (char *) emalloc(VAR_12.uncompressed_filesize);
			VAR_33 = php_stream_read(VAR_0, VAR_36, VAR_12.uncompressed_filesize);
			if (VAR_33 != VAR_12.uncompressed_filesize || VAR_33 <= 8) {
				php_stream_close(VAR_34);
				efree(VAR_36);
				PHAR_ZIP_FAIL(""signature cannot be read"");
			}
			VAR_11->sig_flags = PHAR_GET_32(VAR_36);
			if (VAR_17 == phar_verify_signature(VAR_34, php_stream_tell(VAR_34), VAR_11->sig_flags, VAR_36 + 8, VAR_12.uncompressed_filesize - 8, VAR_1, &VAR_11->signature, &VAR_11->sig_len, VAR_6)) {
				efree(VAR_36);
				if (VAR_6) {
					char *VAR_26;
					php_stream_close(VAR_34);
					spprintf(&VAR_26, 4096, ""signature cannot be verified: %s"", *VAR_6);
					efree(*VAR_6);
					PHAR_ZIP_FAIL_FREE(VAR_26, VAR_26);
				} else {
					php_stream_close(VAR_34);
					PHAR_ZIP_FAIL(""signature cannot be verified"");
				}
			}
			php_stream_close(VAR_34);
			efree(VAR_36);
			/* COMMENT_14 */
			if (VAR_10 != PHAR_GET_16(VAR_7.count) - 1) {
				PHAR_ZIP_FAIL(""entries exist after signature, invalid phar"");
			}

			continue;
		}

		phar_add_virtual_dirs(VAR_11, VAR_12.filename, VAR_12.filename_len);

		if (PHAR_GET_16(VAR_27.extra_len)) {
			zend_off_t VAR_37 = php_stream_tell(VAR_0);
			if (VAR_17 == phar_zip_process_extra(VAR_0, &VAR_12, PHAR_GET_16(VAR_27.extra_len))) {
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""Unable to process extra field header for file in central directory"");
			}
			php_stream_seek(VAR_0, VAR_37 + PHAR_GET_16(VAR_27.extra_len), VAR_19);
		}

		switch (PHAR_GET_16(VAR_27.compressed)) {
			case VAR_38 :
				/* COMMENT_15 */
				break;
			case VAR_39 :
				VAR_12.flags |= VAR_40;
				if (!PHAR_G(VAR_41)) {
					pefree(VAR_12.filename, VAR_12.is_persistent);
					PHAR_ZIP_FAIL(""zlib extension is required"");
				}
				break;
			case VAR_42 :
				VAR_12.flags |= VAR_43;
				if (!PHAR_G(VAR_44)) {
					pefree(VAR_12.filename, VAR_12.is_persistent);
					PHAR_ZIP_FAIL(""bzip2 extension is required"");
				}
				break;
			case 1 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Shrunk) used in this zip"");
			case 2 :
			case 3 :
			case 4 :
			case 5 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Reduce) used in this zip"");
			case 6 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Implode) used in this zip"");
			case 7 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Tokenize) used in this zip"");
			case 9 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (Deflate64) used in this zip"");
			case 10 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip"");
			case 14 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (LZMA) used in this zip"");
			case 18 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (IBM TERSE) used in this zip"");
			case 19 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (IBM LZ77) used in this zip"");
			case 97 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (WavPack) used in this zip"");
			case 98 :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (PPMd) used in this zip"");
			default :
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unsupported compression method (unknown) used in this zip"");
		}

		/* COMMENT_16 */
		if (PHAR_GET_16(VAR_27.comment_len)) {
			if (PHAR_GET_16(VAR_27.comment_len) != php_stream_read(VAR_0, VAR_8, PHAR_GET_16(VAR_27.comment_len))) {
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""unable to read in file comment, truncated"");
			}

			VAR_13 = VAR_8;
			VAR_12.metadata_len = PHAR_GET_16(VAR_27.comment_len);

			if (phar_parse_metadata(&VAR_13, &(VAR_12.metadata), PHAR_GET_16(VAR_27.comment_len)) == VAR_17) {
				VAR_12.metadata_len = 0;
				/* COMMENT_4 */

				ZVAL_NEW_STR(&VAR_12.metadata, zend_string_init(VAR_8, PHAR_GET_16(VAR_27.comment_len), VAR_12.is_persistent));
			}
		} else {
			ZVAL_UNDEF(&VAR_12.metadata);
		}

		if (!VAR_15 && VAR_12.filename_len == sizeof("".phar/alias.txt"")-1 && !strncmp(VAR_12.filename, "".phar/alias.txt"", sizeof("".phar/alias.txt"")-1)) {
			php_stream_filter *VAR_45;
			zend_off_t VAR_46;
			/* COMMENT_17 */
			phar_zip_file_header VAR_47;

			/* COMMENT_18 */
			VAR_46 = php_stream_tell(VAR_0);
			php_stream_seek(VAR_0, PHAR_GET_32(VAR_27.offset), VAR_19);

			if (sizeof(VAR_47) != php_stream_read(VAR_0, (char *) &VAR_47, sizeof(VAR_47))) {
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (cannot read local file header for alias)"");
			}

			/* COMMENT_19 */
			if (VAR_12.filename_len != PHAR_GET_16(VAR_47.filename_len) || VAR_12.crc32 != PHAR_GET_32(VAR_47.crc32) || VAR_12.uncompressed_filesize != PHAR_GET_32(VAR_47.uncompsize) || VAR_12.compressed_filesize != PHAR_GET_32(VAR_47.compsize)) {
				pefree(VAR_12.filename, VAR_12.is_persistent);
				PHAR_ZIP_FAIL(""phar error: internal corruption of zip-based phar (local header of alias does not match central directory)"");
			}

			/* COMMENT_20 */
			VAR_12.offset = VAR_12.offset_abs =
				sizeof(VAR_47) + VAR_12.header_offset + PHAR_GET_16(VAR_47.filename_len) + PHAR_GET_16(VAR_47.extra_len);
			php_stream_seek(VAR_0, VAR_12.offset, VAR_19);
			/* COMMENT_21 */
			VAR_0->writepos = 0;
			VAR_0->readpos = 0;
			php_stream_seek(VAR_0, VAR_12.offset, VAR_19);
			VAR_0->writepos = 0;
			VAR_0->readpos = 0;
			/* COMMENT_22 */

			VAR_11->alias_len = VAR_12.uncompressed_filesize;
			if (VAR_12.flags & VAR_40) {
				VAR_45 = php_stream_filter_create(""zlib.inflate"", NULL, php_stream_is_persistent(VAR_0));

				if (!VAR_45) {
					pefree(VAR_12.filename, VAR_12.is_persistent);
					PHAR_ZIP_FAIL(""unable to decompress alias, zlib filter creation failed"");
				}

				php_stream_filter_append(&VAR_0->readfilters, VAR_45);

				/* COMMENT_23 */
/* COMMENT_24 */
				{
					zend_string *VAR_48 = php_stream_copy_to_mem(VAR_0, VAR_12.uncompressed_filesize, 0);
					if (VAR_48) {
						VAR_12.uncompressed_filesize = ZSTR_LEN(VAR_48);
						VAR_15 = estrndup(ZSTR_VAL(VAR_48), ZSTR_LEN(VAR_48));
						zend_string_release(VAR_48);
					} else {
						VAR_15 = NULL;
						VAR_12.uncompressed_filesize = 0;
					}
				}

				if (!VAR_12.uncompressed_filesize || !VAR_15) {
					pefree(VAR_12.filename, VAR_12.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
				}

				php_stream_filter_flush(VAR_45, 1);
				php_stream_filter_remove(VAR_45, 1);

			} else if (VAR_12.flags & VAR_43) {
				VAR_45 = php_stream_filter_create(""bzip2.decompress"", NULL, php_stream_is_persistent(VAR_0));

				if (!VAR_45) {
					pefree(VAR_12.filename, VAR_12.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, bzip2 filter creation failed"");
				}

				php_stream_filter_append(&VAR_0->readfilters, VAR_45);

				/* COMMENT_23 */
/* COMMENT_24 */
				{
					zend_string *VAR_48 = php_stream_copy_to_mem(VAR_0, VAR_12.uncompressed_filesize, 0);
					if (VAR_48) {
						VAR_12.uncompressed_filesize = ZSTR_LEN(VAR_48);
						VAR_15 = estrndup(ZSTR_VAL(VAR_48), ZSTR_LEN(VAR_48));
						zend_string_release(VAR_48);
					} else {
						VAR_15 = NULL;
						VAR_12.uncompressed_filesize = 0;
					}
				}

				if (!VAR_12.uncompressed_filesize || !VAR_15) {
					pefree(VAR_12.filename, VAR_12.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
				}

				php_stream_filter_flush(VAR_45, 1);
				php_stream_filter_remove(VAR_45, 1);
			} else {
				/* COMMENT_23 */
/* COMMENT_24 */
				{
					zend_string *VAR_48 = php_stream_copy_to_mem(VAR_0, VAR_12.uncompressed_filesize, 0);
					if (VAR_48) {
						VAR_12.uncompressed_filesize = ZSTR_LEN(VAR_48);
						VAR_15 = estrndup(ZSTR_VAL(VAR_48), ZSTR_LEN(VAR_48));
						zend_string_release(VAR_48);
					} else {
						VAR_15 = NULL;
						VAR_12.uncompressed_filesize = 0;
					}
				}

				if (!VAR_12.uncompressed_filesize || !VAR_15) {
					pefree(VAR_12.filename, VAR_12.is_persistent);
					PHAR_ZIP_FAIL(""unable to read in alias, truncated"");
				}
			}

			/* COMMENT_25 */
			php_stream_seek(VAR_0, VAR_46, VAR_19);
		}

		phar_set_inode(&VAR_12);
		zend_hash_str_add_mem(&VAR_11->manifest, VAR_12.filename, VAR_12.filename_len, (void *)&VAR_12, sizeof(phar_entry_info));
	}

	VAR_11->fp = VAR_0;

	if (zend_hash_str_exists(&(VAR_11->manifest), "".phar/stub.php"", sizeof("".phar/stub.php"")-1)) {
		VAR_11->is_data = 0;
	} else {
		VAR_11->is_data = 1;
	}

	zend_hash_str_add_ptr(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2, VAR_11);

	if (VAR_15) {
		phar_archive_data *VAR_50;

		if (!phar_validate_alias(VAR_15, VAR_11->alias_len)) {
			if (VAR_6) {
				spprintf(VAR_6, 4096, ""phar error: invalid alias \""%s\"" in zip-based phar \""%s\"""", VAR_15, VAR_1);
			}
			efree(VAR_15);
			zend_hash_str_del(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2);
			return VAR_17;
		}

		VAR_11->is_temporary_alias = 0;

		if (NULL != (VAR_50 = zend_hash_str_find_ptr(&(PHAR_G(VAR_51)), VAR_15, VAR_11->alias_len))) {
			if (VAR_52 != phar_free_alias(VAR_50, VAR_15, VAR_11->alias_len)) {
				if (VAR_6) {
					spprintf(VAR_6, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with implicit alias, alias is already in use"", VAR_1);
				}
				efree(VAR_15);
				zend_hash_str_del(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2);
				return VAR_17;
			}
		}

		VAR_11->alias = VAR_12.is_persistent ? pestrndup(VAR_15, VAR_11->alias_len, 1) : VAR_15;

		if (VAR_12.is_persistent) {
			efree(VAR_15);
		}

		zend_hash_str_add_ptr(&(PHAR_G(VAR_51)), VAR_15, VAR_11->alias_len, VAR_11);
	} else {
		phar_archive_data *VAR_50;

		if (VAR_4) {
			if (NULL != (VAR_50 = zend_hash_str_find_ptr(&(PHAR_G(VAR_51)), VAR_3, VAR_4))) {
				if (VAR_52 != phar_free_alias(VAR_50, VAR_3, VAR_4)) {
					if (VAR_6) {
						spprintf(VAR_6, 4096, ""phar error: Unable to add zip-based phar \""%s\"" with explicit alias, alias is already in use"", VAR_1);
					}
					zend_hash_str_del(&(PHAR_G(VAR_49)), VAR_11->fname, VAR_2);
					return VAR_17;
				}
			}

			zend_hash_str_add_ptr(&(PHAR_G(VAR_51)), VAR_15, VAR_11->alias_len, VAR_11);
			VAR_11->alias = pestrndup(VAR_3, VAR_4, VAR_11->is_persistent);
			VAR_11->alias_len = VAR_4;
		} else {
			VAR_11->alias = pestrndup(VAR_11->fname, VAR_2, VAR_11->is_persistent);
			VAR_11->alias_len = VAR_2;
		}

		VAR_11->is_temporary_alias = 1;
	}

	if (VAR_5) {
		*VAR_5 = VAR_11;
	}

	return VAR_52;
}",php/php-src/0bfb970f43acd1e81d11be1154805f86655f15d5/zip.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -253,7 +253,7 @@
 			php_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);
 			sig = (char *) emalloc(entry.uncompressed_filesize);
 			read = php_stream_read(fp, sig, entry.uncompressed_filesize);
-			if (read != entry.uncompressed_filesize) {
+			if (read != entry.uncompressed_filesize || read <= 8) {
 				php_stream_close(sigfile);
 				efree(sig);
 				PHAR_ZIP_FAIL(""signature cannot be read"");","{'deleted_lines': ['\t\t\tif (read != entry.uncompressed_filesize) {'], 'added_lines': ['\t\t\tif (read != entry.uncompressed_filesize || read <= 8) {']}",True,"The ZIP signature-verification feature in PHP before 5.6.26 and 7.x before 7.0.11 does not ensure that the uncompressed_filesize field is large enough, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via a crafted PHAR archive, related to ext/phar/util.c and ext/phar/zip.c.",9.8,CRITICAL,3,valid,2016-09-05T05:07:35Z,1
CVE-2016-7414,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,"Fix bug #72928 - Out of bound when verify signature of zip phar in phar_parse_zipfile

(cherry picked from commit 19484ab77466f99c78fc0e677f7e03da0584d6a2)",0bfb970f43acd1e81d11be1154805f86655f15d5,https://github.com/php/php-src/commit/0bfb970f43acd1e81d11be1154805f86655f15d5,ext/phar/util.c,phar_verify_signature,"int phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error) 
{
int read_size, len;
zend_off_t read_len;
unsigned char buf[1024];
php_stream_rewind(fp);
switch (sig_type) {
case PHAR_SIG_OPENSSL: {
#ifdef PHAR_HAVE_OPENSSL
BIO *in;
EVP_PKEY *key;
EVP_MD *mdtype = (EVP_MD *) EVP_sha1();
EVP_MD_CTX md_ctx;
#else
int tempsig;
#endif
zend_string *pubkey = NULL;
char *pfile;
php_stream *pfp;
#ifndef PHAR_HAVE_OPENSSL
if (!zend_hash_str_exists(&module_registry, ""openssl"", sizeof(""openssl"")-1)) {
if (error) {
spprintf(error, 0, ""openssl not loaded"");
}
return FAILURE;
}
#endif
spprintf(&pfile, 0, ""%s.pubkey"", fname);
pfp = php_stream_open_wrapper(pfile, ""rb"", 0, NULL);
efree(pfile);
if (!pfp || !(pubkey = php_stream_copy_to_mem(pfp, PHP_STREAM_COPY_ALL, 0)) || !ZSTR_LEN(pubkey)) {
if (pfp) {
php_stream_close(pfp);
}
if (error) {
spprintf(error, 0, ""openssl public key could not be read"");
}
return FAILURE;
}
php_stream_close(pfp);
#ifndef PHAR_HAVE_OPENSSL
tempsig = sig_len;
if (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0, &sig, &tempsig)) {
if (pubkey) {
zend_string_release(pubkey);
}
if (error) {
spprintf(error, 0, ""openssl signature could not be verified"");
}
return FAILURE;
}
if (pubkey) {
zend_string_release(pubkey);
}
sig_len = tempsig;
#else
in = BIO_new_mem_buf(pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0);
if (NULL == in) {
zend_string_release(pubkey);
if (error) {
spprintf(error, 0, ""openssl signature could not be processed"");
}
return FAILURE;
}
key = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);
BIO_free(in);
zend_string_release(pubkey);
if (NULL == key) {
if (error) {
spprintf(error, 0, ""openssl signature could not be processed"");
}
return FAILURE;
}
EVP_VerifyInit(&md_ctx, mdtype);
read_len = end_of_phar;
if (read_len > sizeof(buf)) {
read_size = sizeof(buf);
} else {
read_size = (int)read_len;
}
php_stream_seek(fp, 0, SEEK_SET);
while (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
EVP_VerifyUpdate (&md_ctx, buf, len);
read_len -= (zend_off_t)len;
if (read_len < read_size) {
read_size = (int)read_len;
}
}
if (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {
EVP_MD_CTX_cleanup(&md_ctx);
if (error) {
spprintf(error, 0, ""broken openssl signature"");
}
return FAILURE;
}
EVP_MD_CTX_cleanup(&md_ctx);
#endif
*signature_len = phar_hex_str((const char*)sig, sig_len, signature);
}
break;
#ifdef PHAR_HASH_OK
case PHAR_SIG_SHA512: {
unsigned char digest[64];
PHP_SHA512_CTX context;
PHP_SHA512Init(&context);
read_len = end_of_phar;
if (read_len > sizeof(buf)) {
read_size = sizeof(buf);
} else {
read_size = (int)read_len;
}
while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
PHP_SHA512Update(&context, buf, len);
read_len -= (zend_off_t)len;
if (read_len < read_size) {
read_size = (int)read_len;
}
}
PHP_SHA512Final(digest, &context);
if (memcmp(digest, sig, sizeof(digest))) {
if (error) {
spprintf(error, 0, ""broken signature"");
}
return FAILURE;
}
*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
break;
}
case PHAR_SIG_SHA256: {
unsigned char digest[32];
PHP_SHA256_CTX context;
PHP_SHA256Init(&context);
read_len = end_of_phar;
if (read_len > sizeof(buf)) {
read_size = sizeof(buf);
} else {
read_size = (int)read_len;
}
while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
PHP_SHA256Update(&context, buf, len);
read_len -= (zend_off_t)len;
if (read_len < read_size) {
read_size = (int)read_len;
}
}
PHP_SHA256Final(digest, &context);
if (memcmp(digest, sig, sizeof(digest))) {
if (error) {
spprintf(error, 0, ""broken signature"");
}
return FAILURE;
}
*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
break;
}
#else
case PHAR_SIG_SHA512:
case PHAR_SIG_SHA256:
if (error) {
spprintf(error, 0, ""unsupported signature"");
}
return FAILURE;
#endif
case PHAR_SIG_SHA1: {
unsigned char digest[20];
PHP_SHA1_CTX  context;
PHP_SHA1Init(&context);
read_len = end_of_phar;
if (read_len > sizeof(buf)) {
read_size = sizeof(buf);
} else {
read_size = (int)read_len;
}
while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
PHP_SHA1Update(&context, buf, len);
read_len -= (zend_off_t)len;
if (read_len < read_size) {
read_size = (int)read_len;
}
}
PHP_SHA1Final(digest, &context);
if (memcmp(digest, sig, sizeof(digest))) {
if (error) {
spprintf(error, 0, ""broken signature"");
}
return FAILURE;
}
*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
break;
}
case PHAR_SIG_MD5: {
unsigned char digest[16];
PHP_MD5_CTX   context;
PHP_MD5Init(&context);
read_len = end_of_phar;
if (read_len > sizeof(buf)) {
read_size = sizeof(buf);
} else {
read_size = (int)read_len;
}
while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
PHP_MD5Update(&context, buf, len);
read_len -= (zend_off_t)len;
if (read_len < read_size) {
read_size = (int)read_len;
}
}
PHP_MD5Final(digest, &context);
if (memcmp(digest, sig, sizeof(digest))) {
if (error) {
spprintf(error, 0, ""broken signature"");
}
return FAILURE;
}
*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
break;
}
default:
if (error) {
spprintf(error, 0, ""broken or unsupported signature"");
}
return FAILURE;
}
return SUCCESS;
}","int phar_verify_signature(php_stream *VAR_0, size_t VAR_1, php_uint32 VAR_2, char *VAR_3, int VAR_4, char *VAR_5, char **VAR_6, int *VAR_7, char **VAR_8) 
{
int VAR_9, VAR_10;
zend_off_t VAR_11;
unsigned char VAR_12[1024];
php_stream_rewind(VAR_0);
switch (VAR_2) {
case VAR_13: {
#ifdef VAR_14
BIO *VAR_15;
EVP_PKEY *VAR_16;
EVP_MD *VAR_17 = (EVP_MD *) EVP_sha1();
EVP_MD_CTX VAR_18;
#else
int VAR_19;
#endif
zend_string *VAR_20 = NULL;
char *VAR_21;
php_stream *VAR_22;
#ifndef VAR_14
if (!zend_hash_str_exists(&VAR_23, ""openssl"", sizeof(""openssl"")-1)) {
if (VAR_8) {
spprintf(VAR_8, 0, ""openssl not loaded"");
}
return VAR_24;
}
#endif
spprintf(&VAR_21, 0, ""%s.pubkey"", VAR_5);
VAR_22 = php_stream_open_wrapper(VAR_21, ""rb"", 0, NULL);
efree(VAR_21);
if (!VAR_22 || !(VAR_20 = php_stream_copy_to_mem(VAR_22, VAR_25, 0)) || !ZSTR_LEN(VAR_20)) {
if (VAR_22) {
php_stream_close(VAR_22);
}
if (VAR_8) {
spprintf(VAR_8, 0, ""openssl public key could not be read"");
}
return VAR_24;
}
php_stream_close(VAR_22);
#ifndef VAR_14
VAR_19 = VAR_4;
if (VAR_24 == phar_call_openssl_signverify(0, VAR_0, VAR_1, VAR_20 ? ZSTR_VAL(VAR_20) : NULL, VAR_20 ? ZSTR_LEN(VAR_20) : 0, &VAR_3, &VAR_19)) {
if (VAR_20) {
zend_string_release(VAR_20);
}
if (VAR_8) {
spprintf(VAR_8, 0, ""openssl signature could not be verified"");
}
return VAR_24;
}
if (VAR_20) {
zend_string_release(VAR_20);
}
VAR_4 = VAR_19;
#else
VAR_15 = BIO_new_mem_buf(VAR_20 ? ZSTR_VAL(VAR_20) : NULL, VAR_20 ? ZSTR_LEN(VAR_20) : 0);
if (NULL == VAR_15) {
zend_string_release(VAR_20);
if (VAR_8) {
spprintf(VAR_8, 0, ""openssl signature could not be processed"");
}
return VAR_24;
}
VAR_16 = PEM_read_bio_PUBKEY(VAR_15, NULL,NULL, NULL);
BIO_free(VAR_15);
zend_string_release(VAR_20);
if (NULL == VAR_16) {
if (VAR_8) {
spprintf(VAR_8, 0, ""openssl signature could not be processed"");
}
return VAR_24;
}
EVP_VerifyInit(&VAR_18, VAR_17);
VAR_11 = VAR_1;
if (VAR_11 > sizeof(VAR_12)) {
VAR_9 = sizeof(VAR_12);
} else {
VAR_9 = (int)VAR_11;
}
php_stream_seek(VAR_0, 0, VAR_26);
while (VAR_9 && (VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
EVP_VerifyUpdate (&VAR_18, VAR_12, VAR_10);
VAR_11 -= (zend_off_t)VAR_10;
if (VAR_11 < VAR_9) {
VAR_9 = (int)VAR_11;
}
}
if (EVP_VerifyFinal(&VAR_18, (unsigned char *)VAR_3, VAR_4, VAR_16) != 1) {
EVP_MD_CTX_cleanup(&VAR_18);
if (VAR_8) {
spprintf(VAR_8, 0, ""broken openssl signature"");
}
return VAR_24;
}
EVP_MD_CTX_cleanup(&VAR_18);
#endif
*VAR_7 = phar_hex_str((const char*)VAR_3, VAR_4, VAR_6);
}
break;
#ifdef VAR_27
case VAR_28: {
unsigned char VAR_29[64];
PHP_SHA512_CTX VAR_30;
PHP_SHA512Init(&VAR_30);
VAR_11 = VAR_1;
if (VAR_11 > sizeof(VAR_12)) {
VAR_9 = sizeof(VAR_12);
} else {
VAR_9 = (int)VAR_11;
}
while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
PHP_SHA512Update(&VAR_30, VAR_12, VAR_10);
VAR_11 -= (zend_off_t)VAR_10;
if (VAR_11 < VAR_9) {
VAR_9 = (int)VAR_11;
}
}
PHP_SHA512Final(VAR_29, &VAR_30);
if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
if (VAR_8) {
spprintf(VAR_8, 0, ""broken signature"");
}
return VAR_24;
}
*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
break;
}
case VAR_31: {
unsigned char VAR_29[32];
PHP_SHA256_CTX VAR_30;
PHP_SHA256Init(&VAR_30);
VAR_11 = VAR_1;
if (VAR_11 > sizeof(VAR_12)) {
VAR_9 = sizeof(VAR_12);
} else {
VAR_9 = (int)VAR_11;
}
while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
PHP_SHA256Update(&VAR_30, VAR_12, VAR_10);
VAR_11 -= (zend_off_t)VAR_10;
if (VAR_11 < VAR_9) {
VAR_9 = (int)VAR_11;
}
}
PHP_SHA256Final(VAR_29, &VAR_30);
if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
if (VAR_8) {
spprintf(VAR_8, 0, ""broken signature"");
}
return VAR_24;
}
*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
break;
}
#else
case VAR_28:
case VAR_31:
if (VAR_8) {
spprintf(VAR_8, 0, ""unsupported signature"");
}
return VAR_24;
#endif
case VAR_32: {
unsigned char VAR_29[20];
PHP_SHA1_CTX  VAR_30;
PHP_SHA1Init(&VAR_30);
VAR_11 = VAR_1;
if (VAR_11 > sizeof(VAR_12)) {
VAR_9 = sizeof(VAR_12);
} else {
VAR_9 = (int)VAR_11;
}
while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
PHP_SHA1Update(&VAR_30, VAR_12, VAR_10);
VAR_11 -= (zend_off_t)VAR_10;
if (VAR_11 < VAR_9) {
VAR_9 = (int)VAR_11;
}
}
PHP_SHA1Final(VAR_29, &VAR_30);
if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
if (VAR_8) {
spprintf(VAR_8, 0, ""broken signature"");
}
return VAR_24;
}
*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
break;
}
case VAR_33: {
unsigned char VAR_29[16];
PHP_MD5_CTX   VAR_30;
PHP_MD5Init(&VAR_30);
VAR_11 = VAR_1;
if (VAR_11 > sizeof(VAR_12)) {
VAR_9 = sizeof(VAR_12);
} else {
VAR_9 = (int)VAR_11;
}
while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
PHP_MD5Update(&VAR_30, VAR_12, VAR_10);
VAR_11 -= (zend_off_t)VAR_10;
if (VAR_11 < VAR_9) {
VAR_9 = (int)VAR_11;
}
}
PHP_MD5Final(VAR_29, &VAR_30);
if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
if (VAR_8) {
spprintf(VAR_8, 0, ""broken signature"");
}
return VAR_24;
}
*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
break;
}
default:
if (VAR_8) {
spprintf(VAR_8, 0, ""broken or unsupported signature"");
}
return VAR_24;
}
return VAR_34;
}",php/php-src/0bfb970f43acd1e81d11be1154805f86655f15d5/util.c/vul/before/0.json,"int phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error) /* {{{ */
{
	int read_size, len;
	zend_off_t read_len;
	unsigned char buf[1024];

	php_stream_rewind(fp);

	switch (sig_type) {
		case PHAR_SIG_OPENSSL: {
#ifdef PHAR_HAVE_OPENSSL
			BIO *in;
			EVP_PKEY *key;
			EVP_MD *mdtype = (EVP_MD *) EVP_sha1();
			EVP_MD_CTX md_ctx;
#else
			int tempsig;
#endif
			zend_string *pubkey = NULL;
			char *pfile;
			php_stream *pfp;
#ifndef PHAR_HAVE_OPENSSL
			if (!zend_hash_str_exists(&module_registry, ""openssl"", sizeof(""openssl"")-1)) {
				if (error) {
					spprintf(error, 0, ""openssl not loaded"");
				}
				return FAILURE;
			}
#endif
			/* use __FILE__ . '.pubkey' for public key file */
			spprintf(&pfile, 0, ""%s.pubkey"", fname);
			pfp = php_stream_open_wrapper(pfile, ""rb"", 0, NULL);
			efree(pfile);

			if (!pfp || !(pubkey = php_stream_copy_to_mem(pfp, PHP_STREAM_COPY_ALL, 0)) || !ZSTR_LEN(pubkey)) {
				if (pfp) {
					php_stream_close(pfp);
				}
				if (error) {
					spprintf(error, 0, ""openssl public key could not be read"");
				}
				return FAILURE;
			}

			php_stream_close(pfp);
#ifndef PHAR_HAVE_OPENSSL
			tempsig = sig_len;

			if (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0, &sig, &tempsig)) {
				if (pubkey) {
					zend_string_release(pubkey);
				}

				if (error) {
					spprintf(error, 0, ""openssl signature could not be verified"");
				}

				return FAILURE;
			}

			if (pubkey) {
				zend_string_release(pubkey);
			}

			sig_len = tempsig;
#else
			in = BIO_new_mem_buf(pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0);

			if (NULL == in) {
				zend_string_release(pubkey);
				if (error) {
					spprintf(error, 0, ""openssl signature could not be processed"");
				}
				return FAILURE;
			}

			key = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);
			BIO_free(in);
			zend_string_release(pubkey);

			if (NULL == key) {
				if (error) {
					spprintf(error, 0, ""openssl signature could not be processed"");
				}
				return FAILURE;
			}

			EVP_VerifyInit(&md_ctx, mdtype);
			read_len = end_of_phar;

			if (read_len > sizeof(buf)) {
				read_size = sizeof(buf);
			} else {
				read_size = (int)read_len;
			}

			php_stream_seek(fp, 0, SEEK_SET);

			while (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
				EVP_VerifyUpdate (&md_ctx, buf, len);
				read_len -= (zend_off_t)len;

				if (read_len < read_size) {
					read_size = (int)read_len;
				}
			}

			if (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {
				/* 1: signature verified, 0: signature does not match, -1: failed signature operation */
				EVP_MD_CTX_cleanup(&md_ctx);

				if (error) {
					spprintf(error, 0, ""broken openssl signature"");
				}

				return FAILURE;
			}

			EVP_MD_CTX_cleanup(&md_ctx);
#endif

			*signature_len = phar_hex_str((const char*)sig, sig_len, signature);
		}
		break;
#ifdef PHAR_HASH_OK
		case PHAR_SIG_SHA512: {
			unsigned char digest[64];
			PHP_SHA512_CTX context;

			if (sig_len < sizeof(digest)) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			PHP_SHA512Init(&context);
			read_len = end_of_phar;

			if (read_len > sizeof(buf)) {
				read_size = sizeof(buf);
			} else {
				read_size = (int)read_len;
			}

			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
				PHP_SHA512Update(&context, buf, len);
				read_len -= (zend_off_t)len;
				if (read_len < read_size) {
					read_size = (int)read_len;
				}
			}

			PHP_SHA512Final(digest, &context);

			if (memcmp(digest, sig, sizeof(digest))) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
			break;
		}
		case PHAR_SIG_SHA256: {
			unsigned char digest[32];
			PHP_SHA256_CTX context;

			if (sig_len < sizeof(digest)) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			PHP_SHA256Init(&context);
			read_len = end_of_phar;

			if (read_len > sizeof(buf)) {
				read_size = sizeof(buf);
			} else {
				read_size = (int)read_len;
			}

			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
				PHP_SHA256Update(&context, buf, len);
				read_len -= (zend_off_t)len;
				if (read_len < read_size) {
					read_size = (int)read_len;
				}
			}

			PHP_SHA256Final(digest, &context);

			if (memcmp(digest, sig, sizeof(digest))) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
			break;
		}
#else
		case PHAR_SIG_SHA512:
		case PHAR_SIG_SHA256:
			if (error) {
				spprintf(error, 0, ""unsupported signature"");
			}
			return FAILURE;
#endif
		case PHAR_SIG_SHA1: {
			unsigned char digest[20];
			PHP_SHA1_CTX  context;

			if (sig_len < sizeof(digest)) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			PHP_SHA1Init(&context);
			read_len = end_of_phar;

			if (read_len > sizeof(buf)) {
				read_size = sizeof(buf);
			} else {
				read_size = (int)read_len;
			}

			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
				PHP_SHA1Update(&context, buf, len);
				read_len -= (zend_off_t)len;
				if (read_len < read_size) {
					read_size = (int)read_len;
				}
			}

			PHP_SHA1Final(digest, &context);

			if (memcmp(digest, sig, sizeof(digest))) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
			break;
		}
		case PHAR_SIG_MD5: {
			unsigned char digest[16];
			PHP_MD5_CTX   context;

			if (sig_len < sizeof(digest)) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			PHP_MD5Init(&context);
			read_len = end_of_phar;

			if (read_len > sizeof(buf)) {
				read_size = sizeof(buf);
			} else {
				read_size = (int)read_len;
			}

			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
				PHP_MD5Update(&context, buf, len);
				read_len -= (zend_off_t)len;
				if (read_len < read_size) {
					read_size = (int)read_len;
				}
			}

			PHP_MD5Final(digest, &context);

			if (memcmp(digest, sig, sizeof(digest))) {
				if (error) {
					spprintf(error, 0, ""broken signature"");
				}
				return FAILURE;
			}

			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);
			break;
		}
		default:
			if (error) {
				spprintf(error, 0, ""broken or unsupported signature"");
			}
			return FAILURE;
	}
	return SUCCESS;
}","int phar_verify_signature(php_stream *VAR_0, size_t VAR_1, php_uint32 VAR_2, char *VAR_3, int VAR_4, char *VAR_5, char **VAR_6, int *VAR_7, char **VAR_8) /* COMMENT_0 */
{
	int VAR_9, VAR_10;
	zend_off_t VAR_11;
	unsigned char VAR_12[1024];

	php_stream_rewind(VAR_0);

	switch (VAR_2) {
		case VAR_13: {
#ifdef VAR_14
			BIO *VAR_15;
			EVP_PKEY *VAR_16;
			EVP_MD *VAR_17 = (EVP_MD *) EVP_sha1();
			EVP_MD_CTX VAR_18;
#else
			int VAR_19;
#endif
			zend_string *VAR_20 = NULL;
			char *VAR_21;
			php_stream *VAR_22;
#ifndef VAR_14
			if (!zend_hash_str_exists(&VAR_23, ""openssl"", sizeof(""openssl"")-1)) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""openssl not loaded"");
				}
				return VAR_24;
			}
#endif
			/* COMMENT_1 */
			spprintf(&VAR_21, 0, ""%s.pubkey"", VAR_5);
			VAR_22 = php_stream_open_wrapper(VAR_21, ""rb"", 0, NULL);
			efree(VAR_21);

			if (!VAR_22 || !(VAR_20 = php_stream_copy_to_mem(VAR_22, VAR_25, 0)) || !ZSTR_LEN(VAR_20)) {
				if (VAR_22) {
					php_stream_close(VAR_22);
				}
				if (VAR_8) {
					spprintf(VAR_8, 0, ""openssl public key could not be read"");
				}
				return VAR_24;
			}

			php_stream_close(VAR_22);
#ifndef VAR_14
			VAR_19 = VAR_4;

			if (VAR_24 == phar_call_openssl_signverify(0, VAR_0, VAR_1, VAR_20 ? ZSTR_VAL(VAR_20) : NULL, VAR_20 ? ZSTR_LEN(VAR_20) : 0, &VAR_3, &VAR_19)) {
				if (VAR_20) {
					zend_string_release(VAR_20);
				}

				if (VAR_8) {
					spprintf(VAR_8, 0, ""openssl signature could not be verified"");
				}

				return VAR_24;
			}

			if (VAR_20) {
				zend_string_release(VAR_20);
			}

			VAR_4 = VAR_19;
#else
			VAR_15 = BIO_new_mem_buf(VAR_20 ? ZSTR_VAL(VAR_20) : NULL, VAR_20 ? ZSTR_LEN(VAR_20) : 0);

			if (NULL == VAR_15) {
				zend_string_release(VAR_20);
				if (VAR_8) {
					spprintf(VAR_8, 0, ""openssl signature could not be processed"");
				}
				return VAR_24;
			}

			VAR_16 = PEM_read_bio_PUBKEY(VAR_15, NULL,NULL, NULL);
			BIO_free(VAR_15);
			zend_string_release(VAR_20);

			if (NULL == VAR_16) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""openssl signature could not be processed"");
				}
				return VAR_24;
			}

			EVP_VerifyInit(&VAR_18, VAR_17);
			VAR_11 = VAR_1;

			if (VAR_11 > sizeof(VAR_12)) {
				VAR_9 = sizeof(VAR_12);
			} else {
				VAR_9 = (int)VAR_11;
			}

			php_stream_seek(VAR_0, 0, VAR_26);

			while (VAR_9 && (VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
				EVP_VerifyUpdate (&VAR_18, VAR_12, VAR_10);
				VAR_11 -= (zend_off_t)VAR_10;

				if (VAR_11 < VAR_9) {
					VAR_9 = (int)VAR_11;
				}
			}

			if (EVP_VerifyFinal(&VAR_18, (unsigned char *)VAR_3, VAR_4, VAR_16) != 1) {
				/* COMMENT_2 */
				EVP_MD_CTX_cleanup(&VAR_18);

				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken openssl signature"");
				}

				return VAR_24;
			}

			EVP_MD_CTX_cleanup(&VAR_18);
#endif

			*VAR_7 = phar_hex_str((const char*)VAR_3, VAR_4, VAR_6);
		}
		break;
#ifdef VAR_27
		case VAR_28: {
			unsigned char VAR_29[64];
			PHP_SHA512_CTX VAR_30;

			if (VAR_4 < sizeof(VAR_29)) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			PHP_SHA512Init(&VAR_30);
			VAR_11 = VAR_1;

			if (VAR_11 > sizeof(VAR_12)) {
				VAR_9 = sizeof(VAR_12);
			} else {
				VAR_9 = (int)VAR_11;
			}

			while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
				PHP_SHA512Update(&VAR_30, VAR_12, VAR_10);
				VAR_11 -= (zend_off_t)VAR_10;
				if (VAR_11 < VAR_9) {
					VAR_9 = (int)VAR_11;
				}
			}

			PHP_SHA512Final(VAR_29, &VAR_30);

			if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
			break;
		}
		case VAR_31: {
			unsigned char VAR_29[32];
			PHP_SHA256_CTX VAR_30;

			if (VAR_4 < sizeof(VAR_29)) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			PHP_SHA256Init(&VAR_30);
			VAR_11 = VAR_1;

			if (VAR_11 > sizeof(VAR_12)) {
				VAR_9 = sizeof(VAR_12);
			} else {
				VAR_9 = (int)VAR_11;
			}

			while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
				PHP_SHA256Update(&VAR_30, VAR_12, VAR_10);
				VAR_11 -= (zend_off_t)VAR_10;
				if (VAR_11 < VAR_9) {
					VAR_9 = (int)VAR_11;
				}
			}

			PHP_SHA256Final(VAR_29, &VAR_30);

			if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
			break;
		}
#else
		case VAR_28:
		case VAR_31:
			if (VAR_8) {
				spprintf(VAR_8, 0, ""unsupported signature"");
			}
			return VAR_24;
#endif
		case VAR_32: {
			unsigned char VAR_29[20];
			PHP_SHA1_CTX  VAR_30;

			if (VAR_4 < sizeof(VAR_29)) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			PHP_SHA1Init(&VAR_30);
			VAR_11 = VAR_1;

			if (VAR_11 > sizeof(VAR_12)) {
				VAR_9 = sizeof(VAR_12);
			} else {
				VAR_9 = (int)VAR_11;
			}

			while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
				PHP_SHA1Update(&VAR_30, VAR_12, VAR_10);
				VAR_11 -= (zend_off_t)VAR_10;
				if (VAR_11 < VAR_9) {
					VAR_9 = (int)VAR_11;
				}
			}

			PHP_SHA1Final(VAR_29, &VAR_30);

			if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
			break;
		}
		case VAR_33: {
			unsigned char VAR_29[16];
			PHP_MD5_CTX   VAR_30;

			if (VAR_4 < sizeof(VAR_29)) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			PHP_MD5Init(&VAR_30);
			VAR_11 = VAR_1;

			if (VAR_11 > sizeof(VAR_12)) {
				VAR_9 = sizeof(VAR_12);
			} else {
				VAR_9 = (int)VAR_11;
			}

			while ((VAR_10 = php_stream_read(VAR_0, (char*)VAR_12, VAR_9)) > 0) {
				PHP_MD5Update(&VAR_30, VAR_12, VAR_10);
				VAR_11 -= (zend_off_t)VAR_10;
				if (VAR_11 < VAR_9) {
					VAR_9 = (int)VAR_11;
				}
			}

			PHP_MD5Final(VAR_29, &VAR_30);

			if (memcmp(VAR_29, VAR_3, sizeof(VAR_29))) {
				if (VAR_8) {
					spprintf(VAR_8, 0, ""broken signature"");
				}
				return VAR_24;
			}

			*VAR_7 = phar_hex_str((const char*)VAR_29, sizeof(VAR_29), VAR_6);
			break;
		}
		default:
			if (VAR_8) {
				spprintf(VAR_8, 0, ""broken or unsupported signature"");
			}
			return VAR_24;
	}
	return VAR_34;
}",php/php-src/0bfb970f43acd1e81d11be1154805f86655f15d5/util.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -127,6 +127,13 @@
 			unsigned char digest[64];
 			PHP_SHA512_CTX context;
 
+			if (sig_len < sizeof(digest)) {
+				if (error) {
+					spprintf(error, 0, ""broken signature"");
+				}
+				return FAILURE;
+			}
+
 			PHP_SHA512Init(&context);
 			read_len = end_of_phar;
 
@@ -159,6 +166,13 @@
 		case PHAR_SIG_SHA256: {
 			unsigned char digest[32];
 			PHP_SHA256_CTX context;
+
+			if (sig_len < sizeof(digest)) {
+				if (error) {
+					spprintf(error, 0, ""broken signature"");
+				}
+				return FAILURE;
+			}
 
 			PHP_SHA256Init(&context);
 			read_len = end_of_phar;
@@ -201,6 +215,13 @@
 			unsigned char digest[20];
 			PHP_SHA1_CTX  context;
 
+			if (sig_len < sizeof(digest)) {
+				if (error) {
+					spprintf(error, 0, ""broken signature"");
+				}
+				return FAILURE;
+			}
+
 			PHP_SHA1Init(&context);
 			read_len = end_of_phar;
 
@@ -233,6 +254,13 @@
 		case PHAR_SIG_MD5: {
 			unsigned char digest[16];
 			PHP_MD5_CTX   context;
+
+			if (sig_len < sizeof(digest)) {
+				if (error) {
+					spprintf(error, 0, ""broken signature"");
+				}
+				return FAILURE;
+			}
 
 			PHP_MD5Init(&context);
 			read_len = end_of_phar;","{'deleted_lines': [], 'added_lines': ['\t\t\tif (sig_len < sizeof(digest)) {', '\t\t\t\tif (error) {', '\t\t\t\t\tspprintf(error, 0, ""broken signature"");', '\t\t\t\t}', '\t\t\t\treturn FAILURE;', '\t\t\t}', '', '', '\t\t\tif (sig_len < sizeof(digest)) {', '\t\t\t\tif (error) {', '\t\t\t\t\tspprintf(error, 0, ""broken signature"");', '\t\t\t\t}', '\t\t\t\treturn FAILURE;', '\t\t\t}', '\t\t\tif (sig_len < sizeof(digest)) {', '\t\t\t\tif (error) {', '\t\t\t\t\tspprintf(error, 0, ""broken signature"");', '\t\t\t\t}', '\t\t\t\treturn FAILURE;', '\t\t\t}', '', '', '\t\t\tif (sig_len < sizeof(digest)) {', '\t\t\t\tif (error) {', '\t\t\t\t\tspprintf(error, 0, ""broken signature"");', '\t\t\t\t}', '\t\t\t\treturn FAILURE;', '\t\t\t}']}",True,"The ZIP signature-verification feature in PHP before 5.6.26 and 7.x before 7.0.11 does not ensure that the uncompressed_filesize field is large enough, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via a crafted PHAR archive, related to ext/phar/util.c and ext/phar/zip.c.",9.8,CRITICAL,3,valid,2016-09-05T05:07:35Z,1
CVE-2016-7170,['CWE-129'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu,"vmsvga: correct bitmap and pixmap size checks

When processing svga command DEFINE_CURSOR in vmsvga_fifo_run,
the computed BITMAP and PIXMAP size are checked against the
'cursor.mask[]' and 'cursor.image[]' array sizes in bytes.
Correct these checks to avoid OOB memory access.

Reported-by: Qinghao Tang <luodalongde@gmail.com>
Reported-by: Li Qiang <liqiang6-s@360.cn>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
Message-id: 1473338754-15430-1-git-send-email-ppandit@redhat.com
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>",167d97a3def77ee2dbf6e908b0ecbfe2103977db,https://github.com/qemu/qemu/commit/167d97a3def77ee2dbf6e908b0ecbfe2103977db,hw/display/vmware_vga.c,vmsvga_fifo_run,"static void vmsvga_fifo_run(struct vmsvga_state_s *s)
{
uint32_t cmd, colour;
int args, len, maxloop = 1024;
int x, y, dx, dy, width, height;
struct vmsvga_cursor_definition_s cursor;
uint32_t cmd_start;
len = vmsvga_fifo_length(s);
while (len > 0 && --maxloop > 0) {
cmd_start = s->fifo_stop;
switch (cmd = vmsvga_fifo_read(s)) {
case SVGA_CMD_UPDATE:
case SVGA_CMD_UPDATE_VERBOSE:
len -= 5;
if (len < 0) {
goto rewind;
}
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
width = vmsvga_fifo_read(s);
height = vmsvga_fifo_read(s);
vmsvga_update_rect_delayed(s, x, y, width, height);
break;
case SVGA_CMD_RECT_FILL:
len -= 6;
if (len < 0) {
goto rewind;
}
colour = vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
width = vmsvga_fifo_read(s);
height = vmsvga_fifo_read(s);
#ifdef HW_FILL_ACCEL
if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
break;
}
#endif
args = 0;
goto badcmd;
case SVGA_CMD_RECT_COPY:
len -= 7;
if (len < 0) {
goto rewind;
}
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
dx = vmsvga_fifo_read(s);
dy = vmsvga_fifo_read(s);
width = vmsvga_fifo_read(s);
height = vmsvga_fifo_read(s);
#ifdef HW_RECT_ACCEL
if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
break;
}
#endif
args = 0;
goto badcmd;
case SVGA_CMD_DEFINE_CURSOR:
len -= 8;
if (len < 0) {
goto rewind;
}
cursor.id = vmsvga_fifo_read(s);
cursor.hot_x = vmsvga_fifo_read(s);
cursor.hot_y = vmsvga_fifo_read(s);
cursor.width = x = vmsvga_fifo_read(s);
cursor.height = y = vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
cursor.bpp = vmsvga_fifo_read(s);
args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
if (cursor.width > 256 ||
cursor.height > 256 ||
cursor.bpp > 32 ||
SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
goto badcmd;
}
len -= args;
if (len < 0) {
goto rewind;
}
for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {
cursor.mask[args] = vmsvga_fifo_read_raw(s);
}
for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {
cursor.image[args] = vmsvga_fifo_read_raw(s);
}
#ifdef HW_MOUSE_ACCEL
vmsvga_cursor_define(s, &cursor);
break;
#else
args = 0;
goto badcmd;
#endif
case SVGA_CMD_DEFINE_ALPHA_CURSOR:
len -= 6;
if (len < 0) {
goto rewind;
}
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
x = vmsvga_fifo_read(s);
y = vmsvga_fifo_read(s);
args = x * y;
goto badcmd;
case SVGA_CMD_RECT_ROP_FILL:
args = 6;
goto badcmd;
case SVGA_CMD_RECT_ROP_COPY:
args = 7;
goto badcmd;
case SVGA_CMD_DRAW_GLYPH_CLIPPED:
len -= 4;
if (len < 0) {
goto rewind;
}
vmsvga_fifo_read(s);
vmsvga_fifo_read(s);
args = 7 + (vmsvga_fifo_read(s) >> 2);
goto badcmd;
case SVGA_CMD_SURFACE_ALPHA_BLEND:
args = 12;
goto badcmd;
case SVGA_CMD_SURFACE_FILL:
case SVGA_CMD_SURFACE_COPY:
case SVGA_CMD_FRONT_ROP_FILL:
case SVGA_CMD_FENCE:
case SVGA_CMD_INVALID_CMD:
break; 
default:
args = 0;
badcmd:
len -= args;
if (len < 0) {
goto rewind;
}
while (args--) {
vmsvga_fifo_read(s);
}
printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
__func__, cmd);
break;
rewind:
s->fifo_stop = cmd_start;
s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);
break;
}
}
s->syncing = 0;
}","static void vmsvga_fifo_run(struct vmsvga_state_s *VAR_0)
{
uint32_t VAR_1, VAR_2;
int VAR_3, VAR_4, VAR_5 = 1024;
int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
struct vmsvga_cursor_definition_s VAR_12;
uint32_t VAR_13;
VAR_4 = vmsvga_fifo_length(VAR_0);
while (VAR_4 > 0 && --VAR_5 > 0) {
VAR_13 = VAR_0->fifo_stop;
switch (VAR_1 = vmsvga_fifo_read(VAR_0)) {
case VAR_14:
case VAR_15:
VAR_4 -= 5;
if (VAR_4 < 0) {
goto rewind;
}
VAR_6 = vmsvga_fifo_read(VAR_0);
VAR_7 = vmsvga_fifo_read(VAR_0);
VAR_10 = vmsvga_fifo_read(VAR_0);
VAR_11 = vmsvga_fifo_read(VAR_0);
vmsvga_update_rect_delayed(VAR_0, VAR_6, VAR_7, VAR_10, VAR_11);
break;
case VAR_16:
VAR_4 -= 6;
if (VAR_4 < 0) {
goto rewind;
}
VAR_2 = vmsvga_fifo_read(VAR_0);
VAR_6 = vmsvga_fifo_read(VAR_0);
VAR_7 = vmsvga_fifo_read(VAR_0);
VAR_10 = vmsvga_fifo_read(VAR_0);
VAR_11 = vmsvga_fifo_read(VAR_0);
#ifdef VAR_17
if (vmsvga_fill_rect(VAR_0, VAR_2, VAR_6, VAR_7, VAR_10, VAR_11) == 0) {
break;
}
#endif
VAR_3 = 0;
goto badcmd;
case VAR_18:
VAR_4 -= 7;
if (VAR_4 < 0) {
goto rewind;
}
VAR_6 = vmsvga_fifo_read(VAR_0);
VAR_7 = vmsvga_fifo_read(VAR_0);
VAR_8 = vmsvga_fifo_read(VAR_0);
VAR_9 = vmsvga_fifo_read(VAR_0);
VAR_10 = vmsvga_fifo_read(VAR_0);
VAR_11 = vmsvga_fifo_read(VAR_0);
#ifdef VAR_19
if (vmsvga_copy_rect(VAR_0, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11) == 0) {
break;
}
#endif
VAR_3 = 0;
goto badcmd;
case VAR_20:
VAR_4 -= 8;
if (VAR_4 < 0) {
goto rewind;
}
VAR_12.id = vmsvga_fifo_read(VAR_0);
VAR_12.hot_x = vmsvga_fifo_read(VAR_0);
VAR_12.hot_y = vmsvga_fifo_read(VAR_0);
VAR_12.width = VAR_6 = vmsvga_fifo_read(VAR_0);
VAR_12.height = VAR_7 = vmsvga_fifo_read(VAR_0);
vmsvga_fifo_read(VAR_0);
VAR_12.bpp = vmsvga_fifo_read(VAR_0);
VAR_3 = SVGA_BITMAP_SIZE(VAR_6, VAR_7) + SVGA_PIXMAP_SIZE(VAR_6, VAR_7, VAR_12.bpp);
if (VAR_12.width > 256 ||
VAR_12.height > 256 ||
VAR_12.bpp > 32 ||
SVGA_BITMAP_SIZE(VAR_6, VAR_7) > sizeof VAR_12.mask ||
SVGA_PIXMAP_SIZE(VAR_6, VAR_7, VAR_12.bpp) > sizeof VAR_12.image) {
goto badcmd;
}
VAR_4 -= VAR_3;
if (VAR_4 < 0) {
goto rewind;
}
for (VAR_3 = 0; VAR_3 < SVGA_BITMAP_SIZE(VAR_6, VAR_7); VAR_3++) {
VAR_12.mask[VAR_3] = vmsvga_fifo_read_raw(VAR_0);
}
for (VAR_3 = 0; VAR_3 < SVGA_PIXMAP_SIZE(VAR_6, VAR_7, VAR_12.bpp); VAR_3++) {
VAR_12.image[VAR_3] = vmsvga_fifo_read_raw(VAR_0);
}
#ifdef VAR_21
vmsvga_cursor_define(VAR_0, &VAR_12);
break;
#else
VAR_3 = 0;
goto badcmd;
#endif
case VAR_22:
VAR_4 -= 6;
if (VAR_4 < 0) {
goto rewind;
}
vmsvga_fifo_read(VAR_0);
vmsvga_fifo_read(VAR_0);
vmsvga_fifo_read(VAR_0);
VAR_6 = vmsvga_fifo_read(VAR_0);
VAR_7 = vmsvga_fifo_read(VAR_0);
VAR_3 = VAR_6 * VAR_7;
goto badcmd;
case VAR_23:
VAR_3 = 6;
goto badcmd;
case VAR_24:
VAR_3 = 7;
goto badcmd;
case VAR_25:
VAR_4 -= 4;
if (VAR_4 < 0) {
goto rewind;
}
vmsvga_fifo_read(VAR_0);
vmsvga_fifo_read(VAR_0);
VAR_3 = 7 + (vmsvga_fifo_read(VAR_0) >> 2);
goto badcmd;
case VAR_26:
VAR_3 = 12;
goto badcmd;
case VAR_27:
case VAR_28:
case VAR_29:
case VAR_30:
case VAR_31:
break; 
default:
VAR_3 = 0;
badcmd:
VAR_4 -= VAR_3;
if (VAR_4 < 0) {
goto rewind;
}
while (VAR_3--) {
vmsvga_fifo_read(VAR_0);
}
printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
VAR_32, VAR_1);
break;
rewind:
VAR_0->fifo_stop = VAR_13;
VAR_0->fifo[VAR_33] = cpu_to_le32(VAR_0->fifo_stop);
break;
}
}
VAR_0->syncing = 0;
}",qemu/167d97a3def77ee2dbf6e908b0ecbfe2103977db/vmware_vga.c/vul/before/0.json,"static void vmsvga_fifo_run(struct vmsvga_state_s *s)
{
    uint32_t cmd, colour;
    int args, len, maxloop = 1024;
    int x, y, dx, dy, width, height;
    struct vmsvga_cursor_definition_s cursor;
    uint32_t cmd_start;

    len = vmsvga_fifo_length(s);
    while (len > 0 && --maxloop > 0) {
        /* May need to go back to the start of the command if incomplete */
        cmd_start = s->fifo_stop;

        switch (cmd = vmsvga_fifo_read(s)) {
        case SVGA_CMD_UPDATE:
        case SVGA_CMD_UPDATE_VERBOSE:
            len -= 5;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
            vmsvga_update_rect_delayed(s, x, y, width, height);
            break;

        case SVGA_CMD_RECT_FILL:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }

            colour = vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_FILL_ACCEL
            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_RECT_COPY:
            len -= 7;
            if (len < 0) {
                goto rewind;
            }

            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            dx = vmsvga_fifo_read(s);
            dy = vmsvga_fifo_read(s);
            width = vmsvga_fifo_read(s);
            height = vmsvga_fifo_read(s);
#ifdef HW_RECT_ACCEL
            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {
                break;
            }
#endif
            args = 0;
            goto badcmd;

        case SVGA_CMD_DEFINE_CURSOR:
            len -= 8;
            if (len < 0) {
                goto rewind;
            }

            cursor.id = vmsvga_fifo_read(s);
            cursor.hot_x = vmsvga_fifo_read(s);
            cursor.hot_y = vmsvga_fifo_read(s);
            cursor.width = x = vmsvga_fifo_read(s);
            cursor.height = y = vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            cursor.bpp = vmsvga_fifo_read(s);

            args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
            if (cursor.width > 256
                || cursor.height > 256
                || cursor.bpp > 32
                || SVGA_BITMAP_SIZE(x, y)
                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])
                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {
                    goto badcmd;
            }

            len -= args;
            if (len < 0) {
                goto rewind;
            }

            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {
                cursor.mask[args] = vmsvga_fifo_read_raw(s);
            }
            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {
                cursor.image[args] = vmsvga_fifo_read_raw(s);
            }
#ifdef HW_MOUSE_ACCEL
            vmsvga_cursor_define(s, &cursor);
            break;
#else
            args = 0;
            goto badcmd;
#endif

        /*
         * Other commands that we at least know the number of arguments
         * for so we can avoid FIFO desync if driver uses them illegally.
         */
        case SVGA_CMD_DEFINE_ALPHA_CURSOR:
            len -= 6;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            x = vmsvga_fifo_read(s);
            y = vmsvga_fifo_read(s);
            args = x * y;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_FILL:
            args = 6;
            goto badcmd;
        case SVGA_CMD_RECT_ROP_COPY:
            args = 7;
            goto badcmd;
        case SVGA_CMD_DRAW_GLYPH_CLIPPED:
            len -= 4;
            if (len < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(s);
            vmsvga_fifo_read(s);
            args = 7 + (vmsvga_fifo_read(s) >> 2);
            goto badcmd;
        case SVGA_CMD_SURFACE_ALPHA_BLEND:
            args = 12;
            goto badcmd;

        /*
         * Other commands that are not listed as depending on any
         * CAPABILITIES bits, but are not described in the README either.
         */
        case SVGA_CMD_SURFACE_FILL:
        case SVGA_CMD_SURFACE_COPY:
        case SVGA_CMD_FRONT_ROP_FILL:
        case SVGA_CMD_FENCE:
        case SVGA_CMD_INVALID_CMD:
            break; /* Nop */

        default:
            args = 0;
        badcmd:
            len -= args;
            if (len < 0) {
                goto rewind;
            }
            while (args--) {
                vmsvga_fifo_read(s);
            }
            printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
                   __func__, cmd);
            break;

        rewind:
            s->fifo_stop = cmd_start;
            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);
            break;
        }
    }

    s->syncing = 0;
}","static void vmsvga_fifo_run(struct vmsvga_state_s *VAR_0)
{
    uint32_t VAR_1, VAR_2;
    int VAR_3, VAR_4, VAR_5 = 1024;
    int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11;
    struct vmsvga_cursor_definition_s VAR_12;
    uint32_t VAR_13;

    VAR_4 = vmsvga_fifo_length(VAR_0);
    while (VAR_4 > 0 && --VAR_5 > 0) {
        /* COMMENT_0 */
        VAR_13 = VAR_0->fifo_stop;

        switch (VAR_1 = vmsvga_fifo_read(VAR_0)) {
        case VAR_14:
        case VAR_15:
            VAR_4 -= 5;
            if (VAR_4 < 0) {
                goto rewind;
            }

            VAR_6 = vmsvga_fifo_read(VAR_0);
            VAR_7 = vmsvga_fifo_read(VAR_0);
            VAR_10 = vmsvga_fifo_read(VAR_0);
            VAR_11 = vmsvga_fifo_read(VAR_0);
            vmsvga_update_rect_delayed(VAR_0, VAR_6, VAR_7, VAR_10, VAR_11);
            break;

        case VAR_16:
            VAR_4 -= 6;
            if (VAR_4 < 0) {
                goto rewind;
            }

            VAR_2 = vmsvga_fifo_read(VAR_0);
            VAR_6 = vmsvga_fifo_read(VAR_0);
            VAR_7 = vmsvga_fifo_read(VAR_0);
            VAR_10 = vmsvga_fifo_read(VAR_0);
            VAR_11 = vmsvga_fifo_read(VAR_0);
#ifdef VAR_17
            if (vmsvga_fill_rect(VAR_0, VAR_2, VAR_6, VAR_7, VAR_10, VAR_11) == 0) {
                break;
            }
#endif
            VAR_3 = 0;
            goto badcmd;

        case VAR_18:
            VAR_4 -= 7;
            if (VAR_4 < 0) {
                goto rewind;
            }

            VAR_6 = vmsvga_fifo_read(VAR_0);
            VAR_7 = vmsvga_fifo_read(VAR_0);
            VAR_8 = vmsvga_fifo_read(VAR_0);
            VAR_9 = vmsvga_fifo_read(VAR_0);
            VAR_10 = vmsvga_fifo_read(VAR_0);
            VAR_11 = vmsvga_fifo_read(VAR_0);
#ifdef VAR_19
            if (vmsvga_copy_rect(VAR_0, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11) == 0) {
                break;
            }
#endif
            VAR_3 = 0;
            goto badcmd;

        case VAR_20:
            VAR_4 -= 8;
            if (VAR_4 < 0) {
                goto rewind;
            }

            VAR_12.id = vmsvga_fifo_read(VAR_0);
            VAR_12.hot_x = vmsvga_fifo_read(VAR_0);
            VAR_12.hot_y = vmsvga_fifo_read(VAR_0);
            VAR_12.width = VAR_6 = vmsvga_fifo_read(VAR_0);
            VAR_12.height = VAR_7 = vmsvga_fifo_read(VAR_0);
            vmsvga_fifo_read(VAR_0);
            VAR_12.bpp = vmsvga_fifo_read(VAR_0);

            VAR_3 = SVGA_BITMAP_SIZE(VAR_6, VAR_7) + SVGA_PIXMAP_SIZE(VAR_6, VAR_7, VAR_12.bpp);
            if (VAR_12.width > 256
                || VAR_12.height > 256
                || VAR_12.bpp > 32
                || SVGA_BITMAP_SIZE(VAR_6, VAR_7)
                    > sizeof(VAR_12.mask) / sizeof(VAR_12.mask[0])
                || SVGA_PIXMAP_SIZE(VAR_6, VAR_7, VAR_12.bpp)
                    > sizeof(VAR_12.image) / sizeof(VAR_12.image[0])) {
                    goto badcmd;
            }

            VAR_4 -= VAR_3;
            if (VAR_4 < 0) {
                goto rewind;
            }

            for (VAR_3 = 0; VAR_3 < SVGA_BITMAP_SIZE(VAR_6, VAR_7); VAR_3++) {
                VAR_12.mask[VAR_3] = vmsvga_fifo_read_raw(VAR_0);
            }
            for (VAR_3 = 0; VAR_3 < SVGA_PIXMAP_SIZE(VAR_6, VAR_7, VAR_12.bpp); VAR_3++) {
                VAR_12.image[VAR_3] = vmsvga_fifo_read_raw(VAR_0);
            }
#ifdef VAR_21
            vmsvga_cursor_define(VAR_0, &VAR_12);
            break;
#else
            VAR_3 = 0;
            goto badcmd;
#endif

        /* COMMENT_1 */
                                                                       
                                                                         
           
        case VAR_22:
            VAR_4 -= 6;
            if (VAR_4 < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(VAR_0);
            vmsvga_fifo_read(VAR_0);
            vmsvga_fifo_read(VAR_0);
            VAR_6 = vmsvga_fifo_read(VAR_0);
            VAR_7 = vmsvga_fifo_read(VAR_0);
            VAR_3 = VAR_6 * VAR_7;
            goto badcmd;
        case VAR_23:
            VAR_3 = 6;
            goto badcmd;
        case VAR_24:
            VAR_3 = 7;
            goto badcmd;
        case VAR_25:
            VAR_4 -= 4;
            if (VAR_4 < 0) {
                goto rewind;
            }
            vmsvga_fifo_read(VAR_0);
            vmsvga_fifo_read(VAR_0);
            VAR_3 = 7 + (vmsvga_fifo_read(VAR_0) >> 2);
            goto badcmd;
        case VAR_26:
            VAR_3 = 12;
            goto badcmd;

        /* COMMENT_5 */
                                                                 
                                                                         
           
        case VAR_27:
        case VAR_28:
        case VAR_29:
        case VAR_30:
        case VAR_31:
            break; /* COMMENT_9 */

        default:
            VAR_3 = 0;
        badcmd:
            VAR_4 -= VAR_3;
            if (VAR_4 < 0) {
                goto rewind;
            }
            while (VAR_3--) {
                vmsvga_fifo_read(VAR_0);
            }
            printf(""%s: Unknown command 0x%02x in SVGA command FIFO\n"",
                   VAR_32, VAR_1);
            break;

        rewind:
            VAR_0->fifo_stop = VAR_13;
            VAR_0->fifo[VAR_33] = cpu_to_le32(VAR_0->fifo_stop);
            break;
        }
    }

    VAR_0->syncing = 0;
}",qemu/167d97a3def77ee2dbf6e908b0ecbfe2103977db/vmware_vga.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -80,11 +80,13 @@
             cursor.bpp = vmsvga_fifo_read(s);
 
             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);
-            if (cursor.width > 256 ||
-                cursor.height > 256 ||
-                cursor.bpp > 32 ||
-                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||
-                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {
+            if (cursor.width > 256
+                || cursor.height > 256
+                || cursor.bpp > 32
+                || SVGA_BITMAP_SIZE(x, y)
+                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])
+                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)
+                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {
                     goto badcmd;
             }
 ","{'deleted_lines': ['            if (cursor.width > 256 ||', '                cursor.height > 256 ||', '                cursor.bpp > 32 ||', '                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||', '                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {'], 'added_lines': ['            if (cursor.width > 256', '                || cursor.height > 256', '                || cursor.bpp > 32', '                || SVGA_BITMAP_SIZE(x, y)', '                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])', '                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)', '                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {']}",True,The vmsvga_fifo_run function in hw/display/vmware_vga.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (out-of-bounds write and QEMU process crash) via vectors related to cursor.mask[] and cursor.image[] array sizes when processing a DEFINE_CURSOR svga command.,4.4,MEDIUM,1,valid,2016-09-08T12:45:54Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,MariaDB/server,"don't use my_copystat in the server

it was supposed to be used in command-line tools only.
Different fix for 4e5473862e:

Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE",347eeefbfc658c8531878218487d729f4e020805,https://github.com/MariaDB/server/commit/347eeefbfc658c8531878218487d729f4e020805,sql/mysqld.cc,init_common_variables,"static int init_common_variables()
{
umask(((~my_umask) & 0666));
my_decimal_set_zero(&decimal_zero); 
tzset();
sf_leaking_memory= 0; 
max_system_variables.pseudo_thread_id= (ulong)~0;
server_start_time= flush_status_time= my_time(0);
rpl_filter= new Rpl_filter;
binlog_filter= new Rpl_filter;
if (!rpl_filter || !binlog_filter)
{
sql_perror(""Could not allocate replication and binlog filters"");
return 1;
}
if (init_thread_environment() ||
mysql_init_variables())
return 1;
if (ignore_db_dirs_init())
return 1;
#ifdef HAVE_TZNAME
struct tm tm_tmp;
localtime_r(&server_start_time,&tm_tmp);
const char *tz_name=  tzname[tm_tmp.tm_isdst != 0 ? 1 : 0];
#ifdef _WIN32
wchar_t wtz_name[sizeof(system_time_zone)];
mbstowcs(wtz_name, tz_name, sizeof(system_time_zone)-1);
WideCharToMultiByte(CP_UTF8,0, wtz_name, -1, system_time_zone, 
sizeof(system_time_zone) - 1, NULL, NULL);
#else
strmake_buf(system_time_zone, tz_name);
#endif 
#endif 
global_system_variables.time_zone= my_tz_SYSTEM;
#ifdef HAVE_PSI_INTERFACE
mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,
key_BINLOG_update_cond,
key_file_binlog,
key_file_binlog_index,
key_BINLOG_COND_queue_busy);
#endif
mysql_bin_log.init_pthread_objects();
if (!IS_TIME_T_VALID_FOR_TIMESTAMP(server_start_time))
{
sql_print_error(""This MySQL server doesn't support dates later then 2038"");
return 1;
}
if (gethostname(glob_hostname,sizeof(glob_hostname)) < 0)
{
strmake(glob_hostname, STRING_WITH_LEN(""localhost""));
sql_print_warning(""gethostname failed, using '%s' as hostname"",
glob_hostname);
opt_log_basename= const_cast<char *>(""mysql"");
}
else
opt_log_basename= glob_hostname;
if (!*pidfile_name)
{
strmake(pidfile_name, opt_log_basename, sizeof(pidfile_name)-5);
strmov(fn_ext(pidfile_name),"".pid"");  }
#if defined(WITH_INNOBASE_STORAGE_ENGINE) || defined(WITH_XTRADB_STORAGE_ENGINE)
default_storage_engine= const_cast<char *>(""InnoDB"");
#else
default_storage_engine= const_cast<char *>(""MyISAM"");
#endif
if (add_status_vars(status_vars))
return 1; 
#ifndef DBUG_OFF
compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==
SQLCOM_END + 8);
#endif
if (get_options(&remaining_argc, &remaining_argv))
return 1;
set_server_version();
if (!opt_help)
sql_print_information(""%s (mysqld %s) starting as process %lu ..."",
my_progname, server_version, (ulong) getpid());
#ifndef EMBEDDED_LIBRARY
if (opt_abort && !opt_verbose)
unireg_abort(0);
#endif 
DBUG_PRINT(""info"",(""%s  Ver %s for %s on %s\n"",my_progname,
server_version, SYSTEM_TYPE,MACHINE_TYPE));
#ifdef HAVE_LARGE_PAGES
if (opt_large_pages && (opt_large_page_size= my_get_large_page_size()))
{
DBUG_PRINT(""info"", (""Large page set, large_page_size = %d"",
opt_large_page_size));
my_use_large_pages= 1;
my_large_page_size= opt_large_page_size;
}
else
{
opt_large_pages= 0;
}
#endif 
#ifdef HAVE_SOLARIS_LARGE_PAGES
#define LARGE_PAGESIZE (4*1024*1024)  
#define SUPER_LARGE_PAGESIZE (256*1024*1024)  
if (opt_large_pages)
{
int nelem;
size_t max_desired_page_size;
if (opt_super_large_pages)
max_desired_page_size= SUPER_LARGE_PAGESIZE;
else
max_desired_page_size= LARGE_PAGESIZE;
nelem = getpagesizes(NULL, 0);
if (nelem > 0)
{
size_t *pagesize = (size_t *) malloc(sizeof(size_t) * nelem);
if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0)
{
size_t max_page_size= 0;
for (int i= 0; i < nelem; i++)
{
if (pagesize[i] > max_page_size &&
pagesize[i] <= max_desired_page_size)
max_page_size= pagesize[i];
}
free(pagesize);
if (max_page_size > 0)
{
struct memcntl_mha mpss;
mpss.mha_cmd= MHA_MAPSIZE_BSSBRK;
mpss.mha_pagesize= max_page_size;
mpss.mha_flags= 0;
memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);
mpss.mha_cmd= MHA_MAPSIZE_STACK;
memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);
}
}
}
}
#endif 
{
uint files, wanted_files, max_open_files;
wanted_files= (10 + max_connections + extra_max_connections +
table_cache_size*2);
max_open_files= max(max(wanted_files,
(max_connections + extra_max_connections)*5),
open_files_limit);
files= my_set_max_open_files(max_open_files);
if (files < wanted_files)
{
if (!open_files_limit)
{
max_connections= (ulong) min(files-10-TABLE_OPEN_CACHE_MIN*2,
max_connections);
table_cache_size= (ulong) min(max((files-10-max_connections)/2,
TABLE_OPEN_CACHE_MIN),
table_cache_size);
DBUG_PRINT(""warning"",
(""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
files, max_connections, table_cache_size));
if (global_system_variables.log_warnings)
sql_print_warning(""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
files, max_connections, table_cache_size);
}
else if (global_system_variables.log_warnings)
sql_print_warning(""Could not increase number of max_open_files to more than %u (request: %u)"", files, wanted_files);
}
open_files_limit= files;
}
unireg_init(opt_specialflag); 
if (!(my_default_lc_messages=
my_locale_by_name(lc_messages)))
{
sql_print_error(""Unknown locale: '%s'"", lc_messages);
return 1;
}
global_system_variables.lc_messages= my_default_lc_messages;
if (init_errmessage())
return 1;
init_client_errs();
mysql_library_init(unused,unused,unused); 
lex_init();
if (item_create_init())
return 1;
item_init();
#ifndef EMBEDDED_LIBRARY
my_regex_init(&my_charset_latin1, check_enough_stack_size);
my_string_stack_guard= check_enough_stack_size;
#else
my_regex_init(&my_charset_latin1, NULL);
#endif
for (;;)
{
char *next_character_set_name= strchr(default_character_set_name, ',');
if (next_character_set_name)
*next_character_set_name++= '\0';
if (!(default_charset_info=
get_charset_by_csname(default_character_set_name,
MY_CS_PRIMARY, MYF(MY_WME))))
{
if (next_character_set_name)
{
default_character_set_name= next_character_set_name;
default_collation_name= 0;                }
else
return 1;                               }
else
break;
}
if (default_collation_name)
{
CHARSET_INFO *default_collation;
default_collation= get_charset_by_name(default_collation_name, MYF(0));
if (!default_collation)
{
sql_print_error(ER_DEFAULT(ER_UNKNOWN_COLLATION), default_collation_name);
return 1;
}
if (!my_charset_same(default_charset_info, default_collation))
{
sql_print_error(ER_DEFAULT(ER_COLLATION_CHARSET_MISMATCH),
default_collation_name,
default_charset_info->csname);
return 1;
}
default_charset_info= default_collation;
}
global_system_variables.collation_server= default_charset_info;
global_system_variables.collation_database= default_charset_info;
global_system_variables.collation_connection=  default_charset_info;
global_system_variables.character_set_results= default_charset_info;
global_system_variables.character_set_client=  default_charset_info;
if (!(character_set_filesystem=
get_charset_by_csname(character_set_filesystem_name,
MY_CS_PRIMARY, MYF(MY_WME))))
return 1;
global_system_variables.character_set_filesystem= character_set_filesystem;
if (!(my_default_lc_time_names=
my_locale_by_name(lc_time_names_name)))
{
sql_print_error(""Unknown locale: '%s'"", lc_time_names_name);
return 1;
}
global_system_variables.lc_time_names= my_default_lc_time_names;
if (opt_log && opt_logname && *opt_logname &&
!(log_output_options & (LOG_FILE | LOG_NONE)))
sql_print_warning(""Although a path was specified for the ""
""--log option, log tables are used. ""
""To enable logging to files use the --log-output option."");
if (opt_slow_log && opt_slow_logname && *opt_slow_logname &&
!(log_output_options & (LOG_FILE | LOG_NONE)))
sql_print_warning(""Although a path was specified for the ""
""--log-slow-queries option, log tables are used. ""
""To enable logging to files use the --log-output=file option."");
if (!opt_logname || !*opt_logname)
make_default_log_name(&opt_logname, "".log"", false);
if (!opt_slow_logname || !*opt_slow_logname)
make_default_log_name(&opt_slow_logname, ""-slow.log"", false);
#if defined(ENABLED_DEBUG_SYNC)
if (debug_sync_init())
return 1; 
#endif 
#if (ENABLE_TEMP_POOL)
if (use_temp_pool && bitmap_init(&temp_pool,0,1024,1))
return 1;
#else
use_temp_pool= 0;
#endif
if (my_dboptions_cache_init())
return 1;
DBUG_PRINT(""info"", (""lower_case_table_names: %d"", lower_case_table_names));
lower_case_file_system= test_if_case_insensitive(mysql_real_data_home);
if (!lower_case_table_names && lower_case_file_system == 1)
{
if (lower_case_table_names_used)
{
#if MYSQL_VERSION_ID < 100100
if (global_system_variables.log_warnings)
sql_print_warning(""You have forced lower_case_table_names to 0 through ""
""a command-line option, even though your file system ""
""'%s' is case insensitive.  This means that you can ""
""corrupt your tables if you access them using names ""
""with different letter case. You should consider ""
""changing lower_case_table_names to 1 or 2"",
mysql_real_data_home);
#else
sql_print_error(""The server option 'lower_case_table_names' is ""
""configured to use case sensitive table names but the ""
""data directory resides on a case-insensitive file system. ""
""Please use a case sensitive file system for your data ""
""directory or switch to a case-insensitive table name ""
""mode."");
#endif
return 1;
}
else
{
if (global_system_variables.log_warnings)
sql_print_warning(""Setting lower_case_table_names=2 because file system for %s is case insensitive"", mysql_real_data_home);
lower_case_table_names= 2;
}
}
else if (lower_case_table_names == 2 &&
!(lower_case_file_system= (lower_case_file_system == 1)))
{
if (global_system_variables.log_warnings)
sql_print_warning(""lower_case_table_names was set to 2, even though your ""
""the file system '%s' is case sensitive.  Now setting ""
""lower_case_table_names to 0 to avoid future problems."",
mysql_real_data_home);
lower_case_table_names= 0;
}
else
{
lower_case_file_system= (lower_case_file_system == 1);
}
table_alias_charset= (lower_case_table_names ?
files_charset_info :
&my_charset_bin);
if (ignore_db_dirs_process_additions())
{
sql_print_error(""An error occurred while storing ignore_db_dirs to a hash."");
return 1;
}
return 0;
}","static int init_common_variables()
{
umask(((~VAR_0) & 0666));
my_decimal_set_zero(&VAR_1); 
tzset();
VAR_2= 0; 
VAR_3.pseudo_thread_id= (ulong)~0;
VAR_4= VAR_5= my_time(0);
VAR_6= new Rpl_filter;
VAR_7= new Rpl_filter;
if (!VAR_6 || !VAR_7)
{
sql_perror(""Could not allocate replication and binlog filters"");
return 1;
}
if (init_thread_environment() ||
mysql_init_variables())
return 1;
if (ignore_db_dirs_init())
return 1;
#ifdef VAR_8
struct tm VAR_9;
localtime_r(&VAR_4,&VAR_9);
const char *VAR_10=  VAR_11[VAR_9.tm_isdst != 0 ? 1 : 0];
#ifdef VAR_12
wchar_t VAR_13[sizeof(VAR_14)];
mbstowcs(VAR_13, VAR_10, sizeof(VAR_14)-1);
WideCharToMultiByte(VAR_15,0, VAR_13, -1, VAR_14, 
sizeof(VAR_14) - 1, NULL, NULL);
#else
strmake_buf(VAR_14, VAR_10);
#endif 
#endif 
VAR_16.time_zone= VAR_17;
#ifdef VAR_18
VAR_19.set_psi_keys(VAR_20,
VAR_21,
VAR_22,
VAR_23,
VAR_24);
#endif
VAR_19.init_pthread_objects();
if (!IS_TIME_T_VALID_FOR_TIMESTAMP(VAR_4))
{
sql_print_error(""This MySQL server doesn't support dates later then 2038"");
return 1;
}
if (gethostname(VAR_25,sizeof(VAR_25)) < 0)
{
strmake(VAR_25, STRING_WITH_LEN(""localhost""));
sql_print_warning(""gethostname failed, using '%s' as hostname"",
VAR_25);
VAR_26= VAR_27<char *>(""mysql"");
}
else
VAR_26= VAR_25;
if (!*VAR_28)
{
strmake(VAR_28, VAR_26, sizeof(VAR_28)-5);
strmov(fn_ext(VAR_28),"".pid"");
}
#if defined(VAR_29) || defined(VAR_30)
VAR_31= VAR_27<char *>(""InnoDB"");
#else
VAR_31= VAR_27<char *>(""MyISAM"");
#endif
if (add_status_vars(VAR_32))
return 1; 
#ifndef VAR_33
compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==
VAR_34 + 8);
#endif
if (get_options(&VAR_35, &VAR_36))
return 1;
set_server_version();
if (!VAR_37)
sql_print_information(""%s (mysqld %s) starting as process %lu ..."",
VAR_38, VAR_39, (ulong) getpid());
#ifndef VAR_40
if (VAR_41 && !VAR_42)
unireg_abort(0);
#endif 
DBUG_PRINT(""info"",(""%s  Ver %s for %s on %s\n"",VAR_38,
VAR_39, VAR_43,VAR_44));
#ifdef VAR_45
if (VAR_46 && (VAR_47= my_get_large_page_size()))
{
DBUG_PRINT(""info"", (""Large page set, large_page_size = %d"",
VAR_47));
VAR_48= 1;
VAR_49= VAR_47;
}
else
{
VAR_46= 0;
}
#endif 
#ifdef VAR_50
#define VAR_51 (4*1024*1024)  
#define VAR_52 (256*1024*1024)  
if (VAR_46)
{
int VAR_53;
size_t VAR_54;
if (VAR_55)
VAR_54= VAR_52;
else
VAR_54= VAR_51;
VAR_53 = getpagesizes(NULL, 0);
if (VAR_53 > 0)
{
size_t *VAR_56 = (size_t *) malloc(sizeof(size_t) * VAR_53);
if (VAR_56 != NULL && getpagesizes(VAR_56, VAR_53) > 0)
{
size_t VAR_57= 0;
for (int VAR_58= 0; VAR_58 < VAR_53; VAR_58++)
{
if (VAR_56[VAR_58] > VAR_57 &&
VAR_56[VAR_58] <= VAR_54)
VAR_57= VAR_56[VAR_58];
}
free(VAR_56);
if (VAR_57 > 0)
{
struct memcntl_mha VAR_59;
VAR_59.mha_cmd= VAR_60;
VAR_59.mha_pagesize= VAR_57;
VAR_59.mha_flags= 0;
memcntl(NULL, 0, VAR_61, (VAR_62)&VAR_59, 0, 0);
VAR_59.mha_cmd= VAR_63;
memcntl(NULL, 0, VAR_61, (VAR_62)&VAR_59, 0, 0);
}
}
}
}
#endif 
{
uint VAR_64, VAR_65, VAR_66;
VAR_65= (10 + VAR_67 + VAR_68 +
VAR_69*2);
VAR_66= max(max(VAR_65,
(VAR_67 + VAR_68)*5),
VAR_70);
VAR_64= my_set_max_open_files(VAR_66);
if (VAR_64 < VAR_65)
{
if (!VAR_70)
{
VAR_67= (ulong) min(VAR_64-10-VAR_71*2,
VAR_67);
VAR_69= (ulong) min(max((VAR_64-10-VAR_67)/2,
VAR_71),
VAR_69);
DBUG_PRINT(""warning"",
(""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
VAR_64, VAR_67, VAR_69));
if (VAR_16.log_warnings)
sql_print_warning(""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
VAR_64, VAR_67, VAR_69);
}
else if (VAR_16.log_warnings)
sql_print_warning(""Could not increase number of max_open_files to more than %u (request: %u)"", VAR_64, VAR_65);
}
VAR_70= VAR_64;
}
unireg_init(VAR_72); 
if (!(VAR_73=
my_locale_by_name(VAR_74)))
{
sql_print_error(""Unknown locale: '%s'"", VAR_74);
return 1;
}
VAR_16.lc_messages= VAR_73;
if (init_errmessage())
return 1;
init_client_errs();
mysql_library_init(VAR_75,VAR_75,VAR_75); 
lex_init();
if (item_create_init())
return 1;
item_init();
#ifndef VAR_40
my_regex_init(&VAR_76, VAR_77);
VAR_78= VAR_77;
#else
my_regex_init(&VAR_76, NULL);
#endif
for (;;)
{
char *VAR_79= strchr(VAR_80, ',');
if (VAR_79)
*VAR_79++= '\0';
if (!(VAR_81=
get_charset_by_csname(VAR_80,
VAR_82, MYF(VAR_83))))
{
if (VAR_79)
{
VAR_80= VAR_79;
VAR_84= 0;          
}
else
return 1;                           
}
else
break;
}
if (VAR_84)
{
CHARSET_INFO *VAR_85;
VAR_85= get_charset_by_name(VAR_84, MYF(0));
if (!VAR_85)
{
sql_print_error(ER_DEFAULT(VAR_86), VAR_84);
return 1;
}
if (!my_charset_same(VAR_81, VAR_85))
{
sql_print_error(ER_DEFAULT(VAR_87),
VAR_84,
VAR_81->csname);
return 1;
}
VAR_81= VAR_85;
}
VAR_16.collation_server= VAR_81;
VAR_16.collation_database= VAR_81;
VAR_16.collation_connection=  VAR_81;
VAR_16.character_set_results= VAR_81;
VAR_16.character_set_client=  VAR_81;
if (!(VAR_88=
get_charset_by_csname(VAR_89,
VAR_82, MYF(VAR_83))))
return 1;
VAR_16.character_set_filesystem= VAR_88;
if (!(VAR_90=
my_locale_by_name(VAR_91)))
{
sql_print_error(""Unknown locale: '%s'"", VAR_91);
return 1;
}
VAR_16.lc_time_names= VAR_90;
if (VAR_92 && VAR_93 && *VAR_93 &&
!(VAR_94 & (VAR_95 | VAR_96)))
sql_print_warning(""Although a path was specified for the ""
""--log option, log tables are used. ""
""To enable logging to files use the --log-output option."");
if (VAR_97 && VAR_98 && *VAR_98 &&
!(VAR_94 & (VAR_95 | VAR_96)))
sql_print_warning(""Although a path was specified for the ""
""--log-slow-queries option, log tables are used. ""
""To enable logging to files use the --log-output=file option."");
if (!VAR_93 || !*VAR_93)
make_default_log_name(&VAR_93, "".log"", false);
if (!VAR_98 || !*VAR_98)
make_default_log_name(&VAR_98, ""-slow.log"", false);
#if defined(VAR_99)
if (debug_sync_init())
return 1; 
#endif 
#if (VAR_100)
if (VAR_101 && bitmap_init(&VAR_102,0,1024,1))
return 1;
#else
VAR_101= 0;
#endif
if (my_dboptions_cache_init())
return 1;
DBUG_PRINT(""info"", (""lower_case_table_names: %d"", VAR_103));
VAR_104= test_if_case_insensitive(VAR_105);
if (!VAR_103 && VAR_104 == 1)
{
if (VAR_106)
{
#if VAR_107 < 100100
if (VAR_16.log_warnings)
sql_print_warning(""You have forced lower_case_table_names to 0 through ""
""a command-line option, even though your file system ""
""'%s' is case insensitive.  This means that you can ""
""corrupt your tables if you access them using names ""
""with different letter case. You should consider ""
""changing lower_case_table_names to 1 or 2"",
VAR_105);
#else
sql_print_error(""The server option 'lower_case_table_names' is ""
""configured to use case sensitive table names but the ""
""data directory resides on a case-insensitive file system. ""
""Please use a case sensitive file system for your data ""
""directory or switch to a case-insensitive table name ""
""mode."");
#endif
return 1;
}
else
{
if (VAR_16.log_warnings)
sql_print_warning(""Setting lower_case_table_names=2 because file system for %s is case insensitive"", VAR_105);
VAR_103= 2;
}
}
else if (VAR_103 == 2 &&
!(VAR_104= (VAR_104 == 1)))
{
if (VAR_16.log_warnings)
sql_print_warning(""lower_case_table_names was set to 2, even though your ""
""the file system '%s' is case sensitive.  Now setting ""
""lower_case_table_names to 0 to avoid future problems."",
VAR_105);
VAR_103= 0;
}
else
{
VAR_104= (VAR_104 == 1);
}
VAR_108= (VAR_103 ?
VAR_109 :
&VAR_110);
if (ignore_db_dirs_process_additions())
{
sql_print_error(""An error occurred while storing ignore_db_dirs to a hash."");
return 1;
}
return 0;
}",MariaDB/server/347eeefbfc658c8531878218487d729f4e020805/mysqld.cc/vul/before/0.json,"static int init_common_variables()
{
  umask(((~my_umask) & 0666));
  my_decimal_set_zero(&decimal_zero); // set decimal_zero constant;

  tzset();			// Set tzname

  sf_leaking_memory= 0; // no memory leaks from now on

  max_system_variables.pseudo_thread_id= (ulong)~0;
  server_start_time= flush_status_time= my_time(0);
  my_disable_copystat_in_redel= 1;

  rpl_filter= new Rpl_filter;
  binlog_filter= new Rpl_filter;
  if (!rpl_filter || !binlog_filter)
  {
    sql_perror(""Could not allocate replication and binlog filters"");
    return 1;
  }

  if (init_thread_environment() ||
      mysql_init_variables())
    return 1;

  if (ignore_db_dirs_init())
    return 1;

#ifdef HAVE_TZNAME
  struct tm tm_tmp;
  localtime_r(&server_start_time,&tm_tmp);
  const char *tz_name=  tzname[tm_tmp.tm_isdst != 0 ? 1 : 0];
#ifdef _WIN32
  /*
    Time zone name may be localized and contain non-ASCII characters,
    Convert from ANSI encoding to UTF8.
  */
  wchar_t wtz_name[sizeof(system_time_zone)];
  mbstowcs(wtz_name, tz_name, sizeof(system_time_zone)-1);
  WideCharToMultiByte(CP_UTF8,0, wtz_name, -1, system_time_zone, 
    sizeof(system_time_zone) - 1, NULL, NULL);
#else
  strmake_buf(system_time_zone, tz_name);
#endif /* _WIN32 */
#endif /* HAVE_TZNAME */

  /*
    We set SYSTEM time zone as reasonable default and
    also for failure of my_tz_init() and bootstrap mode.
    If user explicitly set time zone with --default-time-zone
    option we will change this value in my_tz_init().
  */
  global_system_variables.time_zone= my_tz_SYSTEM;

#ifdef HAVE_PSI_INTERFACE
  /*
    Complete the mysql_bin_log initialization.
    Instrumentation keys are known only after the performance schema initialization,
    and can not be set in the MYSQL_BIN_LOG constructor (called before main()).
  */
  mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,
                             key_BINLOG_update_cond,
                             key_file_binlog,
                             key_file_binlog_index,
                             key_BINLOG_COND_queue_busy);
#endif

  /*
    Init mutexes for the global MYSQL_BIN_LOG objects.
    As safe_mutex depends on what MY_INIT() does, we can't init the mutexes of
    global MYSQL_BIN_LOGs in their constructors, because then they would be
    inited before MY_INIT(). So we do it here.
  */
  mysql_bin_log.init_pthread_objects();

  /* TODO: remove this when my_time_t is 64 bit compatible */
  if (!IS_TIME_T_VALID_FOR_TIMESTAMP(server_start_time))
  {
    sql_print_error(""This MySQL server doesn't support dates later then 2038"");
    return 1;
  }

  if (gethostname(glob_hostname,sizeof(glob_hostname)) < 0)
  {
    /*
      Get hostname of computer (used by 'show variables') and as default
      basename for the pid file if --log-basename is not given.
    */
    strmake(glob_hostname, STRING_WITH_LEN(""localhost""));
    sql_print_warning(""gethostname failed, using '%s' as hostname"",
                        glob_hostname);
    opt_log_basename= const_cast<char *>(""mysql"");
  }
  else
    opt_log_basename= glob_hostname;

  if (!*pidfile_name)
  {
    strmake(pidfile_name, opt_log_basename, sizeof(pidfile_name)-5);
    strmov(fn_ext(pidfile_name),"".pid"");		// Add proper extension
  }

  /*
    The default-storage-engine entry in my_long_options should have a
    non-null default value. It was earlier intialized as
    (longlong)""MyISAM"" in my_long_options but this triggered a
    compiler error in the Sun Studio 12 compiler. As a work-around we
    set the def_value member to 0 in my_long_options and initialize it
    to the correct value here.

    From MySQL 5.5 onwards, the default storage engine is InnoDB
    (except in the embedded server, where the default continues to
    be MyISAM)
  */
#if defined(WITH_INNOBASE_STORAGE_ENGINE) || defined(WITH_XTRADB_STORAGE_ENGINE)
  default_storage_engine= const_cast<char *>(""InnoDB"");
#else
  default_storage_engine= const_cast<char *>(""MyISAM"");
#endif

  /*
    Add server status variables to the dynamic list of
    status variables that is shown by SHOW STATUS.
    Later, in plugin_init, and mysql_install_plugin
    new entries could be added to that list.
  */
  if (add_status_vars(status_vars))
    return 1; // an error was already reported

#ifndef DBUG_OFF
  /*
    We have few debug-only commands in com_status_vars, only visible in debug
    builds. for simplicity we enable the assert only in debug builds

    There are 8 Com_ variables which don't have corresponding SQLCOM_ values:
    (TODO strictly speaking they shouldn't be here, should not have Com_ prefix
    that is. Perhaps Stmt_ ? Comstmt_ ? Prepstmt_ ?)

      Com_admin_commands       => com_other
      Com_stmt_close           => com_stmt_close
      Com_stmt_execute         => com_stmt_execute
      Com_stmt_fetch           => com_stmt_fetch
      Com_stmt_prepare         => com_stmt_prepare
      Com_stmt_reprepare       => com_stmt_reprepare
      Com_stmt_reset           => com_stmt_reset
      Com_stmt_send_long_data  => com_stmt_send_long_data

    With this correction the number of Com_ variables (number of elements in
    the array, excluding the last element - terminator) must match the number
    of SQLCOM_ constants.
  */
  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==
                     SQLCOM_END + 8);
#endif

  if (get_options(&remaining_argc, &remaining_argv))
    return 1;
  set_server_version();

  if (!opt_help)
    sql_print_information(""%s (mysqld %s) starting as process %lu ..."",
                          my_progname, server_version, (ulong) getpid());

#ifndef EMBEDDED_LIBRARY
  if (opt_abort && !opt_verbose)
    unireg_abort(0);
#endif /*!EMBEDDED_LIBRARY*/

  DBUG_PRINT(""info"",(""%s  Ver %s for %s on %s\n"",my_progname,
		     server_version, SYSTEM_TYPE,MACHINE_TYPE));

#ifdef HAVE_LARGE_PAGES
  /* Initialize large page size */
  if (opt_large_pages && (opt_large_page_size= my_get_large_page_size()))
  {
      DBUG_PRINT(""info"", (""Large page set, large_page_size = %d"",
                 opt_large_page_size));
      my_use_large_pages= 1;
      my_large_page_size= opt_large_page_size;
  }
  else
  {
    opt_large_pages= 0;
    /* 
       Either not configured to use large pages or Linux haven't
       been compiled with large page support
    */
  }
#endif /* HAVE_LARGE_PAGES */
#ifdef HAVE_SOLARIS_LARGE_PAGES
#define LARGE_PAGESIZE (4*1024*1024)  /* 4MB */
#define SUPER_LARGE_PAGESIZE (256*1024*1024)  /* 256MB */
  if (opt_large_pages)
  {
  /*
    tell the kernel that we want to use 4/256MB page for heap storage
    and also for the stack. We use 4 MByte as default and if the
    super-large-page is set we increase it to 256 MByte. 256 MByte
    is for server installations with GBytes of RAM memory where
    the MySQL Server will have page caches and other memory regions
    measured in a number of GBytes.
    We use as big pages as possible which isn't bigger than the above
    desired page sizes.
  */
   int nelem;
   size_t max_desired_page_size;
   if (opt_super_large_pages)
     max_desired_page_size= SUPER_LARGE_PAGESIZE;
   else
     max_desired_page_size= LARGE_PAGESIZE;
   nelem = getpagesizes(NULL, 0);
   if (nelem > 0)
   {
     size_t *pagesize = (size_t *) malloc(sizeof(size_t) * nelem);
     if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0)
     {
       size_t max_page_size= 0;
       for (int i= 0; i < nelem; i++)
       {
         if (pagesize[i] > max_page_size &&
             pagesize[i] <= max_desired_page_size)
            max_page_size= pagesize[i];
       }
       free(pagesize);
       if (max_page_size > 0)
       {
         struct memcntl_mha mpss;

         mpss.mha_cmd= MHA_MAPSIZE_BSSBRK;
         mpss.mha_pagesize= max_page_size;
         mpss.mha_flags= 0;
         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);
         mpss.mha_cmd= MHA_MAPSIZE_STACK;
         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);
       }
     }
   }
  }
#endif /* HAVE_SOLARIS_LARGE_PAGES */

  /* connections and databases needs lots of files */
  {
    uint files, wanted_files, max_open_files;

    /* MyISAM requires two file handles per table. */
    wanted_files= (10 + max_connections + extra_max_connections +
                   table_cache_size*2);
    /*
      We are trying to allocate no less than max_connections*5 file
      handles (i.e. we are trying to set the limit so that they will
      be available).  In addition, we allocate no less than how much
      was already allocated.  However below we report a warning and
      recompute values only if we got less file handles than were
      explicitly requested.  No warning and re-computation occur if we
      can't get max_connections*5 but still got no less than was
      requested (value of wanted_files).
    */
    max_open_files= max(max(wanted_files,
                            (max_connections + extra_max_connections)*5),
                        open_files_limit);
    files= my_set_max_open_files(max_open_files);

    if (files < wanted_files)
    {
      if (!open_files_limit)
      {
        /*
          If we have requested too much file handles than we bring
          max_connections in supported bounds.
        */
        max_connections= (ulong) min(files-10-TABLE_OPEN_CACHE_MIN*2,
                                     max_connections);
        /*
          Decrease table_cache_size according to max_connections, but
          not below TABLE_OPEN_CACHE_MIN.  Outer min() ensures that we
          never increase table_cache_size automatically (that could
          happen if max_connections is decreased above).
        */
        table_cache_size= (ulong) min(max((files-10-max_connections)/2,
                                          TABLE_OPEN_CACHE_MIN),
                                      table_cache_size);
	DBUG_PRINT(""warning"",
		   (""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
		    files, max_connections, table_cache_size));
	if (global_system_variables.log_warnings)
	  sql_print_warning(""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
			files, max_connections, table_cache_size);
      }
      else if (global_system_variables.log_warnings)
	sql_print_warning(""Could not increase number of max_open_files to more than %u (request: %u)"", files, wanted_files);
    }
    open_files_limit= files;
  }
  unireg_init(opt_specialflag); /* Set up extern variabels */
  if (!(my_default_lc_messages=
        my_locale_by_name(lc_messages)))
  {
    sql_print_error(""Unknown locale: '%s'"", lc_messages);
    return 1;
  }
  global_system_variables.lc_messages= my_default_lc_messages;
  if (init_errmessage())	/* Read error messages from file */
    return 1;
  init_client_errs();
  mysql_library_init(unused,unused,unused); /* for replication */
  lex_init();
  if (item_create_init())
    return 1;
  item_init();
#ifndef EMBEDDED_LIBRARY
  my_regex_init(&my_charset_latin1, check_enough_stack_size);
  my_string_stack_guard= check_enough_stack_size;
#else
  my_regex_init(&my_charset_latin1, NULL);
#endif
  /*
    Process a comma-separated character set list and choose
    the first available character set. This is mostly for
    test purposes, to be able to start ""mysqld"" even if
    the requested character set is not available (see bug#18743).
  */
  for (;;)
  {
    char *next_character_set_name= strchr(default_character_set_name, ',');
    if (next_character_set_name)
      *next_character_set_name++= '\0';
    if (!(default_charset_info=
          get_charset_by_csname(default_character_set_name,
                                MY_CS_PRIMARY, MYF(MY_WME))))
    {
      if (next_character_set_name)
      {
        default_character_set_name= next_character_set_name;
        default_collation_name= 0;          // Ignore collation
      }
      else
        return 1;                           // Eof of the list
    }
    else
      break;
  }

  if (default_collation_name)
  {
    CHARSET_INFO *default_collation;
    default_collation= get_charset_by_name(default_collation_name, MYF(0));
    if (!default_collation)
    {
      sql_print_error(ER_DEFAULT(ER_UNKNOWN_COLLATION), default_collation_name);
      return 1;
    }
    if (!my_charset_same(default_charset_info, default_collation))
    {
      sql_print_error(ER_DEFAULT(ER_COLLATION_CHARSET_MISMATCH),
		      default_collation_name,
		      default_charset_info->csname);
      return 1;
    }
    default_charset_info= default_collation;
  }
  /* Set collactions that depends on the default collation */
  global_system_variables.collation_server=	 default_charset_info;
  global_system_variables.collation_database=	 default_charset_info;
  global_system_variables.collation_connection=  default_charset_info;
  global_system_variables.character_set_results= default_charset_info;
  global_system_variables.character_set_client=  default_charset_info;

  if (!(character_set_filesystem=
        get_charset_by_csname(character_set_filesystem_name,
                              MY_CS_PRIMARY, MYF(MY_WME))))
    return 1;
  global_system_variables.character_set_filesystem= character_set_filesystem;

  if (!(my_default_lc_time_names=
        my_locale_by_name(lc_time_names_name)))
  {
    sql_print_error(""Unknown locale: '%s'"", lc_time_names_name);
    return 1;
  }
  global_system_variables.lc_time_names= my_default_lc_time_names;

  /* check log options and issue warnings if needed */
  if (opt_log && opt_logname && *opt_logname &&
      !(log_output_options & (LOG_FILE | LOG_NONE)))
    sql_print_warning(""Although a path was specified for the ""
                      ""--log option, log tables are used. ""
                      ""To enable logging to files use the --log-output option."");

  if (opt_slow_log && opt_slow_logname && *opt_slow_logname &&
      !(log_output_options & (LOG_FILE | LOG_NONE)))
    sql_print_warning(""Although a path was specified for the ""
                      ""--log-slow-queries option, log tables are used. ""
                      ""To enable logging to files use the --log-output=file option."");

  if (!opt_logname || !*opt_logname)
    make_default_log_name(&opt_logname, "".log"", false);
  if (!opt_slow_logname || !*opt_slow_logname)
    make_default_log_name(&opt_slow_logname, ""-slow.log"", false);

#if defined(ENABLED_DEBUG_SYNC)
  /* Initialize the debug sync facility. See debug_sync.cc. */
  if (debug_sync_init())
    return 1; /* purecov: tested */
#endif /* defined(ENABLED_DEBUG_SYNC) */

#if (ENABLE_TEMP_POOL)
  if (use_temp_pool && bitmap_init(&temp_pool,0,1024,1))
    return 1;
#else
  use_temp_pool= 0;
#endif

  if (my_dboptions_cache_init())
    return 1;

  /*
    Ensure that lower_case_table_names is set on system where we have case
    insensitive names.  If this is not done the users MyISAM tables will
    get corrupted if accesses with names of different case.
  */
  DBUG_PRINT(""info"", (""lower_case_table_names: %d"", lower_case_table_names));
  lower_case_file_system= test_if_case_insensitive(mysql_real_data_home);
  if (!lower_case_table_names && lower_case_file_system == 1)
  {
    if (lower_case_table_names_used)
    {
#if MYSQL_VERSION_ID < 100100
      if (global_system_variables.log_warnings)
        sql_print_warning(""You have forced lower_case_table_names to 0 through ""
                          ""a command-line option, even though your file system ""
                          ""'%s' is case insensitive.  This means that you can ""
                          ""corrupt your tables if you access them using names ""
                          ""with different letter case. You should consider ""
                          ""changing lower_case_table_names to 1 or 2"",
                          mysql_real_data_home);
#else
      sql_print_error(""The server option 'lower_case_table_names' is ""
                      ""configured to use case sensitive table names but the ""
                      ""data directory resides on a case-insensitive file system. ""
                      ""Please use a case sensitive file system for your data ""
                      ""directory or switch to a case-insensitive table name ""
                      ""mode."");
#endif
      return 1;
    }
    else
    {
      if (global_system_variables.log_warnings)
	sql_print_warning(""Setting lower_case_table_names=2 because file system for %s is case insensitive"", mysql_real_data_home);
      lower_case_table_names= 2;
    }
  }
  else if (lower_case_table_names == 2 &&
           !(lower_case_file_system= (lower_case_file_system == 1)))
  {
    if (global_system_variables.log_warnings)
      sql_print_warning(""lower_case_table_names was set to 2, even though your ""
                        ""the file system '%s' is case sensitive.  Now setting ""
                        ""lower_case_table_names to 0 to avoid future problems."",
			mysql_real_data_home);
    lower_case_table_names= 0;
  }
  else
  {
    lower_case_file_system= (lower_case_file_system == 1);
  }

  /* Reset table_alias_charset, now that lower_case_table_names is set. */
  table_alias_charset= (lower_case_table_names ?
			files_charset_info :
			&my_charset_bin);

  if (ignore_db_dirs_process_additions())
  {
    sql_print_error(""An error occurred while storing ignore_db_dirs to a hash."");
    return 1;
  }

  return 0;
}","static int init_common_variables()
{
  umask(((~VAR_0) & 0666));
  my_decimal_set_zero(&VAR_1); /* COMMENT_0 */

  tzset();			/* COMMENT_1 */

  VAR_2= 0; /* COMMENT_2 */

  VAR_3.pseudo_thread_id= (ulong)~0;
  VAR_4= VAR_5= my_time(0);
  VAR_6= 1;

  VAR_7= new Rpl_filter;
  VAR_8= new Rpl_filter;
  if (!VAR_7 || !VAR_8)
  {
    sql_perror(""Could not allocate replication and binlog filters"");
    return 1;
  }

  if (init_thread_environment() ||
      mysql_init_variables())
    return 1;

  if (ignore_db_dirs_init())
    return 1;

#ifdef VAR_9
  struct tm VAR_10;
  localtime_r(&VAR_4,&VAR_10);
  const char *VAR_11=  VAR_12[VAR_10.tm_isdst != 0 ? 1 : 0];
#ifdef VAR_13
  /* COMMENT_3 */
                                                                     
                                       
    
  wchar_t VAR_14[sizeof(VAR_15)];
  mbstowcs(VAR_14, VAR_11, sizeof(VAR_15)-1);
  WideCharToMultiByte(VAR_16,0, VAR_14, -1, VAR_15, 
    sizeof(VAR_15) - 1, NULL, NULL);
#else
  strmake_buf(VAR_15, VAR_11);
#endif /* COMMENT_7 */
#endif /* COMMENT_8 */

  /* COMMENT_9 */
                                                     
                                                        
                                                             
                                                     
    
  VAR_17.time_zone= VAR_18;

#ifdef VAR_19
  /* COMMENT_15 */
                                              
                                                                                    
                                                                               
    
  VAR_20.set_psi_keys(VAR_21,
                             VAR_22,
                             VAR_23,
                             VAR_24,
                             VAR_25);
#endif

  /* COMMENT_20 */
                                                      
                                                                              
                                                                           
                                              
    
  VAR_20.init_pthread_objects();

  /* COMMENT_26 */
  if (!IS_TIME_T_VALID_FOR_TIMESTAMP(VAR_4))
  {
    sql_print_error(""This MySQL server doesn't support dates later then 2038"");
    return 1;
  }

  if (gethostname(VAR_26,sizeof(VAR_26)) < 0)
  {
    /* COMMENT_27 */
                                                                        
                                                               
      
    strmake(VAR_26, STRING_WITH_LEN(""localhost""));
    sql_print_warning(""gethostname failed, using '%s' as hostname"",
                        VAR_26);
    VAR_27= VAR_28<char *>(""mysql"");
  }
  else
    VAR_27= VAR_26;

  if (!*VAR_29)
  {
    strmake(VAR_29, VAR_27, sizeof(VAR_29)-5);
    strmov(fn_ext(VAR_29),"".pid"");		/* COMMENT_31 */
  }

  /* COMMENT_32 */
                                                                     
                                                        
                                                              
                                                                     
                                                                      
                              

                                                                
                                                                  
              
    
#if defined(VAR_30) || defined(VAR_31)
  VAR_32= VAR_28<char *>(""InnoDB"");
#else
  VAR_32= VAR_28<char *>(""MyISAM"");
#endif

  /* COMMENT_44 */
                                                      
                                                  
                                                   
                                            
    
  if (add_status_vars(VAR_33))
    return 1; /* COMMENT_50 */

#ifndef VAR_34
  /* COMMENT_51 */
                                                                             
                                                                    

                                                                             
                                                                               
                                                    

                                           
                                                
                                                  
                                                
                                                  
                                                    
                                                
                                                         

                                                                            
                                                                             
                         
    
  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==
                     VAR_35 + 8);
#endif

  if (get_options(&VAR_36, &VAR_37))
    return 1;
  set_server_version();

  if (!VAR_38)
    sql_print_information(""%s (mysqld %s) starting as process %lu ..."",
                          VAR_39, VAR_40, (ulong) getpid());

#ifndef VAR_41
  if (VAR_42 && !VAR_43)
    unireg_abort(0);
#endif /* COMMENT_70 */

  DBUG_PRINT(""info"",(""%s  Ver %s for %s on %s\n"",VAR_39,
		     VAR_40, VAR_44,VAR_45));

#ifdef VAR_46
  /* COMMENT_71 */
  if (VAR_47 && (VAR_48= my_get_large_page_size()))
  {
      DBUG_PRINT(""info"", (""Large page set, large_page_size = %d"",
                 VAR_48));
      VAR_49= 1;
      VAR_50= VAR_48;
  }
  else
  {
    VAR_47= 0;
    /* COMMENT_72 */
                                                                
                                            
      
  }
#endif /* COMMENT_76 */
#ifdef VAR_51
#define VAR_52 (4*1024*1024)  /* 4MB */
#define VAR_53 (256*1024*1024)  /* 256MB */
  if (VAR_47)
  {
  /* COMMENT_77 */
                                                                     
                                                                
                                                                  
                                                               
                                                                   
                                   
                                                                     
                       
    
   int VAR_54;
   size_t VAR_55;
   if (VAR_56)
     VAR_55= VAR_53;
   else
     VAR_55= VAR_52;
   VAR_54 = getpagesizes(NULL, 0);
   if (VAR_54 > 0)
   {
     size_t *VAR_57 = (size_t *) malloc(sizeof(size_t) * VAR_54);
     if (VAR_57 != NULL && getpagesizes(VAR_57, VAR_54) > 0)
     {
       size_t VAR_58= 0;
       for (int VAR_59= 0; VAR_59 < VAR_54; VAR_59++)
       {
         if (VAR_57[VAR_59] > VAR_58 &&
             VAR_57[VAR_59] <= VAR_55)
            VAR_58= VAR_57[VAR_59];
       }
       free(VAR_57);
       if (VAR_58 > 0)
       {
         struct memcntl_mha VAR_60;

         VAR_60.mha_cmd= VAR_61;
         VAR_60.mha_pagesize= VAR_58;
         VAR_60.mha_flags= 0;
         memcntl(NULL, 0, VAR_62, (VAR_63)&VAR_60, 0, 0);
         VAR_60.mha_cmd= VAR_64;
         memcntl(NULL, 0, VAR_62, (VAR_63)&VAR_60, 0, 0);
       }
     }
   }
  }
#endif /* COMMENT_87 */

  /* COMMENT_88 */
  {
    uint VAR_65, VAR_66, VAR_67;

    /* COMMENT_89 */
    VAR_66= (10 + VAR_68 + VAR_69 +
                   VAR_70*2);
    /* COMMENT_90 */
                                                                   
                                                                    
                                                                    
                                                                   
                                                                 
                                                                      
                                                                
                                        
      
    VAR_67= max(max(VAR_66,
                            (VAR_68 + VAR_69)*5),
                        VAR_71);
    VAR_65= my_set_max_open_files(VAR_67);

    if (VAR_65 < VAR_66)
    {
      if (!VAR_71)
      {
        /* COMMENT_100 */
                                                                  
                                              
          
        VAR_68= (ulong) min(VAR_65-10-VAR_72*2,
                                     VAR_68);
        /* COMMENT_104 */
                                                                     
                                                                      
                                                                   
                                                        
          
        VAR_70= (ulong) min(max((VAR_65-10-VAR_68)/2,
                                          VAR_72),
                                      VAR_70);
	DBUG_PRINT(""warning"",
		   (""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
		    VAR_65, VAR_68, VAR_70));
	if (VAR_17.log_warnings)
	  sql_print_warning(""Changed limits: max_open_files: %u  max_connections: %ld  table_cache: %ld"",
			VAR_65, VAR_68, VAR_70);
      }
      else if (VAR_17.log_warnings)
	sql_print_warning(""Could not increase number of max_open_files to more than %u (request: %u)"", VAR_65, VAR_66);
    }
    VAR_71= VAR_65;
  }
  unireg_init(VAR_73); /* COMMENT_110 */
  if (!(VAR_74=
        my_locale_by_name(VAR_75)))
  {
    sql_print_error(""Unknown locale: '%s'"", VAR_75);
    return 1;
  }
  VAR_17.lc_messages= VAR_74;
  if (init_errmessage())	/* COMMENT_111 */
    return 1;
  init_client_errs();
  mysql_library_init(VAR_76,VAR_76,VAR_76); /* COMMENT_112 */
  lex_init();
  if (item_create_init())
    return 1;
  item_init();
#ifndef VAR_41
  my_regex_init(&VAR_77, VAR_78);
  VAR_79= VAR_78;
#else
  my_regex_init(&VAR_77, NULL);
#endif
  /* COMMENT_113 */
                                                           
                                                         
                                                       
                                                                 
    
  for (;;)
  {
    char *VAR_80= strchr(VAR_81, ',');
    if (VAR_80)
      *VAR_80++= '\0';
    if (!(VAR_82=
          get_charset_by_csname(VAR_81,
                                VAR_83, MYF(VAR_84))))
    {
      if (VAR_80)
      {
        VAR_81= VAR_80;
        VAR_85= 0;          /* COMMENT_119 */
      }
      else
        return 1;                           /* COMMENT_120 */
    }
    else
      break;
  }

  if (VAR_85)
  {
    CHARSET_INFO *VAR_86;
    VAR_86= get_charset_by_name(VAR_85, MYF(0));
    if (!VAR_86)
    {
      sql_print_error(ER_DEFAULT(VAR_87), VAR_85);
      return 1;
    }
    if (!my_charset_same(VAR_82, VAR_86))
    {
      sql_print_error(ER_DEFAULT(VAR_88),
		      VAR_85,
		      VAR_82->csname);
      return 1;
    }
    VAR_82= VAR_86;
  }
  /* COMMENT_121 */
  VAR_17.collation_server=	 VAR_82;
  VAR_17.collation_database=	 VAR_82;
  VAR_17.collation_connection=  VAR_82;
  VAR_17.character_set_results= VAR_82;
  VAR_17.character_set_client=  VAR_82;

  if (!(VAR_89=
        get_charset_by_csname(VAR_90,
                              VAR_83, MYF(VAR_84))))
    return 1;
  VAR_17.character_set_filesystem= VAR_89;

  if (!(VAR_91=
        my_locale_by_name(VAR_92)))
  {
    sql_print_error(""Unknown locale: '%s'"", VAR_92);
    return 1;
  }
  VAR_17.lc_time_names= VAR_91;

  /* COMMENT_122 */
  if (VAR_93 && VAR_94 && *VAR_94 &&
      !(VAR_95 & (VAR_96 | VAR_97)))
    sql_print_warning(""Although a path was specified for the ""
                      ""--log option, log tables are used. ""
                      ""To enable logging to files use the --log-output option."");

  if (VAR_98 && VAR_99 && *VAR_99 &&
      !(VAR_95 & (VAR_96 | VAR_97)))
    sql_print_warning(""Although a path was specified for the ""
                      ""--log-slow-queries option, log tables are used. ""
                      ""To enable logging to files use the --log-output=file option."");

  if (!VAR_94 || !*VAR_94)
    make_default_log_name(&VAR_94, "".log"", false);
  if (!VAR_99 || !*VAR_99)
    make_default_log_name(&VAR_99, ""-slow.log"", false);

#if defined(VAR_100)
  /* COMMENT_123 */
  if (debug_sync_init())
    return 1; /* COMMENT_124 */
#endif /* COMMENT_125 */

#if (VAR_101)
  if (VAR_102 && bitmap_init(&VAR_103,0,1024,1))
    return 1;
#else
  VAR_102= 0;
#endif

  if (my_dboptions_cache_init())
    return 1;

  /* COMMENT_126 */
                                                                          
                                                                        
                                                           
    
  DBUG_PRINT(""info"", (""lower_case_table_names: %d"", VAR_104));
  VAR_105= test_if_case_insensitive(VAR_106);
  if (!VAR_104 && VAR_105 == 1)
  {
    if (VAR_107)
    {
#if VAR_108 < 100100
      if (VAR_17.log_warnings)
        sql_print_warning(""You have forced lower_case_table_names to 0 through ""
                          ""a command-line option, even though your file system ""
                          ""'%s' is case insensitive.  This means that you can ""
                          ""corrupt your tables if you access them using names ""
                          ""with different letter case. You should consider ""
                          ""changing lower_case_table_names to 1 or 2"",
                          VAR_106);
#else
      sql_print_error(""The server option 'lower_case_table_names' is ""
                      ""configured to use case sensitive table names but the ""
                      ""data directory resides on a case-insensitive file system. ""
                      ""Please use a case sensitive file system for your data ""
                      ""directory or switch to a case-insensitive table name ""
                      ""mode."");
#endif
      return 1;
    }
    else
    {
      if (VAR_17.log_warnings)
	sql_print_warning(""Setting lower_case_table_names=2 because file system for %s is case insensitive"", VAR_106);
      VAR_104= 2;
    }
  }
  else if (VAR_104 == 2 &&
           !(VAR_105= (VAR_105 == 1)))
  {
    if (VAR_17.log_warnings)
      sql_print_warning(""lower_case_table_names was set to 2, even though your ""
                        ""the file system '%s' is case sensitive.  Now setting ""
                        ""lower_case_table_names to 0 to avoid future problems."",
			VAR_106);
    VAR_104= 0;
  }
  else
  {
    VAR_105= (VAR_105 == 1);
  }

  /* COMMENT_131 */
  VAR_109= (VAR_104 ?
			VAR_110 :
			&VAR_111);

  if (ignore_db_dirs_process_additions())
  {
    sql_print_error(""An error occurred while storing ignore_db_dirs to a hash."");
    return 1;
  }

  return 0;
}",MariaDB/server/347eeefbfc658c8531878218487d729f4e020805/mysqld.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,7 @@
 
   max_system_variables.pseudo_thread_id= (ulong)~0;
   server_start_time= flush_status_time= my_time(0);
+  my_disable_copystat_in_redel= 1;
 
   rpl_filter= new Rpl_filter;
   binlog_filter= new Rpl_filter;","{'deleted_lines': [], 'added_lines': ['  my_disable_copystat_in_redel= 1;']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-09-11T18:55:11Z,1
CVE-2016-6663,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,MariaDB/server,"don't use my_copystat in the server

it was supposed to be used in command-line tools only.
Different fix for 4e5473862e:

Bug#24388746: PRIVILEGE ESCALATION AND RACE CONDITION USING CREATE TABLE",347eeefbfc658c8531878218487d729f4e020805,https://github.com/MariaDB/server/commit/347eeefbfc658c8531878218487d729f4e020805,mysys/my_redel.c,my_redel,"int my_redel(const char *org_name, const char *tmp_name,
time_t backup_time_stamp, myf MyFlags)
{
int error=1;
DBUG_ENTER(""my_redel"");
DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
org_name,tmp_name,MyFlags));
if (my_copystat(org_name,tmp_name,MyFlags) < 0)
goto end;
if (MyFlags & MY_REDEL_MAKE_BACKUP)
{
char name_buff[FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH];    
my_create_backup_name(name_buff, org_name, backup_time_stamp);
if (my_rename(org_name, name_buff, MyFlags))
goto end;
}
else if (my_delete(org_name, MyFlags))
goto end;
if (my_rename(tmp_name,org_name,MyFlags))
goto end;
error=0;
end:
DBUG_RETURN(error);
}","int my_redel(const char *VAR_0, const char *VAR_1,
time_t VAR_2, myf VAR_3)
{
int VAR_4=1;
DBUG_ENTER(""my_redel"");
DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
VAR_0,VAR_1,VAR_3));
if (my_copystat(VAR_0,VAR_1,VAR_3) < 0)
goto end;
if (VAR_3 & VAR_5)
{
char VAR_6[VAR_7 + VAR_8];    
my_create_backup_name(VAR_6, VAR_0, VAR_2);
if (my_rename(VAR_0, VAR_6, VAR_3))
goto end;
}
else if (my_delete(VAR_0, VAR_3))
goto end;
if (my_rename(VAR_1,VAR_0,VAR_3))
goto end;
VAR_4=0;
end:
DBUG_RETURN(VAR_4);
}",MariaDB/server/347eeefbfc658c8531878218487d729f4e020805/my_redel.c/vul/before/0.json,"int my_redel(const char *org_name, const char *tmp_name,
             time_t backup_time_stamp, myf MyFlags)
{
  int error=1;
  DBUG_ENTER(""my_redel"");
  DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
		   org_name,tmp_name,MyFlags));

  if (!my_disable_copystat_in_redel &&
      my_copystat(org_name,tmp_name,MyFlags) < 0)
    goto end;
  if (MyFlags & MY_REDEL_MAKE_BACKUP)
  {
    char name_buff[FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH];    
    my_create_backup_name(name_buff, org_name, backup_time_stamp);
    if (my_rename(org_name, name_buff, MyFlags))
      goto end;
  }
  else if (my_delete(org_name, MyFlags))
      goto end;
  if (my_rename(tmp_name,org_name,MyFlags))
    goto end;

  error=0;
end:
  DBUG_RETURN(error);
}","int my_redel(const char *VAR_0, const char *VAR_1,
             time_t VAR_2, myf VAR_3)
{
  int VAR_4=1;
  DBUG_ENTER(""my_redel"");
  DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
		   VAR_0,VAR_1,VAR_3));

  if (!VAR_5 &&
      my_copystat(VAR_0,VAR_1,VAR_3) < 0)
    goto end;
  if (VAR_3 & VAR_6)
  {
    char VAR_7[VAR_8 + VAR_9];    
    my_create_backup_name(VAR_7, VAR_0, VAR_2);
    if (my_rename(VAR_0, VAR_7, VAR_3))
      goto end;
  }
  else if (my_delete(VAR_0, VAR_3))
      goto end;
  if (my_rename(VAR_1,VAR_0,VAR_3))
    goto end;

  VAR_4=0;
end:
  DBUG_RETURN(VAR_4);
}",MariaDB/server/347eeefbfc658c8531878218487d729f4e020805/my_redel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,8 @@
   DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
 		   org_name,tmp_name,MyFlags));
 
-  if (my_copystat(org_name,tmp_name,MyFlags) < 0)
+  if (!my_disable_copystat_in_redel &&
+      my_copystat(org_name,tmp_name,MyFlags) < 0)
     goto end;
   if (MyFlags & MY_REDEL_MAKE_BACKUP)
   {","{'deleted_lines': ['  if (my_copystat(org_name,tmp_name,MyFlags) < 0)'], 'added_lines': ['  if (!my_disable_copystat_in_redel &&', '      my_copystat(org_name,tmp_name,MyFlags) < 0)']}",True,"Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table.",7.0,HIGH,2,valid,2016-09-11T18:55:11Z,1
CVE-2016-7957,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"BTL2AP: compare strings with strcmp, not memcp

Otherwise a string shorter than 7 characters will trigger an out of bounds access

Bug: 12825
Change-Id: I54a7909d74838dcb56583374e5753f877ff74fe2
Reviewed-on: https://code.wireshark.org/review/17826
Reviewed-by: Michal Labedzki <michal.labedzki@tieto.com>
(cherry picked from commit 7be73201a044e8228de8e91a5f8708ebcd761015)
Reviewed-on: https://code.wireshark.org/review/17828
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",355b56b1c6c545072ac0c1225730b526c6749f0a,https://github.com/wireshark/wireshark/commit/355b56b1c6c545072ac0c1225730b526c6749f0a,epan/dissectors/packet-btl2cap.c,dissect_disconnrequestresponse,"static int
dissect_disconnrequestresponse(tvbuff_t *tvb, int offset, packet_info *pinfo,
proto_tree *tree, proto_tree *command_tree, bthci_acl_data_t *acl_data, btl2cap_data_t *l2cap_data,
gboolean is_request)
{
guint16       scid;
guint16       dcid;
guint         psm = 0;
const gchar  *service_name = ""Unknown"";
dcid = tvb_get_letohs(tvb, offset);
proto_tree_add_item(command_tree, hf_btl2cap_dcid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
scid = tvb_get_letohs(tvb, offset);
proto_tree_add_item(command_tree, hf_btl2cap_scid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
offset += 2;
if (!pinfo->fd->flags.visited) {
psm_data_t        *psm_data;
wmem_tree_key_t    key[6];
guint32            k_interface_id;
guint32            k_adapter_id;
guint32            k_chandle;
guint32            k_cid;
guint32            k_frame_number;
guint32            interface_id;
guint32            adapter_id;
guint32            chandle;
guint32            key_scid;
guint32            key_dcid;
if (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID)
interface_id = pinfo->phdr->interface_id;
else
interface_id = HCI_INTERFACE_DEFAULT;
adapter_id   = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
chandle      = (acl_data) ? acl_data->chandle : 0;
if ((is_request && pinfo->p2p_dir == P2P_DIR_SENT) ||
(!is_request && pinfo->p2p_dir == P2P_DIR_RECV)) {
key_dcid     = dcid | 0x80000000;
key_scid     = scid;
} else {
key_dcid     = scid | 0x80000000;
key_scid     = dcid;
}
k_interface_id = interface_id;
k_adapter_id   = adapter_id;
k_chandle      = chandle;
k_cid          = key_dcid;
k_frame_number = pinfo->num;
key[0].length = 1;
key[0].key    = &k_interface_id;
key[1].length = 1;
key[1].key    = &k_adapter_id;
key[2].length = 1;
key[2].key    = &k_chandle;
key[3].length = 1;
key[3].key    = &k_cid;
key[4].length = 1;
key[4].key    = &k_frame_number;
key[5].length = 0;
key[5].key    = NULL;
psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
if (psm_data && psm_data->interface_id == interface_id &&
psm_data->adapter_id == adapter_id &&
psm_data->chandle == chandle &&
psm_data->remote_cid == key_dcid &&
psm_data->disconnect_in_frame == max_disconnect_in_frame) {
psm_data->disconnect_in_frame = pinfo->num;
}
k_interface_id = interface_id;
k_adapter_id   = adapter_id;
k_chandle      = chandle;
k_cid          = key_scid;
k_frame_number = pinfo->num;
key[0].length = 1;
key[0].key    = &k_interface_id;
key[1].length = 1;
key[1].key    = &k_adapter_id;
key[2].length = 1;
key[2].key    = &k_chandle;
key[3].length = 1;
key[3].key    = &k_cid;
key[4].length = 1;
key[4].key    = &k_frame_number;
key[5].length = 0;
key[5].key    = NULL;
psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
if (psm_data && psm_data->interface_id == interface_id &&
psm_data->adapter_id == adapter_id &&
psm_data->chandle == chandle &&
psm_data->local_cid == key_scid &&
psm_data->disconnect_in_frame == max_disconnect_in_frame) {
psm_data->disconnect_in_frame = pinfo->num;
}
}
if (l2cap_data) {
proto_item        *sub_item;
guint32            bt_uuid = 0;
guint32            connect_in_frame = 0;
psm_data_t        *psm_data;
wmem_tree_key_t    key[6];
guint32            k_interface_id;
guint32            k_adapter_id;
guint32            k_chandle;
guint32            k_cid;
guint32            k_frame_number;
guint32            interface_id;
guint32            adapter_id;
guint32            chandle;
guint32            key_dcid;
if (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID)
interface_id = pinfo->phdr->interface_id;
else
interface_id = HCI_INTERFACE_DEFAULT;
adapter_id   = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
chandle      = (acl_data) ? acl_data->chandle : 0;
if ((is_request && pinfo->p2p_dir == P2P_DIR_SENT) ||
(!is_request && pinfo->p2p_dir == P2P_DIR_RECV)) {
key_dcid     = dcid | 0x80000000;
} else {
key_dcid     = scid | 0x80000000;
}
k_interface_id = interface_id;
k_adapter_id   = adapter_id;
k_chandle      = chandle;
k_cid          = key_dcid;
k_frame_number = pinfo->num;
key[0].length = 1;
key[0].key    = &k_interface_id;
key[1].length = 1;
key[1].key    = &k_adapter_id;
key[2].length = 1;
key[2].key    = &k_chandle;
key[3].length = 1;
key[3].key    = &k_cid;
key[4].length = 1;
key[4].key    = &k_frame_number;
key[5].length = 0;
key[5].key    = NULL;
psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
if (psm_data && psm_data->interface_id == interface_id &&
psm_data->adapter_id == adapter_id &&
psm_data->chandle == chandle &&
psm_data->remote_cid == key_dcid) {
psm = psm_data->psm;
bt_uuid = get_service_uuid(pinfo, l2cap_data, psm_data->psm, psm_data->local_service);
connect_in_frame = psm_data->connect_in_frame;
}
if (bt_uuid) {
bluetooth_uuid_t   uuid;
uuid.size = 2;
uuid.bt_uuid = bt_uuid;
uuid.data[0] = bt_uuid >> 8;
uuid.data[1] = bt_uuid & 0xFF;
service_name = val_to_str_ext_const(uuid.bt_uuid, &bluetooth_uuid_vals_ext, ""Unknown"");
}
if (memcmp(service_name, ""Unknown"", 7) == 0) {
service_name = val_to_str_const(psm, psm_vals, ""Unknown"");
}
if (psm > 0) {
sub_item = proto_tree_add_uint(tree, hf_btl2cap_psm, tvb, offset, 0, psm);
PROTO_ITEM_SET_GENERATED(sub_item);
}
if (bt_uuid) {
sub_item = proto_tree_add_uint(tree, hf_btl2cap_service, tvb, 0, 0, bt_uuid);
PROTO_ITEM_SET_GENERATED(sub_item);
}
if (connect_in_frame > 0) {
sub_item = proto_tree_add_uint(tree, hf_btl2cap_connect_in_frame, tvb, 0, 0, connect_in_frame);
PROTO_ITEM_SET_GENERATED(sub_item);
}
}
if (psm > 0)
col_append_fstr(pinfo->cinfo, COL_INFO, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: 0x%04x, Service: %s)"", scid, dcid, psm, service_name);
else
col_append_fstr(pinfo->cinfo, COL_INFO, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: Unknown, Service: %s)"", scid, dcid, service_name);
return offset;
}","static int
dissect_disconnrequestresponse(tvbuff_t *VAR_0, int VAR_1, packet_info *VAR_2,
proto_tree *VAR_3, proto_tree *VAR_4, bthci_acl_data_t *VAR_5, btl2cap_data_t *VAR_6,
gboolean VAR_7)
{
guint16       VAR_8;
guint16       VAR_9;
guint         VAR_10 = 0;
const gchar  *VAR_11 = ""Unknown"";
VAR_9 = tvb_get_letohs(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_12, VAR_0, VAR_1, 2, VAR_13);
VAR_1 += 2;
VAR_8 = tvb_get_letohs(VAR_0, VAR_1);
proto_tree_add_item(VAR_4, VAR_14, VAR_0, VAR_1, 2, VAR_13);
VAR_1 += 2;
if (!VAR_2->fd->flags.visited) {
psm_data_t        *VAR_15;
wmem_tree_key_t    VAR_16[6];
guint32            VAR_17;
guint32            VAR_18;
guint32            VAR_19;
guint32            VAR_20;
guint32            VAR_21;
guint32            VAR_22;
guint32            VAR_23;
guint32            VAR_24;
guint32            VAR_25;
guint32            VAR_26;
if (VAR_2->phdr->presence_flags & VAR_27)
VAR_22 = VAR_2->phdr->interface_id;
else
VAR_22 = VAR_28;
VAR_23   = (VAR_5) ? VAR_5->adapter_id : VAR_29;
VAR_24      = (VAR_5) ? VAR_5->chandle : 0;
if ((VAR_7 && VAR_2->p2p_dir == VAR_30) ||
(!VAR_7 && VAR_2->p2p_dir == VAR_31)) {
VAR_26     = VAR_9 | 0x80000000;
VAR_25     = VAR_8;
} else {
VAR_26     = VAR_8 | 0x80000000;
VAR_25     = VAR_9;
}
VAR_17 = VAR_22;
VAR_18   = VAR_23;
VAR_19      = VAR_24;
VAR_20          = VAR_26;
VAR_21 = VAR_2->num;
VAR_16[0].length = 1;
VAR_16[0].key    = &VAR_17;
VAR_16[1].length = 1;
VAR_16[1].key    = &VAR_18;
VAR_16[2].length = 1;
VAR_16[2].key    = &VAR_19;
VAR_16[3].length = 1;
VAR_16[3].key    = &VAR_20;
VAR_16[4].length = 1;
VAR_16[4].key    = &VAR_21;
VAR_16[5].length = 0;
VAR_16[5].key    = NULL;
VAR_15 = (psm_data_t *)wmem_tree_lookup32_array_le(VAR_32, VAR_16);
if (VAR_15 && VAR_15->interface_id == VAR_22 &&
VAR_15->adapter_id == VAR_23 &&
VAR_15->chandle == VAR_24 &&
VAR_15->remote_cid == VAR_26 &&
VAR_15->disconnect_in_frame == VAR_33) {
VAR_15->disconnect_in_frame = VAR_2->num;
}
VAR_17 = VAR_22;
VAR_18   = VAR_23;
VAR_19      = VAR_24;
VAR_20          = VAR_25;
VAR_21 = VAR_2->num;
VAR_16[0].length = 1;
VAR_16[0].key    = &VAR_17;
VAR_16[1].length = 1;
VAR_16[1].key    = &VAR_18;
VAR_16[2].length = 1;
VAR_16[2].key    = &VAR_19;
VAR_16[3].length = 1;
VAR_16[3].key    = &VAR_20;
VAR_16[4].length = 1;
VAR_16[4].key    = &VAR_21;
VAR_16[5].length = 0;
VAR_16[5].key    = NULL;
VAR_15 = (psm_data_t *)wmem_tree_lookup32_array_le(VAR_32, VAR_16);
if (VAR_15 && VAR_15->interface_id == VAR_22 &&
VAR_15->adapter_id == VAR_23 &&
VAR_15->chandle == VAR_24 &&
VAR_15->local_cid == VAR_25 &&
VAR_15->disconnect_in_frame == VAR_33) {
VAR_15->disconnect_in_frame = VAR_2->num;
}
}
if (VAR_6) {
proto_item        *VAR_34;
guint32            VAR_35 = 0;
guint32            VAR_36 = 0;
psm_data_t        *VAR_15;
wmem_tree_key_t    VAR_16[6];
guint32            VAR_17;
guint32            VAR_18;
guint32            VAR_19;
guint32            VAR_20;
guint32            VAR_21;
guint32            VAR_22;
guint32            VAR_23;
guint32            VAR_24;
guint32            VAR_26;
if (VAR_2->phdr->presence_flags & VAR_27)
VAR_22 = VAR_2->phdr->interface_id;
else
VAR_22 = VAR_28;
VAR_23   = (VAR_5) ? VAR_5->adapter_id : VAR_29;
VAR_24      = (VAR_5) ? VAR_5->chandle : 0;
if ((VAR_7 && VAR_2->p2p_dir == VAR_30) ||
(!VAR_7 && VAR_2->p2p_dir == VAR_31)) {
VAR_26     = VAR_9 | 0x80000000;
} else {
VAR_26     = VAR_8 | 0x80000000;
}
VAR_17 = VAR_22;
VAR_18   = VAR_23;
VAR_19      = VAR_24;
VAR_20          = VAR_26;
VAR_21 = VAR_2->num;
VAR_16[0].length = 1;
VAR_16[0].key    = &VAR_17;
VAR_16[1].length = 1;
VAR_16[1].key    = &VAR_18;
VAR_16[2].length = 1;
VAR_16[2].key    = &VAR_19;
VAR_16[3].length = 1;
VAR_16[3].key    = &VAR_20;
VAR_16[4].length = 1;
VAR_16[4].key    = &VAR_21;
VAR_16[5].length = 0;
VAR_16[5].key    = NULL;
VAR_15 = (psm_data_t *)wmem_tree_lookup32_array_le(VAR_32, VAR_16);
if (VAR_15 && VAR_15->interface_id == VAR_22 &&
VAR_15->adapter_id == VAR_23 &&
VAR_15->chandle == VAR_24 &&
VAR_15->remote_cid == VAR_26) {
VAR_10 = VAR_15->psm;
VAR_35 = get_service_uuid(VAR_2, VAR_6, VAR_15->psm, VAR_15->local_service);
VAR_36 = VAR_15->connect_in_frame;
}
if (VAR_35) {
bluetooth_uuid_t   VAR_37;
VAR_37.size = 2;
VAR_37.bt_uuid = VAR_35;
VAR_37.data[0] = VAR_35 >> 8;
VAR_37.data[1] = VAR_35 & 0xFF;
VAR_11 = val_to_str_ext_const(VAR_37.bt_uuid, &VAR_38, ""Unknown"");
}
if (memcmp(VAR_11, ""Unknown"", 7) == 0) {
VAR_11 = val_to_str_const(VAR_10, VAR_39, ""Unknown"");
}
if (VAR_10 > 0) {
VAR_34 = proto_tree_add_uint(VAR_3, VAR_40, VAR_0, VAR_1, 0, VAR_10);
PROTO_ITEM_SET_GENERATED(VAR_34);
}
if (VAR_35) {
VAR_34 = proto_tree_add_uint(VAR_3, VAR_41, VAR_0, 0, 0, VAR_35);
PROTO_ITEM_SET_GENERATED(VAR_34);
}
if (VAR_36 > 0) {
VAR_34 = proto_tree_add_uint(VAR_3, VAR_42, VAR_0, 0, 0, VAR_36);
PROTO_ITEM_SET_GENERATED(VAR_34);
}
}
if (VAR_10 > 0)
col_append_fstr(VAR_2->cinfo, VAR_43, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: 0x%04x, Service: %s)"", VAR_8, VAR_9, VAR_10, VAR_11);
else
col_append_fstr(VAR_2->cinfo, VAR_43, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: Unknown, Service: %s)"", VAR_8, VAR_9, VAR_11);
return VAR_1;
}",wireshark/355b56b1c6c545072ac0c1225730b526c6749f0a/packet-btl2cap.c/vul/before/0.json,"static int
dissect_disconnrequestresponse(tvbuff_t *tvb, int offset, packet_info *pinfo,
        proto_tree *tree, proto_tree *command_tree, bthci_acl_data_t *acl_data, btl2cap_data_t *l2cap_data,
        gboolean is_request)
{
    guint16       scid;
    guint16       dcid;
    guint         psm = 0;
    const gchar  *service_name = ""Unknown"";

    dcid = tvb_get_letohs(tvb, offset);
    proto_tree_add_item(command_tree, hf_btl2cap_dcid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    scid = tvb_get_letohs(tvb, offset);
    proto_tree_add_item(command_tree, hf_btl2cap_scid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    if (!pinfo->fd->flags.visited) {
        psm_data_t        *psm_data;
        wmem_tree_key_t    key[6];
        guint32            k_interface_id;
        guint32            k_adapter_id;
        guint32            k_chandle;
        guint32            k_cid;
        guint32            k_frame_number;
        guint32            interface_id;
        guint32            adapter_id;
        guint32            chandle;
        guint32            key_scid;
        guint32            key_dcid;

        if (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID)
            interface_id = pinfo->phdr->interface_id;
        else
            interface_id = HCI_INTERFACE_DEFAULT;
        adapter_id   = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
        chandle      = (acl_data) ? acl_data->chandle : 0;
        if ((is_request && pinfo->p2p_dir == P2P_DIR_SENT) ||
                (!is_request && pinfo->p2p_dir == P2P_DIR_RECV)) {
            key_dcid     = dcid | 0x80000000;
            key_scid     = scid;
        } else {
            key_dcid     = scid | 0x80000000;
            key_scid     = dcid;
        }

        k_interface_id = interface_id;
        k_adapter_id   = adapter_id;
        k_chandle      = chandle;
        k_cid          = key_dcid;
        k_frame_number = pinfo->num;

        key[0].length = 1;
        key[0].key    = &k_interface_id;
        key[1].length = 1;
        key[1].key    = &k_adapter_id;
        key[2].length = 1;
        key[2].key    = &k_chandle;
        key[3].length = 1;
        key[3].key    = &k_cid;
        key[4].length = 1;
        key[4].key    = &k_frame_number;
        key[5].length = 0;
        key[5].key    = NULL;

        psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
        if (psm_data && psm_data->interface_id == interface_id &&
                psm_data->adapter_id == adapter_id &&
                psm_data->chandle == chandle &&
                psm_data->remote_cid == key_dcid &&
                psm_data->disconnect_in_frame == max_disconnect_in_frame) {
            psm_data->disconnect_in_frame = pinfo->num;
        }

        k_interface_id = interface_id;
        k_adapter_id   = adapter_id;
        k_chandle      = chandle;
        k_cid          = key_scid;
        k_frame_number = pinfo->num;

        key[0].length = 1;
        key[0].key    = &k_interface_id;
        key[1].length = 1;
        key[1].key    = &k_adapter_id;
        key[2].length = 1;
        key[2].key    = &k_chandle;
        key[3].length = 1;
        key[3].key    = &k_cid;
        key[4].length = 1;
        key[4].key    = &k_frame_number;
        key[5].length = 0;
        key[5].key    = NULL;

        psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
        if (psm_data && psm_data->interface_id == interface_id &&
                psm_data->adapter_id == adapter_id &&
                psm_data->chandle == chandle &&
                psm_data->local_cid == key_scid &&
                psm_data->disconnect_in_frame == max_disconnect_in_frame) {
            psm_data->disconnect_in_frame = pinfo->num;
        }
    }

    if (l2cap_data) {
        proto_item        *sub_item;
        guint32            bt_uuid = 0;
        guint32            connect_in_frame = 0;
        psm_data_t        *psm_data;
        wmem_tree_key_t    key[6];
        guint32            k_interface_id;
        guint32            k_adapter_id;
        guint32            k_chandle;
        guint32            k_cid;
        guint32            k_frame_number;
        guint32            interface_id;
        guint32            adapter_id;
        guint32            chandle;
        guint32            key_dcid;

        if (pinfo->phdr->presence_flags & WTAP_HAS_INTERFACE_ID)
            interface_id = pinfo->phdr->interface_id;
        else
            interface_id = HCI_INTERFACE_DEFAULT;
        adapter_id   = (acl_data) ? acl_data->adapter_id : HCI_ADAPTER_DEFAULT;
        chandle      = (acl_data) ? acl_data->chandle : 0;
        if ((is_request && pinfo->p2p_dir == P2P_DIR_SENT) ||
                (!is_request && pinfo->p2p_dir == P2P_DIR_RECV)) {
            key_dcid     = dcid | 0x80000000;
        } else {
            key_dcid     = scid | 0x80000000;
        }

        k_interface_id = interface_id;
        k_adapter_id   = adapter_id;
        k_chandle      = chandle;
        k_cid          = key_dcid;
        k_frame_number = pinfo->num;

        key[0].length = 1;
        key[0].key    = &k_interface_id;
        key[1].length = 1;
        key[1].key    = &k_adapter_id;
        key[2].length = 1;
        key[2].key    = &k_chandle;
        key[3].length = 1;
        key[3].key    = &k_cid;
        key[4].length = 1;
        key[4].key    = &k_frame_number;
        key[5].length = 0;
        key[5].key    = NULL;

        psm_data = (psm_data_t *)wmem_tree_lookup32_array_le(cid_to_psm_table, key);
        if (psm_data && psm_data->interface_id == interface_id &&
                psm_data->adapter_id == adapter_id &&
                psm_data->chandle == chandle &&
                psm_data->remote_cid == key_dcid) {
            psm = psm_data->psm;
            bt_uuid = get_service_uuid(pinfo, l2cap_data, psm_data->psm, psm_data->local_service);
            connect_in_frame = psm_data->connect_in_frame;
        }

        if (bt_uuid) {
            bluetooth_uuid_t   uuid;

            uuid.size = 2;
            uuid.bt_uuid = bt_uuid;
            uuid.data[0] = bt_uuid >> 8;
            uuid.data[1] = bt_uuid & 0xFF;

            service_name = val_to_str_ext_const(uuid.bt_uuid, &bluetooth_uuid_vals_ext, ""Unknown"");
        }

        if (strcmp(service_name, ""Unknown"") == 0) {
            service_name = val_to_str_const(psm, psm_vals, ""Unknown"");
        }

        if (psm > 0) {
            sub_item = proto_tree_add_uint(tree, hf_btl2cap_psm, tvb, offset, 0, psm);
            PROTO_ITEM_SET_GENERATED(sub_item);
        }

        if (bt_uuid) {
            sub_item = proto_tree_add_uint(tree, hf_btl2cap_service, tvb, 0, 0, bt_uuid);
            PROTO_ITEM_SET_GENERATED(sub_item);
        }

        if (connect_in_frame > 0) {
            sub_item = proto_tree_add_uint(tree, hf_btl2cap_connect_in_frame, tvb, 0, 0, connect_in_frame);
            PROTO_ITEM_SET_GENERATED(sub_item);
        }
    }

    if (psm > 0)
        col_append_fstr(pinfo->cinfo, COL_INFO, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: 0x%04x, Service: %s)"", scid, dcid, psm, service_name);
    else
        col_append_fstr(pinfo->cinfo, COL_INFO, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: Unknown, Service: %s)"", scid, dcid, service_name);


    return offset;
}","static int
dissect_disconnrequestresponse(tvbuff_t *VAR_0, int VAR_1, packet_info *VAR_2,
        proto_tree *VAR_3, proto_tree *VAR_4, bthci_acl_data_t *VAR_5, btl2cap_data_t *VAR_6,
        gboolean VAR_7)
{
    guint16       VAR_8;
    guint16       VAR_9;
    guint         VAR_10 = 0;
    const gchar  *VAR_11 = ""Unknown"";

    VAR_9 = tvb_get_letohs(VAR_0, VAR_1);
    proto_tree_add_item(VAR_4, VAR_12, VAR_0, VAR_1, 2, VAR_13);
    VAR_1 += 2;

    VAR_8 = tvb_get_letohs(VAR_0, VAR_1);
    proto_tree_add_item(VAR_4, VAR_14, VAR_0, VAR_1, 2, VAR_13);
    VAR_1 += 2;

    if (!VAR_2->fd->flags.visited) {
        psm_data_t        *VAR_15;
        wmem_tree_key_t    VAR_16[6];
        guint32            VAR_17;
        guint32            VAR_18;
        guint32            VAR_19;
        guint32            VAR_20;
        guint32            VAR_21;
        guint32            VAR_22;
        guint32            VAR_23;
        guint32            VAR_24;
        guint32            VAR_25;
        guint32            VAR_26;

        if (VAR_2->phdr->presence_flags & VAR_27)
            VAR_22 = VAR_2->phdr->interface_id;
        else
            VAR_22 = VAR_28;
        VAR_23   = (VAR_5) ? VAR_5->adapter_id : VAR_29;
        VAR_24      = (VAR_5) ? VAR_5->chandle : 0;
        if ((VAR_7 && VAR_2->p2p_dir == VAR_30) ||
                (!VAR_7 && VAR_2->p2p_dir == VAR_31)) {
            VAR_26     = VAR_9 | 0x80000000;
            VAR_25     = VAR_8;
        } else {
            VAR_26     = VAR_8 | 0x80000000;
            VAR_25     = VAR_9;
        }

        VAR_17 = VAR_22;
        VAR_18   = VAR_23;
        VAR_19      = VAR_24;
        VAR_20          = VAR_26;
        VAR_21 = VAR_2->num;

        VAR_16[0].length = 1;
        VAR_16[0].key    = &VAR_17;
        VAR_16[1].length = 1;
        VAR_16[1].key    = &VAR_18;
        VAR_16[2].length = 1;
        VAR_16[2].key    = &VAR_19;
        VAR_16[3].length = 1;
        VAR_16[3].key    = &VAR_20;
        VAR_16[4].length = 1;
        VAR_16[4].key    = &VAR_21;
        VAR_16[5].length = 0;
        VAR_16[5].key    = NULL;

        VAR_15 = (psm_data_t *)wmem_tree_lookup32_array_le(VAR_32, VAR_16);
        if (VAR_15 && VAR_15->interface_id == VAR_22 &&
                VAR_15->adapter_id == VAR_23 &&
                VAR_15->chandle == VAR_24 &&
                VAR_15->remote_cid == VAR_26 &&
                VAR_15->disconnect_in_frame == VAR_33) {
            VAR_15->disconnect_in_frame = VAR_2->num;
        }

        VAR_17 = VAR_22;
        VAR_18   = VAR_23;
        VAR_19      = VAR_24;
        VAR_20          = VAR_25;
        VAR_21 = VAR_2->num;

        VAR_16[0].length = 1;
        VAR_16[0].key    = &VAR_17;
        VAR_16[1].length = 1;
        VAR_16[1].key    = &VAR_18;
        VAR_16[2].length = 1;
        VAR_16[2].key    = &VAR_19;
        VAR_16[3].length = 1;
        VAR_16[3].key    = &VAR_20;
        VAR_16[4].length = 1;
        VAR_16[4].key    = &VAR_21;
        VAR_16[5].length = 0;
        VAR_16[5].key    = NULL;

        VAR_15 = (psm_data_t *)wmem_tree_lookup32_array_le(VAR_32, VAR_16);
        if (VAR_15 && VAR_15->interface_id == VAR_22 &&
                VAR_15->adapter_id == VAR_23 &&
                VAR_15->chandle == VAR_24 &&
                VAR_15->local_cid == VAR_25 &&
                VAR_15->disconnect_in_frame == VAR_33) {
            VAR_15->disconnect_in_frame = VAR_2->num;
        }
    }

    if (VAR_6) {
        proto_item        *VAR_34;
        guint32            VAR_35 = 0;
        guint32            VAR_36 = 0;
        psm_data_t        *VAR_15;
        wmem_tree_key_t    VAR_16[6];
        guint32            VAR_17;
        guint32            VAR_18;
        guint32            VAR_19;
        guint32            VAR_20;
        guint32            VAR_21;
        guint32            VAR_22;
        guint32            VAR_23;
        guint32            VAR_24;
        guint32            VAR_26;

        if (VAR_2->phdr->presence_flags & VAR_27)
            VAR_22 = VAR_2->phdr->interface_id;
        else
            VAR_22 = VAR_28;
        VAR_23   = (VAR_5) ? VAR_5->adapter_id : VAR_29;
        VAR_24      = (VAR_5) ? VAR_5->chandle : 0;
        if ((VAR_7 && VAR_2->p2p_dir == VAR_30) ||
                (!VAR_7 && VAR_2->p2p_dir == VAR_31)) {
            VAR_26     = VAR_9 | 0x80000000;
        } else {
            VAR_26     = VAR_8 | 0x80000000;
        }

        VAR_17 = VAR_22;
        VAR_18   = VAR_23;
        VAR_19      = VAR_24;
        VAR_20          = VAR_26;
        VAR_21 = VAR_2->num;

        VAR_16[0].length = 1;
        VAR_16[0].key    = &VAR_17;
        VAR_16[1].length = 1;
        VAR_16[1].key    = &VAR_18;
        VAR_16[2].length = 1;
        VAR_16[2].key    = &VAR_19;
        VAR_16[3].length = 1;
        VAR_16[3].key    = &VAR_20;
        VAR_16[4].length = 1;
        VAR_16[4].key    = &VAR_21;
        VAR_16[5].length = 0;
        VAR_16[5].key    = NULL;

        VAR_15 = (psm_data_t *)wmem_tree_lookup32_array_le(VAR_32, VAR_16);
        if (VAR_15 && VAR_15->interface_id == VAR_22 &&
                VAR_15->adapter_id == VAR_23 &&
                VAR_15->chandle == VAR_24 &&
                VAR_15->remote_cid == VAR_26) {
            VAR_10 = VAR_15->psm;
            VAR_35 = get_service_uuid(VAR_2, VAR_6, VAR_15->psm, VAR_15->local_service);
            VAR_36 = VAR_15->connect_in_frame;
        }

        if (VAR_35) {
            bluetooth_uuid_t   VAR_37;

            VAR_37.size = 2;
            VAR_37.bt_uuid = VAR_35;
            VAR_37.data[0] = VAR_35 >> 8;
            VAR_37.data[1] = VAR_35 & 0xFF;

            VAR_11 = val_to_str_ext_const(VAR_37.bt_uuid, &VAR_38, ""Unknown"");
        }

        if (strcmp(VAR_11, ""Unknown"") == 0) {
            VAR_11 = val_to_str_const(VAR_10, VAR_39, ""Unknown"");
        }

        if (VAR_10 > 0) {
            VAR_34 = proto_tree_add_uint(VAR_3, VAR_40, VAR_0, VAR_1, 0, VAR_10);
            PROTO_ITEM_SET_GENERATED(VAR_34);
        }

        if (VAR_35) {
            VAR_34 = proto_tree_add_uint(VAR_3, VAR_41, VAR_0, 0, 0, VAR_35);
            PROTO_ITEM_SET_GENERATED(VAR_34);
        }

        if (VAR_36 > 0) {
            VAR_34 = proto_tree_add_uint(VAR_3, VAR_42, VAR_0, 0, 0, VAR_36);
            PROTO_ITEM_SET_GENERATED(VAR_34);
        }
    }

    if (VAR_10 > 0)
        col_append_fstr(VAR_2->cinfo, VAR_43, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: 0x%04x, Service: %s)"", VAR_8, VAR_9, VAR_10, VAR_11);
    else
        col_append_fstr(VAR_2->cinfo, VAR_43, "" (SCID: 0x%04x, DCID: 0x%04x, PSM: Unknown, Service: %s)"", VAR_8, VAR_9, VAR_11);


    return VAR_1;
}",wireshark/355b56b1c6c545072ac0c1225730b526c6749f0a/packet-btl2cap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -171,7 +171,7 @@
             service_name = val_to_str_ext_const(uuid.bt_uuid, &bluetooth_uuid_vals_ext, ""Unknown"");
         }
 
-        if (memcmp(service_name, ""Unknown"", 7) == 0) {
+        if (strcmp(service_name, ""Unknown"") == 0) {
             service_name = val_to_str_const(psm, psm_vals, ""Unknown"");
         }
 ","{'deleted_lines': ['        if (memcmp(service_name, ""Unknown"", 7) == 0) {'], 'added_lines': ['        if (strcmp(service_name, ""Unknown"") == 0) {']}",True,"In Wireshark 2.2.0, the Bluetooth L2CAP dissector could crash, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-btl2cap.c by avoiding use of a seven-byte memcmp for potentially shorter strings.",7.5,HIGH,2,valid,2016-09-21T09:09:43Z,1
CVE-2016-10749,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,DaveGamble/cJSON,fix buffer overflow (#30),94df772485c92866ca417d92137747b2e3b0a917,https://github.com/DaveGamble/cJSON/commit/94df772485c92866ca417d92137747b2e3b0a917,cJSON.c,parse_string,"static const char *parse_string(cJSON *item,const char *str,const char **ep)
{
const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
if (*str!='\""') {*ep=str;return 0;}
while (*end_ptr!='\""' && *end_ptr && ++len) if (*end_ptr++ == '\\') end_ptr++;
out=(char*)cJSON_malloc(len+1);
if (!out) return 0;
item->valuestring=out; 
item->type=cJSON_String;
ptr=str+1;ptr2=out;
while (ptr < end_ptr)
{
if (*ptr!='\\') *ptr2++=*ptr++;
else
{
ptr++;
switch (*ptr)
{
case 'b': *ptr2++='\b';break;
case 'f': *ptr2++='\f';break;
case 'n': *ptr2++='\n';break;
case 'r': *ptr2++='\r';break;
case 't': *ptr2++='\t';break;
case 'u': 
uc=parse_hex4(ptr+1);ptr+=4;
if (ptr >= end_ptr) {*ep=str;return 0;}
if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}
if (uc>=0xD800 && uc<=0xDBFF)
{
if (ptr+6 > end_ptr)    {*ep=str;return 0;}
if (ptr[1]!='\\' || ptr[2]!='u')    {*ep=str;return 0;}
uc2=parse_hex4(ptr+3);ptr+=6;
if (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}
uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
}
len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
switch (len) {
case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
case 1: *--ptr2 =(uc | firstByteMark[len]);
}
ptr2+=len;
break;
default:  *ptr2++=*ptr; break;
}
ptr++;
}
}
*ptr2=0;
if (*ptr=='\""') ptr++;
return ptr;
}","static const char *parse_string(cJSON *VAR_0,const char *VAR_1,const char **VAR_2)
{
const char *VAR_3=VAR_1+1,*VAR_4=VAR_1+1;char *VAR_5;char *VAR_6;int VAR_7=0;unsigned VAR_8,VAR_9;
if (*VAR_1!='\""') {*VAR_2=VAR_1;return 0;}
while (*VAR_4!='\""' && *VAR_4 && ++VAR_7) if (*VAR_4++ == '\\') VAR_4++;
VAR_6=(char*)cJSON_malloc(VAR_7+1);
if (!VAR_6) return 0;
VAR_0->valuestring=VAR_6; 
VAR_0->type=VAR_10;
VAR_3=VAR_1+1;VAR_5=VAR_6;
while (VAR_3 < VAR_4)
{
if (*VAR_3!='\\') *VAR_5++=*VAR_3++;
else
{
VAR_3++;
switch (*VAR_3)
{
case 'b': *VAR_5++='\b';break;
case 'f': *VAR_5++='\f';break;
case 'n': *VAR_5++='\n';break;
case 'r': *VAR_5++='\r';break;
case 't': *VAR_5++='\t';break;
case 'u': 
VAR_8=parse_hex4(VAR_3+1);VAR_3+=4;
if (VAR_3 >= VAR_4) {*VAR_2=VAR_1;return 0;}
if ((VAR_8>=0xDC00 && VAR_8<=0xDFFF) || VAR_8==0)    {*VAR_2=VAR_1;return 0;}
if (VAR_8>=0xD800 && VAR_8<=0xDBFF)
{
if (VAR_3+6 > VAR_4)    {*VAR_2=VAR_1;return 0;}
if (VAR_3[1]!='\\' || VAR_3[2]!='u')    {*VAR_2=VAR_1;return 0;}
VAR_9=parse_hex4(VAR_3+3);VAR_3+=6;
if (VAR_9<0xDC00 || VAR_9>0xDFFF)       {*VAR_2=VAR_1;return 0;}
VAR_8=0x10000 + (((VAR_8&0x3FF)<<10) | (VAR_9&0x3FF));
}
VAR_7=4;if (VAR_8<0x80) VAR_7=1;else if (VAR_8<0x800) VAR_7=2;else if (VAR_8<0x10000) VAR_7=3; VAR_5+=VAR_7;
switch (VAR_7) {
case 4: *--VAR_5 =((VAR_8 | 0x80) & 0xBF); VAR_8 >>= 6;
case 3: *--VAR_5 =((VAR_8 | 0x80) & 0xBF); VAR_8 >>= 6;
case 2: *--VAR_5 =((VAR_8 | 0x80) & 0xBF); VAR_8 >>= 6;
case 1: *--VAR_5 =(VAR_8 | VAR_11[VAR_7]);
}
VAR_5+=VAR_7;
break;
default:  *VAR_5++=*VAR_3; break;
}
VAR_3++;
}
}
*VAR_5=0;
if (*VAR_3=='\""') VAR_3++;
return VAR_3;
}",DaveGamble/cJSON/94df772485c92866ca417d92137747b2e3b0a917/cJSON.c/vul/before/0.json,"static const char *parse_string(cJSON *item,const char *str,const char **ep)
{
	const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
	if (*str!='\""') {*ep=str;return 0;}	/* not a string! */

	while (*end_ptr!='\""' && *end_ptr && ++len)
	{
	    if (*end_ptr++ == '\\')
	    {
		if (*end_ptr == '\0')
		{
		    /* prevent buffer overflow when last input character is a backslash */
		    return 0;
		}
		end_ptr++;	/* Skip escaped quotes. */
	    }
	}

	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
	item->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */
	item->type=cJSON_String;
	
	ptr=str+1;ptr2=out;
	while (ptr < end_ptr)
	{
		if (*ptr!='\\') *ptr2++=*ptr++;
		else
		{
			ptr++;
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */
					if (ptr >= end_ptr) {*ep=str;return 0;}	/* invalid */
					
					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}	/* check for invalid.   */
					
					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
					{
						if (ptr+6 > end_ptr)    {*ep=str;return 0;}	/* invalid */
						if (ptr[1]!='\\' || ptr[2]!='u')    {*ep=str;return 0;}	/* missing second-half of surrogate.    */
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}	/* invalid second-half of surrogate.    */
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
					}
					ptr2+=len;
					break;
				default:  *ptr2++=*ptr; break;
			}
			ptr++;
		}
	}
	*ptr2=0;
	if (*ptr=='\""') ptr++;
	return ptr;
}","static const char *parse_string(cJSON *VAR_0,const char *VAR_1,const char **VAR_2)
{
	const char *VAR_3=VAR_1+1,*VAR_4=VAR_1+1;char *VAR_5;char *VAR_6;int VAR_7=0;unsigned VAR_8,VAR_9;
	if (*VAR_1!='\""') {*VAR_2=VAR_1;return 0;}	/* COMMENT_0 */

	while (*VAR_4!='\""' && *VAR_4 && ++VAR_7)
	{
	    if (*VAR_4++ == '\\')
	    {
		if (*VAR_4 == '\0')
		{
		    /* COMMENT_1 */
		    return 0;
		}
		VAR_4++;	/* COMMENT_2 */
	    }
	}

	VAR_6=(char*)cJSON_malloc(VAR_7+1);	/* COMMENT_3 */
	if (!VAR_6) return 0;
	VAR_0->valuestring=VAR_6; /* COMMENT_4 */
	VAR_0->type=VAR_10;
	
	VAR_3=VAR_1+1;VAR_5=VAR_6;
	while (VAR_3 < VAR_4)
	{
		if (*VAR_3!='\\') *VAR_5++=*VAR_3++;
		else
		{
			VAR_3++;
			switch (*VAR_3)
			{
				case 'b': *VAR_5++='\b';	break;
				case 'f': *VAR_5++='\f';	break;
				case 'n': *VAR_5++='\n';	break;
				case 'r': *VAR_5++='\r';	break;
				case 't': *VAR_5++='\t';	break;
				case 'u':	 /* COMMENT_5 */
					VAR_8=parse_hex4(VAR_3+1);VAR_3+=4;	/* COMMENT_6 */
					if (VAR_3 >= VAR_4) {*VAR_2=VAR_1;return 0;}	/* COMMENT_7 */
					
					if ((VAR_8>=0xDC00 && VAR_8<=0xDFFF) || VAR_8==0)    {*VAR_2=VAR_1;return 0;}	/* COMMENT_8 */
					
					if (VAR_8>=0xD800 && VAR_8<=0xDBFF)	/* COMMENT_9 */
					{
						if (VAR_3+6 > VAR_4)    {*VAR_2=VAR_1;return 0;}	/* COMMENT_7 */
						if (VAR_3[1]!='\\' || VAR_3[2]!='u')    {*VAR_2=VAR_1;return 0;}	/* COMMENT_10 */
						VAR_9=parse_hex4(VAR_3+3);VAR_3+=6;
						if (VAR_9<0xDC00 || VAR_9>0xDFFF)       {*VAR_2=VAR_1;return 0;}	/* COMMENT_11 */
						VAR_8=0x10000 + (((VAR_8&0x3FF)<<10) | (VAR_9&0x3FF));
					}

					VAR_7=4;if (VAR_8<0x80) VAR_7=1;else if (VAR_8<0x800) VAR_7=2;else if (VAR_8<0x10000) VAR_7=3; VAR_5+=VAR_7;
					
					switch (VAR_7) {
						case 4: *--VAR_5 =((VAR_8 | 0x80) & 0xBF); VAR_8 >>= 6;
						case 3: *--VAR_5 =((VAR_8 | 0x80) & 0xBF); VAR_8 >>= 6;
						case 2: *--VAR_5 =((VAR_8 | 0x80) & 0xBF); VAR_8 >>= 6;
						case 1: *--VAR_5 =(VAR_8 | VAR_11[VAR_7]);
					}
					VAR_5+=VAR_7;
					break;
				default:  *VAR_5++=*VAR_3; break;
			}
			VAR_3++;
		}
	}
	*VAR_5=0;
	if (*VAR_3=='\""') VAR_3++;
	return VAR_3;
}",DaveGamble/cJSON/94df772485c92866ca417d92137747b2e3b0a917/cJSON.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,9 +2,20 @@
 {
 	const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
 	if (*str!='\""') {*ep=str;return 0;}	/* not a string! */
-	
-	while (*end_ptr!='\""' && *end_ptr && ++len) if (*end_ptr++ == '\\') end_ptr++;	/* Skip escaped quotes. */
-	
+
+	while (*end_ptr!='\""' && *end_ptr && ++len)
+	{
+	    if (*end_ptr++ == '\\')
+	    {
+		if (*end_ptr == '\0')
+		{
+		    /* prevent buffer overflow when last input character is a backslash */
+		    return 0;
+		}
+		end_ptr++;	/* Skip escaped quotes. */
+	    }
+	}
+
 	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
 	if (!out) return 0;
 	item->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */","{'deleted_lines': ['\t', '\twhile (*end_ptr!=\'\\""\' && *end_ptr && ++len) if (*end_ptr++ == \'\\\\\') end_ptr++;\t/* Skip escaped quotes. */', '\t'], 'added_lines': ['', '\twhile (*end_ptr!=\'\\""\' && *end_ptr && ++len)', '\t{', ""\t    if (*end_ptr++ == '\\\\')"", '\t    {', ""\t\tif (*end_ptr == '\\0')"", '\t\t{', '\t\t    /* prevent buffer overflow when last input character is a backslash */', '\t\t    return 0;', '\t\t}', '\t\tend_ptr++;\t/* Skip escaped quotes. */', '\t    }', '\t}', '']}",True,"parse_string in cJSON.c in cJSON before 2016-10-02 has a buffer over-read, as demonstrated by a string that begins with a "" character and ends with a \ character.",9.8,CRITICAL,3,valid,2016-10-02T11:56:53Z,1
CVE-2016-10397,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,php/php-src,Fix bug #73192,b061fa909de77085d3822a89ab901b934d0362c4,https://github.com/php/php-src/commit/b061fa909de77085d3822a89ab901b934d0362c4,ext/standard/url.c,php_url_parse_ex,"PHPAPI php_url *php_url_parse_ex(char const *str, int length)
{
char port_buf[6];
php_url *ret = ecalloc(1, sizeof(php_url));
char const *s, *e, *p, *pp, *ue;
s = str;
ue = s + length;
if ((e = memchr(s, ':', length)) && (e - s)) {
p = s;
while (p < e) {
if (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {
if (e + 1 < ue) {
goto parse_port;
} else {
goto just_path;
}
}
p++;
}
if (*(e + 1) == '\0') { 
ret->scheme = estrndup(s, (e - s));
php_replace_controlchars_ex(ret->scheme, (e - s));
goto end;
}
if (*(e+1) != '/') {
p = e + 1;
while (isdigit(*p)) {
p++;
}
if ((*p == '\0' || *p == '/') && (p - e) < 7) {
goto parse_port;
}
ret->scheme = estrndup(s, (e-s));
php_replace_controlchars_ex(ret->scheme, (e - s));
length -= ++e - s;
s = e;
goto just_path;
} else {
ret->scheme = estrndup(s, (e-s));
php_replace_controlchars_ex(ret->scheme, (e - s));
if (*(e+2) == '/') {
s = e + 3;
if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
if (*(e + 3) == '/') {
if (*(e + 5) == ':') {
s = e + 4;
}
goto nohost;
}
}
} else {
if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
s = e + 1;
goto nohost;
} else {
length -= ++e - s;
s = e;
goto just_path;
}
}
}
} else if (e) { 
parse_port:
p = e + 1;
pp = p;
while (pp-p < 6 && isdigit(*pp)) {
pp++;
}
if (pp - p > 0 && pp - p < 6 && (*pp == '/' || *pp == '\0')) {
long port;
memcpy(port_buf, p, (pp - p));
port_buf[pp - p] = '\0';
port = strtol(port_buf, NULL, 10);
if (port > 0 && port <= 65535) {
ret->port = (unsigned short) port;
if (*s == '/' && *(s + 1) == '/') { 
s += 2;
}
} else {
STR_FREE(ret->scheme);
efree(ret);
return NULL;
}
} else if (p == pp && *pp == '\0') {
STR_FREE(ret->scheme);
efree(ret);
return NULL;
} else if (*s == '/' && *(s + 1) == '/') { 
s += 2;
} else {
goto just_path;
}
} else if (*s == '/' && *(s + 1) == '/') { 
s += 2;
} else {
just_path:
ue = s + length;
goto nohost;
}
e = ue;
if (!(p = memchr(s, '/', (ue - s)))) {
char *query, *fragment;
query = memchr(s, '?', (ue - s));
fragment = memchr(s, '#', (ue - s));
if (query && fragment) {
if (query > fragment) {
e = fragment;
} else {
e = query;
}
} else if (query) {
e = query;
} else if (fragment) {
e = fragment;
}
} else {
e = p;
}
if ((p = zend_memrchr(s, '@', (e-s)))) {
if ((pp = memchr(s, ':', (p-s)))) {
ret->user = estrndup(s, (pp-s));
php_replace_controlchars_ex(ret->user, (pp - s));
pp++;
ret->pass = estrndup(pp, (p-pp));
php_replace_controlchars_ex(ret->pass, (p-pp));
} else {
ret->user = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->user, (p-s));
}
s = p + 1;
}
if (*s == '[' && *(e-1) == ']') {
p = s;
} else {
for(p = e; p >= s && *p != ':'; p--);
}
if (p >= s && *p == ':') {
if (!ret->port) {
p++;
if (e-p > 5) { 
STR_FREE(ret->scheme);
STR_FREE(ret->user);
STR_FREE(ret->pass);
efree(ret);
return NULL;
} else if (e - p > 0) {
long port;
memcpy(port_buf, p, (e - p));
port_buf[e - p] = '\0';
port = strtol(port_buf, NULL, 10);
if (port > 0 && port <= 65535) {
ret->port = (unsigned short)port;
} else {
STR_FREE(ret->scheme);
STR_FREE(ret->user);
STR_FREE(ret->pass);
efree(ret);
return NULL;
}
}
p--;
}
} else {
p = e;
}
if ((p-s) < 1) {
STR_FREE(ret->scheme);
STR_FREE(ret->user);
STR_FREE(ret->pass);
efree(ret);
return NULL;
}
ret->host = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->host, (p - s));
if (e == ue) {
return ret;
}
s = e;
nohost:
if ((p = memchr(s, '?', (ue - s)))) {
pp = memchr(s, '#', (ue - s));
if (pp && pp < p) {
if (pp - s) {
ret->path = estrndup(s, (pp-s));
php_replace_controlchars_ex(ret->path, (pp - s));
}
p = pp;
goto label_parse;
}
if (p - s) {
ret->path = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->path, (p - s));
}
if (pp) {
if (pp - ++p) {
ret->query = estrndup(p, (pp-p));
php_replace_controlchars_ex(ret->query, (pp - p));
}
p = pp;
goto label_parse;
} else if (++p - ue) {
ret->query = estrndup(p, (ue-p));
php_replace_controlchars_ex(ret->query, (ue - p));
}
} else if ((p = memchr(s, '#', (ue - s)))) {
if (p - s) {
ret->path = estrndup(s, (p-s));
php_replace_controlchars_ex(ret->path, (p - s));
}
label_parse:
p++;
if (ue - p) {
ret->fragment = estrndup(p, (ue-p));
php_replace_controlchars_ex(ret->fragment, (ue - p));
}
} else {
ret->path = estrndup(s, (ue-s));
php_replace_controlchars_ex(ret->path, (ue - s));
}
end:
return ret;
}","PHPAPI VAR_0 *php_url_parse_ex(char const *VAR_1, int VAR_2)
{
char VAR_3[6];
php_url *VAR_4 = ecalloc(1, sizeof(php_url));
char const *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;
VAR_5 = VAR_1;
VAR_9 = VAR_5 + VAR_2;
if ((VAR_6 = memchr(VAR_5, ':', VAR_2)) && (VAR_6 - VAR_5)) {
VAR_7 = VAR_5;
while (VAR_7 < VAR_6) {
if (!isalpha(*VAR_7) && !isdigit(*VAR_7) && *VAR_7 != '+' && *VAR_7 != '.' && *VAR_7 != '-') {
if (VAR_6 + 1 < VAR_9) {
goto parse_port;
} else {
goto just_path;
}
}
VAR_7++;
}
if (*(VAR_6 + 1) == '\0') { 
VAR_4->scheme = estrndup(VAR_5, (VAR_6 - VAR_5));
php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
goto end;
}
if (*(VAR_6+1) != '/') {
VAR_7 = VAR_6 + 1;
while (isdigit(*VAR_7)) {
VAR_7++;
}
if ((*VAR_7 == '\0' || *VAR_7 == '/') && (VAR_7 - VAR_6) < 7) {
goto parse_port;
}
VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
VAR_2 -= ++VAR_6 - VAR_5;
VAR_5 = VAR_6;
goto just_path;
} else {
VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
if (*(VAR_6+2) == '/') {
VAR_5 = VAR_6 + 3;
if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
if (*(VAR_6 + 3) == '/') {
if (*(VAR_6 + 5) == ':') {
VAR_5 = VAR_6 + 4;
}
goto nohost;
}
}
} else {
if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
VAR_5 = VAR_6 + 1;
goto nohost;
} else {
VAR_2 -= ++VAR_6 - VAR_5;
VAR_5 = VAR_6;
goto just_path;
}
}
}
} else if (VAR_6) { 
parse_port:
VAR_7 = VAR_6 + 1;
VAR_8 = VAR_7;
while (VAR_8-VAR_7 < 6 && isdigit(*VAR_8)) {
VAR_8++;
}
if (VAR_8 - VAR_7 > 0 && VAR_8 - VAR_7 < 6 && (*VAR_8 == '/' || *VAR_8 == '\0')) {
long VAR_10;
memcpy(VAR_3, VAR_7, (VAR_8 - VAR_7));
VAR_3[VAR_8 - VAR_7] = '\0';
VAR_10 = strtol(VAR_3, NULL, 10);
if (VAR_10 > 0 && VAR_10 <= 65535) {
VAR_4->port = (unsigned short) VAR_10;
if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { 
VAR_5 += 2;
}
} else {
STR_FREE(VAR_4->scheme);
efree(VAR_4);
return NULL;
}
} else if (VAR_7 == VAR_8 && *VAR_8 == '\0') {
STR_FREE(VAR_4->scheme);
efree(VAR_4);
return NULL;
} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { 
VAR_5 += 2;
} else {
goto just_path;
}
} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { 
VAR_5 += 2;
} else {
just_path:
VAR_9 = VAR_5 + VAR_2;
goto nohost;
}
VAR_6 = VAR_9;
if (!(VAR_7 = memchr(VAR_5, '/', (VAR_9 - VAR_5)))) {
char *VAR_11, *VAR_12;
VAR_11 = memchr(VAR_5, '?', (VAR_9 - VAR_5));
VAR_12 = memchr(VAR_5, '#', (VAR_9 - VAR_5));
if (VAR_11 && VAR_12) {
if (VAR_11 > VAR_12) {
VAR_6 = VAR_12;
} else {
VAR_6 = VAR_11;
}
} else if (VAR_11) {
VAR_6 = VAR_11;
} else if (VAR_12) {
VAR_6 = VAR_12;
}
} else {
VAR_6 = VAR_7;
}
if ((VAR_7 = zend_memrchr(VAR_5, '@', (VAR_6-VAR_5)))) {
if ((VAR_8 = memchr(VAR_5, ':', (VAR_7-VAR_5)))) {
VAR_4->user = estrndup(VAR_5, (VAR_8-VAR_5));
php_replace_controlchars_ex(VAR_4->user, (VAR_8 - VAR_5));
VAR_8++;
VAR_4->pass = estrndup(VAR_8, (VAR_7-VAR_8));
php_replace_controlchars_ex(VAR_4->pass, (VAR_7-VAR_8));
} else {
VAR_4->user = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->user, (VAR_7-VAR_5));
}
VAR_5 = VAR_7 + 1;
}
if (*VAR_5 == '[' && *(VAR_6-1) == ']') {
VAR_7 = VAR_5;
} else {
for(VAR_7 = VAR_6; VAR_7 >= VAR_5 && *VAR_7 != ':'; VAR_7--);
}
if (VAR_7 >= VAR_5 && *VAR_7 == ':') {
if (!VAR_4->port) {
VAR_7++;
if (VAR_6-VAR_7 > 5) { 
STR_FREE(VAR_4->scheme);
STR_FREE(VAR_4->user);
STR_FREE(VAR_4->pass);
efree(VAR_4);
return NULL;
} else if (VAR_6 - VAR_7 > 0) {
long VAR_10;
memcpy(VAR_3, VAR_7, (VAR_6 - VAR_7));
VAR_3[VAR_6 - VAR_7] = '\0';
VAR_10 = strtol(VAR_3, NULL, 10);
if (VAR_10 > 0 && VAR_10 <= 65535) {
VAR_4->port = (unsigned short)VAR_10;
} else {
STR_FREE(VAR_4->scheme);
STR_FREE(VAR_4->user);
STR_FREE(VAR_4->pass);
efree(VAR_4);
return NULL;
}
}
VAR_7--;
}
} else {
VAR_7 = VAR_6;
}
if ((VAR_7-VAR_5) < 1) {
STR_FREE(VAR_4->scheme);
STR_FREE(VAR_4->user);
STR_FREE(VAR_4->pass);
efree(VAR_4);
return NULL;
}
VAR_4->host = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->host, (VAR_7 - VAR_5));
if (VAR_6 == VAR_9) {
return VAR_4;
}
VAR_5 = VAR_6;
nohost:
if ((VAR_7 = memchr(VAR_5, '?', (VAR_9 - VAR_5)))) {
VAR_8 = memchr(VAR_5, '#', (VAR_9 - VAR_5));
if (VAR_8 && VAR_8 < VAR_7) {
if (VAR_8 - VAR_5) {
VAR_4->path = estrndup(VAR_5, (VAR_8-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_8 - VAR_5));
}
VAR_7 = VAR_8;
goto label_parse;
}
if (VAR_7 - VAR_5) {
VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
}
if (VAR_8) {
if (VAR_8 - ++VAR_7) {
VAR_4->query = estrndup(VAR_7, (VAR_8-VAR_7));
php_replace_controlchars_ex(VAR_4->query, (VAR_8 - VAR_7));
}
VAR_7 = VAR_8;
goto label_parse;
} else if (++VAR_7 - VAR_9) {
VAR_4->query = estrndup(VAR_7, (VAR_9-VAR_7));
php_replace_controlchars_ex(VAR_4->query, (VAR_9 - VAR_7));
}
} else if ((VAR_7 = memchr(VAR_5, '#', (VAR_9 - VAR_5)))) {
if (VAR_7 - VAR_5) {
VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
}
label_parse:
VAR_7++;
if (VAR_9 - VAR_7) {
VAR_4->fragment = estrndup(VAR_7, (VAR_9-VAR_7));
php_replace_controlchars_ex(VAR_4->fragment, (VAR_9 - VAR_7));
}
} else {
VAR_4->path = estrndup(VAR_5, (VAR_9-VAR_5));
php_replace_controlchars_ex(VAR_4->path, (VAR_9 - VAR_5));
}
end:
return VAR_4;
}",,"PHPAPI php_url *php_url_parse_ex(char const *str, int length)
{
	char port_buf[6];
	php_url *ret = ecalloc(1, sizeof(php_url));
	char const *s, *e, *p, *pp, *ue;

	s = str;
	ue = s + length;

	/* parse scheme */
	if ((e = memchr(s, ':', length)) && (e - s)) {
		/* validate scheme */
		p = s;
		while (p < e) {
			/* scheme = 1*[ lowalpha | digit | ""+"" | ""-"" | ""."" ] */
			if (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') {
				if (e + 1 < ue) {
					goto parse_port;
				} else {
					goto just_path;
				}
			}
			p++;
		}

		if (*(e + 1) == '\0') { /* only scheme is available */
			ret->scheme = estrndup(s, (e - s));
			php_replace_controlchars_ex(ret->scheme, (e - s));
			goto end;
		}

		/*
		 * certain schemas like mailto: and zlib: may not have any / after them
		 * this check ensures we support those.
		 */
		if (*(e+1) != '/') {
			/* check if the data we get is a port this allows us to
			 * correctly parse things like a.com:80
			 */
			p = e + 1;
			while (isdigit(*p)) {
				p++;
			}

			if ((*p == '\0' || *p == '/') && (p - e) < 7) {
				goto parse_port;
			}

			ret->scheme = estrndup(s, (e-s));
			php_replace_controlchars_ex(ret->scheme, (e - s));

			length -= ++e - s;
			s = e;
			goto just_path;
		} else {
			ret->scheme = estrndup(s, (e-s));
			php_replace_controlchars_ex(ret->scheme, (e - s));

			if (*(e+2) == '/') {
				s = e + 3;
				if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
					if (*(e + 3) == '/') {
						/* support windows drive letters as in:
						   file:///c:/somedir/file.txt
						*/
						if (*(e + 5) == ':') {
							s = e + 4;
						}
						goto nohost;
					}
				}
			} else {
				if (!strncasecmp(""file"", ret->scheme, sizeof(""file""))) {
					s = e + 1;
					goto nohost;
				} else {
					length -= ++e - s;
					s = e;
					goto just_path;
				}
			}
		}
	} else if (e) { /* no scheme; starts with colon: look for port */
		parse_port:
		p = e + 1;
		pp = p;

		while (pp-p < 6 && isdigit(*pp)) {
			pp++;
		}

		if (pp - p > 0 && pp - p < 6 && (*pp == '/' || *pp == '\0')) {
			long port;
			memcpy(port_buf, p, (pp - p));
			port_buf[pp - p] = '\0';
			port = strtol(port_buf, NULL, 10);
			if (port > 0 && port <= 65535) {
				ret->port = (unsigned short) port;
				if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */
				    s += 2;
				}
			} else {
				STR_FREE(ret->scheme);
				efree(ret);
				return NULL;
			}
		} else if (p == pp && *pp == '\0') {
			STR_FREE(ret->scheme);
			efree(ret);
			return NULL;
		} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */
			s += 2;
		} else {
			goto just_path;
		}
	} else if (*s == '/' && *(s + 1) == '/') { /* relative-scheme URL */
		s += 2;
	} else {
		just_path:
		ue = s + length;
		goto nohost;
	}

	e = s + strcspn(s, ""/?#"");

	/* check for login and password */
	if ((p = zend_memrchr(s, '@', (e-s)))) {
		if ((pp = memchr(s, ':', (p-s)))) {
			ret->user = estrndup(s, (pp-s));
			php_replace_controlchars_ex(ret->user, (pp - s));

			pp++;
			ret->pass = estrndup(pp, (p-pp));
			php_replace_controlchars_ex(ret->pass, (p-pp));
		} else {
			ret->user = estrndup(s, (p-s));
			php_replace_controlchars_ex(ret->user, (p-s));
		}

		s = p + 1;
	}

	/* check for port */
	if (*s == '[' && *(e-1) == ']') {
		/* Short circuit portscan,
		   we're dealing with an
		   IPv6 embedded address */
		p = s;
	} else {
		/* memrchr is a GNU specific extension
		   Emulate for wide compatibility */
		for(p = e; p >= s && *p != ':'; p--);
	}

	if (p >= s && *p == ':') {
		if (!ret->port) {
			p++;
			if (e-p > 5) { /* port cannot be longer then 5 characters */
				STR_FREE(ret->scheme);
				STR_FREE(ret->user);
				STR_FREE(ret->pass);
				efree(ret);
				return NULL;
			} else if (e - p > 0) {
				long port;
				memcpy(port_buf, p, (e - p));
				port_buf[e - p] = '\0';
				port = strtol(port_buf, NULL, 10);
				if (port > 0 && port <= 65535) {
					ret->port = (unsigned short)port;
				} else {
					STR_FREE(ret->scheme);
					STR_FREE(ret->user);
					STR_FREE(ret->pass);
					efree(ret);
					return NULL;
				}
			}
			p--;
		}
	} else {
		p = e;
	}

	/* check if we have a valid host, if we don't reject the string as url */
	if ((p-s) < 1) {
		STR_FREE(ret->scheme);
		STR_FREE(ret->user);
		STR_FREE(ret->pass);
		efree(ret);
		return NULL;
	}

	ret->host = estrndup(s, (p-s));
	php_replace_controlchars_ex(ret->host, (p - s));

	if (e == ue) {
		return ret;
	}

	s = e;

	nohost:

	if ((p = memchr(s, '?', (ue - s)))) {
		pp = memchr(s, '#', (ue - s));

		if (pp && pp < p) {
			if (pp - s) {
				ret->path = estrndup(s, (pp-s));
				php_replace_controlchars_ex(ret->path, (pp - s));
			}
			p = pp;
			goto label_parse;
		}

		if (p - s) {
			ret->path = estrndup(s, (p-s));
			php_replace_controlchars_ex(ret->path, (p - s));
		}

		if (pp) {
			if (pp - ++p) {
				ret->query = estrndup(p, (pp-p));
				php_replace_controlchars_ex(ret->query, (pp - p));
			}
			p = pp;
			goto label_parse;
		} else if (++p - ue) {
			ret->query = estrndup(p, (ue-p));
			php_replace_controlchars_ex(ret->query, (ue - p));
		}
	} else if ((p = memchr(s, '#', (ue - s)))) {
		if (p - s) {
			ret->path = estrndup(s, (p-s));
			php_replace_controlchars_ex(ret->path, (p - s));
		}

		label_parse:
		p++;

		if (ue - p) {
			ret->fragment = estrndup(p, (ue-p));
			php_replace_controlchars_ex(ret->fragment, (ue - p));
		}
	} else {
		ret->path = estrndup(s, (ue-s));
		php_replace_controlchars_ex(ret->path, (ue - s));
	}
end:
	return ret;
}","PHPAPI VAR_0 *php_url_parse_ex(char const *VAR_1, int VAR_2)
{
	char VAR_3[6];
	php_url *VAR_4 = ecalloc(1, sizeof(php_url));
	char const *VAR_5, *VAR_6, *VAR_7, *VAR_8, *VAR_9;

	VAR_5 = VAR_1;
	VAR_9 = VAR_5 + VAR_2;

	/* COMMENT_0 */
	if ((VAR_6 = memchr(VAR_5, ':', VAR_2)) && (VAR_6 - VAR_5)) {
		/* COMMENT_1 */
		VAR_7 = VAR_5;
		while (VAR_7 < VAR_6) {
			/* COMMENT_2 */
			if (!isalpha(*VAR_7) && !isdigit(*VAR_7) && *VAR_7 != '+' && *VAR_7 != '.' && *VAR_7 != '-') {
				if (VAR_6 + 1 < VAR_9) {
					goto parse_port;
				} else {
					goto just_path;
				}
			}
			VAR_7++;
		}

		if (*(VAR_6 + 1) == '\0') { /* COMMENT_3 */
			VAR_4->scheme = estrndup(VAR_5, (VAR_6 - VAR_5));
			php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));
			goto end;
		}

		/* COMMENT_4 */
                                                                         
                                         
     
		if (*(VAR_6+1) != '/') {
			/* COMMENT_8 */
                                          
      
			VAR_7 = VAR_6 + 1;
			while (isdigit(*VAR_7)) {
				VAR_7++;
			}

			if ((*VAR_7 == '\0' || *VAR_7 == '/') && (VAR_7 - VAR_6) < 7) {
				goto parse_port;
			}

			VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
			php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));

			VAR_2 -= ++VAR_6 - VAR_5;
			VAR_5 = VAR_6;
			goto just_path;
		} else {
			VAR_4->scheme = estrndup(VAR_5, (VAR_6-VAR_5));
			php_replace_controlchars_ex(VAR_4->scheme, (VAR_6 - VAR_5));

			if (*(VAR_6+2) == '/') {
				VAR_5 = VAR_6 + 3;
				if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
					if (*(VAR_6 + 3) == '/') {
						/* COMMENT_11 */
                                    
        
						if (*(VAR_6 + 5) == ':') {
							VAR_5 = VAR_6 + 4;
						}
						goto nohost;
					}
				}
			} else {
				if (!strncasecmp(""file"", VAR_4->scheme, sizeof(""file""))) {
					VAR_5 = VAR_6 + 1;
					goto nohost;
				} else {
					VAR_2 -= ++VAR_6 - VAR_5;
					VAR_5 = VAR_6;
					goto just_path;
				}
			}
		}
	} else if (VAR_6) { /* COMMENT_14 */
		parse_port:
		VAR_7 = VAR_6 + 1;
		VAR_8 = VAR_7;

		while (VAR_8-VAR_7 < 6 && isdigit(*VAR_8)) {
			VAR_8++;
		}

		if (VAR_8 - VAR_7 > 0 && VAR_8 - VAR_7 < 6 && (*VAR_8 == '/' || *VAR_8 == '\0')) {
			long VAR_10;
			memcpy(VAR_3, VAR_7, (VAR_8 - VAR_7));
			VAR_3[VAR_8 - VAR_7] = '\0';
			VAR_10 = strtol(VAR_3, NULL, 10);
			if (VAR_10 > 0 && VAR_10 <= 65535) {
				VAR_4->port = (unsigned short) VAR_10;
				if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { /* COMMENT_15 */
				    VAR_5 += 2;
				}
			} else {
				STR_FREE(VAR_4->scheme);
				efree(VAR_4);
				return NULL;
			}
		} else if (VAR_7 == VAR_8 && *VAR_8 == '\0') {
			STR_FREE(VAR_4->scheme);
			efree(VAR_4);
			return NULL;
		} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { /* COMMENT_15 */
			VAR_5 += 2;
		} else {
			goto just_path;
		}
	} else if (*VAR_5 == '/' && *(VAR_5 + 1) == '/') { /* COMMENT_15 */
		VAR_5 += 2;
	} else {
		just_path:
		VAR_9 = VAR_5 + VAR_2;
		goto nohost;
	}

	VAR_6 = VAR_5 + strcspn(VAR_5, ""/?#"");

	/* COMMENT_16 */
	if ((VAR_7 = zend_memrchr(VAR_5, '@', (VAR_6-VAR_5)))) {
		if ((VAR_8 = memchr(VAR_5, ':', (VAR_7-VAR_5)))) {
			VAR_4->user = estrndup(VAR_5, (VAR_8-VAR_5));
			php_replace_controlchars_ex(VAR_4->user, (VAR_8 - VAR_5));

			VAR_8++;
			VAR_4->pass = estrndup(VAR_8, (VAR_7-VAR_8));
			php_replace_controlchars_ex(VAR_4->pass, (VAR_7-VAR_8));
		} else {
			VAR_4->user = estrndup(VAR_5, (VAR_7-VAR_5));
			php_replace_controlchars_ex(VAR_4->user, (VAR_7-VAR_5));
		}

		VAR_5 = VAR_7 + 1;
	}

	/* COMMENT_17 */
	if (*VAR_5 == '[' && *(VAR_6-1) == ']') {
		/* COMMENT_18 */
                          
                             
		VAR_7 = VAR_5;
	} else {
		/* COMMENT_21 */
                                      
		for(VAR_7 = VAR_6; VAR_7 >= VAR_5 && *VAR_7 != ':'; VAR_7--);
	}

	if (VAR_7 >= VAR_5 && *VAR_7 == ':') {
		if (!VAR_4->port) {
			VAR_7++;
			if (VAR_6-VAR_7 > 5) { /* COMMENT_23 */
				STR_FREE(VAR_4->scheme);
				STR_FREE(VAR_4->user);
				STR_FREE(VAR_4->pass);
				efree(VAR_4);
				return NULL;
			} else if (VAR_6 - VAR_7 > 0) {
				long VAR_10;
				memcpy(VAR_3, VAR_7, (VAR_6 - VAR_7));
				VAR_3[VAR_6 - VAR_7] = '\0';
				VAR_10 = strtol(VAR_3, NULL, 10);
				if (VAR_10 > 0 && VAR_10 <= 65535) {
					VAR_4->port = (unsigned short)VAR_10;
				} else {
					STR_FREE(VAR_4->scheme);
					STR_FREE(VAR_4->user);
					STR_FREE(VAR_4->pass);
					efree(VAR_4);
					return NULL;
				}
			}
			VAR_7--;
		}
	} else {
		VAR_7 = VAR_6;
	}

	/* COMMENT_24 */
	if ((VAR_7-VAR_5) < 1) {
		STR_FREE(VAR_4->scheme);
		STR_FREE(VAR_4->user);
		STR_FREE(VAR_4->pass);
		efree(VAR_4);
		return NULL;
	}

	VAR_4->host = estrndup(VAR_5, (VAR_7-VAR_5));
	php_replace_controlchars_ex(VAR_4->host, (VAR_7 - VAR_5));

	if (VAR_6 == VAR_9) {
		return VAR_4;
	}

	VAR_5 = VAR_6;

	nohost:

	if ((VAR_7 = memchr(VAR_5, '?', (VAR_9 - VAR_5)))) {
		VAR_8 = memchr(VAR_5, '#', (VAR_9 - VAR_5));

		if (VAR_8 && VAR_8 < VAR_7) {
			if (VAR_8 - VAR_5) {
				VAR_4->path = estrndup(VAR_5, (VAR_8-VAR_5));
				php_replace_controlchars_ex(VAR_4->path, (VAR_8 - VAR_5));
			}
			VAR_7 = VAR_8;
			goto label_parse;
		}

		if (VAR_7 - VAR_5) {
			VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
			php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
		}

		if (VAR_8) {
			if (VAR_8 - ++VAR_7) {
				VAR_4->query = estrndup(VAR_7, (VAR_8-VAR_7));
				php_replace_controlchars_ex(VAR_4->query, (VAR_8 - VAR_7));
			}
			VAR_7 = VAR_8;
			goto label_parse;
		} else if (++VAR_7 - VAR_9) {
			VAR_4->query = estrndup(VAR_7, (VAR_9-VAR_7));
			php_replace_controlchars_ex(VAR_4->query, (VAR_9 - VAR_7));
		}
	} else if ((VAR_7 = memchr(VAR_5, '#', (VAR_9 - VAR_5)))) {
		if (VAR_7 - VAR_5) {
			VAR_4->path = estrndup(VAR_5, (VAR_7-VAR_5));
			php_replace_controlchars_ex(VAR_4->path, (VAR_7 - VAR_5));
		}

		label_parse:
		VAR_7++;

		if (VAR_9 - VAR_7) {
			VAR_4->fragment = estrndup(VAR_7, (VAR_9-VAR_7));
			php_replace_controlchars_ex(VAR_4->fragment, (VAR_9 - VAR_7));
		}
	} else {
		VAR_4->path = estrndup(VAR_5, (VAR_9-VAR_5));
		php_replace_controlchars_ex(VAR_4->path, (VAR_9 - VAR_5));
	}
end:
	return VAR_4;
}",,"--- func_before
+++ func_after
@@ -121,28 +121,7 @@
 		goto nohost;
 	}
 
-	e = ue;
-
-	if (!(p = memchr(s, '/', (ue - s)))) {
-		char *query, *fragment;
-
-		query = memchr(s, '?', (ue - s));
-		fragment = memchr(s, '#', (ue - s));
-
-		if (query && fragment) {
-			if (query > fragment) {
-				e = fragment;
-			} else {
-				e = query;
-			}
-		} else if (query) {
-			e = query;
-		} else if (fragment) {
-			e = fragment;
-		}
-	} else {
-		e = p;
-	}
+	e = s + strcspn(s, ""/?#"");
 
 	/* check for login and password */
 	if ((p = zend_memrchr(s, '@', (e-s)))) {","{'deleted_lines': ['\te = ue;', '', ""\tif (!(p = memchr(s, '/', (ue - s)))) {"", '\t\tchar *query, *fragment;', '', ""\t\tquery = memchr(s, '?', (ue - s));"", ""\t\tfragment = memchr(s, '#', (ue - s));"", '', '\t\tif (query && fragment) {', '\t\t\tif (query > fragment) {', '\t\t\t\te = fragment;', '\t\t\t} else {', '\t\t\t\te = query;', '\t\t\t}', '\t\t} else if (query) {', '\t\t\te = query;', '\t\t} else if (fragment) {', '\t\t\te = fragment;', '\t\t}', '\t} else {', '\t\te = p;', '\t}'], 'added_lines': ['\te = s + strcspn(s, ""/?#"");']}",True,"In PHP before 5.6.28 and 7.x before 7.0.13, incorrect handling of various URI components in the URL parser could be used by attackers to bypass hostname-specific URL checks, as demonstrated by evil.example.com:80#@good.example.com/ and evil.example.com:80?@good.example.com/ inputs to the parse_url function (implemented in the php_url_parse_ex function in ext/standard/url.c).",7.5,HIGH,2,valid,2016-10-07T23:04:22Z,1
CVE-2016-9372,"['CWE-20', 'CWE-399']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"Profinet I/O: Sanity check number of I/O objects

Can prevent really long loops from fuzz testing.

Bug: 12851
Change-Id: I85e00af2c4753ce4c5bcb650a7df188d7f679c9a
Reviewed-on: https://code.wireshark.org/review/18136
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit e8022a9c7b36b96578a30fc8132def6de8928606)
Reviewed-on: https://code.wireshark.org/review/18137",4127e3930ef663114567002001f44e01eba8a250,https://github.com/wireshark/wireshark/commit/4127e3930ef663114567002001f44e01eba8a250,plugins/profinet/packet-pn-rtc-one.c,dissect_PNIO_C_SDU_RTC1,"int
dissect_PNIO_C_SDU_RTC1(tvbuff_t *tvb, int offset,
packet_info *pinfo, proto_tree *tree, guint8 *drep _U_)
{
proto_tree  *data_tree = NULL;
guint16     frameOffset;
guint32     objectCounter;
gboolean    inputFlag;
gboolean    outputFlag;
gboolean    psInfoText;     
proto_item *IODataObject_item;
proto_item *IODataObject_item_info;
proto_tree *IODataObject_tree;
proto_item *ModuleID_item;
proto_item *ModuleDiff_item;
wmem_strbuf_t *moduleName;
guint8  toggleBitSb;
guint8  toggleBitCb;
guint64 f_data;
guint8  statusbyte;
guint8  controlbyte;
guint16 number_io_data_objects_input_cr;
guint16 number_iocs_input_cr;
guint16 number_io_data_objects_output_cr;
guint16 number_iocs_output_cr;
conversation_t    *conversation;
stationInfo       *station_info = NULL;
iocsObject        *iocs_object;
ioDataObject      *io_data_object;
moduleDiffInfo    *module_diff_info;
wmem_list_frame_t *frame;
wmem_list_frame_t *frame_diff;
frameOffset = 0;
f_data = 0;
inputFlag = FALSE;
outputFlag = FALSE;
psInfoText = FALSE;
number_io_data_objects_input_cr = 0;
number_iocs_input_cr = 0;
number_io_data_objects_output_cr = 0;
number_iocs_output_cr = 0;
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO"");            
if (tree) {
proto_item *data_item;
data_item = proto_tree_add_protocol_format(tree, proto_pn_io_rtc1, tvb, offset, tvb_captured_length(tvb),
""PROFINET IO Cyclic Service Data Unit: %u bytes"", tvb_captured_length(tvb));
data_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc);
}
if (!(dissect_CSF_SDU_heur(tvb, pinfo, data_tree, NULL) == FALSE))
return(tvb_captured_length(tvb));
conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
if (conversation != NULL) {
station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);
if (station_info != NULL) {
if (pnio_ps_selection == TRUE) {
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO_PS"");    
}
if (addresses_equal(&(pinfo->src), &(conversation->key_ptr->addr1)) && addresses_equal(&(pinfo->dst), &(conversation->key_ptr->addr2))) {
inputFlag = TRUE;
outputFlag = FALSE;
number_io_data_objects_input_cr = station_info->ioDataObjectNr;
number_iocs_input_cr = station_info->iocsNr;
}
if (addresses_equal(&(pinfo->dst), &(conversation->key_ptr->addr1)) && addresses_equal(&(pinfo->src), &(conversation->key_ptr->addr2))) {
outputFlag = TRUE;
inputFlag = FALSE;
number_io_data_objects_output_cr = station_info->ioDataObjectNr;
number_iocs_output_cr = station_info->iocsNr;
}
}
}
if (inputFlag) {
if (pnio_ps_selection == TRUE) {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
offset, 0, ""Response"", ""Response Frame (IO_Device -> IO_Controller)"");
}
else {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
offset, 0, ""Input"", ""Input Frame (IO_Device -> IO_Controller)"");
}
if (station_info != NULL) {
if (station_info->typeofstation != NULL) {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_vendor, tvb, 0,
0, station_info->typeofstation, ""\""%s\"""", station_info->typeofstation);
}
if (station_info->nameofstation != NULL) {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_nameofstation, tvb, 0,
0, station_info->nameofstation, ""\""%s\"""", station_info->nameofstation);
}
if (station_info->gsdPathLength == TRUE) {      
if (station_info->gsdFound == TRUE) {       
if (station_info->gsdLocation != NULL) {
IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_found, tvb, offset, 0, ENC_NA);
proto_item_append_text(IODataObject_item_info, "": \""%s\"""", station_info->gsdLocation);
}
}
else {
if (station_info->gsdLocation != NULL) {
IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_error, tvb, offset, 0, ENC_NA);
proto_item_append_text(IODataObject_item_info, "" Please place relevant GSD-file under \""%s\"""", station_info->gsdLocation);
}
}
}
else {
IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_path, tvb, offset, 0, ENC_NA);
proto_item_append_text(IODataObject_item_info, "" Please check your GSD-file networkpath. (No Path configured)"");
}
}
objectCounter = number_io_data_objects_input_cr + number_iocs_input_cr;
while (objectCounter--) {
if (station_info != NULL) {
for (frame = wmem_list_head(station_info->ioobject_data_in); frame != NULL; frame = wmem_list_frame_next(frame)) {
io_data_object = (ioDataObject*)wmem_list_frame_data(frame);
if (io_data_object->frameOffset == frameOffset) {
IODataObject_item = proto_tree_add_item(data_tree, hf_pn_io_io_data_object, tvb, offset, 0, ENC_NA);
IODataObject_tree = proto_item_add_subtree(IODataObject_item, ett_pn_io_io_data_object);
for (frame_diff = wmem_list_head(station_info->diff_module); frame_diff != NULL; frame_diff = wmem_list_frame_next(frame_diff)) {
module_diff_info = (moduleDiffInfo*)wmem_list_frame_data(frame_diff);
if (io_data_object->moduleIdentNr != module_diff_info->modulID) {
ModuleDiff_item = proto_tree_add_item(IODataObject_tree, hf_pn_io_io_data_object_info_module_diff, tvb, 0, 0, ENC_NA);
proto_item_append_text(ModuleDiff_item, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", module_diff_info->modulID, io_data_object->moduleIdentNr);
break;
}
}
proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_moduleidentnumber, tvb, 0, 0, io_data_object->moduleIdentNr);
proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_submoduleidentnumber, tvb, 0, 0, io_data_object->subModuleIdentNr);
if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
if (io_data_object->profisafeSupported == TRUE && psInfoText == FALSE) {
col_append_str(pinfo->cinfo, COL_INFO, "", PROFIsafe Device"");    
psInfoText = TRUE;
}
proto_tree_add_uint(IODataObject_tree, hf_pn_io_ps_f_dest_adr, tvb, 0, 0, io_data_object->f_dest_adr);
if ((io_data_object->length - F_MESSAGE_TRAILER_4BYTE) > 0) {
offset = dissect_pn_io_ps_uint(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_f_data,
(io_data_object->length - F_MESSAGE_TRAILER_4BYTE), &f_data);
}
statusbyte = tvb_get_guint8(tvb, offset);
toggleBitSb = statusbyte & 0x20;     
if (io_data_object->lastToggleBit != toggleBitSb) {    
ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChanged, tvb, offset, 0,
toggleBitSb, ""%u"", toggleBitSb);
PROTO_ITEM_SET_HIDDEN(ModuleID_item);
ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChange_slot_nr, tvb, offset, 0,
io_data_object->slotNr, ""%u"", io_data_object->slotNr);
PROTO_ITEM_SET_HIDDEN(ModuleID_item);
ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChange_subslot_nr, tvb, offset, 0,
io_data_object->subSlotNr, ""%u"", io_data_object->subSlotNr);
PROTO_ITEM_SET_HIDDEN(ModuleID_item);
}
offset = dissect_pn_io_ps_SB(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_sb, ps_sb_fields);
offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->f_crc_len, ""CRC"");
io_data_object->last_sb_cb = statusbyte;       
io_data_object->lastToggleBit = toggleBitSb;   
}    
else {
offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->length, ""IO Data"");
}
if (io_data_object->discardIOXS == FALSE) {
offset = dissect_PNIO_IOxS(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_iops, ioxs_fields);
proto_item_set_len(IODataObject_item, io_data_object->length + 1);     
}
else {
proto_item_set_len(IODataObject_item, io_data_object->length);         
}
proto_item_append_text(IODataObject_item, "": Slot: 0x%x Subslot: 0x%x"",
io_data_object->slotNr, io_data_object->subSlotNr);
if (io_data_object->amountInGSDML > 1) {    
if (io_data_object->slotNr == 0) {
moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
}
else {
moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
}
if (io_data_object->profisafeSupported == TRUE) {
if (io_data_object->length >= 5) {        
wmem_strbuf_append(moduleName, "", DI"");
}
else {
wmem_strbuf_append(moduleName, "", DO"");
}
}
else {
if (io_data_object->length > 0) {
wmem_strbuf_append(moduleName, "", DI"");
}
else {
wmem_strbuf_append(moduleName, "", DO"");
}
}
io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(moduleName));
}
proto_item_append_text(IODataObject_item, "" ModuleName: \""%s\"""", io_data_object->moduleNameStr);
if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
(proto_item_append_text(IODataObject_item, "" (PROFIsafe Module)""));
}
frameOffset = frameOffset + io_data_object->length;  
if (io_data_object->discardIOXS == FALSE) {
frameOffset = frameOffset + 1;      
}
}
}
}
if (station_info != NULL) {
for (frame = wmem_list_head(station_info->iocs_data_in); frame != NULL; frame = wmem_list_frame_next(frame)) {
iocs_object = (iocsObject*)wmem_list_frame_data(frame);
if (iocs_object->frameOffset == frameOffset) {
offset = dissect_PNIO_IOCS(tvb, offset, pinfo, data_tree, drep, hf_pn_io_iocs, iocs_object->slotNr,
iocs_object->subSlotNr, ioxs_fields);
frameOffset = frameOffset + 1;      
break;
}
}
}
}
offset = dissect_pn_user_data(tvb, offset, pinfo, tree, tvb_captured_length_remaining(tvb, offset), ""GAP and RTCPadding"");
}   
else if (outputFlag) {
if (pnio_ps_selection == TRUE) {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
offset, 0, ""Request"", ""Request Frame (IO_Controller -> IO_Device)"");
}
else {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
offset, 0, ""Output"", ""Output Frame (IO_Controller -> IO_Device)"");
}
if (station_info != NULL) {
if (station_info->typeofstation != NULL) {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_vendor, tvb, 0,
0, station_info->typeofstation, ""\""%s\"""", station_info->typeofstation);
}
if (station_info->nameofstation != NULL) {
proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_nameofstation, tvb, 0,
0, station_info->nameofstation, ""\""%s\"""", station_info->nameofstation);
}
if (station_info->gsdPathLength == TRUE) {      
if (station_info->gsdFound == TRUE) {       
if (station_info->gsdLocation != NULL) {
IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_found, tvb, offset, 0, ENC_NA);
proto_item_append_text(IODataObject_item_info, "": \""%s\"""", station_info->gsdLocation);
}
}
else {
if (station_info->gsdLocation != NULL) {
IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_error, tvb, offset, 0, ENC_NA);
proto_item_append_text(IODataObject_item_info, "" Please place relevant GSD-file under \""%s\"""", station_info->gsdLocation);
}
}
}
else {
IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_path, tvb, offset, 0, ENC_NA);
proto_item_append_text(IODataObject_item_info, "" Please check your GSD-file networkpath. (No Path configured)"");
}
}
objectCounter = number_io_data_objects_output_cr + number_iocs_output_cr;
while (objectCounter--) {
if (station_info != NULL) {
for (frame = wmem_list_head(station_info->ioobject_data_out); frame != NULL; frame = wmem_list_frame_next(frame)) {
io_data_object = (ioDataObject*)wmem_list_frame_data(frame);
if (io_data_object != NULL && io_data_object->frameOffset == frameOffset) {
IODataObject_item = proto_tree_add_item(data_tree, hf_pn_io_io_data_object, tvb, offset, 0, ENC_NA);
IODataObject_tree = proto_item_add_subtree(IODataObject_item, ett_pn_io_io_data_object);
for (frame_diff = wmem_list_head(station_info->diff_module); frame_diff != NULL; frame_diff = wmem_list_frame_next(frame_diff)) {
module_diff_info = (moduleDiffInfo*)wmem_list_frame_data(frame_diff);
if (io_data_object->moduleIdentNr != module_diff_info->modulID) {
ModuleDiff_item = proto_tree_add_item(IODataObject_tree, hf_pn_io_io_data_object_info_module_diff, tvb, 0, 0, ENC_NA);
proto_item_append_text(ModuleDiff_item, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", module_diff_info->modulID, io_data_object->moduleIdentNr);
break;
}
}
proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_moduleidentnumber, tvb, 0, 0, io_data_object->moduleIdentNr);
proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_submoduleidentnumber, tvb, 0, 0, io_data_object->subModuleIdentNr);
if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
if (io_data_object->profisafeSupported == TRUE && psInfoText == FALSE) {
col_append_str(pinfo->cinfo, COL_INFO, "", PROFIsafe Device"");    
psInfoText = TRUE;
}
proto_tree_add_uint(IODataObject_tree, hf_pn_io_ps_f_dest_adr, tvb, 0, 0, io_data_object->f_dest_adr);
if ((io_data_object->length - F_MESSAGE_TRAILER_4BYTE) > 0) {
offset = dissect_pn_io_ps_uint(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_f_data,
(io_data_object->length - F_MESSAGE_TRAILER_4BYTE), &f_data);
}
controlbyte = tvb_get_guint8(tvb, offset);
toggleBitCb = controlbyte & 0x20;               
if (io_data_object->lastToggleBit != toggleBitCb) {   
ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChanged, tvb, offset, 0,
toggleBitCb, ""%u"", toggleBitCb);
PROTO_ITEM_SET_HIDDEN(ModuleID_item);
ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChange_slot_nr, tvb, offset, 0,
io_data_object->slotNr, ""%u"", io_data_object->slotNr);
PROTO_ITEM_SET_HIDDEN(ModuleID_item);
ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChange_subslot_nr, tvb, offset, 0,
io_data_object->subSlotNr, ""%u"", io_data_object->subSlotNr);
PROTO_ITEM_SET_HIDDEN(ModuleID_item);
}
offset = dissect_pn_io_ps_CB(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_cb, ps_cb_fields);
offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->f_crc_len, ""CRC"");
io_data_object->last_sb_cb = controlbyte;         
io_data_object->lastToggleBit = toggleBitCb;      
}    
else {
offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->length, ""IO Data"");
}
if (io_data_object->discardIOXS == FALSE) {
offset = dissect_PNIO_IOxS(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_iops, ioxs_fields);
proto_item_set_len(IODataObject_item, io_data_object->length + 1);        
}
else {
proto_item_set_len(IODataObject_item, io_data_object->length);            
}
proto_item_append_text(IODataObject_item, "": Slot: 0x%x Subslot: 0x%x"",
io_data_object->slotNr, io_data_object->subSlotNr);
if (io_data_object->amountInGSDML > 1) {    
if (io_data_object->slotNr == 0) {
moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
}
else {
moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
}
if (io_data_object->profisafeSupported == TRUE) {
if (io_data_object->length >= 5) {        
wmem_strbuf_append(moduleName, "", DO"");
}
else {
wmem_strbuf_append(moduleName, "", DI"");
}
}
else {
if (io_data_object->length > 0) {
wmem_strbuf_append(moduleName, "", DO"");
}
else {
wmem_strbuf_append(moduleName, "", DI"");
}
}
io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(moduleName));
}
proto_item_append_text(IODataObject_item, "" ModuleName: \""%s\"""", io_data_object->moduleNameStr);
if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
proto_item_append_text(IODataObject_item, "" (PROFIsafe Module)"");
}
frameOffset = frameOffset + io_data_object->length; 
if (io_data_object->discardIOXS == FALSE) {
frameOffset = frameOffset + 1;      
}
}
}
}
if (station_info != NULL) {
for (frame = wmem_list_head(station_info->iocs_data_out); frame != NULL; frame = wmem_list_frame_next(frame)) {
iocs_object = (iocsObject*)wmem_list_frame_data(frame);
if (iocs_object->frameOffset == frameOffset) {
offset = dissect_PNIO_IOCS(tvb, offset, pinfo, data_tree, drep, hf_pn_io_iocs, iocs_object->slotNr,
iocs_object->subSlotNr, ioxs_fields);
frameOffset = frameOffset + 1;      
break;
}
}
}
}
offset = dissect_pn_user_data(tvb, offset, pinfo, tree, tvb_captured_length_remaining(tvb, offset), ""GAP and RTCPadding"");
}   
return offset;
}","int
dissect_PNIO_C_SDU_RTC1(tvbuff_t *VAR_0, int VAR_1,
packet_info *VAR_2, proto_tree *VAR_3, guint8 *VAR_4 _U_)
{
proto_tree  *VAR_5 = NULL;
guint16     VAR_6;
guint32     VAR_7;
gboolean    VAR_8;
gboolean    VAR_9;
gboolean    VAR_10;     
proto_item *VAR_11;
proto_item *VAR_12;
proto_tree *VAR_13;
proto_item *VAR_14;
proto_item *VAR_15;
wmem_strbuf_t *VAR_16;
guint8  VAR_17;
guint8  VAR_18;
guint64 VAR_19;
guint8  VAR_20;
guint8  VAR_21;
guint16 VAR_22;
guint16 VAR_23;
guint16 VAR_24;
guint16 VAR_25;
conversation_t    *VAR_26;
stationInfo       *VAR_27 = NULL;
iocsObject        *VAR_28;
ioDataObject      *VAR_29;
moduleDiffInfo    *VAR_30;
wmem_list_frame_t *VAR_31;
wmem_list_frame_t *VAR_32;
VAR_6 = 0;
VAR_19 = 0;
VAR_8 = FALSE;
VAR_9 = FALSE;
VAR_10 = FALSE;
VAR_22 = 0;
VAR_23 = 0;
VAR_24 = 0;
VAR_25 = 0;
col_set_str(VAR_2->cinfo, VAR_33, ""PNIO"");            
if (VAR_3) {
proto_item *VAR_34;
VAR_34 = proto_tree_add_protocol_format(VAR_3, VAR_35, VAR_0, VAR_1, tvb_captured_length(VAR_0),
""PROFINET IO Cyclic Service Data Unit: %u bytes"", tvb_captured_length(VAR_0));
VAR_5 = proto_item_add_subtree(VAR_34, VAR_36);
}
if (!(dissect_CSF_SDU_heur(VAR_0, VAR_2, VAR_5, NULL) == FALSE))
return(tvb_captured_length(VAR_0));
VAR_26 = find_conversation(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_37, 0, 0, 0);
if (VAR_26 != NULL) {
VAR_27 = (stationInfo*)conversation_get_proto_data(VAR_26, VAR_38);
if (VAR_27 != NULL) {
if (VAR_39 == TRUE) {
col_set_str(VAR_2->cinfo, VAR_33, ""PNIO_PS"");    
}
if (addresses_equal(&(VAR_2->src), &(VAR_26->key_ptr->addr1)) && addresses_equal(&(VAR_2->dst), &(VAR_26->key_ptr->addr2))) {
VAR_8 = TRUE;
VAR_9 = FALSE;
VAR_22 = VAR_27->ioDataObjectNr;
VAR_23 = VAR_27->iocsNr;
}
if (addresses_equal(&(VAR_2->dst), &(VAR_26->key_ptr->addr1)) && addresses_equal(&(VAR_2->src), &(VAR_26->key_ptr->addr2))) {
VAR_9 = TRUE;
VAR_8 = FALSE;
VAR_24 = VAR_27->ioDataObjectNr;
VAR_25 = VAR_27->iocsNr;
}
}
}
if (VAR_8) {
if (VAR_39 == TRUE) {
proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
VAR_1, 0, ""Response"", ""Response Frame (IO_Device -> IO_Controller)"");
}
else {
proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
VAR_1, 0, ""Input"", ""Input Frame (IO_Device -> IO_Controller)"");
}
if (VAR_27 != NULL) {
if (VAR_27->typeofstation != NULL) {
proto_tree_add_string_format_value(VAR_5, VAR_41, VAR_0, 0,
0, VAR_27->typeofstation, ""\""%s\"""", VAR_27->typeofstation);
}
if (VAR_27->nameofstation != NULL) {
proto_tree_add_string_format_value(VAR_5, VAR_42, VAR_0, 0,
0, VAR_27->nameofstation, ""\""%s\"""", VAR_27->nameofstation);
}
if (VAR_27->gsdPathLength == TRUE) {      
if (VAR_27->gsdFound == TRUE) {       
if (VAR_27->gsdLocation != NULL) {
VAR_12 = proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_1, 0, VAR_44);
proto_item_append_text(VAR_12, "": \""%s\"""", VAR_27->gsdLocation);
}
}
else {
if (VAR_27->gsdLocation != NULL) {
VAR_12 = proto_tree_add_item(VAR_5, VAR_45, VAR_0, VAR_1, 0, VAR_44);
proto_item_append_text(VAR_12, "" Please place relevant GSD-file under \""%s\"""", VAR_27->gsdLocation);
}
}
}
else {
VAR_12 = proto_tree_add_item(VAR_5, VAR_46, VAR_0, VAR_1, 0, VAR_44);
proto_item_append_text(VAR_12, "" Please check your GSD-file networkpath. (No Path configured)"");
}
}
VAR_7 = VAR_22 + VAR_23;
while (VAR_7--) {
if (VAR_27 != NULL) {
for (VAR_31 = wmem_list_head(VAR_27->ioobject_data_in); VAR_31 != NULL; VAR_31 = wmem_list_frame_next(VAR_31)) {
VAR_29 = (ioDataObject*)wmem_list_frame_data(VAR_31);
if (VAR_29->frameOffset == VAR_6) {
VAR_11 = proto_tree_add_item(VAR_5, VAR_47, VAR_0, VAR_1, 0, VAR_44);
VAR_13 = proto_item_add_subtree(VAR_11, VAR_48);
for (VAR_32 = wmem_list_head(VAR_27->diff_module); VAR_32 != NULL; VAR_32 = wmem_list_frame_next(VAR_32)) {
VAR_30 = (moduleDiffInfo*)wmem_list_frame_data(VAR_32);
if (VAR_29->moduleIdentNr != VAR_30->modulID) {
VAR_15 = proto_tree_add_item(VAR_13, VAR_49, VAR_0, 0, 0, VAR_44);
proto_item_append_text(VAR_15, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", VAR_30->modulID, VAR_29->moduleIdentNr);
break;
}
}
proto_tree_add_uint(VAR_13, VAR_50, VAR_0, 0, 0, VAR_29->moduleIdentNr);
proto_tree_add_uint(VAR_13, VAR_51, VAR_0, 0, 0, VAR_29->subModuleIdentNr);
if (VAR_29->profisafeSupported == TRUE && VAR_39 == TRUE) {
if (VAR_29->profisafeSupported == TRUE && VAR_10 == FALSE) {
col_append_str(VAR_2->cinfo, VAR_52, "", PROFIsafe Device"");    
VAR_10 = TRUE;
}
proto_tree_add_uint(VAR_13, VAR_53, VAR_0, 0, 0, VAR_29->f_dest_adr);
if ((VAR_29->length - VAR_54) > 0) {
VAR_1 = dissect_pn_io_ps_uint(VAR_0, VAR_1, VAR_2, VAR_13, VAR_4, VAR_55,
(VAR_29->length - VAR_54), &VAR_19);
}
VAR_20 = tvb_get_guint8(VAR_0, VAR_1);
VAR_17 = VAR_20 & 0x20;     
if (VAR_29->lastToggleBit != VAR_17) {    
VAR_14 = proto_tree_add_uint_format_value(VAR_13, VAR_56, VAR_0, VAR_1, 0,
VAR_17, ""%u"", VAR_17);
PROTO_ITEM_SET_HIDDEN(VAR_14);
VAR_14 = proto_tree_add_uint_format_value(VAR_13, VAR_57, VAR_0, VAR_1, 0,
VAR_29->slotNr, ""%u"", VAR_29->slotNr);
PROTO_ITEM_SET_HIDDEN(VAR_14);
VAR_14 = proto_tree_add_uint_format_value(VAR_13, VAR_58, VAR_0, VAR_1, 0,
VAR_29->subSlotNr, ""%u"", VAR_29->subSlotNr);
PROTO_ITEM_SET_HIDDEN(VAR_14);
}
VAR_1 = dissect_pn_io_ps_SB(VAR_0, VAR_1, VAR_2, VAR_13, VAR_4, VAR_59, VAR_60);
VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_13, VAR_29->f_crc_len, ""CRC"");
VAR_29->last_sb_cb = VAR_20;       
VAR_29->lastToggleBit = VAR_17;   
}    
else {
VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_13, VAR_29->length, ""IO Data"");
}
if (VAR_29->discardIOXS == FALSE) {
VAR_1 = dissect_PNIO_IOxS(VAR_0, VAR_1, VAR_2, VAR_13, VAR_4, VAR_61, VAR_62);
proto_item_set_len(VAR_11, VAR_29->length + 1);     
}
else {
proto_item_set_len(VAR_11, VAR_29->length);         
}
proto_item_append_text(VAR_11, "": Slot: 0x%x Subslot: 0x%x"",
VAR_29->slotNr, VAR_29->subSlotNr);
if (VAR_29->amountInGSDML > 1) {    
if (VAR_29->slotNr == 0) {
VAR_16 = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
}
else {
VAR_16 = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
}
if (VAR_29->profisafeSupported == TRUE) {
if (VAR_29->length >= 5) {        
wmem_strbuf_append(VAR_16, "", DI"");
}
else {
wmem_strbuf_append(VAR_16, "", DO"");
}
}
else {
if (VAR_29->length > 0) {
wmem_strbuf_append(VAR_16, "", DI"");
}
else {
wmem_strbuf_append(VAR_16, "", DO"");
}
}
VAR_29->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(VAR_16));
}
proto_item_append_text(VAR_11, "" ModuleName: \""%s\"""", VAR_29->moduleNameStr);
if (VAR_29->profisafeSupported == TRUE && VAR_39 == TRUE) {
(proto_item_append_text(VAR_11, "" (PROFIsafe Module)""));
}
VAR_6 = VAR_6 + VAR_29->length;  
if (VAR_29->discardIOXS == FALSE) {
VAR_6 = VAR_6 + 1;      
}
}
}
}
if (VAR_27 != NULL) {
for (VAR_31 = wmem_list_head(VAR_27->iocs_data_in); VAR_31 != NULL; VAR_31 = wmem_list_frame_next(VAR_31)) {
VAR_28 = (iocsObject*)wmem_list_frame_data(VAR_31);
if (VAR_28->frameOffset == VAR_6) {
VAR_1 = dissect_PNIO_IOCS(VAR_0, VAR_1, VAR_2, VAR_5, VAR_4, VAR_63, VAR_28->slotNr,
VAR_28->subSlotNr, VAR_62);
VAR_6 = VAR_6 + 1;      
break;
}
}
}
}
VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_3, tvb_captured_length_remaining(VAR_0, VAR_1), ""GAP and RTCPadding"");
}   
else if (VAR_9) {
if (VAR_39 == TRUE) {
proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
VAR_1, 0, ""Request"", ""Request Frame (IO_Controller -> IO_Device)"");
}
else {
proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
VAR_1, 0, ""Output"", ""Output Frame (IO_Controller -> IO_Device)"");
}
if (VAR_27 != NULL) {
if (VAR_27->typeofstation != NULL) {
proto_tree_add_string_format_value(VAR_5, VAR_41, VAR_0, 0,
0, VAR_27->typeofstation, ""\""%s\"""", VAR_27->typeofstation);
}
if (VAR_27->nameofstation != NULL) {
proto_tree_add_string_format_value(VAR_5, VAR_42, VAR_0, 0,
0, VAR_27->nameofstation, ""\""%s\"""", VAR_27->nameofstation);
}
if (VAR_27->gsdPathLength == TRUE) {      
if (VAR_27->gsdFound == TRUE) {       
if (VAR_27->gsdLocation != NULL) {
VAR_12 = proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_1, 0, VAR_44);
proto_item_append_text(VAR_12, "": \""%s\"""", VAR_27->gsdLocation);
}
}
else {
if (VAR_27->gsdLocation != NULL) {
VAR_12 = proto_tree_add_item(VAR_5, VAR_45, VAR_0, VAR_1, 0, VAR_44);
proto_item_append_text(VAR_12, "" Please place relevant GSD-file under \""%s\"""", VAR_27->gsdLocation);
}
}
}
else {
VAR_12 = proto_tree_add_item(VAR_5, VAR_46, VAR_0, VAR_1, 0, VAR_44);
proto_item_append_text(VAR_12, "" Please check your GSD-file networkpath. (No Path configured)"");
}
}
VAR_7 = VAR_24 + VAR_25;
while (VAR_7--) {
if (VAR_27 != NULL) {
for (VAR_31 = wmem_list_head(VAR_27->ioobject_data_out); VAR_31 != NULL; VAR_31 = wmem_list_frame_next(VAR_31)) {
VAR_29 = (ioDataObject*)wmem_list_frame_data(VAR_31);
if (VAR_29 != NULL && VAR_29->frameOffset == VAR_6) {
VAR_11 = proto_tree_add_item(VAR_5, VAR_47, VAR_0, VAR_1, 0, VAR_44);
VAR_13 = proto_item_add_subtree(VAR_11, VAR_48);
for (VAR_32 = wmem_list_head(VAR_27->diff_module); VAR_32 != NULL; VAR_32 = wmem_list_frame_next(VAR_32)) {
VAR_30 = (moduleDiffInfo*)wmem_list_frame_data(VAR_32);
if (VAR_29->moduleIdentNr != VAR_30->modulID) {
VAR_15 = proto_tree_add_item(VAR_13, VAR_49, VAR_0, 0, 0, VAR_44);
proto_item_append_text(VAR_15, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", VAR_30->modulID, VAR_29->moduleIdentNr);
break;
}
}
proto_tree_add_uint(VAR_13, VAR_50, VAR_0, 0, 0, VAR_29->moduleIdentNr);
proto_tree_add_uint(VAR_13, VAR_51, VAR_0, 0, 0, VAR_29->subModuleIdentNr);
if (VAR_29->profisafeSupported == TRUE && VAR_39 == TRUE) {
if (VAR_29->profisafeSupported == TRUE && VAR_10 == FALSE) {
col_append_str(VAR_2->cinfo, VAR_52, "", PROFIsafe Device"");    
VAR_10 = TRUE;
}
proto_tree_add_uint(VAR_13, VAR_53, VAR_0, 0, 0, VAR_29->f_dest_adr);
if ((VAR_29->length - VAR_54) > 0) {
VAR_1 = dissect_pn_io_ps_uint(VAR_0, VAR_1, VAR_2, VAR_13, VAR_4, VAR_55,
(VAR_29->length - VAR_54), &VAR_19);
}
VAR_21 = tvb_get_guint8(VAR_0, VAR_1);
VAR_18 = VAR_21 & 0x20;               
if (VAR_29->lastToggleBit != VAR_18) {   
VAR_14 = proto_tree_add_uint_format_value(VAR_13, VAR_64, VAR_0, VAR_1, 0,
VAR_18, ""%u"", VAR_18);
PROTO_ITEM_SET_HIDDEN(VAR_14);
VAR_14 = proto_tree_add_uint_format_value(VAR_13, VAR_65, VAR_0, VAR_1, 0,
VAR_29->slotNr, ""%u"", VAR_29->slotNr);
PROTO_ITEM_SET_HIDDEN(VAR_14);
VAR_14 = proto_tree_add_uint_format_value(VAR_13, VAR_66, VAR_0, VAR_1, 0,
VAR_29->subSlotNr, ""%u"", VAR_29->subSlotNr);
PROTO_ITEM_SET_HIDDEN(VAR_14);
}
VAR_1 = dissect_pn_io_ps_CB(VAR_0, VAR_1, VAR_2, VAR_13, VAR_4, VAR_67, VAR_68);
VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_13, VAR_29->f_crc_len, ""CRC"");
VAR_29->last_sb_cb = VAR_21;         
VAR_29->lastToggleBit = VAR_18;      
}    
else {
VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_13, VAR_29->length, ""IO Data"");
}
if (VAR_29->discardIOXS == FALSE) {
VAR_1 = dissect_PNIO_IOxS(VAR_0, VAR_1, VAR_2, VAR_13, VAR_4, VAR_61, VAR_62);
proto_item_set_len(VAR_11, VAR_29->length + 1);        
}
else {
proto_item_set_len(VAR_11, VAR_29->length);            
}
proto_item_append_text(VAR_11, "": Slot: 0x%x Subslot: 0x%x"",
VAR_29->slotNr, VAR_29->subSlotNr);
if (VAR_29->amountInGSDML > 1) {    
if (VAR_29->slotNr == 0) {
VAR_16 = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
}
else {
VAR_16 = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
}
if (VAR_29->profisafeSupported == TRUE) {
if (VAR_29->length >= 5) {        
wmem_strbuf_append(VAR_16, "", DO"");
}
else {
wmem_strbuf_append(VAR_16, "", DI"");
}
}
else {
if (VAR_29->length > 0) {
wmem_strbuf_append(VAR_16, "", DO"");
}
else {
wmem_strbuf_append(VAR_16, "", DI"");
}
}
VAR_29->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(VAR_16));
}
proto_item_append_text(VAR_11, "" ModuleName: \""%s\"""", VAR_29->moduleNameStr);
if (VAR_29->profisafeSupported == TRUE && VAR_39 == TRUE) {
proto_item_append_text(VAR_11, "" (PROFIsafe Module)"");
}
VAR_6 = VAR_6 + VAR_29->length; 
if (VAR_29->discardIOXS == FALSE) {
VAR_6 = VAR_6 + 1;      
}
}
}
}
if (VAR_27 != NULL) {
for (VAR_31 = wmem_list_head(VAR_27->iocs_data_out); VAR_31 != NULL; VAR_31 = wmem_list_frame_next(VAR_31)) {
VAR_28 = (iocsObject*)wmem_list_frame_data(VAR_31);
if (VAR_28->frameOffset == VAR_6) {
VAR_1 = dissect_PNIO_IOCS(VAR_0, VAR_1, VAR_2, VAR_5, VAR_4, VAR_63, VAR_28->slotNr,
VAR_28->subSlotNr, VAR_62);
VAR_6 = VAR_6 + 1;      
break;
}
}
}
}
VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_3, tvb_captured_length_remaining(VAR_0, VAR_1), ""GAP and RTCPadding"");
}   
return VAR_1;
}",,"int
dissect_PNIO_C_SDU_RTC1(tvbuff_t *tvb, int offset,
    packet_info *pinfo, proto_tree *tree, guint8 *drep _U_)
{
    proto_tree  *data_tree = NULL;

    /* Count & offset for comparation of the arrays */
    guint16     frameOffset;
    guint32     objectCounter;
    gboolean    inputFlag;
    gboolean    outputFlag;
    gboolean    psInfoText;     /* Used to display only once per frame the info text ""PROFIsafe Device"" */

    proto_item *data_item;
    proto_item *IODataObject_item;
    proto_item *IODataObject_item_info;
    proto_tree *IODataObject_tree;
    proto_item *ModuleID_item;
    proto_item *ModuleDiff_item;

    wmem_strbuf_t *moduleName;

    guint8  toggleBitSb;
    guint8  toggleBitCb;
    guint64 f_data;

    guint8  statusbyte;
    guint8  controlbyte;

    guint16 number_io_data_objects_input_cr;
    guint16 number_iocs_input_cr;
    guint16 number_io_data_objects_output_cr;
    guint16 number_iocs_output_cr;

    conversation_t    *conversation;
    stationInfo       *station_info = NULL;
    iocsObject        *iocs_object;
    ioDataObject      *io_data_object;
    moduleDiffInfo    *module_diff_info;
    wmem_list_frame_t *frame;
    wmem_list_frame_t *frame_diff;

    /* Initial */
    frameOffset = 0;
    f_data = 0;
    inputFlag = FALSE;
    outputFlag = FALSE;
    psInfoText = FALSE;
    number_io_data_objects_input_cr = 0;
    number_iocs_input_cr = 0;
    number_io_data_objects_output_cr = 0;
    number_iocs_output_cr = 0;

    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO"");            /* set protocol name */

    data_item = proto_tree_add_protocol_format(tree, proto_pn_io_rtc1, tvb, offset, tvb_captured_length(tvb),
            ""PROFINET IO Cyclic Service Data Unit: %u bytes"", tvb_captured_length(tvb));
    data_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc);

    /* dissect_dcerpc_uint16(tvb, offset, pinfo, data_tree, drep, hf_pn_io_packedframe_SFCRC, &u16SFCRC); */
    if (!(dissect_CSF_SDU_heur(tvb, pinfo, data_tree, NULL) == FALSE))
        return(tvb_captured_length(tvb));

    /* Only dissect cyclic RTC1 frames, if PN Connect Request has been read */
    conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);

    /* Detect input data package and output data package */
    if (conversation != NULL) {
        station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);
        if (station_info != NULL) {
            if (pnio_ps_selection == TRUE) {
                col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO_PS"");    /* set PROFISsafe protocol name */
            }

            if (addresses_equal(&(pinfo->src), &(conversation->key_ptr->addr1)) && addresses_equal(&(pinfo->dst), &(conversation->key_ptr->addr2))) {
                inputFlag = TRUE;
                outputFlag = FALSE;
                number_io_data_objects_input_cr = station_info->ioDataObjectNr;
                number_iocs_input_cr = station_info->iocsNr;
            }

            if (addresses_equal(&(pinfo->dst), &(conversation->key_ptr->addr1)) && addresses_equal(&(pinfo->src), &(conversation->key_ptr->addr2))) {
                outputFlag = TRUE;
                inputFlag = FALSE;
                number_io_data_objects_output_cr = station_info->ioDataObjectNr;
                number_iocs_output_cr = station_info->iocsNr;
            }
        }
    }

    /* ------- Input (PNIO) / Response (PNIO_PS) Frame Handling ------- */
    if (inputFlag) {
        if (pnio_ps_selection == TRUE) {
            proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
                offset, 0, ""Response"", ""Response Frame (IO_Device -> IO_Controller)"");
        }
        else {
            proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
                offset, 0, ""Input"", ""Input Frame (IO_Device -> IO_Controller)"");
        }

        if (station_info != NULL) {
            if (station_info->typeofstation != NULL) {
                proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_vendor, tvb, 0,
                    0, station_info->typeofstation, ""\""%s\"""", station_info->typeofstation);
            }
            if (station_info->nameofstation != NULL) {
                proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_nameofstation, tvb, 0,
                    0, station_info->nameofstation, ""\""%s\"""", station_info->nameofstation);
            }

            if (station_info->gsdPathLength == TRUE) {      /* given path isn't too long for the array */
                if (station_info->gsdFound == TRUE) {       /* found a GSD-file */
                    if (station_info->gsdLocation != NULL) {
                        IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_found, tvb, offset, 0, ENC_NA);
                        proto_item_append_text(IODataObject_item_info, "": \""%s\"""", station_info->gsdLocation);
                    }
                }
                else {
                    if (station_info->gsdLocation != NULL) {
                        IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_error, tvb, offset, 0, ENC_NA);
                        proto_item_append_text(IODataObject_item_info, "" Please place relevant GSD-file under \""%s\"""", station_info->gsdLocation);
                    }
                }
            }
            else {
                IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_path, tvb, offset, 0, ENC_NA);
                proto_item_append_text(IODataObject_item_info, "" Please check your GSD-file networkpath. (No Path configured)"");
            }
        }

        /* ---- Input IOData-/IOCS-Object Handling ---- */
        objectCounter = number_io_data_objects_input_cr + number_iocs_input_cr;
        if (objectCounter > (guint)tvb_reported_length_remaining(tvb, offset)) {
            expert_add_info_format(pinfo, data_item, &ei_pn_io_too_many_data_objects, ""Too many data objects: %d"", objectCounter);
            return(tvb_captured_length(tvb));
        }

        while (objectCounter--) {
            /* ---- Input IO Data Object Handling ---- */
            if (station_info != NULL) {
                for (frame = wmem_list_head(station_info->ioobject_data_in); frame != NULL; frame = wmem_list_frame_next(frame)) {
                    io_data_object = (ioDataObject*)wmem_list_frame_data(frame);
                    if (io_data_object->frameOffset == frameOffset) {
                        /* Found following object */

                        IODataObject_item = proto_tree_add_item(data_tree, hf_pn_io_io_data_object, tvb, offset, 0, ENC_NA);
                        IODataObject_tree = proto_item_add_subtree(IODataObject_item, ett_pn_io_io_data_object);

                        /* Control: the Device still uses the correct ModuleIdentNumber? */
                        for (frame_diff = wmem_list_head(station_info->diff_module); frame_diff != NULL; frame_diff = wmem_list_frame_next(frame_diff)) {
                            module_diff_info = (moduleDiffInfo*)wmem_list_frame_data(frame_diff);
                            if (io_data_object->moduleIdentNr != module_diff_info->modulID) {
                                ModuleDiff_item = proto_tree_add_item(IODataObject_tree, hf_pn_io_io_data_object_info_module_diff, tvb, 0, 0, ENC_NA);
                                proto_item_append_text(ModuleDiff_item, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", module_diff_info->modulID, io_data_object->moduleIdentNr);
                                break;
                            }
                        }

                        proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_moduleidentnumber, tvb, 0, 0, io_data_object->moduleIdentNr);
                        proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_submoduleidentnumber, tvb, 0, 0, io_data_object->subModuleIdentNr);

                        /* PROFIsafe Supported Inputmodule handling */
                        if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
                            if (io_data_object->profisafeSupported == TRUE && psInfoText == FALSE) {
                                /* Only add one information string per device to the infotext */
                                col_append_str(pinfo->cinfo, COL_INFO, "", PROFIsafe Device"");    /* Add string to wireshark infotext */
                                psInfoText = TRUE;
                            }

                            proto_tree_add_uint(IODataObject_tree, hf_pn_io_ps_f_dest_adr, tvb, 0, 0, io_data_object->f_dest_adr);

                            /* Get Safety IO Data */
                            if ((io_data_object->length - F_MESSAGE_TRAILER_4BYTE) > 0) {
                                offset = dissect_pn_io_ps_uint(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_f_data,
                                    (io_data_object->length - F_MESSAGE_TRAILER_4BYTE), &f_data);
                            }

                            /* ---- Check for new PNIO data using togglebit ---- */
                            statusbyte = tvb_get_guint8(tvb, offset);
                            toggleBitSb = statusbyte & 0x20;     /* get ToggleBit of StatusByte */

                            if (io_data_object->lastToggleBit != toggleBitSb) {    /* ToggleBit has changed --> new Data incoming */
                                /* Special Filter for ToggleBit within Statusbyte */
                                ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChanged, tvb, offset, 0,
                                    toggleBitSb, ""%u"", toggleBitSb);
                                PROTO_ITEM_SET_HIDDEN(ModuleID_item);

                                ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChange_slot_nr, tvb, offset, 0,
                                    io_data_object->slotNr, ""%u"", io_data_object->slotNr);
                                PROTO_ITEM_SET_HIDDEN(ModuleID_item);

                                ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_sb_toggelBitChange_subslot_nr, tvb, offset, 0,
                                    io_data_object->subSlotNr, ""%u"", io_data_object->subSlotNr);
                                PROTO_ITEM_SET_HIDDEN(ModuleID_item);
                            }

                            offset = dissect_pn_io_ps_SB(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_sb, ps_sb_fields);
                            offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->f_crc_len, ""CRC"");

                            io_data_object->last_sb_cb = statusbyte;       /* save the value of current statusbyte */
                            io_data_object->lastToggleBit = toggleBitSb;   /* save the value of current togglebit within statusbyte */
                        }    /* END of PROFIsafe Module Handling */

                        else {
                            /* Module is not PROFIsafe supported */
                            offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->length, ""IO Data"");
                        }

                        if (io_data_object->discardIOXS == FALSE) {
                            offset = dissect_PNIO_IOxS(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_iops, ioxs_fields);
                            proto_item_set_len(IODataObject_item, io_data_object->length + 1);     /* Length = Databytes + IOXS Byte */
                        }
                        else {
                            proto_item_set_len(IODataObject_item, io_data_object->length);         /* Length = Databytes */
                        }

                        proto_item_append_text(IODataObject_item, "": Slot: 0x%x Subslot: 0x%x"",
                            io_data_object->slotNr, io_data_object->subSlotNr);


                        /* ModuleIdentNr appears not only once in GSD-file -> set module name more generally */
                        if (io_data_object->amountInGSDML > 1) {    /* if ModuleIdentNr only appears once in GSD-file, use the found GSD-file-ModuleName, else ... */
                            if (io_data_object->slotNr == 0) {
                                moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
                            }
                            else {
                                moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
                            }

                            if (io_data_object->profisafeSupported == TRUE) {
                                /* PROFIsafe */
                                if (io_data_object->length >= 5) {        /* 5 due to 3 CRC bytes &  1 status byte & (at least) 1 data byte */
                                    wmem_strbuf_append(moduleName, "", DI"");
                                }
                                else {
                                    wmem_strbuf_append(moduleName, "", DO"");
                                }
                            }
                            else {
                                /* PROFINET */
                                if (io_data_object->length > 0) {
                                    wmem_strbuf_append(moduleName, "", DI"");
                                }
                                else {
                                    wmem_strbuf_append(moduleName, "", DO"");
                                }
                            }

                            io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(moduleName));
                        }

                        proto_item_append_text(IODataObject_item, "" ModuleName: \""%s\"""", io_data_object->moduleNameStr);

                        /* emphasize the PROFIsafe supported Modul */
                        if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
                            (proto_item_append_text(IODataObject_item, "" (PROFIsafe Module)""));
                        }


                        /* Set frameOffset to its new value, to find the next object */
                        frameOffset = frameOffset + io_data_object->length;  /* frameOffset = current value + data bytes */
                        if (io_data_object->discardIOXS == FALSE) {
                            frameOffset = frameOffset + 1;      /* frameOffset = current value + iops byte */
                        }
                    }
                }
            }

            /* ---- Input IOCS Object Handling ---- */
            if (station_info != NULL) {
                for (frame = wmem_list_head(station_info->iocs_data_in); frame != NULL; frame = wmem_list_frame_next(frame)) {
                    iocs_object = (iocsObject*)wmem_list_frame_data(frame);
                    if (iocs_object->frameOffset == frameOffset) {
                        offset = dissect_PNIO_IOCS(tvb, offset, pinfo, data_tree, drep, hf_pn_io_iocs, iocs_object->slotNr,
                            iocs_object->subSlotNr, ioxs_fields);

                        /* Set frameOffset to its new value, to find the next object */
                        frameOffset = frameOffset + 1;      /* frameOffset = current value + iops byte */

                        break;
                    }
                }
            }
        }

        /* Dissect padding */
        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, tvb_captured_length_remaining(tvb, offset), ""GAP and RTCPadding"");
    }   /* END of Input Frame Handling */

    /* ----- Output (PNIO) / Request (PNIO_PS) Frame Handling ------ */
    else if (outputFlag) {
        if (pnio_ps_selection == TRUE) {
            proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
                offset, 0, ""Request"", ""Request Frame (IO_Controller -> IO_Device)"");
        }
        else {
            proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_type, tvb,
                offset, 0, ""Output"", ""Output Frame (IO_Controller -> IO_Device)"");
        }

        if (station_info != NULL) {
            if (station_info->typeofstation != NULL) {
                proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_vendor, tvb, 0,
                    0, station_info->typeofstation, ""\""%s\"""", station_info->typeofstation);
            }
            if (station_info->nameofstation != NULL) {
                proto_tree_add_string_format_value(data_tree, hf_pn_io_frame_info_nameofstation, tvb, 0,
                    0, station_info->nameofstation, ""\""%s\"""", station_info->nameofstation);
            }

            if (station_info->gsdPathLength == TRUE) {      /* given path isn't too long for the array */
                if (station_info->gsdFound == TRUE) {       /* found a GSD-file */
                    if (station_info->gsdLocation != NULL) {
                        IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_found, tvb, offset, 0, ENC_NA);
                        proto_item_append_text(IODataObject_item_info, "": \""%s\"""", station_info->gsdLocation);
                    }
                }
                else {
                    if (station_info->gsdLocation != NULL) {
                        IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_error, tvb, offset, 0, ENC_NA);
                        proto_item_append_text(IODataObject_item_info, "" Please place relevant GSD-file under \""%s\"""", station_info->gsdLocation);
                    }
                }
            }
            else {
                IODataObject_item_info = proto_tree_add_item(data_tree, hf_pn_io_frame_info_gsd_path, tvb, offset, 0, ENC_NA);
                proto_item_append_text(IODataObject_item_info, "" Please check your GSD-file networkpath. (No Path configured)"");
            }
        }

        /* ---- Output IOData-/IOCS-Object Handling ---- */
        objectCounter = number_io_data_objects_output_cr + number_iocs_output_cr;
        if (objectCounter > (guint)tvb_reported_length_remaining(tvb, offset)) {
            expert_add_info_format(pinfo, data_item, &ei_pn_io_too_many_data_objects, ""Too many data objects: %d"", objectCounter);
            return(tvb_captured_length(tvb));
        }
        while (objectCounter--) {
            /* ---- Output IO Data Object Handling ---- */
            if (station_info != NULL) {
                for (frame = wmem_list_head(station_info->ioobject_data_out); frame != NULL; frame = wmem_list_frame_next(frame)) {
                    io_data_object = (ioDataObject*)wmem_list_frame_data(frame);
                    if (io_data_object != NULL && io_data_object->frameOffset == frameOffset) {
                        /* Found following object */

                        IODataObject_item = proto_tree_add_item(data_tree, hf_pn_io_io_data_object, tvb, offset, 0, ENC_NA);
                        IODataObject_tree = proto_item_add_subtree(IODataObject_item, ett_pn_io_io_data_object);

                        /* Control: the Device still uses the correct ModuleIdentNumber? */
                        for (frame_diff = wmem_list_head(station_info->diff_module); frame_diff != NULL; frame_diff = wmem_list_frame_next(frame_diff)) {
                            module_diff_info = (moduleDiffInfo*)wmem_list_frame_data(frame_diff);
                            if (io_data_object->moduleIdentNr != module_diff_info->modulID) {
                                ModuleDiff_item = proto_tree_add_item(IODataObject_tree, hf_pn_io_io_data_object_info_module_diff, tvb, 0, 0, ENC_NA);
                                proto_item_append_text(ModuleDiff_item, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", module_diff_info->modulID, io_data_object->moduleIdentNr);
                                break;
                            }
                        }

                        proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_moduleidentnumber, tvb, 0, 0, io_data_object->moduleIdentNr);
                        proto_tree_add_uint(IODataObject_tree, hf_pn_io_io_data_object_info_submoduleidentnumber, tvb, 0, 0, io_data_object->subModuleIdentNr);

                        if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
                            if (io_data_object->profisafeSupported == TRUE && psInfoText == FALSE) {
                                /* Only add one information string per device to the infotext */
                                col_append_str(pinfo->cinfo, COL_INFO, "", PROFIsafe Device"");    /* Add string to wireshark infotext */
                                psInfoText = TRUE;
                            }

                            proto_tree_add_uint(IODataObject_tree, hf_pn_io_ps_f_dest_adr, tvb, 0, 0, io_data_object->f_dest_adr);

                            /* Get Safety IO Data */
                            if ((io_data_object->length - F_MESSAGE_TRAILER_4BYTE) > 0) {
                                offset = dissect_pn_io_ps_uint(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_f_data,
                                    (io_data_object->length - F_MESSAGE_TRAILER_4BYTE), &f_data);
                            }

                            /* ---- Check for new PNIO data using togglebit ---- */
                            controlbyte = tvb_get_guint8(tvb, offset);
                            toggleBitCb = controlbyte & 0x20;               /* get ToggleBit of Controlbyte */

                            if (io_data_object->lastToggleBit != toggleBitCb) {   /* ToggleBit has changed --> new Data incoming */
                                /* Special Filter for ToggleBit within Controlbyte */
                                ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChanged, tvb, offset, 0,
                                    toggleBitCb, ""%u"", toggleBitCb);
                                PROTO_ITEM_SET_HIDDEN(ModuleID_item);

                                ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChange_slot_nr, tvb, offset, 0,
                                    io_data_object->slotNr, ""%u"", io_data_object->slotNr);
                                PROTO_ITEM_SET_HIDDEN(ModuleID_item);

                                ModuleID_item = proto_tree_add_uint_format_value(IODataObject_tree, hf_pn_io_ps_cb_toggelBitChange_subslot_nr, tvb, offset, 0,
                                    io_data_object->subSlotNr, ""%u"", io_data_object->subSlotNr);
                                PROTO_ITEM_SET_HIDDEN(ModuleID_item);
                            }

                            offset = dissect_pn_io_ps_CB(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_ps_cb, ps_cb_fields);
                            offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->f_crc_len, ""CRC"");

                            io_data_object->last_sb_cb = controlbyte;         /* save the value of current controlbyte */
                            io_data_object->lastToggleBit = toggleBitCb;      /* save the value of current togglebit within controlbyte */
                        }    /* End of PROFIsafe Module Handling */
                        else {
                            /* Module is not PROFIsafe supported */
                            offset = dissect_pn_user_data(tvb, offset, pinfo, IODataObject_tree, io_data_object->length, ""IO Data"");
                        }

                        if (io_data_object->discardIOXS == FALSE) {
                            offset = dissect_PNIO_IOxS(tvb, offset, pinfo, IODataObject_tree, drep, hf_pn_io_iops, ioxs_fields);
                            proto_item_set_len(IODataObject_item, io_data_object->length + 1);        /* Length = Databytes + IOXS Byte */
                        }
                        else {
                            proto_item_set_len(IODataObject_item, io_data_object->length);            /* Length = Databytes */
                        }

                        proto_item_append_text(IODataObject_item, "": Slot: 0x%x Subslot: 0x%x"",
                            io_data_object->slotNr, io_data_object->subSlotNr);


                        /* ModuleIdentNr appears not only once in GSD-file -> set module name more generally */
                        if (io_data_object->amountInGSDML > 1) {    /* if ModuleIdentNr only appears once in GSD-file, use the found GSD-file-ModuleName, else ... */
                            if (io_data_object->slotNr == 0) {
                                moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
                            }
                            else {
                                moduleName = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
                            }

                            if (io_data_object->profisafeSupported == TRUE) {
                                /* PROFIsafe */
                                if (io_data_object->length >= 5) {        /* 5 due to 3 CRC bytes &  1 status byte & (at least) 1 data byte */
                                    wmem_strbuf_append(moduleName, "", DO"");
                                }
                                else {
                                    wmem_strbuf_append(moduleName, "", DI"");
                                }
                            }
                            else {
                                /* PROFINET */
                                if (io_data_object->length > 0) {
                                    wmem_strbuf_append(moduleName, "", DO"");
                                }
                                else {
                                    wmem_strbuf_append(moduleName, "", DI"");
                                }
                            }

                            io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(moduleName));
                        }

                        proto_item_append_text(IODataObject_item, "" ModuleName: \""%s\"""", io_data_object->moduleNameStr);

                        /* emphasize the PROFIsafe supported Modul */
                        if (io_data_object->profisafeSupported == TRUE && pnio_ps_selection == TRUE) {
                            proto_item_append_text(IODataObject_item, "" (PROFIsafe Module)"");
                        }

                        /* Set frameOffset to its new value, to find the next object */
                        frameOffset = frameOffset + io_data_object->length; /* frameOffset = current value + data bytes */
                        if (io_data_object->discardIOXS == FALSE) {
                            frameOffset = frameOffset + 1;      /* frameOffset = current value + iops byte */
                        }
                    }
                }
            }

            /* ---- Output IOCS Object Handling ---- */
            if (station_info != NULL) {
                for (frame = wmem_list_head(station_info->iocs_data_out); frame != NULL; frame = wmem_list_frame_next(frame)) {
                    iocs_object = (iocsObject*)wmem_list_frame_data(frame);
                    if (iocs_object->frameOffset == frameOffset) {
                        offset = dissect_PNIO_IOCS(tvb, offset, pinfo, data_tree, drep, hf_pn_io_iocs, iocs_object->slotNr,
                            iocs_object->subSlotNr, ioxs_fields);

                        /* Set frameOffset to its new value, to find the next object */
                        frameOffset = frameOffset + 1;      /* frameOffset = current value + iops byte */

                        break;
                    }
                }
            }
        }

        /* Dissect padding */
        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, tvb_captured_length_remaining(tvb, offset), ""GAP and RTCPadding"");
    }   /* END of Output Frame Handling */

    return offset;
}","int
dissect_PNIO_C_SDU_RTC1(tvbuff_t *VAR_0, int VAR_1,
    packet_info *VAR_2, proto_tree *VAR_3, guint8 *VAR_4 _U_)
{
    proto_tree  *VAR_5 = NULL;

    /* COMMENT_0 */
    guint16     VAR_6;
    guint32     VAR_7;
    gboolean    VAR_8;
    gboolean    VAR_9;
    gboolean    VAR_10;     /* COMMENT_1 */

    proto_item *VAR_11;
    proto_item *VAR_12;
    proto_item *VAR_13;
    proto_tree *VAR_14;
    proto_item *VAR_15;
    proto_item *VAR_16;

    wmem_strbuf_t *VAR_17;

    guint8  VAR_18;
    guint8  VAR_19;
    guint64 VAR_20;

    guint8  VAR_21;
    guint8  VAR_22;

    guint16 VAR_23;
    guint16 VAR_24;
    guint16 VAR_25;
    guint16 VAR_26;

    conversation_t    *VAR_27;
    stationInfo       *VAR_28 = NULL;
    iocsObject        *VAR_29;
    ioDataObject      *VAR_30;
    moduleDiffInfo    *VAR_31;
    wmem_list_frame_t *VAR_32;
    wmem_list_frame_t *VAR_33;

    /* COMMENT_2 */
    VAR_6 = 0;
    VAR_20 = 0;
    VAR_8 = FALSE;
    VAR_9 = FALSE;
    VAR_10 = FALSE;
    VAR_23 = 0;
    VAR_24 = 0;
    VAR_25 = 0;
    VAR_26 = 0;

    col_set_str(VAR_2->cinfo, VAR_34, ""PNIO"");            /* COMMENT_3 */

    VAR_11 = proto_tree_add_protocol_format(VAR_3, VAR_35, VAR_0, VAR_1, tvb_captured_length(VAR_0),
            ""PROFINET IO Cyclic Service Data Unit: %u bytes"", tvb_captured_length(VAR_0));
    VAR_5 = proto_item_add_subtree(VAR_11, VAR_36);

    /* COMMENT_4 */
    if (!(dissect_CSF_SDU_heur(VAR_0, VAR_2, VAR_5, NULL) == FALSE))
        return(tvb_captured_length(VAR_0));

    /* COMMENT_5 */
    VAR_27 = find_conversation(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_37, 0, 0, 0);

    /* COMMENT_6 */
    if (VAR_27 != NULL) {
        VAR_28 = (stationInfo*)conversation_get_proto_data(VAR_27, VAR_38);
        if (VAR_28 != NULL) {
            if (VAR_39 == TRUE) {
                col_set_str(VAR_2->cinfo, VAR_34, ""PNIO_PS"");    /* COMMENT_7 */
            }

            if (addresses_equal(&(VAR_2->src), &(VAR_27->key_ptr->addr1)) && addresses_equal(&(VAR_2->dst), &(VAR_27->key_ptr->addr2))) {
                VAR_8 = TRUE;
                VAR_9 = FALSE;
                VAR_23 = VAR_28->ioDataObjectNr;
                VAR_24 = VAR_28->iocsNr;
            }

            if (addresses_equal(&(VAR_2->dst), &(VAR_27->key_ptr->addr1)) && addresses_equal(&(VAR_2->src), &(VAR_27->key_ptr->addr2))) {
                VAR_9 = TRUE;
                VAR_8 = FALSE;
                VAR_25 = VAR_28->ioDataObjectNr;
                VAR_26 = VAR_28->iocsNr;
            }
        }
    }

    /* COMMENT_8 */
    if (VAR_8) {
        if (VAR_39 == TRUE) {
            proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
                VAR_1, 0, ""Response"", ""Response Frame (IO_Device -> IO_Controller)"");
        }
        else {
            proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
                VAR_1, 0, ""Input"", ""Input Frame (IO_Device -> IO_Controller)"");
        }

        if (VAR_28 != NULL) {
            if (VAR_28->typeofstation != NULL) {
                proto_tree_add_string_format_value(VAR_5, VAR_41, VAR_0, 0,
                    0, VAR_28->typeofstation, ""\""%s\"""", VAR_28->typeofstation);
            }
            if (VAR_28->nameofstation != NULL) {
                proto_tree_add_string_format_value(VAR_5, VAR_42, VAR_0, 0,
                    0, VAR_28->nameofstation, ""\""%s\"""", VAR_28->nameofstation);
            }

            if (VAR_28->gsdPathLength == TRUE) {      /* COMMENT_9 */
                if (VAR_28->gsdFound == TRUE) {       /* COMMENT_10 */
                    if (VAR_28->gsdLocation != NULL) {
                        VAR_13 = proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_1, 0, VAR_44);
                        proto_item_append_text(VAR_13, "": \""%s\"""", VAR_28->gsdLocation);
                    }
                }
                else {
                    if (VAR_28->gsdLocation != NULL) {
                        VAR_13 = proto_tree_add_item(VAR_5, VAR_45, VAR_0, VAR_1, 0, VAR_44);
                        proto_item_append_text(VAR_13, "" Please place relevant GSD-file under \""%s\"""", VAR_28->gsdLocation);
                    }
                }
            }
            else {
                VAR_13 = proto_tree_add_item(VAR_5, VAR_46, VAR_0, VAR_1, 0, VAR_44);
                proto_item_append_text(VAR_13, "" Please check your GSD-file networkpath. (No Path configured)"");
            }
        }

        /* COMMENT_11 */
        VAR_7 = VAR_23 + VAR_24;
        if (VAR_7 > (guint)tvb_reported_length_remaining(VAR_0, VAR_1)) {
            expert_add_info_format(VAR_2, VAR_11, &VAR_47, ""Too many data objects: %d"", VAR_7);
            return(tvb_captured_length(VAR_0));
        }

        while (VAR_7--) {
            /* COMMENT_12 */
            if (VAR_28 != NULL) {
                for (VAR_32 = wmem_list_head(VAR_28->ioobject_data_in); VAR_32 != NULL; VAR_32 = wmem_list_frame_next(VAR_32)) {
                    VAR_30 = (ioDataObject*)wmem_list_frame_data(VAR_32);
                    if (VAR_30->frameOffset == VAR_6) {
                        /* COMMENT_13 */

                        VAR_12 = proto_tree_add_item(VAR_5, VAR_48, VAR_0, VAR_1, 0, VAR_44);
                        VAR_14 = proto_item_add_subtree(VAR_12, VAR_49);

                        /* COMMENT_14 */
                        for (VAR_33 = wmem_list_head(VAR_28->diff_module); VAR_33 != NULL; VAR_33 = wmem_list_frame_next(VAR_33)) {
                            VAR_31 = (moduleDiffInfo*)wmem_list_frame_data(VAR_33);
                            if (VAR_30->moduleIdentNr != VAR_31->modulID) {
                                VAR_16 = proto_tree_add_item(VAR_14, VAR_50, VAR_0, 0, 0, VAR_44);
                                proto_item_append_text(VAR_16, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", VAR_31->modulID, VAR_30->moduleIdentNr);
                                break;
                            }
                        }

                        proto_tree_add_uint(VAR_14, VAR_51, VAR_0, 0, 0, VAR_30->moduleIdentNr);
                        proto_tree_add_uint(VAR_14, VAR_52, VAR_0, 0, 0, VAR_30->subModuleIdentNr);

                        /* COMMENT_15 */
                        if (VAR_30->profisafeSupported == TRUE && VAR_39 == TRUE) {
                            if (VAR_30->profisafeSupported == TRUE && VAR_10 == FALSE) {
                                /* COMMENT_16 */
                                col_append_str(VAR_2->cinfo, VAR_53, "", PROFIsafe Device"");    /* COMMENT_17 */
                                VAR_10 = TRUE;
                            }

                            proto_tree_add_uint(VAR_14, VAR_54, VAR_0, 0, 0, VAR_30->f_dest_adr);

                            /* COMMENT_18 */
                            if ((VAR_30->length - VAR_55) > 0) {
                                VAR_1 = dissect_pn_io_ps_uint(VAR_0, VAR_1, VAR_2, VAR_14, VAR_4, VAR_56,
                                    (VAR_30->length - VAR_55), &VAR_20);
                            }

                            /* COMMENT_19 */
                            VAR_21 = tvb_get_guint8(VAR_0, VAR_1);
                            VAR_18 = VAR_21 & 0x20;     /* COMMENT_20 */

                            if (VAR_30->lastToggleBit != VAR_18) {    /* COMMENT_21 */
                                /* COMMENT_22 */
                                VAR_15 = proto_tree_add_uint_format_value(VAR_14, VAR_57, VAR_0, VAR_1, 0,
                                    VAR_18, ""%u"", VAR_18);
                                PROTO_ITEM_SET_HIDDEN(VAR_15);

                                VAR_15 = proto_tree_add_uint_format_value(VAR_14, VAR_58, VAR_0, VAR_1, 0,
                                    VAR_30->slotNr, ""%u"", VAR_30->slotNr);
                                PROTO_ITEM_SET_HIDDEN(VAR_15);

                                VAR_15 = proto_tree_add_uint_format_value(VAR_14, VAR_59, VAR_0, VAR_1, 0,
                                    VAR_30->subSlotNr, ""%u"", VAR_30->subSlotNr);
                                PROTO_ITEM_SET_HIDDEN(VAR_15);
                            }

                            VAR_1 = dissect_pn_io_ps_SB(VAR_0, VAR_1, VAR_2, VAR_14, VAR_4, VAR_60, VAR_61);
                            VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_14, VAR_30->f_crc_len, ""CRC"");

                            VAR_30->last_sb_cb = VAR_21;       /* COMMENT_23 */
                            VAR_30->lastToggleBit = VAR_18;   /* COMMENT_24 */
                        }    /* COMMENT_25 */

                        else {
                            /* COMMENT_26 */
                            VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_14, VAR_30->length, ""IO Data"");
                        }

                        if (VAR_30->discardIOXS == FALSE) {
                            VAR_1 = dissect_PNIO_IOxS(VAR_0, VAR_1, VAR_2, VAR_14, VAR_4, VAR_62, VAR_63);
                            proto_item_set_len(VAR_12, VAR_30->length + 1);     /* COMMENT_27 */
                        }
                        else {
                            proto_item_set_len(VAR_12, VAR_30->length);         /* COMMENT_28 */
                        }

                        proto_item_append_text(VAR_12, "": Slot: 0x%x Subslot: 0x%x"",
                            VAR_30->slotNr, VAR_30->subSlotNr);


                        /* COMMENT_29 */
                        if (VAR_30->amountInGSDML > 1) {    /* COMMENT_30 */
                            if (VAR_30->slotNr == 0) {
                                VAR_17 = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
                            }
                            else {
                                VAR_17 = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
                            }

                            if (VAR_30->profisafeSupported == TRUE) {
                                /* COMMENT_31 */
                                if (VAR_30->length >= 5) {        /* COMMENT_32 */
                                    wmem_strbuf_append(VAR_17, "", DI"");
                                }
                                else {
                                    wmem_strbuf_append(VAR_17, "", DO"");
                                }
                            }
                            else {
                                /* COMMENT_33 */
                                if (VAR_30->length > 0) {
                                    wmem_strbuf_append(VAR_17, "", DI"");
                                }
                                else {
                                    wmem_strbuf_append(VAR_17, "", DO"");
                                }
                            }

                            VAR_30->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(VAR_17));
                        }

                        proto_item_append_text(VAR_12, "" ModuleName: \""%s\"""", VAR_30->moduleNameStr);

                        /* COMMENT_34 */
                        if (VAR_30->profisafeSupported == TRUE && VAR_39 == TRUE) {
                            (proto_item_append_text(VAR_12, "" (PROFIsafe Module)""));
                        }


                        /* COMMENT_35 */
                        VAR_6 = VAR_6 + VAR_30->length;  /* COMMENT_36 */
                        if (VAR_30->discardIOXS == FALSE) {
                            VAR_6 = VAR_6 + 1;      /* COMMENT_37 */
                        }
                    }
                }
            }

            /* COMMENT_38 */
            if (VAR_28 != NULL) {
                for (VAR_32 = wmem_list_head(VAR_28->iocs_data_in); VAR_32 != NULL; VAR_32 = wmem_list_frame_next(VAR_32)) {
                    VAR_29 = (iocsObject*)wmem_list_frame_data(VAR_32);
                    if (VAR_29->frameOffset == VAR_6) {
                        VAR_1 = dissect_PNIO_IOCS(VAR_0, VAR_1, VAR_2, VAR_5, VAR_4, VAR_64, VAR_29->slotNr,
                            VAR_29->subSlotNr, VAR_63);

                        /* COMMENT_35 */
                        VAR_6 = VAR_6 + 1;      /* COMMENT_37 */

                        break;
                    }
                }
            }
        }

        /* COMMENT_39 */
        VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_3, tvb_captured_length_remaining(VAR_0, VAR_1), ""GAP and RTCPadding"");
    }   /* COMMENT_40 */

    /* COMMENT_41 */
    else if (VAR_9) {
        if (VAR_39 == TRUE) {
            proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
                VAR_1, 0, ""Request"", ""Request Frame (IO_Controller -> IO_Device)"");
        }
        else {
            proto_tree_add_string_format_value(VAR_5, VAR_40, VAR_0,
                VAR_1, 0, ""Output"", ""Output Frame (IO_Controller -> IO_Device)"");
        }

        if (VAR_28 != NULL) {
            if (VAR_28->typeofstation != NULL) {
                proto_tree_add_string_format_value(VAR_5, VAR_41, VAR_0, 0,
                    0, VAR_28->typeofstation, ""\""%s\"""", VAR_28->typeofstation);
            }
            if (VAR_28->nameofstation != NULL) {
                proto_tree_add_string_format_value(VAR_5, VAR_42, VAR_0, 0,
                    0, VAR_28->nameofstation, ""\""%s\"""", VAR_28->nameofstation);
            }

            if (VAR_28->gsdPathLength == TRUE) {      /* COMMENT_9 */
                if (VAR_28->gsdFound == TRUE) {       /* COMMENT_10 */
                    if (VAR_28->gsdLocation != NULL) {
                        VAR_13 = proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_1, 0, VAR_44);
                        proto_item_append_text(VAR_13, "": \""%s\"""", VAR_28->gsdLocation);
                    }
                }
                else {
                    if (VAR_28->gsdLocation != NULL) {
                        VAR_13 = proto_tree_add_item(VAR_5, VAR_45, VAR_0, VAR_1, 0, VAR_44);
                        proto_item_append_text(VAR_13, "" Please place relevant GSD-file under \""%s\"""", VAR_28->gsdLocation);
                    }
                }
            }
            else {
                VAR_13 = proto_tree_add_item(VAR_5, VAR_46, VAR_0, VAR_1, 0, VAR_44);
                proto_item_append_text(VAR_13, "" Please check your GSD-file networkpath. (No Path configured)"");
            }
        }

        /* COMMENT_42 */
        VAR_7 = VAR_25 + VAR_26;
        if (VAR_7 > (guint)tvb_reported_length_remaining(VAR_0, VAR_1)) {
            expert_add_info_format(VAR_2, VAR_11, &VAR_47, ""Too many data objects: %d"", VAR_7);
            return(tvb_captured_length(VAR_0));
        }
        while (VAR_7--) {
            /* COMMENT_43 */
            if (VAR_28 != NULL) {
                for (VAR_32 = wmem_list_head(VAR_28->ioobject_data_out); VAR_32 != NULL; VAR_32 = wmem_list_frame_next(VAR_32)) {
                    VAR_30 = (ioDataObject*)wmem_list_frame_data(VAR_32);
                    if (VAR_30 != NULL && VAR_30->frameOffset == VAR_6) {
                        /* COMMENT_13 */

                        VAR_12 = proto_tree_add_item(VAR_5, VAR_48, VAR_0, VAR_1, 0, VAR_44);
                        VAR_14 = proto_item_add_subtree(VAR_12, VAR_49);

                        /* COMMENT_14 */
                        for (VAR_33 = wmem_list_head(VAR_28->diff_module); VAR_33 != NULL; VAR_33 = wmem_list_frame_next(VAR_33)) {
                            VAR_31 = (moduleDiffInfo*)wmem_list_frame_data(VAR_33);
                            if (VAR_30->moduleIdentNr != VAR_31->modulID) {
                                VAR_16 = proto_tree_add_item(VAR_14, VAR_50, VAR_0, 0, 0, VAR_44);
                                proto_item_append_text(VAR_16, "": Device using ModuleIdentNumber 0x%08x instead of 0x%08x"", VAR_31->modulID, VAR_30->moduleIdentNr);
                                break;
                            }
                        }

                        proto_tree_add_uint(VAR_14, VAR_51, VAR_0, 0, 0, VAR_30->moduleIdentNr);
                        proto_tree_add_uint(VAR_14, VAR_52, VAR_0, 0, 0, VAR_30->subModuleIdentNr);

                        if (VAR_30->profisafeSupported == TRUE && VAR_39 == TRUE) {
                            if (VAR_30->profisafeSupported == TRUE && VAR_10 == FALSE) {
                                /* COMMENT_16 */
                                col_append_str(VAR_2->cinfo, VAR_53, "", PROFIsafe Device"");    /* COMMENT_17 */
                                VAR_10 = TRUE;
                            }

                            proto_tree_add_uint(VAR_14, VAR_54, VAR_0, 0, 0, VAR_30->f_dest_adr);

                            /* COMMENT_18 */
                            if ((VAR_30->length - VAR_55) > 0) {
                                VAR_1 = dissect_pn_io_ps_uint(VAR_0, VAR_1, VAR_2, VAR_14, VAR_4, VAR_56,
                                    (VAR_30->length - VAR_55), &VAR_20);
                            }

                            /* COMMENT_19 */
                            VAR_22 = tvb_get_guint8(VAR_0, VAR_1);
                            VAR_19 = VAR_22 & 0x20;               /* COMMENT_44 */

                            if (VAR_30->lastToggleBit != VAR_19) {   /* COMMENT_21 */
                                /* COMMENT_45 */
                                VAR_15 = proto_tree_add_uint_format_value(VAR_14, VAR_65, VAR_0, VAR_1, 0,
                                    VAR_19, ""%u"", VAR_19);
                                PROTO_ITEM_SET_HIDDEN(VAR_15);

                                VAR_15 = proto_tree_add_uint_format_value(VAR_14, VAR_66, VAR_0, VAR_1, 0,
                                    VAR_30->slotNr, ""%u"", VAR_30->slotNr);
                                PROTO_ITEM_SET_HIDDEN(VAR_15);

                                VAR_15 = proto_tree_add_uint_format_value(VAR_14, VAR_67, VAR_0, VAR_1, 0,
                                    VAR_30->subSlotNr, ""%u"", VAR_30->subSlotNr);
                                PROTO_ITEM_SET_HIDDEN(VAR_15);
                            }

                            VAR_1 = dissect_pn_io_ps_CB(VAR_0, VAR_1, VAR_2, VAR_14, VAR_4, VAR_68, VAR_69);
                            VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_14, VAR_30->f_crc_len, ""CRC"");

                            VAR_30->last_sb_cb = VAR_22;         /* COMMENT_46 */
                            VAR_30->lastToggleBit = VAR_19;      /* COMMENT_47 */
                        }    /* COMMENT_48 */
                        else {
                            /* COMMENT_26 */
                            VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_14, VAR_30->length, ""IO Data"");
                        }

                        if (VAR_30->discardIOXS == FALSE) {
                            VAR_1 = dissect_PNIO_IOxS(VAR_0, VAR_1, VAR_2, VAR_14, VAR_4, VAR_62, VAR_63);
                            proto_item_set_len(VAR_12, VAR_30->length + 1);        /* COMMENT_27 */
                        }
                        else {
                            proto_item_set_len(VAR_12, VAR_30->length);            /* COMMENT_28 */
                        }

                        proto_item_append_text(VAR_12, "": Slot: 0x%x Subslot: 0x%x"",
                            VAR_30->slotNr, VAR_30->subSlotNr);


                        /* COMMENT_29 */
                        if (VAR_30->amountInGSDML > 1) {    /* COMMENT_30 */
                            if (VAR_30->slotNr == 0) {
                                VAR_17 = wmem_strbuf_new(wmem_packet_scope(), ""Headstation"");
                            }
                            else {
                                VAR_17 = wmem_strbuf_new(wmem_packet_scope(), ""Module"");
                            }

                            if (VAR_30->profisafeSupported == TRUE) {
                                /* COMMENT_31 */
                                if (VAR_30->length >= 5) {        /* COMMENT_32 */
                                    wmem_strbuf_append(VAR_17, "", DO"");
                                }
                                else {
                                    wmem_strbuf_append(VAR_17, "", DI"");
                                }
                            }
                            else {
                                /* COMMENT_33 */
                                if (VAR_30->length > 0) {
                                    wmem_strbuf_append(VAR_17, "", DO"");
                                }
                                else {
                                    wmem_strbuf_append(VAR_17, "", DI"");
                                }
                            }

                            VAR_30->moduleNameStr = wmem_strdup(wmem_file_scope(), wmem_strbuf_get_str(VAR_17));
                        }

                        proto_item_append_text(VAR_12, "" ModuleName: \""%s\"""", VAR_30->moduleNameStr);

                        /* COMMENT_34 */
                        if (VAR_30->profisafeSupported == TRUE && VAR_39 == TRUE) {
                            proto_item_append_text(VAR_12, "" (PROFIsafe Module)"");
                        }

                        /* COMMENT_35 */
                        VAR_6 = VAR_6 + VAR_30->length; /* COMMENT_36 */
                        if (VAR_30->discardIOXS == FALSE) {
                            VAR_6 = VAR_6 + 1;      /* COMMENT_37 */
                        }
                    }
                }
            }

            /* COMMENT_49 */
            if (VAR_28 != NULL) {
                for (VAR_32 = wmem_list_head(VAR_28->iocs_data_out); VAR_32 != NULL; VAR_32 = wmem_list_frame_next(VAR_32)) {
                    VAR_29 = (iocsObject*)wmem_list_frame_data(VAR_32);
                    if (VAR_29->frameOffset == VAR_6) {
                        VAR_1 = dissect_PNIO_IOCS(VAR_0, VAR_1, VAR_2, VAR_5, VAR_4, VAR_64, VAR_29->slotNr,
                            VAR_29->subSlotNr, VAR_63);

                        /* COMMENT_35 */
                        VAR_6 = VAR_6 + 1;      /* COMMENT_37 */

                        break;
                    }
                }
            }
        }

        /* COMMENT_39 */
        VAR_1 = dissect_pn_user_data(VAR_0, VAR_1, VAR_2, VAR_3, tvb_captured_length_remaining(VAR_0, VAR_1), ""GAP and RTCPadding"");
    }   /* COMMENT_50 */

    return VAR_1;
}",,"--- func_before
+++ func_after
@@ -11,6 +11,7 @@
     gboolean    outputFlag;
     gboolean    psInfoText;     /* Used to display only once per frame the info text ""PROFIsafe Device"" */
 
+    proto_item *data_item;
     proto_item *IODataObject_item;
     proto_item *IODataObject_item_info;
     proto_tree *IODataObject_tree;
@@ -52,12 +53,9 @@
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO"");            /* set protocol name */
 
-    if (tree) {
-        proto_item *data_item;
-        data_item = proto_tree_add_protocol_format(tree, proto_pn_io_rtc1, tvb, offset, tvb_captured_length(tvb),
+    data_item = proto_tree_add_protocol_format(tree, proto_pn_io_rtc1, tvb, offset, tvb_captured_length(tvb),
             ""PROFINET IO Cyclic Service Data Unit: %u bytes"", tvb_captured_length(tvb));
-        data_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc);
-    }
+    data_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc);
 
     /* dissect_dcerpc_uint16(tvb, offset, pinfo, data_tree, drep, hf_pn_io_packedframe_SFCRC, &u16SFCRC); */
     if (!(dissect_CSF_SDU_heur(tvb, pinfo, data_tree, NULL) == FALSE))
@@ -133,6 +131,11 @@
 
         /* ---- Input IOData-/IOCS-Object Handling ---- */
         objectCounter = number_io_data_objects_input_cr + number_iocs_input_cr;
+        if (objectCounter > (guint)tvb_reported_length_remaining(tvb, offset)) {
+            expert_add_info_format(pinfo, data_item, &ei_pn_io_too_many_data_objects, ""Too many data objects: %d"", objectCounter);
+            return(tvb_captured_length(tvb));
+        }
+
         while (objectCounter--) {
             /* ---- Input IO Data Object Handling ---- */
             if (station_info != NULL) {
@@ -328,6 +331,10 @@
 
         /* ---- Output IOData-/IOCS-Object Handling ---- */
         objectCounter = number_io_data_objects_output_cr + number_iocs_output_cr;
+        if (objectCounter > (guint)tvb_reported_length_remaining(tvb, offset)) {
+            expert_add_info_format(pinfo, data_item, &ei_pn_io_too_many_data_objects, ""Too many data objects: %d"", objectCounter);
+            return(tvb_captured_length(tvb));
+        }
         while (objectCounter--) {
             /* ---- Output IO Data Object Handling ---- */
             if (station_info != NULL) {","{'deleted_lines': ['    if (tree) {', '        proto_item *data_item;', '        data_item = proto_tree_add_protocol_format(tree, proto_pn_io_rtc1, tvb, offset, tvb_captured_length(tvb),', '        data_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc);', '    }'], 'added_lines': ['    proto_item *data_item;', '    data_item = proto_tree_add_protocol_format(tree, proto_pn_io_rtc1, tvb, offset, tvb_captured_length(tvb),', '    data_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc);', '        if (objectCounter > (guint)tvb_reported_length_remaining(tvb, offset)) {', '            expert_add_info_format(pinfo, data_item, &ei_pn_io_too_many_data_objects, ""Too many data objects: %d"", objectCounter);', '            return(tvb_captured_length(tvb));', '        }', '', '        if (objectCounter > (guint)tvb_reported_length_remaining(tvb, offset)) {', '            expert_add_info_format(pinfo, data_item, &ei_pn_io_too_many_data_objects, ""Too many data objects: %d"", objectCounter);', '            return(tvb_captured_length(tvb));', '        }']}",True,"In Wireshark 2.2.0 to 2.2.1, the Profinet I/O dissector could loop excessively, triggered by network traffic or a capture file. This was addressed in plugins/profinet/packet-pn-rtc-one.c by rejecting input with too many I/O objects.",5.9,MEDIUM,1,valid,2016-10-10T02:54:03Z,1
CVE-2016-9372,"['CWE-20', 'CWE-399']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"Profinet I/O: Sanity check number of I/O objects

Can prevent really long loops from fuzz testing.

Bug: 12851
Change-Id: I85e00af2c4753ce4c5bcb650a7df188d7f679c9a
Reviewed-on: https://code.wireshark.org/review/18136
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit e8022a9c7b36b96578a30fc8132def6de8928606)
Reviewed-on: https://code.wireshark.org/review/18137",4127e3930ef663114567002001f44e01eba8a250,https://github.com/wireshark/wireshark/commit/4127e3930ef663114567002001f44e01eba8a250,plugins/profinet/packet-pn-rtc-one.c,init_pn_io_rtc1,"void
init_pn_io_rtc1(int proto)
{
static hf_register_info hf[] = {
{ &hf_pn_io_io_data_object,
{ ""IODataObject"", ""pn_io.io_data_object"",
FT_NONE, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_io_data_object_info_module_diff,
{ ""Difference"", ""pn_io.io_data_object.diff_module"",
FT_NONE, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_io_data_object_info_moduleidentnumber,
{ ""ModuleIdentNumber"", ""pn_io.io_data_object.module_nr"",
FT_UINT32, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_io_data_object_info_submoduleidentnumber,
{ ""SubmoduleIdentNumber"", ""pn_io.io_data_object.submodule_nr"",
FT_UINT32, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_frame_info_type,
{ ""PN Frame Type"", ""pn_io.frame_info.type"",
FT_STRING, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_frame_info_vendor,
{ ""DeviceVendorValue"", ""pn_io.frame_info.vendor"",
FT_STRING, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_frame_info_nameofstation,
{ ""NameOfStation"", ""pn_io.frame_info.nameofstation"",
FT_STRING, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_frame_info_gsd_found,
{ ""GSD-file found"", ""pn_io.frame_info.gsd_found"",
FT_NONE, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_frame_info_gsd_error,
{ ""GSD-file not found."", ""pn_io.frame_info.gsd_error"",
FT_NONE, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_frame_info_gsd_path,
{ ""GSD-file networkpath failure!"", ""pn_io.frame_info.gsd_path"",
FT_NONE, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_iocs,
{ ""IOCS"", ""pn_io.ioxs"",
FT_UINT8, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_iops,
{ ""IOPS"", ""pn_io.ioxs"",
FT_UINT8, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ioxs_extension,
{ ""Extension"", ""pn_io.ioxs.extension"",
FT_UINT8, BASE_HEX, VALS(pn_io_ioxs_extension), 0x01,
NULL, HFILL }
},
{ &hf_pn_io_ioxs_res14,
{ ""Reserved"", ""pn_io.ioxs.res14"",
FT_UINT8, BASE_HEX, NULL, 0x1E,
NULL, HFILL }
},
{ &hf_pn_io_ioxs_instance,
{ ""Instance"", ""pn_io.ioxs.instance"",
FT_UINT8, BASE_HEX, VALS(pn_io_ioxs_instance), 0x60,
NULL, HFILL }
},
{ &hf_pn_io_ioxs_datastate,
{ ""DataState"", ""pn_io.ioxs.datastate"",
FT_UINT8, BASE_HEX, VALS(pn_io_ioxs_datastate), 0x80,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb,
{ ""Status Byte"", ""pn_io.ps.sb"",
FT_UINT8, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_toggelBitChanged,
{ ""Status Byte"", ""pn_io.ps.sb.toggle_d_changed"",
FT_UINT8, BASE_HEX, NULL, 0x00,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_toggelBitChange_slot_nr,
{ ""Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.slot"",
FT_UINT16, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_toggelBitChange_subslot_nr,
{ ""Sub_Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.subslot"",
FT_UINT16, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb,
{ ""Control Byte"", ""pn_io.ps.cb"",
FT_UINT8, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_toggelBitChanged,
{ ""Control Byte"", ""pn_io.ps.cb.toggle_h_changed"",
FT_UINT8, BASE_HEX, NULL, 0x00,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_toggelBitChange_slot_nr,
{ ""Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.slot"",
FT_UINT16, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_toggelBitChange_subslot_nr,
{ ""Sub_Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.subslot"",
FT_UINT16, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_iparOK,
{ ""iPar_OK - F-Device has new iParameter values assigned"", ""pn_io.ps.sb.iPar_OK"",
FT_UINT8, BASE_HEX, NULL, 0x01,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_DeviceFault,
{ ""Device_Fault - Failure exists in F-Device or F-Module"", ""pn_io.ps.sb.DeviceFault"",
FT_UINT8, BASE_HEX, NULL, 0x02,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_CECRC,
{ ""CE_CRC - CRC Communication fault"", ""pn_io.ps.sb.CE_CRC"",
FT_UINT8, BASE_HEX, NULL, 0x04,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_WDtimeout,
{ ""WD_timeout - WatchDog timeout Communication fault"", ""pn_io.ps.sb.WD_timeout"",
FT_UINT8, BASE_HEX, NULL, 0x08,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_FVactivated,
{ ""FV_activated - Fail-safe values (FV) activated"", ""pn_io.ps.sb.FV_activated"",
FT_UINT8, BASE_HEX, NULL, 0x10,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_Toggle_d,
{ ""Toggle_d - Device-based Toggle Bit"", ""pn_io.ps.sb.Toggle_d"",
FT_UINT8, BASE_HEX, NULL, 0x20,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_ConsNr_reset,
{ ""cons_nr_R - F-Device has reset its consecutive number counter"", ""pn_io.ps.sb.cons_nr_R"",
FT_UINT8, BASE_HEX, NULL, 0x40,
NULL, HFILL }
},
{ &hf_pn_io_ps_sb_res,
{ ""Bit7 - reserved for future releases"", ""pn_io.ps.sb.bit7"",
FT_UINT8, BASE_HEX, NULL, 0x80,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_iparEN,
{ ""iPar_EN - iParameter assignment deblocked"", ""pn_io.ps.cb.iparEN"",
FT_UINT8, BASE_HEX, NULL, 0x01,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_OAReq,
{ ""OA_Req - Operator acknowledge requested"", ""pn_io.ps.cb.OA_Req"",
FT_UINT8, BASE_HEX, NULL, 0x02,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_resetConsNr,
{ ""R_cons_nr - Set the Virtual Consecutive Number within the F-Device to be \""0\"""", ""pn_io.ps.cb.R_cons_nr"",
FT_UINT8, BASE_HEX, NULL, 0x04,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_useTO2,
{ ""Bit3 - Reserved or Use the secondary watchdog (Use_TO2)"", ""pn_io.ps.cb.bit3"",
FT_UINT8, BASE_HEX, NULL, 0x08,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_activateFV,
{ ""activate_FV - Fail-safe values (FV) to be activated"", ""pn_io.ps.cb.activate_FV"",
FT_UINT8, BASE_HEX, NULL, 0x10,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_Toggle_h,
{ ""Toggle_h - Host-based Toggle Bit"", ""pn_io.ps.cb.Toggle_h"",
FT_UINT8, BASE_HEX, NULL, 0x20,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_Chf_ACK,
{ ""Bit6 - Reserved or Operator acknowledge after cleared channel fault (ChF_Ack)"", ""pn_io.ps.cb.bit6"",
FT_UINT8, BASE_HEX, NULL, 0x40,
NULL, HFILL }
},
{ &hf_pn_io_ps_cb_loopcheck,
{ ""Bit7 - Reserved or Loop-back check (Loopcheck, shall be set to 1)"", ""pn_io.ps.cb.bit7"",
FT_UINT8, BASE_HEX, NULL, 0x80,
NULL, HFILL }
},
{ &hf_pn_io_ps_f_dest_adr,
{ ""F_Dest_Add"", ""pn_io.ps.f_dest_add"",
FT_UINT16, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_pn_io_ps_f_data,
{ ""SafetyIO Data"", ""pn_io.ps.f_data"",
FT_UINT64, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
};
static gint *ett[] = {
&ett_pn_io_rtc,
&ett_pn_io_ioxs,
&ett_pn_io_io_data_object
};
proto_pn_io_rtc1 = proto;
proto_register_field_array(proto, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
}","void
init_pn_io_rtc1(int VAR_0)
{
static hf_register_info VAR_1[] = {
{ &VAR_2,
{ ""IODataObject"", ""pn_io.io_data_object"",
VAR_3, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_6,
{ ""Difference"", ""pn_io.io_data_object.diff_module"",
VAR_3, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_7,
{ ""ModuleIdentNumber"", ""pn_io.io_data_object.module_nr"",
VAR_8, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_10,
{ ""SubmoduleIdentNumber"", ""pn_io.io_data_object.submodule_nr"",
VAR_8, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_11,
{ ""PN Frame Type"", ""pn_io.frame_info.type"",
VAR_12, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_13,
{ ""DeviceVendorValue"", ""pn_io.frame_info.vendor"",
VAR_12, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_14,
{ ""NameOfStation"", ""pn_io.frame_info.nameofstation"",
VAR_12, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_15,
{ ""GSD-file found"", ""pn_io.frame_info.gsd_found"",
VAR_3, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_16,
{ ""GSD-file not found."", ""pn_io.frame_info.gsd_error"",
VAR_3, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_17,
{ ""GSD-file networkpath failure!"", ""pn_io.frame_info.gsd_path"",
VAR_3, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_18,
{ ""IOCS"", ""pn_io.ioxs"",
VAR_19, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_20,
{ ""IOPS"", ""pn_io.ioxs"",
VAR_19, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_21,
{ ""Extension"", ""pn_io.ioxs.extension"",
VAR_19, VAR_9, VALS(VAR_22), 0x01,
NULL, VAR_5 }
},
{ &VAR_23,
{ ""Reserved"", ""pn_io.ioxs.res14"",
VAR_19, VAR_9, NULL, 0x1E,
NULL, VAR_5 }
},
{ &VAR_24,
{ ""Instance"", ""pn_io.ioxs.instance"",
VAR_19, VAR_9, VALS(VAR_25), 0x60,
NULL, VAR_5 }
},
{ &VAR_26,
{ ""DataState"", ""pn_io.ioxs.datastate"",
VAR_19, VAR_9, VALS(VAR_27), 0x80,
NULL, VAR_5 }
},
{ &VAR_28,
{ ""Status Byte"", ""pn_io.ps.sb"",
VAR_19, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_29,
{ ""Status Byte"", ""pn_io.ps.sb.toggle_d_changed"",
VAR_19, VAR_9, NULL, 0x00,
NULL, VAR_5 }
},
{ &VAR_30,
{ ""Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.slot"",
VAR_31, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_32,
{ ""Sub_Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.subslot"",
VAR_31, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_33,
{ ""Control Byte"", ""pn_io.ps.cb"",
VAR_19, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_34,
{ ""Control Byte"", ""pn_io.ps.cb.toggle_h_changed"",
VAR_19, VAR_9, NULL, 0x00,
NULL, VAR_5 }
},
{ &VAR_35,
{ ""Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.slot"",
VAR_31, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_36,
{ ""Sub_Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.subslot"",
VAR_31, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_37,
{ ""iPar_OK - F-Device has new iParameter values assigned"", ""pn_io.ps.sb.iPar_OK"",
VAR_19, VAR_9, NULL, 0x01,
NULL, VAR_5 }
},
{ &VAR_38,
{ ""Device_Fault - Failure exists in F-Device or F-Module"", ""pn_io.ps.sb.DeviceFault"",
VAR_19, VAR_9, NULL, 0x02,
NULL, VAR_5 }
},
{ &VAR_39,
{ ""CE_CRC - CRC Communication fault"", ""pn_io.ps.sb.CE_CRC"",
VAR_19, VAR_9, NULL, 0x04,
NULL, VAR_5 }
},
{ &VAR_40,
{ ""WD_timeout - WatchDog timeout Communication fault"", ""pn_io.ps.sb.WD_timeout"",
VAR_19, VAR_9, NULL, 0x08,
NULL, VAR_5 }
},
{ &VAR_41,
{ ""FV_activated - Fail-safe values (FV) activated"", ""pn_io.ps.sb.FV_activated"",
VAR_19, VAR_9, NULL, 0x10,
NULL, VAR_5 }
},
{ &VAR_42,
{ ""Toggle_d - Device-based Toggle Bit"", ""pn_io.ps.sb.Toggle_d"",
VAR_19, VAR_9, NULL, 0x20,
NULL, VAR_5 }
},
{ &VAR_43,
{ ""cons_nr_R - F-Device has reset its consecutive number counter"", ""pn_io.ps.sb.cons_nr_R"",
VAR_19, VAR_9, NULL, 0x40,
NULL, VAR_5 }
},
{ &VAR_44,
{ ""Bit7 - reserved for future releases"", ""pn_io.ps.sb.bit7"",
VAR_19, VAR_9, NULL, 0x80,
NULL, VAR_5 }
},
{ &VAR_45,
{ ""iPar_EN - iParameter assignment deblocked"", ""pn_io.ps.cb.iparEN"",
VAR_19, VAR_9, NULL, 0x01,
NULL, VAR_5 }
},
{ &VAR_46,
{ ""OA_Req - Operator acknowledge requested"", ""pn_io.ps.cb.OA_Req"",
VAR_19, VAR_9, NULL, 0x02,
NULL, VAR_5 }
},
{ &VAR_47,
{ ""R_cons_nr - Set the Virtual Consecutive Number within the F-Device to be \""0\"""", ""pn_io.ps.cb.R_cons_nr"",
VAR_19, VAR_9, NULL, 0x04,
NULL, VAR_5 }
},
{ &VAR_48,
{ ""Bit3 - Reserved or Use the secondary watchdog (Use_TO2)"", ""pn_io.ps.cb.bit3"",
VAR_19, VAR_9, NULL, 0x08,
NULL, VAR_5 }
},
{ &VAR_49,
{ ""activate_FV - Fail-safe values (FV) to be activated"", ""pn_io.ps.cb.activate_FV"",
VAR_19, VAR_9, NULL, 0x10,
NULL, VAR_5 }
},
{ &VAR_50,
{ ""Toggle_h - Host-based Toggle Bit"", ""pn_io.ps.cb.Toggle_h"",
VAR_19, VAR_9, NULL, 0x20,
NULL, VAR_5 }
},
{ &VAR_51,
{ ""Bit6 - Reserved or Operator acknowledge after cleared channel fault (ChF_Ack)"", ""pn_io.ps.cb.bit6"",
VAR_19, VAR_9, NULL, 0x40,
NULL, VAR_5 }
},
{ &VAR_52,
{ ""Bit7 - Reserved or Loop-back check (Loopcheck, shall be set to 1)"", ""pn_io.ps.cb.bit7"",
VAR_19, VAR_9, NULL, 0x80,
NULL, VAR_5 }
},
{ &VAR_53,
{ ""F_Dest_Add"", ""pn_io.ps.f_dest_add"",
VAR_31, VAR_54, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_55,
{ ""SafetyIO Data"", ""pn_io.ps.f_data"",
VAR_56, VAR_9, NULL, 0x0,
NULL, VAR_5 }
},
};
static gint *VAR_57[] = {
&VAR_58,
&VAR_59,
&VAR_60
};
VAR_61 = VAR_0;
proto_register_field_array(VAR_0, VAR_1, array_length(VAR_1));
proto_register_subtree_array(VAR_57, array_length(VAR_57));
}",wireshark/4127e3930ef663114567002001f44e01eba8a250/packet-pn-rtc-one.c/vul/before/0.json,"void
init_pn_io_rtc1(int proto)
{
    static hf_register_info hf[] = {
        { &hf_pn_io_io_data_object,
            { ""IODataObject"", ""pn_io.io_data_object"",
            FT_NONE, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_io_data_object_info_module_diff,
            { ""Difference"", ""pn_io.io_data_object.diff_module"",
            FT_NONE, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_io_data_object_info_moduleidentnumber,
            { ""ModuleIdentNumber"", ""pn_io.io_data_object.module_nr"",
            FT_UINT32, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_io_data_object_info_submoduleidentnumber,
            { ""SubmoduleIdentNumber"", ""pn_io.io_data_object.submodule_nr"",
            FT_UINT32, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_frame_info_type,
            { ""PN Frame Type"", ""pn_io.frame_info.type"",
            FT_STRING, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_frame_info_vendor,
            { ""DeviceVendorValue"", ""pn_io.frame_info.vendor"",
            FT_STRING, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_frame_info_nameofstation,
            { ""NameOfStation"", ""pn_io.frame_info.nameofstation"",
            FT_STRING, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_frame_info_gsd_found,
            { ""GSD-file found"", ""pn_io.frame_info.gsd_found"",
            FT_NONE, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_frame_info_gsd_error,
            { ""GSD-file not found."", ""pn_io.frame_info.gsd_error"",
            FT_NONE, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_frame_info_gsd_path,
            { ""GSD-file networkpath failure!"", ""pn_io.frame_info.gsd_path"",
            FT_NONE, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_iocs,
            { ""IOCS"", ""pn_io.ioxs"",
            FT_UINT8, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_iops,
            { ""IOPS"", ""pn_io.ioxs"",
            FT_UINT8, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_ioxs_extension,
            { ""Extension"", ""pn_io.ioxs.extension"",
            FT_UINT8, BASE_HEX, VALS(pn_io_ioxs_extension), 0x01,
            NULL, HFILL }
        },
        { &hf_pn_io_ioxs_res14,
            { ""Reserved"", ""pn_io.ioxs.res14"",
            FT_UINT8, BASE_HEX, NULL, 0x1E,
            NULL, HFILL }
        },
        { &hf_pn_io_ioxs_instance,
            { ""Instance"", ""pn_io.ioxs.instance"",
            FT_UINT8, BASE_HEX, VALS(pn_io_ioxs_instance), 0x60,
            NULL, HFILL }
        },
        { &hf_pn_io_ioxs_datastate,
            { ""DataState"", ""pn_io.ioxs.datastate"",
            FT_UINT8, BASE_HEX, VALS(pn_io_ioxs_datastate), 0x80,
            NULL, HFILL }
        },
        /* PROFIsafe parameter */
        /* Status Byte & Control Byte for PROFIsafe --- dissector handle */
        { &hf_pn_io_ps_sb,
            { ""Status Byte"", ""pn_io.ps.sb"",
            FT_UINT8, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_toggelBitChanged,
            { ""Status Byte"", ""pn_io.ps.sb.toggle_d_changed"",
            FT_UINT8, BASE_HEX, NULL, 0x00,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_toggelBitChange_slot_nr,
            { ""Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.slot"",
            FT_UINT16, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_toggelBitChange_subslot_nr,
            { ""Sub_Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.subslot"",
            FT_UINT16, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb,
            { ""Control Byte"", ""pn_io.ps.cb"",
            FT_UINT8, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_toggelBitChanged,
            { ""Control Byte"", ""pn_io.ps.cb.toggle_h_changed"",
            FT_UINT8, BASE_HEX, NULL, 0x00,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_toggelBitChange_slot_nr,
            { ""Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.slot"",
            FT_UINT16, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_toggelBitChange_subslot_nr,
            { ""Sub_Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.subslot"",
            FT_UINT16, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        /* Structures for dissecting Status Byte & Control Byte PROFIsafe ---dissector details */
        { &hf_pn_io_ps_sb_iparOK,
            { ""iPar_OK - F-Device has new iParameter values assigned"", ""pn_io.ps.sb.iPar_OK"",
            FT_UINT8, BASE_HEX, NULL, 0x01,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_DeviceFault,
            { ""Device_Fault - Failure exists in F-Device or F-Module"", ""pn_io.ps.sb.DeviceFault"",
            FT_UINT8, BASE_HEX, NULL, 0x02,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_CECRC,
            { ""CE_CRC - CRC Communication fault"", ""pn_io.ps.sb.CE_CRC"",
            FT_UINT8, BASE_HEX, NULL, 0x04,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_WDtimeout,
            { ""WD_timeout - WatchDog timeout Communication fault"", ""pn_io.ps.sb.WD_timeout"",
            FT_UINT8, BASE_HEX, NULL, 0x08,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_FVactivated,
            { ""FV_activated - Fail-safe values (FV) activated"", ""pn_io.ps.sb.FV_activated"",
            FT_UINT8, BASE_HEX, NULL, 0x10,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_Toggle_d,
            { ""Toggle_d - Device-based Toggle Bit"", ""pn_io.ps.sb.Toggle_d"",
            FT_UINT8, BASE_HEX, NULL, 0x20,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_ConsNr_reset,
            { ""cons_nr_R - F-Device has reset its consecutive number counter"", ""pn_io.ps.sb.cons_nr_R"",
            FT_UINT8, BASE_HEX, NULL, 0x40,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_sb_res,
            { ""Bit7 - reserved for future releases"", ""pn_io.ps.sb.bit7"",
            FT_UINT8, BASE_HEX, NULL, 0x80,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_iparEN,
            { ""iPar_EN - iParameter assignment deblocked"", ""pn_io.ps.cb.iparEN"",
            FT_UINT8, BASE_HEX, NULL, 0x01,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_OAReq,
            { ""OA_Req - Operator acknowledge requested"", ""pn_io.ps.cb.OA_Req"",
            FT_UINT8, BASE_HEX, NULL, 0x02,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_resetConsNr,
            { ""R_cons_nr - Set the Virtual Consecutive Number within the F-Device to be \""0\"""", ""pn_io.ps.cb.R_cons_nr"",
            FT_UINT8, BASE_HEX, NULL, 0x04,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_useTO2,
            { ""Bit3 - Reserved or Use the secondary watchdog (Use_TO2)"", ""pn_io.ps.cb.bit3"",
            FT_UINT8, BASE_HEX, NULL, 0x08,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_activateFV,
            { ""activate_FV - Fail-safe values (FV) to be activated"", ""pn_io.ps.cb.activate_FV"",
            FT_UINT8, BASE_HEX, NULL, 0x10,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_Toggle_h,
            { ""Toggle_h - Host-based Toggle Bit"", ""pn_io.ps.cb.Toggle_h"",
            FT_UINT8, BASE_HEX, NULL, 0x20,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_Chf_ACK,
            { ""Bit6 - Reserved or Operator acknowledge after cleared channel fault (ChF_Ack)"", ""pn_io.ps.cb.bit6"",
            FT_UINT8, BASE_HEX, NULL, 0x40,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_cb_loopcheck,
            { ""Bit7 - Reserved or Loop-back check (Loopcheck, shall be set to 1)"", ""pn_io.ps.cb.bit7"",
            FT_UINT8, BASE_HEX, NULL, 0x80,
            NULL, HFILL }
        },
        /* PROFIsafe */
        { &hf_pn_io_ps_f_dest_adr,
            { ""F_Dest_Add"", ""pn_io.ps.f_dest_add"",
            FT_UINT16, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_pn_io_ps_f_data,
            { ""SafetyIO Data"", ""pn_io.ps.f_data"",
            FT_UINT64, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
    };

    static gint *ett[] = {
        &ett_pn_io_rtc,
        &ett_pn_io_ioxs,
        &ett_pn_io_io_data_object
    };

    static ei_register_info ei[] = {
        { &ei_pn_io_too_many_data_objects, { ""pn_io.too_many_data_objects"", PI_MALFORMED, PI_ERROR, ""Too many data objects"", EXPFILL }},
    };

    expert_module_t* expert_pn_io;

    proto_pn_io_rtc1 = proto;
    proto_register_field_array(proto, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));
    expert_pn_io = expert_register_protocol(proto_pn_io_rtc1);
    expert_register_field_array(expert_pn_io, ei, array_length(ei));
}","void
init_pn_io_rtc1(int VAR_0)
{
    static hf_register_info VAR_1[] = {
        { &VAR_2,
            { ""IODataObject"", ""pn_io.io_data_object"",
            VAR_3, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_6,
            { ""Difference"", ""pn_io.io_data_object.diff_module"",
            VAR_3, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_7,
            { ""ModuleIdentNumber"", ""pn_io.io_data_object.module_nr"",
            VAR_8, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_10,
            { ""SubmoduleIdentNumber"", ""pn_io.io_data_object.submodule_nr"",
            VAR_8, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_11,
            { ""PN Frame Type"", ""pn_io.frame_info.type"",
            VAR_12, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_13,
            { ""DeviceVendorValue"", ""pn_io.frame_info.vendor"",
            VAR_12, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_14,
            { ""NameOfStation"", ""pn_io.frame_info.nameofstation"",
            VAR_12, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_15,
            { ""GSD-file found"", ""pn_io.frame_info.gsd_found"",
            VAR_3, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_16,
            { ""GSD-file not found."", ""pn_io.frame_info.gsd_error"",
            VAR_3, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_17,
            { ""GSD-file networkpath failure!"", ""pn_io.frame_info.gsd_path"",
            VAR_3, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_18,
            { ""IOCS"", ""pn_io.ioxs"",
            VAR_19, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_20,
            { ""IOPS"", ""pn_io.ioxs"",
            VAR_19, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_21,
            { ""Extension"", ""pn_io.ioxs.extension"",
            VAR_19, VAR_9, VALS(VAR_22), 0x01,
            NULL, VAR_5 }
        },
        { &VAR_23,
            { ""Reserved"", ""pn_io.ioxs.res14"",
            VAR_19, VAR_9, NULL, 0x1E,
            NULL, VAR_5 }
        },
        { &VAR_24,
            { ""Instance"", ""pn_io.ioxs.instance"",
            VAR_19, VAR_9, VALS(VAR_25), 0x60,
            NULL, VAR_5 }
        },
        { &VAR_26,
            { ""DataState"", ""pn_io.ioxs.datastate"",
            VAR_19, VAR_9, VALS(VAR_27), 0x80,
            NULL, VAR_5 }
        },
        /* COMMENT_0 */
        /* COMMENT_1 */
        { &VAR_28,
            { ""Status Byte"", ""pn_io.ps.sb"",
            VAR_19, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_29,
            { ""Status Byte"", ""pn_io.ps.sb.toggle_d_changed"",
            VAR_19, VAR_9, NULL, 0x00,
            NULL, VAR_5 }
        },
        { &VAR_30,
            { ""Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.slot"",
            VAR_31, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_32,
            { ""Sub_Slot_Number"", ""pn_io.ps.sb.toggle_d_changed.subslot"",
            VAR_31, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_33,
            { ""Control Byte"", ""pn_io.ps.cb"",
            VAR_19, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_34,
            { ""Control Byte"", ""pn_io.ps.cb.toggle_h_changed"",
            VAR_19, VAR_9, NULL, 0x00,
            NULL, VAR_5 }
        },
        { &VAR_35,
            { ""Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.slot"",
            VAR_31, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_36,
            { ""Sub_Slot_Number"", ""pn_io.ps.cb.toggle_h_changed.subslot"",
            VAR_31, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
        /* COMMENT_2 */
        { &VAR_37,
            { ""iPar_OK - F-Device has new iParameter values assigned"", ""pn_io.ps.sb.iPar_OK"",
            VAR_19, VAR_9, NULL, 0x01,
            NULL, VAR_5 }
        },
        { &VAR_38,
            { ""Device_Fault - Failure exists in F-Device or F-Module"", ""pn_io.ps.sb.DeviceFault"",
            VAR_19, VAR_9, NULL, 0x02,
            NULL, VAR_5 }
        },
        { &VAR_39,
            { ""CE_CRC - CRC Communication fault"", ""pn_io.ps.sb.CE_CRC"",
            VAR_19, VAR_9, NULL, 0x04,
            NULL, VAR_5 }
        },
        { &VAR_40,
            { ""WD_timeout - WatchDog timeout Communication fault"", ""pn_io.ps.sb.WD_timeout"",
            VAR_19, VAR_9, NULL, 0x08,
            NULL, VAR_5 }
        },
        { &VAR_41,
            { ""FV_activated - Fail-safe values (FV) activated"", ""pn_io.ps.sb.FV_activated"",
            VAR_19, VAR_9, NULL, 0x10,
            NULL, VAR_5 }
        },
        { &VAR_42,
            { ""Toggle_d - Device-based Toggle Bit"", ""pn_io.ps.sb.Toggle_d"",
            VAR_19, VAR_9, NULL, 0x20,
            NULL, VAR_5 }
        },
        { &VAR_43,
            { ""cons_nr_R - F-Device has reset its consecutive number counter"", ""pn_io.ps.sb.cons_nr_R"",
            VAR_19, VAR_9, NULL, 0x40,
            NULL, VAR_5 }
        },
        { &VAR_44,
            { ""Bit7 - reserved for future releases"", ""pn_io.ps.sb.bit7"",
            VAR_19, VAR_9, NULL, 0x80,
            NULL, VAR_5 }
        },
        { &VAR_45,
            { ""iPar_EN - iParameter assignment deblocked"", ""pn_io.ps.cb.iparEN"",
            VAR_19, VAR_9, NULL, 0x01,
            NULL, VAR_5 }
        },
        { &VAR_46,
            { ""OA_Req - Operator acknowledge requested"", ""pn_io.ps.cb.OA_Req"",
            VAR_19, VAR_9, NULL, 0x02,
            NULL, VAR_5 }
        },
        { &VAR_47,
            { ""R_cons_nr - Set the Virtual Consecutive Number within the F-Device to be \""0\"""", ""pn_io.ps.cb.R_cons_nr"",
            VAR_19, VAR_9, NULL, 0x04,
            NULL, VAR_5 }
        },
        { &VAR_48,
            { ""Bit3 - Reserved or Use the secondary watchdog (Use_TO2)"", ""pn_io.ps.cb.bit3"",
            VAR_19, VAR_9, NULL, 0x08,
            NULL, VAR_5 }
        },
        { &VAR_49,
            { ""activate_FV - Fail-safe values (FV) to be activated"", ""pn_io.ps.cb.activate_FV"",
            VAR_19, VAR_9, NULL, 0x10,
            NULL, VAR_5 }
        },
        { &VAR_50,
            { ""Toggle_h - Host-based Toggle Bit"", ""pn_io.ps.cb.Toggle_h"",
            VAR_19, VAR_9, NULL, 0x20,
            NULL, VAR_5 }
        },
        { &VAR_51,
            { ""Bit6 - Reserved or Operator acknowledge after cleared channel fault (ChF_Ack)"", ""pn_io.ps.cb.bit6"",
            VAR_19, VAR_9, NULL, 0x40,
            NULL, VAR_5 }
        },
        { &VAR_52,
            { ""Bit7 - Reserved or Loop-back check (Loopcheck, shall be set to 1)"", ""pn_io.ps.cb.bit7"",
            VAR_19, VAR_9, NULL, 0x80,
            NULL, VAR_5 }
        },
        /* COMMENT_3 */
        { &VAR_53,
            { ""F_Dest_Add"", ""pn_io.ps.f_dest_add"",
            VAR_31, VAR_54, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_55,
            { ""SafetyIO Data"", ""pn_io.ps.f_data"",
            VAR_56, VAR_9, NULL, 0x0,
            NULL, VAR_5 }
        },
    };

    static gint *VAR_57[] = {
        &VAR_58,
        &VAR_59,
        &VAR_60
    };

    static ei_register_info VAR_61[] = {
        { &VAR_62, { ""pn_io.too_many_data_objects"", VAR_63, VAR_64, ""Too many data objects"", VAR_65 }},
    };

    expert_module_t* VAR_66;

    VAR_67 = VAR_0;
    proto_register_field_array(VAR_0, VAR_1, array_length(VAR_1));
    proto_register_subtree_array(VAR_57, array_length(VAR_57));
    VAR_66 = expert_register_protocol(VAR_67);
    expert_register_field_array(VAR_66, VAR_61, array_length(VAR_61));
}",wireshark/4127e3930ef663114567002001f44e01eba8a250/packet-pn-rtc-one.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -224,7 +224,15 @@
         &ett_pn_io_io_data_object
     };
 
+    static ei_register_info ei[] = {
+        { &ei_pn_io_too_many_data_objects, { ""pn_io.too_many_data_objects"", PI_MALFORMED, PI_ERROR, ""Too many data objects"", EXPFILL }},
+    };
+
+    expert_module_t* expert_pn_io;
+
     proto_pn_io_rtc1 = proto;
     proto_register_field_array(proto, hf, array_length(hf));
     proto_register_subtree_array(ett, array_length(ett));
+    expert_pn_io = expert_register_protocol(proto_pn_io_rtc1);
+    expert_register_field_array(expert_pn_io, ei, array_length(ei));
 }","{'deleted_lines': [], 'added_lines': ['    static ei_register_info ei[] = {', '        { &ei_pn_io_too_many_data_objects, { ""pn_io.too_many_data_objects"", PI_MALFORMED, PI_ERROR, ""Too many data objects"", EXPFILL }},', '    };', '', '    expert_module_t* expert_pn_io;', '', '    expert_pn_io = expert_register_protocol(proto_pn_io_rtc1);', '    expert_register_field_array(expert_pn_io, ei, array_length(ei));']}",True,"In Wireshark 2.2.0 to 2.2.1, the Profinet I/O dissector could loop excessively, triggered by network traffic or a capture file. This was addressed in plugins/profinet/packet-pn-rtc-one.c by rejecting input with too many I/O objects.",5.9,MEDIUM,1,valid,2016-10-10T02:54:03Z,1
CVE-2016-8860,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,torproject/tor,"Add a one-word sentinel value of 0x0 at the end of each buf_t chunk

This helps protect against bugs where any part of a buf_t's memory
is passed to a function that expects a NUL-terminated input.

It also closes TROVE-2016-10-001 (aka bug 20384).",3cea86eb2fbb65949673eb4ba8ebb695c87a57ce,https://github.com/torproject/tor/commit/3cea86eb2fbb65949673eb4ba8ebb695c87a57ce,src/or/buffers.c,chunk_grow,"static INLINE chunk_t *
chunk_grow(chunk_t *chunk, size_t sz)
{
off_t offset;
size_t memlen_orig = chunk->memlen;
tor_assert(sz > chunk->memlen);
offset = chunk->data - chunk->mem;
chunk = tor_realloc(chunk, CHUNK_ALLOC_SIZE(sz));
chunk->memlen = sz;
chunk->data = chunk->mem + offset;
#ifdef DEBUG_CHUNK_ALLOC
tor_assert(chunk->DBG_alloc == CHUNK_ALLOC_SIZE(memlen_orig));
chunk->DBG_alloc = CHUNK_ALLOC_SIZE(sz);
#endif
total_bytes_allocated_in_chunks +=
CHUNK_ALLOC_SIZE(sz) - CHUNK_ALLOC_SIZE(memlen_orig);
return chunk;
}","static INLINE VAR_0 *
chunk_grow(chunk_t *VAR_1, size_t VAR_2)
{
off_t VAR_3;
size_t VAR_4 = VAR_1->memlen;
tor_assert(VAR_2 > VAR_1->memlen);
VAR_3 = VAR_1->data - VAR_1->mem;
VAR_1 = tor_realloc(VAR_1, CHUNK_ALLOC_SIZE(VAR_2));
VAR_1->memlen = VAR_2;
VAR_1->data = VAR_1->mem + VAR_3;
#ifdef VAR_5
tor_assert(VAR_1->DBG_alloc == CHUNK_ALLOC_SIZE(VAR_4));
VAR_1->DBG_alloc = CHUNK_ALLOC_SIZE(VAR_2);
#endif
VAR_6 +=
CHUNK_ALLOC_SIZE(VAR_2) - CHUNK_ALLOC_SIZE(VAR_4);
return VAR_1;
}",,"static INLINE chunk_t *
chunk_grow(chunk_t *chunk, size_t sz)
{
  off_t offset;
  const size_t memlen_orig = chunk->memlen;
  const size_t orig_alloc = CHUNK_ALLOC_SIZE(memlen_orig);
  const size_t new_alloc = CHUNK_ALLOC_SIZE(sz);
  tor_assert(sz > chunk->memlen);
  offset = chunk->data - chunk->mem;
  chunk = tor_realloc(chunk, new_alloc);
  chunk->memlen = sz;
  chunk->data = chunk->mem + offset;
#ifdef DEBUG_CHUNK_ALLOC
  tor_assert(chunk->DBG_alloc == orig_alloc);
  chunk->DBG_alloc = new_alloc;
#endif
  total_bytes_allocated_in_chunks += new_alloc - orig_alloc;
  CHUNK_SET_SENTINEL(chunk, new_alloc);
  return chunk;
}","static INLINE VAR_0 *
chunk_grow(chunk_t *VAR_1, size_t VAR_2)
{
  off_t VAR_3;
  const size_t VAR_4 = VAR_1->memlen;
  const size_t VAR_5 = CHUNK_ALLOC_SIZE(VAR_4);
  const size_t VAR_6 = CHUNK_ALLOC_SIZE(VAR_2);
  tor_assert(VAR_2 > VAR_1->memlen);
  VAR_3 = VAR_1->data - VAR_1->mem;
  VAR_1 = tor_realloc(VAR_1, VAR_6);
  VAR_1->memlen = VAR_2;
  VAR_1->data = VAR_1->mem + VAR_3;
#ifdef VAR_7
  tor_assert(VAR_1->DBG_alloc == VAR_5);
  VAR_1->DBG_alloc = VAR_6;
#endif
  VAR_8 += VAR_6 - VAR_5;
  CHUNK_SET_SENTINEL(VAR_1, VAR_6);
  return VAR_1;
}",,"--- func_before
+++ func_after
@@ -2,17 +2,19 @@
 chunk_grow(chunk_t *chunk, size_t sz)
 {
   off_t offset;
-  size_t memlen_orig = chunk->memlen;
+  const size_t memlen_orig = chunk->memlen;
+  const size_t orig_alloc = CHUNK_ALLOC_SIZE(memlen_orig);
+  const size_t new_alloc = CHUNK_ALLOC_SIZE(sz);
   tor_assert(sz > chunk->memlen);
   offset = chunk->data - chunk->mem;
-  chunk = tor_realloc(chunk, CHUNK_ALLOC_SIZE(sz));
+  chunk = tor_realloc(chunk, new_alloc);
   chunk->memlen = sz;
   chunk->data = chunk->mem + offset;
 #ifdef DEBUG_CHUNK_ALLOC
-  tor_assert(chunk->DBG_alloc == CHUNK_ALLOC_SIZE(memlen_orig));
-  chunk->DBG_alloc = CHUNK_ALLOC_SIZE(sz);
+  tor_assert(chunk->DBG_alloc == orig_alloc);
+  chunk->DBG_alloc = new_alloc;
 #endif
-  total_bytes_allocated_in_chunks +=
-    CHUNK_ALLOC_SIZE(sz) - CHUNK_ALLOC_SIZE(memlen_orig);
+  total_bytes_allocated_in_chunks += new_alloc - orig_alloc;
+  CHUNK_SET_SENTINEL(chunk, new_alloc);
   return chunk;
 }","{'deleted_lines': ['  size_t memlen_orig = chunk->memlen;', '  chunk = tor_realloc(chunk, CHUNK_ALLOC_SIZE(sz));', '  tor_assert(chunk->DBG_alloc == CHUNK_ALLOC_SIZE(memlen_orig));', '  chunk->DBG_alloc = CHUNK_ALLOC_SIZE(sz);', '  total_bytes_allocated_in_chunks +=', '    CHUNK_ALLOC_SIZE(sz) - CHUNK_ALLOC_SIZE(memlen_orig);'], 'added_lines': ['  const size_t memlen_orig = chunk->memlen;', '  const size_t orig_alloc = CHUNK_ALLOC_SIZE(memlen_orig);', '  const size_t new_alloc = CHUNK_ALLOC_SIZE(sz);', '  chunk = tor_realloc(chunk, new_alloc);', '  tor_assert(chunk->DBG_alloc == orig_alloc);', '  chunk->DBG_alloc = new_alloc;', '  total_bytes_allocated_in_chunks += new_alloc - orig_alloc;', '  CHUNK_SET_SENTINEL(chunk, new_alloc);']}",True,"Tor before 0.2.8.9 and 0.2.9.x before 0.2.9.4-alpha had internal functions that were entitled to expect that buf_t data had NUL termination, but the implementation of or/buffers.c did not ensure that NUL termination was present, which allows remote attackers to cause a denial of service (client, hidden service, relay, or authority crash) via crafted data.",7.5,HIGH,2,valid,2016-10-14T13:38:12Z,1
CVE-2016-8860,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,torproject/tor,"Add a one-word sentinel value of 0x0 at the end of each buf_t chunk

This helps protect against bugs where any part of a buf_t's memory
is passed to a function that expects a NUL-terminated input.

It also closes TROVE-2016-10-001 (aka bug 20384).",3cea86eb2fbb65949673eb4ba8ebb695c87a57ce,https://github.com/torproject/tor/commit/3cea86eb2fbb65949673eb4ba8ebb695c87a57ce,src/or/buffers.c,chunk_new_with_alloc_size,"static INLINE chunk_t *
chunk_new_with_alloc_size(size_t alloc)
{
chunk_t *ch;
ch = tor_malloc(alloc);
ch->next = NULL;
ch->datalen = 0;
#ifdef DEBUG_CHUNK_ALLOC
ch->DBG_alloc = alloc;
#endif
ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);
total_bytes_allocated_in_chunks += alloc;
ch->data = &ch->mem[0];
return ch;
}","static INLINE VAR_0 *
chunk_new_with_alloc_size(size_t VAR_1)
{
chunk_t *VAR_2;
VAR_2 = tor_malloc(VAR_1);
VAR_2->next = NULL;
VAR_2->datalen = 0;
#ifdef VAR_3
VAR_2->DBG_alloc = VAR_1;
#endif
VAR_2->memlen = CHUNK_SIZE_WITH_ALLOC(VAR_1);
VAR_4 += VAR_1;
VAR_2->data = &VAR_2->mem[0];
return VAR_2;
}",,"static INLINE chunk_t *
chunk_new_with_alloc_size(size_t alloc)
{
  chunk_t *ch;
  ch = tor_malloc(alloc);
  ch->next = NULL;
  ch->datalen = 0;
#ifdef DEBUG_CHUNK_ALLOC
  ch->DBG_alloc = alloc;
#endif
  ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);
  total_bytes_allocated_in_chunks += alloc;
  ch->data = &ch->mem[0];
  CHUNK_SET_SENTINEL(ch, alloc);
  return ch;
}","static INLINE VAR_0 *
chunk_new_with_alloc_size(size_t VAR_1)
{
  chunk_t *VAR_2;
  VAR_2 = tor_malloc(VAR_1);
  VAR_2->next = NULL;
  VAR_2->datalen = 0;
#ifdef VAR_3
  VAR_2->DBG_alloc = VAR_1;
#endif
  VAR_2->memlen = CHUNK_SIZE_WITH_ALLOC(VAR_1);
  VAR_4 += VAR_1;
  VAR_2->data = &VAR_2->mem[0];
  CHUNK_SET_SENTINEL(VAR_2, VAR_1);
  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -11,5 +11,6 @@
   ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);
   total_bytes_allocated_in_chunks += alloc;
   ch->data = &ch->mem[0];
+  CHUNK_SET_SENTINEL(ch, alloc);
   return ch;
 }","{'deleted_lines': [], 'added_lines': ['  CHUNK_SET_SENTINEL(ch, alloc);']}",True,"Tor before 0.2.8.9 and 0.2.9.x before 0.2.9.4-alpha had internal functions that were entitled to expect that buf_t data had NUL termination, but the implementation of or/buffers.c did not ensure that NUL termination was present, which allows remote attackers to cause a denial of service (client, hidden service, relay, or authority crash) via crafted data.",7.5,HIGH,2,valid,2016-10-14T13:38:12Z,1
CVE-2016-9102,['CWE-772'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu,"9pfs: fix memory leak in v9fs_xattrcreate

The 'fs.xattr.value' field in V9fsFidState object doesn't consider the
situation that this field has been allocated previously. Every time, it
will be allocated directly. This leads to a host memory leak issue if
the client sends another Txattrcreate message with the same fid number
before the fid from the previous time got clunked.

Signed-off-by: Li Qiang <liqiang6-s@360.cn>
Reviewed-by: Greg Kurz <groug@kaod.org>
[groug, updated the changelog to indicate how the leak can occur]
Signed-off-by: Greg Kurz <groug@kaod.org>",ff55e94d23ae94c8628b0115320157c763eb3e06,https://github.com/qemu/qemu/commit/ff55e94d23ae94c8628b0115320157c763eb3e06,hw/9pfs/9p.c,v9fs_xattrcreate,"static void coroutine_fn v9fs_xattrcreate(void *opaque)
{
int flags;
int32_t fid;
int64_t size;
ssize_t err = 0;
V9fsString name;
size_t offset = 7;
V9fsFidState *file_fidp;
V9fsFidState *xattr_fidp;
V9fsPDU *pdu = opaque;
v9fs_string_init(&name);
err = pdu_unmarshal(pdu, offset, ""dsqd"", &fid, &name, &size, &flags);
if (err < 0) {
goto out_nofid;
}
trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);
file_fidp = get_fid(pdu, fid);
if (file_fidp == NULL) {
err = -EINVAL;
goto out_nofid;
}
xattr_fidp = file_fidp;
xattr_fidp->fid_type = P9_FID_XATTR;
xattr_fidp->fs.xattr.copied_len = 0;
xattr_fidp->fs.xattr.len = size;
xattr_fidp->fs.xattr.flags = flags;
v9fs_string_init(&xattr_fidp->fs.xattr.name);
v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);
xattr_fidp->fs.xattr.value = g_malloc0(size);
err = offset;
put_fid(pdu, file_fidp);
out_nofid:
pdu_complete(pdu, err);
v9fs_string_free(&name);
}","static void VAR_0 v9fs_xattrcreate(void *VAR_1)
{
int VAR_2;
int32_t VAR_3;
int64_t VAR_4;
ssize_t VAR_5 = 0;
V9fsString VAR_6;
size_t VAR_7 = 7;
V9fsFidState *VAR_8;
V9fsFidState *VAR_9;
V9fsPDU *VAR_10 = VAR_1;
v9fs_string_init(&VAR_6);
VAR_5 = pdu_unmarshal(VAR_10, VAR_7, ""dsqd"", &VAR_3, &VAR_6, &VAR_4, &VAR_2);
if (VAR_5 < 0) {
goto out_nofid;
}
trace_v9fs_xattrcreate(VAR_10->tag, VAR_10->id, VAR_3, VAR_6.data, VAR_4, VAR_2);
VAR_8 = get_fid(VAR_10, VAR_3);
if (VAR_8 == NULL) {
VAR_5 = -VAR_11;
goto out_nofid;
}
VAR_9 = VAR_8;
VAR_9->fid_type = VAR_12;
VAR_9->fs.xattr.copied_len = 0;
VAR_9->fs.xattr.len = VAR_4;
VAR_9->fs.xattr.flags = VAR_2;
v9fs_string_init(&VAR_9->fs.xattr.name);
v9fs_string_copy(&VAR_9->fs.xattr.name, &VAR_6);
VAR_9->fs.xattr.value = g_malloc0(VAR_4);
VAR_5 = VAR_7;
put_fid(VAR_10, VAR_8);
out_nofid:
pdu_complete(VAR_10, VAR_5);
v9fs_string_free(&VAR_6);
}",,"static void coroutine_fn v9fs_xattrcreate(void *opaque)
{
    int flags;
    int32_t fid;
    int64_t size;
    ssize_t err = 0;
    V9fsString name;
    size_t offset = 7;
    V9fsFidState *file_fidp;
    V9fsFidState *xattr_fidp;
    V9fsPDU *pdu = opaque;

    v9fs_string_init(&name);
    err = pdu_unmarshal(pdu, offset, ""dsqd"", &fid, &name, &size, &flags);
    if (err < 0) {
        goto out_nofid;
    }
    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);

    file_fidp = get_fid(pdu, fid);
    if (file_fidp == NULL) {
        err = -EINVAL;
        goto out_nofid;
    }
    /* Make the file fid point to xattr */
    xattr_fidp = file_fidp;
    xattr_fidp->fid_type = P9_FID_XATTR;
    xattr_fidp->fs.xattr.copied_len = 0;
    xattr_fidp->fs.xattr.len = size;
    xattr_fidp->fs.xattr.flags = flags;
    v9fs_string_init(&xattr_fidp->fs.xattr.name);
    v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);
    g_free(xattr_fidp->fs.xattr.value);
    xattr_fidp->fs.xattr.value = g_malloc0(size);
    err = offset;
    put_fid(pdu, file_fidp);
out_nofid:
    pdu_complete(pdu, err);
    v9fs_string_free(&name);
}","static void VAR_0 v9fs_xattrcreate(void *VAR_1)
{
    int VAR_2;
    int32_t VAR_3;
    int64_t VAR_4;
    ssize_t VAR_5 = 0;
    V9fsString VAR_6;
    size_t VAR_7 = 7;
    V9fsFidState *VAR_8;
    V9fsFidState *VAR_9;
    V9fsPDU *VAR_10 = VAR_1;

    v9fs_string_init(&VAR_6);
    VAR_5 = pdu_unmarshal(VAR_10, VAR_7, ""dsqd"", &VAR_3, &VAR_6, &VAR_4, &VAR_2);
    if (VAR_5 < 0) {
        goto out_nofid;
    }
    trace_v9fs_xattrcreate(VAR_10->tag, VAR_10->id, VAR_3, VAR_6.data, VAR_4, VAR_2);

    VAR_8 = get_fid(VAR_10, VAR_3);
    if (VAR_8 == NULL) {
        VAR_5 = -VAR_11;
        goto out_nofid;
    }
    /* COMMENT_0 */
    VAR_9 = VAR_8;
    VAR_9->fid_type = VAR_12;
    VAR_9->fs.xattr.copied_len = 0;
    VAR_9->fs.xattr.len = VAR_4;
    VAR_9->fs.xattr.flags = VAR_2;
    v9fs_string_init(&VAR_9->fs.xattr.name);
    v9fs_string_copy(&VAR_9->fs.xattr.name, &VAR_6);
    g_free(VAR_9->fs.xattr.value);
    VAR_9->fs.xattr.value = g_malloc0(VAR_4);
    VAR_5 = VAR_7;
    put_fid(VAR_10, VAR_8);
out_nofid:
    pdu_complete(VAR_10, VAR_5);
    v9fs_string_free(&VAR_6);
}",,"--- func_before
+++ func_after
@@ -30,6 +30,7 @@
     xattr_fidp->fs.xattr.flags = flags;
     v9fs_string_init(&xattr_fidp->fs.xattr.name);
     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);
+    g_free(xattr_fidp->fs.xattr.value);
     xattr_fidp->fs.xattr.value = g_malloc0(size);
     err = offset;
     put_fid(pdu, file_fidp);","{'deleted_lines': [], 'added_lines': ['    g_free(xattr_fidp->fs.xattr.value);']}",True,Memory leak in the v9fs_xattrcreate function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption and QEMU process crash) via a large number of Txattrcreate messages with the same fid number.,6.0,MEDIUM,1,valid,2016-10-17T12:13:58Z,1
CVE-2016-8693,['CWE-415'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,jasper-software/jasper,"The memory stream interface allows for a buffer size of zero.
The case of a zero-sized buffer was not handled correctly, as it could
lead to a double free.
This problem has now been fixed (hopefully).
One might ask whether a zero-sized buffer should be allowed at all,
but this is a question for another day.",44a524e367597af58d6265ae2014468b334d0309,https://github.com/jasper-software/jasper/commit/44a524e367597af58d6265ae2014468b334d0309,src/libjasper/base/jas_stream.c,mem_resize,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
{
unsigned char *buf;
assert(m->buf_);
assert(bufsize >= 0);
if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {
return -1;
}
m->buf_ = buf;
m->bufsize_ = bufsize;
return 0;
}","static int mem_resize(jas_stream_memobj_t *VAR_0, int VAR_1)
{
unsigned char *VAR_2;
assert(VAR_0->buf_);
assert(VAR_1 >= 0);
if (!(VAR_2 = jas_realloc2(VAR_0->buf_, VAR_1, sizeof(unsigned char)))) {
return -1;
}
VAR_0->buf_ = VAR_2;
VAR_0->bufsize_ = VAR_1;
return 0;
}",jasper-software/jasper/44a524e367597af58d6265ae2014468b334d0309/jas_stream.c/vul/before/0.json,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
{
	unsigned char *buf;

	//assert(m->buf_);
	assert(bufsize >= 0);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
	  bufsize) {
		return -1;
	}
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}","static int mem_resize(jas_stream_memobj_t *VAR_0, int VAR_1)
{
	unsigned char *VAR_2;

	/* COMMENT_0 */
	assert(VAR_1 >= 0);
	if (!(VAR_2 = jas_realloc2(VAR_0->buf_, VAR_1, sizeof(unsigned char))) &&
	  VAR_1) {
		return -1;
	}
	VAR_0->buf_ = VAR_2;
	VAR_0->bufsize_ = VAR_1;
	return 0;
}",jasper-software/jasper/44a524e367597af58d6265ae2014468b334d0309/jas_stream.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,9 +2,10 @@
 {
 	unsigned char *buf;
 
-	assert(m->buf_);
+	//assert(m->buf_);
 	assert(bufsize >= 0);
-	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {
+	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
+	  bufsize) {
 		return -1;
 	}
 	m->buf_ = buf;","{'deleted_lines': ['\tassert(m->buf_);', '\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {'], 'added_lines': ['\t//assert(m->buf_);', '\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&', '\t  bufsize) {']}",True,Double free vulnerability in the mem_close function in jas_stream.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted BMP image to the imginfo command.,7.8,HIGH,2,valid,2016-10-20T14:34:32Z,1
CVE-2016-10250,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,jasper-software/jasper,Fixed another problem with incorrect cleanup of JP2 box data upon error.,bdfe95a6e81ffb4b2fad31a76b57943695beed20,https://github.com/jasper-software/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20,src/libjasper/jp2/jp2_cod.c,jp2_box_get,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
jp2_box_t *box;
jp2_boxinfo_t *boxinfo;
jas_stream_t *tmpstream;
uint_fast32_t len;
uint_fast64_t extlen;
bool dataflag;
box = 0;
tmpstream = 0;
if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
goto error;
}
box->ops = &jp2_boxinfo_unk.ops;
if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
goto error;
}
boxinfo = jp2_boxinfolookup(box->type);
box->info = boxinfo;
box->ops = &boxinfo->ops;
box->len = len;
JAS_DBGLOG(10, (
""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
'""', boxinfo->name, '""', box->type, box->len
));
if (box->len == 1) {
if (jp2_getuint64(in, &extlen)) {
goto error;
}
if (extlen > 0xffffffffUL) {
jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
extlen = 0xffffffffUL;
}
box->len = extlen;
box->datalen = extlen - JP2_BOX_HDRLEN(true);
} else {
box->datalen = box->len - JP2_BOX_HDRLEN(false);
}
if (box->len != 0 && box->len < 8) {
goto error;
}
dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
if (dataflag) {
if (!(tmpstream = jas_stream_memopen(0, 0))) {
goto error;
}
if (jas_stream_copy(tmpstream, in, box->datalen)) {
box->ops = &jp2_boxinfo_unk.ops;
jas_eprintf(""cannot copy box data\n"");
goto error;
}
jas_stream_rewind(tmpstream);
if (box->ops->getdata) {
if ((*box->ops->getdata)(box, tmpstream)) {
jas_eprintf(""cannot parse box data\n"");
goto error;
}
}
jas_stream_close(tmpstream);
}
if (jas_getdbglevel() >= 1) {
jp2_box_dump(box, stderr);
}
return box;
error:
if (box) {
jp2_box_destroy(box);
}
if (tmpstream) {
jas_stream_close(tmpstream);
}
return 0;
}","jp2_box_t *jp2_box_get(jas_stream_t *VAR_0)
{
jp2_box_t *VAR_1;
jp2_boxinfo_t *VAR_2;
jas_stream_t *VAR_3;
uint_fast32_t VAR_4;
uint_fast64_t VAR_5;
bool VAR_6;
VAR_1 = 0;
VAR_3 = 0;
if (!(VAR_1 = jas_malloc(sizeof(jp2_box_t)))) {
goto error;
}
VAR_1->ops = &VAR_7.ops;
if (jp2_getuint32(VAR_0, &VAR_4) || jp2_getuint32(VAR_0, &VAR_1->type)) {
goto error;
}
VAR_2 = jp2_boxinfolookup(VAR_1->type);
VAR_1->info = VAR_2;
VAR_1->ops = &VAR_2->ops;
VAR_1->len = VAR_4;
JAS_DBGLOG(10, (
""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
'""', VAR_2->name, '""', VAR_1->type, VAR_1->len
));
if (VAR_1->len == 1) {
if (jp2_getuint64(VAR_0, &VAR_5)) {
goto error;
}
if (VAR_5 > 0xffffffffUL) {
jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
VAR_5 = 0xffffffffUL;
}
VAR_1->len = VAR_5;
VAR_1->datalen = VAR_5 - JP2_BOX_HDRLEN(true);
} else {
VAR_1->datalen = VAR_1->len - JP2_BOX_HDRLEN(false);
}
if (VAR_1->len != 0 && VAR_1->len < 8) {
goto error;
}
VAR_6 = !(VAR_1->info->flags & (VAR_8 | VAR_9));
if (VAR_6) {
if (!(VAR_3 = jas_stream_memopen(0, 0))) {
goto error;
}
if (jas_stream_copy(VAR_3, VAR_0, VAR_1->datalen)) {
VAR_1->ops = &VAR_7.ops;
jas_eprintf(""cannot copy box data\n"");
goto error;
}
jas_stream_rewind(VAR_3);
if (VAR_1->ops->getdata) {
if ((*VAR_1->ops->getdata)(VAR_1, VAR_3)) {
jas_eprintf(""cannot parse box data\n"");
goto error;
}
}
jas_stream_close(VAR_3);
}
if (jas_getdbglevel() >= 1) {
jp2_box_dump(VAR_1, VAR_10);
}
return VAR_1;
error:
if (VAR_1) {
jp2_box_destroy(VAR_1);
}
if (VAR_3) {
jas_stream_close(VAR_3);
}
return 0;
}",jasper-software/jasper/bdfe95a6e81ffb4b2fad31a76b57943695beed20/jp2_cod.c/vul/before/0.json,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}

	// Mark the box data as never having been constructed
	// so that we will not errantly attempt to destroy it later.
	box->ops = &jp2_boxinfo_unk.ops;

	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
	box->info = boxinfo;
	box->len = len;
	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			jas_eprintf(""cannot copy box data\n"");
			goto error;
		}
		jas_stream_rewind(tmpstream);

		// From here onwards, the box data will need to be destroyed.
		// So, initialize the box operations.
		box->ops = &boxinfo->ops;

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}","jp2_box_t *jp2_box_get(jas_stream_t *VAR_0)
{
	jp2_box_t *VAR_1;
	jp2_boxinfo_t *VAR_2;
	jas_stream_t *VAR_3;
	uint_fast32_t VAR_4;
	uint_fast64_t VAR_5;
	bool VAR_6;

	VAR_1 = 0;
	VAR_3 = 0;

	if (!(VAR_1 = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}

	/* COMMENT_0 */
	/* COMMENT_1 */
	VAR_1->ops = &VAR_7.ops;

	if (jp2_getuint32(VAR_0, &VAR_4) || jp2_getuint32(VAR_0, &VAR_1->type)) {
		goto error;
	}
	VAR_2 = jp2_boxinfolookup(VAR_1->type);
	VAR_1->info = VAR_2;
	VAR_1->len = VAR_4;
	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', VAR_2->name, '""', VAR_1->type, VAR_1->len
	  ));
	if (VAR_1->len == 1) {
		if (jp2_getuint64(VAR_0, &VAR_5)) {
			goto error;
		}
		if (VAR_5 > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			VAR_5 = 0xffffffffUL;
		}
		VAR_1->len = VAR_5;
		VAR_1->datalen = VAR_5 - JP2_BOX_HDRLEN(true);
	} else {
		VAR_1->datalen = VAR_1->len - JP2_BOX_HDRLEN(false);
	}
	if (VAR_1->len != 0 && VAR_1->len < 8) {
		goto error;
	}

	VAR_6 = !(VAR_1->info->flags & (VAR_8 | VAR_9));

	if (VAR_6) {
		if (!(VAR_3 = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(VAR_3, VAR_0, VAR_1->datalen)) {
			jas_eprintf(""cannot copy box data\n"");
			goto error;
		}
		jas_stream_rewind(VAR_3);

		/* COMMENT_2 */
		/* COMMENT_3 */
		VAR_1->ops = &VAR_2->ops;

		if (VAR_1->ops->getdata) {
			if ((*VAR_1->ops->getdata)(VAR_1, VAR_3)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(VAR_3);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(VAR_1, VAR_10);
	}

	return VAR_1;

error:
	if (VAR_1) {
		jp2_box_destroy(VAR_1);
	}
	if (VAR_3) {
		jas_stream_close(VAR_3);
	}
	return 0;
}",jasper-software/jasper/bdfe95a6e81ffb4b2fad31a76b57943695beed20/jp2_cod.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,13 +13,16 @@
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}
+
+	// Mark the box data as never having been constructed
+	// so that we will not errantly attempt to destroy it later.
 	box->ops = &jp2_boxinfo_unk.ops;
+
 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
-	box->ops = &boxinfo->ops;
 	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
@@ -49,13 +52,14 @@
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
-			// Mark the box data as never having been constructed
-			// so that we will not errantly attempt to destroy it later.
-			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
+
+		// From here onwards, the box data will need to be destroyed.
+		// So, initialize the box operations.
+		box->ops = &boxinfo->ops;
 
 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {","{'deleted_lines': ['\tbox->ops = &boxinfo->ops;', '\t\t\t// Mark the box data as never having been constructed', '\t\t\t// so that we will not errantly attempt to destroy it later.', '\t\t\tbox->ops = &jp2_boxinfo_unk.ops;'], 'added_lines': ['', '\t// Mark the box data as never having been constructed', '\t// so that we will not errantly attempt to destroy it later.', '', '', '\t\t// From here onwards, the box data will need to be destroyed.', '\t\t// So, initialize the box operations.', '\t\tbox->ops = &boxinfo->ops;']}",True,The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.,7.5,HIGH,2,valid,2016-10-23T10:52:29Z,1
CVE-2016-10250,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,jasper-software/jasper,Fixed another problem with incorrect cleanup of JP2 box data upon error.,bdfe95a6e81ffb4b2fad31a76b57943695beed20,https://github.com/jasper-software/jasper/commit/bdfe95a6e81ffb4b2fad31a76b57943695beed20,src/libjasper/jp2/jp2_cod.c,jp2_box_dump,"void jp2_box_dump(jp2_box_t *box, FILE *out)
{
jp2_boxinfo_t *boxinfo;
boxinfo = jp2_boxinfolookup(box->type);
assert(boxinfo);
fprintf(out, ""JP2 box: "");
fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
'""', box->type, box->len);
if (box->ops->dumpdata) {
(*box->ops->dumpdata)(box, out);
}
}","void jp2_box_dump(jp2_box_t *VAR_0, FILE *VAR_1)
{
jp2_boxinfo_t *VAR_2;
VAR_2 = jp2_boxinfolookup(VAR_0->type);
assert(VAR_2);
fprintf(VAR_1, ""JP2 box: "");
fprintf(VAR_1, ""type=%c%s%c (0x%08""VAR_3""); length=%""VAR_4""\n"", '""', VAR_2->name,
'""', VAR_0->type, VAR_0->len);
if (VAR_0->ops->dumpdata) {
(*VAR_0->ops->dumpdata)(VAR_0, VAR_1);
}
}",jasper-software/jasper/bdfe95a6e81ffb4b2fad31a76b57943695beed20/jp2_cod.c/vul/before/1.json,"void jp2_box_dump(jp2_box_t *box, FILE *out)
{
	jp2_boxinfo_t *boxinfo;
	boxinfo = jp2_boxinfolookup(box->type);
	assert(boxinfo);

	fprintf(out, ""JP2 box: "");
	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
	  boxinfo->name, '""', box->type, box->len);
	if (box->ops->dumpdata) {
		(*box->ops->dumpdata)(box, out);
	}
}","void jp2_box_dump(jp2_box_t *VAR_0, FILE *VAR_1)
{
	jp2_boxinfo_t *VAR_2;
	VAR_2 = jp2_boxinfolookup(VAR_0->type);
	assert(VAR_2);

	fprintf(VAR_1, ""JP2 box: "");
	fprintf(VAR_1, ""type=%c%s%c (0x%08""VAR_3""); length=%""VAR_4""\n"", '""',
	  VAR_2->name, '""', VAR_0->type, VAR_0->len);
	if (VAR_0->ops->dumpdata) {
		(*VAR_0->ops->dumpdata)(VAR_0, VAR_1);
	}
}",jasper-software/jasper/bdfe95a6e81ffb4b2fad31a76b57943695beed20/jp2_cod.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -5,8 +5,8 @@
 	assert(boxinfo);
 
 	fprintf(out, ""JP2 box: "");
-	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name,
-	  '""', box->type, box->len);
+	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
+	  boxinfo->name, '""', box->type, box->len);
 	if (box->ops->dumpdata) {
 		(*box->ops->dumpdata)(box, out);
 	}","{'deleted_lines': ['\tfprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\\n"", \'""\', boxinfo->name,', '\t  \'""\', box->type, box->len);'], 'added_lines': ['\tfprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\\n"", \'""\',', '\t  boxinfo->name, \'""\', box->type, box->len);']}",True,The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.,7.5,HIGH,2,valid,2016-10-23T10:52:29Z,1
CVE-2016-10189,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,bitlbee,imcb_file_send_start: handle ft attempts from non-existing users,701ab8129ba9ea64f569daedca9a8603abad740f,https://github.com/bitlbee/bitlbee/commit/701ab8129ba9ea64f569daedca9a8603abad740f,protocols/bee_ft.c,imcb_file_send_start,"file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)
{
bee_t *bee = ic->bee;
bee_user_t *bu = bee_user_by_handle(bee, ic, handle);
if (bee->ui->ft_in_start) {
return bee->ui->ft_in_start(bee, bu, file_name, file_size);
} else {
return NULL;
}
}","file_transfer_t *imcb_file_send_start(struct im_connection *VAR_0, char *VAR_1, char *VAR_2, size_t VAR_3)
{
bee_t *VAR_4 = VAR_0->bee;
bee_user_t *VAR_5 = bee_user_by_handle(VAR_4, VAR_0, VAR_1);
if (VAR_4->ui->ft_in_start) {
return VAR_4->ui->ft_in_start(VAR_4, VAR_5, VAR_2, VAR_3);
} else {
return NULL;
}
}",bitlbee/701ab8129ba9ea64f569daedca9a8603abad740f/bee_ft.c/vul/before/0.json,"file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)
{
	bee_t *bee = ic->bee;
	bee_user_t *bu = bee_user_by_handle(bee, ic, handle);

	if (bee->ui->ft_in_start && bu) {
		return bee->ui->ft_in_start(bee, bu, file_name, file_size);
	} else {
		return NULL;
	}
}","file_transfer_t *imcb_file_send_start(struct im_connection *VAR_0, char *VAR_1, char *VAR_2, size_t VAR_3)
{
	bee_t *VAR_4 = VAR_0->bee;
	bee_user_t *VAR_5 = bee_user_by_handle(VAR_4, VAR_0, VAR_1);

	if (VAR_4->ui->ft_in_start && VAR_5) {
		return VAR_4->ui->ft_in_start(VAR_4, VAR_5, VAR_2, VAR_3);
	} else {
		return NULL;
	}
}",bitlbee/701ab8129ba9ea64f569daedca9a8603abad740f/bee_ft.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	bee_t *bee = ic->bee;
 	bee_user_t *bu = bee_user_by_handle(bee, ic, handle);
 
-	if (bee->ui->ft_in_start) {
+	if (bee->ui->ft_in_start && bu) {
 		return bee->ui->ft_in_start(bee, bu, file_name, file_size);
 	} else {
 		return NULL;","{'deleted_lines': ['\tif (bee->ui->ft_in_start) {'], 'added_lines': ['\tif (bee->ui->ft_in_start && bu) {']}",True,BitlBee before 3.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.,7.5,HIGH,2,valid,2016-11-13T19:52:43Z,1
CVE-2016-9777,['CWE-125'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"KVM: x86: fix out-of-bounds accesses of rtc_eoi map

KVM was using arrays of size KVM_MAX_VCPUS with vcpu_id, but ID can be
bigger that the maximal number of VCPUs, resulting in out-of-bounds
access.

Found by syzkaller:

  BUG: KASAN: slab-out-of-bounds in __apic_accept_irq+0xb33/0xb50 at addr [...]
  Write of size 1 by task a.out/27101
  CPU: 1 PID: 27101 Comm: a.out Not tainted 4.9.0-rc5+ #49
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
   [...]
  Call Trace:
   [...] __apic_accept_irq+0xb33/0xb50 arch/x86/kvm/lapic.c:905
   [...] kvm_apic_set_irq+0x10e/0x180 arch/x86/kvm/lapic.c:495
   [...] kvm_irq_delivery_to_apic+0x732/0xc10 arch/x86/kvm/irq_comm.c:86
   [...] ioapic_service+0x41d/0x760 arch/x86/kvm/ioapic.c:360
   [...] ioapic_set_irq+0x275/0x6c0 arch/x86/kvm/ioapic.c:222
   [...] kvm_ioapic_inject_all arch/x86/kvm/ioapic.c:235
   [...] kvm_set_ioapic+0x223/0x310 arch/x86/kvm/ioapic.c:670
   [...] kvm_vm_ioctl_set_irqchip arch/x86/kvm/x86.c:3668
   [...] kvm_arch_vm_ioctl+0x1a08/0x23c0 arch/x86/kvm/x86.c:3999
   [...] kvm_vm_ioctl+0x1fa/0x1a70 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3099

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Cc: stable@vger.kernel.org
Fixes: af1bae5497b9 (""KVM: x86: bump KVM_MAX_VCPU_ID to 1023"")
Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
Reviewed-by: David Hildenbrand <david@redhat.com>
Signed-off-by: Radim Krm <rkrcmar@redhat.com>",81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755,https://github.com/torvalds/linux/commit/81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755,arch/x86/kvm/ioapic.c,rtc_irq_eoi_tracking_reset,"static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)
{
ioapic->rtc_status.pending_eoi = 0;
bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);
}","static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *VAR_0)
{
VAR_0->rtc_status.pending_eoi = 0;
bitmap_zero(VAR_0->rtc_status.dest_map.map, VAR_1);
}",torvalds/linux/81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755/ioapic.c/vul/before/0.json,"static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)
{
	ioapic->rtc_status.pending_eoi = 0;
	bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);
}","static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *VAR_0)
{
	VAR_0->rtc_status.pending_eoi = 0;
	bitmap_zero(VAR_0->rtc_status.dest_map.map, VAR_1);
}",torvalds/linux/81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755/ioapic.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)
 {
 	ioapic->rtc_status.pending_eoi = 0;
-	bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);
+	bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);
 }","{'deleted_lines': ['\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);'], 'added_lines': ['\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);']}",True,"KVM in the Linux kernel before 4.8.12, when I/O APIC is enabled, does not properly restrict the VCPU index, which allows guest OS users to gain host OS privileges or cause a denial of service (out-of-bounds array access and host OS crash) via a crafted interrupt request, related to arch/x86/kvm/ioapic.c and arch/x86/kvm/ioapic.h.",7.8,HIGH,2,valid,2016-11-23T20:15:27Z,1
CVE-2017-3730,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"Fix missing NULL checks in CKE processing

Reviewed-by: Rich Salz <rsalz@openssl.org>",efbe126e3ebb9123ac9d058aa2bb044261342aaa,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,ssl/statem/statem_clnt.c,tls_construct_cke_ecdhe,"static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_EC
unsigned char *encodedPoint = NULL;
int encoded_pt_len = 0;
EVP_PKEY *ckey = NULL, *skey = NULL;
skey = s->s3->peer_tmp;
if (skey == NULL) {
SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
return 0;
}
ckey = ssl_generate_pkey(skey);
if (ssl_derive(s, ckey, skey) == 0) {
SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);
goto err;
}
encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);
if (encoded_pt_len == 0) {
SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
goto err;
}
EVP_PKEY_free(ckey);
ckey = NULL;
*len = encoded_pt_len;
**p = *len;
*p += 1;
memcpy(*p, encodedPoint, *len);
*len += 1;
OPENSSL_free(encodedPoint);
return 1;
err:
EVP_PKEY_free(ckey);
return 0;
#else
SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
*al = SSL_AD_INTERNAL_ERROR;
return 0;
#endif
}","static int tls_construct_cke_ecdhe(SSL *VAR_0, unsigned char **VAR_1, int *VAR_2, int *VAR_3)
{
#ifndef VAR_4
unsigned char *VAR_5 = NULL;
int VAR_6 = 0;
EVP_PKEY *VAR_7 = NULL, *VAR_8 = NULL;
VAR_8 = VAR_0->s3->peer_tmp;
if (VAR_8 == NULL) {
SSLerr(VAR_9, VAR_10);
return 0;
}
VAR_7 = ssl_generate_pkey(VAR_8);
if (ssl_derive(VAR_0, VAR_7, VAR_8) == 0) {
SSLerr(VAR_9, VAR_11);
goto err;
}
VAR_6 = EVP_PKEY_get1_tls_encodedpoint(VAR_7, &VAR_5);
if (VAR_6 == 0) {
SSLerr(VAR_9, VAR_12);
goto err;
}
EVP_PKEY_free(VAR_7);
VAR_7 = NULL;
*VAR_2 = VAR_6;
**VAR_1 = *VAR_2;
*VAR_1 += 1;
memcpy(*VAR_1, VAR_5, *VAR_2);
*VAR_2 += 1;
OPENSSL_free(VAR_5);
return 1;
err:
EVP_PKEY_free(VAR_7);
return 0;
#else
SSLerr(VAR_9, VAR_10);
*VAR_3 = VAR_13;
return 0;
#endif
}",openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa/statem_clnt.c/vul/before/0.json,"static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_EC
    unsigned char *encodedPoint = NULL;
    int encoded_pt_len = 0;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    ckey = ssl_generate_pkey(skey);
    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        goto err;
    }

    if (ssl_derive(s, ckey, skey) == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);
        goto err;
    }

    /* Generate encoding of client key */
    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);

    if (encoded_pt_len == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
        goto err;
    }

    EVP_PKEY_free(ckey);
    ckey = NULL;

    *len = encoded_pt_len;

    /* length of encoded point */
    **p = *len;
    *p += 1;
    /* copy the point */
    memcpy(*p, encodedPoint, *len);
    /* increment len to account for length field */
    *len += 1;

    OPENSSL_free(encodedPoint);

    return 1;
 err:
    EVP_PKEY_free(ckey);
    return 0;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}","static int tls_construct_cke_ecdhe(SSL *VAR_0, unsigned char **VAR_1, int *VAR_2, int *VAR_3)
{
#ifndef VAR_4
    unsigned char *VAR_5 = NULL;
    int VAR_6 = 0;
    EVP_PKEY *VAR_7 = NULL, *VAR_8 = NULL;

    VAR_8 = VAR_0->s3->peer_tmp;
    if (VAR_8 == NULL) {
        SSLerr(VAR_9, VAR_10);
        return 0;
    }

    VAR_7 = ssl_generate_pkey(VAR_8);
    if (VAR_7 == NULL) {
        SSLerr(VAR_9, VAR_10);
        goto err;
    }

    if (ssl_derive(VAR_0, VAR_7, VAR_8) == 0) {
        SSLerr(VAR_9, VAR_11);
        goto err;
    }

    /* COMMENT_0 */
    VAR_6 = EVP_PKEY_get1_tls_encodedpoint(VAR_7, &VAR_5);

    if (VAR_6 == 0) {
        SSLerr(VAR_9, VAR_12);
        goto err;
    }

    EVP_PKEY_free(VAR_7);
    VAR_7 = NULL;

    *VAR_2 = VAR_6;

    /* COMMENT_1 */
    **VAR_1 = *VAR_2;
    *VAR_1 += 1;
    /* COMMENT_2 */
    memcpy(*VAR_1, VAR_5, *VAR_2);
    /* COMMENT_3 */
    *VAR_2 += 1;

    OPENSSL_free(VAR_5);

    return 1;
 err:
    EVP_PKEY_free(VAR_7);
    return 0;
#else
    SSLerr(VAR_9, VAR_10);
    *VAR_3 = VAR_13;
    return 0;
#endif
}",openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa/statem_clnt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,10 @@
     }
 
     ckey = ssl_generate_pkey(skey);
+    if (ckey == NULL) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);","{'deleted_lines': [], 'added_lines': ['    if (ckey == NULL) {', '        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);', '        goto err;', '    }']}",True,"In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.",7.5,HIGH,2,valid,2016-11-23T22:12:40Z,1
CVE-2017-3730,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"Fix missing NULL checks in CKE processing

Reviewed-by: Rich Salz <rsalz@openssl.org>",efbe126e3ebb9123ac9d058aa2bb044261342aaa,https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa,ssl/statem/statem_clnt.c,tls_construct_cke_dhe,"static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_DH
DH *dh_clnt = NULL;
const BIGNUM *pub_key;
EVP_PKEY *ckey = NULL, *skey = NULL;
skey = s->s3->peer_tmp;
if (skey == NULL) {
SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
return 0;
}
ckey = ssl_generate_pkey(skey);
dh_clnt = EVP_PKEY_get0_DH(ckey);
if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
EVP_PKEY_free(ckey);
return 0;
}
DH_get0_key(dh_clnt, &pub_key, NULL);
*len = BN_num_bytes(pub_key);
s2n(*len, *p);
BN_bn2bin(pub_key, *p);
*len += 2;
EVP_PKEY_free(ckey);
return 1;
#else
SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
*al = SSL_AD_INTERNAL_ERROR;
return 0;
#endif
}","static int tls_construct_cke_dhe(SSL *VAR_0, unsigned char **VAR_1, int *VAR_2, int *VAR_3)
{
#ifndef VAR_4
DH *VAR_5 = NULL;
const BIGNUM *VAR_6;
EVP_PKEY *VAR_7 = NULL, *VAR_8 = NULL;
VAR_8 = VAR_0->s3->peer_tmp;
if (VAR_8 == NULL) {
SSLerr(VAR_9, VAR_10);
return 0;
}
VAR_7 = ssl_generate_pkey(VAR_8);
VAR_5 = EVP_PKEY_get0_DH(VAR_7);
if (VAR_5 == NULL || ssl_derive(VAR_0, VAR_7, VAR_8) == 0) {
SSLerr(VAR_9, VAR_10);
EVP_PKEY_free(VAR_7);
return 0;
}
DH_get0_key(VAR_5, &VAR_6, NULL);
*VAR_2 = BN_num_bytes(VAR_6);
s2n(*VAR_2, *VAR_1);
BN_bn2bin(VAR_6, *VAR_1);
*VAR_2 += 2;
EVP_PKEY_free(VAR_7);
return 1;
#else
SSLerr(VAR_9, VAR_10);
*VAR_3 = VAR_11;
return 0;
#endif
}",openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa/statem_clnt.c/vul/before/1.json,"static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_DH
    DH *dh_clnt = NULL;
    const BIGNUM *pub_key;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }
    ckey = ssl_generate_pkey(skey);
    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    dh_clnt = EVP_PKEY_get0_DH(ckey);

    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        EVP_PKEY_free(ckey);
        return 0;
    }

    /* send off the data */
    DH_get0_key(dh_clnt, &pub_key, NULL);
    *len = BN_num_bytes(pub_key);
    s2n(*len, *p);
    BN_bn2bin(pub_key, *p);
    *len += 2;
    EVP_PKEY_free(ckey);

    return 1;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}","static int tls_construct_cke_dhe(SSL *VAR_0, unsigned char **VAR_1, int *VAR_2, int *VAR_3)
{
#ifndef VAR_4
    DH *VAR_5 = NULL;
    const BIGNUM *VAR_6;
    EVP_PKEY *VAR_7 = NULL, *VAR_8 = NULL;

    VAR_8 = VAR_0->s3->peer_tmp;
    if (VAR_8 == NULL) {
        SSLerr(VAR_9, VAR_10);
        return 0;
    }
    VAR_7 = ssl_generate_pkey(VAR_8);
    if (VAR_7 == NULL) {
        SSLerr(VAR_9, VAR_10);
        return 0;
    }

    VAR_5 = EVP_PKEY_get0_DH(VAR_7);

    if (VAR_5 == NULL || ssl_derive(VAR_0, VAR_7, VAR_8) == 0) {
        SSLerr(VAR_9, VAR_10);
        EVP_PKEY_free(VAR_7);
        return 0;
    }

    /* COMMENT_0 */
    DH_get0_key(VAR_5, &VAR_6, NULL);
    *VAR_2 = BN_num_bytes(VAR_6);
    s2n(*VAR_2, *VAR_1);
    BN_bn2bin(VAR_6, *VAR_1);
    *VAR_2 += 2;
    EVP_PKEY_free(VAR_7);

    return 1;
#else
    SSLerr(VAR_9, VAR_10);
    *VAR_3 = VAR_11;
    return 0;
#endif
}",openssl/efbe126e3ebb9123ac9d058aa2bb044261342aaa/statem_clnt.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -11,6 +11,11 @@
         return 0;
     }
     ckey = ssl_generate_pkey(skey);
+    if (ckey == NULL) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
     dh_clnt = EVP_PKEY_get0_DH(ckey);
 
     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {","{'deleted_lines': [], 'added_lines': ['    if (ckey == NULL) {', '        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);', '        return 0;', '    }', '']}",True,"In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.",7.5,HIGH,2,valid,2016-11-23T22:12:40Z,1
CVE-2016-10011,['CWE-320'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,openbsd/src,"use sshbuf_allocate() to pre-allocate the buffer used for loading
keys. This avoids implicit realloc inside the buffer code, which
might theoretically leave fragments of the key on the heap. This
doesn't appear to happen in practice for normal sized keys, but
was observed for novelty oversize ones.

Pointed out by Jann Horn of Project Zero; ok markus@",ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9,https://github.com/openbsd/src/commit/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9,usr.bin/ssh/authfile.c,sshkey_load_file,"int
sshkey_load_file(int fd, struct sshbuf *blob)
{
u_char buf[1024];
size_t len;
struct stat st;
int r;
if (fstat(fd, &st) < 0)
return SSH_ERR_SYSTEM_ERROR;
if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
st.st_size > MAX_KEY_FILE_SIZE)
return SSH_ERR_INVALID_FORMAT;
for (;;) {
if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
if (errno == EPIPE)
break;
r = SSH_ERR_SYSTEM_ERROR;
goto out;
}
if ((r = sshbuf_put(blob, buf, len)) != 0)
goto out;
if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {
r = SSH_ERR_INVALID_FORMAT;
goto out;
}
}
if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
st.st_size != (off_t)sshbuf_len(blob)) {
r = SSH_ERR_FILE_CHANGED;
goto out;
}
r = 0;
out:
explicit_bzero(buf, sizeof(buf));
if (r != 0)
sshbuf_reset(blob);
return r;
}","int
sshkey_load_file(int VAR_0, struct sshbuf *VAR_1)
{
u_char VAR_2[1024];
size_t VAR_3;
struct stat VAR_4;
int VAR_5;
if (fstat(VAR_0, &VAR_4) < 0)
return VAR_6;
if ((VAR_4.st_mode & (VAR_7|VAR_8|VAR_9)) == 0 &&
VAR_4.st_size > VAR_10)
return VAR_11;
for (;;) {
if ((VAR_3 = atomicio(VAR_12, VAR_0, VAR_2, sizeof(VAR_2))) == 0) {
if (VAR_13 == VAR_14)
break;
VAR_5 = VAR_6;
goto out;
}
if ((VAR_5 = sshbuf_put(VAR_1, VAR_2, VAR_3)) != 0)
goto out;
if (sshbuf_len(VAR_1) > VAR_10) {
VAR_5 = VAR_11;
goto out;
}
}
if ((VAR_4.st_mode & (VAR_7|VAR_8|VAR_9)) == 0 &&
VAR_4.st_size != (off_t)sshbuf_len(VAR_1)) {
VAR_5 = VAR_15;
goto out;
}
VAR_5 = 0;
out:
explicit_bzero(VAR_2, sizeof(VAR_2));
if (VAR_5 != 0)
sshbuf_reset(VAR_1);
return VAR_5;
}",openbsd/src/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9/authfile.c/vul/before/0.json,"int
sshkey_load_file(int fd, struct sshbuf *blob)
{
	u_char buf[1024];
	size_t len;
	struct stat st;
	int r, dontmax = 0;

	if (fstat(fd, &st) < 0)
		return SSH_ERR_SYSTEM_ERROR;
	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
	    st.st_size > MAX_KEY_FILE_SIZE)
		return SSH_ERR_INVALID_FORMAT;
	/*
	 * Pre-allocate the buffer used for the key contents and clamp its
	 * maximum size. This ensures that key contents are never leaked via
	 * implicit realloc() in the sshbuf code.
	 */
	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
		dontmax = 1;
	}
	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
		return r;
	for (;;) {
		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
			if (errno == EPIPE)
				break;
			r = SSH_ERR_SYSTEM_ERROR;
			goto out;
		}
		if ((r = sshbuf_put(blob, buf, len)) != 0)
			goto out;
		if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}
	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
	    st.st_size != (off_t)sshbuf_len(blob)) {
		r = SSH_ERR_FILE_CHANGED;
		goto out;
	}
	r = 0;

 out:
	explicit_bzero(buf, sizeof(buf));
	if (r != 0)
		sshbuf_reset(blob);
	return r;
}","int
sshkey_load_file(int VAR_0, struct sshbuf *VAR_1)
{
	u_char VAR_2[1024];
	size_t VAR_3;
	struct stat VAR_4;
	int VAR_5, VAR_6 = 0;

	if (fstat(VAR_0, &VAR_4) < 0)
		return VAR_7;
	if ((VAR_4.st_mode & (VAR_8|VAR_9|VAR_10)) == 0 &&
	    VAR_4.st_size > VAR_11)
		return VAR_12;
	/* COMMENT_0 */
                                                                   
                                                                     
                                          
    
	if ((VAR_4.st_mode & VAR_13) == 0 || VAR_4.st_size <= 0) {
		VAR_4.st_size = 64*1024; /* COMMENT_5 */
		VAR_6 = 1;
	}
	if ((VAR_5 = sshbuf_allocate(VAR_1, VAR_4.st_size)) != 0 ||
	    (VAR_6 && (VAR_5 = sshbuf_set_max_size(VAR_1, VAR_4.st_size)) != 0))
		return VAR_5;
	for (;;) {
		if ((VAR_3 = atomicio(VAR_14, VAR_0, VAR_2, sizeof(VAR_2))) == 0) {
			if (VAR_15 == VAR_16)
				break;
			VAR_5 = VAR_7;
			goto out;
		}
		if ((VAR_5 = sshbuf_put(VAR_1, VAR_2, VAR_3)) != 0)
			goto out;
		if (sshbuf_len(VAR_1) > VAR_11) {
			VAR_5 = VAR_12;
			goto out;
		}
	}
	if ((VAR_4.st_mode & (VAR_8|VAR_9|VAR_10)) == 0 &&
	    VAR_4.st_size != (off_t)sshbuf_len(VAR_1)) {
		VAR_5 = VAR_17;
		goto out;
	}
	VAR_5 = 0;

 out:
	explicit_bzero(VAR_2, sizeof(VAR_2));
	if (VAR_5 != 0)
		sshbuf_reset(VAR_1);
	return VAR_5;
}",openbsd/src/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9/authfile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,13 +4,25 @@
 	u_char buf[1024];
 	size_t len;
 	struct stat st;
-	int r;
+	int r, dontmax = 0;
 
 	if (fstat(fd, &st) < 0)
 		return SSH_ERR_SYSTEM_ERROR;
 	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
 	    st.st_size > MAX_KEY_FILE_SIZE)
 		return SSH_ERR_INVALID_FORMAT;
+	/*
+	 * Pre-allocate the buffer used for the key contents and clamp its
+	 * maximum size. This ensures that key contents are never leaked via
+	 * implicit realloc() in the sshbuf code.
+	 */
+	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
+		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
+		dontmax = 1;
+	}
+	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
+	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
+		return r;
 	for (;;) {
 		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)","{'deleted_lines': ['\tint r;'], 'added_lines': ['\tint r, dontmax = 0;', '\t/*', '\t * Pre-allocate the buffer used for the key contents and clamp its', '\t * maximum size. This ensures that key contents are never leaked via', '\t * implicit realloc() in the sshbuf code.', '\t */', '\tif ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {', '\t\tst.st_size = 64*1024; /* 64k should be enough for anyone :) */', '\t\tdontmax = 1;', '\t}', '\tif ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||', '\t    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))', '\t\treturn r;']}",True,"authfile.c in sshd in OpenSSH before 7.4 does not properly consider the effects of realloc on buffer contents, which might allow local users to obtain sensitive private-key information by leveraging access to a privilege-separated child process.",5.5,MEDIUM,1,valid,2016-11-25T23:24:45Z,1
CVE-2016-9576,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Don't feed anything but regular iovec's to blk_rq_map_user_iov

In theory we could map other things, but there's a reason that function
is called ""user_iov"".  Using anything else (like splice can do) just
confuses it.

Reported-and-tested-by: Johannes Thumshirn <jthumshirn@suse.de>
Cc: Al Viro <viro@ZenIV.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",a0ac402cfcdc904f9772e1762b3fda112dcc56a0,https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0,block/blk-map.c,blk_rq_map_user_iov,"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
struct rq_map_data *map_data,
const struct iov_iter *iter, gfp_t gfp_mask)
{
bool copy = false;
unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
struct bio *bio = NULL;
struct iov_iter i;
int ret;
if (map_data)
copy = true;
else if (iov_iter_alignment(iter) & align)
copy = true;
else if (queue_virt_boundary(q))
copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);
i = *iter;
do {
ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
if (ret)
goto unmap_rq;
if (!bio)
bio = rq->bio;
} while (iov_iter_count(&i));
if (!bio_flagged(bio, BIO_USER_MAPPED))
rq->cmd_flags |= REQ_COPY_USER;
return 0;
unmap_rq:
__blk_rq_unmap_user(bio);
rq->bio = NULL;
return -EINVAL;
}","int blk_rq_map_user_iov(struct request_queue *VAR_0, struct request *VAR_1,
struct rq_map_data *VAR_2,
const struct iov_iter *VAR_3, gfp_t VAR_4)
{
bool VAR_5 = false;
unsigned long VAR_6 = VAR_0->dma_pad_mask | queue_dma_alignment(VAR_0);
struct bio *bio = NULL;
struct iov_iter VAR_7;
int VAR_8;
if (VAR_2)
VAR_5 = true;
else if (iov_iter_alignment(VAR_3) & VAR_6)
VAR_5 = true;
else if (queue_virt_boundary(VAR_0))
VAR_5 = queue_virt_boundary(VAR_0) & iov_iter_gap_alignment(VAR_3);
VAR_7 = *VAR_3;
do {
VAR_8 =__blk_rq_map_user_iov(VAR_1, VAR_2, &VAR_7, VAR_4, VAR_5);
if (VAR_8)
goto unmap_rq;
if (!bio)
bio = VAR_1->bio;
} while (iov_iter_count(&VAR_7));
if (!bio_flagged(bio, VAR_9))
VAR_1->cmd_flags |= VAR_10;
return 0;
unmap_rq:
__blk_rq_unmap_user(bio);
VAR_1->bio = NULL;
return -VAR_11;
}",torvalds/linux/a0ac402cfcdc904f9772e1762b3fda112dcc56a0/blk-map.c/vul/before/0.json,"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
			struct rq_map_data *map_data,
			const struct iov_iter *iter, gfp_t gfp_mask)
{
	bool copy = false;
	unsigned long align = q->dma_pad_mask | queue_dma_alignment(q);
	struct bio *bio = NULL;
	struct iov_iter i;
	int ret;

	if (!iter_is_iovec(iter))
		goto fail;

	if (map_data)
		copy = true;
	else if (iov_iter_alignment(iter) & align)
		copy = true;
	else if (queue_virt_boundary(q))
		copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);

	i = *iter;
	do {
		ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);
		if (ret)
			goto unmap_rq;
		if (!bio)
			bio = rq->bio;
	} while (iov_iter_count(&i));

	if (!bio_flagged(bio, BIO_USER_MAPPED))
		rq->cmd_flags |= REQ_COPY_USER;
	return 0;

unmap_rq:
	__blk_rq_unmap_user(bio);
fail:
	rq->bio = NULL;
	return -EINVAL;
}","int blk_rq_map_user_iov(struct request_queue *VAR_0, struct request *VAR_1,
			struct rq_map_data *VAR_2,
			const struct iov_iter *VAR_3, gfp_t VAR_4)
{
	bool VAR_5 = false;
	unsigned long VAR_6 = VAR_0->dma_pad_mask | queue_dma_alignment(VAR_0);
	struct bio *bio = NULL;
	struct iov_iter VAR_7;
	int VAR_8;

	if (!iter_is_iovec(VAR_3))
		goto fail;

	if (VAR_2)
		VAR_5 = true;
	else if (iov_iter_alignment(VAR_3) & VAR_6)
		VAR_5 = true;
	else if (queue_virt_boundary(VAR_0))
		VAR_5 = queue_virt_boundary(VAR_0) & iov_iter_gap_alignment(VAR_3);

	VAR_7 = *VAR_3;
	do {
		VAR_8 =__blk_rq_map_user_iov(VAR_1, VAR_2, &VAR_7, VAR_4, VAR_5);
		if (VAR_8)
			goto unmap_rq;
		if (!bio)
			bio = VAR_1->bio;
	} while (iov_iter_count(&VAR_7));

	if (!bio_flagged(bio, VAR_9))
		VAR_1->cmd_flags |= VAR_10;
	return 0;

unmap_rq:
	__blk_rq_unmap_user(bio);
fail:
	VAR_1->bio = NULL;
	return -VAR_11;
}",torvalds/linux/a0ac402cfcdc904f9772e1762b3fda112dcc56a0/blk-map.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,9 @@
 	struct bio *bio = NULL;
 	struct iov_iter i;
 	int ret;
+
+	if (!iter_is_iovec(iter))
+		goto fail;
 
 	if (map_data)
 		copy = true;
@@ -30,6 +33,7 @@
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
+fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }","{'deleted_lines': [], 'added_lines': ['', '\tif (!iter_is_iovec(iter))', '\t\tgoto fail;', 'fail:']}",True,"The blk_rq_map_user_iov function in block/blk-map.c in the Linux kernel before 4.8.14 does not properly restrict the type of iterator, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device.",7.8,HIGH,2,valid,2016-12-07T00:18:14Z,1
CVE-2016-10010,['CWE-264'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,openbsd/src,disable Unix-domain socket forwarding when privsep is disabled,c76fac666ea038753294f2ac94d310f8adece9ce,https://github.com/openbsd/src/commit/c76fac666ea038753294f2ac94d310f8adece9ce,usr.bin/ssh/serverloop.c,server_request_direct_streamlocal,"static Channel *
server_request_direct_streamlocal(void)
{
Channel *c = NULL;
char *target, *originator;
u_short originator_port;
target = packet_get_string(NULL);
originator = packet_get_string(NULL);
originator_port = packet_get_int();
packet_check_eom();
debug(""server_request_direct_streamlocal: originator %s port %d, target %s"",
originator, originator_port, target);
if ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&
!no_port_forwarding_flag && !options.disable_forwarding) {
c = channel_connect_to_path(target,
""direct-streamlocal@openssh.com"", ""direct-streamlocal"");
} else {
logit(""refused streamlocal port forward: ""
""originator %s port %d, target %s"",
originator, originator_port, target);
}
free(originator);
free(target);
return c;
}","static Channel *
server_request_direct_streamlocal(void)
{
Channel *VAR_0 = NULL;
char *VAR_1, *VAR_2;
u_short VAR_3;
VAR_1 = packet_get_string(NULL);
VAR_2 = packet_get_string(NULL);
VAR_3 = packet_get_int();
packet_check_eom();
debug(""server_request_direct_streamlocal: originator %s port %d, target %s"",
VAR_2, VAR_3, VAR_1);
if ((VAR_4.allow_streamlocal_forwarding & VAR_5) != 0 &&
!VAR_6 && !VAR_4.disable_forwarding) {
VAR_0 = channel_connect_to_path(VAR_1,
""direct-streamlocal@openssh.com"", ""direct-streamlocal"");
} else {
logit(""refused streamlocal port forward: ""
""originator %s port %d, target %s"",
VAR_2, VAR_3, VAR_1);
}
free(VAR_2);
free(VAR_1);
return VAR_0;
}",openbsd/src/c76fac666ea038753294f2ac94d310f8adece9ce/serverloop.c/vul/before/1.json,"static Channel *
server_request_direct_streamlocal(void)
{
	Channel *c = NULL;
	char *target, *originator;
	u_short originator_port;

	target = packet_get_string(NULL);
	originator = packet_get_string(NULL);
	originator_port = packet_get_int();
	packet_check_eom();

	debug(""server_request_direct_streamlocal: originator %s port %d, target %s"",
	    originator, originator_port, target);

	/* XXX fine grained permissions */
	if ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&
	    !no_port_forwarding_flag && !options.disable_forwarding &&
	    use_privsep) {
		c = channel_connect_to_path(target,
		    ""direct-streamlocal@openssh.com"", ""direct-streamlocal"");
	} else {
		logit(""refused streamlocal port forward: ""
		    ""originator %s port %d, target %s"",
		    originator, originator_port, target);
	}

	free(originator);
	free(target);

	return c;
}","static Channel *
server_request_direct_streamlocal(void)
{
	Channel *VAR_0 = NULL;
	char *VAR_1, *VAR_2;
	u_short VAR_3;

	VAR_1 = packet_get_string(NULL);
	VAR_2 = packet_get_string(NULL);
	VAR_3 = packet_get_int();
	packet_check_eom();

	debug(""server_request_direct_streamlocal: originator %s port %d, target %s"",
	    VAR_2, VAR_3, VAR_1);

	/* COMMENT_0 */
	if ((VAR_4.allow_streamlocal_forwarding & VAR_5) != 0 &&
	    !VAR_6 && !VAR_4.disable_forwarding &&
	    VAR_7) {
		VAR_0 = channel_connect_to_path(VAR_1,
		    ""direct-streamlocal@openssh.com"", ""direct-streamlocal"");
	} else {
		logit(""refused streamlocal port forward: ""
		    ""originator %s port %d, target %s"",
		    VAR_2, VAR_3, VAR_1);
	}

	free(VAR_2);
	free(VAR_1);

	return VAR_0;
}",openbsd/src/c76fac666ea038753294f2ac94d310f8adece9ce/serverloop.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -15,7 +15,8 @@
 
 	/* XXX fine grained permissions */
 	if ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&
-	    !no_port_forwarding_flag && !options.disable_forwarding) {
+	    !no_port_forwarding_flag && !options.disable_forwarding &&
+	    use_privsep) {
 		c = channel_connect_to_path(target,
 		    ""direct-streamlocal@openssh.com"", ""direct-streamlocal"");
 	} else {","{'deleted_lines': ['\t    !no_port_forwarding_flag && !options.disable_forwarding) {'], 'added_lines': ['\t    !no_port_forwarding_flag && !options.disable_forwarding &&', '\t    use_privsep) {']}",True,"sshd in OpenSSH before 7.4, when privilege separation is not used, creates forwarded Unix-domain sockets as root, which might allow local users to gain privileges via unspecified vectors, related to serverloop.c.",7.0,HIGH,2,valid,2016-12-14T00:36:34Z,1
CVE-2016-10010,['CWE-264'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,openbsd/src,disable Unix-domain socket forwarding when privsep is disabled,c76fac666ea038753294f2ac94d310f8adece9ce,https://github.com/openbsd/src/commit/c76fac666ea038753294f2ac94d310f8adece9ce,usr.bin/ssh/serverloop.c,server_input_global_request,"static int
server_input_global_request(int type, u_int32_t seq, void *ctxt)
{
char *rtype;
int want_reply;
int r, success = 0, allocated_listen_port = 0;
struct sshbuf *resp = NULL;
rtype = packet_get_string(NULL);
want_reply = packet_get_char();
debug(""server_input_global_request: rtype %s want_reply %d"", rtype, want_reply);
if (strcmp(rtype, ""tcpip-forward"") == 0) {
struct passwd *pw;
struct Forward fwd;
pw = the_authctxt->pw;
if (pw == NULL || !the_authctxt->valid)
fatal(""server_input_global_request: no/invalid user"");
memset(&fwd, 0, sizeof(fwd));
fwd.listen_host = packet_get_string(NULL);
fwd.listen_port = (u_short)packet_get_int();
debug(""server_input_global_request: tcpip-forward listen %s port %d"",
fwd.listen_host, fwd.listen_port);
if ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||
no_port_forwarding_flag || options.disable_forwarding ||
(!want_reply && fwd.listen_port == 0) ||
(fwd.listen_port != 0 &&
!bind_permitted(fwd.listen_port, pw->pw_uid))) {
success = 0;
packet_send_debug(""Server has disabled port forwarding."");
} else {
success = channel_setup_remote_fwd_listener(&fwd,
&allocated_listen_port, &options.fwd_opts);
}
free(fwd.listen_host);
if ((resp = sshbuf_new()) == NULL)
fatal(""%s: sshbuf_new"", __func__);
if (allocated_listen_port != 0 &&
(r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)
fatal(""%s: sshbuf_put_u32: %s"", __func__, ssh_err(r));
} else if (strcmp(rtype, ""cancel-tcpip-forward"") == 0) {
struct Forward fwd;
memset(&fwd, 0, sizeof(fwd));
fwd.listen_host = packet_get_string(NULL);
fwd.listen_port = (u_short)packet_get_int();
debug(""%s: cancel-tcpip-forward addr %s port %d"", __func__,
fwd.listen_host, fwd.listen_port);
success = channel_cancel_rport_listener(&fwd);
free(fwd.listen_host);
} else if (strcmp(rtype, ""streamlocal-forward@openssh.com"") == 0) {
struct Forward fwd;
memset(&fwd, 0, sizeof(fwd));
fwd.listen_path = packet_get_string(NULL);
debug(""server_input_global_request: streamlocal-forward listen path %s"",
fwd.listen_path);
if ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0
|| no_port_forwarding_flag || options.disable_forwarding) {
success = 0;
packet_send_debug(""Server has disabled port forwarding."");
} else {
success = channel_setup_remote_fwd_listener(
&fwd, NULL, &options.fwd_opts);
}
free(fwd.listen_path);
} else if (strcmp(rtype, ""cancel-streamlocal-forward@openssh.com"") == 0) {
struct Forward fwd;
memset(&fwd, 0, sizeof(fwd));
fwd.listen_path = packet_get_string(NULL);
debug(""%s: cancel-streamlocal-forward path %s"", __func__,
fwd.listen_path);
success = channel_cancel_rport_listener(&fwd);
free(fwd.listen_path);
} else if (strcmp(rtype, ""no-more-sessions@openssh.com"") == 0) {
no_more_sessions = 1;
success = 1;
} else if (strcmp(rtype, ""hostkeys-prove-00@openssh.com"") == 0) {
success = server_input_hostkeys_prove(&resp);
}
if (want_reply) {
packet_start(success ?
SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
if (success && resp != NULL)
ssh_packet_put_raw(active_state, sshbuf_ptr(resp),
sshbuf_len(resp));
packet_send();
packet_write_wait();
}
free(rtype);
sshbuf_free(resp);
return 0;
}","static int
server_input_global_request(int VAR_0, u_int32_t VAR_1, void *VAR_2)
{
char *VAR_3;
int VAR_4;
int VAR_5, VAR_6 = 0, VAR_7 = 0;
struct sshbuf *VAR_8 = NULL;
VAR_3 = packet_get_string(NULL);
VAR_4 = packet_get_char();
debug(""server_input_global_request: rtype %s want_reply %d"", VAR_3, VAR_4);
if (strcmp(VAR_3, ""tcpip-forward"") == 0) {
struct passwd *VAR_9;
struct Forward VAR_10;
VAR_9 = VAR_11->pw;
if (VAR_9 == NULL || !VAR_11->valid)
fatal(""server_input_global_request: no/invalid user"");
memset(&VAR_10, 0, sizeof(VAR_10));
VAR_10.listen_host = packet_get_string(NULL);
VAR_10.listen_port = (u_short)packet_get_int();
debug(""server_input_global_request: tcpip-forward listen %s port %d"",
VAR_10.listen_host, VAR_10.listen_port);
if ((VAR_12.allow_tcp_forwarding & VAR_13) == 0 ||
VAR_14 || VAR_12.disable_forwarding ||
(!VAR_4 && VAR_10.listen_port == 0) ||
(VAR_10.listen_port != 0 &&
!bind_permitted(VAR_10.listen_port, VAR_9->pw_uid))) {
VAR_6 = 0;
packet_send_debug(""Server has disabled port forwarding."");
} else {
VAR_6 = channel_setup_remote_fwd_listener(&VAR_10,
&VAR_7, &VAR_12.fwd_opts);
}
free(VAR_10.listen_host);
if ((VAR_8 = sshbuf_new()) == NULL)
fatal(""%s: sshbuf_new"", VAR_15);
if (VAR_7 != 0 &&
(VAR_5 = sshbuf_put_u32(VAR_8, VAR_7)) != 0)
fatal(""%s: sshbuf_put_u32: %s"", VAR_15, ssh_err(VAR_5));
} else if (strcmp(VAR_3, ""cancel-tcpip-forward"") == 0) {
struct Forward VAR_10;
memset(&VAR_10, 0, sizeof(VAR_10));
VAR_10.listen_host = packet_get_string(NULL);
VAR_10.listen_port = (u_short)packet_get_int();
debug(""%s: cancel-tcpip-forward addr %s port %d"", VAR_15,
VAR_10.listen_host, VAR_10.listen_port);
VAR_6 = channel_cancel_rport_listener(&VAR_10);
free(VAR_10.listen_host);
} else if (strcmp(VAR_3, ""streamlocal-forward@openssh.com"") == 0) {
struct Forward VAR_10;
memset(&VAR_10, 0, sizeof(VAR_10));
VAR_10.listen_path = packet_get_string(NULL);
debug(""server_input_global_request: streamlocal-forward listen path %s"",
VAR_10.listen_path);
if ((VAR_12.allow_streamlocal_forwarding & VAR_13) == 0
|| VAR_14 || VAR_12.disable_forwarding) {
VAR_6 = 0;
packet_send_debug(""Server has disabled port forwarding."");
} else {
VAR_6 = channel_setup_remote_fwd_listener(
&VAR_10, NULL, &VAR_12.fwd_opts);
}
free(VAR_10.listen_path);
} else if (strcmp(VAR_3, ""cancel-streamlocal-forward@openssh.com"") == 0) {
struct Forward VAR_10;
memset(&VAR_10, 0, sizeof(VAR_10));
VAR_10.listen_path = packet_get_string(NULL);
debug(""%s: cancel-streamlocal-forward path %s"", VAR_15,
VAR_10.listen_path);
VAR_6 = channel_cancel_rport_listener(&VAR_10);
free(VAR_10.listen_path);
} else if (strcmp(VAR_3, ""no-more-sessions@openssh.com"") == 0) {
VAR_16 = 1;
VAR_6 = 1;
} else if (strcmp(VAR_3, ""hostkeys-prove-00@openssh.com"") == 0) {
VAR_6 = server_input_hostkeys_prove(&VAR_8);
}
if (VAR_4) {
packet_start(VAR_6 ?
VAR_17 : VAR_18);
if (VAR_6 && VAR_8 != NULL)
ssh_packet_put_raw(VAR_19, sshbuf_ptr(VAR_8),
sshbuf_len(VAR_8));
packet_send();
packet_write_wait();
}
free(VAR_3);
sshbuf_free(VAR_8);
return 0;
}",openbsd/src/c76fac666ea038753294f2ac94d310f8adece9ce/serverloop.c/vul/before/0.json,"static int
server_input_global_request(int type, u_int32_t seq, void *ctxt)
{
	char *rtype;
	int want_reply;
	int r, success = 0, allocated_listen_port = 0;
	struct sshbuf *resp = NULL;

	rtype = packet_get_string(NULL);
	want_reply = packet_get_char();
	debug(""server_input_global_request: rtype %s want_reply %d"", rtype, want_reply);

	/* -R style forwarding */
	if (strcmp(rtype, ""tcpip-forward"") == 0) {
		struct passwd *pw;
		struct Forward fwd;

		pw = the_authctxt->pw;
		if (pw == NULL || !the_authctxt->valid)
			fatal(""server_input_global_request: no/invalid user"");
		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_host = packet_get_string(NULL);
		fwd.listen_port = (u_short)packet_get_int();
		debug(""server_input_global_request: tcpip-forward listen %s port %d"",
		    fwd.listen_host, fwd.listen_port);

		/* check permissions */
		if ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||
		    no_port_forwarding_flag || options.disable_forwarding ||
		    (!want_reply && fwd.listen_port == 0) ||
		    (fwd.listen_port != 0 &&
		     !bind_permitted(fwd.listen_port, pw->pw_uid))) {
			success = 0;
			packet_send_debug(""Server has disabled port forwarding."");
		} else {
			/* Start listening on the port */
			success = channel_setup_remote_fwd_listener(&fwd,
			    &allocated_listen_port, &options.fwd_opts);
		}
		free(fwd.listen_host);
		if ((resp = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new"", __func__);
		if (allocated_listen_port != 0 &&
		    (r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)
			fatal(""%s: sshbuf_put_u32: %s"", __func__, ssh_err(r));
	} else if (strcmp(rtype, ""cancel-tcpip-forward"") == 0) {
		struct Forward fwd;

		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_host = packet_get_string(NULL);
		fwd.listen_port = (u_short)packet_get_int();
		debug(""%s: cancel-tcpip-forward addr %s port %d"", __func__,
		    fwd.listen_host, fwd.listen_port);

		success = channel_cancel_rport_listener(&fwd);
		free(fwd.listen_host);
	} else if (strcmp(rtype, ""streamlocal-forward@openssh.com"") == 0) {
		struct Forward fwd;

		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_path = packet_get_string(NULL);
		debug(""server_input_global_request: streamlocal-forward listen path %s"",
		    fwd.listen_path);

		/* check permissions */
		if ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0
		    || no_port_forwarding_flag || options.disable_forwarding ||
		    !use_privsep) {
			success = 0;
			packet_send_debug(""Server has disabled port forwarding."");
		} else {
			/* Start listening on the socket */
			success = channel_setup_remote_fwd_listener(
			    &fwd, NULL, &options.fwd_opts);
		}
		free(fwd.listen_path);
	} else if (strcmp(rtype, ""cancel-streamlocal-forward@openssh.com"") == 0) {
		struct Forward fwd;

		memset(&fwd, 0, sizeof(fwd));
		fwd.listen_path = packet_get_string(NULL);
		debug(""%s: cancel-streamlocal-forward path %s"", __func__,
		    fwd.listen_path);

		success = channel_cancel_rport_listener(&fwd);
		free(fwd.listen_path);
	} else if (strcmp(rtype, ""no-more-sessions@openssh.com"") == 0) {
		no_more_sessions = 1;
		success = 1;
	} else if (strcmp(rtype, ""hostkeys-prove-00@openssh.com"") == 0) {
		success = server_input_hostkeys_prove(&resp);
	}
	if (want_reply) {
		packet_start(success ?
		    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);
		if (success && resp != NULL)
			ssh_packet_put_raw(active_state, sshbuf_ptr(resp),
			    sshbuf_len(resp));
		packet_send();
		packet_write_wait();
	}
	free(rtype);
	sshbuf_free(resp);
	return 0;
}","static int
server_input_global_request(int VAR_0, u_int32_t VAR_1, void *VAR_2)
{
	char *VAR_3;
	int VAR_4;
	int VAR_5, VAR_6 = 0, VAR_7 = 0;
	struct sshbuf *VAR_8 = NULL;

	VAR_3 = packet_get_string(NULL);
	VAR_4 = packet_get_char();
	debug(""server_input_global_request: rtype %s want_reply %d"", VAR_3, VAR_4);

	/* COMMENT_0 */
	if (strcmp(VAR_3, ""tcpip-forward"") == 0) {
		struct passwd *VAR_9;
		struct Forward VAR_10;

		VAR_9 = VAR_11->pw;
		if (VAR_9 == NULL || !VAR_11->valid)
			fatal(""server_input_global_request: no/invalid user"");
		memset(&VAR_10, 0, sizeof(VAR_10));
		VAR_10.listen_host = packet_get_string(NULL);
		VAR_10.listen_port = (u_short)packet_get_int();
		debug(""server_input_global_request: tcpip-forward listen %s port %d"",
		    VAR_10.listen_host, VAR_10.listen_port);

		/* COMMENT_1 */
		if ((VAR_12.allow_tcp_forwarding & VAR_13) == 0 ||
		    VAR_14 || VAR_12.disable_forwarding ||
		    (!VAR_4 && VAR_10.listen_port == 0) ||
		    (VAR_10.listen_port != 0 &&
		     !bind_permitted(VAR_10.listen_port, VAR_9->pw_uid))) {
			VAR_6 = 0;
			packet_send_debug(""Server has disabled port forwarding."");
		} else {
			/* COMMENT_2 */
			VAR_6 = channel_setup_remote_fwd_listener(&VAR_10,
			    &VAR_7, &VAR_12.fwd_opts);
		}
		free(VAR_10.listen_host);
		if ((VAR_8 = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new"", VAR_15);
		if (VAR_7 != 0 &&
		    (VAR_5 = sshbuf_put_u32(VAR_8, VAR_7)) != 0)
			fatal(""%s: sshbuf_put_u32: %s"", VAR_15, ssh_err(VAR_5));
	} else if (strcmp(VAR_3, ""cancel-tcpip-forward"") == 0) {
		struct Forward VAR_10;

		memset(&VAR_10, 0, sizeof(VAR_10));
		VAR_10.listen_host = packet_get_string(NULL);
		VAR_10.listen_port = (u_short)packet_get_int();
		debug(""%s: cancel-tcpip-forward addr %s port %d"", VAR_15,
		    VAR_10.listen_host, VAR_10.listen_port);

		VAR_6 = channel_cancel_rport_listener(&VAR_10);
		free(VAR_10.listen_host);
	} else if (strcmp(VAR_3, ""streamlocal-forward@openssh.com"") == 0) {
		struct Forward VAR_10;

		memset(&VAR_10, 0, sizeof(VAR_10));
		VAR_10.listen_path = packet_get_string(NULL);
		debug(""server_input_global_request: streamlocal-forward listen path %s"",
		    VAR_10.listen_path);

		/* COMMENT_1 */
		if ((VAR_12.allow_streamlocal_forwarding & VAR_13) == 0
		    || VAR_14 || VAR_12.disable_forwarding ||
		    !VAR_16) {
			VAR_6 = 0;
			packet_send_debug(""Server has disabled port forwarding."");
		} else {
			/* COMMENT_3 */
			VAR_6 = channel_setup_remote_fwd_listener(
			    &VAR_10, NULL, &VAR_12.fwd_opts);
		}
		free(VAR_10.listen_path);
	} else if (strcmp(VAR_3, ""cancel-streamlocal-forward@openssh.com"") == 0) {
		struct Forward VAR_10;

		memset(&VAR_10, 0, sizeof(VAR_10));
		VAR_10.listen_path = packet_get_string(NULL);
		debug(""%s: cancel-streamlocal-forward path %s"", VAR_15,
		    VAR_10.listen_path);

		VAR_6 = channel_cancel_rport_listener(&VAR_10);
		free(VAR_10.listen_path);
	} else if (strcmp(VAR_3, ""no-more-sessions@openssh.com"") == 0) {
		VAR_17 = 1;
		VAR_6 = 1;
	} else if (strcmp(VAR_3, ""hostkeys-prove-00@openssh.com"") == 0) {
		VAR_6 = server_input_hostkeys_prove(&VAR_8);
	}
	if (VAR_4) {
		packet_start(VAR_6 ?
		    VAR_18 : VAR_19);
		if (VAR_6 && VAR_8 != NULL)
			ssh_packet_put_raw(VAR_20, sshbuf_ptr(VAR_8),
			    sshbuf_len(VAR_8));
		packet_send();
		packet_write_wait();
	}
	free(VAR_3);
	sshbuf_free(VAR_8);
	return 0;
}",openbsd/src/c76fac666ea038753294f2ac94d310f8adece9ce/serverloop.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -64,7 +64,8 @@
 
 		/* check permissions */
 		if ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0
-		    || no_port_forwarding_flag || options.disable_forwarding) {
+		    || no_port_forwarding_flag || options.disable_forwarding ||
+		    !use_privsep) {
 			success = 0;
 			packet_send_debug(""Server has disabled port forwarding."");
 		} else {","{'deleted_lines': ['\t\t    || no_port_forwarding_flag || options.disable_forwarding) {'], 'added_lines': ['\t\t    || no_port_forwarding_flag || options.disable_forwarding ||', '\t\t    !use_privsep) {']}",True,"sshd in OpenSSH before 7.4, when privilege separation is not used, creates forwarded Unix-domain sockets as root, which might allow local users to gain privileges via unspecified vectors, related to serverloop.c.",7.0,HIGH,2,valid,2016-12-14T00:36:34Z,1
CVE-2016-10094,['CWE-189'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vadz/libtiff,"* tools/tiff2pdf.c: avoid potential heap-based overflow in
t2p_readwrite_pdf_image_tile().
Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2640",c7153361a4041260719b340f73f2f76,https://github.com/vadz/libtiff/commit/c7153361a4041260719b340f73f2f76b0969235c,tools/tiff2pdf.c,t2p_readwrite_pdf_image_tile,"tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){
uint16 edge=0;
tsize_t written=0;
unsigned char* buffer=NULL;
tsize_t bufferoffset=0;
unsigned char* samplebuffer=NULL;
tsize_t samplebufferoffset=0;
tsize_t read=0;
uint16 i=0;
ttile_t tilecount=0;
ttile_t septilecount=0;
tsize_t septilesize=0;
#ifdef JPEG_SUPPORT
unsigned char* jpt;
float* xfloatp;
uint32 xuint32=0;
#endif
if (t2p->t2p_error != T2P_ERR_OK)
return(0);
edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)
#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)
#endif
)
){
#ifdef CCITT_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_G4){
buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(buffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
TIFFReverseBits(buffer, t2p->tiff_datasize);
}
t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
_TIFFfree(buffer);
return(t2p->tiff_datasize);
}
#endif
#ifdef ZIP_SUPPORT
if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(buffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
TIFFReverseBits(buffer, t2p->tiff_datasize);
}
t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
_TIFFfree(buffer);
return(t2p->tiff_datasize);
}
#endif
#ifdef OJPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_OJPEG){
if(! t2p->pdf_ojpegdata){
TIFFError(TIFF2PDF_MODULE, 
""No support for OJPEG image %s with ""
""bad tables"", 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
buffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(buffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image, %s"", 
(unsigned long) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
if(edge!=0){
if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
buffer[7]=
(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;
buffer[8]=
(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;
}
if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
buffer[9]=
(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;
buffer[10]=
(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;
}
}
bufferoffset=t2p->pdf_ojpegdatalength;
bufferoffset+=TIFFReadRawTile(input, 
tile, 
(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
-1);
((unsigned char*)buffer)[bufferoffset++]=0xff;
((unsigned char*)buffer)[bufferoffset++]=0xd9;
t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
_TIFFfree(buffer);
return(bufferoffset);
}
#endif
#ifdef JPEG_SUPPORT
if(t2p->tiff_compression == COMPRESSION_JPEG){
unsigned char table_end[2];
uint32 count = 0;
buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(buffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate "" TIFF_SIZE_FORMAT "" bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(TIFF_SIZE_T) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
if (count >= 4) {
int retTIFFReadRawTile;
_TIFFmemcpy(buffer, jpt, count - 2);
bufferoffset += count - 2;
table_end[0] = buffer[bufferoffset-2];
table_end[1] = buffer[bufferoffset-1];
xuint32 = bufferoffset;
bufferoffset -= 2;
retTIFFReadRawTile= TIFFReadRawTile(
input, 
tile, 
(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
-1);
if( retTIFFReadRawTile < 0 )
{
_TIFFfree(buffer);
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
bufferoffset += retTIFFReadRawTile;
buffer[xuint32-2]=table_end[0];
buffer[xuint32-1]=table_end[1];
}
}
t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
_TIFFfree(buffer);
return(bufferoffset);
}
#endif
(void)0;
}
if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(buffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate %lu bytes of memory for ""
""t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
read = TIFFReadEncodedTile(
input, 
tile, 
(tdata_t) &buffer[bufferoffset], 
t2p->tiff_datasize);
if(read==-1){
TIFFError(TIFF2PDF_MODULE, 
""Error on decoding tile %u of %s"", 
tile, 
TIFFFileName(input));
_TIFFfree(buffer);
t2p->t2p_error=T2P_ERR_ERROR;
return(0);
}
} else {
if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
septilesize=TIFFTileSize(input);
septilecount=TIFFNumberOfTiles(input);
tilecount=septilecount/t2p->tiff_samplesperpixel;
buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(buffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(samplebuffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
samplebufferoffset=0;
for(i=0;i<t2p->tiff_samplesperpixel;i++){
read = 
TIFFReadEncodedTile(input, 
tile + i*tilecount, 
(tdata_t) &(samplebuffer[samplebufferoffset]), 
septilesize);
if(read==-1){
TIFFError(TIFF2PDF_MODULE, 
""Error on decoding tile %u of %s"", 
tile + i*tilecount, 
TIFFFileName(input));
_TIFFfree(samplebuffer);
_TIFFfree(buffer);
t2p->t2p_error=T2P_ERR_ERROR;
return(0);
}
samplebufferoffset+=read;
}
t2p_sample_planar_separate_to_contig(
t2p,
&(buffer[bufferoffset]),
samplebuffer, 
samplebufferoffset); 
bufferoffset+=samplebufferoffset;
_TIFFfree(samplebuffer);
}
if(buffer==NULL){
buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
if(buffer==NULL){
TIFFError(TIFF2PDF_MODULE, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) t2p->tiff_datasize, 
TIFFFileName(input));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
read = TIFFReadEncodedTile(
input, 
tile, 
(tdata_t) &buffer[bufferoffset], 
t2p->tiff_datasize);
if(read==-1){
TIFFError(TIFF2PDF_MODULE, 
""Error on decoding tile %u of %s"", 
tile, 
TIFFFileName(input));
_TIFFfree(buffer);
t2p->t2p_error=T2P_ERR_ERROR;
return(0);
}
}
if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
(tdata_t)buffer, 
t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
}
if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
(tdata_t)buffer, 
t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
}
if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
TIFFError(TIFF2PDF_MODULE, 
""No support for YCbCr to RGB in tile for %s"", 
TIFFFileName(input));
_TIFFfree(buffer);
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
(tdata_t)buffer, 
t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
}
}
if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){
t2p_tile_collapse_left(
buffer, 
TIFFTileRowSize(input),
t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,
t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, 
t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
}
t2p_disable(output);
TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
TIFFSetField(
output, 
TIFFTAG_IMAGEWIDTH, 
t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
} else {
TIFFSetField(
output, 
TIFFTAG_IMAGEWIDTH, 
t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
}
if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
TIFFSetField(
output, 
TIFFTAG_IMAGELENGTH, 
t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
TIFFSetField(
output, 
TIFFTAG_ROWSPERSTRIP, 
t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
} else {
TIFFSetField(
output, 
TIFFTAG_IMAGELENGTH, 
t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
TIFFSetField(
output, 
TIFFTAG_ROWSPERSTRIP, 
t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
}
TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
switch(t2p->pdf_compression){
case T2P_COMPRESS_NONE:
TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
break;
#ifdef CCITT_SUPPORT
case T2P_COMPRESS_G4:
TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
break;
#endif
#ifdef JPEG_SUPPORT
case T2P_COMPRESS_JPEG:
if (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
uint16 hor = 0, ver = 0;
if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {
if (hor != 0 && ver != 0) {
TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
}
}
if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
}
}
TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); 
if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
} else {
TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
}
}
if(t2p->pdf_colorspace & T2P_CS_GRAY){
(void)0;
}
if(t2p->pdf_colorspace & T2P_CS_CMYK){
(void)0;
}
if(t2p->pdf_defaultcompressionquality != 0){
TIFFSetField(output, 
TIFFTAG_JPEGQUALITY, 
t2p->pdf_defaultcompressionquality);
}
break;
#endif
#ifdef ZIP_SUPPORT
case T2P_COMPRESS_ZIP:
TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
if(t2p->pdf_defaultcompressionquality%100 != 0){
TIFFSetField(output, 
TIFFTAG_PREDICTOR, 
t2p->pdf_defaultcompressionquality % 100);
}
if(t2p->pdf_defaultcompressionquality/100 != 0){
TIFFSetField(output, 
TIFFTAG_ZIPQUALITY, 
(t2p->pdf_defaultcompressionquality / 100));
}
break;
#endif
default:
break;
}
t2p_enable(output);
t2p->outputwritten = 0;
bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,
TIFFStripSize(output)); 
if (buffer != NULL) {
_TIFFfree(buffer);
buffer = NULL;
}
if (bufferoffset == -1) {
TIFFError(TIFF2PDF_MODULE, 
""Error writing encoded tile to output PDF %s"", 
TIFFFileName(output));
t2p->t2p_error = T2P_ERR_ERROR;
return(0);
}
written = t2p->outputwritten;
return(written);
}","tsize_t t2p_readwrite_pdf_image_tile(T2P* VAR_0, TIFF* VAR_1, TIFF* VAR_2, ttile_t VAR_3){
uint16 VAR_4=0;
tsize_t VAR_5=0;
unsigned char* VAR_6=NULL;
tsize_t VAR_7=0;
unsigned char* VAR_8=NULL;
tsize_t VAR_9=0;
tsize_t VAR_10=0;
uint16 VAR_11=0;
ttile_t VAR_12=0;
ttile_t VAR_13=0;
tsize_t VAR_14=0;
#ifdef VAR_15
unsigned char* VAR_16;
float* VAR_17;
uint32 VAR_18=0;
#endif
if (VAR_0->t2p_error != VAR_19)
return(0);
VAR_4 |= t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3);
VAR_4 |= t2p_tile_is_bottom_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3);
if( (VAR_0->pdf_transcode == VAR_20) && ((VAR_4 == 0)
#if defined(VAR_15) || defined(VAR_21)
|| (VAR_0->pdf_compression == VAR_22)
#endif
)
){
#ifdef VAR_23
if(VAR_0->pdf_compression == VAR_24){
VAR_6= (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_6==NULL){
TIFFError(VAR_25, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
TIFFReadRawTile(VAR_1, VAR_3, (tdata_t) VAR_6, VAR_0->tiff_datasize);
if (VAR_0->tiff_fillorder==VAR_27){
TIFFReverseBits(VAR_6, VAR_0->tiff_datasize);
}
t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_0->tiff_datasize);
_TIFFfree(VAR_6);
return(VAR_0->tiff_datasize);
}
#endif
#ifdef VAR_28
if(VAR_0->pdf_compression == VAR_29){
VAR_6= (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_6==NULL){
TIFFError(VAR_25, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
TIFFReadRawTile(VAR_1, VAR_3, (tdata_t) VAR_6, VAR_0->tiff_datasize);
if (VAR_0->tiff_fillorder==VAR_27){
TIFFReverseBits(VAR_6, VAR_0->tiff_datasize);
}
t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_0->tiff_datasize);
_TIFFfree(VAR_6);
return(VAR_0->tiff_datasize);
}
#endif
#ifdef VAR_21
if(VAR_0->tiff_compression == VAR_30){
if(! VAR_0->pdf_ojpegdata){
TIFFError(VAR_25, 
""No support for OJPEG image %s with ""
""bad tables"", 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
VAR_6=(unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_6==NULL){
TIFFError(VAR_25, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image, %s"", 
(unsigned long) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
_TIFFmemcpy(VAR_6, VAR_0->pdf_ojpegdata, VAR_0->pdf_ojpegdatalength);
if(VAR_4!=0){
if(t2p_tile_is_bottom_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3)){
VAR_6[7]=
(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength >> 8) & 0xff;
VAR_6[8]=
(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength ) & 0xff;
}
if(t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3)){
VAR_6[9]=
(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth >> 8) & 0xff;
VAR_6[10]=
(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth ) & 0xff;
}
}
VAR_7=VAR_0->pdf_ojpegdatalength;
VAR_7+=TIFFReadRawTile(VAR_1, 
VAR_3, 
(tdata_t) &(((unsigned char*)VAR_6)[VAR_7]), 
-1);
((unsigned char*)VAR_6)[VAR_7++]=0xff;
((unsigned char*)VAR_6)[VAR_7++]=0xd9;
t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_7);
_TIFFfree(VAR_6);
return(VAR_7);
}
#endif
#ifdef VAR_15
if(VAR_0->tiff_compression == VAR_31){
unsigned char VAR_32[2];
uint32 VAR_33 = 0;
VAR_6= (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_6==NULL){
TIFFError(VAR_25, 
""Can't allocate "" VAR_34 "" bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(TIFF_SIZE_T) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
if(TIFFGetField(VAR_1, VAR_35, &VAR_33, &VAR_16) != 0) {
if (VAR_33 >= 4) {
int VAR_36;
_TIFFmemcpy(VAR_6, VAR_16, VAR_33 - 2);
VAR_7 += VAR_33 - 2;
VAR_32[0] = VAR_6[VAR_7-2];
VAR_32[1] = VAR_6[VAR_7-1];
VAR_18 = VAR_7;
VAR_7 -= 2;
VAR_36= TIFFReadRawTile(
VAR_1, 
VAR_3, 
(tdata_t) &(((unsigned char*)VAR_6)[VAR_7]), 
-1);
if( VAR_36 < 0 )
{
_TIFFfree(VAR_6);
VAR_0->t2p_error = VAR_26;
return(0);
}
VAR_7 += VAR_36;
VAR_6[VAR_18-2]=VAR_32[0];
VAR_6[VAR_18-1]=VAR_32[1];
}
}
t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_7);
_TIFFfree(VAR_6);
return(VAR_7);
}
#endif
(void)0;
}
if(VAR_0->pdf_sample==VAR_37){
VAR_6 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_6==NULL){
TIFFError(VAR_25, 
""Can't allocate %lu bytes of memory for ""
""t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
VAR_10 = TIFFReadEncodedTile(
VAR_1, 
VAR_3, 
(tdata_t) &VAR_6[VAR_7], 
VAR_0->tiff_datasize);
if(VAR_10==-1){
TIFFError(VAR_25, 
""Error on decoding tile %u of %s"", 
VAR_3, 
TIFFFileName(VAR_1));
_TIFFfree(VAR_6);
VAR_0->t2p_error=VAR_26;
return(0);
}
} else {
if(VAR_0->pdf_sample == VAR_38){
VAR_14=TIFFTileSize(VAR_1);
VAR_13=TIFFNumberOfTiles(VAR_1);
VAR_12=VAR_13/VAR_0->tiff_samplesperpixel;
VAR_6 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_6==NULL){
TIFFError(VAR_25, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
VAR_8 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_8==NULL){
TIFFError(VAR_25, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
VAR_9=0;
for(VAR_11=0;VAR_11<VAR_0->tiff_samplesperpixel;VAR_11++){
VAR_10 = 
TIFFReadEncodedTile(VAR_1, 
VAR_3 + VAR_11*VAR_12, 
(tdata_t) &(VAR_8[VAR_9]), 
VAR_14);
if(VAR_10==-1){
TIFFError(VAR_25, 
""Error on decoding tile %u of %s"", 
VAR_3 + VAR_11*VAR_12, 
TIFFFileName(VAR_1));
_TIFFfree(VAR_8);
_TIFFfree(VAR_6);
VAR_0->t2p_error=VAR_26;
return(0);
}
VAR_9+=VAR_10;
}
t2p_sample_planar_separate_to_contig(
VAR_0,
&(VAR_6[VAR_7]),
VAR_8, 
VAR_9); 
VAR_7+=VAR_9;
_TIFFfree(VAR_8);
}
if(VAR_6==NULL){
VAR_6 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
if(VAR_6==NULL){
TIFFError(VAR_25, 
""Can't allocate %lu bytes of memory ""
""for t2p_readwrite_pdf_image_tile, %s"", 
(unsigned long) VAR_0->tiff_datasize, 
TIFFFileName(VAR_1));
VAR_0->t2p_error = VAR_26;
return(0);
}
VAR_10 = TIFFReadEncodedTile(
VAR_1, 
VAR_3, 
(tdata_t) &VAR_6[VAR_7], 
VAR_0->tiff_datasize);
if(VAR_10==-1){
TIFFError(VAR_25, 
""Error on decoding tile %u of %s"", 
VAR_3, 
TIFFFileName(VAR_1));
_TIFFfree(VAR_6);
VAR_0->t2p_error=VAR_26;
return(0);
}
}
if(VAR_0->pdf_sample & VAR_39){
VAR_0->tiff_datasize=t2p_sample_rgba_to_rgb(
(tdata_t)VAR_6, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth
*VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
}
if(VAR_0->pdf_sample & VAR_40){
VAR_0->tiff_datasize=t2p_sample_rgbaa_to_rgb(
(tdata_t)VAR_6, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth
*VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
}
if(VAR_0->pdf_sample & VAR_41){
TIFFError(VAR_25, 
""No support for YCbCr to RGB in tile for %s"", 
TIFFFileName(VAR_1));
_TIFFfree(VAR_6);
VAR_0->t2p_error = VAR_26;
return(0);
}
if(VAR_0->pdf_sample & VAR_42){
VAR_0->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
(tdata_t)VAR_6, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth
*VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
}
}
if(t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3) != 0){
t2p_tile_collapse_left(
VAR_6, 
TIFFTileRowSize(VAR_1),
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth,
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
}
t2p_disable(VAR_2);
TIFFSetField(VAR_2, VAR_43, VAR_0->tiff_photometric);
TIFFSetField(VAR_2, VAR_44, VAR_0->tiff_bitspersample);
TIFFSetField(VAR_2, VAR_45, VAR_0->tiff_samplesperpixel);
if(t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3) == 0){
TIFFSetField(
VAR_2, 
VAR_46, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth);
} else {
TIFFSetField(
VAR_2, 
VAR_46, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth);
}
if(t2p_tile_is_bottom_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3) == 0){
TIFFSetField(
VAR_2, 
VAR_47, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
TIFFSetField(
VAR_2, 
VAR_48, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
} else {
TIFFSetField(
VAR_2, 
VAR_47, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength);
TIFFSetField(
VAR_2, 
VAR_48, 
VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength);
}
TIFFSetField(VAR_2, VAR_49, VAR_50);
TIFFSetField(VAR_2, VAR_51, VAR_52);
switch(VAR_0->pdf_compression){
case VAR_53:
TIFFSetField(VAR_2, VAR_54, VAR_55);
break;
#ifdef VAR_23
case VAR_24:
TIFFSetField(VAR_2, VAR_54, VAR_56);
break;
#endif
#ifdef VAR_15
case VAR_22:
if (VAR_0->tiff_photometric==VAR_57) {
uint16 VAR_58 = 0, VAR_59 = 0;
if (TIFFGetField(VAR_1, VAR_60, &VAR_58, &VAR_59)!=0) {
if (VAR_58 != 0 && VAR_59 != 0) {
TIFFSetField(VAR_2, VAR_60, VAR_58, VAR_59);
}
}
if(TIFFGetField(VAR_1, VAR_61, &VAR_17)!=0){
TIFFSetField(VAR_2, VAR_61, VAR_17);
}
}
TIFFSetField(VAR_2, VAR_54, VAR_31);
TIFFSetField(VAR_2, VAR_62, 0); 
if(VAR_0->pdf_colorspace & (VAR_63 | VAR_64)){
TIFFSetField(VAR_2, VAR_43, VAR_57);
if(VAR_0->tiff_photometric != VAR_57){
TIFFSetField(VAR_2, VAR_65, VAR_66);
} else {
TIFFSetField(VAR_2, VAR_65, VAR_67);
}
}
if(VAR_0->pdf_colorspace & VAR_68){
(void)0;
}
if(VAR_0->pdf_colorspace & VAR_69){
(void)0;
}
if(VAR_0->pdf_defaultcompressionquality != 0){
TIFFSetField(VAR_2, 
VAR_70, 
VAR_0->pdf_defaultcompressionquality);
}
break;
#endif
#ifdef VAR_28
case VAR_29:
TIFFSetField(VAR_2, VAR_54, VAR_71);
if(VAR_0->pdf_defaultcompressionquality%100 != 0){
TIFFSetField(VAR_2, 
VAR_72, 
VAR_0->pdf_defaultcompressionquality % 100);
}
if(VAR_0->pdf_defaultcompressionquality/100 != 0){
TIFFSetField(VAR_2, 
VAR_73, 
(VAR_0->pdf_defaultcompressionquality / 100));
}
break;
#endif
default:
break;
}
t2p_enable(VAR_2);
VAR_0->outputwritten = 0;
VAR_7 = TIFFWriteEncodedStrip(VAR_2, (tstrip_t) 0, VAR_6,
TIFFStripSize(VAR_2)); 
if (VAR_6 != NULL) {
_TIFFfree(VAR_6);
VAR_6 = NULL;
}
if (VAR_7 == -1) {
TIFFError(VAR_25, 
""Error writing encoded tile to output PDF %s"", 
TIFFFileName(VAR_2));
VAR_0->t2p_error = VAR_26;
return(0);
}
VAR_5 = VAR_0->outputwritten;
return(VAR_5);
}",vadz/libtiff/c7153361a4041260719b340f73f2f76/tiff2pdf.c/vul/before/0.json,"tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){

	uint16 edge=0;
	tsize_t written=0;
	unsigned char* buffer=NULL;
	tsize_t bufferoffset=0;
	unsigned char* samplebuffer=NULL;
	tsize_t samplebufferoffset=0;
	tsize_t read=0;
	uint16 i=0;
	ttile_t tilecount=0;
	/* tsize_t tilesize=0; */
	ttile_t septilecount=0;
	tsize_t septilesize=0;
#ifdef JPEG_SUPPORT
	unsigned char* jpt;
	float* xfloatp;
	uint32 xuint32=0;
#endif

	/* Fail if prior error (in particular, can't trust tiff_datasize) */
	if (t2p->t2p_error != T2P_ERR_OK)
		return(0);

	edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
	edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);

	if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)
#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
		|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)
#endif
	)
	){
#ifdef CCITT_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_G4){
			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
			if(buffer==NULL){
				TIFFError(TIFF2PDF_MODULE, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) t2p->tiff_datasize, 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
					TIFFReverseBits(buffer, t2p->tiff_datasize);
			}
			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
			_TIFFfree(buffer);
			return(t2p->tiff_datasize);
		}
#endif
#ifdef ZIP_SUPPORT
		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
			if(buffer==NULL){
				TIFFError(TIFF2PDF_MODULE, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) t2p->tiff_datasize, 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
					TIFFReverseBits(buffer, t2p->tiff_datasize);
			}
			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
			_TIFFfree(buffer);
			return(t2p->tiff_datasize);
		}
#endif
#ifdef OJPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_OJPEG){
			if(! t2p->pdf_ojpegdata){
				TIFFError(TIFF2PDF_MODULE, 
					""No support for OJPEG image %s with ""
                                        ""bad tables"", 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			buffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
			if(buffer==NULL){
				TIFFError(TIFF2PDF_MODULE, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image, %s"", 
					(unsigned long) t2p->tiff_datasize, 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
			if(edge!=0){
				if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
					buffer[7]=
						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;
					buffer[8]=
						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;
				}
				if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
					buffer[9]=
						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;
					buffer[10]=
						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;
				}
			}
			bufferoffset=t2p->pdf_ojpegdatalength;
			bufferoffset+=TIFFReadRawTile(input, 
					tile, 
					(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
					-1);
			((unsigned char*)buffer)[bufferoffset++]=0xff;
			((unsigned char*)buffer)[bufferoffset++]=0xd9;
			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
			_TIFFfree(buffer);
			return(bufferoffset);
		}
#endif
#ifdef JPEG_SUPPORT
		if(t2p->tiff_compression == COMPRESSION_JPEG){
			unsigned char table_end[2];
			uint32 count = 0;
			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
			if(buffer==NULL){
				TIFFError(TIFF2PDF_MODULE, 
					""Can't allocate "" TIFF_SIZE_FORMAT "" bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
                                          (TIFF_SIZE_T) t2p->tiff_datasize, 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
				if (count > 4) {
                                        int retTIFFReadRawTile;
                    /* Ignore EOI marker of JpegTables */
					_TIFFmemcpy(buffer, jpt, count - 2);
					bufferoffset += count - 2;
                    /* Store last 2 bytes of the JpegTables */
					table_end[0] = buffer[bufferoffset-2];
					table_end[1] = buffer[bufferoffset-1];
					xuint32 = bufferoffset;
                                        bufferoffset -= 2;
                                        retTIFFReadRawTile= TIFFReadRawTile(
						input, 
						tile, 
						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
						-1);
                                        if( retTIFFReadRawTile < 0 )
                                        {
                                            _TIFFfree(buffer);
                                            t2p->t2p_error = T2P_ERR_ERROR;
                                            return(0);
                                        }
					bufferoffset += retTIFFReadRawTile;
                    /* Overwrite SOI marker of image scan with previously */
                    /* saved end of JpegTables */
					buffer[xuint32-2]=table_end[0];
					buffer[xuint32-1]=table_end[1];
				}
			}
			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
			_TIFFfree(buffer);
			return(bufferoffset);
		}
#endif
		(void)0;
	}

	if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
		if(buffer==NULL){
			TIFFError(TIFF2PDF_MODULE, 
				""Can't allocate %lu bytes of memory for ""
                                ""t2p_readwrite_pdf_image_tile, %s"", 
				(unsigned long) t2p->tiff_datasize, 
				TIFFFileName(input));
			t2p->t2p_error = T2P_ERR_ERROR;
			return(0);
		}

		read = TIFFReadEncodedTile(
			input, 
			tile, 
			(tdata_t) &buffer[bufferoffset], 
			t2p->tiff_datasize);
		if(read==-1){
			TIFFError(TIFF2PDF_MODULE, 
				""Error on decoding tile %u of %s"", 
				tile, 
				TIFFFileName(input));
			_TIFFfree(buffer);
			t2p->t2p_error=T2P_ERR_ERROR;
			return(0);
		}

	} else {

		if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
			septilesize=TIFFTileSize(input);
			septilecount=TIFFNumberOfTiles(input);
			/* tilesize=septilesize*t2p->tiff_samplesperpixel; */
			tilecount=septilecount/t2p->tiff_samplesperpixel;
			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
			if(buffer==NULL){
				TIFFError(TIFF2PDF_MODULE, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) t2p->tiff_datasize, 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
			if(samplebuffer==NULL){
				TIFFError(TIFF2PDF_MODULE, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) t2p->tiff_datasize, 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			samplebufferoffset=0;
			for(i=0;i<t2p->tiff_samplesperpixel;i++){
				read = 
					TIFFReadEncodedTile(input, 
						tile + i*tilecount, 
						(tdata_t) &(samplebuffer[samplebufferoffset]), 
						septilesize);
				if(read==-1){
					TIFFError(TIFF2PDF_MODULE, 
						""Error on decoding tile %u of %s"", 
						tile + i*tilecount, 
						TIFFFileName(input));
						_TIFFfree(samplebuffer);
						_TIFFfree(buffer);
					t2p->t2p_error=T2P_ERR_ERROR;
					return(0);
				}
				samplebufferoffset+=read;
			}
			t2p_sample_planar_separate_to_contig(
				t2p,
				&(buffer[bufferoffset]),
				samplebuffer, 
				samplebufferoffset); 
			bufferoffset+=samplebufferoffset;
			_TIFFfree(samplebuffer);
		}

		if(buffer==NULL){
			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
			if(buffer==NULL){
				TIFFError(TIFF2PDF_MODULE, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) t2p->tiff_datasize, 
					TIFFFileName(input));
				t2p->t2p_error = T2P_ERR_ERROR;
				return(0);
			}
			read = TIFFReadEncodedTile(
				input, 
				tile, 
				(tdata_t) &buffer[bufferoffset], 
				t2p->tiff_datasize);
			if(read==-1){
				TIFFError(TIFF2PDF_MODULE, 
					""Error on decoding tile %u of %s"", 
					tile, 
					TIFFFileName(input));
				_TIFFfree(buffer);
				t2p->t2p_error=T2P_ERR_ERROR;
				return(0);
			}
		}

		if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
			t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
				(tdata_t)buffer, 
				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
		}

		if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
			t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
				(tdata_t)buffer, 
				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
		}

		if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
			TIFFError(TIFF2PDF_MODULE, 
				""No support for YCbCr to RGB in tile for %s"", 
				TIFFFileName(input));
			_TIFFfree(buffer);
			t2p->t2p_error = T2P_ERR_ERROR;
			return(0);
		}

		if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
			t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
				(tdata_t)buffer, 
				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
		}
	}

	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){
		t2p_tile_collapse_left(
			buffer, 
			TIFFTileRowSize(input),
			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,
			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, 
			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
	}


	t2p_disable(output);
	TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
	TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
	TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
		TIFFSetField(
			output, 
			TIFFTAG_IMAGEWIDTH, 
			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
	} else {
		TIFFSetField(
			output, 
			TIFFTAG_IMAGEWIDTH, 
			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
	}
	if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
		TIFFSetField(
			output, 
			TIFFTAG_IMAGELENGTH, 
			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
		TIFFSetField(
			output, 
			TIFFTAG_ROWSPERSTRIP, 
			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
	} else {
		TIFFSetField(
			output, 
			TIFFTAG_IMAGELENGTH, 
			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
		TIFFSetField(
			output, 
			TIFFTAG_ROWSPERSTRIP, 
			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
	}
	TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
	TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);

	switch(t2p->pdf_compression){
	case T2P_COMPRESS_NONE:
		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
		break;
#ifdef CCITT_SUPPORT
	case T2P_COMPRESS_G4:
		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
		break;
#endif
#ifdef JPEG_SUPPORT
	case T2P_COMPRESS_JPEG:
		if (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
			uint16 hor = 0, ver = 0;
			if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {
				if (hor != 0 && ver != 0) {
					TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
				}
			}
			if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
				TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
			}
		}
		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
		TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */
		if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
			TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
			} else {
				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
			}
		}
		if(t2p->pdf_colorspace & T2P_CS_GRAY){
			(void)0;
		}
		if(t2p->pdf_colorspace & T2P_CS_CMYK){
			(void)0;
		}
		if(t2p->pdf_defaultcompressionquality != 0){
			TIFFSetField(output, 
				TIFFTAG_JPEGQUALITY, 
				t2p->pdf_defaultcompressionquality);
		}
		break;
#endif
#ifdef ZIP_SUPPORT
	case T2P_COMPRESS_ZIP:
		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
		if(t2p->pdf_defaultcompressionquality%100 != 0){
			TIFFSetField(output, 
				TIFFTAG_PREDICTOR, 
				t2p->pdf_defaultcompressionquality % 100);
		}
		if(t2p->pdf_defaultcompressionquality/100 != 0){
			TIFFSetField(output, 
				TIFFTAG_ZIPQUALITY, 
				(t2p->pdf_defaultcompressionquality / 100));
		}
		break;
#endif
	default:
		break;
	}

	t2p_enable(output);
	t2p->outputwritten = 0;
	bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,
					     TIFFStripSize(output)); 
	if (buffer != NULL) {
		_TIFFfree(buffer);
		buffer = NULL;
	}
	if (bufferoffset == -1) {
		TIFFError(TIFF2PDF_MODULE, 
			  ""Error writing encoded tile to output PDF %s"", 
			  TIFFFileName(output));
		t2p->t2p_error = T2P_ERR_ERROR;
		return(0);
	}
	
	written = t2p->outputwritten;
	
	return(written);
}","tsize_t t2p_readwrite_pdf_image_tile(T2P* VAR_0, TIFF* VAR_1, TIFF* VAR_2, ttile_t VAR_3){

	uint16 VAR_4=0;
	tsize_t VAR_5=0;
	unsigned char* VAR_6=NULL;
	tsize_t VAR_7=0;
	unsigned char* VAR_8=NULL;
	tsize_t VAR_9=0;
	tsize_t VAR_10=0;
	uint16 VAR_11=0;
	ttile_t VAR_12=0;
	/* COMMENT_0 */
	ttile_t VAR_13=0;
	tsize_t VAR_14=0;
#ifdef VAR_15
	unsigned char* VAR_16;
	float* VAR_17;
	uint32 VAR_18=0;
#endif

	/* COMMENT_1 */
	if (VAR_0->t2p_error != VAR_19)
		return(0);

	VAR_4 |= t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3);
	VAR_4 |= t2p_tile_is_bottom_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3);

	if( (VAR_0->pdf_transcode == VAR_20) && ((VAR_4 == 0)
#if defined(VAR_15) || defined(VAR_21)
		|| (VAR_0->pdf_compression == VAR_22)
#endif
	)
	){
#ifdef VAR_23
		if(VAR_0->pdf_compression == VAR_24){
			VAR_6= (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
			if(VAR_6==NULL){
				TIFFError(VAR_25, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) VAR_0->tiff_datasize, 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			TIFFReadRawTile(VAR_1, VAR_3, (tdata_t) VAR_6, VAR_0->tiff_datasize);
			if (VAR_0->tiff_fillorder==VAR_27){
					TIFFReverseBits(VAR_6, VAR_0->tiff_datasize);
			}
			t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_0->tiff_datasize);
			_TIFFfree(VAR_6);
			return(VAR_0->tiff_datasize);
		}
#endif
#ifdef VAR_28
		if(VAR_0->pdf_compression == VAR_29){
			VAR_6= (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
			if(VAR_6==NULL){
				TIFFError(VAR_25, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) VAR_0->tiff_datasize, 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			TIFFReadRawTile(VAR_1, VAR_3, (tdata_t) VAR_6, VAR_0->tiff_datasize);
			if (VAR_0->tiff_fillorder==VAR_27){
					TIFFReverseBits(VAR_6, VAR_0->tiff_datasize);
			}
			t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_0->tiff_datasize);
			_TIFFfree(VAR_6);
			return(VAR_0->tiff_datasize);
		}
#endif
#ifdef VAR_21
		if(VAR_0->tiff_compression == VAR_30){
			if(! VAR_0->pdf_ojpegdata){
				TIFFError(VAR_25, 
					""No support for OJPEG image %s with ""
                                        ""bad tables"", 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			VAR_6=(unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
			if(VAR_6==NULL){
				TIFFError(VAR_25, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image, %s"", 
					(unsigned long) VAR_0->tiff_datasize, 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			_TIFFmemcpy(VAR_6, VAR_0->pdf_ojpegdata, VAR_0->pdf_ojpegdatalength);
			if(VAR_4!=0){
				if(t2p_tile_is_bottom_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3)){
					VAR_6[7]=
						(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength >> 8) & 0xff;
					VAR_6[8]=
						(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength ) & 0xff;
				}
				if(t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3)){
					VAR_6[9]=
						(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth >> 8) & 0xff;
					VAR_6[10]=
						(VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth ) & 0xff;
				}
			}
			VAR_7=VAR_0->pdf_ojpegdatalength;
			VAR_7+=TIFFReadRawTile(VAR_1, 
					VAR_3, 
					(tdata_t) &(((unsigned char*)VAR_6)[VAR_7]), 
					-1);
			((unsigned char*)VAR_6)[VAR_7++]=0xff;
			((unsigned char*)VAR_6)[VAR_7++]=0xd9;
			t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_7);
			_TIFFfree(VAR_6);
			return(VAR_7);
		}
#endif
#ifdef VAR_15
		if(VAR_0->tiff_compression == VAR_31){
			unsigned char VAR_32[2];
			uint32 VAR_33 = 0;
			VAR_6= (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
			if(VAR_6==NULL){
				TIFFError(VAR_25, 
					""Can't allocate "" VAR_34 "" bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
                                          (TIFF_SIZE_T) VAR_0->tiff_datasize, 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			if(TIFFGetField(VAR_1, VAR_35, &VAR_33, &VAR_16) != 0) {
				if (VAR_33 > 4) {
                                        int VAR_36;
                    /* COMMENT_2 */
					_TIFFmemcpy(VAR_6, VAR_16, VAR_33 - 2);
					VAR_7 += VAR_33 - 2;
                    /* COMMENT_3 */
					VAR_32[0] = VAR_6[VAR_7-2];
					VAR_32[1] = VAR_6[VAR_7-1];
					VAR_18 = VAR_7;
                                        VAR_7 -= 2;
                                        VAR_36= TIFFReadRawTile(
						VAR_1, 
						VAR_3, 
						(tdata_t) &(((unsigned char*)VAR_6)[VAR_7]), 
						-1);
                                        if( VAR_36 < 0 )
                                        {
                                            _TIFFfree(VAR_6);
                                            VAR_0->t2p_error = VAR_26;
                                            return(0);
                                        }
					VAR_7 += VAR_36;
                    /* COMMENT_4 */
                    /* COMMENT_5 */
					VAR_6[VAR_18-2]=VAR_32[0];
					VAR_6[VAR_18-1]=VAR_32[1];
				}
			}
			t2pWriteFile(VAR_2, (tdata_t) VAR_6, VAR_7);
			_TIFFfree(VAR_6);
			return(VAR_7);
		}
#endif
		(void)0;
	}

	if(VAR_0->pdf_sample==VAR_37){
		VAR_6 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
		if(VAR_6==NULL){
			TIFFError(VAR_25, 
				""Can't allocate %lu bytes of memory for ""
                                ""t2p_readwrite_pdf_image_tile, %s"", 
				(unsigned long) VAR_0->tiff_datasize, 
				TIFFFileName(VAR_1));
			VAR_0->t2p_error = VAR_26;
			return(0);
		}

		VAR_10 = TIFFReadEncodedTile(
			VAR_1, 
			VAR_3, 
			(tdata_t) &VAR_6[VAR_7], 
			VAR_0->tiff_datasize);
		if(VAR_10==-1){
			TIFFError(VAR_25, 
				""Error on decoding tile %u of %s"", 
				VAR_3, 
				TIFFFileName(VAR_1));
			_TIFFfree(VAR_6);
			VAR_0->t2p_error=VAR_26;
			return(0);
		}

	} else {

		if(VAR_0->pdf_sample == VAR_38){
			VAR_14=TIFFTileSize(VAR_1);
			VAR_13=TIFFNumberOfTiles(VAR_1);
			/* COMMENT_6 */
			VAR_12=VAR_13/VAR_0->tiff_samplesperpixel;
			VAR_6 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
			if(VAR_6==NULL){
				TIFFError(VAR_25, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) VAR_0->tiff_datasize, 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			VAR_8 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
			if(VAR_8==NULL){
				TIFFError(VAR_25, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) VAR_0->tiff_datasize, 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			VAR_9=0;
			for(VAR_11=0;VAR_11<VAR_0->tiff_samplesperpixel;VAR_11++){
				VAR_10 = 
					TIFFReadEncodedTile(VAR_1, 
						VAR_3 + VAR_11*VAR_12, 
						(tdata_t) &(VAR_8[VAR_9]), 
						VAR_14);
				if(VAR_10==-1){
					TIFFError(VAR_25, 
						""Error on decoding tile %u of %s"", 
						VAR_3 + VAR_11*VAR_12, 
						TIFFFileName(VAR_1));
						_TIFFfree(VAR_8);
						_TIFFfree(VAR_6);
					VAR_0->t2p_error=VAR_26;
					return(0);
				}
				VAR_9+=VAR_10;
			}
			t2p_sample_planar_separate_to_contig(
				VAR_0,
				&(VAR_6[VAR_7]),
				VAR_8, 
				VAR_9); 
			VAR_7+=VAR_9;
			_TIFFfree(VAR_8);
		}

		if(VAR_6==NULL){
			VAR_6 = (unsigned char*) _TIFFmalloc(VAR_0->tiff_datasize);
			if(VAR_6==NULL){
				TIFFError(VAR_25, 
					""Can't allocate %lu bytes of memory ""
                                        ""for t2p_readwrite_pdf_image_tile, %s"", 
					(unsigned long) VAR_0->tiff_datasize, 
					TIFFFileName(VAR_1));
				VAR_0->t2p_error = VAR_26;
				return(0);
			}
			VAR_10 = TIFFReadEncodedTile(
				VAR_1, 
				VAR_3, 
				(tdata_t) &VAR_6[VAR_7], 
				VAR_0->tiff_datasize);
			if(VAR_10==-1){
				TIFFError(VAR_25, 
					""Error on decoding tile %u of %s"", 
					VAR_3, 
					TIFFFileName(VAR_1));
				_TIFFfree(VAR_6);
				VAR_0->t2p_error=VAR_26;
				return(0);
			}
		}

		if(VAR_0->pdf_sample & VAR_39){
			VAR_0->tiff_datasize=t2p_sample_rgba_to_rgb(
				(tdata_t)VAR_6, 
				VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth
				*VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
		}

		if(VAR_0->pdf_sample & VAR_40){
			VAR_0->tiff_datasize=t2p_sample_rgbaa_to_rgb(
				(tdata_t)VAR_6, 
				VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth
				*VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
		}

		if(VAR_0->pdf_sample & VAR_41){
			TIFFError(VAR_25, 
				""No support for YCbCr to RGB in tile for %s"", 
				TIFFFileName(VAR_1));
			_TIFFfree(VAR_6);
			VAR_0->t2p_error = VAR_26;
			return(0);
		}

		if(VAR_0->pdf_sample & VAR_42){
			VAR_0->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
				(tdata_t)VAR_6, 
				VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth
				*VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
		}
	}

	if(t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3) != 0){
		t2p_tile_collapse_left(
			VAR_6, 
			TIFFTileRowSize(VAR_1),
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth,
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth, 
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
	}


	t2p_disable(VAR_2);
	TIFFSetField(VAR_2, VAR_43, VAR_0->tiff_photometric);
	TIFFSetField(VAR_2, VAR_44, VAR_0->tiff_bitspersample);
	TIFFSetField(VAR_2, VAR_45, VAR_0->tiff_samplesperpixel);
	if(t2p_tile_is_right_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3) == 0){
		TIFFSetField(
			VAR_2, 
			VAR_46, 
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilewidth);
	} else {
		TIFFSetField(
			VAR_2, 
			VAR_46, 
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilewidth);
	}
	if(t2p_tile_is_bottom_edge(VAR_0->tiff_tiles[VAR_0->pdf_page], VAR_3) == 0){
		TIFFSetField(
			VAR_2, 
			VAR_47, 
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
		TIFFSetField(
			VAR_2, 
			VAR_48, 
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_tilelength);
	} else {
		TIFFSetField(
			VAR_2, 
			VAR_47, 
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength);
		TIFFSetField(
			VAR_2, 
			VAR_48, 
			VAR_0->tiff_tiles[VAR_0->pdf_page].tiles_edgetilelength);
	}
	TIFFSetField(VAR_2, VAR_49, VAR_50);
	TIFFSetField(VAR_2, VAR_51, VAR_52);

	switch(VAR_0->pdf_compression){
	case VAR_53:
		TIFFSetField(VAR_2, VAR_54, VAR_55);
		break;
#ifdef VAR_23
	case VAR_24:
		TIFFSetField(VAR_2, VAR_54, VAR_56);
		break;
#endif
#ifdef VAR_15
	case VAR_22:
		if (VAR_0->tiff_photometric==VAR_57) {
			uint16 VAR_58 = 0, VAR_59 = 0;
			if (TIFFGetField(VAR_1, VAR_60, &VAR_58, &VAR_59)!=0) {
				if (VAR_58 != 0 && VAR_59 != 0) {
					TIFFSetField(VAR_2, VAR_60, VAR_58, VAR_59);
				}
			}
			if(TIFFGetField(VAR_1, VAR_61, &VAR_17)!=0){
				TIFFSetField(VAR_2, VAR_61, VAR_17);
			}
		}
		TIFFSetField(VAR_2, VAR_54, VAR_31);
		TIFFSetField(VAR_2, VAR_62, 0); /* COMMENT_7 */
		if(VAR_0->pdf_colorspace & (VAR_63 | VAR_64)){
			TIFFSetField(VAR_2, VAR_43, VAR_57);
			if(VAR_0->tiff_photometric != VAR_57){
				TIFFSetField(VAR_2, VAR_65, VAR_66);
			} else {
				TIFFSetField(VAR_2, VAR_65, VAR_67);
			}
		}
		if(VAR_0->pdf_colorspace & VAR_68){
			(void)0;
		}
		if(VAR_0->pdf_colorspace & VAR_69){
			(void)0;
		}
		if(VAR_0->pdf_defaultcompressionquality != 0){
			TIFFSetField(VAR_2, 
				VAR_70, 
				VAR_0->pdf_defaultcompressionquality);
		}
		break;
#endif
#ifdef VAR_28
	case VAR_29:
		TIFFSetField(VAR_2, VAR_54, VAR_71);
		if(VAR_0->pdf_defaultcompressionquality%100 != 0){
			TIFFSetField(VAR_2, 
				VAR_72, 
				VAR_0->pdf_defaultcompressionquality % 100);
		}
		if(VAR_0->pdf_defaultcompressionquality/100 != 0){
			TIFFSetField(VAR_2, 
				VAR_73, 
				(VAR_0->pdf_defaultcompressionquality / 100));
		}
		break;
#endif
	default:
		break;
	}

	t2p_enable(VAR_2);
	VAR_0->outputwritten = 0;
	VAR_7 = TIFFWriteEncodedStrip(VAR_2, (tstrip_t) 0, VAR_6,
					     TIFFStripSize(VAR_2)); 
	if (VAR_6 != NULL) {
		_TIFFfree(VAR_6);
		VAR_6 = NULL;
	}
	if (VAR_7 == -1) {
		TIFFError(VAR_25, 
			  ""Error writing encoded tile to output PDF %s"", 
			  TIFFFileName(VAR_2));
		VAR_0->t2p_error = VAR_26;
		return(0);
	}
	
	VAR_5 = VAR_0->outputwritten;
	
	return(VAR_5);
}",vadz/libtiff/c7153361a4041260719b340f73f2f76/tiff2pdf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -135,7 +135,7 @@
 				return(0);
 			}
 			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
-				if (count >= 4) {
+				if (count > 4) {
                                         int retTIFFReadRawTile;
                     /* Ignore EOI marker of JpegTables */
 					_TIFFmemcpy(buffer, jpt, count - 2);","{'deleted_lines': ['\t\t\t\tif (count >= 4) {'], 'added_lines': ['\t\t\t\tif (count > 4) {']}",True,Off-by-one error in the t2p_readwrite_pdf_image_tile function in tools/tiff2pdf.c in LibTIFF 4.0.7 allows remote attackers to have unspecified impact via a crafted image.,7.8,HIGH,2,valid,2016-12-20T17:28:17Z,1
CVE-2017-2583,['CWE-Other'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"KVM: x86: fix emulation of ""MOV SS, null selector""

This is CVE-2017-2583.  On Intel this causes a failed vmentry because
SS's type is neither 3 nor 7 (even though the manual says this check is
only done for usable SS, and the dmesg splat says that SS is unusable!).
On AMD it's worse: svm.c is confused and sets CPL to 0 in the vmcb.

The fix fabricates a data segment descriptor when SS is set to a null
selector, so that CPL and SS.DPL are set correctly in the VMCS/vmcb.
Furthermore, only allow setting SS to a NULL selector if SS.RPL < 3;
this in turn ensures CPL < 3 because RPL must be equal to CPL.

Thanks to Andy Lutomirski and Willy Tarreau for help in analyzing
the bug and deciphering the manuals.

Reported-by: Xiaohan Zhang <zhangxiaohan1@huawei.com>
Fixes: 79d5b4c3cd809c770d4bf9812635647016c56011
Cc: stable@nongnu.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",33ab91103b3415e12457e3104f0e4517ce12d0f3,https://github.com/torvalds/linux/commit/33ab91103b3415e12457e3104f0e4517ce12d0f3,arch/x86/kvm/emulate.c,__load_segment_descriptor,"static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
u16 selector, int seg, u8 cpl,
enum x86_transfer_type transfer,
struct desc_struct *desc)
{
struct desc_struct seg_desc, old_desc;
u8 dpl, rpl;
unsigned err_vec = GP_VECTOR;
u32 err_code = 0;
bool null_selector = !(selector & ~0x3); 
ulong desc_addr;
int ret;
u16 dummy;
u32 base3 = 0;
memset(&seg_desc, 0, sizeof seg_desc);
if (ctxt->mode == X86EMUL_MODE_REAL) {
ctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);
set_desc_base(&seg_desc, selector << 4);
goto load;
} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {
set_desc_base(&seg_desc, selector << 4);
set_desc_limit(&seg_desc, 0xffff);
seg_desc.type = 3;
seg_desc.p = 1;
seg_desc.s = 1;
seg_desc.dpl = 3;
goto load;
}
rpl = selector & 3;
if ((seg == VCPU_SREG_CS
|| (seg == VCPU_SREG_SS
&& (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))
|| seg == VCPU_SREG_TR)
&& null_selector)
goto exception;
if (seg == VCPU_SREG_TR && (selector & (1 << 2)))
goto exception;
if (null_selector) 
goto load;
ret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);
if (ret != X86EMUL_CONTINUE)
return ret;
err_code = selector & 0xfffc;
err_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :
GP_VECTOR;
if (seg <= VCPU_SREG_GS && !seg_desc.s) {
if (transfer == X86_TRANSFER_CALL_JMP)
return X86EMUL_UNHANDLEABLE;
goto exception;
}
if (!seg_desc.p) {
err_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;
goto exception;
}
dpl = seg_desc.dpl;
switch (seg) {
case VCPU_SREG_SS:
if (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)
goto exception;
break;
case VCPU_SREG_CS:
if (!(seg_desc.type & 8))
goto exception;
if (seg_desc.type & 4) {
if (dpl > cpl)
goto exception;
} else {
if (rpl > cpl || dpl != cpl)
goto exception;
}
if (seg_desc.d && seg_desc.l) {
u64 efer = 0;
ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);
if (efer & EFER_LMA)
goto exception;
}
selector = (selector & 0xfffc) | cpl;
break;
case VCPU_SREG_TR:
if (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))
goto exception;
old_desc = seg_desc;
seg_desc.type |= 2; 
ret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,
sizeof(seg_desc), &ctxt->exception);
if (ret != X86EMUL_CONTINUE)
return ret;
break;
case VCPU_SREG_LDTR:
if (seg_desc.s || seg_desc.type != 2)
goto exception;
break;
default: 
if ((seg_desc.type & 0xa) == 0x8 ||
(((seg_desc.type & 0xc) != 0xc) &&
(rpl > dpl && cpl > dpl)))
goto exception;
break;
}
if (seg_desc.s) {
if (!(seg_desc.type & 1)) {
seg_desc.type |= 1;
ret = write_segment_descriptor(ctxt, selector,
&seg_desc);
if (ret != X86EMUL_CONTINUE)
return ret;
}
} else if (ctxt->mode == X86EMUL_MODE_PROT64) {
ret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,
sizeof(base3), &ctxt->exception);
if (ret != X86EMUL_CONTINUE)
return ret;
if (is_noncanonical_address(get_desc_base(&seg_desc) |
((u64)base3 << 32)))
return emulate_gp(ctxt, 0);
}
load:
ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);
if (desc)
*desc = seg_desc;
return X86EMUL_CONTINUE;
exception:
return emulate_exception(ctxt, err_vec, err_code, true);
}","static int __load_segment_descriptor(struct x86_emulate_ctxt *VAR_0,
u16 VAR_1, int VAR_2, u8 VAR_3,
enum x86_transfer_type VAR_4,
struct desc_struct *VAR_5)
{
struct desc_struct VAR_6, VAR_7;
u8 VAR_8, VAR_9;
unsigned VAR_10 = VAR_11;
u32 VAR_12 = 0;
bool VAR_13 = !(VAR_1 & ~0x3); 
ulong VAR_14;
int VAR_15;
u16 VAR_16;
u32 VAR_17 = 0;
memset(&VAR_6, 0, sizeof VAR_6);
if (VAR_0->mode == VAR_18) {
VAR_0->ops->get_segment(VAR_0, &VAR_16, &VAR_6, NULL, VAR_2);
set_desc_base(&VAR_6, VAR_1 << 4);
goto load;
} else if (VAR_2 <= VAR_19 && VAR_0->mode == VAR_20) {
set_desc_base(&VAR_6, VAR_1 << 4);
set_desc_limit(&VAR_6, 0xffff);
VAR_6.type = 3;
VAR_6.p = 1;
VAR_6.s = 1;
VAR_6.dpl = 3;
goto load;
}
VAR_9 = VAR_1 & 3;
if ((VAR_2 == VAR_21
|| (VAR_2 == VAR_22
&& (VAR_0->mode != VAR_23 || VAR_9 != VAR_3))
|| VAR_2 == VAR_24)
&& VAR_13)
goto exception;
if (VAR_2 == VAR_24 && (VAR_1 & (1 << 2)))
goto exception;
if (VAR_13) 
goto load;
VAR_15 = read_segment_descriptor(VAR_0, VAR_1, &VAR_6, &VAR_14);
if (VAR_15 != VAR_25)
return VAR_15;
VAR_12 = VAR_1 & 0xfffc;
VAR_10 = (VAR_4 == VAR_26) ? VAR_27 :
VAR_11;
if (VAR_2 <= VAR_19 && !VAR_6.s) {
if (VAR_4 == VAR_28)
return VAR_29;
goto exception;
}
if (!VAR_6.p) {
VAR_10 = (VAR_2 == VAR_22) ? VAR_30 : VAR_31;
goto exception;
}
VAR_8 = VAR_6.dpl;
switch (VAR_2) {
case VAR_22:
if (VAR_9 != VAR_3 || (VAR_6.type & 0xa) != 0x2 || VAR_8 != VAR_3)
goto exception;
break;
case VAR_21:
if (!(VAR_6.type & 8))
goto exception;
if (VAR_6.type & 4) {
if (VAR_8 > VAR_3)
goto exception;
} else {
if (VAR_9 > VAR_3 || VAR_8 != VAR_3)
goto exception;
}
if (VAR_6.d && VAR_6.l) {
u64 VAR_32 = 0;
VAR_0->ops->get_msr(VAR_0, VAR_33, &VAR_32);
if (VAR_32 & VAR_34)
goto exception;
}
VAR_1 = (VAR_1 & 0xfffc) | VAR_3;
break;
case VAR_24:
if (VAR_6.s || (VAR_6.type != 1 && VAR_6.type != 9))
goto exception;
VAR_7 = VAR_6;
VAR_6.type |= 2; 
VAR_15 = VAR_0->ops->cmpxchg_emulated(VAR_0, VAR_14, &VAR_7, &VAR_6,
sizeof(VAR_6), &VAR_0->exception);
if (VAR_15 != VAR_25)
return VAR_15;
break;
case VAR_35:
if (VAR_6.s || VAR_6.type != 2)
goto exception;
break;
default: 
if ((VAR_6.type & 0xa) == 0x8 ||
(((VAR_6.type & 0xc) != 0xc) &&
(VAR_9 > VAR_8 && VAR_3 > VAR_8)))
goto exception;
break;
}
if (VAR_6.s) {
if (!(VAR_6.type & 1)) {
VAR_6.type |= 1;
VAR_15 = write_segment_descriptor(VAR_0, VAR_1,
&VAR_6);
if (VAR_15 != VAR_25)
return VAR_15;
}
} else if (VAR_0->mode == VAR_23) {
VAR_15 = VAR_0->ops->read_std(VAR_0, VAR_14+8, &VAR_17,
sizeof(VAR_17), &VAR_0->exception);
if (VAR_15 != VAR_25)
return VAR_15;
if (is_noncanonical_address(get_desc_base(&VAR_6) |
((u64)VAR_17 << 32)))
return emulate_gp(VAR_0, 0);
}
load:
VAR_0->ops->set_segment(VAR_0, VAR_1, &VAR_6, VAR_17, VAR_2);
if (VAR_5)
*VAR_5 = VAR_6;
return VAR_25;
exception:
return emulate_exception(VAR_0, VAR_10, VAR_12, true);
}",torvalds/linux/33ab91103b3415e12457e3104f0e4517ce12d0f3/emulate.c/vul/before/0.json,"static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
				     u16 selector, int seg, u8 cpl,
				     enum x86_transfer_type transfer,
				     struct desc_struct *desc)
{
	struct desc_struct seg_desc, old_desc;
	u8 dpl, rpl;
	unsigned err_vec = GP_VECTOR;
	u32 err_code = 0;
	bool null_selector = !(selector & ~0x3); /* 0000-0003 are null */
	ulong desc_addr;
	int ret;
	u16 dummy;
	u32 base3 = 0;

	memset(&seg_desc, 0, sizeof seg_desc);

	if (ctxt->mode == X86EMUL_MODE_REAL) {
		/* set real mode segment descriptor (keep limit etc. for
		 * unreal mode) */
		ctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);
		set_desc_base(&seg_desc, selector << 4);
		goto load;
	} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {
		/* VM86 needs a clean new segment descriptor */
		set_desc_base(&seg_desc, selector << 4);
		set_desc_limit(&seg_desc, 0xffff);
		seg_desc.type = 3;
		seg_desc.p = 1;
		seg_desc.s = 1;
		seg_desc.dpl = 3;
		goto load;
	}

	rpl = selector & 3;

	/* TR should be in GDT only */
	if (seg == VCPU_SREG_TR && (selector & (1 << 2)))
		goto exception;

	/* NULL selector is not valid for TR, CS and (except for long mode) SS */
	if (null_selector) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)
			goto exception;

		if (seg == VCPU_SREG_SS) {
			if (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)
				goto exception;

			/*
			 * ctxt->ops->set_segment expects the CPL to be in
			 * SS.DPL, so fake an expand-up 32-bit data segment.
			 */
			seg_desc.type = 3;
			seg_desc.p = 1;
			seg_desc.s = 1;
			seg_desc.dpl = cpl;
			seg_desc.d = 1;
			seg_desc.g = 1;
		}

		/* Skip all following checks */
		goto load;
	}

	ret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);
	if (ret != X86EMUL_CONTINUE)
		return ret;

	err_code = selector & 0xfffc;
	err_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :
							   GP_VECTOR;

	/* can't load system descriptor into segment selector */
	if (seg <= VCPU_SREG_GS && !seg_desc.s) {
		if (transfer == X86_TRANSFER_CALL_JMP)
			return X86EMUL_UNHANDLEABLE;
		goto exception;
	}

	if (!seg_desc.p) {
		err_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;
		goto exception;
	}

	dpl = seg_desc.dpl;

	switch (seg) {
	case VCPU_SREG_SS:
		/*
		 * segment is not a writable data segment or segment
		 * selector's RPL != CPL or segment selector's RPL != CPL
		 */
		if (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)
			goto exception;
		break;
	case VCPU_SREG_CS:
		if (!(seg_desc.type & 8))
			goto exception;

		if (seg_desc.type & 4) {
			/* conforming */
			if (dpl > cpl)
				goto exception;
		} else {
			/* nonconforming */
			if (rpl > cpl || dpl != cpl)
				goto exception;
		}
		/* in long-mode d/b must be clear if l is set */
		if (seg_desc.d && seg_desc.l) {
			u64 efer = 0;

			ctxt->ops->get_msr(ctxt, MSR_EFER, &efer);
			if (efer & EFER_LMA)
				goto exception;
		}

		/* CS(RPL) <- CPL */
		selector = (selector & 0xfffc) | cpl;
		break;
	case VCPU_SREG_TR:
		if (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))
			goto exception;
		old_desc = seg_desc;
		seg_desc.type |= 2; /* busy */
		ret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,
						  sizeof(seg_desc), &ctxt->exception);
		if (ret != X86EMUL_CONTINUE)
			return ret;
		break;
	case VCPU_SREG_LDTR:
		if (seg_desc.s || seg_desc.type != 2)
			goto exception;
		break;
	default: /*  DS, ES, FS, or GS */
		/*
		 * segment is not a data or readable code segment or
		 * ((segment is a data or nonconforming code segment)
		 * and (both RPL and CPL > DPL))
		 */
		if ((seg_desc.type & 0xa) == 0x8 ||
		    (((seg_desc.type & 0xc) != 0xc) &&
		     (rpl > dpl && cpl > dpl)))
			goto exception;
		break;
	}

	if (seg_desc.s) {
		/* mark segment as accessed */
		if (!(seg_desc.type & 1)) {
			seg_desc.type |= 1;
			ret = write_segment_descriptor(ctxt, selector,
						       &seg_desc);
			if (ret != X86EMUL_CONTINUE)
				return ret;
		}
	} else if (ctxt->mode == X86EMUL_MODE_PROT64) {
		ret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,
				sizeof(base3), &ctxt->exception);
		if (ret != X86EMUL_CONTINUE)
			return ret;
		if (is_noncanonical_address(get_desc_base(&seg_desc) |
					     ((u64)base3 << 32)))
			return emulate_gp(ctxt, 0);
	}
load:
	ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);
	if (desc)
		*desc = seg_desc;
	return X86EMUL_CONTINUE;
exception:
	return emulate_exception(ctxt, err_vec, err_code, true);
}","static int __load_segment_descriptor(struct x86_emulate_ctxt *VAR_0,
				     u16 VAR_1, int VAR_2, u8 VAR_3,
				     enum x86_transfer_type VAR_4,
				     struct desc_struct *VAR_5)
{
	struct desc_struct VAR_6, VAR_7;
	u8 VAR_8, VAR_9;
	unsigned VAR_10 = VAR_11;
	u32 VAR_12 = 0;
	bool VAR_13 = !(VAR_1 & ~0x3); /* COMMENT_0 */
	ulong VAR_14;
	int VAR_15;
	u16 VAR_16;
	u32 VAR_17 = 0;

	memset(&VAR_6, 0, sizeof VAR_6);

	if (VAR_0->mode == VAR_18) {
		/* COMMENT_1 */
                    
		VAR_0->ops->get_segment(VAR_0, &VAR_16, &VAR_6, NULL, VAR_2);
		set_desc_base(&VAR_6, VAR_1 << 4);
		goto load;
	} else if (VAR_2 <= VAR_19 && VAR_0->mode == VAR_20) {
		/* COMMENT_3 */
		set_desc_base(&VAR_6, VAR_1 << 4);
		set_desc_limit(&VAR_6, 0xffff);
		VAR_6.type = 3;
		VAR_6.p = 1;
		VAR_6.s = 1;
		VAR_6.dpl = 3;
		goto load;
	}

	VAR_9 = VAR_1 & 3;

	/* COMMENT_4 */
	if (VAR_2 == VAR_21 && (VAR_1 & (1 << 2)))
		goto exception;

	/* COMMENT_5 */
	if (VAR_13) {
		if (VAR_2 == VAR_22 || VAR_2 == VAR_21)
			goto exception;

		if (VAR_2 == VAR_23) {
			if (VAR_0->mode != VAR_24 || VAR_9 != VAR_3)
				goto exception;

			/* COMMENT_6 */
                                                     
                                                       
      
			VAR_6.type = 3;
			VAR_6.p = 1;
			VAR_6.s = 1;
			VAR_6.dpl = VAR_3;
			VAR_6.d = 1;
			VAR_6.g = 1;
		}

		/* COMMENT_10 */
		goto load;
	}

	VAR_15 = read_segment_descriptor(VAR_0, VAR_1, &VAR_6, &VAR_14);
	if (VAR_15 != VAR_25)
		return VAR_15;

	VAR_12 = VAR_1 & 0xfffc;
	VAR_10 = (VAR_4 == VAR_26) ? VAR_27 :
							   VAR_11;

	/* COMMENT_11 */
	if (VAR_2 <= VAR_19 && !VAR_6.s) {
		if (VAR_4 == VAR_28)
			return VAR_29;
		goto exception;
	}

	if (!VAR_6.p) {
		VAR_10 = (VAR_2 == VAR_23) ? VAR_30 : VAR_31;
		goto exception;
	}

	VAR_8 = VAR_6.dpl;

	switch (VAR_2) {
	case VAR_23:
		/* COMMENT_12 */
                                                      
                                                           
     
		if (VAR_9 != VAR_3 || (VAR_6.type & 0xa) != 0x2 || VAR_8 != VAR_3)
			goto exception;
		break;
	case VAR_22:
		if (!(VAR_6.type & 8))
			goto exception;

		if (VAR_6.type & 4) {
			/* COMMENT_16 */
			if (VAR_8 > VAR_3)
				goto exception;
		} else {
			/* COMMENT_17 */
			if (VAR_9 > VAR_3 || VAR_8 != VAR_3)
				goto exception;
		}
		/* COMMENT_18 */
		if (VAR_6.d && VAR_6.l) {
			u64 VAR_32 = 0;

			VAR_0->ops->get_msr(VAR_0, VAR_33, &VAR_32);
			if (VAR_32 & VAR_34)
				goto exception;
		}

		/* COMMENT_19 */
		VAR_1 = (VAR_1 & 0xfffc) | VAR_3;
		break;
	case VAR_21:
		if (VAR_6.s || (VAR_6.type != 1 && VAR_6.type != 9))
			goto exception;
		VAR_7 = VAR_6;
		VAR_6.type |= 2; /* COMMENT_20 */
		VAR_15 = VAR_0->ops->cmpxchg_emulated(VAR_0, VAR_14, &VAR_7, &VAR_6,
						  sizeof(VAR_6), &VAR_0->exception);
		if (VAR_15 != VAR_25)
			return VAR_15;
		break;
	case VAR_35:
		if (VAR_6.s || VAR_6.type != 2)
			goto exception;
		break;
	default: /* COMMENT_21 */
		/* COMMENT_22 */
                                                      
                                                       
                                  
     
		if ((VAR_6.type & 0xa) == 0x8 ||
		    (((VAR_6.type & 0xc) != 0xc) &&
		     (VAR_9 > VAR_8 && VAR_3 > VAR_8)))
			goto exception;
		break;
	}

	if (VAR_6.s) {
		/* COMMENT_27 */
		if (!(VAR_6.type & 1)) {
			VAR_6.type |= 1;
			VAR_15 = write_segment_descriptor(VAR_0, VAR_1,
						       &VAR_6);
			if (VAR_15 != VAR_25)
				return VAR_15;
		}
	} else if (VAR_0->mode == VAR_24) {
		VAR_15 = VAR_0->ops->read_std(VAR_0, VAR_14+8, &VAR_17,
				sizeof(VAR_17), &VAR_0->exception);
		if (VAR_15 != VAR_25)
			return VAR_15;
		if (is_noncanonical_address(get_desc_base(&VAR_6) |
					     ((u64)VAR_17 << 32)))
			return emulate_gp(VAR_0, 0);
	}
load:
	VAR_0->ops->set_segment(VAR_0, VAR_1, &VAR_6, VAR_17, VAR_2);
	if (VAR_5)
		*VAR_5 = VAR_6;
	return VAR_25;
exception:
	return emulate_exception(VAR_0, VAR_10, VAR_12, true);
}",torvalds/linux/33ab91103b3415e12457e3104f0e4517ce12d0f3/emulate.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,20 +34,34 @@
 
 	rpl = selector & 3;
 
-	/* NULL selector is not valid for TR, CS and SS (except for long mode) */
-	if ((seg == VCPU_SREG_CS
-	     || (seg == VCPU_SREG_SS
-		 && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))
-	     || seg == VCPU_SREG_TR)
-	    && null_selector)
-		goto exception;
-
 	/* TR should be in GDT only */
 	if (seg == VCPU_SREG_TR && (selector & (1 << 2)))
 		goto exception;
 
-	if (null_selector) /* for NULL selector skip all following checks */
+	/* NULL selector is not valid for TR, CS and (except for long mode) SS */
+	if (null_selector) {
+		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)
+			goto exception;
+
+		if (seg == VCPU_SREG_SS) {
+			if (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)
+				goto exception;
+
+			/*
+			 * ctxt->ops->set_segment expects the CPL to be in
+			 * SS.DPL, so fake an expand-up 32-bit data segment.
+			 */
+			seg_desc.type = 3;
+			seg_desc.p = 1;
+			seg_desc.s = 1;
+			seg_desc.dpl = cpl;
+			seg_desc.d = 1;
+			seg_desc.g = 1;
+		}
+
+		/* Skip all following checks */
 		goto load;
+	}
 
 	ret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);
 	if (ret != X86EMUL_CONTINUE)","{'deleted_lines': ['\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */', '\tif ((seg == VCPU_SREG_CS', '\t     || (seg == VCPU_SREG_SS', '\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))', '\t     || seg == VCPU_SREG_TR)', '\t    && null_selector)', '\t\tgoto exception;', '', '\tif (null_selector) /* for NULL selector skip all following checks */'], 'added_lines': ['\t/* NULL selector is not valid for TR, CS and (except for long mode) SS */', '\tif (null_selector) {', '\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)', '\t\t\tgoto exception;', '', '\t\tif (seg == VCPU_SREG_SS) {', '\t\t\tif (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)', '\t\t\t\tgoto exception;', '', '\t\t\t/*', '\t\t\t * ctxt->ops->set_segment expects the CPL to be in', '\t\t\t * SS.DPL, so fake an expand-up 32-bit data segment.', '\t\t\t */', '\t\t\tseg_desc.type = 3;', '\t\t\tseg_desc.p = 1;', '\t\t\tseg_desc.s = 1;', '\t\t\tseg_desc.dpl = cpl;', '\t\t\tseg_desc.d = 1;', '\t\t\tseg_desc.g = 1;', '\t\t}', '', '\t\t/* Skip all following checks */', '\t}']}",True,"The load_segment_descriptor implementation in arch/x86/kvm/emulate.c in the Linux kernel before 4.9.5 improperly emulates a ""MOV SS, NULL selector"" instruction, which allows guest OS users to cause a denial of service (guest OS crash) or gain guest OS privileges via a crafted application.",8.4,HIGH,2,valid,2017-01-12T14:02:32Z,1
CVE-2017-2583,['CWE-Other'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"KVM: x86: fix emulation of ""MOV SS, null selector""

This is CVE-2017-2583.  On Intel this causes a failed vmentry because
SS's type is neither 3 nor 7 (even though the manual says this check is
only done for usable SS, and the dmesg splat says that SS is unusable!).
On AMD it's worse: svm.c is confused and sets CPL to 0 in the vmcb.

The fix fabricates a data segment descriptor when SS is set to a null
selector, so that CPL and SS.DPL are set correctly in the VMCS/vmcb.
Furthermore, only allow setting SS to a NULL selector if SS.RPL < 3;
this in turn ensures CPL < 3 because RPL must be equal to CPL.

Thanks to Andy Lutomirski and Willy Tarreau for help in analyzing
the bug and deciphering the manuals.

Reported-by: Xiaohan Zhang <zhangxiaohan1@huawei.com>
Fixes: 79d5b4c3cd809c770d4bf9812635647016c56011
Cc: stable@nongnu.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",33ab91103b3415e12457e3104f0e4517ce12d0f3,https://github.com/torvalds/linux/commit/33ab91103b3415e12457e3104f0e4517ce12d0f3,arch/x86/kvm/emulate.c,load_segment_descriptor,"static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
u16 selector, int seg)
{
u8 cpl = ctxt->ops->cpl(ctxt);
return __load_segment_descriptor(ctxt, selector, seg, cpl,
X86_TRANSFER_NONE, NULL);
}","static int load_segment_descriptor(struct x86_emulate_ctxt *VAR_0,
u16 VAR_1, int VAR_2)
{
u8 VAR_3 = VAR_0->ops->cpl(VAR_0);
return __load_segment_descriptor(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_4, NULL);
}",torvalds/linux/33ab91103b3415e12457e3104f0e4517ce12d0f3/emulate.c/vul/before/1.json,"static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
				   u16 selector, int seg)
{
	u8 cpl = ctxt->ops->cpl(ctxt);

	/*
	 * None of MOV, POP and LSS can load a NULL selector in CPL=3, but
	 * they can load it at CPL<3 (Intel's manual says only LSS can,
	 * but it's wrong).
	 *
	 * However, the Intel manual says that putting IST=1/DPL=3 in
	 * an interrupt gate will result in SS=3 (the AMD manual instead
	 * says it doesn't), so allow SS=3 in __load_segment_descriptor
	 * and only forbid it here.
	 */
	if (seg == VCPU_SREG_SS && selector == 3 &&
	    ctxt->mode == X86EMUL_MODE_PROT64)
		return emulate_exception(ctxt, GP_VECTOR, 0, true);

	return __load_segment_descriptor(ctxt, selector, seg, cpl,
					 X86_TRANSFER_NONE, NULL);
}","static int load_segment_descriptor(struct x86_emulate_ctxt *VAR_0,
				   u16 VAR_1, int VAR_2)
{
	u8 VAR_3 = VAR_0->ops->cpl(VAR_0);

	/* COMMENT_0 */
                                                                   
                                                                
                    
   
                                                              
                                                                 
                                                                
                            
    
	if (VAR_2 == VAR_4 && VAR_1 == 3 &&
	    VAR_0->mode == VAR_5)
		return emulate_exception(VAR_0, VAR_6, 0, true);

	return __load_segment_descriptor(VAR_0, VAR_1, VAR_2, VAR_3,
					 VAR_7, NULL);
}",torvalds/linux/33ab91103b3415e12457e3104f0e4517ce12d0f3/emulate.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,21 @@
 				   u16 selector, int seg)
 {
 	u8 cpl = ctxt->ops->cpl(ctxt);
+
+	/*
+	 * None of MOV, POP and LSS can load a NULL selector in CPL=3, but
+	 * they can load it at CPL<3 (Intel's manual says only LSS can,
+	 * but it's wrong).
+	 *
+	 * However, the Intel manual says that putting IST=1/DPL=3 in
+	 * an interrupt gate will result in SS=3 (the AMD manual instead
+	 * says it doesn't), so allow SS=3 in __load_segment_descriptor
+	 * and only forbid it here.
+	 */
+	if (seg == VCPU_SREG_SS && selector == 3 &&
+	    ctxt->mode == X86EMUL_MODE_PROT64)
+		return emulate_exception(ctxt, GP_VECTOR, 0, true);
+
 	return __load_segment_descriptor(ctxt, selector, seg, cpl,
 					 X86_TRANSFER_NONE, NULL);
 }","{'deleted_lines': [], 'added_lines': ['', '\t/*', '\t * None of MOV, POP and LSS can load a NULL selector in CPL=3, but', ""\t * they can load it at CPL<3 (Intel's manual says only LSS can,"", ""\t * but it's wrong)."", '\t *', '\t * However, the Intel manual says that putting IST=1/DPL=3 in', '\t * an interrupt gate will result in SS=3 (the AMD manual instead', ""\t * says it doesn't), so allow SS=3 in __load_segment_descriptor"", '\t * and only forbid it here.', '\t */', '\tif (seg == VCPU_SREG_SS && selector == 3 &&', '\t    ctxt->mode == X86EMUL_MODE_PROT64)', '\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);', '']}",True,"The load_segment_descriptor implementation in arch/x86/kvm/emulate.c in the Linux kernel before 4.9.5 improperly emulates a ""MOV SS, NULL selector"" instruction, which allows guest OS users to cause a denial of service (guest OS crash) or gain guest OS privileges via a crafted application.",8.4,HIGH,2,valid,2017-01-12T14:02:32Z,1
CVE-2017-5577,['CWE-388'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"drm/vc4: Return -EINVAL on the overflow checks failing.

By failing to set the errno, we'd continue on to trying to set up the
RCL, and then oops on trying to dereference the tile_bo that binning
validation should have set up.

Reported-by: Ingo Molnar <mingo@kernel.org>
Signed-off-by: Eric Anholt <eric@anholt.net>
Fixes: d5b1a78a772f (""drm/vc4: Add support for drawing 3D frames."")",6b8ac63847bc2f958dd93c09edc941a0118992d9,https://github.com/torvalds/linux/commit/6b8ac63847bc2f958dd93c09edc941a0118992d9,drivers/gpu/drm/vc4/vc4_gem.c,vc4_get_bcl,"static int
vc4_get_bcl(struct drm_device *dev, struct vc4_exec_info *exec)
{
struct drm_vc4_submit_cl *args = exec->args;
void *temp = NULL;
void *bin;
int ret = 0;
uint32_t bin_offset = 0;
uint32_t shader_rec_offset = roundup(bin_offset + args->bin_cl_size,
16);
uint32_t uniforms_offset = shader_rec_offset + args->shader_rec_size;
uint32_t exec_size = uniforms_offset + args->uniforms_size;
uint32_t temp_size = exec_size + (sizeof(struct vc4_shader_state) *
args->shader_rec_count);
struct vc4_bo *bo;
if (shader_rec_offset < args->bin_cl_size ||
uniforms_offset < shader_rec_offset ||
exec_size < uniforms_offset ||
args->shader_rec_count >= (UINT_MAX /
sizeof(struct vc4_shader_state)) ||
temp_size < exec_size) {
DRM_ERROR(""overflow in exec arguments\n"");
goto fail;
}
temp = drm_malloc_ab(temp_size, 1);
if (!temp) {
DRM_ERROR(""Failed to allocate storage for copying ""
""in bin/render CLs.\n"");
ret = -ENOMEM;
goto fail;
}
bin = temp + bin_offset;
exec->shader_rec_u = temp + shader_rec_offset;
exec->uniforms_u = temp + uniforms_offset;
exec->shader_state = temp + exec_size;
exec->shader_state_size = args->shader_rec_count;
if (copy_from_user(bin,
(void __user *)(uintptr_t)args->bin_cl,
args->bin_cl_size)) {
ret = -EFAULT;
goto fail;
}
if (copy_from_user(exec->shader_rec_u,
(void __user *)(uintptr_t)args->shader_rec,
args->shader_rec_size)) {
ret = -EFAULT;
goto fail;
}
if (copy_from_user(exec->uniforms_u,
(void __user *)(uintptr_t)args->uniforms,
args->uniforms_size)) {
ret = -EFAULT;
goto fail;
}
bo = vc4_bo_create(dev, exec_size, true);
if (IS_ERR(bo)) {
DRM_ERROR(""Couldn't allocate BO for binning\n"");
ret = PTR_ERR(bo);
goto fail;
}
exec->exec_bo = &bo->base;
list_add_tail(&to_vc4_bo(&exec->exec_bo->base)->unref_head,
&exec->unref_list);
exec->ct0ca = exec->exec_bo->paddr + bin_offset;
exec->bin_u = bin;
exec->shader_rec_v = exec->exec_bo->vaddr + shader_rec_offset;
exec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;
exec->shader_rec_size = args->shader_rec_size;
exec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;
exec->uniforms_p = exec->exec_bo->paddr + uniforms_offset;
exec->uniforms_size = args->uniforms_size;
ret = vc4_validate_bin_cl(dev,
exec->exec_bo->vaddr + bin_offset,
bin,
exec);
if (ret)
goto fail;
ret = vc4_validate_shader_recs(dev, exec);
if (ret)
goto fail;
ret = vc4_wait_for_seqno(dev, exec->bin_dep_seqno, ~0ull, true);
fail:
drm_free_large(temp);
return ret;
}","static int
vc4_get_bcl(struct drm_device *VAR_0, struct vc4_exec_info *VAR_1)
{
struct drm_vc4_submit_cl *VAR_2 = VAR_1->args;
void *VAR_3 = NULL;
void *VAR_4;
int VAR_5 = 0;
uint32_t VAR_6 = 0;
uint32_t VAR_7 = roundup(VAR_6 + VAR_2->bin_cl_size,
16);
uint32_t VAR_8 = VAR_7 + VAR_2->shader_rec_size;
uint32_t VAR_9 = VAR_8 + VAR_2->uniforms_size;
uint32_t VAR_10 = VAR_9 + (sizeof(struct vc4_shader_state) *
VAR_2->shader_rec_count);
struct vc4_bo *VAR_11;
if (VAR_7 < VAR_2->bin_cl_size ||
VAR_8 < VAR_7 ||
VAR_9 < VAR_8 ||
VAR_2->shader_rec_count >= (VAR_12 /
sizeof(struct vc4_shader_state)) ||
VAR_10 < VAR_9) {
DRM_ERROR(""overflow in exec arguments\n"");
goto fail;
}
VAR_3 = drm_malloc_ab(VAR_10, 1);
if (!VAR_3) {
DRM_ERROR(""Failed to allocate storage for copying ""
""in bin/render CLs.\n"");
VAR_5 = -VAR_13;
goto fail;
}
VAR_4 = VAR_3 + VAR_6;
VAR_1->shader_rec_u = VAR_3 + VAR_7;
VAR_1->uniforms_u = VAR_3 + VAR_8;
VAR_1->shader_state = VAR_3 + VAR_9;
VAR_1->shader_state_size = VAR_2->shader_rec_count;
if (copy_from_user(VAR_4,
(void __user *)(uintptr_t)VAR_2->bin_cl,
VAR_2->bin_cl_size)) {
VAR_5 = -VAR_14;
goto fail;
}
if (copy_from_user(VAR_1->shader_rec_u,
(void __user *)(uintptr_t)VAR_2->shader_rec,
VAR_2->shader_rec_size)) {
VAR_5 = -VAR_14;
goto fail;
}
if (copy_from_user(VAR_1->uniforms_u,
(void __user *)(uintptr_t)VAR_2->uniforms,
VAR_2->uniforms_size)) {
VAR_5 = -VAR_14;
goto fail;
}
VAR_11 = vc4_bo_create(VAR_0, VAR_9, true);
if (IS_ERR(VAR_11)) {
DRM_ERROR(""Couldn't allocate BO for binning\n"");
VAR_5 = PTR_ERR(VAR_11);
goto fail;
}
VAR_1->exec_bo = &VAR_11->base;
list_add_tail(&to_vc4_bo(&VAR_1->exec_bo->base)->unref_head,
&VAR_1->unref_list);
VAR_1->ct0ca = VAR_1->exec_bo->paddr + VAR_6;
VAR_1->bin_u = VAR_4;
VAR_1->shader_rec_v = VAR_1->exec_bo->vaddr + VAR_7;
VAR_1->shader_rec_p = VAR_1->exec_bo->paddr + VAR_7;
VAR_1->shader_rec_size = VAR_2->shader_rec_size;
VAR_1->uniforms_v = VAR_1->exec_bo->vaddr + VAR_8;
VAR_1->uniforms_p = VAR_1->exec_bo->paddr + VAR_8;
VAR_1->uniforms_size = VAR_2->uniforms_size;
VAR_5 = vc4_validate_bin_cl(VAR_0,
VAR_1->exec_bo->vaddr + VAR_6,
VAR_4,
VAR_1);
if (VAR_5)
goto fail;
VAR_5 = vc4_validate_shader_recs(VAR_0, VAR_1);
if (VAR_5)
goto fail;
VAR_5 = vc4_wait_for_seqno(VAR_0, VAR_1->bin_dep_seqno, ~0ull, true);
fail:
drm_free_large(VAR_3);
return VAR_5;
}",torvalds/linux/6b8ac63847bc2f958dd93c09edc941a0118992d9/vc4_gem.c/vul/before/0.json,"static int
vc4_get_bcl(struct drm_device *dev, struct vc4_exec_info *exec)
{
	struct drm_vc4_submit_cl *args = exec->args;
	void *temp = NULL;
	void *bin;
	int ret = 0;
	uint32_t bin_offset = 0;
	uint32_t shader_rec_offset = roundup(bin_offset + args->bin_cl_size,
					     16);
	uint32_t uniforms_offset = shader_rec_offset + args->shader_rec_size;
	uint32_t exec_size = uniforms_offset + args->uniforms_size;
	uint32_t temp_size = exec_size + (sizeof(struct vc4_shader_state) *
					  args->shader_rec_count);
	struct vc4_bo *bo;

	if (shader_rec_offset < args->bin_cl_size ||
	    uniforms_offset < shader_rec_offset ||
	    exec_size < uniforms_offset ||
	    args->shader_rec_count >= (UINT_MAX /
					  sizeof(struct vc4_shader_state)) ||
	    temp_size < exec_size) {
		DRM_ERROR(""overflow in exec arguments\n"");
		ret = -EINVAL;
		goto fail;
	}

	/* Allocate space where we'll store the copied in user command lists
	 * and shader records.
	 *
	 * We don't just copy directly into the BOs because we need to
	 * read the contents back for validation, and I think the
	 * bo->vaddr is uncached access.
	 */
	temp = drm_malloc_ab(temp_size, 1);
	if (!temp) {
		DRM_ERROR(""Failed to allocate storage for copying ""
			  ""in bin/render CLs.\n"");
		ret = -ENOMEM;
		goto fail;
	}
	bin = temp + bin_offset;
	exec->shader_rec_u = temp + shader_rec_offset;
	exec->uniforms_u = temp + uniforms_offset;
	exec->shader_state = temp + exec_size;
	exec->shader_state_size = args->shader_rec_count;

	if (copy_from_user(bin,
			   (void __user *)(uintptr_t)args->bin_cl,
			   args->bin_cl_size)) {
		ret = -EFAULT;
		goto fail;
	}

	if (copy_from_user(exec->shader_rec_u,
			   (void __user *)(uintptr_t)args->shader_rec,
			   args->shader_rec_size)) {
		ret = -EFAULT;
		goto fail;
	}

	if (copy_from_user(exec->uniforms_u,
			   (void __user *)(uintptr_t)args->uniforms,
			   args->uniforms_size)) {
		ret = -EFAULT;
		goto fail;
	}

	bo = vc4_bo_create(dev, exec_size, true);
	if (IS_ERR(bo)) {
		DRM_ERROR(""Couldn't allocate BO for binning\n"");
		ret = PTR_ERR(bo);
		goto fail;
	}
	exec->exec_bo = &bo->base;

	list_add_tail(&to_vc4_bo(&exec->exec_bo->base)->unref_head,
		      &exec->unref_list);

	exec->ct0ca = exec->exec_bo->paddr + bin_offset;

	exec->bin_u = bin;

	exec->shader_rec_v = exec->exec_bo->vaddr + shader_rec_offset;
	exec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;
	exec->shader_rec_size = args->shader_rec_size;

	exec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;
	exec->uniforms_p = exec->exec_bo->paddr + uniforms_offset;
	exec->uniforms_size = args->uniforms_size;

	ret = vc4_validate_bin_cl(dev,
				  exec->exec_bo->vaddr + bin_offset,
				  bin,
				  exec);
	if (ret)
		goto fail;

	ret = vc4_validate_shader_recs(dev, exec);
	if (ret)
		goto fail;

	/* Block waiting on any previous rendering into the CS's VBO,
	 * IB, or textures, so that pixels are actually written by the
	 * time we try to read them.
	 */
	ret = vc4_wait_for_seqno(dev, exec->bin_dep_seqno, ~0ull, true);

fail:
	drm_free_large(temp);
	return ret;
}","static int
vc4_get_bcl(struct drm_device *VAR_0, struct vc4_exec_info *VAR_1)
{
	struct drm_vc4_submit_cl *VAR_2 = VAR_1->args;
	void *VAR_3 = NULL;
	void *VAR_4;
	int VAR_5 = 0;
	uint32_t VAR_6 = 0;
	uint32_t VAR_7 = roundup(VAR_6 + VAR_2->bin_cl_size,
					     16);
	uint32_t VAR_8 = VAR_7 + VAR_2->shader_rec_size;
	uint32_t VAR_9 = VAR_8 + VAR_2->uniforms_size;
	uint32_t VAR_10 = VAR_9 + (sizeof(struct vc4_shader_state) *
					  VAR_2->shader_rec_count);
	struct vc4_bo *VAR_11;

	if (VAR_7 < VAR_2->bin_cl_size ||
	    VAR_8 < VAR_7 ||
	    VAR_9 < VAR_8 ||
	    VAR_2->shader_rec_count >= (VAR_12 /
					  sizeof(struct vc4_shader_state)) ||
	    VAR_10 < VAR_9) {
		DRM_ERROR(""overflow in exec arguments\n"");
		VAR_5 = -VAR_13;
		goto fail;
	}

	/* COMMENT_0 */
                       
   
                                                               
                                                          
                                 
    
	VAR_3 = drm_malloc_ab(VAR_10, 1);
	if (!VAR_3) {
		DRM_ERROR(""Failed to allocate storage for copying ""
			  ""in bin/render CLs.\n"");
		VAR_5 = -VAR_14;
		goto fail;
	}
	VAR_4 = VAR_3 + VAR_6;
	VAR_1->shader_rec_u = VAR_3 + VAR_7;
	VAR_1->uniforms_u = VAR_3 + VAR_8;
	VAR_1->shader_state = VAR_3 + VAR_9;
	VAR_1->shader_state_size = VAR_2->shader_rec_count;

	if (copy_from_user(VAR_4,
			   (void __user *)(uintptr_t)VAR_2->bin_cl,
			   VAR_2->bin_cl_size)) {
		VAR_5 = -VAR_15;
		goto fail;
	}

	if (copy_from_user(VAR_1->shader_rec_u,
			   (void __user *)(uintptr_t)VAR_2->shader_rec,
			   VAR_2->shader_rec_size)) {
		VAR_5 = -VAR_15;
		goto fail;
	}

	if (copy_from_user(VAR_1->uniforms_u,
			   (void __user *)(uintptr_t)VAR_2->uniforms,
			   VAR_2->uniforms_size)) {
		VAR_5 = -VAR_15;
		goto fail;
	}

	VAR_11 = vc4_bo_create(VAR_0, VAR_9, true);
	if (IS_ERR(VAR_11)) {
		DRM_ERROR(""Couldn't allocate BO for binning\n"");
		VAR_5 = PTR_ERR(VAR_11);
		goto fail;
	}
	VAR_1->exec_bo = &VAR_11->base;

	list_add_tail(&to_vc4_bo(&VAR_1->exec_bo->base)->unref_head,
		      &VAR_1->unref_list);

	VAR_1->ct0ca = VAR_1->exec_bo->paddr + VAR_6;

	VAR_1->bin_u = VAR_4;

	VAR_1->shader_rec_v = VAR_1->exec_bo->vaddr + VAR_7;
	VAR_1->shader_rec_p = VAR_1->exec_bo->paddr + VAR_7;
	VAR_1->shader_rec_size = VAR_2->shader_rec_size;

	VAR_1->uniforms_v = VAR_1->exec_bo->vaddr + VAR_8;
	VAR_1->uniforms_p = VAR_1->exec_bo->paddr + VAR_8;
	VAR_1->uniforms_size = VAR_2->uniforms_size;

	VAR_5 = vc4_validate_bin_cl(VAR_0,
				  VAR_1->exec_bo->vaddr + VAR_6,
				  VAR_4,
				  VAR_1);
	if (VAR_5)
		goto fail;

	VAR_5 = vc4_validate_shader_recs(VAR_0, VAR_1);
	if (VAR_5)
		goto fail;

	/* COMMENT_7 */
                                                               
                             
    
	VAR_5 = vc4_wait_for_seqno(VAR_0, VAR_1->bin_dep_seqno, ~0ull, true);

fail:
	drm_free_large(VAR_3);
	return VAR_5;
}",torvalds/linux/6b8ac63847bc2f958dd93c09edc941a0118992d9/vc4_gem.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,7 @@
 					  sizeof(struct vc4_shader_state)) ||
 	    temp_size < exec_size) {
 		DRM_ERROR(""overflow in exec arguments\n"");
+		ret = -EINVAL;
 		goto fail;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\tret = -EINVAL;']}",True,"The vc4_get_bcl function in drivers/gpu/drm/vc4/vc4_gem.c in the VideoCore DRM driver in the Linux kernel before 4.9.7 does not set an errno value upon certain overflow detections, which allows local users to cause a denial of service (incorrect pointer dereference and OOPS) via inconsistent size values in a VC4_SUBMIT_CL ioctl call.",5.5,MEDIUM,1,valid,2017-01-17T10:58:06Z,1
CVE-2016-10210,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,libyara/re_lexer.c,yyinput,"static int yyinput (yyscan_t yyscanner)
#else
static int input  (yyscan_t yyscanner)
#endif
{
int c;
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
*yyg->yy_c_buf_p = yyg->yy_hold_char;
if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
{
if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
*yyg->yy_c_buf_p = '\0';
else
{ 
yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
++yyg->yy_c_buf_p;
switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_LAST_MATCH:
re_yyrestart(yyin ,yyscanner);
case EOB_ACT_END_OF_FILE:
{
if ( re_yywrap(yyscanner ) )
return EOF;
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
#ifdef __cplusplus
return yyinput(yyscanner);
#else
return input(yyscanner);
#endif
}
case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
break;
}
}
}
c = *(unsigned char *) yyg->yy_c_buf_p;
*yyg->yy_c_buf_p = '\0';
yyg->yy_hold_char = *++yyg->yy_c_buf_p;
if ( c == '\n' )
do{ yylineno++;
yycolumn=0;
}while(0)
;
return c;
}","static int yyinput (yyscan_t VAR_0)
#else
static int VAR_1  (yyscan_t VAR_0)
#endif
{
int VAR_2;
struct yyguts_t * VAR_3 = (struct yyguts_t*)VAR_0;
*VAR_3->yy_c_buf_p = VAR_3->yy_hold_char;
if ( *VAR_3->yy_c_buf_p == VAR_4 )
{
if ( VAR_3->yy_c_buf_p < &VAR_5->yy_ch_buf[VAR_3->yy_n_chars] )
*VAR_3->yy_c_buf_p = '\0';
else
{ 
yy_size_t VAR_6 = VAR_3->yy_c_buf_p - VAR_3->yytext_ptr;
++VAR_3->yy_c_buf_p;
switch ( yy_get_next_buffer( VAR_0 ) )
{
case VAR_7:
re_yyrestart(VAR_8 ,VAR_0);
case VAR_9:
{
if ( re_yywrap(VAR_0 ) )
return VAR_10;
if ( ! VAR_3->yy_did_buffer_switch_on_eof )
VAR_11;
#ifdef VAR_12
return yyinput(VAR_0);
#else
return VAR_1(VAR_0);
#endif
}
case VAR_13:
VAR_3->yy_c_buf_p = VAR_3->yytext_ptr + VAR_6;
break;
}
}
}
VAR_2 = *(unsigned char *) VAR_3->yy_c_buf_p;
*VAR_3->yy_c_buf_p = '\0';
VAR_3->yy_hold_char = *++VAR_3->yy_c_buf_p;
if ( VAR_2 == '\n' )
do{ VAR_14++;
VAR_15=0;
}while(0)
;
return VAR_2;
}",,"static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
			++yyg->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					re_yyrestart(yyin ,yyscanner);

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( re_yywrap(yyscanner ) )
						return EOF;

					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
	yyg->yy_hold_char = *++yyg->yy_c_buf_p;

	if ( c == '\n' )
		
    do{ yylineno++;
        yycolumn=0;
    }while(0)
;

	return c;
}","static int yyinput (yyscan_t VAR_0)
#else
    static int VAR_1  (yyscan_t VAR_0)
#endif

{
	int VAR_2;
    struct yyguts_t * VAR_3 = (struct yyguts_t*)VAR_0;

	*VAR_3->yy_c_buf_p = VAR_3->yy_hold_char;

	if ( *VAR_3->yy_c_buf_p == VAR_4 )
		{
		/* COMMENT_0 */
                                                            
                                                             
     
		if ( VAR_3->yy_c_buf_p < &VAR_5->yy_ch_buf[VAR_3->yy_n_chars] )
			/* COMMENT_4 */
			*VAR_3->yy_c_buf_p = '\0';

		else
			{ /* COMMENT_5 */
			yy_size_t VAR_6 = VAR_3->yy_c_buf_p - VAR_3->yytext_ptr;
			++VAR_3->yy_c_buf_p;

			switch ( yy_get_next_buffer( VAR_0 ) )
				{
				case VAR_7:
					/* COMMENT_6 */
                                     
                                       
                                     
                                     
                                        
                                         
                               
        

					/* COMMENT_15 */
					re_yyrestart(VAR_8 ,VAR_0);

					/* COMMENT_16 */

				case VAR_9:
					{
					if ( re_yywrap(VAR_0 ) )
						return VAR_10;

					if ( ! VAR_3->yy_did_buffer_switch_on_eof )
						VAR_11;
#ifdef VAR_12
					return yyinput(VAR_0);
#else
					return VAR_1(VAR_0);
#endif
					}

				case VAR_13:
					VAR_3->yy_c_buf_p = VAR_3->yytext_ptr + VAR_6;
					break;
				}
			}
		}

	VAR_2 = *(unsigned char *) VAR_3->yy_c_buf_p;	/* COMMENT_17 */
	*VAR_3->yy_c_buf_p = '\0';	/* COMMENT_18 */
	VAR_3->yy_hold_char = *++VAR_3->yy_c_buf_p;

	if ( VAR_2 == '\n' )
		
    do{ VAR_14++;
        VAR_15=0;
    }while(0)
;

	return VAR_2;
}",,"--- func_before
+++ func_after
@@ -68,7 +68,7 @@
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
-		   
+		
     do{ yylineno++;
         yycolumn=0;
     }while(0)","{'deleted_lines': ['\t\t   '], 'added_lines': ['\t\t']}",True,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,7.5,HIGH,2,valid,2017-01-17T16:07:02Z,1
CVE-2016-10210,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,libyara/re_lexer.c,read_escaped_char,"int read_escaped_char(
yyscan_t yyscanner,
uint8_t* escaped_char)
{
char text[4] = {0, 0, 0, 0};
text[0] = '\\';
text[1] = RE_YY_INPUT(yyscanner);
if (text[1] == EOF)
return 0;
if (text[1] == 'x')
{
text[2] = RE_YY_INPUT(yyscanner);
if (text[2] == EOF)
return 0;
text[3] = RE_YY_INPUT(yyscanner);
if (text[3] == EOF)
return 0;
}
*escaped_char = escaped_char_value(text);
return 1;
}","int read_escaped_char(
yyscan_t VAR_0,
uint8_t* VAR_1)
{
char VAR_2[4] = {0, 0, 0, 0};
VAR_2[0] = '\\';
VAR_2[1] = RE_YY_INPUT(VAR_0);
if (VAR_2[1] == VAR_3)
return 0;
if (VAR_2[1] == 'x')
{
VAR_2[2] = RE_YY_INPUT(VAR_0);
if (VAR_2[2] == VAR_3)
return 0;
VAR_2[3] = RE_YY_INPUT(VAR_0);
if (VAR_2[3] == VAR_3)
return 0;
}
*VAR_1 = escaped_char_value(VAR_2);
return 1;
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/before/3.json,"int read_escaped_char(
    yyscan_t yyscanner,
    uint8_t* escaped_char)
{
  char text[4] = {0, 0, 0, 0};

  text[0] = '\\';
  text[1] = RE_YY_INPUT(yyscanner);

  if (text[1] == EOF || text[1] == 0)
    return 0;

  if (text[1] == 'x')
  {
    text[2] = RE_YY_INPUT(yyscanner);

    if (!isxdigit(text[2]))
      return 0;

    text[3] = RE_YY_INPUT(yyscanner);

    if (!isxdigit(text[3]))
      return 0;
  }

  *escaped_char = escaped_char_value(text);

  return 1;
}","int read_escaped_char(
    yyscan_t VAR_0,
    uint8_t* VAR_1)
{
  char VAR_2[4] = {0, 0, 0, 0};

  VAR_2[0] = '\\';
  VAR_2[1] = RE_YY_INPUT(VAR_0);

  if (VAR_2[1] == VAR_3 || VAR_2[1] == 0)
    return 0;

  if (VAR_2[1] == 'x')
  {
    VAR_2[2] = RE_YY_INPUT(VAR_0);

    if (!isxdigit(VAR_2[2]))
      return 0;

    VAR_2[3] = RE_YY_INPUT(VAR_0);

    if (!isxdigit(VAR_2[3]))
      return 0;
  }

  *VAR_1 = escaped_char_value(VAR_2);

  return 1;
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -7,19 +7,19 @@
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
-  if (text[1] == EOF)
+  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
-    if (text[2] == EOF)
+    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
-    if (text[3] == EOF)
+    if (!isxdigit(text[3]))
       return 0;
   }
 ","{'deleted_lines': ['  if (text[1] == EOF)', '    if (text[2] == EOF)', '    if (text[3] == EOF)'], 'added_lines': ['  if (text[1] == EOF || text[1] == 0)', '    if (!isxdigit(text[2]))', '    if (!isxdigit(text[3]))']}",True,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,7.5,HIGH,2,valid,2017-01-17T16:07:02Z,1
CVE-2016-10210,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,libyara/re_lexer.c,re_yylex_init_extra,"int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
{
struct yyguts_t dummy_yyguts;
re_yyset_extra (yy_user_defined, &dummy_yyguts);
if (ptr_yy_globals == NULL){
errno = EINVAL;
return 1;
}
*ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
if (*ptr_yy_globals == NULL){
errno = ENOMEM;
return 1;
}
memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
re_yyset_extra (yy_user_defined, *ptr_yy_globals);
return yy_init_globals ( *ptr_yy_globals );
}","int re_yylex_init_extra(YY_EXTRA_TYPE VAR_0,yyscan_t* VAR_1 )
{
struct yyguts_t VAR_2;
re_yyset_extra (VAR_0, &VAR_2);
if (VAR_1 == NULL){
VAR_3 = VAR_4;
return 1;
}
*VAR_1 = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &VAR_2 );
if (*VAR_1 == NULL){
VAR_3 = VAR_5;
return 1;
}
memset(*VAR_1,0x00,sizeof(struct yyguts_t));
re_yyset_extra (VAR_0, *VAR_1);
return yy_init_globals ( *VAR_1 );
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/before/2.json,"int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )

{
    struct yyguts_t dummy_yyguts;

    re_yyset_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    re_yyset_extra (yy_user_defined, *ptr_yy_globals);

    return yy_init_globals ( *ptr_yy_globals );
}","int re_yylex_init_extra(YY_EXTRA_TYPE VAR_0,yyscan_t* VAR_1 )

{
    struct yyguts_t VAR_2;

    re_yyset_extra (VAR_0, &VAR_2);

    if (VAR_1 == NULL){
        VAR_3 = VAR_4;
        return 1;
    }

    *VAR_1 = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &VAR_2 );

    if (*VAR_1 == NULL){
        VAR_3 = VAR_5;
        return 1;
    }

    /* COMMENT_0 */
                                                   
    memset(*VAR_1,0x00,sizeof(struct yyguts_t));

    re_yyset_extra (VAR_0, *VAR_1);

    return yy_init_globals ( *VAR_1 );
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -9,19 +9,19 @@
         errno = EINVAL;
         return 1;
     }
-	
+
     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-	
+
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-    
+
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-    
+
     re_yyset_extra (yy_user_defined, *ptr_yy_globals);
-    
+
     return yy_init_globals ( *ptr_yy_globals );
 }","{'deleted_lines': ['\t', '\t', '    ', '    ', '    '], 'added_lines': ['', '', '', '', '']}",True,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,7.5,HIGH,2,valid,2017-01-17T16:07:02Z,1
CVE-2016-10210,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,libyara/re_lexer.c,re_yyget_column,"int re_yyget_column  (yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (! YY_CURRENT_BUFFER)
return 0;
return yycolumn;
}","int re_yyget_column  (yyscan_t VAR_0)
{
struct yyguts_t * VAR_1 = (struct yyguts_t*)VAR_0;
if (! VAR_2)
return 0;
return VAR_3;
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/before/1.json,"int re_yyget_column  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yycolumn;
}","int re_yyget_column  (yyscan_t VAR_0)
{
    struct yyguts_t * VAR_1 = (struct yyguts_t*)VAR_0;

        if (! VAR_2)
            return 0;
    
    return VAR_3;
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     ","{'deleted_lines': ['    '], 'added_lines': ['']}",True,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,7.5,HIGH,2,valid,2017-01-17T16:07:02Z,1
CVE-2016-10210,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,libyara/re_lexer.c,re_yyensure_buffer_stack,"static void re_yyensure_buffer_stack (yyscan_t yyscanner)
{
yy_size_t num_to_alloc;
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!yyg->yy_buffer_stack) {
num_to_alloc = 1; yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}
if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
yy_size_t grow_size = 8 ;
num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}","static void re_yyensure_buffer_stack (yyscan_t VAR_0)
{
yy_size_t VAR_1;
struct yyguts_t * VAR_2 = (struct yyguts_t*)VAR_0;
if (!VAR_2->yy_buffer_stack) {
VAR_1 = 1; 
VAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc
(VAR_1 * sizeof(struct yy_buffer_state*)
, VAR_0);
if ( ! VAR_2->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
memset(VAR_2->yy_buffer_stack, 0, VAR_1 * sizeof(struct yy_buffer_state*));
VAR_2->yy_buffer_stack_max = VAR_1;
VAR_2->yy_buffer_stack_top = 0;
return;
}
if (VAR_2->yy_buffer_stack_top >= (VAR_2->yy_buffer_stack_max) - 1){
yy_size_t VAR_3 = 8 ;
VAR_1 = VAR_2->yy_buffer_stack_max + VAR_3;
VAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc
(VAR_2->yy_buffer_stack,
VAR_1 * sizeof(struct yy_buffer_state*)
, VAR_0);
if ( ! VAR_2->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
memset(VAR_2->yy_buffer_stack + VAR_2->yy_buffer_stack_max, 0, VAR_3 * sizeof(struct yy_buffer_state*));
VAR_2->yy_buffer_stack_max = VAR_1;
}
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/before/5.json,"static void re_yyensure_buffer_stack (yyscan_t yyscanner)
{
	yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1; // After all that talk, this was set to 1 anyways...
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}","static void re_yyensure_buffer_stack (yyscan_t VAR_0)
{
	yy_size_t VAR_1;
    struct yyguts_t * VAR_2 = (struct yyguts_t*)VAR_0;

	if (!VAR_2->yy_buffer_stack) {

		/* COMMENT_0 */
                                                                      
                                        
           
		VAR_1 = 1; /* COMMENT_4 */
		VAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc
								(VAR_1 * sizeof(struct yy_buffer_state*)
								, VAR_0);
		if ( ! VAR_2->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

		memset(VAR_2->yy_buffer_stack, 0, VAR_1 * sizeof(struct yy_buffer_state*));

		VAR_2->yy_buffer_stack_max = VAR_1;
		VAR_2->yy_buffer_stack_top = 0;
		return;
	}

	if (VAR_2->yy_buffer_stack_top >= (VAR_2->yy_buffer_stack_max) - 1){

		/* COMMENT_5 */
		yy_size_t VAR_3 = 8 /* COMMENT_6 */;

		VAR_1 = VAR_2->yy_buffer_stack_max + VAR_3;
		VAR_2->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc
								(VAR_2->yy_buffer_stack,
								VAR_1 * sizeof(struct yy_buffer_state*)
								, VAR_0);
		if ( ! VAR_2->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

		/* COMMENT_7 */
		memset(VAR_2->yy_buffer_stack + VAR_2->yy_buffer_stack_max, 0, VAR_3 * sizeof(struct yy_buffer_state*));
		VAR_2->yy_buffer_stack_max = VAR_1;
	}
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -15,9 +15,9 @@
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );
-								  
+
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;","{'deleted_lines': ['\t\t\t\t\t\t\t\t  ', '\t\t\t\t'], 'added_lines': ['', '']}",True,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,7.5,HIGH,2,valid,2017-01-17T16:07:02Z,1
CVE-2016-10210,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"re_lexer: Make reading escape sequences more robust (#586)

* Add test for issue #503

* re_lexer: Make reading escape sequences more robust

This commit fixes parsing incomplete escape sequences at the end of a
regular expression and parsing things like \xxy (invalid hex digits)
which before were silently turned into (char)255.

Close #503

* Update re_lexer.c",3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,https://github.com/VirusTotal/yara/commit/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4,libyara/re_lexer.c,re_yyget_lineno,"int re_yyget_lineno  (yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (! YY_CURRENT_BUFFER)
return 0;
return yylineno;
}","int re_yyget_lineno  (yyscan_t VAR_0)
{
struct yyguts_t * VAR_1 = (struct yyguts_t*)VAR_0;
if (! VAR_2)
return 0;
return VAR_3;
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/before/0.json,"int re_yyget_lineno  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yylineno;
}","int re_yyget_lineno  (yyscan_t VAR_0)
{
    struct yyguts_t * VAR_1 = (struct yyguts_t*)VAR_0;

        if (! VAR_2)
            return 0;
    
    return VAR_3;
}",VirusTotal/yara/3119b232c9c453c98d8fa8b6ae4e37ba18117cd4/re_lexer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
+
         if (! YY_CURRENT_BUFFER)
             return 0;
     ","{'deleted_lines': ['    '], 'added_lines': ['']}",True,libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.,7.5,HIGH,2,valid,2017-01-17T16:07:02Z,1
CVE-2017-6498,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/pull/359,65f75a32a93ae4044c528a987a68366ecd4b46b9,https://github.com/ImageMagick/ImageMagick/commit/65f75a32a93ae4044c528a987a68366ecd4b46b9,coders/tga.c,WriteTGAImage,"static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)
{
CompressionType
compression;
const char
*value;
const double
midpoint = QuantumRange/2.0;
MagickBooleanType
status;
QuantumAny
range;
register const IndexPacket
*indexes;
register const PixelPacket
*p;
register ssize_t
x;
register ssize_t
i;
register unsigned char
*q;
ssize_t
count,
y;
TGAInfo
tga_info;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
if (status == MagickFalse)
return(status);
if ((image->columns > 65535L) || (image->rows > 65535L))
ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
(void) TransformImageColorspace(image,sRGBColorspace);
compression=image->compression;
if (image_info->compression != UndefinedCompression)
compression=image_info->compression;
range=GetQuantumRange(5UL);
tga_info.id_length=0;
value=GetImageProperty(image,""comment"");
if (value != (const char *) NULL)
tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);
tga_info.colormap_type=0;
tga_info.colormap_index=0;
tga_info.colormap_length=0;
tga_info.colormap_size=0;
tga_info.x_origin=0;
tga_info.y_origin=0;
tga_info.width=(unsigned short) image->columns;
tga_info.height=(unsigned short) image->rows;
tga_info.bits_per_pixel=8;
tga_info.attributes=0;
if ((image_info->type != TrueColorType) &&
(image_info->type != TrueColorMatteType) &&
(image_info->type != PaletteType) &&
(image->matte == MagickFalse) &&
(SetImageGray(image,&image->exception) != MagickFalse))
tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :
TGAMonochrome;
else
if ((image->storage_class == DirectClass) || (image->colors > 256))
{
tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;
if (image_info->depth == 5)
{
tga_info.bits_per_pixel=16;
if (image->matte != MagickFalse)
tga_info.attributes=1;  
}
else
{
tga_info.bits_per_pixel=24;
if (image->matte != MagickFalse)
{
tga_info.bits_per_pixel=32;
tga_info.attributes=8;  
}
}
}
else
{
tga_info.image_type=compression == RLECompression ? TGARLEColormap :
TGAColormap;
tga_info.colormap_type=1;
tga_info.colormap_length=(unsigned short) image->colors;
if (image_info->depth == 5)
tga_info.colormap_size=16;
else
tga_info.colormap_size=24;
}
value=GetImageArtifact(image,""tga:image-origin"");
if (value != (const char *) NULL)
{
OrientationType
origin;
origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,
MagickFalse,value);
if (origin == BottomRightOrientation || origin == TopRightOrientation)
tga_info.attributes|=(1UL << 4);
if (origin == TopLeftOrientation || origin == TopRightOrientation)
tga_info.attributes|=(1UL << 5);
}
(void) WriteBlobByte(image,tga_info.id_length);
(void) WriteBlobByte(image,tga_info.colormap_type);
(void) WriteBlobByte(image,(unsigned char) tga_info.image_type);
(void) WriteBlobLSBShort(image,tga_info.colormap_index);
(void) WriteBlobLSBShort(image,tga_info.colormap_length);
(void) WriteBlobByte(image,tga_info.colormap_size);
(void) WriteBlobLSBShort(image,tga_info.x_origin);
(void) WriteBlobLSBShort(image,tga_info.y_origin);
(void) WriteBlobLSBShort(image,tga_info.width);
(void) WriteBlobLSBShort(image,tga_info.height);
(void) WriteBlobByte(image,tga_info.bits_per_pixel);
(void) WriteBlobByte(image,tga_info.attributes);
if (tga_info.id_length != 0)
(void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);
if (tga_info.colormap_type != 0)
{
unsigned char
green,
*targa_colormap;
targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(
*targa_colormap));
if (targa_colormap == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
q=targa_colormap;
for (i=0; i < (ssize_t) image->colors; i++)
{
if (image_info->depth == 5)
{
green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,
range);
*q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,
range)) | ((green & 0x07) << 5);
*q++=(((image->matte != MagickFalse) && (
(double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |
((unsigned char) ScaleQuantumToAny(image->colormap[i].red,
range) << 2) | ((green & 0x18) >> 3);
}
else
{
*q++=ScaleQuantumToChar(image->colormap[i].blue);
*q++=ScaleQuantumToChar(image->colormap[i].green);
*q++=ScaleQuantumToChar(image->colormap[i].red);
}
}
(void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*
tga_info.colormap_length),targa_colormap);
targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);
}
for (y=(ssize_t) (image->rows-1); y >= 0; y--)
{
p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
if (p == (const PixelPacket *) NULL)
break;
indexes=GetVirtualIndexQueue(image);
if (compression == RLECompression)
{
x=0;
count=0;
while (x < (ssize_t) image->columns)
{
i=1;
while ((i < 128) && (count + i < 128) &&
((x + i) < (ssize_t) image->columns))
{
if (tga_info.image_type == TGARLEColormap)
{
if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))
break;
}
else
if (tga_info.image_type == TGARLEMonochrome)
{
if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))
break;
}
else
{
if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||
(GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||
(GetPixelRed(p+i) != GetPixelRed(p+(i-1))))
break;
if ((image->matte != MagickFalse) &&
(GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))
break;
}
i++;
}
if (i < 3)
{
count+=i;
p+=i;
indexes+=i;
}
if ((i >= 3) || (count == 128) ||
((x + i) == (ssize_t) image->columns))
{
if (count > 0)
{
(void) WriteBlobByte(image,(unsigned char) (--count));
while (count >= 0)
{
WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),
p-(count+1),range,midpoint);
count--;
}
count=0;
}
}
if (i >= 3)
{
(void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));
WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);
p+=i;
indexes+=i;
}
x+=i;
}
}
else
{
for (x=0; x < (ssize_t) image->columns; x++)
WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);
}
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WriteTGAImage(const ImageInfo *VAR_0,Image *VAR_1)
{
CompressionType
VAR_2;
const char
*VAR_3;
const double
VAR_4 = VAR_5/2.0;
MagickBooleanType
VAR_6;
QuantumAny
VAR_7;
register const IndexPacket
*VAR_8;
register const PixelPacket
*VAR_9;
register ssize_t
VAR_10;
register ssize_t
VAR_11;
register unsigned char
*VAR_12;
ssize_t
VAR_13,
VAR_14;
TGAInfo
VAR_15;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_16);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_16);
if (VAR_1->debug != VAR_17)
(void) LogMagickEvent(VAR_18,GetMagickModule(),""%s"",VAR_1->filename);
VAR_6=OpenBlob(VAR_0,VAR_1,VAR_19,&VAR_1->exception);
if (VAR_6 == VAR_17)
return(VAR_6);
if ((VAR_1->columns > 65535L) || (VAR_1->rows > 65535L))
ThrowWriterException(VAR_20,""WidthOrHeightExceedsLimit"");
(void) TransformImageColorspace(VAR_1,VAR_21);
VAR_2=VAR_1->compression;
if (VAR_0->compression != VAR_22)
VAR_2=VAR_0->compression;
VAR_7=GetQuantumRange(5UL);
VAR_15.id_length=0;
VAR_3=GetImageProperty(VAR_1,""comment"");
if (VAR_3 != (const char *) NULL)
VAR_15.id_length=(unsigned char) MagickMin(strlen(VAR_3),255);
VAR_15.colormap_type=0;
VAR_15.colormap_index=0;
VAR_15.colormap_length=0;
VAR_15.colormap_size=0;
VAR_15.x_origin=0;
VAR_15.y_origin=0;
VAR_15.width=(unsigned short) VAR_1->columns;
VAR_15.height=(unsigned short) VAR_1->rows;
VAR_15.bits_per_pixel=8;
VAR_15.attributes=0;
if ((VAR_0->type != VAR_23) &&
(VAR_0->type != VAR_24) &&
(VAR_0->type != VAR_25) &&
(VAR_1->matte == VAR_17) &&
(SetImageGray(VAR_1,&VAR_1->exception) != VAR_17))
VAR_15.image_type=VAR_2 == VAR_26 ? VAR_27 :
VAR_28;
else
if ((VAR_1->storage_class == VAR_29) || (VAR_1->colors > 256))
{
VAR_15.image_type=VAR_2 == VAR_26 ? VAR_30 : VAR_31;
if (VAR_0->depth == 5)
{
VAR_15.bits_per_pixel=16;
if (VAR_1->matte != VAR_17)
VAR_15.attributes=1;  
}
else
{
VAR_15.bits_per_pixel=24;
if (VAR_1->matte != VAR_17)
{
VAR_15.bits_per_pixel=32;
VAR_15.attributes=8;  
}
}
}
else
{
VAR_15.image_type=VAR_2 == VAR_26 ? VAR_32 :
VAR_33;
VAR_15.colormap_type=1;
VAR_15.colormap_length=(unsigned short) VAR_1->colors;
if (VAR_0->depth == 5)
VAR_15.colormap_size=16;
else
VAR_15.colormap_size=24;
}
VAR_3=GetImageArtifact(VAR_1,""tga:image-origin"");
if (VAR_3 != (const char *) NULL)
{
OrientationType
VAR_34;
VAR_34=(OrientationType) ParseCommandOption(VAR_35,
VAR_17,VAR_3);
if (VAR_34 == VAR_36 || VAR_34 == VAR_37)
VAR_15.attributes|=(1UL << 4);
if (VAR_34 == VAR_38 || VAR_34 == VAR_37)
VAR_15.attributes|=(1UL << 5);
}
(void) WriteBlobByte(VAR_1,VAR_15.id_length);
(void) WriteBlobByte(VAR_1,VAR_15.colormap_type);
(void) WriteBlobByte(VAR_1,(unsigned char) VAR_15.image_type);
(void) WriteBlobLSBShort(VAR_1,VAR_15.colormap_index);
(void) WriteBlobLSBShort(VAR_1,VAR_15.colormap_length);
(void) WriteBlobByte(VAR_1,VAR_15.colormap_size);
(void) WriteBlobLSBShort(VAR_1,VAR_15.x_origin);
(void) WriteBlobLSBShort(VAR_1,VAR_15.y_origin);
(void) WriteBlobLSBShort(VAR_1,VAR_15.width);
(void) WriteBlobLSBShort(VAR_1,VAR_15.height);
(void) WriteBlobByte(VAR_1,VAR_15.bits_per_pixel);
(void) WriteBlobByte(VAR_1,VAR_15.attributes);
if (VAR_15.id_length != 0)
(void) WriteBlob(VAR_1,VAR_15.id_length,(unsigned char *) VAR_3);
if (VAR_15.colormap_type != 0)
{
unsigned char
VAR_39,
*VAR_40;
VAR_40=(unsigned char *) AcquireQuantumMemory((size_t)
VAR_15.colormap_length,(VAR_15.colormap_size/8)*sizeof(
*VAR_40));
if (VAR_40 == (unsigned char *) NULL)
ThrowWriterException(VAR_41,""MemoryAllocationFailed"");
VAR_12=VAR_40;
for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->colors; VAR_11++)
{
if (VAR_0->depth == 5)
{
VAR_39=(unsigned char) ScaleQuantumToAny(VAR_1->colormap[VAR_11].green,
VAR_7);
*VAR_12++=((unsigned char) ScaleQuantumToAny(VAR_1->colormap[VAR_11].blue,
VAR_7)) | ((VAR_39 & 0x07) << 5);
*VAR_12++=(((VAR_1->matte != VAR_17) && (
(double) VAR_1->colormap[VAR_11].opacity < VAR_4)) ? 0x80 : 0) |
((unsigned char) ScaleQuantumToAny(VAR_1->colormap[VAR_11].red,
VAR_7) << 2) | ((VAR_39 & 0x18) >> 3);
}
else
{
*VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_11].blue);
*VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_11].green);
*VAR_12++=ScaleQuantumToChar(VAR_1->colormap[VAR_11].red);
}
}
(void) WriteBlob(VAR_1,(size_t) ((VAR_15.colormap_size/8)*
VAR_15.colormap_length),VAR_40);
VAR_40=(unsigned char *) RelinquishMagickMemory(VAR_40);
}
for (VAR_14=(ssize_t) (VAR_1->rows-1); VAR_14 >= 0; VAR_14--)
{
VAR_9=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,&VAR_1->exception);
if (VAR_9 == (const PixelPacket *) NULL)
break;
VAR_8=GetVirtualIndexQueue(VAR_1);
if (VAR_2 == VAR_26)
{
VAR_10=0;
VAR_13=0;
while (VAR_10 < (ssize_t) VAR_1->columns)
{
VAR_11=1;
while ((VAR_11 < 128) && (VAR_13 + VAR_11 < 128) &&
((VAR_10 + VAR_11) < (ssize_t) VAR_1->columns))
{
if (VAR_15.image_type == VAR_32)
{
if (GetPixelIndex(VAR_8+VAR_11) != GetPixelIndex(VAR_8+(VAR_11-1)))
break;
}
else
if (VAR_15.image_type == VAR_27)
{
if (GetPixelLuma(VAR_1,VAR_9+VAR_11) != GetPixelLuma(VAR_1,VAR_9+(VAR_11-1)))
break;
}
else
{
if ((GetPixelBlue(VAR_9+VAR_11) != GetPixelBlue(VAR_9+(VAR_11-1))) ||
(GetPixelGreen(VAR_9+VAR_11) != GetPixelGreen(VAR_9+(VAR_11-1))) ||
(GetPixelRed(VAR_9+VAR_11) != GetPixelRed(VAR_9+(VAR_11-1))))
break;
if ((VAR_1->matte != VAR_17) &&
(GetPixelAlpha(VAR_9+VAR_11) != GetPixelAlpha(VAR_9+(VAR_11-1))))
break;
}
VAR_11++;
}
if (VAR_11 < 3)
{
VAR_13+=VAR_11;
VAR_9+=VAR_11;
VAR_8+=VAR_11;
}
if ((VAR_11 >= 3) || (VAR_13 == 128) ||
((VAR_10 + VAR_11) == (ssize_t) VAR_1->columns))
{
if (VAR_13 > 0)
{
(void) WriteBlobByte(VAR_1,(unsigned char) (--VAR_13));
while (VAR_13 >= 0)
{
WriteTGAPixel(VAR_1,VAR_15.image_type,VAR_8-(VAR_13+1),
VAR_9-(VAR_13+1),VAR_7,VAR_4);
VAR_13--;
}
VAR_13=0;
}
}
if (VAR_11 >= 3)
{
(void) WriteBlobByte(VAR_1,(unsigned char) ((VAR_11-1) | 0x80));
WriteTGAPixel(VAR_1,VAR_15.image_type,VAR_8,VAR_9,VAR_7,VAR_4);
VAR_9+=VAR_11;
VAR_8+=VAR_11;
}
VAR_10+=VAR_11;
}
}
else
{
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1->columns; VAR_10++)
WriteTGAPixel(VAR_1,VAR_15.image_type,VAR_8+VAR_10,VAR_9++,VAR_7,VAR_4);
}
if (VAR_1->previous == (Image *) NULL)
{
VAR_6=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_14,
VAR_1->rows);
if (VAR_6 == VAR_17)
break;
}
}
(void) CloseBlob(VAR_1);
return(VAR_43);
}",ImageMagick/65f75a32a93ae4044c528a987a68366ecd4b46b9/tga.c/vul/before/0.json,"static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)
{
  CompressionType
    compression;

  const char
    *comment,
    *value;

  const double
    midpoint = QuantumRange/2.0;

  MagickBooleanType
    status;

  QuantumAny
    range;

  register const IndexPacket
    *indexes;

  register const PixelPacket
    *p;

  register ssize_t
    x;

  register ssize_t
    i;

  register unsigned char
    *q;

  ssize_t
    count,
    y;

  TGAInfo
    tga_info;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
  /*
    Initialize TGA raster file header.
  */
  if ((image->columns > 65535L) || (image->rows > 65535L))
    ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
  (void) TransformImageColorspace(image,sRGBColorspace);
  compression=image->compression;
  if (image_info->compression != UndefinedCompression)
    compression=image_info->compression;
  range=GetQuantumRange(5UL);
  tga_info.id_length=0;
  comment=GetImageProperty(image,""comment"");
  if (comment != (const char *) NULL)
    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);
  tga_info.colormap_type=0;
  tga_info.colormap_index=0;
  tga_info.colormap_length=0;
  tga_info.colormap_size=0;
  tga_info.x_origin=0;
  tga_info.y_origin=0;
  tga_info.width=(unsigned short) image->columns;
  tga_info.height=(unsigned short) image->rows;
  tga_info.bits_per_pixel=8;
  tga_info.attributes=0;
  if ((image_info->type != TrueColorType) &&
      (image_info->type != TrueColorMatteType) &&
      (image_info->type != PaletteType) &&
      (image->matte == MagickFalse) &&
      (SetImageGray(image,&image->exception) != MagickFalse))
    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :
      TGAMonochrome;
  else
    if ((image->storage_class == DirectClass) || (image->colors > 256))
      {
        /*
          Full color TGA raster.
        */
        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;
        if (image_info->depth == 5)
          {
            tga_info.bits_per_pixel=16;
            if (image->matte != MagickFalse)
              tga_info.attributes=1;  /* # of alpha bits */
          }
        else
          {
            tga_info.bits_per_pixel=24;
            if (image->matte != MagickFalse)
              {
                tga_info.bits_per_pixel=32;
                tga_info.attributes=8;  /* # of alpha bits */
              }
          }
      }
    else
      {
        /*
          Colormapped TGA raster.
        */
        tga_info.image_type=compression == RLECompression ? TGARLEColormap :
          TGAColormap;
        tga_info.colormap_type=1;
        tga_info.colormap_length=(unsigned short) image->colors;
        if (image_info->depth == 5)
          tga_info.colormap_size=16;
        else
          tga_info.colormap_size=24;
      }
  value=GetImageArtifact(image,""tga:image-origin"");
  if (value != (const char *) NULL)
    {
      OrientationType
        origin;

      origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,
        MagickFalse,value);
      if (origin == BottomRightOrientation || origin == TopRightOrientation)
        tga_info.attributes|=(1UL << 4);
      if (origin == TopLeftOrientation || origin == TopRightOrientation)
        tga_info.attributes|=(1UL << 5);
    }
  /*
    Write TGA header.
  */
  (void) WriteBlobByte(image,tga_info.id_length);
  (void) WriteBlobByte(image,tga_info.colormap_type);
  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);
  (void) WriteBlobLSBShort(image,tga_info.colormap_index);
  (void) WriteBlobLSBShort(image,tga_info.colormap_length);
  (void) WriteBlobByte(image,tga_info.colormap_size);
  (void) WriteBlobLSBShort(image,tga_info.x_origin);
  (void) WriteBlobLSBShort(image,tga_info.y_origin);
  (void) WriteBlobLSBShort(image,tga_info.width);
  (void) WriteBlobLSBShort(image,tga_info.height);
  (void) WriteBlobByte(image,tga_info.bits_per_pixel);
  (void) WriteBlobByte(image,tga_info.attributes);
  if (tga_info.id_length != 0)
    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);
  if (tga_info.colormap_type != 0)
    {
      unsigned char
        green,
        *targa_colormap;

      /*
        Dump colormap to file (blue, green, red byte order).
      */
      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
        tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(
        *targa_colormap));
      if (targa_colormap == (unsigned char *) NULL)
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      q=targa_colormap;
      for (i=0; i < (ssize_t) image->colors; i++)
      {
        if (image_info->depth == 5)
          {
            green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,
              range);
            *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,
              range)) | ((green & 0x07) << 5);
            *q++=(((image->matte != MagickFalse) && (
              (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |
              ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,
              range) << 2) | ((green & 0x18) >> 3);
          }
        else
          {
            *q++=ScaleQuantumToChar(image->colormap[i].blue);
            *q++=ScaleQuantumToChar(image->colormap[i].green);
            *q++=ScaleQuantumToChar(image->colormap[i].red);
          }
      }
      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*
        tga_info.colormap_length),targa_colormap);
      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);
    }
  /*
    Convert MIFF to TGA raster pixels.
  */
  for (y=(ssize_t) (image->rows-1); y >= 0; y--)
  {
    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
    if (p == (const PixelPacket *) NULL)
      break;
    indexes=GetVirtualIndexQueue(image);
    if (compression == RLECompression)
      {
        x=0;
        count=0;
        while (x < (ssize_t) image->columns)
        {
          i=1;
          while ((i < 128) && (count + i < 128) &&
                 ((x + i) < (ssize_t) image->columns))
          {
            if (tga_info.image_type == TGARLEColormap)
              {
                if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))
                  break;
              }
            else
              if (tga_info.image_type == TGARLEMonochrome)
                {
                  if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))
                    break;
                }
              else
                {
                  if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||
                      (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||
                      (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))
                    break;
                  if ((image->matte != MagickFalse) &&
                      (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))
                    break;
                }
            i++;
          }
          if (i < 3)
            {
              count+=i;
              p+=i;
              indexes+=i;
            }
          if ((i >= 3) || (count == 128) ||
              ((x + i) == (ssize_t) image->columns))
            {
              if (count > 0)
                {
                  (void) WriteBlobByte(image,(unsigned char) (--count));
                  while (count >= 0)
                  {
                    WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),
                      p-(count+1),range,midpoint);
                    count--;
                  }
                  count=0;
                }
            }
          if (i >= 3)
            {
              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));
              WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);
              p+=i;
              indexes+=i;
            }
          x+=i;
        }
      }
    else
      {
        for (x=0; x < (ssize_t) image->columns; x++)
          WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);
      }
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WriteTGAImage(const ImageInfo *VAR_0,Image *VAR_1)
{
  CompressionType
    VAR_2;

  const char
    *VAR_3,
    *VAR_4;

  const double
    VAR_5 = VAR_6/2.0;

  MagickBooleanType
    VAR_7;

  QuantumAny
    VAR_8;

  register const IndexPacket
    *VAR_9;

  register const PixelPacket
    *VAR_10;

  register ssize_t
    VAR_11;

  register ssize_t
    VAR_12;

  register unsigned char
    *VAR_13;

  ssize_t
    VAR_14,
    VAR_15;

  TGAInfo
    VAR_16;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_17);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_17);
  if (VAR_1->debug != VAR_18)
    (void) LogMagickEvent(VAR_19,GetMagickModule(),""%s"",VAR_1->filename);
  VAR_7=OpenBlob(VAR_0,VAR_1,VAR_20,&VAR_1->exception);
  if (VAR_7 == VAR_18)
    return(VAR_7);
  /* COMMENT_3 */
                                      
    
  if ((VAR_1->columns > 65535L) || (VAR_1->rows > 65535L))
    ThrowWriterException(VAR_21,""WidthOrHeightExceedsLimit"");
  (void) TransformImageColorspace(VAR_1,VAR_22);
  VAR_2=VAR_1->compression;
  if (VAR_0->compression != VAR_23)
    VAR_2=VAR_0->compression;
  VAR_8=GetQuantumRange(5UL);
  VAR_16.id_length=0;
  VAR_3=GetImageProperty(VAR_1,""comment"");
  if (VAR_3 != (const char *) NULL)
    VAR_16.id_length=(unsigned char) MagickMin(strlen(VAR_3),255);
  VAR_16.colormap_type=0;
  VAR_16.colormap_index=0;
  VAR_16.colormap_length=0;
  VAR_16.colormap_size=0;
  VAR_16.x_origin=0;
  VAR_16.y_origin=0;
  VAR_16.width=(unsigned short) VAR_1->columns;
  VAR_16.height=(unsigned short) VAR_1->rows;
  VAR_16.bits_per_pixel=8;
  VAR_16.attributes=0;
  if ((VAR_0->type != VAR_24) &&
      (VAR_0->type != VAR_25) &&
      (VAR_0->type != VAR_26) &&
      (VAR_1->matte == VAR_18) &&
      (SetImageGray(VAR_1,&VAR_1->exception) != VAR_18))
    VAR_16.image_type=VAR_2 == VAR_27 ? VAR_28 :
      VAR_29;
  else
    if ((VAR_1->storage_class == VAR_30) || (VAR_1->colors > 256))
      {
        /* COMMENT_6 */
                                
          
        VAR_16.image_type=VAR_2 == VAR_27 ? VAR_31 : VAR_32;
        if (VAR_0->depth == 5)
          {
            VAR_16.bits_per_pixel=16;
            if (VAR_1->matte != VAR_18)
              VAR_16.attributes=1;  /* COMMENT_9 */
          }
        else
          {
            VAR_16.bits_per_pixel=24;
            if (VAR_1->matte != VAR_18)
              {
                VAR_16.bits_per_pixel=32;
                VAR_16.attributes=8;  /* COMMENT_9 */
              }
          }
      }
    else
      {
        /* COMMENT_10 */
                                 
          
        VAR_16.image_type=VAR_2 == VAR_27 ? VAR_33 :
          VAR_34;
        VAR_16.colormap_type=1;
        VAR_16.colormap_length=(unsigned short) VAR_1->colors;
        if (VAR_0->depth == 5)
          VAR_16.colormap_size=16;
        else
          VAR_16.colormap_size=24;
      }
  VAR_4=GetImageArtifact(VAR_1,""tga:image-origin"");
  if (VAR_4 != (const char *) NULL)
    {
      OrientationType
        VAR_35;

      VAR_35=(OrientationType) ParseCommandOption(VAR_36,
        VAR_18,VAR_4);
      if (VAR_35 == VAR_37 || VAR_35 == VAR_38)
        VAR_16.attributes|=(1UL << 4);
      if (VAR_35 == VAR_39 || VAR_35 == VAR_38)
        VAR_16.attributes|=(1UL << 5);
    }
  /* COMMENT_13 */
                     
    
  (void) WriteBlobByte(VAR_1,VAR_16.id_length);
  (void) WriteBlobByte(VAR_1,VAR_16.colormap_type);
  (void) WriteBlobByte(VAR_1,(unsigned char) VAR_16.image_type);
  (void) WriteBlobLSBShort(VAR_1,VAR_16.colormap_index);
  (void) WriteBlobLSBShort(VAR_1,VAR_16.colormap_length);
  (void) WriteBlobByte(VAR_1,VAR_16.colormap_size);
  (void) WriteBlobLSBShort(VAR_1,VAR_16.x_origin);
  (void) WriteBlobLSBShort(VAR_1,VAR_16.y_origin);
  (void) WriteBlobLSBShort(VAR_1,VAR_16.width);
  (void) WriteBlobLSBShort(VAR_1,VAR_16.height);
  (void) WriteBlobByte(VAR_1,VAR_16.bits_per_pixel);
  (void) WriteBlobByte(VAR_1,VAR_16.attributes);
  if (VAR_16.id_length != 0)
    (void) WriteBlob(VAR_1,VAR_16.id_length,(unsigned char *) VAR_3);
  if (VAR_16.colormap_type != 0)
    {
      unsigned char
        VAR_40,
        *VAR_41;

      /* COMMENT_16 */
                                                            
        
      VAR_41=(unsigned char *) AcquireQuantumMemory((size_t)
        VAR_16.colormap_length,(VAR_16.colormap_size/8)*sizeof(
        *VAR_41));
      if (VAR_41 == (unsigned char *) NULL)
        ThrowWriterException(VAR_42,""MemoryAllocationFailed"");
      VAR_13=VAR_41;
      for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->colors; VAR_12++)
      {
        if (VAR_0->depth == 5)
          {
            VAR_40=(unsigned char) ScaleQuantumToAny(VAR_1->colormap[VAR_12].green,
              VAR_8);
            *VAR_13++=((unsigned char) ScaleQuantumToAny(VAR_1->colormap[VAR_12].blue,
              VAR_8)) | ((VAR_40 & 0x07) << 5);
            *VAR_13++=(((VAR_1->matte != VAR_18) && (
              (double) VAR_1->colormap[VAR_12].opacity < VAR_5)) ? 0x80 : 0) |
              ((unsigned char) ScaleQuantumToAny(VAR_1->colormap[VAR_12].red,
              VAR_8) << 2) | ((VAR_40 & 0x18) >> 3);
          }
        else
          {
            *VAR_13++=ScaleQuantumToChar(VAR_1->colormap[VAR_12].blue);
            *VAR_13++=ScaleQuantumToChar(VAR_1->colormap[VAR_12].green);
            *VAR_13++=ScaleQuantumToChar(VAR_1->colormap[VAR_12].red);
          }
      }
      (void) WriteBlob(VAR_1,(size_t) ((VAR_16.colormap_size/8)*
        VAR_16.colormap_length),VAR_41);
      VAR_41=(unsigned char *) RelinquishMagickMemory(VAR_41);
    }
  /* COMMENT_19 */
                                      
    
  for (VAR_15=(ssize_t) (VAR_1->rows-1); VAR_15 >= 0; VAR_15--)
  {
    VAR_10=GetVirtualPixels(VAR_1,0,VAR_15,VAR_1->columns,1,&VAR_1->exception);
    if (VAR_10 == (const PixelPacket *) NULL)
      break;
    VAR_9=GetVirtualIndexQueue(VAR_1);
    if (VAR_2 == VAR_27)
      {
        VAR_11=0;
        VAR_14=0;
        while (VAR_11 < (ssize_t) VAR_1->columns)
        {
          VAR_12=1;
          while ((VAR_12 < 128) && (VAR_14 + VAR_12 < 128) &&
                 ((VAR_11 + VAR_12) < (ssize_t) VAR_1->columns))
          {
            if (VAR_16.image_type == VAR_33)
              {
                if (GetPixelIndex(VAR_9+VAR_12) != GetPixelIndex(VAR_9+(VAR_12-1)))
                  break;
              }
            else
              if (VAR_16.image_type == VAR_28)
                {
                  if (GetPixelLuma(VAR_1,VAR_10+VAR_12) != GetPixelLuma(VAR_1,VAR_10+(VAR_12-1)))
                    break;
                }
              else
                {
                  if ((GetPixelBlue(VAR_10+VAR_12) != GetPixelBlue(VAR_10+(VAR_12-1))) ||
                      (GetPixelGreen(VAR_10+VAR_12) != GetPixelGreen(VAR_10+(VAR_12-1))) ||
                      (GetPixelRed(VAR_10+VAR_12) != GetPixelRed(VAR_10+(VAR_12-1))))
                    break;
                  if ((VAR_1->matte != VAR_18) &&
                      (GetPixelAlpha(VAR_10+VAR_12) != GetPixelAlpha(VAR_10+(VAR_12-1))))
                    break;
                }
            VAR_12++;
          }
          if (VAR_12 < 3)
            {
              VAR_14+=VAR_12;
              VAR_10+=VAR_12;
              VAR_9+=VAR_12;
            }
          if ((VAR_12 >= 3) || (VAR_14 == 128) ||
              ((VAR_11 + VAR_12) == (ssize_t) VAR_1->columns))
            {
              if (VAR_14 > 0)
                {
                  (void) WriteBlobByte(VAR_1,(unsigned char) (--VAR_14));
                  while (VAR_14 >= 0)
                  {
                    WriteTGAPixel(VAR_1,VAR_16.image_type,VAR_9-(VAR_14+1),
                      VAR_10-(VAR_14+1),VAR_8,VAR_5);
                    VAR_14--;
                  }
                  VAR_14=0;
                }
            }
          if (VAR_12 >= 3)
            {
              (void) WriteBlobByte(VAR_1,(unsigned char) ((VAR_12-1) | 0x80));
              WriteTGAPixel(VAR_1,VAR_16.image_type,VAR_9,VAR_10,VAR_8,VAR_5);
              VAR_10+=VAR_12;
              VAR_9+=VAR_12;
            }
          VAR_11+=VAR_12;
        }
      }
    else
      {
        for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->columns; VAR_11++)
          WriteTGAPixel(VAR_1,VAR_16.image_type,VAR_9+VAR_11,VAR_10++,VAR_8,VAR_5);
      }
    if (VAR_1->previous == (Image *) NULL)
      {
        VAR_7=SetImageProgress(VAR_1,VAR_43,(MagickOffsetType) VAR_15,
          VAR_1->rows);
        if (VAR_7 == VAR_18)
          break;
      }
  }
  (void) CloseBlob(VAR_1);
  return(VAR_44);
}",ImageMagick/65f75a32a93ae4044c528a987a68366ecd4b46b9/tga.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,7 @@
     compression;
 
   const char
+    *comment,
     *value;
 
   const double
@@ -60,9 +61,9 @@
     compression=image_info->compression;
   range=GetQuantumRange(5UL);
   tga_info.id_length=0;
-  value=GetImageProperty(image,""comment"");
-  if (value != (const char *) NULL)
-    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);
+  comment=GetImageProperty(image,""comment"");
+  if (comment != (const char *) NULL)
+    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);
   tga_info.colormap_type=0;
   tga_info.colormap_index=0;
   tga_info.colormap_length=0;
@@ -146,7 +147,7 @@
   (void) WriteBlobByte(image,tga_info.bits_per_pixel);
   (void) WriteBlobByte(image,tga_info.attributes);
   if (tga_info.id_length != 0)
-    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);
+    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);
   if (tga_info.colormap_type != 0)
     {
       unsigned char","{'deleted_lines': ['  value=GetImageProperty(image,""comment"");', '  if (value != (const char *) NULL)', '    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);', '    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);'], 'added_lines': ['    *comment,', '  comment=GetImageProperty(image,""comment"");', '  if (comment != (const char *) NULL)', '    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);', '    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);']}",True,"An issue was discovered in ImageMagick 6.9.7. Incorrect TGA files could trigger assertion failures, thus leading to DoS.",5.5,MEDIUM,1,valid,2017-01-20T00:30:48Z,1
CVE-2017-8072,['CWE-388'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"HID: cp2112: fix gpio-callback error handling

In case of a zero-length report, the gpio direction_input callback would
currently return success instead of an errno.

Fixes: 1ffb3c40ffb5 (""HID: cp2112: make transfer buffers DMA capable"")
Cc: stable <stable@vger.kernel.org>     # 4.9
Signed-off-by: Johan Hovold <johan@kernel.org>
Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>",8e9faa15469ed7c7467423db4c62aeed3ff4cae3,https://github.com/torvalds/linux/commit/8e9faa15469ed7c7467423db4c62aeed3ff4cae3,drivers/hid/hid-cp2112.c,cp2112_gpio_direction_input,"static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
{
struct cp2112_device *dev = gpiochip_get_data(chip);
struct hid_device *hdev = dev->hdev;
u8 *buf = dev->in_out_buffer;
int ret;
mutex_lock(&dev->lock);
ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
HID_REQ_GET_REPORT);
if (ret != CP2112_GPIO_CONFIG_LENGTH) {
hid_err(hdev, ""error requesting GPIO config: %d\n"", ret);
goto exit;
}
buf[1] &= ~(1 << offset);
buf[2] = gpio_push_pull;
ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
HID_REQ_SET_REPORT);
if (ret < 0) {
hid_err(hdev, ""error setting GPIO config: %d\n"", ret);
goto exit;
}
ret = 0;
exit:
mutex_unlock(&dev->lock);
return ret <= 0 ? ret : -EIO;
}","static int cp2112_gpio_direction_input(struct gpio_chip *VAR_0, unsigned VAR_1)
{
struct cp2112_device *VAR_2 = gpiochip_get_data(VAR_0);
struct hid_device *VAR_3 = VAR_2->hdev;
u8 *VAR_4 = VAR_2->in_out_buffer;
int VAR_5;
mutex_lock(&VAR_2->lock);
VAR_5 = hid_hw_raw_request(VAR_3, VAR_6, VAR_4,
VAR_7, VAR_8,
VAR_9);
if (VAR_5 != VAR_7) {
hid_err(VAR_3, ""error requesting GPIO config: %d\n"", VAR_5);
goto exit;
}
VAR_4[1] &= ~(1 << VAR_1);
VAR_4[2] = VAR_10;
VAR_5 = hid_hw_raw_request(VAR_3, VAR_6, VAR_4,
VAR_7, VAR_8,
VAR_11);
if (VAR_5 < 0) {
hid_err(VAR_3, ""error setting GPIO config: %d\n"", VAR_5);
goto exit;
}
VAR_5 = 0;
exit:
mutex_unlock(&VAR_2->lock);
return VAR_5 <= 0 ? VAR_5 : -VAR_12;
}",torvalds/linux/8e9faa15469ed7c7467423db4c62aeed3ff4cae3/hid-cp2112.c/vul/before/0.json,"static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	struct hid_device *hdev = dev->hdev;
	u8 *buf = dev->in_out_buffer;
	int ret;

	mutex_lock(&dev->lock);

	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_CONFIG_LENGTH) {
		hid_err(hdev, ""error requesting GPIO config: %d\n"", ret);
		goto exit;
	}

	buf[1] &= ~(1 << offset);
	buf[2] = gpio_push_pull;

	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_SET_REPORT);
	if (ret < 0) {
		hid_err(hdev, ""error setting GPIO config: %d\n"", ret);
		goto exit;
	}

	ret = 0;

exit:
	mutex_unlock(&dev->lock);
	return ret < 0 ? ret : -EIO;
}","static int cp2112_gpio_direction_input(struct gpio_chip *VAR_0, unsigned VAR_1)
{
	struct cp2112_device *VAR_2 = gpiochip_get_data(VAR_0);
	struct hid_device *VAR_3 = VAR_2->hdev;
	u8 *VAR_4 = VAR_2->in_out_buffer;
	int VAR_5;

	mutex_lock(&VAR_2->lock);

	VAR_5 = hid_hw_raw_request(VAR_3, VAR_6, VAR_4,
				 VAR_7, VAR_8,
				 VAR_9);
	if (VAR_5 != VAR_7) {
		hid_err(VAR_3, ""error requesting GPIO config: %d\n"", VAR_5);
		goto exit;
	}

	VAR_4[1] &= ~(1 << VAR_1);
	VAR_4[2] = VAR_10;

	VAR_5 = hid_hw_raw_request(VAR_3, VAR_6, VAR_4,
				 VAR_7, VAR_8,
				 VAR_11);
	if (VAR_5 < 0) {
		hid_err(VAR_3, ""error setting GPIO config: %d\n"", VAR_5);
		goto exit;
	}

	VAR_5 = 0;

exit:
	mutex_unlock(&VAR_2->lock);
	return VAR_5 < 0 ? VAR_5 : -VAR_12;
}",torvalds/linux/8e9faa15469ed7c7467423db4c62aeed3ff4cae3/hid-cp2112.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,5 +30,5 @@
 
 exit:
 	mutex_unlock(&dev->lock);
-	return ret <= 0 ? ret : -EIO;
+	return ret < 0 ? ret : -EIO;
 }","{'deleted_lines': ['\treturn ret <= 0 ? ret : -EIO;'], 'added_lines': ['\treturn ret < 0 ? ret : -EIO;']}",True,"The cp2112_gpio_direction_input function in drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 does not have the expected EIO error status for a zero-length report, which allows local users to have an unspecified impact via unknown vectors.",7.8,HIGH,2,valid,2017-01-30T10:26:39Z,1
CVE-2017-5850,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,openbsd/src,"Reimplement httpd's support for byte ranges.

The previous implementation loaded all the output into a single output
buffer and used its size to determine the Content-Length of the body.

The new implementation calculates the body length first and writes the
individual ranges in an async way using the bufferevent mechanism.

This prevents httpd from using too much memory and applies the
watermark and throttling mechanisms to range requests.

Problem reported by Pierre Kim (pierre.kim.sec at gmail.com)

OK benno@ sunil@",142cfc82b932bc211218fbd7bdda8c7ce83f19df,https://github.com/openbsd/src/commit/142cfc82b932bc211218fbd7bdda8c7ce83f19df,usr.sbin/httpd/server_file.c,server_partial_file_request,"int
server_partial_file_request(struct httpd *env, struct client *clt, char *path,
struct stat *st, char *range_str)
{
struct server_config*srv_conf = clt->clt_srv_conf;
struct http_descriptor*resp = clt->clt_descresp;
struct http_descriptor*desc = clt->clt_descreq;
struct media_type*media, multipart_media;
struct range*range;
struct evbuffer*evb = NULL;
size_t content_length;
int code = 500, fd = -1, i, nranges, ret;
uint32_t boundary;
char content_range[64];
const char*errstr = NULL;
if (desc->http_method != HTTP_METHOD_GET)
return server_file_request(env, clt, path, st);
if ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {
code = 416;
(void)snprintf(content_range, sizeof(content_range),
""bytes */%lld"", st->st_size);
errstr = content_range;
goto abort;
}
if ((fd = open(path, O_RDONLY)) == -1)
goto abort;
media = media_find_config(env, srv_conf, path);
if ((evb = evbuffer_new()) == NULL) {
errstr = ""failed to allocate file buffer"";
goto abort;
}
if (nranges == 1) {
(void)snprintf(content_range, sizeof(content_range),
""bytes %lld-%lld/%lld"", range->start, range->end,
st->st_size);
if (kv_add(&resp->http_headers, ""Content-Range"",
content_range) == NULL)
goto abort;
content_length = range->end - range->start + 1;
if (buffer_add_range(fd, evb, range) == 0)
goto abort;
} else {
content_length = 0;
boundary = arc4random();
while (nranges--) {
if ((i = evbuffer_add_printf(evb, ""\r\n--%ud\r\n"",
boundary)) == -1)
goto abort;
content_length += i;
if ((i = evbuffer_add_printf(evb,
""Content-Type: %s/%s\r\n"",
media->media_type, media->media_subtype)) == -1)
goto abort;
content_length += i;
if ((i = evbuffer_add_printf(evb,
""Content-Range: bytes %lld-%lld/%lld\r\n\r\n"",
range->start, range->end, st->st_size)) == -1)
goto abort;
content_length += i;
if (buffer_add_range(fd, evb, range) == 0)
goto abort;
content_length += range->end - range->start + 1;
range++;
}
if ((i = evbuffer_add_printf(evb, ""\r\n--%ud--\r\n"",
boundary)) == -1)
goto abort;
content_length += i;
(void)strlcpy(multipart_media.media_type, ""multipart"",
sizeof(multipart_media.media_type));
(void)snprintf(multipart_media.media_subtype,
sizeof(multipart_media.media_subtype),
""byteranges; boundary=%ud"", boundary);
media = &multipart_media;
}
close(fd);
fd = -1;
ret = server_response_http(clt, 206, media, content_length,
MINIMUM(time(NULL), st->st_mtim.tv_sec));
switch (ret) {
case -1:
goto fail;
case 0:
goto done;
default:
break;
}
if (server_bufferevent_write_buffer(clt, evb) == -1)
goto fail;
bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
if (clt->clt_persist)
clt->clt_toread = TOREAD_HTTP_HEADER;
else
clt->clt_toread = TOREAD_HTTP_NONE;
clt->clt_done = 0;
done:
evbuffer_free(evb);
server_reset_http(clt);
return (0);
fail:
bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
bufferevent_free(clt->clt_bev);
clt->clt_bev = NULL;
abort:
if (evb != NULL)
evbuffer_free(evb);
if (fd != -1)
close(fd);
if (errstr == NULL)
errstr = strerror(errno);
server_abort_http(clt, code, errstr);
return (-1);
}","int
server_partial_file_request(struct httpd *VAR_0, struct client *VAR_1, char *VAR_2,
struct stat *VAR_3, char *VAR_4)
{
struct server_config*VAR_5 = VAR_1->clt_srv_conf;
struct http_descriptor*VAR_6 = VAR_1->clt_descresp;
struct http_descriptor*VAR_7 = VAR_1->clt_descreq;
struct media_type*VAR_8, VAR_9;
struct range*range;
struct evbuffer*VAR_10 = NULL;
size_t VAR_11;
int VAR_12 = 500, VAR_13 = -1, VAR_14, VAR_15, VAR_16;
uint32_t VAR_17;
char VAR_18[64];
const char*VAR_19 = NULL;
if (VAR_7->http_method != VAR_20)
return server_file_request(VAR_0, VAR_1, VAR_2, VAR_3);
if ((range = parse_range(VAR_4, VAR_3->st_size, &VAR_15)) == NULL) {
VAR_12 = 416;
(void)snprintf(VAR_18, sizeof(VAR_18),
""bytes */%lld"", VAR_3->st_size);
VAR_19 = VAR_18;
goto abort;
}
if ((VAR_13 = open(VAR_2, VAR_21)) == -1)
goto abort;
VAR_8 = media_find_config(VAR_0, VAR_5, VAR_2);
if ((VAR_10 = evbuffer_new()) == NULL) {
VAR_19 = ""failed to allocate file buffer"";
goto abort;
}
if (VAR_15 == 1) {
(void)snprintf(VAR_18, sizeof(VAR_18),
""bytes %lld-%lld/%lld"", range->start, range->end,
VAR_3->st_size);
if (kv_add(&VAR_6->http_headers, ""Content-Range"",
VAR_18) == NULL)
goto abort;
VAR_11 = range->end - range->start + 1;
if (buffer_add_range(VAR_13, VAR_10, range) == 0)
goto abort;
} else {
VAR_11 = 0;
VAR_17 = arc4random();
while (VAR_15--) {
if ((VAR_14 = evbuffer_add_printf(VAR_10, ""\r\n--%ud\r\n"",
VAR_17)) == -1)
goto abort;
VAR_11 += VAR_14;
if ((VAR_14 = evbuffer_add_printf(VAR_10,
""Content-Type: %s/%s\r\n"",
VAR_8->media_type, VAR_8->media_subtype)) == -1)
goto abort;
VAR_11 += VAR_14;
if ((VAR_14 = evbuffer_add_printf(VAR_10,
""Content-Range: bytes %lld-%lld/%lld\r\n\r\n"",
range->start, range->end, VAR_3->st_size)) == -1)
goto abort;
VAR_11 += VAR_14;
if (buffer_add_range(VAR_13, VAR_10, range) == 0)
goto abort;
VAR_11 += range->end - range->start + 1;
range++;
}
if ((VAR_14 = evbuffer_add_printf(VAR_10, ""\r\n--%ud--\r\n"",
VAR_17)) == -1)
goto abort;
VAR_11 += VAR_14;
(void)strlcpy(VAR_9.media_type, ""multipart"",
sizeof(VAR_9.media_type));
(void)snprintf(VAR_9.media_subtype,
sizeof(VAR_9.media_subtype),
""byteranges; boundary=%ud"", VAR_17);
VAR_8 = &VAR_9;
}
close(VAR_13);
VAR_13 = -1;
VAR_16 = server_response_http(VAR_1, 206, VAR_8, VAR_11,
MINIMUM(time(NULL), VAR_3->st_mtim.tv_sec));
switch (VAR_16) {
case -1:
goto fail;
case 0:
goto done;
default:
break;
}
if (server_bufferevent_write_buffer(VAR_1, VAR_10) == -1)
goto fail;
bufferevent_enable(VAR_1->clt_bev, VAR_22|VAR_23);
if (VAR_1->clt_persist)
VAR_1->clt_toread = VAR_24;
else
VAR_1->clt_toread = VAR_25;
VAR_1->clt_done = 0;
done:
evbuffer_free(VAR_10);
server_reset_http(VAR_1);
return (0);
fail:
bufferevent_disable(VAR_1->clt_bev, VAR_22|VAR_23);
bufferevent_free(VAR_1->clt_bev);
VAR_1->clt_bev = NULL;
abort:
if (VAR_10 != NULL)
evbuffer_free(VAR_10);
if (VAR_13 != -1)
close(VAR_13);
if (VAR_19 == NULL)
VAR_19 = strerror(VAR_26);
server_abort_http(VAR_1, VAR_12, VAR_19);
return (-1);
}",openbsd/src/142cfc82b932bc211218fbd7bdda8c7ce83f19df/server_file.c/vul/before/0.json,"int
server_partial_file_request(struct httpd *env, struct client *clt, char *path,
    struct stat *st, char *range_str)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct http_descriptor	*resp = clt->clt_descresp;
	struct http_descriptor	*desc = clt->clt_descreq;
	struct media_type	*media, multipart_media;
	struct range_data	*r = &clt->clt_ranges;
	struct range		*range;
	size_t			 content_length = 0;
	int			 code = 500, fd = -1, i, nranges, ret;
	char			 content_range[64];
	const char		*errstr = NULL;

	/* Ignore range request for methods other than GET */
	if (desc->http_method != HTTP_METHOD_GET)
		return server_file_request(env, clt, path, st);

	if ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {
		code = 416;
		(void)snprintf(content_range, sizeof(content_range),
		    ""bytes */%lld"", st->st_size);
		errstr = content_range;
		goto abort;
	}

	/* Now open the file, should be readable or we have another problem */
	if ((fd = open(path, O_RDONLY)) == -1)
		goto abort;

	media = media_find_config(env, srv_conf, path);
	r->range_media = media;

	if (nranges == 1) {
		range = &r->range[0];
		(void)snprintf(content_range, sizeof(content_range),
		    ""bytes %lld-%lld/%lld"", range->start, range->end,
		    st->st_size);
		if (kv_add(&resp->http_headers, ""Content-Range"",
		    content_range) == NULL)
			goto abort;

		range = &r->range[0];
		content_length += range->end - range->start + 1;
	} else {
		/* Add boundary, all parts will be handled by the callback */
		arc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));

		/* Calculate Content-Length of the complete multipart body */
		for (i = 0; i < nranges; i++) {
			range = &r->range[i];

			/* calculate Content-Length of the complete body */
			if ((ret = snprintf(NULL, 0,
			    ""\r\n--%llu\r\n""
			    ""Content-Type: %s/%s\r\n""
			    ""Content-Range: bytes %lld-%lld/%lld\r\n\r\n"",
			    clt->clt_boundary,
			    media->media_type, media->media_subtype,
			    range->start, range->end, st->st_size)) < 0)
				goto abort;

			/* Add data length */
			content_length += ret + range->end - range->start + 1;

		}
		if ((ret = snprintf(NULL, 0, ""\r\n--%llu--\r\n"",
		    clt->clt_boundary)) < 0)
			goto abort;
		content_length += ret;

		/* prepare multipart/byteranges media type */
		(void)strlcpy(multipart_media.media_type, ""multipart"",
		    sizeof(multipart_media.media_type));
		(void)snprintf(multipart_media.media_subtype,
		    sizeof(multipart_media.media_subtype),
		    ""byteranges; boundary=%llu"", clt->clt_boundary);
		media = &multipart_media;
	}

	/* Start with first range */
	r->range_toread = TOREAD_HTTP_RANGE;

	ret = server_response_http(clt, 206, media, content_length,
	    MINIMUM(time(NULL), st->st_mtim.tv_sec));
	switch (ret) {
	case -1:
		goto fail;
	case 0:
		/* Connection is already finished */
		close(fd);
		goto done;
	default:
		break;
	}

	clt->clt_fd = fd;
	if (clt->clt_srvbev != NULL)
		bufferevent_free(clt->clt_srvbev);

	clt->clt_srvbev_throttled = 0;
	clt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,
	    server_write, server_file_error, clt);
	if (clt->clt_srvbev == NULL) {
		errstr = ""failed to allocate file buffer event"";
		goto fail;
	}

	/* Adjust read watermark to the socket output buffer size */
	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
	    clt->clt_sndbufsiz);

	bufferevent_settimeout(clt->clt_srvbev,
	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
	bufferevent_enable(clt->clt_srvbev, EV_READ);
	bufferevent_disable(clt->clt_bev, EV_READ);

 done:
	server_reset_http(clt);
	return (0);
 fail:
	bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
	bufferevent_free(clt->clt_bev);
	clt->clt_bev = NULL;
 abort:
	if (fd != -1)
		close(fd);
	if (errstr == NULL)
		errstr = strerror(errno);
	server_abort_http(clt, code, errstr);
	return (-1);
}","int
server_partial_file_request(struct httpd *VAR_0, struct client *VAR_1, char *VAR_2,
    struct stat *VAR_3, char *VAR_4)
{
	struct server_config	*VAR_5 = VAR_1->clt_srv_conf;
	struct http_descriptor	*VAR_6 = VAR_1->clt_descresp;
	struct http_descriptor	*VAR_7 = VAR_1->clt_descreq;
	struct media_type	*VAR_8, VAR_9;
	struct range_data	*VAR_10 = &VAR_1->clt_ranges;
	struct range		*range;
	size_t			 VAR_11 = 0;
	int			 VAR_12 = 500, VAR_13 = -1, VAR_14, VAR_15, VAR_16;
	char			 VAR_17[64];
	const char		*VAR_18 = NULL;

	/* COMMENT_0 */
	if (VAR_7->http_method != VAR_19)
		return server_file_request(VAR_0, VAR_1, VAR_2, VAR_3);

	if ((VAR_15 = parse_ranges(VAR_1, VAR_4, VAR_3->st_size)) < 1) {
		VAR_12 = 416;
		(void)snprintf(VAR_17, sizeof(VAR_17),
		    ""bytes */%lld"", VAR_3->st_size);
		VAR_18 = VAR_17;
		goto abort;
	}

	/* COMMENT_1 */
	if ((VAR_13 = open(VAR_2, VAR_20)) == -1)
		goto abort;

	VAR_8 = media_find_config(VAR_0, VAR_5, VAR_2);
	VAR_10->range_media = VAR_8;

	if (VAR_15 == 1) {
		range = &VAR_10->range[0];
		(void)snprintf(VAR_17, sizeof(VAR_17),
		    ""bytes %lld-%lld/%lld"", range->start, range->end,
		    VAR_3->st_size);
		if (kv_add(&VAR_6->http_headers, ""Content-Range"",
		    VAR_17) == NULL)
			goto abort;

		range = &VAR_10->range[0];
		VAR_11 += range->end - range->start + 1;
	} else {
		/* COMMENT_2 */
		arc4random_buf(&VAR_1->clt_boundary, sizeof(VAR_1->clt_boundary));

		/* COMMENT_3 */
		for (VAR_14 = 0; VAR_14 < VAR_15; VAR_14++) {
			range = &VAR_10->range[VAR_14];

			/* COMMENT_4 */
			if ((VAR_16 = snprintf(NULL, 0,
			    ""\r\n--%llu\r\n""
			    ""Content-Type: %s/%s\r\n""
			    ""Content-Range: bytes %lld-%lld/%lld\r\n\r\n"",
			    VAR_1->clt_boundary,
			    VAR_8->media_type, VAR_8->media_subtype,
			    range->start, range->end, VAR_3->st_size)) < 0)
				goto abort;

			/* COMMENT_5 */
			VAR_11 += VAR_16 + range->end - range->start + 1;

		}
		if ((VAR_16 = snprintf(NULL, 0, ""\r\n--%llu--\r\n"",
		    VAR_1->clt_boundary)) < 0)
			goto abort;
		VAR_11 += VAR_16;

		/* COMMENT_6 */
		(void)strlcpy(VAR_9.media_type, ""multipart"",
		    sizeof(VAR_9.media_type));
		(void)snprintf(VAR_9.media_subtype,
		    sizeof(VAR_9.media_subtype),
		    ""byteranges; boundary=%llu"", VAR_1->clt_boundary);
		VAR_8 = &VAR_9;
	}

	/* COMMENT_7 */
	VAR_10->range_toread = VAR_21;

	VAR_16 = server_response_http(VAR_1, 206, VAR_8, VAR_11,
	    MINIMUM(time(NULL), VAR_3->st_mtim.tv_sec));
	switch (VAR_16) {
	case -1:
		goto fail;
	case 0:
		/* COMMENT_8 */
		close(VAR_13);
		goto done;
	default:
		break;
	}

	VAR_1->clt_fd = VAR_13;
	if (VAR_1->clt_srvbev != NULL)
		bufferevent_free(VAR_1->clt_srvbev);

	VAR_1->clt_srvbev_throttled = 0;
	VAR_1->clt_srvbev = bufferevent_new(VAR_1->clt_fd, VAR_22,
	    VAR_23, VAR_24, VAR_1);
	if (VAR_1->clt_srvbev == NULL) {
		VAR_18 = ""failed to allocate file buffer event"";
		goto fail;
	}

	/* COMMENT_9 */
	bufferevent_setwatermark(VAR_1->clt_srvbev, VAR_25, 0,
	    VAR_1->clt_sndbufsiz);

	bufferevent_settimeout(VAR_1->clt_srvbev,
	    VAR_5->timeout.tv_sec, VAR_5->timeout.tv_sec);
	bufferevent_enable(VAR_1->clt_srvbev, VAR_25);
	bufferevent_disable(VAR_1->clt_bev, VAR_25);

 done:
	server_reset_http(VAR_1);
	return (0);
 fail:
	bufferevent_disable(VAR_1->clt_bev, VAR_25|VAR_26);
	bufferevent_free(VAR_1->clt_bev);
	VAR_1->clt_bev = NULL;
 abort:
	if (VAR_13 != -1)
		close(VAR_13);
	if (VAR_18 == NULL)
		VAR_18 = strerror(VAR_27);
	server_abort_http(VAR_1, VAR_12, VAR_18);
	return (-1);
}",openbsd/src/142cfc82b932bc211218fbd7bdda8c7ce83f19df/server_file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,11 +6,10 @@
 	struct http_descriptor	*resp = clt->clt_descresp;
 	struct http_descriptor	*desc = clt->clt_descreq;
 	struct media_type	*media, multipart_media;
+	struct range_data	*r = &clt->clt_ranges;
 	struct range		*range;
-	struct evbuffer		*evb = NULL;
-	size_t			 content_length;
+	size_t			 content_length = 0;
 	int			 code = 500, fd = -1, i, nranges, ret;
-	uint32_t		 boundary;
 	char			 content_range[64];
 	const char		*errstr = NULL;
 
@@ -18,7 +17,7 @@
 	if (desc->http_method != HTTP_METHOD_GET)
 		return server_file_request(env, clt, path, st);
 
-	if ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {
+	if ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {
 		code = 416;
 		(void)snprintf(content_range, sizeof(content_range),
 		    ""bytes */%lld"", st->st_size);
@@ -31,12 +30,10 @@
 		goto abort;
 
 	media = media_find_config(env, srv_conf, path);
-	if ((evb = evbuffer_new()) == NULL) {
-		errstr = ""failed to allocate file buffer"";
-		goto abort;
-	}
+	r->range_media = media;
 
 	if (nranges == 1) {
+		range = &r->range[0];
 		(void)snprintf(content_range, sizeof(content_range),
 		    ""bytes %lld-%lld/%lld"", range->start, range->end,
 		    st->st_size);
@@ -44,56 +41,46 @@
 		    content_range) == NULL)
 			goto abort;
 
-		content_length = range->end - range->start + 1;
-		if (buffer_add_range(fd, evb, range) == 0)
-			goto abort;
+		range = &r->range[0];
+		content_length += range->end - range->start + 1;
+	} else {
+		/* Add boundary, all parts will be handled by the callback */
+		arc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));
 
-	} else {
-		content_length = 0;
-		boundary = arc4random();
-		/* Generate a multipart payload of byteranges */
-		while (nranges--) {
-			if ((i = evbuffer_add_printf(evb, ""\r\n--%ud\r\n"",
-			    boundary)) == -1)
+		/* Calculate Content-Length of the complete multipart body */
+		for (i = 0; i < nranges; i++) {
+			range = &r->range[i];
+
+			/* calculate Content-Length of the complete body */
+			if ((ret = snprintf(NULL, 0,
+			    ""\r\n--%llu\r\n""
+			    ""Content-Type: %s/%s\r\n""
+			    ""Content-Range: bytes %lld-%lld/%lld\r\n\r\n"",
+			    clt->clt_boundary,
+			    media->media_type, media->media_subtype,
+			    range->start, range->end, st->st_size)) < 0)
 				goto abort;
 
-			content_length += i;
-			if ((i = evbuffer_add_printf(evb,
-			    ""Content-Type: %s/%s\r\n"",
-			    media->media_type, media->media_subtype)) == -1)
-				goto abort;
+			/* Add data length */
+			content_length += ret + range->end - range->start + 1;
 
-			content_length += i;
-			if ((i = evbuffer_add_printf(evb,
-			    ""Content-Range: bytes %lld-%lld/%lld\r\n\r\n"",
-			    range->start, range->end, st->st_size)) == -1)
-				goto abort;
-
-			content_length += i;
-			if (buffer_add_range(fd, evb, range) == 0)
-				goto abort;
-
-			content_length += range->end - range->start + 1;
-			range++;
 		}
-
-		if ((i = evbuffer_add_printf(evb, ""\r\n--%ud--\r\n"",
-		    boundary)) == -1)
+		if ((ret = snprintf(NULL, 0, ""\r\n--%llu--\r\n"",
+		    clt->clt_boundary)) < 0)
 			goto abort;
-
-		content_length += i;
+		content_length += ret;
 
 		/* prepare multipart/byteranges media type */
 		(void)strlcpy(multipart_media.media_type, ""multipart"",
 		    sizeof(multipart_media.media_type));
 		(void)snprintf(multipart_media.media_subtype,
 		    sizeof(multipart_media.media_subtype),
-		    ""byteranges; boundary=%ud"", boundary);
+		    ""byteranges; boundary=%llu"", clt->clt_boundary);
 		media = &multipart_media;
 	}
 
-	close(fd);
-	fd = -1;
+	/* Start with first range */
+	r->range_toread = TOREAD_HTTP_RANGE;
 
 	ret = server_response_http(clt, 206, media, content_length,
 	    MINIMUM(time(NULL), st->st_mtim.tv_sec));
@@ -102,23 +89,34 @@
 		goto fail;
 	case 0:
 		/* Connection is already finished */
+		close(fd);
 		goto done;
 	default:
 		break;
 	}
 
-	if (server_bufferevent_write_buffer(clt, evb) == -1)
+	clt->clt_fd = fd;
+	if (clt->clt_srvbev != NULL)
+		bufferevent_free(clt->clt_srvbev);
+
+	clt->clt_srvbev_throttled = 0;
+	clt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,
+	    server_write, server_file_error, clt);
+	if (clt->clt_srvbev == NULL) {
+		errstr = ""failed to allocate file buffer event"";
 		goto fail;
+	}
 
-	bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
-	if (clt->clt_persist)
-		clt->clt_toread = TOREAD_HTTP_HEADER;
-	else
-		clt->clt_toread = TOREAD_HTTP_NONE;
-	clt->clt_done = 0;
+	/* Adjust read watermark to the socket output buffer size */
+	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
+	    clt->clt_sndbufsiz);
+
+	bufferevent_settimeout(clt->clt_srvbev,
+	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
+	bufferevent_enable(clt->clt_srvbev, EV_READ);
+	bufferevent_disable(clt->clt_bev, EV_READ);
 
  done:
-	evbuffer_free(evb);
 	server_reset_http(clt);
 	return (0);
  fail:
@@ -126,8 +124,6 @@
 	bufferevent_free(clt->clt_bev);
 	clt->clt_bev = NULL;
  abort:
-	if (evb != NULL)
-		evbuffer_free(evb);
 	if (fd != -1)
 		close(fd);
 	if (errstr == NULL)","{'deleted_lines': ['\tstruct evbuffer\t\t*evb = NULL;', '\tsize_t\t\t\t content_length;', '\tuint32_t\t\t boundary;', '\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {', '\tif ((evb = evbuffer_new()) == NULL) {', '\t\terrstr = ""failed to allocate file buffer"";', '\t\tgoto abort;', '\t}', '\t\tcontent_length = range->end - range->start + 1;', '\t\tif (buffer_add_range(fd, evb, range) == 0)', '\t\t\tgoto abort;', '\t} else {', '\t\tcontent_length = 0;', '\t\tboundary = arc4random();', '\t\t/* Generate a multipart payload of byteranges */', '\t\twhile (nranges--) {', '\t\t\tif ((i = evbuffer_add_printf(evb, ""\\r\\n--%ud\\r\\n"",', '\t\t\t    boundary)) == -1)', '\t\t\tcontent_length += i;', '\t\t\tif ((i = evbuffer_add_printf(evb,', '\t\t\t    ""Content-Type: %s/%s\\r\\n"",', '\t\t\t    media->media_type, media->media_subtype)) == -1)', '\t\t\t\tgoto abort;', '\t\t\tcontent_length += i;', '\t\t\tif ((i = evbuffer_add_printf(evb,', '\t\t\t    ""Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n"",', '\t\t\t    range->start, range->end, st->st_size)) == -1)', '\t\t\t\tgoto abort;', '', '\t\t\tcontent_length += i;', '\t\t\tif (buffer_add_range(fd, evb, range) == 0)', '\t\t\t\tgoto abort;', '', '\t\t\tcontent_length += range->end - range->start + 1;', '\t\t\trange++;', '', '\t\tif ((i = evbuffer_add_printf(evb, ""\\r\\n--%ud--\\r\\n"",', '\t\t    boundary)) == -1)', '', '\t\tcontent_length += i;', '\t\t    ""byteranges; boundary=%ud"", boundary);', '\tclose(fd);', '\tfd = -1;', '\tif (server_bufferevent_write_buffer(clt, evb) == -1)', '\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);', '\tif (clt->clt_persist)', '\t\tclt->clt_toread = TOREAD_HTTP_HEADER;', '\telse', '\t\tclt->clt_toread = TOREAD_HTTP_NONE;', '\tclt->clt_done = 0;', '\tevbuffer_free(evb);', '\tif (evb != NULL)', '\t\tevbuffer_free(evb);'], 'added_lines': ['\tstruct range_data\t*r = &clt->clt_ranges;', '\tsize_t\t\t\t content_length = 0;', '\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {', '\tr->range_media = media;', '\t\trange = &r->range[0];', '\t\trange = &r->range[0];', '\t\tcontent_length += range->end - range->start + 1;', '\t} else {', '\t\t/* Add boundary, all parts will be handled by the callback */', '\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));', '\t\t/* Calculate Content-Length of the complete multipart body */', '\t\tfor (i = 0; i < nranges; i++) {', '\t\t\trange = &r->range[i];', '', '\t\t\t/* calculate Content-Length of the complete body */', '\t\t\tif ((ret = snprintf(NULL, 0,', '\t\t\t    ""\\r\\n--%llu\\r\\n""', '\t\t\t    ""Content-Type: %s/%s\\r\\n""', '\t\t\t    ""Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n"",', '\t\t\t    clt->clt_boundary,', '\t\t\t    media->media_type, media->media_subtype,', '\t\t\t    range->start, range->end, st->st_size)) < 0)', '\t\t\t/* Add data length */', '\t\t\tcontent_length += ret + range->end - range->start + 1;', '\t\tif ((ret = snprintf(NULL, 0, ""\\r\\n--%llu--\\r\\n"",', '\t\t    clt->clt_boundary)) < 0)', '\t\tcontent_length += ret;', '\t\t    ""byteranges; boundary=%llu"", clt->clt_boundary);', '\t/* Start with first range */', '\tr->range_toread = TOREAD_HTTP_RANGE;', '\t\tclose(fd);', '\tclt->clt_fd = fd;', '\tif (clt->clt_srvbev != NULL)', '\t\tbufferevent_free(clt->clt_srvbev);', '', '\tclt->clt_srvbev_throttled = 0;', '\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,', '\t    server_write, server_file_error, clt);', '\tif (clt->clt_srvbev == NULL) {', '\t\terrstr = ""failed to allocate file buffer event"";', '\t}', '\t/* Adjust read watermark to the socket output buffer size */', '\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,', '\t    clt->clt_sndbufsiz);', '', '\tbufferevent_settimeout(clt->clt_srvbev,', '\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);', '\tbufferevent_enable(clt->clt_srvbev, EV_READ);', '\tbufferevent_disable(clt->clt_bev, EV_READ);']}",True,httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header.,7.5,HIGH,2,valid,2017-01-31T14:39:47Z,1
CVE-2017-12899,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12899/DECnet: Fix bounds checking.

If we're skipping over padding before the *real* flags, check whether
the real flags are in the captured data before fetching it.  This fixes
a buffer over-read discovered by Kamil Frankowicz.

Note one place where we don't need to do bounds checking as it's already
been done.

Add a test using the capture file supplied by the reporter(s).",c6e0531b5def26ecf912e8de6ade86cbdaed3751,https://github.com/the-tcpdump-group/tcpdump/commit/c6e0531b5def26ecf912e8de6ade86cbdaed3751,print-decnet.c,decnet_print,"void
decnet_print(netdissect_options *ndo,
register const u_char *ap, register u_int length,
register u_int caplen)
{
register const union routehdr *rhp;
register int mflags;
int dst, src, hops;
u_int nsplen, pktlen;
const u_char *nspp;
if (length < sizeof(struct shorthdr)) {
ND_PRINT((ndo, ""%s"", tstr));
return;
}
ND_TCHECK2(*ap, sizeof(short));
pktlen = EXTRACT_LE_16BITS(ap);
if (pktlen < sizeof(struct shorthdr)) {
ND_PRINT((ndo, ""%s"", tstr));
return;
}
if (pktlen > length) {
ND_PRINT((ndo, ""%s"", tstr));
return;
}
length = pktlen;
rhp = (const union routehdr *)&(ap[sizeof(short)]);
ND_TCHECK(rhp->rh_short.sh_flags);
mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
if (mflags & RMF_PAD) {
u_int padlen = mflags & RMF_PADMASK;
if (ndo->ndo_vflag)
ND_PRINT((ndo, ""[pad:%d] "", padlen));
if (length < padlen + 2) {
ND_PRINT((ndo, ""%s"", tstr));
return;
}
ND_TCHECK2(ap[sizeof(short)], padlen);
ap += padlen;
length -= padlen;
caplen -= padlen;
rhp = (const union routehdr *)&(ap[sizeof(short)]);
mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
}
if (mflags & RMF_FVER) {
ND_PRINT((ndo, ""future-version-decnet""));
ND_DEFAULTPRINT(ap, min(length, caplen));
return;
}
if (mflags & RMF_CTLMSG) {
if (!print_decnet_ctlmsg(ndo, rhp, length, caplen))
goto trunc;
return;
}
switch (mflags & RMF_MASK) {
case RMF_LONG:
if (length < sizeof(struct longhdr)) {
ND_PRINT((ndo, ""%s"", tstr));
return;
}
ND_TCHECK(rhp->rh_long);
dst =
EXTRACT_LE_16BITS(rhp->rh_long.lg_dst.dne_remote.dne_nodeaddr);
src =
EXTRACT_LE_16BITS(rhp->rh_long.lg_src.dne_remote.dne_nodeaddr);
hops = EXTRACT_LE_8BITS(rhp->rh_long.lg_visits);
nspp = &(ap[sizeof(short) + sizeof(struct longhdr)]);
nsplen = length - sizeof(struct longhdr);
break;
case RMF_SHORT:
ND_TCHECK(rhp->rh_short);
dst = EXTRACT_LE_16BITS(rhp->rh_short.sh_dst);
src = EXTRACT_LE_16BITS(rhp->rh_short.sh_src);
hops = (EXTRACT_LE_8BITS(rhp->rh_short.sh_visits) & VIS_MASK)+1;
nspp = &(ap[sizeof(short) + sizeof(struct shorthdr)]);
nsplen = length - sizeof(struct shorthdr);
break;
default:
ND_PRINT((ndo, ""unknown message flags under mask""));
ND_DEFAULTPRINT((const u_char *)ap, min(length, caplen));
return;
}
ND_PRINT((ndo, ""%s > %s %d "",
dnaddr_string(ndo, src), dnaddr_string(ndo, dst), pktlen));
if (ndo->ndo_vflag) {
if (mflags & RMF_RQR)
ND_PRINT((ndo, ""RQR ""));
if (mflags & RMF_RTS)
ND_PRINT((ndo, ""RTS ""));
if (mflags & RMF_IE)
ND_PRINT((ndo, ""IE ""));
ND_PRINT((ndo, ""%d hops "", hops));
}
if (!print_nsp(ndo, nspp, nsplen))
goto trunc;
return;
trunc:
ND_PRINT((ndo, ""%s"", tstr));
return;
}","void
decnet_print(netdissect_options *VAR_0,
register const u_char *VAR_1, register u_int VAR_2,
register u_int VAR_3)
{
register const union routehdr *VAR_4;
register int VAR_5;
int VAR_6, VAR_7, VAR_8;
u_int VAR_9, VAR_10;
const u_char *VAR_11;
if (VAR_2 < sizeof(struct shorthdr)) {
ND_PRINT((VAR_0, ""%s"", VAR_12));
return;
}
ND_TCHECK2(*VAR_1, sizeof(short));
VAR_10 = EXTRACT_LE_16BITS(VAR_1);
if (VAR_10 < sizeof(struct shorthdr)) {
ND_PRINT((VAR_0, ""%s"", VAR_12));
return;
}
if (VAR_10 > VAR_2) {
ND_PRINT((VAR_0, ""%s"", VAR_12));
return;
}
VAR_2 = VAR_10;
VAR_4 = (const union routehdr *)&(VAR_1[sizeof(short)]);
ND_TCHECK(VAR_4->rh_short.sh_flags);
VAR_5 = EXTRACT_LE_8BITS(VAR_4->rh_short.sh_flags);
if (VAR_5 & VAR_13) {
u_int VAR_14 = VAR_5 & VAR_15;
if (VAR_0->ndo_vflag)
ND_PRINT((VAR_0, ""[pad:%d] "", VAR_14));
if (VAR_2 < VAR_14 + 2) {
ND_PRINT((VAR_0, ""%s"", VAR_12));
return;
}
ND_TCHECK2(VAR_1[sizeof(short)], VAR_14);
VAR_1 += VAR_14;
VAR_2 -= VAR_14;
VAR_3 -= VAR_14;
VAR_4 = (const union routehdr *)&(VAR_1[sizeof(short)]);
VAR_5 = EXTRACT_LE_8BITS(VAR_4->rh_short.sh_flags);
}
if (VAR_5 & VAR_16) {
ND_PRINT((VAR_0, ""future-version-decnet""));
ND_DEFAULTPRINT(VAR_1, min(VAR_2, VAR_3));
return;
}
if (VAR_5 & VAR_17) {
if (!print_decnet_ctlmsg(VAR_0, VAR_4, VAR_2, VAR_3))
goto trunc;
return;
}
switch (VAR_5 & VAR_18) {
case VAR_19:
if (VAR_2 < sizeof(struct longhdr)) {
ND_PRINT((VAR_0, ""%s"", VAR_12));
return;
}
ND_TCHECK(VAR_4->rh_long);
VAR_6 =
EXTRACT_LE_16BITS(VAR_4->rh_long.lg_dst.dne_remote.dne_nodeaddr);
VAR_7 =
EXTRACT_LE_16BITS(VAR_4->rh_long.lg_src.dne_remote.dne_nodeaddr);
VAR_8 = EXTRACT_LE_8BITS(VAR_4->rh_long.lg_visits);
VAR_11 = &(VAR_1[sizeof(short) + sizeof(struct longhdr)]);
VAR_9 = VAR_2 - sizeof(struct longhdr);
break;
case VAR_20:
ND_TCHECK(VAR_4->rh_short);
VAR_6 = EXTRACT_LE_16BITS(VAR_4->rh_short.sh_dst);
VAR_7 = EXTRACT_LE_16BITS(VAR_4->rh_short.sh_src);
VAR_8 = (EXTRACT_LE_8BITS(VAR_4->rh_short.sh_visits) & VAR_21)+1;
VAR_11 = &(VAR_1[sizeof(short) + sizeof(struct shorthdr)]);
VAR_9 = VAR_2 - sizeof(struct shorthdr);
break;
default:
ND_PRINT((VAR_0, ""unknown message flags under mask""));
ND_DEFAULTPRINT((const u_char *)VAR_1, min(VAR_2, VAR_3));
return;
}
ND_PRINT((VAR_0, ""%s > %s %d "",
dnaddr_string(VAR_0, VAR_7), dnaddr_string(VAR_0, VAR_6), VAR_10));
if (VAR_0->ndo_vflag) {
if (VAR_5 & VAR_22)
ND_PRINT((VAR_0, ""RQR ""));
if (VAR_5 & VAR_23)
ND_PRINT((VAR_0, ""RTS ""));
if (VAR_5 & VAR_24)
ND_PRINT((VAR_0, ""IE ""));
ND_PRINT((VAR_0, ""%d hops "", VAR_8));
}
if (!print_nsp(VAR_0, VAR_11, VAR_9))
goto trunc;
return;
trunc:
ND_PRINT((VAR_0, ""%s"", VAR_12));
return;
}",the-tcpdump-group/tcpdump/c6e0531b5def26ecf912e8de6ade86cbdaed3751/print-decnet.c/vul/before/0.json,"void
decnet_print(netdissect_options *ndo,
             register const u_char *ap, register u_int length,
             register u_int caplen)
{
	register const union routehdr *rhp;
	register int mflags;
	int dst, src, hops;
	u_int nsplen, pktlen;
	const u_char *nspp;

	if (length < sizeof(struct shorthdr)) {
		ND_PRINT((ndo, ""%s"", tstr));
		return;
	}

	ND_TCHECK2(*ap, sizeof(short));
	pktlen = EXTRACT_LE_16BITS(ap);
	if (pktlen < sizeof(struct shorthdr)) {
		ND_PRINT((ndo, ""%s"", tstr));
		return;
	}
	if (pktlen > length) {
		ND_PRINT((ndo, ""%s"", tstr));
		return;
	}
	length = pktlen;

	rhp = (const union routehdr *)&(ap[sizeof(short)]);
	ND_TCHECK(rhp->rh_short.sh_flags);
	mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);

	if (mflags & RMF_PAD) {
	    /* pad bytes of some sort in front of message */
	    u_int padlen = mflags & RMF_PADMASK;
	    if (ndo->ndo_vflag)
		ND_PRINT((ndo, ""[pad:%d] "", padlen));
	    if (length < padlen + 2) {
		ND_PRINT((ndo, ""%s"", tstr));
		return;
	    }
	    ND_TCHECK2(ap[sizeof(short)], padlen);
	    ap += padlen;
	    length -= padlen;
	    caplen -= padlen;
	    rhp = (const union routehdr *)&(ap[sizeof(short)]);
	    ND_TCHECK(rhp->rh_short.sh_flags);
	    mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
	}

	if (mflags & RMF_FVER) {
		ND_PRINT((ndo, ""future-version-decnet""));
		ND_DEFAULTPRINT(ap, min(length, caplen));
		return;
	}

	/* is it a control message? */
	if (mflags & RMF_CTLMSG) {
		if (!print_decnet_ctlmsg(ndo, rhp, length, caplen))
			goto trunc;
		return;
	}

	switch (mflags & RMF_MASK) {
	case RMF_LONG:
	    if (length < sizeof(struct longhdr)) {
		ND_PRINT((ndo, ""%s"", tstr));
		return;
	    }
	    ND_TCHECK(rhp->rh_long);
	    dst =
		EXTRACT_LE_16BITS(rhp->rh_long.lg_dst.dne_remote.dne_nodeaddr);
	    src =
		EXTRACT_LE_16BITS(rhp->rh_long.lg_src.dne_remote.dne_nodeaddr);
	    hops = EXTRACT_LE_8BITS(rhp->rh_long.lg_visits);
	    nspp = &(ap[sizeof(short) + sizeof(struct longhdr)]);
	    nsplen = length - sizeof(struct longhdr);
	    break;
	case RMF_SHORT:
	    ND_TCHECK(rhp->rh_short);
	    dst = EXTRACT_LE_16BITS(rhp->rh_short.sh_dst);
	    src = EXTRACT_LE_16BITS(rhp->rh_short.sh_src);
	    hops = (EXTRACT_LE_8BITS(rhp->rh_short.sh_visits) & VIS_MASK)+1;
	    nspp = &(ap[sizeof(short) + sizeof(struct shorthdr)]);
	    nsplen = length - sizeof(struct shorthdr);
	    break;
	default:
	    ND_PRINT((ndo, ""unknown message flags under mask""));
	    ND_DEFAULTPRINT((const u_char *)ap, min(length, caplen));
	    return;
	}

	ND_PRINT((ndo, ""%s > %s %d "",
			dnaddr_string(ndo, src), dnaddr_string(ndo, dst), pktlen));
	if (ndo->ndo_vflag) {
	    if (mflags & RMF_RQR)
		ND_PRINT((ndo, ""RQR ""));
	    if (mflags & RMF_RTS)
		ND_PRINT((ndo, ""RTS ""));
	    if (mflags & RMF_IE)
		ND_PRINT((ndo, ""IE ""));
	    ND_PRINT((ndo, ""%d hops "", hops));
	}

	if (!print_nsp(ndo, nspp, nsplen))
		goto trunc;
	return;

trunc:
	ND_PRINT((ndo, ""%s"", tstr));
	return;
}","void
decnet_print(netdissect_options *VAR_0,
             register const u_char *VAR_1, register u_int VAR_2,
             register u_int VAR_3)
{
	register const union routehdr *VAR_4;
	register int VAR_5;
	int VAR_6, VAR_7, VAR_8;
	u_int VAR_9, VAR_10;
	const u_char *VAR_11;

	if (VAR_2 < sizeof(struct shorthdr)) {
		ND_PRINT((VAR_0, ""%s"", VAR_12));
		return;
	}

	ND_TCHECK2(*VAR_1, sizeof(short));
	VAR_10 = EXTRACT_LE_16BITS(VAR_1);
	if (VAR_10 < sizeof(struct shorthdr)) {
		ND_PRINT((VAR_0, ""%s"", VAR_12));
		return;
	}
	if (VAR_10 > VAR_2) {
		ND_PRINT((VAR_0, ""%s"", VAR_12));
		return;
	}
	VAR_2 = VAR_10;

	VAR_4 = (const union routehdr *)&(VAR_1[sizeof(short)]);
	ND_TCHECK(VAR_4->rh_short.sh_flags);
	VAR_5 = EXTRACT_LE_8BITS(VAR_4->rh_short.sh_flags);

	if (VAR_5 & VAR_13) {
	    /* COMMENT_0 */
	    u_int VAR_14 = VAR_5 & VAR_15;
	    if (VAR_0->ndo_vflag)
		ND_PRINT((VAR_0, ""[pad:%d] "", VAR_14));
	    if (VAR_2 < VAR_14 + 2) {
		ND_PRINT((VAR_0, ""%s"", VAR_12));
		return;
	    }
	    ND_TCHECK2(VAR_1[sizeof(short)], VAR_14);
	    VAR_1 += VAR_14;
	    VAR_2 -= VAR_14;
	    VAR_3 -= VAR_14;
	    VAR_4 = (const union routehdr *)&(VAR_1[sizeof(short)]);
	    ND_TCHECK(VAR_4->rh_short.sh_flags);
	    VAR_5 = EXTRACT_LE_8BITS(VAR_4->rh_short.sh_flags);
	}

	if (VAR_5 & VAR_16) {
		ND_PRINT((VAR_0, ""future-version-decnet""));
		ND_DEFAULTPRINT(VAR_1, min(VAR_2, VAR_3));
		return;
	}

	/* COMMENT_1 */
	if (VAR_5 & VAR_17) {
		if (!print_decnet_ctlmsg(VAR_0, VAR_4, VAR_2, VAR_3))
			goto trunc;
		return;
	}

	switch (VAR_5 & VAR_18) {
	case VAR_19:
	    if (VAR_2 < sizeof(struct longhdr)) {
		ND_PRINT((VAR_0, ""%s"", VAR_12));
		return;
	    }
	    ND_TCHECK(VAR_4->rh_long);
	    VAR_6 =
		EXTRACT_LE_16BITS(VAR_4->rh_long.lg_dst.dne_remote.dne_nodeaddr);
	    VAR_7 =
		EXTRACT_LE_16BITS(VAR_4->rh_long.lg_src.dne_remote.dne_nodeaddr);
	    VAR_8 = EXTRACT_LE_8BITS(VAR_4->rh_long.lg_visits);
	    VAR_11 = &(VAR_1[sizeof(short) + sizeof(struct longhdr)]);
	    VAR_9 = VAR_2 - sizeof(struct longhdr);
	    break;
	case VAR_20:
	    ND_TCHECK(VAR_4->rh_short);
	    VAR_6 = EXTRACT_LE_16BITS(VAR_4->rh_short.sh_dst);
	    VAR_7 = EXTRACT_LE_16BITS(VAR_4->rh_short.sh_src);
	    VAR_8 = (EXTRACT_LE_8BITS(VAR_4->rh_short.sh_visits) & VAR_21)+1;
	    VAR_11 = &(VAR_1[sizeof(short) + sizeof(struct shorthdr)]);
	    VAR_9 = VAR_2 - sizeof(struct shorthdr);
	    break;
	default:
	    ND_PRINT((VAR_0, ""unknown message flags under mask""));
	    ND_DEFAULTPRINT((const u_char *)VAR_1, min(VAR_2, VAR_3));
	    return;
	}

	ND_PRINT((VAR_0, ""%s > %s %d "",
			dnaddr_string(VAR_0, VAR_7), dnaddr_string(VAR_0, VAR_6), VAR_10));
	if (VAR_0->ndo_vflag) {
	    if (VAR_5 & VAR_22)
		ND_PRINT((VAR_0, ""RQR ""));
	    if (VAR_5 & VAR_23)
		ND_PRINT((VAR_0, ""RTS ""));
	    if (VAR_5 & VAR_24)
		ND_PRINT((VAR_0, ""IE ""));
	    ND_PRINT((VAR_0, ""%d hops "", VAR_8));
	}

	if (!print_nsp(VAR_0, VAR_11, VAR_9))
		goto trunc;
	return;

trunc:
	ND_PRINT((VAR_0, ""%s"", VAR_12));
	return;
}",the-tcpdump-group/tcpdump/c6e0531b5def26ecf912e8de6ade86cbdaed3751/print-decnet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -44,6 +44,7 @@
 	    length -= padlen;
 	    caplen -= padlen;
 	    rhp = (const union routehdr *)&(ap[sizeof(short)]);
+	    ND_TCHECK(rhp->rh_short.sh_flags);
 	    mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t    ND_TCHECK(rhp->rh_short.sh_flags);']}",True,The DECnet parser in tcpdump before 4.9.2 has a buffer over-read in print-decnet.c:decnet_print().,9.8,CRITICAL,3,valid,2017-02-03T23:52:24Z,1
CVE-2017-12899,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12899/DECnet: Fix bounds checking.

If we're skipping over padding before the *real* flags, check whether
the real flags are in the captured data before fetching it.  This fixes
a buffer over-read discovered by Kamil Frankowicz.

Note one place where we don't need to do bounds checking as it's already
been done.

Add a test using the capture file supplied by the reporter(s).",c6e0531b5def26ecf912e8de6ade86cbdaed3751,https://github.com/the-tcpdump-group/tcpdump/commit/c6e0531b5def26ecf912e8de6ade86cbdaed3751,print-decnet.c,print_decnet_ctlmsg,"static int
print_decnet_ctlmsg(netdissect_options *ndo,
register const union routehdr *rhp, u_int length,
u_int caplen)
{
int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
register const union controlmsg *cmp = (const union controlmsg *)rhp;
int src, dst, info, blksize, eco, ueco, hello, other, vers;
etheraddr srcea, rtea;
int priority;
const char *rhpx = (const char *)rhp;
int ret;
switch (mflags & RMF_CTLMASK) {
case RMF_INIT:
ND_PRINT((ndo, ""init ""));
if (length < sizeof(struct initmsg))
goto trunc;
ND_TCHECK(cmp->cm_init);
src = EXTRACT_LE_16BITS(cmp->cm_init.in_src);
info = EXTRACT_LE_8BITS(cmp->cm_init.in_info);
blksize = EXTRACT_LE_16BITS(cmp->cm_init.in_blksize);
vers = EXTRACT_LE_8BITS(cmp->cm_init.in_vers);
eco = EXTRACT_LE_8BITS(cmp->cm_init.in_eco);
ueco = EXTRACT_LE_8BITS(cmp->cm_init.in_ueco);
hello = EXTRACT_LE_16BITS(cmp->cm_init.in_hello);
print_t_info(ndo, info);
ND_PRINT((ndo,
""src %sblksize %d vers %d eco %d ueco %d hello %d"",
dnaddr_string(ndo, src), blksize, vers, eco, ueco,
hello));
ret = 1;
break;
case RMF_VER:
ND_PRINT((ndo, ""verification ""));
if (length < sizeof(struct verifmsg))
goto trunc;
ND_TCHECK(cmp->cm_ver);
src = EXTRACT_LE_16BITS(cmp->cm_ver.ve_src);
other = EXTRACT_LE_8BITS(cmp->cm_ver.ve_fcnval);
ND_PRINT((ndo, ""src %s fcnval %o"", dnaddr_string(ndo, src), other));
ret = 1;
break;
case RMF_TEST:
ND_PRINT((ndo, ""test ""));
if (length < sizeof(struct testmsg))
goto trunc;
ND_TCHECK(cmp->cm_test);
src = EXTRACT_LE_16BITS(cmp->cm_test.te_src);
other = EXTRACT_LE_8BITS(cmp->cm_test.te_data);
ND_PRINT((ndo, ""src %s data %o"", dnaddr_string(ndo, src), other));
ret = 1;
break;
case RMF_L1ROUT:
ND_PRINT((ndo, ""lev-1-routing ""));
if (length < sizeof(struct l1rout))
goto trunc;
ND_TCHECK(cmp->cm_l1rou);
src = EXTRACT_LE_16BITS(cmp->cm_l1rou.r1_src);
ND_PRINT((ndo, ""src %s "", dnaddr_string(ndo, src)));
ret = print_l1_routes(ndo, &(rhpx[sizeof(struct l1rout)]),
length - sizeof(struct l1rout));
break;
case RMF_L2ROUT:
ND_PRINT((ndo, ""lev-2-routing ""));
if (length < sizeof(struct l2rout))
goto trunc;
ND_TCHECK(cmp->cm_l2rout);
src = EXTRACT_LE_16BITS(cmp->cm_l2rout.r2_src);
ND_PRINT((ndo, ""src %s "", dnaddr_string(ndo, src)));
ret = print_l2_routes(ndo, &(rhpx[sizeof(struct l2rout)]),
length - sizeof(struct l2rout));
break;
case RMF_RHELLO:
ND_PRINT((ndo, ""router-hello ""));
if (length < sizeof(struct rhellomsg))
goto trunc;
ND_TCHECK(cmp->cm_rhello);
vers = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_vers);
eco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_eco);
ueco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_ueco);
memcpy((char *)&srcea, (const char *)&(cmp->cm_rhello.rh_src),
sizeof(srcea));
src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);
info = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_info);
blksize = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_blksize);
priority = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_priority);
hello = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_hello);
print_i_info(ndo, info);
ND_PRINT((ndo,
""vers %d eco %d ueco %d src %s blksize %d pri %d hello %d"",
vers, eco, ueco, dnaddr_string(ndo, src),
blksize, priority, hello));
ret = print_elist(&(rhpx[sizeof(struct rhellomsg)]),
length - sizeof(struct rhellomsg));
break;
case RMF_EHELLO:
ND_PRINT((ndo, ""endnode-hello ""));
if (length < sizeof(struct ehellomsg))
goto trunc;
ND_TCHECK(cmp->cm_ehello);
vers = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_vers);
eco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_eco);
ueco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_ueco);
memcpy((char *)&srcea, (const char *)&(cmp->cm_ehello.eh_src),
sizeof(srcea));
src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);
info = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_info);
blksize = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_blksize);
memcpy((char *)&rtea, (const char *)&(cmp->cm_ehello.eh_router),
sizeof(rtea));
dst = EXTRACT_LE_16BITS(rtea.dne_remote.dne_nodeaddr);
hello = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_hello);
other = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_data);
print_i_info(ndo, info);
ND_PRINT((ndo,
""vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o"",
vers, eco, ueco, dnaddr_string(ndo, src),
blksize, dnaddr_string(ndo, dst), hello, other));
ret = 1;
break;
default:
ND_PRINT((ndo, ""unknown control message""));
ND_DEFAULTPRINT((const u_char *)rhp, min(length, caplen));
ret = 1;
break;
}
return (ret);
trunc:
return (0);
}","static int
print_decnet_ctlmsg(netdissect_options *VAR_0,
register const union routehdr *VAR_1, u_int VAR_2,
u_int VAR_3)
{
int VAR_4 = EXTRACT_LE_8BITS(VAR_1->rh_short.sh_flags);
register const union controlmsg *VAR_5 = (const union controlmsg *)VAR_1;
int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
etheraddr VAR_15, VAR_16;
int VAR_17;
const char *VAR_18 = (const char *)VAR_1;
int VAR_19;
switch (VAR_4 & VAR_20) {
case VAR_21:
ND_PRINT((VAR_0, ""init ""));
if (VAR_2 < sizeof(struct initmsg))
goto trunc;
ND_TCHECK(VAR_5->cm_init);
VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_init.in_src);
VAR_8 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_info);
VAR_9 = EXTRACT_LE_16BITS(VAR_5->cm_init.in_blksize);
VAR_14 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_vers);
VAR_10 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_eco);
VAR_11 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_ueco);
VAR_12 = EXTRACT_LE_16BITS(VAR_5->cm_init.in_hello);
print_t_info(VAR_0, VAR_8);
ND_PRINT((VAR_0,
""src %sblksize %d vers %d eco %d ueco %d hello %d"",
dnaddr_string(VAR_0, VAR_6), VAR_9, VAR_14, VAR_10, VAR_11,
VAR_12));
VAR_19 = 1;
break;
case VAR_22:
ND_PRINT((VAR_0, ""verification ""));
if (VAR_2 < sizeof(struct verifmsg))
goto trunc;
ND_TCHECK(VAR_5->cm_ver);
VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_ver.ve_src);
VAR_13 = EXTRACT_LE_8BITS(VAR_5->cm_ver.ve_fcnval);
ND_PRINT((VAR_0, ""src %s fcnval %o"", dnaddr_string(VAR_0, VAR_6), VAR_13));
VAR_19 = 1;
break;
case VAR_23:
ND_PRINT((VAR_0, ""test ""));
if (VAR_2 < sizeof(struct testmsg))
goto trunc;
ND_TCHECK(VAR_5->cm_test);
VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_test.te_src);
VAR_13 = EXTRACT_LE_8BITS(VAR_5->cm_test.te_data);
ND_PRINT((VAR_0, ""src %s data %o"", dnaddr_string(VAR_0, VAR_6), VAR_13));
VAR_19 = 1;
break;
case VAR_24:
ND_PRINT((VAR_0, ""lev-1-routing ""));
if (VAR_2 < sizeof(struct l1rout))
goto trunc;
ND_TCHECK(VAR_5->cm_l1rou);
VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_l1rou.r1_src);
ND_PRINT((VAR_0, ""src %s "", dnaddr_string(VAR_0, VAR_6)));
VAR_19 = print_l1_routes(VAR_0, &(VAR_18[sizeof(struct l1rout)]),
VAR_2 - sizeof(struct l1rout));
break;
case VAR_25:
ND_PRINT((VAR_0, ""lev-2-routing ""));
if (VAR_2 < sizeof(struct l2rout))
goto trunc;
ND_TCHECK(VAR_5->cm_l2rout);
VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_l2rout.r2_src);
ND_PRINT((VAR_0, ""src %s "", dnaddr_string(VAR_0, VAR_6)));
VAR_19 = print_l2_routes(VAR_0, &(VAR_18[sizeof(struct l2rout)]),
VAR_2 - sizeof(struct l2rout));
break;
case VAR_26:
ND_PRINT((VAR_0, ""router-hello ""));
if (VAR_2 < sizeof(struct rhellomsg))
goto trunc;
ND_TCHECK(VAR_5->cm_rhello);
VAR_14 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_vers);
VAR_10 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_eco);
VAR_11 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_ueco);
memcpy((char *)&VAR_15, (const char *)&(VAR_5->cm_rhello.rh_src),
sizeof(VAR_15));
VAR_6 = EXTRACT_LE_16BITS(VAR_15.dne_remote.dne_nodeaddr);
VAR_8 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_info);
VAR_9 = EXTRACT_LE_16BITS(VAR_5->cm_rhello.rh_blksize);
VAR_17 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_priority);
VAR_12 = EXTRACT_LE_16BITS(VAR_5->cm_rhello.rh_hello);
print_i_info(VAR_0, VAR_8);
ND_PRINT((VAR_0,
""vers %d eco %d ueco %d src %s blksize %d pri %d hello %d"",
VAR_14, VAR_10, VAR_11, dnaddr_string(VAR_0, VAR_6),
VAR_9, VAR_17, VAR_12));
VAR_19 = print_elist(&(VAR_18[sizeof(struct rhellomsg)]),
VAR_2 - sizeof(struct rhellomsg));
break;
case VAR_27:
ND_PRINT((VAR_0, ""endnode-hello ""));
if (VAR_2 < sizeof(struct ehellomsg))
goto trunc;
ND_TCHECK(VAR_5->cm_ehello);
VAR_14 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_vers);
VAR_10 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_eco);
VAR_11 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_ueco);
memcpy((char *)&VAR_15, (const char *)&(VAR_5->cm_ehello.eh_src),
sizeof(VAR_15));
VAR_6 = EXTRACT_LE_16BITS(VAR_15.dne_remote.dne_nodeaddr);
VAR_8 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_info);
VAR_9 = EXTRACT_LE_16BITS(VAR_5->cm_ehello.eh_blksize);
memcpy((char *)&VAR_16, (const char *)&(VAR_5->cm_ehello.eh_router),
sizeof(VAR_16));
VAR_7 = EXTRACT_LE_16BITS(VAR_16.dne_remote.dne_nodeaddr);
VAR_12 = EXTRACT_LE_16BITS(VAR_5->cm_ehello.eh_hello);
VAR_13 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_data);
print_i_info(VAR_0, VAR_8);
ND_PRINT((VAR_0,
""vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o"",
VAR_14, VAR_10, VAR_11, dnaddr_string(VAR_0, VAR_6),
VAR_9, dnaddr_string(VAR_0, VAR_7), VAR_12, VAR_13));
VAR_19 = 1;
break;
default:
ND_PRINT((VAR_0, ""unknown control message""));
ND_DEFAULTPRINT((const u_char *)VAR_1, min(VAR_2, VAR_3));
VAR_19 = 1;
break;
}
return (VAR_19);
trunc:
return (0);
}",the-tcpdump-group/tcpdump/c6e0531b5def26ecf912e8de6ade86cbdaed3751/print-decnet.c/vul/before/1.json,"static int
print_decnet_ctlmsg(netdissect_options *ndo,
                    register const union routehdr *rhp, u_int length,
                    u_int caplen)
{
	/* Our caller has already checked for mflags */
	int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
	register const union controlmsg *cmp = (const union controlmsg *)rhp;
	int src, dst, info, blksize, eco, ueco, hello, other, vers;
	etheraddr srcea, rtea;
	int priority;
	const char *rhpx = (const char *)rhp;
	int ret;

	switch (mflags & RMF_CTLMASK) {
	case RMF_INIT:
	    ND_PRINT((ndo, ""init ""));
	    if (length < sizeof(struct initmsg))
		goto trunc;
	    ND_TCHECK(cmp->cm_init);
	    src = EXTRACT_LE_16BITS(cmp->cm_init.in_src);
	    info = EXTRACT_LE_8BITS(cmp->cm_init.in_info);
	    blksize = EXTRACT_LE_16BITS(cmp->cm_init.in_blksize);
	    vers = EXTRACT_LE_8BITS(cmp->cm_init.in_vers);
	    eco = EXTRACT_LE_8BITS(cmp->cm_init.in_eco);
	    ueco = EXTRACT_LE_8BITS(cmp->cm_init.in_ueco);
	    hello = EXTRACT_LE_16BITS(cmp->cm_init.in_hello);
	    print_t_info(ndo, info);
	    ND_PRINT((ndo,
		""src %sblksize %d vers %d eco %d ueco %d hello %d"",
			dnaddr_string(ndo, src), blksize, vers, eco, ueco,
			hello));
	    ret = 1;
	    break;
	case RMF_VER:
	    ND_PRINT((ndo, ""verification ""));
	    if (length < sizeof(struct verifmsg))
		goto trunc;
	    ND_TCHECK(cmp->cm_ver);
	    src = EXTRACT_LE_16BITS(cmp->cm_ver.ve_src);
	    other = EXTRACT_LE_8BITS(cmp->cm_ver.ve_fcnval);
	    ND_PRINT((ndo, ""src %s fcnval %o"", dnaddr_string(ndo, src), other));
	    ret = 1;
	    break;
	case RMF_TEST:
	    ND_PRINT((ndo, ""test ""));
	    if (length < sizeof(struct testmsg))
		goto trunc;
	    ND_TCHECK(cmp->cm_test);
	    src = EXTRACT_LE_16BITS(cmp->cm_test.te_src);
	    other = EXTRACT_LE_8BITS(cmp->cm_test.te_data);
	    ND_PRINT((ndo, ""src %s data %o"", dnaddr_string(ndo, src), other));
	    ret = 1;
	    break;
	case RMF_L1ROUT:
	    ND_PRINT((ndo, ""lev-1-routing ""));
	    if (length < sizeof(struct l1rout))
		goto trunc;
	    ND_TCHECK(cmp->cm_l1rou);
	    src = EXTRACT_LE_16BITS(cmp->cm_l1rou.r1_src);
	    ND_PRINT((ndo, ""src %s "", dnaddr_string(ndo, src)));
	    ret = print_l1_routes(ndo, &(rhpx[sizeof(struct l1rout)]),
				length - sizeof(struct l1rout));
	    break;
	case RMF_L2ROUT:
	    ND_PRINT((ndo, ""lev-2-routing ""));
	    if (length < sizeof(struct l2rout))
		goto trunc;
	    ND_TCHECK(cmp->cm_l2rout);
	    src = EXTRACT_LE_16BITS(cmp->cm_l2rout.r2_src);
	    ND_PRINT((ndo, ""src %s "", dnaddr_string(ndo, src)));
	    ret = print_l2_routes(ndo, &(rhpx[sizeof(struct l2rout)]),
				length - sizeof(struct l2rout));
	    break;
	case RMF_RHELLO:
	    ND_PRINT((ndo, ""router-hello ""));
	    if (length < sizeof(struct rhellomsg))
		goto trunc;
	    ND_TCHECK(cmp->cm_rhello);
	    vers = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_vers);
	    eco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_eco);
	    ueco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_ueco);
	    memcpy((char *)&srcea, (const char *)&(cmp->cm_rhello.rh_src),
		sizeof(srcea));
	    src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);
	    info = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_info);
	    blksize = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_blksize);
	    priority = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_priority);
	    hello = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_hello);
	    print_i_info(ndo, info);
	    ND_PRINT((ndo,
	    ""vers %d eco %d ueco %d src %s blksize %d pri %d hello %d"",
			vers, eco, ueco, dnaddr_string(ndo, src),
			blksize, priority, hello));
	    ret = print_elist(&(rhpx[sizeof(struct rhellomsg)]),
				length - sizeof(struct rhellomsg));
	    break;
	case RMF_EHELLO:
	    ND_PRINT((ndo, ""endnode-hello ""));
	    if (length < sizeof(struct ehellomsg))
		goto trunc;
	    ND_TCHECK(cmp->cm_ehello);
	    vers = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_vers);
	    eco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_eco);
	    ueco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_ueco);
	    memcpy((char *)&srcea, (const char *)&(cmp->cm_ehello.eh_src),
		sizeof(srcea));
	    src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);
	    info = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_info);
	    blksize = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_blksize);
	    /*seed*/
	    memcpy((char *)&rtea, (const char *)&(cmp->cm_ehello.eh_router),
		sizeof(rtea));
	    dst = EXTRACT_LE_16BITS(rtea.dne_remote.dne_nodeaddr);
	    hello = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_hello);
	    other = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_data);
	    print_i_info(ndo, info);
	    ND_PRINT((ndo,
	""vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o"",
			vers, eco, ueco, dnaddr_string(ndo, src),
			blksize, dnaddr_string(ndo, dst), hello, other));
	    ret = 1;
	    break;

	default:
	    ND_PRINT((ndo, ""unknown control message""));
	    ND_DEFAULTPRINT((const u_char *)rhp, min(length, caplen));
	    ret = 1;
	    break;
	}
	return (ret);

trunc:
	return (0);
}","static int
print_decnet_ctlmsg(netdissect_options *VAR_0,
                    register const union routehdr *VAR_1, u_int VAR_2,
                    u_int VAR_3)
{
	/* COMMENT_0 */
	int VAR_4 = EXTRACT_LE_8BITS(VAR_1->rh_short.sh_flags);
	register const union controlmsg *VAR_5 = (const union controlmsg *)VAR_1;
	int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
	etheraddr VAR_15, VAR_16;
	int VAR_17;
	const char *VAR_18 = (const char *)VAR_1;
	int VAR_19;

	switch (VAR_4 & VAR_20) {
	case VAR_21:
	    ND_PRINT((VAR_0, ""init ""));
	    if (VAR_2 < sizeof(struct initmsg))
		goto trunc;
	    ND_TCHECK(VAR_5->cm_init);
	    VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_init.in_src);
	    VAR_8 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_info);
	    VAR_9 = EXTRACT_LE_16BITS(VAR_5->cm_init.in_blksize);
	    VAR_14 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_vers);
	    VAR_10 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_eco);
	    VAR_11 = EXTRACT_LE_8BITS(VAR_5->cm_init.in_ueco);
	    VAR_12 = EXTRACT_LE_16BITS(VAR_5->cm_init.in_hello);
	    print_t_info(VAR_0, VAR_8);
	    ND_PRINT((VAR_0,
		""src %sblksize %d vers %d eco %d ueco %d hello %d"",
			dnaddr_string(VAR_0, VAR_6), VAR_9, VAR_14, VAR_10, VAR_11,
			VAR_12));
	    VAR_19 = 1;
	    break;
	case VAR_22:
	    ND_PRINT((VAR_0, ""verification ""));
	    if (VAR_2 < sizeof(struct verifmsg))
		goto trunc;
	    ND_TCHECK(VAR_5->cm_ver);
	    VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_ver.ve_src);
	    VAR_13 = EXTRACT_LE_8BITS(VAR_5->cm_ver.ve_fcnval);
	    ND_PRINT((VAR_0, ""src %s fcnval %o"", dnaddr_string(VAR_0, VAR_6), VAR_13));
	    VAR_19 = 1;
	    break;
	case VAR_23:
	    ND_PRINT((VAR_0, ""test ""));
	    if (VAR_2 < sizeof(struct testmsg))
		goto trunc;
	    ND_TCHECK(VAR_5->cm_test);
	    VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_test.te_src);
	    VAR_13 = EXTRACT_LE_8BITS(VAR_5->cm_test.te_data);
	    ND_PRINT((VAR_0, ""src %s data %o"", dnaddr_string(VAR_0, VAR_6), VAR_13));
	    VAR_19 = 1;
	    break;
	case VAR_24:
	    ND_PRINT((VAR_0, ""lev-1-routing ""));
	    if (VAR_2 < sizeof(struct l1rout))
		goto trunc;
	    ND_TCHECK(VAR_5->cm_l1rou);
	    VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_l1rou.r1_src);
	    ND_PRINT((VAR_0, ""src %s "", dnaddr_string(VAR_0, VAR_6)));
	    VAR_19 = print_l1_routes(VAR_0, &(VAR_18[sizeof(struct l1rout)]),
				VAR_2 - sizeof(struct l1rout));
	    break;
	case VAR_25:
	    ND_PRINT((VAR_0, ""lev-2-routing ""));
	    if (VAR_2 < sizeof(struct l2rout))
		goto trunc;
	    ND_TCHECK(VAR_5->cm_l2rout);
	    VAR_6 = EXTRACT_LE_16BITS(VAR_5->cm_l2rout.r2_src);
	    ND_PRINT((VAR_0, ""src %s "", dnaddr_string(VAR_0, VAR_6)));
	    VAR_19 = print_l2_routes(VAR_0, &(VAR_18[sizeof(struct l2rout)]),
				VAR_2 - sizeof(struct l2rout));
	    break;
	case VAR_26:
	    ND_PRINT((VAR_0, ""router-hello ""));
	    if (VAR_2 < sizeof(struct rhellomsg))
		goto trunc;
	    ND_TCHECK(VAR_5->cm_rhello);
	    VAR_14 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_vers);
	    VAR_10 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_eco);
	    VAR_11 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_ueco);
	    memcpy((char *)&VAR_15, (const char *)&(VAR_5->cm_rhello.rh_src),
		sizeof(VAR_15));
	    VAR_6 = EXTRACT_LE_16BITS(VAR_15.dne_remote.dne_nodeaddr);
	    VAR_8 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_info);
	    VAR_9 = EXTRACT_LE_16BITS(VAR_5->cm_rhello.rh_blksize);
	    VAR_17 = EXTRACT_LE_8BITS(VAR_5->cm_rhello.rh_priority);
	    VAR_12 = EXTRACT_LE_16BITS(VAR_5->cm_rhello.rh_hello);
	    print_i_info(VAR_0, VAR_8);
	    ND_PRINT((VAR_0,
	    ""vers %d eco %d ueco %d src %s blksize %d pri %d hello %d"",
			VAR_14, VAR_10, VAR_11, dnaddr_string(VAR_0, VAR_6),
			VAR_9, VAR_17, VAR_12));
	    VAR_19 = print_elist(&(VAR_18[sizeof(struct rhellomsg)]),
				VAR_2 - sizeof(struct rhellomsg));
	    break;
	case VAR_27:
	    ND_PRINT((VAR_0, ""endnode-hello ""));
	    if (VAR_2 < sizeof(struct ehellomsg))
		goto trunc;
	    ND_TCHECK(VAR_5->cm_ehello);
	    VAR_14 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_vers);
	    VAR_10 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_eco);
	    VAR_11 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_ueco);
	    memcpy((char *)&VAR_15, (const char *)&(VAR_5->cm_ehello.eh_src),
		sizeof(VAR_15));
	    VAR_6 = EXTRACT_LE_16BITS(VAR_15.dne_remote.dne_nodeaddr);
	    VAR_8 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_info);
	    VAR_9 = EXTRACT_LE_16BITS(VAR_5->cm_ehello.eh_blksize);
	    /* COMMENT_1 */
	    memcpy((char *)&VAR_16, (const char *)&(VAR_5->cm_ehello.eh_router),
		sizeof(VAR_16));
	    VAR_7 = EXTRACT_LE_16BITS(VAR_16.dne_remote.dne_nodeaddr);
	    VAR_12 = EXTRACT_LE_16BITS(VAR_5->cm_ehello.eh_hello);
	    VAR_13 = EXTRACT_LE_8BITS(VAR_5->cm_ehello.eh_data);
	    print_i_info(VAR_0, VAR_8);
	    ND_PRINT((VAR_0,
	""vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o"",
			VAR_14, VAR_10, VAR_11, dnaddr_string(VAR_0, VAR_6),
			VAR_9, dnaddr_string(VAR_0, VAR_7), VAR_12, VAR_13));
	    VAR_19 = 1;
	    break;

	default:
	    ND_PRINT((VAR_0, ""unknown control message""));
	    ND_DEFAULTPRINT((const u_char *)VAR_1, min(VAR_2, VAR_3));
	    VAR_19 = 1;
	    break;
	}
	return (VAR_19);

trunc:
	return (0);
}",the-tcpdump-group/tcpdump/c6e0531b5def26ecf912e8de6ade86cbdaed3751/print-decnet.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
                     register const union routehdr *rhp, u_int length,
                     u_int caplen)
 {
+	/* Our caller has already checked for mflags */
 	int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
 	register const union controlmsg *cmp = (const union controlmsg *)rhp;
 	int src, dst, info, blksize, eco, ueco, hello, other, vers;","{'deleted_lines': [], 'added_lines': ['\t/* Our caller has already checked for mflags */']}",True,The DECnet parser in tcpdump before 4.9.2 has a buffer over-read in print-decnet.c:decnet_print().,9.8,CRITICAL,3,valid,2017-02-03T23:52:24Z,1
CVE-2017-5896,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ArtifexSoftware/mupdf,Bug 697514: Write SVG output to stdout if no output specified.,40ac85bfb676bb4373bda4b18f9fd90268c9f1e9,https://github.com/ArtifexSoftware/mupdf/commit/40ac85bfb676bb4373bda4b18f9fd90268c9f1e9,source/tools/mudraw.c,dodrawpage,"static void dodrawpage(fz_context *ctx, fz_page *page, fz_display_list *list, int pagenum, fz_cookie *cookie, int start, int interptime, char *filename, int bg)
{
fz_rect mediabox;
fz_device *dev = NULL;
fz_bound_page(ctx, page, &mediabox);
if (output_format == OUT_TRACE)
{
fz_try(ctx)
{
fz_printf(ctx, out, ""<page mediabox=\""%g %g %g %g\"">\n"",
mediabox.x0, mediabox.y0, mediabox.x1, mediabox.y1);
dev = fz_new_trace_device(ctx, out);
if (lowmemory)
fz_enable_device_hints(ctx, dev, FZ_NO_CACHE);
if (list)
fz_run_display_list(ctx, list, dev, &fz_identity, &fz_infinite_rect, cookie);
else
fz_run_page(ctx, page, dev, &fz_identity, cookie);
fz_printf(ctx, out, ""</page>\n"");
fz_close_device(ctx, dev);
}
fz_always(ctx)
{
fz_drop_device(ctx, dev);
dev = NULL;
}
fz_catch(ctx)
{
fz_drop_display_list(ctx, list);
fz_drop_page(ctx, page);
fz_rethrow(ctx);
}
}
else if (output_format == OUT_TEXT || output_format == OUT_HTML || output_format == OUT_STEXT)
{
fz_stext_page *text = NULL;
fz_var(text);
fz_try(ctx)
{
fz_rect mediabox;
if (list)
fz_bound_display_list(ctx, list, &mediabox);
else
fz_bound_page(ctx, page, &mediabox);
text = fz_new_stext_page(ctx, &mediabox);
dev = fz_new_stext_device(ctx, sheet, text, 0);
if (lowmemory)
fz_enable_device_hints(ctx, dev, FZ_NO_CACHE);
if (output_format == OUT_HTML)
fz_disable_device_hints(ctx, dev, FZ_IGNORE_IMAGE);
if (list)
fz_run_display_list(ctx, list, dev, &fz_identity, &fz_infinite_rect, cookie);
else
fz_run_page(ctx, page, dev, &fz_identity, cookie);
fz_close_device(ctx, dev);
fz_drop_device(ctx, dev);
dev = NULL;
if (output_format == OUT_STEXT)
{
fz_print_stext_page_xml(ctx, out, text);
}
else if (output_format == OUT_HTML)
{
fz_analyze_text(ctx, sheet, text);
fz_print_stext_page_html(ctx, out, text);
}
else if (output_format == OUT_TEXT)
{
fz_print_stext_page(ctx, out, text);
fz_printf(ctx, out, ""\f\n"");
}
}
fz_always(ctx)
{
fz_drop_device(ctx, dev);
dev = NULL;
fz_drop_stext_page(ctx, text);
}
fz_catch(ctx)
{
fz_drop_display_list(ctx, list);
fz_drop_page(ctx, page);
fz_rethrow(ctx);
}
}
#if FZ_ENABLE_PDF
else if (output_format == OUT_PDF)
{
fz_buffer *contents;
pdf_obj *resources;
dev = pdf_page_write(ctx, pdfout, &mediabox, &resources, &contents);
fz_try(ctx)
{
pdf_obj *page_obj;
if (list)
fz_run_display_list(ctx, list, dev, &fz_identity, NULL, cookie);
else
fz_run_page(ctx, page, dev, &fz_identity, cookie);
fz_close_device(ctx, dev);
page_obj = pdf_add_page(ctx, pdfout, &mediabox, rotation, resources, contents);
pdf_insert_page(ctx, pdfout, -1, page_obj);
pdf_drop_obj(ctx, page_obj);
}
fz_always(ctx)
{
pdf_drop_obj(ctx, resources);
fz_drop_buffer(ctx, contents);
fz_drop_device(ctx, dev);
dev = NULL;
}
fz_catch(ctx)
{
fz_drop_display_list(ctx, list);
fz_drop_page(ctx, page);
fz_rethrow(ctx);
}
}
#endif
else if (output_format == OUT_SVG)
{
float zoom;
fz_matrix ctm;
fz_rect bounds, tbounds;
char buf[512];
fz_output *out;
if (!strcmp(output, ""-""))
out = fz_stdout(ctx);
else
{
sprintf(buf, output, pagenum);
out = fz_new_output_with_path(ctx, buf, 0);
}
fz_bound_page(ctx, page, &bounds);
zoom = resolution / 72;
fz_pre_rotate(fz_scale(&ctm, zoom, zoom), rotation);
tbounds = bounds;
fz_transform_rect(&tbounds, &ctm);
fz_try(ctx)
{
dev = fz_new_svg_device(ctx, out, tbounds.x1-tbounds.x0, tbounds.y1-tbounds.y0);
if (lowmemory)
fz_enable_device_hints(ctx, dev, FZ_NO_CACHE);
if (list)
fz_run_display_list(ctx, list, dev, &ctm, &tbounds, cookie);
else
fz_run_page(ctx, page, dev, &ctm, cookie);
fz_close_device(ctx, dev);
fz_drop_device(ctx, dev);
dev = NULL;
}
fz_always(ctx)
{
fz_drop_device(ctx, dev);
dev = NULL;
fz_drop_output(ctx, out);
}
fz_catch(ctx)
{
fz_drop_display_list(ctx, list);
fz_drop_page(ctx, page);
fz_rethrow(ctx);
}
}
else
{
float zoom;
fz_matrix ctm;
fz_rect bounds, tbounds;
fz_irect ibounds;
fz_pixmap *pix = NULL;
int w, h;
fz_band_writer *bander = NULL;
fz_bitmap *bit = NULL;
fz_var(pix);
fz_var(bander);
fz_var(bit);
fz_bound_page(ctx, page, &bounds);
zoom = resolution / 72;
fz_pre_scale(fz_rotate(&ctm, rotation), zoom, zoom);
tbounds = bounds;
fz_round_rect(&ibounds, fz_transform_rect(&tbounds, &ctm));
w = width;
h = height;
if (res_specified)
{
int t;
t = ibounds.x1 - ibounds.x0;
if (w && t <= w)
w = 0;
t = ibounds.y1 - ibounds.y0;
if (h && t <= h)
h = 0;
}
if (w || h)
{
float scalex = w / (tbounds.x1 - tbounds.x0);
float scaley = h / (tbounds.y1 - tbounds.y0);
fz_matrix scale_mat;
if (fit)
{
if (w == 0)
scalex = 1.0f;
if (h == 0)
scaley = 1.0f;
}
else
{
if (w == 0)
scalex = scaley;
if (h == 0)
scaley = scalex;
}
if (!fit)
{
if (scalex > scaley)
scalex = scaley;
else
scaley = scalex;
}
fz_scale(&scale_mat, scalex, scaley);
fz_concat(&ctm, &ctm, &scale_mat);
tbounds = bounds;
fz_transform_rect(&tbounds, &ctm);
}
fz_round_rect(&ibounds, &tbounds);
fz_rect_from_irect(&tbounds, &ibounds);
fz_try(ctx)
{
fz_irect band_ibounds = ibounds;
int band, bands = 1;
int totalheight = ibounds.y1 - ibounds.y0;
int drawheight = totalheight;
if (band_height != 0)
{
drawheight = band_height;
if (totalheight > band_height)
band_ibounds.y1 = band_ibounds.y0 + band_height;
bands = (totalheight + band_height-1)/band_height;
tbounds.y1 = tbounds.y0 + band_height + 2;
DEBUG_THREADS((""Using %d Bands\n"", bands));
}
if (num_workers > 0)
{
for (band = 0; band < fz_mini(num_workers, bands); band++)
{
workers[band].band = band;
workers[band].ctm = ctm;
workers[band].tbounds = tbounds;
memset(&workers[band].cookie, 0, sizeof(fz_cookie));
workers[band].list = list;
workers[band].pix = fz_new_pixmap_with_bbox(ctx, colorspace, &band_ibounds, alpha);
fz_set_pixmap_resolution(ctx, workers[band].pix, resolution, resolution);
DEBUG_THREADS((""Worker %d, Pre-triggering band %d\n"", band, band));
mu_trigger_semaphore(&workers[band].start);
ctm.f -= drawheight;
}
pix = workers[0].pix;
}
else
{
pix = fz_new_pixmap_with_bbox(ctx, colorspace, &band_ibounds, alpha);
fz_set_pixmap_resolution(ctx, pix, resolution, resolution);
}
if (output)
{
if (output_format == OUT_PGM || output_format == OUT_PPM || output_format == OUT_PNM)
bander = fz_new_pnm_band_writer(ctx, out);
else if (output_format == OUT_PAM)
bander = fz_new_pam_band_writer(ctx, out);
else if (output_format == OUT_PNG)
bander = fz_new_png_band_writer(ctx, out);
else if (output_format == OUT_PBM)
bander = fz_new_pbm_band_writer(ctx, out);
else if (output_format == OUT_PKM)
bander = fz_new_pkm_band_writer(ctx, out);
else if (output_format == OUT_PS)
bander = fz_new_ps_band_writer(ctx, out);
else if (output_format == OUT_PCL)
{
if (out_cs == CS_MONO)
bander = fz_new_mono_pcl_band_writer(ctx, out, NULL);
else
bander = fz_new_color_pcl_band_writer(ctx, out, NULL);
}
if (bander)
fz_write_header(ctx, bander, pix->w, totalheight, pix->n, pix->alpha, pix->xres, pix->yres, ++output_pagenum);
}
for (band = 0; band < bands; band++)
{
if (num_workers > 0)
{
worker_t *w = &workers[band % num_workers];
DEBUG_THREADS((""Waiting for worker %d to complete band %d\n"", w->num, band));
mu_wait_semaphore(&w->stop);
pix = w->pix;
bit = w->bit;
w->bit = NULL;
cookie->errors += w->cookie.errors;
}
else
drawband(ctx, page, list, &ctm, &tbounds, cookie, band * band_height, pix, &bit);
if (output)
{
if (bander)
fz_write_band(ctx, bander, bit ? bit->stride : pix->stride, band * band_height, drawheight, bit ? bit->samples : pix->samples);
else if (output_format == OUT_PWG)
fz_write_pixmap_as_pwg(ctx, out, pix, NULL);
else if (output_format == OUT_TGA)
fz_write_pixmap_as_tga(ctx, out, pix);
fz_drop_bitmap(ctx, bit);
bit = NULL;
}
if (num_workers > 0 && band + num_workers < bands)
{
worker_t *w = &workers[band % num_workers];
w->band = band + num_workers;
w->ctm = ctm;
w->tbounds = tbounds;
memset(&w->cookie, 0, sizeof(fz_cookie));
DEBUG_THREADS((""Triggering worker %d for band %d\n"", w->num, w->band));
mu_trigger_semaphore(&w->start);
}
ctm.f -= drawheight;
}
if (showmd5)
{
unsigned char digest[16];
int i;
fz_md5_pixmap(ctx, pix, digest);
fprintf(stderr, "" "");
for (i = 0; i < 16; i++)
fprintf(stderr, ""%02x"", digest[i]);
}
if (output)
{
if (bander)
fz_write_trailer(ctx, bander);
}
}
fz_always(ctx)
{
fz_drop_band_writer(ctx, bander);
fz_drop_bitmap(ctx, bit);
bit = NULL;
if (num_workers > 0)
{
int band;
for (band = 0; band < num_workers; band++)
fz_drop_pixmap(ctx, workers[band].pix);
}
else
fz_drop_pixmap(ctx, pix);
}
fz_catch(ctx)
{
fz_drop_display_list(ctx, list);
fz_drop_page(ctx, page);
fz_rethrow(ctx);
}
}
fz_drop_display_list(ctx, list);
if (!output_append)
file_level_trailers(ctx);
fz_drop_page(ctx, page);
if (showtime)
{
int end = gettime();
int diff = end - start;
if (bg)
{
if (diff + interptime < timing.min)
{
timing.min = diff + interptime;
timing.mininterp = interptime;
timing.minpage = pagenum;
timing.minfilename = filename;
}
if (diff + interptime > timing.max)
{
timing.max = diff + interptime;
timing.maxinterp = interptime;
timing.maxpage = pagenum;
timing.maxfilename = filename;
}
timing.count ++;
fprintf(stderr, "" %dms (interpretation) %dms (rendering) %dms (total)"", interptime, diff, diff + interptime);
}
else
{
if (diff < timing.min)
{
timing.min = diff;
timing.minpage = pagenum;
timing.minfilename = filename;
}
if (diff > timing.max)
{
timing.max = diff;
timing.maxpage = pagenum;
timing.maxfilename = filename;
}
timing.total += diff;
timing.count ++;
fprintf(stderr, "" %dms"", diff);
}
}
fprintf(stderr, ""\n"");
if (lowmemory)
{
fz_empty_store(ctx);
}
if (showmemory)
{
fz_dump_glyph_cache_stats(ctx);
}
fz_flush_warnings(ctx);
if (cookie->errors)
errored = 1;
}","static void dodrawpage(fz_context *VAR_0, fz_page *VAR_1, fz_display_list *VAR_2, int VAR_3, fz_cookie *VAR_4, int VAR_5, int VAR_6, char *VAR_7, int VAR_8)
{
fz_rect VAR_9;
fz_device *VAR_10 = NULL;
fz_bound_page(VAR_0, VAR_1, &VAR_9);
if (VAR_11 == VAR_12)
{
fz_try(VAR_0)
{
fz_printf(VAR_0, VAR_13, ""<page mediabox=\""%g %g %g %g\"">\n"",
VAR_9.x0, VAR_9.y0, VAR_9.x1, VAR_9.y1);
VAR_10 = fz_new_trace_device(VAR_0, VAR_13);
if (VAR_14)
fz_enable_device_hints(VAR_0, VAR_10, VAR_15);
if (VAR_2)
fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_16, &VAR_17, VAR_4);
else
fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_16, VAR_4);
fz_printf(VAR_0, VAR_13, ""</page>\n"");
fz_close_device(VAR_0, VAR_10);
}
fz_always(VAR_0)
{
fz_drop_device(VAR_0, VAR_10);
VAR_10 = NULL;
}
fz_catch(VAR_0)
{
fz_drop_display_list(VAR_0, VAR_2);
fz_drop_page(VAR_0, VAR_1);
fz_rethrow(VAR_0);
}
}
else if (VAR_11 == VAR_18 || VAR_11 == VAR_19 || VAR_11 == VAR_20)
{
fz_stext_page *VAR_21 = NULL;
fz_var(VAR_21);
fz_try(VAR_0)
{
fz_rect VAR_9;
if (VAR_2)
fz_bound_display_list(VAR_0, VAR_2, &VAR_9);
else
fz_bound_page(VAR_0, VAR_1, &VAR_9);
VAR_21 = fz_new_stext_page(VAR_0, &VAR_9);
VAR_10 = fz_new_stext_device(VAR_0, VAR_22, VAR_21, 0);
if (VAR_14)
fz_enable_device_hints(VAR_0, VAR_10, VAR_15);
if (VAR_11 == VAR_19)
fz_disable_device_hints(VAR_0, VAR_10, VAR_23);
if (VAR_2)
fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_16, &VAR_17, VAR_4);
else
fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_16, VAR_4);
fz_close_device(VAR_0, VAR_10);
fz_drop_device(VAR_0, VAR_10);
VAR_10 = NULL;
if (VAR_11 == VAR_20)
{
fz_print_stext_page_xml(VAR_0, VAR_13, VAR_21);
}
else if (VAR_11 == VAR_19)
{
fz_analyze_text(VAR_0, VAR_22, VAR_21);
fz_print_stext_page_html(VAR_0, VAR_13, VAR_21);
}
else if (VAR_11 == VAR_18)
{
fz_print_stext_page(VAR_0, VAR_13, VAR_21);
fz_printf(VAR_0, VAR_13, ""\f\n"");
}
}
fz_always(VAR_0)
{
fz_drop_device(VAR_0, VAR_10);
VAR_10 = NULL;
fz_drop_stext_page(VAR_0, VAR_21);
}
fz_catch(VAR_0)
{
fz_drop_display_list(VAR_0, VAR_2);
fz_drop_page(VAR_0, VAR_1);
fz_rethrow(VAR_0);
}
}
#if VAR_24
else if (output_format == VAR_25)
{
fz_buffer *VAR_26;
pdf_obj *VAR_27;
VAR_10 = pdf_page_write(VAR_0, VAR_28, &VAR_9, &VAR_27, &VAR_26);
fz_try(VAR_0)
{
pdf_obj *VAR_29;
if (VAR_2)
fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_16, NULL, VAR_4);
else
fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_16, VAR_4);
fz_close_device(VAR_0, VAR_10);
VAR_29 = pdf_add_page(VAR_0, VAR_28, &VAR_9, VAR_30, VAR_27, VAR_26);
pdf_insert_page(VAR_0, VAR_28, -1, VAR_29);
pdf_drop_obj(VAR_0, VAR_29);
}
fz_always(VAR_0)
{
pdf_drop_obj(VAR_0, VAR_27);
fz_drop_buffer(VAR_0, VAR_26);
fz_drop_device(VAR_0, VAR_10);
VAR_10 = NULL;
}
fz_catch(VAR_0)
{
fz_drop_display_list(VAR_0, VAR_2);
fz_drop_page(VAR_0, VAR_1);
fz_rethrow(VAR_0);
}
}
#endif
else if (output_format == VAR_31)
{
float VAR_32;
fz_matrix VAR_33;
fz_rect VAR_34, VAR_35;
char VAR_36[512];
fz_output *VAR_13;
if (!strcmp(VAR_37, ""-""))
VAR_13 = fz_stdout(VAR_0);
else
{
sprintf(VAR_36, VAR_37, VAR_3);
VAR_13 = fz_new_output_with_path(VAR_0, VAR_36, 0);
}
fz_bound_page(VAR_0, VAR_1, &VAR_34);
VAR_32 = VAR_38 / 72;
fz_pre_rotate(fz_scale(&VAR_33, VAR_32, VAR_32), VAR_30);
VAR_35 = VAR_34;
fz_transform_rect(&VAR_35, &VAR_33);
fz_try(VAR_0)
{
VAR_10 = fz_new_svg_device(VAR_0, VAR_13, VAR_35.x1-VAR_35.x0, VAR_35.y1-VAR_35.y0);
if (VAR_14)
fz_enable_device_hints(VAR_0, VAR_10, VAR_15);
if (VAR_2)
fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_33, &VAR_35, VAR_4);
else
fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_33, VAR_4);
fz_close_device(VAR_0, VAR_10);
fz_drop_device(VAR_0, VAR_10);
VAR_10 = NULL;
}
fz_always(VAR_0)
{
fz_drop_device(VAR_0, VAR_10);
VAR_10 = NULL;
fz_drop_output(VAR_0, VAR_13);
}
fz_catch(VAR_0)
{
fz_drop_display_list(VAR_0, VAR_2);
fz_drop_page(VAR_0, VAR_1);
fz_rethrow(VAR_0);
}
}
else
{
float VAR_32;
fz_matrix VAR_33;
fz_rect VAR_34, VAR_35;
fz_irect VAR_39;
fz_pixmap *VAR_40 = NULL;
int VAR_41, VAR_42;
fz_band_writer *VAR_43 = NULL;
fz_bitmap *VAR_44 = NULL;
fz_var(VAR_40);
fz_var(VAR_43);
fz_var(VAR_44);
fz_bound_page(VAR_0, VAR_1, &VAR_34);
VAR_32 = VAR_38 / 72;
fz_pre_scale(fz_rotate(&VAR_33, VAR_30), VAR_32, VAR_32);
VAR_35 = VAR_34;
fz_round_rect(&VAR_39, fz_transform_rect(&VAR_35, &VAR_33));
VAR_41 = VAR_45;
VAR_42 = VAR_46;
if (VAR_47)
{
int VAR_48;
VAR_48 = VAR_39.x1 - VAR_39.x0;
if (VAR_41 && VAR_48 <= VAR_41)
VAR_41 = 0;
VAR_48 = VAR_39.y1 - VAR_39.y0;
if (VAR_42 && VAR_48 <= VAR_42)
VAR_42 = 0;
}
if (VAR_41 || VAR_42)
{
float VAR_49 = VAR_41 / (VAR_35.x1 - VAR_35.x0);
float VAR_50 = VAR_42 / (VAR_35.y1 - VAR_35.y0);
fz_matrix VAR_51;
if (VAR_52)
{
if (VAR_41 == 0)
VAR_49 = 1.0f;
if (VAR_42 == 0)
VAR_50 = 1.0f;
}
else
{
if (VAR_41 == 0)
VAR_49 = VAR_50;
if (VAR_42 == 0)
VAR_50 = VAR_49;
}
if (!VAR_52)
{
if (VAR_49 > VAR_50)
VAR_49 = VAR_50;
else
VAR_50 = VAR_49;
}
fz_scale(&VAR_51, VAR_49, VAR_50);
fz_concat(&VAR_33, &VAR_33, &VAR_51);
VAR_35 = VAR_34;
fz_transform_rect(&VAR_35, &VAR_33);
}
fz_round_rect(&VAR_39, &VAR_35);
fz_rect_from_irect(&VAR_35, &VAR_39);
fz_try(VAR_0)
{
fz_irect VAR_53 = VAR_39;
int VAR_54, VAR_55 = 1;
int VAR_56 = VAR_39.y1 - VAR_39.y0;
int VAR_57 = VAR_56;
if (VAR_58 != 0)
{
VAR_57 = VAR_58;
if (VAR_56 > VAR_58)
VAR_53.y1 = VAR_53.y0 + VAR_58;
VAR_55 = (VAR_56 + VAR_58-1)/VAR_58;
VAR_35.y1 = VAR_35.y0 + VAR_58 + 2;
DEBUG_THREADS((""Using %d Bands\n"", VAR_55));
}
if (VAR_59 > 0)
{
for (VAR_54 = 0; VAR_54 < fz_mini(VAR_59, VAR_55); VAR_54++)
{
VAR_60[VAR_54].band = VAR_54;
VAR_60[VAR_54].ctm = VAR_33;
VAR_60[VAR_54].tbounds = VAR_35;
memset(&VAR_60[VAR_54].cookie, 0, sizeof(fz_cookie));
VAR_60[VAR_54].list = VAR_2;
VAR_60[VAR_54].pix = fz_new_pixmap_with_bbox(VAR_0, VAR_61, &VAR_53, VAR_62);
fz_set_pixmap_resolution(VAR_0, VAR_60[VAR_54].pix, VAR_38, VAR_38);
DEBUG_THREADS((""Worker %d, Pre-triggering band %d\n"", VAR_54, VAR_54));
mu_trigger_semaphore(&VAR_60[VAR_54].start);
VAR_33.f -= VAR_57;
}
VAR_40 = VAR_60[0].pix;
}
else
{
VAR_40 = fz_new_pixmap_with_bbox(VAR_0, VAR_61, &VAR_53, VAR_62);
fz_set_pixmap_resolution(VAR_0, VAR_40, VAR_38, VAR_38);
}
if (VAR_37)
{
if (output_format == VAR_63 || output_format == VAR_64 || output_format == VAR_65)
VAR_43 = fz_new_pnm_band_writer(VAR_0, VAR_13);
else if (output_format == VAR_66)
VAR_43 = fz_new_pam_band_writer(VAR_0, VAR_13);
else if (output_format == VAR_67)
VAR_43 = fz_new_png_band_writer(VAR_0, VAR_13);
else if (output_format == VAR_68)
VAR_43 = fz_new_pbm_band_writer(VAR_0, VAR_13);
else if (output_format == VAR_69)
VAR_43 = fz_new_pkm_band_writer(VAR_0, VAR_13);
else if (output_format == VAR_70)
VAR_43 = fz_new_ps_band_writer(VAR_0, VAR_13);
else if (output_format == VAR_71)
{
if (VAR_72 == VAR_73)
VAR_43 = fz_new_mono_pcl_band_writer(VAR_0, VAR_13, NULL);
else
VAR_43 = fz_new_color_pcl_band_writer(VAR_0, VAR_13, NULL);
}
if (VAR_43)
fz_write_header(VAR_0, VAR_43, VAR_40->w, VAR_56, VAR_40->n, VAR_40->alpha, VAR_40->xres, VAR_40->yres, ++VAR_74);
}
for (VAR_54 = 0; VAR_54 < VAR_55; VAR_54++)
{
if (VAR_59 > 0)
{
worker_t *VAR_41 = &VAR_60[VAR_54 % VAR_59];
DEBUG_THREADS((""Waiting for worker %d to complete band %d\n"", VAR_41->num, VAR_54));
mu_wait_semaphore(&VAR_41->stop);
VAR_40 = VAR_41->pix;
VAR_44 = VAR_41->bit;
VAR_41->bit = NULL;
VAR_4->errors += VAR_41->cookie.errors;
}
else
drawband(VAR_0, VAR_1, VAR_2, &VAR_33, &VAR_35, VAR_4, VAR_54 * VAR_58, VAR_40, &VAR_44);
if (VAR_37)
{
if (VAR_43)
fz_write_band(VAR_0, VAR_43, VAR_44 ? VAR_44->stride : VAR_40->stride, VAR_54 * VAR_58, VAR_57, VAR_44 ? VAR_44->samples : VAR_40->samples);
else if (output_format == VAR_75)
fz_write_pixmap_as_pwg(VAR_0, VAR_13, VAR_40, NULL);
else if (output_format == VAR_76)
fz_write_pixmap_as_tga(VAR_0, VAR_13, VAR_40);
fz_drop_bitmap(VAR_0, VAR_44);
VAR_44 = NULL;
}
if (VAR_59 > 0 && VAR_54 + VAR_59 < VAR_55)
{
worker_t *VAR_41 = &VAR_60[VAR_54 % VAR_59];
VAR_41->band = VAR_54 + VAR_59;
VAR_41->ctm = VAR_33;
VAR_41->tbounds = VAR_35;
memset(&VAR_41->cookie, 0, sizeof(fz_cookie));
DEBUG_THREADS((""Triggering worker %d for band %d\n"", VAR_41->num, VAR_41->band));
mu_trigger_semaphore(&VAR_41->start);
}
VAR_33.f -= VAR_57;
}
if (VAR_77)
{
unsigned char VAR_78[16];
int VAR_79;
fz_md5_pixmap(VAR_0, VAR_40, VAR_78);
fprintf(VAR_80, "" "");
for (VAR_79 = 0; VAR_79 < 16; VAR_79++)
fprintf(VAR_80, ""%02x"", VAR_78[VAR_79]);
}
if (VAR_37)
{
if (VAR_43)
fz_write_trailer(VAR_0, VAR_43);
}
}
fz_always(VAR_0)
{
fz_drop_band_writer(VAR_0, VAR_43);
fz_drop_bitmap(VAR_0, VAR_44);
VAR_44 = NULL;
if (VAR_59 > 0)
{
int VAR_54;
for (VAR_54 = 0; VAR_54 < VAR_59; VAR_54++)
fz_drop_pixmap(VAR_0, VAR_60[VAR_54].pix);
}
else
fz_drop_pixmap(VAR_0, VAR_40);
}
fz_catch(VAR_0)
{
fz_drop_display_list(VAR_0, VAR_2);
fz_drop_page(VAR_0, VAR_1);
fz_rethrow(VAR_0);
}
}
fz_drop_display_list(VAR_0, VAR_2);
if (!VAR_81)
file_level_trailers(VAR_0);
fz_drop_page(VAR_0, VAR_1);
if (VAR_82)
{
int VAR_83 = gettime();
int VAR_84 = VAR_83 - VAR_5;
if (VAR_8)
{
if (VAR_84 + VAR_6 < VAR_85.min)
{
VAR_85.min = VAR_84 + VAR_6;
VAR_85.mininterp = VAR_6;
VAR_85.minpage = VAR_3;
VAR_85.minfilename = VAR_7;
}
if (VAR_84 + VAR_6 > VAR_85.max)
{
VAR_85.max = VAR_84 + VAR_6;
VAR_85.maxinterp = VAR_6;
VAR_85.maxpage = VAR_3;
VAR_85.maxfilename = VAR_7;
}
VAR_85.count ++;
fprintf(VAR_80, "" %dms (interpretation) %dms (rendering) %dms (total)"", VAR_6, VAR_84, VAR_84 + VAR_6);
}
else
{
if (VAR_84 < VAR_85.min)
{
VAR_85.min = VAR_84;
VAR_85.minpage = VAR_3;
VAR_85.minfilename = VAR_7;
}
if (VAR_84 > VAR_85.max)
{
VAR_85.max = VAR_84;
VAR_85.maxpage = VAR_3;
VAR_85.maxfilename = VAR_7;
}
VAR_85.total += VAR_84;
VAR_85.count ++;
fprintf(VAR_80, "" %dms"", VAR_84);
}
}
fprintf(VAR_80, ""\n"");
if (VAR_14)
{
fz_empty_store(VAR_0);
}
if (VAR_86)
{
fz_dump_glyph_cache_stats(VAR_0);
}
fz_flush_warnings(VAR_0);
if (VAR_4->errors)
VAR_87 = 1;
}",ArtifexSoftware/mupdf/40ac85bfb676bb4373bda4b18f9fd90268c9f1e9/mudraw.c/vul/before/0.json,"static void dodrawpage(fz_context *ctx, fz_page *page, fz_display_list *list, int pagenum, fz_cookie *cookie, int start, int interptime, char *filename, int bg)
{
	fz_rect mediabox;
	fz_device *dev = NULL;

	fz_bound_page(ctx, page, &mediabox);

	if (output_format == OUT_TRACE)
	{
		fz_try(ctx)
		{
			fz_printf(ctx, out, ""<page mediabox=\""%g %g %g %g\"">\n"",
					mediabox.x0, mediabox.y0, mediabox.x1, mediabox.y1);
			dev = fz_new_trace_device(ctx, out);
			if (lowmemory)
				fz_enable_device_hints(ctx, dev, FZ_NO_CACHE);
			if (list)
				fz_run_display_list(ctx, list, dev, &fz_identity, &fz_infinite_rect, cookie);
			else
				fz_run_page(ctx, page, dev, &fz_identity, cookie);
			fz_printf(ctx, out, ""</page>\n"");
			fz_close_device(ctx, dev);
		}
		fz_always(ctx)
		{
			fz_drop_device(ctx, dev);
			dev = NULL;
		}
		fz_catch(ctx)
		{
			fz_drop_display_list(ctx, list);
			fz_drop_page(ctx, page);
			fz_rethrow(ctx);
		}
	}

	else if (output_format == OUT_TEXT || output_format == OUT_HTML || output_format == OUT_STEXT)
	{
		fz_stext_page *text = NULL;

		fz_var(text);

		fz_try(ctx)
		{
			fz_rect mediabox;
			if (list)
				fz_bound_display_list(ctx, list, &mediabox);
			else
				fz_bound_page(ctx, page, &mediabox);
			text = fz_new_stext_page(ctx, &mediabox);
			dev = fz_new_stext_device(ctx, sheet, text, 0);
			if (lowmemory)
				fz_enable_device_hints(ctx, dev, FZ_NO_CACHE);
			if (output_format == OUT_HTML)
				fz_disable_device_hints(ctx, dev, FZ_IGNORE_IMAGE);
			if (list)
				fz_run_display_list(ctx, list, dev, &fz_identity, &fz_infinite_rect, cookie);
			else
				fz_run_page(ctx, page, dev, &fz_identity, cookie);
			fz_close_device(ctx, dev);
			fz_drop_device(ctx, dev);
			dev = NULL;
			if (output_format == OUT_STEXT)
			{
				fz_print_stext_page_xml(ctx, out, text);
			}
			else if (output_format == OUT_HTML)
			{
				fz_analyze_text(ctx, sheet, text);
				fz_print_stext_page_html(ctx, out, text);
			}
			else if (output_format == OUT_TEXT)
			{
				fz_print_stext_page(ctx, out, text);
				fz_printf(ctx, out, ""\f\n"");
			}
		}
		fz_always(ctx)
		{
			fz_drop_device(ctx, dev);
			dev = NULL;
			fz_drop_stext_page(ctx, text);
		}
		fz_catch(ctx)
		{
			fz_drop_display_list(ctx, list);
			fz_drop_page(ctx, page);
			fz_rethrow(ctx);
		}
	}

#if FZ_ENABLE_PDF
	else if (output_format == OUT_PDF)
	{
		fz_buffer *contents;
		pdf_obj *resources;

		dev = pdf_page_write(ctx, pdfout, &mediabox, &resources, &contents);
		fz_try(ctx)
		{
			pdf_obj *page_obj;

			if (list)
				fz_run_display_list(ctx, list, dev, &fz_identity, NULL, cookie);
			else
				fz_run_page(ctx, page, dev, &fz_identity, cookie);
			fz_close_device(ctx, dev);

			page_obj = pdf_add_page(ctx, pdfout, &mediabox, rotation, resources, contents);
			pdf_insert_page(ctx, pdfout, -1, page_obj);
			pdf_drop_obj(ctx, page_obj);
		}
		fz_always(ctx)
		{
			pdf_drop_obj(ctx, resources);
			fz_drop_buffer(ctx, contents);
			fz_drop_device(ctx, dev);
			dev = NULL;
		}
		fz_catch(ctx)
		{
			fz_drop_display_list(ctx, list);
			fz_drop_page(ctx, page);
			fz_rethrow(ctx);
		}
	}
#endif

	else if (output_format == OUT_SVG)
	{
		float zoom;
		fz_matrix ctm;
		fz_rect bounds, tbounds;
		char buf[512];
		fz_output *out;

		if (!output || !strcmp(output, ""-""))
			out = fz_stdout(ctx);
		else
		{
			sprintf(buf, output, pagenum);
			out = fz_new_output_with_path(ctx, buf, 0);
		}

		fz_bound_page(ctx, page, &bounds);
		zoom = resolution / 72;
		fz_pre_rotate(fz_scale(&ctm, zoom, zoom), rotation);
		tbounds = bounds;
		fz_transform_rect(&tbounds, &ctm);

		fz_try(ctx)
		{
			dev = fz_new_svg_device(ctx, out, tbounds.x1-tbounds.x0, tbounds.y1-tbounds.y0);
			if (lowmemory)
				fz_enable_device_hints(ctx, dev, FZ_NO_CACHE);
			if (list)
				fz_run_display_list(ctx, list, dev, &ctm, &tbounds, cookie);
			else
				fz_run_page(ctx, page, dev, &ctm, cookie);
			fz_close_device(ctx, dev);
			fz_drop_device(ctx, dev);
			dev = NULL;
		}
		fz_always(ctx)
		{
			fz_drop_device(ctx, dev);
			dev = NULL;
			fz_drop_output(ctx, out);
		}
		fz_catch(ctx)
		{
			fz_drop_display_list(ctx, list);
			fz_drop_page(ctx, page);
			fz_rethrow(ctx);
		}
	}
	else
	{
		float zoom;
		fz_matrix ctm;
		fz_rect bounds, tbounds;
		fz_irect ibounds;
		fz_pixmap *pix = NULL;
		int w, h;
		fz_band_writer *bander = NULL;
		fz_bitmap *bit = NULL;

		fz_var(pix);
		fz_var(bander);
		fz_var(bit);

		fz_bound_page(ctx, page, &bounds);
		zoom = resolution / 72;
		fz_pre_scale(fz_rotate(&ctm, rotation), zoom, zoom);
		tbounds = bounds;
		fz_round_rect(&ibounds, fz_transform_rect(&tbounds, &ctm));

		/* Make local copies of our width/height */
		w = width;
		h = height;

		/* If a resolution is specified, check to see whether w/h are
		 * exceeded; if not, unset them. */
		if (res_specified)
		{
			int t;
			t = ibounds.x1 - ibounds.x0;
			if (w && t <= w)
				w = 0;
			t = ibounds.y1 - ibounds.y0;
			if (h && t <= h)
				h = 0;
		}

		/* Now w or h will be 0 unless they need to be enforced. */
		if (w || h)
		{
			float scalex = w / (tbounds.x1 - tbounds.x0);
			float scaley = h / (tbounds.y1 - tbounds.y0);
			fz_matrix scale_mat;

			if (fit)
			{
				if (w == 0)
					scalex = 1.0f;
				if (h == 0)
					scaley = 1.0f;
			}
			else
			{
				if (w == 0)
					scalex = scaley;
				if (h == 0)
					scaley = scalex;
			}
			if (!fit)
			{
				if (scalex > scaley)
					scalex = scaley;
				else
					scaley = scalex;
			}
			fz_scale(&scale_mat, scalex, scaley);
			fz_concat(&ctm, &ctm, &scale_mat);
			tbounds = bounds;
			fz_transform_rect(&tbounds, &ctm);
		}
		fz_round_rect(&ibounds, &tbounds);
		fz_rect_from_irect(&tbounds, &ibounds);

		fz_try(ctx)
		{
			fz_irect band_ibounds = ibounds;
			int band, bands = 1;
			int totalheight = ibounds.y1 - ibounds.y0;
			int drawheight = totalheight;

			if (band_height != 0)
			{
				/* Banded rendering; we'll only render to a
				 * given height at a time. */
				drawheight = band_height;
				if (totalheight > band_height)
					band_ibounds.y1 = band_ibounds.y0 + band_height;
				bands = (totalheight + band_height-1)/band_height;
				tbounds.y1 = tbounds.y0 + band_height + 2;
				DEBUG_THREADS((""Using %d Bands\n"", bands));
			}

			if (num_workers > 0)
			{
				for (band = 0; band < fz_mini(num_workers, bands); band++)
				{
					workers[band].band = band;
					workers[band].ctm = ctm;
					workers[band].tbounds = tbounds;
					memset(&workers[band].cookie, 0, sizeof(fz_cookie));
					workers[band].list = list;
					workers[band].pix = fz_new_pixmap_with_bbox(ctx, colorspace, &band_ibounds, alpha);
					fz_set_pixmap_resolution(ctx, workers[band].pix, resolution, resolution);
					DEBUG_THREADS((""Worker %d, Pre-triggering band %d\n"", band, band));
					mu_trigger_semaphore(&workers[band].start);
					ctm.f -= drawheight;
				}
				pix = workers[0].pix;
			}
			else
			{
				pix = fz_new_pixmap_with_bbox(ctx, colorspace, &band_ibounds, alpha);
				fz_set_pixmap_resolution(ctx, pix, resolution, resolution);
			}

			/* Output any page level headers (for banded formats) */
			if (output)
			{
				if (output_format == OUT_PGM || output_format == OUT_PPM || output_format == OUT_PNM)
					bander = fz_new_pnm_band_writer(ctx, out);
				else if (output_format == OUT_PAM)
					bander = fz_new_pam_band_writer(ctx, out);
				else if (output_format == OUT_PNG)
					bander = fz_new_png_band_writer(ctx, out);
				else if (output_format == OUT_PBM)
					bander = fz_new_pbm_band_writer(ctx, out);
				else if (output_format == OUT_PKM)
					bander = fz_new_pkm_band_writer(ctx, out);
				else if (output_format == OUT_PS)
					bander = fz_new_ps_band_writer(ctx, out);
				else if (output_format == OUT_PCL)
				{
					if (out_cs == CS_MONO)
						bander = fz_new_mono_pcl_band_writer(ctx, out, NULL);
					else
						bander = fz_new_color_pcl_band_writer(ctx, out, NULL);
				}
				if (bander)
					fz_write_header(ctx, bander, pix->w, totalheight, pix->n, pix->alpha, pix->xres, pix->yres, ++output_pagenum);
			}

			for (band = 0; band < bands; band++)
			{
				if (num_workers > 0)
				{
					worker_t *w = &workers[band % num_workers];
					DEBUG_THREADS((""Waiting for worker %d to complete band %d\n"", w->num, band));
					mu_wait_semaphore(&w->stop);
					pix = w->pix;
					bit = w->bit;
					w->bit = NULL;
					cookie->errors += w->cookie.errors;
				}
				else
					drawband(ctx, page, list, &ctm, &tbounds, cookie, band * band_height, pix, &bit);

				if (output)
				{
					if (bander)
						fz_write_band(ctx, bander, bit ? bit->stride : pix->stride, band * band_height, drawheight, bit ? bit->samples : pix->samples);
					else if (output_format == OUT_PWG)
						fz_write_pixmap_as_pwg(ctx, out, pix, NULL);
					else if (output_format == OUT_TGA)
						fz_write_pixmap_as_tga(ctx, out, pix);
					fz_drop_bitmap(ctx, bit);
					bit = NULL;
				}

				if (num_workers > 0 && band + num_workers < bands)
				{
					worker_t *w = &workers[band % num_workers];
					w->band = band + num_workers;
					w->ctm = ctm;
					w->tbounds = tbounds;
					memset(&w->cookie, 0, sizeof(fz_cookie));
					DEBUG_THREADS((""Triggering worker %d for band %d\n"", w->num, w->band));
					mu_trigger_semaphore(&w->start);
				}
				ctm.f -= drawheight;
			}

			/* FIXME */
			if (showmd5)
			{
				unsigned char digest[16];
				int i;

				fz_md5_pixmap(ctx, pix, digest);
				fprintf(stderr, "" "");
				for (i = 0; i < 16; i++)
					fprintf(stderr, ""%02x"", digest[i]);
			}

			/* Any page level trailers go here */
			if (output)
			{
				if (bander)
					fz_write_trailer(ctx, bander);
			}
		}
		fz_always(ctx)
		{
			fz_drop_band_writer(ctx, bander);
			fz_drop_bitmap(ctx, bit);
			bit = NULL;
			if (num_workers > 0)
			{
				int band;
				for (band = 0; band < num_workers; band++)
					fz_drop_pixmap(ctx, workers[band].pix);
			}
			else
				fz_drop_pixmap(ctx, pix);
		}
		fz_catch(ctx)
		{
			fz_drop_display_list(ctx, list);
			fz_drop_page(ctx, page);
			fz_rethrow(ctx);
		}
	}

	fz_drop_display_list(ctx, list);

	if (!output_append)
		file_level_trailers(ctx);

	fz_drop_page(ctx, page);

	if (showtime)
	{
		int end = gettime();
		int diff = end - start;

		if (bg)
		{
			if (diff + interptime < timing.min)
			{
				timing.min = diff + interptime;
				timing.mininterp = interptime;
				timing.minpage = pagenum;
				timing.minfilename = filename;
			}
			if (diff + interptime > timing.max)
			{
				timing.max = diff + interptime;
				timing.maxinterp = interptime;
				timing.maxpage = pagenum;
				timing.maxfilename = filename;
			}
			timing.count ++;

			fprintf(stderr, "" %dms (interpretation) %dms (rendering) %dms (total)"", interptime, diff, diff + interptime);
		}
		else
		{
			if (diff < timing.min)
			{
				timing.min = diff;
				timing.minpage = pagenum;
				timing.minfilename = filename;
			}
			if (diff > timing.max)
			{
				timing.max = diff;
				timing.maxpage = pagenum;
				timing.maxfilename = filename;
			}
			timing.total += diff;
			timing.count ++;

			fprintf(stderr, "" %dms"", diff);
		}
	}

	fprintf(stderr, ""\n"");

	if (lowmemory)
	{
		fz_empty_store(ctx);
	}

	if (showmemory)
	{
		fz_dump_glyph_cache_stats(ctx);
	}

	fz_flush_warnings(ctx);

	if (cookie->errors)
		errored = 1;
}","static void dodrawpage(fz_context *VAR_0, fz_page *VAR_1, fz_display_list *VAR_2, int VAR_3, fz_cookie *VAR_4, int VAR_5, int VAR_6, char *VAR_7, int VAR_8)
{
	fz_rect VAR_9;
	fz_device *VAR_10 = NULL;

	fz_bound_page(VAR_0, VAR_1, &VAR_9);

	if (VAR_11 == VAR_12)
	{
		fz_try(VAR_0)
		{
			fz_printf(VAR_0, VAR_13, ""<page mediabox=\""%g %g %g %g\"">\n"",
					VAR_9.x0, VAR_9.y0, VAR_9.x1, VAR_9.y1);
			VAR_10 = fz_new_trace_device(VAR_0, VAR_13);
			if (VAR_14)
				fz_enable_device_hints(VAR_0, VAR_10, VAR_15);
			if (VAR_2)
				fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_16, &VAR_17, VAR_4);
			else
				fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_16, VAR_4);
			fz_printf(VAR_0, VAR_13, ""</page>\n"");
			fz_close_device(VAR_0, VAR_10);
		}
		fz_always(VAR_0)
		{
			fz_drop_device(VAR_0, VAR_10);
			VAR_10 = NULL;
		}
		fz_catch(VAR_0)
		{
			fz_drop_display_list(VAR_0, VAR_2);
			fz_drop_page(VAR_0, VAR_1);
			fz_rethrow(VAR_0);
		}
	}

	else if (VAR_11 == VAR_18 || VAR_11 == VAR_19 || VAR_11 == VAR_20)
	{
		fz_stext_page *VAR_21 = NULL;

		fz_var(VAR_21);

		fz_try(VAR_0)
		{
			fz_rect VAR_9;
			if (VAR_2)
				fz_bound_display_list(VAR_0, VAR_2, &VAR_9);
			else
				fz_bound_page(VAR_0, VAR_1, &VAR_9);
			VAR_21 = fz_new_stext_page(VAR_0, &VAR_9);
			VAR_10 = fz_new_stext_device(VAR_0, VAR_22, VAR_21, 0);
			if (VAR_14)
				fz_enable_device_hints(VAR_0, VAR_10, VAR_15);
			if (VAR_11 == VAR_19)
				fz_disable_device_hints(VAR_0, VAR_10, VAR_23);
			if (VAR_2)
				fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_16, &VAR_17, VAR_4);
			else
				fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_16, VAR_4);
			fz_close_device(VAR_0, VAR_10);
			fz_drop_device(VAR_0, VAR_10);
			VAR_10 = NULL;
			if (VAR_11 == VAR_20)
			{
				fz_print_stext_page_xml(VAR_0, VAR_13, VAR_21);
			}
			else if (VAR_11 == VAR_19)
			{
				fz_analyze_text(VAR_0, VAR_22, VAR_21);
				fz_print_stext_page_html(VAR_0, VAR_13, VAR_21);
			}
			else if (VAR_11 == VAR_18)
			{
				fz_print_stext_page(VAR_0, VAR_13, VAR_21);
				fz_printf(VAR_0, VAR_13, ""\f\n"");
			}
		}
		fz_always(VAR_0)
		{
			fz_drop_device(VAR_0, VAR_10);
			VAR_10 = NULL;
			fz_drop_stext_page(VAR_0, VAR_21);
		}
		fz_catch(VAR_0)
		{
			fz_drop_display_list(VAR_0, VAR_2);
			fz_drop_page(VAR_0, VAR_1);
			fz_rethrow(VAR_0);
		}
	}

#if VAR_24
	else if (output_format == VAR_25)
	{
		fz_buffer *VAR_26;
		pdf_obj *VAR_27;

		VAR_10 = pdf_page_write(VAR_0, VAR_28, &VAR_9, &VAR_27, &VAR_26);
		fz_try(VAR_0)
		{
			pdf_obj *VAR_29;

			if (VAR_2)
				fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_16, NULL, VAR_4);
			else
				fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_16, VAR_4);
			fz_close_device(VAR_0, VAR_10);

			VAR_29 = pdf_add_page(VAR_0, VAR_28, &VAR_9, VAR_30, VAR_27, VAR_26);
			pdf_insert_page(VAR_0, VAR_28, -1, VAR_29);
			pdf_drop_obj(VAR_0, VAR_29);
		}
		fz_always(VAR_0)
		{
			pdf_drop_obj(VAR_0, VAR_27);
			fz_drop_buffer(VAR_0, VAR_26);
			fz_drop_device(VAR_0, VAR_10);
			VAR_10 = NULL;
		}
		fz_catch(VAR_0)
		{
			fz_drop_display_list(VAR_0, VAR_2);
			fz_drop_page(VAR_0, VAR_1);
			fz_rethrow(VAR_0);
		}
	}
#endif

	else if (output_format == VAR_31)
	{
		float VAR_32;
		fz_matrix VAR_33;
		fz_rect VAR_34, VAR_35;
		char VAR_36[512];
		fz_output *VAR_13;

		if (!VAR_37 || !strcmp(VAR_37, ""-""))
			VAR_13 = fz_stdout(VAR_0);
		else
		{
			sprintf(VAR_36, VAR_37, VAR_3);
			VAR_13 = fz_new_output_with_path(VAR_0, VAR_36, 0);
		}

		fz_bound_page(VAR_0, VAR_1, &VAR_34);
		VAR_32 = VAR_38 / 72;
		fz_pre_rotate(fz_scale(&VAR_33, VAR_32, VAR_32), VAR_30);
		VAR_35 = VAR_34;
		fz_transform_rect(&VAR_35, &VAR_33);

		fz_try(VAR_0)
		{
			VAR_10 = fz_new_svg_device(VAR_0, VAR_13, VAR_35.x1-VAR_35.x0, VAR_35.y1-VAR_35.y0);
			if (VAR_14)
				fz_enable_device_hints(VAR_0, VAR_10, VAR_15);
			if (VAR_2)
				fz_run_display_list(VAR_0, VAR_2, VAR_10, &VAR_33, &VAR_35, VAR_4);
			else
				fz_run_page(VAR_0, VAR_1, VAR_10, &VAR_33, VAR_4);
			fz_close_device(VAR_0, VAR_10);
			fz_drop_device(VAR_0, VAR_10);
			VAR_10 = NULL;
		}
		fz_always(VAR_0)
		{
			fz_drop_device(VAR_0, VAR_10);
			VAR_10 = NULL;
			fz_drop_output(VAR_0, VAR_13);
		}
		fz_catch(VAR_0)
		{
			fz_drop_display_list(VAR_0, VAR_2);
			fz_drop_page(VAR_0, VAR_1);
			fz_rethrow(VAR_0);
		}
	}
	else
	{
		float VAR_32;
		fz_matrix VAR_33;
		fz_rect VAR_34, VAR_35;
		fz_irect VAR_39;
		fz_pixmap *VAR_40 = NULL;
		int VAR_41, VAR_42;
		fz_band_writer *VAR_43 = NULL;
		fz_bitmap *VAR_44 = NULL;

		fz_var(VAR_40);
		fz_var(VAR_43);
		fz_var(VAR_44);

		fz_bound_page(VAR_0, VAR_1, &VAR_34);
		VAR_32 = VAR_38 / 72;
		fz_pre_scale(fz_rotate(&VAR_33, VAR_30), VAR_32, VAR_32);
		VAR_35 = VAR_34;
		fz_round_rect(&VAR_39, fz_transform_rect(&VAR_35, &VAR_33));

		/* COMMENT_0 */
		VAR_41 = VAR_45;
		VAR_42 = VAR_46;

		/* COMMENT_1 */
                                     
		if (VAR_47)
		{
			int VAR_48;
			VAR_48 = VAR_39.x1 - VAR_39.x0;
			if (VAR_41 && VAR_48 <= VAR_41)
				VAR_41 = 0;
			VAR_48 = VAR_39.y1 - VAR_39.y0;
			if (VAR_42 && VAR_48 <= VAR_42)
				VAR_42 = 0;
		}

		/* COMMENT_3 */
		if (VAR_41 || VAR_42)
		{
			float VAR_49 = VAR_41 / (VAR_35.x1 - VAR_35.x0);
			float VAR_50 = VAR_42 / (VAR_35.y1 - VAR_35.y0);
			fz_matrix VAR_51;

			if (VAR_52)
			{
				if (VAR_41 == 0)
					VAR_49 = 1.0f;
				if (VAR_42 == 0)
					VAR_50 = 1.0f;
			}
			else
			{
				if (VAR_41 == 0)
					VAR_49 = VAR_50;
				if (VAR_42 == 0)
					VAR_50 = VAR_49;
			}
			if (!VAR_52)
			{
				if (VAR_49 > VAR_50)
					VAR_49 = VAR_50;
				else
					VAR_50 = VAR_49;
			}
			fz_scale(&VAR_51, VAR_49, VAR_50);
			fz_concat(&VAR_33, &VAR_33, &VAR_51);
			VAR_35 = VAR_34;
			fz_transform_rect(&VAR_35, &VAR_33);
		}
		fz_round_rect(&VAR_39, &VAR_35);
		fz_rect_from_irect(&VAR_35, &VAR_39);

		fz_try(VAR_0)
		{
			fz_irect VAR_53 = VAR_39;
			int VAR_54, VAR_55 = 1;
			int VAR_56 = VAR_39.y1 - VAR_39.y0;
			int VAR_57 = VAR_56;

			if (VAR_58 != 0)
			{
				/* COMMENT_4 */
                                 
				VAR_57 = VAR_58;
				if (VAR_56 > VAR_58)
					VAR_53.y1 = VAR_53.y0 + VAR_58;
				VAR_55 = (VAR_56 + VAR_58-1)/VAR_58;
				VAR_35.y1 = VAR_35.y0 + VAR_58 + 2;
				DEBUG_THREADS((""Using %d Bands\n"", VAR_55));
			}

			if (VAR_59 > 0)
			{
				for (VAR_54 = 0; VAR_54 < fz_mini(VAR_59, VAR_55); VAR_54++)
				{
					VAR_60[VAR_54].band = VAR_54;
					VAR_60[VAR_54].ctm = VAR_33;
					VAR_60[VAR_54].tbounds = VAR_35;
					memset(&VAR_60[VAR_54].cookie, 0, sizeof(fz_cookie));
					VAR_60[VAR_54].list = VAR_2;
					VAR_60[VAR_54].pix = fz_new_pixmap_with_bbox(VAR_0, VAR_61, &VAR_53, VAR_62);
					fz_set_pixmap_resolution(VAR_0, VAR_60[VAR_54].pix, VAR_38, VAR_38);
					DEBUG_THREADS((""Worker %d, Pre-triggering band %d\n"", VAR_54, VAR_54));
					mu_trigger_semaphore(&VAR_60[VAR_54].start);
					VAR_33.f -= VAR_57;
				}
				VAR_40 = VAR_60[0].pix;
			}
			else
			{
				VAR_40 = fz_new_pixmap_with_bbox(VAR_0, VAR_61, &VAR_53, VAR_62);
				fz_set_pixmap_resolution(VAR_0, VAR_40, VAR_38, VAR_38);
			}

			/* COMMENT_6 */
			if (VAR_37)
			{
				if (output_format == VAR_63 || output_format == VAR_64 || output_format == VAR_65)
					VAR_43 = fz_new_pnm_band_writer(VAR_0, VAR_13);
				else if (output_format == VAR_66)
					VAR_43 = fz_new_pam_band_writer(VAR_0, VAR_13);
				else if (output_format == VAR_67)
					VAR_43 = fz_new_png_band_writer(VAR_0, VAR_13);
				else if (output_format == VAR_68)
					VAR_43 = fz_new_pbm_band_writer(VAR_0, VAR_13);
				else if (output_format == VAR_69)
					VAR_43 = fz_new_pkm_band_writer(VAR_0, VAR_13);
				else if (output_format == VAR_70)
					VAR_43 = fz_new_ps_band_writer(VAR_0, VAR_13);
				else if (output_format == VAR_71)
				{
					if (VAR_72 == VAR_73)
						VAR_43 = fz_new_mono_pcl_band_writer(VAR_0, VAR_13, NULL);
					else
						VAR_43 = fz_new_color_pcl_band_writer(VAR_0, VAR_13, NULL);
				}
				if (VAR_43)
					fz_write_header(VAR_0, VAR_43, VAR_40->w, VAR_56, VAR_40->n, VAR_40->alpha, VAR_40->xres, VAR_40->yres, ++VAR_74);
			}

			for (VAR_54 = 0; VAR_54 < VAR_55; VAR_54++)
			{
				if (VAR_59 > 0)
				{
					worker_t *VAR_41 = &VAR_60[VAR_54 % VAR_59];
					DEBUG_THREADS((""Waiting for worker %d to complete band %d\n"", VAR_41->num, VAR_54));
					mu_wait_semaphore(&VAR_41->stop);
					VAR_40 = VAR_41->pix;
					VAR_44 = VAR_41->bit;
					VAR_41->bit = NULL;
					VAR_4->errors += VAR_41->cookie.errors;
				}
				else
					drawband(VAR_0, VAR_1, VAR_2, &VAR_33, &VAR_35, VAR_4, VAR_54 * VAR_58, VAR_40, &VAR_44);

				if (VAR_37)
				{
					if (VAR_43)
						fz_write_band(VAR_0, VAR_43, VAR_44 ? VAR_44->stride : VAR_40->stride, VAR_54 * VAR_58, VAR_57, VAR_44 ? VAR_44->samples : VAR_40->samples);
					else if (output_format == VAR_75)
						fz_write_pixmap_as_pwg(VAR_0, VAR_13, VAR_40, NULL);
					else if (output_format == VAR_76)
						fz_write_pixmap_as_tga(VAR_0, VAR_13, VAR_40);
					fz_drop_bitmap(VAR_0, VAR_44);
					VAR_44 = NULL;
				}

				if (VAR_59 > 0 && VAR_54 + VAR_59 < VAR_55)
				{
					worker_t *VAR_41 = &VAR_60[VAR_54 % VAR_59];
					VAR_41->band = VAR_54 + VAR_59;
					VAR_41->ctm = VAR_33;
					VAR_41->tbounds = VAR_35;
					memset(&VAR_41->cookie, 0, sizeof(fz_cookie));
					DEBUG_THREADS((""Triggering worker %d for band %d\n"", VAR_41->num, VAR_41->band));
					mu_trigger_semaphore(&VAR_41->start);
				}
				VAR_33.f -= VAR_57;
			}

			/* COMMENT_7 */
			if (VAR_77)
			{
				unsigned char VAR_78[16];
				int VAR_79;

				fz_md5_pixmap(VAR_0, VAR_40, VAR_78);
				fprintf(VAR_80, "" "");
				for (VAR_79 = 0; VAR_79 < 16; VAR_79++)
					fprintf(VAR_80, ""%02x"", VAR_78[VAR_79]);
			}

			/* COMMENT_8 */
			if (VAR_37)
			{
				if (VAR_43)
					fz_write_trailer(VAR_0, VAR_43);
			}
		}
		fz_always(VAR_0)
		{
			fz_drop_band_writer(VAR_0, VAR_43);
			fz_drop_bitmap(VAR_0, VAR_44);
			VAR_44 = NULL;
			if (VAR_59 > 0)
			{
				int VAR_54;
				for (VAR_54 = 0; VAR_54 < VAR_59; VAR_54++)
					fz_drop_pixmap(VAR_0, VAR_60[VAR_54].pix);
			}
			else
				fz_drop_pixmap(VAR_0, VAR_40);
		}
		fz_catch(VAR_0)
		{
			fz_drop_display_list(VAR_0, VAR_2);
			fz_drop_page(VAR_0, VAR_1);
			fz_rethrow(VAR_0);
		}
	}

	fz_drop_display_list(VAR_0, VAR_2);

	if (!VAR_81)
		file_level_trailers(VAR_0);

	fz_drop_page(VAR_0, VAR_1);

	if (VAR_82)
	{
		int VAR_83 = gettime();
		int VAR_84 = VAR_83 - VAR_5;

		if (VAR_8)
		{
			if (VAR_84 + VAR_6 < VAR_85.min)
			{
				VAR_85.min = VAR_84 + VAR_6;
				VAR_85.mininterp = VAR_6;
				VAR_85.minpage = VAR_3;
				VAR_85.minfilename = VAR_7;
			}
			if (VAR_84 + VAR_6 > VAR_85.max)
			{
				VAR_85.max = VAR_84 + VAR_6;
				VAR_85.maxinterp = VAR_6;
				VAR_85.maxpage = VAR_3;
				VAR_85.maxfilename = VAR_7;
			}
			VAR_85.count ++;

			fprintf(VAR_80, "" %dms (interpretation) %dms (rendering) %dms (total)"", VAR_6, VAR_84, VAR_84 + VAR_6);
		}
		else
		{
			if (VAR_84 < VAR_85.min)
			{
				VAR_85.min = VAR_84;
				VAR_85.minpage = VAR_3;
				VAR_85.minfilename = VAR_7;
			}
			if (VAR_84 > VAR_85.max)
			{
				VAR_85.max = VAR_84;
				VAR_85.maxpage = VAR_3;
				VAR_85.maxfilename = VAR_7;
			}
			VAR_85.total += VAR_84;
			VAR_85.count ++;

			fprintf(VAR_80, "" %dms"", VAR_84);
		}
	}

	fprintf(VAR_80, ""\n"");

	if (VAR_14)
	{
		fz_empty_store(VAR_0);
	}

	if (VAR_86)
	{
		fz_dump_glyph_cache_stats(VAR_0);
	}

	fz_flush_warnings(VAR_0);

	if (VAR_4->errors)
		VAR_87 = 1;
}",ArtifexSoftware/mupdf/40ac85bfb676bb4373bda4b18f9fd90268c9f1e9/mudraw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -134,7 +134,7 @@
 		char buf[512];
 		fz_output *out;
 
-		if (!strcmp(output, ""-""))
+		if (!output || !strcmp(output, ""-""))
 			out = fz_stdout(ctx);
 		else
 		{","{'deleted_lines': ['\t\tif (!strcmp(output, ""-""))'], 'added_lines': ['\t\tif (!output || !strcmp(output, ""-""))']}",True,Heap-based buffer overflow in the fz_subsample_pixmap function in fitz/pixmap.c in MuPDF 1.10a allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted image.,5.5,MEDIUM,1,valid,2017-02-04T05:21:20Z,1
CVE-2017-12985,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.

rt6_print(), ah_print(), and esp_print() return -1 if they run up
against the end of the packet while dissecting; if that happens, stop
dissecting, don't try to fetch the next header value, because 1) *it*
might be past the end of the packet and 2) we won't be using it in any
case, as we'll be exiting the loop.

Also, change mobility_print() to return -1 if it runs up against the
end of the packet, and stop dissecting if it does so.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add tests using the capture files supplied by the reporter(s).",66df248b49095c261138b5a5e34d341a6bf9ac7f,https://github.com/the-tcpdump-group/tcpdump/commit/66df248b49095c261138b5a5e34d341a6bf9ac7f,print-mobility.c,mobility_print,"int
mobility_print(netdissect_options *ndo,
const u_char *bp, const u_char *bp2 _U_)
{
const struct ip6_mobility *mh;
const u_char *ep;
unsigned mhlen, hlen;
uint8_t type;
mh = (const struct ip6_mobility *)bp;
ep = ndo->ndo_snapend;
if (!ND_TTEST(mh->ip6m_len)) {
mhlen = ep - bp;
goto trunc;
}
mhlen = (mh->ip6m_len + 1) << 3;
ND_TCHECK(mh->ip6m_type);
type = mh->ip6m_type;
if (type <= IP6M_MAX && mhlen < ip6m_hdrlen[type]) {
ND_PRINT((ndo, ""(header length %u is too small for type %u)"", mhlen, type));
goto trunc;
}
ND_PRINT((ndo, ""mobility: %s"", tok2str(ip6m_str, ""type-#%u"", type)));
switch (type) {
case IP6M_BINDING_REQUEST:
hlen = IP6M_MINLEN;
break;
case IP6M_HOME_TEST_INIT:
case IP6M_CAREOF_TEST_INIT:
hlen = IP6M_MINLEN;
if (ndo->ndo_vflag) {
ND_TCHECK2(*mh, hlen + 8);
ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"",
EXTRACT_32BITS(&bp[hlen]),
EXTRACT_32BITS(&bp[hlen + 4])));
}
hlen += 8;
break;
case IP6M_HOME_TEST:
case IP6M_CAREOF_TEST:
ND_TCHECK(mh->ip6m_data16[0]);
ND_PRINT((ndo, "" nonce id=0x%x"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
hlen = IP6M_MINLEN;
if (ndo->ndo_vflag) {
ND_TCHECK2(*mh, hlen + 8);
ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
EXTRACT_32BITS(&bp[hlen]),
EXTRACT_32BITS(&bp[hlen + 4])));
}
hlen += 8;
if (ndo->ndo_vflag) {
ND_TCHECK2(*mh, hlen + 8);
ND_PRINT((ndo, "" %s Keygen Token=%08x:%08x"",
type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
EXTRACT_32BITS(&bp[hlen]),
EXTRACT_32BITS(&bp[hlen + 4])));
}
hlen += 8;
break;
case IP6M_BINDING_UPDATE:
ND_TCHECK(mh->ip6m_data16[0]);
ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
hlen = IP6M_MINLEN;
ND_TCHECK2(*mh, hlen + 1);
if (bp[hlen] & 0xf0)
ND_PRINT((ndo, "" ""));
if (bp[hlen] & 0x80)
ND_PRINT((ndo, ""A""));
if (bp[hlen] & 0x40)
ND_PRINT((ndo, ""H""));
if (bp[hlen] & 0x20)
ND_PRINT((ndo, ""L""));
if (bp[hlen] & 0x10)
ND_PRINT((ndo, ""K""));
hlen += 1;
hlen += 1;
ND_TCHECK2(*mh, hlen + 2);
ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
hlen += 2;
break;
case IP6M_BINDING_ACK:
ND_TCHECK(mh->ip6m_data8[0]);
ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
if (mh->ip6m_data8[1] & 0x80)
ND_PRINT((ndo, "" K""));
hlen = IP6M_MINLEN;
ND_TCHECK2(*mh, hlen + 2);
ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&bp[hlen])));
hlen += 2;
ND_TCHECK2(*mh, hlen + 2);
ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
hlen += 2;
break;
case IP6M_BINDING_ERROR:
ND_TCHECK(mh->ip6m_data8[0]);
ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
hlen = IP6M_MINLEN;
ND_TCHECK2(*mh, hlen + 16);
ND_PRINT((ndo, "" homeaddr %s"", ip6addr_string(ndo, &bp[hlen])));
hlen += 16;
break;
default:
ND_PRINT((ndo, "" len=%u"", mh->ip6m_len));
return(mhlen);
break;
}
if (ndo->ndo_vflag)
if (mobility_opt_print(ndo, &bp[hlen], mhlen - hlen))
goto trunc;
return(mhlen);
trunc:
ND_PRINT((ndo, ""%s"", tstr));
return(mhlen);
}","int
mobility_print(netdissect_options *VAR_0,
const u_char *VAR_1, const u_char *VAR_2 _U_)
{
const struct ip6_mobility *VAR_3;
const u_char *VAR_4;
unsigned VAR_5, VAR_6;
uint8_t VAR_7;
VAR_3 = (const struct ip6_mobility *)VAR_1;
VAR_4 = VAR_0->ndo_snapend;
if (!ND_TTEST(VAR_3->ip6m_len)) {
VAR_5 = VAR_4 - VAR_1;
goto trunc;
}
VAR_5 = (VAR_3->ip6m_len + 1) << 3;
ND_TCHECK(VAR_3->ip6m_type);
VAR_7 = VAR_3->ip6m_type;
if (VAR_7 <= VAR_8 && VAR_5 < VAR_9[VAR_7]) {
ND_PRINT((VAR_0, ""(header length %u is too small for type %u)"", VAR_5, VAR_7));
goto trunc;
}
ND_PRINT((VAR_0, ""mobility: %s"", tok2str(VAR_10, ""type-#%u"", VAR_7)));
switch (VAR_7) {
case VAR_11:
VAR_6 = VAR_12;
break;
case VAR_13:
case VAR_14:
VAR_6 = VAR_12;
if (VAR_0->ndo_vflag) {
ND_TCHECK2(*VAR_3, VAR_6 + 8);
ND_PRINT((VAR_0, "" %s Init Cookie=%08x:%08x"",
VAR_7 == VAR_13 ? ""Home"" : ""Care-of"",
EXTRACT_32BITS(&VAR_1[VAR_6]),
EXTRACT_32BITS(&VAR_1[VAR_6 + 4])));
}
VAR_6 += 8;
break;
case VAR_15:
case VAR_16:
ND_TCHECK(VAR_3->ip6m_data16[0]);
ND_PRINT((VAR_0, "" nonce id=0x%x"", EXTRACT_16BITS(&VAR_3->ip6m_data16[0])));
VAR_6 = VAR_12;
if (VAR_0->ndo_vflag) {
ND_TCHECK2(*VAR_3, VAR_6 + 8);
ND_PRINT((VAR_0, "" %s Init Cookie=%08x:%08x"",
VAR_7 == VAR_15 ? ""Home"" : ""Care-of"",
EXTRACT_32BITS(&VAR_1[VAR_6]),
EXTRACT_32BITS(&VAR_1[VAR_6 + 4])));
}
VAR_6 += 8;
if (VAR_0->ndo_vflag) {
ND_TCHECK2(*VAR_3, VAR_6 + 8);
ND_PRINT((VAR_0, "" %s Keygen Token=%08x:%08x"",
VAR_7 == VAR_15 ? ""Home"" : ""Care-of"",
EXTRACT_32BITS(&VAR_1[VAR_6]),
EXTRACT_32BITS(&VAR_1[VAR_6 + 4])));
}
VAR_6 += 8;
break;
case VAR_17:
ND_TCHECK(VAR_3->ip6m_data16[0]);
ND_PRINT((VAR_0, "" seq#=%u"", EXTRACT_16BITS(&VAR_3->ip6m_data16[0])));
VAR_6 = VAR_12;
ND_TCHECK2(*VAR_3, VAR_6 + 1);
if (VAR_1[VAR_6] & 0xf0)
ND_PRINT((VAR_0, "" ""));
if (VAR_1[VAR_6] & 0x80)
ND_PRINT((VAR_0, ""A""));
if (VAR_1[VAR_6] & 0x40)
ND_PRINT((VAR_0, ""H""));
if (VAR_1[VAR_6] & 0x20)
ND_PRINT((VAR_0, ""L""));
if (VAR_1[VAR_6] & 0x10)
ND_PRINT((VAR_0, ""K""));
VAR_6 += 1;
VAR_6 += 1;
ND_TCHECK2(*VAR_3, VAR_6 + 2);
ND_PRINT((VAR_0, "" lifetime=%u"", EXTRACT_16BITS(&VAR_1[VAR_6]) << 2));
VAR_6 += 2;
break;
case VAR_18:
ND_TCHECK(VAR_3->ip6m_data8[0]);
ND_PRINT((VAR_0, "" status=%u"", VAR_3->ip6m_data8[0]));
if (VAR_3->ip6m_data8[1] & 0x80)
ND_PRINT((VAR_0, "" K""));
VAR_6 = VAR_12;
ND_TCHECK2(*VAR_3, VAR_6 + 2);
ND_PRINT((VAR_0, "" seq#=%u"", EXTRACT_16BITS(&VAR_1[VAR_6])));
VAR_6 += 2;
ND_TCHECK2(*VAR_3, VAR_6 + 2);
ND_PRINT((VAR_0, "" lifetime=%u"", EXTRACT_16BITS(&VAR_1[VAR_6]) << 2));
VAR_6 += 2;
break;
case VAR_19:
ND_TCHECK(VAR_3->ip6m_data8[0]);
ND_PRINT((VAR_0, "" status=%u"", VAR_3->ip6m_data8[0]));
VAR_6 = VAR_12;
ND_TCHECK2(*VAR_3, VAR_6 + 16);
ND_PRINT((VAR_0, "" homeaddr %s"", ip6addr_string(VAR_0, &VAR_1[VAR_6])));
VAR_6 += 16;
break;
default:
ND_PRINT((VAR_0, "" len=%u"", VAR_3->ip6m_len));
return(VAR_5);
break;
}
if (VAR_0->ndo_vflag)
if (mobility_opt_print(VAR_0, &VAR_1[VAR_6], VAR_5 - VAR_6))
goto trunc;
return(VAR_5);
trunc:
ND_PRINT((VAR_0, ""%s"", VAR_20));
return(VAR_5);
}",,"int
mobility_print(netdissect_options *ndo,
               const u_char *bp, const u_char *bp2 _U_)
{
	const struct ip6_mobility *mh;
	const u_char *ep;
	unsigned mhlen, hlen;
	uint8_t type;

	mh = (const struct ip6_mobility *)bp;

	/* 'ep' points to the end of available data. */
	ep = ndo->ndo_snapend;

	if (!ND_TTEST(mh->ip6m_len)) {
		/*
		 * There's not enough captured data to include the
		 * mobility header length.
		 *
		 * Our caller expects us to return the length, however,
		 * so return a value that will run to the end of the
		 * captured data.
		 *
		 * XXX - ""ip6_print()"" doesn't do anything with the
		 * returned length, however, as it breaks out of the
		 * header-processing loop.
		 */
		mhlen = ep - bp;
		goto trunc;
	}
	mhlen = (mh->ip6m_len + 1) << 3;

	/* XXX ip6m_cksum */

	ND_TCHECK(mh->ip6m_type);
	type = mh->ip6m_type;
	if (type <= IP6M_MAX && mhlen < ip6m_hdrlen[type]) {
		ND_PRINT((ndo, ""(header length %u is too small for type %u)"", mhlen, type));
		goto trunc;
	}
	ND_PRINT((ndo, ""mobility: %s"", tok2str(ip6m_str, ""type-#%u"", type)));
	switch (type) {
	case IP6M_BINDING_REQUEST:
		hlen = IP6M_MINLEN;
		break;
	case IP6M_HOME_TEST_INIT:
	case IP6M_CAREOF_TEST_INIT:
		hlen = IP6M_MINLEN;
		if (ndo->ndo_vflag) {
			ND_TCHECK2(*mh, hlen + 8);
			ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
			       type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&bp[hlen]),
			       EXTRACT_32BITS(&bp[hlen + 4])));
		}
		hlen += 8;
		break;
	case IP6M_HOME_TEST:
	case IP6M_CAREOF_TEST:
		ND_TCHECK(mh->ip6m_data16[0]);
		ND_PRINT((ndo, "" nonce id=0x%x"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
		hlen = IP6M_MINLEN;
		if (ndo->ndo_vflag) {
			ND_TCHECK2(*mh, hlen + 8);
			ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
			       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&bp[hlen]),
			       EXTRACT_32BITS(&bp[hlen + 4])));
		}
		hlen += 8;
		if (ndo->ndo_vflag) {
			ND_TCHECK2(*mh, hlen + 8);
			ND_PRINT((ndo, "" %s Keygen Token=%08x:%08x"",
			       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&bp[hlen]),
			       EXTRACT_32BITS(&bp[hlen + 4])));
		}
		hlen += 8;
		break;
	case IP6M_BINDING_UPDATE:
		ND_TCHECK(mh->ip6m_data16[0]);
		ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
		hlen = IP6M_MINLEN;
		ND_TCHECK2(*mh, hlen + 1);
		if (bp[hlen] & 0xf0)
			ND_PRINT((ndo, "" ""));
		if (bp[hlen] & 0x80)
			ND_PRINT((ndo, ""A""));
		if (bp[hlen] & 0x40)
			ND_PRINT((ndo, ""H""));
		if (bp[hlen] & 0x20)
			ND_PRINT((ndo, ""L""));
		if (bp[hlen] & 0x10)
			ND_PRINT((ndo, ""K""));
		/* Reserved (4bits) */
		hlen += 1;
		/* Reserved (8bits) */
		hlen += 1;
		ND_TCHECK2(*mh, hlen + 2);
		/* units of 4 secs */
		ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
		hlen += 2;
		break;
	case IP6M_BINDING_ACK:
		ND_TCHECK(mh->ip6m_data8[0]);
		ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
		if (mh->ip6m_data8[1] & 0x80)
			ND_PRINT((ndo, "" K""));
		/* Reserved (7bits) */
		hlen = IP6M_MINLEN;
		ND_TCHECK2(*mh, hlen + 2);
		ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&bp[hlen])));
		hlen += 2;
		ND_TCHECK2(*mh, hlen + 2);
		/* units of 4 secs */
		ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
		hlen += 2;
		break;
	case IP6M_BINDING_ERROR:
		ND_TCHECK(mh->ip6m_data8[0]);
		ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
		/* Reserved */
		hlen = IP6M_MINLEN;
		ND_TCHECK2(*mh, hlen + 16);
		ND_PRINT((ndo, "" homeaddr %s"", ip6addr_string(ndo, &bp[hlen])));
		hlen += 16;
		break;
	default:
		ND_PRINT((ndo, "" len=%u"", mh->ip6m_len));
		return(mhlen);
		break;
	}
	if (ndo->ndo_vflag)
		if (mobility_opt_print(ndo, &bp[hlen], mhlen - hlen))
			goto trunc;

	return(mhlen);

 trunc:
	ND_PRINT((ndo, ""%s"", tstr));
	return(-1);
}","int
mobility_print(netdissect_options *VAR_0,
               const u_char *VAR_1, const u_char *VAR_2 _U_)
{
	const struct ip6_mobility *VAR_3;
	const u_char *VAR_4;
	unsigned VAR_5, VAR_6;
	uint8_t VAR_7;

	VAR_3 = (const struct ip6_mobility *)VAR_1;

	/* COMMENT_0 */
	VAR_4 = VAR_0->ndo_snapend;

	if (!ND_TTEST(VAR_3->ip6m_len)) {
		/* COMMENT_1 */
                                                    
                            
    
                                                         
                                                      
                   
    
                                                     
                                                      
                            
     
		VAR_5 = VAR_4 - VAR_1;
		goto trunc;
	}
	VAR_5 = (VAR_3->ip6m_len + 1) << 3;

	/* COMMENT_12 */

	ND_TCHECK(VAR_3->ip6m_type);
	VAR_7 = VAR_3->ip6m_type;
	if (VAR_7 <= VAR_8 && VAR_5 < VAR_9[VAR_7]) {
		ND_PRINT((VAR_0, ""(header length %u is too small for type %u)"", VAR_5, VAR_7));
		goto trunc;
	}
	ND_PRINT((VAR_0, ""mobility: %s"", tok2str(VAR_10, ""type-#%u"", VAR_7)));
	switch (VAR_7) {
	case VAR_11:
		VAR_6 = VAR_12;
		break;
	case VAR_13:
	case VAR_14:
		VAR_6 = VAR_12;
		if (VAR_0->ndo_vflag) {
			ND_TCHECK2(*VAR_3, VAR_6 + 8);
			ND_PRINT((VAR_0, "" %s Init Cookie=%08x:%08x"",
			       VAR_7 == VAR_13 ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&VAR_1[VAR_6]),
			       EXTRACT_32BITS(&VAR_1[VAR_6 + 4])));
		}
		VAR_6 += 8;
		break;
	case VAR_15:
	case VAR_16:
		ND_TCHECK(VAR_3->ip6m_data16[0]);
		ND_PRINT((VAR_0, "" nonce id=0x%x"", EXTRACT_16BITS(&VAR_3->ip6m_data16[0])));
		VAR_6 = VAR_12;
		if (VAR_0->ndo_vflag) {
			ND_TCHECK2(*VAR_3, VAR_6 + 8);
			ND_PRINT((VAR_0, "" %s Init Cookie=%08x:%08x"",
			       VAR_7 == VAR_15 ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&VAR_1[VAR_6]),
			       EXTRACT_32BITS(&VAR_1[VAR_6 + 4])));
		}
		VAR_6 += 8;
		if (VAR_0->ndo_vflag) {
			ND_TCHECK2(*VAR_3, VAR_6 + 8);
			ND_PRINT((VAR_0, "" %s Keygen Token=%08x:%08x"",
			       VAR_7 == VAR_15 ? ""Home"" : ""Care-of"",
			       EXTRACT_32BITS(&VAR_1[VAR_6]),
			       EXTRACT_32BITS(&VAR_1[VAR_6 + 4])));
		}
		VAR_6 += 8;
		break;
	case VAR_17:
		ND_TCHECK(VAR_3->ip6m_data16[0]);
		ND_PRINT((VAR_0, "" seq#=%u"", EXTRACT_16BITS(&VAR_3->ip6m_data16[0])));
		VAR_6 = VAR_12;
		ND_TCHECK2(*VAR_3, VAR_6 + 1);
		if (VAR_1[VAR_6] & 0xf0)
			ND_PRINT((VAR_0, "" ""));
		if (VAR_1[VAR_6] & 0x80)
			ND_PRINT((VAR_0, ""A""));
		if (VAR_1[VAR_6] & 0x40)
			ND_PRINT((VAR_0, ""H""));
		if (VAR_1[VAR_6] & 0x20)
			ND_PRINT((VAR_0, ""L""));
		if (VAR_1[VAR_6] & 0x10)
			ND_PRINT((VAR_0, ""K""));
		/* COMMENT_13 */
		VAR_6 += 1;
		/* COMMENT_14 */
		VAR_6 += 1;
		ND_TCHECK2(*VAR_3, VAR_6 + 2);
		/* COMMENT_15 */
		ND_PRINT((VAR_0, "" lifetime=%u"", EXTRACT_16BITS(&VAR_1[VAR_6]) << 2));
		VAR_6 += 2;
		break;
	case VAR_18:
		ND_TCHECK(VAR_3->ip6m_data8[0]);
		ND_PRINT((VAR_0, "" status=%u"", VAR_3->ip6m_data8[0]));
		if (VAR_3->ip6m_data8[1] & 0x80)
			ND_PRINT((VAR_0, "" K""));
		/* COMMENT_16 */
		VAR_6 = VAR_12;
		ND_TCHECK2(*VAR_3, VAR_6 + 2);
		ND_PRINT((VAR_0, "" seq#=%u"", EXTRACT_16BITS(&VAR_1[VAR_6])));
		VAR_6 += 2;
		ND_TCHECK2(*VAR_3, VAR_6 + 2);
		/* COMMENT_15 */
		ND_PRINT((VAR_0, "" lifetime=%u"", EXTRACT_16BITS(&VAR_1[VAR_6]) << 2));
		VAR_6 += 2;
		break;
	case VAR_19:
		ND_TCHECK(VAR_3->ip6m_data8[0]);
		ND_PRINT((VAR_0, "" status=%u"", VAR_3->ip6m_data8[0]));
		/* COMMENT_17 */
		VAR_6 = VAR_12;
		ND_TCHECK2(*VAR_3, VAR_6 + 16);
		ND_PRINT((VAR_0, "" homeaddr %s"", ip6addr_string(VAR_0, &VAR_1[VAR_6])));
		VAR_6 += 16;
		break;
	default:
		ND_PRINT((VAR_0, "" len=%u"", VAR_3->ip6m_len));
		return(VAR_5);
		break;
	}
	if (VAR_0->ndo_vflag)
		if (mobility_opt_print(VAR_0, &VAR_1[VAR_6], VAR_5 - VAR_6))
			goto trunc;

	return(VAR_5);

 trunc:
	ND_PRINT((VAR_0, ""%s"", VAR_20));
	return(-1);
}",,"--- func_before
+++ func_after
@@ -138,5 +138,5 @@
 
  trunc:
 	ND_PRINT((ndo, ""%s"", tstr));
-	return(mhlen);
+	return(-1);
 }","{'deleted_lines': ['\treturn(mhlen);'], 'added_lines': ['\treturn(-1);']}",True,The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print().,9.8,CRITICAL,3,valid,2017-02-04T11:13:18Z,1
CVE-2017-12985,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.

rt6_print(), ah_print(), and esp_print() return -1 if they run up
against the end of the packet while dissecting; if that happens, stop
dissecting, don't try to fetch the next header value, because 1) *it*
might be past the end of the packet and 2) we won't be using it in any
case, as we'll be exiting the loop.

Also, change mobility_print() to return -1 if it runs up against the
end of the packet, and stop dissecting if it does so.

This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.

Add tests using the capture files supplied by the reporter(s).",66df248b49095c261138b5a5e34d341a6bf9ac7f,https://github.com/the-tcpdump-group/tcpdump/commit/66df248b49095c261138b5a5e34d341a6bf9ac7f,print-ip6.c,ip6_print,"void
ip6_print(netdissect_options *ndo, const u_char *bp, u_int length)
{
register const struct ip6_hdr *ip6;
register int advance;
u_int len;
const u_char *ipend;
register const u_char *cp;
register u_int payload_len;
int nh;
int fragmented = 0;
u_int flow;
ip6 = (const struct ip6_hdr *)bp;
ND_TCHECK(*ip6);
if (length < sizeof (struct ip6_hdr)) {
ND_PRINT((ndo, ""truncated-ip6 %u"", length));
return;
}
if (!ndo->ndo_eflag)
ND_PRINT((ndo, ""IP6 ""));
if (IP6_VERSION(ip6) != 6) {
ND_PRINT((ndo,""version error: %u != 6"", IP6_VERSION(ip6)));
return;
}
payload_len = EXTRACT_16BITS(&ip6->ip6_plen);
len = payload_len + sizeof(struct ip6_hdr);
if (length < len)
ND_PRINT((ndo, ""truncated-ip6 - %u bytes missing!"",
len - length));
if (ndo->ndo_vflag) {
flow = EXTRACT_32BITS(&ip6->ip6_flow);
ND_PRINT((ndo, ""(""));
#if 0
if (flow & 0x0f000000)
ND_PRINT((ndo, ""pri 0x%02x, "", (flow & 0x0f000000) >> 24));
if (flow & 0x00ffffff)
ND_PRINT((ndo, ""flowlabel 0x%06x, "", flow & 0x00ffffff));
#else
if (flow & 0x0ff00000)
ND_PRINT((ndo, ""class 0x%02x, "", (flow & 0x0ff00000) >> 20));
if (flow & 0x000fffff)
ND_PRINT((ndo, ""flowlabel 0x%05x, "", flow & 0x000fffff));
#endif
ND_PRINT((ndo, ""hlim %u, next-header %s (%u) payload length: %u) "",
ip6->ip6_hlim,
tok2str(ipproto_values,""unknown"",ip6->ip6_nxt),
ip6->ip6_nxt,
payload_len));
}
ipend = bp + len;
if (ipend < ndo->ndo_snapend)
ndo->ndo_snapend = ipend;
cp = (const u_char *)ip6;
advance = sizeof(struct ip6_hdr);
nh = ip6->ip6_nxt;
while (cp < ndo->ndo_snapend && advance > 0) {
cp += advance;
len -= advance;
if (cp == (const u_char *)(ip6 + 1) &&
nh != IPPROTO_TCP && nh != IPPROTO_UDP &&
nh != IPPROTO_DCCP && nh != IPPROTO_SCTP) {
ND_PRINT((ndo, ""%s > %s: "", ip6addr_string(ndo, &ip6->ip6_src),
ip6addr_string(ndo, &ip6->ip6_dst)));
}
switch (nh) {
case IPPROTO_HOPOPTS:
advance = hbhopt_print(ndo, cp);
if (advance < 0)
return;
nh = *cp;
break;
case IPPROTO_DSTOPTS:
advance = dstopt_print(ndo, cp);
if (advance < 0)
return;
nh = *cp;
break;
case IPPROTO_FRAGMENT:
advance = frag6_print(ndo, cp, (const u_char *)ip6);
if (advance < 0 || ndo->ndo_snapend <= cp + advance)
return;
nh = *cp;
fragmented = 1;
break;
case IPPROTO_MOBILITY_OLD:
case IPPROTO_MOBILITY:
advance = mobility_print(ndo, cp, (const u_char *)ip6);
nh = *cp;
return;
case IPPROTO_ROUTING:
advance = rt6_print(ndo, cp, (const u_char *)ip6);
nh = *cp;
break;
case IPPROTO_SCTP:
sctp_print(ndo, cp, (const u_char *)ip6, len);
return;
case IPPROTO_DCCP:
dccp_print(ndo, cp, (const u_char *)ip6, len);
return;
case IPPROTO_TCP:
tcp_print(ndo, cp, len, (const u_char *)ip6, fragmented);
return;
case IPPROTO_UDP:
udp_print(ndo, cp, len, (const u_char *)ip6, fragmented);
return;
case IPPROTO_ICMPV6:
icmp6_print(ndo, cp, len, (const u_char *)ip6, fragmented);
return;
case IPPROTO_AH:
advance = ah_print(ndo, cp);
nh = *cp;
break;
case IPPROTO_ESP:
{
int enh, padlen;
advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);
nh = enh & 0xff;
len -= padlen;
break;
}
case IPPROTO_IPCOMP:
{
ipcomp_print(ndo, cp);
advance = -1;
break;
}
case IPPROTO_PIM:
pim_print(ndo, cp, len, (const u_char *)ip6);
return;
case IPPROTO_OSPF:
ospf6_print(ndo, cp, len);
return;
case IPPROTO_IPV6:
ip6_print(ndo, cp, len);
return;
case IPPROTO_IPV4:
ip_print(ndo, cp, len);
return;
case IPPROTO_PGM:
pgm_print(ndo, cp, len, (const u_char *)ip6);
return;
case IPPROTO_GRE:
gre_print(ndo, cp, len);
return;
case IPPROTO_RSVP:
rsvp_print(ndo, cp, len);
return;
case IPPROTO_NONE:
ND_PRINT((ndo, ""no next header""));
return;
default:
ND_PRINT((ndo, ""ip-proto-%d %d"", nh, len));
return;
}
}
return;
trunc:
ND_PRINT((ndo, ""[|ip6]""));
}","void
ip6_print(netdissect_options *VAR_0, const u_char *VAR_1, u_int VAR_2)
{
register const struct ip6_hdr *VAR_3;
register int VAR_4;
u_int VAR_5;
const u_char *VAR_6;
register const u_char *VAR_7;
register u_int VAR_8;
int VAR_9;
int VAR_10 = 0;
u_int VAR_11;
VAR_3 = (const struct ip6_hdr *)VAR_1;
ND_TCHECK(*VAR_3);
if (VAR_2 < sizeof (struct ip6_hdr)) {
ND_PRINT((VAR_0, ""truncated-ip6 %u"", VAR_2));
return;
}
if (!VAR_0->ndo_eflag)
ND_PRINT((VAR_0, ""IP6 ""));
if (IP6_VERSION(VAR_3) != 6) {
ND_PRINT((VAR_0,""version error: %u != 6"", IP6_VERSION(VAR_3)));
return;
}
VAR_8 = EXTRACT_16BITS(&VAR_3->ip6_plen);
VAR_5 = VAR_8 + sizeof(struct ip6_hdr);
if (VAR_2 < VAR_5)
ND_PRINT((VAR_0, ""truncated-ip6 - %u bytes missing!"",
VAR_5 - VAR_2));
if (VAR_0->ndo_vflag) {
VAR_11 = EXTRACT_32BITS(&VAR_3->ip6_flow);
ND_PRINT((VAR_0, ""(""));
#if 0
if (VAR_11 & 0x0f000000)
ND_PRINT((VAR_0, ""pri 0x%02x, "", (VAR_11 & 0x0f000000) >> 24));
if (VAR_11 & 0x00ffffff)
ND_PRINT((VAR_0, ""flowlabel 0x%06x, "", VAR_11 & 0x00ffffff));
#else
if (VAR_11 & 0x0ff00000)
ND_PRINT((VAR_0, ""class 0x%02x, "", (VAR_11 & 0x0ff00000) >> 20));
if (VAR_11 & 0x000fffff)
ND_PRINT((VAR_0, ""flowlabel 0x%05x, "", VAR_11 & 0x000fffff));
#endif
ND_PRINT((VAR_0, ""hlim %u, next-header %s (%u) payload length: %u) "",
VAR_3->ip6_hlim,
tok2str(VAR_12,""unknown"",VAR_3->ip6_nxt),
VAR_3->ip6_nxt,
VAR_8));
}
VAR_6 = VAR_1 + VAR_5;
if (VAR_6 < VAR_0->ndo_snapend)
VAR_0->ndo_snapend = VAR_6;
VAR_7 = (const u_char *)VAR_3;
VAR_4 = sizeof(struct ip6_hdr);
VAR_9 = VAR_3->ip6_nxt;
while (VAR_7 < VAR_0->ndo_snapend && VAR_4 > 0) {
VAR_7 += VAR_4;
VAR_5 -= VAR_4;
if (VAR_7 == (const u_char *)(VAR_3 + 1) &&
VAR_9 != VAR_13 && VAR_9 != VAR_14 &&
VAR_9 != VAR_15 && VAR_9 != VAR_16) {
ND_PRINT((VAR_0, ""%s > %s: "", ip6addr_string(VAR_0, &VAR_3->ip6_src),
ip6addr_string(VAR_0, &VAR_3->ip6_dst)));
}
switch (VAR_9) {
case VAR_17:
VAR_4 = hbhopt_print(VAR_0, VAR_7);
if (VAR_4 < 0)
return;
VAR_9 = *VAR_7;
break;
case VAR_18:
VAR_4 = dstopt_print(VAR_0, VAR_7);
if (VAR_4 < 0)
return;
VAR_9 = *VAR_7;
break;
case VAR_19:
VAR_4 = frag6_print(VAR_0, VAR_7, (const u_char *)VAR_3);
if (VAR_4 < 0 || VAR_0->ndo_snapend <= VAR_7 + VAR_4)
return;
VAR_9 = *VAR_7;
VAR_10 = 1;
break;
case VAR_20:
case VAR_21:
VAR_4 = mobility_print(VAR_0, VAR_7, (const u_char *)VAR_3);
VAR_9 = *VAR_7;
return;
case VAR_22:
VAR_4 = rt6_print(VAR_0, VAR_7, (const u_char *)VAR_3);
VAR_9 = *VAR_7;
break;
case VAR_16:
sctp_print(VAR_0, VAR_7, (const u_char *)VAR_3, VAR_5);
return;
case VAR_15:
dccp_print(VAR_0, VAR_7, (const u_char *)VAR_3, VAR_5);
return;
case VAR_13:
tcp_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, VAR_10);
return;
case VAR_14:
udp_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, VAR_10);
return;
case VAR_23:
icmp6_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, VAR_10);
return;
case VAR_24:
VAR_4 = ah_print(VAR_0, VAR_7);
VAR_9 = *VAR_7;
break;
case VAR_25:
{
int VAR_26, VAR_27;
VAR_4 = esp_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, &VAR_26, &VAR_27);
VAR_9 = VAR_26 & 0xff;
VAR_5 -= VAR_27;
break;
}
case VAR_28:
{
ipcomp_print(VAR_0, VAR_7);
VAR_4 = -1;
break;
}
case VAR_29:
pim_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3);
return;
case VAR_30:
ospf6_print(VAR_0, VAR_7, VAR_5);
return;
case VAR_31:
ip6_print(VAR_0, VAR_7, VAR_5);
return;
case VAR_32:
ip_print(VAR_0, VAR_7, VAR_5);
return;
case VAR_33:
pgm_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3);
return;
case VAR_34:
gre_print(VAR_0, VAR_7, VAR_5);
return;
case VAR_35:
rsvp_print(VAR_0, VAR_7, VAR_5);
return;
case VAR_36:
ND_PRINT((VAR_0, ""no next header""));
return;
default:
ND_PRINT((VAR_0, ""ip-proto-%d %d"", VAR_9, VAR_5));
return;
}
}
return;
trunc:
ND_PRINT((VAR_0, ""[|ip6]""));
}",the-tcpdump-group/tcpdump/66df248b49095c261138b5a5e34d341a6bf9ac7f/print-ip6.c/vul/before/0.json,"void
ip6_print(netdissect_options *ndo, const u_char *bp, u_int length)
{
	register const struct ip6_hdr *ip6;
	register int advance;
	u_int len;
	const u_char *ipend;
	register const u_char *cp;
	register u_int payload_len;
	int nh;
	int fragmented = 0;
	u_int flow;

	ip6 = (const struct ip6_hdr *)bp;

	ND_TCHECK(*ip6);
	if (length < sizeof (struct ip6_hdr)) {
		ND_PRINT((ndo, ""truncated-ip6 %u"", length));
		return;
	}

        if (!ndo->ndo_eflag)
            ND_PRINT((ndo, ""IP6 ""));

	if (IP6_VERSION(ip6) != 6) {
          ND_PRINT((ndo,""version error: %u != 6"", IP6_VERSION(ip6)));
          return;
	}

	payload_len = EXTRACT_16BITS(&ip6->ip6_plen);
	len = payload_len + sizeof(struct ip6_hdr);
	if (length < len)
		ND_PRINT((ndo, ""truncated-ip6 - %u bytes missing!"",
			len - length));

        if (ndo->ndo_vflag) {
            flow = EXTRACT_32BITS(&ip6->ip6_flow);
            ND_PRINT((ndo, ""(""));
#if 0
            /* rfc1883 */
            if (flow & 0x0f000000)
		ND_PRINT((ndo, ""pri 0x%02x, "", (flow & 0x0f000000) >> 24));
            if (flow & 0x00ffffff)
		ND_PRINT((ndo, ""flowlabel 0x%06x, "", flow & 0x00ffffff));
#else
            /* RFC 2460 */
            if (flow & 0x0ff00000)
		ND_PRINT((ndo, ""class 0x%02x, "", (flow & 0x0ff00000) >> 20));
            if (flow & 0x000fffff)
		ND_PRINT((ndo, ""flowlabel 0x%05x, "", flow & 0x000fffff));
#endif

            ND_PRINT((ndo, ""hlim %u, next-header %s (%u) payload length: %u) "",
                         ip6->ip6_hlim,
                         tok2str(ipproto_values,""unknown"",ip6->ip6_nxt),
                         ip6->ip6_nxt,
                         payload_len));
        }

	/*
	 * Cut off the snapshot length to the end of the IP payload.
	 */
	ipend = bp + len;
	if (ipend < ndo->ndo_snapend)
		ndo->ndo_snapend = ipend;

	cp = (const u_char *)ip6;
	advance = sizeof(struct ip6_hdr);
	nh = ip6->ip6_nxt;
	while (cp < ndo->ndo_snapend && advance > 0) {
		if (len < (u_int)advance)
			goto trunc;
		cp += advance;
		len -= advance;

		if (cp == (const u_char *)(ip6 + 1) &&
		    nh != IPPROTO_TCP && nh != IPPROTO_UDP &&
		    nh != IPPROTO_DCCP && nh != IPPROTO_SCTP) {
			ND_PRINT((ndo, ""%s > %s: "", ip6addr_string(ndo, &ip6->ip6_src),
				     ip6addr_string(ndo, &ip6->ip6_dst)));
		}

		switch (nh) {
		case IPPROTO_HOPOPTS:
			advance = hbhopt_print(ndo, cp);
			if (advance < 0)
				return;
			nh = *cp;
			break;
		case IPPROTO_DSTOPTS:
			advance = dstopt_print(ndo, cp);
			if (advance < 0)
				return;
			nh = *cp;
			break;
		case IPPROTO_FRAGMENT:
			advance = frag6_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0 || ndo->ndo_snapend <= cp + advance)
				return;
			nh = *cp;
			fragmented = 1;
			break;

		case IPPROTO_MOBILITY_OLD:
		case IPPROTO_MOBILITY:
			/*
			 * XXX - we don't use ""advance""; RFC 3775 says that
			 * the next header field in a mobility header
			 * should be IPPROTO_NONE, but speaks of
			 * the possiblity of a future extension in
			 * which payload can be piggybacked atop a
			 * mobility header.
			 */
			advance = mobility_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0)
				return;
			nh = *cp;
			return;
		case IPPROTO_ROUTING:
			ND_TCHECK(*cp);
			advance = rt6_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0)
				return;
			nh = *cp;
			break;
		case IPPROTO_SCTP:
			sctp_print(ndo, cp, (const u_char *)ip6, len);
			return;
		case IPPROTO_DCCP:
			dccp_print(ndo, cp, (const u_char *)ip6, len);
			return;
		case IPPROTO_TCP:
			tcp_print(ndo, cp, len, (const u_char *)ip6, fragmented);
			return;
		case IPPROTO_UDP:
			udp_print(ndo, cp, len, (const u_char *)ip6, fragmented);
			return;
		case IPPROTO_ICMPV6:
			icmp6_print(ndo, cp, len, (const u_char *)ip6, fragmented);
			return;
		case IPPROTO_AH:
			advance = ah_print(ndo, cp);
			if (advance < 0)
				return;
			nh = *cp;
			break;
		case IPPROTO_ESP:
		    {
			int enh, padlen;
			advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);
			if (advance < 0)
				return;
			nh = enh & 0xff;
			len -= padlen;
			break;
		    }
		case IPPROTO_IPCOMP:
		    {
			ipcomp_print(ndo, cp);
			/*
			 * Either this has decompressed the payload and
			 * printed it, in which case there's nothing more
			 * to do, or it hasn't, in which case there's
			 * nothing more to do.
			 */
			advance = -1;
			break;
		    }

		case IPPROTO_PIM:
			pim_print(ndo, cp, len, (const u_char *)ip6);
			return;

		case IPPROTO_OSPF:
			ospf6_print(ndo, cp, len);
			return;

		case IPPROTO_IPV6:
			ip6_print(ndo, cp, len);
			return;

		case IPPROTO_IPV4:
		        ip_print(ndo, cp, len);
			return;

                case IPPROTO_PGM:
                        pgm_print(ndo, cp, len, (const u_char *)ip6);
                        return;

		case IPPROTO_GRE:
			gre_print(ndo, cp, len);
			return;

		case IPPROTO_RSVP:
			rsvp_print(ndo, cp, len);
			return;

		case IPPROTO_NONE:
			ND_PRINT((ndo, ""no next header""));
			return;

		default:
			ND_PRINT((ndo, ""ip-proto-%d %d"", nh, len));
			return;
		}
	}

	return;
trunc:
	ND_PRINT((ndo, ""[|ip6]""));
}","void
ip6_print(netdissect_options *VAR_0, const u_char *VAR_1, u_int VAR_2)
{
	register const struct ip6_hdr *VAR_3;
	register int VAR_4;
	u_int VAR_5;
	const u_char *VAR_6;
	register const u_char *VAR_7;
	register u_int VAR_8;
	int VAR_9;
	int VAR_10 = 0;
	u_int VAR_11;

	VAR_3 = (const struct ip6_hdr *)VAR_1;

	ND_TCHECK(*VAR_3);
	if (VAR_2 < sizeof (struct ip6_hdr)) {
		ND_PRINT((VAR_0, ""truncated-ip6 %u"", VAR_2));
		return;
	}

        if (!VAR_0->ndo_eflag)
            ND_PRINT((VAR_0, ""IP6 ""));

	if (IP6_VERSION(VAR_3) != 6) {
          ND_PRINT((VAR_0,""version error: %u != 6"", IP6_VERSION(VAR_3)));
          return;
	}

	VAR_8 = EXTRACT_16BITS(&VAR_3->ip6_plen);
	VAR_5 = VAR_8 + sizeof(struct ip6_hdr);
	if (VAR_2 < VAR_5)
		ND_PRINT((VAR_0, ""truncated-ip6 - %u bytes missing!"",
			VAR_5 - VAR_2));

        if (VAR_0->ndo_vflag) {
            VAR_11 = EXTRACT_32BITS(&VAR_3->ip6_flow);
            ND_PRINT((VAR_0, ""(""));
#if 0
            /* COMMENT_0 */
            if (VAR_11 & 0x0f000000)
		ND_PRINT((VAR_0, ""pri 0x%02x, "", (VAR_11 & 0x0f000000) >> 24));
            if (VAR_11 & 0x00ffffff)
		ND_PRINT((VAR_0, ""flowlabel 0x%06x, "", VAR_11 & 0x00ffffff));
#else
            /* COMMENT_1 */
            if (VAR_11 & 0x0ff00000)
		ND_PRINT((VAR_0, ""class 0x%02x, "", (VAR_11 & 0x0ff00000) >> 20));
            if (VAR_11 & 0x000fffff)
		ND_PRINT((VAR_0, ""flowlabel 0x%05x, "", VAR_11 & 0x000fffff));
#endif

            ND_PRINT((VAR_0, ""hlim %u, next-header %s (%u) payload length: %u) "",
                         VAR_3->ip6_hlim,
                         tok2str(VAR_12,""unknown"",VAR_3->ip6_nxt),
                         VAR_3->ip6_nxt,
                         VAR_8));
        }

	/* COMMENT_2 */
                                                             
    
	VAR_6 = VAR_1 + VAR_5;
	if (VAR_6 < VAR_0->ndo_snapend)
		VAR_0->ndo_snapend = VAR_6;

	VAR_7 = (const u_char *)VAR_3;
	VAR_4 = sizeof(struct ip6_hdr);
	VAR_9 = VAR_3->ip6_nxt;
	while (VAR_7 < VAR_0->ndo_snapend && VAR_4 > 0) {
		if (VAR_5 < (u_int)VAR_4)
			goto trunc;
		VAR_7 += VAR_4;
		VAR_5 -= VAR_4;

		if (VAR_7 == (const u_char *)(VAR_3 + 1) &&
		    VAR_9 != VAR_13 && VAR_9 != VAR_14 &&
		    VAR_9 != VAR_15 && VAR_9 != VAR_16) {
			ND_PRINT((VAR_0, ""%s > %s: "", ip6addr_string(VAR_0, &VAR_3->ip6_src),
				     ip6addr_string(VAR_0, &VAR_3->ip6_dst)));
		}

		switch (VAR_9) {
		case VAR_17:
			VAR_4 = hbhopt_print(VAR_0, VAR_7);
			if (VAR_4 < 0)
				return;
			VAR_9 = *VAR_7;
			break;
		case VAR_18:
			VAR_4 = dstopt_print(VAR_0, VAR_7);
			if (VAR_4 < 0)
				return;
			VAR_9 = *VAR_7;
			break;
		case VAR_19:
			VAR_4 = frag6_print(VAR_0, VAR_7, (const u_char *)VAR_3);
			if (VAR_4 < 0 || VAR_0->ndo_snapend <= VAR_7 + VAR_4)
				return;
			VAR_9 = *VAR_7;
			VAR_10 = 1;
			break;

		case VAR_20:
		case VAR_21:
			/* COMMENT_5 */
                                                      
                                                
                                           
                                             
                                             
                      
      
			VAR_4 = mobility_print(VAR_0, VAR_7, (const u_char *)VAR_3);
			if (VAR_4 < 0)
				return;
			VAR_9 = *VAR_7;
			return;
		case VAR_22:
			ND_TCHECK(*VAR_7);
			VAR_4 = rt6_print(VAR_0, VAR_7, (const u_char *)VAR_3);
			if (VAR_4 < 0)
				return;
			VAR_9 = *VAR_7;
			break;
		case VAR_16:
			sctp_print(VAR_0, VAR_7, (const u_char *)VAR_3, VAR_5);
			return;
		case VAR_15:
			dccp_print(VAR_0, VAR_7, (const u_char *)VAR_3, VAR_5);
			return;
		case VAR_13:
			tcp_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, VAR_10);
			return;
		case VAR_14:
			udp_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, VAR_10);
			return;
		case VAR_23:
			icmp6_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, VAR_10);
			return;
		case VAR_24:
			VAR_4 = ah_print(VAR_0, VAR_7);
			if (VAR_4 < 0)
				return;
			VAR_9 = *VAR_7;
			break;
		case VAR_25:
		    {
			int VAR_26, VAR_27;
			VAR_4 = esp_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3, &VAR_26, &VAR_27);
			if (VAR_4 < 0)
				return;
			VAR_9 = VAR_26 & 0xff;
			VAR_5 -= VAR_27;
			break;
		    }
		case VAR_28:
		    {
			ipcomp_print(VAR_0, VAR_7);
			/* COMMENT_13 */
                                                  
                                                    
                                                
                         
      
			VAR_4 = -1;
			break;
		    }

		case VAR_29:
			pim_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3);
			return;

		case VAR_30:
			ospf6_print(VAR_0, VAR_7, VAR_5);
			return;

		case VAR_31:
			ip6_print(VAR_0, VAR_7, VAR_5);
			return;

		case VAR_32:
		        ip_print(VAR_0, VAR_7, VAR_5);
			return;

                case VAR_33:
                        pgm_print(VAR_0, VAR_7, VAR_5, (const u_char *)VAR_3);
                        return;

		case VAR_34:
			gre_print(VAR_0, VAR_7, VAR_5);
			return;

		case VAR_35:
			rsvp_print(VAR_0, VAR_7, VAR_5);
			return;

		case VAR_36:
			ND_PRINT((VAR_0, ""no next header""));
			return;

		default:
			ND_PRINT((VAR_0, ""ip-proto-%d %d"", VAR_9, VAR_5));
			return;
		}
	}

	return;
trunc:
	ND_PRINT((VAR_0, ""[|ip6]""));
}",the-tcpdump-group/tcpdump/66df248b49095c261138b5a5e34d341a6bf9ac7f/print-ip6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -68,6 +68,8 @@
 	advance = sizeof(struct ip6_hdr);
 	nh = ip6->ip6_nxt;
 	while (cp < ndo->ndo_snapend && advance > 0) {
+		if (len < (u_int)advance)
+			goto trunc;
 		cp += advance;
 		len -= advance;
 
@@ -110,10 +112,15 @@
 			 * mobility header.
 			 */
 			advance = mobility_print(ndo, cp, (const u_char *)ip6);
+			if (advance < 0)
+				return;
 			nh = *cp;
 			return;
 		case IPPROTO_ROUTING:
+			ND_TCHECK(*cp);
 			advance = rt6_print(ndo, cp, (const u_char *)ip6);
+			if (advance < 0)
+				return;
 			nh = *cp;
 			break;
 		case IPPROTO_SCTP:
@@ -133,12 +140,16 @@
 			return;
 		case IPPROTO_AH:
 			advance = ah_print(ndo, cp);
+			if (advance < 0)
+				return;
 			nh = *cp;
 			break;
 		case IPPROTO_ESP:
 		    {
 			int enh, padlen;
 			advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);
+			if (advance < 0)
+				return;
 			nh = enh & 0xff;
 			len -= padlen;
 			break;","{'deleted_lines': [], 'added_lines': ['\t\tif (len < (u_int)advance)', '\t\t\tgoto trunc;', '\t\t\tif (advance < 0)', '\t\t\t\treturn;', '\t\t\tND_TCHECK(*cp);', '\t\t\tif (advance < 0)', '\t\t\t\treturn;', '\t\t\tif (advance < 0)', '\t\t\t\treturn;', '\t\t\tif (advance < 0)', '\t\t\t\treturn;']}",True,The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print().,9.8,CRITICAL,3,valid,2017-02-04T11:13:18Z,1
CVE-2017-8068,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"pegasus: Use heap buffers for all register access

Allocating USB buffers on the stack is not portable, and no longer
works on x86_64 (with VMAP_STACK enabled as per default).

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
References: https://bugs.debian.org/852556
Reported-by: Lisandro Damin Nicanor Prez Meyer <lisandro@debian.org>
Tested-by: Lisandro Damin Nicanor Prez Meyer <lisandro@debian.org>
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>",5593523f968bc86d42a035c6df47d5e0979b5ace,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,drivers/net/usb/pegasus.c,set_register,"static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
{
int ret;
ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
indx, &data, 1, 1000);
if (ret < 0)
netif_dbg(pegasus, drv, pegasus->net,
""%s returned %d\n"", __func__, ret);
return ret;
}","static int set_register(pegasus_t *VAR_0, __u16 VAR_1, __u8 VAR_2)
{
int VAR_3;
VAR_3 = usb_control_msg(VAR_0->usb, usb_sndctrlpipe(VAR_0->usb, 0),
VAR_4, VAR_5, VAR_2,
VAR_1, &VAR_2, 1, 1000);
if (VAR_3 < 0)
netif_dbg(VAR_0, VAR_6, VAR_0->net,
""%s returned %d\n"", VAR_7, VAR_3);
return VAR_3;
}",torvalds/linux/5593523f968bc86d42a035c6df47d5e0979b5ace/pegasus.c/vul/before/2.json,"static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
{
	u8 *buf;
	int ret;

	buf = kmemdup(&data, 1, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, buf, 1, 1000);
	if (ret < 0)
		netif_dbg(pegasus, drv, pegasus->net,
			  ""%s returned %d\n"", __func__, ret);
	kfree(buf);
	return ret;
}","static int set_register(pegasus_t *VAR_0, __u16 VAR_1, __u8 VAR_2)
{
	u8 *VAR_3;
	int VAR_4;

	VAR_3 = kmemdup(&VAR_2, 1, VAR_5);
	if (!VAR_3)
		return -VAR_6;

	VAR_4 = usb_control_msg(VAR_0->usb, usb_sndctrlpipe(VAR_0->usb, 0),
			      VAR_7, VAR_8, VAR_2,
			      VAR_1, VAR_3, 1, 1000);
	if (VAR_4 < 0)
		netif_dbg(VAR_0, VAR_9, VAR_0->net,
			  ""%s returned %d\n"", VAR_10, VAR_4);
	kfree(VAR_3);
	return VAR_4;
}",torvalds/linux/5593523f968bc86d42a035c6df47d5e0979b5ace/pegasus.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,12 +1,18 @@
 static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
+	u8 *buf;
 	int ret;
+
+	buf = kmemdup(&data, 1, GFP_NOIO);
+	if (!buf)
+		return -ENOMEM;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
-			      indx, &data, 1, 1000);
+			      indx, buf, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
+	kfree(buf);
 	return ret;
 }","{'deleted_lines': ['\t\t\t      indx, &data, 1, 1000);'], 'added_lines': ['\tu8 *buf;', '', '\tbuf = kmemdup(&data, 1, GFP_NOIO);', '\tif (!buf)', '\t\treturn -ENOMEM;', '\t\t\t      indx, buf, 1, 1000);', '\tkfree(buf);']}",True,"drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",7.8,HIGH,2,valid,2017-02-04T16:56:03Z,1
CVE-2017-8068,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"pegasus: Use heap buffers for all register access

Allocating USB buffers on the stack is not portable, and no longer
works on x86_64 (with VMAP_STACK enabled as per default).

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
References: https://bugs.debian.org/852556
Reported-by: Lisandro Damin Nicanor Prez Meyer <lisandro@debian.org>
Tested-by: Lisandro Damin Nicanor Prez Meyer <lisandro@debian.org>
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>",5593523f968bc86d42a035c6df47d5e0979b5ace,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,drivers/net/usb/pegasus.c,get_registers,"static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
{
int ret;
ret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),
PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
indx, data, size, 1000);
if (ret < 0)
netif_dbg(pegasus, drv, pegasus->net,
""%s returned %d\n"", __func__, ret);
return ret;
}","static int get_registers(pegasus_t *VAR_0, __u16 VAR_1, __u16 VAR_2, void *VAR_3)
{
int VAR_4;
VAR_4 = usb_control_msg(VAR_0->usb, usb_rcvctrlpipe(VAR_0->usb, 0),
VAR_5, VAR_6, 0,
VAR_1, VAR_3, VAR_2, 1000);
if (VAR_4 < 0)
netif_dbg(VAR_0, VAR_7, VAR_0->net,
""%s returned %d\n"", VAR_8, VAR_4);
return VAR_4;
}",torvalds/linux/5593523f968bc86d42a035c6df47d5e0979b5ace/pegasus.c/vul/before/1.json,"static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
{
	u8 *buf;
	int ret;

	buf = kmalloc(size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

	ret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),
			      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
			      indx, buf, size, 1000);
	if (ret < 0)
		netif_dbg(pegasus, drv, pegasus->net,
			  ""%s returned %d\n"", __func__, ret);
	else if (ret <= size)
		memcpy(data, buf, ret);
	kfree(buf);
	return ret;
}","static int get_registers(pegasus_t *VAR_0, __u16 VAR_1, __u16 VAR_2, void *VAR_3)
{
	u8 *VAR_4;
	int VAR_5;

	VAR_4 = kmalloc(VAR_2, VAR_6);
	if (!VAR_4)
		return -VAR_7;

	VAR_5 = usb_control_msg(VAR_0->usb, usb_rcvctrlpipe(VAR_0->usb, 0),
			      VAR_8, VAR_9, 0,
			      VAR_1, VAR_4, VAR_2, 1000);
	if (VAR_5 < 0)
		netif_dbg(VAR_0, VAR_10, VAR_0->net,
			  ""%s returned %d\n"", VAR_11, VAR_5);
	else if (VAR_5 <= VAR_2)
		memcpy(VAR_3, VAR_4, VAR_5);
	kfree(VAR_4);
	return VAR_5;
}",torvalds/linux/5593523f968bc86d42a035c6df47d5e0979b5ace/pegasus.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,12 +1,20 @@
 static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
 {
+	u8 *buf;
 	int ret;
+
+	buf = kmalloc(size, GFP_NOIO);
+	if (!buf)
+		return -ENOMEM;
 
 	ret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
-			      indx, data, size, 1000);
+			      indx, buf, size, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
+	else if (ret <= size)
+		memcpy(data, buf, ret);
+	kfree(buf);
 	return ret;
 }","{'deleted_lines': ['\t\t\t      indx, data, size, 1000);'], 'added_lines': ['\tu8 *buf;', '', '\tbuf = kmalloc(size, GFP_NOIO);', '\tif (!buf)', '\t\treturn -ENOMEM;', '\t\t\t      indx, buf, size, 1000);', '\telse if (ret <= size)', '\t\tmemcpy(data, buf, ret);', '\tkfree(buf);']}",True,"drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",7.8,HIGH,2,valid,2017-02-04T16:56:03Z,1
CVE-2017-8068,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"pegasus: Use heap buffers for all register access

Allocating USB buffers on the stack is not portable, and no longer
works on x86_64 (with VMAP_STACK enabled as per default).

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
References: https://bugs.debian.org/852556
Reported-by: Lisandro Damin Nicanor Prez Meyer <lisandro@debian.org>
Tested-by: Lisandro Damin Nicanor Prez Meyer <lisandro@debian.org>
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>",5593523f968bc86d42a035c6df47d5e0979b5ace,https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace,drivers/net/usb/pegasus.c,set_registers,"static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
{
int ret;
ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,
indx, data, size, 100);
if (ret < 0)
netif_dbg(pegasus, drv, pegasus->net,
""%s returned %d\n"", __func__, ret);
return ret;
}","static int set_registers(pegasus_t *VAR_0, __u16 VAR_1, __u16 VAR_2, void *VAR_3)
{
int VAR_4;
VAR_4 = usb_control_msg(VAR_0->usb, usb_sndctrlpipe(VAR_0->usb, 0),
VAR_5, VAR_6, 0,
VAR_1, VAR_3, VAR_2, 100);
if (VAR_4 < 0)
netif_dbg(VAR_0, VAR_7, VAR_0->net,
""%s returned %d\n"", VAR_8, VAR_4);
return VAR_4;
}",torvalds/linux/5593523f968bc86d42a035c6df47d5e0979b5ace/pegasus.c/vul/before/0.json,"static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,
			 const void *data)
{
	u8 *buf;
	int ret;

	buf = kmemdup(data, size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
			      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,
			      indx, buf, size, 100);
	if (ret < 0)
		netif_dbg(pegasus, drv, pegasus->net,
			  ""%s returned %d\n"", __func__, ret);
	kfree(buf);
	return ret;
}","static int set_registers(pegasus_t *VAR_0, __u16 VAR_1, __u16 VAR_2,
			 const void *VAR_3)
{
	u8 *VAR_4;
	int VAR_5;

	VAR_4 = kmemdup(VAR_3, VAR_2, VAR_6);
	if (!VAR_4)
		return -VAR_7;

	VAR_5 = usb_control_msg(VAR_0->usb, usb_sndctrlpipe(VAR_0->usb, 0),
			      VAR_8, VAR_9, 0,
			      VAR_1, VAR_4, VAR_2, 100);
	if (VAR_5 < 0)
		netif_dbg(VAR_0, VAR_10, VAR_0->net,
			  ""%s returned %d\n"", VAR_11, VAR_5);
	kfree(VAR_4);
	return VAR_5;
}",torvalds/linux/5593523f968bc86d42a035c6df47d5e0979b5ace/pegasus.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,12 +1,19 @@
-static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
+static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,
+			 const void *data)
 {
+	u8 *buf;
 	int ret;
+
+	buf = kmemdup(data, size, GFP_NOIO);
+	if (!buf)
+		return -ENOMEM;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,
-			      indx, data, size, 100);
+			      indx, buf, size, 100);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
+	kfree(buf);
 	return ret;
 }","{'deleted_lines': ['static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)', '\t\t\t      indx, data, size, 100);'], 'added_lines': ['static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,', '\t\t\t const void *data)', '\tu8 *buf;', '', '\tbuf = kmemdup(data, size, GFP_NOIO);', '\tif (!buf)', '\t\treturn -ENOMEM;', '\t\t\t      indx, buf, size, 100);', '\tkfree(buf);']}",True,"drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",7.8,HIGH,2,valid,2017-02-04T16:56:03Z,1
CVE-2017-8069,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"rtl8150: Use heap buffers for all register access

Allocating USB buffers on the stack is not portable, and no longer
works on x86_64 (with VMAP_STACK enabled as per default).

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>",7926aff5c57b577ab0f43364ff0c59d968f6a414,https://github.com/torvalds/linux/commit/7926aff5c57b577ab0f43364ff0c59d968f6a414,drivers/net/usb/rtl8150.c,get_registers,"static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
{
return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
indx, 0, data, size, 500);
}","static int get_registers(rtl8150_t * VAR_0, u16 VAR_1, u16 VAR_2, void *VAR_3)
{
return usb_control_msg(VAR_0->udev, usb_rcvctrlpipe(VAR_0->udev, 0),
VAR_4, VAR_5,
VAR_1, 0, VAR_3, VAR_2, 500);
}",torvalds/linux/7926aff5c57b577ab0f43364ff0c59d968f6a414/rtl8150.c/vul/before/1.json,"static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
{
	void *buf;
	int ret;

	buf = kmalloc(size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

	ret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
			      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
			      indx, 0, buf, size, 500);
	if (ret > 0 && ret <= size)
		memcpy(data, buf, ret);
	kfree(buf);
	return ret;
}","static int get_registers(rtl8150_t * VAR_0, u16 VAR_1, u16 VAR_2, void *VAR_3)
{
	void *VAR_4;
	int VAR_5;

	VAR_4 = kmalloc(VAR_2, VAR_6);
	if (!VAR_4)
		return -VAR_7;

	VAR_5 = usb_control_msg(VAR_0->udev, usb_rcvctrlpipe(VAR_0->udev, 0),
			      VAR_8, VAR_9,
			      VAR_1, 0, VAR_4, VAR_2, 500);
	if (VAR_5 > 0 && VAR_5 <= VAR_2)
		memcpy(VAR_3, VAR_4, VAR_5);
	kfree(VAR_4);
	return VAR_5;
}",torvalds/linux/7926aff5c57b577ab0f43364ff0c59d968f6a414/rtl8150.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,17 @@
 static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
-	return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
-			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
-			       indx, 0, data, size, 500);
+	void *buf;
+	int ret;
+
+	buf = kmalloc(size, GFP_NOIO);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
+			      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
+			      indx, 0, buf, size, 500);
+	if (ret > 0 && ret <= size)
+		memcpy(data, buf, ret);
+	kfree(buf);
+	return ret;
 }","{'deleted_lines': ['\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),', '\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,', '\t\t\t       indx, 0, data, size, 500);'], 'added_lines': ['\tvoid *buf;', '\tint ret;', '', '\tbuf = kmalloc(size, GFP_NOIO);', '\tif (!buf)', '\t\treturn -ENOMEM;', '', '\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),', '\t\t\t      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,', '\t\t\t      indx, 0, buf, size, 500);', '\tif (ret > 0 && ret <= size)', '\t\tmemcpy(data, buf, ret);', '\tkfree(buf);', '\treturn ret;']}",True,"drivers/net/usb/rtl8150.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",7.8,HIGH,2,valid,2017-02-04T16:56:32Z,1
CVE-2017-8069,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"rtl8150: Use heap buffers for all register access

Allocating USB buffers on the stack is not portable, and no longer
works on x86_64 (with VMAP_STACK enabled as per default).

Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
Signed-off-by: David S. Miller <davem@davemloft.net>",7926aff5c57b577ab0f43364ff0c59d968f6a414,https://github.com/torvalds/linux/commit/7926aff5c57b577ab0f43364ff0c59d968f6a414,drivers/net/usb/rtl8150.c,set_registers,"static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
{
return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
indx, 0, data, size, 500);
}","static int set_registers(rtl8150_t * VAR_0, u16 VAR_1, u16 VAR_2, void *VAR_3)
{
return usb_control_msg(VAR_0->udev, usb_sndctrlpipe(VAR_0->udev, 0),
VAR_4, VAR_5,
VAR_1, 0, VAR_3, VAR_2, 500);
}",torvalds/linux/7926aff5c57b577ab0f43364ff0c59d968f6a414/rtl8150.c/vul/before/0.json,"static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)
{
	void *buf;
	int ret;

	buf = kmemdup(data, size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

	ret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
			      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
			      indx, 0, buf, size, 500);
	kfree(buf);
	return ret;
}","static int set_registers(rtl8150_t * VAR_0, u16 VAR_1, u16 VAR_2, const void *VAR_3)
{
	void *VAR_4;
	int VAR_5;

	VAR_4 = kmemdup(VAR_3, VAR_2, VAR_6);
	if (!VAR_4)
		return -VAR_7;

	VAR_5 = usb_control_msg(VAR_0->udev, usb_sndctrlpipe(VAR_0->udev, 0),
			      VAR_8, VAR_9,
			      VAR_1, 0, VAR_4, VAR_2, 500);
	kfree(VAR_4);
	return VAR_5;
}",torvalds/linux/7926aff5c57b577ab0f43364ff0c59d968f6a414/rtl8150.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,15 @@
-static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
+static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)
 {
-	return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
-			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
-			       indx, 0, data, size, 500);
+	void *buf;
+	int ret;
+
+	buf = kmemdup(data, size, GFP_NOIO);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
+			      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
+			      indx, 0, buf, size, 500);
+	kfree(buf);
+	return ret;
 }","{'deleted_lines': ['static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)', '\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),', '\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,', '\t\t\t       indx, 0, data, size, 500);'], 'added_lines': ['static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)', '\tvoid *buf;', '\tint ret;', '', '\tbuf = kmemdup(data, size, GFP_NOIO);', '\tif (!buf)', '\t\treturn -ENOMEM;', '', '\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),', '\t\t\t      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,', '\t\t\t      indx, 0, buf, size, 500);', '\tkfree(buf);', '\treturn ret;']}",True,"drivers/net/usb/rtl8150.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",7.8,HIGH,2,valid,2017-02-04T16:56:32Z,1
CVE-2017-12987,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12987/IEEE 802.11: Fix processing of TIM IE.

The arguments to memcpy() were completely wrong.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by Brian 'geeknik' Carpenter.",99798bd9a41bd3d03fdc1e949810a38967f20ed3,https://github.com/the-tcpdump-group/tcpdump/commit/99798bd9a41bd3d03fdc1e949810a38967f20ed3,print-802_11.c,parse_elements,"static int
parse_elements(netdissect_options *ndo,
struct mgmt_body_t *pbody, const u_char *p, int offset,
u_int length)
{
u_int elementlen;
struct ssid_t ssid;
struct challenge_t challenge;
struct rates_t rates;
struct ds_t ds;
struct cf_t cf;
struct tim_t tim;
pbody->challenge_present = 0;
pbody->ssid_present = 0;
pbody->rates_present = 0;
pbody->ds_present = 0;
pbody->cf_present = 0;
pbody->tim_present = 0;
while (length != 0) {
if (!ND_TTEST2(*(p + offset), 2))
return 0;
if (length < 2)
return 0;
elementlen = *(p + offset + 1);
if (!ND_TTEST2(*(p + offset + 2), elementlen))
return 0;
if (length < elementlen + 2)
return 0;
switch (*(p + offset)) {
case E_SSID:
memcpy(&ssid, p + offset, 2);
offset += 2;
length -= 2;
if (ssid.length != 0) {
if (ssid.length > sizeof(ssid.ssid) - 1)
return 0;
if (!ND_TTEST2(*(p + offset), ssid.length))
return 0;
if (length < ssid.length)
return 0;
memcpy(&ssid.ssid, p + offset, ssid.length);
offset += ssid.length;
length -= ssid.length;
}
ssid.ssid[ssid.length] = '\0';
if (!pbody->ssid_present) {
pbody->ssid = ssid;
pbody->ssid_present = 1;
}
break;
case E_CHALLENGE:
memcpy(&challenge, p + offset, 2);
offset += 2;
length -= 2;
if (challenge.length != 0) {
if (challenge.length >
sizeof(challenge.text) - 1)
return 0;
if (!ND_TTEST2(*(p + offset), challenge.length))
return 0;
if (length < challenge.length)
return 0;
memcpy(&challenge.text, p + offset,
challenge.length);
offset += challenge.length;
length -= challenge.length;
}
challenge.text[challenge.length] = '\0';
if (!pbody->challenge_present) {
pbody->challenge = challenge;
pbody->challenge_present = 1;
}
break;
case E_RATES:
memcpy(&rates, p + offset, 2);
offset += 2;
length -= 2;
if (rates.length != 0) {
if (rates.length > sizeof rates.rate)
return 0;
if (!ND_TTEST2(*(p + offset), rates.length))
return 0;
if (length < rates.length)
return 0;
memcpy(&rates.rate, p + offset, rates.length);
offset += rates.length;
length -= rates.length;
}
if (!pbody->rates_present && rates.length != 0) {
pbody->rates = rates;
pbody->rates_present = 1;
}
break;
case E_DS:
memcpy(&ds, p + offset, 2);
offset += 2;
length -= 2;
if (ds.length != 1) {
offset += ds.length;
length -= ds.length;
break;
}
ds.channel = *(p + offset);
offset += 1;
length -= 1;
if (!pbody->ds_present) {
pbody->ds = ds;
pbody->ds_present = 1;
}
break;
case E_CF:
memcpy(&cf, p + offset, 2);
offset += 2;
length -= 2;
if (cf.length != 6) {
offset += cf.length;
length -= cf.length;
break;
}
memcpy(&cf.count, p + offset, 6);
offset += 6;
length -= 6;
if (!pbody->cf_present) {
pbody->cf = cf;
pbody->cf_present = 1;
}
break;
case E_TIM:
memcpy(&tim, p + offset, 2);
offset += 2;
length -= 2;
if (tim.length <= 3) {
offset += tim.length;
length -= tim.length;
break;
}
if (tim.length - 3 > (int)sizeof tim.bitmap)
return 0;
memcpy(&tim.count, p + offset, 3);
offset += 3;
length -= 3;
memcpy(tim.bitmap, p + (tim.length - 3),
(tim.length - 3));
offset += tim.length - 3;
length -= tim.length - 3;
if (!pbody->tim_present) {
pbody->tim = tim;
pbody->tim_present = 1;
}
break;
default:
#if 0
ND_PRINT((ndo, ""(1) unhandled element_id (%d)  "",
*(p + offset)));
#endif
offset += 2 + elementlen;
length -= 2 + elementlen;
break;
}
}
return 1;
}","static int
parse_elements(netdissect_options *VAR_0,
struct mgmt_body_t *VAR_1, const u_char *VAR_2, int VAR_3,
u_int VAR_4)
{
u_int VAR_5;
struct ssid_t VAR_6;
struct challenge_t VAR_7;
struct rates_t VAR_8;
struct ds_t VAR_9;
struct cf_t VAR_10;
struct tim_t VAR_11;
VAR_1->challenge_present = 0;
VAR_1->ssid_present = 0;
VAR_1->rates_present = 0;
VAR_1->ds_present = 0;
VAR_1->cf_present = 0;
VAR_1->tim_present = 0;
while (VAR_4 != 0) {
if (!ND_TTEST2(*(VAR_2 + VAR_3), 2))
return 0;
if (VAR_4 < 2)
return 0;
VAR_5 = *(VAR_2 + VAR_3 + 1);
if (!ND_TTEST2(*(VAR_2 + VAR_3 + 2), VAR_5))
return 0;
if (VAR_4 < VAR_5 + 2)
return 0;
switch (*(VAR_2 + VAR_3)) {
case VAR_12:
memcpy(&VAR_6, VAR_2 + VAR_3, 2);
VAR_3 += 2;
VAR_4 -= 2;
if (VAR_6.length != 0) {
if (VAR_6.length > sizeof(VAR_6.ssid) - 1)
return 0;
if (!ND_TTEST2(*(VAR_2 + VAR_3), VAR_6.length))
return 0;
if (VAR_4 < VAR_6.length)
return 0;
memcpy(&VAR_6.ssid, VAR_2 + VAR_3, VAR_6.length);
VAR_3 += VAR_6.length;
VAR_4 -= VAR_6.length;
}
VAR_6.ssid[VAR_6.length] = '\0';
if (!VAR_1->ssid_present) {
VAR_1->ssid = VAR_6;
VAR_1->ssid_present = 1;
}
break;
case VAR_13:
memcpy(&VAR_7, VAR_2 + VAR_3, 2);
VAR_3 += 2;
VAR_4 -= 2;
if (VAR_7.length != 0) {
if (VAR_7.length >
sizeof(VAR_7.text) - 1)
return 0;
if (!ND_TTEST2(*(VAR_2 + VAR_3), VAR_7.length))
return 0;
if (VAR_4 < VAR_7.length)
return 0;
memcpy(&VAR_7.text, VAR_2 + VAR_3,
VAR_7.length);
VAR_3 += VAR_7.length;
VAR_4 -= VAR_7.length;
}
VAR_7.text[VAR_7.length] = '\0';
if (!VAR_1->challenge_present) {
VAR_1->challenge = VAR_7;
VAR_1->challenge_present = 1;
}
break;
case VAR_14:
memcpy(&VAR_8, VAR_2 + VAR_3, 2);
VAR_3 += 2;
VAR_4 -= 2;
if (VAR_8.length != 0) {
if (VAR_8.length > sizeof VAR_8.rate)
return 0;
if (!ND_TTEST2(*(VAR_2 + VAR_3), VAR_8.length))
return 0;
if (VAR_4 < VAR_8.length)
return 0;
memcpy(&VAR_8.rate, VAR_2 + VAR_3, VAR_8.length);
VAR_3 += VAR_8.length;
VAR_4 -= VAR_8.length;
}
if (!VAR_1->rates_present && VAR_8.length != 0) {
VAR_1->rates = VAR_8;
VAR_1->rates_present = 1;
}
break;
case VAR_15:
memcpy(&VAR_9, VAR_2 + VAR_3, 2);
VAR_3 += 2;
VAR_4 -= 2;
if (VAR_9.length != 1) {
VAR_3 += VAR_9.length;
VAR_4 -= VAR_9.length;
break;
}
VAR_9.channel = *(VAR_2 + VAR_3);
VAR_3 += 1;
VAR_4 -= 1;
if (!VAR_1->ds_present) {
VAR_1->ds = VAR_9;
VAR_1->ds_present = 1;
}
break;
case VAR_16:
memcpy(&VAR_10, VAR_2 + VAR_3, 2);
VAR_3 += 2;
VAR_4 -= 2;
if (VAR_10.length != 6) {
VAR_3 += VAR_10.length;
VAR_4 -= VAR_10.length;
break;
}
memcpy(&VAR_10.count, VAR_2 + VAR_3, 6);
VAR_3 += 6;
VAR_4 -= 6;
if (!VAR_1->cf_present) {
VAR_1->cf = VAR_10;
VAR_1->cf_present = 1;
}
break;
case VAR_17:
memcpy(&VAR_11, VAR_2 + VAR_3, 2);
VAR_3 += 2;
VAR_4 -= 2;
if (VAR_11.length <= 3) {
VAR_3 += VAR_11.length;
VAR_4 -= VAR_11.length;
break;
}
if (VAR_11.length - 3 > (int)sizeof VAR_11.bitmap)
return 0;
memcpy(&VAR_11.count, VAR_2 + VAR_3, 3);
VAR_3 += 3;
VAR_4 -= 3;
memcpy(VAR_11.bitmap, VAR_2 + (VAR_11.length - 3),
(VAR_11.length - 3));
VAR_3 += VAR_11.length - 3;
VAR_4 -= VAR_11.length - 3;
if (!VAR_1->tim_present) {
VAR_1->tim = VAR_11;
VAR_1->tim_present = 1;
}
break;
default:
#if 0
ND_PRINT((VAR_0, ""(1) unhandled element_id (%d)  "",
*(VAR_2 + VAR_3)));
#endif
VAR_3 += 2 + VAR_5;
VAR_4 -= 2 + VAR_5;
break;
}
}
return 1;
}",the-tcpdump-group/tcpdump/99798bd9a41bd3d03fdc1e949810a38967f20ed3/print-802_11.c/vul/before/0.json,"static int
parse_elements(netdissect_options *ndo,
               struct mgmt_body_t *pbody, const u_char *p, int offset,
               u_int length)
{
	u_int elementlen;
	struct ssid_t ssid;
	struct challenge_t challenge;
	struct rates_t rates;
	struct ds_t ds;
	struct cf_t cf;
	struct tim_t tim;

	/*
	 * We haven't seen any elements yet.
	 */
	pbody->challenge_present = 0;
	pbody->ssid_present = 0;
	pbody->rates_present = 0;
	pbody->ds_present = 0;
	pbody->cf_present = 0;
	pbody->tim_present = 0;

	while (length != 0) {
		/* Make sure we at least have the element ID and length. */
		if (!ND_TTEST2(*(p + offset), 2))
			return 0;
		if (length < 2)
			return 0;
		elementlen = *(p + offset + 1);

		/* Make sure we have the entire element. */
		if (!ND_TTEST2(*(p + offset + 2), elementlen))
			return 0;
		if (length < elementlen + 2)
			return 0;

		switch (*(p + offset)) {
		case E_SSID:
			memcpy(&ssid, p + offset, 2);
			offset += 2;
			length -= 2;
			if (ssid.length != 0) {
				if (ssid.length > sizeof(ssid.ssid) - 1)
					return 0;
				if (!ND_TTEST2(*(p + offset), ssid.length))
					return 0;
				if (length < ssid.length)
					return 0;
				memcpy(&ssid.ssid, p + offset, ssid.length);
				offset += ssid.length;
				length -= ssid.length;
			}
			ssid.ssid[ssid.length] = '\0';
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen an SSID IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->ssid_present) {
				pbody->ssid = ssid;
				pbody->ssid_present = 1;
			}
			break;
		case E_CHALLENGE:
			memcpy(&challenge, p + offset, 2);
			offset += 2;
			length -= 2;
			if (challenge.length != 0) {
				if (challenge.length >
				    sizeof(challenge.text) - 1)
					return 0;
				if (!ND_TTEST2(*(p + offset), challenge.length))
					return 0;
				if (length < challenge.length)
					return 0;
				memcpy(&challenge.text, p + offset,
				    challenge.length);
				offset += challenge.length;
				length -= challenge.length;
			}
			challenge.text[challenge.length] = '\0';
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a challenge IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->challenge_present) {
				pbody->challenge = challenge;
				pbody->challenge_present = 1;
			}
			break;
		case E_RATES:
			memcpy(&rates, p + offset, 2);
			offset += 2;
			length -= 2;
			if (rates.length != 0) {
				if (rates.length > sizeof rates.rate)
					return 0;
				if (!ND_TTEST2(*(p + offset), rates.length))
					return 0;
				if (length < rates.length)
					return 0;
				memcpy(&rates.rate, p + offset, rates.length);
				offset += rates.length;
				length -= rates.length;
			}
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a rates IE,
			 * copy this one if it's not zero-length,
			 * otherwise ignore this one, so we later
			 * report the first one we saw.
			 *
			 * We ignore zero-length rates IEs as some
			 * devices seem to put a zero-length rates
			 * IE, followed by an SSID IE, followed by
			 * a non-zero-length rates IE into frames,
			 * even though IEEE Std 802.11-2007 doesn't
			 * seem to indicate that a zero-length rates
			 * IE is valid.
			 */
			if (!pbody->rates_present && rates.length != 0) {
				pbody->rates = rates;
				pbody->rates_present = 1;
			}
			break;
		case E_DS:
			memcpy(&ds, p + offset, 2);
			offset += 2;
			length -= 2;
			if (ds.length != 1) {
				offset += ds.length;
				length -= ds.length;
				break;
			}
			ds.channel = *(p + offset);
			offset += 1;
			length -= 1;
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a DS IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->ds_present) {
				pbody->ds = ds;
				pbody->ds_present = 1;
			}
			break;
		case E_CF:
			memcpy(&cf, p + offset, 2);
			offset += 2;
			length -= 2;
			if (cf.length != 6) {
				offset += cf.length;
				length -= cf.length;
				break;
			}
			memcpy(&cf.count, p + offset, 6);
			offset += 6;
			length -= 6;
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a CF IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->cf_present) {
				pbody->cf = cf;
				pbody->cf_present = 1;
			}
			break;
		case E_TIM:
			memcpy(&tim, p + offset, 2);
			offset += 2;
			length -= 2;
			if (tim.length <= 3) {
				offset += tim.length;
				length -= tim.length;
				break;
			}
			if (tim.length - 3 > (int)sizeof tim.bitmap)
				return 0;
			memcpy(&tim.count, p + offset, 3);
			offset += 3;
			length -= 3;

			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);
			offset += tim.length - 3;
			length -= tim.length - 3;
			/*
			 * Present and not truncated.
			 *
			 * If we haven't already seen a TIM IE,
			 * copy this one, otherwise ignore this one,
			 * so we later report the first one we saw.
			 */
			if (!pbody->tim_present) {
				pbody->tim = tim;
				pbody->tim_present = 1;
			}
			break;
		default:
#if 0
			ND_PRINT((ndo, ""(1) unhandled element_id (%d)  "",
			    *(p + offset)));
#endif
			offset += 2 + elementlen;
			length -= 2 + elementlen;
			break;
		}
	}

	/* No problems found. */
	return 1;
}","static int
parse_elements(netdissect_options *VAR_0,
               struct mgmt_body_t *VAR_1, const u_char *VAR_2, int VAR_3,
               u_int VAR_4)
{
	u_int VAR_5;
	struct ssid_t VAR_6;
	struct challenge_t VAR_7;
	struct rates_t VAR_8;
	struct ds_t VAR_9;
	struct cf_t VAR_10;
	struct tim_t VAR_11;

	/* COMMENT_0 */
                                     
    
	VAR_1->challenge_present = 0;
	VAR_1->ssid_present = 0;
	VAR_1->rates_present = 0;
	VAR_1->ds_present = 0;
	VAR_1->cf_present = 0;
	VAR_1->tim_present = 0;

	while (VAR_4 != 0) {
		/* COMMENT_3 */
		if (!ND_TTEST2(*(VAR_2 + VAR_3), 2))
			return 0;
		if (VAR_4 < 2)
			return 0;
		VAR_5 = *(VAR_2 + VAR_3 + 1);

		/* COMMENT_4 */
		if (!ND_TTEST2(*(VAR_2 + VAR_3 + 2), VAR_5))
			return 0;
		if (VAR_4 < VAR_5 + 2)
			return 0;

		switch (*(VAR_2 + VAR_3)) {
		case VAR_12:
			memcpy(&VAR_6, VAR_2 + VAR_3, 2);
			VAR_3 += 2;
			VAR_4 -= 2;
			if (VAR_6.length != 0) {
				if (VAR_6.length > sizeof(VAR_6.ssid) - 1)
					return 0;
				if (!ND_TTEST2(*(VAR_2 + VAR_3), VAR_6.length))
					return 0;
				if (VAR_4 < VAR_6.length)
					return 0;
				memcpy(&VAR_6.ssid, VAR_2 + VAR_3, VAR_6.length);
				VAR_3 += VAR_6.length;
				VAR_4 -= VAR_6.length;
			}
			VAR_6.ssid[VAR_6.length] = '\0';
			/* COMMENT_5 */
                                
     
                                            
                                               
                                              
      
			if (!VAR_1->ssid_present) {
				VAR_1->ssid = VAR_6;
				VAR_1->ssid_present = 1;
			}
			break;
		case VAR_13:
			memcpy(&VAR_7, VAR_2 + VAR_3, 2);
			VAR_3 += 2;
			VAR_4 -= 2;
			if (VAR_7.length != 0) {
				if (VAR_7.length >
				    sizeof(VAR_7.text) - 1)
					return 0;
				if (!ND_TTEST2(*(VAR_2 + VAR_3), VAR_7.length))
					return 0;
				if (VAR_4 < VAR_7.length)
					return 0;
				memcpy(&VAR_7.text, VAR_2 + VAR_3,
				    VAR_7.length);
				VAR_3 += VAR_7.length;
				VAR_4 -= VAR_7.length;
			}
			VAR_7.text[VAR_7.length] = '\0';
			/* COMMENT_12 */
                                
     
                                                
                                               
                                              
      
			if (!VAR_1->challenge_present) {
				VAR_1->challenge = VAR_7;
				VAR_1->challenge_present = 1;
			}
			break;
		case VAR_14:
			memcpy(&VAR_8, VAR_2 + VAR_3, 2);
			VAR_3 += 2;
			VAR_4 -= 2;
			if (VAR_8.length != 0) {
				if (VAR_8.length > sizeof VAR_8.rate)
					return 0;
				if (!ND_TTEST2(*(VAR_2 + VAR_3), VAR_8.length))
					return 0;
				if (VAR_4 < VAR_8.length)
					return 0;
				memcpy(&VAR_8.rate, VAR_2 + VAR_3, VAR_8.length);
				VAR_3 += VAR_8.length;
				VAR_4 -= VAR_8.length;
			}
			/* COMMENT_19 */
                                
     
                                            
                                            
                                            
                                  
     
                                             
                                             
                                             
                                             
                                              
                                               
                  
      
			if (!VAR_1->rates_present && VAR_8.length != 0) {
				VAR_1->rates = VAR_8;
				VAR_1->rates_present = 1;
			}
			break;
		case VAR_15:
			memcpy(&VAR_9, VAR_2 + VAR_3, 2);
			VAR_3 += 2;
			VAR_4 -= 2;
			if (VAR_9.length != 1) {
				VAR_3 += VAR_9.length;
				VAR_4 -= VAR_9.length;
				break;
			}
			VAR_9.channel = *(VAR_2 + VAR_3);
			VAR_3 += 1;
			VAR_4 -= 1;
			/* COMMENT_34 */
                                
     
                                         
                                               
                                              
      
			if (!VAR_1->ds_present) {
				VAR_1->ds = VAR_9;
				VAR_1->ds_present = 1;
			}
			break;
		case VAR_16:
			memcpy(&VAR_10, VAR_2 + VAR_3, 2);
			VAR_3 += 2;
			VAR_4 -= 2;
			if (VAR_10.length != 6) {
				VAR_3 += VAR_10.length;
				VAR_4 -= VAR_10.length;
				break;
			}
			memcpy(&VAR_10.count, VAR_2 + VAR_3, 6);
			VAR_3 += 6;
			VAR_4 -= 6;
			/* COMMENT_41 */
                                
     
                                         
                                               
                                              
      
			if (!VAR_1->cf_present) {
				VAR_1->cf = VAR_10;
				VAR_1->cf_present = 1;
			}
			break;
		case VAR_17:
			memcpy(&VAR_11, VAR_2 + VAR_3, 2);
			VAR_3 += 2;
			VAR_4 -= 2;
			if (VAR_11.length <= 3) {
				VAR_3 += VAR_11.length;
				VAR_4 -= VAR_11.length;
				break;
			}
			if (VAR_11.length - 3 > (int)sizeof VAR_11.bitmap)
				return 0;
			memcpy(&VAR_11.count, VAR_2 + VAR_3, 3);
			VAR_3 += 3;
			VAR_4 -= 3;

			memcpy(VAR_11.bitmap, VAR_2 + VAR_3 + 3, VAR_11.length - 3);
			VAR_3 += VAR_11.length - 3;
			VAR_4 -= VAR_11.length - 3;
			/* COMMENT_48 */
                                
     
                                          
                                               
                                              
      
			if (!VAR_1->tim_present) {
				VAR_1->tim = VAR_11;
				VAR_1->tim_present = 1;
			}
			break;
		default:
#if 0
			ND_PRINT((VAR_0, ""(1) unhandled element_id (%d)  "",
			    *(VAR_2 + VAR_3)));
#endif
			VAR_3 += 2 + VAR_5;
			VAR_4 -= 2 + VAR_5;
			break;
		}
	}

	/* COMMENT_55 */
	return 1;
}",the-tcpdump-group/tcpdump/99798bd9a41bd3d03fdc1e949810a38967f20ed3/print-802_11.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -193,8 +193,7 @@
 			offset += 3;
 			length -= 3;
 
-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));
+			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);
 			offset += tim.length - 3;
 			length -= tim.length - 3;
 			/*","{'deleted_lines': ['\t\t\tmemcpy(tim.bitmap, p + (tim.length - 3),', '\t\t\t    (tim.length - 3));'], 'added_lines': ['\t\t\tmemcpy(tim.bitmap, p + offset + 3, tim.length - 3);']}",True,The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().,9.8,CRITICAL,3,valid,2017-02-06T19:24:42Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_atm1_print,"u_int
juniper_atm1_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, register const u_char *p)
{
int llc_hdrlen;
struct juniper_l2info_t l2info;
l2info.pictype = DLT_JUNIPER_ATM1;
if (juniper_parse_header(ndo, p, h, &l2info) == 0)
return l2info.header_len;
p+=l2info.header_len;
if (l2info.cookie[0] == 0x80) { 
oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);
return l2info.header_len;
}
if (EXTRACT_24BITS(p) == 0xfefe03 || 
EXTRACT_24BITS(p) == 0xaaaa03) { 
llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
if (llc_hdrlen > 0)
return l2info.header_len;
}
if (p[0] == 0x03) { 
isoclns_print(ndo, p + 1, l2info.length - 1);
return l2info.header_len;
}
if (ip_heuristic_guess(ndo, p, l2info.length) != 0) 
return l2info.header_len;
return l2info.header_len;
}","u_int
juniper_atm1_print(netdissect_options *VAR_0,
const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
int VAR_3;
struct juniper_l2info_t VAR_4;
VAR_4.pictype = VAR_5;
if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_4) == 0)
return VAR_4.header_len;
VAR_2+=VAR_4.header_len;
if (VAR_4.cookie[0] == 0x80) { 
oam_print(VAR_0, VAR_2, VAR_4.length, VAR_6);
return VAR_4.header_len;
}
if (EXTRACT_24BITS(VAR_2) == 0xfefe03 || 
EXTRACT_24BITS(VAR_2) == 0xaaaa03) { 
VAR_3 = llc_print(VAR_0, VAR_2, VAR_4.length, VAR_4.caplen, NULL, NULL);
if (VAR_3 > 0)
return VAR_4.header_len;
}
if (VAR_2[0] == 0x03) { 
isoclns_print(VAR_0, VAR_2 + 1, VAR_4.length - 1);
return VAR_4.header_len;
}
if (ip_heuristic_guess(VAR_0, VAR_2, VAR_4.length) != 0) 
return VAR_4.header_len;
return VAR_4.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/0.json,"u_int
juniper_atm1_print(netdissect_options *ndo,
                   const struct pcap_pkthdr *h, register const u_char *p)
{
        int llc_hdrlen;

        struct juniper_l2info_t l2info;

        l2info.pictype = DLT_JUNIPER_ATM1;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;

        if (l2info.cookie[0] == 0x80) { /* OAM cell ? */
            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);
            return l2info.header_len;
        }

        ND_TCHECK2(p[0], 3);
        if (EXTRACT_24BITS(p) == 0xfefe03 || /* NLPID encaps ? */
            EXTRACT_24BITS(p) == 0xaaaa03) { /* SNAP encaps ? */

            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
            if (llc_hdrlen > 0)
                return l2info.header_len;
        }

        if (p[0] == 0x03) { /* Cisco style NLPID encaps ? */
            isoclns_print(ndo, p + 1, l2info.length - 1);
            /* FIXME check if frame was recognized */
            return l2info.header_len;
        }

        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) /* last try - vcmux encaps ? */
            return l2info.header_len;

	return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_atm1]""));
	return l2info.header_len;
}","u_int
juniper_atm1_print(netdissect_options *VAR_0,
                   const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
        int VAR_3;

        struct juniper_l2info_t VAR_4;

        VAR_4.pictype = VAR_5;
        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_4) == 0)
            return VAR_4.header_len;

        VAR_2+=VAR_4.header_len;

        if (VAR_4.cookie[0] == 0x80) { /* COMMENT_0 */
            oam_print(VAR_0, VAR_2, VAR_4.length, VAR_6);
            return VAR_4.header_len;
        }

        ND_TCHECK2(VAR_2[0], 3);
        if (EXTRACT_24BITS(VAR_2) == 0xfefe03 || /* COMMENT_1 */
            EXTRACT_24BITS(VAR_2) == 0xaaaa03) { /* COMMENT_2 */

            VAR_3 = llc_print(VAR_0, VAR_2, VAR_4.length, VAR_4.caplen, NULL, NULL);
            if (VAR_3 > 0)
                return VAR_4.header_len;
        }

        if (VAR_2[0] == 0x03) { /* COMMENT_3 */
            isoclns_print(VAR_0, VAR_2 + 1, VAR_4.length - 1);
            /* COMMENT_4 */
            return VAR_4.header_len;
        }

        if (ip_heuristic_guess(VAR_0, VAR_2, VAR_4.length) != 0) /* COMMENT_5 */
            return VAR_4.header_len;

	return VAR_4.header_len;

trunc:
	ND_PRINT((VAR_0, ""[|juniper_atm1]""));
	return VAR_4.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,7 @@
             return l2info.header_len;
         }
 
+        ND_TCHECK2(p[0], 3);
         if (EXTRACT_24BITS(p) == 0xfefe03 || /* NLPID encaps ? */
             EXTRACT_24BITS(p) == 0xaaaa03) { /* SNAP encaps ? */
 
@@ -35,4 +36,8 @@
             return l2info.header_len;
 
 	return l2info.header_len;
+
+trunc:
+	ND_PRINT((ndo, ""[|juniper_atm1]""));
+	return l2info.header_len;
 }","{'deleted_lines': [], 'added_lines': ['        ND_TCHECK2(p[0], 3);', '', 'trunc:', '\tND_PRINT((ndo, ""[|juniper_atm1]""));', '\treturn l2info.header_len;']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_atm2_print,"u_int
juniper_atm2_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, register const u_char *p)
{
int llc_hdrlen;
struct juniper_l2info_t l2info;
l2info.pictype = DLT_JUNIPER_ATM2;
if (juniper_parse_header(ndo, p, h, &l2info) == 0)
return l2info.header_len;
p+=l2info.header_len;
if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { 
oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);
return l2info.header_len;
}
if (EXTRACT_24BITS(p) == 0xfefe03 || 
EXTRACT_24BITS(p) == 0xaaaa03) { 
llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
if (llc_hdrlen > 0)
return l2info.header_len;
}
if (l2info.direction != JUNIPER_BPF_PKT_IN && 
(EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {
ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
return l2info.header_len;
}
if (p[0] == 0x03) { 
isoclns_print(ndo, p + 1, l2info.length - 1);
return l2info.header_len;
}
if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) 
return l2info.header_len;
if (ip_heuristic_guess(ndo, p, l2info.length) != 0) 
return l2info.header_len;
return l2info.header_len;
}","u_int
juniper_atm2_print(netdissect_options *VAR_0,
const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
int VAR_3;
struct juniper_l2info_t VAR_4;
VAR_4.pictype = VAR_5;
if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_4) == 0)
return VAR_4.header_len;
VAR_2+=VAR_4.header_len;
if (VAR_4.cookie[7] & VAR_6) { 
oam_print(VAR_0, VAR_2, VAR_4.length, VAR_7);
return VAR_4.header_len;
}
if (EXTRACT_24BITS(VAR_2) == 0xfefe03 || 
EXTRACT_24BITS(VAR_2) == 0xaaaa03) { 
VAR_3 = llc_print(VAR_0, VAR_2, VAR_4.length, VAR_4.caplen, NULL, NULL);
if (VAR_3 > 0)
return VAR_4.header_len;
}
if (VAR_4.direction != VAR_8 && 
(EXTRACT_32BITS(VAR_4.cookie) & VAR_9)) {
ether_print(VAR_0, VAR_2, VAR_4.length, VAR_4.caplen, NULL, NULL);
return VAR_4.header_len;
}
if (VAR_2[0] == 0x03) { 
isoclns_print(VAR_0, VAR_2 + 1, VAR_4.length - 1);
return VAR_4.header_len;
}
if(juniper_ppp_heuristic_guess(VAR_0, VAR_2, VAR_4.length) != 0) 
return VAR_4.header_len;
if (ip_heuristic_guess(VAR_0, VAR_2, VAR_4.length) != 0) 
return VAR_4.header_len;
return VAR_4.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/4.json,"u_int
juniper_atm2_print(netdissect_options *ndo,
                   const struct pcap_pkthdr *h, register const u_char *p)
{
        int llc_hdrlen;

        struct juniper_l2info_t l2info;

        l2info.pictype = DLT_JUNIPER_ATM2;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;

        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { /* OAM cell ? */
            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);
            return l2info.header_len;
        }

        ND_TCHECK2(p[0], 3);
        if (EXTRACT_24BITS(p) == 0xfefe03 || /* NLPID encaps ? */
            EXTRACT_24BITS(p) == 0xaaaa03) { /* SNAP encaps ? */

            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
            if (llc_hdrlen > 0)
                return l2info.header_len;
        }

        if (l2info.direction != JUNIPER_BPF_PKT_IN && /* ether-over-1483 encaps ? */
            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {
            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
            return l2info.header_len;
        }

        if (p[0] == 0x03) { /* Cisco style NLPID encaps ? */
            isoclns_print(ndo, p + 1, l2info.length - 1);
            /* FIXME check if frame was recognized */
            return l2info.header_len;
        }

        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) /* PPPoA vcmux encaps ? */
            return l2info.header_len;

        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) /* last try - vcmux encaps ? */
            return l2info.header_len;

	return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_atm2]""));
	return l2info.header_len;
}","u_int
juniper_atm2_print(netdissect_options *VAR_0,
                   const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
        int VAR_3;

        struct juniper_l2info_t VAR_4;

        VAR_4.pictype = VAR_5;
        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_4) == 0)
            return VAR_4.header_len;

        VAR_2+=VAR_4.header_len;

        if (VAR_4.cookie[7] & VAR_6) { /* COMMENT_0 */
            oam_print(VAR_0, VAR_2, VAR_4.length, VAR_7);
            return VAR_4.header_len;
        }

        ND_TCHECK2(VAR_2[0], 3);
        if (EXTRACT_24BITS(VAR_2) == 0xfefe03 || /* COMMENT_1 */
            EXTRACT_24BITS(VAR_2) == 0xaaaa03) { /* COMMENT_2 */

            VAR_3 = llc_print(VAR_0, VAR_2, VAR_4.length, VAR_4.caplen, NULL, NULL);
            if (VAR_3 > 0)
                return VAR_4.header_len;
        }

        if (VAR_4.direction != VAR_8 && /* COMMENT_3 */
            (EXTRACT_32BITS(VAR_4.cookie) & VAR_9)) {
            ether_print(VAR_0, VAR_2, VAR_4.length, VAR_4.caplen, NULL, NULL);
            return VAR_4.header_len;
        }

        if (VAR_2[0] == 0x03) { /* COMMENT_4 */
            isoclns_print(VAR_0, VAR_2 + 1, VAR_4.length - 1);
            /* COMMENT_5 */
            return VAR_4.header_len;
        }

        if(juniper_ppp_heuristic_guess(VAR_0, VAR_2, VAR_4.length) != 0) /* COMMENT_6 */
            return VAR_4.header_len;

        if (ip_heuristic_guess(VAR_0, VAR_2, VAR_4.length) != 0) /* COMMENT_7 */
            return VAR_4.header_len;

	return VAR_4.header_len;

trunc:
	ND_PRINT((VAR_0, ""[|juniper_atm2]""));
	return VAR_4.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -17,6 +17,7 @@
             return l2info.header_len;
         }
 
+        ND_TCHECK2(p[0], 3);
         if (EXTRACT_24BITS(p) == 0xfefe03 || /* NLPID encaps ? */
             EXTRACT_24BITS(p) == 0xaaaa03) { /* SNAP encaps ? */
 
@@ -44,4 +45,8 @@
             return l2info.header_len;
 
 	return l2info.header_len;
+
+trunc:
+	ND_PRINT((ndo, ""[|juniper_atm2]""));
+	return l2info.header_len;
 }","{'deleted_lines': [], 'added_lines': ['        ND_TCHECK2(p[0], 3);', '', 'trunc:', '\tND_PRINT((ndo, ""[|juniper_atm2]""));', '\treturn l2info.header_len;']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_ggsn_print,"u_int
juniper_ggsn_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, register const u_char *p)
{
struct juniper_l2info_t l2info;
struct juniper_ggsn_header {
uint8_t svc_id;
uint8_t flags_len;
uint8_t proto;
uint8_t flags;
uint8_t vlan_id[2];
uint8_t res[2];
};
const struct juniper_ggsn_header *gh;
l2info.pictype = DLT_JUNIPER_GGSN;
if (juniper_parse_header(ndo, p, h, &l2info) == 0)
return l2info.header_len;
p+=l2info.header_len;
gh = (struct juniper_ggsn_header *)&l2info.cookie;
if (ndo->ndo_eflag) {
ND_PRINT((ndo, ""proto %s (%u), vlan %u: "",
tok2str(juniper_protocol_values,""Unknown"",gh->proto),
gh->proto,
EXTRACT_16BITS(&gh->vlan_id[0])));
}
switch (gh->proto) {
case JUNIPER_PROTO_IPV4:
ip_print(ndo, p, l2info.length);
break;
case JUNIPER_PROTO_IPV6:
ip6_print(ndo, p, l2info.length);
break;
default:
if (!ndo->ndo_eflag)
ND_PRINT((ndo, ""unknown GGSN proto (%u)"", gh->proto));
}
return l2info.header_len;
}","u_int
juniper_ggsn_print(netdissect_options *VAR_0,
const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
struct juniper_l2info_t VAR_3;
struct juniper_ggsn_header {
uint8_t svc_id;
uint8_t flags_len;
uint8_t proto;
uint8_t flags;
uint8_t vlan_id[2];
uint8_t res[2];
};
const struct juniper_ggsn_header *VAR_4;
VAR_3.pictype = VAR_5;
if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
return VAR_3.header_len;
VAR_2+=VAR_3.header_len;
VAR_4 = (struct juniper_ggsn_header *)&VAR_3.cookie;
if (VAR_0->ndo_eflag) {
ND_PRINT((VAR_0, ""proto %s (%u), vlan %u: "",
tok2str(VAR_6,""Unknown"",VAR_4->proto),
VAR_4->proto,
EXTRACT_16BITS(&VAR_4->vlan_id[0])));
}
switch (VAR_4->proto) {
case VAR_7:
ip_print(VAR_0, VAR_2, VAR_3.length);
break;
case VAR_8:
ip6_print(VAR_0, VAR_2, VAR_3.length);
break;
default:
if (!VAR_0->ndo_eflag)
ND_PRINT((VAR_0, ""unknown GGSN proto (%u)"", VAR_4->proto));
}
return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/5.json,"u_int
juniper_ggsn_print(netdissect_options *ndo,
                   const struct pcap_pkthdr *h, register const u_char *p)
{
        struct juniper_l2info_t l2info;
        struct juniper_ggsn_header {
            uint8_t svc_id;
            uint8_t flags_len;
            uint8_t proto;
            uint8_t flags;
            uint8_t vlan_id[2];
            uint8_t res[2];
        };
        const struct juniper_ggsn_header *gh;

        l2info.pictype = DLT_JUNIPER_GGSN;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;
        gh = (struct juniper_ggsn_header *)&l2info.cookie;

        ND_TCHECK(*gh);
        if (ndo->ndo_eflag) {
            ND_PRINT((ndo, ""proto %s (%u), vlan %u: "",
                   tok2str(juniper_protocol_values,""Unknown"",gh->proto),
                   gh->proto,
                   EXTRACT_16BITS(&gh->vlan_id[0])));
        }

        switch (gh->proto) {
        case JUNIPER_PROTO_IPV4:
            ip_print(ndo, p, l2info.length);
            break;
        case JUNIPER_PROTO_IPV6:
            ip6_print(ndo, p, l2info.length);
            break;
        default:
            if (!ndo->ndo_eflag)
                ND_PRINT((ndo, ""unknown GGSN proto (%u)"", gh->proto));
        }

        return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
}","u_int
juniper_ggsn_print(netdissect_options *VAR_0,
                   const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
        struct juniper_l2info_t VAR_3;
        struct juniper_ggsn_header {
            uint8_t svc_id;
            uint8_t flags_len;
            uint8_t proto;
            uint8_t flags;
            uint8_t vlan_id[2];
            uint8_t res[2];
        };
        const struct juniper_ggsn_header *VAR_4;

        VAR_3.pictype = VAR_5;
        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
            return VAR_3.header_len;

        VAR_2+=VAR_3.header_len;
        VAR_4 = (struct juniper_ggsn_header *)&VAR_3.cookie;

        ND_TCHECK(*VAR_4);
        if (VAR_0->ndo_eflag) {
            ND_PRINT((VAR_0, ""proto %s (%u), vlan %u: "",
                   tok2str(VAR_6,""Unknown"",VAR_4->proto),
                   VAR_4->proto,
                   EXTRACT_16BITS(&VAR_4->vlan_id[0])));
        }

        switch (VAR_4->proto) {
        case VAR_7:
            ip_print(VAR_0, VAR_2, VAR_3.length);
            break;
        case VAR_8:
            ip6_print(VAR_0, VAR_2, VAR_3.length);
            break;
        default:
            if (!VAR_0->ndo_eflag)
                ND_PRINT((VAR_0, ""unknown GGSN proto (%u)"", VAR_4->proto));
        }

        return VAR_3.header_len;

trunc:
	ND_PRINT((VAR_0, ""[|juniper_services]""));
	return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -20,6 +20,7 @@
         p+=l2info.header_len;
         gh = (struct juniper_ggsn_header *)&l2info.cookie;
 
+        ND_TCHECK(*gh);
         if (ndo->ndo_eflag) {
             ND_PRINT((ndo, ""proto %s (%u), vlan %u: "",
                    tok2str(juniper_protocol_values,""Unknown"",gh->proto),
@@ -40,4 +41,8 @@
         }
 
         return l2info.header_len;
+
+trunc:
+	ND_PRINT((ndo, ""[|juniper_services]""));
+	return l2info.header_len;
 }","{'deleted_lines': [], 'added_lines': ['        ND_TCHECK(*gh);', '', 'trunc:', '\tND_PRINT((ndo, ""[|juniper_services]""));', '\treturn l2info.header_len;']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_es_print,"u_int
juniper_es_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, register const u_char *p)
{
struct juniper_l2info_t l2info;
struct juniper_ipsec_header {
uint8_t sa_index[2];
uint8_t ttl;
uint8_t type;
uint8_t spi[4];
uint8_t src_ip[4];
uint8_t dst_ip[4];
};
u_int rewrite_len,es_type_bundle;
const struct juniper_ipsec_header *ih;
l2info.pictype = DLT_JUNIPER_ES;
if (juniper_parse_header(ndo, p, h, &l2info) == 0)
return l2info.header_len;
p+=l2info.header_len;
ih = (const struct juniper_ipsec_header *)p;
switch (ih->type) {
case JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPE:
case JUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPE:
rewrite_len = 0;
es_type_bundle = 1;
break;
case JUNIPER_IPSEC_O_ESP_AUTHENTICATION_TYPE:
case JUNIPER_IPSEC_O_AH_AUTHENTICATION_TYPE:
case JUNIPER_IPSEC_O_ESP_ENCRYPTION_TYPE:
rewrite_len = 16;
es_type_bundle = 0;
break;
default:
ND_PRINT((ndo, ""ES Invalid type %u, length %u"",
ih->type,
l2info.length));
return l2info.header_len;
}
l2info.length-=rewrite_len;
p+=rewrite_len;
if (ndo->ndo_eflag) {
if (!es_type_bundle) {
ND_PRINT((ndo, ""ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n"",
EXTRACT_16BITS(&ih->sa_index),
ih->ttl,
tok2str(juniper_ipsec_type_values,""Unknown"",ih->type),
ih->type,
EXTRACT_32BITS(&ih->spi),
ipaddr_string(ndo, &ih->src_ip),
ipaddr_string(ndo, &ih->dst_ip),
l2info.length));
} else {
ND_PRINT((ndo, ""ES SA, index %u, ttl %u type %s (%u), length %u\n"",
EXTRACT_16BITS(&ih->sa_index),
ih->ttl,
tok2str(juniper_ipsec_type_values,""Unknown"",ih->type),
ih->type,
l2info.length));
}
}
ip_print(ndo, p, l2info.length);
return l2info.header_len;
}","u_int
juniper_es_print(netdissect_options *VAR_0,
const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
struct juniper_l2info_t VAR_3;
struct juniper_ipsec_header {
uint8_t sa_index[2];
uint8_t ttl;
uint8_t type;
uint8_t spi[4];
uint8_t src_ip[4];
uint8_t dst_ip[4];
};
u_int VAR_4,VAR_5;
const struct juniper_ipsec_header *VAR_6;
VAR_3.pictype = VAR_7;
if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
return VAR_3.header_len;
VAR_2+=VAR_3.header_len;
VAR_6 = (const struct juniper_ipsec_header *)VAR_2;
switch (VAR_6->type) {
case VAR_8:
case VAR_9:
VAR_4 = 0;
VAR_5 = 1;
break;
case VAR_10:
case VAR_11:
case VAR_12:
VAR_4 = 16;
VAR_5 = 0;
break;
default:
ND_PRINT((VAR_0, ""ES Invalid type %u, length %u"",
VAR_6->type,
VAR_3.length));
return VAR_3.header_len;
}
VAR_3.length-=VAR_4;
VAR_2+=VAR_4;
if (VAR_0->ndo_eflag) {
if (!VAR_5) {
ND_PRINT((VAR_0, ""ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n"",
EXTRACT_16BITS(&VAR_6->sa_index),
VAR_6->ttl,
tok2str(VAR_13,""Unknown"",VAR_6->type),
VAR_6->type,
EXTRACT_32BITS(&VAR_6->spi),
ipaddr_string(VAR_0, &VAR_6->src_ip),
ipaddr_string(VAR_0, &VAR_6->dst_ip),
VAR_3.length));
} else {
ND_PRINT((VAR_0, ""ES SA, index %u, ttl %u type %s (%u), length %u\n"",
EXTRACT_16BITS(&VAR_6->sa_index),
VAR_6->ttl,
tok2str(VAR_13,""Unknown"",VAR_6->type),
VAR_6->type,
VAR_3.length));
}
}
ip_print(VAR_0, VAR_2, VAR_3.length);
return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/2.json,"u_int
juniper_es_print(netdissect_options *ndo,
                 const struct pcap_pkthdr *h, register const u_char *p)
{
        struct juniper_l2info_t l2info;
        struct juniper_ipsec_header {
            uint8_t sa_index[2];
            uint8_t ttl;
            uint8_t type;
            uint8_t spi[4];
            uint8_t src_ip[4];
            uint8_t dst_ip[4];
        };
        u_int rewrite_len,es_type_bundle;
        const struct juniper_ipsec_header *ih;

        l2info.pictype = DLT_JUNIPER_ES;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;
        ih = (const struct juniper_ipsec_header *)p;

        ND_TCHECK(*ih);
        switch (ih->type) {
        case JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPE:
        case JUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPE:
            rewrite_len = 0;
            es_type_bundle = 1;
            break;
        case JUNIPER_IPSEC_O_ESP_AUTHENTICATION_TYPE:
        case JUNIPER_IPSEC_O_AH_AUTHENTICATION_TYPE:
        case JUNIPER_IPSEC_O_ESP_ENCRYPTION_TYPE:
            rewrite_len = 16;
            es_type_bundle = 0;
            break;
        default:
            ND_PRINT((ndo, ""ES Invalid type %u, length %u"",
                   ih->type,
                   l2info.length));
            return l2info.header_len;
        }

        l2info.length-=rewrite_len;
        p+=rewrite_len;

        if (ndo->ndo_eflag) {
            if (!es_type_bundle) {
                ND_PRINT((ndo, ""ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n"",
                       EXTRACT_16BITS(&ih->sa_index),
                       ih->ttl,
                       tok2str(juniper_ipsec_type_values,""Unknown"",ih->type),
                       ih->type,
                       EXTRACT_32BITS(&ih->spi),
                       ipaddr_string(ndo, &ih->src_ip),
                       ipaddr_string(ndo, &ih->dst_ip),
                       l2info.length));
            } else {
                ND_PRINT((ndo, ""ES SA, index %u, ttl %u type %s (%u), length %u\n"",
                       EXTRACT_16BITS(&ih->sa_index),
                       ih->ttl,
                       tok2str(juniper_ipsec_type_values,""Unknown"",ih->type),
                       ih->type,
                       l2info.length));
            }
        }

        ip_print(ndo, p, l2info.length);
        return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
}","u_int
juniper_es_print(netdissect_options *VAR_0,
                 const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
        struct juniper_l2info_t VAR_3;
        struct juniper_ipsec_header {
            uint8_t sa_index[2];
            uint8_t ttl;
            uint8_t type;
            uint8_t spi[4];
            uint8_t src_ip[4];
            uint8_t dst_ip[4];
        };
        u_int VAR_4,VAR_5;
        const struct juniper_ipsec_header *VAR_6;

        VAR_3.pictype = VAR_7;
        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
            return VAR_3.header_len;

        VAR_2+=VAR_3.header_len;
        VAR_6 = (const struct juniper_ipsec_header *)VAR_2;

        ND_TCHECK(*VAR_6);
        switch (VAR_6->type) {
        case VAR_8:
        case VAR_9:
            VAR_4 = 0;
            VAR_5 = 1;
            break;
        case VAR_10:
        case VAR_11:
        case VAR_12:
            VAR_4 = 16;
            VAR_5 = 0;
            break;
        default:
            ND_PRINT((VAR_0, ""ES Invalid type %u, length %u"",
                   VAR_6->type,
                   VAR_3.length));
            return VAR_3.header_len;
        }

        VAR_3.length-=VAR_4;
        VAR_2+=VAR_4;

        if (VAR_0->ndo_eflag) {
            if (!VAR_5) {
                ND_PRINT((VAR_0, ""ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\n"",
                       EXTRACT_16BITS(&VAR_6->sa_index),
                       VAR_6->ttl,
                       tok2str(VAR_13,""Unknown"",VAR_6->type),
                       VAR_6->type,
                       EXTRACT_32BITS(&VAR_6->spi),
                       ipaddr_string(VAR_0, &VAR_6->src_ip),
                       ipaddr_string(VAR_0, &VAR_6->dst_ip),
                       VAR_3.length));
            } else {
                ND_PRINT((VAR_0, ""ES SA, index %u, ttl %u type %s (%u), length %u\n"",
                       EXTRACT_16BITS(&VAR_6->sa_index),
                       VAR_6->ttl,
                       tok2str(VAR_13,""Unknown"",VAR_6->type),
                       VAR_6->type,
                       VAR_3.length));
            }
        }

        ip_print(VAR_0, VAR_2, VAR_3.length);
        return VAR_3.header_len;

trunc:
	ND_PRINT((VAR_0, ""[|juniper_services]""));
	return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -21,6 +21,7 @@
         p+=l2info.header_len;
         ih = (const struct juniper_ipsec_header *)p;
 
+        ND_TCHECK(*ih);
         switch (ih->type) {
         case JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPE:
         case JUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPE:
@@ -66,4 +67,8 @@
 
         ip_print(ndo, p, l2info.length);
         return l2info.header_len;
+
+trunc:
+	ND_PRINT((ndo, ""[|juniper_services]""));
+	return l2info.header_len;
 }","{'deleted_lines': [], 'added_lines': ['        ND_TCHECK(*ih);', '', 'trunc:', '\tND_PRINT((ndo, ""[|juniper_services]""));', '\treturn l2info.header_len;']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_services_print,"u_int
juniper_services_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, register const u_char *p)
{
struct juniper_l2info_t l2info;
struct juniper_services_header {
uint8_t svc_id;
uint8_t flags_len;
uint8_t svc_set_id[2];
uint8_t dir_iif[4];
};
const struct juniper_services_header *sh;
l2info.pictype = DLT_JUNIPER_SERVICES;
if (juniper_parse_header(ndo, p, h, &l2info) == 0)
return l2info.header_len;
p+=l2info.header_len;
sh = (const struct juniper_services_header *)p;
if (ndo->ndo_eflag)
ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
sh->svc_id,
sh->flags_len,
EXTRACT_16BITS(&sh->svc_set_id),
EXTRACT_24BITS(&sh->dir_iif[1])));
ip_heuristic_guess (ndo, p, l2info.length);
return l2info.header_len;
}","u_int
juniper_services_print(netdissect_options *VAR_0,
const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
struct juniper_l2info_t VAR_3;
struct juniper_services_header {
uint8_t svc_id;
uint8_t flags_len;
uint8_t svc_set_id[2];
uint8_t dir_iif[4];
};
const struct juniper_services_header *VAR_4;
VAR_3.pictype = VAR_5;
if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
return VAR_3.header_len;
VAR_2+=VAR_3.header_len;
VAR_4 = (const struct juniper_services_header *)VAR_2;
if (VAR_0->ndo_eflag)
ND_PRINT((VAR_0, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
VAR_4->svc_id,
VAR_4->flags_len,
EXTRACT_16BITS(&VAR_4->svc_set_id),
EXTRACT_24BITS(&VAR_4->dir_iif[1])));
ip_heuristic_guess (VAR_0, VAR_2, VAR_3.length);
return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/6.json,"u_int
juniper_services_print(netdissect_options *ndo,
                       const struct pcap_pkthdr *h, register const u_char *p)
{
        struct juniper_l2info_t l2info;
        struct juniper_services_header {
            uint8_t svc_id;
            uint8_t flags_len;
            uint8_t svc_set_id[2];
            uint8_t dir_iif[4];
        };
        const struct juniper_services_header *sh;

        l2info.pictype = DLT_JUNIPER_SERVICES;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;
        sh = (const struct juniper_services_header *)p;

        ND_TCHECK(*sh);
        if (ndo->ndo_eflag)
            ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                   sh->svc_id,
                   sh->flags_len,
                   EXTRACT_16BITS(&sh->svc_set_id),
                   EXTRACT_24BITS(&sh->dir_iif[1])));

        /* no proto field - lets guess by first byte of IP header*/
        ip_heuristic_guess (ndo, p, l2info.length);

        return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
}","u_int
juniper_services_print(netdissect_options *VAR_0,
                       const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
        struct juniper_l2info_t VAR_3;
        struct juniper_services_header {
            uint8_t svc_id;
            uint8_t flags_len;
            uint8_t svc_set_id[2];
            uint8_t dir_iif[4];
        };
        const struct juniper_services_header *VAR_4;

        VAR_3.pictype = VAR_5;
        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
            return VAR_3.header_len;

        VAR_2+=VAR_3.header_len;
        VAR_4 = (const struct juniper_services_header *)VAR_2;

        ND_TCHECK(*VAR_4);
        if (VAR_0->ndo_eflag)
            ND_PRINT((VAR_0, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                   VAR_4->svc_id,
                   VAR_4->flags_len,
                   EXTRACT_16BITS(&VAR_4->svc_set_id),
                   EXTRACT_24BITS(&VAR_4->dir_iif[1])));

        /* COMMENT_0 */
        ip_heuristic_guess (VAR_0, VAR_2, VAR_3.length);

        return VAR_3.header_len;

trunc:
	ND_PRINT((VAR_0, ""[|juniper_services]""));
	return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -18,6 +18,7 @@
         p+=l2info.header_len;
         sh = (const struct juniper_services_header *)p;
 
+        ND_TCHECK(*sh);
         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                    sh->svc_id,
@@ -29,4 +30,8 @@
         ip_heuristic_guess (ndo, p, l2info.length);
 
         return l2info.header_len;
+
+trunc:
+	ND_PRINT((ndo, ""[|juniper_services]""));
+	return l2info.header_len;
 }","{'deleted_lines': [], 'added_lines': ['        ND_TCHECK(*sh);', '', 'trunc:', '\tND_PRINT((ndo, ""[|juniper_services]""));', '\treturn l2info.header_len;']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_monitor_print,"u_int
juniper_monitor_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, register const u_char *p)
{
struct juniper_l2info_t l2info;
struct juniper_monitor_header {
uint8_t pkt_type;
uint8_t padding;
uint8_t iif[2];
uint8_t service_id[4];
};
const struct juniper_monitor_header *mh;
l2info.pictype = DLT_JUNIPER_MONITOR;
if (juniper_parse_header(ndo, p, h, &l2info) == 0)
return l2info.header_len;
p+=l2info.header_len;
mh = (const struct juniper_monitor_header *)p;
if (ndo->ndo_eflag)
ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
EXTRACT_32BITS(&mh->service_id),
EXTRACT_16BITS(&mh->iif),
mh->pkt_type));
ip_heuristic_guess (ndo, p, l2info.length);
return l2info.header_len;
}","u_int
juniper_monitor_print(netdissect_options *VAR_0,
const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
struct juniper_l2info_t VAR_3;
struct juniper_monitor_header {
uint8_t pkt_type;
uint8_t padding;
uint8_t iif[2];
uint8_t service_id[4];
};
const struct juniper_monitor_header *VAR_4;
VAR_3.pictype = VAR_5;
if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
return VAR_3.header_len;
VAR_2+=VAR_3.header_len;
VAR_4 = (const struct juniper_monitor_header *)VAR_2;
if (VAR_0->ndo_eflag)
ND_PRINT((VAR_0, ""service-id %u, iif %u, pkt-type %u: "",
EXTRACT_32BITS(&VAR_4->service_id),
EXTRACT_16BITS(&VAR_4->iif),
VAR_4->pkt_type));
ip_heuristic_guess (VAR_0, VAR_2, VAR_3.length);
return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/3.json,"u_int
juniper_monitor_print(netdissect_options *ndo,
                      const struct pcap_pkthdr *h, register const u_char *p)
{
        struct juniper_l2info_t l2info;
        struct juniper_monitor_header {
            uint8_t pkt_type;
            uint8_t padding;
            uint8_t iif[2];
            uint8_t service_id[4];
        };
        const struct juniper_monitor_header *mh;

        l2info.pictype = DLT_JUNIPER_MONITOR;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;
        mh = (const struct juniper_monitor_header *)p;

        ND_TCHECK(*mh);
        if (ndo->ndo_eflag)
            ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
                   EXTRACT_32BITS(&mh->service_id),
                   EXTRACT_16BITS(&mh->iif),
                   mh->pkt_type));

        /* no proto field - lets guess by first byte of IP header*/
        ip_heuristic_guess (ndo, p, l2info.length);

        return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
}","u_int
juniper_monitor_print(netdissect_options *VAR_0,
                      const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
        struct juniper_l2info_t VAR_3;
        struct juniper_monitor_header {
            uint8_t pkt_type;
            uint8_t padding;
            uint8_t iif[2];
            uint8_t service_id[4];
        };
        const struct juniper_monitor_header *VAR_4;

        VAR_3.pictype = VAR_5;
        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
            return VAR_3.header_len;

        VAR_2+=VAR_3.header_len;
        VAR_4 = (const struct juniper_monitor_header *)VAR_2;

        ND_TCHECK(*VAR_4);
        if (VAR_0->ndo_eflag)
            ND_PRINT((VAR_0, ""service-id %u, iif %u, pkt-type %u: "",
                   EXTRACT_32BITS(&VAR_4->service_id),
                   EXTRACT_16BITS(&VAR_4->iif),
                   VAR_4->pkt_type));

        /* COMMENT_0 */
        ip_heuristic_guess (VAR_0, VAR_2, VAR_3.length);

        return VAR_3.header_len;

trunc:
	ND_PRINT((VAR_0, ""[|juniper_services]""));
	return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -18,6 +18,7 @@
         p+=l2info.header_len;
         mh = (const struct juniper_monitor_header *)p;
 
+        ND_TCHECK(*mh);
         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
                    EXTRACT_32BITS(&mh->service_id),
@@ -28,4 +29,8 @@
         ip_heuristic_guess (ndo, p, l2info.length);
 
         return l2info.header_len;
+
+trunc:
+	ND_PRINT((ndo, ""[|juniper_services]""));
+	return l2info.header_len;
 }","{'deleted_lines': [], 'added_lines': ['        ND_TCHECK(*mh);', '', 'trunc:', '\tND_PRINT((ndo, ""[|juniper_services]""));', '\treturn l2info.header_len;']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_parse_header,"static int
juniper_parse_header(netdissect_options *ndo,
const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)
{
const struct juniper_cookie_table_t *lp = juniper_cookie_table;
u_int idx, jnx_ext_len, jnx_header_len = 0;
uint8_t tlv_type,tlv_len;
uint32_t control_word;
int tlv_value;
const u_char *tptr;
l2info->header_len = 0;
l2info->cookie_len = 0;
l2info->proto = 0;
l2info->length = h->len;
l2info->caplen = h->caplen;
ND_TCHECK2(p[0], 4);
l2info->flags = p[3];
l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;
if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { 
ND_PRINT((ndo, ""no magic-number found!""));
return 0;
}
if (ndo->ndo_eflag) 
ND_PRINT((ndo, ""%3s "", tok2str(juniper_direction_values, ""---"", l2info->direction)));
jnx_header_len = 4;
if (ndo->ndo_vflag > 1)
ND_PRINT((ndo, ""\n\tJuniper PCAP Flags [%s]"",
bittok2str(jnx_flag_values, ""none"", l2info->flags)));
if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {
tptr = p+jnx_header_len;
ND_TCHECK2(tptr[0], 2);
jnx_ext_len = EXTRACT_16BITS(tptr);
jnx_header_len += 2;
tptr +=2;
jnx_header_len += jnx_ext_len;
if (ndo->ndo_vflag > 1)
ND_PRINT((ndo, "", PCAP Extension(s) total length %u"", jnx_ext_len));
ND_TCHECK2(tptr[0], jnx_ext_len);
while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {
tlv_type = *(tptr++);
tlv_len = *(tptr++);
tlv_value = 0;
if (tlv_type == 0 || tlv_len == 0)
break;
if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)
goto trunc;
if (ndo->ndo_vflag > 1)
ND_PRINT((ndo, ""\n\t  %s Extension TLV #%u, length %u, value "",
tok2str(jnx_ext_tlv_values,""Unknown"",tlv_type),
tlv_type,
tlv_len));
tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);
switch (tlv_type) {
case JUNIPER_EXT_TLV_IFD_NAME:
break;
case JUNIPER_EXT_TLV_IFD_MEDIATYPE:
case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:
if (tlv_value != -1) {
if (ndo->ndo_vflag > 1)
ND_PRINT((ndo, ""%s (%u)"",
tok2str(juniper_ifmt_values, ""Unknown"", tlv_value),
tlv_value));
}
break;
case JUNIPER_EXT_TLV_IFL_ENCAPS:
case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:
if (tlv_value != -1) {
if (ndo->ndo_vflag > 1)
ND_PRINT((ndo, ""%s (%u)"",
tok2str(juniper_ifle_values, ""Unknown"", tlv_value),
tlv_value));
}
break;
case JUNIPER_EXT_TLV_IFL_IDX: 
case JUNIPER_EXT_TLV_IFL_UNIT:
case JUNIPER_EXT_TLV_IFD_IDX:
default:
if (tlv_value != -1) {
if (ndo->ndo_vflag > 1)
ND_PRINT((ndo, ""%u"", tlv_value));
}
break;
}
tptr+=tlv_len;
jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;
}
if (ndo->ndo_vflag > 1)
ND_PRINT((ndo, ""\n\t-----original packet-----\n\t""));
}
if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {
if (ndo->ndo_eflag)
ND_PRINT((ndo, ""no-L2-hdr, ""));
ND_TCHECK2(p[jnx_header_len + 4], 1);
if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,
l2info->length - (jnx_header_len + 4)) == 0)
ND_PRINT((ndo, ""no IP-hdr found!""));
l2info->header_len=jnx_header_len+4;
return 0; 
}
l2info->header_len = jnx_header_len;
p+=l2info->header_len;
l2info->length -= l2info->header_len;
l2info->caplen -= l2info->header_len;
while (lp->s != NULL) {
if (lp->pictype == l2info->pictype) {
l2info->cookie_len += lp->cookie_len;
switch (p[0]) {
case LS_COOKIE_ID:
l2info->cookie_type = LS_COOKIE_ID;
l2info->cookie_len += 2;
break;
case AS_COOKIE_ID:
l2info->cookie_type = AS_COOKIE_ID;
l2info->cookie_len = 8;
break;
default:
l2info->bundle = l2info->cookie[0];
break;
}
#ifdef DLT_JUNIPER_MFR
if (l2info->pictype == DLT_JUNIPER_MFR &&
(p[0] & MFR_BE_MASK) == MFR_BE_MASK) {
l2info->cookie_len = 0;
}
#endif
l2info->header_len += l2info->cookie_len;
l2info->length -= l2info->cookie_len;
l2info->caplen -= l2info->cookie_len;
if (ndo->ndo_eflag)
ND_PRINT((ndo, ""%s-PIC, cookie-len %u"",
lp->s,
l2info->cookie_len));
if (l2info->cookie_len > 0) {
ND_TCHECK2(p[0], l2info->cookie_len);
if (ndo->ndo_eflag)
ND_PRINT((ndo, "", cookie 0x""));
for (idx = 0; idx < l2info->cookie_len; idx++) {
l2info->cookie[idx] = p[idx]; 
if (ndo->ndo_eflag) ND_PRINT((ndo, ""%02x"", p[idx]));
}
}
if (ndo->ndo_eflag) ND_PRINT((ndo, "": "")); 
l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);
break;
}
++lp;
}
p+=l2info->cookie_len;
switch(l2info->pictype) {
#ifdef DLT_JUNIPER_MLPPP
case DLT_JUNIPER_MLPPP:
switch (l2info->cookie_type) {
case LS_COOKIE_ID:
l2info->bundle = l2info->cookie[1];
break;
case AS_COOKIE_ID:
l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
break;
default:
l2info->bundle = l2info->cookie[0];
break;
}
break;
#endif
#ifdef DLT_JUNIPER_MLFR
case DLT_JUNIPER_MLFR:
switch (l2info->cookie_type) {
case LS_COOKIE_ID:
l2info->bundle = l2info->cookie[1];
l2info->proto = EXTRACT_16BITS(p);
l2info->header_len += 2;
l2info->length -= 2;
l2info->caplen -= 2;
break;
case AS_COOKIE_ID:
l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
break;
default:
l2info->bundle = l2info->cookie[0];
l2info->header_len += 2;
l2info->length -= 2;
l2info->caplen -= 2;
break;
}
break;
#endif
#ifdef DLT_JUNIPER_MFR
case DLT_JUNIPER_MFR:
switch (l2info->cookie_type) {
case LS_COOKIE_ID:
l2info->bundle = l2info->cookie[1];
l2info->proto = EXTRACT_16BITS(p);
l2info->header_len += 2;
l2info->length -= 2;
l2info->caplen -= 2;
break;
case AS_COOKIE_ID:
l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
break;
default:
l2info->bundle = l2info->cookie[0];
break;
}
break;
#endif
#ifdef DLT_JUNIPER_ATM2
case DLT_JUNIPER_ATM2:
ND_TCHECK2(p[0], 4);
if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {
control_word = EXTRACT_32BITS(p);
switch(control_word) {
case 0: 
case 0x08000000: 
case 0x08380000: 
l2info->header_len += 4;
break;
default:
break;
}
if (ndo->ndo_eflag)
ND_PRINT((ndo, ""control-word 0x%08x "", control_word));
}
break;
#endif
#ifdef DLT_JUNIPER_GGSN
case DLT_JUNIPER_GGSN:
break;
#endif
#ifdef DLT_JUNIPER_ATM1
case DLT_JUNIPER_ATM1:
break;
#endif
#ifdef DLT_JUNIPER_PPP
case DLT_JUNIPER_PPP:
break;
#endif
#ifdef DLT_JUNIPER_CHDLC
case DLT_JUNIPER_CHDLC:
break;
#endif
#ifdef DLT_JUNIPER_ETHER
case DLT_JUNIPER_ETHER:
break;
#endif
#ifdef DLT_JUNIPER_FRELAY
case DLT_JUNIPER_FRELAY:
break;
#endif
default:
ND_PRINT((ndo, ""Unknown Juniper DLT_ type %u: "", l2info->pictype));
break;
}
if (ndo->ndo_eflag > 1)
ND_PRINT((ndo, ""hlen %u, proto 0x%04x, "", l2info->header_len, l2info->proto));
return 1; 
trunc:
ND_PRINT((ndo, ""[|juniper_hdr], length %u"", h->len));
return 0;
}","static int
juniper_parse_header(netdissect_options *VAR_0,
const u_char *VAR_1, const struct pcap_pkthdr *VAR_2, struct juniper_l2info_t *VAR_3)
{
const struct juniper_cookie_table_t *VAR_4 = VAR_5;
u_int VAR_6, VAR_7, VAR_8 = 0;
uint8_t VAR_9,VAR_10;
uint32_t VAR_11;
int VAR_12;
const u_char *VAR_13;
VAR_3->header_len = 0;
VAR_3->cookie_len = 0;
VAR_3->proto = 0;
VAR_3->length = VAR_2->len;
VAR_3->caplen = VAR_2->caplen;
ND_TCHECK2(VAR_1[0], 4);
VAR_3->flags = VAR_1[3];
VAR_3->direction = VAR_1[3]&VAR_14;
if (EXTRACT_24BITS(VAR_1) != VAR_15) { 
ND_PRINT((VAR_0, ""no magic-number found!""));
return 0;
}
if (VAR_0->ndo_eflag) 
ND_PRINT((VAR_0, ""%3s "", tok2str(VAR_16, ""---"", VAR_3->direction)));
VAR_8 = 4;
if (VAR_0->ndo_vflag > 1)
ND_PRINT((VAR_0, ""\n\tJuniper PCAP Flags [%s]"",
bittok2str(VAR_17, ""none"", VAR_3->flags)));
if ((VAR_3->flags & VAR_18 ) == VAR_18 ) {
VAR_13 = VAR_1+VAR_8;
ND_TCHECK2(VAR_13[0], 2);
VAR_7 = EXTRACT_16BITS(VAR_13);
VAR_8 += 2;
VAR_13 +=2;
VAR_8 += VAR_7;
if (VAR_0->ndo_vflag > 1)
ND_PRINT((VAR_0, "", PCAP Extension(s) total length %u"", VAR_7));
ND_TCHECK2(VAR_13[0], VAR_7);
while (VAR_7 > VAR_19) {
VAR_9 = *(VAR_13++);
VAR_10 = *(VAR_13++);
VAR_12 = 0;
if (VAR_9 == 0 || VAR_10 == 0)
break;
if (VAR_10+VAR_19 > VAR_7)
goto trunc;
if (VAR_0->ndo_vflag > 1)
ND_PRINT((VAR_0, ""\n\t  %s Extension TLV #%u, length %u, value "",
tok2str(VAR_20,""Unknown"",VAR_9),
VAR_9,
VAR_10));
VAR_12 = juniper_read_tlv_value(VAR_13, VAR_9, VAR_10);
switch (VAR_9) {
case VAR_21:
break;
case VAR_22:
case VAR_23:
if (VAR_12 != -1) {
if (VAR_0->ndo_vflag > 1)
ND_PRINT((VAR_0, ""%s (%u)"",
tok2str(VAR_24, ""Unknown"", VAR_12),
VAR_12));
}
break;
case VAR_25:
case VAR_26:
if (VAR_12 != -1) {
if (VAR_0->ndo_vflag > 1)
ND_PRINT((VAR_0, ""%s (%u)"",
tok2str(VAR_27, ""Unknown"", VAR_12),
VAR_12));
}
break;
case VAR_28: 
case VAR_29:
case VAR_30:
default:
if (VAR_12 != -1) {
if (VAR_0->ndo_vflag > 1)
ND_PRINT((VAR_0, ""%u"", VAR_12));
}
break;
}
VAR_13+=VAR_10;
VAR_7 -= VAR_10+VAR_19;
}
if (VAR_0->ndo_vflag > 1)
ND_PRINT((VAR_0, ""\n\t-----original packet-----\n\t""));
}
if ((VAR_3->flags & VAR_31 ) == VAR_31 ) {
if (VAR_0->ndo_eflag)
ND_PRINT((VAR_0, ""no-L2-hdr, ""));
ND_TCHECK2(VAR_1[VAR_8 + 4], 1);
if (ip_heuristic_guess(VAR_0, VAR_1 + VAR_8 + 4,
VAR_3->length - (VAR_8 + 4)) == 0)
ND_PRINT((VAR_0, ""no IP-hdr found!""));
VAR_3->header_len=VAR_8+4;
return 0; 
}
VAR_3->header_len = VAR_8;
VAR_1+=VAR_3->header_len;
VAR_3->length -= VAR_3->header_len;
VAR_3->caplen -= VAR_3->header_len;
while (VAR_4->s != NULL) {
if (VAR_4->pictype == VAR_3->pictype) {
VAR_3->cookie_len += VAR_4->cookie_len;
switch (VAR_1[0]) {
case VAR_32:
VAR_3->cookie_type = VAR_32;
VAR_3->cookie_len += 2;
break;
case VAR_33:
VAR_3->cookie_type = VAR_33;
VAR_3->cookie_len = 8;
break;
default:
VAR_3->bundle = VAR_3->cookie[0];
break;
}
#ifdef VAR_34
if (VAR_3->pictype == VAR_34 &&
(VAR_1[0] & VAR_35) == VAR_35) {
VAR_3->cookie_len = 0;
}
#endif
VAR_3->header_len += VAR_3->cookie_len;
VAR_3->length -= VAR_3->cookie_len;
VAR_3->caplen -= VAR_3->cookie_len;
if (VAR_0->ndo_eflag)
ND_PRINT((VAR_0, ""%s-PIC, cookie-len %u"",
VAR_4->s,
VAR_3->cookie_len));
if (VAR_3->cookie_len > 0) {
ND_TCHECK2(VAR_1[0], VAR_3->cookie_len);
if (VAR_0->ndo_eflag)
ND_PRINT((VAR_0, "", cookie 0x""));
for (VAR_6 = 0; VAR_6 < VAR_3->cookie_len; VAR_6++) {
VAR_3->cookie[VAR_6] = VAR_1[VAR_6]; 
if (VAR_0->ndo_eflag) ND_PRINT((VAR_0, ""%02x"", VAR_1[VAR_6]));
}
}
if (VAR_0->ndo_eflag) ND_PRINT((VAR_0, "": "")); 
VAR_3->proto = EXTRACT_16BITS(VAR_1+VAR_3->cookie_len);
break;
}
++VAR_4;
}
VAR_1+=VAR_3->cookie_len;
switch(VAR_3->pictype) {
#ifdef VAR_36
case VAR_36:
switch (VAR_3->cookie_type) {
case VAR_32:
VAR_3->bundle = VAR_3->cookie[1];
break;
case VAR_33:
VAR_3->bundle = (EXTRACT_16BITS(&VAR_3->cookie[6])>>3)&0xfff;
VAR_3->proto = (VAR_3->cookie[5])&VAR_37;
break;
default:
VAR_3->bundle = VAR_3->cookie[0];
break;
}
break;
#endif
#ifdef VAR_38
case VAR_38:
switch (VAR_3->cookie_type) {
case VAR_32:
VAR_3->bundle = VAR_3->cookie[1];
VAR_3->proto = EXTRACT_16BITS(VAR_1);
VAR_3->header_len += 2;
VAR_3->length -= 2;
VAR_3->caplen -= 2;
break;
case VAR_33:
VAR_3->bundle = (EXTRACT_16BITS(&VAR_3->cookie[6])>>3)&0xfff;
VAR_3->proto = (VAR_3->cookie[5])&VAR_37;
break;
default:
VAR_3->bundle = VAR_3->cookie[0];
VAR_3->header_len += 2;
VAR_3->length -= 2;
VAR_3->caplen -= 2;
break;
}
break;
#endif
#ifdef VAR_34
case VAR_34:
switch (VAR_3->cookie_type) {
case VAR_32:
VAR_3->bundle = VAR_3->cookie[1];
VAR_3->proto = EXTRACT_16BITS(VAR_1);
VAR_3->header_len += 2;
VAR_3->length -= 2;
VAR_3->caplen -= 2;
break;
case VAR_33:
VAR_3->bundle = (EXTRACT_16BITS(&VAR_3->cookie[6])>>3)&0xfff;
VAR_3->proto = (VAR_3->cookie[5])&VAR_37;
break;
default:
VAR_3->bundle = VAR_3->cookie[0];
break;
}
break;
#endif
#ifdef VAR_39
case VAR_39:
ND_TCHECK2(VAR_1[0], 4);
if (VAR_3->cookie[7] & VAR_40) {
VAR_11 = EXTRACT_32BITS(VAR_1);
switch(VAR_11) {
case 0: 
case 0x08000000: 
case 0x08380000: 
VAR_3->header_len += 4;
break;
default:
break;
}
if (VAR_0->ndo_eflag)
ND_PRINT((VAR_0, ""control-word 0x%08x "", VAR_11));
}
break;
#endif
#ifdef VAR_41
case VAR_41:
break;
#endif
#ifdef VAR_42
case VAR_42:
break;
#endif
#ifdef VAR_43
case VAR_43:
break;
#endif
#ifdef VAR_44
case VAR_44:
break;
#endif
#ifdef VAR_45
case VAR_45:
break;
#endif
#ifdef VAR_46
case VAR_46:
break;
#endif
default:
ND_PRINT((VAR_0, ""Unknown Juniper DLT_ type %u: "", VAR_3->pictype));
break;
}
if (VAR_0->ndo_eflag > 1)
ND_PRINT((VAR_0, ""hlen %u, proto 0x%04x, "", VAR_3->header_len, VAR_3->proto));
return 1; 
trunc:
ND_PRINT((VAR_0, ""[|juniper_hdr], length %u"", VAR_2->len));
return 0;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/7.json,"static int
juniper_parse_header(netdissect_options *ndo,
                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)
{
    const struct juniper_cookie_table_t *lp = juniper_cookie_table;
    u_int idx, jnx_ext_len, jnx_header_len = 0;
    uint8_t tlv_type,tlv_len;
    uint32_t control_word;
    int tlv_value;
    const u_char *tptr;


    l2info->header_len = 0;
    l2info->cookie_len = 0;
    l2info->proto = 0;


    l2info->length = h->len;
    l2info->caplen = h->caplen;
    ND_TCHECK2(p[0], 4);
    l2info->flags = p[3];
    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;

    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */
        ND_PRINT((ndo, ""no magic-number found!""));
        return 0;
    }

    if (ndo->ndo_eflag) /* print direction */
        ND_PRINT((ndo, ""%3s "", tok2str(juniper_direction_values, ""---"", l2info->direction)));

    /* magic number + flags */
    jnx_header_len = 4;

    if (ndo->ndo_vflag > 1)
        ND_PRINT((ndo, ""\n\tJuniper PCAP Flags [%s]"",
               bittok2str(jnx_flag_values, ""none"", l2info->flags)));

    /* extensions present ?  - calculate how much bytes to skip */
    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {

        tptr = p+jnx_header_len;

        /* ok to read extension length ? */
        ND_TCHECK2(tptr[0], 2);
        jnx_ext_len = EXTRACT_16BITS(tptr);
        jnx_header_len += 2;
        tptr +=2;

        /* nail up the total length -
         * just in case something goes wrong
         * with TLV parsing */
        jnx_header_len += jnx_ext_len;

        if (ndo->ndo_vflag > 1)
            ND_PRINT((ndo, "", PCAP Extension(s) total length %u"", jnx_ext_len));

        ND_TCHECK2(tptr[0], jnx_ext_len);
        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {
            tlv_type = *(tptr++);
            tlv_len = *(tptr++);
            tlv_value = 0;

            /* sanity checks */
            if (tlv_type == 0 || tlv_len == 0)
                break;
            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)
                goto trunc;

            if (ndo->ndo_vflag > 1)
                ND_PRINT((ndo, ""\n\t  %s Extension TLV #%u, length %u, value "",
                       tok2str(jnx_ext_tlv_values,""Unknown"",tlv_type),
                       tlv_type,
                       tlv_len));

            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);
            switch (tlv_type) {
            case JUNIPER_EXT_TLV_IFD_NAME:
                /* FIXME */
                break;
            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:
            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:
                if (tlv_value != -1) {
                    if (ndo->ndo_vflag > 1)
                        ND_PRINT((ndo, ""%s (%u)"",
                               tok2str(juniper_ifmt_values, ""Unknown"", tlv_value),
                               tlv_value));
                }
                break;
            case JUNIPER_EXT_TLV_IFL_ENCAPS:
            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:
                if (tlv_value != -1) {
                    if (ndo->ndo_vflag > 1)
                        ND_PRINT((ndo, ""%s (%u)"",
                               tok2str(juniper_ifle_values, ""Unknown"", tlv_value),
                               tlv_value));
                }
                break;
            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */
            case JUNIPER_EXT_TLV_IFL_UNIT:
            case JUNIPER_EXT_TLV_IFD_IDX:
            default:
                if (tlv_value != -1) {
                    if (ndo->ndo_vflag > 1)
                        ND_PRINT((ndo, ""%u"", tlv_value));
                }
                break;
            }

            tptr+=tlv_len;
            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;
        }

        if (ndo->ndo_vflag > 1)
            ND_PRINT((ndo, ""\n\t-----original packet-----\n\t""));
    }

    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {
        if (ndo->ndo_eflag)
            ND_PRINT((ndo, ""no-L2-hdr, ""));

        /* there is no link-layer present -
         * perform the v4/v6 heuristics
         * to figure out what it is
         */
        ND_TCHECK2(p[jnx_header_len + 4], 1);
        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,
                               l2info->length - (jnx_header_len + 4)) == 0)
            ND_PRINT((ndo, ""no IP-hdr found!""));

        l2info->header_len=jnx_header_len+4;
        return 0; /* stop parsing the output further */

    }
    l2info->header_len = jnx_header_len;
    p+=l2info->header_len;
    l2info->length -= l2info->header_len;
    l2info->caplen -= l2info->header_len;

    /* search through the cookie table and copy values matching for our PIC type */
    ND_TCHECK(p[0]);
    while (lp->s != NULL) {
        if (lp->pictype == l2info->pictype) {

            l2info->cookie_len += lp->cookie_len;

            switch (p[0]) {
            case LS_COOKIE_ID:
                l2info->cookie_type = LS_COOKIE_ID;
                l2info->cookie_len += 2;
                break;
            case AS_COOKIE_ID:
                l2info->cookie_type = AS_COOKIE_ID;
                l2info->cookie_len = 8;
                break;

            default:
                l2info->bundle = l2info->cookie[0];
                break;
            }


#ifdef DLT_JUNIPER_MFR
            /* MFR child links don't carry cookies */
            if (l2info->pictype == DLT_JUNIPER_MFR &&
                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {
                l2info->cookie_len = 0;
            }
#endif

            l2info->header_len += l2info->cookie_len;
            l2info->length -= l2info->cookie_len;
            l2info->caplen -= l2info->cookie_len;

            if (ndo->ndo_eflag)
                ND_PRINT((ndo, ""%s-PIC, cookie-len %u"",
                       lp->s,
                       l2info->cookie_len));

            if (l2info->cookie_len > 0) {
                ND_TCHECK2(p[0], l2info->cookie_len);
                if (ndo->ndo_eflag)
                    ND_PRINT((ndo, "", cookie 0x""));
                for (idx = 0; idx < l2info->cookie_len; idx++) {
                    l2info->cookie[idx] = p[idx]; /* copy cookie data */
                    if (ndo->ndo_eflag) ND_PRINT((ndo, ""%02x"", p[idx]));
                }
            }

            if (ndo->ndo_eflag) ND_PRINT((ndo, "": "")); /* print demarc b/w L2/L3*/


            l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);
            break;
        }
        ++lp;
    }
    p+=l2info->cookie_len;

    /* DLT_ specific parsing */
    switch(l2info->pictype) {
#ifdef DLT_JUNIPER_MLPPP
    case DLT_JUNIPER_MLPPP:
        switch (l2info->cookie_type) {
        case LS_COOKIE_ID:
            l2info->bundle = l2info->cookie[1];
            break;
        case AS_COOKIE_ID:
            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
            break;
        default:
            l2info->bundle = l2info->cookie[0];
            break;
        }
        break;
#endif
#ifdef DLT_JUNIPER_MLFR
    case DLT_JUNIPER_MLFR:
        switch (l2info->cookie_type) {
        case LS_COOKIE_ID:
            ND_TCHECK2(p[0], 2);
            l2info->bundle = l2info->cookie[1];
            l2info->proto = EXTRACT_16BITS(p);
            l2info->header_len += 2;
            l2info->length -= 2;
            l2info->caplen -= 2;
            break;
        case AS_COOKIE_ID:
            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
            break;
        default:
            l2info->bundle = l2info->cookie[0];
            l2info->header_len += 2;
            l2info->length -= 2;
            l2info->caplen -= 2;
            break;
        }
        break;
#endif
#ifdef DLT_JUNIPER_MFR
    case DLT_JUNIPER_MFR:
        switch (l2info->cookie_type) {
        case LS_COOKIE_ID:
            ND_TCHECK2(p[0], 2);
            l2info->bundle = l2info->cookie[1];
            l2info->proto = EXTRACT_16BITS(p);
            l2info->header_len += 2;
            l2info->length -= 2;
            l2info->caplen -= 2;
            break;
        case AS_COOKIE_ID:
            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;
            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;
            break;
        default:
            l2info->bundle = l2info->cookie[0];
            break;
        }
        break;
#endif
#ifdef DLT_JUNIPER_ATM2
    case DLT_JUNIPER_ATM2:
        ND_TCHECK2(p[0], 4);
        /* ATM cell relay control word present ? */
        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {
            control_word = EXTRACT_32BITS(p);
            /* some control word heuristics */
            switch(control_word) {
            case 0: /* zero control word */
            case 0x08000000: /* < JUNOS 7.4 control-word */
            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/
                l2info->header_len += 4;
                break;
            default:
                break;
            }

            if (ndo->ndo_eflag)
                ND_PRINT((ndo, ""control-word 0x%08x "", control_word));
        }
        break;
#endif
#ifdef DLT_JUNIPER_GGSN
    case DLT_JUNIPER_GGSN:
        break;
#endif
#ifdef DLT_JUNIPER_ATM1
    case DLT_JUNIPER_ATM1:
        break;
#endif
#ifdef DLT_JUNIPER_PPP
    case DLT_JUNIPER_PPP:
        break;
#endif
#ifdef DLT_JUNIPER_CHDLC
    case DLT_JUNIPER_CHDLC:
        break;
#endif
#ifdef DLT_JUNIPER_ETHER
    case DLT_JUNIPER_ETHER:
        break;
#endif
#ifdef DLT_JUNIPER_FRELAY
    case DLT_JUNIPER_FRELAY:
        break;
#endif

    default:
        ND_PRINT((ndo, ""Unknown Juniper DLT_ type %u: "", l2info->pictype));
        break;
    }

    if (ndo->ndo_eflag > 1)
        ND_PRINT((ndo, ""hlen %u, proto 0x%04x, "", l2info->header_len, l2info->proto));

    return 1; /* everything went ok so far. continue parsing */
 trunc:
    ND_PRINT((ndo, ""[|juniper_hdr], length %u"", h->len));
    return 0;
}","static int
juniper_parse_header(netdissect_options *VAR_0,
                     const u_char *VAR_1, const struct pcap_pkthdr *VAR_2, struct juniper_l2info_t *VAR_3)
{
    const struct juniper_cookie_table_t *VAR_4 = VAR_5;
    u_int VAR_6, VAR_7, VAR_8 = 0;
    uint8_t VAR_9,VAR_10;
    uint32_t VAR_11;
    int VAR_12;
    const u_char *VAR_13;


    VAR_3->header_len = 0;
    VAR_3->cookie_len = 0;
    VAR_3->proto = 0;


    VAR_3->length = VAR_2->len;
    VAR_3->caplen = VAR_2->caplen;
    ND_TCHECK2(VAR_1[0], 4);
    VAR_3->flags = VAR_1[3];
    VAR_3->direction = VAR_1[3]&VAR_14;

    if (EXTRACT_24BITS(VAR_1) != VAR_15) { /* COMMENT_0 */
        ND_PRINT((VAR_0, ""no magic-number found!""));
        return 0;
    }

    if (VAR_0->ndo_eflag) /* COMMENT_1 */
        ND_PRINT((VAR_0, ""%3s "", tok2str(VAR_16, ""---"", VAR_3->direction)));

    /* COMMENT_2 */
    VAR_8 = 4;

    if (VAR_0->ndo_vflag > 1)
        ND_PRINT((VAR_0, ""\n\tJuniper PCAP Flags [%s]"",
               bittok2str(VAR_17, ""none"", VAR_3->flags)));

    /* COMMENT_3 */
    if ((VAR_3->flags & VAR_18 ) == VAR_18 ) {

        VAR_13 = VAR_1+VAR_8;

        /* COMMENT_4 */
        ND_TCHECK2(VAR_13[0], 2);
        VAR_7 = EXTRACT_16BITS(VAR_13);
        VAR_8 += 2;
        VAR_13 +=2;

        /* COMMENT_5 */
                                            
                              
        VAR_8 += VAR_7;

        if (VAR_0->ndo_vflag > 1)
            ND_PRINT((VAR_0, "", PCAP Extension(s) total length %u"", VAR_7));

        ND_TCHECK2(VAR_13[0], VAR_7);
        while (VAR_7 > VAR_19) {
            VAR_9 = *(VAR_13++);
            VAR_10 = *(VAR_13++);
            VAR_12 = 0;

            /* COMMENT_8 */
            if (VAR_9 == 0 || VAR_10 == 0)
                break;
            if (VAR_10+VAR_19 > VAR_7)
                goto trunc;

            if (VAR_0->ndo_vflag > 1)
                ND_PRINT((VAR_0, ""\n\t  %s Extension TLV #%u, length %u, value "",
                       tok2str(VAR_20,""Unknown"",VAR_9),
                       VAR_9,
                       VAR_10));

            VAR_12 = juniper_read_tlv_value(VAR_13, VAR_9, VAR_10);
            switch (VAR_9) {
            case VAR_21:
                /* COMMENT_9 */
                break;
            case VAR_22:
            case VAR_23:
                if (VAR_12 != -1) {
                    if (VAR_0->ndo_vflag > 1)
                        ND_PRINT((VAR_0, ""%s (%u)"",
                               tok2str(VAR_24, ""Unknown"", VAR_12),
                               VAR_12));
                }
                break;
            case VAR_25:
            case VAR_26:
                if (VAR_12 != -1) {
                    if (VAR_0->ndo_vflag > 1)
                        ND_PRINT((VAR_0, ""%s (%u)"",
                               tok2str(VAR_27, ""Unknown"", VAR_12),
                               VAR_12));
                }
                break;
            case VAR_28: /* COMMENT_10 */
            case VAR_29:
            case VAR_30:
            default:
                if (VAR_12 != -1) {
                    if (VAR_0->ndo_vflag > 1)
                        ND_PRINT((VAR_0, ""%u"", VAR_12));
                }
                break;
            }

            VAR_13+=VAR_10;
            VAR_7 -= VAR_10+VAR_19;
        }

        if (VAR_0->ndo_vflag > 1)
            ND_PRINT((VAR_0, ""\n\t-----original packet-----\n\t""));
    }

    if ((VAR_3->flags & VAR_31 ) == VAR_31 ) {
        if (VAR_0->ndo_eflag)
            ND_PRINT((VAR_0, ""no-L2-hdr, ""));

        /* COMMENT_11 */
                                       
                                   
           
        ND_TCHECK2(VAR_1[VAR_8 + 4], 1);
        if (ip_heuristic_guess(VAR_0, VAR_1 + VAR_8 + 4,
                               VAR_3->length - (VAR_8 + 4)) == 0)
            ND_PRINT((VAR_0, ""no IP-hdr found!""));

        VAR_3->header_len=VAR_8+4;
        return 0; /* COMMENT_15 */

    }
    VAR_3->header_len = VAR_8;
    VAR_1+=VAR_3->header_len;
    VAR_3->length -= VAR_3->header_len;
    VAR_3->caplen -= VAR_3->header_len;

    /* COMMENT_16 */
    ND_TCHECK(VAR_1[0]);
    while (VAR_4->s != NULL) {
        if (VAR_4->pictype == VAR_3->pictype) {

            VAR_3->cookie_len += VAR_4->cookie_len;

            switch (VAR_1[0]) {
            case VAR_32:
                VAR_3->cookie_type = VAR_32;
                VAR_3->cookie_len += 2;
                break;
            case VAR_33:
                VAR_3->cookie_type = VAR_33;
                VAR_3->cookie_len = 8;
                break;

            default:
                VAR_3->bundle = VAR_3->cookie[0];
                break;
            }


#ifdef VAR_34
            /* COMMENT_17 */
            if (VAR_3->pictype == VAR_34 &&
                (VAR_1[0] & VAR_35) == VAR_35) {
                VAR_3->cookie_len = 0;
            }
#endif

            VAR_3->header_len += VAR_3->cookie_len;
            VAR_3->length -= VAR_3->cookie_len;
            VAR_3->caplen -= VAR_3->cookie_len;

            if (VAR_0->ndo_eflag)
                ND_PRINT((VAR_0, ""%s-PIC, cookie-len %u"",
                       VAR_4->s,
                       VAR_3->cookie_len));

            if (VAR_3->cookie_len > 0) {
                ND_TCHECK2(VAR_1[0], VAR_3->cookie_len);
                if (VAR_0->ndo_eflag)
                    ND_PRINT((VAR_0, "", cookie 0x""));
                for (VAR_6 = 0; VAR_6 < VAR_3->cookie_len; VAR_6++) {
                    VAR_3->cookie[VAR_6] = VAR_1[VAR_6]; /* COMMENT_18 */
                    if (VAR_0->ndo_eflag) ND_PRINT((VAR_0, ""%02x"", VAR_1[VAR_6]));
                }
            }

            if (VAR_0->ndo_eflag) ND_PRINT((VAR_0, "": "")); /* COMMENT_19 */


            VAR_3->proto = EXTRACT_16BITS(VAR_1+VAR_3->cookie_len);
            break;
        }
        ++VAR_4;
    }
    VAR_1+=VAR_3->cookie_len;

    /* COMMENT_20 */
    switch(VAR_3->pictype) {
#ifdef VAR_36
    case VAR_36:
        switch (VAR_3->cookie_type) {
        case VAR_32:
            VAR_3->bundle = VAR_3->cookie[1];
            break;
        case VAR_33:
            VAR_3->bundle = (EXTRACT_16BITS(&VAR_3->cookie[6])>>3)&0xfff;
            VAR_3->proto = (VAR_3->cookie[5])&VAR_37;
            break;
        default:
            VAR_3->bundle = VAR_3->cookie[0];
            break;
        }
        break;
#endif
#ifdef VAR_38
    case VAR_38:
        switch (VAR_3->cookie_type) {
        case VAR_32:
            ND_TCHECK2(VAR_1[0], 2);
            VAR_3->bundle = VAR_3->cookie[1];
            VAR_3->proto = EXTRACT_16BITS(VAR_1);
            VAR_3->header_len += 2;
            VAR_3->length -= 2;
            VAR_3->caplen -= 2;
            break;
        case VAR_33:
            VAR_3->bundle = (EXTRACT_16BITS(&VAR_3->cookie[6])>>3)&0xfff;
            VAR_3->proto = (VAR_3->cookie[5])&VAR_37;
            break;
        default:
            VAR_3->bundle = VAR_3->cookie[0];
            VAR_3->header_len += 2;
            VAR_3->length -= 2;
            VAR_3->caplen -= 2;
            break;
        }
        break;
#endif
#ifdef VAR_34
    case VAR_34:
        switch (VAR_3->cookie_type) {
        case VAR_32:
            ND_TCHECK2(VAR_1[0], 2);
            VAR_3->bundle = VAR_3->cookie[1];
            VAR_3->proto = EXTRACT_16BITS(VAR_1);
            VAR_3->header_len += 2;
            VAR_3->length -= 2;
            VAR_3->caplen -= 2;
            break;
        case VAR_33:
            VAR_3->bundle = (EXTRACT_16BITS(&VAR_3->cookie[6])>>3)&0xfff;
            VAR_3->proto = (VAR_3->cookie[5])&VAR_37;
            break;
        default:
            VAR_3->bundle = VAR_3->cookie[0];
            break;
        }
        break;
#endif
#ifdef VAR_39
    case VAR_39:
        ND_TCHECK2(VAR_1[0], 4);
        /* COMMENT_21 */
        if (VAR_3->cookie[7] & VAR_40) {
            VAR_11 = EXTRACT_32BITS(VAR_1);
            /* COMMENT_22 */
            switch(VAR_11) {
            case 0: /* COMMENT_23 */
            case 0x08000000: /* COMMENT_24 */
            case 0x08380000: /* COMMENT_25 */
                VAR_3->header_len += 4;
                break;
            default:
                break;
            }

            if (VAR_0->ndo_eflag)
                ND_PRINT((VAR_0, ""control-word 0x%08x "", VAR_11));
        }
        break;
#endif
#ifdef VAR_41
    case VAR_41:
        break;
#endif
#ifdef VAR_42
    case VAR_42:
        break;
#endif
#ifdef VAR_43
    case VAR_43:
        break;
#endif
#ifdef VAR_44
    case VAR_44:
        break;
#endif
#ifdef VAR_45
    case VAR_45:
        break;
#endif
#ifdef VAR_46
    case VAR_46:
        break;
#endif

    default:
        ND_PRINT((VAR_0, ""Unknown Juniper DLT_ type %u: "", VAR_3->pictype));
        break;
    }

    if (VAR_0->ndo_eflag > 1)
        ND_PRINT((VAR_0, ""hlen %u, proto 0x%04x, "", VAR_3->header_len, VAR_3->proto));

    return 1; /* COMMENT_26 */
 trunc:
    ND_PRINT((VAR_0, ""[|juniper_hdr], length %u"", VAR_2->len));
    return 0;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -138,6 +138,7 @@
     l2info->caplen -= l2info->header_len;
 
     /* search through the cookie table and copy values matching for our PIC type */
+    ND_TCHECK(p[0]);
     while (lp->s != NULL) {
         if (lp->pictype == l2info->pictype) {
 
@@ -218,6 +219,7 @@
     case DLT_JUNIPER_MLFR:
         switch (l2info->cookie_type) {
         case LS_COOKIE_ID:
+            ND_TCHECK2(p[0], 2);
             l2info->bundle = l2info->cookie[1];
             l2info->proto = EXTRACT_16BITS(p);
             l2info->header_len += 2;
@@ -241,6 +243,7 @@
     case DLT_JUNIPER_MFR:
         switch (l2info->cookie_type) {
         case LS_COOKIE_ID:
+            ND_TCHECK2(p[0], 2);
             l2info->bundle = l2info->cookie[1];
             l2info->proto = EXTRACT_16BITS(p);
             l2info->header_len += 2;","{'deleted_lines': [], 'added_lines': ['    ND_TCHECK(p[0]);', '            ND_TCHECK2(p[0], 2);', '            ND_TCHECK2(p[0], 2);']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-12993,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12993/Juniper: Add more bounds checks.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add tests using the capture files supplied by the reporter(s).",b534e304568585707c4a92422aeca25cf908ff02,https://github.com/the-tcpdump-group/tcpdump/commit/b534e304568585707c4a92422aeca25cf908ff02,print-juniper.c,juniper_pppoe_atm_print,"u_int
juniper_pppoe_atm_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, register const u_char *p)
{
struct juniper_l2info_t l2info;
uint16_t extracted_ethertype;
l2info.pictype = DLT_JUNIPER_PPPOE_ATM;
if (juniper_parse_header(ndo, p, h, &l2info) == 0)
return l2info.header_len;
p+=l2info.header_len;
extracted_ethertype = EXTRACT_16BITS(p);
if (ethertype_print(ndo, extracted_ethertype,
p+ETHERTYPE_LEN,
l2info.length-ETHERTYPE_LEN,
l2info.caplen-ETHERTYPE_LEN,
NULL, NULL) == 0)
ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype));
return l2info.header_len;
}","u_int
juniper_pppoe_atm_print(netdissect_options *VAR_0,
const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
struct juniper_l2info_t VAR_3;
uint16_t VAR_4;
VAR_3.pictype = VAR_5;
if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
return VAR_3.header_len;
VAR_2+=VAR_3.header_len;
VAR_4 = EXTRACT_16BITS(VAR_2);
if (ethertype_print(VAR_0, VAR_4,
VAR_2+VAR_6,
VAR_3.length-VAR_6,
VAR_3.caplen-VAR_6,
NULL, NULL) == 0)
ND_PRINT((VAR_0, ""unknown ethertype 0x%04x"", VAR_4));
return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/before/1.json,"u_int
juniper_pppoe_atm_print(netdissect_options *ndo,
                        const struct pcap_pkthdr *h, register const u_char *p)
{
        struct juniper_l2info_t l2info;
	uint16_t extracted_ethertype;

        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;

        ND_TCHECK2(p[0], 2);
        extracted_ethertype = EXTRACT_16BITS(p);
        /* this DLT contains nothing but raw PPPoE frames,
         * prepended with a type field*/
        if (ethertype_print(ndo, extracted_ethertype,
                              p+ETHERTYPE_LEN,
                              l2info.length-ETHERTYPE_LEN,
                              l2info.caplen-ETHERTYPE_LEN,
                              NULL, NULL) == 0)
            /* ether_type not known, probably it wasn't one */
            ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype));

        return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_pppoe_atm]""));
	return l2info.header_len;
}","u_int
juniper_pppoe_atm_print(netdissect_options *VAR_0,
                        const struct pcap_pkthdr *VAR_1, register const u_char *VAR_2)
{
        struct juniper_l2info_t VAR_3;
	uint16_t VAR_4;

        VAR_3.pictype = VAR_5;
        if (juniper_parse_header(VAR_0, VAR_2, VAR_1, &VAR_3) == 0)
            return VAR_3.header_len;

        VAR_2+=VAR_3.header_len;

        ND_TCHECK2(VAR_2[0], 2);
        VAR_4 = EXTRACT_16BITS(VAR_2);
        /* COMMENT_0 */
                                        
        if (ethertype_print(VAR_0, VAR_4,
                              VAR_2+VAR_6,
                              VAR_3.length-VAR_6,
                              VAR_3.caplen-VAR_6,
                              NULL, NULL) == 0)
            /* COMMENT_2 */
            ND_PRINT((VAR_0, ""unknown ethertype 0x%04x"", VAR_4));

        return VAR_3.header_len;

trunc:
	ND_PRINT((VAR_0, ""[|juniper_pppoe_atm]""));
	return VAR_3.header_len;
}",the-tcpdump-group/tcpdump/b534e304568585707c4a92422aeca25cf908ff02/print-juniper.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -11,6 +11,7 @@
 
         p+=l2info.header_len;
 
+        ND_TCHECK2(p[0], 2);
         extracted_ethertype = EXTRACT_16BITS(p);
         /* this DLT contains nothing but raw PPPoE frames,
          * prepended with a type field*/
@@ -23,4 +24,8 @@
             ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype));
 
         return l2info.header_len;
+
+trunc:
+	ND_PRINT((ndo, ""[|juniper_pppoe_atm]""));
+	return l2info.header_len;
 }","{'deleted_lines': [], 'added_lines': ['        ND_TCHECK2(p[0], 2);', '', 'trunc:', '\tND_PRINT((ndo, ""[|juniper_pppoe_atm]""));', '\treturn l2info.header_len;']}",True,"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",9.8,CRITICAL,3,valid,2017-02-07T18:33:07Z,1
CVE-2017-6497,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Added missing null check.,7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94,https://github.com/ImageMagick/ImageMagick/commit/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94,coders/psd.c,ReadPSDChannel,"static MagickBooleanType ReadPSDChannel(Image *image,
const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
const size_t channel,const PSDCompressionType compression,
ExceptionInfo *exception)
{
Image
*channel_image,
*mask;
MagickOffsetType
offset;
MagickBooleanType
status;
channel_image=image;
mask=(Image *) NULL;
if (layer_info->channel_info[channel].type < -1)
{
const char
*option;
option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
if ((layer_info->channel_info[channel].type != -2) ||
(layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
(IsStringTrue(option) == MagickFalse)))
{
SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
return(MagickTrue);
}
mask=CloneImage(image,layer_info->mask.page.width,
layer_info->mask.page.height,MagickFalse,exception);
mask->matte=MagickFalse;
channel_image=mask;
}
offset=TellBlob(image);
status=MagickTrue;
switch(compression)
{
case Raw:
status=ReadPSDChannelRaw(channel_image,psd_info->channels,
layer_info->channel_info[channel].type,exception);
break;
case RLE:
{
MagickOffsetType
*sizes;
sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
if (sizes == (MagickOffsetType *) NULL)
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
status=ReadPSDChannelRLE(channel_image,psd_info,
layer_info->channel_info[channel].type,sizes,exception);
sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
}
break;
case ZipWithPrediction:
case ZipWithoutPrediction:
#ifdef MAGICKCORE_ZLIB_DELEGATE
status=ReadPSDChannelZip(channel_image,layer_info->channels,
layer_info->channel_info[channel].type,compression,
layer_info->channel_info[channel].size-2,exception);
#else
(void) ThrowMagickException(exception,GetMagickModule(),
MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
""'%s' (ZLIB)"",image->filename);
#endif
break;
default:
(void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
""CompressionNotSupported"",""'%.20g'"",(double) compression);
break;
}
SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
if (status == MagickFalse)
{
if (mask != (Image *) NULL)
DestroyImage(mask);
ThrowBinaryException(CoderError,""UnableToDecompressImage"",
image->filename);
}
layer_info->mask.image=mask;
return(status);
}","static MagickBooleanType ReadPSDChannel(Image *VAR_0,
const ImageInfo *VAR_1,const PSDInfo *VAR_2,LayerInfo* VAR_3,
const size_t VAR_4,const PSDCompressionType VAR_5,
ExceptionInfo *VAR_6)
{
Image
*VAR_7,
*VAR_8;
MagickOffsetType
VAR_9;
MagickBooleanType
VAR_10;
VAR_7=VAR_0;
VAR_8=(Image *) NULL;
if (VAR_3->channel_info[VAR_4].type < -1)
{
const char
*VAR_11;
VAR_11=GetImageOption(VAR_1,""psd:preserve-opacity-mask"");
if ((VAR_3->channel_info[VAR_4].type != -2) ||
(VAR_3->mask.flags > 2) || ((VAR_3->mask.flags & 0x02) &&
(IsStringTrue(VAR_11) == VAR_12)))
{
SeekBlob(VAR_0,VAR_3->channel_info[VAR_4].size-2,VAR_13);
return(VAR_14);
}
VAR_8=CloneImage(VAR_0,VAR_3->mask.page.width,
VAR_3->mask.page.height,VAR_12,VAR_6);
VAR_8->matte=VAR_12;
VAR_7=VAR_8;
}
VAR_9=TellBlob(VAR_0);
VAR_10=VAR_14;
switch(VAR_5)
{
case VAR_15:
VAR_10=ReadPSDChannelRaw(VAR_7,VAR_2->channels,
VAR_3->channel_info[VAR_4].type,VAR_6);
break;
case VAR_16:
{
MagickOffsetType
*VAR_17;
VAR_17=ReadPSDRLESizes(VAR_7,VAR_2,VAR_7->rows);
if (VAR_17 == (MagickOffsetType *) NULL)
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_0->filename);
VAR_10=ReadPSDChannelRLE(VAR_7,VAR_2,
VAR_3->channel_info[VAR_4].type,VAR_17,VAR_6);
VAR_17=(MagickOffsetType *) RelinquishMagickMemory(VAR_17);
}
break;
case VAR_19:
case VAR_20:
#ifdef VAR_21
VAR_10=ReadPSDChannelZip(VAR_7,VAR_3->channels,
VAR_3->channel_info[VAR_4].type,VAR_5,
VAR_3->channel_info[VAR_4].size-2,VAR_6);
#else
(void) ThrowMagickException(VAR_6,GetMagickModule(),
VAR_22,""DelegateLibrarySupportNotBuiltIn"",
""'%s' (ZLIB)"",VAR_0->filename);
#endif
break;
default:
(void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_23,
""CompressionNotSupported"",""'%.20g'"",(double) VAR_5);
break;
}
SeekBlob(VAR_0,VAR_9+VAR_3->channel_info[VAR_4].size-2,VAR_24);
if (VAR_10 == VAR_12)
{
if (VAR_8 != (Image *) NULL)
DestroyImage(VAR_8);
ThrowBinaryException(VAR_25,""UnableToDecompressImage"",
VAR_0->filename);
}
VAR_3->mask.image=VAR_8;
return(VAR_10);
}",ImageMagick/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94/psd.c/vul/before/0.json,"static MagickBooleanType ReadPSDChannel(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
  const size_t channel,const PSDCompressionType compression,
  ExceptionInfo *exception)
{
  Image
    *channel_image,
    *mask;

  MagickOffsetType
    offset;

  MagickBooleanType
    status;

  channel_image=image;
  mask=(Image *) NULL;
  if (layer_info->channel_info[channel].type < -1)
    {
      const char
        *option;
      /*
        Ignore mask that is not a user supplied layer mask, if the mask is
        disabled or if the flags have unsupported values.
      */
      option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
      if ((layer_info->channel_info[channel].type != -2) ||
          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
           (IsStringTrue(option) == MagickFalse)))
      {
        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
        return(MagickTrue);
      }
      mask=CloneImage(image,layer_info->mask.page.width,
        layer_info->mask.page.height,MagickFalse,exception);
      if (mask != (Image *) NULL)
        {
          mask->matte=MagickFalse;
          channel_image=mask;
        }
    }

  offset=TellBlob(image);
  status=MagickTrue;
  switch(compression)
  {
    case Raw:
      status=ReadPSDChannelRaw(channel_image,psd_info->channels,
        layer_info->channel_info[channel].type,exception);
      break;
    case RLE:
      {
        MagickOffsetType
          *sizes;

        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
        if (sizes == (MagickOffsetType *) NULL)
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        status=ReadPSDChannelRLE(channel_image,psd_info,
          layer_info->channel_info[channel].type,sizes,exception);
        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
      }
      break;
    case ZipWithPrediction:
    case ZipWithoutPrediction:
#ifdef MAGICKCORE_ZLIB_DELEGATE
      status=ReadPSDChannelZip(channel_image,layer_info->channels,
        layer_info->channel_info[channel].type,compression,
        layer_info->channel_info[channel].size-2,exception);
#else
      (void) ThrowMagickException(exception,GetMagickModule(),
          MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
            ""'%s' (ZLIB)"",image->filename);
#endif
      break;
    default:
      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
        ""CompressionNotSupported"",""'%.20g'"",(double) compression);
      break;
  }

  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
  if (status == MagickFalse)
    {
      if (mask != (Image *) NULL)
        DestroyImage(mask);
      ThrowBinaryException(CoderError,""UnableToDecompressImage"",
        image->filename);
    }
  layer_info->mask.image=mask;
  return(status);
}","static MagickBooleanType ReadPSDChannel(Image *VAR_0,
  const ImageInfo *VAR_1,const PSDInfo *VAR_2,LayerInfo* VAR_3,
  const size_t VAR_4,const PSDCompressionType VAR_5,
  ExceptionInfo *VAR_6)
{
  Image
    *VAR_7,
    *VAR_8;

  MagickOffsetType
    VAR_9;

  MagickBooleanType
    VAR_10;

  VAR_7=VAR_0;
  VAR_8=(Image *) NULL;
  if (VAR_3->channel_info[VAR_4].type < -1)
    {
      const char
        *VAR_11;
      /* COMMENT_0 */
                                                                          
                                                         
        
      VAR_11=GetImageOption(VAR_1,""psd:preserve-opacity-mask"");
      if ((VAR_3->channel_info[VAR_4].type != -2) ||
          (VAR_3->mask.flags > 2) || ((VAR_3->mask.flags & 0x02) &&
           (IsStringTrue(VAR_11) == VAR_12)))
      {
        SeekBlob(VAR_0,VAR_3->channel_info[VAR_4].size-2,VAR_13);
        return(VAR_14);
      }
      VAR_8=CloneImage(VAR_0,VAR_3->mask.page.width,
        VAR_3->mask.page.height,VAR_12,VAR_6);
      if (VAR_8 != (Image *) NULL)
        {
          VAR_8->matte=VAR_12;
          VAR_7=VAR_8;
        }
    }

  VAR_9=TellBlob(VAR_0);
  VAR_10=VAR_14;
  switch(VAR_5)
  {
    case VAR_15:
      VAR_10=ReadPSDChannelRaw(VAR_7,VAR_2->channels,
        VAR_3->channel_info[VAR_4].type,VAR_6);
      break;
    case VAR_16:
      {
        MagickOffsetType
          *VAR_17;

        VAR_17=ReadPSDRLESizes(VAR_7,VAR_2,VAR_7->rows);
        if (VAR_17 == (MagickOffsetType *) NULL)
          ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
            VAR_0->filename);
        VAR_10=ReadPSDChannelRLE(VAR_7,VAR_2,
          VAR_3->channel_info[VAR_4].type,VAR_17,VAR_6);
        VAR_17=(MagickOffsetType *) RelinquishMagickMemory(VAR_17);
      }
      break;
    case VAR_19:
    case VAR_20:
#ifdef VAR_21
      VAR_10=ReadPSDChannelZip(VAR_7,VAR_3->channels,
        VAR_3->channel_info[VAR_4].type,VAR_5,
        VAR_3->channel_info[VAR_4].size-2,VAR_6);
#else
      (void) ThrowMagickException(VAR_6,GetMagickModule(),
          VAR_22,""DelegateLibrarySupportNotBuiltIn"",
            ""'%s' (ZLIB)"",VAR_0->filename);
#endif
      break;
    default:
      (void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_23,
        ""CompressionNotSupported"",""'%.20g'"",(double) VAR_5);
      break;
  }

  SeekBlob(VAR_0,VAR_9+VAR_3->channel_info[VAR_4].size-2,VAR_24);
  if (VAR_10 == VAR_12)
    {
      if (VAR_8 != (Image *) NULL)
        DestroyImage(VAR_8);
      ThrowBinaryException(VAR_25,""UnableToDecompressImage"",
        VAR_0->filename);
    }
  VAR_3->mask.image=VAR_8;
  return(VAR_10);
}",ImageMagick/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94/psd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,8 +33,11 @@
       }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
-      mask->matte=MagickFalse;
-      channel_image=mask;
+      if (mask != (Image *) NULL)
+        {
+          mask->matte=MagickFalse;
+          channel_image=mask;
+        }
     }
 
   offset=TellBlob(image);","{'deleted_lines': ['      mask->matte=MagickFalse;', '      channel_image=mask;'], 'added_lines': ['      if (mask != (Image *) NULL)', '        {', '          mask->matte=MagickFalse;', '          channel_image=mask;', '        }']}",True,"An issue was discovered in ImageMagick 6.9.7. A specially crafted psd file could lead to a NULL pointer dereference (thus, a DoS).",7.5,HIGH,2,valid,2017-02-11T09:31:39Z,1
CVE-2017-6345,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"net/llc: avoid BUG_ON() in skb_orphan()

It seems nobody used LLC since linux-3.12.

Fortunately fuzzers like syzkaller still know how to run this code,
otherwise it would be no fun.

Setting skb->sk without skb->destructor leads to all kinds of
bugs, we now prefer to be very strict about it.

Ideally here we would use skb_set_owner() but this helper does not exist yet,
only CAN seems to have a private helper for that.

Fixes: 376c7311bdb6 (""net: add a temporary sanity check in skb_orphan()"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",8b74d439e1697110c5e5c600643e823eb1dd0762,https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762,net/llc/llc_conn.c,llc_conn_handler,"void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)
{
struct llc_addr saddr, daddr;
struct sock *sk;
llc_pdu_decode_sa(skb, saddr.mac);
llc_pdu_decode_ssap(skb, &saddr.lsap);
llc_pdu_decode_da(skb, daddr.mac);
llc_pdu_decode_dsap(skb, &daddr.lsap);
sk = __llc_lookup(sap, &saddr, &daddr);
if (!sk)
goto drop;
bh_lock_sock(sk);
if (unlikely(sk->sk_state == TCP_LISTEN)) {
struct sock *newsk = llc_create_incoming_sock(sk, skb->dev,
&saddr, &daddr);
if (!newsk)
goto drop_unlock;
skb_set_owner_r(skb, newsk);
} else {
skb->sk = sk;
}
if (!sock_owned_by_user(sk))
llc_conn_rcv(sk, skb);
else {
dprintk(""%s: adding to backlog...\n"", __func__);
llc_set_backlog_type(skb, LLC_PACKET);
if (sk_add_backlog(sk, skb, sk->sk_rcvbuf))
goto drop_unlock;
}
out:
bh_unlock_sock(sk);
sock_put(sk);
return;
drop:
kfree_skb(skb);
return;
drop_unlock:
kfree_skb(skb);
goto out;
}","void llc_conn_handler(struct llc_sap *VAR_0, struct sk_buff *VAR_1)
{
struct llc_addr VAR_2, VAR_3;
struct sock *VAR_4;
llc_pdu_decode_sa(VAR_1, VAR_2.mac);
llc_pdu_decode_ssap(VAR_1, &VAR_2.lsap);
llc_pdu_decode_da(VAR_1, VAR_3.mac);
llc_pdu_decode_dsap(VAR_1, &VAR_3.lsap);
VAR_4 = __llc_lookup(VAR_0, &VAR_2, &VAR_3);
if (!VAR_4)
goto drop;
bh_lock_sock(VAR_4);
if (unlikely(VAR_4->sk_state == VAR_5)) {
struct sock *VAR_6 = llc_create_incoming_sock(VAR_4, VAR_1->dev,
&VAR_2, &VAR_3);
if (!VAR_6)
goto drop_unlock;
skb_set_owner_r(VAR_1, VAR_6);
} else {
VAR_1->sk = VAR_4;
}
if (!sock_owned_by_user(VAR_4))
llc_conn_rcv(VAR_4, VAR_1);
else {
dprintk(""%s: adding to backlog...\n"", VAR_7);
llc_set_backlog_type(VAR_1, VAR_8);
if (sk_add_backlog(VAR_4, VAR_1, VAR_4->sk_rcvbuf))
goto drop_unlock;
}
out:
bh_unlock_sock(VAR_4);
sock_put(VAR_4);
return;
drop:
kfree_skb(VAR_1);
return;
drop_unlock:
kfree_skb(VAR_1);
goto out;
}",torvalds/linux/8b74d439e1697110c5e5c600643e823eb1dd0762/llc_conn.c/vul/before/0.json,"void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)
{
	struct llc_addr saddr, daddr;
	struct sock *sk;

	llc_pdu_decode_sa(skb, saddr.mac);
	llc_pdu_decode_ssap(skb, &saddr.lsap);
	llc_pdu_decode_da(skb, daddr.mac);
	llc_pdu_decode_dsap(skb, &daddr.lsap);

	sk = __llc_lookup(sap, &saddr, &daddr);
	if (!sk)
		goto drop;

	bh_lock_sock(sk);
	/*
	 * This has to be done here and not at the upper layer ->accept
	 * method because of the way the PROCOM state machine works:
	 * it needs to set several state variables (see, for instance,
	 * llc_adm_actions_2 in net/llc/llc_c_st.c) and send a packet to
	 * the originator of the new connection, and this state has to be
	 * in the newly created struct sock private area. -acme
	 */
	if (unlikely(sk->sk_state == TCP_LISTEN)) {
		struct sock *newsk = llc_create_incoming_sock(sk, skb->dev,
							      &saddr, &daddr);
		if (!newsk)
			goto drop_unlock;
		skb_set_owner_r(skb, newsk);
	} else {
		/*
		 * Can't be skb_set_owner_r, this will be done at the
		 * llc_conn_state_process function, later on, when we will use
		 * skb_queue_rcv_skb to send it to upper layers, this is
		 * another trick required to cope with how the PROCOM state
		 * machine works. -acme
		 */
		skb_orphan(skb);
		sock_hold(sk);
		skb->sk = sk;
		skb->destructor = sock_efree;
	}
	if (!sock_owned_by_user(sk))
		llc_conn_rcv(sk, skb);
	else {
		dprintk(""%s: adding to backlog...\n"", __func__);
		llc_set_backlog_type(skb, LLC_PACKET);
		if (sk_add_backlog(sk, skb, sk->sk_rcvbuf))
			goto drop_unlock;
	}
out:
	bh_unlock_sock(sk);
	sock_put(sk);
	return;
drop:
	kfree_skb(skb);
	return;
drop_unlock:
	kfree_skb(skb);
	goto out;
}","void llc_conn_handler(struct llc_sap *VAR_0, struct sk_buff *VAR_1)
{
	struct llc_addr VAR_2, VAR_3;
	struct sock *VAR_4;

	llc_pdu_decode_sa(VAR_1, VAR_2.mac);
	llc_pdu_decode_ssap(VAR_1, &VAR_2.lsap);
	llc_pdu_decode_da(VAR_1, VAR_3.mac);
	llc_pdu_decode_dsap(VAR_1, &VAR_3.lsap);

	VAR_4 = __llc_lookup(VAR_0, &VAR_2, &VAR_3);
	if (!VAR_4)
		goto drop;

	bh_lock_sock(VAR_4);
	/* COMMENT_0 */
                                                                
                                                             
                                                               
                                                                 
                                                                  
                                                        
    
	if (unlikely(VAR_4->sk_state == VAR_5)) {
		struct sock *VAR_6 = llc_create_incoming_sock(VAR_4, VAR_1->dev,
							      &VAR_2, &VAR_3);
		if (!VAR_6)
			goto drop_unlock;
		skb_set_owner_r(VAR_1, VAR_6);
	} else {
		/* COMMENT_8 */
                                                       
                                                                
                                                          
                                                             
                         
     
		skb_orphan(VAR_1);
		sock_hold(VAR_4);
		VAR_1->sk = VAR_4;
		VAR_1->destructor = VAR_7;
	}
	if (!sock_owned_by_user(VAR_4))
		llc_conn_rcv(VAR_4, VAR_1);
	else {
		dprintk(""%s: adding to backlog...\n"", VAR_8);
		llc_set_backlog_type(VAR_1, VAR_9);
		if (sk_add_backlog(VAR_4, VAR_1, VAR_4->sk_rcvbuf))
			goto drop_unlock;
	}
out:
	bh_unlock_sock(VAR_4);
	sock_put(VAR_4);
	return;
drop:
	kfree_skb(VAR_1);
	return;
drop_unlock:
	kfree_skb(VAR_1);
	goto out;
}",torvalds/linux/8b74d439e1697110c5e5c600643e823eb1dd0762/llc_conn.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,7 +35,10 @@
 		 * another trick required to cope with how the PROCOM state
 		 * machine works. -acme
 		 */
+		skb_orphan(skb);
+		sock_hold(sk);
 		skb->sk = sk;
+		skb->destructor = sock_efree;
 	}
 	if (!sock_owned_by_user(sk))
 		llc_conn_rcv(sk, skb);","{'deleted_lines': [], 'added_lines': ['\t\tskb_orphan(skb);', '\t\tsock_hold(sk);', '\t\tskb->destructor = sock_efree;']}",True,"The LLC subsystem in the Linux kernel before 4.9.13 does not ensure that a certain destructor exists in required circumstances, which allows local users to cause a denial of service (BUG_ON) or possibly have unspecified other impact via crafted system calls.",7.8,HIGH,2,valid,2017-02-12T22:03:52Z,1
CVE-2017-6345,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"net/llc: avoid BUG_ON() in skb_orphan()

It seems nobody used LLC since linux-3.12.

Fortunately fuzzers like syzkaller still know how to run this code,
otherwise it would be no fun.

Setting skb->sk without skb->destructor leads to all kinds of
bugs, we now prefer to be very strict about it.

Ideally here we would use skb_set_owner() but this helper does not exist yet,
only CAN seems to have a private helper for that.

Fixes: 376c7311bdb6 (""net: add a temporary sanity check in skb_orphan()"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",8b74d439e1697110c5e5c600643e823eb1dd0762,https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762,net/llc/llc_sap.c,llc_sap_rcv,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
struct sock *sk)
{
struct llc_sap_state_ev *ev = llc_sap_ev(skb);
ev->type   = LLC_SAP_EV_TYPE_PDU;
ev->reason = 0;
skb->sk = sk;
llc_sap_state_process(sap, skb);
}","static void llc_sap_rcv(struct llc_sap *VAR_0, struct sk_buff *VAR_1,
struct sock *VAR_2)
{
struct llc_sap_state_ev *VAR_3 = llc_sap_ev(VAR_1);
VAR_3->type   = VAR_4;
VAR_3->reason = 0;
VAR_1->sk = VAR_2;
llc_sap_state_process(VAR_0, VAR_1);
}",torvalds/linux/8b74d439e1697110c5e5c600643e823eb1dd0762/llc_sap.c/vul/before/0.json,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);

	ev->type   = LLC_SAP_EV_TYPE_PDU;
	ev->reason = 0;
	skb_orphan(skb);
	sock_hold(sk);
	skb->sk = sk;
	skb->destructor = sock_efree;
	llc_sap_state_process(sap, skb);
}","static void llc_sap_rcv(struct llc_sap *VAR_0, struct sk_buff *VAR_1,
			struct sock *VAR_2)
{
	struct llc_sap_state_ev *VAR_3 = llc_sap_ev(VAR_1);

	VAR_3->type   = VAR_4;
	VAR_3->reason = 0;
	skb_orphan(VAR_1);
	sock_hold(VAR_2);
	VAR_1->sk = VAR_2;
	VAR_1->destructor = VAR_5;
	llc_sap_state_process(VAR_0, VAR_1);
}",torvalds/linux/8b74d439e1697110c5e5c600643e823eb1dd0762/llc_sap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,9 @@
 
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
+	skb_orphan(skb);
+	sock_hold(sk);
 	skb->sk = sk;
+	skb->destructor = sock_efree;
 	llc_sap_state_process(sap, skb);
 }","{'deleted_lines': [], 'added_lines': ['\tskb_orphan(skb);', '\tsock_hold(sk);', '\tskb->destructor = sock_efree;']}",True,"The LLC subsystem in the Linux kernel before 4.9.13 does not ensure that a certain destructor exists in required circumstances, which allows local users to cause a denial of service (BUG_ON) or possibly have unspecified other impact via crafted system calls.",7.8,HIGH,2,valid,2017-02-12T22:03:52Z,1
CVE-2017-6348,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"irda: Fix lockdep annotations in hashbin_delete().

A nested lock depth was added to the hasbin_delete() code but it
doesn't actually work some well and results in tons of lockdep splats.

Fix the code instead to properly drop the lock around the operation
and just keep peeking the head of the hashbin queue.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Tested-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",4c03b862b12f980456f9de92db6d508a4999b788,https://github.com/torvalds/linux/commit/4c03b862b12f980456f9de92db6d508a4999b788,net/irda/irqueue.c,hashbin_delete,"int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)
{
irda_queue_t* queue;
unsigned long flags = 0;
int i;
IRDA_ASSERT(hashbin != NULL, return -1;);
IRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);
if ( hashbin->hb_type & HB_LOCK ) {
spin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,
hashbin_lock_depth++);
}
for (i = 0; i < HASHBIN_SIZE; i ++ ) {
queue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);
while (queue ) {
if (free_func)
(*free_func)(queue);
queue = dequeue_first(
(irda_queue_t**) &hashbin->hb_queue[i]);
}
}
hashbin->hb_current = NULL;
hashbin->magic = ~HB_MAGIC;
if ( hashbin->hb_type & HB_LOCK) {
spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
#ifdef CONFIG_LOCKDEP
hashbin_lock_depth--;
#endif
}
kfree(hashbin);
return 0;
}","int hashbin_delete( hashbin_t* VAR_0, FREE_FUNC VAR_1)
{
irda_queue_t* VAR_2;
unsigned long VAR_3 = 0;
int VAR_4;
IRDA_ASSERT(VAR_0 != NULL, return -1;);
IRDA_ASSERT(VAR_0->magic == VAR_5, return -1;);
if ( VAR_0->hb_type & VAR_6 ) {
spin_lock_irqsave_nested(&VAR_0->hb_spinlock, VAR_3,
VAR_7++);
}
for (VAR_4 = 0; VAR_4 < VAR_8; VAR_4 ++ ) {
VAR_2 = dequeue_first((irda_queue_t**) &VAR_0->hb_queue[VAR_4]);
while (VAR_2 ) {
if (VAR_1)
(*VAR_1)(VAR_2);
VAR_2 = dequeue_first(
(irda_queue_t**) &VAR_0->hb_queue[VAR_4]);
}
}
VAR_0->hb_current = NULL;
VAR_0->magic = ~VAR_5;
if ( VAR_0->hb_type & VAR_6) {
spin_unlock_irqrestore(&VAR_0->hb_spinlock, VAR_3);
#ifdef VAR_9
VAR_7--;
#endif
}
kfree(VAR_0);
return 0;
}",torvalds/linux/4c03b862b12f980456f9de92db6d508a4999b788/irqueue.c/vul/before/0.json,"int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)
{
	irda_queue_t* queue;
	unsigned long flags = 0;
	int i;

	IRDA_ASSERT(hashbin != NULL, return -1;);
	IRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);

	/* Synchronize */
	if (hashbin->hb_type & HB_LOCK)
		spin_lock_irqsave(&hashbin->hb_spinlock, flags);

	/*
	 *  Free the entries in the hashbin, TODO: use hashbin_clear when
	 *  it has been shown to work
	 */
	for (i = 0; i < HASHBIN_SIZE; i ++ ) {
		while (1) {
			queue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);

			if (!queue)
				break;

			if (free_func) {
				if (hashbin->hb_type & HB_LOCK)
					spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
				free_func(queue);
				if (hashbin->hb_type & HB_LOCK)
					spin_lock_irqsave(&hashbin->hb_spinlock, flags);
			}
		}
	}

	/* Cleanup local data */
	hashbin->hb_current = NULL;
	hashbin->magic = ~HB_MAGIC;

	/* Release lock */
	if (hashbin->hb_type & HB_LOCK)
		spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);

	/*
	 *  Free the hashbin structure
	 */
	kfree(hashbin);

	return 0;
}","int hashbin_delete( hashbin_t* VAR_0, FREE_FUNC VAR_1)
{
	irda_queue_t* VAR_2;
	unsigned long VAR_3 = 0;
	int VAR_4;

	IRDA_ASSERT(VAR_0 != NULL, return -1;);
	IRDA_ASSERT(VAR_0->magic == VAR_5, return -1;);

	/* COMMENT_0 */
	if (VAR_0->hb_type & VAR_6)
		spin_lock_irqsave(&VAR_0->hb_spinlock, VAR_3);

	/* COMMENT_1 */
                                                                  
                              
    
	for (VAR_4 = 0; VAR_4 < VAR_7; VAR_4 ++ ) {
		while (1) {
			VAR_2 = dequeue_first((irda_queue_t**) &VAR_0->hb_queue[VAR_4]);

			if (!VAR_2)
				break;

			if (VAR_1) {
				if (VAR_0->hb_type & VAR_6)
					spin_unlock_irqrestore(&VAR_0->hb_spinlock, VAR_3);
				VAR_1(VAR_2);
				if (VAR_0->hb_type & VAR_6)
					spin_lock_irqsave(&VAR_0->hb_spinlock, VAR_3);
			}
		}
	}

	/* COMMENT_5 */
	VAR_0->hb_current = NULL;
	VAR_0->magic = ~VAR_5;

	/* COMMENT_6 */
	if (VAR_0->hb_type & VAR_6)
		spin_unlock_irqrestore(&VAR_0->hb_spinlock, VAR_3);

	/* COMMENT_7 */
                               
    
	kfree(VAR_0);

	return 0;
}",torvalds/linux/4c03b862b12f980456f9de92db6d508a4999b788/irqueue.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,22 +8,27 @@
 	IRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);
 
 	/* Synchronize */
-	if ( hashbin->hb_type & HB_LOCK ) {
-		spin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,
-					 hashbin_lock_depth++);
-	}
+	if (hashbin->hb_type & HB_LOCK)
+		spin_lock_irqsave(&hashbin->hb_spinlock, flags);
 
 	/*
 	 *  Free the entries in the hashbin, TODO: use hashbin_clear when
 	 *  it has been shown to work
 	 */
 	for (i = 0; i < HASHBIN_SIZE; i ++ ) {
-		queue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);
-		while (queue ) {
-			if (free_func)
-				(*free_func)(queue);
-			queue = dequeue_first(
-				(irda_queue_t**) &hashbin->hb_queue[i]);
+		while (1) {
+			queue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);
+
+			if (!queue)
+				break;
+
+			if (free_func) {
+				if (hashbin->hb_type & HB_LOCK)
+					spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
+				free_func(queue);
+				if (hashbin->hb_type & HB_LOCK)
+					spin_lock_irqsave(&hashbin->hb_spinlock, flags);
+			}
 		}
 	}
 
@@ -32,12 +37,8 @@
 	hashbin->magic = ~HB_MAGIC;
 
 	/* Release lock */
-	if ( hashbin->hb_type & HB_LOCK) {
+	if (hashbin->hb_type & HB_LOCK)
 		spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
-#ifdef CONFIG_LOCKDEP
-		hashbin_lock_depth--;
-#endif
-	}
 
 	/*
 	 *  Free the hashbin structure","{'deleted_lines': ['\tif ( hashbin->hb_type & HB_LOCK ) {', '\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,', '\t\t\t\t\t hashbin_lock_depth++);', '\t}', '\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);', '\t\twhile (queue ) {', '\t\t\tif (free_func)', '\t\t\t\t(*free_func)(queue);', '\t\t\tqueue = dequeue_first(', '\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);', '\tif ( hashbin->hb_type & HB_LOCK) {', '#ifdef CONFIG_LOCKDEP', '\t\thashbin_lock_depth--;', '#endif', '\t}'], 'added_lines': ['\tif (hashbin->hb_type & HB_LOCK)', '\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);', '\t\twhile (1) {', '\t\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);', '', '\t\t\tif (!queue)', '\t\t\t\tbreak;', '', '\t\t\tif (free_func) {', '\t\t\t\tif (hashbin->hb_type & HB_LOCK)', '\t\t\t\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);', '\t\t\t\tfree_func(queue);', '\t\t\t\tif (hashbin->hb_type & HB_LOCK)', '\t\t\t\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);', '\t\t\t}', '\tif (hashbin->hb_type & HB_LOCK)']}",True,"The hashbin_delete function in net/irda/irqueue.c in the Linux kernel before 4.9.13 improperly manages lock dropping, which allows local users to cause a denial of service (deadlock) via crafted operations on IrDA devices.",5.5,MEDIUM,1,valid,2017-02-17T21:19:39Z,1
CVE-2017-13002,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13002/AODV: Add some missing bounds checks.

In aodv_extension() do a bounds check on the extension header before we
look at it.

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).

While we're at it, add the RFC number, and check the validity of the
length for the Hello extension.",cbddb98484ea8ec1deece351abd56e063d775b38,https://github.com/the-tcpdump-group/tcpdump/commit/cbddb98484ea8ec1deece351abd56e063d775b38,print-aodv.c,aodv_extension,"static void
aodv_extension(netdissect_options *ndo,
const struct aodv_ext *ep, u_int length)
{
const struct aodv_hello *ah;
switch (ep->type) {
case AODV_EXT_HELLO:
ah = (const struct aodv_hello *)(const void *)ep;
ND_TCHECK(*ah);
if (length < sizeof(struct aodv_hello))
goto trunc;
ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
(unsigned long)EXTRACT_32BITS(&ah->interval)));
break;
default:
ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
break;
}
return;
trunc:
ND_PRINT((ndo, "" [|hello]""));
}","static void
aodv_extension(netdissect_options *VAR_0,
const struct aodv_ext *VAR_1, u_int VAR_2)
{
const struct aodv_hello *VAR_3;
switch (VAR_1->type) {
case VAR_4:
VAR_3 = (const struct aodv_hello *)(const void *)VAR_1;
ND_TCHECK(*VAR_3);
if (VAR_2 < sizeof(struct aodv_hello))
goto trunc;
ND_PRINT((VAR_0, ""\n\text HELLO %ld ms"",
(unsigned long)EXTRACT_32BITS(&VAR_3->interval)));
break;
default:
ND_PRINT((VAR_0, ""\n\text %u %u"", VAR_1->type, VAR_1->length));
break;
}
return;
trunc:
ND_PRINT((VAR_0, "" [|hello]""));
}",the-tcpdump-group/tcpdump/cbddb98484ea8ec1deece351abd56e063d775b38/print-aodv.c/vul/before/0.json,"static void
aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
{
	const struct aodv_hello *ah;

	ND_TCHECK(*ep);
	switch (ep->type) {
	case AODV_EXT_HELLO:
		ah = (const struct aodv_hello *)(const void *)ep;
		ND_TCHECK(*ah);
		if (length < sizeof(struct aodv_hello))
			goto trunc;
		if (ep->length < 4) {
			ND_PRINT((ndo, ""\n\text HELLO - bad length %u"", ep->length));
			break;
		}
		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
		break;

	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, "" [|hello]""));
}","static void
aodv_extension(netdissect_options *VAR_0,
               const struct aodv_ext *VAR_1, u_int VAR_2)
{
	const struct aodv_hello *VAR_3;

	ND_TCHECK(*VAR_1);
	switch (VAR_1->type) {
	case VAR_4:
		VAR_3 = (const struct aodv_hello *)(const void *)VAR_1;
		ND_TCHECK(*VAR_3);
		if (VAR_2 < sizeof(struct aodv_hello))
			goto trunc;
		if (VAR_1->length < 4) {
			ND_PRINT((VAR_0, ""\n\text HELLO - bad length %u"", VAR_1->length));
			break;
		}
		ND_PRINT((VAR_0, ""\n\text HELLO %ld ms"",
		    (unsigned long)EXTRACT_32BITS(&VAR_3->interval)));
		break;

	default:
		ND_PRINT((VAR_0, ""\n\text %u %u"", VAR_1->type, VAR_1->length));
		break;
	}
	return;

trunc:
	ND_PRINT((VAR_0, "" [|hello]""));
}",the-tcpdump-group/tcpdump/cbddb98484ea8ec1deece351abd56e063d775b38/print-aodv.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,12 +4,17 @@
 {
 	const struct aodv_hello *ah;
 
+	ND_TCHECK(*ep);
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
+		if (ep->length < 4) {
+			ND_PRINT((ndo, ""\n\text HELLO - bad length %u"", ep->length));
+			break;
+		}
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;","{'deleted_lines': [], 'added_lines': ['\tND_TCHECK(*ep);', '\t\tif (ep->length < 4) {', '\t\t\tND_PRINT((ndo, ""\\n\\text HELLO - bad length %u"", ep->length));', '\t\t\tbreak;', '\t\t}']}",True,The AODV parser in tcpdump before 4.9.2 has a buffer over-read in print-aodv.c:aodv_extension().,9.8,CRITICAL,3,valid,2017-02-19T22:19:32Z,1
CVE-2017-11472,['CWE-755'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,acpica,"Namespace: fix operand cache leak

I found some ACPI operand cache leaks in ACPI early abort cases.

Boot log of ACPI operand cache leak is as follows:
>[    0.174332] ACPI: Added _OSI(Module Device)
>[    0.175504] ACPI: Added _OSI(Processor Device)
>[    0.176010] ACPI: Added _OSI(3.0 _SCP Extensions)
>[    0.177032] ACPI: Added _OSI(Processor Aggregator Device)
>[    0.178284] ACPI: SCI (IRQ16705) allocation failed
>[    0.179352] ACPI Exception: AE_NOT_ACQUIRED, Unable to install
System Control Interrupt handler (20160930/evevent-131)
>[    0.180008] ACPI: Unable to start the ACPI Interpreter
>[    0.181125] ACPI Error: Could not remove SCI handler
(20160930/evmisc-281)
>[    0.184068] kmem_cache_destroy Acpi-Operand: Slab cache still has
objects
>[    0.185358] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.10.0-rc3 #2
>[    0.186820] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS
VirtualBox 12/01/2006
>[    0.188000] Call Trace:
>[    0.188000]  ? dump_stack+0x5c/0x7d
>[    0.188000]  ? kmem_cache_destroy+0x224/0x230
>[    0.188000]  ? acpi_sleep_proc_init+0x22/0x22
>[    0.188000]  ? acpi_os_delete_cache+0xa/0xd
>[    0.188000]  ? acpi_ut_delete_caches+0x3f/0x7b
>[    0.188000]  ? acpi_terminate+0x5/0xf
>[    0.188000]  ? acpi_init+0x288/0x32e
>[    0.188000]  ? __class_create+0x4c/0x80
>[    0.188000]  ? video_setup+0x7a/0x7a
>[    0.188000]  ? do_one_initcall+0x4e/0x1b0
>[    0.188000]  ? kernel_init_freeable+0x194/0x21a
>[    0.188000]  ? rest_init+0x80/0x80
>[    0.188000]  ? kernel_init+0xa/0x100
>[    0.188000]  ? ret_from_fork+0x25/0x30

When early abort is occurred due to invalid ACPI information, Linux kernel
terminates ACPI by calling AcpiTerminate() function. The function calls
AcpiNsTerminate() function to delete namespace data and ACPI operand cache
(AcpiGbl_ModuleCodeList).

But the deletion code in AcpiNsTerminate() function is wrapped in
ACPI_EXEC_APP definition, therefore the code is only executed when the
definition exists. If the define doesn't exist, ACPI operand cache
(AcpiGbl_ModuleCodeList) is leaked, and stack dump is shown in kernel log.

This causes a security threat because the old kernel (<= 4.9) shows memory
locations of kernel functions in stack dump, therefore kernel ASLR can be
neutralized.

To fix ACPI operand leak for enhancing security, I made a patch which
removes the ACPI_EXEC_APP define in AcpiNsTerminate() function for
executing the deletion code unconditionally.

Signed-off-by: Seunghun Han <kkamagui@gmail.com>
Signed-off-by: Lv Zheng <lv.zheng@intel.com>",a23325b2e583556eae88ed3f764e457786bf4df6,https://github.com/acpica/acpica/commit/a23325b2e583556eae88ed3f764e457786bf4df6,source/components/namespace/nsutils.c,AcpiNsTerminate,"void
AcpiNsTerminate (
void)
{
ACPI_STATUS             Status;
ACPI_FUNCTION_TRACE (NsTerminate);
#ifdef ACPI_EXEC_APP
{
ACPI_OPERAND_OBJECT     *Prev;
ACPI_OPERAND_OBJECT     *Next;
Next = AcpiGbl_ModuleCodeList;
while (Next)
{
Prev = Next;
Next = Next->Method.Mutex;
Prev->Method.Mutex = NULL; 
AcpiUtRemoveReference (Prev);
}
}
#endif
AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);
Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
if (ACPI_FAILURE (Status))
{
return_VOID;
}
AcpiNsDeleteNode (AcpiGbl_RootNode);
(void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);
ACPI_DEBUG_PRINT ((ACPI_DB_INFO, ""Namespace freed\n""));
return_VOID;
}","void
AcpiNsTerminate (
void)
{
ACPI_STATUS             VAR_0;
ACPI_FUNCTION_TRACE (VAR_1);
#ifdef VAR_2
{
ACPI_OPERAND_OBJECT     *VAR_3;
ACPI_OPERAND_OBJECT     *VAR_4;
VAR_4 = VAR_5;
while (VAR_4)
{
VAR_3 = VAR_4;
VAR_4 = VAR_4->Method.Mutex;
VAR_3->Method.Mutex = NULL; 
AcpiUtRemoveReference (VAR_3);
}
}
#endif
AcpiNsDeleteNamespaceSubtree (VAR_6);
VAR_0 = AcpiUtAcquireMutex (VAR_7);
if (ACPI_FAILURE (VAR_0))
{
VAR_8;
}
AcpiNsDeleteNode (VAR_6);
(void) AcpiUtReleaseMutex (VAR_7);
ACPI_DEBUG_PRINT ((VAR_9, ""Namespace freed\n""));
VAR_8;
}",acpica/a23325b2e583556eae88ed3f764e457786bf4df6/nsutils.c/vul/before/0.json,"void
AcpiNsTerminate (
    void)
{
    ACPI_STATUS             Status;
    ACPI_OPERAND_OBJECT     *Prev;
    ACPI_OPERAND_OBJECT     *Next;


    ACPI_FUNCTION_TRACE (NsTerminate);


    /* Delete any module-level code blocks */

    Next = AcpiGbl_ModuleCodeList;
    while (Next)
    {
        Prev = Next;
        Next = Next->Method.Mutex;
        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */
        AcpiUtRemoveReference (Prev);
    }

    /*
     * Free the entire namespace -- all nodes and all objects
     * attached to the nodes
     */
    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);

    /* Delete any objects attached to the root node */

    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);
    if (ACPI_FAILURE (Status))
    {
        return_VOID;
    }

    AcpiNsDeleteNode (AcpiGbl_RootNode);
    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);

    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, ""Namespace freed\n""));
    return_VOID;
}","void
AcpiNsTerminate (
    void)
{
    ACPI_STATUS             VAR_0;
    ACPI_OPERAND_OBJECT     *VAR_1;
    ACPI_OPERAND_OBJECT     *VAR_2;


    ACPI_FUNCTION_TRACE (VAR_3);


    /* COMMENT_0 */

    VAR_2 = VAR_4;
    while (VAR_2)
    {
        VAR_1 = VAR_2;
        VAR_2 = VAR_2->Method.Mutex;
        VAR_1->Method.Mutex = NULL; /* COMMENT_1 */
        AcpiUtRemoveReference (VAR_1);
    }

    /* COMMENT_2 */
                                                             
                            
       
    AcpiNsDeleteNamespaceSubtree (VAR_5);

    /* COMMENT_6 */

    VAR_0 = AcpiUtAcquireMutex (VAR_6);
    if (ACPI_FAILURE (VAR_0))
    {
        VAR_7;
    }

    AcpiNsDeleteNode (VAR_5);
    (void) AcpiUtReleaseMutex (VAR_6);

    ACPI_DEBUG_PRINT ((VAR_8, ""Namespace freed\n""));
    VAR_7;
}",acpica/a23325b2e583556eae88ed3f764e457786bf4df6/nsutils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,28 +3,23 @@
     void)
 {
     ACPI_STATUS             Status;
+    ACPI_OPERAND_OBJECT     *Prev;
+    ACPI_OPERAND_OBJECT     *Next;
 
 
     ACPI_FUNCTION_TRACE (NsTerminate);
 
 
-#ifdef ACPI_EXEC_APP
+    /* Delete any module-level code blocks */
+
+    Next = AcpiGbl_ModuleCodeList;
+    while (Next)
     {
-        ACPI_OPERAND_OBJECT     *Prev;
-        ACPI_OPERAND_OBJECT     *Next;
-
-        /* Delete any module-level code blocks */
-
-        Next = AcpiGbl_ModuleCodeList;
-        while (Next)
-        {
-            Prev = Next;
-            Next = Next->Method.Mutex;
-            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */
-            AcpiUtRemoveReference (Prev);
-        }
+        Prev = Next;
+        Next = Next->Method.Mutex;
+        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */
+        AcpiUtRemoveReference (Prev);
     }
-#endif
 
     /*
      * Free the entire namespace -- all nodes and all objects","{'deleted_lines': ['#ifdef ACPI_EXEC_APP', '        ACPI_OPERAND_OBJECT     *Prev;', '        ACPI_OPERAND_OBJECT     *Next;', '', '        /* Delete any module-level code blocks */', '', '        Next = AcpiGbl_ModuleCodeList;', '        while (Next)', '        {', '            Prev = Next;', '            Next = Next->Method.Mutex;', '            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */', '            AcpiUtRemoveReference (Prev);', '        }', '#endif'], 'added_lines': ['    ACPI_OPERAND_OBJECT     *Prev;', '    ACPI_OPERAND_OBJECT     *Next;', '    /* Delete any module-level code blocks */', '', '    Next = AcpiGbl_ModuleCodeList;', '    while (Next)', '        Prev = Next;', '        Next = Next->Method.Mutex;', '        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */', '        AcpiUtRemoveReference (Prev);']}",True,"The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",7.1,HIGH,2,valid,2017-02-22T08:32:49Z,1
CVE-2017-13005,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13005/NFS: Add two bounds checks before fetching data

This fixes a buffer over-read discovered by Kamil Frankowicz.

Add a test using the capture file supplied by the reporter(s).",b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd,https://github.com/the-tcpdump-group/tcpdump/commit/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd,print-nfs.c,xid_map_enter,"static int
xid_map_enter(netdissect_options *ndo,
const struct sunrpc_msg *rp, const u_char *bp)
{
const struct ip *ip = NULL;
const struct ip6_hdr *ip6 = NULL;
struct xid_map_entry *xmep;
if (!ND_TTEST(rp->rm_call.cb_vers))
return (0);
switch (IP_V((const struct ip *)bp)) {
case 4:
ip = (const struct ip *)bp;
break;
case 6:
ip6 = (const struct ip6_hdr *)bp;
break;
default:
return (1);
}
xmep = &xid_map[xid_map_next];
if (++xid_map_next >= XIDMAPSIZE)
xid_map_next = 0;
UNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));
if (ip) {
xmep->ipver = 4;
UNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));
UNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));
}
else if (ip6) {
xmep->ipver = 6;
UNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));
UNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));
}
xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
return (1);
}","static int
xid_map_enter(netdissect_options *VAR_0,
const struct sunrpc_msg *VAR_1, const u_char *VAR_2)
{
const struct ip *ip = NULL;
const struct ip6_hdr *VAR_3 = NULL;
struct xid_map_entry *VAR_4;
if (!ND_TTEST(VAR_1->rm_call.cb_vers))
return (0);
switch (IP_V((const struct ip *)VAR_2)) {
case 4:
ip = (const struct ip *)VAR_2;
break;
case 6:
VAR_3 = (const struct ip6_hdr *)VAR_2;
break;
default:
return (1);
}
VAR_4 = &VAR_5[VAR_6];
if (++VAR_6 >= VAR_7)
VAR_6 = 0;
UNALIGNED_MEMCPY(&VAR_4->xid, &VAR_1->rm_xid, sizeof(VAR_4->xid));
if (ip) {
VAR_4->ipver = 4;
UNALIGNED_MEMCPY(&VAR_4->client, &ip->ip_src, sizeof(ip->ip_src));
UNALIGNED_MEMCPY(&VAR_4->server, &ip->ip_dst, sizeof(ip->ip_dst));
}
else if (VAR_3) {
VAR_4->ipver = 6;
UNALIGNED_MEMCPY(&VAR_4->client, &VAR_3->ip6_src, sizeof(VAR_3->ip6_src));
UNALIGNED_MEMCPY(&VAR_4->server, &VAR_3->ip6_dst, sizeof(VAR_3->ip6_dst));
}
VAR_4->proc = EXTRACT_32BITS(&VAR_1->rm_call.cb_proc);
VAR_4->vers = EXTRACT_32BITS(&VAR_1->rm_call.cb_vers);
return (1);
}",the-tcpdump-group/tcpdump/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd/print-nfs.c/vul/before/0.json,"static int
xid_map_enter(netdissect_options *ndo,
              const struct sunrpc_msg *rp, const u_char *bp)
{
	const struct ip *ip = NULL;
	const struct ip6_hdr *ip6 = NULL;
	struct xid_map_entry *xmep;

	if (!ND_TTEST(rp->rm_call.cb_vers))
		return (0);
	switch (IP_V((const struct ip *)bp)) {
	case 4:
		ip = (const struct ip *)bp;
		break;
	case 6:
		ip6 = (const struct ip6_hdr *)bp;
		break;
	default:
		return (1);
	}

	xmep = &xid_map[xid_map_next];

	if (++xid_map_next >= XIDMAPSIZE)
		xid_map_next = 0;

	UNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));
	if (ip) {
		xmep->ipver = 4;
		UNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));
		UNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));
	}
	else if (ip6) {
		xmep->ipver = 6;
		UNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));
		UNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));
	}
	if (!ND_TTEST(rp->rm_call.cb_proc))
		return (0);
	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
	if (!ND_TTEST(rp->rm_call.cb_vers))
		return (0);
	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
	return (1);
}","static int
xid_map_enter(netdissect_options *VAR_0,
              const struct sunrpc_msg *VAR_1, const u_char *VAR_2)
{
	const struct ip *ip = NULL;
	const struct ip6_hdr *VAR_3 = NULL;
	struct xid_map_entry *VAR_4;

	if (!ND_TTEST(VAR_1->rm_call.cb_vers))
		return (0);
	switch (IP_V((const struct ip *)VAR_2)) {
	case 4:
		ip = (const struct ip *)VAR_2;
		break;
	case 6:
		VAR_3 = (const struct ip6_hdr *)VAR_2;
		break;
	default:
		return (1);
	}

	VAR_4 = &VAR_5[VAR_6];

	if (++VAR_6 >= VAR_7)
		VAR_6 = 0;

	UNALIGNED_MEMCPY(&VAR_4->xid, &VAR_1->rm_xid, sizeof(VAR_4->xid));
	if (ip) {
		VAR_4->ipver = 4;
		UNALIGNED_MEMCPY(&VAR_4->client, &ip->ip_src, sizeof(ip->ip_src));
		UNALIGNED_MEMCPY(&VAR_4->server, &ip->ip_dst, sizeof(ip->ip_dst));
	}
	else if (VAR_3) {
		VAR_4->ipver = 6;
		UNALIGNED_MEMCPY(&VAR_4->client, &VAR_3->ip6_src, sizeof(VAR_3->ip6_src));
		UNALIGNED_MEMCPY(&VAR_4->server, &VAR_3->ip6_dst, sizeof(VAR_3->ip6_dst));
	}
	if (!ND_TTEST(VAR_1->rm_call.cb_proc))
		return (0);
	VAR_4->proc = EXTRACT_32BITS(&VAR_1->rm_call.cb_proc);
	if (!ND_TTEST(VAR_1->rm_call.cb_vers))
		return (0);
	VAR_4->vers = EXTRACT_32BITS(&VAR_1->rm_call.cb_vers);
	return (1);
}",the-tcpdump-group/tcpdump/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd/print-nfs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,7 +35,11 @@
 		UNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));
 		UNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));
 	}
+	if (!ND_TTEST(rp->rm_call.cb_proc))
+		return (0);
 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
+	if (!ND_TTEST(rp->rm_call.cb_vers))
+		return (0);
 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
 	return (1);
 }","{'deleted_lines': [], 'added_lines': ['\tif (!ND_TTEST(rp->rm_call.cb_proc))', '\t\treturn (0);', '\tif (!ND_TTEST(rp->rm_call.cb_vers))', '\t\treturn (0);']}",True,The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:xid_map_enter().,9.8,CRITICAL,3,valid,2017-02-23T15:50:18Z,1
CVE-2017-15377,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,OISF/suricata,"detect: avoid needless recursive scanning

Don't recursively inspect a detect list if the recursion
doesn't increase chance of success.",b9579fbe7dd408200ef03cbe20efddb624b73885,https://github.com/OISF/suricata/commit/b9579fbe7dd408200ef03cbe20efddb624b73885,src/detect-engine-content-inspection.c,DetectEngineContentInspection,"int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,
const Signature *s, const SigMatchData *smd,
Flow *f,
uint8_t *buffer, uint32_t buffer_len,
uint32_t stream_start_offset,
uint8_t inspection_mode, void *data)
{
SCEnter();
KEYWORD_PROFILING_START;
det_ctx->inspection_recursion_counter++;
if (det_ctx->inspection_recursion_counter == de_ctx->inspection_recursion_limit) {
det_ctx->discontinue_matching = 1;
KEYWORD_PROFILING_END(det_ctx, smd->type, 0);
SCReturnInt(0);
}
if (smd == NULL || buffer_len == 0) {
KEYWORD_PROFILING_END(det_ctx, smd->type, 0);
SCReturnInt(0);
}
if (smd->type == DETECT_CONTENT) {
DetectContentData *cd = (DetectContentData *)smd->ctx;
SCLogDebug(""inspecting content %""PRIu32"" buffer_len %""PRIu32, cd->id, buffer_len);
#ifdef DEBUG
BUG_ON(cd->depth != 0 && cd->depth <= cd->offset);
#endif
uint8_t *found = NULL;
uint32_t offset = 0;
uint32_t depth = buffer_len;
uint32_t prev_offset = 0; 
uint32_t prev_buffer_offset = det_ctx->buffer_offset;
do {
if ((cd->flags & DETECT_CONTENT_DISTANCE) ||
(cd->flags & DETECT_CONTENT_WITHIN)) {
SCLogDebug(""det_ctx->buffer_offset %""PRIu32, det_ctx->buffer_offset);
offset = prev_buffer_offset;
depth = buffer_len;
int distance = cd->distance;
if (cd->flags & DETECT_CONTENT_DISTANCE) {
if (cd->flags & DETECT_CONTENT_DISTANCE_BE) {
distance = det_ctx->bj_values[cd->distance];
}
if (distance < 0 && (uint32_t)(abs(distance)) > offset)
offset = 0;
else
offset += distance;
SCLogDebug(""cd->distance %""PRIi32"", offset %""PRIu32"", depth %""PRIu32,
distance, offset, depth);
}
if (cd->flags & DETECT_CONTENT_WITHIN) {
if (cd->flags & DETECT_CONTENT_WITHIN_BE) {
if ((int32_t)depth > (int32_t)(prev_buffer_offset + det_ctx->bj_values[cd->within] + distance)) {
depth = prev_buffer_offset + det_ctx->bj_values[cd->within] + distance;
}
} else {
if ((int32_t)depth > (int32_t)(prev_buffer_offset + cd->within + distance)) {
depth = prev_buffer_offset + cd->within + distance;
}
SCLogDebug(""cd->within %""PRIi32"", det_ctx->buffer_offset %""PRIu32"", depth %""PRIu32,
cd->within, prev_buffer_offset, depth);
}
if (stream_start_offset != 0 && prev_buffer_offset == 0) {
if (depth <= stream_start_offset) {
goto no_match;
} else if (depth >= (stream_start_offset + buffer_len)) {
;
} else {
depth = depth - stream_start_offset;
}
}
}
if (cd->flags & DETECT_CONTENT_DEPTH_BE) {
if ((det_ctx->bj_values[cd->depth] + prev_buffer_offset) < depth) {
depth = prev_buffer_offset + det_ctx->bj_values[cd->depth];
}
} else {
if (cd->depth != 0) {
if ((cd->depth + prev_buffer_offset) < depth) {
depth = prev_buffer_offset + cd->depth;
}
SCLogDebug(""cd->depth %""PRIu32"", depth %""PRIu32, cd->depth, depth);
}
}
if (cd->flags & DETECT_CONTENT_OFFSET_BE) {
if (det_ctx->bj_values[cd->offset] > offset)
offset = det_ctx->bj_values[cd->offset];
} else {
if (cd->offset > offset) {
offset = cd->offset;
SCLogDebug(""setting offset %""PRIu32, offset);
}
}
} else { 
if (cd->flags & DETECT_CONTENT_DEPTH_BE) {
depth = det_ctx->bj_values[cd->depth];
} else {
if (cd->depth != 0) {
depth = cd->depth;
}
}
if (stream_start_offset != 0 && cd->flags & DETECT_CONTENT_DEPTH) {
if (depth <= stream_start_offset) {
goto no_match;
} else if (depth >= (stream_start_offset + buffer_len)) {
;
} else {
depth = depth - stream_start_offset;
}
}
if (cd->flags & DETECT_CONTENT_OFFSET_BE)
offset = det_ctx->bj_values[cd->offset];
else
offset = cd->offset;
prev_buffer_offset = 0;
}
SCLogDebug(""offset %""PRIu32"", prev_offset %""PRIu32, offset, prev_offset);
if (prev_offset != 0)
offset = prev_offset;
SCLogDebug(""offset %""PRIu32"", depth %""PRIu32, offset, depth);
if (depth > buffer_len)
depth = buffer_len;
if (offset > depth || depth == 0) {
if (cd->flags & DETECT_CONTENT_NEGATED) {
goto match;
} else {
goto no_match;
}
}
uint8_t *sbuffer = buffer + offset;
uint32_t sbuffer_len = depth - offset;
uint32_t match_offset = 0;
SCLogDebug(""sbuffer_len %""PRIu32, sbuffer_len);
#ifdef DEBUG
BUG_ON(sbuffer_len > buffer_len);
#endif
found = SpmScan(cd->spm_ctx, det_ctx->spm_thread_ctx, sbuffer,
sbuffer_len);
SCLogDebug(""found %p cd negated %s"", found, cd->flags & DETECT_CONTENT_NEGATED ? ""true"" : ""false"");
if (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {
goto no_match;
} else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {
goto match;
} else if (found != NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {
SCLogDebug(""content %""PRIu32"" matched at offset %""PRIu32"", but negated so no match"", cd->id, match_offset);
if (DETECT_CONTENT_IS_SINGLE(cd))
det_ctx->discontinue_matching = 1;
goto no_match;
} else {
match_offset = (uint32_t)((found - buffer) + cd->content_len);
SCLogDebug(""content %""PRIu32"" matched at offset %""PRIu32"""", cd->id, match_offset);
det_ctx->buffer_offset = match_offset;
if (cd->flags & DETECT_CONTENT_REPLACE) {
if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD) {
det_ctx->replist = DetectReplaceAddToList(det_ctx->replist, found, cd);
} else {
SCLogWarning(SC_ERR_INVALID_VALUE, ""Can't modify payload without packet"");
}
}
if (!(cd->flags & DETECT_CONTENT_RELATIVE_NEXT)) {
SCLogDebug(""no relative match coming up, so this is a match"");
goto match;
}
if (smd->is_last) {
goto no_match;
}
SCLogDebug(""content %""PRIu32, cd->id);
KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,
f, buffer, buffer_len, stream_start_offset, inspection_mode, data);
if (r == 1) {
SCReturnInt(1);
}
if (det_ctx->discontinue_matching)
goto no_match;
prev_offset = (match_offset - (cd->content_len - 1));
SCLogDebug(""trying to see if there is another match after prev_offset %""PRIu32, prev_offset);
}
} while(1);
} else if (smd->type == DETECT_ISDATAAT) {
SCLogDebug(""inspecting isdataat"");
DetectIsdataatData *id = (DetectIsdataatData *)smd->ctx;
if (id->flags & ISDATAAT_RELATIVE) {
if (det_ctx->buffer_offset + id->dataat > buffer_len) {
SCLogDebug(""det_ctx->buffer_offset + id->dataat %""PRIu32"" > %""PRIu32, det_ctx->buffer_offset + id->dataat, buffer_len);
if (id->flags & ISDATAAT_NEGATED)
goto match;
goto no_match;
} else {
SCLogDebug(""relative isdataat match"");
if (id->flags & ISDATAAT_NEGATED)
goto no_match;
goto match;
}
} else {
if (id->dataat < buffer_len) {
SCLogDebug(""absolute isdataat match"");
if (id->flags & ISDATAAT_NEGATED)
goto no_match;
goto match;
} else {
SCLogDebug(""absolute isdataat mismatch, id->isdataat %""PRIu32"", buffer_len %""PRIu32"""", id->dataat, buffer_len);
if (id->flags & ISDATAAT_NEGATED)
goto match;
goto no_match;
}
}
} else if (smd->type == DETECT_PCRE) {
SCLogDebug(""inspecting pcre"");
DetectPcreData *pe = (DetectPcreData *)smd->ctx;
uint32_t prev_buffer_offset = det_ctx->buffer_offset;
uint32_t prev_offset = 0;
int r = 0;
det_ctx->pcre_match_start_offset = 0;
do {
Packet *p = NULL;
if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD)
p = (Packet *)data;
r = DetectPcrePayloadMatch(det_ctx, s, smd, p, f,
buffer, buffer_len);
if (r == 0) {
goto no_match;
}
if (!(pe->flags & DETECT_PCRE_RELATIVE_NEXT)) {
SCLogDebug(""no relative match coming up, so this is a match"");
goto match;
}
KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
prev_offset = det_ctx->pcre_match_start_offset;
r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,
f, buffer, buffer_len, stream_start_offset, inspection_mode, data);
if (r == 1) {
SCReturnInt(1);
}
if (det_ctx->discontinue_matching)
goto no_match;
det_ctx->buffer_offset = prev_buffer_offset;
det_ctx->pcre_match_start_offset = prev_offset;
} while (1);
} else if (smd->type == DETECT_BYTETEST) {
DetectBytetestData *btd = (DetectBytetestData *)smd->ctx;
uint8_t flags = btd->flags;
int32_t offset = btd->offset;
uint64_t value = btd->value;
if (flags & DETECT_BYTETEST_OFFSET_BE) {
offset = det_ctx->bj_values[offset];
}
if (flags & DETECT_BYTETEST_VALUE_BE) {
value = det_ctx->bj_values[value];
}
if (flags & DETECT_BYTETEST_DCE && data != NULL) {
DCERPCState *dcerpc_state = (DCERPCState *)data;
flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
DETECT_BYTETEST_LITTLE: 0);
}
if (DetectBytetestDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len, flags,
offset, value) != 1) {
goto no_match;
}
goto match;
} else if (smd->type == DETECT_BYTEJUMP) {
DetectBytejumpData *bjd = (DetectBytejumpData *)smd->ctx;
uint8_t flags = bjd->flags;
int32_t offset = bjd->offset;
if (flags & DETECT_BYTEJUMP_OFFSET_BE) {
offset = det_ctx->bj_values[offset];
}
if (flags & DETECT_BYTEJUMP_DCE && data != NULL) {
DCERPCState *dcerpc_state = (DCERPCState *)data;
flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
DETECT_BYTEJUMP_LITTLE: 0);
}
if (DetectBytejumpDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len,
flags, offset) != 1) {
goto no_match;
}
goto match;
} else if (smd->type == DETECT_BYTE_EXTRACT) {
DetectByteExtractData *bed = (DetectByteExtractData *)smd->ctx;
uint8_t endian = bed->endian;
if ((bed->flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN) &&
endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL) {
DCERPCState *dcerpc_state = (DCERPCState *)data;
endian |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?
DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG);
}
if (DetectByteExtractDoMatch(det_ctx, smd, s, buffer,
buffer_len,
&det_ctx->bj_values[bed->local_id],
endian) != 1) {
goto no_match;
}
goto match;
} else if (smd->type == DETECT_AL_URILEN) {
SCLogDebug(""inspecting uri len"");
int r = 0;
DetectUrilenData *urilend = (DetectUrilenData *) smd->ctx;
switch (urilend->mode) {
case DETECT_URILEN_EQ:
if (buffer_len == urilend->urilen1)
r = 1;
break;
case DETECT_URILEN_LT:
if (buffer_len < urilend->urilen1)
r = 1;
break;
case DETECT_URILEN_GT:
if (buffer_len > urilend->urilen1)
r = 1;
break;
case DETECT_URILEN_RA:
if (buffer_len > urilend->urilen1 &&
buffer_len < urilend->urilen2) {
r = 1;
}
break;
}
if (r == 1) {
goto match;
}
det_ctx->discontinue_matching = 0;
goto no_match;
#ifdef HAVE_LUA
}
else if (smd->type == DETECT_LUA) {
SCLogDebug(""lua starting"");
if (DetectLuaMatchBuffer(det_ctx, s, smd, buffer, buffer_len,
det_ctx->buffer_offset, f) != 1)
{
SCLogDebug(""lua no_match"");
goto no_match;
}
SCLogDebug(""lua match"");
goto match;
#endif 
} else if (smd->type == DETECT_BASE64_DECODE) {
if (DetectBase64DecodeDoMatch(det_ctx, s, smd, buffer, buffer_len)) {
if (s->sm_arrays[DETECT_SM_LIST_BASE64_DATA] != NULL) {
KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
if (DetectBase64DataDoMatch(de_ctx, det_ctx, s, f)) {
goto final_match;
}
}
}
} else {
SCLogDebug(""sm->type %u"", smd->type);
#ifdef DEBUG
BUG_ON(1);
#endif
}
no_match:
KEYWORD_PROFILING_END(det_ctx, smd->type, 0);
SCReturnInt(0);
match:
if (!smd->is_last) {
KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,
f, buffer, buffer_len, stream_start_offset, inspection_mode, data);
SCReturnInt(r);
}
final_match:
KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
SCReturnInt(1);
}","int DetectEngineContentInspection(DetectEngineCtx *VAR_0, DetectEngineThreadCtx *VAR_1,
const Signature *VAR_2, const SigMatchData *VAR_3,
Flow *VAR_4,
uint8_t *VAR_5, uint32_t VAR_6,
uint32_t VAR_7,
uint8_t VAR_8, void *VAR_9)
{
SCEnter();
VAR_10;
VAR_1->inspection_recursion_counter++;
if (VAR_1->inspection_recursion_counter == VAR_0->inspection_recursion_limit) {
VAR_1->discontinue_matching = 1;
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);
SCReturnInt(0);
}
if (VAR_3 == NULL || VAR_6 == 0) {
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);
SCReturnInt(0);
}
if (VAR_3->type == VAR_11) {
DetectContentData *VAR_12 = (DetectContentData *)VAR_3->ctx;
SCLogDebug(""inspecting content %""VAR_13"" buffer_len %""VAR_13, VAR_12->id, VAR_6);
#ifdef VAR_14
BUG_ON(VAR_12->depth != 0 && VAR_12->depth <= VAR_12->offset);
#endif
uint8_t *VAR_15 = NULL;
uint32_t VAR_16 = 0;
uint32_t VAR_17 = VAR_6;
uint32_t VAR_18 = 0; 
uint32_t VAR_19 = VAR_1->buffer_offset;
do {
if ((VAR_12->flags & VAR_20) ||
(VAR_12->flags & VAR_21)) {
SCLogDebug(""det_ctx->buffer_offset %""VAR_13, VAR_1->buffer_offset);
VAR_16 = VAR_19;
VAR_17 = VAR_6;
int VAR_22 = VAR_12->distance;
if (VAR_12->flags & VAR_20) {
if (VAR_12->flags & VAR_23) {
VAR_22 = VAR_1->bj_values[VAR_12->distance];
}
if (VAR_22 < 0 && (uint32_t)(abs(VAR_22)) > VAR_16)
VAR_16 = 0;
else
VAR_16 += VAR_22;
SCLogDebug(""cd->distance %""VAR_24"", offset %""VAR_13"", depth %""VAR_13,
VAR_22, VAR_16, VAR_17);
}
if (VAR_12->flags & VAR_21) {
if (VAR_12->flags & VAR_25) {
if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22)) {
VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22;
}
} else {
if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_12->within + VAR_22)) {
VAR_17 = VAR_19 + VAR_12->within + VAR_22;
}
SCLogDebug(""cd->within %""VAR_24"", det_ctx->buffer_offset %""VAR_13"", depth %""VAR_13,
VAR_12->within, VAR_19, VAR_17);
}
if (VAR_7 != 0 && VAR_19 == 0) {
if (VAR_17 <= VAR_7) {
goto no_match;
} else if (VAR_17 >= (VAR_7 + VAR_6)) {
;
} else {
VAR_17 = VAR_17 - VAR_7;
}
}
}
if (VAR_12->flags & VAR_26) {
if ((VAR_1->bj_values[VAR_12->depth] + VAR_19) < VAR_17) {
VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->depth];
}
} else {
if (VAR_12->depth != 0) {
if ((VAR_12->depth + VAR_19) < VAR_17) {
VAR_17 = VAR_19 + VAR_12->depth;
}
SCLogDebug(""cd->depth %""VAR_13"", depth %""VAR_13, VAR_12->depth, VAR_17);
}
}
if (VAR_12->flags & VAR_27) {
if (VAR_1->bj_values[VAR_12->offset] > VAR_16)
VAR_16 = VAR_1->bj_values[VAR_12->offset];
} else {
if (VAR_12->offset > VAR_16) {
VAR_16 = VAR_12->offset;
SCLogDebug(""setting offset %""VAR_13, VAR_16);
}
}
} else { 
if (VAR_12->flags & VAR_26) {
VAR_17 = VAR_1->bj_values[VAR_12->depth];
} else {
if (VAR_12->depth != 0) {
VAR_17 = VAR_12->depth;
}
}
if (VAR_7 != 0 && VAR_12->flags & VAR_28) {
if (VAR_17 <= VAR_7) {
goto no_match;
} else if (VAR_17 >= (VAR_7 + VAR_6)) {
;
} else {
VAR_17 = VAR_17 - VAR_7;
}
}
if (VAR_12->flags & VAR_27)
VAR_16 = VAR_1->bj_values[VAR_12->offset];
else
VAR_16 = VAR_12->offset;
VAR_19 = 0;
}
SCLogDebug(""offset %""VAR_13"", prev_offset %""VAR_13, VAR_16, VAR_18);
if (VAR_18 != 0)
VAR_16 = VAR_18;
SCLogDebug(""offset %""VAR_13"", depth %""VAR_13, VAR_16, VAR_17);
if (VAR_17 > VAR_6)
VAR_17 = VAR_6;
if (VAR_16 > VAR_17 || VAR_17 == 0) {
if (VAR_12->flags & VAR_29) {
goto match;
} else {
goto no_match;
}
}
uint8_t *VAR_30 = VAR_5 + VAR_16;
uint32_t VAR_31 = VAR_17 - VAR_16;
uint32_t VAR_32 = 0;
SCLogDebug(""sbuffer_len %""VAR_13, VAR_31);
#ifdef VAR_14
BUG_ON(VAR_31 > VAR_6);
#endif
VAR_15 = SpmScan(VAR_12->spm_ctx, VAR_1->spm_thread_ctx, VAR_30,
VAR_31);
SCLogDebug(""found %p cd negated %s"", VAR_15, VAR_12->flags & VAR_29 ? ""true"" : ""false"");
if (VAR_15 == NULL && !(VAR_12->flags & VAR_29)) {
goto no_match;
} else if (VAR_15 == NULL && (VAR_12->flags & VAR_29)) {
goto match;
} else if (VAR_15 != NULL && (VAR_12->flags & VAR_29)) {
SCLogDebug(""content %""VAR_13"" matched at offset %""VAR_13"", but negated so no match"", VAR_12->id, VAR_32);
if (DETECT_CONTENT_IS_SINGLE(VAR_12))
VAR_1->discontinue_matching = 1;
goto no_match;
} else {
VAR_32 = (uint32_t)((VAR_15 - VAR_5) + VAR_12->content_len);
SCLogDebug(""content %""VAR_13"" matched at offset %""VAR_13"""", VAR_12->id, VAR_32);
VAR_1->buffer_offset = VAR_32;
if (VAR_12->flags & VAR_33) {
if (VAR_8 == VAR_34) {
VAR_1->replist = DetectReplaceAddToList(VAR_1->replist, VAR_15, VAR_12);
} else {
SCLogWarning(VAR_35, ""Can't modify payload without packet"");
}
}
if (!(VAR_12->flags & VAR_36)) {
SCLogDebug(""no relative match coming up, so this is a match"");
goto match;
}
if (VAR_3->is_last) {
goto no_match;
}
SCLogDebug(""content %""VAR_13, VAR_12->id);
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
int VAR_37 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,
VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);
if (VAR_37 == 1) {
SCReturnInt(1);
}
if (VAR_1->discontinue_matching)
goto no_match;
VAR_18 = (VAR_32 - (VAR_12->content_len - 1));
SCLogDebug(""trying to see if there is another match after prev_offset %""VAR_13, VAR_18);
}
} while(1);
} else if (VAR_3->type == VAR_38) {
SCLogDebug(""inspecting isdataat"");
DetectIsdataatData *VAR_39 = (DetectIsdataatData *)VAR_3->ctx;
if (VAR_39->flags & VAR_40) {
if (VAR_1->buffer_offset + VAR_39->dataat > VAR_6) {
SCLogDebug(""det_ctx->buffer_offset + id->dataat %""VAR_13"" > %""VAR_13, VAR_1->buffer_offset + VAR_39->dataat, VAR_6);
if (VAR_39->flags & VAR_41)
goto match;
goto no_match;
} else {
SCLogDebug(""relative isdataat match"");
if (VAR_39->flags & VAR_41)
goto no_match;
goto match;
}
} else {
if (VAR_39->dataat < VAR_6) {
SCLogDebug(""absolute isdataat match"");
if (VAR_39->flags & VAR_41)
goto no_match;
goto match;
} else {
SCLogDebug(""absolute isdataat mismatch, id->isdataat %""VAR_13"", buffer_len %""VAR_13"""", VAR_39->dataat, VAR_6);
if (VAR_39->flags & VAR_41)
goto match;
goto no_match;
}
}
} else if (VAR_3->type == VAR_42) {
SCLogDebug(""inspecting pcre"");
DetectPcreData *VAR_43 = (DetectPcreData *)VAR_3->ctx;
uint32_t VAR_19 = VAR_1->buffer_offset;
uint32_t VAR_18 = 0;
int VAR_37 = 0;
VAR_1->pcre_match_start_offset = 0;
do {
Packet *VAR_44 = NULL;
if (VAR_8 == VAR_34)
VAR_44 = (Packet *)VAR_9;
VAR_37 = DetectPcrePayloadMatch(VAR_1, VAR_2, VAR_3, VAR_44, VAR_4,
VAR_5, VAR_6);
if (VAR_37 == 0) {
goto no_match;
}
if (!(VAR_43->flags & VAR_45)) {
SCLogDebug(""no relative match coming up, so this is a match"");
goto match;
}
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
VAR_18 = VAR_1->pcre_match_start_offset;
VAR_37 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,
VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);
if (VAR_37 == 1) {
SCReturnInt(1);
}
if (VAR_1->discontinue_matching)
goto no_match;
VAR_1->buffer_offset = VAR_19;
VAR_1->pcre_match_start_offset = VAR_18;
} while (1);
} else if (VAR_3->type == VAR_46) {
DetectBytetestData *VAR_47 = (DetectBytetestData *)VAR_3->ctx;
uint8_t VAR_48 = VAR_47->flags;
int32_t VAR_16 = VAR_47->offset;
uint64_t VAR_49 = VAR_47->value;
if (VAR_48 & VAR_50) {
VAR_16 = VAR_1->bj_values[VAR_16];
}
if (VAR_48 & VAR_51) {
VAR_49 = VAR_1->bj_values[VAR_49];
}
if (VAR_48 & VAR_52 && VAR_9 != NULL) {
DCERPCState *VAR_53 = (DCERPCState *)VAR_9;
VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
VAR_54: 0);
}
if (DetectBytetestDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6, VAR_48,
VAR_16, VAR_49) != 1) {
goto no_match;
}
goto match;
} else if (VAR_3->type == VAR_55) {
DetectBytejumpData *VAR_56 = (DetectBytejumpData *)VAR_3->ctx;
uint8_t VAR_48 = VAR_56->flags;
int32_t VAR_16 = VAR_56->offset;
if (VAR_48 & VAR_57) {
VAR_16 = VAR_1->bj_values[VAR_16];
}
if (VAR_48 & VAR_58 && VAR_9 != NULL) {
DCERPCState *VAR_53 = (DCERPCState *)VAR_9;
VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
VAR_59: 0);
}
if (DetectBytejumpDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6,
VAR_48, VAR_16) != 1) {
goto no_match;
}
goto match;
} else if (VAR_3->type == VAR_60) {
DetectByteExtractData *VAR_61 = (DetectByteExtractData *)VAR_3->ctx;
uint8_t VAR_62 = VAR_61->endian;
if ((VAR_61->flags & VAR_63) &&
VAR_62 == VAR_64 && VAR_9 != NULL) {
DCERPCState *VAR_53 = (DCERPCState *)VAR_9;
VAR_62 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?
VAR_65 : VAR_66);
}
if (DetectByteExtractDoMatch(VAR_1, VAR_3, VAR_2, VAR_5,
VAR_6,
&VAR_1->bj_values[VAR_61->local_id],
VAR_62) != 1) {
goto no_match;
}
goto match;
} else if (VAR_3->type == VAR_67) {
SCLogDebug(""inspecting uri len"");
int VAR_37 = 0;
DetectUrilenData *VAR_68 = (DetectUrilenData *) VAR_3->ctx;
switch (VAR_68->mode) {
case VAR_69:
if (VAR_6 == VAR_68->urilen1)
VAR_37 = 1;
break;
case VAR_70:
if (VAR_6 < VAR_68->urilen1)
VAR_37 = 1;
break;
case VAR_71:
if (VAR_6 > VAR_68->urilen1)
VAR_37 = 1;
break;
case VAR_72:
if (VAR_6 > VAR_68->urilen1 &&
VAR_6 < VAR_68->urilen2) {
VAR_37 = 1;
}
break;
}
if (VAR_37 == 1) {
goto match;
}
VAR_1->discontinue_matching = 0;
goto no_match;
#ifdef VAR_73
}
else if (VAR_3->type == VAR_74) {
SCLogDebug(""lua starting"");
if (DetectLuaMatchBuffer(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6,
VAR_1->buffer_offset, VAR_4) != 1)
{
SCLogDebug(""lua no_match"");
goto no_match;
}
SCLogDebug(""lua match"");
goto match;
#endif
} else if (smd->type == DETECT_BASE64_DECODE) {
if (DetectBase64DecodeDoMatch(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6)) {
if (VAR_2->sm_arrays[VAR_75] != NULL) {
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
if (DetectBase64DataDoMatch(VAR_0, VAR_1, VAR_2, VAR_4)) {
goto final_match;
}
}
}
} else {
SCLogDebug(""sm->type %u"", VAR_3->type);
#ifdef VAR_14
BUG_ON(1);
#endif
}
no_match:
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);
SCReturnInt(0);
match:
if (!VAR_3->is_last) {
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
int VAR_37 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,
VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);
SCReturnInt(VAR_37);
}
final_match:
KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
SCReturnInt(1);
}",OISF/suricata/b9579fbe7dd408200ef03cbe20efddb624b73885/detect-engine-content-inspection.c/vul/before/0.json,"int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,
                                  const Signature *s, const SigMatchData *smd,
                                  Flow *f,
                                  uint8_t *buffer, uint32_t buffer_len,
                                  uint32_t stream_start_offset,
                                  uint8_t inspection_mode, void *data)
{
    SCEnter();
    KEYWORD_PROFILING_START;

    det_ctx->inspection_recursion_counter++;

    if (det_ctx->inspection_recursion_counter == de_ctx->inspection_recursion_limit) {
        det_ctx->discontinue_matching = 1;
        KEYWORD_PROFILING_END(det_ctx, smd->type, 0);
        SCReturnInt(0);
    }

    if (smd == NULL || buffer_len == 0) {
        KEYWORD_PROFILING_END(det_ctx, smd->type, 0);
        SCReturnInt(0);
    }

    /* \todo unify this which is phase 2 of payload inspection unification */
    if (smd->type == DETECT_CONTENT) {

        DetectContentData *cd = (DetectContentData *)smd->ctx;
        SCLogDebug(""inspecting content %""PRIu32"" buffer_len %""PRIu32, cd->id, buffer_len);

        /* we might have already have this content matched by the mpm.
         * (if there is any other reason why we'd want to avoid checking
         *  it here, please fill it in) */
        //if (cd->flags & DETECT_CONTENT_NO_DOUBLE_INSPECTION_REQUIRED) {
        //    goto match;
        //}

        /* rule parsers should take care of this */
#ifdef DEBUG
        BUG_ON(cd->depth != 0 && cd->depth <= cd->offset);
#endif

        /* search for our pattern, checking the matches recursively.
         * if we match we look for the next SigMatch as well */
        uint8_t *found = NULL;
        uint32_t offset = 0;
        uint32_t depth = buffer_len;
        uint32_t prev_offset = 0; /**< used in recursive searching */
        uint32_t prev_buffer_offset = det_ctx->buffer_offset;

        do {
            if ((cd->flags & DETECT_CONTENT_DISTANCE) ||
                (cd->flags & DETECT_CONTENT_WITHIN)) {
                SCLogDebug(""det_ctx->buffer_offset %""PRIu32, det_ctx->buffer_offset);

                offset = prev_buffer_offset;
                depth = buffer_len;

                int distance = cd->distance;
                if (cd->flags & DETECT_CONTENT_DISTANCE) {
                    if (cd->flags & DETECT_CONTENT_DISTANCE_BE) {
                        distance = det_ctx->bj_values[cd->distance];
                    }
                    if (distance < 0 && (uint32_t)(abs(distance)) > offset)
                        offset = 0;
                    else
                        offset += distance;

                    SCLogDebug(""cd->distance %""PRIi32"", offset %""PRIu32"", depth %""PRIu32,
                               distance, offset, depth);
                }

                if (cd->flags & DETECT_CONTENT_WITHIN) {
                    if (cd->flags & DETECT_CONTENT_WITHIN_BE) {
                        if ((int32_t)depth > (int32_t)(prev_buffer_offset + det_ctx->bj_values[cd->within] + distance)) {
                            depth = prev_buffer_offset + det_ctx->bj_values[cd->within] + distance;
                        }
                    } else {
                        if ((int32_t)depth > (int32_t)(prev_buffer_offset + cd->within + distance)) {
                            depth = prev_buffer_offset + cd->within + distance;
                        }

                        SCLogDebug(""cd->within %""PRIi32"", det_ctx->buffer_offset %""PRIu32"", depth %""PRIu32,
                                   cd->within, prev_buffer_offset, depth);
                    }

                    if (stream_start_offset != 0 && prev_buffer_offset == 0) {
                        if (depth <= stream_start_offset) {
                            goto no_match;
                        } else if (depth >= (stream_start_offset + buffer_len)) {
                            ;
                        } else {
                            depth = depth - stream_start_offset;
                        }
                    }
                }

                if (cd->flags & DETECT_CONTENT_DEPTH_BE) {
                    if ((det_ctx->bj_values[cd->depth] + prev_buffer_offset) < depth) {
                        depth = prev_buffer_offset + det_ctx->bj_values[cd->depth];
                    }
                } else {
                    if (cd->depth != 0) {
                        if ((cd->depth + prev_buffer_offset) < depth) {
                            depth = prev_buffer_offset + cd->depth;
                        }

                        SCLogDebug(""cd->depth %""PRIu32"", depth %""PRIu32, cd->depth, depth);
                    }
                }

                if (cd->flags & DETECT_CONTENT_OFFSET_BE) {
                    if (det_ctx->bj_values[cd->offset] > offset)
                        offset = det_ctx->bj_values[cd->offset];
                } else {
                    if (cd->offset > offset) {
                        offset = cd->offset;
                        SCLogDebug(""setting offset %""PRIu32, offset);
                    }
                }
            } else { /* implied no relative matches */
                /* set depth */
                if (cd->flags & DETECT_CONTENT_DEPTH_BE) {
                    depth = det_ctx->bj_values[cd->depth];
                } else {
                    if (cd->depth != 0) {
                        depth = cd->depth;
                    }
                }

                if (stream_start_offset != 0 && cd->flags & DETECT_CONTENT_DEPTH) {
                    if (depth <= stream_start_offset) {
                        goto no_match;
                    } else if (depth >= (stream_start_offset + buffer_len)) {
                        ;
                    } else {
                        depth = depth - stream_start_offset;
                    }
                }

                /* set offset */
                if (cd->flags & DETECT_CONTENT_OFFSET_BE)
                    offset = det_ctx->bj_values[cd->offset];
                else
                    offset = cd->offset;
                prev_buffer_offset = 0;
            }

            /* update offset with prev_offset if we're searching for
             * matches after the first occurence. */
            SCLogDebug(""offset %""PRIu32"", prev_offset %""PRIu32, offset, prev_offset);
            if (prev_offset != 0)
                offset = prev_offset;

            SCLogDebug(""offset %""PRIu32"", depth %""PRIu32, offset, depth);

            if (depth > buffer_len)
                depth = buffer_len;

            /* if offset is bigger than depth we can never match on a pattern.
             * We can however, ""match"" on a negated pattern. */
            if (offset > depth || depth == 0) {
                if (cd->flags & DETECT_CONTENT_NEGATED) {
                    goto match;
                } else {
                    goto no_match;
                }
            }

            uint8_t *sbuffer = buffer + offset;
            uint32_t sbuffer_len = depth - offset;
            uint32_t match_offset = 0;
            SCLogDebug(""sbuffer_len %""PRIu32, sbuffer_len);
#ifdef DEBUG
            BUG_ON(sbuffer_len > buffer_len);
#endif

            /* \todo Add another optimization here.  If cd->content_len is
             * greater than sbuffer_len found is anyways NULL */

            /* do the actual search */
            found = SpmScan(cd->spm_ctx, det_ctx->spm_thread_ctx, sbuffer,
                            sbuffer_len);

            /* next we evaluate the result in combination with the
             * negation flag. */
            SCLogDebug(""found %p cd negated %s"", found, cd->flags & DETECT_CONTENT_NEGATED ? ""true"" : ""false"");

            if (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {
                if ((cd->flags & (DETECT_CONTENT_DISTANCE|DETECT_CONTENT_WITHIN)) == 0) {
                    /* independent match from previous matches, so failure is fatal */
                    det_ctx->discontinue_matching = 1;
                }

                goto no_match;
            } else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {
                goto match;
            } else if (found != NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {
                SCLogDebug(""content %""PRIu32"" matched at offset %""PRIu32"", but negated so no match"", cd->id, match_offset);
                /* don't bother carrying recursive matches now, for preceding
                 * relative keywords */
                if (DETECT_CONTENT_IS_SINGLE(cd))
                    det_ctx->discontinue_matching = 1;
                goto no_match;
            } else {
                match_offset = (uint32_t)((found - buffer) + cd->content_len);
                SCLogDebug(""content %""PRIu32"" matched at offset %""PRIu32"""", cd->id, match_offset);
                det_ctx->buffer_offset = match_offset;

                /* Match branch, add replace to the list if needed */
                if (cd->flags & DETECT_CONTENT_REPLACE) {
                    if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD) {
                        /* we will need to replace content if match is confirmed */
                        det_ctx->replist = DetectReplaceAddToList(det_ctx->replist, found, cd);
                    } else {
                        SCLogWarning(SC_ERR_INVALID_VALUE, ""Can't modify payload without packet"");
                    }
                }

                /* if this is the last match we're done */
                if (smd->is_last) {
                    goto match;
                }

                SCLogDebug(""content %""PRIu32, cd->id);
                KEYWORD_PROFILING_END(det_ctx, smd->type, 1);

                /* see if the next buffer keywords match. If not, we will
                 * search for another occurence of this content and see
                 * if the others match then until we run out of matches */
                int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,
                        f, buffer, buffer_len, stream_start_offset, inspection_mode, data);
                if (r == 1) {
                    SCReturnInt(1);
                }
                SCLogDebug(""no match for 'next sm'"");

                if (det_ctx->discontinue_matching) {
                    SCLogDebug(""'next sm' said to discontinue this right now"");
                    goto no_match;
                }

                /* no match and no reason to look for another instance */
                if ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {
                    SCLogDebug(""'next sm' does not depend on me, so we can give up"");
                    det_ctx->discontinue_matching = 1;
                    goto no_match;
                }

                SCLogDebug(""'next sm' depends on me %p, lets see what we can do (flags %u)"", cd, cd->flags);

                /* set the previous match offset to the start of this match + 1 */
                prev_offset = (match_offset - (cd->content_len - 1));
                SCLogDebug(""trying to see if there is another match after prev_offset %""PRIu32, prev_offset);
            }

        } while(1);

    } else if (smd->type == DETECT_ISDATAAT) {
        SCLogDebug(""inspecting isdataat"");

        DetectIsdataatData *id = (DetectIsdataatData *)smd->ctx;
        if (id->flags & ISDATAAT_RELATIVE) {
            if (det_ctx->buffer_offset + id->dataat > buffer_len) {
                SCLogDebug(""det_ctx->buffer_offset + id->dataat %""PRIu32"" > %""PRIu32, det_ctx->buffer_offset + id->dataat, buffer_len);
                if (id->flags & ISDATAAT_NEGATED)
                    goto match;
                goto no_match;
            } else {
                SCLogDebug(""relative isdataat match"");
                if (id->flags & ISDATAAT_NEGATED)
                    goto no_match;
                goto match;
            }
        } else {
            if (id->dataat < buffer_len) {
                SCLogDebug(""absolute isdataat match"");
                if (id->flags & ISDATAAT_NEGATED)
                    goto no_match;
                goto match;
            } else {
                SCLogDebug(""absolute isdataat mismatch, id->isdataat %""PRIu32"", buffer_len %""PRIu32"""", id->dataat, buffer_len);
                if (id->flags & ISDATAAT_NEGATED)
                    goto match;
                goto no_match;
            }
        }

    } else if (smd->type == DETECT_PCRE) {
        SCLogDebug(""inspecting pcre"");
        DetectPcreData *pe = (DetectPcreData *)smd->ctx;
        uint32_t prev_buffer_offset = det_ctx->buffer_offset;
        uint32_t prev_offset = 0;
        int r = 0;

        det_ctx->pcre_match_start_offset = 0;
        do {
            Packet *p = NULL;
            if (inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD)
                p = (Packet *)data;
            r = DetectPcrePayloadMatch(det_ctx, s, smd, p, f,
                                       buffer, buffer_len);
            if (r == 0) {
                goto no_match;
            }

            if (!(pe->flags & DETECT_PCRE_RELATIVE_NEXT)) {
                SCLogDebug(""no relative match coming up, so this is a match"");
                goto match;
            }
            KEYWORD_PROFILING_END(det_ctx, smd->type, 1);

            /* save it, in case we need to do a pcre match once again */
            prev_offset = det_ctx->pcre_match_start_offset;

            /* see if the next payload keywords match. If not, we will
             * search for another occurence of this pcre and see
             * if the others match, until we run out of matches */
            r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,
                    f, buffer, buffer_len, stream_start_offset, inspection_mode, data);
            if (r == 1) {
                SCReturnInt(1);
            }

            if (det_ctx->discontinue_matching)
                goto no_match;

            det_ctx->buffer_offset = prev_buffer_offset;
            det_ctx->pcre_match_start_offset = prev_offset;
        } while (1);

    } else if (smd->type == DETECT_BYTETEST) {
        DetectBytetestData *btd = (DetectBytetestData *)smd->ctx;
        uint8_t flags = btd->flags;
        int32_t offset = btd->offset;
        uint64_t value = btd->value;
        if (flags & DETECT_BYTETEST_OFFSET_BE) {
            offset = det_ctx->bj_values[offset];
        }
        if (flags & DETECT_BYTETEST_VALUE_BE) {
            value = det_ctx->bj_values[value];
        }

        /* if we have dce enabled we will have to use the endianness
         * specified by the dce header */
        if (flags & DETECT_BYTETEST_DCE && data != NULL) {
            DCERPCState *dcerpc_state = (DCERPCState *)data;
            /* enable the endianness flag temporarily.  once we are done
             * processing we reset the flags to the original value*/
            flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
                      DETECT_BYTETEST_LITTLE: 0);
        }

        if (DetectBytetestDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len, flags,
                                  offset, value) != 1) {
            goto no_match;
        }

        goto match;

    } else if (smd->type == DETECT_BYTEJUMP) {
        DetectBytejumpData *bjd = (DetectBytejumpData *)smd->ctx;
        uint8_t flags = bjd->flags;
        int32_t offset = bjd->offset;

        if (flags & DETECT_BYTEJUMP_OFFSET_BE) {
            offset = det_ctx->bj_values[offset];
        }

        /* if we have dce enabled we will have to use the endianness
         * specified by the dce header */
        if (flags & DETECT_BYTEJUMP_DCE && data != NULL) {
            DCERPCState *dcerpc_state = (DCERPCState *)data;
            /* enable the endianness flag temporarily.  once we are done
             * processing we reset the flags to the original value*/
            flags |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
                      DETECT_BYTEJUMP_LITTLE: 0);
        }

        if (DetectBytejumpDoMatch(det_ctx, s, smd->ctx, buffer, buffer_len,
                                  flags, offset) != 1) {
            goto no_match;
        }

        goto match;

    } else if (smd->type == DETECT_BYTE_EXTRACT) {

        DetectByteExtractData *bed = (DetectByteExtractData *)smd->ctx;
        uint8_t endian = bed->endian;

        /* if we have dce enabled we will have to use the endianness
         * specified by the dce header */
        if ((bed->flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN) &&
            endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL) {

            DCERPCState *dcerpc_state = (DCERPCState *)data;
            /* enable the endianness flag temporarily.  once we are done
             * processing we reset the flags to the original value*/
            endian |= ((dcerpc_state->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?
                       DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG);
        }

        if (DetectByteExtractDoMatch(det_ctx, smd, s, buffer,
                                     buffer_len,
                                     &det_ctx->bj_values[bed->local_id],
                                     endian) != 1) {
            goto no_match;
        }

        goto match;

        /* we should never get here, but bail out just in case */
    } else if (smd->type == DETECT_AL_URILEN) {
        SCLogDebug(""inspecting uri len"");

        int r = 0;
        DetectUrilenData *urilend = (DetectUrilenData *) smd->ctx;

        switch (urilend->mode) {
            case DETECT_URILEN_EQ:
                if (buffer_len == urilend->urilen1)
                    r = 1;
                break;
            case DETECT_URILEN_LT:
                if (buffer_len < urilend->urilen1)
                    r = 1;
                break;
            case DETECT_URILEN_GT:
                if (buffer_len > urilend->urilen1)
                    r = 1;
                break;
            case DETECT_URILEN_RA:
                if (buffer_len > urilend->urilen1 &&
                    buffer_len < urilend->urilen2) {
                    r = 1;
                }
                break;
        }

        if (r == 1) {
            goto match;
        }

        det_ctx->discontinue_matching = 0;

        goto no_match;
#ifdef HAVE_LUA
    }
    else if (smd->type == DETECT_LUA) {
        SCLogDebug(""lua starting"");

        if (DetectLuaMatchBuffer(det_ctx, s, smd, buffer, buffer_len,
                    det_ctx->buffer_offset, f) != 1)
        {
            SCLogDebug(""lua no_match"");
            goto no_match;
        }
        SCLogDebug(""lua match"");
        goto match;
#endif /* HAVE_LUA */
    } else if (smd->type == DETECT_BASE64_DECODE) {
        if (DetectBase64DecodeDoMatch(det_ctx, s, smd, buffer, buffer_len)) {
            if (s->sm_arrays[DETECT_SM_LIST_BASE64_DATA] != NULL) {
                KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
                if (DetectBase64DataDoMatch(de_ctx, det_ctx, s, f)) {
                    /* Base64 is a terminal list. */
                    goto final_match;
                }
            }
        }
    } else {
        SCLogDebug(""sm->type %u"", smd->type);
#ifdef DEBUG
        BUG_ON(1);
#endif
    }

no_match:
    KEYWORD_PROFILING_END(det_ctx, smd->type, 0);
    SCReturnInt(0);

match:
    /* this sigmatch matched, inspect the next one. If it was the last,
     * the buffer portion of the signature matched. */
    if (!smd->is_last) {
        KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
        int r = DetectEngineContentInspection(de_ctx, det_ctx, s, smd+1,
                f, buffer, buffer_len, stream_start_offset, inspection_mode, data);
        SCReturnInt(r);
    }
final_match:
    KEYWORD_PROFILING_END(det_ctx, smd->type, 1);
    SCReturnInt(1);
}","int DetectEngineContentInspection(DetectEngineCtx *VAR_0, DetectEngineThreadCtx *VAR_1,
                                  const Signature *VAR_2, const SigMatchData *VAR_3,
                                  Flow *VAR_4,
                                  uint8_t *VAR_5, uint32_t VAR_6,
                                  uint32_t VAR_7,
                                  uint8_t VAR_8, void *VAR_9)
{
    SCEnter();
    VAR_10;

    VAR_1->inspection_recursion_counter++;

    if (VAR_1->inspection_recursion_counter == VAR_0->inspection_recursion_limit) {
        VAR_1->discontinue_matching = 1;
        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);
        SCReturnInt(0);
    }

    if (VAR_3 == NULL || VAR_6 == 0) {
        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);
        SCReturnInt(0);
    }

    /* COMMENT_0 */
    if (VAR_3->type == VAR_11) {

        DetectContentData *VAR_12 = (DetectContentData *)VAR_3->ctx;
        SCLogDebug(""inspecting content %""VAR_13"" buffer_len %""VAR_13, VAR_12->id, VAR_6);

        /* COMMENT_1 */
                                                                        
                                          
        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */

        /* COMMENT_7 */
#ifdef VAR_14
        BUG_ON(VAR_12->depth != 0 && VAR_12->depth <= VAR_12->offset);
#endif

        /* COMMENT_8 */
                                                               
        uint8_t *VAR_15 = NULL;
        uint32_t VAR_16 = 0;
        uint32_t VAR_17 = VAR_6;
        uint32_t VAR_18 = 0; /* COMMENT_10 */
        uint32_t VAR_19 = VAR_1->buffer_offset;

        do {
            if ((VAR_12->flags & VAR_20) ||
                (VAR_12->flags & VAR_21)) {
                SCLogDebug(""det_ctx->buffer_offset %""VAR_13, VAR_1->buffer_offset);

                VAR_16 = VAR_19;
                VAR_17 = VAR_6;

                int VAR_22 = VAR_12->distance;
                if (VAR_12->flags & VAR_20) {
                    if (VAR_12->flags & VAR_23) {
                        VAR_22 = VAR_1->bj_values[VAR_12->distance];
                    }
                    if (VAR_22 < 0 && (uint32_t)(abs(VAR_22)) > VAR_16)
                        VAR_16 = 0;
                    else
                        VAR_16 += VAR_22;

                    SCLogDebug(""cd->distance %""VAR_24"", offset %""VAR_13"", depth %""VAR_13,
                               VAR_22, VAR_16, VAR_17);
                }

                if (VAR_12->flags & VAR_21) {
                    if (VAR_12->flags & VAR_25) {
                        if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22)) {
                            VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->within] + VAR_22;
                        }
                    } else {
                        if ((int32_t)VAR_17 > (int32_t)(VAR_19 + VAR_12->within + VAR_22)) {
                            VAR_17 = VAR_19 + VAR_12->within + VAR_22;
                        }

                        SCLogDebug(""cd->within %""VAR_24"", det_ctx->buffer_offset %""VAR_13"", depth %""VAR_13,
                                   VAR_12->within, VAR_19, VAR_17);
                    }

                    if (VAR_7 != 0 && VAR_19 == 0) {
                        if (VAR_17 <= VAR_7) {
                            goto no_match;
                        } else if (VAR_17 >= (VAR_7 + VAR_6)) {
                            ;
                        } else {
                            VAR_17 = VAR_17 - VAR_7;
                        }
                    }
                }

                if (VAR_12->flags & VAR_26) {
                    if ((VAR_1->bj_values[VAR_12->depth] + VAR_19) < VAR_17) {
                        VAR_17 = VAR_19 + VAR_1->bj_values[VAR_12->depth];
                    }
                } else {
                    if (VAR_12->depth != 0) {
                        if ((VAR_12->depth + VAR_19) < VAR_17) {
                            VAR_17 = VAR_19 + VAR_12->depth;
                        }

                        SCLogDebug(""cd->depth %""VAR_13"", depth %""VAR_13, VAR_12->depth, VAR_17);
                    }
                }

                if (VAR_12->flags & VAR_27) {
                    if (VAR_1->bj_values[VAR_12->offset] > VAR_16)
                        VAR_16 = VAR_1->bj_values[VAR_12->offset];
                } else {
                    if (VAR_12->offset > VAR_16) {
                        VAR_16 = VAR_12->offset;
                        SCLogDebug(""setting offset %""VAR_13, VAR_16);
                    }
                }
            } else { /* COMMENT_11 */
                /* COMMENT_12 */
                if (VAR_12->flags & VAR_26) {
                    VAR_17 = VAR_1->bj_values[VAR_12->depth];
                } else {
                    if (VAR_12->depth != 0) {
                        VAR_17 = VAR_12->depth;
                    }
                }

                if (VAR_7 != 0 && VAR_12->flags & VAR_28) {
                    if (VAR_17 <= VAR_7) {
                        goto no_match;
                    } else if (VAR_17 >= (VAR_7 + VAR_6)) {
                        ;
                    } else {
                        VAR_17 = VAR_17 - VAR_7;
                    }
                }

                /* COMMENT_13 */
                if (VAR_12->flags & VAR_27)
                    VAR_16 = VAR_1->bj_values[VAR_12->offset];
                else
                    VAR_16 = VAR_12->offset;
                VAR_19 = 0;
            }

            /* COMMENT_14 */
                                                    
            SCLogDebug(""offset %""VAR_13"", prev_offset %""VAR_13, VAR_16, VAR_18);
            if (VAR_18 != 0)
                VAR_16 = VAR_18;

            SCLogDebug(""offset %""VAR_13"", depth %""VAR_13, VAR_16, VAR_17);

            if (VAR_17 > VAR_6)
                VAR_17 = VAR_6;

            /* COMMENT_16 */
                                                               
            if (VAR_16 > VAR_17 || VAR_17 == 0) {
                if (VAR_12->flags & VAR_29) {
                    goto match;
                } else {
                    goto no_match;
                }
            }

            uint8_t *VAR_30 = VAR_5 + VAR_16;
            uint32_t VAR_31 = VAR_17 - VAR_16;
            uint32_t VAR_32 = 0;
            SCLogDebug(""sbuffer_len %""VAR_13, VAR_31);
#ifdef VAR_14
            BUG_ON(VAR_31 > VAR_6);
#endif

            /* COMMENT_18 */
                                                                

            /* COMMENT_20 */
            VAR_15 = SpmScan(VAR_12->spm_ctx, VAR_1->spm_thread_ctx, VAR_30,
                            VAR_31);

            /* COMMENT_21 */
                                
            SCLogDebug(""found %p cd negated %s"", VAR_15, VAR_12->flags & VAR_29 ? ""true"" : ""false"");

            if (VAR_15 == NULL && !(VAR_12->flags & VAR_29)) {
                if ((VAR_12->flags & (VAR_20|VAR_21)) == 0) {
                    /* COMMENT_23 */
                    VAR_1->discontinue_matching = 1;
                }

                goto no_match;
            } else if (VAR_15 == NULL && (VAR_12->flags & VAR_29)) {
                goto match;
            } else if (VAR_15 != NULL && (VAR_12->flags & VAR_29)) {
                SCLogDebug(""content %""VAR_13"" matched at offset %""VAR_13"", but negated so no match"", VAR_12->id, VAR_32);
                /* COMMENT_24 */
                                       
                if (DETECT_CONTENT_IS_SINGLE(VAR_12))
                    VAR_1->discontinue_matching = 1;
                goto no_match;
            } else {
                VAR_32 = (uint32_t)((VAR_15 - VAR_5) + VAR_12->content_len);
                SCLogDebug(""content %""VAR_13"" matched at offset %""VAR_13"""", VAR_12->id, VAR_32);
                VAR_1->buffer_offset = VAR_32;

                /* COMMENT_26 */
                if (VAR_12->flags & VAR_33) {
                    if (VAR_8 == VAR_34) {
                        /* COMMENT_27 */
                        VAR_1->replist = DetectReplaceAddToList(VAR_1->replist, VAR_15, VAR_12);
                    } else {
                        SCLogWarning(VAR_35, ""Can't modify payload without packet"");
                    }
                }

                /* COMMENT_28 */
                if (VAR_3->is_last) {
                    goto match;
                }

                SCLogDebug(""content %""VAR_13, VAR_12->id);
                KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);

                /* COMMENT_29 */
                                                                       
                                                                          
                int VAR_36 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,
                        VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);
                if (VAR_36 == 1) {
                    SCReturnInt(1);
                }
                SCLogDebug(""no match for 'next sm'"");

                if (VAR_1->discontinue_matching) {
                    SCLogDebug(""'next sm' said to discontinue this right now"");
                    goto no_match;
                }

                /* COMMENT_32 */
                if ((VAR_12->flags & VAR_37) == 0) {
                    SCLogDebug(""'next sm' does not depend on me, so we can give up"");
                    VAR_1->discontinue_matching = 1;
                    goto no_match;
                }

                SCLogDebug(""'next sm' depends on me %p, lets see what we can do (flags %u)"", VAR_12, VAR_12->flags);

                /* COMMENT_33 */
                VAR_18 = (VAR_32 - (VAR_12->content_len - 1));
                SCLogDebug(""trying to see if there is another match after prev_offset %""VAR_13, VAR_18);
            }

        } while(1);

    } else if (VAR_3->type == VAR_38) {
        SCLogDebug(""inspecting isdataat"");

        DetectIsdataatData *VAR_39 = (DetectIsdataatData *)VAR_3->ctx;
        if (VAR_39->flags & VAR_40) {
            if (VAR_1->buffer_offset + VAR_39->dataat > VAR_6) {
                SCLogDebug(""det_ctx->buffer_offset + id->dataat %""VAR_13"" > %""VAR_13, VAR_1->buffer_offset + VAR_39->dataat, VAR_6);
                if (VAR_39->flags & VAR_41)
                    goto match;
                goto no_match;
            } else {
                SCLogDebug(""relative isdataat match"");
                if (VAR_39->flags & VAR_41)
                    goto no_match;
                goto match;
            }
        } else {
            if (VAR_39->dataat < VAR_6) {
                SCLogDebug(""absolute isdataat match"");
                if (VAR_39->flags & VAR_41)
                    goto no_match;
                goto match;
            } else {
                SCLogDebug(""absolute isdataat mismatch, id->isdataat %""VAR_13"", buffer_len %""VAR_13"""", VAR_39->dataat, VAR_6);
                if (VAR_39->flags & VAR_41)
                    goto match;
                goto no_match;
            }
        }

    } else if (VAR_3->type == VAR_42) {
        SCLogDebug(""inspecting pcre"");
        DetectPcreData *VAR_43 = (DetectPcreData *)VAR_3->ctx;
        uint32_t VAR_19 = VAR_1->buffer_offset;
        uint32_t VAR_18 = 0;
        int VAR_36 = 0;

        VAR_1->pcre_match_start_offset = 0;
        do {
            Packet *VAR_44 = NULL;
            if (VAR_8 == VAR_34)
                VAR_44 = (Packet *)VAR_9;
            VAR_36 = DetectPcrePayloadMatch(VAR_1, VAR_2, VAR_3, VAR_44, VAR_4,
                                       VAR_5, VAR_6);
            if (VAR_36 == 0) {
                goto no_match;
            }

            if (!(VAR_43->flags & VAR_45)) {
                SCLogDebug(""no relative match coming up, so this is a match"");
                goto match;
            }
            KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);

            /* COMMENT_34 */
            VAR_18 = VAR_1->pcre_match_start_offset;

            /* COMMENT_35 */
                                                                
                                                                  
            VAR_36 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,
                    VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);
            if (VAR_36 == 1) {
                SCReturnInt(1);
            }

            if (VAR_1->discontinue_matching)
                goto no_match;

            VAR_1->buffer_offset = VAR_19;
            VAR_1->pcre_match_start_offset = VAR_18;
        } while (1);

    } else if (VAR_3->type == VAR_46) {
        DetectBytetestData *VAR_47 = (DetectBytetestData *)VAR_3->ctx;
        uint8_t VAR_48 = VAR_47->flags;
        int32_t VAR_16 = VAR_47->offset;
        uint64_t VAR_49 = VAR_47->value;
        if (VAR_48 & VAR_50) {
            VAR_16 = VAR_1->bj_values[VAR_16];
        }
        if (VAR_48 & VAR_51) {
            VAR_49 = VAR_1->bj_values[VAR_49];
        }

        /* COMMENT_38 */
                                         
        if (VAR_48 & VAR_52 && VAR_9 != NULL) {
            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;
            /* COMMENT_40 */
                                                                    
            VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
                      VAR_54: 0);
        }

        if (DetectBytetestDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6, VAR_48,
                                  VAR_16, VAR_49) != 1) {
            goto no_match;
        }

        goto match;

    } else if (VAR_3->type == VAR_55) {
        DetectBytejumpData *VAR_56 = (DetectBytejumpData *)VAR_3->ctx;
        uint8_t VAR_48 = VAR_56->flags;
        int32_t VAR_16 = VAR_56->offset;

        if (VAR_48 & VAR_57) {
            VAR_16 = VAR_1->bj_values[VAR_16];
        }

        /* COMMENT_42 */
                                         
        if (VAR_48 & VAR_58 && VAR_9 != NULL) {
            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;
            /* COMMENT_44 */
                                                                    
            VAR_48 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] & 0x10) ?
                      VAR_59: 0);
        }

        if (DetectBytejumpDoMatch(VAR_1, VAR_2, VAR_3->ctx, VAR_5, VAR_6,
                                  VAR_48, VAR_16) != 1) {
            goto no_match;
        }

        goto match;

    } else if (VAR_3->type == VAR_60) {

        DetectByteExtractData *VAR_61 = (DetectByteExtractData *)VAR_3->ctx;
        uint8_t VAR_62 = VAR_61->endian;

        /* COMMENT_46 */
                                         
        if ((VAR_61->flags & VAR_63) &&
            VAR_62 == VAR_64 && VAR_9 != NULL) {

            DCERPCState *VAR_53 = (DCERPCState *)VAR_9;
            /* COMMENT_48 */
                                                                    
            VAR_62 |= ((VAR_53->dcerpc.dcerpchdr.packed_drep[0] == 0x10) ?
                       VAR_65 : VAR_66);
        }

        if (DetectByteExtractDoMatch(VAR_1, VAR_3, VAR_2, VAR_5,
                                     VAR_6,
                                     &VAR_1->bj_values[VAR_61->local_id],
                                     VAR_62) != 1) {
            goto no_match;
        }

        goto match;

        /* COMMENT_50 */
    } else if (VAR_3->type == VAR_67) {
        SCLogDebug(""inspecting uri len"");

        int VAR_36 = 0;
        DetectUrilenData *VAR_68 = (DetectUrilenData *) VAR_3->ctx;

        switch (VAR_68->mode) {
            case VAR_69:
                if (VAR_6 == VAR_68->urilen1)
                    VAR_36 = 1;
                break;
            case VAR_70:
                if (VAR_6 < VAR_68->urilen1)
                    VAR_36 = 1;
                break;
            case VAR_71:
                if (VAR_6 > VAR_68->urilen1)
                    VAR_36 = 1;
                break;
            case VAR_72:
                if (VAR_6 > VAR_68->urilen1 &&
                    VAR_6 < VAR_68->urilen2) {
                    VAR_36 = 1;
                }
                break;
        }

        if (VAR_36 == 1) {
            goto match;
        }

        VAR_1->discontinue_matching = 0;

        goto no_match;
#ifdef VAR_73
    }
    else if (VAR_3->type == VAR_74) {
        SCLogDebug(""lua starting"");

        if (DetectLuaMatchBuffer(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6,
                    VAR_1->buffer_offset, VAR_4) != 1)
        {
            SCLogDebug(""lua no_match"");
            goto no_match;
        }
        SCLogDebug(""lua match"");
        goto match;
#endif/* COMMENT_51 */
    } else if (smd->type == DETECT_BASE64_DECODE) {
        if (DetectBase64DecodeDoMatch(VAR_1, VAR_2, VAR_3, VAR_5, VAR_6)) {
            if (VAR_2->sm_arrays[VAR_75] != NULL) {
                KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
                if (DetectBase64DataDoMatch(VAR_0, VAR_1, VAR_2, VAR_4)) {
                    /* COMMENT_52 */
                    goto final_match;
                }
            }
        }
    } else {
        SCLogDebug(""sm->type %u"", VAR_3->type);
#ifdef VAR_14
        BUG_ON(1);
#endif
    }

no_match:
    KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 0);
    SCReturnInt(0);

match:
    /* COMMENT_53 */
                                                      
    if (!VAR_3->is_last) {
        KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
        int VAR_36 = DetectEngineContentInspection(VAR_0, VAR_1, VAR_2, VAR_3+1,
                VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9);
        SCReturnInt(VAR_36);
    }
final_match:
    KEYWORD_PROFILING_END(VAR_1, VAR_3->type, 1);
    SCReturnInt(1);
}",OISF/suricata/b9579fbe7dd408200ef03cbe20efddb624b73885/detect-engine-content-inspection.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -186,6 +186,11 @@
             SCLogDebug(""found %p cd negated %s"", found, cd->flags & DETECT_CONTENT_NEGATED ? ""true"" : ""false"");
 
             if (found == NULL && !(cd->flags & DETECT_CONTENT_NEGATED)) {
+                if ((cd->flags & (DETECT_CONTENT_DISTANCE|DETECT_CONTENT_WITHIN)) == 0) {
+                    /* independent match from previous matches, so failure is fatal */
+                    det_ctx->discontinue_matching = 1;
+                }
+
                 goto no_match;
             } else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {
                 goto match;
@@ -210,16 +215,10 @@
                         SCLogWarning(SC_ERR_INVALID_VALUE, ""Can't modify payload without packet"");
                     }
                 }
-                if (!(cd->flags & DETECT_CONTENT_RELATIVE_NEXT)) {
-                    SCLogDebug(""no relative match coming up, so this is a match"");
+
+                /* if this is the last match we're done */
+                if (smd->is_last) {
                     goto match;
-                }
-
-                /* bail out if we have no next match. Technically this is an
-                 * error, as the current cd has the DETECT_CONTENT_RELATIVE_NEXT
-                 * flag set. */
-                if (smd->is_last) {
-                    goto no_match;
                 }
 
                 SCLogDebug(""content %""PRIu32, cd->id);
@@ -233,9 +232,21 @@
                 if (r == 1) {
                     SCReturnInt(1);
                 }
-
-                if (det_ctx->discontinue_matching)
+                SCLogDebug(""no match for 'next sm'"");
+
+                if (det_ctx->discontinue_matching) {
+                    SCLogDebug(""'next sm' said to discontinue this right now"");
                     goto no_match;
+                }
+
+                /* no match and no reason to look for another instance */
+                if ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {
+                    SCLogDebug(""'next sm' does not depend on me, so we can give up"");
+                    det_ctx->discontinue_matching = 1;
+                    goto no_match;
+                }
+
+                SCLogDebug(""'next sm' depends on me %p, lets see what we can do (flags %u)"", cd, cd->flags);
 
                 /* set the previous match offset to the start of this match + 1 */
                 prev_offset = (match_offset - (cd->content_len - 1));","{'deleted_lines': ['                if (!(cd->flags & DETECT_CONTENT_RELATIVE_NEXT)) {', '                    SCLogDebug(""no relative match coming up, so this is a match"");', '                }', '', '                /* bail out if we have no next match. Technically this is an', '                 * error, as the current cd has the DETECT_CONTENT_RELATIVE_NEXT', '                 * flag set. */', '                if (smd->is_last) {', '                    goto no_match;', '', '                if (det_ctx->discontinue_matching)'], 'added_lines': ['                if ((cd->flags & (DETECT_CONTENT_DISTANCE|DETECT_CONTENT_WITHIN)) == 0) {', '                    /* independent match from previous matches, so failure is fatal */', '                    det_ctx->discontinue_matching = 1;', '                }', '', '', ""                /* if this is the last match we're done */"", '                if (smd->is_last) {', '                SCLogDebug(""no match for \'next sm\'"");', '', '                if (det_ctx->discontinue_matching) {', '                    SCLogDebug(""\'next sm\' said to discontinue this right now"");', '                }', '', '                /* no match and no reason to look for another instance */', '                if ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {', '                    SCLogDebug(""\'next sm\' does not depend on me, so we can give up"");', '                    det_ctx->discontinue_matching = 1;', '                    goto no_match;', '                }', '', '                SCLogDebug(""\'next sm\' depends on me %p, lets see what we can do (flags %u)"", cd, cd->flags);']}",True,"In Suricata before 4.x, it was possible to trigger lots of redundant checks on the content of crafted network traffic with a certain signature, because of DetectEngineContentInspection in detect-engine-content-inspection.c. The search engine doesn't stop when it should after no match is found; instead, it stops only upon reaching inspection-recursion-limit (3000 by default).",7.5,HIGH,2,valid,2017-03-03T14:38:43Z,1
CVE-2017-8924,['CWE-191'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"USB: serial: io_ti: fix information leak in completion handler

Add missing sanity check to the bulk-in completion handler to avoid an
integer underflow that can be triggered by a malicious device.

This avoids leaking 128 kB of memory content from after the URB transfer
buffer to user space.

Fixes: 8c209e6782ca (""USB: make actual_length in struct urb field u32"")
Fixes: 1da177e4c3f4 (""Linux-2.6.12-rc2"")
Cc: stable <stable@vger.kernel.org>	# 2.6.30
Signed-off-by: Johan Hovold <johan@kernel.org>",654b404f2a222f918af9b0cd18ad469d0c941a8e,https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e,drivers/usb/serial/io_ti.c,edge_bulk_in_callback,"static void edge_bulk_in_callback(struct urb *urb)
{
struct edgeport_port *edge_port = urb->context;
struct device *dev = &edge_port->port->dev;
unsigned char *data = urb->transfer_buffer;
int retval = 0;
int port_number;
int status = urb->status;
switch (status) {
case 0:
break;
case -ECONNRESET:
case -ENOENT:
case -ESHUTDOWN:
dev_dbg(&urb->dev->dev, ""%s - urb shutting down with status: %d\n"", __func__, status);
return;
default:
dev_err(&urb->dev->dev, ""%s - nonzero read bulk status received: %d\n"", __func__, status);
}
if (status == -EPIPE)
goto exit;
if (status) {
dev_err(&urb->dev->dev, ""%s - stopping read!\n"", __func__);
return;
}
port_number = edge_port->port->port_number;
if (edge_port->lsr_event) {
edge_port->lsr_event = 0;
dev_dbg(dev, ""%s ===== Port %u LSR Status = %02x, Data = %02x ======\n"",
__func__, port_number, edge_port->lsr_mask, *data);
handle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);
--urb->actual_length;
++data;
}
if (urb->actual_length) {
usb_serial_debug_data(dev, __func__, urb->actual_length, data);
if (edge_port->close_pending)
dev_dbg(dev, ""%s - close pending, dropping data on the floor\n"",
__func__);
else
edge_tty_recv(edge_port->port, data,
urb->actual_length);
edge_port->port->icount.rx += urb->actual_length;
}
exit:
spin_lock(&edge_port->ep_lock);
if (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)
retval = usb_submit_urb(urb, GFP_ATOMIC);
else if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)
edge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;
spin_unlock(&edge_port->ep_lock);
if (retval)
dev_err(dev, ""%s - usb_submit_urb failed with result %d\n"", __func__, retval);
}","static void edge_bulk_in_callback(struct urb *urb)
{
struct edgeport_port *VAR_0 = urb->context;
struct device *VAR_1 = &VAR_0->port->dev;
unsigned char *VAR_2 = urb->transfer_buffer;
int VAR_3 = 0;
int VAR_4;
int VAR_5 = urb->status;
switch (VAR_5) {
case 0:
break;
case -VAR_6:
case -VAR_7:
case -VAR_8:
dev_dbg(&urb->dev->dev, ""%s - urb shutting down with status: %d\n"", VAR_9, VAR_5);
return;
default:
dev_err(&urb->dev->dev, ""%s - nonzero read bulk status received: %d\n"", VAR_9, VAR_5);
}
if (VAR_5 == -VAR_10)
goto exit;
if (VAR_5) {
dev_err(&urb->dev->dev, ""%s - stopping read!\n"", VAR_9);
return;
}
VAR_4 = VAR_0->port->port_number;
if (VAR_0->lsr_event) {
VAR_0->lsr_event = 0;
dev_dbg(VAR_1, ""%s ===== Port %u LSR Status = %02x, Data = %02x ======\n"",
VAR_9, VAR_4, VAR_0->lsr_mask, *VAR_2);
handle_new_lsr(VAR_0, 1, VAR_0->lsr_mask, *VAR_2);
--urb->actual_length;
++VAR_2;
}
if (urb->actual_length) {
usb_serial_debug_data(VAR_1, VAR_9, urb->actual_length, VAR_2);
if (VAR_0->close_pending)
dev_dbg(VAR_1, ""%s - close pending, dropping data on the floor\n"",
VAR_9);
else
edge_tty_recv(VAR_0->port, VAR_2,
urb->actual_length);
VAR_0->port->icount.rx += urb->actual_length;
}
exit:
spin_lock(&VAR_0->ep_lock);
if (VAR_0->ep_read_urb_state == VAR_11)
VAR_3 = usb_submit_urb(urb, VAR_12);
else if (VAR_0->ep_read_urb_state == VAR_13)
VAR_0->ep_read_urb_state = VAR_14;
spin_unlock(&VAR_0->ep_lock);
if (VAR_3)
dev_err(VAR_1, ""%s - usb_submit_urb failed with result %d\n"", VAR_9, VAR_3);
}",torvalds/linux/654b404f2a222f918af9b0cd18ad469d0c941a8e/io_ti.c/vul/before/0.json,"static void edge_bulk_in_callback(struct urb *urb)
{
	struct edgeport_port *edge_port = urb->context;
	struct device *dev = &edge_port->port->dev;
	unsigned char *data = urb->transfer_buffer;
	int retval = 0;
	int port_number;
	int status = urb->status;

	switch (status) {
	case 0:
		/* success */
		break;
	case -ECONNRESET:
	case -ENOENT:
	case -ESHUTDOWN:
		/* this urb is terminated, clean up */
		dev_dbg(&urb->dev->dev, ""%s - urb shutting down with status: %d\n"", __func__, status);
		return;
	default:
		dev_err(&urb->dev->dev, ""%s - nonzero read bulk status received: %d\n"", __func__, status);
	}

	if (status == -EPIPE)
		goto exit;

	if (status) {
		dev_err(&urb->dev->dev, ""%s - stopping read!\n"", __func__);
		return;
	}

	port_number = edge_port->port->port_number;

	if (urb->actual_length > 0 && edge_port->lsr_event) {
		edge_port->lsr_event = 0;
		dev_dbg(dev, ""%s ===== Port %u LSR Status = %02x, Data = %02x ======\n"",
			__func__, port_number, edge_port->lsr_mask, *data);
		handle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);
		/* Adjust buffer length/pointer */
		--urb->actual_length;
		++data;
	}

	if (urb->actual_length) {
		usb_serial_debug_data(dev, __func__, urb->actual_length, data);
		if (edge_port->close_pending)
			dev_dbg(dev, ""%s - close pending, dropping data on the floor\n"",
								__func__);
		else
			edge_tty_recv(edge_port->port, data,
					urb->actual_length);
		edge_port->port->icount.rx += urb->actual_length;
	}

exit:
	/* continue read unless stopped */
	spin_lock(&edge_port->ep_lock);
	if (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)
		retval = usb_submit_urb(urb, GFP_ATOMIC);
	else if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)
		edge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;

	spin_unlock(&edge_port->ep_lock);
	if (retval)
		dev_err(dev, ""%s - usb_submit_urb failed with result %d\n"", __func__, retval);
}","static void edge_bulk_in_callback(struct urb *urb)
{
	struct edgeport_port *VAR_0 = urb->context;
	struct device *VAR_1 = &VAR_0->port->dev;
	unsigned char *VAR_2 = urb->transfer_buffer;
	int VAR_3 = 0;
	int VAR_4;
	int VAR_5 = urb->status;

	switch (VAR_5) {
	case 0:
		/* COMMENT_0 */
		break;
	case -VAR_6:
	case -VAR_7:
	case -VAR_8:
		/* COMMENT_1 */
		dev_dbg(&urb->dev->dev, ""%s - urb shutting down with status: %d\n"", VAR_9, VAR_5);
		return;
	default:
		dev_err(&urb->dev->dev, ""%s - nonzero read bulk status received: %d\n"", VAR_9, VAR_5);
	}

	if (VAR_5 == -VAR_10)
		goto exit;

	if (VAR_5) {
		dev_err(&urb->dev->dev, ""%s - stopping read!\n"", VAR_9);
		return;
	}

	VAR_4 = VAR_0->port->port_number;

	if (urb->actual_length > 0 && VAR_0->lsr_event) {
		VAR_0->lsr_event = 0;
		dev_dbg(VAR_1, ""%s ===== Port %u LSR Status = %02x, Data = %02x ======\n"",
			VAR_9, VAR_4, VAR_0->lsr_mask, *VAR_2);
		handle_new_lsr(VAR_0, 1, VAR_0->lsr_mask, *VAR_2);
		/* COMMENT_2 */
		--urb->actual_length;
		++VAR_2;
	}

	if (urb->actual_length) {
		usb_serial_debug_data(VAR_1, VAR_9, urb->actual_length, VAR_2);
		if (VAR_0->close_pending)
			dev_dbg(VAR_1, ""%s - close pending, dropping data on the floor\n"",
								VAR_9);
		else
			edge_tty_recv(VAR_0->port, VAR_2,
					urb->actual_length);
		VAR_0->port->icount.rx += urb->actual_length;
	}

exit:
	/* COMMENT_3 */
	spin_lock(&VAR_0->ep_lock);
	if (VAR_0->ep_read_urb_state == VAR_11)
		VAR_3 = usb_submit_urb(urb, VAR_12);
	else if (VAR_0->ep_read_urb_state == VAR_13)
		VAR_0->ep_read_urb_state = VAR_14;

	spin_unlock(&VAR_0->ep_lock);
	if (VAR_3)
		dev_err(VAR_1, ""%s - usb_submit_urb failed with result %d\n"", VAR_9, VAR_3);
}",torvalds/linux/654b404f2a222f918af9b0cd18ad469d0c941a8e/io_ti.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
 
 	port_number = edge_port->port->port_number;
 
-	if (edge_port->lsr_event) {
+	if (urb->actual_length > 0 && edge_port->lsr_event) {
 		edge_port->lsr_event = 0;
 		dev_dbg(dev, ""%s ===== Port %u LSR Status = %02x, Data = %02x ======\n"",
 			__func__, port_number, edge_port->lsr_mask, *data);","{'deleted_lines': ['\tif (edge_port->lsr_event) {'], 'added_lines': ['\tif (urb->actual_length > 0 && edge_port->lsr_event) {']}",True,The edge_bulk_in_callback function in drivers/usb/serial/io_ti.c in the Linux kernel before 4.10.4 allows local users to obtain sensitive information (in the dmesg ringbuffer and syslog) from uninitialized kernel memory by using a crafted USB device (posing as an io_ti USB serial device) to trigger an integer underflow.,4.6,MEDIUM,1,valid,2017-03-06T16:36:40Z,1
CVE-2017-7703,['CWE-74'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"imap: Give correct lineend to get_token_len()

The return value from get_token_len() is the token length, but the
returned next_token can have a offset more than token length because
it also skip trailing blanks.  Ensure we always give correct lineend.

Bug: 13466
Change-Id: I88a11b9bce02999fcf87c0d7542e56fa90aae5a0
Reviewed-on: https://code.wireshark.org/review/20451
Petri-Dish: Stig Bjrlykke <stig@bjorlykke.org>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Stig Bjrlykke <stig@bjorlykke.org>
(cherry picked from commit eb046064ff0f064896ad60508876b8a764fbbca9)
Reviewed-on: https://code.wireshark.org/review/20459",671e32820ab29d41d712cc8a472eab9b672684d9,https://github.com/wireshark/wireshark/commit/671e32820ab29d41d712cc8a472eab9b672684d9,epan/dissectors/packet-imap.c,dissect_imap,"static void
dissect_imap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{
gboolean        is_request;
proto_tree      *imap_tree, *reqresp_tree;
proto_item      *ti, *hidden_item;
gint            offset = 0;
gint            uid_offset = 0;
gint            folder_offset = 0;
const guchar    *line;
const guchar    *uid_line;
const guchar    *folder_line;
gint            next_offset;
int             linelen;
int             tokenlen;
int             uid_tokenlen;
int             folder_tokenlen;
const guchar    *next_token;
const guchar    *uid_next_token;
const guchar    *folder_next_token;
guchar          *tokenbuf;
guchar          *command_token;
int             iter;
int             commandlen;
conversation_t *conversation;
imap_state_t   *session_state;
conversation = find_or_create_conversation(pinfo);
session_state = (imap_state_t *)conversation_get_proto_data(conversation, proto_imap);
if (!session_state) {
session_state = wmem_new0(wmem_file_scope(), imap_state_t);
session_state->ssl_requested = FALSE;
conversation_add_proto_data(conversation, proto_imap, session_state);
}
tokenbuf = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);
command_token = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);
commandlen = 0;
folder_offset = 0;
folder_tokenlen = 0;
folder_line = NULL;
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""IMAP"");
if (pinfo->match_uint == pinfo->destport)
is_request = TRUE;
else
is_request = FALSE;
linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);
line = tvb_get_ptr(tvb, offset, linelen);
col_add_fstr(pinfo->cinfo, COL_INFO, ""%s: %s"", is_request ? ""Request"" : ""Response"", format_text(line, linelen));
{
ti = proto_tree_add_item(tree, proto_imap, tvb, offset, -1, ENC_NA);
imap_tree = proto_item_add_subtree(ti, ett_imap);
hidden_item = proto_tree_add_boolean(imap_tree, hf_imap_isrequest, tvb, 0, 0, is_request);
PROTO_ITEM_SET_HIDDEN(hidden_item);
while(tvb_offset_exists(tvb, offset)) {
linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);
line = tvb_get_ptr(tvb, offset, linelen);
ti = proto_tree_add_item(imap_tree, hf_imap_line, tvb, offset, next_offset - offset, ENC_ASCII|ENC_NA);
reqresp_tree = proto_item_add_subtree(ti, ett_imap_reqresp);
if ( (line) && ((line[0] != '*') || (TRUE == is_request)) ) {
tokenlen = get_token_len(line, line + linelen, &next_token);
if (tokenlen != 0) {
proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
offset += (gint) (next_token - line);
linelen -= (int) (next_token - line);
line = next_token;
}
tokenlen = get_token_len(line, line + linelen, &next_token);
if (tokenlen != 0) {
for (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) {
tokenbuf[iter] = g_ascii_tolower(line[iter]);
}
if (tree && is_request && strncmp(tokenbuf, ""uid"", tokenlen) == 0) {
proto_tree_add_item(reqresp_tree, hf_imap_request_uid, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
uid_offset = offset;
uid_offset += (gint) (next_token - line);
uid_line = next_token;
uid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token);
if (tokenlen != 0) {
proto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA);
for (iter = 0; iter < uid_tokenlen && iter < MAX_BUFFER-1; iter++) {
command_token[iter] = g_ascii_tolower(uid_line[iter]);
}
commandlen = uid_tokenlen;
folder_offset = uid_offset;
folder_offset += (gint) (uid_next_token - uid_line);
folder_line = uid_next_token;
folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token);
}
} else {
proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_command : hf_imap_response_status, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
if (is_request) {
for (iter = 0; iter < tokenlen && iter < 256; iter++) {
command_token[iter] = g_ascii_tolower(line[iter]);
}
commandlen = tokenlen;
folder_offset = offset;
folder_offset += (gint) (next_token - line);
folder_line = next_token;
folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token);
}
}
if (tree && commandlen > 0 && (
strncmp(command_token, ""select"", commandlen) == 0 ||
strncmp(command_token, ""examine"", commandlen) == 0 ||
strncmp(command_token, ""create"", commandlen) == 0 ||
strncmp(command_token, ""delete"", commandlen) == 0 ||
strncmp(command_token, ""rename"", commandlen) == 0 ||
strncmp(command_token, ""subscribe"", commandlen) == 0 ||
strncmp(command_token, ""unsubscribe"", commandlen) == 0 ||
strncmp(command_token, ""status"", commandlen) == 0 ||
strncmp(command_token, ""append"", commandlen) == 0 ||
strncmp(command_token, ""search"", commandlen) == 0)) {
if (folder_tokenlen != 0)
proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);
}
if (tree && is_request && (NULL != folder_line) && strncmp(command_token, ""copy"", commandlen) == 0) {
folder_offset += (gint) (folder_next_token - folder_line);
folder_line = folder_next_token;
folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token);
if (folder_tokenlen != 0)
proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);
}
if (session_state->ssl_requested) {
if (!is_request && session_state->ssl_requested &&
strncmp(tokenbuf, ""ok"", tokenlen) == 0) {
ssl_starttls_ack(ssl_handle, pinfo, imap_handle);
}
session_state->ssl_requested = FALSE;
}
if (is_request && commandlen > 0 &&
strncmp(command_token, ""starttls"", commandlen) == 0) {
session_state->ssl_requested = TRUE;
}
}
if (linelen != 0) {
proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request : hf_imap_response, tvb, offset, linelen, ENC_ASCII|ENC_NA);
}
}
offset = next_offset; 
}
}
}","static void
dissect_imap(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2)
{
gboolean        VAR_3;
proto_tree      *VAR_4, *VAR_5;
proto_item      *VAR_6, *VAR_7;
gint            VAR_8 = 0;
gint            VAR_9 = 0;
gint            VAR_10 = 0;
const guchar    *VAR_11;
const guchar    *VAR_12;
const guchar    *VAR_13;
gint            VAR_14;
int             VAR_15;
int             VAR_16;
int             VAR_17;
int             VAR_18;
const guchar    *VAR_19;
const guchar    *VAR_20;
const guchar    *VAR_21;
guchar          *VAR_22;
guchar          *VAR_23;
int             VAR_24;
int             VAR_25;
conversation_t *VAR_26;
imap_state_t   *VAR_27;
VAR_26 = find_or_create_conversation(VAR_1);
VAR_27 = (imap_state_t *)conversation_get_proto_data(VAR_26, VAR_28);
if (!VAR_27) {
VAR_27 = wmem_new0(wmem_file_scope(), imap_state_t);
VAR_27->ssl_requested = FALSE;
conversation_add_proto_data(VAR_26, VAR_28, VAR_27);
}
VAR_22 = (guchar *)wmem_alloc0(wmem_packet_scope(), VAR_29);
VAR_23 = (guchar *)wmem_alloc0(wmem_packet_scope(), VAR_29);
VAR_25 = 0;
VAR_10 = 0;
VAR_18 = 0;
VAR_13 = NULL;
col_set_str(VAR_1->cinfo, VAR_30, ""IMAP"");
if (VAR_1->match_uint == VAR_1->destport)
VAR_3 = TRUE;
else
VAR_3 = FALSE;
VAR_15 = tvb_find_line_end(VAR_0, VAR_8, -1, &VAR_14, FALSE);
VAR_11 = tvb_get_ptr(VAR_0, VAR_8, VAR_15);
col_add_fstr(VAR_1->cinfo, VAR_31, ""%s: %s"", VAR_3 ? ""Request"" : ""Response"", format_text(VAR_11, VAR_15));
{
VAR_6 = proto_tree_add_item(VAR_2, VAR_28, VAR_0, VAR_8, -1, VAR_32);
VAR_4 = proto_item_add_subtree(VAR_6, VAR_33);
VAR_7 = proto_tree_add_boolean(VAR_4, VAR_34, VAR_0, 0, 0, VAR_3);
PROTO_ITEM_SET_HIDDEN(VAR_7);
while(tvb_offset_exists(VAR_0, VAR_8)) {
VAR_15 = tvb_find_line_end(VAR_0, VAR_8, -1, &VAR_14, FALSE);
VAR_11 = tvb_get_ptr(VAR_0, VAR_8, VAR_15);
VAR_6 = proto_tree_add_item(VAR_4, VAR_35, VAR_0, VAR_8, VAR_14 - VAR_8, VAR_36|VAR_32);
VAR_5 = proto_item_add_subtree(VAR_6, VAR_37);
if ( (VAR_11) && ((VAR_11[0] != '*') || (TRUE == VAR_3)) ) {
VAR_16 = get_token_len(VAR_11, VAR_11 + VAR_15, &VAR_19);
if (VAR_16 != 0) {
proto_tree_add_item(VAR_5, (VAR_3) ? VAR_38 : VAR_39, VAR_0, VAR_8, VAR_16, VAR_36|VAR_32);
VAR_8 += (gint) (VAR_19 - VAR_11);
VAR_15 -= (int) (VAR_19 - VAR_11);
VAR_11 = VAR_19;
}
VAR_16 = get_token_len(VAR_11, VAR_11 + VAR_15, &VAR_19);
if (VAR_16 != 0) {
for (VAR_24 = 0; VAR_24 < VAR_16 && VAR_24 < VAR_29-1; VAR_24++) {
VAR_22[VAR_24] = g_ascii_tolower(VAR_11[VAR_24]);
}
if (VAR_2 && VAR_3 && strncmp(VAR_22, ""uid"", VAR_16) == 0) {
proto_tree_add_item(VAR_5, VAR_40, VAR_0, VAR_8, VAR_16, VAR_36|VAR_32);
VAR_9 = VAR_8;
VAR_9 += (gint) (VAR_19 - VAR_11);
VAR_12 = VAR_19;
VAR_17 = get_token_len(VAR_12, VAR_12 + (VAR_15 - VAR_16), &VAR_20);
if (VAR_16 != 0) {
proto_tree_add_item(VAR_5, VAR_41, VAR_0, VAR_9, VAR_17, VAR_36|VAR_32);
for (VAR_24 = 0; VAR_24 < VAR_17 && VAR_24 < VAR_29-1; VAR_24++) {
VAR_23[VAR_24] = g_ascii_tolower(VAR_12[VAR_24]);
}
VAR_25 = VAR_17;
VAR_10 = VAR_9;
VAR_10 += (gint) (VAR_20 - VAR_12);
VAR_13 = VAR_20;
VAR_18 = get_token_len(VAR_13, VAR_13 + (VAR_15 - VAR_16 - VAR_17), &VAR_21);
}
} else {
proto_tree_add_item(VAR_5, (VAR_3) ? VAR_41 : VAR_42, VAR_0, VAR_8, VAR_16, VAR_36|VAR_32);
if (VAR_3) {
for (VAR_24 = 0; VAR_24 < VAR_16 && VAR_24 < 256; VAR_24++) {
VAR_23[VAR_24] = g_ascii_tolower(VAR_11[VAR_24]);
}
VAR_25 = VAR_16;
VAR_10 = VAR_8;
VAR_10 += (gint) (VAR_19 - VAR_11);
VAR_13 = VAR_19;
VAR_18 = get_token_len(VAR_13, VAR_13 + (VAR_15 - VAR_16 - 1), &VAR_21);
}
}
if (VAR_2 && VAR_25 > 0 && (
strncmp(VAR_23, ""select"", VAR_25) == 0 ||
strncmp(VAR_23, ""examine"", VAR_25) == 0 ||
strncmp(VAR_23, ""create"", VAR_25) == 0 ||
strncmp(VAR_23, ""delete"", VAR_25) == 0 ||
strncmp(VAR_23, ""rename"", VAR_25) == 0 ||
strncmp(VAR_23, ""subscribe"", VAR_25) == 0 ||
strncmp(VAR_23, ""unsubscribe"", VAR_25) == 0 ||
strncmp(VAR_23, ""status"", VAR_25) == 0 ||
strncmp(VAR_23, ""append"", VAR_25) == 0 ||
strncmp(VAR_23, ""search"", VAR_25) == 0)) {
if (VAR_18 != 0)
proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_10, VAR_18, VAR_36|VAR_32);
}
if (VAR_2 && VAR_3 && (NULL != VAR_13) && strncmp(VAR_23, ""copy"", VAR_25) == 0) {
VAR_10 += (gint) (VAR_21 - VAR_13);
VAR_13 = VAR_21;
VAR_18 = get_token_len(VAR_13, VAR_13 + (VAR_15 - VAR_16), &VAR_21);
if (VAR_18 != 0)
proto_tree_add_item(VAR_5, VAR_43, VAR_0, VAR_10, VAR_18, VAR_36|VAR_32);
}
if (VAR_27->ssl_requested) {
if (!VAR_3 && VAR_27->ssl_requested &&
strncmp(VAR_22, ""ok"", VAR_16) == 0) {
ssl_starttls_ack(VAR_44, VAR_1, VAR_45);
}
VAR_27->ssl_requested = FALSE;
}
if (VAR_3 && VAR_25 > 0 &&
strncmp(VAR_23, ""starttls"", VAR_25) == 0) {
VAR_27->ssl_requested = TRUE;
}
}
if (VAR_15 != 0) {
proto_tree_add_item(VAR_5, (VAR_3) ? VAR_46 : VAR_47, VAR_0, VAR_8, VAR_15, VAR_36|VAR_32);
}
}
VAR_8 = VAR_14; 
}
}
}",wireshark/671e32820ab29d41d712cc8a472eab9b672684d9/packet-imap.c/vul/before/0.json,"static void
dissect_imap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{
  gboolean        is_request;
  proto_tree      *imap_tree, *reqresp_tree;
  proto_item      *ti, *hidden_item;
  gint            offset = 0;
  gint            uid_offset = 0;
  gint            folder_offset = 0;
  const guchar    *line;
  const guchar    *lineend;
  const guchar    *uid_line;
  const guchar    *folder_line;
  gint            next_offset;
  int             linelen;
  int             tokenlen;
  int             uid_tokenlen;
  int             folder_tokenlen;
  const guchar    *next_token;
  const guchar    *uid_next_token;
  const guchar    *folder_next_token;
  guchar          *tokenbuf;
  guchar          *command_token;
  int             iter;
  int             commandlen;
  conversation_t *conversation;
  imap_state_t   *session_state;

  conversation = find_or_create_conversation(pinfo);
  session_state = (imap_state_t *)conversation_get_proto_data(conversation, proto_imap);
  if (!session_state) {
    session_state = wmem_new0(wmem_file_scope(), imap_state_t);
    session_state->ssl_requested = FALSE;
    conversation_add_proto_data(conversation, proto_imap, session_state);
  }

  tokenbuf = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);
  command_token = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);
  commandlen = 0;
  folder_offset = 0;
  folder_tokenlen = 0;
  folder_line = NULL;
  col_set_str(pinfo->cinfo, COL_PROTOCOL, ""IMAP"");


  if (pinfo->match_uint == pinfo->destport)
    is_request = TRUE;
  else
    is_request = FALSE;

  /*
   * Put the first line from the buffer into the summary
   * (but leave out the line terminator).
   */
  linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);
  line = tvb_get_ptr(tvb, offset, linelen);

  col_add_fstr(pinfo->cinfo, COL_INFO, ""%s: %s"", is_request ? ""Request"" : ""Response"", format_text(line, linelen));

  {
    ti = proto_tree_add_item(tree, proto_imap, tvb, offset, -1, ENC_NA);
    imap_tree = proto_item_add_subtree(ti, ett_imap);

    hidden_item = proto_tree_add_boolean(imap_tree, hf_imap_isrequest, tvb, 0, 0, is_request);
    PROTO_ITEM_SET_HIDDEN(hidden_item);

    while(tvb_offset_exists(tvb, offset)) {

      /*
       * Find the end of each line
       *
       * Note that ""tvb_find_line_end()"" will return a value that is
       * not longer than what's in the buffer, so the ""tvb_get_ptr()""
       * call won't throw an exception.
       */
      linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);
      line = tvb_get_ptr(tvb, offset, linelen);
      lineend = (line + linelen);

      /*
       * Put the line into the protocol tree.
       */
      ti = proto_tree_add_item(imap_tree, hf_imap_line, tvb, offset, next_offset - offset, ENC_ASCII|ENC_NA);

      reqresp_tree = proto_item_add_subtree(ti, ett_imap_reqresp);

      /*
       * Check that the line doesn't begin with '*', because that's a continuation line.
       * Otherwise if a tag is present then extract tokens.
       */
      if ( (line) && ((line[0] != '*') || (TRUE == is_request)) ) {
        /*
         * Show each line as tags + requests or replies.
         */

        /*
         * Extract the first token, and, if there is a first
         * token, add it as the request or reply tag.
         */
        tokenlen = get_token_len(line, lineend, &next_token);
        if (tokenlen != 0) {
          proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);

          offset += (gint) (next_token - line);
          linelen -= (int) (next_token - line);
          line = next_token;
        }

        /*
         * Extract second token, and, if there is a second
         * token, and it's not uid, add it as the request or reply command.
         */
        tokenlen = get_token_len(line, lineend, &next_token);
        if (tokenlen != 0) {
          for (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) {
            tokenbuf[iter] = g_ascii_tolower(line[iter]);
          }
          if (tree && is_request && strncmp(tokenbuf, ""uid"", tokenlen) == 0) {
            proto_tree_add_item(reqresp_tree, hf_imap_request_uid, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
            /*
             * UID is a precursor to a command, if following the tag,
              * so move to next token to grab the actual command.
              */
            uid_offset = offset;
            uid_offset += (gint) (next_token - line);
            uid_line = next_token;
            uid_tokenlen = get_token_len(uid_line, lineend, &uid_next_token);
            if (tokenlen != 0) {
              proto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA);

              /*
               * Save command string to do specialized processing.
               */
              for (iter = 0; iter < uid_tokenlen && iter < MAX_BUFFER-1; iter++) {
                command_token[iter] = g_ascii_tolower(uid_line[iter]);
              }
              commandlen = uid_tokenlen;

              folder_offset = uid_offset;
              folder_offset += (gint) (uid_next_token - uid_line);
              folder_line = uid_next_token;
              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);
            }
          } else {
            /*
             * Not a UID request so perform normal parsing.
             */
            proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_command : hf_imap_response_status, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);

            if (is_request) {
              /*
               * Save command string to do specialized processing.
               */
              for (iter = 0; iter < tokenlen && iter < 256; iter++) {
                command_token[iter] = g_ascii_tolower(line[iter]);
              }
              commandlen = tokenlen;

              folder_offset = offset;
              folder_offset += (gint) (next_token - line);
              folder_line = next_token;
              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);
            }
          }

          if (tree && commandlen > 0 && (
              strncmp(command_token, ""select"", commandlen) == 0 ||
              strncmp(command_token, ""examine"", commandlen) == 0 ||
              strncmp(command_token, ""create"", commandlen) == 0 ||
              strncmp(command_token, ""delete"", commandlen) == 0 ||
              strncmp(command_token, ""rename"", commandlen) == 0 ||
              strncmp(command_token, ""subscribe"", commandlen) == 0 ||
              strncmp(command_token, ""unsubscribe"", commandlen) == 0 ||
              strncmp(command_token, ""status"", commandlen) == 0 ||
              strncmp(command_token, ""append"", commandlen) == 0 ||
              strncmp(command_token, ""search"", commandlen) == 0)) {
            /*
             * These commands support folder as an argument,
             * so parse out the folder name.
             */
            if (folder_tokenlen != 0)
              proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);
          }

          if (tree && is_request && (NULL != folder_line) && strncmp(command_token, ""copy"", commandlen) == 0) {
            /*
             * Handle the copy command separately since folder
             * is the second argument for this command.
             */
            folder_offset += (gint) (folder_next_token - folder_line);
            folder_line = folder_next_token;
            folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);

            if (folder_tokenlen != 0)
              proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);
          }

          /* If not yet switched to TLS, check for STARTTLS. */
          if (session_state->ssl_requested) {
            if (!is_request && session_state->ssl_requested &&
              strncmp(tokenbuf, ""ok"", tokenlen) == 0) {
              /* STARTTLS accepted, next reply will be TLS. */
              ssl_starttls_ack(ssl_handle, pinfo, imap_handle);
            }
            session_state->ssl_requested = FALSE;
          }
          if (is_request && commandlen > 0 &&
            strncmp(command_token, ""starttls"", commandlen) == 0) {
            /* If next response is OK, then TLS should be commenced. */
            session_state->ssl_requested = TRUE;
          }
        }

        /*
         * Add the rest of the line as request or reply data.
         */
        if (linelen != 0) {
          proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request : hf_imap_response, tvb, offset, linelen, ENC_ASCII|ENC_NA);
        }

      }

      offset = next_offset; /* Skip over last line and \r\n at the end of it */
    }
  }
}","static void
dissect_imap(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2)
{
  gboolean        VAR_3;
  proto_tree      *VAR_4, *VAR_5;
  proto_item      *VAR_6, *VAR_7;
  gint            VAR_8 = 0;
  gint            VAR_9 = 0;
  gint            VAR_10 = 0;
  const guchar    *VAR_11;
  const guchar    *VAR_12;
  const guchar    *VAR_13;
  const guchar    *VAR_14;
  gint            VAR_15;
  int             VAR_16;
  int             VAR_17;
  int             VAR_18;
  int             VAR_19;
  const guchar    *VAR_20;
  const guchar    *VAR_21;
  const guchar    *VAR_22;
  guchar          *VAR_23;
  guchar          *VAR_24;
  int             VAR_25;
  int             VAR_26;
  conversation_t *VAR_27;
  imap_state_t   *VAR_28;

  VAR_27 = find_or_create_conversation(VAR_1);
  VAR_28 = (imap_state_t *)conversation_get_proto_data(VAR_27, VAR_29);
  if (!VAR_28) {
    VAR_28 = wmem_new0(wmem_file_scope(), imap_state_t);
    VAR_28->ssl_requested = FALSE;
    conversation_add_proto_data(VAR_27, VAR_29, VAR_28);
  }

  VAR_23 = (guchar *)wmem_alloc0(wmem_packet_scope(), VAR_30);
  VAR_24 = (guchar *)wmem_alloc0(wmem_packet_scope(), VAR_30);
  VAR_26 = 0;
  VAR_10 = 0;
  VAR_19 = 0;
  VAR_14 = NULL;
  col_set_str(VAR_1->cinfo, VAR_31, ""IMAP"");


  if (VAR_1->match_uint == VAR_1->destport)
    VAR_3 = TRUE;
  else
    VAR_3 = FALSE;

  /* COMMENT_0 */
                                                        
                                         
     
  VAR_16 = tvb_find_line_end(VAR_0, VAR_8, -1, &VAR_15, FALSE);
  VAR_11 = tvb_get_ptr(VAR_0, VAR_8, VAR_16);

  col_add_fstr(VAR_1->cinfo, VAR_32, ""%s: %s"", VAR_3 ? ""Request"" : ""Response"", format_text(VAR_11, VAR_16));

  {
    VAR_6 = proto_tree_add_item(VAR_2, VAR_29, VAR_0, VAR_8, -1, VAR_33);
    VAR_4 = proto_item_add_subtree(VAR_6, VAR_34);

    VAR_7 = proto_tree_add_boolean(VAR_4, VAR_35, VAR_0, 0, 0, VAR_3);
    PROTO_ITEM_SET_HIDDEN(VAR_7);

    while(tvb_offset_exists(VAR_0, VAR_8)) {

      /* COMMENT_4 */
                                  
        
                                                                    
                                                                     
                                       
         
      VAR_16 = tvb_find_line_end(VAR_0, VAR_8, -1, &VAR_15, FALSE);
      VAR_11 = tvb_get_ptr(VAR_0, VAR_8, VAR_16);
      VAR_12 = (VAR_11 + VAR_16);

      /* COMMENT_11 */
                                             
         
      VAR_6 = proto_tree_add_item(VAR_4, VAR_36, VAR_0, VAR_8, VAR_15 - VAR_8, VAR_37|VAR_33);

      VAR_5 = proto_item_add_subtree(VAR_6, VAR_38);

      /* COMMENT_14 */
                                                                                        
                                                           
         
      if ( (VAR_11) && ((VAR_11[0] != '*') || (TRUE == VAR_3)) ) {
        /* COMMENT_18 */
                                                        
           

        /* COMMENT_21 */
                                                            
                                                     
           
        VAR_17 = get_token_len(VAR_11, VAR_12, &VAR_20);
        if (VAR_17 != 0) {
          proto_tree_add_item(VAR_5, (VAR_3) ? VAR_39 : VAR_40, VAR_0, VAR_8, VAR_17, VAR_37|VAR_33);

          VAR_8 += (gint) (VAR_20 - VAR_11);
          VAR_16 -= (int) (VAR_20 - VAR_11);
          VAR_11 = VAR_20;
        }

        /* COMMENT_25 */
                                                          
                                                                           
           
        VAR_17 = get_token_len(VAR_11, VAR_12, &VAR_20);
        if (VAR_17 != 0) {
          for (VAR_25 = 0; VAR_25 < VAR_17 && VAR_25 < VAR_30-1; VAR_25++) {
            VAR_23[VAR_25] = g_ascii_tolower(VAR_11[VAR_25]);
          }
          if (VAR_2 && VAR_3 && strncmp(VAR_23, ""uid"", VAR_17) == 0) {
            proto_tree_add_item(VAR_5, VAR_41, VAR_0, VAR_8, VAR_17, VAR_37|VAR_33);
            /* COMMENT_29 */
                                                                     
                                                                 
                
            VAR_9 = VAR_8;
            VAR_9 += (gint) (VAR_20 - VAR_11);
            VAR_13 = VAR_20;
            VAR_18 = get_token_len(VAR_13, VAR_12, &VAR_21);
            if (VAR_17 != 0) {
              proto_tree_add_item(VAR_5, VAR_42, VAR_0, VAR_9, VAR_18, VAR_37|VAR_33);

              /* COMMENT_33 */
                                                                  
                 
              for (VAR_25 = 0; VAR_25 < VAR_18 && VAR_25 < VAR_30-1; VAR_25++) {
                VAR_24[VAR_25] = g_ascii_tolower(VAR_13[VAR_25]);
              }
              VAR_26 = VAR_18;

              VAR_10 = VAR_9;
              VAR_10 += (gint) (VAR_21 - VAR_13);
              VAR_14 = VAR_21;
              VAR_19 = get_token_len(VAR_14, VAR_12, &VAR_22);
            }
          } else {
            /* COMMENT_36 */
                                                           
               
            proto_tree_add_item(VAR_5, (VAR_3) ? VAR_42 : VAR_43, VAR_0, VAR_8, VAR_17, VAR_37|VAR_33);

            if (VAR_3) {
              /* COMMENT_39 */
                                                                  
                 
              for (VAR_25 = 0; VAR_25 < VAR_17 && VAR_25 < 256; VAR_25++) {
                VAR_24[VAR_25] = g_ascii_tolower(VAR_11[VAR_25]);
              }
              VAR_26 = VAR_17;

              VAR_10 = VAR_8;
              VAR_10 += (gint) (VAR_20 - VAR_11);
              VAR_14 = VAR_20;
              VAR_19 = get_token_len(VAR_14, VAR_12, &VAR_22);
            }
          }

          if (VAR_2 && VAR_26 > 0 && (
              strncmp(VAR_24, ""select"", VAR_26) == 0 ||
              strncmp(VAR_24, ""examine"", VAR_26) == 0 ||
              strncmp(VAR_24, ""create"", VAR_26) == 0 ||
              strncmp(VAR_24, ""delete"", VAR_26) == 0 ||
              strncmp(VAR_24, ""rename"", VAR_26) == 0 ||
              strncmp(VAR_24, ""subscribe"", VAR_26) == 0 ||
              strncmp(VAR_24, ""unsubscribe"", VAR_26) == 0 ||
              strncmp(VAR_24, ""status"", VAR_26) == 0 ||
              strncmp(VAR_24, ""append"", VAR_26) == 0 ||
              strncmp(VAR_24, ""search"", VAR_26) == 0)) {
            /* COMMENT_42 */
                                                            
                                            
               
            if (VAR_19 != 0)
              proto_tree_add_item(VAR_5, VAR_44, VAR_0, VAR_10, VAR_19, VAR_37|VAR_33);
          }

          if (VAR_2 && VAR_3 && (NULL != VAR_14) && strncmp(VAR_24, ""copy"", VAR_26) == 0) {
            /* COMMENT_46 */
                                                              
                                                       
               
            VAR_10 += (gint) (VAR_22 - VAR_14);
            VAR_14 = VAR_22;
            VAR_19 = get_token_len(VAR_14, VAR_12, &VAR_22);

            if (VAR_19 != 0)
              proto_tree_add_item(VAR_5, VAR_44, VAR_0, VAR_10, VAR_19, VAR_37|VAR_33);
          }

          /* COMMENT_50 */
          if (VAR_28->ssl_requested) {
            if (!VAR_3 && VAR_28->ssl_requested &&
              strncmp(VAR_23, ""ok"", VAR_17) == 0) {
              /* COMMENT_51 */
              ssl_starttls_ack(VAR_45, VAR_1, VAR_46);
            }
            VAR_28->ssl_requested = FALSE;
          }
          if (VAR_3 && VAR_26 > 0 &&
            strncmp(VAR_24, ""starttls"", VAR_26) == 0) {
            /* COMMENT_52 */
            VAR_28->ssl_requested = TRUE;
          }
        }

        /* COMMENT_53 */
                                                             
           
        if (VAR_16 != 0) {
          proto_tree_add_item(VAR_5, (VAR_3) ? VAR_47 : VAR_48, VAR_0, VAR_8, VAR_16, VAR_37|VAR_33);
        }

      }

      VAR_8 = VAR_15; /* COMMENT_56 */
    }
  }
}",wireshark/671e32820ab29d41d712cc8a472eab9b672684d9/packet-imap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,7 @@
   gint            uid_offset = 0;
   gint            folder_offset = 0;
   const guchar    *line;
+  const guchar    *lineend;
   const guchar    *uid_line;
   const guchar    *folder_line;
   gint            next_offset;
@@ -74,6 +75,7 @@
        */
       linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);
       line = tvb_get_ptr(tvb, offset, linelen);
+      lineend = (line + linelen);
 
       /*
        * Put the line into the protocol tree.
@@ -95,7 +97,7 @@
          * Extract the first token, and, if there is a first
          * token, add it as the request or reply tag.
          */
-        tokenlen = get_token_len(line, line + linelen, &next_token);
+        tokenlen = get_token_len(line, lineend, &next_token);
         if (tokenlen != 0) {
           proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);
 
@@ -108,7 +110,7 @@
          * Extract second token, and, if there is a second
          * token, and it's not uid, add it as the request or reply command.
          */
-        tokenlen = get_token_len(line, line + linelen, &next_token);
+        tokenlen = get_token_len(line, lineend, &next_token);
         if (tokenlen != 0) {
           for (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) {
             tokenbuf[iter] = g_ascii_tolower(line[iter]);
@@ -122,7 +124,7 @@
             uid_offset = offset;
             uid_offset += (gint) (next_token - line);
             uid_line = next_token;
-            uid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token);
+            uid_tokenlen = get_token_len(uid_line, lineend, &uid_next_token);
             if (tokenlen != 0) {
               proto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA);
 
@@ -137,7 +139,7 @@
               folder_offset = uid_offset;
               folder_offset += (gint) (uid_next_token - uid_line);
               folder_line = uid_next_token;
-              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token);
+              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);
             }
           } else {
             /*
@@ -157,7 +159,7 @@
               folder_offset = offset;
               folder_offset += (gint) (next_token - line);
               folder_line = next_token;
-              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token);
+              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);
             }
           }
 
@@ -187,7 +189,7 @@
              */
             folder_offset += (gint) (folder_next_token - folder_line);
             folder_line = folder_next_token;
-            folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token);
+            folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);
 
             if (folder_tokenlen != 0)
               proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);","{'deleted_lines': ['        tokenlen = get_token_len(line, line + linelen, &next_token);', '        tokenlen = get_token_len(line, line + linelen, &next_token);', '            uid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token);', '              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token);', '              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token);', '            folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token);'], 'added_lines': ['  const guchar    *lineend;', '      lineend = (line + linelen);', '        tokenlen = get_token_len(line, lineend, &next_token);', '        tokenlen = get_token_len(line, lineend, &next_token);', '            uid_tokenlen = get_token_len(uid_line, lineend, &uid_next_token);', '              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);', '              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);', '            folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);']}",True,"In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the IMAP dissector could crash, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-imap.c by calculating a line's end correctly.",7.5,HIGH,2,valid,2017-03-08T20:01:12Z,1
CVE-2017-9373,['CWE-401'],AV:L/AC:M/Au:N/C:N/I:N/A:P,0,qemu,"ide: ahci: call cleanup function in ahci unit

This can avoid memory leak when hotunplug the ahci device.

Signed-off-by: Li Qiang <liqiang6-s@360.cn>
Message-id: 1488449293-80280-4-git-send-email-liqiang6-s@360.cn
Signed-off-by: John Snow <jsnow@redhat.com>",d68f0f778e7f4fbd674627274267f269e40f0b04,https://github.com/qemu/qemu/commit/d68f0f778e7f4fbd674627274267f269e40f0b04,hw/ide/ahci.c,ahci_uninit,"void ahci_uninit(AHCIState *s)
{
g_free(s->dev);
}","void ahci_uninit(AHCIState *VAR_0)
{
g_free(VAR_0->dev);
}",qemu/d68f0f778e7f4fbd674627274267f269e40f0b04/ahci.c/vul/before/0.json,"void ahci_uninit(AHCIState *s)
{
    int i, j;

    for (i = 0; i < s->ports; i++) {
        AHCIDevice *ad = &s->dev[i];

        for (j = 0; j < 2; j++) {
            IDEState *s = &ad->port.ifs[j];

            ide_exit(s);
        }
    }

    g_free(s->dev);
}","void ahci_uninit(AHCIState *VAR_0)
{
    int VAR_1, VAR_2;

    for (VAR_1 = 0; VAR_1 < VAR_0->ports; VAR_1++) {
        AHCIDevice *VAR_3 = &VAR_0->dev[VAR_1];

        for (VAR_2 = 0; VAR_2 < 2; VAR_2++) {
            IDEState *VAR_0 = &VAR_3->port.ifs[VAR_2];

            ide_exit(VAR_0);
        }
    }

    g_free(VAR_0->dev);
}",qemu/d68f0f778e7f4fbd674627274267f269e40f0b04/ahci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,16 @@
 void ahci_uninit(AHCIState *s)
 {
+    int i, j;
+
+    for (i = 0; i < s->ports; i++) {
+        AHCIDevice *ad = &s->dev[i];
+
+        for (j = 0; j < 2; j++) {
+            IDEState *s = &ad->port.ifs[j];
+
+            ide_exit(s);
+        }
+    }
+
     g_free(s->dev);
 }","{'deleted_lines': [], 'added_lines': ['    int i, j;', '', '    for (i = 0; i < s->ports; i++) {', '        AHCIDevice *ad = &s->dev[i];', '', '        for (j = 0; j < 2; j++) {', '            IDEState *s = &ad->port.ifs[j];', '', '            ide_exit(s);', '        }', '    }', '']}",True,"Memory leak in QEMU (aka Quick Emulator), when built with IDE AHCI Emulation support, allows local guest OS privileged users to cause a denial of service (memory consumption) by repeatedly hot-unplugging the AHCI device.",5.5,MEDIUM,1,valid,2017-03-16T00:50:14Z,1
CVE-2017-13023,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13023/IPv6 mobility: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,https://github.com/the-tcpdump-group/tcpdump/commit/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00,print-mobility.c,mobility_opt_print,"static int
mobility_opt_print(netdissect_options *ndo,
const u_char *bp, const unsigned len)
{
unsigned i, optlen;
for (i = 0; i < len; i += optlen) {
ND_TCHECK(bp[i]);
if (bp[i] == IP6MOPT_PAD1)
optlen = 1;
else {
if (i + 1 < len) {
ND_TCHECK(bp[i + 1]);
optlen = bp[i + 1] + 2;
}
else
goto trunc;
}
if (i + optlen > len)
goto trunc;
ND_TCHECK(bp[i + optlen]);
switch (bp[i]) {
case IP6MOPT_PAD1:
ND_PRINT((ndo, ""(pad1)""));
break;
case IP6MOPT_PADN:
if (len - i < IP6MOPT_MINLEN) {
ND_PRINT((ndo, ""(padn: trunc)""));
goto trunc;
}
ND_PRINT((ndo, ""(padn)""));
break;
case IP6MOPT_REFRESH:
if (len - i < IP6MOPT_REFRESH_MINLEN) {
ND_PRINT((ndo, ""(refresh: trunc)""));
goto trunc;
}
ND_PRINT((ndo, ""(refresh: %u)"",
EXTRACT_16BITS(&bp[i+2]) << 2));
break;
case IP6MOPT_ALTCOA:
if (len - i < IP6MOPT_ALTCOA_MINLEN) {
ND_PRINT((ndo, ""(altcoa: trunc)""));
goto trunc;
}
ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));
break;
case IP6MOPT_NONCEID:
if (len - i < IP6MOPT_NONCEID_MINLEN) {
ND_PRINT((ndo, ""(ni: trunc)""));
goto trunc;
}
ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
EXTRACT_16BITS(&bp[i+2]),
EXTRACT_16BITS(&bp[i+4])));
break;
case IP6MOPT_AUTH:
if (len - i < IP6MOPT_AUTH_MINLEN) {
ND_PRINT((ndo, ""(auth: trunc)""));
goto trunc;
}
ND_PRINT((ndo, ""(auth)""));
break;
default:
if (len - i < IP6MOPT_MINLEN) {
ND_PRINT((ndo, ""(sopt_type %u: trunc)"", bp[i]));
goto trunc;
}
ND_PRINT((ndo, ""(type-0x%02x: len=%u)"", bp[i], bp[i + 1]));
break;
}
}
return 0;
trunc:
return 1;
}","static int
mobility_opt_print(netdissect_options *VAR_0,
const u_char *VAR_1, const unsigned VAR_2)
{
unsigned VAR_3, VAR_4;
for (VAR_3 = 0; VAR_3 < VAR_2; VAR_3 += VAR_4) {
ND_TCHECK(VAR_1[VAR_3]);
if (VAR_1[VAR_3] == VAR_5)
VAR_4 = 1;
else {
if (VAR_3 + 1 < VAR_2) {
ND_TCHECK(VAR_1[VAR_3 + 1]);
VAR_4 = VAR_1[VAR_3 + 1] + 2;
}
else
goto trunc;
}
if (VAR_3 + VAR_4 > VAR_2)
goto trunc;
ND_TCHECK(VAR_1[VAR_3 + VAR_4]);
switch (VAR_1[VAR_3]) {
case VAR_5:
ND_PRINT((VAR_0, ""(pad1)""));
break;
case VAR_6:
if (VAR_2 - VAR_3 < VAR_7) {
ND_PRINT((VAR_0, ""(padn: trunc)""));
goto trunc;
}
ND_PRINT((VAR_0, ""(padn)""));
break;
case VAR_8:
if (VAR_2 - VAR_3 < VAR_9) {
ND_PRINT((VAR_0, ""(refresh: trunc)""));
goto trunc;
}
ND_PRINT((VAR_0, ""(refresh: %u)"",
EXTRACT_16BITS(&VAR_1[VAR_3+2]) << 2));
break;
case VAR_10:
if (VAR_2 - VAR_3 < VAR_11) {
ND_PRINT((VAR_0, ""(altcoa: trunc)""));
goto trunc;
}
ND_PRINT((VAR_0, ""(alt-CoA: %s)"", ip6addr_string(VAR_0, &VAR_1[VAR_3+2])));
break;
case VAR_12:
if (VAR_2 - VAR_3 < VAR_13) {
ND_PRINT((VAR_0, ""(ni: trunc)""));
goto trunc;
}
ND_PRINT((VAR_0, ""(ni: ho=0x%04x co=0x%04x)"",
EXTRACT_16BITS(&VAR_1[VAR_3+2]),
EXTRACT_16BITS(&VAR_1[VAR_3+4])));
break;
case VAR_14:
if (VAR_2 - VAR_3 < VAR_15) {
ND_PRINT((VAR_0, ""(auth: trunc)""));
goto trunc;
}
ND_PRINT((VAR_0, ""(auth)""));
break;
default:
if (VAR_2 - VAR_3 < VAR_7) {
ND_PRINT((VAR_0, ""(sopt_type %u: trunc)"", VAR_1[VAR_3]));
goto trunc;
}
ND_PRINT((VAR_0, ""(type-0x%02x: len=%u)"", VAR_1[VAR_3], VAR_1[VAR_3 + 1]));
break;
}
}
return 0;
trunc:
return 1;
}",the-tcpdump-group/tcpdump/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00/print-mobility.c/vul/before/0.json,"static int
mobility_opt_print(netdissect_options *ndo,
                   const u_char *bp, const unsigned len)
{
	unsigned i, optlen;

	for (i = 0; i < len; i += optlen) {
		ND_TCHECK(bp[i]);
		if (bp[i] == IP6MOPT_PAD1)
			optlen = 1;
		else {
			if (i + 1 < len) {
				ND_TCHECK(bp[i + 1]);
				optlen = bp[i + 1] + 2;
			}
			else
				goto trunc;
		}
		if (i + optlen > len)
			goto trunc;
		ND_TCHECK(bp[i + optlen]);

		switch (bp[i]) {
		case IP6MOPT_PAD1:
			ND_PRINT((ndo, ""(pad1)""));
			break;
		case IP6MOPT_PADN:
			if (len - i < IP6MOPT_MINLEN) {
				ND_PRINT((ndo, ""(padn: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(padn)""));
			break;
		case IP6MOPT_REFRESH:
			if (len - i < IP6MOPT_REFRESH_MINLEN) {
				ND_PRINT((ndo, ""(refresh: trunc)""));
				goto trunc;
			}
			/* units of 4 secs */
			ND_TCHECK_16BITS(&bp[i+2]);
			ND_PRINT((ndo, ""(refresh: %u)"",
				EXTRACT_16BITS(&bp[i+2]) << 2));
			break;
		case IP6MOPT_ALTCOA:
			if (len - i < IP6MOPT_ALTCOA_MINLEN) {
				ND_PRINT((ndo, ""(altcoa: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));
			break;
		case IP6MOPT_NONCEID:
			if (len - i < IP6MOPT_NONCEID_MINLEN) {
				ND_PRINT((ndo, ""(ni: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
				EXTRACT_16BITS(&bp[i+2]),
				EXTRACT_16BITS(&bp[i+4])));
			break;
		case IP6MOPT_AUTH:
			if (len - i < IP6MOPT_AUTH_MINLEN) {
				ND_PRINT((ndo, ""(auth: trunc)""));
				goto trunc;
			}
			ND_PRINT((ndo, ""(auth)""));
			break;
		default:
			if (len - i < IP6MOPT_MINLEN) {
				ND_PRINT((ndo, ""(sopt_type %u: trunc)"", bp[i]));
				goto trunc;
			}
			ND_PRINT((ndo, ""(type-0x%02x: len=%u)"", bp[i], bp[i + 1]));
			break;
		}
	}
	return 0;

trunc:
	return 1;
}","static int
mobility_opt_print(netdissect_options *VAR_0,
                   const u_char *VAR_1, const unsigned VAR_2)
{
	unsigned VAR_3, VAR_4;

	for (VAR_3 = 0; VAR_3 < VAR_2; VAR_3 += VAR_4) {
		ND_TCHECK(VAR_1[VAR_3]);
		if (VAR_1[VAR_3] == VAR_5)
			VAR_4 = 1;
		else {
			if (VAR_3 + 1 < VAR_2) {
				ND_TCHECK(VAR_1[VAR_3 + 1]);
				VAR_4 = VAR_1[VAR_3 + 1] + 2;
			}
			else
				goto trunc;
		}
		if (VAR_3 + VAR_4 > VAR_2)
			goto trunc;
		ND_TCHECK(VAR_1[VAR_3 + VAR_4]);

		switch (VAR_1[VAR_3]) {
		case VAR_5:
			ND_PRINT((VAR_0, ""(pad1)""));
			break;
		case VAR_6:
			if (VAR_2 - VAR_3 < VAR_7) {
				ND_PRINT((VAR_0, ""(padn: trunc)""));
				goto trunc;
			}
			ND_PRINT((VAR_0, ""(padn)""));
			break;
		case VAR_8:
			if (VAR_2 - VAR_3 < VAR_9) {
				ND_PRINT((VAR_0, ""(refresh: trunc)""));
				goto trunc;
			}
			/* COMMENT_0 */
			ND_TCHECK_16BITS(&VAR_1[VAR_3+2]);
			ND_PRINT((VAR_0, ""(refresh: %u)"",
				EXTRACT_16BITS(&VAR_1[VAR_3+2]) << 2));
			break;
		case VAR_10:
			if (VAR_2 - VAR_3 < VAR_11) {
				ND_PRINT((VAR_0, ""(altcoa: trunc)""));
				goto trunc;
			}
			ND_PRINT((VAR_0, ""(alt-CoA: %s)"", ip6addr_string(VAR_0, &VAR_1[VAR_3+2])));
			break;
		case VAR_12:
			if (VAR_2 - VAR_3 < VAR_13) {
				ND_PRINT((VAR_0, ""(ni: trunc)""));
				goto trunc;
			}
			ND_PRINT((VAR_0, ""(ni: ho=0x%04x co=0x%04x)"",
				EXTRACT_16BITS(&VAR_1[VAR_3+2]),
				EXTRACT_16BITS(&VAR_1[VAR_3+4])));
			break;
		case VAR_14:
			if (VAR_2 - VAR_3 < VAR_15) {
				ND_PRINT((VAR_0, ""(auth: trunc)""));
				goto trunc;
			}
			ND_PRINT((VAR_0, ""(auth)""));
			break;
		default:
			if (VAR_2 - VAR_3 < VAR_7) {
				ND_PRINT((VAR_0, ""(sopt_type %u: trunc)"", VAR_1[VAR_3]));
				goto trunc;
			}
			ND_PRINT((VAR_0, ""(type-0x%02x: len=%u)"", VAR_1[VAR_3], VAR_1[VAR_3 + 1]));
			break;
		}
	}
	return 0;

trunc:
	return 1;
}",the-tcpdump-group/tcpdump/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00/print-mobility.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,6 +37,7 @@
 				goto trunc;
 			}
 			/* units of 4 secs */
+			ND_TCHECK_16BITS(&bp[i+2]);
 			ND_PRINT((ndo, ""(refresh: %u)"",
 				EXTRACT_16BITS(&bp[i+2]) << 2));
 			break;","{'deleted_lines': [], 'added_lines': ['\t\t\tND_TCHECK_16BITS(&bp[i+2]);']}",True,The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().,9.8,CRITICAL,3,valid,2017-03-22T15:08:25Z,1
CVE-2017-7623,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jsummers/imageworsener,"Fixed a MIFF decoding bug (buffer overrun when ""depth"" param is missing)

Fixes issue #12",f9c12fa89a7f75a4489b861627fc7fa6d56e8de8,https://github.com/jsummers/imageworsener/commit/f9c12fa89a7f75a4489b861627fc7fa6d56e8de8,src/imagew-miff.c,iwmiff_read_pixels,"static int iwmiff_read_pixels(struct iwmiffrcontext *rctx)
{
int samples_per_pixel;
int samples_per_row;
size_t tmprowsize;
iw_byte *tmprow = NULL;
int retval=0;
int j;
struct iw_image *img;
img = rctx->img;
samples_per_pixel = iw_imgtype_num_channels(img->imgtype);
samples_per_row = samples_per_pixel * img->width;
tmprowsize = (rctx->miff_bitdepth/8)*samples_per_row;
tmprow = iw_mallocz(rctx->ctx,tmprowsize);
if(!tmprow) goto done;
img->bpr = tmprowsize;
img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx, img->bpr, img->height);
if(!img->pixels) goto done;
for(j=0;j<img->height;j++) {
if(!iwmiff_read_and_uncompress_row(rctx,tmprow,tmprowsize))
goto done;
if(rctx->miff_bitdepth==64) {
iwmiffr_convert_row64_32(rctx,tmprow,&img->pixels[j*img->bpr],samples_per_row);
}
else {
iwmiffr_convert_row32(rctx,tmprow,&img->pixels[j*img->bpr],samples_per_row);
}
}
retval=1;
done:
if(tmprow) free(tmprow);
if(rctx->zmod && rctx->zctx) {
rctx->zmod->inflate_end(rctx->zctx);
rctx->zctx = NULL;
}
if(rctx->cbuf) {
iw_free(rctx->ctx,rctx->cbuf);
rctx->cbuf = NULL;
}
return retval;
}","static int iwmiff_read_pixels(struct iwmiffrcontext *VAR_0)
{
int VAR_1;
int VAR_2;
size_t VAR_3;
iw_byte *VAR_4 = NULL;
int VAR_5=0;
int VAR_6;
struct iw_image *VAR_7;
VAR_7 = VAR_0->img;
VAR_1 = iw_imgtype_num_channels(VAR_7->imgtype);
VAR_2 = VAR_1 * VAR_7->width;
VAR_3 = (VAR_0->miff_bitdepth/8)*VAR_2;
VAR_4 = iw_mallocz(VAR_0->ctx,VAR_3);
if(!VAR_4) goto done;
VAR_7->bpr = VAR_3;
VAR_7->pixels = (iw_byte*)iw_malloc_large(VAR_0->ctx, VAR_7->bpr, VAR_7->height);
if(!VAR_7->pixels) goto done;
for(VAR_6=0;VAR_6<VAR_7->height;VAR_6++) {
if(!iwmiff_read_and_uncompress_row(VAR_0,VAR_4,VAR_3))
goto done;
if(VAR_0->miff_bitdepth==64) {
iwmiffr_convert_row64_32(VAR_0,VAR_4,&VAR_7->pixels[VAR_6*VAR_7->bpr],VAR_2);
}
else {
iwmiffr_convert_row32(VAR_0,VAR_4,&VAR_7->pixels[VAR_6*VAR_7->bpr],VAR_2);
}
}
VAR_5=1;
done:
if(VAR_4) free(VAR_4);
if(VAR_0->zmod && VAR_0->zctx) {
VAR_0->zmod->inflate_end(VAR_0->zctx);
VAR_0->zctx = NULL;
}
if(VAR_0->cbuf) {
iw_free(VAR_0->ctx,VAR_0->cbuf);
VAR_0->cbuf = NULL;
}
return VAR_5;
}",jsummers/imageworsener/f9c12fa89a7f75a4489b861627fc7fa6d56e8de8/imagew-miff.c/vul/before/0.json,"static int iwmiff_read_pixels(struct iwmiffrcontext *rctx)
{
	int samples_per_pixel;
	int samples_per_row;
	size_t tmprowsize;
	iw_byte *tmprow = NULL;
	int retval=0;
	int j;
	struct iw_image *img;

	img = rctx->img;

	samples_per_pixel = iw_imgtype_num_channels(img->imgtype);
	samples_per_row = samples_per_pixel * img->width;

	tmprowsize = (rctx->miff_bitdepth/8)*samples_per_row;
	tmprow = iw_mallocz(rctx->ctx,tmprowsize);
	if(!tmprow) goto done;

	img->bpr = tmprowsize;

	img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx, img->bpr, img->height);
	if(!img->pixels) goto done;

	for(j=0;j<img->height;j++) {
		if(!iwmiff_read_and_uncompress_row(rctx,tmprow,tmprowsize))
			goto done;

		// There are two possibilities for {miff_bitdepth, img->bit_depth}:
		//  32->32, 64->32
		if(rctx->miff_bitdepth==64) {
			iwmiffr_convert_row64_32(rctx,tmprow,&img->pixels[j*img->bpr],samples_per_row);
		}
		else if(rctx->miff_bitdepth==32) {
			iwmiffr_convert_row32(rctx,tmprow,&img->pixels[j*img->bpr],samples_per_row);
		}
	}

	retval=1;

done:
	if(tmprow) free(tmprow);
	if(rctx->zmod && rctx->zctx) {
		rctx->zmod->inflate_end(rctx->zctx);
		rctx->zctx = NULL;
	}
	if(rctx->cbuf) {
		iw_free(rctx->ctx,rctx->cbuf);
		rctx->cbuf = NULL;
	}
	return retval;
}","static int iwmiff_read_pixels(struct iwmiffrcontext *VAR_0)
{
	int VAR_1;
	int VAR_2;
	size_t VAR_3;
	iw_byte *VAR_4 = NULL;
	int VAR_5=0;
	int VAR_6;
	struct iw_image *VAR_7;

	VAR_7 = VAR_0->img;

	VAR_1 = iw_imgtype_num_channels(VAR_7->imgtype);
	VAR_2 = VAR_1 * VAR_7->width;

	VAR_3 = (VAR_0->miff_bitdepth/8)*VAR_2;
	VAR_4 = iw_mallocz(VAR_0->ctx,VAR_3);
	if(!VAR_4) goto done;

	VAR_7->bpr = VAR_3;

	VAR_7->pixels = (iw_byte*)iw_malloc_large(VAR_0->ctx, VAR_7->bpr, VAR_7->height);
	if(!VAR_7->pixels) goto done;

	for(VAR_6=0;VAR_6<VAR_7->height;VAR_6++) {
		if(!iwmiff_read_and_uncompress_row(VAR_0,VAR_4,VAR_3))
			goto done;

		/* COMMENT_0 */
		/* COMMENT_1 */
		if(VAR_0->miff_bitdepth==64) {
			iwmiffr_convert_row64_32(VAR_0,VAR_4,&VAR_7->pixels[VAR_6*VAR_7->bpr],VAR_2);
		}
		else if(VAR_0->miff_bitdepth==32) {
			iwmiffr_convert_row32(VAR_0,VAR_4,&VAR_7->pixels[VAR_6*VAR_7->bpr],VAR_2);
		}
	}

	VAR_5=1;

done:
	if(VAR_4) free(VAR_4);
	if(VAR_0->zmod && VAR_0->zctx) {
		VAR_0->zmod->inflate_end(VAR_0->zctx);
		VAR_0->zctx = NULL;
	}
	if(VAR_0->cbuf) {
		iw_free(VAR_0->ctx,VAR_0->cbuf);
		VAR_0->cbuf = NULL;
	}
	return VAR_5;
}",jsummers/imageworsener/f9c12fa89a7f75a4489b861627fc7fa6d56e8de8/imagew-miff.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
 		if(rctx->miff_bitdepth==64) {
 			iwmiffr_convert_row64_32(rctx,tmprow,&img->pixels[j*img->bpr],samples_per_row);
 		}
-		else {
+		else if(rctx->miff_bitdepth==32) {
 			iwmiffr_convert_row32(rctx,tmprow,&img->pixels[j*img->bpr],samples_per_row);
 		}
 	}","{'deleted_lines': ['\t\telse {'], 'added_lines': ['\t\telse if(rctx->miff_bitdepth==32) {']}",True,The iwmiffr_convert_row32 function in imagew-miff.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted file.,5.5,MEDIUM,1,valid,2017-04-05T15:06:14Z,1
CVE-2017-7623,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jsummers/imageworsener,"Fixed a MIFF decoding bug (buffer overrun when ""depth"" param is missing)

Fixes issue #12",f9c12fa89a7f75a4489b861627fc7fa6d56e8de8,https://github.com/jsummers/imageworsener/commit/f9c12fa89a7f75a4489b861627fc7fa6d56e8de8,src/imagew-miff.c,iw_read_miff_file,"IW_IMPL(int) iw_read_miff_file(struct iw_context *ctx, struct iw_iodescr *iodescr)
{
struct iw_image img;
struct iwmiffrcontext rctx;
int retval=0;
iw_zeromem(&rctx,sizeof(struct iwmiffrcontext));
iw_zeromem(&img,sizeof(struct iw_image));
rctx.ctx = ctx;
rctx.host_endian = iw_get_host_endianness();
rctx.iodescr = iodescr;
rctx.img = &img;
rctx.compression = IW_COMPRESSION_NONE;
rctx.zmod = iw_get_zlib_module(ctx);
iw_make_srgb_csdescr_2(&rctx.csdescr);
img.sampletype = IW_SAMPLETYPE_FLOATINGPOINT;
if(!iwmiff_read_header(&rctx))
goto done;
if(!iw_check_image_dimensions(rctx.ctx,img.width,img.height))
goto done;
if(rctx.is_grayscale) {
img.imgtype = rctx.has_alpha ? IW_IMGTYPE_GRAYA : IW_IMGTYPE_GRAY;
img.native_grayscale = 1;
}
else {
img.imgtype = rctx.has_alpha ? IW_IMGTYPE_RGBA : IW_IMGTYPE_RGB;
}
if(rctx.density_known && rctx.density_units==1) {
img.density_x = rctx.density_x*100.0;
img.density_y = rctx.density_y*100.0;
img.density_code = IW_DENSITY_UNITS_PER_METER;
}
if(!iwmiff_read_icc_profile(&rctx))
goto done;
if(!iwmiff_read_pixels(&rctx))
goto done;
iw_set_input_image(ctx, &img);
iw_set_input_colorspace(ctx,&rctx.csdescr);
retval = 1;
done:
if(!retval) {
iw_set_error(ctx,""Failed to read MIFF file"");
}
return retval;
}","VAR_0(int) iw_read_miff_file(struct iw_context *VAR_1, struct iw_iodescr *VAR_2)
{
struct iw_image VAR_3;
struct iwmiffrcontext VAR_4;
int VAR_5=0;
iw_zeromem(&VAR_4,sizeof(struct iwmiffrcontext));
iw_zeromem(&VAR_3,sizeof(struct iw_image));
VAR_4.ctx = VAR_1;
VAR_4.host_endian = iw_get_host_endianness();
VAR_4.iodescr = VAR_2;
VAR_4.img = &VAR_3;
VAR_4.compression = VAR_6;
VAR_4.zmod = iw_get_zlib_module(VAR_1);
iw_make_srgb_csdescr_2(&VAR_4.csdescr);
VAR_3.sampletype = VAR_7;
if(!iwmiff_read_header(&VAR_4))
goto done;
if(!iw_check_image_dimensions(VAR_4.ctx,VAR_3.width,VAR_3.height))
goto done;
if(VAR_4.is_grayscale) {
VAR_3.imgtype = VAR_4.has_alpha ? VAR_8 : VAR_9;
VAR_3.native_grayscale = 1;
}
else {
VAR_3.imgtype = VAR_4.has_alpha ? VAR_10 : VAR_11;
}
if(VAR_4.density_known && VAR_4.density_units==1) {
VAR_3.density_x = VAR_4.density_x*100.0;
VAR_3.density_y = VAR_4.density_y*100.0;
VAR_3.density_code = VAR_12;
}
if(!iwmiff_read_icc_profile(&VAR_4))
goto done;
if(!iwmiff_read_pixels(&VAR_4))
goto done;
iw_set_input_image(VAR_1, &VAR_3);
iw_set_input_colorspace(VAR_1,&VAR_4.csdescr);
VAR_5 = 1;
done:
if(!VAR_5) {
iw_set_error(VAR_1,""Failed to read MIFF file"");
}
return VAR_5;
}",,"IW_IMPL(int) iw_read_miff_file(struct iw_context *ctx, struct iw_iodescr *iodescr)
{
	struct iw_image img;
	struct iwmiffrcontext rctx;
	int retval=0;

	iw_zeromem(&rctx,sizeof(struct iwmiffrcontext));
	iw_zeromem(&img,sizeof(struct iw_image));

	rctx.ctx = ctx;
	rctx.host_endian = iw_get_host_endianness();
	rctx.iodescr = iodescr;
	rctx.img = &img;
	rctx.compression = IW_COMPRESSION_NONE;
	rctx.zmod = iw_get_zlib_module(ctx);

	// Assume sRGB by default
	iw_make_srgb_csdescr_2(&rctx.csdescr);

	img.sampletype = IW_SAMPLETYPE_FLOATINGPOINT;

	if(!iwmiff_read_header(&rctx))
		goto done;

	if(img.bit_depth!=32 && img.bit_depth!=64) {
		iw_set_error(ctx, ""MIFF: Unsupported or unset bit depth"");
		goto done;

	}

	if(!iw_check_image_dimensions(rctx.ctx,img.width,img.height))
		goto done;

	if(rctx.is_grayscale) {
		img.imgtype = rctx.has_alpha ? IW_IMGTYPE_GRAYA : IW_IMGTYPE_GRAY;
		img.native_grayscale = 1;
	}
	else {
		img.imgtype = rctx.has_alpha ? IW_IMGTYPE_RGBA : IW_IMGTYPE_RGB;
	}

	if(rctx.density_known && rctx.density_units==1) {
		img.density_x = rctx.density_x*100.0;
		img.density_y = rctx.density_y*100.0;
		img.density_code = IW_DENSITY_UNITS_PER_METER;
	}

	if(!iwmiff_read_icc_profile(&rctx))
		goto done;

	if(!iwmiff_read_pixels(&rctx))
		goto done;

	iw_set_input_image(ctx, &img);

	iw_set_input_colorspace(ctx,&rctx.csdescr);

	retval = 1;

done:
	if(!retval) {
		iw_set_error(ctx,""Failed to read MIFF file"");
	}
	return retval;
}","VAR_0(int) iw_read_miff_file(struct iw_context *VAR_1, struct iw_iodescr *VAR_2)
{
	struct iw_image VAR_3;
	struct iwmiffrcontext VAR_4;
	int VAR_5=0;

	iw_zeromem(&VAR_4,sizeof(struct iwmiffrcontext));
	iw_zeromem(&VAR_3,sizeof(struct iw_image));

	VAR_4.ctx = VAR_1;
	VAR_4.host_endian = iw_get_host_endianness();
	VAR_4.iodescr = VAR_2;
	VAR_4.img = &VAR_3;
	VAR_4.compression = VAR_6;
	VAR_4.zmod = iw_get_zlib_module(VAR_1);

	/* COMMENT_0 */
	iw_make_srgb_csdescr_2(&VAR_4.csdescr);

	VAR_3.sampletype = VAR_7;

	if(!iwmiff_read_header(&VAR_4))
		goto done;

	if(VAR_3.bit_depth!=32 && VAR_3.bit_depth!=64) {
		iw_set_error(VAR_1, ""MIFF: Unsupported or unset bit depth"");
		goto done;

	}

	if(!iw_check_image_dimensions(VAR_4.ctx,VAR_3.width,VAR_3.height))
		goto done;

	if(VAR_4.is_grayscale) {
		VAR_3.imgtype = VAR_4.has_alpha ? VAR_8 : VAR_9;
		VAR_3.native_grayscale = 1;
	}
	else {
		VAR_3.imgtype = VAR_4.has_alpha ? VAR_10 : VAR_11;
	}

	if(VAR_4.density_known && VAR_4.density_units==1) {
		VAR_3.density_x = VAR_4.density_x*100.0;
		VAR_3.density_y = VAR_4.density_y*100.0;
		VAR_3.density_code = VAR_12;
	}

	if(!iwmiff_read_icc_profile(&VAR_4))
		goto done;

	if(!iwmiff_read_pixels(&VAR_4))
		goto done;

	iw_set_input_image(VAR_1, &VAR_3);

	iw_set_input_colorspace(VAR_1,&VAR_4.csdescr);

	VAR_5 = 1;

done:
	if(!VAR_5) {
		iw_set_error(VAR_1,""Failed to read MIFF file"");
	}
	return VAR_5;
}",,"--- func_before
+++ func_after
@@ -21,6 +21,12 @@
 
 	if(!iwmiff_read_header(&rctx))
 		goto done;
+
+	if(img.bit_depth!=32 && img.bit_depth!=64) {
+		iw_set_error(ctx, ""MIFF: Unsupported or unset bit depth"");
+		goto done;
+
+	}
 
 	if(!iw_check_image_dimensions(rctx.ctx,img.width,img.height))
 		goto done;","{'deleted_lines': [], 'added_lines': ['', '\tif(img.bit_depth!=32 && img.bit_depth!=64) {', '\t\tiw_set_error(ctx, ""MIFF: Unsupported or unset bit depth"");', '\t\tgoto done;', '', '\t}']}",True,The iwmiffr_convert_row32 function in imagew-miff.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted file.,5.5,MEDIUM,1,valid,2017-04-05T15:06:14Z,1
CVE-2017-8086,['CWE-772'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,qemu,"9pfs: xattr: fix memory leak in v9fs_list_xattr

Free 'orig_value' in error path.

Signed-off-by: Li Qiang <liqiang6-s@360.cn>
Signed-off-by: Greg Kurz <groug@kaod.org>",4ffcdef4277a91af15a3c09f7d16af072c29f3f2,https://github.com/qemu/qemu/commit/4ffcdef4277a91af15a3c09f7d16af072c29f3f2,hw/9pfs/9p-xattr.c,v9fs_list_xattr,"ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,
void *value, size_t vsize)
{
ssize_t size = 0;
void *ovalue = value;
XattrOperations *xops;
char *orig_value, *orig_value_start;
ssize_t xattr_len, parsed_len = 0, attr_len;
char *dirpath, *name;
int dirfd;
dirpath = g_path_get_dirname(path);
dirfd = local_opendir_nofollow(ctx, dirpath);
g_free(dirpath);
if (dirfd == -1) {
return -1;
}
name = g_path_get_basename(path);
xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);
if (xattr_len <= 0) {
g_free(name);
close_preserve_errno(dirfd);
return xattr_len;
}
orig_value = g_malloc(xattr_len);
xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);
g_free(name);
close_preserve_errno(dirfd);
if (xattr_len < 0) {
return -1;
}
orig_value_start = orig_value;
while (xattr_len > parsed_len) {
xops = get_xattr_operations(ctx->xops, orig_value);
if (!xops) {
goto next_entry;
}
if (!value) {
size += xops->listxattr(ctx, path, orig_value, value, vsize);
} else {
size = xops->listxattr(ctx, path, orig_value, value, vsize);
if (size < 0) {
goto err_out;
}
value += size;
vsize -= size;
}
next_entry:
attr_len = strlen(orig_value) + 1;
parsed_len += attr_len;
orig_value += attr_len;
}
if (value) {
size = value - ovalue;
}
err_out:
g_free(orig_value_start);
return size;
}","ssize_t v9fs_list_xattr(FsContext *VAR_0, const char *VAR_1,
void *VAR_2, size_t VAR_3)
{
ssize_t VAR_4 = 0;
void *VAR_5 = VAR_2;
XattrOperations *VAR_6;
char *VAR_7, *VAR_8;
ssize_t VAR_9, VAR_10 = 0, VAR_11;
char *VAR_12, *VAR_13;
int VAR_14;
VAR_12 = g_path_get_dirname(VAR_1);
VAR_14 = local_opendir_nofollow(VAR_0, VAR_12);
g_free(VAR_12);
if (VAR_14 == -1) {
return -1;
}
VAR_13 = g_path_get_basename(VAR_1);
VAR_9 = flistxattrat_nofollow(VAR_14, VAR_13, VAR_2, 0);
if (VAR_9 <= 0) {
g_free(VAR_13);
close_preserve_errno(VAR_14);
return VAR_9;
}
VAR_7 = g_malloc(VAR_9);
VAR_9 = flistxattrat_nofollow(VAR_14, VAR_13, VAR_7, VAR_9);
g_free(VAR_13);
close_preserve_errno(VAR_14);
if (VAR_9 < 0) {
return -1;
}
VAR_8 = VAR_7;
while (VAR_9 > VAR_10) {
VAR_6 = get_xattr_operations(VAR_0->xops, VAR_7);
if (!VAR_6) {
goto next_entry;
}
if (!VAR_2) {
VAR_4 += VAR_6->listxattr(VAR_0, VAR_1, VAR_7, VAR_2, VAR_3);
} else {
VAR_4 = VAR_6->listxattr(VAR_0, VAR_1, VAR_7, VAR_2, VAR_3);
if (VAR_4 < 0) {
goto err_out;
}
VAR_2 += VAR_4;
VAR_3 -= VAR_4;
}
next_entry:
VAR_11 = strlen(VAR_7) + 1;
VAR_10 += VAR_11;
VAR_7 += VAR_11;
}
if (VAR_2) {
VAR_4 = VAR_2 - VAR_5;
}
err_out:
g_free(VAR_8);
return VAR_4;
}",qemu/4ffcdef4277a91af15a3c09f7d16af072c29f3f2/9p-xattr.c/vul/before/0.json,"ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,
                        void *value, size_t vsize)
{
    ssize_t size = 0;
    void *ovalue = value;
    XattrOperations *xops;
    char *orig_value, *orig_value_start;
    ssize_t xattr_len, parsed_len = 0, attr_len;
    char *dirpath, *name;
    int dirfd;

    /* Get the actual len */
    dirpath = g_path_get_dirname(path);
    dirfd = local_opendir_nofollow(ctx, dirpath);
    g_free(dirpath);
    if (dirfd == -1) {
        return -1;
    }

    name = g_path_get_basename(path);
    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);
    if (xattr_len <= 0) {
        g_free(name);
        close_preserve_errno(dirfd);
        return xattr_len;
    }

    /* Now fetch the xattr and find the actual size */
    orig_value = g_malloc(xattr_len);
    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);
    g_free(name);
    close_preserve_errno(dirfd);
    if (xattr_len < 0) {
        g_free(orig_value);
        return -1;
    }

    /* store the orig pointer */
    orig_value_start = orig_value;
    while (xattr_len > parsed_len) {
        xops = get_xattr_operations(ctx->xops, orig_value);
        if (!xops) {
            goto next_entry;
        }

        if (!value) {
            size += xops->listxattr(ctx, path, orig_value, value, vsize);
        } else {
            size = xops->listxattr(ctx, path, orig_value, value, vsize);
            if (size < 0) {
                goto err_out;
            }
            value += size;
            vsize -= size;
        }
next_entry:
        /* Got the next entry */
        attr_len = strlen(orig_value) + 1;
        parsed_len += attr_len;
        orig_value += attr_len;
    }
    if (value) {
        size = value - ovalue;
    }

err_out:
    g_free(orig_value_start);
    return size;
}","ssize_t v9fs_list_xattr(FsContext *VAR_0, const char *VAR_1,
                        void *VAR_2, size_t VAR_3)
{
    ssize_t VAR_4 = 0;
    void *VAR_5 = VAR_2;
    XattrOperations *VAR_6;
    char *VAR_7, *VAR_8;
    ssize_t VAR_9, VAR_10 = 0, VAR_11;
    char *VAR_12, *VAR_13;
    int VAR_14;

    /* COMMENT_0 */
    VAR_12 = g_path_get_dirname(VAR_1);
    VAR_14 = local_opendir_nofollow(VAR_0, VAR_12);
    g_free(VAR_12);
    if (VAR_14 == -1) {
        return -1;
    }

    VAR_13 = g_path_get_basename(VAR_1);
    VAR_9 = flistxattrat_nofollow(VAR_14, VAR_13, VAR_2, 0);
    if (VAR_9 <= 0) {
        g_free(VAR_13);
        close_preserve_errno(VAR_14);
        return VAR_9;
    }

    /* COMMENT_1 */
    VAR_7 = g_malloc(VAR_9);
    VAR_9 = flistxattrat_nofollow(VAR_14, VAR_13, VAR_7, VAR_9);
    g_free(VAR_13);
    close_preserve_errno(VAR_14);
    if (VAR_9 < 0) {
        g_free(VAR_7);
        return -1;
    }

    /* COMMENT_2 */
    VAR_8 = VAR_7;
    while (VAR_9 > VAR_10) {
        VAR_6 = get_xattr_operations(VAR_0->xops, VAR_7);
        if (!VAR_6) {
            goto next_entry;
        }

        if (!VAR_2) {
            VAR_4 += VAR_6->listxattr(VAR_0, VAR_1, VAR_7, VAR_2, VAR_3);
        } else {
            VAR_4 = VAR_6->listxattr(VAR_0, VAR_1, VAR_7, VAR_2, VAR_3);
            if (VAR_4 < 0) {
                goto err_out;
            }
            VAR_2 += VAR_4;
            VAR_3 -= VAR_4;
        }
next_entry:
        /* COMMENT_3 */
        VAR_11 = strlen(VAR_7) + 1;
        VAR_10 += VAR_11;
        VAR_7 += VAR_11;
    }
    if (VAR_2) {
        VAR_4 = VAR_2 - VAR_5;
    }

err_out:
    g_free(VAR_8);
    return VAR_4;
}",qemu/4ffcdef4277a91af15a3c09f7d16af072c29f3f2/9p-xattr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,6 +31,7 @@
     g_free(name);
     close_preserve_errno(dirfd);
     if (xattr_len < 0) {
+        g_free(orig_value);
         return -1;
     }
 ","{'deleted_lines': [], 'added_lines': ['        g_free(orig_value);']}",True,Memory leak in the v9fs_list_xattr function in hw/9pfs/9p-xattr.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (memory consumption) via vectors involving the orig_value variable.,6.5,MEDIUM,1,valid,2017-04-07T10:48:52Z,1
CVE-2017-7375,['CWE-611'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,GNOME/libxml2,"Prevent unwanted external entity reference

For https://bugzilla.gnome.org/show_bug.cgi?id=780691

* parser.c: add a specific check to avoid PE reference",90ccb58242866b0ba3edbef8fe44214a101c2b3e,https://github.com/GNOME/libxml2/commit/90ccb58242866b0ba3edbef8fe44214a101c2b3e,parser.c,xmlParsePEReference,"void
xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
const xmlChar *name;
xmlEntityPtr entity = NULL;
xmlParserInputPtr input;
if (RAW != '%')
return;
NEXT;
name = xmlParseName(ctxt);
if (name == NULL) {
xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
""xmlParsePEReference: no name\n"");
return;
}
if (RAW != ';') {
xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
return;
}
NEXT;
ctxt->nbentities++;
if ((ctxt->sax != NULL) &&
(ctxt->sax->getParameterEntity != NULL))
entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
if (ctxt->instate == XML_PARSER_EOF)
return;
if (entity == NULL) {
if ((ctxt->standalone == 1) ||
((ctxt->hasExternalSubset == 0) &&
(ctxt->hasPErefs == 0))) {
xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
""PEReference: %%%s; not found\n"",
name);
} else {
xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
""PEReference: %%%s; not found\n"",
name, NULL);
ctxt->valid = 0;
}
xmlParserEntityCheck(ctxt, 0, NULL, 0);
} else {
if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
(entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
""Internal: %%%s; is not a parameter entity\n"",
name, NULL);
} else if (ctxt->input->free != deallocblankswrapper) {
input = xmlNewBlanksWrapperInputStream(ctxt, entity);
if (xmlPushInput(ctxt, input) < 0)
return;
} else {
input = xmlNewEntityInputStream(ctxt, entity);
if (xmlPushInput(ctxt, input) < 0)
return;
if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
(IS_BLANK_CH(NXT(5)))) {
xmlParseTextDecl(ctxt);
if (ctxt->errNo ==
XML_ERR_UNSUPPORTED_ENCODING) {
xmlHaltParser(ctxt);
return;
}
}
}
}
ctxt->hasPErefs = 1;
}","void
xmlParsePEReference(xmlParserCtxtPtr VAR_0)
{
const xmlChar *VAR_1;
xmlEntityPtr VAR_2 = NULL;
xmlParserInputPtr VAR_3;
if (VAR_4 != '%')
return;
VAR_5;
VAR_1 = xmlParseName(VAR_0);
if (VAR_1 == NULL) {
xmlFatalErrMsg(VAR_0, VAR_6,
""xmlParsePEReference: no name\n"");
return;
}
if (VAR_4 != ';') {
xmlFatalErr(VAR_0, VAR_7, NULL);
return;
}
VAR_5;
VAR_0->nbentities++;
if ((VAR_0->sax != NULL) &&
(VAR_0->sax->getParameterEntity != NULL))
VAR_2 = VAR_0->sax->getParameterEntity(VAR_0->userData, VAR_1);
if (VAR_0->instate == VAR_8)
return;
if (VAR_2 == NULL) {
if ((VAR_0->standalone == 1) ||
((VAR_0->hasExternalSubset == 0) &&
(VAR_0->hasPErefs == 0))) {
xmlFatalErrMsgStr(VAR_0, VAR_9,
""PEReference: %%%s; not found\n"",
VAR_1);
} else {
xmlWarningMsg(VAR_0, VAR_10,
""PEReference: %%%s; not found\n"",
VAR_1, NULL);
VAR_0->valid = 0;
}
xmlParserEntityCheck(VAR_0, 0, NULL, 0);
} else {
if ((VAR_2->etype != VAR_11) &&
(VAR_2->etype != VAR_12)) {
xmlWarningMsg(VAR_0, VAR_10,
""Internal: %%%s; is not a parameter entity\n"",
VAR_1, NULL);
} else if (VAR_0->input->free != VAR_13) {
VAR_3 = xmlNewBlanksWrapperInputStream(VAR_0, VAR_2);
if (xmlPushInput(VAR_0, VAR_3) < 0)
return;
} else {
VAR_3 = xmlNewEntityInputStream(VAR_0, VAR_2);
if (xmlPushInput(VAR_0, VAR_3) < 0)
return;
if ((VAR_2->etype == VAR_12) &&
(CMP5(VAR_14, '<', '?', 'x', 'm', 'l')) &&
(IS_BLANK_CH(NXT(5)))) {
xmlParseTextDecl(VAR_0);
if (VAR_0->errNo ==
VAR_15) {
xmlHaltParser(VAR_0);
return;
}
}
}
}
VAR_0->hasPErefs = 1;
}",GNOME/libxml2/90ccb58242866b0ba3edbef8fe44214a101c2b3e/parser.c/vul/before/0.json,"void
xmlParsePEReference(xmlParserCtxtPtr ctxt)
{
    const xmlChar *name;
    xmlEntityPtr entity = NULL;
    xmlParserInputPtr input;

    if (RAW != '%')
        return;
    NEXT;
    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
		       ""xmlParsePEReference: no name\n"");
	return;
    }
    if (RAW != ';') {
	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
        return;
    }

    NEXT;

    /*
     * Increate the number of entity references parsed
     */
    ctxt->nbentities++;

    /*
     * Request the entity from SAX
     */
    if ((ctxt->sax != NULL) &&
	(ctxt->sax->getParameterEntity != NULL))
	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
    if (ctxt->instate == XML_PARSER_EOF)
	return;
    if (entity == NULL) {
	/*
	 * [ WFC: Entity Declared ]
	 * In a document without any DTD, a document with only an
	 * internal DTD subset which contains no parameter entity
	 * references, or a document with ""standalone='yes'"", ...
	 * ... The declaration of a parameter entity must precede
	 * any reference to it...
	 */
	if ((ctxt->standalone == 1) ||
	    ((ctxt->hasExternalSubset == 0) &&
	     (ctxt->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
			      ""PEReference: %%%s; not found\n"",
			      name);
	} else {
	    /*
	     * [ VC: Entity Declared ]
	     * In a document with an external subset or external
	     * parameter entities with ""standalone='no'"", ...
	     * ... The declaration of a parameter entity must
	     * precede any reference to it...
	     */
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
			  ""PEReference: %%%s; not found\n"",
			  name, NULL);
	    ctxt->valid = 0;
	}
	xmlParserEntityCheck(ctxt, 0, NULL, 0);
    } else {
	/*
	 * Internal checking in case the entity quest barfed
	 */
	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  name, NULL);
	} else if (ctxt->input->free != deallocblankswrapper) {
	    input = xmlNewBlanksWrapperInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
		return;
	} else {
	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
		(ctxt->replaceEntities == 0) &&
		(ctxt->validate == 0))
		return;

	    /*
	     * TODO !!!
	     * handle the extra spaces added before and after
	     * c.f. http://www.w3.org/TR/REC-xml#as-PE
	     */
	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
		return;
	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
		(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
		(IS_BLANK_CH(NXT(5)))) {
		xmlParseTextDecl(ctxt);
		if (ctxt->errNo ==
		    XML_ERR_UNSUPPORTED_ENCODING) {
		    /*
		     * The XML REC instructs us to stop parsing
		     * right here
		     */
		    xmlHaltParser(ctxt);
		    return;
		}
	    }
	}
    }
    ctxt->hasPErefs = 1;
}","void
xmlParsePEReference(xmlParserCtxtPtr VAR_0)
{
    const xmlChar *VAR_1;
    xmlEntityPtr VAR_2 = NULL;
    xmlParserInputPtr VAR_3;

    if (VAR_4 != '%')
        return;
    VAR_5;
    VAR_1 = xmlParseName(VAR_0);
    if (VAR_1 == NULL) {
	xmlFatalErrMsg(VAR_0, VAR_6,
		       ""xmlParsePEReference: no name\n"");
	return;
    }
    if (VAR_4 != ';') {
	xmlFatalErr(VAR_0, VAR_7, NULL);
        return;
    }

    VAR_5;

    /* COMMENT_0 */
                                                      
       
    VAR_0->nbentities++;

    /* COMMENT_3 */
                                  
       
    if ((VAR_0->sax != NULL) &&
	(VAR_0->sax->getParameterEntity != NULL))
	VAR_2 = VAR_0->sax->getParameterEntity(VAR_0->userData, VAR_1);
    if (VAR_0->instate == VAR_8)
	return;
    if (VAR_2 == NULL) {
	/* COMMENT_6 */
                            
                                                          
                                                          
                                                          
                                                          
                          
    
	if ((VAR_0->standalone == 1) ||
	    ((VAR_0->hasExternalSubset == 0) &&
	     (VAR_0->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(VAR_0, VAR_9,
			      ""PEReference: %%%s; not found\n"",
			      VAR_1);
	} else {
	    /* COMMENT_14 */
                               
                                                         
                                                      
                                                      
                                      
        
	    xmlWarningMsg(VAR_0, VAR_10,
			  ""PEReference: %%%s; not found\n"",
			  VAR_1, NULL);
	    VAR_0->valid = 0;
	}
	xmlParserEntityCheck(VAR_0, 0, NULL, 0);
    } else {
	/* COMMENT_21 */
                                                     
    
	if ((VAR_2->etype != VAR_11) &&
	    (VAR_2->etype != VAR_12)) {
	    xmlWarningMsg(VAR_0, VAR_10,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  VAR_1, NULL);
	} else if (VAR_0->input->free != VAR_13) {
	    VAR_3 = xmlNewBlanksWrapperInputStream(VAR_0, VAR_2);
	    if (xmlPushInput(VAR_0, VAR_3) < 0)
		return;
	} else {
	    if ((VAR_2->etype == VAR_12) &&
	        ((VAR_0->options & VAR_14) == 0) &&
		((VAR_0->options & VAR_15) == 0) &&
		((VAR_0->options & VAR_16) == 0) &&
		((VAR_0->options & VAR_17) == 0) &&
		(VAR_0->replaceEntities == 0) &&
		(VAR_0->validate == 0))
		return;

	    /* COMMENT_24 */
                
                                                      
                                               
        
	    VAR_3 = xmlNewEntityInputStream(VAR_0, VAR_2);
	    if (xmlPushInput(VAR_0, VAR_3) < 0)
		return;
	    if ((VAR_2->etype == VAR_12) &&
		(CMP5(VAR_18, '<', '?', 'x', 'm', 'l')) &&
		(IS_BLANK_CH(NXT(5)))) {
		xmlParseTextDecl(VAR_0);
		if (VAR_0->errNo ==
		    VAR_19) {
		    /* COMMENT_29 */
                                                 
                   
         
		    xmlHaltParser(VAR_0);
		    return;
		}
	    }
	}
    }
    VAR_0->hasPErefs = 1;
}",GNOME/libxml2/90ccb58242866b0ba3edbef8fe44214a101c2b3e/parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,15 @@
 	    if (xmlPushInput(ctxt, input) < 0)
 		return;
 	} else {
+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+		(ctxt->replaceEntities == 0) &&
+		(ctxt->validate == 0))
+		return;
+
 	    /*
 	     * TODO !!!
 	     * handle the extra spaces added before and after","{'deleted_lines': [], 'added_lines': ['\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&', '\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&', '\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&', '\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&', '\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&', '\t\t(ctxt->replaceEntities == 0) &&', '\t\t(ctxt->validate == 0))', '\t\treturn;', '']}",True,"A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes). Depending on the context, this may expose a higher-risk attack surface in libxml2 not usually reachable with default parser flags, and expose content from local files, HTTP, or FTP servers (which might be otherwise unreachable).",9.8,CRITICAL,3,valid,2017-04-07T15:43:02Z,1
CVE-2017-7940,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jsummers/imageworsener,"Fixed a memory leak in the GIF decoder

Fixes issue #18",5fa486466630a9677b86c1d4cbfd9a5ff76cb33b,https://github.com/jsummers/imageworsener/commit/5fa486466630a9677b86c1d4cbfd9a5ff76cb33b,src/imagew-gif.c,iw_read_gif_file,"IW_IMPL(int) iw_read_gif_file(struct iw_context *ctx, struct iw_iodescr *iodescr)
{
struct iw_image img;
struct iwgifrcontext *rctx = NULL;
int retval=0;
iw_zeromem(&img,sizeof(struct iw_image));
rctx = iw_mallocz(ctx,sizeof(struct iwgifrcontext));
if(!rctx) goto done;
rctx->ctx = ctx;
rctx->iodescr = iodescr;
rctx->img = &img;
iw_make_srgb_csdescr_2(&rctx->csdescr);
rctx->page = iw_get_value(ctx,IW_VAL_PAGE_TO_READ);
if(rctx->page<1) rctx->page = 1;
rctx->include_screen = iw_get_value(ctx,IW_VAL_INCLUDE_SCREEN);
if(!iwgif_read_main(rctx))
goto done;
iw_set_input_image(ctx, &img);
iw_set_input_colorspace(ctx,&rctx->csdescr);
retval = 1;
done:
if(!retval) {
iw_set_error(ctx,""Failed to read GIF file"");
}
if(rctx) {
if(rctx->row_pointers) iw_free(ctx,rctx->row_pointers);
iw_free(ctx,rctx);
}
return retval;
}","VAR_0(int) iw_read_gif_file(struct iw_context *VAR_1, struct iw_iodescr *VAR_2)
{
struct iw_image VAR_3;
struct iwgifrcontext *VAR_4 = NULL;
int VAR_5=0;
iw_zeromem(&VAR_3,sizeof(struct iw_image));
VAR_4 = iw_mallocz(VAR_1,sizeof(struct iwgifrcontext));
if(!VAR_4) goto done;
VAR_4->ctx = VAR_1;
VAR_4->iodescr = VAR_2;
VAR_4->img = &VAR_3;
iw_make_srgb_csdescr_2(&VAR_4->csdescr);
VAR_4->page = iw_get_value(VAR_1,VAR_6);
if(VAR_4->page<1) VAR_4->page = 1;
VAR_4->include_screen = iw_get_value(VAR_1,VAR_7);
if(!iwgif_read_main(VAR_4))
goto done;
iw_set_input_image(VAR_1, &VAR_3);
iw_set_input_colorspace(VAR_1,&VAR_4->csdescr);
VAR_5 = 1;
done:
if(!VAR_5) {
iw_set_error(VAR_1,""Failed to read GIF file"");
}
if(VAR_4) {
if(VAR_4->row_pointers) iw_free(VAR_1,VAR_4->row_pointers);
iw_free(VAR_1,VAR_4);
}
return VAR_5;
}",,"IW_IMPL(int) iw_read_gif_file(struct iw_context *ctx, struct iw_iodescr *iodescr)
{
	struct iw_image img;
	struct iwgifrcontext *rctx = NULL;
	int retval=0;

	iw_zeromem(&img,sizeof(struct iw_image));
	rctx = iw_mallocz(ctx,sizeof(struct iwgifrcontext));
	if(!rctx) goto done;

	rctx->ctx = ctx;
	rctx->iodescr = iodescr;
	rctx->img = &img;

	// Assume GIF images are sRGB.
	iw_make_srgb_csdescr_2(&rctx->csdescr);

	rctx->page = iw_get_value(ctx,IW_VAL_PAGE_TO_READ);
	if(rctx->page<1) rctx->page = 1;

	rctx->include_screen = iw_get_value(ctx,IW_VAL_INCLUDE_SCREEN);

	if(!iwgif_read_main(rctx))
		goto done;

	iw_set_input_image(ctx, &img);

	iw_set_input_colorspace(ctx,&rctx->csdescr);

	retval = 1;

done:
	if(!retval) {
		iw_set_error(ctx,""Failed to read GIF file"");
		// If we didn't call iw_set_input_image, 'img' still belongs to us,
		// so free its contents.
		iw_free(ctx, img.pixels);
	}

	if(rctx) {
		if(rctx->row_pointers) iw_free(ctx,rctx->row_pointers);
		iw_free(ctx,rctx);
	}

	return retval;
}","VAR_0(int) iw_read_gif_file(struct iw_context *VAR_1, struct iw_iodescr *VAR_2)
{
	struct iw_image VAR_3;
	struct iwgifrcontext *VAR_4 = NULL;
	int VAR_5=0;

	iw_zeromem(&VAR_3,sizeof(struct iw_image));
	VAR_4 = iw_mallocz(VAR_1,sizeof(struct iwgifrcontext));
	if(!VAR_4) goto done;

	VAR_4->ctx = VAR_1;
	VAR_4->iodescr = VAR_2;
	VAR_4->img = &VAR_3;

	/* COMMENT_0 */
	iw_make_srgb_csdescr_2(&VAR_4->csdescr);

	VAR_4->page = iw_get_value(VAR_1,VAR_6);
	if(VAR_4->page<1) VAR_4->page = 1;

	VAR_4->include_screen = iw_get_value(VAR_1,VAR_7);

	if(!iwgif_read_main(VAR_4))
		goto done;

	iw_set_input_image(VAR_1, &VAR_3);

	iw_set_input_colorspace(VAR_1,&VAR_4->csdescr);

	VAR_5 = 1;

done:
	if(!VAR_5) {
		iw_set_error(VAR_1,""Failed to read GIF file"");
		/* COMMENT_1 */
		/* COMMENT_2 */
		iw_free(VAR_1, VAR_3.pixels);
	}

	if(VAR_4) {
		if(VAR_4->row_pointers) iw_free(VAR_1,VAR_4->row_pointers);
		iw_free(VAR_1,VAR_4);
	}

	return VAR_5;
}",,"--- func_before
+++ func_after
@@ -32,6 +32,9 @@
 done:
 	if(!retval) {
 		iw_set_error(ctx,""Failed to read GIF file"");
+		// If we didn't call iw_set_input_image, 'img' still belongs to us,
+		// so free its contents.
+		iw_free(ctx, img.pixels);
 	}
 
 	if(rctx) {","{'deleted_lines': [], 'added_lines': [""\t\t// If we didn't call iw_set_input_image, 'img' still belongs to us,"", '\t\t// so free its contents.', '\t\tiw_free(ctx, img.pixels);']}",True,The iw_read_gif_file function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to consume an amount of available memory via a crafted file.,5.5,MEDIUM,1,valid,2017-04-18T14:53:10Z,1
CVE-2017-7895,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"nfsd: stricter decoding of write-like NFSv2/v3 ops

The NFSv2/v3 code does not systematically check whether we decode past
the end of the buffer.  This generally appears to be harmless, but there
are a few places where we do arithmetic on the pointers involved and
don't account for the possibility that a length could be negative.  Add
checks to catch these.

Reported-by: Tuomas Haanp <thaan@synopsys.com>
Reported-by: Ari Kauppi <ari@synopsys.com>
Reviewed-by: NeilBrown <neilb@suse.com>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>",13bf9fbff0e5e099e2b6f003a0ab8ae145436309,https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,fs/nfsd/nfs3xdr.c,nfs3svc_decode_symlinkargs,"int
nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,
struct nfsd3_symlinkargs *args)
{
unsigned int len, avail;
char *old, *new;
struct kvec *vec;
if (!(p = decode_fh(p, &args->ffh)) ||
!(p = decode_filename(p, &args->fname, &args->flen))
)
return 0;
p = decode_sattr3(p, &args->attrs);
len = ntohl(*p++);
if (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)
return 0;
args->tname = new = page_address(*(rqstp->rq_next_page++));
args->tlen = len;
old = (char*)p;
vec = &rqstp->rq_arg.head[0];
avail = vec->iov_len - (old - (char*)vec->iov_base);
while (len && avail && *old) {
*new++ = *old++;
len--;
avail--;
}
if (len && !avail && rqstp->rq_arg.page_len) {
avail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);
old = page_address(rqstp->rq_arg.pages[0]);
}
while (len && avail && *old) {
*new++ = *old++;
len--;
avail--;
}
*new = '\0';
if (len)
return 0;
return 1;
}","int
nfs3svc_decode_symlinkargs(struct svc_rqst *VAR_0, __be32 *VAR_1,
struct nfsd3_symlinkargs *VAR_2)
{
unsigned int VAR_3, VAR_4;
char *VAR_5, *VAR_6;
struct kvec *VAR_7;
if (!(VAR_1 = decode_fh(VAR_1, &VAR_2->ffh)) ||
!(VAR_1 = decode_filename(VAR_1, &VAR_2->fname, &VAR_2->flen))
)
return 0;
VAR_1 = decode_sattr3(VAR_1, &VAR_2->attrs);
VAR_3 = ntohl(*VAR_1++);
if (VAR_3 == 0 || VAR_3 > VAR_8 || VAR_3 >= VAR_9)
return 0;
VAR_2->tname = VAR_6 = page_address(*(VAR_0->rq_next_page++));
VAR_2->tlen = VAR_3;
VAR_5 = (char*)VAR_1;
VAR_7 = &VAR_0->rq_arg.head[0];
VAR_4 = VAR_7->iov_len - (VAR_5 - (char*)VAR_7->iov_base);
while (VAR_3 && VAR_4 && *VAR_5) {
*VAR_6++ = *VAR_5++;
VAR_3--;
VAR_4--;
}
if (VAR_3 && !VAR_4 && VAR_0->rq_arg.page_len) {
VAR_4 = min_t(unsigned int, VAR_0->rq_arg.page_len, VAR_9);
VAR_5 = page_address(VAR_0->rq_arg.pages[0]);
}
while (VAR_3 && VAR_4 && *VAR_5) {
*VAR_6++ = *VAR_5++;
VAR_3--;
VAR_4--;
}
*VAR_6 = '\0';
if (VAR_3)
return 0;
return 1;
}",torvalds/linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309/nfs3xdr.c/vul/before/1.json,"int
nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,
					struct nfsd3_symlinkargs *args)
{
	unsigned int len, avail;
	char *old, *new;
	struct kvec *vec;

	if (!(p = decode_fh(p, &args->ffh)) ||
	    !(p = decode_filename(p, &args->fname, &args->flen))
		)
		return 0;
	p = decode_sattr3(p, &args->attrs);

	/* now decode the pathname, which might be larger than the first page.
	 * As we have to check for nul's anyway, we copy it into a new page
	 * This page appears in the rq_res.pages list, but as pages_len is always
	 * 0, it won't get in the way
	 */
	len = ntohl(*p++);
	if (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)
		return 0;
	args->tname = new = page_address(*(rqstp->rq_next_page++));
	args->tlen = len;
	/* first copy and check from the first page */
	old = (char*)p;
	vec = &rqstp->rq_arg.head[0];
	if ((void *)old > vec->iov_base + vec->iov_len)
		return 0;
	avail = vec->iov_len - (old - (char*)vec->iov_base);
	while (len && avail && *old) {
		*new++ = *old++;
		len--;
		avail--;
	}
	/* now copy next page if there is one */
	if (len && !avail && rqstp->rq_arg.page_len) {
		avail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);
		old = page_address(rqstp->rq_arg.pages[0]);
	}
	while (len && avail && *old) {
		*new++ = *old++;
		len--;
		avail--;
	}
	*new = '\0';
	if (len)
		return 0;

	return 1;
}","int
nfs3svc_decode_symlinkargs(struct svc_rqst *VAR_0, __be32 *VAR_1,
					struct nfsd3_symlinkargs *VAR_2)
{
	unsigned int VAR_3, VAR_4;
	char *VAR_5, *VAR_6;
	struct kvec *VAR_7;

	if (!(VAR_1 = decode_fh(VAR_1, &VAR_2->ffh)) ||
	    !(VAR_1 = decode_filename(VAR_1, &VAR_2->fname, &VAR_2->flen))
		)
		return 0;
	VAR_1 = decode_sattr3(VAR_1, &VAR_2->attrs);

	/* COMMENT_0 */
                                                                    
                                                                          
                              
    
	VAR_3 = ntohl(*VAR_1++);
	if (VAR_3 == 0 || VAR_3 > VAR_8 || VAR_3 >= VAR_9)
		return 0;
	VAR_2->tname = VAR_6 = page_address(*(VAR_0->rq_next_page++));
	VAR_2->tlen = VAR_3;
	/* COMMENT_5 */
	VAR_5 = (char*)VAR_1;
	VAR_7 = &VAR_0->rq_arg.head[0];
	if ((void *)VAR_5 > VAR_7->iov_base + VAR_7->iov_len)
		return 0;
	VAR_4 = VAR_7->iov_len - (VAR_5 - (char*)VAR_7->iov_base);
	while (VAR_3 && VAR_4 && *VAR_5) {
		*VAR_6++ = *VAR_5++;
		VAR_3--;
		VAR_4--;
	}
	/* COMMENT_6 */
	if (VAR_3 && !VAR_4 && VAR_0->rq_arg.page_len) {
		VAR_4 = min_t(unsigned int, VAR_0->rq_arg.page_len, VAR_9);
		VAR_5 = page_address(VAR_0->rq_arg.pages[0]);
	}
	while (VAR_3 && VAR_4 && *VAR_5) {
		*VAR_6++ = *VAR_5++;
		VAR_3--;
		VAR_4--;
	}
	*VAR_6 = '\0';
	if (VAR_3)
		return 0;

	return 1;
}",torvalds/linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309/nfs3xdr.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -25,6 +25,8 @@
 	/* first copy and check from the first page */
 	old = (char*)p;
 	vec = &rqstp->rq_arg.head[0];
+	if ((void *)old > vec->iov_base + vec->iov_len)
+		return 0;
 	avail = vec->iov_len - (old - (char*)vec->iov_base);
 	while (len && avail && *old) {
 		*new++ = *old++;","{'deleted_lines': [], 'added_lines': ['\tif ((void *)old > vec->iov_base + vec->iov_len)', '\t\treturn 0;']}",True,"The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c.",9.8,CRITICAL,3,valid,2017-04-21T19:26:30Z,1
CVE-2017-7895,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"nfsd: stricter decoding of write-like NFSv2/v3 ops

The NFSv2/v3 code does not systematically check whether we decode past
the end of the buffer.  This generally appears to be harmless, but there
are a few places where we do arithmetic on the pointers involved and
don't account for the possibility that a length could be negative.  Add
checks to catch these.

Reported-by: Tuomas Haanp <thaan@synopsys.com>
Reported-by: Ari Kauppi <ari@synopsys.com>
Reviewed-by: NeilBrown <neilb@suse.com>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>",13bf9fbff0e5e099e2b6f003a0ab8ae145436309,https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,fs/nfsd/nfs3xdr.c,nfs3svc_decode_writeargs,"int
nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,
struct nfsd3_writeargs *args)
{
unsigned int len, v, hdr, dlen;
u32 max_blocksize = svc_max_payload(rqstp);
struct kvec *head = rqstp->rq_arg.head;
struct kvec *tail = rqstp->rq_arg.tail;
p = decode_fh(p, &args->fh);
if (!p)
return 0;
p = xdr_decode_hyper(p, &args->offset);
args->count = ntohl(*p++);
args->stable = ntohl(*p++);
len = args->len = ntohl(*p++);
if (args->count != args->len)
return 0;
hdr = (void*)p - head->iov_base;
dlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;
if (dlen < XDR_QUADLEN(len)*4)
return 0;
if (args->count > max_blocksize) {
args->count = max_blocksize;
len = args->len = max_blocksize;
}
rqstp->rq_vec[0].iov_base = (void*)p;
rqstp->rq_vec[0].iov_len = head->iov_len - hdr;
v = 0;
while (len > rqstp->rq_vec[v].iov_len) {
len -= rqstp->rq_vec[v].iov_len;
v++;
rqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);
rqstp->rq_vec[v].iov_len = PAGE_SIZE;
}
rqstp->rq_vec[v].iov_len = len;
args->vlen = v + 1;
return 1;
}","int
nfs3svc_decode_writeargs(struct svc_rqst *VAR_0, __be32 *VAR_1,
struct nfsd3_writeargs *VAR_2)
{
unsigned int VAR_3, VAR_4, VAR_5, VAR_6;
u32 VAR_7 = svc_max_payload(VAR_0);
struct kvec *VAR_8 = VAR_0->rq_arg.head;
struct kvec *VAR_9 = VAR_0->rq_arg.tail;
VAR_1 = decode_fh(VAR_1, &VAR_2->fh);
if (!VAR_1)
return 0;
VAR_1 = xdr_decode_hyper(VAR_1, &VAR_2->offset);
VAR_2->count = ntohl(*VAR_1++);
VAR_2->stable = ntohl(*VAR_1++);
VAR_3 = VAR_2->len = ntohl(*VAR_1++);
if (VAR_2->count != VAR_2->len)
return 0;
VAR_5 = (void*)VAR_1 - VAR_8->iov_base;
VAR_6 = VAR_8->iov_len + VAR_0->rq_arg.page_len + VAR_9->iov_len - VAR_5;
if (VAR_6 < XDR_QUADLEN(VAR_3)*4)
return 0;
if (VAR_2->count > VAR_7) {
VAR_2->count = VAR_7;
VAR_3 = VAR_2->len = VAR_7;
}
VAR_0->rq_vec[0].iov_base = (void*)VAR_1;
VAR_0->rq_vec[0].iov_len = VAR_8->iov_len - VAR_5;
VAR_4 = 0;
while (VAR_3 > VAR_0->rq_vec[VAR_4].iov_len) {
VAR_3 -= VAR_0->rq_vec[VAR_4].iov_len;
VAR_4++;
VAR_0->rq_vec[VAR_4].iov_base = page_address(VAR_0->rq_pages[VAR_4]);
VAR_0->rq_vec[VAR_4].iov_len = VAR_10;
}
VAR_0->rq_vec[VAR_4].iov_len = VAR_3;
VAR_2->vlen = VAR_4 + 1;
return 1;
}",torvalds/linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309/nfs3xdr.c/vul/before/0.json,"int
nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,
					struct nfsd3_writeargs *args)
{
	unsigned int len, v, hdr, dlen;
	u32 max_blocksize = svc_max_payload(rqstp);
	struct kvec *head = rqstp->rq_arg.head;
	struct kvec *tail = rqstp->rq_arg.tail;

	p = decode_fh(p, &args->fh);
	if (!p)
		return 0;
	p = xdr_decode_hyper(p, &args->offset);

	args->count = ntohl(*p++);
	args->stable = ntohl(*p++);
	len = args->len = ntohl(*p++);
	if ((void *)p > head->iov_base + head->iov_len)
		return 0;
	/*
	 * The count must equal the amount of data passed.
	 */
	if (args->count != args->len)
		return 0;

	/*
	 * Check to make sure that we got the right number of
	 * bytes.
	 */
	hdr = (void*)p - head->iov_base;
	dlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;
	/*
	 * Round the length of the data which was specified up to
	 * the next multiple of XDR units and then compare that
	 * against the length which was actually received.
	 * Note that when RPCSEC/GSS (for example) is used, the
	 * data buffer can be padded so dlen might be larger
	 * than required.  It must never be smaller.
	 */
	if (dlen < XDR_QUADLEN(len)*4)
		return 0;

	if (args->count > max_blocksize) {
		args->count = max_blocksize;
		len = args->len = max_blocksize;
	}
	rqstp->rq_vec[0].iov_base = (void*)p;
	rqstp->rq_vec[0].iov_len = head->iov_len - hdr;
	v = 0;
	while (len > rqstp->rq_vec[v].iov_len) {
		len -= rqstp->rq_vec[v].iov_len;
		v++;
		rqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);
		rqstp->rq_vec[v].iov_len = PAGE_SIZE;
	}
	rqstp->rq_vec[v].iov_len = len;
	args->vlen = v + 1;
	return 1;
}","int
nfs3svc_decode_writeargs(struct svc_rqst *VAR_0, __be32 *VAR_1,
					struct nfsd3_writeargs *VAR_2)
{
	unsigned int VAR_3, VAR_4, VAR_5, VAR_6;
	u32 VAR_7 = svc_max_payload(VAR_0);
	struct kvec *VAR_8 = VAR_0->rq_arg.head;
	struct kvec *VAR_9 = VAR_0->rq_arg.tail;

	VAR_1 = decode_fh(VAR_1, &VAR_2->fh);
	if (!VAR_1)
		return 0;
	VAR_1 = xdr_decode_hyper(VAR_1, &VAR_2->offset);

	VAR_2->count = ntohl(*VAR_1++);
	VAR_2->stable = ntohl(*VAR_1++);
	VAR_3 = VAR_2->len = ntohl(*VAR_1++);
	if ((void *)VAR_1 > VAR_8->iov_base + VAR_8->iov_len)
		return 0;
	/* COMMENT_0 */
                                                   
    
	if (VAR_2->count != VAR_2->len)
		return 0;

	/* COMMENT_3 */
                                                      
          
    
	VAR_5 = (void*)VAR_1 - VAR_8->iov_base;
	VAR_6 = VAR_8->iov_len + VAR_0->rq_arg.page_len + VAR_9->iov_len - VAR_5;
	/* COMMENT_7 */
                                                          
                                                        
                                                   
                                                        
                                                     
                                             
    
	if (VAR_6 < XDR_QUADLEN(VAR_3)*4)
		return 0;

	if (VAR_2->count > VAR_7) {
		VAR_2->count = VAR_7;
		VAR_3 = VAR_2->len = VAR_7;
	}
	VAR_0->rq_vec[0].iov_base = (void*)VAR_1;
	VAR_0->rq_vec[0].iov_len = VAR_8->iov_len - VAR_5;
	VAR_4 = 0;
	while (VAR_3 > VAR_0->rq_vec[VAR_4].iov_len) {
		VAR_3 -= VAR_0->rq_vec[VAR_4].iov_len;
		VAR_4++;
		VAR_0->rq_vec[VAR_4].iov_base = page_address(VAR_0->rq_pages[VAR_4]);
		VAR_0->rq_vec[VAR_4].iov_len = VAR_10;
	}
	VAR_0->rq_vec[VAR_4].iov_len = VAR_3;
	VAR_2->vlen = VAR_4 + 1;
	return 1;
}",torvalds/linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309/nfs3xdr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,6 +15,8 @@
 	args->count = ntohl(*p++);
 	args->stable = ntohl(*p++);
 	len = args->len = ntohl(*p++);
+	if ((void *)p > head->iov_base + head->iov_len)
+		return 0;
 	/*
 	 * The count must equal the amount of data passed.
 	 */","{'deleted_lines': [], 'added_lines': ['\tif ((void *)p > head->iov_base + head->iov_len)', '\t\treturn 0;']}",True,"The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c.",9.8,CRITICAL,3,valid,2017-04-21T19:26:30Z,1
CVE-2017-7895,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"nfsd: stricter decoding of write-like NFSv2/v3 ops

The NFSv2/v3 code does not systematically check whether we decode past
the end of the buffer.  This generally appears to be harmless, but there
are a few places where we do arithmetic on the pointers involved and
don't account for the possibility that a length could be negative.  Add
checks to catch these.

Reported-by: Tuomas Haanp <thaan@synopsys.com>
Reported-by: Ari Kauppi <ari@synopsys.com>
Reviewed-by: NeilBrown <neilb@suse.com>
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>",13bf9fbff0e5e099e2b6f003a0ab8ae145436309,https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309,fs/nfsd/nfsxdr.c,nfssvc_decode_writeargs,"int
nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,
struct nfsd_writeargs *args)
{
unsigned int len, hdr, dlen;
struct kvec *head = rqstp->rq_arg.head;
int v;
p = decode_fh(p, &args->fh);
if (!p)
return 0;
p++;
args->offset = ntohl(*p++);
p++;
len = args->len = ntohl(*p++);
if (len > NFSSVC_MAXBLKSIZE_V2)
return 0;
hdr = (void*)p - head->iov_base;
dlen = head->iov_len + rqstp->rq_arg.page_len - hdr;
if (dlen < XDR_QUADLEN(len)*4)
return 0;
rqstp->rq_vec[0].iov_base = (void*)p;
rqstp->rq_vec[0].iov_len = head->iov_len - hdr;
v = 0;
while (len > rqstp->rq_vec[v].iov_len) {
len -= rqstp->rq_vec[v].iov_len;
v++;
rqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);
rqstp->rq_vec[v].iov_len = PAGE_SIZE;
}
rqstp->rq_vec[v].iov_len = len;
args->vlen = v + 1;
return 1;
}","int
nfssvc_decode_writeargs(struct svc_rqst *VAR_0, __be32 *VAR_1,
struct nfsd_writeargs *VAR_2)
{
unsigned int VAR_3, VAR_4, VAR_5;
struct kvec *VAR_6 = VAR_0->rq_arg.head;
int VAR_7;
VAR_1 = decode_fh(VAR_1, &VAR_2->fh);
if (!VAR_1)
return 0;
VAR_1++;
VAR_2->offset = ntohl(*VAR_1++);
VAR_1++;
VAR_3 = VAR_2->len = ntohl(*VAR_1++);
if (VAR_3 > VAR_8)
return 0;
VAR_4 = (void*)VAR_1 - VAR_6->iov_base;
VAR_5 = VAR_6->iov_len + VAR_0->rq_arg.page_len - VAR_4;
if (VAR_5 < XDR_QUADLEN(VAR_3)*4)
return 0;
VAR_0->rq_vec[0].iov_base = (void*)VAR_1;
VAR_0->rq_vec[0].iov_len = VAR_6->iov_len - VAR_4;
VAR_7 = 0;
while (VAR_3 > VAR_0->rq_vec[VAR_7].iov_len) {
VAR_3 -= VAR_0->rq_vec[VAR_7].iov_len;
VAR_7++;
VAR_0->rq_vec[VAR_7].iov_base = page_address(VAR_0->rq_pages[VAR_7]);
VAR_0->rq_vec[VAR_7].iov_len = VAR_9;
}
VAR_0->rq_vec[VAR_7].iov_len = VAR_3;
VAR_2->vlen = VAR_7 + 1;
return 1;
}",torvalds/linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309/nfsxdr.c/vul/before/0.json,"int
nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,
					struct nfsd_writeargs *args)
{
	unsigned int len, hdr, dlen;
	struct kvec *head = rqstp->rq_arg.head;
	int v;

	p = decode_fh(p, &args->fh);
	if (!p)
		return 0;

	p++;				/* beginoffset */
	args->offset = ntohl(*p++);	/* offset */
	p++;				/* totalcount */
	len = args->len = ntohl(*p++);
	/*
	 * The protocol specifies a maximum of 8192 bytes.
	 */
	if (len > NFSSVC_MAXBLKSIZE_V2)
		return 0;

	/*
	 * Check to make sure that we got the right number of
	 * bytes.
	 */
	hdr = (void*)p - head->iov_base;
	if (hdr > head->iov_len)
		return 0;
	dlen = head->iov_len + rqstp->rq_arg.page_len - hdr;

	/*
	 * Round the length of the data which was specified up to
	 * the next multiple of XDR units and then compare that
	 * against the length which was actually received.
	 * Note that when RPCSEC/GSS (for example) is used, the
	 * data buffer can be padded so dlen might be larger
	 * than required.  It must never be smaller.
	 */
	if (dlen < XDR_QUADLEN(len)*4)
		return 0;

	rqstp->rq_vec[0].iov_base = (void*)p;
	rqstp->rq_vec[0].iov_len = head->iov_len - hdr;
	v = 0;
	while (len > rqstp->rq_vec[v].iov_len) {
		len -= rqstp->rq_vec[v].iov_len;
		v++;
		rqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);
		rqstp->rq_vec[v].iov_len = PAGE_SIZE;
	}
	rqstp->rq_vec[v].iov_len = len;
	args->vlen = v + 1;
	return 1;
}","int
nfssvc_decode_writeargs(struct svc_rqst *VAR_0, __be32 *VAR_1,
					struct nfsd_writeargs *VAR_2)
{
	unsigned int VAR_3, VAR_4, VAR_5;
	struct kvec *VAR_6 = VAR_0->rq_arg.head;
	int VAR_7;

	VAR_1 = decode_fh(VAR_1, &VAR_2->fh);
	if (!VAR_1)
		return 0;

	VAR_1++;				/* COMMENT_0 */
	VAR_2->offset = ntohl(*VAR_1++);	/* COMMENT_1 */
	VAR_1++;				/* COMMENT_2 */
	VAR_3 = VAR_2->len = ntohl(*VAR_1++);
	/* COMMENT_3 */
                                                   
    
	if (VAR_3 > VAR_8)
		return 0;

	/* COMMENT_6 */
                                                      
          
    
	VAR_4 = (void*)VAR_1 - VAR_6->iov_base;
	if (VAR_4 > VAR_6->iov_len)
		return 0;
	VAR_5 = VAR_6->iov_len + VAR_0->rq_arg.page_len - VAR_4;

	/* COMMENT_10 */
                                                          
                                                        
                                                   
                                                        
                                                     
                                             
    
	if (VAR_5 < XDR_QUADLEN(VAR_3)*4)
		return 0;

	VAR_0->rq_vec[0].iov_base = (void*)VAR_1;
	VAR_0->rq_vec[0].iov_len = VAR_6->iov_len - VAR_4;
	VAR_7 = 0;
	while (VAR_3 > VAR_0->rq_vec[VAR_7].iov_len) {
		VAR_3 -= VAR_0->rq_vec[VAR_7].iov_len;
		VAR_7++;
		VAR_0->rq_vec[VAR_7].iov_base = page_address(VAR_0->rq_pages[VAR_7]);
		VAR_0->rq_vec[VAR_7].iov_len = VAR_9;
	}
	VAR_0->rq_vec[VAR_7].iov_len = VAR_3;
	VAR_2->vlen = VAR_7 + 1;
	return 1;
}",torvalds/linux/13bf9fbff0e5e099e2b6f003a0ab8ae145436309/nfsxdr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,6 +25,8 @@
 	 * bytes.
 	 */
 	hdr = (void*)p - head->iov_base;
+	if (hdr > head->iov_len)
+		return 0;
 	dlen = head->iov_len + rqstp->rq_arg.page_len - hdr;
 
 	/*","{'deleted_lines': [], 'added_lines': ['\tif (hdr > head->iov_len)', '\t\treturn 0;']}",True,"The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c.",9.8,CRITICAL,3,valid,2017-04-21T19:26:30Z,1
CVE-2017-8073,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,weechat,irc: fix parsing of DCC filename,2fb346f25f79e412cf0ed314fdf791763c19b70b,https://github.com/weechat/weechat/commit/2fb346f25f79e412cf0ed314fdf791763c19b70b,src/plugins/irc/irc-ctcp.c,irc_ctcp_dcc_filename_without_quotes,"char *
irc_ctcp_dcc_filename_without_quotes (const char *filename)
{
int length;
length = strlen (filename);
if (length > 0)
{
if ((filename[0] == '\""') && (filename[length - 1] == '\""'))
return weechat_strndup (filename + 1, length - 2);
}
return strdup (filename);
}","char *
irc_ctcp_dcc_filename_without_quotes (const char *VAR_0)
{
int VAR_1;
VAR_1 = strlen (VAR_0);
if (VAR_1 > 0)
{
if ((VAR_0[0] == '\""') && (VAR_0[VAR_1 - 1] == '\""'))
return weechat_strndup (VAR_0 + 1, VAR_1 - 2);
}
return strdup (VAR_0);
}",weechat/2fb346f25f79e412cf0ed314fdf791763c19b70b/irc-ctcp.c/vul/before/0.json,"char *
irc_ctcp_dcc_filename_without_quotes (const char *filename)
{
    int length;

    length = strlen (filename);
    if (length > 1)
    {
        if ((filename[0] == '\""') && (filename[length - 1] == '\""'))
            return weechat_strndup (filename + 1, length - 2);
    }
    return strdup (filename);
}","char *
irc_ctcp_dcc_filename_without_quotes (const char *VAR_0)
{
    int VAR_1;

    VAR_1 = strlen (VAR_0);
    if (VAR_1 > 1)
    {
        if ((VAR_0[0] == '\""') && (VAR_0[VAR_1 - 1] == '\""'))
            return weechat_strndup (VAR_0 + 1, VAR_1 - 2);
    }
    return strdup (VAR_0);
}",weechat/2fb346f25f79e412cf0ed314fdf791763c19b70b/irc-ctcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
     int length;
 
     length = strlen (filename);
-    if (length > 0)
+    if (length > 1)
     {
         if ((filename[0] == '\""') && (filename[length - 1] == '\""'))
             return weechat_strndup (filename + 1, length - 2);","{'deleted_lines': ['    if (length > 0)'], 'added_lines': ['    if (length > 1)']}",True,"WeeChat before 1.7.1 allows a remote crash by sending a filename via DCC to the IRC plugin. This occurs in the irc_ctcp_dcc_filename_without_quotes function during quote removal, with a buffer overflow.",7.5,HIGH,2,valid,2017-04-22T13:10:53Z,1
CVE-2017-11472,['CWE-755'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,torvalds/linux,"ACPICA: Namespace: fix operand cache leak

ACPICA commit a23325b2e583556eae88ed3f764e457786bf4df6

I found some ACPI operand cache leaks in ACPI early abort cases.

Boot log of ACPI operand cache leak is as follows:
>[    0.174332] ACPI: Added _OSI(Module Device)
>[    0.175504] ACPI: Added _OSI(Processor Device)
>[    0.176010] ACPI: Added _OSI(3.0 _SCP Extensions)
>[    0.177032] ACPI: Added _OSI(Processor Aggregator Device)
>[    0.178284] ACPI: SCI (IRQ16705) allocation failed
>[    0.179352] ACPI Exception: AE_NOT_ACQUIRED, Unable to install
System Control Interrupt handler (20160930/evevent-131)
>[    0.180008] ACPI: Unable to start the ACPI Interpreter
>[    0.181125] ACPI Error: Could not remove SCI handler
(20160930/evmisc-281)
>[    0.184068] kmem_cache_destroy Acpi-Operand: Slab cache still has
objects
>[    0.185358] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.10.0-rc3 #2
>[    0.186820] Hardware name: innotek gmb_h virtual_box/virtual_box, BIOS
virtual_box 12/01/2006
>[    0.188000] Call Trace:
>[    0.188000]  ? dump_stack+0x5c/0x7d
>[    0.188000]  ? kmem_cache_destroy+0x224/0x230
>[    0.188000]  ? acpi_sleep_proc_init+0x22/0x22
>[    0.188000]  ? acpi_os_delete_cache+0xa/0xd
>[    0.188000]  ? acpi_ut_delete_caches+0x3f/0x7b
>[    0.188000]  ? acpi_terminate+0x5/0xf
>[    0.188000]  ? acpi_init+0x288/0x32e
>[    0.188000]  ? __class_create+0x4c/0x80
>[    0.188000]  ? video_setup+0x7a/0x7a
>[    0.188000]  ? do_one_initcall+0x4e/0x1b0
>[    0.188000]  ? kernel_init_freeable+0x194/0x21a
>[    0.188000]  ? rest_init+0x80/0x80
>[    0.188000]  ? kernel_init+0xa/0x100
>[    0.188000]  ? ret_from_fork+0x25/0x30

When early abort is occurred due to invalid ACPI information, Linux kernel
terminates ACPI by calling acpi_terminate() function. The function calls
acpi_ns_terminate() function to delete namespace data and ACPI operand cache
(acpi_gbl_module_code_list).

But the deletion code in acpi_ns_terminate() function is wrapped in
ACPI_EXEC_APP definition, therefore the code is only executed when the
definition exists. If the define doesn't exist, ACPI operand cache
(acpi_gbl_module_code_list) is leaked, and stack dump is shown in kernel log.

This causes a security threat because the old kernel (<= 4.9) shows memory
locations of kernel functions in stack dump, therefore kernel ASLR can be
neutralized.

To fix ACPI operand leak for enhancing security, I made a patch which
removes the ACPI_EXEC_APP define in acpi_ns_terminate() function for
executing the deletion code unconditionally.

Link: https://github.com/acpica/acpica/commit/a23325b2
Signed-off-by: Seunghun Han <kkamagui@gmail.com>
Signed-off-by: Lv Zheng <lv.zheng@intel.com>
Signed-off-by: Bob Moore <robert.moore@intel.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>",3b2d69114fefa474fca542e51119036dceb4aa6f,https://github.com/torvalds/linux/commit/3b2d69114fefa474fca542e51119036dceb4aa6f,drivers/acpi/acpica/nsutils.c,acpi_ns_terminate,"void acpi_ns_terminate(void)
{
acpi_status status;
ACPI_FUNCTION_TRACE(ns_terminate);
#ifdef ACPI_EXEC_APP
{
union acpi_operand_object *prev;
union acpi_operand_object *next;
next = acpi_gbl_module_code_list;
while (next) {
prev = next;
next = next->method.mutex;
prev->method.mutex = NULL;
acpi_ut_remove_reference(prev);
}
}
#endif
acpi_ns_delete_namespace_subtree(acpi_gbl_root_node);
status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
if (ACPI_FAILURE(status)) {
return_VOID;
}
acpi_ns_delete_node(acpi_gbl_root_node);
(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
ACPI_DEBUG_PRINT((ACPI_DB_INFO, ""Namespace freed\n""));
return_VOID;
}","void acpi_ns_terminate(void)
{
acpi_status VAR_0;
ACPI_FUNCTION_TRACE(VAR_1);
#ifdef VAR_2
{
union acpi_operand_object *VAR_3;
union acpi_operand_object *VAR_4;
VAR_4 = VAR_5;
while (VAR_4) {
VAR_3 = VAR_4;
VAR_4 = VAR_4->method.mutex;
VAR_3->method.mutex = NULL;
acpi_ut_remove_reference(VAR_3);
}
}
#endif
acpi_ns_delete_namespace_subtree(VAR_6);
VAR_0 = acpi_ut_acquire_mutex(VAR_7);
if (ACPI_FAILURE(VAR_0)) {
VAR_8;
}
acpi_ns_delete_node(VAR_6);
(void)acpi_ut_release_mutex(VAR_7);
ACPI_DEBUG_PRINT((VAR_9, ""Namespace freed\n""));
VAR_8;
}",torvalds/linux/3b2d69114fefa474fca542e51119036dceb4aa6f/nsutils.c/vul/before/0.json,"void acpi_ns_terminate(void)
{
	acpi_status status;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;

	ACPI_FUNCTION_TRACE(ns_terminate);

	/* Delete any module-level code blocks */

	next = acpi_gbl_module_code_list;
	while (next) {
		prev = next;
		next = next->method.mutex;
		prev->method.mutex = NULL;	/* Clear the Mutex (cheated) field */
		acpi_ut_remove_reference(prev);
	}

	/*
	 * Free the entire namespace -- all nodes and all objects
	 * attached to the nodes
	 */
	acpi_ns_delete_namespace_subtree(acpi_gbl_root_node);

	/* Delete any objects attached to the root node */

	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
	if (ACPI_FAILURE(status)) {
		return_VOID;
	}

	acpi_ns_delete_node(acpi_gbl_root_node);
	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);

	ACPI_DEBUG_PRINT((ACPI_DB_INFO, ""Namespace freed\n""));
	return_VOID;
}","void acpi_ns_terminate(void)
{
	acpi_status VAR_0;
	union acpi_operand_object *VAR_1;
	union acpi_operand_object *VAR_2;

	ACPI_FUNCTION_TRACE(VAR_3);

	/* COMMENT_0 */

	VAR_2 = VAR_4;
	while (VAR_2) {
		VAR_1 = VAR_2;
		VAR_2 = VAR_2->method.mutex;
		VAR_1->method.mutex = NULL;	/* COMMENT_1 */
		acpi_ut_remove_reference(VAR_1);
	}

	/* COMMENT_2 */
                                                          
                         
    
	acpi_ns_delete_namespace_subtree(VAR_5);

	/* COMMENT_6 */

	VAR_0 = acpi_ut_acquire_mutex(VAR_6);
	if (ACPI_FAILURE(VAR_0)) {
		VAR_7;
	}

	acpi_ns_delete_node(VAR_5);
	(void)acpi_ut_release_mutex(VAR_6);

	ACPI_DEBUG_PRINT((VAR_8, ""Namespace freed\n""));
	VAR_7;
}",torvalds/linux/3b2d69114fefa474fca542e51119036dceb4aa6f/nsutils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,25 +1,20 @@
 void acpi_ns_terminate(void)
 {
 	acpi_status status;
+	union acpi_operand_object *prev;
+	union acpi_operand_object *next;
 
 	ACPI_FUNCTION_TRACE(ns_terminate);
 
-#ifdef ACPI_EXEC_APP
-	{
-		union acpi_operand_object *prev;
-		union acpi_operand_object *next;
+	/* Delete any module-level code blocks */
 
-		/* Delete any module-level code blocks */
-
-		next = acpi_gbl_module_code_list;
-		while (next) {
-			prev = next;
-			next = next->method.mutex;
-			prev->method.mutex = NULL;	/* Clear the Mutex (cheated) field */
-			acpi_ut_remove_reference(prev);
-		}
+	next = acpi_gbl_module_code_list;
+	while (next) {
+		prev = next;
+		next = next->method.mutex;
+		prev->method.mutex = NULL;	/* Clear the Mutex (cheated) field */
+		acpi_ut_remove_reference(prev);
 	}
-#endif
 
 	/*
 	 * Free the entire namespace -- all nodes and all objects","{'deleted_lines': ['#ifdef ACPI_EXEC_APP', '\t{', '\t\tunion acpi_operand_object *prev;', '\t\tunion acpi_operand_object *next;', '\t\t/* Delete any module-level code blocks */', '', '\t\tnext = acpi_gbl_module_code_list;', '\t\twhile (next) {', '\t\t\tprev = next;', '\t\t\tnext = next->method.mutex;', '\t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */', '\t\t\tacpi_ut_remove_reference(prev);', '\t\t}', '#endif'], 'added_lines': ['\tunion acpi_operand_object *prev;', '\tunion acpi_operand_object *next;', '\t/* Delete any module-level code blocks */', '\tnext = acpi_gbl_module_code_list;', '\twhile (next) {', '\t\tprev = next;', '\t\tnext = next->method.mutex;', '\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */', '\t\tacpi_ut_remove_reference(prev);']}",True,"The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.",7.1,HIGH,2,valid,2017-04-26T08:18:08Z,1
CVE-2017-8344,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/446,4c6289b2f39a47a430ce27b61d3e3967201e77e8,https://github.com/ImageMagick/ImageMagick/commit/4c6289b2f39a47a430ce27b61d3e3967201e77e8,coders/pcx.c,ReadPCXImage,"static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define ThrowPCXException(severity,tag) \
{ \
scanline=(unsigned char *) RelinquishMagickMemory(scanline); \
pixel_info=RelinquishVirtualMemory(pixel_info); \
ThrowReaderException(severity,tag); \
}
Image
*image;
int
bits,
id,
mask;
MagickBooleanType
status;
MagickOffsetType
offset,
*page_table;
MemoryInfo
*pixel_info;
PCXInfo
pcx_info;
register IndexPacket
*indexes;
register ssize_t
x;
register PixelPacket
*q;
register ssize_t
i;
register unsigned char
*p,
*r;
size_t
one,
pcx_packets;
ssize_t
count,
y;
unsigned char
packet,
pcx_colormap[768],
*pixels,
*scanline;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
page_table=(MagickOffsetType *) NULL;
if (LocaleCompare(image_info->magick,""DCX"") == 0)
{
size_t
magic;
magic=ReadBlobLSBLong(image);
if (magic != 987654321)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
sizeof(*page_table));
if (page_table == (MagickOffsetType *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
for (id=0; id < 1024; id++)
{
page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);
if (page_table[id] == 0)
break;
}
}
if (page_table != (MagickOffsetType *) NULL)
{
offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);
if (offset < 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
count=ReadBlob(image,1,&pcx_info.identifier);
for (id=1; id < 1024; id++)
{
int
bits_per_pixel;
pcx_info.version=(unsigned char) ReadBlobByte(image);
if ((count != 1) || (pcx_info.identifier != 0x0a))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pcx_info.encoding=(unsigned char) ReadBlobByte(image);
bits_per_pixel=ReadBlobByte(image);
if (bits_per_pixel == -1)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;
pcx_info.left=ReadBlobLSBShort(image);
pcx_info.top=ReadBlobLSBShort(image);
pcx_info.right=ReadBlobLSBShort(image);
pcx_info.bottom=ReadBlobLSBShort(image);
pcx_info.horizontal_resolution=ReadBlobLSBShort(image);
pcx_info.vertical_resolution=ReadBlobLSBShort(image);
image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-
pcx_info.left)+1UL;
image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-
pcx_info.top)+1UL;
if ((image->columns == 0) || (image->rows == 0) ||
((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&
(pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
image->depth=pcx_info.bits_per_pixel;
image->units=PixelsPerInchResolution;
image->x_resolution=(double) pcx_info.horizontal_resolution;
image->y_resolution=(double) pcx_info.vertical_resolution;
image->colors=16;
count=ReadBlob(image,3*image->colors,pcx_colormap);
if (count != (ssize_t) (3*image->colors))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pcx_info.reserved=(unsigned char) ReadBlobByte(image);
pcx_info.planes=(unsigned char) ReadBlobByte(image);
if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (pcx_info.planes == 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
one=1;
if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))
if ((pcx_info.version == 3) || (pcx_info.version == 5) ||
((pcx_info.bits_per_pixel*pcx_info.planes) == 1))
image->colors=(size_t) MagickMin(one << (1UL*
(pcx_info.bits_per_pixel*pcx_info.planes)),256UL);
if (AcquireImageColormap(image,image->colors) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))
image->storage_class=DirectClass;
p=pcx_colormap;
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].red=ScaleCharToQuantum(*p++);
image->colormap[i].green=ScaleCharToQuantum(*p++);
image->colormap[i].blue=ScaleCharToQuantum(*p++);
}
pcx_info.bytes_per_line=ReadBlobLSBShort(image);
pcx_info.palette_info=ReadBlobLSBShort(image);
pcx_info.horizontal_screensize=ReadBlobLSBShort(image);
pcx_info.vertical_screensize=ReadBlobLSBShort(image);
for (i=0; i < 54; i++)
(void) ReadBlobByte(image);
if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;
if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pcx_packets=(size_t) pcx_packets*pcx_info.planes;
if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >
(pcx_packets*8U))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,
pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));
pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));
if ((scanline == (unsigned char *) NULL) ||
(pixel_info == (MemoryInfo *) NULL))
{
if (scanline != (unsigned char *) NULL)
scanline=(unsigned char *) RelinquishMagickMemory(scanline);
if (pixel_info != (MemoryInfo *) NULL)
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
p=pixels;
if (pcx_info.encoding == 0)
while (pcx_packets != 0)
{
packet=(unsigned char) ReadBlobByte(image);
if (EOFBlob(image) != MagickFalse)
ThrowPCXException(CorruptImageError,""UnexpectedEndOfFile"");
*p++=packet;
pcx_packets--;
}
else
while (pcx_packets != 0)
{
packet=(unsigned char) ReadBlobByte(image);
if (EOFBlob(image) != MagickFalse)
ThrowPCXException(CorruptImageError,""UnexpectedEndOfFile"");
if ((packet & 0xc0) != 0xc0)
{
*p++=packet;
pcx_packets--;
continue;
}
count=(ssize_t) (packet & 0x3f);
packet=(unsigned char) ReadBlobByte(image);
if (EOFBlob(image) != MagickFalse)
ThrowPCXException(CorruptImageError,""UnexpectedEndOfFile"");
for ( ; count != 0; count--)
{
*p++=packet;
pcx_packets--;
if (pcx_packets == 0)
break;
}
}
if (image->storage_class == DirectClass)
image->matte=pcx_info.planes > 3 ? MagickTrue : MagickFalse;
else
if ((pcx_info.version == 5) ||
((pcx_info.bits_per_pixel*pcx_info.planes) == 1))
{
if (image->colors > 256)
ThrowPCXException(CorruptImageError,""ColormapExceeds256Colors"");
if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)
{
image->colormap[0].red=(Quantum) 0;
image->colormap[0].green=(Quantum) 0;
image->colormap[0].blue=(Quantum) 0;
image->colormap[1].red=QuantumRange;
image->colormap[1].green=QuantumRange;
image->colormap[1].blue=QuantumRange;
}
else
if (image->colors > 16)
{
pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);
count=ReadBlob(image,3*image->colors,pcx_colormap);
p=pcx_colormap;
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].red=ScaleCharToQuantum(*p++);
image->colormap[i].green=ScaleCharToQuantum(*p++);
image->colormap[i].blue=ScaleCharToQuantum(*p++);
}
}
}
for (y=0; y < (ssize_t) image->rows; y++)
{
p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
r=scanline;
if (image->storage_class == DirectClass)
for (i=0; i < pcx_info.planes; i++)
{
r=scanline+i;
for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
{
switch (i)
{
case 0:
{
*r=(*p++);
break;
}
case 1:
{
*r=(*p++);
break;
}
case 2:
{
*r=(*p++);
break;
}
case 3:
default:
{
*r=(*p++);
break;
}
}
r+=pcx_info.planes;
}
}
else
if (pcx_info.planes > 1)
{
for (x=0; x < (ssize_t) image->columns; x++)
*r++=0;
for (i=0; i < pcx_info.planes; i++)
{
r=scanline;
for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
{
bits=(*p++);
for (mask=0x80; mask != 0; mask>>=1)
{
if (bits & mask)
*r|=1 << i;
r++;
}
}
}
}
else
switch (pcx_info.bits_per_pixel)
{
case 1:
{
register ssize_t
bit;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=7; bit >= 0; bit--)
*r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)
*r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);
p++;
}
break;
}
case 2:
{
for (x=0; x < ((ssize_t) image->columns-3); x+=4)
{
*r++=(*p >> 6) & 0x3;
*r++=(*p >> 4) & 0x3;
*r++=(*p >> 2) & 0x3;
*r++=(*p) & 0x3;
p++;
}
if ((image->columns % 4) != 0)
{
for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)
*r++=(unsigned char) ((*p >> (i*2)) & 0x03);
p++;
}
break;
}
case 4:
{
for (x=0; x < ((ssize_t) image->columns-1); x+=2)
{
*r++=(*p >> 4) & 0xf;
*r++=(*p) & 0xf;
p++;
}
if ((image->columns % 2) != 0)
*r++=(*p++ >> 4) & 0xf;
break;
}
case 8:
{
(void) CopyMagickMemory(r,p,image->columns);
break;
}
default:
break;
}
r=scanline;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (image->storage_class == PseudoClass)
SetPixelIndex(indexes+x,*r++);
else
{
SetPixelRed(q,ScaleCharToQuantum(*r++));
SetPixelGreen(q,ScaleCharToQuantum(*r++));
SetPixelBlue(q,ScaleCharToQuantum(*r++));
if (image->matte != MagickFalse)
SetPixelAlpha(q,ScaleCharToQuantum(*r++));
}
q++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
if (image->storage_class == PseudoClass)
(void) SyncImage(image);
scanline=(unsigned char *) RelinquishMagickMemory(scanline);
pixel_info=RelinquishVirtualMemory(pixel_info);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
if (page_table == (MagickOffsetType *) NULL)
break;
if (page_table[id] == 0)
break;
offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);
if (offset < 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
count=ReadBlob(image,1,&pcx_info.identifier);
if ((count != 0) && (pcx_info.identifier == 0x0a))
{
AcquireNextImage(image_info,image);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
}
if (page_table != (MagickOffsetType *) NULL)
page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadPCXImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define ThrowPCXException(VAR_2,VAR_3) \
{ \
scanline=(unsigned char *) RelinquishMagickMemory(scanline); \
pixel_info=RelinquishVirtualMemory(pixel_info); \
ThrowReaderException(severity,tag); \
}
Image
*VAR_4;
int
VAR_5,
VAR_6,
VAR_7;
MagickBooleanType
VAR_8;
MagickOffsetType
VAR_9,
*VAR_10;
MemoryInfo
*VAR_11;
PCXInfo
VAR_12;
register IndexPacket
*VAR_13;
register ssize_t
VAR_14;
register PixelPacket
*VAR_15;
register ssize_t
VAR_16;
register unsigned char
*VAR_17,
*VAR_18;
size_t
VAR_19,
VAR_20;
ssize_t
VAR_21,
VAR_22;
unsigned char
VAR_23,
VAR_24[768],
*VAR_25,
*VAR_26;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_27);
if (VAR_0->debug != VAR_28)
(void) LogMagickEvent(VAR_29,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_27);
VAR_4=AcquireImage(VAR_0);
VAR_8=OpenBlob(VAR_0,VAR_4,VAR_30,VAR_1);
if (VAR_8 == VAR_28)
{
VAR_4=DestroyImageList(VAR_4);
return((Image *) NULL);
}
VAR_10=(MagickOffsetType *) NULL;
if (LocaleCompare(VAR_0->magick,""DCX"") == 0)
{
size_t
VAR_31;
VAR_31=ReadBlobLSBLong(VAR_4);
if (VAR_31 != 987654321)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_10=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
sizeof(*VAR_10));
if (VAR_10 == (MagickOffsetType *) NULL)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
for (VAR_6=0; VAR_6 < 1024; VAR_6++)
{
VAR_10[VAR_6]=(MagickOffsetType) ReadBlobLSBLong(VAR_4);
if (VAR_10[VAR_6] == 0)
break;
}
}
if (VAR_10 != (MagickOffsetType *) NULL)
{
VAR_9=SeekBlob(VAR_4,(MagickOffsetType) VAR_10[0],VAR_34);
if (VAR_9 < 0)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
}
VAR_21=ReadBlob(VAR_4,1,&VAR_12.identifier);
for (VAR_6=1; VAR_6 < 1024; VAR_6++)
{
int
VAR_35;
VAR_12.version=(unsigned char) ReadBlobByte(VAR_4);
if ((VAR_21 != 1) || (VAR_12.identifier != 0x0a))
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_12.encoding=(unsigned char) ReadBlobByte(VAR_4);
VAR_35=ReadBlobByte(VAR_4);
if (VAR_35 == -1)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_12.bits_per_pixel=(unsigned char) VAR_35;
VAR_12.left=ReadBlobLSBShort(VAR_4);
VAR_12.top=ReadBlobLSBShort(VAR_4);
VAR_12.right=ReadBlobLSBShort(VAR_4);
VAR_12.bottom=ReadBlobLSBShort(VAR_4);
VAR_12.horizontal_resolution=ReadBlobLSBShort(VAR_4);
VAR_12.vertical_resolution=ReadBlobLSBShort(VAR_4);
VAR_4->columns=(size_t) MagickAbsoluteValue((ssize_t) VAR_12.right-
VAR_12.left)+1UL;
VAR_4->rows=(size_t) MagickAbsoluteValue((ssize_t) VAR_12.bottom-
VAR_12.top)+1UL;
if ((VAR_4->columns == 0) || (VAR_4->rows == 0) ||
((VAR_12.bits_per_pixel != 1) && (VAR_12.bits_per_pixel != 2) &&
(VAR_12.bits_per_pixel != 4) && (VAR_12.bits_per_pixel != 8)))
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_4->depth=VAR_12.bits_per_pixel;
VAR_4->units=VAR_36;
VAR_4->x_resolution=(double) VAR_12.horizontal_resolution;
VAR_4->y_resolution=(double) VAR_12.vertical_resolution;
VAR_4->colors=16;
VAR_21=ReadBlob(VAR_4,3*VAR_4->colors,VAR_24);
if (VAR_21 != (ssize_t) (3*VAR_4->colors))
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_12.reserved=(unsigned char) ReadBlobByte(VAR_4);
VAR_12.planes=(unsigned char) ReadBlobByte(VAR_4);
if ((VAR_12.bits_per_pixel*VAR_12.planes) >= 64)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
if (VAR_12.planes == 0)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_19=1;
if ((VAR_12.bits_per_pixel != 8) || (VAR_12.planes == 1))
if ((VAR_12.version == 3) || (VAR_12.version == 5) ||
((VAR_12.bits_per_pixel*VAR_12.planes) == 1))
VAR_4->colors=(size_t) MagickMin(VAR_19 << (1UL*
(VAR_12.bits_per_pixel*VAR_12.planes)),256UL);
if (AcquireImageColormap(VAR_4,VAR_4->colors) == VAR_28)
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
if ((VAR_12.bits_per_pixel >= 8) && (VAR_12.planes != 1))
VAR_4->storage_class=VAR_37;
VAR_17=VAR_24;
for (VAR_16=0; VAR_16 < (ssize_t) VAR_4->colors; VAR_16++)
{
VAR_4->colormap[VAR_16].red=ScaleCharToQuantum(*VAR_17++);
VAR_4->colormap[VAR_16].green=ScaleCharToQuantum(*VAR_17++);
VAR_4->colormap[VAR_16].blue=ScaleCharToQuantum(*VAR_17++);
}
VAR_12.bytes_per_line=ReadBlobLSBShort(VAR_4);
VAR_12.palette_info=ReadBlobLSBShort(VAR_4);
VAR_12.horizontal_screensize=ReadBlobLSBShort(VAR_4);
VAR_12.vertical_screensize=ReadBlobLSBShort(VAR_4);
for (VAR_16=0; VAR_16 < 54; VAR_16++)
(void) ReadBlobByte(VAR_4);
if ((VAR_0->ping != VAR_28) && (VAR_0->number_scenes != 0))
if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_8=SetImageExtent(VAR_4,VAR_4->columns,VAR_4->rows);
if (VAR_8 == VAR_28)
{
InheritException(VAR_1,&VAR_4->exception);
return(DestroyImageList(VAR_4));
}
if (HeapOverflowSanityCheck(VAR_4->rows, (size_t) VAR_12.bytes_per_line) != VAR_28)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_20=(size_t) VAR_4->rows*VAR_12.bytes_per_line;
if (HeapOverflowSanityCheck(VAR_20, (size_t) VAR_12.planes) != VAR_28)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_20=(size_t) VAR_20*VAR_12.planes;
if ((size_t) (VAR_12.bits_per_pixel*VAR_12.planes*VAR_4->columns) >
(VAR_20*8U))
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_26=(unsigned char *) AcquireQuantumMemory(MagickMax(VAR_4->columns,
VAR_12.bytes_per_line),MagickMax(8,VAR_12.planes)*sizeof(*VAR_26));
VAR_11=AcquireVirtualMemory(VAR_20,2*sizeof(*VAR_25));
if ((VAR_26 == (unsigned char *) NULL) ||
(VAR_11 == (MemoryInfo *) NULL))
{
if (VAR_26 != (unsigned char *) NULL)
VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
if (VAR_11 != (MemoryInfo *) NULL)
VAR_11=RelinquishVirtualMemory(VAR_11);
ThrowReaderException(VAR_33,""MemoryAllocationFailed"");
}
VAR_25=(unsigned char *) GetVirtualMemoryBlob(VAR_11);
VAR_17=VAR_25;
if (VAR_12.encoding == 0)
while (VAR_20 != 0)
{
VAR_23=(unsigned char) ReadBlobByte(VAR_4);
if (EOFBlob(VAR_4) != VAR_28)
ThrowPCXException(VAR_32,""UnexpectedEndOfFile"");
*VAR_17++=VAR_23;
VAR_20--;
}
else
while (VAR_20 != 0)
{
VAR_23=(unsigned char) ReadBlobByte(VAR_4);
if (EOFBlob(VAR_4) != VAR_28)
ThrowPCXException(VAR_32,""UnexpectedEndOfFile"");
if ((VAR_23 & 0xc0) != 0xc0)
{
*VAR_17++=VAR_23;
VAR_20--;
continue;
}
VAR_21=(ssize_t) (VAR_23 & 0x3f);
VAR_23=(unsigned char) ReadBlobByte(VAR_4);
if (EOFBlob(VAR_4) != VAR_28)
ThrowPCXException(VAR_32,""UnexpectedEndOfFile"");
for ( ; VAR_21 != 0; VAR_21--)
{
*VAR_17++=VAR_23;
VAR_20--;
if (VAR_20 == 0)
break;
}
}
if (VAR_4->storage_class == VAR_37)
VAR_4->matte=VAR_12.planes > 3 ? VAR_38 : VAR_28;
else
if ((VAR_12.version == 5) ||
((VAR_12.bits_per_pixel*VAR_12.planes) == 1))
{
if (VAR_4->colors > 256)
ThrowPCXException(VAR_32,""ColormapExceeds256Colors"");
if ((VAR_12.bits_per_pixel*VAR_12.planes) == 1)
{
VAR_4->colormap[0].red=(Quantum) 0;
VAR_4->colormap[0].green=(Quantum) 0;
VAR_4->colormap[0].blue=(Quantum) 0;
VAR_4->colormap[1].red=VAR_39;
VAR_4->colormap[1].green=VAR_39;
VAR_4->colormap[1].blue=VAR_39;
}
else
if (VAR_4->colors > 16)
{
VAR_12.colormap_signature=(unsigned char) ReadBlobByte(VAR_4);
VAR_21=ReadBlob(VAR_4,3*VAR_4->colors,VAR_24);
VAR_17=VAR_24;
for (VAR_16=0; VAR_16 < (ssize_t) VAR_4->colors; VAR_16++)
{
VAR_4->colormap[VAR_16].red=ScaleCharToQuantum(*VAR_17++);
VAR_4->colormap[VAR_16].green=ScaleCharToQuantum(*VAR_17++);
VAR_4->colormap[VAR_16].blue=ScaleCharToQuantum(*VAR_17++);
}
}
}
for (VAR_22=0; VAR_22 < (ssize_t) VAR_4->rows; VAR_22++)
{
VAR_17=VAR_25+(VAR_22*VAR_12.bytes_per_line*VAR_12.planes);
VAR_15=QueueAuthenticPixels(VAR_4,0,VAR_22,VAR_4->columns,1,VAR_1);
if (VAR_15 == (PixelPacket *) NULL)
break;
VAR_13=GetAuthenticIndexQueue(VAR_4);
VAR_18=VAR_26;
if (VAR_4->storage_class == VAR_37)
for (VAR_16=0; VAR_16 < VAR_12.planes; VAR_16++)
{
VAR_18=VAR_26+VAR_16;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_12.bytes_per_line; VAR_14++)
{
switch (VAR_16)
{
case 0:
{
*VAR_18=(*VAR_17++);
break;
}
case 1:
{
*VAR_18=(*VAR_17++);
break;
}
case 2:
{
*VAR_18=(*VAR_17++);
break;
}
case 3:
default:
{
*VAR_18=(*VAR_17++);
break;
}
}
VAR_18+=VAR_12.planes;
}
}
else
if (VAR_12.planes > 1)
{
for (VAR_14=0; VAR_14 < (ssize_t) VAR_4->columns; VAR_14++)
*VAR_18++=0;
for (VAR_16=0; VAR_16 < VAR_12.planes; VAR_16++)
{
VAR_18=VAR_26;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_12.bytes_per_line; VAR_14++)
{
VAR_5=(*VAR_17++);
for (VAR_7=0x80; VAR_7 != 0; VAR_7>>=1)
{
if (VAR_5 & VAR_7)
*VAR_18|=1 << VAR_16;
VAR_18++;
}
}
}
}
else
switch (VAR_12.bits_per_pixel)
{
case 1:
{
register ssize_t
VAR_40;
for (VAR_14=0; VAR_14 < ((ssize_t) VAR_4->columns-7); VAR_14+=8)
{
for (VAR_40=7; VAR_40 >= 0; VAR_40--)
*VAR_18++=(unsigned char) ((*VAR_17) & (0x01 << VAR_40) ? 0x01 : 0x00);
VAR_17++;
}
if ((VAR_4->columns % 8) != 0)
{
for (VAR_40=7; VAR_40 >= (ssize_t) (8-(VAR_4->columns % 8)); VAR_40--)
*VAR_18++=(unsigned char) ((*VAR_17) & (0x01 << VAR_40) ? 0x01 : 0x00);
VAR_17++;
}
break;
}
case 2:
{
for (VAR_14=0; VAR_14 < ((ssize_t) VAR_4->columns-3); VAR_14+=4)
{
*VAR_18++=(*VAR_17 >> 6) & 0x3;
*VAR_18++=(*VAR_17 >> 4) & 0x3;
*VAR_18++=(*VAR_17 >> 2) & 0x3;
*VAR_18++=(*VAR_17) & 0x3;
VAR_17++;
}
if ((VAR_4->columns % 4) != 0)
{
for (VAR_16=3; VAR_16 >= (ssize_t) (4-(VAR_4->columns % 4)); VAR_16--)
*VAR_18++=(unsigned char) ((*VAR_17 >> (VAR_16*2)) & 0x03);
VAR_17++;
}
break;
}
case 4:
{
for (VAR_14=0; VAR_14 < ((ssize_t) VAR_4->columns-1); VAR_14+=2)
{
*VAR_18++=(*VAR_17 >> 4) & 0xf;
*VAR_18++=(*VAR_17) & 0xf;
VAR_17++;
}
if ((VAR_4->columns % 2) != 0)
*VAR_18++=(*VAR_17++ >> 4) & 0xf;
break;
}
case 8:
{
(void) CopyMagickMemory(VAR_18,VAR_17,VAR_4->columns);
break;
}
default:
break;
}
VAR_18=VAR_26;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_4->columns; VAR_14++)
{
if (VAR_4->storage_class == VAR_41)
SetPixelIndex(VAR_13+VAR_14,*VAR_18++);
else
{
SetPixelRed(VAR_15,ScaleCharToQuantum(*VAR_18++));
SetPixelGreen(VAR_15,ScaleCharToQuantum(*VAR_18++));
SetPixelBlue(VAR_15,ScaleCharToQuantum(*VAR_18++));
if (VAR_4->matte != VAR_28)
SetPixelAlpha(VAR_15,ScaleCharToQuantum(*VAR_18++));
}
VAR_15++;
}
if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_28)
break;
if (VAR_4->previous == (Image *) NULL)
{
VAR_8=SetImageProgress(VAR_4,VAR_42,(MagickOffsetType) VAR_22,
VAR_4->rows);
if (VAR_8 == VAR_28)
break;
}
}
if (VAR_4->storage_class == VAR_41)
(void) SyncImage(VAR_4);
VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
VAR_11=RelinquishVirtualMemory(VAR_11);
if (EOFBlob(VAR_4) != VAR_28)
{
ThrowFileException(VAR_1,VAR_32,""UnexpectedEndOfFile"",
VAR_4->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
if (VAR_10 == (MagickOffsetType *) NULL)
break;
if (VAR_10[VAR_6] == 0)
break;
VAR_9=SeekBlob(VAR_4,(MagickOffsetType) VAR_10[VAR_6],VAR_34);
if (VAR_9 < 0)
ThrowReaderException(VAR_32,""ImproperImageHeader"");
VAR_21=ReadBlob(VAR_4,1,&VAR_12.identifier);
if ((VAR_21 != 0) && (VAR_12.identifier == 0x0a))
{
AcquireNextImage(VAR_0,VAR_4);
if (GetNextImageInList(VAR_4) == (Image *) NULL)
{
VAR_4=DestroyImageList(VAR_4);
return((Image *) NULL);
}
VAR_4=SyncNextImageInList(VAR_4);
VAR_8=SetImageProgress(VAR_4,VAR_43,TellBlob(VAR_4),
GetBlobSize(VAR_4));
if (VAR_8 == VAR_28)
break;
}
}
if (VAR_10 != (MagickOffsetType *) NULL)
VAR_10=(MagickOffsetType *) RelinquishMagickMemory(VAR_10);
(void) CloseBlob(VAR_4);
return(GetFirstImageInList(VAR_4));
}",ImageMagick/4c6289b2f39a47a430ce27b61d3e3967201e77e8/pcx.c/vul/before/0.json,"static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define ThrowPCXException(severity,tag) \
{ \
  if (scanline != (unsigned char *) NULL) \
    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \
  if (pixel_info != (MemoryInfo *) NULL) \
    pixel_info=RelinquishVirtualMemory(pixel_info); \
  if (page_table != (MagickOffsetType *) NULL) \
    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \
  ThrowReaderException(severity,tag); \
}

  Image
    *image;

  int
    bits,
    id,
    mask;

  MagickBooleanType
    status;

  MagickOffsetType
    offset,
    *page_table;

  MemoryInfo
    *pixel_info;

  PCXInfo
    pcx_info;

  register IndexPacket
    *indexes;

  register ssize_t
    x;

  register PixelPacket
    *q;

  register ssize_t
    i;

  register unsigned char
    *p,
    *r;

  size_t
    one,
    pcx_packets;

  ssize_t
    count,
    y;

  unsigned char
    packet,
    pcx_colormap[768],
    *pixels,
    *scanline;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a PCX file.
  */
  page_table=(MagickOffsetType *) NULL;
  scanline=(unsigned char *) NULL;
  pixel_info=(MemoryInfo *) NULL;
  if (LocaleCompare(image_info->magick,""DCX"") == 0)
    {
      size_t
        magic;

      /*
        Read the DCX page table.
      */
      magic=ReadBlobLSBLong(image);
      if (magic != 987654321)
        ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
        sizeof(*page_table));
      if (page_table == (MagickOffsetType *) NULL)
        ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");
      for (id=0; id < 1024; id++)
      {
        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);
        if (page_table[id] == 0)
          break;
      }
    }
  if (page_table != (MagickOffsetType *) NULL)
    {
      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);
      if (offset < 0)
        ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    }
  count=ReadBlob(image,1,&pcx_info.identifier);
  for (id=1; id < 1024; id++)
  {
    int
      bits_per_pixel;

    /*
      Verify PCX identifier.
    */
    pcx_info.version=(unsigned char) ReadBlobByte(image);
    if ((count != 1) || (pcx_info.identifier != 0x0a))
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    pcx_info.encoding=(unsigned char) ReadBlobByte(image);
    bits_per_pixel=ReadBlobByte(image);
    if (bits_per_pixel == -1)
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;
    pcx_info.left=ReadBlobLSBShort(image);
    pcx_info.top=ReadBlobLSBShort(image);
    pcx_info.right=ReadBlobLSBShort(image);
    pcx_info.bottom=ReadBlobLSBShort(image);
    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);
    pcx_info.vertical_resolution=ReadBlobLSBShort(image);
    /*
      Read PCX raster colormap.
    */
    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-
      pcx_info.left)+1UL;
    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-
      pcx_info.top)+1UL;
    if ((image->columns == 0) || (image->rows == 0) ||
        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&
         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    image->depth=pcx_info.bits_per_pixel;
    image->units=PixelsPerInchResolution;
    image->x_resolution=(double) pcx_info.horizontal_resolution;
    image->y_resolution=(double) pcx_info.vertical_resolution;
    image->colors=16;
    count=ReadBlob(image,3*image->colors,pcx_colormap);
    if (count != (ssize_t) (3*image->colors))
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    pcx_info.reserved=(unsigned char) ReadBlobByte(image);
    pcx_info.planes=(unsigned char) ReadBlobByte(image);
    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    if (pcx_info.planes == 0)
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    one=1;
    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))
      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||
          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))
        image->colors=(size_t) MagickMin(one << (1UL*
          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);
    if (AcquireImageColormap(image,image->colors) == MagickFalse)
      ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");
    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))
      image->storage_class=DirectClass;
    p=pcx_colormap;
    for (i=0; i < (ssize_t) image->colors; i++)
    {
      image->colormap[i].red=ScaleCharToQuantum(*p++);
      image->colormap[i].green=ScaleCharToQuantum(*p++);
      image->colormap[i].blue=ScaleCharToQuantum(*p++);
    }
    pcx_info.bytes_per_line=ReadBlobLSBShort(image);
    pcx_info.palette_info=ReadBlobLSBShort(image);
    pcx_info.horizontal_screensize=ReadBlobLSBShort(image);
    pcx_info.vertical_screensize=ReadBlobLSBShort(image);
    for (i=0; i < 54; i++)
      (void) ReadBlobByte(image);
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    /*
      Read image data.
    */
    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;
    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    pcx_packets=(size_t) pcx_packets*pcx_info.planes;
    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >
        (pcx_packets*8U))
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,
      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));
    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));
    if ((scanline == (unsigned char *) NULL) ||
        (pixel_info == (MemoryInfo *) NULL))
      {
        if (scanline != (unsigned char *) NULL)
          scanline=(unsigned char *) RelinquishMagickMemory(scanline);
        if (pixel_info != (MemoryInfo *) NULL)
          pixel_info=RelinquishVirtualMemory(pixel_info);
        ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    /*
      Uncompress image data.
    */
    p=pixels;
    if (pcx_info.encoding == 0)
      while (pcx_packets != 0)
      {
        packet=(unsigned char) ReadBlobByte(image);
        if (EOFBlob(image) != MagickFalse)
          ThrowPCXException(CorruptImageError,""UnexpectedEndOfFile"");
        *p++=packet;
        pcx_packets--;
      }
    else
      while (pcx_packets != 0)
      {
        packet=(unsigned char) ReadBlobByte(image);
        if (EOFBlob(image) != MagickFalse)
          ThrowPCXException(CorruptImageError,""UnexpectedEndOfFile"");
        if ((packet & 0xc0) != 0xc0)
          {
            *p++=packet;
            pcx_packets--;
            continue;
          }
        count=(ssize_t) (packet & 0x3f);
        packet=(unsigned char) ReadBlobByte(image);
        if (EOFBlob(image) != MagickFalse)
          ThrowPCXException(CorruptImageError,""UnexpectedEndOfFile"");
        for ( ; count != 0; count--)
        {
          *p++=packet;
          pcx_packets--;
          if (pcx_packets == 0)
            break;
        }
      }
    if (image->storage_class == DirectClass)
      image->matte=pcx_info.planes > 3 ? MagickTrue : MagickFalse;
    else
      if ((pcx_info.version == 5) ||
          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))
        {
          /*
            Initialize image colormap.
          */
          if (image->colors > 256)
            ThrowPCXException(CorruptImageError,""ColormapExceeds256Colors"");
          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)
            {
              /*
                Monochrome colormap.
              */
              image->colormap[0].red=(Quantum) 0;
              image->colormap[0].green=(Quantum) 0;
              image->colormap[0].blue=(Quantum) 0;
              image->colormap[1].red=QuantumRange;
              image->colormap[1].green=QuantumRange;
              image->colormap[1].blue=QuantumRange;
            }
          else
            if (image->colors > 16)
              {
                /*
                  256 color images have their color map at the end of the file.
                */
                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);
                count=ReadBlob(image,3*image->colors,pcx_colormap);
                p=pcx_colormap;
                for (i=0; i < (ssize_t) image->colors; i++)
                {
                  image->colormap[i].red=ScaleCharToQuantum(*p++);
                  image->colormap[i].green=ScaleCharToQuantum(*p++);
                  image->colormap[i].blue=ScaleCharToQuantum(*p++);
                }
            }
        }
    /*
      Convert PCX raster image to pixel packets.
    */
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);
      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
      if (q == (PixelPacket *) NULL)
        break;
      indexes=GetAuthenticIndexQueue(image);
      r=scanline;
      if (image->storage_class == DirectClass)
        for (i=0; i < pcx_info.planes; i++)
        {
          r=scanline+i;
          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
          {
            switch (i)
            {
              case 0:
              {
                *r=(*p++);
                break;
              }
              case 1:
              {
                *r=(*p++);
                break;
              }
              case 2:
              {
                *r=(*p++);
                break;
              }
              case 3:
              default:
              {
                *r=(*p++);
                break;
              }
            }
            r+=pcx_info.planes;
          }
        }
      else
        if (pcx_info.planes > 1)
          {
            for (x=0; x < (ssize_t) image->columns; x++)
              *r++=0;
            for (i=0; i < pcx_info.planes; i++)
            {
              r=scanline;
              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)
              {
                 bits=(*p++);
                 for (mask=0x80; mask != 0; mask>>=1)
                 {
                   if (bits & mask)
                     *r|=1 << i;
                   r++;
                 }
               }
            }
          }
        else
          switch (pcx_info.bits_per_pixel)
          {
            case 1:
            {
              register ssize_t
                bit;

              for (x=0; x < ((ssize_t) image->columns-7); x+=8)
              {
                for (bit=7; bit >= 0; bit--)
                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);
                p++;
              }
              if ((image->columns % 8) != 0)
                {
                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)
                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);
                  p++;
                }
              break;
            }
            case 2:
            {
              for (x=0; x < ((ssize_t) image->columns-3); x+=4)
              {
                *r++=(*p >> 6) & 0x3;
                *r++=(*p >> 4) & 0x3;
                *r++=(*p >> 2) & 0x3;
                *r++=(*p) & 0x3;
                p++;
              }
              if ((image->columns % 4) != 0)
                {
                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)
                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);
                  p++;
                }
              break;
            }
            case 4:
            {
              for (x=0; x < ((ssize_t) image->columns-1); x+=2)
              {
                *r++=(*p >> 4) & 0xf;
                *r++=(*p) & 0xf;
                p++;
              }
              if ((image->columns % 2) != 0)
                *r++=(*p++ >> 4) & 0xf;
              break;
            }
            case 8:
            {
              (void) CopyMagickMemory(r,p,image->columns);
              break;
            }
            default:
              break;
          }
      /*
        Transfer image scanline.
      */
      r=scanline;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (image->storage_class == PseudoClass)
          SetPixelIndex(indexes+x,*r++);
        else
          {
            SetPixelRed(q,ScaleCharToQuantum(*r++));
            SetPixelGreen(q,ScaleCharToQuantum(*r++));
            SetPixelBlue(q,ScaleCharToQuantum(*r++));
            if (image->matte != MagickFalse)
              SetPixelAlpha(q,ScaleCharToQuantum(*r++));
          }
        q++;
      }
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image);
    scanline=(unsigned char *) RelinquishMagickMemory(scanline);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    if (page_table == (MagickOffsetType *) NULL)
      break;
    if (page_table[id] == 0)
      break;
    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);
    if (offset < 0)
      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
    count=ReadBlob(image,1,&pcx_info.identifier);
    if ((count != 0) && (pcx_info.identifier == 0x0a))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  }
  if (page_table != (MagickOffsetType *) NULL)
    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadPCXImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define ThrowPCXException(VAR_2,VAR_3) \
{ \
  if (scanline != (unsigned char *) NULL) \
    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \
  if (pixel_info != (MemoryInfo *) NULL) \
    pixel_info=RelinquishVirtualMemory(pixel_info); \
  if (page_table != (MagickOffsetType *) NULL) \
    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \
  ThrowReaderException(severity,tag); \
}

  Image
    *VAR_4;

  int
    VAR_5,
    VAR_6,
    VAR_7;

  MagickBooleanType
    VAR_8;

  MagickOffsetType
    VAR_9,
    *VAR_10;

  MemoryInfo
    *VAR_11;

  PCXInfo
    VAR_12;

  register IndexPacket
    *VAR_13;

  register ssize_t
    VAR_14;

  register PixelPacket
    *VAR_15;

  register ssize_t
    VAR_16;

  register unsigned char
    *VAR_17,
    *VAR_18;

  size_t
    VAR_19,
    VAR_20;

  ssize_t
    VAR_21,
    VAR_22;

  unsigned char
    VAR_23,
    VAR_24[768],
    *VAR_25,
    *VAR_26;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_27);
  if (VAR_0->debug != VAR_28)
    (void) LogMagickEvent(VAR_29,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_27);
  VAR_4=AcquireImage(VAR_0);
  VAR_8=OpenBlob(VAR_0,VAR_4,VAR_30,VAR_1);
  if (VAR_8 == VAR_28)
    {
      VAR_4=DestroyImageList(VAR_4);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                                 
    
  VAR_10=(MagickOffsetType *) NULL;
  VAR_26=(unsigned char *) NULL;
  VAR_11=(MemoryInfo *) NULL;
  if (LocaleCompare(VAR_0->magick,""DCX"") == 0)
    {
      size_t
        VAR_31;

      /* COMMENT_6 */
                                
        
      VAR_31=ReadBlobLSBLong(VAR_4);
      if (VAR_31 != 987654321)
        ThrowPCXException(VAR_32,""ImproperImageHeader"");
      VAR_10=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
        sizeof(*VAR_10));
      if (VAR_10 == (MagickOffsetType *) NULL)
        ThrowPCXException(VAR_33,""MemoryAllocationFailed"");
      for (VAR_6=0; VAR_6 < 1024; VAR_6++)
      {
        VAR_10[VAR_6]=(MagickOffsetType) ReadBlobLSBLong(VAR_4);
        if (VAR_10[VAR_6] == 0)
          break;
      }
    }
  if (VAR_10 != (MagickOffsetType *) NULL)
    {
      VAR_9=SeekBlob(VAR_4,(MagickOffsetType) VAR_10[0],VAR_34);
      if (VAR_9 < 0)
        ThrowPCXException(VAR_32,""ImproperImageHeader"");
    }
  VAR_21=ReadBlob(VAR_4,1,&VAR_12.identifier);
  for (VAR_6=1; VAR_6 < 1024; VAR_6++)
  {
    int
      VAR_35;

    /* COMMENT_9 */
                            
      
    VAR_12.version=(unsigned char) ReadBlobByte(VAR_4);
    if ((VAR_21 != 1) || (VAR_12.identifier != 0x0a))
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_12.encoding=(unsigned char) ReadBlobByte(VAR_4);
    VAR_35=ReadBlobByte(VAR_4);
    if (VAR_35 == -1)
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_12.bits_per_pixel=(unsigned char) VAR_35;
    VAR_12.left=ReadBlobLSBShort(VAR_4);
    VAR_12.top=ReadBlobLSBShort(VAR_4);
    VAR_12.right=ReadBlobLSBShort(VAR_4);
    VAR_12.bottom=ReadBlobLSBShort(VAR_4);
    VAR_12.horizontal_resolution=ReadBlobLSBShort(VAR_4);
    VAR_12.vertical_resolution=ReadBlobLSBShort(VAR_4);
    /* COMMENT_12 */
                               
      
    VAR_4->columns=(size_t) MagickAbsoluteValue((ssize_t) VAR_12.right-
      VAR_12.left)+1UL;
    VAR_4->rows=(size_t) MagickAbsoluteValue((ssize_t) VAR_12.bottom-
      VAR_12.top)+1UL;
    if ((VAR_4->columns == 0) || (VAR_4->rows == 0) ||
        ((VAR_12.bits_per_pixel != 1) && (VAR_12.bits_per_pixel != 2) &&
         (VAR_12.bits_per_pixel != 4) && (VAR_12.bits_per_pixel != 8)))
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_4->depth=VAR_12.bits_per_pixel;
    VAR_4->units=VAR_36;
    VAR_4->x_resolution=(double) VAR_12.horizontal_resolution;
    VAR_4->y_resolution=(double) VAR_12.vertical_resolution;
    VAR_4->colors=16;
    VAR_21=ReadBlob(VAR_4,3*VAR_4->colors,VAR_24);
    if (VAR_21 != (ssize_t) (3*VAR_4->colors))
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_12.reserved=(unsigned char) ReadBlobByte(VAR_4);
    VAR_12.planes=(unsigned char) ReadBlobByte(VAR_4);
    if ((VAR_12.bits_per_pixel*VAR_12.planes) >= 64)
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    if (VAR_12.planes == 0)
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_19=1;
    if ((VAR_12.bits_per_pixel != 8) || (VAR_12.planes == 1))
      if ((VAR_12.version == 3) || (VAR_12.version == 5) ||
          ((VAR_12.bits_per_pixel*VAR_12.planes) == 1))
        VAR_4->colors=(size_t) MagickMin(VAR_19 << (1UL*
          (VAR_12.bits_per_pixel*VAR_12.planes)),256UL);
    if (AcquireImageColormap(VAR_4,VAR_4->colors) == VAR_28)
      ThrowPCXException(VAR_33,""MemoryAllocationFailed"");
    if ((VAR_12.bits_per_pixel >= 8) && (VAR_12.planes != 1))
      VAR_4->storage_class=VAR_37;
    VAR_17=VAR_24;
    for (VAR_16=0; VAR_16 < (ssize_t) VAR_4->colors; VAR_16++)
    {
      VAR_4->colormap[VAR_16].red=ScaleCharToQuantum(*VAR_17++);
      VAR_4->colormap[VAR_16].green=ScaleCharToQuantum(*VAR_17++);
      VAR_4->colormap[VAR_16].blue=ScaleCharToQuantum(*VAR_17++);
    }
    VAR_12.bytes_per_line=ReadBlobLSBShort(VAR_4);
    VAR_12.palette_info=ReadBlobLSBShort(VAR_4);
    VAR_12.horizontal_screensize=ReadBlobLSBShort(VAR_4);
    VAR_12.vertical_screensize=ReadBlobLSBShort(VAR_4);
    for (VAR_16=0; VAR_16 < 54; VAR_16++)
      (void) ReadBlobByte(VAR_4);
    if ((VAR_0->ping != VAR_28) && (VAR_0->number_scenes != 0))
      if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_8=SetImageExtent(VAR_4,VAR_4->columns,VAR_4->rows);
    if (VAR_8 == VAR_28)
      {
        InheritException(VAR_1,&VAR_4->exception);
        return(DestroyImageList(VAR_4));
      }
    /* COMMENT_15 */
                      
      
    if (HeapOverflowSanityCheck(VAR_4->rows, (size_t) VAR_12.bytes_per_line) != VAR_28)
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_20=(size_t) VAR_4->rows*VAR_12.bytes_per_line;
    if (HeapOverflowSanityCheck(VAR_20, (size_t) VAR_12.planes) != VAR_28)
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_20=(size_t) VAR_20*VAR_12.planes;
    if ((size_t) (VAR_12.bits_per_pixel*VAR_12.planes*VAR_4->columns) >
        (VAR_20*8U))
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_26=(unsigned char *) AcquireQuantumMemory(MagickMax(VAR_4->columns,
      VAR_12.bytes_per_line),MagickMax(8,VAR_12.planes)*sizeof(*VAR_26));
    VAR_11=AcquireVirtualMemory(VAR_20,2*sizeof(*VAR_25));
    if ((VAR_26 == (unsigned char *) NULL) ||
        (VAR_11 == (MemoryInfo *) NULL))
      {
        if (VAR_26 != (unsigned char *) NULL)
          VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
        if (VAR_11 != (MemoryInfo *) NULL)
          VAR_11=RelinquishVirtualMemory(VAR_11);
        ThrowPCXException(VAR_33,""MemoryAllocationFailed"");
      }
    VAR_25=(unsigned char *) GetVirtualMemoryBlob(VAR_11);
    /* COMMENT_18 */
                            
      
    VAR_17=VAR_25;
    if (VAR_12.encoding == 0)
      while (VAR_20 != 0)
      {
        VAR_23=(unsigned char) ReadBlobByte(VAR_4);
        if (EOFBlob(VAR_4) != VAR_28)
          ThrowPCXException(VAR_32,""UnexpectedEndOfFile"");
        *VAR_17++=VAR_23;
        VAR_20--;
      }
    else
      while (VAR_20 != 0)
      {
        VAR_23=(unsigned char) ReadBlobByte(VAR_4);
        if (EOFBlob(VAR_4) != VAR_28)
          ThrowPCXException(VAR_32,""UnexpectedEndOfFile"");
        if ((VAR_23 & 0xc0) != 0xc0)
          {
            *VAR_17++=VAR_23;
            VAR_20--;
            continue;
          }
        VAR_21=(ssize_t) (VAR_23 & 0x3f);
        VAR_23=(unsigned char) ReadBlobByte(VAR_4);
        if (EOFBlob(VAR_4) != VAR_28)
          ThrowPCXException(VAR_32,""UnexpectedEndOfFile"");
        for ( ; VAR_21 != 0; VAR_21--)
        {
          *VAR_17++=VAR_23;
          VAR_20--;
          if (VAR_20 == 0)
            break;
        }
      }
    if (VAR_4->storage_class == VAR_37)
      VAR_4->matte=VAR_12.planes > 3 ? VAR_38 : VAR_28;
    else
      if ((VAR_12.version == 5) ||
          ((VAR_12.bits_per_pixel*VAR_12.planes) == 1))
        {
          /* COMMENT_21 */
                                      
            
          if (VAR_4->colors > 256)
            ThrowPCXException(VAR_32,""ColormapExceeds256Colors"");
          if ((VAR_12.bits_per_pixel*VAR_12.planes) == 1)
            {
              /* COMMENT_24 */
                                    
                
              VAR_4->colormap[0].red=(Quantum) 0;
              VAR_4->colormap[0].green=(Quantum) 0;
              VAR_4->colormap[0].blue=(Quantum) 0;
              VAR_4->colormap[1].red=VAR_39;
              VAR_4->colormap[1].green=VAR_39;
              VAR_4->colormap[1].blue=VAR_39;
            }
          else
            if (VAR_4->colors > 16)
              {
                /* COMMENT_27 */
                                                                               
                  
                VAR_12.colormap_signature=(unsigned char) ReadBlobByte(VAR_4);
                VAR_21=ReadBlob(VAR_4,3*VAR_4->colors,VAR_24);
                VAR_17=VAR_24;
                for (VAR_16=0; VAR_16 < (ssize_t) VAR_4->colors; VAR_16++)
                {
                  VAR_4->colormap[VAR_16].red=ScaleCharToQuantum(*VAR_17++);
                  VAR_4->colormap[VAR_16].green=ScaleCharToQuantum(*VAR_17++);
                  VAR_4->colormap[VAR_16].blue=ScaleCharToQuantum(*VAR_17++);
                }
            }
        }
    /* COMMENT_30 */
                                                
      
    for (VAR_22=0; VAR_22 < (ssize_t) VAR_4->rows; VAR_22++)
    {
      VAR_17=VAR_25+(VAR_22*VAR_12.bytes_per_line*VAR_12.planes);
      VAR_15=QueueAuthenticPixels(VAR_4,0,VAR_22,VAR_4->columns,1,VAR_1);
      if (VAR_15 == (PixelPacket *) NULL)
        break;
      VAR_13=GetAuthenticIndexQueue(VAR_4);
      VAR_18=VAR_26;
      if (VAR_4->storage_class == VAR_37)
        for (VAR_16=0; VAR_16 < VAR_12.planes; VAR_16++)
        {
          VAR_18=VAR_26+VAR_16;
          for (VAR_14=0; VAR_14 < (ssize_t) VAR_12.bytes_per_line; VAR_14++)
          {
            switch (VAR_16)
            {
              case 0:
              {
                *VAR_18=(*VAR_17++);
                break;
              }
              case 1:
              {
                *VAR_18=(*VAR_17++);
                break;
              }
              case 2:
              {
                *VAR_18=(*VAR_17++);
                break;
              }
              case 3:
              default:
              {
                *VAR_18=(*VAR_17++);
                break;
              }
            }
            VAR_18+=VAR_12.planes;
          }
        }
      else
        if (VAR_12.planes > 1)
          {
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_4->columns; VAR_14++)
              *VAR_18++=0;
            for (VAR_16=0; VAR_16 < VAR_12.planes; VAR_16++)
            {
              VAR_18=VAR_26;
              for (VAR_14=0; VAR_14 < (ssize_t) VAR_12.bytes_per_line; VAR_14++)
              {
                 VAR_5=(*VAR_17++);
                 for (VAR_7=0x80; VAR_7 != 0; VAR_7>>=1)
                 {
                   if (VAR_5 & VAR_7)
                     *VAR_18|=1 << VAR_16;
                   VAR_18++;
                 }
               }
            }
          }
        else
          switch (VAR_12.bits_per_pixel)
          {
            case 1:
            {
              register ssize_t
                VAR_40;

              for (VAR_14=0; VAR_14 < ((ssize_t) VAR_4->columns-7); VAR_14+=8)
              {
                for (VAR_40=7; VAR_40 >= 0; VAR_40--)
                  *VAR_18++=(unsigned char) ((*VAR_17) & (0x01 << VAR_40) ? 0x01 : 0x00);
                VAR_17++;
              }
              if ((VAR_4->columns % 8) != 0)
                {
                  for (VAR_40=7; VAR_40 >= (ssize_t) (8-(VAR_4->columns % 8)); VAR_40--)
                    *VAR_18++=(unsigned char) ((*VAR_17) & (0x01 << VAR_40) ? 0x01 : 0x00);
                  VAR_17++;
                }
              break;
            }
            case 2:
            {
              for (VAR_14=0; VAR_14 < ((ssize_t) VAR_4->columns-3); VAR_14+=4)
              {
                *VAR_18++=(*VAR_17 >> 6) & 0x3;
                *VAR_18++=(*VAR_17 >> 4) & 0x3;
                *VAR_18++=(*VAR_17 >> 2) & 0x3;
                *VAR_18++=(*VAR_17) & 0x3;
                VAR_17++;
              }
              if ((VAR_4->columns % 4) != 0)
                {
                  for (VAR_16=3; VAR_16 >= (ssize_t) (4-(VAR_4->columns % 4)); VAR_16--)
                    *VAR_18++=(unsigned char) ((*VAR_17 >> (VAR_16*2)) & 0x03);
                  VAR_17++;
                }
              break;
            }
            case 4:
            {
              for (VAR_14=0; VAR_14 < ((ssize_t) VAR_4->columns-1); VAR_14+=2)
              {
                *VAR_18++=(*VAR_17 >> 4) & 0xf;
                *VAR_18++=(*VAR_17) & 0xf;
                VAR_17++;
              }
              if ((VAR_4->columns % 2) != 0)
                *VAR_18++=(*VAR_17++ >> 4) & 0xf;
              break;
            }
            case 8:
            {
              (void) CopyMagickMemory(VAR_18,VAR_17,VAR_4->columns);
              break;
            }
            default:
              break;
          }
      /* COMMENT_33 */
                                
        
      VAR_18=VAR_26;
      for (VAR_14=0; VAR_14 < (ssize_t) VAR_4->columns; VAR_14++)
      {
        if (VAR_4->storage_class == VAR_41)
          SetPixelIndex(VAR_13+VAR_14,*VAR_18++);
        else
          {
            SetPixelRed(VAR_15,ScaleCharToQuantum(*VAR_18++));
            SetPixelGreen(VAR_15,ScaleCharToQuantum(*VAR_18++));
            SetPixelBlue(VAR_15,ScaleCharToQuantum(*VAR_18++));
            if (VAR_4->matte != VAR_28)
              SetPixelAlpha(VAR_15,ScaleCharToQuantum(*VAR_18++));
          }
        VAR_15++;
      }
      if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_28)
        break;
      if (VAR_4->previous == (Image *) NULL)
        {
          VAR_8=SetImageProgress(VAR_4,VAR_42,(MagickOffsetType) VAR_22,
            VAR_4->rows);
          if (VAR_8 == VAR_28)
            break;
        }
    }
    if (VAR_4->storage_class == VAR_41)
      (void) SyncImage(VAR_4);
    VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
    VAR_11=RelinquishVirtualMemory(VAR_11);
    if (EOFBlob(VAR_4) != VAR_28)
      {
        ThrowFileException(VAR_1,VAR_32,""UnexpectedEndOfFile"",
          VAR_4->filename);
        break;
      }
    /* COMMENT_36 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_4->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    if (VAR_10 == (MagickOffsetType *) NULL)
      break;
    if (VAR_10[VAR_6] == 0)
      break;
    VAR_9=SeekBlob(VAR_4,(MagickOffsetType) VAR_10[VAR_6],VAR_34);
    if (VAR_9 < 0)
      ThrowPCXException(VAR_32,""ImproperImageHeader"");
    VAR_21=ReadBlob(VAR_4,1,&VAR_12.identifier);
    if ((VAR_21 != 0) && (VAR_12.identifier == 0x0a))
      {
        /* COMMENT_39 */
                                        
          
        AcquireNextImage(VAR_0,VAR_4);
        if (GetNextImageInList(VAR_4) == (Image *) NULL)
          {
            VAR_4=DestroyImageList(VAR_4);
            return((Image *) NULL);
          }
        VAR_4=SyncNextImageInList(VAR_4);
        VAR_8=SetImageProgress(VAR_4,VAR_43,TellBlob(VAR_4),
          GetBlobSize(VAR_4));
        if (VAR_8 == VAR_28)
          break;
      }
  }
  if (VAR_10 != (MagickOffsetType *) NULL)
    VAR_10=(MagickOffsetType *) RelinquishMagickMemory(VAR_10);
  (void) CloseBlob(VAR_4);
  return(GetFirstImageInList(VAR_4));
}",ImageMagick/4c6289b2f39a47a430ce27b61d3e3967201e77e8/pcx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,15 @@
 static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define ThrowPCXException(severity,tag) \
-  { \
+{ \
+  if (scanline != (unsigned char *) NULL) \
     scanline=(unsigned char *) RelinquishMagickMemory(scanline); \
+  if (pixel_info != (MemoryInfo *) NULL) \
     pixel_info=RelinquishVirtualMemory(pixel_info); \
-    ThrowReaderException(severity,tag); \
-  }
+  if (page_table != (MagickOffsetType *) NULL) \
+    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \
+  ThrowReaderException(severity,tag); \
+}
 
   Image
     *image;
@@ -79,6 +83,8 @@
     Determine if this a PCX file.
   */
   page_table=(MagickOffsetType *) NULL;
+  scanline=(unsigned char *) NULL;
+  pixel_info=(MemoryInfo *) NULL;
   if (LocaleCompare(image_info->magick,""DCX"") == 0)
     {
       size_t
@@ -89,11 +95,11 @@
       */
       magic=ReadBlobLSBLong(image);
       if (magic != 987654321)
-        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+        ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
       page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,
         sizeof(*page_table));
       if (page_table == (MagickOffsetType *) NULL)
-        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+        ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");
       for (id=0; id < 1024; id++)
       {
         page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);
@@ -105,7 +111,7 @@
     {
       offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);
       if (offset < 0)
-        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+        ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     }
   count=ReadBlob(image,1,&pcx_info.identifier);
   for (id=1; id < 1024; id++)
@@ -118,11 +124,11 @@
     */
     pcx_info.version=(unsigned char) ReadBlobByte(image);
     if ((count != 1) || (pcx_info.identifier != 0x0a))
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     pcx_info.encoding=(unsigned char) ReadBlobByte(image);
     bits_per_pixel=ReadBlobByte(image);
     if (bits_per_pixel == -1)
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;
     pcx_info.left=ReadBlobLSBShort(image);
     pcx_info.top=ReadBlobLSBShort(image);
@@ -140,7 +146,7 @@
     if ((image->columns == 0) || (image->rows == 0) ||
         ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&
          (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     image->depth=pcx_info.bits_per_pixel;
     image->units=PixelsPerInchResolution;
     image->x_resolution=(double) pcx_info.horizontal_resolution;
@@ -148,13 +154,13 @@
     image->colors=16;
     count=ReadBlob(image,3*image->colors,pcx_colormap);
     if (count != (ssize_t) (3*image->colors))
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     pcx_info.reserved=(unsigned char) ReadBlobByte(image);
     pcx_info.planes=(unsigned char) ReadBlobByte(image);
     if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     if (pcx_info.planes == 0)
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     one=1;
     if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))
       if ((pcx_info.version == 3) || (pcx_info.version == 5) ||
@@ -162,7 +168,7 @@
         image->colors=(size_t) MagickMin(one << (1UL*
           (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);
     if (AcquireImageColormap(image,image->colors) == MagickFalse)
-      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+      ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");
     if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))
       image->storage_class=DirectClass;
     p=pcx_colormap;
@@ -191,14 +197,14 @@
       Read image data.
     */
     if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;
     if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     pcx_packets=(size_t) pcx_packets*pcx_info.planes;
     if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >
         (pcx_packets*8U))
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,
       pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));
     pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));
@@ -209,7 +215,7 @@
           scanline=(unsigned char *) RelinquishMagickMemory(scanline);
         if (pixel_info != (MemoryInfo *) NULL)
           pixel_info=RelinquishVirtualMemory(pixel_info);
-        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+        ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     /*
@@ -463,7 +469,7 @@
       break;
     offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);
     if (offset < 0)
-      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");
     count=ReadBlob(image,1,&pcx_info.identifier);
     if ((count != 0) && (pcx_info.identifier == 0x0a))
       {","{'deleted_lines': ['  { \\', '    ThrowReaderException(severity,tag); \\', '  }', '        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");', '        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");'], 'added_lines': ['{ \\', '  if (scanline != (unsigned char *) NULL) \\', '  if (pixel_info != (MemoryInfo *) NULL) \\', '  if (page_table != (MagickOffsetType *) NULL) \\', '    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\', '  ThrowReaderException(severity,tag); \\', '}', '  scanline=(unsigned char *) NULL;', '  pixel_info=(MemoryInfo *) NULL;', '        ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '        ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");', '        ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");', '        ThrowPCXException(ResourceLimitError,""MemoryAllocationFailed"");', '      ThrowPCXException(CorruptImageError,""ImproperImageHeader"");']}",True,"In ImageMagick 7.0.5-5, the ReadPCXImage function in pcx.c allows attackers to cause a denial of service (memory leak) via a crafted file.",6.5,MEDIUM,1,valid,2017-04-26T20:58:26Z,1
CVE-2017-8351,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/448,23071f835d44e661177957fde0add67db7788a69,https://github.com/ImageMagick/ImageMagick/commit/23071f835d44e661177957fde0add67db7788a69,coders/pcd.c,ReadPCDImage,"static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image
*image;
MagickBooleanType
status;
MagickOffsetType
offset;
MagickSizeType
number_pixels;
register ssize_t
i,
y;
register PixelPacket
*q;
register unsigned char
*c1,
*c2,
*yy;
size_t
height,
number_images,
rotate,
scene,
width;
ssize_t
count,
x;
unsigned char
*chroma1,
*chroma2,
*header,
*luma;
unsigned int
overview;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));
if (header == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,3*0x800,header);
overview=LocaleNCompare((char *) header,""PCD_OPA"",7) == 0;
if ((count != (3*0x800)) ||
((LocaleNCompare((char *) header+0x800,""PCD"",3) != 0) && (overview == 0)))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
rotate=header[0x0e02] & 0x03;
number_images=(header[10] << 8) | header[11];
if (number_images > 65535)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
header=(unsigned char *) RelinquishMagickMemory(header);
if ((image->columns == 0) || (image->rows == 0))
scene=3;
else
{
width=192;
height=128;
for (scene=1; scene < 6; scene++)
{
if ((width >= image->columns) && (height >= image->rows))
break;
width<<=1;
height<<=1;
}
}
if (image_info->number_scenes != 0)
scene=(size_t) MagickMin(image_info->scene,6);
if (overview != 0)
scene=1;
width=192;
height=128;
for (i=1; i < (ssize_t) MagickMin(scene,3); i++)
{
width<<=1;
height<<=1;
}
image->columns=width;
image->rows=height;
image->depth=8;
for ( ; i < (ssize_t) scene; i++)
{
image->columns<<=1;
image->rows<<=1;
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
number_pixels=(MagickSizeType) image->columns*image->rows;
if (number_pixels != (size_t) number_pixels)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*
sizeof(*chroma1));
chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*
sizeof(*chroma2));
luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*
sizeof(*luma));
if ((chroma1 == (unsigned char *) NULL) ||
(chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
offset=93;
if (overview != 0)
offset=2;
else
if (scene == 2)
offset=20;
else
if (scene <= 1)
offset=1;
for (i=0; i < (ssize_t) (offset*0x800); i++)
(void) ReadBlobByte(image);
if (overview != 0)
{
Image
*overview_image;
MagickProgressMonitor
progress_monitor;
register ssize_t
j;
for (j=1; j <= (ssize_t) number_images; j++)
{
progress_monitor=SetImageProgressMonitor(image,
(MagickProgressMonitor) NULL,image->client_data);
(void) FormatLocaleString(image->filename,MaxTextExtent,
""images/img%04ld.pcd"",(long) j);
(void) FormatLocaleString(image->magick_filename,MaxTextExtent,
""images/img%04ld.pcd"",(long) j);
image->scene=(size_t) j;
image->columns=width;
image->rows=height;
image->depth=8;
yy=luma;
c1=chroma1;
c2=chroma2;
for (y=0; y < (ssize_t) height; y+=2)
{
count=ReadBlob(image,width,yy);
yy+=image->columns;
count=ReadBlob(image,width,yy);
yy+=image->columns;
count=ReadBlob(image,width >> 1,c1);
c1+=image->columns;
count=ReadBlob(image,width >> 1,c2);
c2+=image->columns;
}
Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);
Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);
yy=luma;
c1=chroma1;
c2=chroma2;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelRed(q,ScaleCharToQuantum(*yy++));
SetPixelGreen(q,ScaleCharToQuantum(*c1++));
SetPixelBlue(q,ScaleCharToQuantum(*c2++));
q++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
}
image->colorspace=YCCColorspace;
if (LocaleCompare(image_info->magick,""PCDS"") == 0)
SetImageColorspace(image,sRGBColorspace);
if (j < (ssize_t) number_images)
{
AcquireNextImage(image_info,image);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
}
(void) SetImageProgressMonitor(image,progress_monitor,
image->client_data);
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,j-1,number_images);
if (status == MagickFalse)
break;
}
}
chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);
chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);
luma=(unsigned char *) RelinquishMagickMemory(luma);
image=GetFirstImageInList(image);
overview_image=OverviewImage(image_info,image,exception);
return(overview_image);
}
yy=luma;
c1=chroma1;
c2=chroma2;
for (y=0; y < (ssize_t) height; y+=2)
{
count=ReadBlob(image,width,yy);
yy+=image->columns;
count=ReadBlob(image,width,yy);
yy+=image->columns;
count=ReadBlob(image,width >> 1,c1);
c1+=image->columns;
count=ReadBlob(image,width >> 1,c2);
c2+=image->columns;
}
if (scene >= 4)
{
Upsample(768,512,image->columns,luma);
Upsample(384,256,image->columns,chroma1);
Upsample(384,256,image->columns,chroma2);
image->rows=1024;
for (i=0; i < (4*0x800); i++)
(void) ReadBlobByte(image);
status=DecodeImage(image,luma,chroma1,chroma2);
if ((scene >= 5) && status)
{
Upsample(1536,1024,image->columns,luma);
Upsample(768,512,image->columns,chroma1);
Upsample(768,512,image->columns,chroma2);
image->rows=2048;
offset=TellBlob(image)/0x800+12;
offset=SeekBlob(image,offset*0x800,SEEK_SET);
status=DecodeImage(image,luma,chroma1,chroma2);
if ((scene >= 6) && (status != MagickFalse))
{
Upsample(3072,2048,image->columns,luma);
Upsample(1536,1024,image->columns,chroma1);
Upsample(1536,1024,image->columns,chroma2);
image->rows=4096;
}
}
}
Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);
Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);
yy=luma;
c1=chroma1;
c2=chroma2;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelRed(q,ScaleCharToQuantum(*yy++));
SetPixelGreen(q,ScaleCharToQuantum(*c1++));
SetPixelBlue(q,ScaleCharToQuantum(*c2++));
q++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);
chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);
luma=(unsigned char *) RelinquishMagickMemory(luma);
if (EOFBlob(image) != MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
(void) CloseBlob(image);
if (image_info->ping == MagickFalse)
if ((rotate == 1) || (rotate == 3))
{
double
degrees;
Image
*rotate_image;
degrees=rotate == 1 ? -90.0 : 90.0;
rotate_image=RotateImage(image,degrees,exception);
if (rotate_image != (Image *) NULL)
{
image=DestroyImage(image);
image=rotate_image;
}
}
image->chromaticity.red_primary.x=0.6400f;
image->chromaticity.red_primary.y=0.3300f;
image->chromaticity.green_primary.x=0.3000f;
image->chromaticity.green_primary.y=0.6000f;
image->chromaticity.blue_primary.x=0.1500f;
image->chromaticity.blue_primary.y=0.0600f;
image->chromaticity.white_point.x=0.3127f;
image->chromaticity.white_point.y=0.3290f;
image->gamma=1.000f/2.200f;
image->colorspace=YCCColorspace;
if (LocaleCompare(image_info->magick,""PCDS"") == 0)
SetImageColorspace(image,sRGBColorspace);
return(GetFirstImageInList(image));
}","static Image *ReadPCDImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image
*VAR_2;
MagickBooleanType
VAR_3;
MagickOffsetType
VAR_4;
MagickSizeType
VAR_5;
register ssize_t
VAR_6,
VAR_7;
register PixelPacket
*VAR_8;
register unsigned char
*VAR_9,
*VAR_10,
*VAR_11;
size_t
VAR_12,
VAR_13,
VAR_14,
VAR_15,
VAR_16;
ssize_t
VAR_17,
VAR_18;
unsigned char
*VAR_19,
*VAR_20,
*VAR_21,
*VAR_22;
unsigned int
VAR_23;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_24);
if (VAR_0->debug != VAR_25)
(void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_24);
VAR_2=AcquireImage(VAR_0);
VAR_3=OpenBlob(VAR_0,VAR_2,VAR_27,VAR_1);
if (VAR_3 == VAR_25)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_21=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*VAR_21));
if (VAR_21 == (unsigned char *) NULL)
ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
VAR_17=ReadBlob(VAR_2,3*0x800,VAR_21);
VAR_23=LocaleNCompare((char *) VAR_21,""PCD_OPA"",7) == 0;
if ((VAR_17 != (3*0x800)) ||
((LocaleNCompare((char *) VAR_21+0x800,""PCD"",3) != 0) && (VAR_23 == 0)))
ThrowReaderException(VAR_29,""ImproperImageHeader"");
VAR_14=VAR_21[0x0e02] & 0x03;
VAR_13=(VAR_21[10] << 8) | VAR_21[11];
if (VAR_13 > 65535)
ThrowReaderException(VAR_29,""ImproperImageHeader"");
VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
if ((VAR_2->columns == 0) || (VAR_2->rows == 0))
VAR_15=3;
else
{
VAR_16=192;
VAR_12=128;
for (VAR_15=1; VAR_15 < 6; VAR_15++)
{
if ((VAR_16 >= VAR_2->columns) && (VAR_12 >= VAR_2->rows))
break;
VAR_16<<=1;
VAR_12<<=1;
}
}
if (VAR_0->number_scenes != 0)
VAR_15=(size_t) MagickMin(VAR_0->scene,6);
if (VAR_23 != 0)
VAR_15=1;
VAR_16=192;
VAR_12=128;
for (VAR_6=1; VAR_6 < (ssize_t) MagickMin(VAR_15,3); VAR_6++)
{
VAR_16<<=1;
VAR_12<<=1;
}
VAR_2->columns=VAR_16;
VAR_2->rows=VAR_12;
VAR_2->depth=8;
for ( ; VAR_6 < (ssize_t) VAR_15; VAR_6++)
{
VAR_2->columns<<=1;
VAR_2->rows<<=1;
}
VAR_3=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
if (VAR_3 == VAR_25)
{
InheritException(VAR_1,&VAR_2->exception);
return(DestroyImageList(VAR_2));
}
VAR_5=(MagickSizeType) VAR_2->columns*VAR_2->rows;
if (VAR_5 != (size_t) VAR_5)
ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
VAR_19=(unsigned char *) AcquireQuantumMemory(VAR_2->columns+1UL,VAR_2->rows*
sizeof(*VAR_19));
VAR_20=(unsigned char *) AcquireQuantumMemory(VAR_2->columns+1UL,VAR_2->rows*
sizeof(*VAR_20));
VAR_22=(unsigned char *) AcquireQuantumMemory(VAR_2->columns+1UL,VAR_2->rows*
sizeof(*VAR_22));
if ((VAR_19 == (unsigned char *) NULL) ||
(VAR_20 == (unsigned char *) NULL) || (VAR_22 == (unsigned char *) NULL))
ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
VAR_4=93;
if (VAR_23 != 0)
VAR_4=2;
else
if (VAR_15 == 2)
VAR_4=20;
else
if (VAR_15 <= 1)
VAR_4=1;
for (VAR_6=0; VAR_6 < (ssize_t) (VAR_4*0x800); VAR_6++)
(void) ReadBlobByte(VAR_2);
if (VAR_23 != 0)
{
Image
*VAR_30;
MagickProgressMonitor
VAR_31;
register ssize_t
VAR_32;
for (VAR_32=1; VAR_32 <= (ssize_t) VAR_13; VAR_32++)
{
VAR_31=SetImageProgressMonitor(VAR_2,
(MagickProgressMonitor) NULL,VAR_2->client_data);
(void) FormatLocaleString(VAR_2->filename,VAR_33,
""images/img%04ld.pcd"",(long) VAR_32);
(void) FormatLocaleString(VAR_2->magick_filename,VAR_33,
""images/img%04ld.pcd"",(long) VAR_32);
VAR_2->scene=(size_t) VAR_32;
VAR_2->columns=VAR_16;
VAR_2->rows=VAR_12;
VAR_2->depth=8;
VAR_11=VAR_22;
VAR_9=VAR_19;
VAR_10=VAR_20;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_12; VAR_7+=2)
{
VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
VAR_11+=VAR_2->columns;
VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
VAR_11+=VAR_2->columns;
VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_9);
VAR_9+=VAR_2->columns;
VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_10);
VAR_10+=VAR_2->columns;
}
Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_19);
Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_20);
VAR_11=VAR_22;
VAR_9=VAR_19;
VAR_10=VAR_20;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2->rows; VAR_7++)
{
VAR_8=QueueAuthenticPixels(VAR_2,0,VAR_7,VAR_2->columns,1,VAR_1);
if (VAR_8 == (PixelPacket *) NULL)
break;
for (VAR_18=0; VAR_18 < (ssize_t) VAR_2->columns; VAR_18++)
{
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_11++));
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_9++));
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_10++));
VAR_8++;
}
if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_25)
break;
}
VAR_2->colorspace=VAR_34;
if (LocaleCompare(VAR_0->magick,""PCDS"") == 0)
SetImageColorspace(VAR_2,VAR_35);
if (VAR_32 < (ssize_t) VAR_13)
{
AcquireNextImage(VAR_0,VAR_2);
if (GetNextImageInList(VAR_2) == (Image *) NULL)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_2=SyncNextImageInList(VAR_2);
}
(void) SetImageProgressMonitor(VAR_2,VAR_31,
VAR_2->client_data);
if (VAR_2->previous == (Image *) NULL)
{
VAR_3=SetImageProgress(VAR_2,VAR_36,VAR_32-1,VAR_13);
if (VAR_3 == VAR_25)
break;
}
}
VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
VAR_19=(unsigned char *) RelinquishMagickMemory(VAR_19);
VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
VAR_2=GetFirstImageInList(VAR_2);
VAR_30=OverviewImage(VAR_0,VAR_2,VAR_1);
return(VAR_30);
}
VAR_11=VAR_22;
VAR_9=VAR_19;
VAR_10=VAR_20;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_12; VAR_7+=2)
{
VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
VAR_11+=VAR_2->columns;
VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
VAR_11+=VAR_2->columns;
VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_9);
VAR_9+=VAR_2->columns;
VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_10);
VAR_10+=VAR_2->columns;
}
if (VAR_15 >= 4)
{
Upsample(768,512,VAR_2->columns,VAR_22);
Upsample(384,256,VAR_2->columns,VAR_19);
Upsample(384,256,VAR_2->columns,VAR_20);
VAR_2->rows=1024;
for (VAR_6=0; VAR_6 < (4*0x800); VAR_6++)
(void) ReadBlobByte(VAR_2);
VAR_3=DecodeImage(VAR_2,VAR_22,VAR_19,VAR_20);
if ((VAR_15 >= 5) && VAR_3)
{
Upsample(1536,1024,VAR_2->columns,VAR_22);
Upsample(768,512,VAR_2->columns,VAR_19);
Upsample(768,512,VAR_2->columns,VAR_20);
VAR_2->rows=2048;
VAR_4=TellBlob(VAR_2)/0x800+12;
VAR_4=SeekBlob(VAR_2,VAR_4*0x800,VAR_37);
VAR_3=DecodeImage(VAR_2,VAR_22,VAR_19,VAR_20);
if ((VAR_15 >= 6) && (VAR_3 != VAR_25))
{
Upsample(3072,2048,VAR_2->columns,VAR_22);
Upsample(1536,1024,VAR_2->columns,VAR_19);
Upsample(1536,1024,VAR_2->columns,VAR_20);
VAR_2->rows=4096;
}
}
}
Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_19);
Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_20);
VAR_11=VAR_22;
VAR_9=VAR_19;
VAR_10=VAR_20;
for (VAR_7=0; VAR_7 < (ssize_t) VAR_2->rows; VAR_7++)
{
VAR_8=QueueAuthenticPixels(VAR_2,0,VAR_7,VAR_2->columns,1,VAR_1);
if (VAR_8 == (PixelPacket *) NULL)
break;
for (VAR_18=0; VAR_18 < (ssize_t) VAR_2->columns; VAR_18++)
{
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_11++));
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_9++));
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_10++));
VAR_8++;
}
if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_25)
break;
if (VAR_2->previous == (Image *) NULL)
{
VAR_3=SetImageProgress(VAR_2,VAR_36,(MagickOffsetType) VAR_7,
VAR_2->rows);
if (VAR_3 == VAR_25)
break;
}
}
VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
VAR_19=(unsigned char *) RelinquishMagickMemory(VAR_19);
VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
if (EOFBlob(VAR_2) != VAR_25)
ThrowFileException(VAR_1,VAR_29,""UnexpectedEndOfFile"",
VAR_2->filename);
(void) CloseBlob(VAR_2);
if (VAR_0->ping == VAR_25)
if ((VAR_14 == 1) || (VAR_14 == 3))
{
double
VAR_38;
Image
*VAR_39;
VAR_38=VAR_14 == 1 ? -90.0 : 90.0;
VAR_39=RotateImage(VAR_2,VAR_38,VAR_1);
if (VAR_39 != (Image *) NULL)
{
VAR_2=DestroyImage(VAR_2);
VAR_2=VAR_39;
}
}
VAR_2->chromaticity.red_primary.x=0.6400f;
VAR_2->chromaticity.red_primary.y=0.3300f;
VAR_2->chromaticity.green_primary.x=0.3000f;
VAR_2->chromaticity.green_primary.y=0.6000f;
VAR_2->chromaticity.blue_primary.x=0.1500f;
VAR_2->chromaticity.blue_primary.y=0.0600f;
VAR_2->chromaticity.white_point.x=0.3127f;
VAR_2->chromaticity.white_point.y=0.3290f;
VAR_2->gamma=1.000f/2.200f;
VAR_2->colorspace=VAR_34;
if (LocaleCompare(VAR_0->magick,""PCDS"") == 0)
SetImageColorspace(VAR_2,VAR_35);
return(GetFirstImageInList(VAR_2));
}",ImageMagick/23071f835d44e661177957fde0add67db7788a69/pcd.c/vul/before/0.json,"static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  MagickSizeType
    number_pixels;

  register ssize_t
    i,
    y;

  register PixelPacket
    *q;

  register unsigned char
    *c1,
    *c2,
    *yy;

  size_t
    height,
    number_images,
    rotate,
    scene,
    width;

  ssize_t
    count,
    x;

  unsigned char
    *chroma1,
    *chroma2,
    *header,
    *luma;

  unsigned int
    overview;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a PCD file.
  */
  header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));
  if (header == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  count=ReadBlob(image,3*0x800,header);
  overview=LocaleNCompare((char *) header,""PCD_OPA"",7) == 0;
  if ((count != (3*0x800)) ||
      ((LocaleNCompare((char *) header+0x800,""PCD"",3) != 0) && (overview == 0)))
    {
      header=(unsigned char *) RelinquishMagickMemory(header);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
  rotate=header[0x0e02] & 0x03;
  number_images=(header[10] << 8) | header[11];
  header=(unsigned char *) RelinquishMagickMemory(header);
  if (number_images > 65535)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  /*
    Determine resolution by scene specification.
  */
  if ((image->columns == 0) || (image->rows == 0))
    scene=3;
  else
    {
      width=192;
      height=128;
      for (scene=1; scene < 6; scene++)
      {
        if ((width >= image->columns) && (height >= image->rows))
          break;
        width<<=1;
        height<<=1;
      }
    }
  if (image_info->number_scenes != 0)
    scene=(size_t) MagickMin(image_info->scene,6);
  if (overview != 0)
    scene=1;
  /*
    Initialize image structure.
  */
  width=192;
  height=128;
  for (i=1; i < (ssize_t) MagickMin(scene,3); i++)
  {
    width<<=1;
    height<<=1;
  }
  image->columns=width;
  image->rows=height;
  image->depth=8;
  for ( ; i < (ssize_t) scene; i++)
  {
    image->columns<<=1;
    image->rows<<=1;
  }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  /*
    Allocate luma and chroma memory.
  */
  number_pixels=(MagickSizeType) image->columns*image->rows;
  if (number_pixels != (size_t) number_pixels)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*
    sizeof(*chroma1));
  chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*
    sizeof(*chroma2));
  luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*
    sizeof(*luma));
  if ((chroma1 == (unsigned char *) NULL) ||
      (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  /*
    Advance to image data.
  */
  offset=93;
  if (overview != 0)
    offset=2;
  else
    if (scene == 2)
      offset=20;
    else
      if (scene <= 1)
        offset=1;
  for (i=0; i < (ssize_t) (offset*0x800); i++)
    (void) ReadBlobByte(image);
  if (overview != 0)
    {
      Image
        *overview_image;

      MagickProgressMonitor
        progress_monitor;

      register ssize_t
        j;

      /*
        Read thumbnails from overview image.
      */
      for (j=1; j <= (ssize_t) number_images; j++)
      {
        progress_monitor=SetImageProgressMonitor(image,
          (MagickProgressMonitor) NULL,image->client_data);
        (void) FormatLocaleString(image->filename,MaxTextExtent,
          ""images/img%04ld.pcd"",(long) j);
        (void) FormatLocaleString(image->magick_filename,MaxTextExtent,
          ""images/img%04ld.pcd"",(long) j);
        image->scene=(size_t) j;
        image->columns=width;
        image->rows=height;
        image->depth=8;
        yy=luma;
        c1=chroma1;
        c2=chroma2;
        for (y=0; y < (ssize_t) height; y+=2)
        {
          count=ReadBlob(image,width,yy);
          yy+=image->columns;
          count=ReadBlob(image,width,yy);
          yy+=image->columns;
          count=ReadBlob(image,width >> 1,c1);
          c1+=image->columns;
          count=ReadBlob(image,width >> 1,c2);
          c2+=image->columns;
        }
        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);
        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);
        /*
          Transfer luminance and chrominance channels.
        */
        yy=luma;
        c1=chroma1;
        c2=chroma2;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (PixelPacket *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum(*yy++));
            SetPixelGreen(q,ScaleCharToQuantum(*c1++));
            SetPixelBlue(q,ScaleCharToQuantum(*c2++));
            q++;
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
        }
        image->colorspace=YCCColorspace;
        if (LocaleCompare(image_info->magick,""PCDS"") == 0)
          (void) SetImageColorspace(image,sRGBColorspace);
        if (j < (ssize_t) number_images)
          {
            /*
              Allocate next image structure.
            */
            AcquireNextImage(image_info,image);
            if (GetNextImageInList(image) == (Image *) NULL)
              {
                image=DestroyImageList(image);
                return((Image *) NULL);
              }
            image=SyncNextImageInList(image);
          }
        (void) SetImageProgressMonitor(image,progress_monitor,
          image->client_data);
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,j-1,number_images);
            if (status == MagickFalse)
              break;
          }
      }
      chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);
      chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);
      luma=(unsigned char *) RelinquishMagickMemory(luma);
      image=GetFirstImageInList(image);
      overview_image=OverviewImage(image_info,image,exception);
      return(overview_image);
    }
  /*
    Read interleaved image.
  */
  yy=luma;
  c1=chroma1;
  c2=chroma2;
  for (y=0; y < (ssize_t) height; y+=2)
  {
    count=ReadBlob(image,width,yy);
    yy+=image->columns;
    count=ReadBlob(image,width,yy);
    yy+=image->columns;
    count=ReadBlob(image,width >> 1,c1);
    c1+=image->columns;
    count=ReadBlob(image,width >> 1,c2);
    c2+=image->columns;
  }
  if (scene >= 4)
    {
      /*
        Recover luminance deltas for 1536x1024 image.
      */
      Upsample(768,512,image->columns,luma);
      Upsample(384,256,image->columns,chroma1);
      Upsample(384,256,image->columns,chroma2);
      image->rows=1024;
      for (i=0; i < (4*0x800); i++)
        (void) ReadBlobByte(image);
      status=DecodeImage(image,luma,chroma1,chroma2);
      if ((scene >= 5) && status)
        {
          /*
            Recover luminance deltas for 3072x2048 image.
          */
          Upsample(1536,1024,image->columns,luma);
          Upsample(768,512,image->columns,chroma1);
          Upsample(768,512,image->columns,chroma2);
          image->rows=2048;
          offset=TellBlob(image)/0x800+12;
          offset=SeekBlob(image,offset*0x800,SEEK_SET);
          status=DecodeImage(image,luma,chroma1,chroma2);
          if ((scene >= 6) && (status != MagickFalse))
            {
              /*
                Recover luminance deltas for 6144x4096 image (vaporware).
              */
              Upsample(3072,2048,image->columns,luma);
              Upsample(1536,1024,image->columns,chroma1);
              Upsample(1536,1024,image->columns,chroma2);
              image->rows=4096;
            }
        }
    }
  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);
  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);
  /*
    Transfer luminance and chrominance channels.
  */
  yy=luma;
  c1=chroma1;
  c2=chroma2;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelRed(q,ScaleCharToQuantum(*yy++));
      SetPixelGreen(q,ScaleCharToQuantum(*c1++));
      SetPixelBlue(q,ScaleCharToQuantum(*c2++));
      q++;
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);
  chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);
  luma=(unsigned char *) RelinquishMagickMemory(luma);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  (void) CloseBlob(image);
  if (image_info->ping == MagickFalse)
    if ((rotate == 1) || (rotate == 3))
      {
        double
          degrees;

        Image
          *rotate_image;

        /*
          Rotate image.
        */
        degrees=rotate == 1 ? -90.0 : 90.0;
        rotate_image=RotateImage(image,degrees,exception);
        if (rotate_image != (Image *) NULL)
          {
            image=DestroyImage(image);
            image=rotate_image;
          }
      }
  /*
    Set CCIR 709 primaries with a D65 white point.
  */
  image->chromaticity.red_primary.x=0.6400f;
  image->chromaticity.red_primary.y=0.3300f;
  image->chromaticity.green_primary.x=0.3000f;
  image->chromaticity.green_primary.y=0.6000f;
  image->chromaticity.blue_primary.x=0.1500f;
  image->chromaticity.blue_primary.y=0.0600f;
  image->chromaticity.white_point.x=0.3127f;
  image->chromaticity.white_point.y=0.3290f;
  image->gamma=1.000f/2.200f;
  image->colorspace=YCCColorspace;
  if (LocaleCompare(image_info->magick,""PCDS"") == 0)
    (void) SetImageColorspace(image,sRGBColorspace);
  return(GetFirstImageInList(image));
}","static Image *ReadPCDImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image
    *VAR_2;

  MagickBooleanType
    VAR_3;

  MagickOffsetType
    VAR_4;

  MagickSizeType
    VAR_5;

  register ssize_t
    VAR_6,
    VAR_7;

  register PixelPacket
    *VAR_8;

  register unsigned char
    *VAR_9,
    *VAR_10,
    *VAR_11;

  size_t
    VAR_12,
    VAR_13,
    VAR_14,
    VAR_15,
    VAR_16;

  ssize_t
    VAR_17,
    VAR_18;

  unsigned char
    *VAR_19,
    *VAR_20,
    *VAR_21,
    *VAR_22;

  unsigned int
    VAR_23;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_24);
  if (VAR_0->debug != VAR_25)
    (void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_24);
  VAR_2=AcquireImage(VAR_0);
  VAR_3=OpenBlob(VAR_0,VAR_2,VAR_27,VAR_1);
  if (VAR_3 == VAR_25)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                                 
    
  VAR_21=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*VAR_21));
  if (VAR_21 == (unsigned char *) NULL)
    ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
  VAR_17=ReadBlob(VAR_2,3*0x800,VAR_21);
  VAR_23=LocaleNCompare((char *) VAR_21,""PCD_OPA"",7) == 0;
  if ((VAR_17 != (3*0x800)) ||
      ((LocaleNCompare((char *) VAR_21+0x800,""PCD"",3) != 0) && (VAR_23 == 0)))
    {
      VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
      ThrowReaderException(VAR_29,""ImproperImageHeader"");
    }
  VAR_14=VAR_21[0x0e02] & 0x03;
  VAR_13=(VAR_21[10] << 8) | VAR_21[11];
  VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
  if (VAR_13 > 65535)
    ThrowReaderException(VAR_29,""ImproperImageHeader"");
  /* COMMENT_6 */
                                                
    
  if ((VAR_2->columns == 0) || (VAR_2->rows == 0))
    VAR_15=3;
  else
    {
      VAR_16=192;
      VAR_12=128;
      for (VAR_15=1; VAR_15 < 6; VAR_15++)
      {
        if ((VAR_16 >= VAR_2->columns) && (VAR_12 >= VAR_2->rows))
          break;
        VAR_16<<=1;
        VAR_12<<=1;
      }
    }
  if (VAR_0->number_scenes != 0)
    VAR_15=(size_t) MagickMin(VAR_0->scene,6);
  if (VAR_23 != 0)
    VAR_15=1;
  /* COMMENT_9 */
                               
    
  VAR_16=192;
  VAR_12=128;
  for (VAR_6=1; VAR_6 < (ssize_t) MagickMin(VAR_15,3); VAR_6++)
  {
    VAR_16<<=1;
    VAR_12<<=1;
  }
  VAR_2->columns=VAR_16;
  VAR_2->rows=VAR_12;
  VAR_2->depth=8;
  for ( ; VAR_6 < (ssize_t) VAR_15; VAR_6++)
  {
    VAR_2->columns<<=1;
    VAR_2->rows<<=1;
  }
  VAR_3=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
  if (VAR_3 == VAR_25)
    {
      InheritException(VAR_1,&VAR_2->exception);
      return(DestroyImageList(VAR_2));
    }
  /* COMMENT_12 */
                                    
    
  VAR_5=(MagickSizeType) VAR_2->columns*VAR_2->rows;
  if (VAR_5 != (size_t) VAR_5)
    ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
  VAR_19=(unsigned char *) AcquireQuantumMemory(VAR_2->columns+1UL,VAR_2->rows*
    sizeof(*VAR_19));
  VAR_20=(unsigned char *) AcquireQuantumMemory(VAR_2->columns+1UL,VAR_2->rows*
    sizeof(*VAR_20));
  VAR_22=(unsigned char *) AcquireQuantumMemory(VAR_2->columns+1UL,VAR_2->rows*
    sizeof(*VAR_22));
  if ((VAR_19 == (unsigned char *) NULL) ||
      (VAR_20 == (unsigned char *) NULL) || (VAR_22 == (unsigned char *) NULL))
    ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
  /* COMMENT_15 */
                          
    
  VAR_4=93;
  if (VAR_23 != 0)
    VAR_4=2;
  else
    if (VAR_15 == 2)
      VAR_4=20;
    else
      if (VAR_15 <= 1)
        VAR_4=1;
  for (VAR_6=0; VAR_6 < (ssize_t) (VAR_4*0x800); VAR_6++)
    (void) ReadBlobByte(VAR_2);
  if (VAR_23 != 0)
    {
      Image
        *VAR_30;

      MagickProgressMonitor
        VAR_31;

      register ssize_t
        VAR_32;

      /* COMMENT_18 */
                                            
        
      for (VAR_32=1; VAR_32 <= (ssize_t) VAR_13; VAR_32++)
      {
        VAR_31=SetImageProgressMonitor(VAR_2,
          (MagickProgressMonitor) NULL,VAR_2->client_data);
        (void) FormatLocaleString(VAR_2->filename,VAR_33,
          ""images/img%04ld.pcd"",(long) VAR_32);
        (void) FormatLocaleString(VAR_2->magick_filename,VAR_33,
          ""images/img%04ld.pcd"",(long) VAR_32);
        VAR_2->scene=(size_t) VAR_32;
        VAR_2->columns=VAR_16;
        VAR_2->rows=VAR_12;
        VAR_2->depth=8;
        VAR_11=VAR_22;
        VAR_9=VAR_19;
        VAR_10=VAR_20;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_12; VAR_7+=2)
        {
          VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
          VAR_11+=VAR_2->columns;
          VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
          VAR_11+=VAR_2->columns;
          VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_9);
          VAR_9+=VAR_2->columns;
          VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_10);
          VAR_10+=VAR_2->columns;
        }
        Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_19);
        Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_20);
        /* COMMENT_21 */
                                                      
          
        VAR_11=VAR_22;
        VAR_9=VAR_19;
        VAR_10=VAR_20;
        for (VAR_7=0; VAR_7 < (ssize_t) VAR_2->rows; VAR_7++)
        {
          VAR_8=QueueAuthenticPixels(VAR_2,0,VAR_7,VAR_2->columns,1,VAR_1);
          if (VAR_8 == (PixelPacket *) NULL)
            break;
          for (VAR_18=0; VAR_18 < (ssize_t) VAR_2->columns; VAR_18++)
          {
            SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_11++));
            SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_9++));
            SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_10++));
            VAR_8++;
          }
          if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_25)
            break;
        }
        VAR_2->colorspace=VAR_34;
        if (LocaleCompare(VAR_0->magick,""PCDS"") == 0)
          (void) SetImageColorspace(VAR_2,VAR_35);
        if (VAR_32 < (ssize_t) VAR_13)
          {
            /* COMMENT_24 */
                                            
              
            AcquireNextImage(VAR_0,VAR_2);
            if (GetNextImageInList(VAR_2) == (Image *) NULL)
              {
                VAR_2=DestroyImageList(VAR_2);
                return((Image *) NULL);
              }
            VAR_2=SyncNextImageInList(VAR_2);
          }
        (void) SetImageProgressMonitor(VAR_2,VAR_31,
          VAR_2->client_data);
        if (VAR_2->previous == (Image *) NULL)
          {
            VAR_3=SetImageProgress(VAR_2,VAR_36,VAR_32-1,VAR_13);
            if (VAR_3 == VAR_25)
              break;
          }
      }
      VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
      VAR_19=(unsigned char *) RelinquishMagickMemory(VAR_19);
      VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
      VAR_2=GetFirstImageInList(VAR_2);
      VAR_30=OverviewImage(VAR_0,VAR_2,VAR_1);
      return(VAR_30);
    }
  /* COMMENT_27 */
                           
    
  VAR_11=VAR_22;
  VAR_9=VAR_19;
  VAR_10=VAR_20;
  for (VAR_7=0; VAR_7 < (ssize_t) VAR_12; VAR_7+=2)
  {
    VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
    VAR_11+=VAR_2->columns;
    VAR_17=ReadBlob(VAR_2,VAR_16,VAR_11);
    VAR_11+=VAR_2->columns;
    VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_9);
    VAR_9+=VAR_2->columns;
    VAR_17=ReadBlob(VAR_2,VAR_16 >> 1,VAR_10);
    VAR_10+=VAR_2->columns;
  }
  if (VAR_15 >= 4)
    {
      /* COMMENT_30 */
                                                     
        
      Upsample(768,512,VAR_2->columns,VAR_22);
      Upsample(384,256,VAR_2->columns,VAR_19);
      Upsample(384,256,VAR_2->columns,VAR_20);
      VAR_2->rows=1024;
      for (VAR_6=0; VAR_6 < (4*0x800); VAR_6++)
        (void) ReadBlobByte(VAR_2);
      VAR_3=DecodeImage(VAR_2,VAR_22,VAR_19,VAR_20);
      if ((VAR_15 >= 5) && VAR_3)
        {
          /* COMMENT_33 */
                                                         
            
          Upsample(1536,1024,VAR_2->columns,VAR_22);
          Upsample(768,512,VAR_2->columns,VAR_19);
          Upsample(768,512,VAR_2->columns,VAR_20);
          VAR_2->rows=2048;
          VAR_4=TellBlob(VAR_2)/0x800+12;
          VAR_4=SeekBlob(VAR_2,VAR_4*0x800,VAR_37);
          VAR_3=DecodeImage(VAR_2,VAR_22,VAR_19,VAR_20);
          if ((VAR_15 >= 6) && (VAR_3 != VAR_25))
            {
              /* COMMENT_36 */
                                                                         
                
              Upsample(3072,2048,VAR_2->columns,VAR_22);
              Upsample(1536,1024,VAR_2->columns,VAR_19);
              Upsample(1536,1024,VAR_2->columns,VAR_20);
              VAR_2->rows=4096;
            }
        }
    }
  Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_19);
  Upsample(VAR_2->columns >> 1,VAR_2->rows >> 1,VAR_2->columns,VAR_20);
  /* COMMENT_39 */
                                                
    
  VAR_11=VAR_22;
  VAR_9=VAR_19;
  VAR_10=VAR_20;
  for (VAR_7=0; VAR_7 < (ssize_t) VAR_2->rows; VAR_7++)
  {
    VAR_8=QueueAuthenticPixels(VAR_2,0,VAR_7,VAR_2->columns,1,VAR_1);
    if (VAR_8 == (PixelPacket *) NULL)
      break;
    for (VAR_18=0; VAR_18 < (ssize_t) VAR_2->columns; VAR_18++)
    {
      SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_11++));
      SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_9++));
      SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_10++));
      VAR_8++;
    }
    if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_25)
      break;
    if (VAR_2->previous == (Image *) NULL)
      {
        VAR_3=SetImageProgress(VAR_2,VAR_36,(MagickOffsetType) VAR_7,
                VAR_2->rows);
        if (VAR_3 == VAR_25)
          break;
      }
  }
  VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
  VAR_19=(unsigned char *) RelinquishMagickMemory(VAR_19);
  VAR_22=(unsigned char *) RelinquishMagickMemory(VAR_22);
  if (EOFBlob(VAR_2) != VAR_25)
    ThrowFileException(VAR_1,VAR_29,""UnexpectedEndOfFile"",
      VAR_2->filename);
  (void) CloseBlob(VAR_2);
  if (VAR_0->ping == VAR_25)
    if ((VAR_14 == 1) || (VAR_14 == 3))
      {
        double
          VAR_38;

        Image
          *VAR_39;

        /* COMMENT_42 */
                       
          
        VAR_38=VAR_14 == 1 ? -90.0 : 90.0;
        VAR_39=RotateImage(VAR_2,VAR_38,VAR_1);
        if (VAR_39 != (Image *) NULL)
          {
            VAR_2=DestroyImage(VAR_2);
            VAR_2=VAR_39;
          }
      }
  /* COMMENT_45 */
                                                  
    
  VAR_2->chromaticity.red_primary.x=0.6400f;
  VAR_2->chromaticity.red_primary.y=0.3300f;
  VAR_2->chromaticity.green_primary.x=0.3000f;
  VAR_2->chromaticity.green_primary.y=0.6000f;
  VAR_2->chromaticity.blue_primary.x=0.1500f;
  VAR_2->chromaticity.blue_primary.y=0.0600f;
  VAR_2->chromaticity.white_point.x=0.3127f;
  VAR_2->chromaticity.white_point.y=0.3290f;
  VAR_2->gamma=1.000f/2.200f;
  VAR_2->colorspace=VAR_34;
  if (LocaleCompare(VAR_0->magick,""PCDS"") == 0)
    (void) SetImageColorspace(VAR_2,VAR_35);
  return(GetFirstImageInList(VAR_2));
}",ImageMagick/23071f835d44e661177957fde0add67db7788a69/pcd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -71,12 +71,15 @@
   overview=LocaleNCompare((char *) header,""PCD_OPA"",7) == 0;
   if ((count != (3*0x800)) ||
       ((LocaleNCompare((char *) header+0x800,""PCD"",3) != 0) && (overview == 0)))
-    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+    {
+      header=(unsigned char *) RelinquishMagickMemory(header);
+      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+    }
   rotate=header[0x0e02] & 0x03;
   number_images=(header[10] << 8) | header[11];
+  header=(unsigned char *) RelinquishMagickMemory(header);
   if (number_images > 65535)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
-  header=(unsigned char *) RelinquishMagickMemory(header);
   /*
     Determine resolution by scene specification.
   */
@@ -216,7 +219,7 @@
         }
         image->colorspace=YCCColorspace;
         if (LocaleCompare(image_info->magick,""PCDS"") == 0)
-          SetImageColorspace(image,sRGBColorspace);
+          (void) SetImageColorspace(image,sRGBColorspace);
         if (j < (ssize_t) number_images)
           {
             /*
@@ -370,6 +373,6 @@
   image->gamma=1.000f/2.200f;
   image->colorspace=YCCColorspace;
   if (LocaleCompare(image_info->magick,""PCDS"") == 0)
-    SetImageColorspace(image,sRGBColorspace);
+    (void) SetImageColorspace(image,sRGBColorspace);
   return(GetFirstImageInList(image));
 }","{'deleted_lines': ['    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '  header=(unsigned char *) RelinquishMagickMemory(header);', '          SetImageColorspace(image,sRGBColorspace);', '    SetImageColorspace(image,sRGBColorspace);'], 'added_lines': ['    {', '      header=(unsigned char *) RelinquishMagickMemory(header);', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '    }', '  header=(unsigned char *) RelinquishMagickMemory(header);', '          (void) SetImageColorspace(image,sRGBColorspace);', '    (void) SetImageColorspace(image,sRGBColorspace);']}",True,"In ImageMagick 7.0.5-5, the ReadPCDImage function in pcd.c allows attackers to cause a denial of service (memory leak) via a crafted file.",6.5,MEDIUM,1,valid,2017-04-26T21:07:38Z,1
CVE-2017-18222,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"net: hns: fix ethtool_get_strings overflow in hns driver

hns_get_sset_count() returns HNS_NET_STATS_CNT and the data space allocated
is not enough for ethtool_get_strings(), which will cause random memory
corruption.

When SLAB and DEBUG_SLAB are both enabled, memory corruptions like the
the following can be observed without this patch:
[   43.115200] Slab corruption (Not tainted): Acpi-ParseExt start=ffff801fb0b69030, len=80
[   43.115206] Redzone: 0x9f911029d006462/0x5f78745f31657070.
[   43.115208] Last user: [<5f7272655f746b70>](0x5f7272655f746b70)
[   43.115214] 010: 70 70 65 31 5f 74 78 5f 70 6b 74 00 6b 6b 6b 6b  ppe1_tx_pkt.kkkk
[   43.115217] 030: 70 70 65 31 5f 74 78 5f 70 6b 74 5f 6f 6b 00 6b  ppe1_tx_pkt_ok.k
[   43.115218] Next obj: start=ffff801fb0b69098, len=80
[   43.115220] Redzone: 0x706d655f6f666966/0x9f911029d74e35b.
[   43.115229] Last user: [<ffff0000084b11b0>](acpi_os_release_object+0x28/0x38)
[   43.115231] 000: 74 79 00 6b 6b 6b 6b 6b 70 70 65 31 5f 74 78 5f  ty.kkkkkppe1_tx_
[   43.115232] 010: 70 6b 74 5f 65 72 72 5f 63 73 75 6d 5f 66 61 69  pkt_err_csum_fai

Signed-off-by: Timmy Li <lixiaoping3@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",412b65d15a7f8a93794653968308fc100f2aa87c,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,drivers/net/ethernet/hisilicon/hns/hns_dsaf_rcb.c,hns_rcb_get_ring_sset_count,"int hns_rcb_get_ring_sset_count(int stringset)
{
if (stringset == ETH_SS_STATS)
return HNS_RING_STATIC_REG_NUM;
return 0;
}","int hns_rcb_get_ring_sset_count(int VAR_0)
{
if (VAR_0 == VAR_1)
return VAR_2;
return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_rcb.c/vul/before/0.json,"int hns_rcb_get_ring_sset_count(int stringset)
{
	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
		return HNS_RING_STATIC_REG_NUM;

	return 0;
}","int hns_rcb_get_ring_sset_count(int VAR_0)
{
	if (VAR_0 == VAR_1 || VAR_0 == VAR_2)
		return VAR_3;

	return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_rcb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 int hns_rcb_get_ring_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return HNS_RING_STATIC_REG_NUM;
 
 	return 0;","{'deleted_lines': ['\tif (stringset == ETH_SS_STATS)'], 'added_lines': ['\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)']}",True,"In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.",7.8,HIGH,2,valid,2017-05-02T02:46:52Z,1
CVE-2017-18222,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"net: hns: fix ethtool_get_strings overflow in hns driver

hns_get_sset_count() returns HNS_NET_STATS_CNT and the data space allocated
is not enough for ethtool_get_strings(), which will cause random memory
corruption.

When SLAB and DEBUG_SLAB are both enabled, memory corruptions like the
the following can be observed without this patch:
[   43.115200] Slab corruption (Not tainted): Acpi-ParseExt start=ffff801fb0b69030, len=80
[   43.115206] Redzone: 0x9f911029d006462/0x5f78745f31657070.
[   43.115208] Last user: [<5f7272655f746b70>](0x5f7272655f746b70)
[   43.115214] 010: 70 70 65 31 5f 74 78 5f 70 6b 74 00 6b 6b 6b 6b  ppe1_tx_pkt.kkkk
[   43.115217] 030: 70 70 65 31 5f 74 78 5f 70 6b 74 5f 6f 6b 00 6b  ppe1_tx_pkt_ok.k
[   43.115218] Next obj: start=ffff801fb0b69098, len=80
[   43.115220] Redzone: 0x706d655f6f666966/0x9f911029d74e35b.
[   43.115229] Last user: [<ffff0000084b11b0>](acpi_os_release_object+0x28/0x38)
[   43.115231] 000: 74 79 00 6b 6b 6b 6b 6b 70 70 65 31 5f 74 78 5f  ty.kkkkkppe1_tx_
[   43.115232] 010: 70 6b 74 5f 65 72 72 5f 63 73 75 6d 5f 66 61 69  pkt_err_csum_fai

Signed-off-by: Timmy Li <lixiaoping3@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",412b65d15a7f8a93794653968308fc100f2aa87c,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,drivers/net/ethernet/hisilicon/hns/hns_dsaf_ppe.c,hns_ppe_get_sset_count,"int hns_ppe_get_sset_count(int stringset)
{
if (stringset == ETH_SS_STATS)
return ETH_PPE_STATIC_NUM;
return 0;
}","int hns_ppe_get_sset_count(int VAR_0)
{
if (VAR_0 == VAR_1)
return VAR_2;
return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_ppe.c/vul/before/0.json,"int hns_ppe_get_sset_count(int stringset)
{
	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
		return ETH_PPE_STATIC_NUM;
	return 0;
}","int hns_ppe_get_sset_count(int VAR_0)
{
	if (VAR_0 == VAR_1 || VAR_0 == VAR_2)
		return VAR_3;
	return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_ppe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 int hns_ppe_get_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ETH_PPE_STATIC_NUM;
 	return 0;
 }","{'deleted_lines': ['\tif (stringset == ETH_SS_STATS)'], 'added_lines': ['\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)']}",True,"In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.",7.8,HIGH,2,valid,2017-05-02T02:46:52Z,1
CVE-2017-18222,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"net: hns: fix ethtool_get_strings overflow in hns driver

hns_get_sset_count() returns HNS_NET_STATS_CNT and the data space allocated
is not enough for ethtool_get_strings(), which will cause random memory
corruption.

When SLAB and DEBUG_SLAB are both enabled, memory corruptions like the
the following can be observed without this patch:
[   43.115200] Slab corruption (Not tainted): Acpi-ParseExt start=ffff801fb0b69030, len=80
[   43.115206] Redzone: 0x9f911029d006462/0x5f78745f31657070.
[   43.115208] Last user: [<5f7272655f746b70>](0x5f7272655f746b70)
[   43.115214] 010: 70 70 65 31 5f 74 78 5f 70 6b 74 00 6b 6b 6b 6b  ppe1_tx_pkt.kkkk
[   43.115217] 030: 70 70 65 31 5f 74 78 5f 70 6b 74 5f 6f 6b 00 6b  ppe1_tx_pkt_ok.k
[   43.115218] Next obj: start=ffff801fb0b69098, len=80
[   43.115220] Redzone: 0x706d655f6f666966/0x9f911029d74e35b.
[   43.115229] Last user: [<ffff0000084b11b0>](acpi_os_release_object+0x28/0x38)
[   43.115231] 000: 74 79 00 6b 6b 6b 6b 6b 70 70 65 31 5f 74 78 5f  ty.kkkkkppe1_tx_
[   43.115232] 010: 70 6b 74 5f 65 72 72 5f 63 73 75 6d 5f 66 61 69  pkt_err_csum_fai

Signed-off-by: Timmy Li <lixiaoping3@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",412b65d15a7f8a93794653968308fc100f2aa87c,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c,hns_xgmac_get_sset_count,"static int hns_xgmac_get_sset_count(int stringset)
{
if (stringset == ETH_SS_STATS)
return ARRAY_SIZE(g_xgmac_stats_string);
return 0;
}","static int hns_xgmac_get_sset_count(int VAR_0)
{
if (VAR_0 == VAR_1)
return ARRAY_SIZE(VAR_2);
return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_xgmac.c/vul/before/0.json,"static int hns_xgmac_get_sset_count(int stringset)
{
	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
		return ARRAY_SIZE(g_xgmac_stats_string);

	return 0;
}","static int hns_xgmac_get_sset_count(int VAR_0)
{
	if (VAR_0 == VAR_1 || VAR_0 == VAR_2)
		return ARRAY_SIZE(VAR_3);

	return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_xgmac.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int hns_xgmac_get_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ARRAY_SIZE(g_xgmac_stats_string);
 
 	return 0;","{'deleted_lines': ['\tif (stringset == ETH_SS_STATS)'], 'added_lines': ['\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)']}",True,"In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.",7.8,HIGH,2,valid,2017-05-02T02:46:52Z,1
CVE-2017-18222,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"net: hns: fix ethtool_get_strings overflow in hns driver

hns_get_sset_count() returns HNS_NET_STATS_CNT and the data space allocated
is not enough for ethtool_get_strings(), which will cause random memory
corruption.

When SLAB and DEBUG_SLAB are both enabled, memory corruptions like the
the following can be observed without this patch:
[   43.115200] Slab corruption (Not tainted): Acpi-ParseExt start=ffff801fb0b69030, len=80
[   43.115206] Redzone: 0x9f911029d006462/0x5f78745f31657070.
[   43.115208] Last user: [<5f7272655f746b70>](0x5f7272655f746b70)
[   43.115214] 010: 70 70 65 31 5f 74 78 5f 70 6b 74 00 6b 6b 6b 6b  ppe1_tx_pkt.kkkk
[   43.115217] 030: 70 70 65 31 5f 74 78 5f 70 6b 74 5f 6f 6b 00 6b  ppe1_tx_pkt_ok.k
[   43.115218] Next obj: start=ffff801fb0b69098, len=80
[   43.115220] Redzone: 0x706d655f6f666966/0x9f911029d74e35b.
[   43.115229] Last user: [<ffff0000084b11b0>](acpi_os_release_object+0x28/0x38)
[   43.115231] 000: 74 79 00 6b 6b 6b 6b 6b 70 70 65 31 5f 74 78 5f  ty.kkkkkppe1_tx_
[   43.115232] 010: 70 6b 74 5f 65 72 72 5f 63 73 75 6d 5f 66 61 69  pkt_err_csum_fai

Signed-off-by: Timmy Li <lixiaoping3@huawei.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",412b65d15a7f8a93794653968308fc100f2aa87c,https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c,drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c,hns_gmac_get_sset_count,"static int hns_gmac_get_sset_count(int stringset)
{
if (stringset == ETH_SS_STATS)
return ARRAY_SIZE(g_gmac_stats_string);
return 0;
}","static int hns_gmac_get_sset_count(int VAR_0)
{
if (VAR_0 == VAR_1)
return ARRAY_SIZE(VAR_2);
return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_gmac.c/vul/before/0.json,"static int hns_gmac_get_sset_count(int stringset)
{
	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
		return ARRAY_SIZE(g_gmac_stats_string);

	return 0;
}","static int hns_gmac_get_sset_count(int VAR_0)
{
	if (VAR_0 == VAR_1 || VAR_0 == VAR_2)
		return ARRAY_SIZE(VAR_3);

	return 0;
}",torvalds/linux/412b65d15a7f8a93794653968308fc100f2aa87c/hns_dsaf_gmac.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int hns_gmac_get_sset_count(int stringset)
 {
-	if (stringset == ETH_SS_STATS)
+	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ARRAY_SIZE(g_gmac_stats_string);
 
 	return 0;","{'deleted_lines': ['\tif (stringset == ETH_SS_STATS)'], 'added_lines': ['\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)']}",True,"In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings.",7.8,HIGH,2,valid,2017-05-02T02:46:52Z,1
CVE-2017-9439,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,Fixed various leaks reported in #460.,6c6abed989ea4a3ef472db65ab487c1809a3a718,https://github.com/ImageMagick/ImageMagick/commit/6c6abed989ea4a3ef472db65ab487c1809a3a718,coders/pdb.c,ReadPDBImage,"static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
unsigned char
attributes,
tag[3];
Image
*image;
IndexPacket
index;
MagickBooleanType
status;
PDBImage
pdb_image;
PDBInfo
pdb_info;
register IndexPacket
*indexes;
register ssize_t
x;
register PixelPacket
*q;
register unsigned char
*p;
size_t
bits_per_pixel,
num_pad_bytes,
one,
packets;
ssize_t
count,
img_offset,
comment_offset = 0,
y;
unsigned char
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);
if (count != sizeof(pdb_info.name))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pdb_info.attributes=(short) ReadBlobMSBShort(image);
pdb_info.version=(short) ReadBlobMSBShort(image);
pdb_info.create_time=ReadBlobMSBLong(image);
pdb_info.modify_time=ReadBlobMSBLong(image);
pdb_info.archive_time=ReadBlobMSBLong(image);
pdb_info.modify_number=ReadBlobMSBLong(image);
pdb_info.application_info=ReadBlobMSBLong(image);
pdb_info.sort_info=ReadBlobMSBLong(image);
(void) ReadBlob(image,4,(unsigned char *) pdb_info.type);
(void) ReadBlob(image,4,(unsigned char *) pdb_info.id);
pdb_info.seed=ReadBlobMSBLong(image);
pdb_info.next_record=ReadBlobMSBLong(image);
pdb_info.number_records=(short) ReadBlobMSBShort(image);
if ((memcmp(pdb_info.type,""vIMG"",4) != 0) ||
(memcmp(pdb_info.id,""View"",4) != 0))
if (pdb_info.next_record != 0)
ThrowReaderException(CoderError,""MultipleRecordListNotSupported"");
img_offset=(ssize_t) ReadBlobMSBSignedLong(image);
attributes=(unsigned char) (ReadBlobByte(image));
(void) attributes;
count=ReadBlob(image,3,(unsigned char *) tag);
if (count != 3  ||  memcmp(tag,""\x6f\x80\x00"",3) != 0)
ThrowReaderException(CorruptImageError,""CorruptImage"");
if (pdb_info.number_records > 1)
{
comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);
attributes=(unsigned char) (ReadBlobByte(image));
count=ReadBlob(image,3,(unsigned char *) tag);
if (count != 3  ||  memcmp(tag,""\x6f\x80\x01"",3) != 0)
ThrowReaderException(CorruptImageError,""CorruptImage"");
}
num_pad_bytes = (size_t) (img_offset - TellBlob( image ));
while (num_pad_bytes-- != 0)
{
int
c;
c=ReadBlobByte(image);
if (c == EOF)
break;
}
count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);
if (count != sizeof(pdb_image.name))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pdb_image.version=ReadBlobByte(image);
pdb_image.type=(unsigned char) ReadBlobByte(image);
pdb_image.reserved_1=ReadBlobMSBLong(image);
pdb_image.note=ReadBlobMSBLong(image);
pdb_image.x_last=(short) ReadBlobMSBShort(image);
pdb_image.y_last=(short) ReadBlobMSBShort(image);
pdb_image.reserved_2=ReadBlobMSBLong(image);
pdb_image.x_anchor=ReadBlobMSBShort(image);
pdb_image.y_anchor=ReadBlobMSBShort(image);
pdb_image.width=(short) ReadBlobMSBShort(image);
pdb_image.height=(short) ReadBlobMSBShort(image);
image->columns=(size_t) pdb_image.width;
image->rows=(size_t) pdb_image.height;
image->depth=8;
image->storage_class=PseudoClass;
bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;
one=1;
if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
packets=(bits_per_pixel*image->columns+7)/8;
pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*
sizeof(*pixels));
if (pixels == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
switch (pdb_image.version & 0x07)
{
case 0:
{
image->compression=NoCompression;
count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);
break;
}
case 1:
{
image->compression=RLECompression;
if (!DecodeImage(image, pixels, packets * image -> rows))
ThrowReaderException( CorruptImageError, ""RLEDecoderError"" );
break;
}
default:
ThrowReaderException(CorruptImageError,
""UnrecognizedImageCompressionType"" );
}
p=pixels;
switch (bits_per_pixel)
{
case 1:
{
int
bit;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=0; bit < 8; bit++)
{
index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01);
SetPixelIndex(indexes+x+bit,index);
}
p++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
(void) SyncImage(image);
break;
}
case 2:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
for (x=0; x < (ssize_t) image->columns-3; x+=4)
{
index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03));
SetPixelIndex(indexes+x,index);
index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03));
SetPixelIndex(indexes+x+1,index);
index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03));
SetPixelIndex(indexes+x+2,index);
index=ConstrainColormapIndex(image,3UL-((*p) & 0x03));
SetPixelIndex(indexes+x+3,index);
p++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
(void) SyncImage(image);
break;
}
case 4:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
for (x=0; x < (ssize_t) image->columns-1; x+=2)
{
index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f));
SetPixelIndex(indexes+x,index);
index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f));
SetPixelIndex(indexes+x+1,index);
p++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
(void) SyncImage(image);
break;
}
default:
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
if (EOFBlob(image) != MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
if (pdb_info.number_records > 1)
{
char
*comment;
int
c;
register char
*p;
size_t
length;
num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));
while (num_pad_bytes--) ReadBlobByte( image );
c=ReadBlobByte(image);
length=MaxTextExtent;
comment=AcquireString((char *) NULL);
for (p=comment; c != EOF; p++)
{
if ((size_t) (p-comment+MaxTextExtent) >= length)
{
*p='\0';
length<<=1;
length+=MaxTextExtent;
comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent,
sizeof(*comment));
if (comment == (char *) NULL)
break;
p=comment+strlen(comment);
}
*p=c;
c=ReadBlobByte(image);
}
*p='\0';
if (comment == (char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) SetImageProperty(image,""comment"",comment);
comment=DestroyString(comment);
}
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadPDBImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
unsigned char
VAR_2,
VAR_3[3];
Image
*VAR_4;
IndexPacket
VAR_5;
MagickBooleanType
VAR_6;
PDBImage
VAR_7;
PDBInfo
VAR_8;
register IndexPacket
*VAR_9;
register ssize_t
VAR_10;
register PixelPacket
*VAR_11;
register unsigned char
*VAR_12;
size_t
VAR_13,
VAR_14,
VAR_15,
VAR_16;
ssize_t
VAR_17,
VAR_18,
VAR_19 = 0,
VAR_20;
unsigned char
*VAR_21;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_22);
if (VAR_0->debug != VAR_23)
(void) LogMagickEvent(VAR_24,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_22);
VAR_4=AcquireImage(VAR_0);
VAR_6=OpenBlob(VAR_0,VAR_4,VAR_25,VAR_1);
if (VAR_6 == VAR_23)
{
VAR_4=DestroyImageList(VAR_4);
return((Image *) NULL);
}
VAR_17=ReadBlob(VAR_4,sizeof(VAR_8.name),(unsigned char *) VAR_8.name);
if (VAR_17 != sizeof(VAR_8.name))
ThrowReaderException(VAR_26,""ImproperImageHeader"");
VAR_8.attributes=(short) ReadBlobMSBShort(VAR_4);
VAR_8.version=(short) ReadBlobMSBShort(VAR_4);
VAR_8.create_time=ReadBlobMSBLong(VAR_4);
VAR_8.modify_time=ReadBlobMSBLong(VAR_4);
VAR_8.archive_time=ReadBlobMSBLong(VAR_4);
VAR_8.modify_number=ReadBlobMSBLong(VAR_4);
VAR_8.application_info=ReadBlobMSBLong(VAR_4);
VAR_8.sort_info=ReadBlobMSBLong(VAR_4);
(void) ReadBlob(VAR_4,4,(unsigned char *) VAR_8.type);
(void) ReadBlob(VAR_4,4,(unsigned char *) VAR_8.id);
VAR_8.seed=ReadBlobMSBLong(VAR_4);
VAR_8.next_record=ReadBlobMSBLong(VAR_4);
VAR_8.number_records=(short) ReadBlobMSBShort(VAR_4);
if ((memcmp(VAR_8.type,""vIMG"",4) != 0) ||
(memcmp(VAR_8.id,""View"",4) != 0))
if (VAR_8.next_record != 0)
ThrowReaderException(VAR_27,""MultipleRecordListNotSupported"");
VAR_18=(ssize_t) ReadBlobMSBSignedLong(VAR_4);
VAR_2=(unsigned char) (ReadBlobByte(VAR_4));
(void) VAR_2;
VAR_17=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
if (VAR_17 != 3  ||  memcmp(VAR_3,""\x6f\x80\x00"",3) != 0)
ThrowReaderException(VAR_26,""CorruptImage"");
if (VAR_8.number_records > 1)
{
VAR_19=(ssize_t) ReadBlobMSBSignedLong(VAR_4);
VAR_2=(unsigned char) (ReadBlobByte(VAR_4));
VAR_17=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
if (VAR_17 != 3  ||  memcmp(VAR_3,""\x6f\x80\x01"",3) != 0)
ThrowReaderException(VAR_26,""CorruptImage"");
}
VAR_14 = (size_t) (VAR_18 - TellBlob( VAR_4 ));
while (VAR_14-- != 0)
{
int
VAR_28;
VAR_28=ReadBlobByte(VAR_4);
if (VAR_28 == VAR_29)
break;
}
VAR_17=ReadBlob(VAR_4,sizeof(VAR_7.name),(unsigned char *) VAR_7.name);
if (VAR_17 != sizeof(VAR_7.name))
ThrowReaderException(VAR_26,""ImproperImageHeader"");
VAR_7.version=ReadBlobByte(VAR_4);
VAR_7.type=(unsigned char) ReadBlobByte(VAR_4);
VAR_7.reserved_1=ReadBlobMSBLong(VAR_4);
VAR_7.note=ReadBlobMSBLong(VAR_4);
VAR_7.x_last=(short) ReadBlobMSBShort(VAR_4);
VAR_7.y_last=(short) ReadBlobMSBShort(VAR_4);
VAR_7.reserved_2=ReadBlobMSBLong(VAR_4);
VAR_7.x_anchor=ReadBlobMSBShort(VAR_4);
VAR_7.y_anchor=ReadBlobMSBShort(VAR_4);
VAR_7.width=(short) ReadBlobMSBShort(VAR_4);
VAR_7.height=(short) ReadBlobMSBShort(VAR_4);
VAR_4->columns=(size_t) VAR_7.width;
VAR_4->rows=(size_t) VAR_7.height;
VAR_4->depth=8;
VAR_4->storage_class=VAR_30;
VAR_13=VAR_7.type == 0 ? 2UL : VAR_7.type == 2 ? 4UL : 1UL;
VAR_15=1;
if (AcquireImageColormap(VAR_4,VAR_15 << VAR_13) == VAR_23)
ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
if (VAR_0->ping != VAR_23)
{
(void) CloseBlob(VAR_4);
return(GetFirstImageInList(VAR_4));
}
VAR_6=SetImageExtent(VAR_4,VAR_4->columns,VAR_4->rows);
if (VAR_6 == VAR_23)
{
InheritException(VAR_1,&VAR_4->exception);
return(DestroyImageList(VAR_4));
}
VAR_16=(VAR_13*VAR_4->columns+7)/8;
VAR_21=(unsigned char *) AcquireQuantumMemory(VAR_16+257UL,VAR_4->rows*
sizeof(*VAR_21));
if (VAR_21 == (unsigned char *) NULL)
ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
switch (VAR_7.version & 0x07)
{
case 0:
{
VAR_4->compression=VAR_32;
VAR_17=(ssize_t) ReadBlob(VAR_4, VAR_16 * VAR_4 -> rows, VAR_21);
break;
}
case 1:
{
VAR_4->compression=VAR_33;
if (!DecodeImage(VAR_4, VAR_21, VAR_16 * VAR_4 -> rows))
ThrowReaderException( VAR_26, ""RLEDecoderError"" );
break;
}
default:
ThrowReaderException(VAR_26,
""UnrecognizedImageCompressionType"" );
}
VAR_12=VAR_21;
switch (VAR_13)
{
case 1:
{
int
VAR_34;
for (VAR_20=0; VAR_20 < (ssize_t) VAR_4->rows; VAR_20++)
{
VAR_11=QueueAuthenticPixels(VAR_4,0,VAR_20,VAR_4->columns,1,VAR_1);
if (VAR_11 == (PixelPacket *) NULL)
break;
VAR_9=GetAuthenticIndexQueue(VAR_4);
for (VAR_10=0; VAR_10 < ((ssize_t) VAR_4->columns-7); VAR_10+=8)
{
for (VAR_34=0; VAR_34 < 8; VAR_34++)
{
VAR_5=(IndexPacket) (*VAR_12 & (0x80 >> VAR_34) ? 0x00 : 0x01);
SetPixelIndex(VAR_9+VAR_10+VAR_34,VAR_5);
}
VAR_12++;
}
if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_23)
break;
VAR_6=SetImageProgress(VAR_4,VAR_35,(MagickOffsetType) VAR_20,
VAR_4->rows);
if (VAR_6 == VAR_23)
break;
}
(void) SyncImage(VAR_4);
break;
}
case 2:
{
for (VAR_20=0; VAR_20 < (ssize_t) VAR_4->rows; VAR_20++)
{
VAR_11=QueueAuthenticPixels(VAR_4,0,VAR_20,VAR_4->columns,1,VAR_1);
if (VAR_11 == (PixelPacket *) NULL)
break;
VAR_9=GetAuthenticIndexQueue(VAR_4);
for (VAR_10=0; VAR_10 < (ssize_t) VAR_4->columns-3; VAR_10+=4)
{
VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12 >> 6) & 0x03));
SetPixelIndex(VAR_9+VAR_10,VAR_5);
VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12 >> 4) & 0x03));
SetPixelIndex(VAR_9+VAR_10+1,VAR_5);
VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12 >> 2) & 0x03));
SetPixelIndex(VAR_9+VAR_10+2,VAR_5);
VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12) & 0x03));
SetPixelIndex(VAR_9+VAR_10+3,VAR_5);
VAR_12++;
}
if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_23)
break;
VAR_6=SetImageProgress(VAR_4,VAR_35,(MagickOffsetType) VAR_20,
VAR_4->rows);
if (VAR_6 == VAR_23)
break;
}
(void) SyncImage(VAR_4);
break;
}
case 4:
{
for (VAR_20=0; VAR_20 < (ssize_t) VAR_4->rows; VAR_20++)
{
VAR_11=QueueAuthenticPixels(VAR_4,0,VAR_20,VAR_4->columns,1,VAR_1);
if (VAR_11 == (PixelPacket *) NULL)
break;
VAR_9=GetAuthenticIndexQueue(VAR_4);
for (VAR_10=0; VAR_10 < (ssize_t) VAR_4->columns-1; VAR_10+=2)
{
VAR_5=ConstrainColormapIndex(VAR_4,15UL-((*VAR_12 >> 4) & 0x0f));
SetPixelIndex(VAR_9+VAR_10,VAR_5);
VAR_5=ConstrainColormapIndex(VAR_4,15UL-((*VAR_12) & 0x0f));
SetPixelIndex(VAR_9+VAR_10+1,VAR_5);
VAR_12++;
}
if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_23)
break;
VAR_6=SetImageProgress(VAR_4,VAR_35,(MagickOffsetType) VAR_20,
VAR_4->rows);
if (VAR_6 == VAR_23)
break;
}
(void) SyncImage(VAR_4);
break;
}
default:
ThrowReaderException(VAR_26,""ImproperImageHeader"");
}
VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
if (EOFBlob(VAR_4) != VAR_23)
ThrowFileException(VAR_1,VAR_26,""UnexpectedEndOfFile"",
VAR_4->filename);
if (VAR_8.number_records > 1)
{
char
*VAR_36;
int
VAR_28;
register char
*VAR_12;
size_t
VAR_37;
VAR_14 = (size_t) (VAR_19 - TellBlob( VAR_4 ));
while (VAR_14--) ReadBlobByte( VAR_4 );
VAR_28=ReadBlobByte(VAR_4);
VAR_37=VAR_38;
VAR_36=AcquireString((char *) NULL);
for (VAR_12=VAR_36; VAR_28 != VAR_29; VAR_12++)
{
if ((size_t) (VAR_12-VAR_36+VAR_38) >= VAR_37)
{
*VAR_12='\0';
VAR_37<<=1;
VAR_37+=VAR_38;
VAR_36=(char *) ResizeQuantumMemory(VAR_36,VAR_37+VAR_38,
sizeof(*VAR_36));
if (VAR_36 == (char *) NULL)
break;
VAR_12=VAR_36+strlen(VAR_36);
}
*VAR_12=VAR_28;
VAR_28=ReadBlobByte(VAR_4);
}
*VAR_12='\0';
if (VAR_36 == (char *) NULL)
ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
(void) SetImageProperty(VAR_4,""comment"",VAR_36);
VAR_36=DestroyString(VAR_36);
}
(void) CloseBlob(VAR_4);
return(GetFirstImageInList(VAR_4));
}",ImageMagick/6c6abed989ea4a3ef472db65ab487c1809a3a718/pdb.c/vul/before/0.json,"static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  unsigned char
    attributes,
    tag[3];

  Image
    *image;

  IndexPacket
    index;

  MagickBooleanType
    status;

  PDBImage
    pdb_image;

  PDBInfo
    pdb_info;

  register IndexPacket
    *indexes;

  register ssize_t
    x;

  register PixelPacket
    *q;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    num_pad_bytes,
    one,
    packets;

  ssize_t
    count,
    img_offset,
    comment_offset = 0,
    y;

  unsigned char
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a PDB image file.
  */
  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);
  if (count != sizeof(pdb_info.name))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  pdb_info.attributes=(short) ReadBlobMSBShort(image);
  pdb_info.version=(short) ReadBlobMSBShort(image);
  pdb_info.create_time=ReadBlobMSBLong(image);
  pdb_info.modify_time=ReadBlobMSBLong(image);
  pdb_info.archive_time=ReadBlobMSBLong(image);
  pdb_info.modify_number=ReadBlobMSBLong(image);
  pdb_info.application_info=ReadBlobMSBLong(image);
  pdb_info.sort_info=ReadBlobMSBLong(image);
  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);
  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);
  pdb_info.seed=ReadBlobMSBLong(image);
  pdb_info.next_record=ReadBlobMSBLong(image);
  pdb_info.number_records=(short) ReadBlobMSBShort(image);
  if ((memcmp(pdb_info.type,""vIMG"",4) != 0) ||
      (memcmp(pdb_info.id,""View"",4) != 0))
  if (pdb_info.next_record != 0)
    ThrowReaderException(CoderError,""MultipleRecordListNotSupported"");
  /*
    Read record header.
  */
  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);
  attributes=(unsigned char) (ReadBlobByte(image));
  (void) attributes;
  count=ReadBlob(image,3,(unsigned char *) tag);
  if (count != 3  ||  memcmp(tag,""\x6f\x80\x00"",3) != 0)
    ThrowReaderException(CorruptImageError,""CorruptImage"");
  if (pdb_info.number_records > 1)
    {
      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);
      attributes=(unsigned char) (ReadBlobByte(image));
      count=ReadBlob(image,3,(unsigned char *) tag);
      if (count != 3  ||  memcmp(tag,""\x6f\x80\x01"",3) != 0)
        ThrowReaderException(CorruptImageError,""CorruptImage"");
    }
  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));
  while (num_pad_bytes-- != 0)
  {
    int
      c;

    c=ReadBlobByte(image);
    if (c == EOF)
      break;
  }
  /*
    Read image header.
  */
  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);
  if (count != sizeof(pdb_image.name))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  pdb_image.version=ReadBlobByte(image);
  pdb_image.type=(unsigned char) ReadBlobByte(image);
  pdb_image.reserved_1=ReadBlobMSBLong(image);
  pdb_image.note=ReadBlobMSBLong(image);
  pdb_image.x_last=(short) ReadBlobMSBShort(image);
  pdb_image.y_last=(short) ReadBlobMSBShort(image);
  pdb_image.reserved_2=ReadBlobMSBLong(image);
  pdb_image.x_anchor=ReadBlobMSBShort(image);
  pdb_image.y_anchor=ReadBlobMSBShort(image);
  pdb_image.width=(short) ReadBlobMSBShort(image);
  pdb_image.height=(short) ReadBlobMSBShort(image);
  /*
    Initialize image structure.
  */
  image->columns=(size_t) pdb_image.width;
  image->rows=(size_t) pdb_image.height;
  image->depth=8;
  image->storage_class=PseudoClass;
  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;
  one=1;
  if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  packets=(bits_per_pixel*image->columns+7)/8;
  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*
    sizeof(*pixels));
  if (pixels == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  switch (pdb_image.version & 0x07)
  {
    case 0:
    {
      image->compression=NoCompression;
      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);
      break;
    }
    case 1:
    {
      image->compression=RLECompression;
      if (!DecodeImage(image,pixels,packets*image->rows))
        {
          pixels=(unsigned char *) RelinquishMagickMemory(pixels);
          ThrowReaderException( CorruptImageError,""RLEDecoderError"");
        }
      break;
    }
    default:
      {
        pixels=(unsigned char *) RelinquishMagickMemory(pixels);
        ThrowReaderException(CorruptImageError,
          ""UnrecognizedImageCompressionType"");
      }
  }
  p=pixels;
  switch (bits_per_pixel)
  {
    case 1:
    {
      int
        bit;

      /*
        Read 1-bit PDB image.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=0; bit < 8; bit++)
          {
            index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01);
            SetPixelIndex(indexes+x+bit,index);
          }
          p++;
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      (void) SyncImage(image);
      break;
    }
    case 2:
    {
      /*
        Read 2-bit PDB image.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < (ssize_t) image->columns-3; x+=4)
        {
          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03));
          SetPixelIndex(indexes+x,index);
          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03));
          SetPixelIndex(indexes+x+1,index);
          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03));
          SetPixelIndex(indexes+x+2,index);
          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03));
          SetPixelIndex(indexes+x+3,index);
          p++;
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      (void) SyncImage(image);
      break;
    }
    case 4:
    {
      /*
        Read 4-bit PDB image.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < (ssize_t) image->columns-1; x+=2)
        {
          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f));
          SetPixelIndex(indexes+x,index);
          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f));
          SetPixelIndex(indexes+x+1,index);
          p++;
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      (void) SyncImage(image);
      break;
    }
    default:
    {
      pixels=(unsigned char *) RelinquishMagickMemory(pixels);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
  }
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  if (pdb_info.number_records > 1)
    {
      char
        *comment;

      int
        c;

      register char
        *p;

      size_t
        length;

      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));
      while (num_pad_bytes--) ReadBlobByte( image );

      /*
        Read comment.
      */
      c=ReadBlobByte(image);
      length=MaxTextExtent;
      comment=AcquireString((char *) NULL);
      for (p=comment; c != EOF; p++)
      {
        if ((size_t) (p-comment+MaxTextExtent) >= length)
          {
            *p='\0';
            length<<=1;
            length+=MaxTextExtent;
            comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent,
              sizeof(*comment));
            if (comment == (char *) NULL)
              break;
            p=comment+strlen(comment);
          }
        *p=c;
        c=ReadBlobByte(image);
      }
      *p='\0';
      if (comment == (char *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      (void) SetImageProperty(image,""comment"",comment);
      comment=DestroyString(comment);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadPDBImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  unsigned char
    VAR_2,
    VAR_3[3];

  Image
    *VAR_4;

  IndexPacket
    VAR_5;

  MagickBooleanType
    VAR_6;

  PDBImage
    VAR_7;

  PDBInfo
    VAR_8;

  register IndexPacket
    *VAR_9;

  register ssize_t
    VAR_10;

  register PixelPacket
    *VAR_11;

  register unsigned char
    *VAR_12;

  size_t
    VAR_13,
    VAR_14,
    VAR_15,
    VAR_16;

  ssize_t
    VAR_17,
    VAR_18,
    VAR_19 = 0,
    VAR_20;

  unsigned char
    *VAR_21;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_22);
  if (VAR_0->debug != VAR_23)
    (void) LogMagickEvent(VAR_24,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_22);
  VAR_4=AcquireImage(VAR_0);
  VAR_6=OpenBlob(VAR_0,VAR_4,VAR_25,VAR_1);
  if (VAR_6 == VAR_23)
    {
      VAR_4=DestroyImageList(VAR_4);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                                       
    
  VAR_17=ReadBlob(VAR_4,sizeof(VAR_8.name),(unsigned char *) VAR_8.name);
  if (VAR_17 != sizeof(VAR_8.name))
    ThrowReaderException(VAR_26,""ImproperImageHeader"");
  VAR_8.attributes=(short) ReadBlobMSBShort(VAR_4);
  VAR_8.version=(short) ReadBlobMSBShort(VAR_4);
  VAR_8.create_time=ReadBlobMSBLong(VAR_4);
  VAR_8.modify_time=ReadBlobMSBLong(VAR_4);
  VAR_8.archive_time=ReadBlobMSBLong(VAR_4);
  VAR_8.modify_number=ReadBlobMSBLong(VAR_4);
  VAR_8.application_info=ReadBlobMSBLong(VAR_4);
  VAR_8.sort_info=ReadBlobMSBLong(VAR_4);
  (void) ReadBlob(VAR_4,4,(unsigned char *) VAR_8.type);
  (void) ReadBlob(VAR_4,4,(unsigned char *) VAR_8.id);
  VAR_8.seed=ReadBlobMSBLong(VAR_4);
  VAR_8.next_record=ReadBlobMSBLong(VAR_4);
  VAR_8.number_records=(short) ReadBlobMSBShort(VAR_4);
  if ((memcmp(VAR_8.type,""vIMG"",4) != 0) ||
      (memcmp(VAR_8.id,""View"",4) != 0))
  if (VAR_8.next_record != 0)
    ThrowReaderException(VAR_27,""MultipleRecordListNotSupported"");
  /* COMMENT_6 */
                       
    
  VAR_18=(ssize_t) ReadBlobMSBSignedLong(VAR_4);
  VAR_2=(unsigned char) (ReadBlobByte(VAR_4));
  (void) VAR_2;
  VAR_17=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
  if (VAR_17 != 3  ||  memcmp(VAR_3,""\x6f\x80\x00"",3) != 0)
    ThrowReaderException(VAR_26,""CorruptImage"");
  if (VAR_8.number_records > 1)
    {
      VAR_19=(ssize_t) ReadBlobMSBSignedLong(VAR_4);
      VAR_2=(unsigned char) (ReadBlobByte(VAR_4));
      VAR_17=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
      if (VAR_17 != 3  ||  memcmp(VAR_3,""\x6f\x80\x01"",3) != 0)
        ThrowReaderException(VAR_26,""CorruptImage"");
    }
  VAR_14 = (size_t) (VAR_18 - TellBlob( VAR_4 ));
  while (VAR_14-- != 0)
  {
    int
      VAR_28;

    VAR_28=ReadBlobByte(VAR_4);
    if (VAR_28 == VAR_29)
      break;
  }
  /* COMMENT_9 */
                      
    
  VAR_17=ReadBlob(VAR_4,sizeof(VAR_7.name),(unsigned char *) VAR_7.name);
  if (VAR_17 != sizeof(VAR_7.name))
    ThrowReaderException(VAR_26,""ImproperImageHeader"");
  VAR_7.version=ReadBlobByte(VAR_4);
  VAR_7.type=(unsigned char) ReadBlobByte(VAR_4);
  VAR_7.reserved_1=ReadBlobMSBLong(VAR_4);
  VAR_7.note=ReadBlobMSBLong(VAR_4);
  VAR_7.x_last=(short) ReadBlobMSBShort(VAR_4);
  VAR_7.y_last=(short) ReadBlobMSBShort(VAR_4);
  VAR_7.reserved_2=ReadBlobMSBLong(VAR_4);
  VAR_7.x_anchor=ReadBlobMSBShort(VAR_4);
  VAR_7.y_anchor=ReadBlobMSBShort(VAR_4);
  VAR_7.width=(short) ReadBlobMSBShort(VAR_4);
  VAR_7.height=(short) ReadBlobMSBShort(VAR_4);
  /* COMMENT_12 */
                               
    
  VAR_4->columns=(size_t) VAR_7.width;
  VAR_4->rows=(size_t) VAR_7.height;
  VAR_4->depth=8;
  VAR_4->storage_class=VAR_30;
  VAR_13=VAR_7.type == 0 ? 2UL : VAR_7.type == 2 ? 4UL : 1UL;
  VAR_15=1;
  if (AcquireImageColormap(VAR_4,VAR_15 << VAR_13) == VAR_23)
    ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
  if (VAR_0->ping != VAR_23)
    {
      (void) CloseBlob(VAR_4);
      return(GetFirstImageInList(VAR_4));
    }
  VAR_6=SetImageExtent(VAR_4,VAR_4->columns,VAR_4->rows);
  if (VAR_6 == VAR_23)
    {
      InheritException(VAR_1,&VAR_4->exception);
      return(DestroyImageList(VAR_4));
    }
  VAR_16=(VAR_13*VAR_4->columns+7)/8;
  VAR_21=(unsigned char *) AcquireQuantumMemory(VAR_16+257UL,VAR_4->rows*
    sizeof(*VAR_21));
  if (VAR_21 == (unsigned char *) NULL)
    ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
  switch (VAR_7.version & 0x07)
  {
    case 0:
    {
      VAR_4->compression=VAR_32;
      VAR_17=(ssize_t) ReadBlob(VAR_4,VAR_16*VAR_4->rows,VAR_21);
      break;
    }
    case 1:
    {
      VAR_4->compression=VAR_33;
      if (!DecodeImage(VAR_4,VAR_21,VAR_16*VAR_4->rows))
        {
          VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
          ThrowReaderException( VAR_26,""RLEDecoderError"");
        }
      break;
    }
    default:
      {
        VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
        ThrowReaderException(VAR_26,
          ""UnrecognizedImageCompressionType"");
      }
  }
  VAR_12=VAR_21;
  switch (VAR_13)
  {
    case 1:
    {
      int
        VAR_34;

      /* COMMENT_15 */
                             
        
      for (VAR_20=0; VAR_20 < (ssize_t) VAR_4->rows; VAR_20++)
      {
        VAR_11=QueueAuthenticPixels(VAR_4,0,VAR_20,VAR_4->columns,1,VAR_1);
        if (VAR_11 == (PixelPacket *) NULL)
          break;
        VAR_9=GetAuthenticIndexQueue(VAR_4);
        for (VAR_10=0; VAR_10 < ((ssize_t) VAR_4->columns-7); VAR_10+=8)
        {
          for (VAR_34=0; VAR_34 < 8; VAR_34++)
          {
            VAR_5=(IndexPacket) (*VAR_12 & (0x80 >> VAR_34) ? 0x00 : 0x01);
            SetPixelIndex(VAR_9+VAR_10+VAR_34,VAR_5);
          }
          VAR_12++;
        }
        if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_23)
          break;
        VAR_6=SetImageProgress(VAR_4,VAR_35,(MagickOffsetType) VAR_20,
          VAR_4->rows);
        if (VAR_6 == VAR_23)
          break;
      }
      (void) SyncImage(VAR_4);
      break;
    }
    case 2:
    {
      /* COMMENT_18 */
                             
        
      for (VAR_20=0; VAR_20 < (ssize_t) VAR_4->rows; VAR_20++)
      {
        VAR_11=QueueAuthenticPixels(VAR_4,0,VAR_20,VAR_4->columns,1,VAR_1);
        if (VAR_11 == (PixelPacket *) NULL)
          break;
        VAR_9=GetAuthenticIndexQueue(VAR_4);
        for (VAR_10=0; VAR_10 < (ssize_t) VAR_4->columns-3; VAR_10+=4)
        {
          VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12 >> 6) & 0x03));
          SetPixelIndex(VAR_9+VAR_10,VAR_5);
          VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12 >> 4) & 0x03));
          SetPixelIndex(VAR_9+VAR_10+1,VAR_5);
          VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12 >> 2) & 0x03));
          SetPixelIndex(VAR_9+VAR_10+2,VAR_5);
          VAR_5=ConstrainColormapIndex(VAR_4,3UL-((*VAR_12) & 0x03));
          SetPixelIndex(VAR_9+VAR_10+3,VAR_5);
          VAR_12++;
        }
        if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_23)
          break;
        VAR_6=SetImageProgress(VAR_4,VAR_35,(MagickOffsetType) VAR_20,
          VAR_4->rows);
        if (VAR_6 == VAR_23)
          break;
      }
      (void) SyncImage(VAR_4);
      break;
    }
    case 4:
    {
      /* COMMENT_21 */
                             
        
      for (VAR_20=0; VAR_20 < (ssize_t) VAR_4->rows; VAR_20++)
      {
        VAR_11=QueueAuthenticPixels(VAR_4,0,VAR_20,VAR_4->columns,1,VAR_1);
        if (VAR_11 == (PixelPacket *) NULL)
          break;
        VAR_9=GetAuthenticIndexQueue(VAR_4);
        for (VAR_10=0; VAR_10 < (ssize_t) VAR_4->columns-1; VAR_10+=2)
        {
          VAR_5=ConstrainColormapIndex(VAR_4,15UL-((*VAR_12 >> 4) & 0x0f));
          SetPixelIndex(VAR_9+VAR_10,VAR_5);
          VAR_5=ConstrainColormapIndex(VAR_4,15UL-((*VAR_12) & 0x0f));
          SetPixelIndex(VAR_9+VAR_10+1,VAR_5);
          VAR_12++;
        }
        if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_23)
          break;
        VAR_6=SetImageProgress(VAR_4,VAR_35,(MagickOffsetType) VAR_20,
          VAR_4->rows);
        if (VAR_6 == VAR_23)
          break;
      }
      (void) SyncImage(VAR_4);
      break;
    }
    default:
    {
      VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
      ThrowReaderException(VAR_26,""ImproperImageHeader"");
    }
  }
  VAR_21=(unsigned char *) RelinquishMagickMemory(VAR_21);
  if (EOFBlob(VAR_4) != VAR_23)
    ThrowFileException(VAR_1,VAR_26,""UnexpectedEndOfFile"",
      VAR_4->filename);
  if (VAR_8.number_records > 1)
    {
      char
        *VAR_36;

      int
        VAR_28;

      register char
        *VAR_12;

      size_t
        VAR_37;

      VAR_14 = (size_t) (VAR_19 - TellBlob( VAR_4 ));
      while (VAR_14--) ReadBlobByte( VAR_4 );

      /* COMMENT_24 */
                     
        
      VAR_28=ReadBlobByte(VAR_4);
      VAR_37=VAR_38;
      VAR_36=AcquireString((char *) NULL);
      for (VAR_12=VAR_36; VAR_28 != VAR_29; VAR_12++)
      {
        if ((size_t) (VAR_12-VAR_36+VAR_38) >= VAR_37)
          {
            *VAR_12='\0';
            VAR_37<<=1;
            VAR_37+=VAR_38;
            VAR_36=(char *) ResizeQuantumMemory(VAR_36,VAR_37+VAR_38,
              sizeof(*VAR_36));
            if (VAR_36 == (char *) NULL)
              break;
            VAR_12=VAR_36+strlen(VAR_36);
          }
        *VAR_12=VAR_28;
        VAR_28=ReadBlobByte(VAR_4);
      }
      *VAR_12='\0';
      if (VAR_36 == (char *) NULL)
        ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
      (void) SetImageProperty(VAR_4,""comment"",VAR_36);
      VAR_36=DestroyString(VAR_36);
    }
  (void) CloseBlob(VAR_4);
  return(GetFirstImageInList(VAR_4));
}",ImageMagick/6c6abed989ea4a3ef472db65ab487c1809a3a718/pdb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -162,19 +162,25 @@
     case 0:
     {
       image->compression=NoCompression;
-      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);
+      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);
       break;
     }
     case 1:
     {
       image->compression=RLECompression;
-      if (!DecodeImage(image, pixels, packets * image -> rows))
-        ThrowReaderException( CorruptImageError, ""RLEDecoderError"" );
+      if (!DecodeImage(image,pixels,packets*image->rows))
+        {
+          pixels=(unsigned char *) RelinquishMagickMemory(pixels);
+          ThrowReaderException( CorruptImageError,""RLEDecoderError"");
+        }
       break;
     }
     default:
-      ThrowReaderException(CorruptImageError,
-         ""UnrecognizedImageCompressionType"" );
+      {
+        pixels=(unsigned char *) RelinquishMagickMemory(pixels);
+        ThrowReaderException(CorruptImageError,
+          ""UnrecognizedImageCompressionType"");
+      }
   }
   p=pixels;
   switch (bits_per_pixel)
@@ -275,7 +281,10 @@
       break;
     }
     default:
+    {
+      pixels=(unsigned char *) RelinquishMagickMemory(pixels);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+    }
   }
   pixels=(unsigned char *) RelinquishMagickMemory(pixels);
   if (EOFBlob(image) != MagickFalse)","{'deleted_lines': ['      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);', '      if (!DecodeImage(image, pixels, packets * image -> rows))', '        ThrowReaderException( CorruptImageError, ""RLEDecoderError"" );', '      ThrowReaderException(CorruptImageError,', '         ""UnrecognizedImageCompressionType"" );'], 'added_lines': ['      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);', '      if (!DecodeImage(image,pixels,packets*image->rows))', '        {', '          pixels=(unsigned char *) RelinquishMagickMemory(pixels);', '          ThrowReaderException( CorruptImageError,""RLEDecoderError"");', '        }', '      {', '        pixels=(unsigned char *) RelinquishMagickMemory(pixels);', '        ThrowReaderException(CorruptImageError,', '          ""UnrecognizedImageCompressionType"");', '      }', '    {', '      pixels=(unsigned char *) RelinquishMagickMemory(pixels);', '    }']}",True,"In ImageMagick 7.0.5-5, a memory leak was found in the function ReadPDBImage in coders/pdb.c, which allows attackers to cause a denial of service via a crafted file.",6.5,MEDIUM,1,valid,2017-05-02T06:26:36Z,1
CVE-2017-9440,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,Fixed memory leak reported in #462.,d4e8b9722577547177a2daecee98ea9e5fe54968,https://github.com/ImageMagick/ImageMagick/commit/d4e8b9722577547177a2daecee98ea9e5fe54968,coders/psd.c,ReadPSDChannelZip,"static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,
const ssize_t type,const PSDCompressionType compression,
const size_t compact_size,ExceptionInfo *exception)
{
MagickBooleanType
status;
register unsigned char
*p;
size_t
count,
length,
packet_size,
row_size;
ssize_t
y;
unsigned char
*compact_pixels,
*pixels;
z_stream
stream;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer data is ZIP compressed"");
compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,
sizeof(*compact_pixels));
if (compact_pixels == (unsigned char *) NULL)
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
packet_size=GetPSDPacketSize(image);
row_size=image->columns*packet_size;
count=image->rows*row_size;
pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));
if (pixels == (unsigned char *) NULL)
{
compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
ResetMagickMemory(&stream,0,sizeof(stream));
stream.data_type=Z_BINARY;
(void) ReadBlob(image,compact_size,compact_pixels);
stream.next_in=(Bytef *)compact_pixels;
stream.avail_in=(uInt) compact_size;
stream.next_out=(Bytef *)pixels;
stream.avail_out=(uInt) count;
if (inflateInit(&stream) == Z_OK)
{
int
ret;
while (stream.avail_out > 0)
{
ret=inflate(&stream,Z_SYNC_FLUSH);
if ((ret != Z_OK) && (ret != Z_STREAM_END))
{
compact_pixels=(unsigned char *) RelinquishMagickMemory(
compact_pixels);
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
return(MagickFalse);
}
}
}
if (compression == ZipWithPrediction)
{
p=pixels;
while (count > 0)
{
length=image->columns;
while (--length)
{
if (packet_size == 2)
{
p[2]+=p[0]+((p[1]+p[3]) >> 8);
p[3]+=p[1];
}
else
*(p+1)+=*p;
p+=packet_size;
}
p+=packet_size;
count-=row_size;
}
}
status=MagickTrue;
p=pixels;
for (y=0; y < (ssize_t) image->rows; y++)
{
status=ReadPSDChannelPixels(image,channels,y,type,p,exception);
if (status == MagickFalse)
break;
p+=row_size;
}
compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
return(status);
}","static MagickBooleanType ReadPSDChannelZip(Image *VAR_0,const size_t VAR_1,
const ssize_t VAR_2,const PSDCompressionType VAR_3,
const size_t VAR_4,ExceptionInfo *VAR_5)
{
MagickBooleanType
VAR_6;
register unsigned char
*VAR_7;
size_t
VAR_8,
VAR_9,
VAR_10,
VAR_11;
ssize_t
VAR_12;
unsigned char
*VAR_13,
*VAR_14;
z_stream
VAR_15;
if (VAR_0->debug != VAR_16)
(void) LogMagickEvent(VAR_17,GetMagickModule(),
""      layer data is ZIP compressed"");
VAR_13=(unsigned char *) AcquireQuantumMemory(VAR_4,
sizeof(*VAR_13));
if (VAR_13 == (unsigned char *) NULL)
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_0->filename);
VAR_10=GetPSDPacketSize(VAR_0);
VAR_11=VAR_0->columns*VAR_10;
VAR_8=VAR_0->rows*VAR_11;
VAR_14=(unsigned char *) AcquireQuantumMemory(VAR_8,sizeof(*VAR_14));
if (VAR_14 == (unsigned char *) NULL)
{
VAR_13=(unsigned char *) RelinquishMagickMemory(VAR_13);
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_0->filename);
}
ResetMagickMemory(&VAR_15,0,sizeof(VAR_15));
VAR_15.data_type=VAR_19;
(void) ReadBlob(VAR_0,VAR_4,VAR_13);
VAR_15.next_in=(Bytef *)VAR_13;
VAR_15.avail_in=(uInt) VAR_4;
VAR_15.next_out=(Bytef *)VAR_14;
VAR_15.avail_out=(uInt) VAR_8;
if (inflateInit(&VAR_15) == VAR_20)
{
int
VAR_21;
while (VAR_15.avail_out > 0)
{
VAR_21=inflate(&VAR_15,VAR_22);
if ((VAR_21 != VAR_20) && (VAR_21 != VAR_23))
{
VAR_13=(unsigned char *) RelinquishMagickMemory(
VAR_13);
VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
return(VAR_16);
}
}
}
if (VAR_3 == VAR_24)
{
VAR_7=VAR_14;
while (VAR_8 > 0)
{
VAR_9=VAR_0->columns;
while (--VAR_9)
{
if (VAR_10 == 2)
{
VAR_7[2]+=VAR_7[0]+((VAR_7[1]+VAR_7[3]) >> 8);
VAR_7[3]+=VAR_7[1];
}
else
*(VAR_7+1)+=*VAR_7;
VAR_7+=VAR_10;
}
VAR_7+=VAR_10;
VAR_8-=VAR_11;
}
}
VAR_6=VAR_25;
VAR_7=VAR_14;
for (VAR_12=0; VAR_12 < (ssize_t) VAR_0->rows; VAR_12++)
{
VAR_6=ReadPSDChannelPixels(VAR_0,VAR_1,VAR_12,VAR_2,VAR_7,VAR_5);
if (VAR_6 == VAR_16)
break;
VAR_7+=VAR_11;
}
VAR_13=(unsigned char *) RelinquishMagickMemory(VAR_13);
VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
return(VAR_6);
}",ImageMagick/d4e8b9722577547177a2daecee98ea9e5fe54968/psd.c/vul/before/0.json,"static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,
  const ssize_t type,const PSDCompressionType compression,
  const size_t compact_size,ExceptionInfo *exception)
{
  MagickBooleanType
    status;

  register unsigned char
    *p;

  size_t
    count,
    length,
    packet_size,
    row_size;

  ssize_t
    y;

  unsigned char
    *compact_pixels,
    *pixels;

  z_stream
    stream;

  if (image->debug != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""      layer data is ZIP compressed"");

  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,
    sizeof(*compact_pixels));
  if (compact_pixels == (unsigned char *) NULL)
    ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
      image->filename);

  packet_size=GetPSDPacketSize(image);
  row_size=image->columns*packet_size;
  count=image->rows*row_size;

  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));
  if (pixels == (unsigned char *) NULL)
    {
      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);
      ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
        image->filename);
    }

  ResetMagickMemory(&stream,0,sizeof(stream));
  stream.data_type=Z_BINARY;
  (void) ReadBlob(image,compact_size,compact_pixels);

  stream.next_in=(Bytef *)compact_pixels;
  stream.avail_in=(uInt) compact_size;
  stream.next_out=(Bytef *)pixels;
  stream.avail_out=(uInt) count;

  if (inflateInit(&stream) == Z_OK)
    {
      int
        ret;

      while (stream.avail_out > 0)
      {
        ret=inflate(&stream,Z_SYNC_FLUSH);
        if ((ret != Z_OK) && (ret != Z_STREAM_END))
          {
            (void) inflateEnd(&stream);
            compact_pixels=(unsigned char *) RelinquishMagickMemory(
              compact_pixels);
            pixels=(unsigned char *) RelinquishMagickMemory(pixels);
            return(MagickFalse);
          }
      }
      (void) inflateEnd(&stream);
    }

  if (compression == ZipWithPrediction)
  {
     p=pixels;
     while (count > 0)
     {
       length=image->columns;
       while (--length)
       {
         if (packet_size == 2)
           {
             p[2]+=p[0]+((p[1]+p[3]) >> 8);
             p[3]+=p[1];
           }
         else
          *(p+1)+=*p;
         p+=packet_size;
       }
       p+=packet_size;
       count-=row_size;
     }
  }

  status=MagickTrue;
  p=pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);
    if (status == MagickFalse)
      break;

    p+=row_size;
  }

  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  return(status);
}","static MagickBooleanType ReadPSDChannelZip(Image *VAR_0,const size_t VAR_1,
  const ssize_t VAR_2,const PSDCompressionType VAR_3,
  const size_t VAR_4,ExceptionInfo *VAR_5)
{
  MagickBooleanType
    VAR_6;

  register unsigned char
    *VAR_7;

  size_t
    VAR_8,
    VAR_9,
    VAR_10,
    VAR_11;

  ssize_t
    VAR_12;

  unsigned char
    *VAR_13,
    *VAR_14;

  z_stream
    VAR_15;

  if (VAR_0->debug != VAR_16)
    (void) LogMagickEvent(VAR_17,GetMagickModule(),
       ""      layer data is ZIP compressed"");

  VAR_13=(unsigned char *) AcquireQuantumMemory(VAR_4,
    sizeof(*VAR_13));
  if (VAR_13 == (unsigned char *) NULL)
    ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
      VAR_0->filename);

  VAR_10=GetPSDPacketSize(VAR_0);
  VAR_11=VAR_0->columns*VAR_10;
  VAR_8=VAR_0->rows*VAR_11;

  VAR_14=(unsigned char *) AcquireQuantumMemory(VAR_8,sizeof(*VAR_14));
  if (VAR_14 == (unsigned char *) NULL)
    {
      VAR_13=(unsigned char *) RelinquishMagickMemory(VAR_13);
      ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
        VAR_0->filename);
    }

  ResetMagickMemory(&VAR_15,0,sizeof(VAR_15));
  VAR_15.data_type=VAR_19;
  (void) ReadBlob(VAR_0,VAR_4,VAR_13);

  VAR_15.next_in=(Bytef *)VAR_13;
  VAR_15.avail_in=(uInt) VAR_4;
  VAR_15.next_out=(Bytef *)VAR_14;
  VAR_15.avail_out=(uInt) VAR_8;

  if (inflateInit(&VAR_15) == VAR_20)
    {
      int
        VAR_21;

      while (VAR_15.avail_out > 0)
      {
        VAR_21=inflate(&VAR_15,VAR_22);
        if ((VAR_21 != VAR_20) && (VAR_21 != VAR_23))
          {
            (void) inflateEnd(&VAR_15);
            VAR_13=(unsigned char *) RelinquishMagickMemory(
              VAR_13);
            VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
            return(VAR_16);
          }
      }
      (void) inflateEnd(&VAR_15);
    }

  if (VAR_3 == VAR_24)
  {
     VAR_7=VAR_14;
     while (VAR_8 > 0)
     {
       VAR_9=VAR_0->columns;
       while (--VAR_9)
       {
         if (VAR_10 == 2)
           {
             VAR_7[2]+=VAR_7[0]+((VAR_7[1]+VAR_7[3]) >> 8);
             VAR_7[3]+=VAR_7[1];
           }
         else
          *(VAR_7+1)+=*VAR_7;
         VAR_7+=VAR_10;
       }
       VAR_7+=VAR_10;
       VAR_8-=VAR_11;
     }
  }

  VAR_6=VAR_25;
  VAR_7=VAR_14;
  for (VAR_12=0; VAR_12 < (ssize_t) VAR_0->rows; VAR_12++)
  {
    VAR_6=ReadPSDChannelPixels(VAR_0,VAR_1,VAR_12,VAR_2,VAR_7,VAR_5);
    if (VAR_6 == VAR_16)
      break;

    VAR_7+=VAR_11;
  }

  VAR_13=(unsigned char *) RelinquishMagickMemory(VAR_13);
  VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
  return(VAR_6);
}",ImageMagick/d4e8b9722577547177a2daecee98ea9e5fe54968/psd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -65,12 +65,14 @@
         ret=inflate(&stream,Z_SYNC_FLUSH);
         if ((ret != Z_OK) && (ret != Z_STREAM_END))
           {
+            (void) inflateEnd(&stream);
             compact_pixels=(unsigned char *) RelinquishMagickMemory(
               compact_pixels);
             pixels=(unsigned char *) RelinquishMagickMemory(pixels);
             return(MagickFalse);
           }
       }
+      (void) inflateEnd(&stream);
     }
 
   if (compression == ZipWithPrediction)","{'deleted_lines': [], 'added_lines': ['            (void) inflateEnd(&stream);', '      (void) inflateEnd(&stream);']}",True,"In ImageMagick 7.0.5-5, a memory leak was found in the function ReadPSDChannel in coders/psd.c, which allows attackers to cause a denial of service via a crafted file.",6.5,MEDIUM,1,valid,2017-05-02T07:04:57Z,1
CVE-2017-9992,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"avcodec/dfa: Fix off by 1 error

Fixes out of array access
Fixes: 1345/clusterfuzz-testcase-minimized-6062963045695488

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",f52fbf4f3ed02a7d872d8a102006f29b4421f360,https://github.com/FFmpeg/FFmpeg/commit/f52fbf4f3ed02a7d872d8a102006f29b4421f360,libavcodec/dfa.c,decode_dds1,"static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)
{
const uint8_t *frame_start = frame;
const uint8_t *frame_end   = frame + width * height;
int mask = 0x10000, bitbuf = 0;
int i, v, offset, count, segments;
segments = bytestream2_get_le16(gb);
while (segments--) {
if (bytestream2_get_bytes_left(gb) < 2)
return AVERROR_INVALIDDATA;
if (mask == 0x10000) {
bitbuf = bytestream2_get_le16u(gb);
mask = 1;
}
if (bitbuf & mask) {
v = bytestream2_get_le16(gb);
offset = (v & 0x1FFF) << 2;
count = ((v >> 13) + 2) << 1;
if (frame - frame_start < offset || frame_end - frame < count*2 + width)
return AVERROR_INVALIDDATA;
for (i = 0; i < count; i++) {
frame[0] = frame[1] =
frame[width] = frame[width + 1] = frame[-offset];
frame += 2;
}
} else if (bitbuf & (mask << 1)) {
v = bytestream2_get_le16(gb)*2;
if (frame - frame_end < v)
return AVERROR_INVALIDDATA;
frame += v;
} else {
if (frame_end - frame < width + 3)
return AVERROR_INVALIDDATA;
frame[0] = frame[1] =
frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);
frame += 2;
frame[0] = frame[1] =
frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);
frame += 2;
}
mask <<= 2;
}
return 0;
}","static int decode_dds1(GetByteContext *VAR_0, uint8_t *VAR_1, int VAR_2, int VAR_3)
{
const uint8_t *VAR_4 = VAR_1;
const uint8_t *VAR_5   = VAR_1 + VAR_2 * VAR_3;
int VAR_6 = 0x10000, VAR_7 = 0;
int VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
VAR_12 = bytestream2_get_le16(VAR_0);
while (VAR_12--) {
if (bytestream2_get_bytes_left(VAR_0) < 2)
return VAR_13;
if (VAR_6 == 0x10000) {
VAR_7 = bytestream2_get_le16u(VAR_0);
VAR_6 = 1;
}
if (VAR_7 & VAR_6) {
VAR_9 = bytestream2_get_le16(VAR_0);
VAR_10 = (VAR_9 & 0x1FFF) << 2;
VAR_11 = ((VAR_9 >> 13) + 2) << 1;
if (VAR_1 - VAR_4 < VAR_10 || VAR_5 - VAR_1 < VAR_11*2 + VAR_2)
return VAR_13;
for (VAR_8 = 0; VAR_8 < VAR_11; VAR_8++) {
VAR_1[0] = VAR_1[1] =
VAR_1[VAR_2] = VAR_1[VAR_2 + 1] = VAR_1[-VAR_10];
VAR_1 += 2;
}
} else if (VAR_7 & (VAR_6 << 1)) {
VAR_9 = bytestream2_get_le16(VAR_0)*2;
if (VAR_1 - VAR_5 < VAR_9)
return VAR_13;
VAR_1 += VAR_9;
} else {
if (VAR_5 - VAR_1 < VAR_2 + 3)
return VAR_13;
VAR_1[0] = VAR_1[1] =
VAR_1[VAR_2] = VAR_1[VAR_2 + 1] =  bytestream2_get_byte(VAR_0);
VAR_1 += 2;
VAR_1[0] = VAR_1[1] =
VAR_1[VAR_2] = VAR_1[VAR_2 + 1] =  bytestream2_get_byte(VAR_0);
VAR_1 += 2;
}
VAR_6 <<= 2;
}
return 0;
}",ffmpeg/f52fbf4f3ed02a7d872d8a102006f29b4421f360/dfa.c/vul/before/0.json,"static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)
{
    const uint8_t *frame_start = frame;
    const uint8_t *frame_end   = frame + width * height;
    int mask = 0x10000, bitbuf = 0;
    int i, v, offset, count, segments;

    segments = bytestream2_get_le16(gb);
    while (segments--) {
        if (bytestream2_get_bytes_left(gb) < 2)
            return AVERROR_INVALIDDATA;
        if (mask == 0x10000) {
            bitbuf = bytestream2_get_le16u(gb);
            mask = 1;
        }

        if (bitbuf & mask) {
            v = bytestream2_get_le16(gb);
            offset = (v & 0x1FFF) << 2;
            count = ((v >> 13) + 2) << 1;
            if (frame - frame_start < offset || frame_end - frame < count*2 + width)
                return AVERROR_INVALIDDATA;
            for (i = 0; i < count; i++) {
                frame[0] = frame[1] =
                frame[width] = frame[width + 1] = frame[-offset];

                frame += 2;
            }
        } else if (bitbuf & (mask << 1)) {
            v = bytestream2_get_le16(gb)*2;
            if (frame - frame_end < v)
                return AVERROR_INVALIDDATA;
            frame += v;
        } else {
            if (frame_end - frame < width + 4)
                return AVERROR_INVALIDDATA;
            frame[0] = frame[1] =
            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);
            frame += 2;
            frame[0] = frame[1] =
            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);
            frame += 2;
        }
        mask <<= 2;
    }

    return 0;
}","static int decode_dds1(GetByteContext *VAR_0, uint8_t *VAR_1, int VAR_2, int VAR_3)
{
    const uint8_t *VAR_4 = VAR_1;
    const uint8_t *VAR_5   = VAR_1 + VAR_2 * VAR_3;
    int VAR_6 = 0x10000, VAR_7 = 0;
    int VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;

    VAR_12 = bytestream2_get_le16(VAR_0);
    while (VAR_12--) {
        if (bytestream2_get_bytes_left(VAR_0) < 2)
            return VAR_13;
        if (VAR_6 == 0x10000) {
            VAR_7 = bytestream2_get_le16u(VAR_0);
            VAR_6 = 1;
        }

        if (VAR_7 & VAR_6) {
            VAR_9 = bytestream2_get_le16(VAR_0);
            VAR_10 = (VAR_9 & 0x1FFF) << 2;
            VAR_11 = ((VAR_9 >> 13) + 2) << 1;
            if (VAR_1 - VAR_4 < VAR_10 || VAR_5 - VAR_1 < VAR_11*2 + VAR_2)
                return VAR_13;
            for (VAR_8 = 0; VAR_8 < VAR_11; VAR_8++) {
                VAR_1[0] = VAR_1[1] =
                VAR_1[VAR_2] = VAR_1[VAR_2 + 1] = VAR_1[-VAR_10];

                VAR_1 += 2;
            }
        } else if (VAR_7 & (VAR_6 << 1)) {
            VAR_9 = bytestream2_get_le16(VAR_0)*2;
            if (VAR_1 - VAR_5 < VAR_9)
                return VAR_13;
            VAR_1 += VAR_9;
        } else {
            if (VAR_5 - VAR_1 < VAR_2 + 4)
                return VAR_13;
            VAR_1[0] = VAR_1[1] =
            VAR_1[VAR_2] = VAR_1[VAR_2 + 1] =  bytestream2_get_byte(VAR_0);
            VAR_1 += 2;
            VAR_1[0] = VAR_1[1] =
            VAR_1[VAR_2] = VAR_1[VAR_2 + 1] =  bytestream2_get_byte(VAR_0);
            VAR_1 += 2;
        }
        VAR_6 <<= 2;
    }

    return 0;
}",ffmpeg/f52fbf4f3ed02a7d872d8a102006f29b4421f360/dfa.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,7 +32,7 @@
                 return AVERROR_INVALIDDATA;
             frame += v;
         } else {
-            if (frame_end - frame < width + 3)
+            if (frame_end - frame < width + 4)
                 return AVERROR_INVALIDDATA;
             frame[0] = frame[1] =
             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);","{'deleted_lines': ['            if (frame_end - frame < width + 3)'], 'added_lines': ['            if (frame_end - frame < width + 4)']}",True,"Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",8.8,HIGH,2,valid,2017-05-05T18:42:11Z,1
CVE-2017-11141,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ImageMagick,Fix moment when quantum info is acquired to fix issue reported in #469.,353b942bd83da7e1356ba99c942848bd1871ee9f,https://github.com/ImageMagick/ImageMagick/commit/353b942bd83da7e1356ba99c942848bd1871ee9f,coders/mat.c,ReadMATImage,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image *image, *image2=NULL,
*rotated_image;
PixelPacket *q;
unsigned int status;
MATHeader MATLAB_HDR;
size_t size;
size_t CellType;
QuantumInfo *quantum_info;
ImageInfo *clone_info;
int i;
ssize_t ldblk;
unsigned char *BImgBuff = NULL;
double MinVal, MaxVal;
size_t Unknown6;
unsigned z, z2;
unsigned Frames;
int logging;
int sample_size;
MagickOffsetType filepos=0x80;
BlobInfo *blob;
size_t one;
unsigned int (*ReadBlobXXXLong)(Image *image);
unsigned short (*ReadBlobXXXShort)(Image *image);
void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
quantum_info=(QuantumInfo *) NULL;
image = AcquireImage(image_info);
status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
clone_info=CloneImageInfo(image_info);
if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
{
image2=ReadMATImageV4(image_info,image,exception);
if (image2  == NULL)
goto MATLAB_KO;
image=image2;
goto END_OF_READING;
}
MATLAB_HDR.Version = ReadBlobLSBShort(image);
if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
{
ReadBlobXXXLong = ReadBlobLSBLong;
ReadBlobXXXShort = ReadBlobLSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesLSB;
ReadBlobFloatsXXX = ReadBlobFloatsLSB;
image->endian = LSBEndian;
}
else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
{
ReadBlobXXXLong = ReadBlobMSBLong;
ReadBlobXXXShort = ReadBlobMSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesMSB;
ReadBlobFloatsXXX = ReadBlobFloatsMSB;
image->endian = MSBEndian;
}
else
goto MATLAB_KO;    
if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
filepos = TellBlob(image);
while(!EOFBlob(image)) 
{
Frames = 1;
(void) SeekBlob(image,filepos,SEEK_SET);
MATLAB_HDR.DataType = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
filepos += MATLAB_HDR.ObjectSize + 4 + 4;
image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
if(MATLAB_HDR.DataType == miCOMPRESSED)
{
image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
if(image2==NULL) continue;
MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
}
#endif
if(MATLAB_HDR.DataType!=miMATRIX) continue;  
MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
if(image!=image2)
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
switch(MATLAB_HDR.DimFlag)
{
case  8: z2=z=1; break;      
case 12: z2=z = ReadBlobXXXLong(image2);  
Unknown6 = ReadBlobXXXLong(image2);
(void) Unknown6;
if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: z2=z = ReadBlobXXXLong(image2);  
if(z!=3 && z!=1)
ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
Frames = ReadBlobXXXLong(image2);
if (Frames == 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
break;
default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
}
MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
MATLAB_HDR.StructureClass != mxINT8_CLASS &&
MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
MATLAB_HDR.StructureClass != mxINT16_CLASS &&
MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
MATLAB_HDR.StructureClass != mxINT32_CLASS &&
MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
MATLAB_HDR.StructureClass != mxINT64_CLASS &&
MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
switch (MATLAB_HDR.NameFlag)
{
case 0:
size = ReadBlobXXXLong(image2);  
size = 4 * (ssize_t) ((size + 3 + 1) / 4);
(void) SeekBlob(image2, size, SEEK_CUR);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(image2, 4, (unsigned char *) &size); 
break;
default:
goto MATLAB_KO;
}
CellType = ReadBlobXXXLong(image2);    
if (logging)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) CellType);
(void) ReadBlob(image2, 4, (unsigned char *) &size);     
NEXT_FRAME:
switch (CellType)
{
case miINT8:
case miUINT8:
sample_size = 8;
if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
image->depth = 1;
else
image->depth = 8;         
ldblk = (ssize_t) MATLAB_HDR.SizeX;
break;
case miINT16:
case miUINT16:
sample_size = 16;
image->depth = 16;        
ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
break;
case miINT32:
case miUINT32:
sample_size = 32;
image->depth = 32;        
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miINT64:
case miUINT64:
sample_size = 64;
image->depth = 64;        
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
case miSINGLE:
sample_size = 32;
image->depth = 32;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{              
}
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miDOUBLE:
sample_size = 64;
image->depth = 64;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
RestoreMSCWarning
ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{                         
}
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
default:
ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
}
(void) sample_size;
image->columns = MATLAB_HDR.SizeX;
image->rows = MATLAB_HDR.SizeY;
quantum_info=AcquireQuantumInfo(clone_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
one=1;
image->colors = one << image->depth;
if (image->columns == 0 || image->rows == 0)
goto MATLAB_KO;
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
{
SetImageColorspace(image,GRAYColorspace);
image->type=GrayscaleType;
}
if (image_info->ping)
{
size_t temp = image->columns;
image->columns = image->rows;
image->rows = temp;
goto done_reading; 
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
if (BImgBuff == NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
MinVal = 0;
MaxVal = 0;
if (CellType==miDOUBLE || CellType==miSINGLE)        
{
CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
}
if(z==1) z=0; 
do
{
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto done_reading;    
}
if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
{
FixLogical((unsigned char *)BImgBuff,ldblk);
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
{
ImportQuantumPixelsFailed:
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
break;
}
}
else
{
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
goto ImportQuantumPixelsFailed;
if (z<=1 &&       
(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
FixSignedValues(q,MATLAB_HDR.SizeX);
}
if (!SyncAuthenticPixels(image,exception))
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
}
} while(z-- >= 2);
ExitLoop:
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{        
CellType = ReadBlobXXXLong(image2);    
i = ReadBlobXXXLong(image2);           
if (CellType==miDOUBLE || CellType==miSINGLE)
{
CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
}
if (CellType==miDOUBLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
}
if (CellType==miSINGLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
}
}
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
image->type=GrayscaleType;
if (image->depth == 1)
image->type=BilevelType;
if(image2==image)
image2 = NULL;    
rotated_image = RotateImage(image, 90.0, exception);
if (rotated_image != (Image *) NULL)
{
rotated_image->page.x=0;
rotated_image->page.y=0;
blob = rotated_image->blob;
rotated_image->blob = image->blob;
rotated_image->colors = image->colors;
image->blob = blob;
AppendImageToList(&image,rotated_image);
DeleteImageFromList(&image);
}
done_reading:
if(image2!=NULL)
if(image2!=image)
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
}
}
AcquireNextImage(image_info,image);
if (image->next == (Image *) NULL) break;
image=SyncNextImageInList(image);
image->columns=image->rows=0;
image->colors=0;
RelinquishMagickMemory(BImgBuff);
BImgBuff = NULL;
if(--Frames>0)
{
z = z2;
if(image2==NULL) image2 = image;
goto NEXT_FRAME;
}
if(image2!=NULL)
if(image2!=image)   
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) unlink(clone_info->filename);
}
}
}
}
RelinquishMagickMemory(BImgBuff);
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
clone_info=DestroyImageInfo(clone_info);
CloseBlob(image);
{
Image *p;
ssize_t scene=0;
p=image;
image=NULL;
while (p != (Image *) NULL)
{
Image *tmp=p;
if ((p->rows == 0) || (p->columns == 0)) {
p=p->previous;
DeleteImageFromList(&tmp);
} else {
image=p;
p=p->previous;
}
}
for (p=image; p != (Image *) NULL; p=p->next)
p->scene=scene++;
}
if(clone_info != NULL)  
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
DestroyImageInfo(clone_info);
clone_info = NULL;
}
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
if(image==NULL)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image *VAR_2, *VAR_3=NULL,
*VAR_4;
PixelPacket *VAR_5;
unsigned int VAR_6;
MATHeader VAR_7;
size_t VAR_8;
size_t VAR_9;
QuantumInfo *VAR_10;
ImageInfo *VAR_11;
int VAR_12;
ssize_t VAR_13;
unsigned char *VAR_14 = NULL;
double VAR_15, VAR_16;
size_t VAR_17;
unsigned VAR_18, VAR_19;
unsigned VAR_20;
int VAR_21;
int VAR_22;
MagickOffsetType VAR_23=0x80;
BlobInfo *VAR_24;
size_t VAR_25;
unsigned int (*VAR_26)(Image *VAR_2);
unsigned short (*VAR_27)(Image *VAR_2);
void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_32);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_32);
VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");
VAR_10=(QuantumInfo *) NULL;
VAR_2 = AcquireImage(VAR_0);
VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
if (VAR_6 == VAR_35)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_11=CloneImageInfo(VAR_0);
if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
{
VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
if (VAR_3  == NULL)
goto MATLAB_KO;
VAR_2=VAR_3;
goto END_OF_READING;
}
VAR_7.Version = ReadBlobLSBShort(VAR_2);
if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
{
VAR_26 = VAR_37;
VAR_27 = VAR_38;
VAR_28 = VAR_39;
VAR_31 = VAR_40;
VAR_2->endian = VAR_41;
}
else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
{
VAR_26 = VAR_42;
VAR_27 = VAR_43;
VAR_28 = VAR_44;
VAR_31 = VAR_45;
VAR_2->endian = VAR_46;
}
else
goto MATLAB_KO;    
if (strncmp(VAR_7.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(VAR_36,""ImproperImageHeader"");
VAR_23 = TellBlob(VAR_2);
while(!EOFBlob(VAR_2)) 
{
VAR_20 = 1;
(void) SeekBlob(VAR_2,VAR_23,VAR_47);
VAR_7.DataType = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
VAR_7.ObjectSize = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
VAR_23 += VAR_7.ObjectSize + 4 + 4;
VAR_3 = VAR_2;
#if defined(VAR_48)
if(VAR_7.DataType == VAR_49)
{
VAR_3 = DecompressBlock(VAR_2,VAR_7.ObjectSize,VAR_11,VAR_1);
if(VAR_3==NULL) continue;
VAR_7.DataType = VAR_26(VAR_3); 
}
#endif
if(VAR_7.DataType!=VAR_50) continue;  
VAR_7.unknown1 = VAR_26(VAR_3);
VAR_7.unknown2 = VAR_26(VAR_3);
VAR_7.unknown5 = VAR_26(VAR_3);
VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;
VAR_7.unknown3 = VAR_26(VAR_3);
if(VAR_2!=VAR_3)
VAR_7.unknown4 = VAR_26(VAR_3);  
VAR_7.unknown4 = VAR_26(VAR_3);
VAR_7.DimFlag = VAR_26(VAR_3);
VAR_7.SizeX = VAR_26(VAR_3);
VAR_7.SizeY = VAR_26(VAR_3);
switch(VAR_7.DimFlag)
{
case  8: VAR_19=VAR_18=1; break;      
case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  
VAR_17 = VAR_26(VAR_3);
(void) VAR_17;
if(VAR_18!=3) ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  
if(VAR_18!=3 && VAR_18!=1)
ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
VAR_20 = VAR_26(VAR_3);
if (VAR_20 == 0)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
break;
default: ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
}
VAR_7.Flag1 = VAR_27(VAR_3);
VAR_7.NameFlag = VAR_27(VAR_3);
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
if (VAR_7.StructureClass != VAR_52 &&
VAR_7.StructureClass != VAR_53 &&    
VAR_7.StructureClass != VAR_54 &&    
VAR_7.StructureClass != VAR_55 &&
VAR_7.StructureClass != VAR_56 &&    
VAR_7.StructureClass != VAR_57 &&
VAR_7.StructureClass != VAR_58 &&    
VAR_7.StructureClass != VAR_59 &&
VAR_7.StructureClass != VAR_60 &&    
VAR_7.StructureClass != VAR_61 &&
VAR_7.StructureClass != VAR_62)    
ThrowReaderException(VAR_51,""UnsupportedCellTypeInTheMatrix"");
switch (VAR_7.NameFlag)
{
case 0:
VAR_8 = VAR_26(VAR_3);  
VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
(void) SeekBlob(VAR_3, VAR_8, VAR_63);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); 
break;
default:
goto MATLAB_KO;
}
VAR_9 = VAR_26(VAR_3);    
if (VAR_21)
(void) LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     
NEXT_FRAME:
switch (VAR_9)
{
case VAR_64:
case VAR_65:
VAR_22 = 8;
if(VAR_7.StructureFlag & VAR_66)
VAR_2->depth = 1;
else
VAR_2->depth = 8;         
VAR_13 = (ssize_t) VAR_7.SizeX;
break;
case VAR_67:
case VAR_68:
VAR_22 = 16;
VAR_2->depth = 16;        
VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
break;
case VAR_69:
case VAR_70:
VAR_22 = 32;
VAR_2->depth = 32;        
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_71:
case VAR_72:
VAR_22 = 64;
VAR_2->depth = 64;        
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
case VAR_73:
VAR_22 = 32;
VAR_2->depth = 32;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
if (VAR_7.StructureFlag & VAR_74)
{              
}
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_75:
VAR_22 = 64;
VAR_2->depth = 64;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
VAR_76
ThrowReaderException(VAR_51, ""IncompatibleSizeOfDouble"");
if (VAR_7.StructureFlag & VAR_74)
{                         
}
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
default:
ThrowReaderException(VAR_51, ""UnsupportedCellTypeInTheMatrix"");
}
(void) VAR_22;
VAR_2->columns = VAR_7.SizeX;
VAR_2->rows = VAR_7.SizeY;
VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
if (VAR_10 == (QuantumInfo *) NULL)
ThrowReaderException(VAR_77,""MemoryAllocationFailed"");
VAR_25=1;
VAR_2->colors = VAR_25 << VAR_2->depth;
if (VAR_2->columns == 0 || VAR_2->rows == 0)
goto MATLAB_KO;
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_74) == 0))
{
SetImageColorspace(VAR_2,VAR_78);
VAR_2->type=VAR_79;
}
if (VAR_0->ping)
{
size_t VAR_80 = VAR_2->columns;
VAR_2->columns = VAR_2->rows;
VAR_2->rows = VAR_80;
goto done_reading; 
}
VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
if (VAR_6 == VAR_35)
{
InheritException(VAR_1,&VAR_2->exception);
return(DestroyImageList(VAR_2));
}
VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    
if (VAR_14 == NULL)
ThrowReaderException(VAR_77,""MemoryAllocationFailed"");
(void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));
VAR_15 = 0;
VAR_16 = 0;
if (VAR_9==VAR_75 || VAR_9==VAR_73)        
{
CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
}
if(VAR_18==1) VAR_18=0; 
do
{
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
if (VAR_5 == (PixelPacket *) NULL)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto done_reading;    
}
if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
if((VAR_9==VAR_64 || VAR_9==VAR_65) && (VAR_7.StructureFlag & VAR_66))
{
FixLogical((unsigned char *)VAR_14,VAR_13);
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
{
ImportQuantumPixelsFailed:
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
break;
}
}
else
{
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
goto ImportQuantumPixelsFailed;
if (VAR_18<=1 &&       
(VAR_9==VAR_64 || VAR_9==VAR_67 || VAR_9==VAR_69 || VAR_9==VAR_71))
FixSignedValues(VAR_5,VAR_7.SizeX);
}
if (!SyncAuthenticPixels(VAR_2,VAR_1))
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
}
} while(VAR_18-- >= 2);
ExitLoop:
if (VAR_7.StructureFlag & VAR_74)
{        
VAR_9 = VAR_26(VAR_3);    
VAR_12 = VAR_26(VAR_3);           
if (VAR_9==VAR_75 || VAR_9==VAR_73)
{
CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
}
if (VAR_9==VAR_75)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_28(VAR_3, VAR_13, (double *)VAR_14);
InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
if (VAR_9==VAR_73)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_31(VAR_3, VAR_13, (float *)VAR_14);
InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
}
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_74) == 0))
VAR_2->type=VAR_79;
if (VAR_2->depth == 1)
VAR_2->type=VAR_82;
if(VAR_3==VAR_2)
VAR_3 = NULL;    
VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
if (VAR_4 != (Image *) NULL)
{
VAR_4->page.x=0;
VAR_4->page.y=0;
VAR_24 = VAR_4->blob;
VAR_4->blob = VAR_2->blob;
VAR_4->colors = VAR_2->colors;
VAR_2->blob = VAR_24;
AppendImageToList(&VAR_2,VAR_4);
DeleteImageFromList(&VAR_2);
}
done_reading:
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
}
}
AcquireNextImage(VAR_0,VAR_2);
if (VAR_2->next == (Image *) NULL) break;
VAR_2=SyncNextImageInList(VAR_2);
VAR_2->columns=VAR_2->rows=0;
VAR_2->colors=0;
RelinquishMagickMemory(VAR_14);
VAR_14 = NULL;
if(--VAR_20>0)
{
VAR_18 = VAR_19;
if(VAR_3==NULL) VAR_3 = VAR_2;
goto NEXT_FRAME;
}
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)   
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) unlink(VAR_11->filename);
}
}
}
}
RelinquishMagickMemory(VAR_14);
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
VAR_11=DestroyImageInfo(VAR_11);
CloseBlob(VAR_2);
{
Image *VAR_83;
ssize_t VAR_84=0;
VAR_83=VAR_2;
VAR_2=NULL;
while (VAR_83 != (Image *) NULL)
{
Image *VAR_85=VAR_83;
if ((VAR_83->rows == 0) || (VAR_83->columns == 0)) {
VAR_83=VAR_83->previous;
DeleteImageFromList(&VAR_85);
} else {
VAR_2=VAR_83;
VAR_83=VAR_83->previous;
}
}
for (VAR_83=VAR_2; VAR_83 != (Image *) NULL; VAR_83=VAR_83->next)
VAR_83->scene=VAR_84++;
}
if(VAR_11 != NULL)  
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
DestroyImageInfo(VAR_11);
VAR_11 = NULL;
}
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
if(VAR_2==NULL)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
return (VAR_2);
}",ImageMagick/353b942bd83da7e1356ba99c942848bd1871ee9f/mat.c/vul/before/0.json,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  quantum_info=(QuantumInfo *) NULL;
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=CloneImageInfo(image_info);
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
      /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image *VAR_2, *VAR_3=NULL,
   *VAR_4;
  PixelPacket *VAR_5;

  unsigned int VAR_6;
  MATHeader VAR_7;
  size_t VAR_8;
  size_t VAR_9;
  QuantumInfo *VAR_10;
  ImageInfo *VAR_11;
  int VAR_12;
  ssize_t VAR_13;
  unsigned char *VAR_14 = NULL;
  double VAR_15, VAR_16;
  size_t VAR_17;
  unsigned VAR_18, VAR_19;
  unsigned VAR_20;
  int VAR_21;
  int VAR_22;
  MagickOffsetType VAR_23=0x80;
  BlobInfo *VAR_24;
  size_t VAR_25;

  unsigned int (*VAR_26)(Image *VAR_2);
  unsigned short (*VAR_27)(Image *VAR_2);
  void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
  void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);


  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_32);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_32);
  VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");

  /* COMMENT_0 */
                     
     
  VAR_10=(QuantumInfo *) NULL;
  VAR_2 = AcquireImage(VAR_0);

  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
  if (VAR_6 == VAR_35)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                       
     
  VAR_11=CloneImageInfo(VAR_0);
  if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
    {
      VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
      if (VAR_3  == NULL)
        goto MATLAB_KO;
      VAR_2=VAR_3;
      goto END_OF_READING;
    }
  VAR_7.Version = ReadBlobLSBShort(VAR_2);
  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");

  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
        VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
  if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
  {
    VAR_26 = VAR_37;
    VAR_27 = VAR_38;
    VAR_28 = VAR_39;
    VAR_31 = VAR_40;
    VAR_2->endian = VAR_41;
  }
  else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
  {
    VAR_26 = VAR_42;
    VAR_27 = VAR_43;
    VAR_28 = VAR_44;
    VAR_31 = VAR_45;
    VAR_2->endian = VAR_46;
  }
  else
    goto MATLAB_KO;    /* COMMENT_6 */

  if (strncmp(VAR_7.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(VAR_36,""ImproperImageHeader"");

  VAR_23 = TellBlob(VAR_2);
  while(!EOFBlob(VAR_2)) /* COMMENT_7 */
  {
    VAR_20 = 1;
    (void) SeekBlob(VAR_2,VAR_23,VAR_47);
    /* COMMENT_8 */

    VAR_7.DataType = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    VAR_7.ObjectSize = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    VAR_23 += VAR_7.ObjectSize + 4 + 4;

    VAR_3 = VAR_2;
#if defined(VAR_48)
    if(VAR_7.DataType == VAR_49)
    {
      VAR_3 = DecompressBlock(VAR_2,VAR_7.ObjectSize,VAR_11,VAR_1);
      if(VAR_3==NULL) continue;
      VAR_7.DataType = VAR_26(VAR_3); /* COMMENT_9 */
    }
#endif

    if(VAR_7.DataType!=VAR_50) continue;  /* COMMENT_10 */

    VAR_7.unknown1 = VAR_26(VAR_3);
    VAR_7.unknown2 = VAR_26(VAR_3);

    VAR_7.unknown5 = VAR_26(VAR_3);
    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;

    VAR_7.unknown3 = VAR_26(VAR_3);
    if(VAR_2!=VAR_3)
      VAR_7.unknown4 = VAR_26(VAR_3);  /* COMMENT_11 */
    VAR_7.unknown4 = VAR_26(VAR_3);
    VAR_7.DimFlag = VAR_26(VAR_3);
    VAR_7.SizeX = VAR_26(VAR_3);
    VAR_7.SizeY = VAR_26(VAR_3);


    switch(VAR_7.DimFlag)
    {
      case  8: VAR_19=VAR_18=1; break;      /* COMMENT_12 */
      case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_13 */
           VAR_17 = VAR_26(VAR_3);
           (void) VAR_17;
         if(VAR_18!=3) ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_14 */
         if(VAR_18!=3 && VAR_18!=1)
           ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
         VAR_20 = VAR_26(VAR_3);
         if (VAR_20 == 0)
           ThrowReaderException(VAR_36,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
    }

    VAR_7.Flag1 = VAR_27(VAR_3);
    VAR_7.NameFlag = VAR_27(VAR_3);

    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
    if (VAR_7.StructureClass != VAR_52 &&
        VAR_7.StructureClass != VAR_53 &&    /* COMMENT_15 */
        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_16 */
        VAR_7.StructureClass != VAR_55 &&
        VAR_7.StructureClass != VAR_56 &&    /* COMMENT_17 */
        VAR_7.StructureClass != VAR_57 &&
        VAR_7.StructureClass != VAR_58 &&    /* COMMENT_18 */
        VAR_7.StructureClass != VAR_59 &&
        VAR_7.StructureClass != VAR_60 &&    /* COMMENT_19 */
        VAR_7.StructureClass != VAR_61 &&
        VAR_7.StructureClass != VAR_62)    /* COMMENT_20 */
      ThrowReaderException(VAR_51,""UnsupportedCellTypeInTheMatrix"");

    switch (VAR_7.NameFlag)
    {
      case 0:
        VAR_8 = VAR_26(VAR_3);  /* COMMENT_21 */
        VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
        (void) SeekBlob(VAR_3, VAR_8, VAR_63);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_22 */
        break;
      default:
        goto MATLAB_KO;
    }

    VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
    if (VAR_21)
      (void) LogMagickEvent(VAR_33,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);

    (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     /* COMMENT_24 */

NEXT_FRAME:
    switch (VAR_9)
    {
      case VAR_64:
      case VAR_65:
        VAR_22 = 8;
        if(VAR_7.StructureFlag & VAR_66)
          VAR_2->depth = 1;
        else
          VAR_2->depth = 8;         /* COMMENT_25 */
        VAR_13 = (ssize_t) VAR_7.SizeX;
        break;
      case VAR_67:
      case VAR_68:
        VAR_22 = 16;
        VAR_2->depth = 16;        /* COMMENT_26 */
        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
        break;
      case VAR_69:
      case VAR_70:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_27 */
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_71:
      case VAR_72:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_28 */
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      case VAR_73:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
        if (VAR_7.StructureFlag & VAR_74)
  {              /* COMMENT_30 */
  }
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_75:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
VAR_76
          ThrowReaderException(VAR_51, ""IncompatibleSizeOfDouble"");
        if (VAR_7.StructureFlag & VAR_74)
  {                         /* COMMENT_31 */
  }
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      default:
        ThrowReaderException(VAR_51, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) VAR_22;
    VAR_2->columns = VAR_7.SizeX;
    VAR_2->rows = VAR_7.SizeY;
    VAR_25=1;
    VAR_2->colors = VAR_25 << VAR_2->depth;
    if (VAR_2->columns == 0 || VAR_2->rows == 0)
      goto MATLAB_KO;
      /* COMMENT_32 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_74) == 0))
      {
        SetImageColorspace(VAR_2,VAR_77);
        VAR_2->type=VAR_78;
      }


    /* COMMENT_33 */
                                                                  
                             
      
    if (VAR_0->ping)
    {
      size_t VAR_79 = VAR_2->columns;
      VAR_2->columns = VAR_2->rows;
      VAR_2->rows = VAR_79;
      goto done_reading; /* COMMENT_37 */
    }
    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
    if (VAR_6 == VAR_35)
      {
        InheritException(VAR_1,&VAR_2->exception);
        return(DestroyImageList(VAR_2));
      }
    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
    if (VAR_10 == (QuantumInfo *) NULL)
      ThrowReaderException(VAR_80,""MemoryAllocationFailed"");

  /* COMMENT_38 */
    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_39 */
    if (VAR_14 == NULL)
      ThrowReaderException(VAR_80,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));

    VAR_15 = 0;
    VAR_16 = 0;
    if (VAR_9==VAR_75 || VAR_9==VAR_73)        /* COMMENT_40 */
    {
      CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
    }

    /* COMMENT_41 */
    if(VAR_18==1) VAR_18=0; /* COMMENT_42 */
    /* COMMENT_43 */
    do
    {
      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
      {
        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
        if (VAR_5 == (PixelPacket *) NULL)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto done_reading;    /* COMMENT_44 */
  }
        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
        if((VAR_9==VAR_64 || VAR_9==VAR_65) && (VAR_7.StructureFlag & VAR_66))
        {
          FixLogical((unsigned char *)VAR_14,VAR_13);
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
    {
ImportQuantumPixelsFailed:
      if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
      goto ImportQuantumPixelsFailed;


          if (VAR_18<=1 &&       /* COMMENT_45 */
          (VAR_9==VAR_64 || VAR_9==VAR_67 || VAR_9==VAR_69 || VAR_9==VAR_71))
      FixSignedValues(VAR_5,VAR_7.SizeX);
        }

        if (!SyncAuthenticPixels(VAR_2,VAR_1))
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
      }
    } while(VAR_18-- >= 2);
ExitLoop:


    /* COMMENT_46 */
    if (VAR_7.StructureFlag & VAR_74)
    {        /* COMMENT_47 */
      VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
      VAR_12 = VAR_26(VAR_3);           /* COMMENT_48 */

      if (VAR_9==VAR_75 || VAR_9==VAR_73)
      {
        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
      }

      if (VAR_9==VAR_75)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_28(VAR_3, VAR_13, (double *)VAR_14);
          InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }

      if (VAR_9==VAR_73)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_31(VAR_3, VAR_13, (float *)VAR_14);
          InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }
    }

      /* COMMENT_49 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_74) == 0))
      VAR_2->type=VAR_78;
    if (VAR_2->depth == 1)
      VAR_2->type=VAR_82;

    if(VAR_3==VAR_2)
        VAR_3 = NULL;    /* COMMENT_50 */

      /* COMMENT_51 */
    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
    if (VAR_4 != (Image *) NULL)
    {
        /* COMMENT_52 */
      VAR_4->page.x=0;
      VAR_4->page.y=0;

      VAR_24 = VAR_4->blob;
      VAR_4->blob = VAR_2->blob;
      VAR_4->colors = VAR_2->colors;
      VAR_2->blob = VAR_24;
      AppendImageToList(&VAR_2,VAR_4);
      DeleteImageFromList(&VAR_2);
    }

done_reading:

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)
      {
        DeleteImageFromList(&VAR_3);
  if(VAR_11)
  {
          if(VAR_11->file)
    {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) remove_utf8(VAR_11->filename);
    }
        }
      }

      /* COMMENT_53 */
    AcquireNextImage(VAR_0,VAR_2);
    if (VAR_2->next == (Image *) NULL) break;
    VAR_2=SyncNextImageInList(VAR_2);
    VAR_2->columns=VAR_2->rows=0;
    VAR_2->colors=0;

      /* COMMENT_54 */
    RelinquishMagickMemory(VAR_14);
    VAR_14 = NULL;

    if(--VAR_20>0)
    {
      VAR_18 = VAR_19;
      if(VAR_3==NULL) VAR_3 = VAR_2;
      goto NEXT_FRAME;
    }

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)   /* COMMENT_55 */
      {
/* COMMENT_56 */
        DeleteImageFromList(&VAR_3);
        if(VAR_11)
        {
          if(VAR_11->file)
          {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) unlink(VAR_11->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(VAR_14);
  if (VAR_10 != (QuantumInfo *) NULL)
    VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
  VAR_11=DestroyImageInfo(VAR_11);
  CloseBlob(VAR_2);


  {
    Image *VAR_83;
    ssize_t VAR_84=0;

    /* COMMENT_57 */
                                                             
      
    VAR_83=VAR_2;
    VAR_2=NULL;
    while (VAR_83 != (Image *) NULL)
      {
        Image *VAR_85=VAR_83;
        if ((VAR_83->rows == 0) || (VAR_83->columns == 0)) {
          VAR_83=VAR_83->previous;
          DeleteImageFromList(&VAR_85);
        } else {
          VAR_2=VAR_83;
          VAR_83=VAR_83->previous;
        }
      }

    /* COMMENT_60 */
                       
      
    for (VAR_83=VAR_2; VAR_83 != (Image *) NULL; VAR_83=VAR_83->next)
      VAR_83->scene=VAR_84++;
  }

  if(VAR_11 != NULL)  /* COMMENT_63 */
  {
    if(VAR_11->file)
    {
      fclose(VAR_11->file);
      VAR_11->file = NULL;
      (void) remove_utf8(VAR_11->filename);
    }
    DestroyImageInfo(VAR_11);
    VAR_11 = NULL;
  }
  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
  if(VAR_2==NULL)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  return (VAR_2);
}",ImageMagick/353b942bd83da7e1356ba99c942848bd1871ee9f/mat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -248,9 +248,6 @@
     (void) sample_size;
     image->columns = MATLAB_HDR.SizeX;
     image->rows = MATLAB_HDR.SizeY;
-    quantum_info=AcquireQuantumInfo(clone_info,image);
-    if (quantum_info == (QuantumInfo *) NULL)
-      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     one=1;
     image->colors = one << image->depth;
     if (image->columns == 0 || image->rows == 0)
@@ -281,6 +278,9 @@
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }
+    quantum_info=AcquireQuantumInfo(clone_info,image);
+    if (quantum_info == (QuantumInfo *) NULL)
+      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
 
   /* ----- Load raster data ----- */
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */","{'deleted_lines': ['    quantum_info=AcquireQuantumInfo(clone_info,image);', '    if (quantum_info == (QuantumInfo *) NULL)', '      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");'], 'added_lines': ['    quantum_info=AcquireQuantumInfo(clone_info,image);', '    if (quantum_info == (QuantumInfo *) NULL)', '      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");']}",True,"The ReadMATImage function in coders\mat.c in ImageMagick 7.0.5-6 has a memory leak vulnerability that can cause memory exhaustion via a crafted MAT file, related to incorrect ordering of a SetImageExtent call.",6.5,MEDIUM,1,valid,2017-05-07T07:53:03Z,1
CVE-2017-9150,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"bpf: don't let ldimm64 leak map addresses on unprivileged

The patch fixes two things at once:

1) It checks the env->allow_ptr_leaks and only prints the map address to
   the log if we have the privileges to do so, otherwise it just dumps 0
   as we would when kptr_restrict is enabled on %pK. Given the latter is
   off by default and not every distro sets it, I don't want to rely on
   this, hence the 0 by default for unprivileged.

2) Printing of ldimm64 in the verifier log is currently broken in that
   we don't print the full immediate, but only the 32 bit part of the
   first insn part for ldimm64. Thus, fix this up as well; it's okay to
   access, since we verified all ldimm64 earlier already (including just
   constants) through replace_map_fd_with_map_ptr().

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Fixes: cbd357008604 (""bpf: verifier (add ability to receive verification log)"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0d0e57697f162da4aa218b5feafe614fb666db07,https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07,kernel/bpf/verifier.c,print_bpf_insn,"static void print_bpf_insn(struct bpf_insn *insn)
{
u8 class = BPF_CLASS(insn->code);
if (class == BPF_ALU || class == BPF_ALU64) {
if (BPF_SRC(insn->code) == BPF_X)
verbose(""(%02x) %sr%d %s %sr%d\n"",
insn->code, class == BPF_ALU ? ""(u32) "" : """",
insn->dst_reg,
bpf_alu_string[BPF_OP(insn->code) >> 4],
class == BPF_ALU ? ""(u32) "" : """",
insn->src_reg);
else
verbose(""(%02x) %sr%d %s %s%d\n"",
insn->code, class == BPF_ALU ? ""(u32) "" : """",
insn->dst_reg,
bpf_alu_string[BPF_OP(insn->code) >> 4],
class == BPF_ALU ? ""(u32) "" : """",
insn->imm);
} else if (class == BPF_STX) {
if (BPF_MODE(insn->code) == BPF_MEM)
verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
insn->code,
bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
insn->dst_reg,
insn->off, insn->src_reg);
else if (BPF_MODE(insn->code) == BPF_XADD)
verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
insn->code,
bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
insn->dst_reg, insn->off,
insn->src_reg);
else
verbose(""BUG_%02x\n"", insn->code);
} else if (class == BPF_ST) {
if (BPF_MODE(insn->code) != BPF_MEM) {
verbose(""BUG_st_%02x\n"", insn->code);
return;
}
verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
insn->code,
bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
insn->dst_reg,
insn->off, insn->imm);
} else if (class == BPF_LDX) {
if (BPF_MODE(insn->code) != BPF_MEM) {
verbose(""BUG_ldx_%02x\n"", insn->code);
return;
}
verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
insn->code, insn->dst_reg,
bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
insn->src_reg, insn->off);
} else if (class == BPF_LD) {
if (BPF_MODE(insn->code) == BPF_ABS) {
verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
insn->code,
bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
insn->imm);
} else if (BPF_MODE(insn->code) == BPF_IND) {
verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
insn->code,
bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
insn->src_reg, insn->imm);
} else if (BPF_MODE(insn->code) == BPF_IMM) {
verbose(""(%02x) r%d = 0x%x\n"",
insn->code, insn->dst_reg, insn->imm);
} else {
verbose(""BUG_ld_%02x\n"", insn->code);
return;
}
} else if (class == BPF_JMP) {
u8 opcode = BPF_OP(insn->code);
if (opcode == BPF_CALL) {
verbose(""(%02x) call %s#%d\n"", insn->code,
func_id_name(insn->imm), insn->imm);
} else if (insn->code == (BPF_JMP | BPF_JA)) {
verbose(""(%02x) goto pc%+d\n"",
insn->code, insn->off);
} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
verbose(""(%02x) exit\n"", insn->code);
} else if (BPF_SRC(insn->code) == BPF_X) {
verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
insn->code, insn->dst_reg,
bpf_jmp_string[BPF_OP(insn->code) >> 4],
insn->src_reg, insn->off);
} else {
verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
insn->code, insn->dst_reg,
bpf_jmp_string[BPF_OP(insn->code) >> 4],
insn->imm, insn->off);
}
} else {
verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
}
}","static void print_bpf_insn(struct bpf_insn *VAR_0)
{
u8 VAR_1 = BPF_CLASS(VAR_0->code);
if (VAR_1 == VAR_2 || VAR_1 == VAR_3) {
if (BPF_SRC(VAR_0->code) == VAR_4)
verbose(""(%02x) %sr%d %s %sr%d\n"",
VAR_0->code, VAR_1 == VAR_2 ? ""(u32) "" : """",
VAR_0->dst_reg,
VAR_5[BPF_OP(VAR_0->code) >> 4],
VAR_1 == VAR_2 ? ""(u32) "" : """",
VAR_0->src_reg);
else
verbose(""(%02x) %sr%d %s %s%d\n"",
VAR_0->code, VAR_1 == VAR_2 ? ""(u32) "" : """",
VAR_0->dst_reg,
VAR_5[BPF_OP(VAR_0->code) >> 4],
VAR_1 == VAR_2 ? ""(u32) "" : """",
VAR_0->imm);
} else if (VAR_1 == VAR_6) {
if (BPF_MODE(VAR_0->code) == VAR_7)
verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
VAR_0->code,
VAR_8[BPF_SIZE(VAR_0->code) >> 3],
VAR_0->dst_reg,
VAR_0->off, VAR_0->src_reg);
else if (BPF_MODE(VAR_0->code) == VAR_9)
verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
VAR_0->code,
VAR_8[BPF_SIZE(VAR_0->code) >> 3],
VAR_0->dst_reg, VAR_0->off,
VAR_0->src_reg);
else
verbose(""BUG_%02x\n"", VAR_0->code);
} else if (VAR_1 == VAR_10) {
if (BPF_MODE(VAR_0->code) != VAR_7) {
verbose(""BUG_st_%02x\n"", VAR_0->code);
return;
}
verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
VAR_0->code,
VAR_8[BPF_SIZE(VAR_0->code) >> 3],
VAR_0->dst_reg,
VAR_0->off, VAR_0->imm);
} else if (VAR_1 == VAR_11) {
if (BPF_MODE(VAR_0->code) != VAR_7) {
verbose(""BUG_ldx_%02x\n"", VAR_0->code);
return;
}
verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
VAR_0->code, VAR_0->dst_reg,
VAR_8[BPF_SIZE(VAR_0->code) >> 3],
VAR_0->src_reg, VAR_0->off);
} else if (VAR_1 == VAR_12) {
if (BPF_MODE(VAR_0->code) == VAR_13) {
verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
VAR_0->code,
VAR_8[BPF_SIZE(VAR_0->code) >> 3],
VAR_0->imm);
} else if (BPF_MODE(VAR_0->code) == VAR_14) {
verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
VAR_0->code,
VAR_8[BPF_SIZE(VAR_0->code) >> 3],
VAR_0->src_reg, VAR_0->imm);
} else if (BPF_MODE(VAR_0->code) == VAR_15) {
verbose(""(%02x) r%d = 0x%x\n"",
VAR_0->code, VAR_0->dst_reg, VAR_0->imm);
} else {
verbose(""BUG_ld_%02x\n"", VAR_0->code);
return;
}
} else if (VAR_1 == VAR_16) {
u8 VAR_17 = BPF_OP(VAR_0->code);
if (VAR_17 == VAR_18) {
verbose(""(%02x) call %s#%d\n"", VAR_0->code,
func_id_name(VAR_0->imm), VAR_0->imm);
} else if (VAR_0->code == (VAR_16 | VAR_19)) {
verbose(""(%02x) goto pc%+d\n"",
VAR_0->code, VAR_0->off);
} else if (VAR_0->code == (VAR_16 | VAR_20)) {
verbose(""(%02x) exit\n"", VAR_0->code);
} else if (BPF_SRC(VAR_0->code) == VAR_4) {
verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
VAR_0->code, VAR_0->dst_reg,
VAR_21[BPF_OP(VAR_0->code) >> 4],
VAR_0->src_reg, VAR_0->off);
} else {
verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
VAR_0->code, VAR_0->dst_reg,
VAR_21[BPF_OP(VAR_0->code) >> 4],
VAR_0->imm, VAR_0->off);
}
} else {
verbose(""(%02x) %s\n"", VAR_0->code, VAR_22[VAR_1]);
}
}",torvalds/linux/0d0e57697f162da4aa218b5feafe614fb666db07/verifier.c/vul/before/0.json,"static void print_bpf_insn(const struct bpf_verifier_env *env,
			   const struct bpf_insn *insn)
{
	u8 class = BPF_CLASS(insn->code);

	if (class == BPF_ALU || class == BPF_ALU64) {
		if (BPF_SRC(insn->code) == BPF_X)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->imm);
	} else if (class == BPF_STX) {
		if (BPF_MODE(insn->code) == BPF_MEM)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg,
				insn->off, insn->src_reg);
		else if (BPF_MODE(insn->code) == BPF_XADD)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg, insn->off,
				insn->src_reg);
		else
			verbose(""BUG_%02x\n"", insn->code);
	} else if (class == BPF_ST) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_st_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			insn->code,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->dst_reg,
			insn->off, insn->imm);
	} else if (class == BPF_LDX) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_ldx_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			insn->code, insn->dst_reg,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->src_reg, insn->off);
	} else if (class == BPF_LD) {
		if (BPF_MODE(insn->code) == BPF_ABS) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IND) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->src_reg, insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IMM &&
			   BPF_SIZE(insn->code) == BPF_DW) {
			/* At this point, we already made sure that the second
			 * part of the ldimm64 insn is accessible.
			 */
			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;

			if (map_ptr && !env->allow_ptr_leaks)
				imm = 0;

			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
				insn->dst_reg, (unsigned long long)imm);
		} else {
			verbose(""BUG_ld_%02x\n"", insn->code);
			return;
		}
	} else if (class == BPF_JMP) {
		u8 opcode = BPF_OP(insn->code);

		if (opcode == BPF_CALL) {
			verbose(""(%02x) call %s#%d\n"", insn->code,
				func_id_name(insn->imm), insn->imm);
		} else if (insn->code == (BPF_JMP | BPF_JA)) {
			verbose(""(%02x) goto pc%+d\n"",
				insn->code, insn->off);
		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
			verbose(""(%02x) exit\n"", insn->code);
		} else if (BPF_SRC(insn->code) == BPF_X) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->src_reg, insn->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->imm, insn->off);
		}
	} else {
		verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
	}
}","static void print_bpf_insn(const struct bpf_verifier_env *VAR_0,
			   const struct bpf_insn *VAR_1)
{
	u8 VAR_2 = BPF_CLASS(VAR_1->code);

	if (VAR_2 == VAR_3 || VAR_2 == VAR_4) {
		if (BPF_SRC(VAR_1->code) == VAR_5)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				VAR_1->code, VAR_2 == VAR_3 ? ""(u32) "" : """",
				VAR_1->dst_reg,
				VAR_6[BPF_OP(VAR_1->code) >> 4],
				VAR_2 == VAR_3 ? ""(u32) "" : """",
				VAR_1->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				VAR_1->code, VAR_2 == VAR_3 ? ""(u32) "" : """",
				VAR_1->dst_reg,
				VAR_6[BPF_OP(VAR_1->code) >> 4],
				VAR_2 == VAR_3 ? ""(u32) "" : """",
				VAR_1->imm);
	} else if (VAR_2 == VAR_7) {
		if (BPF_MODE(VAR_1->code) == VAR_8)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				VAR_1->code,
				VAR_9[BPF_SIZE(VAR_1->code) >> 3],
				VAR_1->dst_reg,
				VAR_1->off, VAR_1->src_reg);
		else if (BPF_MODE(VAR_1->code) == VAR_10)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				VAR_1->code,
				VAR_9[BPF_SIZE(VAR_1->code) >> 3],
				VAR_1->dst_reg, VAR_1->off,
				VAR_1->src_reg);
		else
			verbose(""BUG_%02x\n"", VAR_1->code);
	} else if (VAR_2 == VAR_11) {
		if (BPF_MODE(VAR_1->code) != VAR_8) {
			verbose(""BUG_st_%02x\n"", VAR_1->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			VAR_1->code,
			VAR_9[BPF_SIZE(VAR_1->code) >> 3],
			VAR_1->dst_reg,
			VAR_1->off, VAR_1->imm);
	} else if (VAR_2 == VAR_12) {
		if (BPF_MODE(VAR_1->code) != VAR_8) {
			verbose(""BUG_ldx_%02x\n"", VAR_1->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			VAR_1->code, VAR_1->dst_reg,
			VAR_9[BPF_SIZE(VAR_1->code) >> 3],
			VAR_1->src_reg, VAR_1->off);
	} else if (VAR_2 == VAR_13) {
		if (BPF_MODE(VAR_1->code) == VAR_14) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				VAR_1->code,
				VAR_9[BPF_SIZE(VAR_1->code) >> 3],
				VAR_1->imm);
		} else if (BPF_MODE(VAR_1->code) == VAR_15) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
				VAR_1->code,
				VAR_9[BPF_SIZE(VAR_1->code) >> 3],
				VAR_1->src_reg, VAR_1->imm);
		} else if (BPF_MODE(VAR_1->code) == VAR_16 &&
			   BPF_SIZE(VAR_1->code) == VAR_17) {
			/* COMMENT_0 */
                                             
      
			u64 VAR_18 = ((u64)(VAR_1 + 1)->imm << 32) | (u32)VAR_1->imm;
			bool VAR_19 = VAR_1->src_reg == VAR_20;

			if (VAR_19 && !VAR_0->allow_ptr_leaks)
				VAR_18 = 0;

			verbose(""(%02x) r%d = 0x%llx\n"", VAR_1->code,
				VAR_1->dst_reg, (unsigned long long)VAR_18);
		} else {
			verbose(""BUG_ld_%02x\n"", VAR_1->code);
			return;
		}
	} else if (VAR_2 == VAR_21) {
		u8 VAR_22 = BPF_OP(VAR_1->code);

		if (VAR_22 == VAR_23) {
			verbose(""(%02x) call %s#%d\n"", VAR_1->code,
				func_id_name(VAR_1->imm), VAR_1->imm);
		} else if (VAR_1->code == (VAR_21 | VAR_24)) {
			verbose(""(%02x) goto pc%+d\n"",
				VAR_1->code, VAR_1->off);
		} else if (VAR_1->code == (VAR_21 | VAR_25)) {
			verbose(""(%02x) exit\n"", VAR_1->code);
		} else if (BPF_SRC(VAR_1->code) == VAR_5) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				VAR_1->code, VAR_1->dst_reg,
				VAR_26[BPF_OP(VAR_1->code) >> 4],
				VAR_1->src_reg, VAR_1->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				VAR_1->code, VAR_1->dst_reg,
				VAR_26[BPF_OP(VAR_1->code) >> 4],
				VAR_1->imm, VAR_1->off);
		}
	} else {
		verbose(""(%02x) %s\n"", VAR_1->code, VAR_27[VAR_2]);
	}
}",torvalds/linux/0d0e57697f162da4aa218b5feafe614fb666db07/verifier.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
-static void print_bpf_insn(struct bpf_insn *insn)
+static void print_bpf_insn(const struct bpf_verifier_env *env,
+			   const struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
@@ -62,9 +63,19 @@
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
-		} else if (BPF_MODE(insn->code) == BPF_IMM) {
-			verbose(""(%02x) r%d = 0x%x\n"",
-				insn->code, insn->dst_reg, insn->imm);
+		} else if (BPF_MODE(insn->code) == BPF_IMM &&
+			   BPF_SIZE(insn->code) == BPF_DW) {
+			/* At this point, we already made sure that the second
+			 * part of the ldimm64 insn is accessible.
+			 */
+			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
+			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;
+
+			if (map_ptr && !env->allow_ptr_leaks)
+				imm = 0;
+
+			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
+				insn->dst_reg, (unsigned long long)imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;","{'deleted_lines': ['static void print_bpf_insn(struct bpf_insn *insn)', '\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {', '\t\t\tverbose(""(%02x) r%d = 0x%x\\n"",', '\t\t\t\tinsn->code, insn->dst_reg, insn->imm);'], 'added_lines': ['static void print_bpf_insn(const struct bpf_verifier_env *env,', '\t\t\t   const struct bpf_insn *insn)', '\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&', '\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {', '\t\t\t/* At this point, we already made sure that the second', '\t\t\t * part of the ldimm64 insn is accessible.', '\t\t\t */', '\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;', '\t\t\tbool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;', '', '\t\t\tif (map_ptr && !env->allow_ptr_leaks)', '\t\t\t\timm = 0;', '', '\t\t\tverbose(""(%02x) r%d = 0x%llx\\n"", insn->code,', '\t\t\t\tinsn->dst_reg, (unsigned long long)imm);']}",True,"The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls.",5.5,MEDIUM,1,valid,2017-05-07T22:04:09Z,1
CVE-2017-9150,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"bpf: don't let ldimm64 leak map addresses on unprivileged

The patch fixes two things at once:

1) It checks the env->allow_ptr_leaks and only prints the map address to
   the log if we have the privileges to do so, otherwise it just dumps 0
   as we would when kptr_restrict is enabled on %pK. Given the latter is
   off by default and not every distro sets it, I don't want to rely on
   this, hence the 0 by default for unprivileged.

2) Printing of ldimm64 in the verifier log is currently broken in that
   we don't print the full immediate, but only the 32 bit part of the
   first insn part for ldimm64. Thus, fix this up as well; it's okay to
   access, since we verified all ldimm64 earlier already (including just
   constants) through replace_map_fd_with_map_ptr().

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Fixes: cbd357008604 (""bpf: verifier (add ability to receive verification log)"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Acked-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0d0e57697f162da4aa218b5feafe614fb666db07,https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07,kernel/bpf/verifier.c,do_check,"static int do_check(struct bpf_verifier_env *env)
{
struct bpf_verifier_state *state = &env->cur_state;
struct bpf_insn *insns = env->prog->insnsi;
struct bpf_reg_state *regs = state->regs;
int insn_cnt = env->prog->len;
int insn_idx, prev_insn_idx = 0;
int insn_processed = 0;
bool do_print_state = false;
init_reg_state(regs);
insn_idx = 0;
env->varlen_map_value_access = false;
for (;;) {
struct bpf_insn *insn;
u8 class;
int err;
if (insn_idx >= insn_cnt) {
verbose(""invalid insn idx %d insn_cnt %d\n"",
insn_idx, insn_cnt);
return -EFAULT;
}
insn = &insns[insn_idx];
class = BPF_CLASS(insn->code);
if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
verbose(""BPF program is too large. Processed %d insn\n"",
insn_processed);
return -E2BIG;
}
err = is_state_visited(env, insn_idx);
if (err < 0)
return err;
if (err == 1) {
if (log_level) {
if (do_print_state)
verbose(""\nfrom %d to %d: safe\n"",
prev_insn_idx, insn_idx);
else
verbose(""%d: safe\n"", insn_idx);
}
goto process_bpf_exit;
}
if (log_level && do_print_state) {
verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
print_verifier_state(&env->cur_state);
do_print_state = false;
}
if (log_level) {
verbose(""%d: "", insn_idx);
print_bpf_insn(insn);
}
err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
if (err)
return err;
if (class == BPF_ALU || class == BPF_ALU64) {
err = check_alu_op(env, insn);
if (err)
return err;
} else if (class == BPF_LDX) {
enum bpf_reg_type *prev_src_type, src_reg_type;
err = check_reg_arg(regs, insn->src_reg, SRC_OP);
if (err)
return err;
err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
if (err)
return err;
src_reg_type = regs[insn->src_reg].type;
err = check_mem_access(env, insn->src_reg, insn->off,
BPF_SIZE(insn->code), BPF_READ,
insn->dst_reg);
if (err)
return err;
if (BPF_SIZE(insn->code) != BPF_W &&
BPF_SIZE(insn->code) != BPF_DW) {
insn_idx++;
continue;
}
prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;
if (*prev_src_type == NOT_INIT) {
*prev_src_type = src_reg_type;
} else if (src_reg_type != *prev_src_type &&
(src_reg_type == PTR_TO_CTX ||
*prev_src_type == PTR_TO_CTX)) {
verbose(""same insn cannot be used with different pointers\n"");
return -EINVAL;
}
} else if (class == BPF_STX) {
enum bpf_reg_type *prev_dst_type, dst_reg_type;
if (BPF_MODE(insn->code) == BPF_XADD) {
err = check_xadd(env, insn);
if (err)
return err;
insn_idx++;
continue;
}
err = check_reg_arg(regs, insn->src_reg, SRC_OP);
if (err)
return err;
err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
if (err)
return err;
dst_reg_type = regs[insn->dst_reg].type;
err = check_mem_access(env, insn->dst_reg, insn->off,
BPF_SIZE(insn->code), BPF_WRITE,
insn->src_reg);
if (err)
return err;
prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;
if (*prev_dst_type == NOT_INIT) {
*prev_dst_type = dst_reg_type;
} else if (dst_reg_type != *prev_dst_type &&
(dst_reg_type == PTR_TO_CTX ||
*prev_dst_type == PTR_TO_CTX)) {
verbose(""same insn cannot be used with different pointers\n"");
return -EINVAL;
}
} else if (class == BPF_ST) {
if (BPF_MODE(insn->code) != BPF_MEM ||
insn->src_reg != BPF_REG_0) {
verbose(""BPF_ST uses reserved fields\n"");
return -EINVAL;
}
err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
if (err)
return err;
err = check_mem_access(env, insn->dst_reg, insn->off,
BPF_SIZE(insn->code), BPF_WRITE,
-1);
if (err)
return err;
} else if (class == BPF_JMP) {
u8 opcode = BPF_OP(insn->code);
if (opcode == BPF_CALL) {
if (BPF_SRC(insn->code) != BPF_K ||
insn->off != 0 ||
insn->src_reg != BPF_REG_0 ||
insn->dst_reg != BPF_REG_0) {
verbose(""BPF_CALL uses reserved fields\n"");
return -EINVAL;
}
err = check_call(env, insn->imm, insn_idx);
if (err)
return err;
} else if (opcode == BPF_JA) {
if (BPF_SRC(insn->code) != BPF_K ||
insn->imm != 0 ||
insn->src_reg != BPF_REG_0 ||
insn->dst_reg != BPF_REG_0) {
verbose(""BPF_JA uses reserved fields\n"");
return -EINVAL;
}
insn_idx += insn->off + 1;
continue;
} else if (opcode == BPF_EXIT) {
if (BPF_SRC(insn->code) != BPF_K ||
insn->imm != 0 ||
insn->src_reg != BPF_REG_0 ||
insn->dst_reg != BPF_REG_0) {
verbose(""BPF_EXIT uses reserved fields\n"");
return -EINVAL;
}
err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
if (err)
return err;
if (is_pointer_value(env, BPF_REG_0)) {
verbose(""R0 leaks addr as return value\n"");
return -EACCES;
}
process_bpf_exit:
insn_idx = pop_stack(env, &prev_insn_idx);
if (insn_idx < 0) {
break;
} else {
do_print_state = true;
continue;
}
} else {
err = check_cond_jmp_op(env, insn, &insn_idx);
if (err)
return err;
}
} else if (class == BPF_LD) {
u8 mode = BPF_MODE(insn->code);
if (mode == BPF_ABS || mode == BPF_IND) {
err = check_ld_abs(env, insn);
if (err)
return err;
} else if (mode == BPF_IMM) {
err = check_ld_imm(env, insn);
if (err)
return err;
insn_idx++;
} else {
verbose(""invalid BPF_LD mode\n"");
return -EINVAL;
}
reset_reg_range_values(regs, insn->dst_reg);
} else {
verbose(""unknown insn class %d\n"", class);
return -EINVAL;
}
insn_idx++;
}
verbose(""processed %d insns\n"", insn_processed);
return 0;
}","static int do_check(struct bpf_verifier_env *VAR_0)
{
struct bpf_verifier_state *VAR_1 = &VAR_0->cur_state;
struct bpf_insn *VAR_2 = VAR_0->prog->insnsi;
struct bpf_reg_state *VAR_3 = VAR_1->regs;
int VAR_4 = VAR_0->prog->len;
int VAR_5, VAR_6 = 0;
int VAR_7 = 0;
bool VAR_8 = false;
init_reg_state(VAR_3);
VAR_5 = 0;
VAR_0->varlen_map_value_access = false;
for (;;) {
struct bpf_insn *VAR_9;
u8 VAR_10;
int VAR_11;
if (VAR_5 >= VAR_4) {
verbose(""invalid insn idx %d insn_cnt %d\n"",
VAR_5, VAR_4);
return -VAR_12;
}
VAR_9 = &VAR_2[VAR_5];
VAR_10 = BPF_CLASS(VAR_9->code);
if (++VAR_7 > VAR_13) {
verbose(""BPF program is too large. Processed %d insn\n"",
VAR_7);
return -VAR_14;
}
VAR_11 = is_state_visited(VAR_0, VAR_5);
if (VAR_11 < 0)
return VAR_11;
if (VAR_11 == 1) {
if (VAR_15) {
if (VAR_8)
verbose(""\nfrom %d to %d: safe\n"",
VAR_6, VAR_5);
else
verbose(""%d: safe\n"", VAR_5);
}
goto process_bpf_exit;
}
if (VAR_15 && VAR_8) {
verbose(""\nfrom %d to %d:"", VAR_6, VAR_5);
print_verifier_state(&VAR_0->cur_state);
VAR_8 = false;
}
if (VAR_15) {
verbose(""%d: "", VAR_5);
print_bpf_insn(VAR_9);
}
VAR_11 = ext_analyzer_insn_hook(VAR_0, VAR_5, VAR_6);
if (VAR_11)
return VAR_11;
if (VAR_10 == VAR_16 || VAR_10 == VAR_17) {
VAR_11 = check_alu_op(VAR_0, VAR_9);
if (VAR_11)
return VAR_11;
} else if (VAR_10 == VAR_18) {
enum bpf_reg_type *VAR_19, VAR_20;
VAR_11 = check_reg_arg(VAR_3, VAR_9->src_reg, VAR_21);
if (VAR_11)
return VAR_11;
VAR_11 = check_reg_arg(VAR_3, VAR_9->dst_reg, VAR_22);
if (VAR_11)
return VAR_11;
VAR_20 = VAR_3[VAR_9->src_reg].type;
VAR_11 = check_mem_access(VAR_0, VAR_9->src_reg, VAR_9->off,
BPF_SIZE(VAR_9->code), VAR_23,
VAR_9->dst_reg);
if (VAR_11)
return VAR_11;
if (BPF_SIZE(VAR_9->code) != VAR_24 &&
BPF_SIZE(VAR_9->code) != VAR_25) {
VAR_5++;
continue;
}
VAR_19 = &VAR_0->insn_aux_data[VAR_5].ptr_type;
if (*VAR_19 == VAR_26) {
*VAR_19 = VAR_20;
} else if (VAR_20 != *VAR_19 &&
(VAR_20 == VAR_27 ||
*VAR_19 == VAR_27)) {
verbose(""same insn cannot be used with different pointers\n"");
return -VAR_28;
}
} else if (VAR_10 == VAR_29) {
enum bpf_reg_type *VAR_30, VAR_31;
if (BPF_MODE(VAR_9->code) == VAR_32) {
VAR_11 = check_xadd(VAR_0, VAR_9);
if (VAR_11)
return VAR_11;
VAR_5++;
continue;
}
VAR_11 = check_reg_arg(VAR_3, VAR_9->src_reg, VAR_21);
if (VAR_11)
return VAR_11;
VAR_11 = check_reg_arg(VAR_3, VAR_9->dst_reg, VAR_21);
if (VAR_11)
return VAR_11;
VAR_31 = VAR_3[VAR_9->dst_reg].type;
VAR_11 = check_mem_access(VAR_0, VAR_9->dst_reg, VAR_9->off,
BPF_SIZE(VAR_9->code), VAR_33,
VAR_9->src_reg);
if (VAR_11)
return VAR_11;
VAR_30 = &VAR_0->insn_aux_data[VAR_5].ptr_type;
if (*VAR_30 == VAR_26) {
*VAR_30 = VAR_31;
} else if (VAR_31 != *VAR_30 &&
(VAR_31 == VAR_27 ||
*VAR_30 == VAR_27)) {
verbose(""same insn cannot be used with different pointers\n"");
return -VAR_28;
}
} else if (VAR_10 == VAR_34) {
if (BPF_MODE(VAR_9->code) != VAR_35 ||
VAR_9->src_reg != VAR_36) {
verbose(""BPF_ST uses reserved fields\n"");
return -VAR_28;
}
VAR_11 = check_reg_arg(VAR_3, VAR_9->dst_reg, VAR_21);
if (VAR_11)
return VAR_11;
VAR_11 = check_mem_access(VAR_0, VAR_9->dst_reg, VAR_9->off,
BPF_SIZE(VAR_9->code), VAR_33,
-1);
if (VAR_11)
return VAR_11;
} else if (VAR_10 == VAR_37) {
u8 VAR_38 = BPF_OP(VAR_9->code);
if (VAR_38 == VAR_39) {
if (BPF_SRC(VAR_9->code) != VAR_40 ||
VAR_9->off != 0 ||
VAR_9->src_reg != VAR_36 ||
VAR_9->dst_reg != VAR_36) {
verbose(""BPF_CALL uses reserved fields\n"");
return -VAR_28;
}
VAR_11 = check_call(VAR_0, VAR_9->imm, VAR_5);
if (VAR_11)
return VAR_11;
} else if (VAR_38 == VAR_41) {
if (BPF_SRC(VAR_9->code) != VAR_40 ||
VAR_9->imm != 0 ||
VAR_9->src_reg != VAR_36 ||
VAR_9->dst_reg != VAR_36) {
verbose(""BPF_JA uses reserved fields\n"");
return -VAR_28;
}
VAR_5 += VAR_9->off + 1;
continue;
} else if (VAR_38 == VAR_42) {
if (BPF_SRC(VAR_9->code) != VAR_40 ||
VAR_9->imm != 0 ||
VAR_9->src_reg != VAR_36 ||
VAR_9->dst_reg != VAR_36) {
verbose(""BPF_EXIT uses reserved fields\n"");
return -VAR_28;
}
VAR_11 = check_reg_arg(VAR_3, VAR_36, VAR_21);
if (VAR_11)
return VAR_11;
if (is_pointer_value(VAR_0, VAR_36)) {
verbose(""R0 leaks addr as return value\n"");
return -VAR_43;
}
process_bpf_exit:
VAR_5 = pop_stack(VAR_0, &VAR_6);
if (VAR_5 < 0) {
break;
} else {
VAR_8 = true;
continue;
}
} else {
VAR_11 = check_cond_jmp_op(VAR_0, VAR_9, &VAR_5);
if (VAR_11)
return VAR_11;
}
} else if (VAR_10 == VAR_44) {
u8 VAR_45 = BPF_MODE(VAR_9->code);
if (VAR_45 == VAR_46 || VAR_45 == VAR_47) {
VAR_11 = check_ld_abs(VAR_0, VAR_9);
if (VAR_11)
return VAR_11;
} else if (VAR_45 == VAR_48) {
VAR_11 = check_ld_imm(VAR_0, VAR_9);
if (VAR_11)
return VAR_11;
VAR_5++;
} else {
verbose(""invalid BPF_LD mode\n"");
return -VAR_28;
}
reset_reg_range_values(VAR_3, VAR_9->dst_reg);
} else {
verbose(""unknown insn class %d\n"", VAR_10);
return -VAR_28;
}
VAR_5++;
}
verbose(""processed %d insns\n"", VAR_7);
return 0;
}",torvalds/linux/0d0e57697f162da4aa218b5feafe614fb666db07/verifier.c/vul/before/1.json,"static int do_check(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = &env->cur_state;
	struct bpf_insn *insns = env->prog->insnsi;
	struct bpf_reg_state *regs = state->regs;
	int insn_cnt = env->prog->len;
	int insn_idx, prev_insn_idx = 0;
	int insn_processed = 0;
	bool do_print_state = false;

	init_reg_state(regs);
	insn_idx = 0;
	env->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *insn;
		u8 class;
		int err;

		if (insn_idx >= insn_cnt) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				insn_idx, insn_cnt);
			return -EFAULT;
		}

		insn = &insns[insn_idx];
		class = BPF_CLASS(insn->code);

		if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				insn_processed);
			return -E2BIG;
		}

		err = is_state_visited(env, insn_idx);
		if (err < 0)
			return err;
		if (err == 1) {
			/* found equivalent state, can prune the search */
			if (log_level) {
				if (do_print_state)
					verbose(""\nfrom %d to %d: safe\n"",
						prev_insn_idx, insn_idx);
				else
					verbose(""%d: safe\n"", insn_idx);
			}
			goto process_bpf_exit;
		}

		if (log_level && do_print_state) {
			verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
			print_verifier_state(&env->cur_state);
			do_print_state = false;
		}

		if (log_level) {
			verbose(""%d: "", insn_idx);
			print_bpf_insn(env, insn);
		}

		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
		if (err)
			return err;

		if (class == BPF_ALU || class == BPF_ALU64) {
			err = check_alu_op(env, insn);
			if (err)
				return err;

		} else if (class == BPF_LDX) {
			enum bpf_reg_type *prev_src_type, src_reg_type;

			/* check for reserved fields is already done */

			/* check src operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;

			err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
			if (err)
				return err;

			src_reg_type = regs[insn->src_reg].type;

			/* check that memory (src_reg + off) is readable,
			 * the state of dst_reg will be updated by this func
			 */
			err = check_mem_access(env, insn->src_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_READ,
					       insn->dst_reg);
			if (err)
				return err;

			if (BPF_SIZE(insn->code) != BPF_W &&
			    BPF_SIZE(insn->code) != BPF_DW) {
				insn_idx++;
				continue;
			}

			prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_src_type == NOT_INIT) {
				/* saw a valid insn
				 * dst_reg = *(u32 *)(src_reg + off)
				 * save type to validate intersecting paths
				 */
				*prev_src_type = src_reg_type;

			} else if (src_reg_type != *prev_src_type &&
				   (src_reg_type == PTR_TO_CTX ||
				    *prev_src_type == PTR_TO_CTX)) {
				/* ABuser program is trying to use the same insn
				 * dst_reg = *(u32*) (src_reg + off)
				 * with different pointer types:
				 * src_reg == ctx in one branch and
				 * src_reg == stack|map in some other branch.
				 * Reject it.
				 */
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_STX) {
			enum bpf_reg_type *prev_dst_type, dst_reg_type;

			if (BPF_MODE(insn->code) == BPF_XADD) {
				err = check_xadd(env, insn);
				if (err)
					return err;
				insn_idx++;
				continue;
			}

			/* check src1 operand */
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;
			/* check src2 operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			dst_reg_type = regs[insn->dst_reg].type;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       insn->src_reg);
			if (err)
				return err;

			prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_dst_type == NOT_INIT) {
				*prev_dst_type = dst_reg_type;
			} else if (dst_reg_type != *prev_dst_type &&
				   (dst_reg_type == PTR_TO_CTX ||
				    *prev_dst_type == PTR_TO_CTX)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_ST) {
			if (BPF_MODE(insn->code) != BPF_MEM ||
			    insn->src_reg != BPF_REG_0) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -EINVAL;
			}
			/* check src operand */
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			/* check that memory (dst_reg + off) is writeable */
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       -1);
			if (err)
				return err;

		} else if (class == BPF_JMP) {
			u8 opcode = BPF_OP(insn->code);

			if (opcode == BPF_CALL) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->off != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -EINVAL;
				}

				err = check_call(env, insn->imm, insn_idx);
				if (err)
					return err;

			} else if (opcode == BPF_JA) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -EINVAL;
				}

				insn_idx += insn->off + 1;
				continue;

			} else if (opcode == BPF_EXIT) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -EINVAL;
				}

				/* eBPF calling convetion is such that R0 is used
				 * to return the value from eBPF program.
				 * Make sure that it's readable at this time
				 * of bpf_exit, which means that program wrote
				 * something into it earlier
				 */
				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
				if (err)
					return err;

				if (is_pointer_value(env, BPF_REG_0)) {
					verbose(""R0 leaks addr as return value\n"");
					return -EACCES;
				}

process_bpf_exit:
				insn_idx = pop_stack(env, &prev_insn_idx);
				if (insn_idx < 0) {
					break;
				} else {
					do_print_state = true;
					continue;
				}
			} else {
				err = check_cond_jmp_op(env, insn, &insn_idx);
				if (err)
					return err;
			}
		} else if (class == BPF_LD) {
			u8 mode = BPF_MODE(insn->code);

			if (mode == BPF_ABS || mode == BPF_IND) {
				err = check_ld_abs(env, insn);
				if (err)
					return err;

			} else if (mode == BPF_IMM) {
				err = check_ld_imm(env, insn);
				if (err)
					return err;

				insn_idx++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -EINVAL;
			}
			reset_reg_range_values(regs, insn->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", class);
			return -EINVAL;
		}

		insn_idx++;
	}

	verbose(""processed %d insns\n"", insn_processed);
	return 0;
}","static int do_check(struct bpf_verifier_env *VAR_0)
{
	struct bpf_verifier_state *VAR_1 = &VAR_0->cur_state;
	struct bpf_insn *VAR_2 = VAR_0->prog->insnsi;
	struct bpf_reg_state *VAR_3 = VAR_1->regs;
	int VAR_4 = VAR_0->prog->len;
	int VAR_5, VAR_6 = 0;
	int VAR_7 = 0;
	bool VAR_8 = false;

	init_reg_state(VAR_3);
	VAR_5 = 0;
	VAR_0->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *VAR_9;
		u8 VAR_10;
		int VAR_11;

		if (VAR_5 >= VAR_4) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				VAR_5, VAR_4);
			return -VAR_12;
		}

		VAR_9 = &VAR_2[VAR_5];
		VAR_10 = BPF_CLASS(VAR_9->code);

		if (++VAR_7 > VAR_13) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				VAR_7);
			return -VAR_14;
		}

		VAR_11 = is_state_visited(VAR_0, VAR_5);
		if (VAR_11 < 0)
			return VAR_11;
		if (VAR_11 == 1) {
			/* COMMENT_0 */
			if (VAR_15) {
				if (VAR_8)
					verbose(""\nfrom %d to %d: safe\n"",
						VAR_6, VAR_5);
				else
					verbose(""%d: safe\n"", VAR_5);
			}
			goto process_bpf_exit;
		}

		if (VAR_15 && VAR_8) {
			verbose(""\nfrom %d to %d:"", VAR_6, VAR_5);
			print_verifier_state(&VAR_0->cur_state);
			VAR_8 = false;
		}

		if (VAR_15) {
			verbose(""%d: "", VAR_5);
			print_bpf_insn(VAR_0, VAR_9);
		}

		VAR_11 = ext_analyzer_insn_hook(VAR_0, VAR_5, VAR_6);
		if (VAR_11)
			return VAR_11;

		if (VAR_10 == VAR_16 || VAR_10 == VAR_17) {
			VAR_11 = check_alu_op(VAR_0, VAR_9);
			if (VAR_11)
				return VAR_11;

		} else if (VAR_10 == VAR_18) {
			enum bpf_reg_type *VAR_19, VAR_20;

			/* COMMENT_1 */

			/* COMMENT_2 */
			VAR_11 = check_reg_arg(VAR_3, VAR_9->src_reg, VAR_21);
			if (VAR_11)
				return VAR_11;

			VAR_11 = check_reg_arg(VAR_3, VAR_9->dst_reg, VAR_22);
			if (VAR_11)
				return VAR_11;

			VAR_20 = VAR_3[VAR_9->src_reg].type;

			/* COMMENT_3 */
                                                       
      
			VAR_11 = check_mem_access(VAR_0, VAR_9->src_reg, VAR_9->off,
					       BPF_SIZE(VAR_9->code), VAR_23,
					       VAR_9->dst_reg);
			if (VAR_11)
				return VAR_11;

			if (BPF_SIZE(VAR_9->code) != VAR_24 &&
			    BPF_SIZE(VAR_9->code) != VAR_25) {
				VAR_5++;
				continue;
			}

			VAR_19 = &VAR_0->insn_aux_data[VAR_5].ptr_type;

			if (*VAR_19 == VAR_26) {
				/* COMMENT_6 */
                                        
                                               
       
				*VAR_19 = VAR_20;

			} else if (VAR_20 != *VAR_19 &&
				   (VAR_20 == VAR_27 ||
				    *VAR_19 == VAR_27)) {
				/* COMMENT_10 */
                                        
                                    
                                       
                                                 
                 
       
				verbose(""same insn cannot be used with different pointers\n"");
				return -VAR_28;
			}

		} else if (VAR_10 == VAR_29) {
			enum bpf_reg_type *VAR_30, VAR_31;

			if (BPF_MODE(VAR_9->code) == VAR_32) {
				VAR_11 = check_xadd(VAR_0, VAR_9);
				if (VAR_11)
					return VAR_11;
				VAR_5++;
				continue;
			}

			/* COMMENT_17 */
			VAR_11 = check_reg_arg(VAR_3, VAR_9->src_reg, VAR_21);
			if (VAR_11)
				return VAR_11;
			/* COMMENT_18 */
			VAR_11 = check_reg_arg(VAR_3, VAR_9->dst_reg, VAR_21);
			if (VAR_11)
				return VAR_11;

			VAR_31 = VAR_3[VAR_9->dst_reg].type;

			/* COMMENT_19 */
			VAR_11 = check_mem_access(VAR_0, VAR_9->dst_reg, VAR_9->off,
					       BPF_SIZE(VAR_9->code), VAR_33,
					       VAR_9->src_reg);
			if (VAR_11)
				return VAR_11;

			VAR_30 = &VAR_0->insn_aux_data[VAR_5].ptr_type;

			if (*VAR_30 == VAR_26) {
				*VAR_30 = VAR_31;
			} else if (VAR_31 != *VAR_30 &&
				   (VAR_31 == VAR_27 ||
				    *VAR_30 == VAR_27)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -VAR_28;
			}

		} else if (VAR_10 == VAR_34) {
			if (BPF_MODE(VAR_9->code) != VAR_35 ||
			    VAR_9->src_reg != VAR_36) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -VAR_28;
			}
			/* COMMENT_2 */
			VAR_11 = check_reg_arg(VAR_3, VAR_9->dst_reg, VAR_21);
			if (VAR_11)
				return VAR_11;

			/* COMMENT_19 */
			VAR_11 = check_mem_access(VAR_0, VAR_9->dst_reg, VAR_9->off,
					       BPF_SIZE(VAR_9->code), VAR_33,
					       -1);
			if (VAR_11)
				return VAR_11;

		} else if (VAR_10 == VAR_37) {
			u8 VAR_38 = BPF_OP(VAR_9->code);

			if (VAR_38 == VAR_39) {
				if (BPF_SRC(VAR_9->code) != VAR_40 ||
				    VAR_9->off != 0 ||
				    VAR_9->src_reg != VAR_36 ||
				    VAR_9->dst_reg != VAR_36) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -VAR_28;
				}

				VAR_11 = check_call(VAR_0, VAR_9->imm, VAR_5);
				if (VAR_11)
					return VAR_11;

			} else if (VAR_38 == VAR_41) {
				if (BPF_SRC(VAR_9->code) != VAR_40 ||
				    VAR_9->imm != 0 ||
				    VAR_9->src_reg != VAR_36 ||
				    VAR_9->dst_reg != VAR_36) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -VAR_28;
				}

				VAR_5 += VAR_9->off + 1;
				continue;

			} else if (VAR_38 == VAR_42) {
				if (BPF_SRC(VAR_9->code) != VAR_40 ||
				    VAR_9->imm != 0 ||
				    VAR_9->src_reg != VAR_36 ||
				    VAR_9->dst_reg != VAR_36) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -VAR_28;
				}

				/* COMMENT_20 */
                                             
                                                
                                                  
                                
       
				VAR_11 = check_reg_arg(VAR_3, VAR_36, VAR_21);
				if (VAR_11)
					return VAR_11;

				if (is_pointer_value(VAR_0, VAR_36)) {
					verbose(""R0 leaks addr as return value\n"");
					return -VAR_43;
				}

process_bpf_exit:
				VAR_5 = pop_stack(VAR_0, &VAR_6);
				if (VAR_5 < 0) {
					break;
				} else {
					VAR_8 = true;
					continue;
				}
			} else {
				VAR_11 = check_cond_jmp_op(VAR_0, VAR_9, &VAR_5);
				if (VAR_11)
					return VAR_11;
			}
		} else if (VAR_10 == VAR_44) {
			u8 VAR_45 = BPF_MODE(VAR_9->code);

			if (VAR_45 == VAR_46 || VAR_45 == VAR_47) {
				VAR_11 = check_ld_abs(VAR_0, VAR_9);
				if (VAR_11)
					return VAR_11;

			} else if (VAR_45 == VAR_48) {
				VAR_11 = check_ld_imm(VAR_0, VAR_9);
				if (VAR_11)
					return VAR_11;

				VAR_5++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -VAR_28;
			}
			reset_reg_range_values(VAR_3, VAR_9->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", VAR_10);
			return -VAR_28;
		}

		VAR_5++;
	}

	verbose(""processed %d insns\n"", VAR_7);
	return 0;
}",torvalds/linux/0d0e57697f162da4aa218b5feafe614fb666db07/verifier.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -54,7 +54,7 @@
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
-			print_bpf_insn(insn);
+			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);","{'deleted_lines': ['\t\t\tprint_bpf_insn(insn);'], 'added_lines': ['\t\t\tprint_bpf_insn(env, insn);']}",True,"The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls.",5.5,MEDIUM,1,valid,2017-05-07T22:04:09Z,1
CVE-2017-9076,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"ipv6/dccp: do not inherit ipv6_mc_list from parent

Like commit 657831ffc38e (""dccp/tcp: do not inherit mc_list from parent"")
we should clear ipv6_mc_list etc. for IPv6 sockets too.

Cc: Eric Dumazet <edumazet@google.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Acked-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",83eaddab4378db256d00d295bda6ca997cd13a52,https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52,net/dccp/ipv6.c,dccp_v6_request_recv_sock,"static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,
struct sk_buff *skb,
struct request_sock *req,
struct dst_entry *dst,
struct request_sock *req_unhash,
bool *own_req)
{
struct inet_request_sock *ireq = inet_rsk(req);
struct ipv6_pinfo *newnp;
const struct ipv6_pinfo *np = inet6_sk(sk);
struct ipv6_txoptions *opt;
struct inet_sock *newinet;
struct dccp6_sock *newdp6;
struct sock *newsk;
if (skb->protocol == htons(ETH_P_IP)) {
newsk = dccp_v4_request_recv_sock(sk, skb, req, dst,
req_unhash, own_req);
if (newsk == NULL)
return NULL;
newdp6 = (struct dccp6_sock *)newsk;
newinet = inet_sk(newsk);
newinet->pinet6 = &newdp6->inet6;
newnp = inet6_sk(newsk);
memcpy(newnp, np, sizeof(struct ipv6_pinfo));
newnp->saddr = newsk->sk_v6_rcv_saddr;
inet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;
newsk->sk_backlog_rcv = dccp_v4_do_rcv;
newnp->pktoptions  = NULL;
newnp->opt   = NULL;
newnp->mcast_oif   = inet6_iif(skb);
newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
dccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);
return newsk;
}
if (sk_acceptq_is_full(sk))
goto out_overflow;
if (!dst) {
struct flowi6 fl6;
dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);
if (!dst)
goto out;
}
newsk = dccp_create_openreq_child(sk, req, skb);
if (newsk == NULL)
goto out_nonewsk;
ip6_dst_store(newsk, dst, NULL, NULL);
newsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
NETIF_F_TSO);
newdp6 = (struct dccp6_sock *)newsk;
newinet = inet_sk(newsk);
newinet->pinet6 = &newdp6->inet6;
newnp = inet6_sk(newsk);
memcpy(newnp, np, sizeof(struct ipv6_pinfo));
newsk->sk_v6_daddr= ireq->ir_v6_rmt_addr;
newnp->saddr= ireq->ir_v6_loc_addr;
newsk->sk_v6_rcv_saddr= ireq->ir_v6_loc_addr;
newsk->sk_bound_dev_if= ireq->ir_iif;
newinet->inet_opt = NULL;
newnp->rxopt.all = np->rxopt.all;
newnp->pktoptions = NULL;
newnp->opt  = NULL;
newnp->mcast_oif  = inet6_iif(skb);
newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;
opt = ireq->ipv6_opt;
if (!opt)
opt = rcu_dereference(np->opt);
if (opt) {
opt = ipv6_dup_options(newsk, opt);
RCU_INIT_POINTER(newnp->opt, opt);
}
inet_csk(newsk)->icsk_ext_hdr_len = 0;
if (opt)
inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
opt->opt_flen;
dccp_sync_mss(newsk, dst_mtu(dst));
newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
newinet->inet_rcv_saddr = LOOPBACK4_IPV6;
if (__inet_inherit_port(sk, newsk) < 0) {
inet_csk_prepare_forced_close(newsk);
dccp_done(newsk);
goto out;
}
*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
if (*own_req && ireq->pktopts) {
newnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);
consume_skb(ireq->pktopts);
ireq->pktopts = NULL;
if (newnp->pktoptions)
skb_set_owner_r(newnp->pktoptions, newsk);
}
return newsk;
out_overflow:
__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
out_nonewsk:
dst_release(dst);
out:
__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);
return NULL;
}","static struct sock *dccp_v6_request_recv_sock(const struct sock *VAR_0,
struct sk_buff *VAR_1,
struct request_sock *VAR_2,
struct dst_entry *VAR_3,
struct request_sock *VAR_4,
bool *VAR_5)
{
struct inet_request_sock *VAR_6 = inet_rsk(VAR_2);
struct ipv6_pinfo *VAR_7;
const struct ipv6_pinfo *VAR_8 = inet6_sk(VAR_0);
struct ipv6_txoptions *VAR_9;
struct inet_sock *VAR_10;
struct dccp6_sock *VAR_11;
struct sock *VAR_12;
if (VAR_1->protocol == htons(VAR_13)) {
VAR_12 = dccp_v4_request_recv_sock(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_4, VAR_5);
if (VAR_12 == NULL)
return NULL;
VAR_11 = (struct dccp6_sock *)VAR_12;
VAR_10 = inet_sk(VAR_12);
VAR_10->pinet6 = &VAR_11->inet6;
VAR_7 = inet6_sk(VAR_12);
memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));
VAR_7->saddr = VAR_12->sk_v6_rcv_saddr;
inet_csk(VAR_12)->icsk_af_ops = &VAR_14;
VAR_12->sk_backlog_rcv = VAR_15;
VAR_7->pktoptions  = NULL;
VAR_7->opt   = NULL;
VAR_7->mcast_oif   = inet6_iif(VAR_1);
VAR_7->mcast_hops  = ipv6_hdr(VAR_1)->hop_limit;
dccp_sync_mss(VAR_12, inet_csk(VAR_12)->icsk_pmtu_cookie);
return VAR_12;
}
if (sk_acceptq_is_full(VAR_0))
goto out_overflow;
if (!VAR_3) {
struct flowi6 VAR_16;
VAR_3 = inet6_csk_route_req(VAR_0, &VAR_16, VAR_2, VAR_17);
if (!VAR_3)
goto out;
}
VAR_12 = dccp_create_openreq_child(VAR_0, VAR_2, VAR_1);
if (VAR_12 == NULL)
goto out_nonewsk;
ip6_dst_store(VAR_12, VAR_3, NULL, NULL);
VAR_12->sk_route_caps = VAR_3->dev->features & ~(VAR_18 |
VAR_19);
VAR_11 = (struct dccp6_sock *)VAR_12;
VAR_10 = inet_sk(VAR_12);
VAR_10->pinet6 = &VAR_11->inet6;
VAR_7 = inet6_sk(VAR_12);
memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));
VAR_12->sk_v6_daddr= VAR_6->ir_v6_rmt_addr;
VAR_7->saddr= VAR_6->ir_v6_loc_addr;
VAR_12->sk_v6_rcv_saddr= VAR_6->ir_v6_loc_addr;
VAR_12->sk_bound_dev_if= VAR_6->ir_iif;
VAR_10->inet_opt = NULL;
VAR_7->rxopt.all = VAR_8->rxopt.all;
VAR_7->pktoptions = NULL;
VAR_7->opt  = NULL;
VAR_7->mcast_oif  = inet6_iif(VAR_1);
VAR_7->mcast_hops = ipv6_hdr(VAR_1)->hop_limit;
VAR_9 = VAR_6->ipv6_opt;
if (!VAR_9)
VAR_9 = rcu_dereference(VAR_8->opt);
if (VAR_9) {
VAR_9 = ipv6_dup_options(VAR_12, VAR_9);
RCU_INIT_POINTER(VAR_7->opt, VAR_9);
}
inet_csk(VAR_12)->icsk_ext_hdr_len = 0;
if (VAR_9)
inet_csk(VAR_12)->icsk_ext_hdr_len = VAR_9->opt_nflen +
VAR_9->opt_flen;
dccp_sync_mss(VAR_12, dst_mtu(VAR_3));
VAR_10->inet_daddr = VAR_10->inet_saddr = VAR_20;
VAR_10->inet_rcv_saddr = VAR_20;
if (__inet_inherit_port(VAR_0, VAR_12) < 0) {
inet_csk_prepare_forced_close(VAR_12);
dccp_done(VAR_12);
goto out;
}
*VAR_5 = inet_ehash_nolisten(VAR_12, req_to_sk(VAR_4));
if (*VAR_5 && VAR_6->pktopts) {
VAR_7->pktoptions = skb_clone(VAR_6->pktopts, VAR_21);
consume_skb(VAR_6->pktopts);
VAR_6->pktopts = NULL;
if (VAR_7->pktoptions)
skb_set_owner_r(VAR_7->pktoptions, VAR_12);
}
return VAR_12;
out_overflow:
__NET_INC_STATS(sock_net(VAR_0), VAR_22);
out_nonewsk:
dst_release(VAR_3);
out:
__NET_INC_STATS(sock_net(VAR_0), VAR_23);
return NULL;
}",torvalds/linux/83eaddab4378db256d00d295bda6ca997cd13a52/ipv6.c/vul/before/0.json,"static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,
					      struct sk_buff *skb,
					      struct request_sock *req,
					      struct dst_entry *dst,
					      struct request_sock *req_unhash,
					      bool *own_req)
{
	struct inet_request_sock *ireq = inet_rsk(req);
	struct ipv6_pinfo *newnp;
	const struct ipv6_pinfo *np = inet6_sk(sk);
	struct ipv6_txoptions *opt;
	struct inet_sock *newinet;
	struct dccp6_sock *newdp6;
	struct sock *newsk;

	if (skb->protocol == htons(ETH_P_IP)) {
		/*
		 *	v6 mapped
		 */
		newsk = dccp_v4_request_recv_sock(sk, skb, req, dst,
						  req_unhash, own_req);
		if (newsk == NULL)
			return NULL;

		newdp6 = (struct dccp6_sock *)newsk;
		newinet = inet_sk(newsk);
		newinet->pinet6 = &newdp6->inet6;
		newnp = inet6_sk(newsk);

		memcpy(newnp, np, sizeof(struct ipv6_pinfo));

		newnp->saddr = newsk->sk_v6_rcv_saddr;

		inet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;
		newsk->sk_backlog_rcv = dccp_v4_do_rcv;
		newnp->pktoptions  = NULL;
		newnp->opt	   = NULL;
		newnp->ipv6_mc_list = NULL;
		newnp->ipv6_ac_list = NULL;
		newnp->ipv6_fl_list = NULL;
		newnp->mcast_oif   = inet6_iif(skb);
		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;

		/*
		 * No need to charge this sock to the relevant IPv6 refcnt debug socks count
		 * here, dccp_create_openreq_child now does this for us, see the comment in
		 * that function for the gory details. -acme
		 */

		/* It is tricky place. Until this moment IPv4 tcp
		   worked with IPv6 icsk.icsk_af_ops.
		   Sync it now.
		 */
		dccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);

		return newsk;
	}


	if (sk_acceptq_is_full(sk))
		goto out_overflow;

	if (!dst) {
		struct flowi6 fl6;

		dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);
		if (!dst)
			goto out;
	}

	newsk = dccp_create_openreq_child(sk, req, skb);
	if (newsk == NULL)
		goto out_nonewsk;

	/*
	 * No need to charge this sock to the relevant IPv6 refcnt debug socks
	 * count here, dccp_create_openreq_child now does this for us, see the
	 * comment in that function for the gory details. -acme
	 */

	ip6_dst_store(newsk, dst, NULL, NULL);
	newsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
						      NETIF_F_TSO);
	newdp6 = (struct dccp6_sock *)newsk;
	newinet = inet_sk(newsk);
	newinet->pinet6 = &newdp6->inet6;
	newnp = inet6_sk(newsk);

	memcpy(newnp, np, sizeof(struct ipv6_pinfo));

	newsk->sk_v6_daddr	= ireq->ir_v6_rmt_addr;
	newnp->saddr		= ireq->ir_v6_loc_addr;
	newsk->sk_v6_rcv_saddr	= ireq->ir_v6_loc_addr;
	newsk->sk_bound_dev_if	= ireq->ir_iif;

	/* Now IPv6 options...

	   First: no IPv4 options.
	 */
	newinet->inet_opt = NULL;

	/* Clone RX bits */
	newnp->rxopt.all = np->rxopt.all;

	newnp->ipv6_mc_list = NULL;
	newnp->ipv6_ac_list = NULL;
	newnp->ipv6_fl_list = NULL;
	newnp->pktoptions = NULL;
	newnp->opt	  = NULL;
	newnp->mcast_oif  = inet6_iif(skb);
	newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;

	/*
	 * Clone native IPv6 options from listening socket (if any)
	 *
	 * Yes, keeping reference count would be much more clever, but we make
	 * one more one thing there: reattach optmem to newsk.
	 */
	opt = ireq->ipv6_opt;
	if (!opt)
		opt = rcu_dereference(np->opt);
	if (opt) {
		opt = ipv6_dup_options(newsk, opt);
		RCU_INIT_POINTER(newnp->opt, opt);
	}
	inet_csk(newsk)->icsk_ext_hdr_len = 0;
	if (opt)
		inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
						    opt->opt_flen;

	dccp_sync_mss(newsk, dst_mtu(dst));

	newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
	newinet->inet_rcv_saddr = LOOPBACK4_IPV6;

	if (__inet_inherit_port(sk, newsk) < 0) {
		inet_csk_prepare_forced_close(newsk);
		dccp_done(newsk);
		goto out;
	}
	*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
	/* Clone pktoptions received with SYN, if we own the req */
	if (*own_req && ireq->pktopts) {
		newnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);
		consume_skb(ireq->pktopts);
		ireq->pktopts = NULL;
		if (newnp->pktoptions)
			skb_set_owner_r(newnp->pktoptions, newsk);
	}

	return newsk;

out_overflow:
	__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
out_nonewsk:
	dst_release(dst);
out:
	__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);
	return NULL;
}","static struct sock *dccp_v6_request_recv_sock(const struct sock *VAR_0,
					      struct sk_buff *VAR_1,
					      struct request_sock *VAR_2,
					      struct dst_entry *VAR_3,
					      struct request_sock *VAR_4,
					      bool *VAR_5)
{
	struct inet_request_sock *VAR_6 = inet_rsk(VAR_2);
	struct ipv6_pinfo *VAR_7;
	const struct ipv6_pinfo *VAR_8 = inet6_sk(VAR_0);
	struct ipv6_txoptions *VAR_9;
	struct inet_sock *VAR_10;
	struct dccp6_sock *VAR_11;
	struct sock *VAR_12;

	if (VAR_1->protocol == htons(VAR_13)) {
		/* COMMENT_0 */
              
     
		VAR_12 = dccp_v4_request_recv_sock(VAR_0, VAR_1, VAR_2, VAR_3,
						  VAR_4, VAR_5);
		if (VAR_12 == NULL)
			return NULL;

		VAR_11 = (struct dccp6_sock *)VAR_12;
		VAR_10 = inet_sk(VAR_12);
		VAR_10->pinet6 = &VAR_11->inet6;
		VAR_7 = inet6_sk(VAR_12);

		memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));

		VAR_7->saddr = VAR_12->sk_v6_rcv_saddr;

		inet_csk(VAR_12)->icsk_af_ops = &VAR_14;
		VAR_12->sk_backlog_rcv = VAR_15;
		VAR_7->pktoptions  = NULL;
		VAR_7->opt	   = NULL;
		VAR_7->ipv6_mc_list = NULL;
		VAR_7->ipv6_ac_list = NULL;
		VAR_7->ipv6_fl_list = NULL;
		VAR_7->mcast_oif   = inet6_iif(VAR_1);
		VAR_7->mcast_hops  = ipv6_hdr(VAR_1)->hop_limit;

		/* COMMENT_3 */
                                                                              
                                                                             
                                              
     

		/* COMMENT_8 */
                                       
                 
     
		dccp_sync_mss(VAR_12, inet_csk(VAR_12)->icsk_pmtu_cookie);

		return VAR_12;
	}


	if (sk_acceptq_is_full(VAR_0))
		goto out_overflow;

	if (!VAR_3) {
		struct flowi6 VAR_16;

		VAR_3 = inet6_csk_route_req(VAR_0, &VAR_16, VAR_2, VAR_17);
		if (!VAR_3)
			goto out;
	}

	VAR_12 = dccp_create_openreq_child(VAR_0, VAR_2, VAR_1);
	if (VAR_12 == NULL)
		goto out_nonewsk;

	/* COMMENT_12 */
                                                                       
                                                                       
                                                        
    

	ip6_dst_store(VAR_12, VAR_3, NULL, NULL);
	VAR_12->sk_route_caps = VAR_3->dev->features & ~(VAR_18 |
						      VAR_19);
	VAR_11 = (struct dccp6_sock *)VAR_12;
	VAR_10 = inet_sk(VAR_12);
	VAR_10->pinet6 = &VAR_11->inet6;
	VAR_7 = inet6_sk(VAR_12);

	memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));

	VAR_12->sk_v6_daddr	= VAR_6->ir_v6_rmt_addr;
	VAR_7->saddr		= VAR_6->ir_v6_loc_addr;
	VAR_12->sk_v6_rcv_saddr	= VAR_6->ir_v6_loc_addr;
	VAR_12->sk_bound_dev_if	= VAR_6->ir_iif;

	/* COMMENT_17 */

                           
    
	VAR_10->inet_opt = NULL;

	/* COMMENT_21 */
	VAR_7->rxopt.all = VAR_8->rxopt.all;

	VAR_7->ipv6_mc_list = NULL;
	VAR_7->ipv6_ac_list = NULL;
	VAR_7->ipv6_fl_list = NULL;
	VAR_7->pktoptions = NULL;
	VAR_7->opt	  = NULL;
	VAR_7->mcast_oif  = inet6_iif(VAR_1);
	VAR_7->mcast_hops = ipv6_hdr(VAR_1)->hop_limit;

	/* COMMENT_22 */
                                                            
   
                                                                       
                                                       
    
	VAR_9 = VAR_6->ipv6_opt;
	if (!VAR_9)
		VAR_9 = rcu_dereference(VAR_8->opt);
	if (VAR_9) {
		VAR_9 = ipv6_dup_options(VAR_12, VAR_9);
		RCU_INIT_POINTER(VAR_7->opt, VAR_9);
	}
	inet_csk(VAR_12)->icsk_ext_hdr_len = 0;
	if (VAR_9)
		inet_csk(VAR_12)->icsk_ext_hdr_len = VAR_9->opt_nflen +
						    VAR_9->opt_flen;

	dccp_sync_mss(VAR_12, dst_mtu(VAR_3));

	VAR_10->inet_daddr = VAR_10->inet_saddr = VAR_20;
	VAR_10->inet_rcv_saddr = VAR_20;

	if (__inet_inherit_port(VAR_0, VAR_12) < 0) {
		inet_csk_prepare_forced_close(VAR_12);
		dccp_done(VAR_12);
		goto out;
	}
	*VAR_5 = inet_ehash_nolisten(VAR_12, req_to_sk(VAR_4));
	/* COMMENT_28 */
	if (*VAR_5 && VAR_6->pktopts) {
		VAR_7->pktoptions = skb_clone(VAR_6->pktopts, VAR_21);
		consume_skb(VAR_6->pktopts);
		VAR_6->pktopts = NULL;
		if (VAR_7->pktoptions)
			skb_set_owner_r(VAR_7->pktoptions, VAR_12);
	}

	return VAR_12;

out_overflow:
	__NET_INC_STATS(sock_net(VAR_0), VAR_22);
out_nonewsk:
	dst_release(VAR_3);
out:
	__NET_INC_STATS(sock_net(VAR_0), VAR_23);
	return NULL;
}",torvalds/linux/83eaddab4378db256d00d295bda6ca997cd13a52/ipv6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,6 +35,9 @@
 		newsk->sk_backlog_rcv = dccp_v4_do_rcv;
 		newnp->pktoptions  = NULL;
 		newnp->opt	   = NULL;
+		newnp->ipv6_mc_list = NULL;
+		newnp->ipv6_ac_list = NULL;
+		newnp->ipv6_fl_list = NULL;
 		newnp->mcast_oif   = inet6_iif(skb);
 		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
 
@@ -99,6 +102,9 @@
 	/* Clone RX bits */
 	newnp->rxopt.all = np->rxopt.all;
 
+	newnp->ipv6_mc_list = NULL;
+	newnp->ipv6_ac_list = NULL;
+	newnp->ipv6_fl_list = NULL;
 	newnp->pktoptions = NULL;
 	newnp->opt	  = NULL;
 	newnp->mcast_oif  = inet6_iif(skb);","{'deleted_lines': [], 'added_lines': ['\t\tnewnp->ipv6_mc_list = NULL;', '\t\tnewnp->ipv6_ac_list = NULL;', '\t\tnewnp->ipv6_fl_list = NULL;', '\tnewnp->ipv6_mc_list = NULL;', '\tnewnp->ipv6_ac_list = NULL;', '\tnewnp->ipv6_fl_list = NULL;']}",True,"The dccp_v6_request_recv_sock function in net/dccp/ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890.",7.8,HIGH,2,valid,2017-05-09T23:59:54Z,1
CVE-2017-9076,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"ipv6/dccp: do not inherit ipv6_mc_list from parent

Like commit 657831ffc38e (""dccp/tcp: do not inherit mc_list from parent"")
we should clear ipv6_mc_list etc. for IPv6 sockets too.

Cc: Eric Dumazet <edumazet@google.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Acked-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",83eaddab4378db256d00d295bda6ca997cd13a52,https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52,net/ipv6/tcp_ipv6.c,tcp_v6_syn_recv_sock,"static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,
struct request_sock *req,
struct dst_entry *dst,
struct request_sock *req_unhash,
bool *own_req)
{
struct inet_request_sock *ireq;
struct ipv6_pinfo *newnp;
const struct ipv6_pinfo *np = inet6_sk(sk);
struct ipv6_txoptions *opt;
struct tcp6_sock *newtcp6sk;
struct inet_sock *newinet;
struct tcp_sock *newtp;
struct sock *newsk;
#ifdef CONFIG_TCP_MD5SIG
struct tcp_md5sig_key *key;
#endif
struct flowi6 fl6;
if (skb->protocol == htons(ETH_P_IP)) {
newsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,
req_unhash, own_req);
if (!newsk)
return NULL;
newtcp6sk = (struct tcp6_sock *)newsk;
inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;
newinet = inet_sk(newsk);
newnp = inet6_sk(newsk);
newtp = tcp_sk(newsk);
memcpy(newnp, np, sizeof(struct ipv6_pinfo));
newnp->saddr = newsk->sk_v6_rcv_saddr;
inet_csk(newsk)->icsk_af_ops = &ipv6_mapped;
newsk->sk_backlog_rcv = tcp_v4_do_rcv;
#ifdef CONFIG_TCP_MD5SIG
newtp->af_specific = &tcp_sock_ipv6_mapped_specific;
#endif
newnp->ipv6_ac_list = NULL;
newnp->ipv6_fl_list = NULL;
newnp->pktoptions  = NULL;
newnp->opt   = NULL;
newnp->mcast_oif   = tcp_v6_iif(skb);
newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
if (np->repflow)
newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));
tcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);
return newsk;
}
ireq = inet_rsk(req);
if (sk_acceptq_is_full(sk))
goto out_overflow;
if (!dst) {
dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);
if (!dst)
goto out;
}
newsk = tcp_create_openreq_child(sk, req, skb);
if (!newsk)
goto out_nonewsk;
newsk->sk_gso_type = SKB_GSO_TCPV6;
ip6_dst_store(newsk, dst, NULL, NULL);
inet6_sk_rx_dst_set(newsk, skb);
newtcp6sk = (struct tcp6_sock *)newsk;
inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;
newtp = tcp_sk(newsk);
newinet = inet_sk(newsk);
newnp = inet6_sk(newsk);
memcpy(newnp, np, sizeof(struct ipv6_pinfo));
newsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;
newnp->saddr = ireq->ir_v6_loc_addr;
newsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;
newsk->sk_bound_dev_if = ireq->ir_iif;
newinet->inet_opt = NULL;
newnp->ipv6_ac_list = NULL;
newnp->ipv6_fl_list = NULL;
newnp->rxopt.all = np->rxopt.all;
newnp->pktoptions = NULL;
newnp->opt  = NULL;
newnp->mcast_oif  = tcp_v6_iif(skb);
newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;
newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
if (np->repflow)
newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));
opt = ireq->ipv6_opt;
if (!opt)
opt = rcu_dereference(np->opt);
if (opt) {
opt = ipv6_dup_options(newsk, opt);
RCU_INIT_POINTER(newnp->opt, opt);
}
inet_csk(newsk)->icsk_ext_hdr_len = 0;
if (opt)
inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
opt->opt_flen;
tcp_ca_openreq_child(newsk, dst);
tcp_sync_mss(newsk, dst_mtu(dst));
newtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));
tcp_initialize_rcv_mss(newsk);
newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
newinet->inet_rcv_saddr = LOOPBACK4_IPV6;
#ifdef CONFIG_TCP_MD5SIG
key = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);
if (key) {
tcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,
AF_INET6, key->key, key->keylen,
sk_gfp_mask(sk, GFP_ATOMIC));
}
#endif
if (__inet_inherit_port(sk, newsk) < 0) {
inet_csk_prepare_forced_close(newsk);
tcp_done(newsk);
goto out;
}
*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
if (*own_req) {
tcp_move_syn(newtp, req);
if (ireq->pktopts) {
newnp->pktoptions = skb_clone(ireq->pktopts,
sk_gfp_mask(sk, GFP_ATOMIC));
consume_skb(ireq->pktopts);
ireq->pktopts = NULL;
if (newnp->pktoptions) {
tcp_v6_restore_cb(newnp->pktoptions);
skb_set_owner_r(newnp->pktoptions, newsk);
}
}
}
return newsk;
out_overflow:
__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
out_nonewsk:
dst_release(dst);
out:
tcp_listendrop(sk);
return NULL;
}","static struct sock *tcp_v6_syn_recv_sock(const struct sock *VAR_0, struct sk_buff *VAR_1,
struct request_sock *VAR_2,
struct dst_entry *VAR_3,
struct request_sock *VAR_4,
bool *VAR_5)
{
struct inet_request_sock *VAR_6;
struct ipv6_pinfo *VAR_7;
const struct ipv6_pinfo *VAR_8 = inet6_sk(VAR_0);
struct ipv6_txoptions *VAR_9;
struct tcp6_sock *VAR_10;
struct inet_sock *VAR_11;
struct tcp_sock *VAR_12;
struct sock *VAR_13;
#ifdef VAR_14
struct tcp_md5sig_key *VAR_15;
#endif
struct flowi6 VAR_16;
if (VAR_1->protocol == htons(VAR_17)) {
VAR_13 = tcp_v4_syn_recv_sock(VAR_0, VAR_1, VAR_2, VAR_3,
VAR_4, VAR_5);
if (!VAR_13)
return NULL;
VAR_10 = (struct tcp6_sock *)VAR_13;
inet_sk(VAR_13)->pinet6 = &VAR_10->inet6;
VAR_11 = inet_sk(VAR_13);
VAR_7 = inet6_sk(VAR_13);
VAR_12 = tcp_sk(VAR_13);
memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));
VAR_7->saddr = VAR_13->sk_v6_rcv_saddr;
inet_csk(VAR_13)->icsk_af_ops = &VAR_18;
VAR_13->sk_backlog_rcv = VAR_19;
#ifdef VAR_14
VAR_12->af_specific = &VAR_20;
#endif
VAR_7->ipv6_ac_list = NULL;
VAR_7->ipv6_fl_list = NULL;
VAR_7->pktoptions  = NULL;
VAR_7->opt   = NULL;
VAR_7->mcast_oif   = tcp_v6_iif(VAR_1);
VAR_7->mcast_hops  = ipv6_hdr(VAR_1)->hop_limit;
VAR_7->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(VAR_1));
if (VAR_8->repflow)
VAR_7->flow_label = ip6_flowlabel(ipv6_hdr(VAR_1));
tcp_sync_mss(VAR_13, inet_csk(VAR_13)->icsk_pmtu_cookie);
return VAR_13;
}
VAR_6 = inet_rsk(VAR_2);
if (sk_acceptq_is_full(VAR_0))
goto out_overflow;
if (!VAR_3) {
VAR_3 = inet6_csk_route_req(VAR_0, &VAR_16, VAR_2, VAR_21);
if (!VAR_3)
goto out;
}
VAR_13 = tcp_create_openreq_child(VAR_0, VAR_2, VAR_1);
if (!VAR_13)
goto out_nonewsk;
VAR_13->sk_gso_type = VAR_22;
ip6_dst_store(VAR_13, VAR_3, NULL, NULL);
inet6_sk_rx_dst_set(VAR_13, VAR_1);
VAR_10 = (struct tcp6_sock *)VAR_13;
inet_sk(VAR_13)->pinet6 = &VAR_10->inet6;
VAR_12 = tcp_sk(VAR_13);
VAR_11 = inet_sk(VAR_13);
VAR_7 = inet6_sk(VAR_13);
memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));
VAR_13->sk_v6_daddr = VAR_6->ir_v6_rmt_addr;
VAR_7->saddr = VAR_6->ir_v6_loc_addr;
VAR_13->sk_v6_rcv_saddr = VAR_6->ir_v6_loc_addr;
VAR_13->sk_bound_dev_if = VAR_6->ir_iif;
VAR_11->inet_opt = NULL;
VAR_7->ipv6_ac_list = NULL;
VAR_7->ipv6_fl_list = NULL;
VAR_7->rxopt.all = VAR_8->rxopt.all;
VAR_7->pktoptions = NULL;
VAR_7->opt  = NULL;
VAR_7->mcast_oif  = tcp_v6_iif(VAR_1);
VAR_7->mcast_hops = ipv6_hdr(VAR_1)->hop_limit;
VAR_7->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(VAR_1));
if (VAR_8->repflow)
VAR_7->flow_label = ip6_flowlabel(ipv6_hdr(VAR_1));
VAR_9 = VAR_6->ipv6_opt;
if (!VAR_9)
VAR_9 = rcu_dereference(VAR_8->opt);
if (VAR_9) {
VAR_9 = ipv6_dup_options(VAR_13, VAR_9);
RCU_INIT_POINTER(VAR_7->opt, VAR_9);
}
inet_csk(VAR_13)->icsk_ext_hdr_len = 0;
if (VAR_9)
inet_csk(VAR_13)->icsk_ext_hdr_len = VAR_9->opt_nflen +
VAR_9->opt_flen;
tcp_ca_openreq_child(VAR_13, VAR_3);
tcp_sync_mss(VAR_13, dst_mtu(VAR_3));
VAR_12->advmss = tcp_mss_clamp(tcp_sk(VAR_0), dst_metric_advmss(VAR_3));
tcp_initialize_rcv_mss(VAR_13);
VAR_11->inet_daddr = VAR_11->inet_saddr = VAR_23;
VAR_11->inet_rcv_saddr = VAR_23;
#ifdef VAR_14
VAR_15 = tcp_v6_md5_do_lookup(VAR_0, &VAR_13->sk_v6_daddr);
if (VAR_15) {
tcp_md5_do_add(VAR_13, (union tcp_md5_addr *)&VAR_13->sk_v6_daddr,
VAR_24, VAR_15->key, VAR_15->keylen,
sk_gfp_mask(VAR_0, VAR_25));
}
#endif
if (__inet_inherit_port(VAR_0, VAR_13) < 0) {
inet_csk_prepare_forced_close(VAR_13);
tcp_done(VAR_13);
goto out;
}
*VAR_5 = inet_ehash_nolisten(VAR_13, req_to_sk(VAR_4));
if (*VAR_5) {
tcp_move_syn(VAR_12, VAR_2);
if (VAR_6->pktopts) {
VAR_7->pktoptions = skb_clone(VAR_6->pktopts,
sk_gfp_mask(VAR_0, VAR_25));
consume_skb(VAR_6->pktopts);
VAR_6->pktopts = NULL;
if (VAR_7->pktoptions) {
tcp_v6_restore_cb(VAR_7->pktoptions);
skb_set_owner_r(VAR_7->pktoptions, VAR_13);
}
}
}
return VAR_13;
out_overflow:
__NET_INC_STATS(sock_net(VAR_0), VAR_26);
out_nonewsk:
dst_release(VAR_3);
out:
tcp_listendrop(VAR_0);
return NULL;
}",torvalds/linux/83eaddab4378db256d00d295bda6ca997cd13a52/tcp_ipv6.c/vul/before/0.json,"static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,
					 struct request_sock *req,
					 struct dst_entry *dst,
					 struct request_sock *req_unhash,
					 bool *own_req)
{
	struct inet_request_sock *ireq;
	struct ipv6_pinfo *newnp;
	const struct ipv6_pinfo *np = inet6_sk(sk);
	struct ipv6_txoptions *opt;
	struct tcp6_sock *newtcp6sk;
	struct inet_sock *newinet;
	struct tcp_sock *newtp;
	struct sock *newsk;
#ifdef CONFIG_TCP_MD5SIG
	struct tcp_md5sig_key *key;
#endif
	struct flowi6 fl6;

	if (skb->protocol == htons(ETH_P_IP)) {
		/*
		 *	v6 mapped
		 */

		newsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,
					     req_unhash, own_req);

		if (!newsk)
			return NULL;

		newtcp6sk = (struct tcp6_sock *)newsk;
		inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;

		newinet = inet_sk(newsk);
		newnp = inet6_sk(newsk);
		newtp = tcp_sk(newsk);

		memcpy(newnp, np, sizeof(struct ipv6_pinfo));

		newnp->saddr = newsk->sk_v6_rcv_saddr;

		inet_csk(newsk)->icsk_af_ops = &ipv6_mapped;
		newsk->sk_backlog_rcv = tcp_v4_do_rcv;
#ifdef CONFIG_TCP_MD5SIG
		newtp->af_specific = &tcp_sock_ipv6_mapped_specific;
#endif

		newnp->ipv6_mc_list = NULL;
		newnp->ipv6_ac_list = NULL;
		newnp->ipv6_fl_list = NULL;
		newnp->pktoptions  = NULL;
		newnp->opt	   = NULL;
		newnp->mcast_oif   = tcp_v6_iif(skb);
		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
		newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
		if (np->repflow)
			newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));

		/*
		 * No need to charge this sock to the relevant IPv6 refcnt debug socks count
		 * here, tcp_create_openreq_child now does this for us, see the comment in
		 * that function for the gory details. -acme
		 */

		/* It is tricky place. Until this moment IPv4 tcp
		   worked with IPv6 icsk.icsk_af_ops.
		   Sync it now.
		 */
		tcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);

		return newsk;
	}

	ireq = inet_rsk(req);

	if (sk_acceptq_is_full(sk))
		goto out_overflow;

	if (!dst) {
		dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);
		if (!dst)
			goto out;
	}

	newsk = tcp_create_openreq_child(sk, req, skb);
	if (!newsk)
		goto out_nonewsk;

	/*
	 * No need to charge this sock to the relevant IPv6 refcnt debug socks
	 * count here, tcp_create_openreq_child now does this for us, see the
	 * comment in that function for the gory details. -acme
	 */

	newsk->sk_gso_type = SKB_GSO_TCPV6;
	ip6_dst_store(newsk, dst, NULL, NULL);
	inet6_sk_rx_dst_set(newsk, skb);

	newtcp6sk = (struct tcp6_sock *)newsk;
	inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;

	newtp = tcp_sk(newsk);
	newinet = inet_sk(newsk);
	newnp = inet6_sk(newsk);

	memcpy(newnp, np, sizeof(struct ipv6_pinfo));

	newsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;
	newnp->saddr = ireq->ir_v6_loc_addr;
	newsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;
	newsk->sk_bound_dev_if = ireq->ir_iif;

	/* Now IPv6 options...

	   First: no IPv4 options.
	 */
	newinet->inet_opt = NULL;
	newnp->ipv6_mc_list = NULL;
	newnp->ipv6_ac_list = NULL;
	newnp->ipv6_fl_list = NULL;

	/* Clone RX bits */
	newnp->rxopt.all = np->rxopt.all;

	newnp->pktoptions = NULL;
	newnp->opt	  = NULL;
	newnp->mcast_oif  = tcp_v6_iif(skb);
	newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;
	newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
	if (np->repflow)
		newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));

	/* Clone native IPv6 options from listening socket (if any)

	   Yes, keeping reference count would be much more clever,
	   but we make one more one thing there: reattach optmem
	   to newsk.
	 */
	opt = ireq->ipv6_opt;
	if (!opt)
		opt = rcu_dereference(np->opt);
	if (opt) {
		opt = ipv6_dup_options(newsk, opt);
		RCU_INIT_POINTER(newnp->opt, opt);
	}
	inet_csk(newsk)->icsk_ext_hdr_len = 0;
	if (opt)
		inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
						    opt->opt_flen;

	tcp_ca_openreq_child(newsk, dst);

	tcp_sync_mss(newsk, dst_mtu(dst));
	newtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));

	tcp_initialize_rcv_mss(newsk);

	newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
	newinet->inet_rcv_saddr = LOOPBACK4_IPV6;

#ifdef CONFIG_TCP_MD5SIG
	/* Copy over the MD5 key from the original socket */
	key = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);
	if (key) {
		/* We're using one, so create a matching key
		 * on the newsk structure. If we fail to get
		 * memory, then we end up not copying the key
		 * across. Shucks.
		 */
		tcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,
			       AF_INET6, key->key, key->keylen,
			       sk_gfp_mask(sk, GFP_ATOMIC));
	}
#endif

	if (__inet_inherit_port(sk, newsk) < 0) {
		inet_csk_prepare_forced_close(newsk);
		tcp_done(newsk);
		goto out;
	}
	*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
	if (*own_req) {
		tcp_move_syn(newtp, req);

		/* Clone pktoptions received with SYN, if we own the req */
		if (ireq->pktopts) {
			newnp->pktoptions = skb_clone(ireq->pktopts,
						      sk_gfp_mask(sk, GFP_ATOMIC));
			consume_skb(ireq->pktopts);
			ireq->pktopts = NULL;
			if (newnp->pktoptions) {
				tcp_v6_restore_cb(newnp->pktoptions);
				skb_set_owner_r(newnp->pktoptions, newsk);
			}
		}
	}

	return newsk;

out_overflow:
	__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
out_nonewsk:
	dst_release(dst);
out:
	tcp_listendrop(sk);
	return NULL;
}","static struct sock *tcp_v6_syn_recv_sock(const struct sock *VAR_0, struct sk_buff *VAR_1,
					 struct request_sock *VAR_2,
					 struct dst_entry *VAR_3,
					 struct request_sock *VAR_4,
					 bool *VAR_5)
{
	struct inet_request_sock *VAR_6;
	struct ipv6_pinfo *VAR_7;
	const struct ipv6_pinfo *VAR_8 = inet6_sk(VAR_0);
	struct ipv6_txoptions *VAR_9;
	struct tcp6_sock *VAR_10;
	struct inet_sock *VAR_11;
	struct tcp_sock *VAR_12;
	struct sock *VAR_13;
#ifdef VAR_14
	struct tcp_md5sig_key *VAR_15;
#endif
	struct flowi6 VAR_16;

	if (VAR_1->protocol == htons(VAR_17)) {
		/* COMMENT_0 */
              
     

		VAR_13 = tcp_v4_syn_recv_sock(VAR_0, VAR_1, VAR_2, VAR_3,
					     VAR_4, VAR_5);

		if (!VAR_13)
			return NULL;

		VAR_10 = (struct tcp6_sock *)VAR_13;
		inet_sk(VAR_13)->pinet6 = &VAR_10->inet6;

		VAR_11 = inet_sk(VAR_13);
		VAR_7 = inet6_sk(VAR_13);
		VAR_12 = tcp_sk(VAR_13);

		memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));

		VAR_7->saddr = VAR_13->sk_v6_rcv_saddr;

		inet_csk(VAR_13)->icsk_af_ops = &VAR_18;
		VAR_13->sk_backlog_rcv = VAR_19;
#ifdef VAR_14
		VAR_12->af_specific = &VAR_20;
#endif

		VAR_7->ipv6_mc_list = NULL;
		VAR_7->ipv6_ac_list = NULL;
		VAR_7->ipv6_fl_list = NULL;
		VAR_7->pktoptions  = NULL;
		VAR_7->opt	   = NULL;
		VAR_7->mcast_oif   = tcp_v6_iif(VAR_1);
		VAR_7->mcast_hops  = ipv6_hdr(VAR_1)->hop_limit;
		VAR_7->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(VAR_1));
		if (VAR_8->repflow)
			VAR_7->flow_label = ip6_flowlabel(ipv6_hdr(VAR_1));

		/* COMMENT_3 */
                                                                              
                                                                            
                                              
     

		/* COMMENT_8 */
                                       
                 
     
		tcp_sync_mss(VAR_13, inet_csk(VAR_13)->icsk_pmtu_cookie);

		return VAR_13;
	}

	VAR_6 = inet_rsk(VAR_2);

	if (sk_acceptq_is_full(VAR_0))
		goto out_overflow;

	if (!VAR_3) {
		VAR_3 = inet6_csk_route_req(VAR_0, &VAR_16, VAR_2, VAR_21);
		if (!VAR_3)
			goto out;
	}

	VAR_13 = tcp_create_openreq_child(VAR_0, VAR_2, VAR_1);
	if (!VAR_13)
		goto out_nonewsk;

	/* COMMENT_12 */
                                                                       
                                                                      
                                                        
    

	VAR_13->sk_gso_type = VAR_22;
	ip6_dst_store(VAR_13, VAR_3, NULL, NULL);
	inet6_sk_rx_dst_set(VAR_13, VAR_1);

	VAR_10 = (struct tcp6_sock *)VAR_13;
	inet_sk(VAR_13)->pinet6 = &VAR_10->inet6;

	VAR_12 = tcp_sk(VAR_13);
	VAR_11 = inet_sk(VAR_13);
	VAR_7 = inet6_sk(VAR_13);

	memcpy(VAR_7, VAR_8, sizeof(struct ipv6_pinfo));

	VAR_13->sk_v6_daddr = VAR_6->ir_v6_rmt_addr;
	VAR_7->saddr = VAR_6->ir_v6_loc_addr;
	VAR_13->sk_v6_rcv_saddr = VAR_6->ir_v6_loc_addr;
	VAR_13->sk_bound_dev_if = VAR_6->ir_iif;

	/* COMMENT_17 */

                           
    
	VAR_11->inet_opt = NULL;
	VAR_7->ipv6_mc_list = NULL;
	VAR_7->ipv6_ac_list = NULL;
	VAR_7->ipv6_fl_list = NULL;

	/* COMMENT_21 */
	VAR_7->rxopt.all = VAR_8->rxopt.all;

	VAR_7->pktoptions = NULL;
	VAR_7->opt	  = NULL;
	VAR_7->mcast_oif  = tcp_v6_iif(VAR_1);
	VAR_7->mcast_hops = ipv6_hdr(VAR_1)->hop_limit;
	VAR_7->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(VAR_1));
	if (VAR_8->repflow)
		VAR_7->flow_label = ip6_flowlabel(ipv6_hdr(VAR_1));

	/* COMMENT_22 */

                                                           
                                                         
             
    
	VAR_9 = VAR_6->ipv6_opt;
	if (!VAR_9)
		VAR_9 = rcu_dereference(VAR_8->opt);
	if (VAR_9) {
		VAR_9 = ipv6_dup_options(VAR_13, VAR_9);
		RCU_INIT_POINTER(VAR_7->opt, VAR_9);
	}
	inet_csk(VAR_13)->icsk_ext_hdr_len = 0;
	if (VAR_9)
		inet_csk(VAR_13)->icsk_ext_hdr_len = VAR_9->opt_nflen +
						    VAR_9->opt_flen;

	tcp_ca_openreq_child(VAR_13, VAR_3);

	tcp_sync_mss(VAR_13, dst_mtu(VAR_3));
	VAR_12->advmss = tcp_mss_clamp(tcp_sk(VAR_0), dst_metric_advmss(VAR_3));

	tcp_initialize_rcv_mss(VAR_13);

	VAR_11->inet_daddr = VAR_11->inet_saddr = VAR_23;
	VAR_11->inet_rcv_saddr = VAR_23;

#ifdef VAR_14
	/* COMMENT_28 */
	VAR_15 = tcp_v6_md5_do_lookup(VAR_0, &VAR_13->sk_v6_daddr);
	if (VAR_15) {
		/* COMMENT_29 */
                                              
                                               
                    
     
		tcp_md5_do_add(VAR_13, (union tcp_md5_addr *)&VAR_13->sk_v6_daddr,
			       VAR_24, VAR_15->key, VAR_15->keylen,
			       sk_gfp_mask(VAR_0, VAR_25));
	}
#endif

	if (__inet_inherit_port(VAR_0, VAR_13) < 0) {
		inet_csk_prepare_forced_close(VAR_13);
		tcp_done(VAR_13);
		goto out;
	}
	*VAR_5 = inet_ehash_nolisten(VAR_13, req_to_sk(VAR_4));
	if (*VAR_5) {
		tcp_move_syn(VAR_12, VAR_2);

		/* COMMENT_34 */
		if (VAR_6->pktopts) {
			VAR_7->pktoptions = skb_clone(VAR_6->pktopts,
						      sk_gfp_mask(VAR_0, VAR_25));
			consume_skb(VAR_6->pktopts);
			VAR_6->pktopts = NULL;
			if (VAR_7->pktoptions) {
				tcp_v6_restore_cb(VAR_7->pktoptions);
				skb_set_owner_r(VAR_7->pktoptions, VAR_13);
			}
		}
	}

	return VAR_13;

out_overflow:
	__NET_INC_STATS(sock_net(VAR_0), VAR_26);
out_nonewsk:
	dst_release(VAR_3);
out:
	tcp_listendrop(VAR_0);
	return NULL;
}",torvalds/linux/83eaddab4378db256d00d295bda6ca997cd13a52/tcp_ipv6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,6 +45,7 @@
 		newtp->af_specific = &tcp_sock_ipv6_mapped_specific;
 #endif
 
+		newnp->ipv6_mc_list = NULL;
 		newnp->ipv6_ac_list = NULL;
 		newnp->ipv6_fl_list = NULL;
 		newnp->pktoptions  = NULL;
@@ -114,6 +115,7 @@
 	   First: no IPv4 options.
 	 */
 	newinet->inet_opt = NULL;
+	newnp->ipv6_mc_list = NULL;
 	newnp->ipv6_ac_list = NULL;
 	newnp->ipv6_fl_list = NULL;
 ","{'deleted_lines': [], 'added_lines': ['\t\tnewnp->ipv6_mc_list = NULL;', '\tnewnp->ipv6_mc_list = NULL;']}",True,"The dccp_v6_request_recv_sock function in net/dccp/ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890.",7.8,HIGH,2,valid,2017-05-09T23:59:54Z,1
CVE-2017-9217,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,systemd,"resolved: bugfix of null pointer p->question dereferencing (#6020)

See https://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1621396",a924f43f30f9c4acaf70618dd2a055f8b0f166be,https://github.com/systemd/systemd/commit/a924f43f30f9c4acaf70618dd2a055f8b0f166be,src/resolve/resolved-dns-packet.c,dns_packet_is_reply_for,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
int r;
assert(p);
assert(key);
if (DNS_PACKET_QR(p) != 1)
return 0;
r = dns_packet_extract(p);
if (r < 0)
return r;
if (p->question->n_keys != 1)
return 0;
return dns_resource_key_equal(p->question->keys[0], key);
}","int dns_packet_is_reply_for(DnsPacket *VAR_0, const DnsResourceKey *VAR_1) {
int VAR_2;
assert(VAR_0);
assert(VAR_1);
if (DNS_PACKET_QR(VAR_0) != 1)
return 0;
VAR_2 = dns_packet_extract(VAR_0);
if (VAR_2 < 0)
return VAR_2;
if (VAR_0->question->n_keys != 1)
return 0;
return dns_resource_key_equal(VAR_0->question->keys[0], VAR_1);
}",systemd/a924f43f30f9c4acaf70618dd2a055f8b0f166be/resolved-dns-packet.c/vul/before/0.json,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
        if (r < 0)
                return r;

        if (!p->question)
                return 0;

        if (p->question->n_keys != 1)
                return 0;

        return dns_resource_key_equal(p->question->keys[0], key);
}","int dns_packet_is_reply_for(DnsPacket *VAR_0, const DnsResourceKey *VAR_1) {
        int VAR_2;

        assert(VAR_0);
        assert(VAR_1);

        /* COMMENT_0 */
                                                                    
                      

        if (DNS_PACKET_QR(VAR_0) != 1)
                return 0;

        /* COMMENT_3 */
        VAR_2 = dns_packet_extract(VAR_0);
        if (VAR_2 < 0)
                return VAR_2;

        if (!VAR_0->question)
                return 0;

        if (VAR_0->question->n_keys != 1)
                return 0;

        return dns_resource_key_equal(VAR_0->question->keys[0], VAR_1);
}",systemd/a924f43f30f9c4acaf70618dd2a055f8b0f166be/resolved-dns-packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,6 +16,9 @@
         if (r < 0)
                 return r;
 
+        if (!p->question)
+                return 0;
+
         if (p->question->n_keys != 1)
                 return 0;
 ","{'deleted_lines': [], 'added_lines': ['        if (!p->question)', '                return 0;', '']}",True,systemd-resolved through 233 allows remote attackers to cause a denial of service (daemon crash) via a crafted DNS response with an empty question section.,7.5,HIGH,2,valid,2017-05-24T05:56:48Z,1
CVE-2017-18221,['CWE-20'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"mlock: fix mlock count can not decrease in race condition

Kefeng reported that when running the follow test, the mlock count in
meminfo will increase permanently:

 [1] testcase
 linux:~ # cat test_mlockal
 grep Mlocked /proc/meminfo
  for j in `seq 0 10`
  do
 	for i in `seq 4 15`
 	do
 		./p_mlockall >> log &
 	done
 	sleep 0.2
 done
 # wait some time to let mlock counter decrease and 5s may not enough
 sleep 5
 grep Mlocked /proc/meminfo

 linux:~ # cat p_mlockall.c
 #include <sys/mman.h>
 #include <stdlib.h>
 #include <stdio.h>

 #define SPACE_LEN	4096

 int main(int argc, char ** argv)
 {
	 	int ret;
	 	void *adr = malloc(SPACE_LEN);
	 	if (!adr)
	 		return -1;

	 	ret = mlockall(MCL_CURRENT | MCL_FUTURE);
	 	printf(""mlcokall ret = %d\n"", ret);

	 	ret = munlockall();
	 	printf(""munlcokall ret = %d\n"", ret);

	 	free(adr);
	 	return 0;
	 }

In __munlock_pagevec() we should decrement NR_MLOCK for each page where
we clear the PageMlocked flag.  Commit 1ebb7cc6a583 (""mm: munlock: batch
NR_MLOCK zone state updates"") has introduced a bug where we don't
decrement NR_MLOCK for pages where we clear the flag, but fail to
isolate them from the lru list (e.g.  when the pages are on some other
cpu's percpu pagevec).  Since PageMlocked stays cleared, the NR_MLOCK
accounting gets permanently disrupted by this.

Fix it by counting the number of page whose PageMlock flag is cleared.

Fixes: 1ebb7cc6a583 ("" mm: munlock: batch NR_MLOCK zone state updates"")
Link: http://lkml.kernel.org/r/1495678405-54569-1-git-send-email-xieyisheng1@huawei.com
Signed-off-by: Yisheng Xie <xieyisheng1@huawei.com>
Reported-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Cc: Vlastimil Babka <vbabka@suse.cz>
Cc: Joern Engel <joern@logfs.org>
Cc: Mel Gorman <mgorman@suse.de>
Cc: Michel Lespinasse <walken@google.com>
Cc: Hugh Dickins <hughd@google.com>
Cc: Rik van Riel <riel@redhat.com>
Cc: Johannes Weiner <hannes@cmpxchg.org>
Cc: Michal Hocko <mhocko@suse.cz>
Cc: Xishi Qiu <qiuxishi@huawei.com>
Cc: zhongjiang <zhongjiang@huawei.com>
Cc: Hanjun Guo <guohanjun@huawei.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",70feee0e1ef331b22cc51f383d532a0d043fbdcc,https://github.com/torvalds/linux/commit/70feee0e1ef331b22cc51f383d532a0d043fbdcc,mm/mlock.c,__munlock_pagevec,"static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)
{
int i;
int nr = pagevec_count(pvec);
int delta_munlocked;
struct pagevec pvec_putback;
int pgrescued = 0;
pagevec_init(&pvec_putback, 0);
spin_lock_irq(zone_lru_lock(zone));
for (i = 0; i < nr; i++) {
struct page *page = pvec->pages[i];
if (TestClearPageMlocked(page)) {
if (__munlock_isolate_lru_page(page, false))
continue;
else
__munlock_isolation_failed(page);
}
pagevec_add(&pvec_putback, pvec->pages[i]);
pvec->pages[i] = NULL;
}
delta_munlocked = -nr + pagevec_count(&pvec_putback);
__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);
spin_unlock_irq(zone_lru_lock(zone));
pagevec_release(&pvec_putback);
for (i = 0; i < nr; i++) {
struct page *page = pvec->pages[i];
if (page) {
lock_page(page);
if (!__putback_lru_fast_prepare(page, &pvec_putback,
&pgrescued)) {
get_page(page); 
__munlock_isolated_page(page);
unlock_page(page);
put_page(page); 
}
}
}
if (pagevec_count(&pvec_putback))
__putback_lru_fast(&pvec_putback, pgrescued);
}","static void __munlock_pagevec(struct pagevec *VAR_0, struct zone *zone)
{
int VAR_1;
int VAR_2 = pagevec_count(VAR_0);
int VAR_3;
struct pagevec VAR_4;
int VAR_5 = 0;
pagevec_init(&VAR_4, 0);
spin_lock_irq(zone_lru_lock(zone));
for (VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {
struct page *page = VAR_0->pages[VAR_1];
if (TestClearPageMlocked(page)) {
if (__munlock_isolate_lru_page(page, false))
continue;
else
__munlock_isolation_failed(page);
}
pagevec_add(&VAR_4, VAR_0->pages[VAR_1]);
VAR_0->pages[VAR_1] = NULL;
}
VAR_3 = -VAR_2 + pagevec_count(&VAR_4);
__mod_zone_page_state(zone, VAR_6, VAR_3);
spin_unlock_irq(zone_lru_lock(zone));
pagevec_release(&VAR_4);
for (VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {
struct page *page = VAR_0->pages[VAR_1];
if (page) {
lock_page(page);
if (!__putback_lru_fast_prepare(page, &VAR_4,
&VAR_5)) {
get_page(page); 
__munlock_isolated_page(page);
unlock_page(page);
put_page(page); 
}
}
}
if (pagevec_count(&VAR_4))
__putback_lru_fast(&VAR_4, VAR_5);
}",torvalds/linux/70feee0e1ef331b22cc51f383d532a0d043fbdcc/mlock.c/vul/before/0.json,"static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)
{
	int i;
	int nr = pagevec_count(pvec);
	int delta_munlocked = -nr;
	struct pagevec pvec_putback;
	int pgrescued = 0;

	pagevec_init(&pvec_putback, 0);

	/* Phase 1: page isolation */
	spin_lock_irq(zone_lru_lock(zone));
	for (i = 0; i < nr; i++) {
		struct page *page = pvec->pages[i];

		if (TestClearPageMlocked(page)) {
			/*
			 * We already have pin from follow_page_mask()
			 * so we can spare the get_page() here.
			 */
			if (__munlock_isolate_lru_page(page, false))
				continue;
			else
				__munlock_isolation_failed(page);
		} else {
			delta_munlocked++;
		}

		/*
		 * We won't be munlocking this page in the next phase
		 * but we still need to release the follow_page_mask()
		 * pin. We cannot do it under lru_lock however. If it's
		 * the last pin, __page_cache_release() would deadlock.
		 */
		pagevec_add(&pvec_putback, pvec->pages[i]);
		pvec->pages[i] = NULL;
	}
	__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);
	spin_unlock_irq(zone_lru_lock(zone));

	/* Now we can release pins of pages that we are not munlocking */
	pagevec_release(&pvec_putback);

	/* Phase 2: page munlock */
	for (i = 0; i < nr; i++) {
		struct page *page = pvec->pages[i];

		if (page) {
			lock_page(page);
			if (!__putback_lru_fast_prepare(page, &pvec_putback,
					&pgrescued)) {
				/*
				 * Slow path. We don't want to lose the last
				 * pin before unlock_page()
				 */
				get_page(page); /* for putback_lru_page() */
				__munlock_isolated_page(page);
				unlock_page(page);
				put_page(page); /* from follow_page_mask() */
			}
		}
	}

	/*
	 * Phase 3: page putback for pages that qualified for the fast path
	 * This will also call put_page() to return pin from follow_page_mask()
	 */
	if (pagevec_count(&pvec_putback))
		__putback_lru_fast(&pvec_putback, pgrescued);
}","static void __munlock_pagevec(struct pagevec *VAR_0, struct zone *zone)
{
	int VAR_1;
	int VAR_2 = pagevec_count(VAR_0);
	int VAR_3 = -VAR_2;
	struct pagevec VAR_4;
	int VAR_5 = 0;

	pagevec_init(&VAR_4, 0);

	/* COMMENT_0 */
	spin_lock_irq(zone_lru_lock(zone));
	for (VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {
		struct page *page = VAR_0->pages[VAR_1];

		if (TestClearPageMlocked(page)) {
			/* COMMENT_1 */
                                                 
                                          
      
			if (__munlock_isolate_lru_page(page, false))
				continue;
			else
				__munlock_isolation_failed(page);
		} else {
			VAR_3++;
		}

		/* COMMENT_5 */
                                                       
                                                        
                                                         
                                                         
     
		pagevec_add(&VAR_4, VAR_0->pages[VAR_1]);
		VAR_0->pages[VAR_1] = NULL;
	}
	__mod_zone_page_state(zone, VAR_6, VAR_3);
	spin_unlock_irq(zone_lru_lock(zone));

	/* COMMENT_11 */
	pagevec_release(&VAR_4);

	/* COMMENT_12 */
	for (VAR_1 = 0; VAR_1 < VAR_2; VAR_1++) {
		struct page *page = VAR_0->pages[VAR_1];

		if (page) {
			lock_page(page);
			if (!__putback_lru_fast_prepare(page, &VAR_4,
					&VAR_5)) {
				/* COMMENT_13 */
                                                
                               
       
				get_page(page); /* COMMENT_17 */
				__munlock_isolated_page(page);
				unlock_page(page);
				put_page(page); /* COMMENT_18 */
			}
		}
	}

	/* COMMENT_19 */
                                                                    
                                                                        
    
	if (pagevec_count(&VAR_4))
		__putback_lru_fast(&VAR_4, VAR_5);
}",torvalds/linux/70feee0e1ef331b22cc51f383d532a0d043fbdcc/mlock.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
 	int i;
 	int nr = pagevec_count(pvec);
-	int delta_munlocked;
+	int delta_munlocked = -nr;
 	struct pagevec pvec_putback;
 	int pgrescued = 0;
 
@@ -22,6 +22,8 @@
 				continue;
 			else
 				__munlock_isolation_failed(page);
+		} else {
+			delta_munlocked++;
 		}
 
 		/*
@@ -33,7 +35,6 @@
 		pagevec_add(&pvec_putback, pvec->pages[i]);
 		pvec->pages[i] = NULL;
 	}
-	delta_munlocked = -nr + pagevec_count(&pvec_putback);
 	__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);
 	spin_unlock_irq(zone_lru_lock(zone));
 ","{'deleted_lines': ['\tint delta_munlocked;', '\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);'], 'added_lines': ['\tint delta_munlocked = -nr;', '\t\t} else {', '\t\t\tdelta_munlocked++;']}",True,The __munlock_pagevec function in mm/mlock.c in the Linux kernel before 4.11.4 allows local users to cause a denial of service (NR_MLOCK accounting corruption) via crafted use of mlockall and munlockall system calls.,5.5,MEDIUM,1,valid,2017-06-02T21:46:43Z,1
CVE-2017-16931,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,GNOME/libxml2,"Fix handling of parameter-entity references

There were two bugs where parameter-entity references could lead to an
unexpected change of the input buffer in xmlParseNameComplex and
xmlDictLookup being called with an invalid pointer.

Percent sign in DTD Names
=========================

The NEXTL macro used to call xmlParserHandlePEReference. When parsing
""complex"" names inside the DTD, this could result in entity expansion
which created a new input buffer. The fix is to simply remove the call
to xmlParserHandlePEReference from the NEXTL macro. This is safe because
no users of the macro require expansion of parameter entities.

- xmlParseNameComplex
- xmlParseNCNameComplex
- xmlParseNmtoken

The percent sign is not allowed in names, which are grammatical tokens.

- xmlParseEntityValue

Parameter-entity references in entity values are expanded but this
happens in a separate step in this function.

- xmlParseSystemLiteral

Parameter-entity references are ignored in the system literal.

- xmlParseAttValueComplex
- xmlParseCharDataComplex
- xmlParseCommentComplex
- xmlParsePI
- xmlParseCDSect

Parameter-entity references are ignored outside the DTD.

- xmlLoadEntityContent

This function is only called from xmlStringLenDecodeEntities and
entities are replaced in a separate step immediately after the function
call.

This bug could also be triggered with an internal subset and double
entity expansion.

This fixes bug 766956 initially reported by Wei Lei and independently by
Chromium's ClusterFuzz, Hanno Bck, and Marco Grassi. Thanks to everyone
involved.

xmlParseNameComplex with XML_PARSE_OLD10
========================================

When parsing Names inside an expanded parameter entity with the
XML_PARSE_OLD10 option, xmlParseNameComplex would call xmlGROW via the
GROW macro if the input buffer was exhausted. At the end of the
parameter entity's replacement text, this function would then call
xmlPopInput which invalidated the input buffer.

There should be no need to invoke GROW in this situation because the
buffer is grown periodically every XML_PARSER_CHUNK_SIZE characters and,
at least for UTF-8, in xmlCurrentChar. This also matches the code path
executed when XML_PARSE_OLD10 is not set.

This fixes bugs 781205 (CVE-2017-9049) and 781361 (CVE-2017-9050).
Thanks to Marcel Bhme and Thuan Pham for the report.

Additional hardening
====================

A separate check was added in xmlParseNameComplex to validate the
buffer size.",e26630548e7d138d2c560844c43820b6767251e3,https://github.com/GNOME/libxml2/commit/e26630548e7d138d2c560844c43820b6767251e3,parser.c,xmlParseNameComplex,"static const xmlChar *
xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
int len = 0, l;
int c;
int count = 0;
#ifdef DEBUG
nbParseNameComplex++;
#endif
GROW;
if (ctxt->instate == XML_PARSER_EOF)
return(NULL);
c = CUR_CHAR(l);
if ((ctxt->options & XML_PARSE_OLD10) == 0) {
if ((c == ' ') || (c == '>') || (c == '/') || 
(!(((c >= 'a') && (c <= 'z')) ||
((c >= 'A') && (c <= 'Z')) ||
(c == '_') || (c == ':') ||
((c >= 0xC0) && (c <= 0xD6)) ||
((c >= 0xD8) && (c <= 0xF6)) ||
((c >= 0xF8) && (c <= 0x2FF)) ||
((c >= 0x370) && (c <= 0x37D)) ||
((c >= 0x37F) && (c <= 0x1FFF)) ||
((c >= 0x200C) && (c <= 0x200D)) ||
((c >= 0x2070) && (c <= 0x218F)) ||
((c >= 0x2C00) && (c <= 0x2FEF)) ||
((c >= 0x3001) && (c <= 0xD7FF)) ||
((c >= 0xF900) && (c <= 0xFDCF)) ||
((c >= 0xFDF0) && (c <= 0xFFFD)) ||
((c >= 0x10000) && (c <= 0xEFFFF))))) {
return(NULL);
}
len += l;
NEXTL(l);
c = CUR_CHAR(l);
while ((c != ' ') && (c != '>') && (c != '/') && 
(((c >= 'a') && (c <= 'z')) ||
((c >= 'A') && (c <= 'Z')) ||
((c >= '0') && (c <= '9')) || 
(c == '_') || (c == ':') ||
(c == '-') || (c == '.') || (c == 0xB7) || 
((c >= 0xC0) && (c <= 0xD6)) ||
((c >= 0xD8) && (c <= 0xF6)) ||
((c >= 0xF8) && (c <= 0x2FF)) ||
((c >= 0x300) && (c <= 0x36F)) || 
((c >= 0x370) && (c <= 0x37D)) ||
((c >= 0x37F) && (c <= 0x1FFF)) ||
((c >= 0x200C) && (c <= 0x200D)) ||
((c >= 0x203F) && (c <= 0x2040)) || 
((c >= 0x2070) && (c <= 0x218F)) ||
((c >= 0x2C00) && (c <= 0x2FEF)) ||
((c >= 0x3001) && (c <= 0xD7FF)) ||
((c >= 0xF900) && (c <= 0xFDCF)) ||
((c >= 0xFDF0) && (c <= 0xFFFD)) ||
((c >= 0x10000) && (c <= 0xEFFFF))
)) {
if (count++ > XML_PARSER_CHUNK_SIZE) {
count = 0;
GROW;
if (ctxt->instate == XML_PARSER_EOF)
return(NULL);
}
len += l;
NEXTL(l);
c = CUR_CHAR(l);
}
} else {
if ((c == ' ') || (c == '>') || (c == '/') || 
(!IS_LETTER(c) && (c != '_') &&
(c != ':'))) {
return(NULL);
}
len += l;
NEXTL(l);
c = CUR_CHAR(l);
while ((c != ' ') && (c != '>') && (c != '/') && 
((IS_LETTER(c)) || (IS_DIGIT(c)) ||
(c == '.') || (c == '-') ||
(c == '_') || (c == ':') ||
(IS_COMBINING(c)) ||
(IS_EXTENDER(c)))) {
if (count++ > XML_PARSER_CHUNK_SIZE) {
count = 0;
GROW;
if (ctxt->instate == XML_PARSER_EOF)
return(NULL);
}
len += l;
NEXTL(l);
c = CUR_CHAR(l);
if (c == 0) {
count = 0;
GROW;
if (ctxt->instate == XML_PARSER_EOF)
return(NULL);
c = CUR_CHAR(l);
}
}
}
if ((len > XML_MAX_NAME_LENGTH) &&
((ctxt->options & XML_PARSE_HUGE) == 0)) {
xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, ""Name"");
return(NULL);
}
if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","static const xmlChar *
xmlParseNameComplex(xmlParserCtxtPtr VAR_0) {
int VAR_1 = 0, VAR_2;
int VAR_3;
int VAR_4 = 0;
#ifdef VAR_5
VAR_6++;
#endif
VAR_7;
if (VAR_0->instate == VAR_8)
return(NULL);
VAR_3 = CUR_CHAR(VAR_2);
if ((VAR_0->options & VAR_9) == 0) {
if ((VAR_3 == ' ') || (VAR_3 == '>') || (VAR_3 == '/') || 
(!(((VAR_3 >= 'a') && (VAR_3 <= 'z')) ||
((VAR_3 >= 'A') && (VAR_3 <= 'Z')) ||
(VAR_3 == '_') || (VAR_3 == ':') ||
((VAR_3 >= 0xC0) && (VAR_3 <= 0xD6)) ||
((VAR_3 >= 0xD8) && (VAR_3 <= 0xF6)) ||
((VAR_3 >= 0xF8) && (VAR_3 <= 0x2FF)) ||
((VAR_3 >= 0x370) && (VAR_3 <= 0x37D)) ||
((VAR_3 >= 0x37F) && (VAR_3 <= 0x1FFF)) ||
((VAR_3 >= 0x200C) && (VAR_3 <= 0x200D)) ||
((VAR_3 >= 0x2070) && (VAR_3 <= 0x218F)) ||
((VAR_3 >= 0x2C00) && (VAR_3 <= 0x2FEF)) ||
((VAR_3 >= 0x3001) && (VAR_3 <= 0xD7FF)) ||
((VAR_3 >= 0xF900) && (VAR_3 <= 0xFDCF)) ||
((VAR_3 >= 0xFDF0) && (VAR_3 <= 0xFFFD)) ||
((VAR_3 >= 0x10000) && (VAR_3 <= 0xEFFFF))))) {
return(NULL);
}
VAR_1 += VAR_2;
NEXTL(VAR_2);
VAR_3 = CUR_CHAR(VAR_2);
while ((VAR_3 != ' ') && (VAR_3 != '>') && (VAR_3 != '/') && 
(((VAR_3 >= 'a') && (VAR_3 <= 'z')) ||
((VAR_3 >= 'A') && (VAR_3 <= 'Z')) ||
((VAR_3 >= '0') && (VAR_3 <= '9')) || 
(VAR_3 == '_') || (VAR_3 == ':') ||
(VAR_3 == '-') || (VAR_3 == '.') || (VAR_3 == 0xB7) || 
((VAR_3 >= 0xC0) && (VAR_3 <= 0xD6)) ||
((VAR_3 >= 0xD8) && (VAR_3 <= 0xF6)) ||
((VAR_3 >= 0xF8) && (VAR_3 <= 0x2FF)) ||
((VAR_3 >= 0x300) && (VAR_3 <= 0x36F)) || 
((VAR_3 >= 0x370) && (VAR_3 <= 0x37D)) ||
((VAR_3 >= 0x37F) && (VAR_3 <= 0x1FFF)) ||
((VAR_3 >= 0x200C) && (VAR_3 <= 0x200D)) ||
((VAR_3 >= 0x203F) && (VAR_3 <= 0x2040)) || 
((VAR_3 >= 0x2070) && (VAR_3 <= 0x218F)) ||
((VAR_3 >= 0x2C00) && (VAR_3 <= 0x2FEF)) ||
((VAR_3 >= 0x3001) && (VAR_3 <= 0xD7FF)) ||
((VAR_3 >= 0xF900) && (VAR_3 <= 0xFDCF)) ||
((VAR_3 >= 0xFDF0) && (VAR_3 <= 0xFFFD)) ||
((VAR_3 >= 0x10000) && (VAR_3 <= 0xEFFFF))
)) {
if (VAR_4++ > VAR_10) {
VAR_4 = 0;
VAR_7;
if (VAR_0->instate == VAR_8)
return(NULL);
}
VAR_1 += VAR_2;
NEXTL(VAR_2);
VAR_3 = CUR_CHAR(VAR_2);
}
} else {
if ((VAR_3 == ' ') || (VAR_3 == '>') || (VAR_3 == '/') || 
(!IS_LETTER(VAR_3) && (VAR_3 != '_') &&
(VAR_3 != ':'))) {
return(NULL);
}
VAR_1 += VAR_2;
NEXTL(VAR_2);
VAR_3 = CUR_CHAR(VAR_2);
while ((VAR_3 != ' ') && (VAR_3 != '>') && (VAR_3 != '/') && 
((IS_LETTER(VAR_3)) || (IS_DIGIT(VAR_3)) ||
(VAR_3 == '.') || (VAR_3 == '-') ||
(VAR_3 == '_') || (VAR_3 == ':') ||
(IS_COMBINING(VAR_3)) ||
(IS_EXTENDER(VAR_3)))) {
if (VAR_4++ > VAR_10) {
VAR_4 = 0;
VAR_7;
if (VAR_0->instate == VAR_8)
return(NULL);
}
VAR_1 += VAR_2;
NEXTL(VAR_2);
VAR_3 = CUR_CHAR(VAR_2);
if (VAR_3 == 0) {
VAR_4 = 0;
VAR_7;
if (VAR_0->instate == VAR_8)
return(NULL);
VAR_3 = CUR_CHAR(VAR_2);
}
}
}
if ((VAR_1 > VAR_11) &&
((VAR_0->options & VAR_12) == 0)) {
xmlFatalErr(VAR_0, VAR_13, ""Name"");
return(NULL);
}
if ((*VAR_0->input->cur == '\n') && (VAR_0->input->cur[-1] == '\r'))
return(xmlDictLookup(VAR_0->dict, VAR_0->input->cur - (VAR_1 + 1), VAR_1));
return(xmlDictLookup(VAR_0->dict, VAR_0->input->cur - VAR_1, VAR_1));
}",GNOME/libxml2/e26630548e7d138d2c560844c43820b6767251e3/parser.c/vul/before/0.json,"static const xmlChar *
xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;

#ifdef DEBUG
    nbParseNameComplex++;
#endif

    /*
     * Handler for more complex cases
     */
    GROW;
    if (ctxt->instate == XML_PARSER_EOF)
        return(NULL);
    c = CUR_CHAR(l);
    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
        /*
	 * Use the new checks of production [4] [4a] amd [5] of the
	 * Update 5 of XML-1.0
	 */
	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	    (!(((c >= 'a') && (c <= 'z')) ||
	       ((c >= 'A') && (c <= 'Z')) ||
	       (c == '_') || (c == ':') ||
	       ((c >= 0xC0) && (c <= 0xD6)) ||
	       ((c >= 0xD8) && (c <= 0xF6)) ||
	       ((c >= 0xF8) && (c <= 0x2FF)) ||
	       ((c >= 0x370) && (c <= 0x37D)) ||
	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
	       ((c >= 0x200C) && (c <= 0x200D)) ||
	       ((c >= 0x2070) && (c <= 0x218F)) ||
	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
	    return(NULL);
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
	       (((c >= 'a') && (c <= 'z')) ||
	        ((c >= 'A') && (c <= 'Z')) ||
	        ((c >= '0') && (c <= '9')) || /* !start */
	        (c == '_') || (c == ':') ||
	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
	        ((c >= 0xC0) && (c <= 0xD6)) ||
	        ((c >= 0xD8) && (c <= 0xF6)) ||
	        ((c >= 0xF8) && (c <= 0x2FF)) ||
	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
	        ((c >= 0x370) && (c <= 0x37D)) ||
	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
	        ((c >= 0x200C) && (c <= 0x200D)) ||
	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
	        ((c >= 0x2070) && (c <= 0x218F)) ||
	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
	        ((c >= 0x10000) && (c <= 0xEFFFF))
		)) {
	    if (count++ > XML_PARSER_CHUNK_SIZE) {
		count = 0;
		GROW;
                if (ctxt->instate == XML_PARSER_EOF)
                    return(NULL);
	    }
	    len += l;
	    NEXTL(l);
	    c = CUR_CHAR(l);
	}
    } else {
	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	    (!IS_LETTER(c) && (c != '_') &&
	     (c != ':'))) {
	    return(NULL);
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);

	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
		(c == '.') || (c == '-') ||
		(c == '_') || (c == ':') ||
		(IS_COMBINING(c)) ||
		(IS_EXTENDER(c)))) {
	    if (count++ > XML_PARSER_CHUNK_SIZE) {
		count = 0;
		GROW;
                if (ctxt->instate == XML_PARSER_EOF)
                    return(NULL);
	    }
	    len += l;
	    NEXTL(l);
	    c = CUR_CHAR(l);
	}
    }
    if ((len > XML_MAX_NAME_LENGTH) &&
        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, ""Name"");
        return(NULL);
    }
    if (ctxt->input->cur - ctxt->input->base < len) {
        /*
         * There were a couple of bugs where PERefs lead to to a change
         * of the buffer. Check the buffer size to avoid passing an invalid
         * pointer to xmlDictLookup.
         */
        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                    ""unexpected change of input buffer"");
        return (NULL);
    }
    if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","static const xmlChar *
xmlParseNameComplex(xmlParserCtxtPtr VAR_0) {
    int VAR_1 = 0, VAR_2;
    int VAR_3;
    int VAR_4 = 0;

#ifdef VAR_5
    VAR_6++;
#endif

    /* COMMENT_0 */
                                     
       
    VAR_7;
    if (VAR_0->instate == VAR_8)
        return(NULL);
    VAR_3 = CUR_CHAR(VAR_2);
    if ((VAR_0->options & VAR_9) == 0) {
        /* COMMENT_3 */
                                                            
                       
    
	if ((VAR_3 == ' ') || (VAR_3 == '>') || (VAR_3 == '/') || /* COMMENT_7 */
	    (!(((VAR_3 >= 'a') && (VAR_3 <= 'z')) ||
	       ((VAR_3 >= 'A') && (VAR_3 <= 'Z')) ||
	       (VAR_3 == '_') || (VAR_3 == ':') ||
	       ((VAR_3 >= 0xC0) && (VAR_3 <= 0xD6)) ||
	       ((VAR_3 >= 0xD8) && (VAR_3 <= 0xF6)) ||
	       ((VAR_3 >= 0xF8) && (VAR_3 <= 0x2FF)) ||
	       ((VAR_3 >= 0x370) && (VAR_3 <= 0x37D)) ||
	       ((VAR_3 >= 0x37F) && (VAR_3 <= 0x1FFF)) ||
	       ((VAR_3 >= 0x200C) && (VAR_3 <= 0x200D)) ||
	       ((VAR_3 >= 0x2070) && (VAR_3 <= 0x218F)) ||
	       ((VAR_3 >= 0x2C00) && (VAR_3 <= 0x2FEF)) ||
	       ((VAR_3 >= 0x3001) && (VAR_3 <= 0xD7FF)) ||
	       ((VAR_3 >= 0xF900) && (VAR_3 <= 0xFDCF)) ||
	       ((VAR_3 >= 0xFDF0) && (VAR_3 <= 0xFFFD)) ||
	       ((VAR_3 >= 0x10000) && (VAR_3 <= 0xEFFFF))))) {
	    return(NULL);
	}
	VAR_1 += VAR_2;
	NEXTL(VAR_2);
	VAR_3 = CUR_CHAR(VAR_2);
	while ((VAR_3 != ' ') && (VAR_3 != '>') && (VAR_3 != '/') && /* COMMENT_7 */
	       (((VAR_3 >= 'a') && (VAR_3 <= 'z')) ||
	        ((VAR_3 >= 'A') && (VAR_3 <= 'Z')) ||
	        ((VAR_3 >= '0') && (VAR_3 <= '9')) || /* COMMENT_8 */
	        (VAR_3 == '_') || (VAR_3 == ':') ||
	        (VAR_3 == '-') || (VAR_3 == '.') || (VAR_3 == 0xB7) || /* COMMENT_8 */
	        ((VAR_3 >= 0xC0) && (VAR_3 <= 0xD6)) ||
	        ((VAR_3 >= 0xD8) && (VAR_3 <= 0xF6)) ||
	        ((VAR_3 >= 0xF8) && (VAR_3 <= 0x2FF)) ||
	        ((VAR_3 >= 0x300) && (VAR_3 <= 0x36F)) || /* COMMENT_8 */
	        ((VAR_3 >= 0x370) && (VAR_3 <= 0x37D)) ||
	        ((VAR_3 >= 0x37F) && (VAR_3 <= 0x1FFF)) ||
	        ((VAR_3 >= 0x200C) && (VAR_3 <= 0x200D)) ||
	        ((VAR_3 >= 0x203F) && (VAR_3 <= 0x2040)) || /* COMMENT_8 */
	        ((VAR_3 >= 0x2070) && (VAR_3 <= 0x218F)) ||
	        ((VAR_3 >= 0x2C00) && (VAR_3 <= 0x2FEF)) ||
	        ((VAR_3 >= 0x3001) && (VAR_3 <= 0xD7FF)) ||
	        ((VAR_3 >= 0xF900) && (VAR_3 <= 0xFDCF)) ||
	        ((VAR_3 >= 0xFDF0) && (VAR_3 <= 0xFFFD)) ||
	        ((VAR_3 >= 0x10000) && (VAR_3 <= 0xEFFFF))
		)) {
	    if (VAR_4++ > VAR_10) {
		VAR_4 = 0;
		VAR_7;
                if (VAR_0->instate == VAR_8)
                    return(NULL);
	    }
	    VAR_1 += VAR_2;
	    NEXTL(VAR_2);
	    VAR_3 = CUR_CHAR(VAR_2);
	}
    } else {
	if ((VAR_3 == ' ') || (VAR_3 == '>') || (VAR_3 == '/') || /* COMMENT_7 */
	    (!IS_LETTER(VAR_3) && (VAR_3 != '_') &&
	     (VAR_3 != ':'))) {
	    return(NULL);
	}
	VAR_1 += VAR_2;
	NEXTL(VAR_2);
	VAR_3 = CUR_CHAR(VAR_2);

	while ((VAR_3 != ' ') && (VAR_3 != '>') && (VAR_3 != '/') && /* COMMENT_9 */
	       ((IS_LETTER(VAR_3)) || (IS_DIGIT(VAR_3)) ||
		(VAR_3 == '.') || (VAR_3 == '-') ||
		(VAR_3 == '_') || (VAR_3 == ':') ||
		(IS_COMBINING(VAR_3)) ||
		(IS_EXTENDER(VAR_3)))) {
	    if (VAR_4++ > VAR_10) {
		VAR_4 = 0;
		VAR_7;
                if (VAR_0->instate == VAR_8)
                    return(NULL);
	    }
	    VAR_1 += VAR_2;
	    NEXTL(VAR_2);
	    VAR_3 = CUR_CHAR(VAR_2);
	}
    }
    if ((VAR_1 > VAR_11) &&
        ((VAR_0->options & VAR_12) == 0)) {
        xmlFatalErr(VAR_0, VAR_13, ""Name"");
        return(NULL);
    }
    if (VAR_0->input->cur - VAR_0->input->base < VAR_1) {
        /* COMMENT_10 */
                                                                       
                                                                           
                                    
           
        xmlFatalErr(VAR_0, VAR_14,
                    ""unexpected change of input buffer"");
        return (NULL);
    }
    if ((*VAR_0->input->cur == '\n') && (VAR_0->input->cur[-1] == '\r'))
        return(xmlDictLookup(VAR_0->dict, VAR_0->input->cur - (VAR_1 + 1), VAR_1));
    return(xmlDictLookup(VAR_0->dict, VAR_0->input->cur - VAR_1, VAR_1));
}",GNOME/libxml2/e26630548e7d138d2c560844c43820b6767251e3/parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -97,13 +97,6 @@
 	    len += l;
 	    NEXTL(l);
 	    c = CUR_CHAR(l);
-	    if (c == 0) {
-		count = 0;
-		GROW;
-                if (ctxt->instate == XML_PARSER_EOF)
-                    return(NULL);
-		c = CUR_CHAR(l);
-	    }
 	}
     }
     if ((len > XML_MAX_NAME_LENGTH) &&
@@ -111,6 +104,16 @@
         xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, ""Name"");
         return(NULL);
     }
+    if (ctxt->input->cur - ctxt->input->base < len) {
+        /*
+         * There were a couple of bugs where PERefs lead to to a change
+         * of the buffer. Check the buffer size to avoid passing an invalid
+         * pointer to xmlDictLookup.
+         */
+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
+                    ""unexpected change of input buffer"");
+        return (NULL);
+    }
     if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
         return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));","{'deleted_lines': ['\t    if (c == 0) {', '\t\tcount = 0;', '\t\tGROW;', '                if (ctxt->instate == XML_PARSER_EOF)', '                    return(NULL);', '\t\tc = CUR_CHAR(l);', '\t    }'], 'added_lines': ['    if (ctxt->input->cur - ctxt->input->base < len) {', '        /*', '         * There were a couple of bugs where PERefs lead to to a change', '         * of the buffer. Check the buffer size to avoid passing an invalid', '         * pointer to xmlDictLookup.', '         */', '        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,', '                    ""unexpected change of input buffer"");', '        return (NULL);', '    }']}",True,parser.c in libxml2 before 2.9.5 mishandles parameter-entity references because the NEXTL macro calls the xmlParserHandlePEReference function in the case of a '%' character in a DTD name.,9.8,CRITICAL,3,valid,2017-06-05T13:37:17Z,1
CVE-2017-11411,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,wireshark,"OpenSafety: sanity check calculated length.

Original sanity check was missed for fragmentation

Bug: 13755
Change-Id: If9e24e01a119c869b02f198456776c8e6c6f2ad0
Reviewed-on: https://code.wireshark.org/review/22193
Reviewed-by: Michael Mann <mmann78@netscape.net>
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Roland Knall <rknall@gmail.com>
(cherry picked from commit 66c50585e5c10764d0b8a850fd49fa7012346560)
Reviewed-on: https://code.wireshark.org/review/22680
Reviewed-by: Gerald Combs <gerald@wireshark.org>",a83a324acdfc07a0ca8b65e6ebaba3374ab19c76,https://github.com/wireshark/wireshark/commit/a83a324acdfc07a0ca8b65e6ebaba3374ab19c76,epan/dissectors/packet-opensafety.c,dissect_opensafety_ssdo_message,"static void
dissect_opensafety_ssdo_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *opensafety_tree,
opensafety_packet_info * packet, proto_item * opensafety_item )
{
proto_item    *item;
proto_tree    *ssdo_tree, *ssdo_payload;
guint16        taddr                = 0, sdn = 0, server = 0, client = 0, n = 0, ct = 0;
guint32        abortcode, ssdoIndex = 0, ssdoSubIndex = 0, payloadSize, fragmentId = 0, entry = 0;
guint8         db0Offset, db0, payloadOffset, preload;
guint          dataLength;
gint           calcDataLength;
gboolean       isResponse, saveFragmented;
tvbuff_t      *new_tvb              = NULL;
fragment_head *frag_msg             = NULL;
static const int * ssdo_sacmd_flags[] = {
&hf_oss_ssdo_sacmd_end_segment,
&hf_oss_ssdo_sacmd_initiate,
&hf_oss_ssdo_sacmd_toggle,
&hf_oss_ssdo_sacmd_segmentation,
&hf_oss_ssdo_sacmd_abort_transfer,
&hf_oss_ssdo_sacmd_preload,
&hf_oss_ssdo_sacmd_access_type,
NULL
};
dataLength = tvb_get_guint8(message_tvb, OSS_FRAME_POS_LEN + packet->frame.subframe1);
db0Offset = packet->frame.subframe1 + OSS_FRAME_POS_DATA;
db0 = tvb_get_guint8(message_tvb, db0Offset);
ssdoIndex = 0;
ssdoSubIndex = 0;
isResponse = ( ( OSS_FRAME_ID_T(message_tvb, packet->frame.subframe1) & 0x04 ) == 0x04 );
if ( packet->scm_udid_valid )
{
taddr = OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2 + 3, packet->scm_udid[3], packet->scm_udid[4]);
sdn =  ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ^
( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) );
opensafety_packet_sendreceiv ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet, taddr,
packet->frame.subframe2 + 3, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
packet->frame.subframe1, packet->frame.subframe2, sdn );
}
else if ( ! isResponse )
{
opensafety_packet_sender ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
}
else if ( isResponse )
{
opensafety_packet_receiver ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
}
ssdo_tree = opensafety_packet_payloadtree ( message_tvb, opensafety_tree, packet, ett_opensafety_ssdo );
opensafety_packet_response ( message_tvb, ssdo_tree, packet, isResponse );
packet->payload.ssdo->sacmd.toggle = ( db0 & OPENSAFETY_SSDO_SACMD_TGL ) == OPENSAFETY_SSDO_SACMD_TGL;
packet->payload.ssdo->sacmd.abort_transfer = ( db0 & OPENSAFETY_SSDO_SACMD_ABRT ) == OPENSAFETY_SSDO_SACMD_ABRT;
packet->payload.ssdo->sacmd.preload = ( db0 & OPENSAFETY_SSDO_SACMD_PRLD ) == OPENSAFETY_SSDO_SACMD_PRLD;
packet->payload.ssdo->sacmd.read_access = ( db0 & OPENSAFETY_SSDO_DOWNLOAD ) == OPENSAFETY_SSDO_DOWNLOAD;
packet->payload.ssdo->sacmd.initiate = ( db0 & OPENSAFETY_SSDO_SACMD_INI ) == OPENSAFETY_SSDO_SACMD_INI;
packet->payload.ssdo->sacmd.segmented = ( db0 & OPENSAFETY_SSDO_SACMD_SEG ) == OPENSAFETY_SSDO_SACMD_SEG;
packet->payload.ssdo->sacmd.end_segment = ( db0 & OPENSAFETY_SSDO_SACMD_ENSG ) == OPENSAFETY_SSDO_SACMD_ENSG;
if ( isResponse )
{
opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
packet->frame.subframe1, packet->frame.subframe2, sdn );
client = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);
if ( packet->scm_udid_valid )
{
proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe2 + 3, 2, taddr);
server = taddr;
}
}
else if ( ! isResponse )
{
proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe1, 2, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1));
server = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);
if ( packet->scm_udid_valid )
{
opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
taddr, packet->frame.subframe2 + 3, packet->frame.subframe2, sdn );
client = taddr;
}
}
if ( packet->payload.ssdo->sacmd.toggle )
db0 &= (~OPENSAFETY_SSDO_SACMD_TGL);
proto_tree_add_bitmask(ssdo_tree, message_tvb, db0Offset, hf_oss_ssdo_sacmd,
ett_opensafety_ssdo_sacmd, ssdo_sacmd_flags, ENC_NA);
col_append_fstr(pinfo->cinfo, COL_INFO, "", SACMD: %s"", val_to_str_const(db0, opensafety_ssdo_sacmd_values, "" ""));
payloadOffset = db0Offset + 1;
ct = tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3);
if ( packet->scm_udid_valid )
{
ct = (guint16)((tvb_get_guint8(message_tvb, packet->frame.subframe2 + 2) ^ packet->scm_udid[2]) << 8);
ct += (tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3));
}
proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_sano, message_tvb, packet->frame.subframe1 + 3, 1, ct );
if ( packet->scm_udid_valid && packet->payload.ssdo->sacmd.preload && isResponse )
{
preload = ( (tvb_get_guint8(message_tvb, packet->frame.subframe2 + 4) ^ packet->scm_udid[4]) & 0xFC ) >> 2;
if ( packet->payload.ssdo->sacmd.initiate )
{
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_preload_queue, message_tvb, packet->frame.subframe2 + 4, 1,
preload & 0x0F, ""%d"", preload & 0x0F );
}
else
{
item = proto_tree_add_item(ssdo_tree, hf_oss_ssdo_preload_error, message_tvb, packet->frame.subframe2 + 4, 1, ENC_NA );
if ( (preload & 0x30) == 0x30 )
proto_item_append_text(item, "" (SOD Access Request Number is last successful)"" );
}
}
if ( packet->payload.ssdo->sacmd.initiate && !packet->payload.ssdo->sacmd.abort_transfer )
{
ssdoIndex = tvb_get_letohs(message_tvb, db0Offset + 1);
ssdoSubIndex = tvb_get_guint8(message_tvb, db0Offset + 3);
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_index, message_tvb, db0Offset + 1, 2,
ssdoIndex, ""0x%04X (%s)"", ssdoIndex,
val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown"") );
col_append_fstr(pinfo->cinfo, COL_INFO, "" [%s"", val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown""));
if ( ssdoSubIndex != 0x0 )
{
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_subindex, message_tvb, db0Offset + 3, 1,
ssdoSubIndex, ""0x%02X (%s)"", ssdoSubIndex,
val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown"") );
col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"",
val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown""));
}
col_append_fstr(pinfo->cinfo, COL_INFO, ""%s"", ""]"" );
payloadOffset += 3;
}
if ( packet->payload.ssdo->sacmd.abort_transfer )
{
abortcode = tvb_get_letohl(message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4);
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_abort_code, message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4, 4, abortcode,
""0x%04X %04X - %s"", (guint16)(abortcode >> 16), (guint16)(abortcode),
val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));
col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"", val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));
} else {
if ( ( packet->payload.ssdo->sacmd.initiate || packet->payload.ssdo->sacmd.segmented || packet->payload.ssdo->sacmd.end_segment ) &&
( ( isResponse && !packet->payload.ssdo->sacmd.read_access ) ||
( !isResponse && packet->payload.ssdo->sacmd.read_access ) ) )
{
saveFragmented = pinfo->fragmented;
if ( server != 0 && client != 0 )
fragmentId = (guint32)((((guint32)client) << 16 ) + server );
if ( packet->payload.ssdo->sacmd.segmented && packet->payload.ssdo->sacmd.initiate )
{
payloadOffset += 4;
payloadSize = tvb_get_letohl(message_tvb, payloadOffset - 4);
calcDataLength = dataLength - (payloadOffset - db0Offset);
item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, payloadOffset - 4, 4,
payloadSize, ""%d octets total (%d octets in this frame)"", payloadSize, calcDataLength);
if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
{
pinfo->fragmented = TRUE;
frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
fragmentId, NULL, 0, calcDataLength, TRUE );
fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );
if ( frag_msg != NULL )
{
item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(item);
ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );
}
}
if ( (gint) calcDataLength >= (gint) 0 )
{
proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, calcDataLength, ENC_NA );
} else {
expert_add_info_format(pinfo, item, &ei_payload_length_not_positive,
""Calculation for payload length yielded non-positive result [%d]"", (guint) calcDataLength );
}
}
else
{
payloadSize = dataLength - (payloadOffset - db0Offset);
if ((gint)dataLength < (payloadOffset - db0Offset))
{
expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,
""Calculation for payload length yielded non-positive result [%d]"", (gint)payloadSize );
return;
}
if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
{
pinfo->fragmented = TRUE;
frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
fragmentId, NULL, ct, payloadSize,
packet->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
}
if ( frag_msg )
{
item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb,
0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(item);
ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
new_tvb = process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg,
&oss_frag_items, NULL, ssdo_payload );
if ( packet->payload.ssdo->sacmd.end_segment && new_tvb )
{
item = proto_tree_add_uint_format_value(ssdo_payload, hf_oss_ssdo_payload_size, message_tvb, 0, 0,
payloadSize, ""%d octets (over all fragments)"", frag_msg->len);
PROTO_ITEM_SET_GENERATED(item);
col_append_str(pinfo->cinfo, COL_INFO, "" (Message Reassembled)"" );
dissect_opensafety_ssdo_payload ( pinfo, new_tvb, ssdo_payload, db0 );
}
}
else
{
item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, 0, 0, payloadSize,
""%d octets"", payloadSize);
PROTO_ITEM_SET_GENERATED(item);
if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x06 )
{
entry = tvb_get_letohl ( message_tvb, payloadOffset );
proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
4, entry, ""0x%08X"", entry );
for ( n = 4; n < payloadSize; n+=4 )
{
entry = tvb_get_letohl ( message_tvb, payloadOffset + n );
proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_checksum, message_tvb, (payloadOffset + n ),
4, entry, ""[#%d] 0x%08X"", ( n / 4 ), entry );
}
} else if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x07 ) {
entry = tvb_get_letohl ( message_tvb, payloadOffset );
proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
4, entry, ""0x%08X"", entry );
} else
proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, payloadSize, ENC_NA );
}
}
pinfo->fragmented = saveFragmented;
}
}
}","static void
dissect_opensafety_ssdo_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
opensafety_packet_info * VAR_3, proto_item * VAR_4 )
{
proto_item    *VAR_5;
proto_tree    *VAR_6, *VAR_7;
guint16        VAR_8                = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0, VAR_12 = 0, VAR_13 = 0;
guint32        VAR_14, VAR_15 = 0, VAR_16 = 0, VAR_17, VAR_18 = 0, VAR_19 = 0;
guint8         VAR_20, VAR_21, VAR_22, VAR_23;
guint          VAR_24;
gint           VAR_25;
gboolean       VAR_26, VAR_27;
tvbuff_t      *VAR_28              = NULL;
fragment_head *VAR_29             = NULL;
static const int * VAR_30[] = {
&VAR_31,
&VAR_32,
&VAR_33,
&VAR_34,
&VAR_35,
&VAR_36,
&VAR_37,
NULL
};
VAR_24 = tvb_get_guint8(VAR_0, VAR_38 + VAR_3->frame.subframe1);
VAR_20 = VAR_3->frame.subframe1 + VAR_39;
VAR_21 = tvb_get_guint8(VAR_0, VAR_20);
VAR_15 = 0;
VAR_16 = 0;
VAR_26 = ( ( OSS_FRAME_ID_T(VAR_0, VAR_3->frame.subframe1) & 0x04 ) == 0x04 );
if ( VAR_3->scm_udid_valid )
{
VAR_8 = OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2 + 3, VAR_3->scm_udid[3], VAR_3->scm_udid[4]);
VAR_9 =  ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ^
( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) );
opensafety_packet_sendreceiv ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3, VAR_8,
VAR_3->frame.subframe2 + 3, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
}
else if ( ! VAR_26 )
{
opensafety_packet_sender ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
}
else if ( VAR_26 )
{
opensafety_packet_receiver ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
}
VAR_6 = opensafety_packet_payloadtree ( VAR_0, VAR_2, VAR_3, VAR_40 );
opensafety_packet_response ( VAR_0, VAR_6, VAR_3, VAR_26 );
VAR_3->payload.ssdo->sacmd.toggle = ( VAR_21 & VAR_41 ) == VAR_41;
VAR_3->payload.ssdo->sacmd.abort_transfer = ( VAR_21 & VAR_42 ) == VAR_42;
VAR_3->payload.ssdo->sacmd.preload = ( VAR_21 & VAR_43 ) == VAR_43;
VAR_3->payload.ssdo->sacmd.read_access = ( VAR_21 & VAR_44 ) == VAR_44;
VAR_3->payload.ssdo->sacmd.initiate = ( VAR_21 & VAR_45 ) == VAR_45;
VAR_3->payload.ssdo->sacmd.segmented = ( VAR_21 & VAR_46 ) == VAR_46;
VAR_3->payload.ssdo->sacmd.end_segment = ( VAR_21 & VAR_47 ) == VAR_47;
if ( VAR_26 )
{
opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
VAR_11 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);
if ( VAR_3->scm_udid_valid )
{
proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe2 + 3, 2, VAR_8);
VAR_10 = VAR_8;
}
}
else if ( ! VAR_26 )
{
proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe1, 2, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1));
VAR_10 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);
if ( VAR_3->scm_udid_valid )
{
opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
VAR_8, VAR_3->frame.subframe2 + 3, VAR_3->frame.subframe2, VAR_9 );
VAR_11 = VAR_8;
}
}
if ( VAR_3->payload.ssdo->sacmd.toggle )
VAR_21 &= (~VAR_41);
proto_tree_add_bitmask(VAR_6, VAR_0, VAR_20, VAR_50,
VAR_51, VAR_30, VAR_52);
col_append_fstr(VAR_1->cinfo, VAR_53, "", SACMD: %s"", val_to_str_const(VAR_21, VAR_54, "" ""));
VAR_22 = VAR_20 + 1;
VAR_13 = tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3);
if ( VAR_3->scm_udid_valid )
{
VAR_13 = (guint16)((tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 2) ^ VAR_3->scm_udid[2]) << 8);
VAR_13 += (tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3));
}
proto_tree_add_uint(VAR_6, VAR_55, VAR_0, VAR_3->frame.subframe1 + 3, 1, VAR_13 );
if ( VAR_3->scm_udid_valid && VAR_3->payload.ssdo->sacmd.preload && VAR_26 )
{
VAR_23 = ( (tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 4) ^ VAR_3->scm_udid[4]) & 0xFC ) >> 2;
if ( VAR_3->payload.ssdo->sacmd.initiate )
{
proto_tree_add_uint_format_value(VAR_6, VAR_56, VAR_0, VAR_3->frame.subframe2 + 4, 1,
VAR_23 & 0x0F, ""%d"", VAR_23 & 0x0F );
}
else
{
VAR_5 = proto_tree_add_item(VAR_6, VAR_57, VAR_0, VAR_3->frame.subframe2 + 4, 1, VAR_52 );
if ( (VAR_23 & 0x30) == 0x30 )
proto_item_append_text(VAR_5, "" (SOD Access Request Number is last successful)"" );
}
}
if ( VAR_3->payload.ssdo->sacmd.initiate && !VAR_3->payload.ssdo->sacmd.abort_transfer )
{
VAR_15 = tvb_get_letohs(VAR_0, VAR_20 + 1);
VAR_16 = tvb_get_guint8(VAR_0, VAR_20 + 3);
proto_tree_add_uint_format_value(VAR_6, VAR_58, VAR_0, VAR_20 + 1, 2,
VAR_15, ""0x%04X (%s)"", VAR_15,
val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown"") );
col_append_fstr(VAR_1->cinfo, VAR_53, "" [%s"", val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown""));
if ( VAR_16 != 0x0 )
{
proto_tree_add_uint_format_value(VAR_6, VAR_60, VAR_0, VAR_20 + 3, 1,
VAR_16, ""0x%02X (%s)"", VAR_16,
val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown"") );
col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"",
val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown""));
}
col_append_fstr(VAR_1->cinfo, VAR_53, ""%s"", ""]"" );
VAR_22 += 3;
}
if ( VAR_3->payload.ssdo->sacmd.abort_transfer )
{
VAR_14 = tvb_get_letohl(VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4);
proto_tree_add_uint_format_value(VAR_6, VAR_61, VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4, 4, VAR_14,
""0x%04X %04X - %s"", (guint16)(VAR_14 >> 16), (guint16)(VAR_14),
val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));
col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"", val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));
} else {
if ( ( VAR_3->payload.ssdo->sacmd.initiate || VAR_3->payload.ssdo->sacmd.segmented || VAR_3->payload.ssdo->sacmd.end_segment ) &&
( ( VAR_26 && !VAR_3->payload.ssdo->sacmd.read_access ) ||
( !VAR_26 && VAR_3->payload.ssdo->sacmd.read_access ) ) )
{
VAR_27 = VAR_1->fragmented;
if ( VAR_10 != 0 && VAR_11 != 0 )
VAR_18 = (guint32)((((guint32)VAR_11) << 16 ) + VAR_10 );
if ( VAR_3->payload.ssdo->sacmd.segmented && VAR_3->payload.ssdo->sacmd.initiate )
{
VAR_22 += 4;
VAR_17 = tvb_get_letohl(VAR_0, VAR_22 - 4);
VAR_25 = VAR_24 - (VAR_22 - VAR_20);
VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, VAR_22 - 4, 4,
VAR_17, ""%d octets total (%d octets in this frame)"", VAR_17, VAR_25);
if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
{
VAR_1->fragmented = TRUE;
VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
VAR_18, NULL, 0, VAR_25, TRUE );
fragment_add_seq_offset ( &VAR_64, VAR_1, VAR_18, NULL, VAR_13 );
if ( VAR_29 != NULL )
{
VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0, 0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(VAR_5);
VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);
process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29, &VAR_67, NULL, VAR_7 );
}
}
if ( (gint) VAR_25 >= (gint) 0 )
{
proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_25, VAR_52 );
} else {
expert_add_info_format(VAR_1, VAR_5, &VAR_68,
""Calculation for payload length yielded non-positive result [%d]"", (guint) VAR_25 );
}
}
else
{
VAR_17 = VAR_24 - (VAR_22 - VAR_20);
if ((gint)VAR_24 < (VAR_22 - VAR_20))
{
expert_add_info_format(VAR_1, VAR_4, &VAR_68,
""Calculation for payload length yielded non-positive result [%d]"", (gint)VAR_17 );
return;
}
if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
{
VAR_1->fragmented = TRUE;
VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
VAR_18, NULL, VAR_13, VAR_17,
VAR_3->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
}
if ( VAR_29 )
{
VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0,
0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(VAR_5);
VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);
VAR_28 = process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29,
&VAR_67, NULL, VAR_7 );
if ( VAR_3->payload.ssdo->sacmd.end_segment && VAR_28 )
{
VAR_5 = proto_tree_add_uint_format_value(VAR_7, VAR_63, VAR_0, 0, 0,
VAR_17, ""%d octets (over all fragments)"", VAR_29->len);
PROTO_ITEM_SET_GENERATED(VAR_5);
col_append_str(VAR_1->cinfo, VAR_53, "" (Message Reassembled)"" );
dissect_opensafety_ssdo_payload ( VAR_1, VAR_28, VAR_7, VAR_21 );
}
}
else
{
VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, 0, 0, VAR_17,
""%d octets"", VAR_17);
PROTO_ITEM_SET_GENERATED(VAR_5);
if ( VAR_15 == VAR_69 && VAR_16 == 0x06 )
{
VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
4, VAR_19, ""0x%08X"", VAR_19 );
for ( VAR_12 = 4; VAR_12 < VAR_17; VAR_12+=4 )
{
VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 + VAR_12 );
proto_tree_add_uint_format_value ( VAR_6, VAR_71, VAR_0, (VAR_22 + VAR_12 ),
4, VAR_19, ""[#%d] 0x%08X"", ( VAR_12 / 4 ), VAR_19 );
}
} else if ( VAR_15 == VAR_69 && VAR_16 == 0x07 ) {
VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
4, VAR_19, ""0x%08X"", VAR_19 );
} else
proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_17, VAR_52 );
}
}
VAR_1->fragmented = VAR_27;
}
}
}",wireshark/a83a324acdfc07a0ca8b65e6ebaba3374ab19c76/packet-opensafety.c/vul/before/0.json,"static void
dissect_opensafety_ssdo_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *opensafety_tree,
        opensafety_packet_info * packet, proto_item * opensafety_item )
{
    proto_item    *item;
    proto_tree    *ssdo_tree, *ssdo_payload;
    guint16        taddr                = 0, sdn = 0, server = 0, client = 0, n = 0, ct = 0;
    guint32        abortcode, ssdoIndex = 0, ssdoSubIndex = 0, payloadSize, fragmentId = 0, entry = 0;
    guint8         db0Offset, db0, payloadOffset, preload;
    guint          dataLength;
    gint           calcDataLength;
    gboolean       isResponse, saveFragmented;
    tvbuff_t      *new_tvb              = NULL;
    fragment_head *frag_msg             = NULL;

    static const int * ssdo_sacmd_flags[] = {
            &hf_oss_ssdo_sacmd_end_segment,
            &hf_oss_ssdo_sacmd_initiate,
            &hf_oss_ssdo_sacmd_toggle,
            &hf_oss_ssdo_sacmd_segmentation,
            &hf_oss_ssdo_sacmd_abort_transfer,
            &hf_oss_ssdo_sacmd_preload,
            &hf_oss_ssdo_sacmd_access_type,
            NULL
    };

    dataLength = tvb_get_guint8(message_tvb, OSS_FRAME_POS_LEN + packet->frame.subframe1);

    db0Offset = packet->frame.subframe1 + OSS_FRAME_POS_DATA;
    db0 = tvb_get_guint8(message_tvb, db0Offset);
    ssdoIndex = 0;
    ssdoSubIndex = 0;

    /* Response is determined by the openSAFETY message field */
    isResponse = ( ( OSS_FRAME_ID_T(message_tvb, packet->frame.subframe1) & 0x04 ) == 0x04 );

    if ( packet->scm_udid_valid )
    {
        /* taddr is the 4th octet in the second frame */
        taddr = OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2 + 3, packet->scm_udid[3], packet->scm_udid[4]);
        sdn =  ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ^
                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) );

        opensafety_packet_sendreceiv ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet, taddr,
                packet->frame.subframe2 + 3, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
                packet->frame.subframe1, packet->frame.subframe2, sdn );
    }
    else if ( ! isResponse )
    {
        opensafety_packet_sender ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
    }
    else if ( isResponse )
    {
        opensafety_packet_receiver ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
    }

    ssdo_tree = opensafety_packet_payloadtree ( message_tvb, opensafety_tree, packet, ett_opensafety_ssdo );

    opensafety_packet_response ( message_tvb, ssdo_tree, packet, isResponse );

    packet->payload.ssdo->sacmd.toggle = ( db0 & OPENSAFETY_SSDO_SACMD_TGL ) == OPENSAFETY_SSDO_SACMD_TGL;
    packet->payload.ssdo->sacmd.abort_transfer = ( db0 & OPENSAFETY_SSDO_SACMD_ABRT ) == OPENSAFETY_SSDO_SACMD_ABRT;
    packet->payload.ssdo->sacmd.preload = ( db0 & OPENSAFETY_SSDO_SACMD_PRLD ) == OPENSAFETY_SSDO_SACMD_PRLD;
    packet->payload.ssdo->sacmd.read_access = ( db0 & OPENSAFETY_SSDO_DOWNLOAD ) == OPENSAFETY_SSDO_DOWNLOAD;
    packet->payload.ssdo->sacmd.initiate = ( db0 & OPENSAFETY_SSDO_SACMD_INI ) == OPENSAFETY_SSDO_SACMD_INI;
    packet->payload.ssdo->sacmd.segmented = ( db0 & OPENSAFETY_SSDO_SACMD_SEG ) == OPENSAFETY_SSDO_SACMD_SEG;
    packet->payload.ssdo->sacmd.end_segment = ( db0 & OPENSAFETY_SSDO_SACMD_ENSG ) == OPENSAFETY_SSDO_SACMD_ENSG;

    if ( isResponse )
    {
        opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
                packet->frame.subframe1, packet->frame.subframe2, sdn );
        client = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);

        if ( packet->scm_udid_valid )
        {
            proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe2 + 3, 2, taddr);
            server = taddr;
        }
    }
    else if ( ! isResponse )
    {
        proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe1, 2, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1));
        server = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);
        if ( packet->scm_udid_valid )
        {
            opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
                    taddr, packet->frame.subframe2 + 3, packet->frame.subframe2, sdn );
            client = taddr;
        }
    }

    /* Toggle bit must be removed, otherwise the values cannot be displayed correctly */
    if ( packet->payload.ssdo->sacmd.toggle )
        db0 &= (~OPENSAFETY_SSDO_SACMD_TGL);
    proto_tree_add_bitmask(ssdo_tree, message_tvb, db0Offset, hf_oss_ssdo_sacmd,
            ett_opensafety_ssdo_sacmd, ssdo_sacmd_flags, ENC_NA);

    col_append_fstr(pinfo->cinfo, COL_INFO, "", SACMD: %s"", val_to_str_const(db0, opensafety_ssdo_sacmd_values, "" ""));

    payloadOffset = db0Offset + 1;

    ct = tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3);
    if ( packet->scm_udid_valid )
    {
        ct = (guint16)((tvb_get_guint8(message_tvb, packet->frame.subframe2 + 2) ^ packet->scm_udid[2]) << 8);
        ct += (tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3));
    }

    proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_sano, message_tvb, packet->frame.subframe1 + 3, 1, ct );

    /* Evaluate preload field [field TR] */
    if ( packet->scm_udid_valid && packet->payload.ssdo->sacmd.preload && isResponse )
    {
        /* Preload info are the higher 6 bit of the TR field */
        preload = ( (tvb_get_guint8(message_tvb, packet->frame.subframe2 + 4) ^ packet->scm_udid[4]) & 0xFC ) >> 2;

        if ( packet->payload.ssdo->sacmd.initiate )
        {
            /* Use the lower 4 bits from the preload as size */
            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_preload_queue, message_tvb, packet->frame.subframe2 + 4, 1,
                    preload & 0x0F, ""%d"", preload & 0x0F );
        }
        else
        {
            /* The highest 2 bits of information contain an error flag */
            item = proto_tree_add_item(ssdo_tree, hf_oss_ssdo_preload_error, message_tvb, packet->frame.subframe2 + 4, 1, ENC_NA );
            if ( (preload & 0x30) == 0x30 )
                proto_item_append_text(item, "" (SOD Access Request Number is last successful)"" );
        }
    }

    /* When the following clause is met, DB1,2 contain the SOD index, and DB3 the SOD subindex */
    if ( packet->payload.ssdo->sacmd.initiate && !packet->payload.ssdo->sacmd.abort_transfer )
    {
        ssdoIndex = tvb_get_letohs(message_tvb, db0Offset + 1);
        ssdoSubIndex = tvb_get_guint8(message_tvb, db0Offset + 3);

        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_index, message_tvb, db0Offset + 1, 2,
                ssdoIndex, ""0x%04X (%s)"", ssdoIndex,
                val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown"") );
        col_append_fstr(pinfo->cinfo, COL_INFO, "" [%s"", val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown""));

        /* Some SOD downloads (0x101A for instance) don't have sub-indeces */
        if ( ssdoSubIndex != 0x0 )
        {
            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_subindex, message_tvb, db0Offset + 3, 1,
                ssdoSubIndex, ""0x%02X (%s)"", ssdoSubIndex,
                val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown"") );
            col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"",
                    val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown""));
        }
        col_append_fstr(pinfo->cinfo, COL_INFO, ""%s"", ""]"" );
        payloadOffset += 3;
    }

    if ( packet->payload.ssdo->sacmd.abort_transfer )
    {
        abortcode = tvb_get_letohl(message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4);

        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_abort_code, message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4, 4, abortcode,
                ""0x%04X %04X - %s"", (guint16)(abortcode >> 16), (guint16)(abortcode),
                val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));
        col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"", val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));


    } else {
        /* Either the SSDO msg is a response, then data is sent by the server and only in uploads,
         * or the message is a request, then data is coming from the client and payload data is
         * sent in downloads. Data is only sent in initiate, segmented or end-segment messages */
        if ( ( packet->payload.ssdo->sacmd.initiate || packet->payload.ssdo->sacmd.segmented || packet->payload.ssdo->sacmd.end_segment ) &&
             ( ( isResponse && !packet->payload.ssdo->sacmd.read_access ) ||
                     ( !isResponse && packet->payload.ssdo->sacmd.read_access ) ) )
        {
            saveFragmented = pinfo->fragmented;
            if ( server != 0 && client != 0 )
                fragmentId = (guint32)((((guint32)client) << 16 ) + server );

            /* If payload data has to be calculated, either a total size is given, or not */
            if ( packet->payload.ssdo->sacmd.segmented && packet->payload.ssdo->sacmd.initiate )
            {

                payloadOffset += 4;

                /* reading real size */
                payloadSize = tvb_get_letohl(message_tvb, payloadOffset - 4);

                calcDataLength = dataLength - (payloadOffset - db0Offset);

                item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, payloadOffset - 4, 4,
                        payloadSize, ""%d octets total (%d octets in this frame)"", payloadSize, calcDataLength);

                if ( calcDataLength >= 0 )
                {
                    if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
                    {
                        pinfo->fragmented = TRUE;
                        frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
                                                          fragmentId, NULL, 0, calcDataLength, TRUE );
                        fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );

                        if ( frag_msg != NULL )
                        {
                            item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );
                            PROTO_ITEM_SET_GENERATED(item);

                            ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
                            process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );
                        }
                    }

                    proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, calcDataLength, ENC_NA );
                } else {
                    expert_add_info_format(pinfo, item, &ei_payload_length_not_positive,
                                                ""Calculation for payload length yielded non-positive result [%d]"", (guint) calcDataLength );
                }
            }
            else
            {
                payloadSize = dataLength - (payloadOffset - db0Offset);
                if ((gint)dataLength < (payloadOffset - db0Offset))
                {
                    expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,
                                                    ""Calculation for payload length yielded non-positive result [%d]"", (gint)payloadSize );
                    return;
                }

                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
                {
                    pinfo->fragmented = TRUE;

                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
                                                      fragmentId, NULL, ct, payloadSize,
                                                      packet->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
                }

                if ( frag_msg )
                {
                    item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb,
                                                             0, 0, NULL, ""Reassembled"" );
                    PROTO_ITEM_SET_GENERATED(item);
                    ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);

                    new_tvb = process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg,
                                                       &oss_frag_items, NULL, ssdo_payload );
                    if ( packet->payload.ssdo->sacmd.end_segment && new_tvb )
                    {
                        item = proto_tree_add_uint_format_value(ssdo_payload, hf_oss_ssdo_payload_size, message_tvb, 0, 0,
                                                                payloadSize, ""%d octets (over all fragments)"", frag_msg->len);
                        PROTO_ITEM_SET_GENERATED(item);

                        col_append_str(pinfo->cinfo, COL_INFO, "" (Message Reassembled)"" );
                        dissect_opensafety_ssdo_payload ( pinfo, new_tvb, ssdo_payload, db0 );
                    }
                }
                else
                {
                    item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, 0, 0, payloadSize,
                            ""%d octets"", payloadSize);
                    PROTO_ITEM_SET_GENERATED(item);

                    if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x06 )
                    {
                        entry = tvb_get_letohl ( message_tvb, payloadOffset );
                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
                                    4, entry, ""0x%08X"", entry );
                        for ( n = 4; n < payloadSize; n+=4 )
                        {
                            entry = tvb_get_letohl ( message_tvb, payloadOffset + n );
                            proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_checksum, message_tvb, (payloadOffset + n ),
                                    4, entry, ""[#%d] 0x%08X"", ( n / 4 ), entry );
                        }
                    } else if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x07 ) {
                        entry = tvb_get_letohl ( message_tvb, payloadOffset );
                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
                                    4, entry, ""0x%08X"", entry );
                    } else
                        proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, payloadSize, ENC_NA );
                }
            }

            pinfo->fragmented = saveFragmented;
        }
    }
}","static void
dissect_opensafety_ssdo_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
        opensafety_packet_info * VAR_3, proto_item * VAR_4 )
{
    proto_item    *VAR_5;
    proto_tree    *VAR_6, *VAR_7;
    guint16        VAR_8                = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0, VAR_12 = 0, VAR_13 = 0;
    guint32        VAR_14, VAR_15 = 0, VAR_16 = 0, VAR_17, VAR_18 = 0, VAR_19 = 0;
    guint8         VAR_20, VAR_21, VAR_22, VAR_23;
    guint          VAR_24;
    gint           VAR_25;
    gboolean       VAR_26, VAR_27;
    tvbuff_t      *VAR_28              = NULL;
    fragment_head *VAR_29             = NULL;

    static const int * VAR_30[] = {
            &VAR_31,
            &VAR_32,
            &VAR_33,
            &VAR_34,
            &VAR_35,
            &VAR_36,
            &VAR_37,
            NULL
    };

    VAR_24 = tvb_get_guint8(VAR_0, VAR_38 + VAR_3->frame.subframe1);

    VAR_20 = VAR_3->frame.subframe1 + VAR_39;
    VAR_21 = tvb_get_guint8(VAR_0, VAR_20);
    VAR_15 = 0;
    VAR_16 = 0;

    /* COMMENT_0 */
    VAR_26 = ( ( OSS_FRAME_ID_T(VAR_0, VAR_3->frame.subframe1) & 0x04 ) == 0x04 );

    if ( VAR_3->scm_udid_valid )
    {
        /* COMMENT_1 */
        VAR_8 = OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2 + 3, VAR_3->scm_udid[3], VAR_3->scm_udid[4]);
        VAR_9 =  ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ^
                        ( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) );

        opensafety_packet_sendreceiv ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3, VAR_8,
                VAR_3->frame.subframe2 + 3, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
                VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
    }
    else if ( ! VAR_26 )
    {
        opensafety_packet_sender ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
                OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
                VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
    }
    else if ( VAR_26 )
    {
        opensafety_packet_receiver ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
                OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
                VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
    }

    VAR_6 = opensafety_packet_payloadtree ( VAR_0, VAR_2, VAR_3, VAR_40 );

    opensafety_packet_response ( VAR_0, VAR_6, VAR_3, VAR_26 );

    VAR_3->payload.ssdo->sacmd.toggle = ( VAR_21 & VAR_41 ) == VAR_41;
    VAR_3->payload.ssdo->sacmd.abort_transfer = ( VAR_21 & VAR_42 ) == VAR_42;
    VAR_3->payload.ssdo->sacmd.preload = ( VAR_21 & VAR_43 ) == VAR_43;
    VAR_3->payload.ssdo->sacmd.read_access = ( VAR_21 & VAR_44 ) == VAR_44;
    VAR_3->payload.ssdo->sacmd.initiate = ( VAR_21 & VAR_45 ) == VAR_45;
    VAR_3->payload.ssdo->sacmd.segmented = ( VAR_21 & VAR_46 ) == VAR_46;
    VAR_3->payload.ssdo->sacmd.end_segment = ( VAR_21 & VAR_47 ) == VAR_47;

    if ( VAR_26 )
    {
        opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
                OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
                VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
        VAR_11 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);

        if ( VAR_3->scm_udid_valid )
        {
            proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe2 + 3, 2, VAR_8);
            VAR_10 = VAR_8;
        }
    }
    else if ( ! VAR_26 )
    {
        proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe1, 2, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1));
        VAR_10 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);
        if ( VAR_3->scm_udid_valid )
        {
            opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
                    VAR_8, VAR_3->frame.subframe2 + 3, VAR_3->frame.subframe2, VAR_9 );
            VAR_11 = VAR_8;
        }
    }

    /* COMMENT_2 */
    if ( VAR_3->payload.ssdo->sacmd.toggle )
        VAR_21 &= (~VAR_41);
    proto_tree_add_bitmask(VAR_6, VAR_0, VAR_20, VAR_50,
            VAR_51, VAR_30, VAR_52);

    col_append_fstr(VAR_1->cinfo, VAR_53, "", SACMD: %s"", val_to_str_const(VAR_21, VAR_54, "" ""));

    VAR_22 = VAR_20 + 1;

    VAR_13 = tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3);
    if ( VAR_3->scm_udid_valid )
    {
        VAR_13 = (guint16)((tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 2) ^ VAR_3->scm_udid[2]) << 8);
        VAR_13 += (tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3));
    }

    proto_tree_add_uint(VAR_6, VAR_55, VAR_0, VAR_3->frame.subframe1 + 3, 1, VAR_13 );

    /* COMMENT_3 */
    if ( VAR_3->scm_udid_valid && VAR_3->payload.ssdo->sacmd.preload && VAR_26 )
    {
        /* COMMENT_4 */
        VAR_23 = ( (tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 4) ^ VAR_3->scm_udid[4]) & 0xFC ) >> 2;

        if ( VAR_3->payload.ssdo->sacmd.initiate )
        {
            /* COMMENT_5 */
            proto_tree_add_uint_format_value(VAR_6, VAR_56, VAR_0, VAR_3->frame.subframe2 + 4, 1,
                    VAR_23 & 0x0F, ""%d"", VAR_23 & 0x0F );
        }
        else
        {
            /* COMMENT_6 */
            VAR_5 = proto_tree_add_item(VAR_6, VAR_57, VAR_0, VAR_3->frame.subframe2 + 4, 1, VAR_52 );
            if ( (VAR_23 & 0x30) == 0x30 )
                proto_item_append_text(VAR_5, "" (SOD Access Request Number is last successful)"" );
        }
    }

    /* COMMENT_7 */
    if ( VAR_3->payload.ssdo->sacmd.initiate && !VAR_3->payload.ssdo->sacmd.abort_transfer )
    {
        VAR_15 = tvb_get_letohs(VAR_0, VAR_20 + 1);
        VAR_16 = tvb_get_guint8(VAR_0, VAR_20 + 3);

        proto_tree_add_uint_format_value(VAR_6, VAR_58, VAR_0, VAR_20 + 1, 2,
                VAR_15, ""0x%04X (%s)"", VAR_15,
                val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown"") );
        col_append_fstr(VAR_1->cinfo, VAR_53, "" [%s"", val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown""));

        /* COMMENT_8 */
        if ( VAR_16 != 0x0 )
        {
            proto_tree_add_uint_format_value(VAR_6, VAR_60, VAR_0, VAR_20 + 3, 1,
                VAR_16, ""0x%02X (%s)"", VAR_16,
                val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown"") );
            col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"",
                    val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown""));
        }
        col_append_fstr(VAR_1->cinfo, VAR_53, ""%s"", ""]"" );
        VAR_22 += 3;
    }

    if ( VAR_3->payload.ssdo->sacmd.abort_transfer )
    {
        VAR_14 = tvb_get_letohl(VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4);

        proto_tree_add_uint_format_value(VAR_6, VAR_61, VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4, 4, VAR_14,
                ""0x%04X %04X - %s"", (guint16)(VAR_14 >> 16), (guint16)(VAR_14),
                val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));
        col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"", val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));


    } else {
        /* COMMENT_9 */
                                                                                               
                                                                                                 
        if ( ( VAR_3->payload.ssdo->sacmd.initiate || VAR_3->payload.ssdo->sacmd.segmented || VAR_3->payload.ssdo->sacmd.end_segment ) &&
             ( ( VAR_26 && !VAR_3->payload.ssdo->sacmd.read_access ) ||
                     ( !VAR_26 && VAR_3->payload.ssdo->sacmd.read_access ) ) )
        {
            VAR_27 = VAR_1->fragmented;
            if ( VAR_10 != 0 && VAR_11 != 0 )
                VAR_18 = (guint32)((((guint32)VAR_11) << 16 ) + VAR_10 );

            /* COMMENT_12 */
            if ( VAR_3->payload.ssdo->sacmd.segmented && VAR_3->payload.ssdo->sacmd.initiate )
            {

                VAR_22 += 4;

                /* COMMENT_13 */
                VAR_17 = tvb_get_letohl(VAR_0, VAR_22 - 4);

                VAR_25 = VAR_24 - (VAR_22 - VAR_20);

                VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, VAR_22 - 4, 4,
                        VAR_17, ""%d octets total (%d octets in this frame)"", VAR_17, VAR_25);

                if ( VAR_25 >= 0 )
                {
                    if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
                    {
                        VAR_1->fragmented = TRUE;
                        VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
                                                          VAR_18, NULL, 0, VAR_25, TRUE );
                        fragment_add_seq_offset ( &VAR_64, VAR_1, VAR_18, NULL, VAR_13 );

                        if ( VAR_29 != NULL )
                        {
                            VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0, 0, 0, NULL, ""Reassembled"" );
                            PROTO_ITEM_SET_GENERATED(VAR_5);

                            VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);
                            process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29, &VAR_67, NULL, VAR_7 );
                        }
                    }

                    proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_25, VAR_52 );
                } else {
                    expert_add_info_format(VAR_1, VAR_5, &VAR_68,
                                                ""Calculation for payload length yielded non-positive result [%d]"", (guint) VAR_25 );
                }
            }
            else
            {
                VAR_17 = VAR_24 - (VAR_22 - VAR_20);
                if ((gint)VAR_24 < (VAR_22 - VAR_20))
                {
                    expert_add_info_format(VAR_1, VAR_4, &VAR_68,
                                                    ""Calculation for payload length yielded non-positive result [%d]"", (gint)VAR_17 );
                    return;
                }

                if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
                {
                    VAR_1->fragmented = TRUE;

                    VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
                                                      VAR_18, NULL, VAR_13, VAR_17,
                                                      VAR_3->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
                }

                if ( VAR_29 )
                {
                    VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0,
                                                             0, 0, NULL, ""Reassembled"" );
                    PROTO_ITEM_SET_GENERATED(VAR_5);
                    VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);

                    VAR_28 = process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29,
                                                       &VAR_67, NULL, VAR_7 );
                    if ( VAR_3->payload.ssdo->sacmd.end_segment && VAR_28 )
                    {
                        VAR_5 = proto_tree_add_uint_format_value(VAR_7, VAR_63, VAR_0, 0, 0,
                                                                VAR_17, ""%d octets (over all fragments)"", VAR_29->len);
                        PROTO_ITEM_SET_GENERATED(VAR_5);

                        col_append_str(VAR_1->cinfo, VAR_53, "" (Message Reassembled)"" );
                        dissect_opensafety_ssdo_payload ( VAR_1, VAR_28, VAR_7, VAR_21 );
                    }
                }
                else
                {
                    VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, 0, 0, VAR_17,
                            ""%d octets"", VAR_17);
                    PROTO_ITEM_SET_GENERATED(VAR_5);

                    if ( VAR_15 == VAR_69 && VAR_16 == 0x06 )
                    {
                        VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
                        proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
                                    4, VAR_19, ""0x%08X"", VAR_19 );
                        for ( VAR_12 = 4; VAR_12 < VAR_17; VAR_12+=4 )
                        {
                            VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 + VAR_12 );
                            proto_tree_add_uint_format_value ( VAR_6, VAR_71, VAR_0, (VAR_22 + VAR_12 ),
                                    4, VAR_19, ""[#%d] 0x%08X"", ( VAR_12 / 4 ), VAR_19 );
                        }
                    } else if ( VAR_15 == VAR_69 && VAR_16 == 0x07 ) {
                        VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
                        proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
                                    4, VAR_19, ""0x%08X"", VAR_19 );
                    } else
                        proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_17, VAR_52 );
                }
            }

            VAR_1->fragmented = VAR_27;
        }
    }
}",wireshark/a83a324acdfc07a0ca8b65e6ebaba3374ab19c76/packet-opensafety.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -197,25 +197,25 @@
                 item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, payloadOffset - 4, 4,
                         payloadSize, ""%d octets total (%d octets in this frame)"", payloadSize, calcDataLength);
 
-                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
-                {
-                    pinfo->fragmented = TRUE;
-                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
-                                                      fragmentId, NULL, 0, calcDataLength, TRUE );
-                    fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );
-
-                    if ( frag_msg != NULL )
+                if ( calcDataLength >= 0 )
+                {
+                    if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
                     {
-                        item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );
-                        PROTO_ITEM_SET_GENERATED(item);
-
-                        ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
-                        process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );
+                        pinfo->fragmented = TRUE;
+                        frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
+                                                          fragmentId, NULL, 0, calcDataLength, TRUE );
+                        fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );
+
+                        if ( frag_msg != NULL )
+                        {
+                            item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );
+                            PROTO_ITEM_SET_GENERATED(item);
+
+                            ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
+                            process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );
+                        }
                     }
-                }
-
-                if ( (gint) calcDataLength >= (gint) 0 )
-                {
+
                     proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, calcDataLength, ENC_NA );
                 } else {
                     expert_add_info_format(pinfo, item, &ei_payload_length_not_positive,","{'deleted_lines': ['                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )', '                {', '                    pinfo->fragmented = TRUE;', '                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,', '                                                      fragmentId, NULL, 0, calcDataLength, TRUE );', '                    fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );', '', '                    if ( frag_msg != NULL )', '                        item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );', '                        PROTO_ITEM_SET_GENERATED(item);', '', '                        ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);', '                        process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );', '                }', '', '                if ( (gint) calcDataLength >= (gint) 0 )', '                {'], 'added_lines': ['                if ( calcDataLength >= 0 )', '                {', '                    if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )', '                        pinfo->fragmented = TRUE;', '                        frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,', '                                                          fragmentId, NULL, 0, calcDataLength, TRUE );', '                        fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );', '', '                        if ( frag_msg != NULL )', '                        {', '                            item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );', '                            PROTO_ITEM_SET_GENERATED(item);', '', '                            ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);', '                            process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );', '                        }', '']}",True,"In Wireshark through 2.0.13 and 2.2.x through 2.2.7, the openSAFETY dissector could crash or exhaust system memory. This was addressed in epan/dissectors/packet-opensafety.c by adding length validation. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-9350.",7.5,HIGH,2,valid,2017-06-17T15:33:29Z,1
CVE-2017-11408,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"AMQP: fix a stack overflow when offset goes back and forth

Previous code assumed that list decoding was successful and that some
bytes were consumed. Let's explicitly check this.

Bug: 13780
Change-Id: I3546b093f309f2b8096f01bc9987ac5ad9e029eb
Reviewed-on: https://code.wireshark.org/review/22235
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 246cbbc2ea6dd0a3a69a1aaa94db244a77565353)
Reviewed-on: https://code.wireshark.org/review/22250",e57c86ef8e3b57b7f90c224f6053d1eacf20e1ba,https://github.com/wireshark/wireshark/commit/e57c86ef8e3b57b7f90c224f6053d1eacf20e1ba,epan/dissectors/packet-amqp.c,get_amqp_1_0_value_formatter,"static void
get_amqp_1_0_value_formatter(tvbuff_t *tvb,
packet_info *pinfo,
guint8 code,
int offset,
int bound,
int hf_amqp_type,
const char *name,
guint32 hf_amqp_subtype_count,
const int **hf_amqp_subtypes,
guint *length_size,
proto_item *item)
{
struct amqp1_typeinfo* element_type;
const char *value = NULL;
element_type = decode_fixed_type(code);
if (element_type)
{
struct amqp_synonym_types_t *synonyms;
int shift_view = 0;
if (proto_registrar_get_ftype(hf_amqp_type) == FT_NONE)
{
for (synonyms = amqp_synonym_types; synonyms->hf_none != NULL; synonyms++)
{
if (*(synonyms->hf_none) == hf_amqp_type)
{
if (IS_FT_UINT(element_type->ftype) && synonyms->hf_uint != NULL)
hf_amqp_type = *(synonyms->hf_uint);
else if (IS_FT_STRING(element_type->ftype) && synonyms->hf_str != NULL)
hf_amqp_type = *(synonyms->hf_str);
else if (element_type->ftype == FT_BYTES && synonyms->hf_bin != NULL)
hf_amqp_type = *(synonyms->hf_bin);
else if (element_type->ftype == FT_GUID && synonyms->hf_guid != NULL)
hf_amqp_type = *(synonyms->hf_guid);
break;
}
}
}
if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE)
{
*length_size = element_type->dissector(tvb, pinfo,
offset, bound,
element_type->known_size,
item, hf_amqp_type);
}
else if(code == AMQP_1_0_TYPE_NULL)
{
if(hf_amqp_type == hf_amqp_1_0_list)
{
proto_tree_add_none_format(item, hf_amqp_type,
tvb,
offset-1,
1,
""%s: (null)"",
name ? name : proto_registrar_get_name(hf_amqp_type));
}
}
else
{
*length_size = element_type->formatter(tvb, offset, bound, element_type->known_size, &value);
if (code/16 > 0x9) 
shift_view = element_type->known_size;
else if(*length_size == 0)
shift_view = -1;
proto_tree_add_none_format(item, hf_amqp_type,
tvb,
offset+shift_view,
(*length_size)-shift_view,
""%s (%s): %s"",
name ? name : proto_registrar_get_name(hf_amqp_type),
element_type->amqp_typename, value);
}
}
else { 
switch (code) {
case AMQP_1_0_TYPE_LIST0:
case AMQP_1_0_TYPE_LIST8:
case AMQP_1_0_TYPE_LIST32:
*length_size = dissect_amqp_1_0_list(tvb,
pinfo,
offset-1, 
bound,
item,
hf_amqp_type,
hf_amqp_subtype_count,
hf_amqp_subtypes, name)-1; 
break;
case AMQP_1_0_TYPE_MAP8:
case AMQP_1_0_TYPE_MAP32:
*length_size = dissect_amqp_1_0_map(tvb, pinfo, offset-1, bound, item, hf_amqp_type, name)-1;
break;
case AMQP_1_0_TYPE_ARRAY8:
case AMQP_1_0_TYPE_ARRAY32:
*length_size = dissect_amqp_1_0_array(tvb,
pinfo,
offset-1, 
bound,
item,
hf_amqp_type,
hf_amqp_subtype_count,
hf_amqp_subtypes, name)-1; 
break;
default:
expert_add_info_format(pinfo,
item,
&ei_amqp_unknown_amqp_type,
""Unknown AMQP type %d (0x%x) of field \""%s\"""",
code, code,
name ? name : proto_registrar_get_name(hf_amqp_type));
*length_size = bound-offset; 
break;
}
}
}","static void
get_amqp_1_0_value_formatter(tvbuff_t *VAR_0,
packet_info *VAR_1,
guint8 VAR_2,
int VAR_3,
int VAR_4,
int VAR_5,
const char *VAR_6,
guint32 VAR_7,
const int **VAR_8,
guint *VAR_9,
proto_item *VAR_10)
{
struct amqp1_typeinfo* VAR_11;
const char *VAR_12 = NULL;
VAR_11 = decode_fixed_type(VAR_2);
if (VAR_11)
{
struct amqp_synonym_types_t *VAR_13;
int VAR_14 = 0;
if (proto_registrar_get_ftype(VAR_5) == VAR_15)
{
for (VAR_13 = VAR_16; VAR_13->hf_none != NULL; VAR_13++)
{
if (*(VAR_13->hf_none) == VAR_5)
{
if (IS_FT_UINT(VAR_11->ftype) && VAR_13->hf_uint != NULL)
VAR_5 = *(VAR_13->hf_uint);
else if (IS_FT_STRING(VAR_11->ftype) && VAR_13->hf_str != NULL)
VAR_5 = *(VAR_13->hf_str);
else if (VAR_11->ftype == VAR_17 && VAR_13->hf_bin != NULL)
VAR_5 = *(VAR_13->hf_bin);
else if (VAR_11->ftype == VAR_18 && VAR_13->hf_guid != NULL)
VAR_5 = *(VAR_13->hf_guid);
break;
}
}
}
if (proto_registrar_get_ftype(VAR_5) != VAR_15)
{
*VAR_9 = VAR_11->dissector(VAR_0, VAR_1,
VAR_3, VAR_4,
VAR_11->known_size,
VAR_10, VAR_5);
}
else if(VAR_2 == VAR_19)
{
if(VAR_5 == VAR_20)
{
proto_tree_add_none_format(VAR_10, VAR_5,
VAR_0,
VAR_3-1,
1,
""%s: (null)"",
VAR_6 ? VAR_6 : proto_registrar_get_name(VAR_5));
}
}
else
{
*VAR_9 = VAR_11->formatter(VAR_0, VAR_3, VAR_4, VAR_11->known_size, &VAR_12);
if (VAR_2/16 > 0x9) 
VAR_14 = VAR_11->known_size;
else if(*VAR_9 == 0)
VAR_14 = -1;
proto_tree_add_none_format(VAR_10, VAR_5,
VAR_0,
VAR_3+VAR_14,
(*VAR_9)-VAR_14,
""%s (%s): %s"",
VAR_6 ? VAR_6 : proto_registrar_get_name(VAR_5),
VAR_11->amqp_typename, VAR_12);
}
}
else { 
switch (VAR_2) {
case VAR_21:
case VAR_22:
case VAR_23:
*VAR_9 = dissect_amqp_1_0_list(VAR_0,
VAR_1,
VAR_3-1, 
VAR_4,
VAR_10,
VAR_5,
VAR_7,
VAR_8, VAR_6)-1; 
break;
case VAR_24:
case VAR_25:
*VAR_9 = dissect_amqp_1_0_map(VAR_0, VAR_1, VAR_3-1, VAR_4, VAR_10, VAR_5, VAR_6)-1;
break;
case VAR_26:
case VAR_27:
*VAR_9 = dissect_amqp_1_0_array(VAR_0,
VAR_1,
VAR_3-1, 
VAR_4,
VAR_10,
VAR_5,
VAR_7,
VAR_8, VAR_6)-1; 
break;
default:
expert_add_info_format(VAR_1,
VAR_10,
&VAR_28,
""Unknown AMQP type %d (0x%x) of field \""%s\"""",
VAR_2, VAR_2,
VAR_6 ? VAR_6 : proto_registrar_get_name(VAR_5));
*VAR_9 = VAR_4-VAR_3; 
break;
}
}
}",wireshark/e57c86ef8e3b57b7f90c224f6053d1eacf20e1ba/packet-amqp.c/vul/before/0.json,"static void
get_amqp_1_0_value_formatter(tvbuff_t *tvb,
                             packet_info *pinfo,
                             guint8 code,
                             int offset,
                             int bound,
                             int hf_amqp_type,
                             const char *name,
                             guint32 hf_amqp_subtype_count,
                             const int **hf_amqp_subtypes,
                             guint *length_size,
                             proto_item *item)
{
    struct amqp1_typeinfo* element_type;
    const char *value = NULL;

    element_type = decode_fixed_type(code);
    if (element_type)
    {
        struct amqp_synonym_types_t *synonyms;
        int shift_view = 0;

        /* some AMQP fields can be of several types; by default we use FT_NONE,
         * but to enable filtering we try to find a field corresponding to
         * the actual type */
        if (proto_registrar_get_ftype(hf_amqp_type) == FT_NONE)
        {
            for (synonyms = amqp_synonym_types; synonyms->hf_none != NULL; synonyms++)
            {
                if (*(synonyms->hf_none) == hf_amqp_type)
                {
                    if (IS_FT_UINT(element_type->ftype) && synonyms->hf_uint != NULL)
                        hf_amqp_type = *(synonyms->hf_uint);
                    else if (IS_FT_STRING(element_type->ftype) && synonyms->hf_str != NULL)
                        hf_amqp_type = *(synonyms->hf_str);
                    else if (element_type->ftype == FT_BYTES && synonyms->hf_bin != NULL)
                        hf_amqp_type = *(synonyms->hf_bin);
                    else if (element_type->ftype == FT_GUID && synonyms->hf_guid != NULL)
                        hf_amqp_type = *(synonyms->hf_guid);
                    break;
                }
            }
        }

        if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE)
        {
            /* we know the field as well its type, use native dissectors */
            *length_size = element_type->dissector(tvb, pinfo,
                                                   offset, bound,
                                                   element_type->known_size,
                                                   item, hf_amqp_type);
        }
        else if(code == AMQP_1_0_TYPE_NULL)
        {
            /* null value says that a particular field was optional and is omited
             * the omited fields of standard structutes are not shown
             * however, we still display null values of custom lists, maps and arrays */
            if(hf_amqp_type == hf_amqp_1_0_list)
            {
                proto_tree_add_none_format(item, hf_amqp_type,
                                           tvb,
                                           offset-1,
                                           1,
                                           ""%s: (null)"",
                                           name ? name : proto_registrar_get_name(hf_amqp_type));
            }
        }
        else
        {
            /* multi-type and custom fileds must be converted to a string */
            *length_size = element_type->formatter(tvb, offset, bound, element_type->known_size, &value);

            if (code/16 > 0x9) /* variable width code is 0xa[0-9] or 0xb[0-9] */
               /* shift to right to skip the variable length indicator */
               shift_view = element_type->known_size;
            else if(*length_size == 0)
                /* shift to left to show at least the type code */
                shift_view = -1;

            proto_tree_add_none_format(item, hf_amqp_type,
                                       tvb,
                                       offset+shift_view,
                                       (*length_size)-shift_view,
                                       ""%s (%s): %s"",
                                       name ? name : proto_registrar_get_name(hf_amqp_type),
                                       element_type->amqp_typename, value);
        }
    }
    else { /* no fixed code, i.e. compound (list, map, array) */
        switch (code) {
            case AMQP_1_0_TYPE_LIST0:
            case AMQP_1_0_TYPE_LIST8:
            case AMQP_1_0_TYPE_LIST32:
                *length_size = dissect_amqp_1_0_list(tvb,
                                                     pinfo,
                                                     offset-1, /* ""-1"" due to decode type again in the method */
                                                     bound,
                                                     item,
                                                     hf_amqp_type,
                                                     hf_amqp_subtype_count,
                                                     hf_amqp_subtypes, name);
                if (*length_size == 0) {
                    /* something went wrong during list dissection; let's stop here */
                    *length_size = tvb_reported_length_remaining(tvb, offset);
                } else {
                    *length_size -= 1; /* ""-1"" due to decode type again in the method */
                }
                break;
            case AMQP_1_0_TYPE_MAP8:
            case AMQP_1_0_TYPE_MAP32:
                 /* ""-1"" due to decode type again in the method */
                *length_size = dissect_amqp_1_0_map(tvb, pinfo, offset-1, bound, item, hf_amqp_type, name)-1;
                break;
            case AMQP_1_0_TYPE_ARRAY8:
            case AMQP_1_0_TYPE_ARRAY32:
                *length_size = dissect_amqp_1_0_array(tvb,
                                                      pinfo,
                                                      offset-1, /* ""-1"" due to decode type again in the method */
                                                      bound,
                                                      item,
                                                      hf_amqp_type,
                                                      hf_amqp_subtype_count,
                                                      hf_amqp_subtypes, name)-1; /* ""-1"" due to decode type again in the method */
                break;
            default:
                expert_add_info_format(pinfo,
                                       item,
                                       &ei_amqp_unknown_amqp_type,
                                       ""Unknown AMQP type %d (0x%x) of field \""%s\"""",
                                       code, code,
                                       name ? name : proto_registrar_get_name(hf_amqp_type));
                *length_size = bound-offset; /* to stop dissecting */
                break;
        }
    }
}","static void
get_amqp_1_0_value_formatter(tvbuff_t *VAR_0,
                             packet_info *VAR_1,
                             guint8 VAR_2,
                             int VAR_3,
                             int VAR_4,
                             int VAR_5,
                             const char *VAR_6,
                             guint32 VAR_7,
                             const int **VAR_8,
                             guint *VAR_9,
                             proto_item *VAR_10)
{
    struct amqp1_typeinfo* VAR_11;
    const char *VAR_12 = NULL;

    VAR_11 = decode_fixed_type(VAR_2);
    if (VAR_11)
    {
        struct amqp_synonym_types_t *VAR_13;
        int VAR_14 = 0;

        /* COMMENT_0 */
                                                                          
                             
        if (proto_registrar_get_ftype(VAR_5) == VAR_15)
        {
            for (VAR_13 = VAR_16; VAR_13->hf_none != NULL; VAR_13++)
            {
                if (*(VAR_13->hf_none) == VAR_5)
                {
                    if (IS_FT_UINT(VAR_11->ftype) && VAR_13->hf_uint != NULL)
                        VAR_5 = *(VAR_13->hf_uint);
                    else if (IS_FT_STRING(VAR_11->ftype) && VAR_13->hf_str != NULL)
                        VAR_5 = *(VAR_13->hf_str);
                    else if (VAR_11->ftype == VAR_17 && VAR_13->hf_bin != NULL)
                        VAR_5 = *(VAR_13->hf_bin);
                    else if (VAR_11->ftype == VAR_18 && VAR_13->hf_guid != NULL)
                        VAR_5 = *(VAR_13->hf_guid);
                    break;
                }
            }
        }

        if (proto_registrar_get_ftype(VAR_5) != VAR_15)
        {
            /* COMMENT_3 */
            *VAR_9 = VAR_11->dissector(VAR_0, VAR_1,
                                                   VAR_3, VAR_4,
                                                   VAR_11->known_size,
                                                   VAR_10, VAR_5);
        }
        else if(VAR_2 == VAR_19)
        {
            /* COMMENT_4 */
                                                                     
                                                                                        
            if(VAR_5 == VAR_20)
            {
                proto_tree_add_none_format(VAR_10, VAR_5,
                                           VAR_0,
                                           VAR_3-1,
                                           1,
                                           ""%s: (null)"",
                                           VAR_6 ? VAR_6 : proto_registrar_get_name(VAR_5));
            }
        }
        else
        {
            /* COMMENT_7 */
            *VAR_9 = VAR_11->formatter(VAR_0, VAR_3, VAR_4, VAR_11->known_size, &VAR_12);

            if (VAR_2/16 > 0x9) /* COMMENT_8 */
               /* COMMENT_9 */
               VAR_14 = VAR_11->known_size;
            else if(*VAR_9 == 0)
                /* COMMENT_10 */
                VAR_14 = -1;

            proto_tree_add_none_format(VAR_10, VAR_5,
                                       VAR_0,
                                       VAR_3+VAR_14,
                                       (*VAR_9)-VAR_14,
                                       ""%s (%s): %s"",
                                       VAR_6 ? VAR_6 : proto_registrar_get_name(VAR_5),
                                       VAR_11->amqp_typename, VAR_12);
        }
    }
    else { /* COMMENT_11 */
        switch (VAR_2) {
            case VAR_21:
            case VAR_22:
            case VAR_23:
                *VAR_9 = dissect_amqp_1_0_list(VAR_0,
                                                     VAR_1,
                                                     VAR_3-1, /* COMMENT_12 */
                                                     VAR_4,
                                                     VAR_10,
                                                     VAR_5,
                                                     VAR_7,
                                                     VAR_8, VAR_6);
                if (*VAR_9 == 0) {
                    /* COMMENT_13 */
                    *VAR_9 = tvb_reported_length_remaining(VAR_0, VAR_3);
                } else {
                    *VAR_9 -= 1; /* COMMENT_12 */
                }
                break;
            case VAR_24:
            case VAR_25:
                 /* COMMENT_12 */
                *VAR_9 = dissect_amqp_1_0_map(VAR_0, VAR_1, VAR_3-1, VAR_4, VAR_10, VAR_5, VAR_6)-1;
                break;
            case VAR_26:
            case VAR_27:
                *VAR_9 = dissect_amqp_1_0_array(VAR_0,
                                                      VAR_1,
                                                      VAR_3-1, /* COMMENT_12 */
                                                      VAR_4,
                                                      VAR_10,
                                                      VAR_5,
                                                      VAR_7,
                                                      VAR_8, VAR_6)-1; /* COMMENT_12 */
                break;
            default:
                expert_add_info_format(VAR_1,
                                       VAR_10,
                                       &VAR_28,
                                       ""Unknown AMQP type %d (0x%x) of field \""%s\"""",
                                       VAR_2, VAR_2,
                                       VAR_6 ? VAR_6 : proto_registrar_get_name(VAR_5));
                *VAR_9 = VAR_4-VAR_3; /* COMMENT_14 */
                break;
        }
    }
}",wireshark/e57c86ef8e3b57b7f90c224f6053d1eacf20e1ba/packet-amqp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -98,7 +98,13 @@
                                                      item,
                                                      hf_amqp_type,
                                                      hf_amqp_subtype_count,
-                                                     hf_amqp_subtypes, name)-1; /* ""-1"" due to decode type again in the method */
+                                                     hf_amqp_subtypes, name);
+                if (*length_size == 0) {
+                    /* something went wrong during list dissection; let's stop here */
+                    *length_size = tvb_reported_length_remaining(tvb, offset);
+                } else {
+                    *length_size -= 1; /* ""-1"" due to decode type again in the method */
+                }
                 break;
             case AMQP_1_0_TYPE_MAP8:
             case AMQP_1_0_TYPE_MAP32:","{'deleted_lines': ['                                                     hf_amqp_subtypes, name)-1; /* ""-1"" due to decode type again in the method */'], 'added_lines': ['                                                     hf_amqp_subtypes, name);', '                if (*length_size == 0) {', ""                    /* something went wrong during list dissection; let's stop here */"", '                    *length_size = tvb_reported_length_remaining(tvb, offset);', '                } else {', '                    *length_size -= 1; /* ""-1"" due to decode type again in the method */', '                }']}",True,"In Wireshark 2.2.0 to 2.2.7 and 2.0.0 to 2.0.13, the AMQP dissector could crash. This was addressed in epan/dissectors/packet-amqp.c by checking for successful list dissection.",7.5,HIGH,2,valid,2017-06-19T19:23:47Z,1
CVE-2017-11408,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"AMQP: workaround some proto_tree_add_none_format() asserts

Previously proto_tree_add_none_format() could be called with any type
of field type, not FT_NONE only.

Change-Id: I78976a168fc1bf606b72ad38d284bb0bd1794b03
Ping-Bug: 13780
Reviewed-on: https://code.wireshark.org/review/22243
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit 2de483c0925a5a93cdaee168997f3f3c7949d2d4)
 Conflicts:
	epan/dissectors/packet-amqp.c
Reviewed-on: https://code.wireshark.org/review/22258",a102c172b0b2fe231fdb49f4f6694603f5b93b0c,https://github.com/wireshark/wireshark/commit/a102c172b0b2fe231fdb49f4f6694603f5b93b0c,epan/dissectors/packet-amqp.c,dissect_amqp_1_0_list,"static guint
dissect_amqp_1_0_list(tvbuff_t *tvb,
packet_info *pinfo,
int offset,
int bound,
proto_item *item,
int hf_amqp_type,
guint32 hf_amqp_subtype_count,
const int **hf_amqp_subtypes,
const char *name)
{
proto_item *list_tree;
guint8      type;
guint8      count_len;
guint32     element_count;
guint32     element_size;
guint32     decoded_element_size;
guint32     orig_offset;
guint32     decoded_elements;
int         hf_amqp_item;
list_tree = 0;
decoded_elements = 0;
orig_offset = offset;
if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE)
{
expert_add_info_format(pinfo, item, &ei_amqp_unknown_amqp_type,
""Unexpected list type at frame position %d of field \""%s\"""",
offset,
name ? name : proto_registrar_get_name(hf_amqp_type));
return bound-orig_offset;
}
type = tvb_get_guint8(tvb, offset);
AMQP_INCREMENT(offset, 1, bound);
switch (type) {
case AMQP_1_0_TYPE_LIST0:
count_len = 0;
element_size = 0;
element_count = 0;
break;
case AMQP_1_0_TYPE_LIST8:
count_len = 1;
element_size = tvb_get_guint8(tvb, offset);
element_count = tvb_get_guint8(tvb, offset+count_len);
break;
case AMQP_1_0_TYPE_LIST32:
count_len = 4;
element_size = tvb_get_ntohl(tvb, offset);
element_count = tvb_get_ntohl(tvb, offset+count_len);
break;
default:
proto_tree_add_none_format(list_tree, hf_amqp_1_0_list, tvb,
offset-1,
1,
""(unknown type %d)"",
type);
expert_add_info_format(pinfo,
list_tree,
&ei_amqp_unknown_amqp_type,
""Unknown AMQP list type %d"",
type);
return bound-orig_offset;
}
list_tree = proto_tree_add_none_format(item,
hf_amqp_type,
tvb,
offset-1,
element_size+1+count_len,
""%s"",
name ? name : proto_registrar_get_name(hf_amqp_type));
AMQP_INCREMENT(offset, count_len*2, bound);
if (element_count > 0)
list_tree = proto_item_add_subtree(list_tree, ett_amqp_1_0_list);
if (hf_amqp_subtype_count == 0)
proto_item_append_text(list_tree, "" (list of %d element%s)"", element_count, element_suffix[element_count!=1]);
if (element_count > element_size)
{
expert_add_info_format(pinfo,
list_tree,
&ei_amqp_invalid_number_of_params,
""Number of list elements (%d) bigger than list size (%d)"",
element_count, element_size);
return bound-orig_offset;
}
while ((element_count > 0) && (offset < bound)) {
decoded_element_size = 0;
if (decoded_elements<hf_amqp_subtype_count)
hf_amqp_item = *(hf_amqp_subtypes[decoded_elements]);
else
hf_amqp_item = hf_amqp_1_0_list; 
get_amqp_1_0_type_value_formatter(tvb,
pinfo,
offset,
bound,
hf_amqp_item,
NULL,
&decoded_element_size,
list_tree);
element_count -= 1;
decoded_elements += 1;
AMQP_INCREMENT(offset, decoded_element_size, bound);
}
if (element_count > 0)
expert_add_info_format(pinfo,
list_tree,
&ei_amqp_invalid_number_of_params,
""Number of list elements (%d) not matching number of decoded elements (%d)"",
element_count+decoded_elements, decoded_elements);
return offset-orig_offset;
}","static guint
dissect_amqp_1_0_list(tvbuff_t *VAR_0,
packet_info *VAR_1,
int VAR_2,
int VAR_3,
proto_item *VAR_4,
int VAR_5,
guint32 VAR_6,
const int **VAR_7,
const char *VAR_8)
{
proto_item *VAR_9;
guint8      VAR_10;
guint8      VAR_11;
guint32     VAR_12;
guint32     VAR_13;
guint32     VAR_14;
guint32     VAR_15;
guint32     VAR_16;
int         VAR_17;
VAR_9 = 0;
VAR_16 = 0;
VAR_15 = VAR_2;
if (proto_registrar_get_ftype(VAR_5) != VAR_18)
{
expert_add_info_format(VAR_1, VAR_4, &VAR_19,
""Unexpected list type at frame position %d of field \""%s\"""",
VAR_2,
VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
return VAR_3-VAR_15;
}
VAR_10 = tvb_get_guint8(VAR_0, VAR_2);
AMQP_INCREMENT(VAR_2, 1, VAR_3);
switch (VAR_10) {
case VAR_20:
VAR_11 = 0;
VAR_13 = 0;
VAR_12 = 0;
break;
case VAR_21:
VAR_11 = 1;
VAR_13 = tvb_get_guint8(VAR_0, VAR_2);
VAR_12 = tvb_get_guint8(VAR_0, VAR_2+VAR_11);
break;
case VAR_22:
VAR_11 = 4;
VAR_13 = tvb_get_ntohl(VAR_0, VAR_2);
VAR_12 = tvb_get_ntohl(VAR_0, VAR_2+VAR_11);
break;
default:
proto_tree_add_none_format(VAR_9, VAR_23, VAR_0,
VAR_2-1,
1,
""(unknown type %d)"",
VAR_10);
expert_add_info_format(VAR_1,
VAR_9,
&VAR_19,
""Unknown AMQP list type %d"",
VAR_10);
return VAR_3-VAR_15;
}
VAR_9 = proto_tree_add_none_format(VAR_4,
VAR_5,
VAR_0,
VAR_2-1,
VAR_13+1+VAR_11,
""%s"",
VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
AMQP_INCREMENT(VAR_2, VAR_11*2, VAR_3);
if (VAR_12 > 0)
VAR_9 = proto_item_add_subtree(VAR_9, VAR_24);
if (VAR_6 == 0)
proto_item_append_text(VAR_9, "" (list of %d element%s)"", VAR_12, VAR_25[VAR_12!=1]);
if (VAR_12 > VAR_13)
{
expert_add_info_format(VAR_1,
VAR_9,
&VAR_26,
""Number of list elements (%d) bigger than list size (%d)"",
VAR_12, VAR_13);
return VAR_3-VAR_15;
}
while ((VAR_12 > 0) && (VAR_2 < VAR_3)) {
VAR_14 = 0;
if (VAR_16<VAR_6)
VAR_17 = *(VAR_7[VAR_16]);
else
VAR_17 = VAR_23; 
get_amqp_1_0_type_value_formatter(VAR_0,
VAR_1,
VAR_2,
VAR_3,
VAR_17,
NULL,
&VAR_14,
VAR_9);
VAR_12 -= 1;
VAR_16 += 1;
AMQP_INCREMENT(VAR_2, VAR_14, VAR_3);
}
if (VAR_12 > 0)
expert_add_info_format(VAR_1,
VAR_9,
&VAR_26,
""Number of list elements (%d) not matching number of decoded elements (%d)"",
VAR_12+VAR_16, VAR_16);
return VAR_2-VAR_15;
}",wireshark/a102c172b0b2fe231fdb49f4f6694603f5b93b0c/packet-amqp.c/vul/before/0.json,"static guint
dissect_amqp_1_0_list(tvbuff_t *tvb,
                      packet_info *pinfo,
                      int offset,
                      int bound,
                      proto_item *item,
                      int hf_amqp_type,
                      guint32 hf_amqp_subtype_count,
                      const int **hf_amqp_subtypes,
                      const char *name)
{
    proto_item *list_tree;
    guint8      type;
    guint8      count_len;
    guint32     element_count;
    guint32     element_size;
    guint32     decoded_element_size;
    guint32     orig_offset;
    guint32     decoded_elements;
    int         hf_amqp_item;

    list_tree = 0;
    decoded_elements = 0;
    orig_offset = offset;

    if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE)
    {
        expert_add_info_format(pinfo, item, &ei_amqp_unknown_amqp_type,
                               ""Unexpected list type at frame position %d of field \""%s\"""",
                               offset,
                               name ? name : proto_registrar_get_name(hf_amqp_type));
        return bound-orig_offset;
    }

    type = tvb_get_guint8(tvb, offset);
    AMQP_INCREMENT(offset, 1, bound);
    switch (type) {
    case AMQP_1_0_TYPE_LIST0:
        count_len = 0;
        element_size = 0;
        element_count = 0;
        break;
    case AMQP_1_0_TYPE_LIST8:
        count_len = 1;
        element_size = tvb_get_guint8(tvb, offset);
        element_count = tvb_get_guint8(tvb, offset+count_len);
        break;
    case AMQP_1_0_TYPE_LIST32:
        count_len = 4;
        element_size = tvb_get_ntohl(tvb, offset);
        element_count = tvb_get_ntohl(tvb, offset+count_len);
        break;
    default:
        proto_tree_add_none_format(list_tree, hf_amqp_1_0_list, tvb,
                                   offset-1,
                                   1,
                                   ""(unknown type %d)"",
                                   type);
        expert_add_info_format(pinfo,
                               list_tree,
                               &ei_amqp_unknown_amqp_type,
                               ""Unknown AMQP list type %d"",
                               type);
        return bound-orig_offset;
    }

    list_tree = proto_tree_add_item(item,
                                    hf_amqp_type,
                                    tvb,
                                    offset-1,
                                    element_size+1+count_len,
                                    ENC_BIG_ENDIAN);
    proto_item_set_text(list_tree, ""%s"", name ? name : proto_registrar_get_name(hf_amqp_type));
    AMQP_INCREMENT(offset, count_len*2, bound);

    if (element_count > 0)
        list_tree = proto_item_add_subtree(list_tree, ett_amqp_1_0_list);
    /* display the item count for custom lists only
     * standard structures contain NULL items, so the real element count is different */
    if (hf_amqp_subtype_count == 0)
        proto_item_append_text(list_tree, "" (list of %d element%s)"", element_count, element_suffix[element_count!=1]);

    if (element_count > element_size)
    {
        expert_add_info_format(pinfo,
                               list_tree,
                               &ei_amqp_invalid_number_of_params,
                               ""Number of list elements (%d) bigger than list size (%d)"",
                               element_count, element_size);
        return bound-orig_offset;
    }

    while ((element_count > 0) && (offset < bound)) {
        decoded_element_size = 0;
        if (decoded_elements<hf_amqp_subtype_count)
            hf_amqp_item = *(hf_amqp_subtypes[decoded_elements]);
        else
            hf_amqp_item = hf_amqp_1_0_list; /* dynamic item */
        get_amqp_1_0_type_value_formatter(tvb,
                                          pinfo,
                                          offset,
                                          bound,
                                          hf_amqp_item,
                                          NULL,
                                          &decoded_element_size,
                                          list_tree);
        element_count -= 1;
        decoded_elements += 1;
        AMQP_INCREMENT(offset, decoded_element_size, bound);
    }
    if (element_count > 0)
        expert_add_info_format(pinfo,
                               list_tree,
                               &ei_amqp_invalid_number_of_params,
                               ""Number of list elements (%d) not matching number of decoded elements (%d)"",
                               element_count+decoded_elements, decoded_elements);
    return offset-orig_offset;
}","static guint
dissect_amqp_1_0_list(tvbuff_t *VAR_0,
                      packet_info *VAR_1,
                      int VAR_2,
                      int VAR_3,
                      proto_item *VAR_4,
                      int VAR_5,
                      guint32 VAR_6,
                      const int **VAR_7,
                      const char *VAR_8)
{
    proto_item *VAR_9;
    guint8      VAR_10;
    guint8      VAR_11;
    guint32     VAR_12;
    guint32     VAR_13;
    guint32     VAR_14;
    guint32     VAR_15;
    guint32     VAR_16;
    int         VAR_17;

    VAR_9 = 0;
    VAR_16 = 0;
    VAR_15 = VAR_2;

    if (proto_registrar_get_ftype(VAR_5) != VAR_18)
    {
        expert_add_info_format(VAR_1, VAR_4, &VAR_19,
                               ""Unexpected list type at frame position %d of field \""%s\"""",
                               VAR_2,
                               VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
        return VAR_3-VAR_15;
    }

    VAR_10 = tvb_get_guint8(VAR_0, VAR_2);
    AMQP_INCREMENT(VAR_2, 1, VAR_3);
    switch (VAR_10) {
    case VAR_20:
        VAR_11 = 0;
        VAR_13 = 0;
        VAR_12 = 0;
        break;
    case VAR_21:
        VAR_11 = 1;
        VAR_13 = tvb_get_guint8(VAR_0, VAR_2);
        VAR_12 = tvb_get_guint8(VAR_0, VAR_2+VAR_11);
        break;
    case VAR_22:
        VAR_11 = 4;
        VAR_13 = tvb_get_ntohl(VAR_0, VAR_2);
        VAR_12 = tvb_get_ntohl(VAR_0, VAR_2+VAR_11);
        break;
    default:
        proto_tree_add_none_format(VAR_9, VAR_23, VAR_0,
                                   VAR_2-1,
                                   1,
                                   ""(unknown type %d)"",
                                   VAR_10);
        expert_add_info_format(VAR_1,
                               VAR_9,
                               &VAR_19,
                               ""Unknown AMQP list type %d"",
                               VAR_10);
        return VAR_3-VAR_15;
    }

    VAR_9 = proto_tree_add_item(VAR_4,
                                    VAR_5,
                                    VAR_0,
                                    VAR_2-1,
                                    VAR_13+1+VAR_11,
                                    VAR_24);
    proto_item_set_text(VAR_9, ""%s"", VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
    AMQP_INCREMENT(VAR_2, VAR_11*2, VAR_3);

    if (VAR_12 > 0)
        VAR_9 = proto_item_add_subtree(VAR_9, VAR_25);
    /* COMMENT_0 */
                                                                                        
    if (VAR_6 == 0)
        proto_item_append_text(VAR_9, "" (list of %d element%s)"", VAR_12, VAR_26[VAR_12!=1]);

    if (VAR_12 > VAR_13)
    {
        expert_add_info_format(VAR_1,
                               VAR_9,
                               &VAR_27,
                               ""Number of list elements (%d) bigger than list size (%d)"",
                               VAR_12, VAR_13);
        return VAR_3-VAR_15;
    }

    while ((VAR_12 > 0) && (VAR_2 < VAR_3)) {
        VAR_14 = 0;
        if (VAR_16<VAR_6)
            VAR_17 = *(VAR_7[VAR_16]);
        else
            VAR_17 = VAR_23; /* COMMENT_2 */
        get_amqp_1_0_type_value_formatter(VAR_0,
                                          VAR_1,
                                          VAR_2,
                                          VAR_3,
                                          VAR_17,
                                          NULL,
                                          &VAR_14,
                                          VAR_9);
        VAR_12 -= 1;
        VAR_16 += 1;
        AMQP_INCREMENT(VAR_2, VAR_14, VAR_3);
    }
    if (VAR_12 > 0)
        expert_add_info_format(VAR_1,
                               VAR_9,
                               &VAR_27,
                               ""Number of list elements (%d) not matching number of decoded elements (%d)"",
                               VAR_12+VAR_16, VAR_16);
    return VAR_2-VAR_15;
}",wireshark/a102c172b0b2fe231fdb49f4f6694603f5b93b0c/packet-amqp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -64,13 +64,13 @@
         return bound-orig_offset;
     }
 
-    list_tree = proto_tree_add_none_format(item,
-                                           hf_amqp_type,
-                                           tvb,
-                                           offset-1,
-                                           element_size+1+count_len,
-                                           ""%s"",
-                                           name ? name : proto_registrar_get_name(hf_amqp_type));
+    list_tree = proto_tree_add_item(item,
+                                    hf_amqp_type,
+                                    tvb,
+                                    offset-1,
+                                    element_size+1+count_len,
+                                    ENC_BIG_ENDIAN);
+    proto_item_set_text(list_tree, ""%s"", name ? name : proto_registrar_get_name(hf_amqp_type));
     AMQP_INCREMENT(offset, count_len*2, bound);
 
     if (element_count > 0)","{'deleted_lines': ['    list_tree = proto_tree_add_none_format(item,', '                                           hf_amqp_type,', '                                           tvb,', '                                           offset-1,', '                                           element_size+1+count_len,', '                                           ""%s"",', '                                           name ? name : proto_registrar_get_name(hf_amqp_type));'], 'added_lines': ['    list_tree = proto_tree_add_item(item,', '                                    hf_amqp_type,', '                                    tvb,', '                                    offset-1,', '                                    element_size+1+count_len,', '                                    ENC_BIG_ENDIAN);', '    proto_item_set_text(list_tree, ""%s"", name ? name : proto_registrar_get_name(hf_amqp_type));']}",True,"In Wireshark 2.2.0 to 2.2.7 and 2.0.0 to 2.0.13, the AMQP dissector could crash. This was addressed in epan/dissectors/packet-amqp.c by checking for successful list dissection.",7.5,HIGH,2,valid,2017-06-19T20:12:22Z,1
CVE-2017-11408,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"AMQP: workaround some proto_tree_add_none_format() asserts

Previously proto_tree_add_none_format() could be called with any type
of field type, not FT_NONE only.

Change-Id: I78976a168fc1bf606b72ad38d284bb0bd1794b03
Ping-Bug: 13780
Reviewed-on: https://code.wireshark.org/review/22243
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit 2de483c0925a5a93cdaee168997f3f3c7949d2d4)
 Conflicts:
	epan/dissectors/packet-amqp.c
Reviewed-on: https://code.wireshark.org/review/22258",a102c172b0b2fe231fdb49f4f6694603f5b93b0c,https://github.com/wireshark/wireshark/commit/a102c172b0b2fe231fdb49f4f6694603f5b93b0c,epan/dissectors/packet-amqp.c,dissect_amqp_1_0_array,"static guint
dissect_amqp_1_0_array(tvbuff_t *tvb,
packet_info *pinfo,
int offset,
int bound,
proto_item *item,
int hf_amqp_type,
guint32 hf_amqp_subtype_count,
const int **hf_amqp_subtypes,
const char *name)
{
proto_item *array_tree;
guint8      type;
guint8      count_len;
guint32     element_count;
guint32     element_size;
guint32     element_type;
guint32     decoded_element_size;
guint32     orig_offset;
guint32     decoded_elements;
int         hf_amqp_item;
guint32     hf_amqp_subtype_count_array = 0;
const int   **hf_amqp_subtypes_array = NULL;
const char  *type_name_array = NULL;
array_tree = 0;
decoded_elements = 0;
orig_offset = offset;
if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE)
{
expert_add_info_format(pinfo, item, &ei_amqp_unknown_amqp_type,
""Unexpected array type at frame position %d of field \""%s\"""",
offset,
name ? name : proto_registrar_get_name(hf_amqp_type));
return bound-orig_offset;
}
type = tvb_get_guint8(tvb, offset);
AMQP_INCREMENT(offset, 1, bound);
switch (type) {
case AMQP_1_0_TYPE_ARRAY8:
count_len = 1;
element_size = tvb_get_guint8(tvb, offset);
element_count = tvb_get_guint8(tvb, offset+count_len);
break;
case AMQP_1_0_TYPE_ARRAY32:
count_len = 4;
element_size = tvb_get_ntohl(tvb, offset);
element_count = tvb_get_ntohl(tvb, offset+count_len);
break;
default:
proto_tree_add_none_format(array_tree, hf_amqp_1_0_list, tvb,
offset-1,
1,
""(unknown type %d)"",
type);
expert_add_info_format(pinfo,
array_tree,
&ei_amqp_unknown_amqp_type,
""Unknown AMQP array type %d"",
type);
return bound-orig_offset;
}
element_type = get_amqp_1_0_type_formatter(tvb,
offset+count_len*2,
bound,
&hf_amqp_type,
&type_name_array,
&hf_amqp_subtype_count_array,
&hf_amqp_subtypes_array,
&decoded_element_size);
array_tree = proto_tree_add_none_format(item,
hf_amqp_type,
tvb,
offset-1,
element_size+1+count_len,
""%s"",
name ? name : proto_registrar_get_name(hf_amqp_type));
AMQP_INCREMENT(offset, count_len*2+decoded_element_size, bound);
if (element_count > 0)
array_tree = proto_item_add_subtree(array_tree, ett_amqp_1_0_array);
if (hf_amqp_subtype_count == 0)
proto_item_append_text(array_tree, "" (array of %d element%s)"", element_count, element_suffix[element_count!=1]);
if (element_count > element_size)
{
expert_add_info_format(pinfo,
array_tree,
&ei_amqp_invalid_number_of_params,
""Number of array elements (%d) bigger than array size (%d)"",
element_count, element_size);
return bound-orig_offset;
}
while ((element_count > 0) && (offset < bound)) {
decoded_element_size = 0;
if (decoded_elements<hf_amqp_subtype_count)
hf_amqp_item = *(hf_amqp_subtypes[decoded_elements]);
else
hf_amqp_item = hf_amqp_1_0_list; 
get_amqp_1_0_value_formatter(tvb,
pinfo,
element_type, 
offset,
offset+element_size, 
hf_amqp_item,
(proto_registrar_get_nth(hf_amqp_type))->name, 
hf_amqp_subtype_count_array, 
hf_amqp_subtypes_array, 
&decoded_element_size,
array_tree);
element_count -= 1;
decoded_elements += 1;
if (decoded_element_size==0)
decoded_element_size=1; 
AMQP_INCREMENT(offset, decoded_element_size, bound);
}
if (element_count > 0)
expert_add_info_format(pinfo,
array_tree,
&ei_amqp_invalid_number_of_params,
""Number of array elements (%d) not matching number of decoded elements (%d)"",
element_count+decoded_elements, decoded_elements);
return offset-orig_offset;
}","static guint
dissect_amqp_1_0_array(tvbuff_t *VAR_0,
packet_info *VAR_1,
int VAR_2,
int VAR_3,
proto_item *VAR_4,
int VAR_5,
guint32 VAR_6,
const int **VAR_7,
const char *VAR_8)
{
proto_item *VAR_9;
guint8      VAR_10;
guint8      VAR_11;
guint32     VAR_12;
guint32     VAR_13;
guint32     VAR_14;
guint32     VAR_15;
guint32     VAR_16;
guint32     VAR_17;
int         VAR_18;
guint32     VAR_19 = 0;
const int   **VAR_20 = NULL;
const char  *VAR_21 = NULL;
VAR_9 = 0;
VAR_17 = 0;
VAR_16 = VAR_2;
if (proto_registrar_get_ftype(VAR_5) != VAR_22)
{
expert_add_info_format(VAR_1, VAR_4, &VAR_23,
""Unexpected array type at frame position %d of field \""%s\"""",
VAR_2,
VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
return VAR_3-VAR_16;
}
VAR_10 = tvb_get_guint8(VAR_0, VAR_2);
AMQP_INCREMENT(VAR_2, 1, VAR_3);
switch (VAR_10) {
case VAR_24:
VAR_11 = 1;
VAR_13 = tvb_get_guint8(VAR_0, VAR_2);
VAR_12 = tvb_get_guint8(VAR_0, VAR_2+VAR_11);
break;
case VAR_25:
VAR_11 = 4;
VAR_13 = tvb_get_ntohl(VAR_0, VAR_2);
VAR_12 = tvb_get_ntohl(VAR_0, VAR_2+VAR_11);
break;
default:
proto_tree_add_none_format(VAR_9, VAR_26, VAR_0,
VAR_2-1,
1,
""(unknown type %d)"",
VAR_10);
expert_add_info_format(VAR_1,
VAR_9,
&VAR_23,
""Unknown AMQP array type %d"",
VAR_10);
return VAR_3-VAR_16;
}
VAR_14 = get_amqp_1_0_type_formatter(VAR_0,
VAR_2+VAR_11*2,
VAR_3,
&VAR_5,
&VAR_21,
&VAR_19,
&VAR_20,
&VAR_15);
VAR_9 = proto_tree_add_none_format(VAR_4,
VAR_5,
VAR_0,
VAR_2-1,
VAR_13+1+VAR_11,
""%s"",
VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
AMQP_INCREMENT(VAR_2, VAR_11*2+VAR_15, VAR_3);
if (VAR_12 > 0)
VAR_9 = proto_item_add_subtree(VAR_9, VAR_27);
if (VAR_6 == 0)
proto_item_append_text(VAR_9, "" (array of %d element%s)"", VAR_12, VAR_28[VAR_12!=1]);
if (VAR_12 > VAR_13)
{
expert_add_info_format(VAR_1,
VAR_9,
&VAR_29,
""Number of array elements (%d) bigger than array size (%d)"",
VAR_12, VAR_13);
return VAR_3-VAR_16;
}
while ((VAR_12 > 0) && (VAR_2 < VAR_3)) {
VAR_15 = 0;
if (VAR_17<VAR_6)
VAR_18 = *(VAR_7[VAR_17]);
else
VAR_18 = VAR_26; 
get_amqp_1_0_value_formatter(VAR_0,
VAR_1,
VAR_14, 
VAR_2,
VAR_2+VAR_13, 
VAR_18,
(proto_registrar_get_nth(VAR_5))->name, 
VAR_19, 
VAR_20, 
&VAR_15,
VAR_9);
VAR_12 -= 1;
VAR_17 += 1;
if (VAR_15==0)
VAR_15=1; 
AMQP_INCREMENT(VAR_2, VAR_15, VAR_3);
}
if (VAR_12 > 0)
expert_add_info_format(VAR_1,
VAR_9,
&VAR_29,
""Number of array elements (%d) not matching number of decoded elements (%d)"",
VAR_12+VAR_17, VAR_17);
return VAR_2-VAR_16;
}",wireshark/a102c172b0b2fe231fdb49f4f6694603f5b93b0c/packet-amqp.c/vul/before/1.json,"static guint
dissect_amqp_1_0_array(tvbuff_t *tvb,
                       packet_info *pinfo,
                       int offset,
                       int bound,
                       proto_item *item,
                       int hf_amqp_type,
                       guint32 hf_amqp_subtype_count,
                       const int **hf_amqp_subtypes,
                       const char *name)
{
    proto_item *array_tree;
    guint8      type;
    guint8      count_len;
    guint32     element_count;
    guint32     element_size;
    guint32     element_type;
    guint32     decoded_element_size;
    guint32     orig_offset;
    guint32     decoded_elements;
    int         hf_amqp_item;
    guint32     hf_amqp_subtype_count_array = 0;
    const int   **hf_amqp_subtypes_array = NULL;
    const char  *type_name_array = NULL;

    array_tree = 0;
    decoded_elements = 0;
    orig_offset = offset;

    if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE)
    {
        expert_add_info_format(pinfo, item, &ei_amqp_unknown_amqp_type,
                               ""Unexpected array type at frame position %d of field \""%s\"""",
                               offset,
                               name ? name : proto_registrar_get_name(hf_amqp_type));
        return bound-orig_offset;
    }

    type = tvb_get_guint8(tvb, offset);
    AMQP_INCREMENT(offset, 1, bound);
    switch (type) {
    case AMQP_1_0_TYPE_ARRAY8:
        count_len = 1;
        element_size = tvb_get_guint8(tvb, offset);
        element_count = tvb_get_guint8(tvb, offset+count_len);
        break;
    case AMQP_1_0_TYPE_ARRAY32:
        count_len = 4;
        element_size = tvb_get_ntohl(tvb, offset);
        element_count = tvb_get_ntohl(tvb, offset+count_len);
        break;
    default:
        proto_tree_add_none_format(array_tree, hf_amqp_1_0_list, tvb,
                                   offset-1,
                                   1,
                                   ""(unknown type %d)"",
                                   type);
        expert_add_info_format(pinfo,
                               array_tree,
                               &ei_amqp_unknown_amqp_type,
                               ""Unknown AMQP array type %d"",
                               type);
        return bound-orig_offset;
    }

    element_type = get_amqp_1_0_type_formatter(tvb,
                                               offset+count_len*2,
                                               bound,
                                               &hf_amqp_type,
                                               &type_name_array,
                                               &hf_amqp_subtype_count_array,
                                               &hf_amqp_subtypes_array,
                                               &decoded_element_size);

    array_tree = proto_tree_add_item(item,
                                     hf_amqp_type,
                                     tvb,
                                     offset-1,
                                     element_size+1+count_len,
                                     ENC_BIG_ENDIAN);
    proto_item_set_text(array_tree, ""%s"", name ? name : proto_registrar_get_name(hf_amqp_type));
    AMQP_INCREMENT(offset, count_len*2+decoded_element_size, bound);

    if (element_count > 0)
        array_tree = proto_item_add_subtree(array_tree, ett_amqp_1_0_array);
    /* display the item count for custom arrays only
     * standard structures contain NULL items, so the real element count is different */
    if (hf_amqp_subtype_count == 0)
        proto_item_append_text(array_tree, "" (array of %d element%s)"", element_count, element_suffix[element_count!=1]);

    if (element_count > element_size)
    {
        expert_add_info_format(pinfo,
                               array_tree,
                               &ei_amqp_invalid_number_of_params,
                               ""Number of array elements (%d) bigger than array size (%d)"",
                               element_count, element_size);
        return bound-orig_offset;
    }

    while ((element_count > 0) && (offset < bound)) {
        decoded_element_size = 0;
        if (decoded_elements<hf_amqp_subtype_count)
            hf_amqp_item = *(hf_amqp_subtypes[decoded_elements]);
        else
            hf_amqp_item = hf_amqp_1_0_list; /* dynamic item */
        get_amqp_1_0_value_formatter(tvb,
                                     pinfo,
                                     element_type, /* code */
                                     offset,
                                     offset+element_size, /* bound */
                                     hf_amqp_item,
                                     (proto_registrar_get_nth(hf_amqp_type))->name, /* name */
                                     hf_amqp_subtype_count_array, /* subitem list count */
                                     hf_amqp_subtypes_array, /* subitem list hf_.. list */
                                     &decoded_element_size,
                                     array_tree);
        element_count -= 1;
        decoded_elements += 1;
        if (decoded_element_size==0)
            decoded_element_size=1; /* necessary for 0x40 or similar values where value_formatter returns size of _value_ 0 (type=1 not counted) */
        AMQP_INCREMENT(offset, decoded_element_size, bound);
    }
    if (element_count > 0)
        expert_add_info_format(pinfo,
                               array_tree,
                               &ei_amqp_invalid_number_of_params,
                               ""Number of array elements (%d) not matching number of decoded elements (%d)"",
                               element_count+decoded_elements, decoded_elements);
    return offset-orig_offset;
}","static guint
dissect_amqp_1_0_array(tvbuff_t *VAR_0,
                       packet_info *VAR_1,
                       int VAR_2,
                       int VAR_3,
                       proto_item *VAR_4,
                       int VAR_5,
                       guint32 VAR_6,
                       const int **VAR_7,
                       const char *VAR_8)
{
    proto_item *VAR_9;
    guint8      VAR_10;
    guint8      VAR_11;
    guint32     VAR_12;
    guint32     VAR_13;
    guint32     VAR_14;
    guint32     VAR_15;
    guint32     VAR_16;
    guint32     VAR_17;
    int         VAR_18;
    guint32     VAR_19 = 0;
    const int   **VAR_20 = NULL;
    const char  *VAR_21 = NULL;

    VAR_9 = 0;
    VAR_17 = 0;
    VAR_16 = VAR_2;

    if (proto_registrar_get_ftype(VAR_5) != VAR_22)
    {
        expert_add_info_format(VAR_1, VAR_4, &VAR_23,
                               ""Unexpected array type at frame position %d of field \""%s\"""",
                               VAR_2,
                               VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
        return VAR_3-VAR_16;
    }

    VAR_10 = tvb_get_guint8(VAR_0, VAR_2);
    AMQP_INCREMENT(VAR_2, 1, VAR_3);
    switch (VAR_10) {
    case VAR_24:
        VAR_11 = 1;
        VAR_13 = tvb_get_guint8(VAR_0, VAR_2);
        VAR_12 = tvb_get_guint8(VAR_0, VAR_2+VAR_11);
        break;
    case VAR_25:
        VAR_11 = 4;
        VAR_13 = tvb_get_ntohl(VAR_0, VAR_2);
        VAR_12 = tvb_get_ntohl(VAR_0, VAR_2+VAR_11);
        break;
    default:
        proto_tree_add_none_format(VAR_9, VAR_26, VAR_0,
                                   VAR_2-1,
                                   1,
                                   ""(unknown type %d)"",
                                   VAR_10);
        expert_add_info_format(VAR_1,
                               VAR_9,
                               &VAR_23,
                               ""Unknown AMQP array type %d"",
                               VAR_10);
        return VAR_3-VAR_16;
    }

    VAR_14 = get_amqp_1_0_type_formatter(VAR_0,
                                               VAR_2+VAR_11*2,
                                               VAR_3,
                                               &VAR_5,
                                               &VAR_21,
                                               &VAR_19,
                                               &VAR_20,
                                               &VAR_15);

    VAR_9 = proto_tree_add_item(VAR_4,
                                     VAR_5,
                                     VAR_0,
                                     VAR_2-1,
                                     VAR_13+1+VAR_11,
                                     VAR_27);
    proto_item_set_text(VAR_9, ""%s"", VAR_8 ? VAR_8 : proto_registrar_get_name(VAR_5));
    AMQP_INCREMENT(VAR_2, VAR_11*2+VAR_15, VAR_3);

    if (VAR_12 > 0)
        VAR_9 = proto_item_add_subtree(VAR_9, VAR_28);
    /* COMMENT_0 */
                                                                                        
    if (VAR_6 == 0)
        proto_item_append_text(VAR_9, "" (array of %d element%s)"", VAR_12, VAR_29[VAR_12!=1]);

    if (VAR_12 > VAR_13)
    {
        expert_add_info_format(VAR_1,
                               VAR_9,
                               &VAR_30,
                               ""Number of array elements (%d) bigger than array size (%d)"",
                               VAR_12, VAR_13);
        return VAR_3-VAR_16;
    }

    while ((VAR_12 > 0) && (VAR_2 < VAR_3)) {
        VAR_15 = 0;
        if (VAR_17<VAR_6)
            VAR_18 = *(VAR_7[VAR_17]);
        else
            VAR_18 = VAR_26; /* COMMENT_2 */
        get_amqp_1_0_value_formatter(VAR_0,
                                     VAR_1,
                                     VAR_14, /* COMMENT_3 */
                                     VAR_2,
                                     VAR_2+VAR_13, /* COMMENT_4 */
                                     VAR_18,
                                     (proto_registrar_get_nth(VAR_5))->name, /* COMMENT_5 */
                                     VAR_19, /* COMMENT_6 */
                                     VAR_20, /* COMMENT_7 */
                                     &VAR_15,
                                     VAR_9);
        VAR_12 -= 1;
        VAR_17 += 1;
        if (VAR_15==0)
            VAR_15=1; /* COMMENT_8 */
        AMQP_INCREMENT(VAR_2, VAR_15, VAR_3);
    }
    if (VAR_12 > 0)
        expert_add_info_format(VAR_1,
                               VAR_9,
                               &VAR_30,
                               ""Number of array elements (%d) not matching number of decoded elements (%d)"",
                               VAR_12+VAR_17, VAR_17);
    return VAR_2-VAR_16;
}",wireshark/a102c172b0b2fe231fdb49f4f6694603f5b93b0c/packet-amqp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -72,13 +72,13 @@
                                                &hf_amqp_subtypes_array,
                                                &decoded_element_size);
 
-    array_tree = proto_tree_add_none_format(item,
-                                            hf_amqp_type,
-                                            tvb,
-                                            offset-1,
-                                            element_size+1+count_len,
-                                            ""%s"",
-                                            name ? name : proto_registrar_get_name(hf_amqp_type));
+    array_tree = proto_tree_add_item(item,
+                                     hf_amqp_type,
+                                     tvb,
+                                     offset-1,
+                                     element_size+1+count_len,
+                                     ENC_BIG_ENDIAN);
+    proto_item_set_text(array_tree, ""%s"", name ? name : proto_registrar_get_name(hf_amqp_type));
     AMQP_INCREMENT(offset, count_len*2+decoded_element_size, bound);
 
     if (element_count > 0)","{'deleted_lines': ['    array_tree = proto_tree_add_none_format(item,', '                                            hf_amqp_type,', '                                            tvb,', '                                            offset-1,', '                                            element_size+1+count_len,', '                                            ""%s"",', '                                            name ? name : proto_registrar_get_name(hf_amqp_type));'], 'added_lines': ['    array_tree = proto_tree_add_item(item,', '                                     hf_amqp_type,', '                                     tvb,', '                                     offset-1,', '                                     element_size+1+count_len,', '                                     ENC_BIG_ENDIAN);', '    proto_item_set_text(array_tree, ""%s"", name ? name : proto_registrar_get_name(hf_amqp_type));']}",True,"In Wireshark 2.2.0 to 2.2.7 and 2.0.0 to 2.0.13, the AMQP dissector could crash. This was addressed in epan/dissectors/packet-amqp.c by checking for successful list dissection.",7.5,HIGH,2,valid,2017-06-19T20:12:22Z,1
CVE-2017-9847,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,arvidn/libtorrent,"fix out-of-bounds read in bdecode

Fixes #2099",ec30a5e9ec703afb8abefba757c6d401303b53db,https://github.com/arvidn/libtorrent/commit/ec30a5e9ec703afb8abefba757c6d401303b53db,src/bdecode.cpp,bdecode,"int bdecode(char const* start, char const* end, bdecode_node& ret
, error_code& ec, int* error_pos, int depth_limit, int token_limit)
{
ec.clear();
ret.clear();
if (end - start > bdecode_token::max_offset)
{
if (error_pos) *error_pos = 0;
ec = bdecode_errors::limit_exceeded;
return -1;
}
int sp = 0;
stack_frame* stack = TORRENT_ALLOCA(stack_frame, depth_limit);
char const* const orig_start = start;
if (start == end)
TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
while (start <= end)
{
if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (sp >= depth_limit)
TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);
--token_limit;
if (token_limit < 0)
TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);
const char t = *start;
const int current_frame = sp;
if (current_frame > 0
&& ret.m_tokens[stack[current_frame-1].token].type == bdecode_token::dict)
{
if (stack[current_frame-1].state == 0)
{
if (!numeric(t) && t != 'e')
TORRENT_FAIL_BDECODE(bdecode_errors::expected_digit);
}
}
switch (t)
{
case 'd':
stack[sp++] = ret.m_tokens.size();
ret.m_tokens.push_back(bdecode_token(start - orig_start
, bdecode_token::dict));
++start;
break;
case 'l':
stack[sp++] = ret.m_tokens.size();
ret.m_tokens.push_back(bdecode_token(start - orig_start
, bdecode_token::list));
++start;
break;
case 'i':
{
char const* int_start = start;
bdecode_errors::error_code_enum e = bdecode_errors::no_error;
start = check_integer(start + 1, end, e);
if (e)
{
if (error_pos) *error_pos = start - orig_start;
error_pos = NULL;
start = int_start;
TORRENT_FAIL_BDECODE(e);
}
ret.m_tokens.push_back(bdecode_token(int_start - orig_start
, 1, bdecode_token::integer, 1));
TORRENT_ASSERT(*start == 'e');
++start;
break;
}
case 'e':
{
if (sp == 0)
TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (sp > 0
&& ret.m_tokens[stack[sp-1].token].type == bdecode_token::dict
&& stack[sp-1].state == 1)
{
TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);
}
ret.m_tokens.push_back(bdecode_token(start - orig_start, 1
, bdecode_token::end));
int top = stack[sp-1].token;
if (ret.m_tokens.size() - top > bdecode_token::max_next_item)
TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);
ret.m_tokens[top].next_item = ret.m_tokens.size() - top;
--sp;
++start;
break;
}
default:
{
if (!numeric(t))
TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);
boost::int64_t len = t - '0';
char const* str_start = start;
++start;
bdecode_errors::error_code_enum e = bdecode_errors::no_error;
start = parse_int(start, end, ':', len, e);
if (e)
TORRENT_FAIL_BDECODE(e);
const ptrdiff_t buff_size = end - start - 1;
if (len > buff_size)
TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (len < 0)
TORRENT_FAIL_BDECODE(bdecode_errors::overflow);
++start;
if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (start - str_start - 2 > detail::bdecode_token::max_header)
TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);
ret.m_tokens.push_back(bdecode_token(str_start - orig_start
, 1, bdecode_token::string, start - str_start));
start += len;
break;
}
}
if (current_frame > 0
&& ret.m_tokens[stack[current_frame-1].token].type == bdecode_token::dict)
{
stack[current_frame-1].state = ~stack[current_frame-1].state;
}
if (sp == 0) break;
}
done:
while (sp > 0) {
TORRENT_ASSERT(ec);
--sp;
if (ret.m_tokens[stack[sp].token].type == bdecode_token::dict
&& stack[sp].state == 1)
{
ret.m_tokens.push_back(bdecode_token(start - orig_start
, 2, bdecode_token::dict));
ret.m_tokens.push_back(bdecode_token(start - orig_start
, bdecode_token::end));
}
int top = stack[sp].token;
TORRENT_ASSERT(ret.m_tokens.size() - top <= bdecode_token::max_next_item);
ret.m_tokens[top].next_item = ret.m_tokens.size() - top;
ret.m_tokens.push_back(bdecode_token(start - orig_start, 1, bdecode_token::end));
}
ret.m_tokens.push_back(bdecode_token(start - orig_start, 0
, bdecode_token::end));
ret.m_token_idx = 0;
ret.m_buffer = orig_start;
ret.m_buffer_size = start - orig_start;
ret.m_root_tokens = &ret.m_tokens[0];
return ec ? -1 : 0;
}","int bdecode(char const* VAR_0, char const* VAR_1, bdecode_node& VAR_2
, error_code& VAR_3, int* VAR_4, int VAR_5, int VAR_6)
{
VAR_3.clear();
VAR_2.clear();
if (VAR_1 - VAR_0 > bdecode_token::max_offset)
{
if (VAR_4) *VAR_4 = 0;
VAR_3 = bdecode_errors::limit_exceeded;
return -1;
}
int VAR_7 = 0;
stack_frame* VAR_8 = TORRENT_ALLOCA(stack_frame, VAR_5);
char const* const VAR_9 = VAR_0;
if (VAR_0 == VAR_1)
TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
while (VAR_0 <= VAR_1)
{
if (VAR_0 >= VAR_1) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (VAR_7 >= VAR_5)
TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);
--VAR_6;
if (VAR_6 < 0)
TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);
const char VAR_10 = *VAR_0;
const int VAR_11 = VAR_7;
if (VAR_11 > 0
&& VAR_2.m_tokens[VAR_8[VAR_11-1].token].type == bdecode_token::dict)
{
if (VAR_8[VAR_11-1].state == 0)
{
if (!numeric(VAR_10) && VAR_10 != 'e')
TORRENT_FAIL_BDECODE(bdecode_errors::expected_digit);
}
}
switch (VAR_10)
{
case 'd':
VAR_8[VAR_7++] = VAR_2.m_tokens.size();
VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
, bdecode_token::dict));
++VAR_0;
break;
case 'l':
VAR_8[VAR_7++] = VAR_2.m_tokens.size();
VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
, bdecode_token::list));
++VAR_0;
break;
case 'i':
{
char const* VAR_12 = VAR_0;
bdecode_errors::error_code_enum VAR_13 = bdecode_errors::no_error;
VAR_0 = check_integer(VAR_0 + 1, VAR_1, VAR_13);
if (VAR_13)
{
if (VAR_4) *VAR_4 = VAR_0 - VAR_9;
VAR_4 = NULL;
VAR_0 = VAR_12;
TORRENT_FAIL_BDECODE(VAR_13);
}
VAR_2.m_tokens.push_back(bdecode_token(VAR_12 - VAR_9
, 1, bdecode_token::integer, 1));
TORRENT_ASSERT(*VAR_0 == 'e');
++VAR_0;
break;
}
case 'e':
{
if (VAR_7 == 0)
TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (VAR_7 > 0
&& VAR_2.m_tokens[VAR_8[VAR_7-1].token].type == bdecode_token::dict
&& VAR_8[VAR_7-1].state == 1)
{
TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);
}
VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9, 1
, bdecode_token::end));
int VAR_14 = VAR_8[VAR_7-1].token;
if (VAR_2.m_tokens.size() - VAR_14 > bdecode_token::max_next_item)
TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);
VAR_2.m_tokens[VAR_14].next_item = VAR_2.m_tokens.size() - VAR_14;
--VAR_7;
++VAR_0;
break;
}
default:
{
if (!numeric(VAR_10))
TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);
boost::int64_t VAR_15 = VAR_10 - '0';
char const* VAR_16 = VAR_0;
++VAR_0;
bdecode_errors::error_code_enum VAR_13 = bdecode_errors::no_error;
VAR_0 = parse_int(VAR_0, VAR_1, ':', VAR_15, VAR_13);
if (VAR_13)
TORRENT_FAIL_BDECODE(VAR_13);
const ptrdiff_t VAR_17 = VAR_1 - VAR_0 - 1;
if (VAR_15 > VAR_17)
TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (VAR_15 < 0)
TORRENT_FAIL_BDECODE(bdecode_errors::overflow);
++VAR_0;
if (VAR_0 >= VAR_1) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
if (VAR_0 - VAR_16 - 2 > detail::bdecode_token::max_header)
TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);
VAR_2.m_tokens.push_back(bdecode_token(VAR_16 - VAR_9
, 1, bdecode_token::string, VAR_0 - VAR_16));
VAR_0 += VAR_15;
break;
}
}
if (VAR_11 > 0
&& VAR_2.m_tokens[VAR_8[VAR_11-1].token].type == bdecode_token::dict)
{
VAR_8[VAR_11-1].state = ~VAR_8[VAR_11-1].state;
}
if (VAR_7 == 0) break;
}
done:
while (VAR_7 > 0) {
TORRENT_ASSERT(VAR_3);
--VAR_7;
if (VAR_2.m_tokens[VAR_8[VAR_7].token].type == bdecode_token::dict
&& VAR_8[VAR_7].state == 1)
{
VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
, 2, bdecode_token::dict));
VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
, bdecode_token::end));
}
int VAR_14 = VAR_8[VAR_7].token;
TORRENT_ASSERT(VAR_2.m_tokens.size() - VAR_14 <= bdecode_token::max_next_item);
VAR_2.m_tokens[VAR_14].next_item = VAR_2.m_tokens.size() - VAR_14;
VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9, 1, bdecode_token::end));
}
VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9, 0
, bdecode_token::end));
VAR_2.m_token_idx = 0;
VAR_2.m_buffer = VAR_9;
VAR_2.m_buffer_size = VAR_0 - VAR_9;
VAR_2.m_root_tokens = &VAR_2.m_tokens[0];
return VAR_3 ? -1 : 0;
}",arvidn/libtorrent/ec30a5e9ec703afb8abefba757c6d401303b53db/bdecode.cpp/vul/before/0.json,"int bdecode(char const* start, char const* end, bdecode_node& ret
		, error_code& ec, int* error_pos, int depth_limit, int token_limit)
	{
		ec.clear();
		ret.clear();

		if (end - start > bdecode_token::max_offset)
		{
			if (error_pos) *error_pos = 0;
			ec = bdecode_errors::limit_exceeded;
			return -1;
		}

		// this is the stack of bdecode_token indices, into m_tokens.
		// sp is the stack pointer, as index into the array, stack
		int sp = 0;
		stack_frame* stack = TORRENT_ALLOCA(stack_frame, depth_limit);

		char const* const orig_start = start;

		if (start == end)
			TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

		while (start <= end)
		{
			if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

			if (sp >= depth_limit)
				TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);

			--token_limit;
			if (token_limit < 0)
				TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);

			// look for a new token
			const char t = *start;

			const int current_frame = sp;

			// if we're currently parsing a dictionary, assert that
			// every other node is a string.
			if (current_frame > 0
				&& ret.m_tokens[stack[current_frame-1].token].type == bdecode_token::dict)
			{
				if (stack[current_frame-1].state == 0)
				{
					// the current parent is a dict and we are parsing a key.
					// only allow a digit (for a string) or 'e' to terminate
					if (!numeric(t) && t != 'e')
						TORRENT_FAIL_BDECODE(bdecode_errors::expected_digit);
				}
			}

			switch (t)
			{
				case 'd':
					stack[sp++] = ret.m_tokens.size();
					// we push it into the stack so that we know where to fill
					// in the next_node field once we pop this node off the stack.
					// i.e. get to the node following the dictionary in the buffer
					ret.m_tokens.push_back(bdecode_token(start - orig_start
						, bdecode_token::dict));
					++start;
					break;
				case 'l':
					stack[sp++] = ret.m_tokens.size();
					// we push it into the stack so that we know where to fill
					// in the next_node field once we pop this node off the stack.
					// i.e. get to the node following the list in the buffer
					ret.m_tokens.push_back(bdecode_token(start - orig_start
						, bdecode_token::list));
					++start;
					break;
				case 'i':
				{
					char const* int_start = start;
					bdecode_errors::error_code_enum e = bdecode_errors::no_error;
					// +1 here to point to the first digit, rather than 'i'
					start = check_integer(start + 1, end, e);
					if (e)
					{
						// in order to gracefully terminate the tree,
						// make sure the end of the previous token is set correctly
						if (error_pos) *error_pos = start - orig_start;
						error_pos = NULL;
						start = int_start;
						TORRENT_FAIL_BDECODE(e);
					}
					ret.m_tokens.push_back(bdecode_token(int_start - orig_start
						, 1, bdecode_token::integer, 1));
					TORRENT_ASSERT(*start == 'e');

					// skip 'e'
					++start;
					break;
				}
				case 'e':
				{
					// this is the end of a list or dict
					if (sp == 0)
						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

					if (sp > 0
						&& ret.m_tokens[stack[sp-1].token].type == bdecode_token::dict
						&& stack[sp-1].state == 1)
					{
						// this means we're parsing a dictionary and about to parse a
						// value associated with a key. Instead, we got a termination
						TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);
					}

					// insert the end-of-sequence token
					ret.m_tokens.push_back(bdecode_token(start - orig_start, 1
						, bdecode_token::end));

					// and back-patch the start of this sequence with the offset
					// to the next token we'll insert
					int top = stack[sp-1].token;
					// subtract the token's own index, since this is a relative
					// offset
					if (ret.m_tokens.size() - top > bdecode_token::max_next_item)
						TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);

					ret.m_tokens[top].next_item = ret.m_tokens.size() - top;

					// and pop it from the stack.
					--sp;
					++start;
					break;
				}
				default:
				{
					// this is the case for strings. The start character is any
					// numeric digit
					if (!numeric(t))
						TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);

					boost::int64_t len = t - '0';
					char const* str_start = start;
					++start;
					if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
					bdecode_errors::error_code_enum e = bdecode_errors::no_error;
					start = parse_int(start, end, ':', len, e);
					if (e)
						TORRENT_FAIL_BDECODE(e);

					// remaining buffer size excluding ':'
					const ptrdiff_t buff_size = end - start - 1;
					if (len > buff_size)
						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
					if (len < 0)
						TORRENT_FAIL_BDECODE(bdecode_errors::overflow);

					// skip ':'
					++start;
					if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

					// the bdecode_token only has 8 bits to keep the header size
					// in. If it overflows, fail!
					if (start - str_start - 2 > detail::bdecode_token::max_header)
						TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);

					ret.m_tokens.push_back(bdecode_token(str_start - orig_start
						, 1, bdecode_token::string, start - str_start));
					start += len;
					break;
				}
			}

			if (current_frame > 0
				&& ret.m_tokens[stack[current_frame-1].token].type == bdecode_token::dict)
			{
				// the next item we parse is the opposite
				stack[current_frame-1].state = ~stack[current_frame-1].state;
			}

			// this terminates the top level node, we're done!
			if (sp == 0) break;
		}

done:

		// if parse failed, sp will be greater than 1
		// unwind the stack by inserting terminator to make whatever we have
		// so far valid
		while (sp > 0) {
			TORRENT_ASSERT(ec);
			--sp;

			// we may need to insert a dummy token to properly terminate the tree,
			// in case we just parsed a key to a dict and failed in the value
			if (ret.m_tokens[stack[sp].token].type == bdecode_token::dict
				&& stack[sp].state == 1)
			{
				// insert an empty dictionary as the value
				ret.m_tokens.push_back(bdecode_token(start - orig_start
					, 2, bdecode_token::dict));
				ret.m_tokens.push_back(bdecode_token(start - orig_start
					, bdecode_token::end));
			}

			int top = stack[sp].token;
			TORRENT_ASSERT(ret.m_tokens.size() - top <= bdecode_token::max_next_item);
			ret.m_tokens[top].next_item = ret.m_tokens.size() - top;
			ret.m_tokens.push_back(bdecode_token(start - orig_start, 1, bdecode_token::end));
		}

		ret.m_tokens.push_back(bdecode_token(start - orig_start, 0
			, bdecode_token::end));

		ret.m_token_idx = 0;
		ret.m_buffer = orig_start;
		ret.m_buffer_size = start - orig_start;
		ret.m_root_tokens = &ret.m_tokens[0];

		return ec ? -1 : 0;
	}","int bdecode(char const* VAR_0, char const* VAR_1, bdecode_node& VAR_2
		, error_code& VAR_3, int* VAR_4, int VAR_5, int VAR_6)
	{
		VAR_3.clear();
		VAR_2.clear();

		if (VAR_1 - VAR_0 > bdecode_token::max_offset)
		{
			if (VAR_4) *VAR_4 = 0;
			VAR_3 = bdecode_errors::limit_exceeded;
			return -1;
		}

		/* COMMENT_0 */
		/* COMMENT_1 */
		int VAR_7 = 0;
		stack_frame* VAR_8 = TORRENT_ALLOCA(stack_frame, VAR_5);

		char const* const VAR_9 = VAR_0;

		if (VAR_0 == VAR_1)
			TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

		while (VAR_0 <= VAR_1)
		{
			if (VAR_0 >= VAR_1) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

			if (VAR_7 >= VAR_5)
				TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);

			--VAR_6;
			if (VAR_6 < 0)
				TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);

			/* COMMENT_2 */
			const char VAR_10 = *VAR_0;

			const int VAR_11 = VAR_7;

			/* COMMENT_3 */
			/* COMMENT_4 */
			if (VAR_11 > 0
				&& VAR_2.m_tokens[VAR_8[VAR_11-1].token].type == bdecode_token::dict)
			{
				if (VAR_8[VAR_11-1].state == 0)
				{
					/* COMMENT_5 */
					/* COMMENT_6 */
					if (!numeric(VAR_10) && VAR_10 != 'e')
						TORRENT_FAIL_BDECODE(bdecode_errors::expected_digit);
				}
			}

			switch (VAR_10)
			{
				case 'd':
					VAR_8[VAR_7++] = VAR_2.m_tokens.size();
					/* COMMENT_7 */
					/* COMMENT_8 */
					/* COMMENT_9 */
					VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
						, bdecode_token::dict));
					++VAR_0;
					break;
				case 'l':
					VAR_8[VAR_7++] = VAR_2.m_tokens.size();
					/* COMMENT_7 */
					/* COMMENT_8 */
					/* COMMENT_10 */
					VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
						, bdecode_token::list));
					++VAR_0;
					break;
				case 'i':
				{
					char const* VAR_12 = VAR_0;
					bdecode_errors::error_code_enum VAR_13 = bdecode_errors::no_error;
					/* COMMENT_11 */
					VAR_0 = check_integer(VAR_0 + 1, VAR_1, VAR_13);
					if (VAR_13)
					{
						/* COMMENT_12 */
						/* COMMENT_13 */
						if (VAR_4) *VAR_4 = VAR_0 - VAR_9;
						VAR_4 = NULL;
						VAR_0 = VAR_12;
						TORRENT_FAIL_BDECODE(VAR_13);
					}
					VAR_2.m_tokens.push_back(bdecode_token(VAR_12 - VAR_9
						, 1, bdecode_token::integer, 1));
					TORRENT_ASSERT(*VAR_0 == 'e');

					/* COMMENT_14 */
					++VAR_0;
					break;
				}
				case 'e':
				{
					/* COMMENT_15 */
					if (VAR_7 == 0)
						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

					if (VAR_7 > 0
						&& VAR_2.m_tokens[VAR_8[VAR_7-1].token].type == bdecode_token::dict
						&& VAR_8[VAR_7-1].state == 1)
					{
						/* COMMENT_16 */
						/* COMMENT_17 */
						TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);
					}

					/* COMMENT_18 */
					VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9, 1
						, bdecode_token::end));

					/* COMMENT_19 */
					/* COMMENT_20 */
					int VAR_14 = VAR_8[VAR_7-1].token;
					/* COMMENT_21 */
					/* COMMENT_22 */
					if (VAR_2.m_tokens.size() - VAR_14 > bdecode_token::max_next_item)
						TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);

					VAR_2.m_tokens[VAR_14].next_item = VAR_2.m_tokens.size() - VAR_14;

					/* COMMENT_23 */
					--VAR_7;
					++VAR_0;
					break;
				}
				default:
				{
					/* COMMENT_24 */
					/* COMMENT_25 */
					if (!numeric(VAR_10))
						TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);

					boost::int64_t VAR_15 = VAR_10 - '0';
					char const* VAR_16 = VAR_0;
					++VAR_0;
					if (VAR_0 >= VAR_1) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
					bdecode_errors::error_code_enum VAR_13 = bdecode_errors::no_error;
					VAR_0 = parse_int(VAR_0, VAR_1, ':', VAR_15, VAR_13);
					if (VAR_13)
						TORRENT_FAIL_BDECODE(VAR_13);

					/* COMMENT_26 */
					const ptrdiff_t VAR_17 = VAR_1 - VAR_0 - 1;
					if (VAR_15 > VAR_17)
						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
					if (VAR_15 < 0)
						TORRENT_FAIL_BDECODE(bdecode_errors::overflow);

					/* COMMENT_27 */
					++VAR_0;
					if (VAR_0 >= VAR_1) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

					/* COMMENT_28 */
					/* COMMENT_29 */
					if (VAR_0 - VAR_16 - 2 > detail::bdecode_token::max_header)
						TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);

					VAR_2.m_tokens.push_back(bdecode_token(VAR_16 - VAR_9
						, 1, bdecode_token::string, VAR_0 - VAR_16));
					VAR_0 += VAR_15;
					break;
				}
			}

			if (VAR_11 > 0
				&& VAR_2.m_tokens[VAR_8[VAR_11-1].token].type == bdecode_token::dict)
			{
				/* COMMENT_30 */
				VAR_8[VAR_11-1].state = ~VAR_8[VAR_11-1].state;
			}

			/* COMMENT_31 */
			if (VAR_7 == 0) break;
		}

done:

		/* COMMENT_32 */
		/* COMMENT_33 */
		/* COMMENT_34 */
		while (VAR_7 > 0) {
			TORRENT_ASSERT(VAR_3);
			--VAR_7;

			/* COMMENT_35 */
			/* COMMENT_36 */
			if (VAR_2.m_tokens[VAR_8[VAR_7].token].type == bdecode_token::dict
				&& VAR_8[VAR_7].state == 1)
			{
				/* COMMENT_37 */
				VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
					, 2, bdecode_token::dict));
				VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9
					, bdecode_token::end));
			}

			int VAR_14 = VAR_8[VAR_7].token;
			TORRENT_ASSERT(VAR_2.m_tokens.size() - VAR_14 <= bdecode_token::max_next_item);
			VAR_2.m_tokens[VAR_14].next_item = VAR_2.m_tokens.size() - VAR_14;
			VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9, 1, bdecode_token::end));
		}

		VAR_2.m_tokens.push_back(bdecode_token(VAR_0 - VAR_9, 0
			, bdecode_token::end));

		VAR_2.m_token_idx = 0;
		VAR_2.m_buffer = VAR_9;
		VAR_2.m_buffer_size = VAR_0 - VAR_9;
		VAR_2.m_root_tokens = &VAR_2.m_tokens[0];

		return VAR_3 ? -1 : 0;
	}",arvidn/libtorrent/ec30a5e9ec703afb8abefba757c6d401303b53db/bdecode.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -138,6 +138,7 @@
 					boost::int64_t len = t - '0';
 					char const* str_start = start;
 					++start;
+					if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
 					bdecode_errors::error_code_enum e = bdecode_errors::no_error;
 					start = parse_int(start, end, ':', len, e);
 					if (e)","{'deleted_lines': [], 'added_lines': ['\t\t\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);']}",True,The bdecode function in bdecode.cpp in libtorrent 1.1.3 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted file.,5.5,MEDIUM,1,valid,2017-06-24T04:19:31Z,1
CVE-2018-15863,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,xkbcommon/libxkbcommon,"xkbcomp: Don't crash on no-op modmask expressions

If we have an expression of the form 'l1' in an interp section, we
unconditionally try to dereference its args, even if it has none.

Signed-off-by: Daniel Stone <daniels@collabora.com>",96df3106d49438e442510c59acad306e94f3db4d,https://github.com/xkbcommon/libxkbcommon/commit/96df3106d49438e442510c59acad306e94f3db4d,src/xkbcomp/compat.c,ResolveStateAndPredicate,"static bool
ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
xkb_mod_mask_t *mods_rtrn, CompatInfo *info)
{
if (expr == NULL) {
*pred_rtrn = MATCH_ANY_OR_NONE;
*mods_rtrn = MOD_REAL_MASK_ALL;
return true;
}
*pred_rtrn = MATCH_EXACTLY;
if (expr->expr.op == EXPR_ACTION_DECL) {
const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {
log_err(info->ctx,
""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
return false;
}
expr = expr->action.args;
}
else if (expr->expr.op == EXPR_IDENT) {
const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);
if (pred_txt && istreq(pred_txt, ""any"")) {
*pred_rtrn = MATCH_ANY;
*mods_rtrn = MOD_REAL_MASK_ALL;
return true;
}
}
return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,
mods_rtrn);
}","static bool
ResolveStateAndPredicate(ExprDef *VAR_0, enum xkb_match_operation *VAR_1,
xkb_mod_mask_t *VAR_2, CompatInfo *VAR_3)
{
if (VAR_0 == NULL) {
*VAR_1 = VAR_4;
*VAR_2 = VAR_5;
return true;
}
*VAR_1 = VAR_6;
if (VAR_0->expr.op == VAR_7) {
const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->action.name);
if (!LookupString(VAR_9, VAR_8, VAR_1)) {
log_err(VAR_3->ctx,
""Illegal modifier predicate \""%s\""; Ignored\n"", VAR_8);
return false;
}
VAR_0 = VAR_0->action.args;
}
else if (VAR_0->expr.op == VAR_10) {
const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->ident.ident);
if (VAR_8 && istreq(VAR_8, ""any"")) {
*VAR_1 = VAR_11;
*VAR_2 = VAR_5;
return true;
}
}
return ExprResolveModMask(VAR_3->ctx, VAR_0, VAR_12, &VAR_3->mods,
VAR_2);
}",xkbcommon/libxkbcommon/96df3106d49438e442510c59acad306e94f3db4d/compat.c/vul/before/0.json,"static bool
ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)
{
    if (expr == NULL) {
        *pred_rtrn = MATCH_ANY_OR_NONE;
        *mods_rtrn = MOD_REAL_MASK_ALL;
        return true;
    }

    *pred_rtrn = MATCH_EXACTLY;
    if (expr->expr.op == EXPR_ACTION_DECL) {
        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||
            !expr->action.args) {
            log_err(info->ctx,
                    ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
            return false;
        }
        expr = expr->action.args;
    }
    else if (expr->expr.op == EXPR_IDENT) {
        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);
        if (pred_txt && istreq(pred_txt, ""any"")) {
            *pred_rtrn = MATCH_ANY;
            *mods_rtrn = MOD_REAL_MASK_ALL;
            return true;
        }
    }

    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,
                              mods_rtrn);
}","static bool
ResolveStateAndPredicate(ExprDef *VAR_0, enum xkb_match_operation *VAR_1,
                         xkb_mod_mask_t *VAR_2, CompatInfo *VAR_3)
{
    if (VAR_0 == NULL) {
        *VAR_1 = VAR_4;
        *VAR_2 = VAR_5;
        return true;
    }

    *VAR_1 = VAR_6;
    if (VAR_0->expr.op == VAR_7) {
        const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->action.name);
        if (!LookupString(VAR_9, VAR_8, VAR_1) ||
            !VAR_0->action.args) {
            log_err(VAR_3->ctx,
                    ""Illegal modifier predicate \""%s\""; Ignored\n"", VAR_8);
            return false;
        }
        VAR_0 = VAR_0->action.args;
    }
    else if (VAR_0->expr.op == VAR_10) {
        const char *VAR_8 = xkb_atom_text(VAR_3->ctx, VAR_0->ident.ident);
        if (VAR_8 && istreq(VAR_8, ""any"")) {
            *VAR_1 = VAR_11;
            *VAR_2 = VAR_5;
            return true;
        }
    }

    return ExprResolveModMask(VAR_3->ctx, VAR_0, VAR_12, &VAR_3->mods,
                              VAR_2);
}",xkbcommon/libxkbcommon/96df3106d49438e442510c59acad306e94f3db4d/compat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,8 @@
     *pred_rtrn = MATCH_EXACTLY;
     if (expr->expr.op == EXPR_ACTION_DECL) {
         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
-        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {
+        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||
+            !expr->action.args) {
             log_err(info->ctx,
                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
             return false;","{'deleted_lines': ['        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {'], 'added_lines': ['        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||', '            !expr->action.args) {']}",True,Unchecked NULL pointer usage in ResolveStateAndPredicate in xkbcomp/compat.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with a no-op modmask expression.,5.5,MEDIUM,1,valid,2017-06-26T16:12:29Z,1
CVE-2018-15862,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,xkbcommon/libxkbcommon,"xkbcomp: Don't explode on invalid virtual modifiers

testcase: 'virtualModifiers=LevelThreC'

Signed-off-by: Daniel Stone <daniels@collabora.com>",4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371,https://github.com/xkbcommon/libxkbcommon/commit/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371,src/xkbcomp/expr.c,LookupModMask,"static bool
LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
enum expr_value_type type, xkb_mod_mask_t *val_rtrn)
{
const char *str;
xkb_mod_index_t ndx;
const LookupModMaskPriv *arg = priv;
const struct xkb_mod_set *mods = arg->mods;
enum mod_type mod_type = arg->mod_type;
if (type != EXPR_TYPE_INT)
return false;
str = xkb_atom_text(ctx, field);
if (istreq(str, ""all"")) {
*val_rtrn  = MOD_REAL_MASK_ALL;
return true;
}
if (istreq(str, ""none"")) {
*val_rtrn = 0;
return true;
}
ndx = XkbModNameToIndex(mods, field, mod_type);
if (ndx == XKB_MOD_INVALID)
return false;
*val_rtrn = (1u << ndx);
return true;
}","static bool
LookupModMask(struct xkb_context *VAR_0, const void *VAR_1, xkb_atom_t VAR_2,
enum expr_value_type VAR_3, xkb_mod_mask_t *VAR_4)
{
const char *VAR_5;
xkb_mod_index_t VAR_6;
const LookupModMaskPriv *VAR_7 = VAR_1;
const struct xkb_mod_set *VAR_8 = VAR_7->mods;
enum mod_type mod_type = VAR_7->mod_type;
if (VAR_3 != VAR_9)
return false;
VAR_5 = xkb_atom_text(VAR_0, VAR_2);
if (istreq(VAR_5, ""all"")) {
*VAR_4  = VAR_10;
return true;
}
if (istreq(VAR_5, ""none"")) {
*VAR_4 = 0;
return true;
}
VAR_6 = XkbModNameToIndex(VAR_8, VAR_2, mod_type);
if (VAR_6 == VAR_11)
return false;
*VAR_4 = (1u << VAR_6);
return true;
}",xkbcommon/libxkbcommon/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371/expr.c/vul/before/0.json,"static bool
LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)
{
    const char *str;
    xkb_mod_index_t ndx;
    const LookupModMaskPriv *arg = priv;
    const struct xkb_mod_set *mods = arg->mods;
    enum mod_type mod_type = arg->mod_type;

    if (type != EXPR_TYPE_INT)
        return false;

    str = xkb_atom_text(ctx, field);
    if (!str)
        return false;

    if (istreq(str, ""all"")) {
        *val_rtrn  = MOD_REAL_MASK_ALL;
        return true;
    }

    if (istreq(str, ""none"")) {
        *val_rtrn = 0;
        return true;
    }

    ndx = XkbModNameToIndex(mods, field, mod_type);
    if (ndx == XKB_MOD_INVALID)
        return false;

    *val_rtrn = (1u << ndx);
    return true;
}","static bool
LookupModMask(struct xkb_context *VAR_0, const void *VAR_1, xkb_atom_t VAR_2,
              enum expr_value_type VAR_3, xkb_mod_mask_t *VAR_4)
{
    const char *VAR_5;
    xkb_mod_index_t VAR_6;
    const LookupModMaskPriv *VAR_7 = VAR_1;
    const struct xkb_mod_set *VAR_8 = VAR_7->mods;
    enum mod_type mod_type = VAR_7->mod_type;

    if (VAR_3 != VAR_9)
        return false;

    VAR_5 = xkb_atom_text(VAR_0, VAR_2);
    if (!VAR_5)
        return false;

    if (istreq(VAR_5, ""all"")) {
        *VAR_4  = VAR_10;
        return true;
    }

    if (istreq(VAR_5, ""none"")) {
        *VAR_4 = 0;
        return true;
    }

    VAR_6 = XkbModNameToIndex(VAR_8, VAR_2, mod_type);
    if (VAR_6 == VAR_11)
        return false;

    *VAR_4 = (1u << VAR_6);
    return true;
}",xkbcommon/libxkbcommon/4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371/expr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,8 @@
         return false;
 
     str = xkb_atom_text(ctx, field);
+    if (!str)
+        return false;
 
     if (istreq(str, ""all"")) {
         *val_rtrn  = MOD_REAL_MASK_ALL;","{'deleted_lines': [], 'added_lines': ['    if (!str)', '        return false;']}",True,Unchecked NULL pointer usage in LookupModMask in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with invalid virtual modifiers.,5.5,MEDIUM,1,valid,2017-06-26T16:18:16Z,1
CVE-2017-11328,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix heap overflow (reported by Jurriaan Bremer)

When setting a new array item with yr_object_array_set_item() the array size is doubled if the index for the new item is larger than the already allocated ones. No further checks were made to ensure that the index fits into the array after doubling its capacity. If the array capacity was for example 64, and a new object is assigned to an index larger than 128 the overflow occurs. As yr_object_array_set_item() is usually invoked with indexes that increase monotonically by one, this bug never triggered before. But the new ""dotnet"" module has the potential to allow the exploitation of this bug by scanning a specially crafted .NET binary.",4a342f01e5439b9bb901aff1c6c23c536baeeb3f,https://github.com/VirusTotal/yara/commit/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,libyara/object.c,yr_object_array_set_item,"int yr_object_array_set_item(
YR_OBJECT* object,
YR_OBJECT* item,
int index)
{
YR_OBJECT_ARRAY* array;
int i;
int count;
assert(index >= 0);
assert(object->type == OBJECT_TYPE_ARRAY);
array = object_as_array(object);
if (array->items == NULL)
{
count = yr_max(64, (index + 1) * 2);
array->items = (YR_ARRAY_ITEMS*) yr_malloc(
sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
if (array->items == NULL)
return ERROR_INSUFFICIENT_MEMORY;
memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));
array->items->count = count;
}
else if (index >= array->items->count)
{
count = array->items->count * 2;
array->items = (YR_ARRAY_ITEMS*) yr_realloc(
array->items,
sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
if (array->items == NULL)
return ERROR_INSUFFICIENT_MEMORY;
for (i = array->items->count; i < count; i++)
array->items->objects[i] = NULL;
array->items->count = count;
}
item->parent = object;
array->items->objects[index] = item;
return ERROR_SUCCESS;
}","int yr_object_array_set_item(
YR_OBJECT* VAR_0,
YR_OBJECT* VAR_1,
int VAR_2)
{
YR_OBJECT_ARRAY* VAR_3;
int VAR_4;
int VAR_5;
assert(VAR_2 >= 0);
assert(VAR_0->type == VAR_6);
VAR_3 = object_as_array(VAR_0);
if (VAR_3->items == NULL)
{
VAR_5 = yr_max(64, (VAR_2 + 1) * 2);
VAR_3->items = (YR_ARRAY_ITEMS*) yr_malloc(
sizeof(YR_ARRAY_ITEMS) + VAR_5 * sizeof(YR_OBJECT*));
if (VAR_3->items == NULL)
return VAR_7;
memset(VAR_3->items->objects, 0, VAR_5 * sizeof(YR_OBJECT*));
VAR_3->items->count = VAR_5;
}
else if (VAR_2 >= VAR_3->items->count)
{
VAR_5 = VAR_3->items->count * 2;
VAR_3->items = (YR_ARRAY_ITEMS*) yr_realloc(
VAR_3->items,
sizeof(YR_ARRAY_ITEMS) + VAR_5 * sizeof(YR_OBJECT*));
if (VAR_3->items == NULL)
return VAR_7;
for (VAR_4 = VAR_3->items->count; VAR_4 < VAR_5; VAR_4++)
VAR_3->items->objects[VAR_4] = NULL;
VAR_3->items->count = VAR_5;
}
VAR_1->parent = VAR_0;
VAR_3->items->objects[VAR_2] = VAR_1;
return VAR_8;
}",VirusTotal/yara/4a342f01e5439b9bb901aff1c6c23c536baeeb3f/object.c/vul/before/0.json,"int yr_object_array_set_item(
    YR_OBJECT* object,
    YR_OBJECT* item,
    int index)
{
  YR_OBJECT_ARRAY* array;

  int i;
  int count;

  assert(index >= 0);
  assert(object->type == OBJECT_TYPE_ARRAY);

  array = object_as_array(object);

  if (array->items == NULL)
  {
    count = 64;

    while (count <= index)
      count *= 2;

    array->items = (YR_ARRAY_ITEMS*) yr_malloc(
        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));

    if (array->items == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));

    array->items->count = count;
  }
  else if (index >= array->items->count)
  {
    count = array->items->count * 2;

    while (count <= index)
      count *= 2;

    array->items = (YR_ARRAY_ITEMS*) yr_realloc(
        array->items,
        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));

    if (array->items == NULL)
      return ERROR_INSUFFICIENT_MEMORY;

    for (i = array->items->count; i < count; i++)
      array->items->objects[i] = NULL;

    array->items->count = count;
  }

  item->parent = object;
  array->items->objects[index] = item;

  return ERROR_SUCCESS;
}","int yr_object_array_set_item(
    YR_OBJECT* VAR_0,
    YR_OBJECT* VAR_1,
    int VAR_2)
{
  YR_OBJECT_ARRAY* VAR_3;

  int VAR_4;
  int VAR_5;

  assert(VAR_2 >= 0);
  assert(VAR_0->type == VAR_6);

  VAR_3 = object_as_array(VAR_0);

  if (VAR_3->items == NULL)
  {
    VAR_5 = 64;

    while (VAR_5 <= VAR_2)
      VAR_5 *= 2;

    VAR_3->items = (YR_ARRAY_ITEMS*) yr_malloc(
        sizeof(YR_ARRAY_ITEMS) + VAR_5 * sizeof(YR_OBJECT*));

    if (VAR_3->items == NULL)
      return VAR_7;

    memset(VAR_3->items->objects, 0, VAR_5 * sizeof(YR_OBJECT*));

    VAR_3->items->count = VAR_5;
  }
  else if (VAR_2 >= VAR_3->items->count)
  {
    VAR_5 = VAR_3->items->count * 2;

    while (VAR_5 <= VAR_2)
      VAR_5 *= 2;

    VAR_3->items = (YR_ARRAY_ITEMS*) yr_realloc(
        VAR_3->items,
        sizeof(YR_ARRAY_ITEMS) + VAR_5 * sizeof(YR_OBJECT*));

    if (VAR_3->items == NULL)
      return VAR_7;

    for (VAR_4 = VAR_3->items->count; VAR_4 < VAR_5; VAR_4++)
      VAR_3->items->objects[VAR_4] = NULL;

    VAR_3->items->count = VAR_5;
  }

  VAR_1->parent = VAR_0;
  VAR_3->items->objects[VAR_2] = VAR_1;

  return VAR_8;
}",VirusTotal/yara/4a342f01e5439b9bb901aff1c6c23c536baeeb3f/object.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,7 +15,10 @@
 
   if (array->items == NULL)
   {
-    count = yr_max(64, (index + 1) * 2);
+    count = 64;
+
+    while (count <= index)
+      count *= 2;
 
     array->items = (YR_ARRAY_ITEMS*) yr_malloc(
         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
@@ -30,6 +33,10 @@
   else if (index >= array->items->count)
   {
     count = array->items->count * 2;
+
+    while (count <= index)
+      count *= 2;
+
     array->items = (YR_ARRAY_ITEMS*) yr_realloc(
         array->items,
         sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));","{'deleted_lines': ['    count = yr_max(64, (index + 1) * 2);'], 'added_lines': ['    count = 64;', '', '    while (count <= index)', '      count *= 2;', '', '    while (count <= index)', '      count *= 2;', '']}",True,Heap buffer overflow in the yr_object_array_set_item() function in object.c in YARA 3.x allows a denial-of-service attack by scanning a crafted .NET file.,5.5,MEDIUM,1,valid,2017-07-05T08:01:03Z,1
CVE-2017-12435,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,ImageMagick,.https://github.com/ImageMagick/ImageMagick/issues/543,44cb8dfd4cbe6fc475c863a5946cff64e34c2088,https://github.com/ImageMagick/ImageMagick/commit/44cb8dfd4cbe6fc475c863a5946cff64e34c2088,coders/sun.c,RegisterSUNImage,"ModuleExport size_t RegisterSUNImage(void)
{
MagickInfo
*entry;
entry=SetMagickInfo(""RAS"");
entry->decoder=(DecodeImageHandler *) ReadSUNImage;
entry->encoder=(EncodeImageHandler *) WriteSUNImage;
entry->magick=(IsImageFormatHandler *) IsSUN;
entry->description=ConstantString(""SUN Rasterfile"");
entry->module=ConstantString(""SUN"");
(void) RegisterMagickInfo(entry);
entry=SetMagickInfo(""SUN"");
entry->decoder=(DecodeImageHandler *) ReadSUNImage;
entry->encoder=(EncodeImageHandler *) WriteSUNImage;
entry->description=ConstantString(""SUN Rasterfile"");
entry->module=ConstantString(""SUN"");
(void) RegisterMagickInfo(entry);
return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterSUNImage(void)
{
MagickInfo
*VAR_1;
VAR_1=SetMagickInfo(""RAS"");
VAR_1->decoder=(DecodeImageHandler *) VAR_2;
VAR_1->encoder=(EncodeImageHandler *) VAR_3;
VAR_1->magick=(IsImageFormatHandler *) VAR_4;
VAR_1->description=ConstantString(""SUN Rasterfile"");
VAR_1->module=ConstantString(""SUN"");
(void) RegisterMagickInfo(VAR_1);
VAR_1=SetMagickInfo(""SUN"");
VAR_1->decoder=(DecodeImageHandler *) VAR_2;
VAR_1->encoder=(EncodeImageHandler *) VAR_3;
VAR_1->description=ConstantString(""SUN Rasterfile"");
VAR_1->module=ConstantString(""SUN"");
(void) RegisterMagickInfo(VAR_1);
return(VAR_5);
}",,"ModuleExport size_t RegisterSUNImage(void)
{
  MagickInfo
    *entry;

  entry=SetMagickInfo(""RAS"");
  entry->decoder=(DecodeImageHandler *) ReadSUNImage;
  entry->encoder=(EncodeImageHandler *) WriteSUNImage;
  entry->magick=(IsImageFormatHandler *) IsSUN;
  entry->description=ConstantString(""SUN Rasterfile"");
  entry->seekable_stream=MagickTrue;
  entry->module=ConstantString(""SUN"");
  (void) RegisterMagickInfo(entry);
  entry=SetMagickInfo(""SUN"");
  entry->decoder=(DecodeImageHandler *) ReadSUNImage;
  entry->encoder=(EncodeImageHandler *) WriteSUNImage;
  entry->description=ConstantString(""SUN Rasterfile"");
  entry->seekable_stream=MagickTrue;
  entry->module=ConstantString(""SUN"");
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterSUNImage(void)
{
  MagickInfo
    *VAR_1;

  VAR_1=SetMagickInfo(""RAS"");
  VAR_1->decoder=(DecodeImageHandler *) VAR_2;
  VAR_1->encoder=(EncodeImageHandler *) VAR_3;
  VAR_1->magick=(IsImageFormatHandler *) VAR_4;
  VAR_1->description=ConstantString(""SUN Rasterfile"");
  VAR_1->seekable_stream=VAR_5;
  VAR_1->module=ConstantString(""SUN"");
  (void) RegisterMagickInfo(VAR_1);
  VAR_1=SetMagickInfo(""SUN"");
  VAR_1->decoder=(DecodeImageHandler *) VAR_2;
  VAR_1->encoder=(EncodeImageHandler *) VAR_3;
  VAR_1->description=ConstantString(""SUN Rasterfile"");
  VAR_1->seekable_stream=VAR_5;
  VAR_1->module=ConstantString(""SUN"");
  (void) RegisterMagickInfo(VAR_1);
  return(VAR_6);
}",,"--- func_before
+++ func_after
@@ -8,12 +8,14 @@
   entry->encoder=(EncodeImageHandler *) WriteSUNImage;
   entry->magick=(IsImageFormatHandler *) IsSUN;
   entry->description=ConstantString(""SUN Rasterfile"");
+  entry->seekable_stream=MagickTrue;
   entry->module=ConstantString(""SUN"");
   (void) RegisterMagickInfo(entry);
   entry=SetMagickInfo(""SUN"");
   entry->decoder=(DecodeImageHandler *) ReadSUNImage;
   entry->encoder=(EncodeImageHandler *) WriteSUNImage;
   entry->description=ConstantString(""SUN Rasterfile"");
+  entry->seekable_stream=MagickTrue;
   entry->module=ConstantString(""SUN"");
   (void) RegisterMagickInfo(entry);
   return(MagickImageCoderSignature);","{'deleted_lines': [], 'added_lines': ['  entry->seekable_stream=MagickTrue;', '  entry->seekable_stream=MagickTrue;']}",True,"In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",7.5,HIGH,2,valid,2017-07-05T20:41:58Z,1
CVE-2017-12435,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,ImageMagick,.https://github.com/ImageMagick/ImageMagick/issues/543,44cb8dfd4cbe6fc475c863a5946cff64e34c2088,https://github.com/ImageMagick/ImageMagick/commit/44cb8dfd4cbe6fc475c863a5946cff64e34c2088,coders/sun.c,ReadSUNImage,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*image;
int
bit;
MagickBooleanType
status;
MagickSizeType
number_pixels;
register IndexPacket
*indexes;
register PixelPacket
*q;
register ssize_t
i,
x;
register unsigned char
*p;
size_t
bytes_per_line,
extent,
height,
pixels_length,
quantum;
ssize_t
count,
y;
SUNInfo
sun_info;
unsigned char
*sun_data,
*sun_pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
sun_info.magic=ReadBlobMSBLong(image);
do
{
if (sun_info.magic != 0x59a66a95)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
sun_info.width=ReadBlobMSBLong(image);
sun_info.height=ReadBlobMSBLong(image);
sun_info.depth=ReadBlobMSBLong(image);
sun_info.length=ReadBlobMSBLong(image);
sun_info.type=ReadBlobMSBLong(image);
sun_info.maptype=ReadBlobMSBLong(image);
sun_info.maplength=ReadBlobMSBLong(image);
extent=sun_info.height*sun_info.width;
if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
(sun_info.type != RT_FORMAT_RGB))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.depth != 1) && (sun_info.depth != 8) &&
(sun_info.depth != 24) && (sun_info.depth != 32))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
(sun_info.maptype != RMT_RAW))
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
image->columns=sun_info.width;
image->rows=sun_info.height;
image->depth=sun_info.depth <= 8 ? sun_info.depth :
MAGICKCORE_QUANTUM_DEPTH;
if (sun_info.depth < 24)
{
size_t
one;
image->colors=sun_info.maplength;
one=1;
if (sun_info.maptype == RMT_NONE)
image->colors=one << sun_info.depth;
if (sun_info.maptype == RMT_EQUAL_RGB)
image->colors=sun_info.maplength/3;
if (AcquireImageColormap(image,image->colors) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
switch (sun_info.maptype)
{
case RMT_NONE:
break;
case RMT_EQUAL_RGB:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
{
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
{
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
{
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
case RMT_RAW:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,sun_info.maplength,sun_colormap);
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
if (count != (ssize_t) sun_info.maplength)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
break;
}
default:
break;
}
image->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;
image->columns=sun_info.width;
image->rows=sun_info.height;
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
if (sun_info.length == 0)
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
number_pixels=(MagickSizeType) (image->columns*image->rows);
if ((sun_info.type != RT_ENCODED) &&
((number_pixels*sun_info.depth) > (8UL*sun_info.length)))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
bytes_per_line=sun_info.width*sun_info.depth;
sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,
sizeof(*sun_data));
if (sun_data == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
if (count != (ssize_t) sun_info.length)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
}
height=sun_info.height;
if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
((bytes_per_line/sun_info.depth) != sun_info.width))
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
quantum=sun_info.depth == 1 ? 15 : 7;
bytes_per_line+=quantum;
bytes_per_line<<=1;
if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
bytes_per_line>>=4;
if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
pixels_length=height*bytes_per_line;
sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,
sizeof(*sun_pixels));
if (sun_pixels == (unsigned char *) NULL)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));
if (sun_info.type == RT_ENCODED)
{
status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);
if (status == MagickFalse)
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
}
else
{
if (sun_info.length > pixels_length)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
(void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);
}
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
p=sun_pixels;
if (sun_info.depth == 1)
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=7; bit >= 0; bit--)
SetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
SetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);
p++;
}
if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
else
if (image->storage_class == PseudoClass)
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelIndex(indexes+x,ConstrainColormapIndex(image,*p));
p++;
}
if ((image->columns % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
{
size_t
bytes_per_pixel;
bytes_per_pixel=3;
if (image->matte != MagickFalse)
bytes_per_pixel++;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (image->matte != MagickFalse)
SetPixelAlpha(q,ScaleCharToQuantum(*p++));
if (sun_info.type == RT_STANDARD)
{
SetPixelBlue(q,ScaleCharToQuantum(*p++));
SetPixelGreen(q,ScaleCharToQuantum(*p++));
SetPixelRed(q,ScaleCharToQuantum(*p++));
}
else
{
SetPixelRed(q,ScaleCharToQuantum(*p++));
SetPixelGreen(q,ScaleCharToQuantum(*p++));
SetPixelBlue(q,ScaleCharToQuantum(*p++));
}
if (image->colors != 0)
{
SetPixelRed(q,image->colormap[(ssize_t)
GetPixelRed(q)].red);
SetPixelGreen(q,image->colormap[(ssize_t)
GetPixelGreen(q)].green);
SetPixelBlue(q,image->colormap[(ssize_t)
GetPixelBlue(q)].blue);
}
q++;
}
if (((bytes_per_pixel*image->columns) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
if (image->storage_class == PseudoClass)
(void) SyncImage(image);
sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
sun_info.magic=ReadBlobMSBLong(image);
if (sun_info.magic == 0x59a66a95)
{
AcquireNextImage(image_info,image);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while (sun_info.magic == 0x59a66a95);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*VAR_8;
int
VAR_9;
MagickBooleanType
VAR_10;
MagickSizeType
VAR_11;
register IndexPacket
*VAR_12;
register PixelPacket
*VAR_13;
register ssize_t
VAR_14,
VAR_15;
register unsigned char
*VAR_16;
size_t
VAR_17,
VAR_18,
VAR_19,
VAR_20,
VAR_21;
ssize_t
VAR_22,
VAR_23;
SUNInfo
VAR_24;
unsigned char
*VAR_25,
*VAR_26;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_27);
if (VAR_0->debug != VAR_28)
(void) LogMagickEvent(VAR_29,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_27);
VAR_8=AcquireImage(VAR_0);
VAR_10=OpenBlob(VAR_0,VAR_8,VAR_30,VAR_1);
if (VAR_10 == VAR_28)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
(void) ResetMagickMemory(&VAR_24,0,sizeof(VAR_24));
VAR_24.magic=ReadBlobMSBLong(VAR_8);
do
{
if (VAR_24.magic != 0x59a66a95)
ThrowReaderException(VAR_31,""ImproperImageHeader"");
VAR_24.width=ReadBlobMSBLong(VAR_8);
VAR_24.height=ReadBlobMSBLong(VAR_8);
VAR_24.depth=ReadBlobMSBLong(VAR_8);
VAR_24.length=ReadBlobMSBLong(VAR_8);
VAR_24.type=ReadBlobMSBLong(VAR_8);
VAR_24.maptype=ReadBlobMSBLong(VAR_8);
VAR_24.maplength=ReadBlobMSBLong(VAR_8);
VAR_18=VAR_24.height*VAR_24.width;
if ((VAR_24.height != 0) && (VAR_24.width != VAR_18/VAR_24.height))
ThrowReaderException(VAR_31,""ImproperImageHeader"");
if ((VAR_24.type != VAR_5) && (VAR_24.type != VAR_6) &&
(VAR_24.type != VAR_7))
ThrowReaderException(VAR_31,""ImproperImageHeader"");
if ((VAR_24.maptype == VAR_3) && (VAR_24.maplength != 0))
ThrowReaderException(VAR_31,""ImproperImageHeader"");
if ((VAR_24.depth != 1) && (VAR_24.depth != 8) &&
(VAR_24.depth != 24) && (VAR_24.depth != 32))
ThrowReaderException(VAR_31,""ImproperImageHeader"");
if ((VAR_24.maptype != VAR_3) && (VAR_24.maptype != VAR_2) &&
(VAR_24.maptype != VAR_4))
ThrowReaderException(VAR_32,""ColormapTypeNotSupported"");
VAR_8->columns=VAR_24.width;
VAR_8->rows=VAR_24.height;
VAR_8->depth=VAR_24.depth <= 8 ? VAR_24.depth :
VAR_33;
if (VAR_24.depth < 24)
{
size_t
VAR_34;
VAR_8->colors=VAR_24.maplength;
VAR_34=1;
if (VAR_24.maptype == VAR_3)
VAR_8->colors=VAR_34 << VAR_24.depth;
if (VAR_24.maptype == VAR_2)
VAR_8->colors=VAR_24.maplength/3;
if (AcquireImageColormap(VAR_8,VAR_8->colors) == VAR_28)
ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
}
switch (VAR_24.maptype)
{
case VAR_3:
break;
case VAR_2:
{
unsigned char
*VAR_36;
VAR_36=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
sizeof(*VAR_36));
if (VAR_36 == (unsigned char *) NULL)
ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
VAR_22=ReadBlob(VAR_8,VAR_8->colors,VAR_36);
if (VAR_22 != (ssize_t) VAR_8->colors)
{
VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
}
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->colors; VAR_14++)
VAR_8->colormap[VAR_14].red=ScaleCharToQuantum(VAR_36[VAR_14]);
VAR_22=ReadBlob(VAR_8,VAR_8->colors,VAR_36);
if (VAR_22 != (ssize_t) VAR_8->colors)
{
VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
}
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->colors; VAR_14++)
VAR_8->colormap[VAR_14].green=ScaleCharToQuantum(VAR_36[VAR_14]);
VAR_22=ReadBlob(VAR_8,VAR_8->colors,VAR_36);
if (VAR_22 != (ssize_t) VAR_8->colors)
{
VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
}
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->colors; VAR_14++)
VAR_8->colormap[VAR_14].blue=ScaleCharToQuantum(VAR_36[VAR_14]);
VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
break;
}
case VAR_4:
{
unsigned char
*VAR_36;
VAR_36=(unsigned char *) AcquireQuantumMemory(VAR_24.maplength,
sizeof(*VAR_36));
if (VAR_36 == (unsigned char *) NULL)
ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
VAR_22=ReadBlob(VAR_8,VAR_24.maplength,VAR_36);
VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
if (VAR_22 != (ssize_t) VAR_24.maplength)
ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
break;
}
default:
break;
}
VAR_8->matte=VAR_24.depth == 32 ? VAR_37 : VAR_28;
VAR_8->columns=VAR_24.width;
VAR_8->rows=VAR_24.height;
if (VAR_0->ping != VAR_28)
{
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}
VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows);
if (VAR_10 == VAR_28)
{
InheritException(VAR_1,&VAR_8->exception);
return(DestroyImageList(VAR_8));
}
if (VAR_24.length == 0)
ThrowReaderException(VAR_35,""ImproperImageHeader"");
VAR_11=(MagickSizeType) (VAR_8->columns*VAR_8->rows);
if ((VAR_24.type != VAR_6) &&
((VAR_11*VAR_24.depth) > (8UL*VAR_24.length)))
ThrowReaderException(VAR_31,""ImproperImageHeader"");
if (HeapOverflowSanityCheck(VAR_24.width,VAR_24.depth) != VAR_28)
ThrowReaderException(VAR_31,""ImproperImageHeader"");
VAR_17=VAR_24.width*VAR_24.depth;
VAR_25=(unsigned char *) AcquireQuantumMemory(VAR_24.length,
sizeof(*VAR_25));
if (VAR_25 == (unsigned char *) NULL)
ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
VAR_22=(ssize_t) ReadBlob(VAR_8,VAR_24.length,VAR_25);
if (VAR_22 != (ssize_t) VAR_24.length)
{
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
ThrowReaderException(VAR_31,""UnableToReadImageData"");
}
VAR_19=VAR_24.height;
if ((VAR_19 == 0) || (VAR_24.width == 0) || (VAR_24.depth == 0) ||
((VAR_17/VAR_24.depth) != VAR_24.width))
{
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
ThrowReaderException(VAR_35,""ImproperImageHeader"");
}
VAR_21=VAR_24.depth == 1 ? 15 : 7;
VAR_17+=VAR_21;
VAR_17<<=1;
if ((VAR_17 >> 1) != (VAR_24.width*VAR_24.depth+VAR_21))
{
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
ThrowReaderException(VAR_35,""ImproperImageHeader"");
}
VAR_17>>=4;
if (HeapOverflowSanityCheck(VAR_19,VAR_17) != VAR_28)
{
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
ThrowReaderException(VAR_35,""ImproperImageHeader"");
}
VAR_20=VAR_19*VAR_17;
VAR_26=(unsigned char *) AcquireQuantumMemory(VAR_20+VAR_8->rows,
sizeof(*VAR_26));
if (VAR_26 == (unsigned char *) NULL)
{
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
}
ResetMagickMemory(VAR_26,0,VAR_20*sizeof(*VAR_26));
if (VAR_24.type == VAR_6)
{
VAR_10=DecodeImage(VAR_25,VAR_24.length,VAR_26,VAR_20);
if (VAR_10 == VAR_28)
ThrowReaderException(VAR_31,""UnableToReadImageData"");
}
else
{
if (VAR_24.length > VAR_20)
{
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
ThrowReaderException(VAR_35,""ImproperImageHeader"");
}
(void) CopyMagickMemory(VAR_26,VAR_25,VAR_24.length);
}
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
VAR_16=VAR_26;
if (VAR_24.depth == 1)
for (VAR_23=0; VAR_23 < (ssize_t) VAR_8->rows; VAR_23++)
{
VAR_13=QueueAuthenticPixels(VAR_8,0,VAR_23,VAR_8->columns,1,VAR_1);
if (VAR_13 == (PixelPacket *) NULL)
break;
VAR_12=GetAuthenticIndexQueue(VAR_8);
for (VAR_15=0; VAR_15 < ((ssize_t) VAR_8->columns-7); VAR_15+=8)
{
for (VAR_9=7; VAR_9 >= 0; VAR_9--)
SetPixelIndex(VAR_12+VAR_15+7-VAR_9,((*VAR_16) & (0x01 << VAR_9) ? 0x00 : 0x01));
VAR_16++;
}
if ((VAR_8->columns % 8) != 0)
{
for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
SetPixelIndex(VAR_12+VAR_15+7-VAR_9,(*VAR_16) & (0x01 << VAR_9) ? 0x00 : 0x01);
VAR_16++;
}
if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
VAR_16++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_28)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_23,
VAR_8->rows);
if (VAR_10 == VAR_28)
break;
}
}
else
if (VAR_8->storage_class == VAR_39)
{
for (VAR_23=0; VAR_23 < (ssize_t) VAR_8->rows; VAR_23++)
{
VAR_13=QueueAuthenticPixels(VAR_8,0,VAR_23,VAR_8->columns,1,VAR_1);
if (VAR_13 == (PixelPacket *) NULL)
break;
VAR_12=GetAuthenticIndexQueue(VAR_8);
for (VAR_15=0; VAR_15 < (ssize_t) VAR_8->columns; VAR_15++)
{
SetPixelIndex(VAR_12+VAR_15,ConstrainColormapIndex(VAR_8,*VAR_16));
VAR_16++;
}
if ((VAR_8->columns % 2) != 0)
VAR_16++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_28)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_23,
VAR_8->rows);
if (VAR_10 == VAR_28)
break;
}
}
}
else
{
size_t
VAR_40;
VAR_40=3;
if (VAR_8->matte != VAR_28)
VAR_40++;
for (VAR_23=0; VAR_23 < (ssize_t) VAR_8->rows; VAR_23++)
{
VAR_13=QueueAuthenticPixels(VAR_8,0,VAR_23,VAR_8->columns,1,VAR_1);
if (VAR_13 == (PixelPacket *) NULL)
break;
for (VAR_15=0; VAR_15 < (ssize_t) VAR_8->columns; VAR_15++)
{
if (VAR_8->matte != VAR_28)
SetPixelAlpha(VAR_13,ScaleCharToQuantum(*VAR_16++));
if (VAR_24.type == VAR_5)
{
SetPixelBlue(VAR_13,ScaleCharToQuantum(*VAR_16++));
SetPixelGreen(VAR_13,ScaleCharToQuantum(*VAR_16++));
SetPixelRed(VAR_13,ScaleCharToQuantum(*VAR_16++));
}
else
{
SetPixelRed(VAR_13,ScaleCharToQuantum(*VAR_16++));
SetPixelGreen(VAR_13,ScaleCharToQuantum(*VAR_16++));
SetPixelBlue(VAR_13,ScaleCharToQuantum(*VAR_16++));
}
if (VAR_8->colors != 0)
{
SetPixelRed(VAR_13,VAR_8->colormap[(ssize_t)
GetPixelRed(VAR_13)].red);
SetPixelGreen(VAR_13,VAR_8->colormap[(ssize_t)
GetPixelGreen(VAR_13)].green);
SetPixelBlue(VAR_13,VAR_8->colormap[(ssize_t)
GetPixelBlue(VAR_13)].blue);
}
VAR_13++;
}
if (((VAR_40*VAR_8->columns) % 2) != 0)
VAR_16++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_28)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_23,
VAR_8->rows);
if (VAR_10 == VAR_28)
break;
}
}
}
if (VAR_8->storage_class == VAR_39)
(void) SyncImage(VAR_8);
VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
if (EOFBlob(VAR_8) != VAR_28)
{
ThrowFileException(VAR_1,VAR_31,""UnexpectedEndOfFile"",
VAR_8->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_24.magic=ReadBlobMSBLong(VAR_8);
if (VAR_24.magic == 0x59a66a95)
{
AcquireNextImage(VAR_0,VAR_8);
if (GetNextImageInList(VAR_8) == (Image *) NULL)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
VAR_8=SyncNextImageInList(VAR_8);
VAR_10=SetImageProgress(VAR_8,VAR_41,TellBlob(VAR_8),
GetBlobSize(VAR_8));
if (VAR_10 == VAR_28)
break;
}
} while (VAR_24.magic == 0x59a66a95);
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}",ImageMagick/44cb8dfd4cbe6fc475c863a5946cff64e34c2088/sun.c/vul/before/1.json,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register IndexPacket
    *indexes;

  register PixelPacket
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bytes_per_line,
    extent,
    height,
    pixels_length,
    quantum;

  ssize_t
    count,
    y;

  SUNInfo
    sun_info;

  unsigned char
    *sun_data,
    *sun_pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read SUN raster header.
  */
  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
  sun_info.magic=ReadBlobMSBLong(image);
  do
  {
    /*
      Verify SUN identifier.
    */
    if (sun_info.magic != 0x59a66a95)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    sun_info.width=ReadBlobMSBLong(image);
    sun_info.height=ReadBlobMSBLong(image);
    sun_info.depth=ReadBlobMSBLong(image);
    sun_info.length=ReadBlobMSBLong(image);
    sun_info.type=ReadBlobMSBLong(image);
    sun_info.maptype=ReadBlobMSBLong(image);
    sun_info.maplength=ReadBlobMSBLong(image);
    extent=sun_info.height*sun_info.width;
    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
        (sun_info.type != RT_FORMAT_RGB))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&
        (sun_info.depth != 24) && (sun_info.depth != 32))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
        (sun_info.maptype != RMT_RAW))
      ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    image->depth=sun_info.depth <= 8 ? sun_info.depth :
      MAGICKCORE_QUANTUM_DEPTH;
    if (sun_info.depth < 24)
      {
        size_t
          one;

        if (sun_info.maplength > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        image->colors=sun_info.maplength;
        one=1;
        if (sun_info.maptype == RMT_NONE)
          image->colors=one << sun_info.depth;
        if (sun_info.maptype == RMT_EQUAL_RGB)
          image->colors=sun_info.maplength/3;
        if (AcquireImageColormap(image,image->colors) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    switch (sun_info.maptype)
    {
      case RMT_NONE:
        break;
      case RMT_EQUAL_RGB:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          {
            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
          }
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          {
            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
          }
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          {
            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
          }
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      case RMT_RAW:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,sun_info.maplength,sun_colormap);
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        if (count != (ssize_t) sun_info.maplength)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        break;
      }
      default:
        break;
    }
    image->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    if (image_info->ping != MagickFalse)
      {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    if (sun_info.length == 0)
      ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
    number_pixels=(MagickSizeType) (image->columns*image->rows);
    if ((sun_info.type != RT_ENCODED) &&
        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bytes_per_line=sun_info.width*sun_info.depth;
    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,
      sizeof(*sun_data));
    if (sun_data == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
    if (count != (ssize_t) sun_info.length)
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      }
    height=sun_info.height;
    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
        ((bytes_per_line/sun_info.depth) != sun_info.width))
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
      }
    quantum=sun_info.depth == 1 ? 15 : 7;
    bytes_per_line+=quantum;
    bytes_per_line<<=1;
    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
      }
    bytes_per_line>>=4;
    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
      }
    pixels_length=height*bytes_per_line;
    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,
      sizeof(*sun_pixels));
    if (sun_pixels == (unsigned char *) NULL)
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));
    if (sun_info.type == RT_ENCODED)
      {
        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);
        if (status == MagickFalse)
          ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      }
    else
      {
        if (sun_info.length > pixels_length)
          {
            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
            ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
          }
        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);
      }
    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
    /*
      Convert SUN raster image to pixel packets.
    */
    p=sun_pixels;
    if (sun_info.depth == 1)
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=7; bit >= 0; bit--)
            SetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));
          p++;
        }
        if ((image->columns % 8) != 0)
          {
            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
              SetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);
            p++;
          }
        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
          p++;
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    else
      if (image->storage_class == PseudoClass)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (PixelPacket *) NULL)
              break;
            indexes=GetAuthenticIndexQueue(image);
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelIndex(indexes+x,ConstrainColormapIndex(image,*p));
              p++;
            }
            if ((image->columns % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
      else
        {
          size_t
            bytes_per_pixel;

          bytes_per_pixel=3;
          if (image->matte != MagickFalse)
            bytes_per_pixel++;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (PixelPacket *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (image->matte != MagickFalse)
                SetPixelAlpha(q,ScaleCharToQuantum(*p++));
              if (sun_info.type == RT_STANDARD)
                {
                  SetPixelBlue(q,ScaleCharToQuantum(*p++));
                  SetPixelGreen(q,ScaleCharToQuantum(*p++));
                  SetPixelRed(q,ScaleCharToQuantum(*p++));
                }
              else
                {
                  SetPixelRed(q,ScaleCharToQuantum(*p++));
                  SetPixelGreen(q,ScaleCharToQuantum(*p++));
                  SetPixelBlue(q,ScaleCharToQuantum(*p++));
                }
              if (image->colors != 0)
                {
                  SetPixelRed(q,image->colormap[(ssize_t)
                    GetPixelRed(q)].red);
                  SetPixelGreen(q,image->colormap[(ssize_t)
                    GetPixelGreen(q)].green);
                  SetPixelBlue(q,image->colormap[(ssize_t)
                    GetPixelBlue(q)].blue);
                }
              q++;
            }
            if (((bytes_per_pixel*image->columns) % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image);
    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    sun_info.magic=ReadBlobMSBLong(image);
    if (sun_info.magic == 0x59a66a95)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (sun_info.magic == 0x59a66a95);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *VAR_8;

  int
    VAR_9;

  MagickBooleanType
    VAR_10;

  MagickSizeType
    VAR_11;

  register IndexPacket
    *VAR_12;

  register PixelPacket
    *VAR_13;

  register ssize_t
    VAR_14,
    VAR_15;

  register unsigned char
    *VAR_16;

  size_t
    VAR_17,
    VAR_18,
    VAR_19,
    VAR_20,
    VAR_21;

  ssize_t
    VAR_22,
    VAR_23;

  SUNInfo
    VAR_24;

  unsigned char
    *VAR_25,
    *VAR_26;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_27);
  if (VAR_0->debug != VAR_28)
    (void) LogMagickEvent(VAR_29,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_27);
  VAR_8=AcquireImage(VAR_0);
  VAR_10=OpenBlob(VAR_0,VAR_8,VAR_30,VAR_1);
  if (VAR_10 == VAR_28)
    {
      VAR_8=DestroyImageList(VAR_8);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                           
    
  (void) ResetMagickMemory(&VAR_24,0,sizeof(VAR_24));
  VAR_24.magic=ReadBlobMSBLong(VAR_8);
  do
  {
    /* COMMENT_6 */
                            
      
    if (VAR_24.magic != 0x59a66a95)
      ThrowReaderException(VAR_31,""ImproperImageHeader"");
    VAR_24.width=ReadBlobMSBLong(VAR_8);
    VAR_24.height=ReadBlobMSBLong(VAR_8);
    VAR_24.depth=ReadBlobMSBLong(VAR_8);
    VAR_24.length=ReadBlobMSBLong(VAR_8);
    VAR_24.type=ReadBlobMSBLong(VAR_8);
    VAR_24.maptype=ReadBlobMSBLong(VAR_8);
    VAR_24.maplength=ReadBlobMSBLong(VAR_8);
    VAR_18=VAR_24.height*VAR_24.width;
    if ((VAR_24.height != 0) && (VAR_24.width != VAR_18/VAR_24.height))
      ThrowReaderException(VAR_31,""ImproperImageHeader"");
    if ((VAR_24.type != VAR_5) && (VAR_24.type != VAR_6) &&
        (VAR_24.type != VAR_7))
      ThrowReaderException(VAR_31,""ImproperImageHeader"");
    if ((VAR_24.maptype == VAR_3) && (VAR_24.maplength != 0))
      ThrowReaderException(VAR_31,""ImproperImageHeader"");
    if ((VAR_24.depth != 1) && (VAR_24.depth != 8) &&
        (VAR_24.depth != 24) && (VAR_24.depth != 32))
      ThrowReaderException(VAR_31,""ImproperImageHeader"");
    if ((VAR_24.maptype != VAR_3) && (VAR_24.maptype != VAR_2) &&
        (VAR_24.maptype != VAR_4))
      ThrowReaderException(VAR_32,""ColormapTypeNotSupported"");
    VAR_8->columns=VAR_24.width;
    VAR_8->rows=VAR_24.height;
    VAR_8->depth=VAR_24.depth <= 8 ? VAR_24.depth :
      VAR_33;
    if (VAR_24.depth < 24)
      {
        size_t
          VAR_34;

        if (VAR_24.maplength > GetBlobSize(VAR_8))
          ThrowReaderException(VAR_31,""InsufficientImageDataInFile"");
        VAR_8->colors=VAR_24.maplength;
        VAR_34=1;
        if (VAR_24.maptype == VAR_3)
          VAR_8->colors=VAR_34 << VAR_24.depth;
        if (VAR_24.maptype == VAR_2)
          VAR_8->colors=VAR_24.maplength/3;
        if (AcquireImageColormap(VAR_8,VAR_8->colors) == VAR_28)
          ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
      }
    switch (VAR_24.maptype)
    {
      case VAR_3:
        break;
      case VAR_2:
      {
        unsigned char
          *VAR_36;

        /* COMMENT_9 */
                                   
          
        VAR_36=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
          sizeof(*VAR_36));
        if (VAR_36 == (unsigned char *) NULL)
          ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
        VAR_22=ReadBlob(VAR_8,VAR_8->colors,VAR_36);
        if (VAR_22 != (ssize_t) VAR_8->colors)
          {
            VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
            ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
          }
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->colors; VAR_14++)
          VAR_8->colormap[VAR_14].red=ScaleCharToQuantum(VAR_36[VAR_14]);
        VAR_22=ReadBlob(VAR_8,VAR_8->colors,VAR_36);
        if (VAR_22 != (ssize_t) VAR_8->colors)
          {
            VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
            ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
          }
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->colors; VAR_14++)
          VAR_8->colormap[VAR_14].green=ScaleCharToQuantum(VAR_36[VAR_14]);
        VAR_22=ReadBlob(VAR_8,VAR_8->colors,VAR_36);
        if (VAR_22 != (ssize_t) VAR_8->colors)
          {
            VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
            ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
          }
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->colors; VAR_14++)
          VAR_8->colormap[VAR_14].blue=ScaleCharToQuantum(VAR_36[VAR_14]);
        VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
        break;
      }
      case VAR_4:
      {
        unsigned char
          *VAR_36;

        /* COMMENT_12 */
                                   
          
        VAR_36=(unsigned char *) AcquireQuantumMemory(VAR_24.maplength,
          sizeof(*VAR_36));
        if (VAR_36 == (unsigned char *) NULL)
          ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
        VAR_22=ReadBlob(VAR_8,VAR_24.maplength,VAR_36);
        VAR_36=(unsigned char *) RelinquishMagickMemory(VAR_36);
        if (VAR_22 != (ssize_t) VAR_24.maplength)
          ThrowReaderException(VAR_31,""UnexpectedEndOfFile"");
        break;
      }
      default:
        break;
    }
    VAR_8->matte=VAR_24.depth == 32 ? VAR_37 : VAR_28;
    VAR_8->columns=VAR_24.width;
    VAR_8->rows=VAR_24.height;
    if (VAR_0->ping != VAR_28)
      {
        (void) CloseBlob(VAR_8);
        return(GetFirstImageInList(VAR_8));
      }
    VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows);
    if (VAR_10 == VAR_28)
      {
        InheritException(VAR_1,&VAR_8->exception);
        return(DestroyImageList(VAR_8));
      }
    if (VAR_24.length == 0)
      ThrowReaderException(VAR_35,""ImproperImageHeader"");
    VAR_11=(MagickSizeType) (VAR_8->columns*VAR_8->rows);
    if ((VAR_24.type != VAR_6) &&
        ((VAR_11*VAR_24.depth) > (8UL*VAR_24.length)))
      ThrowReaderException(VAR_31,""ImproperImageHeader"");
    if (HeapOverflowSanityCheck(VAR_24.width,VAR_24.depth) != VAR_28)
      ThrowReaderException(VAR_31,""ImproperImageHeader"");
    VAR_17=VAR_24.width*VAR_24.depth;
    VAR_25=(unsigned char *) AcquireQuantumMemory(VAR_24.length,
      sizeof(*VAR_25));
    if (VAR_25 == (unsigned char *) NULL)
      ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
    VAR_22=(ssize_t) ReadBlob(VAR_8,VAR_24.length,VAR_25);
    if (VAR_22 != (ssize_t) VAR_24.length)
      {
        VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
        ThrowReaderException(VAR_31,""UnableToReadImageData"");
      }
    VAR_19=VAR_24.height;
    if ((VAR_19 == 0) || (VAR_24.width == 0) || (VAR_24.depth == 0) ||
        ((VAR_17/VAR_24.depth) != VAR_24.width))
      {
        VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
        ThrowReaderException(VAR_35,""ImproperImageHeader"");
      }
    VAR_21=VAR_24.depth == 1 ? 15 : 7;
    VAR_17+=VAR_21;
    VAR_17<<=1;
    if ((VAR_17 >> 1) != (VAR_24.width*VAR_24.depth+VAR_21))
      {
        VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
        ThrowReaderException(VAR_35,""ImproperImageHeader"");
      }
    VAR_17>>=4;
    if (HeapOverflowSanityCheck(VAR_19,VAR_17) != VAR_28)
      {
        VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
        ThrowReaderException(VAR_35,""ImproperImageHeader"");
      }
    VAR_20=VAR_19*VAR_17;
    VAR_26=(unsigned char *) AcquireQuantumMemory(VAR_20+VAR_8->rows,
      sizeof(*VAR_26));
    if (VAR_26 == (unsigned char *) NULL)
      {
        VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
        ThrowReaderException(VAR_35,""MemoryAllocationFailed"");
      }
    ResetMagickMemory(VAR_26,0,VAR_20*sizeof(*VAR_26));
    if (VAR_24.type == VAR_6)
      {
        VAR_10=DecodeImage(VAR_25,VAR_24.length,VAR_26,VAR_20);
        if (VAR_10 == VAR_28)
          ThrowReaderException(VAR_31,""UnableToReadImageData"");
      }
    else
      {
        if (VAR_24.length > VAR_20)
          {
            VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
            VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
            ThrowReaderException(VAR_35,""ImproperImageHeader"");
          }
        (void) CopyMagickMemory(VAR_26,VAR_25,VAR_24.length);
      }
    VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
    /* COMMENT_15 */
                                                
      
    VAR_16=VAR_26;
    if (VAR_24.depth == 1)
      for (VAR_23=0; VAR_23 < (ssize_t) VAR_8->rows; VAR_23++)
      {
        VAR_13=QueueAuthenticPixels(VAR_8,0,VAR_23,VAR_8->columns,1,VAR_1);
        if (VAR_13 == (PixelPacket *) NULL)
          break;
        VAR_12=GetAuthenticIndexQueue(VAR_8);
        for (VAR_15=0; VAR_15 < ((ssize_t) VAR_8->columns-7); VAR_15+=8)
        {
          for (VAR_9=7; VAR_9 >= 0; VAR_9--)
            SetPixelIndex(VAR_12+VAR_15+7-VAR_9,((*VAR_16) & (0x01 << VAR_9) ? 0x00 : 0x01));
          VAR_16++;
        }
        if ((VAR_8->columns % 8) != 0)
          {
            for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
              SetPixelIndex(VAR_12+VAR_15+7-VAR_9,(*VAR_16) & (0x01 << VAR_9) ? 0x00 : 0x01);
            VAR_16++;
          }
        if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
          VAR_16++;
        if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_28)
          break;
        if (VAR_8->previous == (Image *) NULL)
          {
            VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_23,
              VAR_8->rows);
            if (VAR_10 == VAR_28)
              break;
          }
      }
    else
      if (VAR_8->storage_class == VAR_39)
        {
          for (VAR_23=0; VAR_23 < (ssize_t) VAR_8->rows; VAR_23++)
          {
            VAR_13=QueueAuthenticPixels(VAR_8,0,VAR_23,VAR_8->columns,1,VAR_1);
            if (VAR_13 == (PixelPacket *) NULL)
              break;
            VAR_12=GetAuthenticIndexQueue(VAR_8);
            for (VAR_15=0; VAR_15 < (ssize_t) VAR_8->columns; VAR_15++)
            {
              SetPixelIndex(VAR_12+VAR_15,ConstrainColormapIndex(VAR_8,*VAR_16));
              VAR_16++;
            }
            if ((VAR_8->columns % 2) != 0)
              VAR_16++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_28)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_23,
                VAR_8->rows);
                if (VAR_10 == VAR_28)
                  break;
              }
          }
        }
      else
        {
          size_t
            VAR_40;

          VAR_40=3;
          if (VAR_8->matte != VAR_28)
            VAR_40++;
          for (VAR_23=0; VAR_23 < (ssize_t) VAR_8->rows; VAR_23++)
          {
            VAR_13=QueueAuthenticPixels(VAR_8,0,VAR_23,VAR_8->columns,1,VAR_1);
            if (VAR_13 == (PixelPacket *) NULL)
              break;
            for (VAR_15=0; VAR_15 < (ssize_t) VAR_8->columns; VAR_15++)
            {
              if (VAR_8->matte != VAR_28)
                SetPixelAlpha(VAR_13,ScaleCharToQuantum(*VAR_16++));
              if (VAR_24.type == VAR_5)
                {
                  SetPixelBlue(VAR_13,ScaleCharToQuantum(*VAR_16++));
                  SetPixelGreen(VAR_13,ScaleCharToQuantum(*VAR_16++));
                  SetPixelRed(VAR_13,ScaleCharToQuantum(*VAR_16++));
                }
              else
                {
                  SetPixelRed(VAR_13,ScaleCharToQuantum(*VAR_16++));
                  SetPixelGreen(VAR_13,ScaleCharToQuantum(*VAR_16++));
                  SetPixelBlue(VAR_13,ScaleCharToQuantum(*VAR_16++));
                }
              if (VAR_8->colors != 0)
                {
                  SetPixelRed(VAR_13,VAR_8->colormap[(ssize_t)
                    GetPixelRed(VAR_13)].red);
                  SetPixelGreen(VAR_13,VAR_8->colormap[(ssize_t)
                    GetPixelGreen(VAR_13)].green);
                  SetPixelBlue(VAR_13,VAR_8->colormap[(ssize_t)
                    GetPixelBlue(VAR_13)].blue);
                }
              VAR_13++;
            }
            if (((VAR_40*VAR_8->columns) % 2) != 0)
              VAR_16++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_28)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_23,
                VAR_8->rows);
                if (VAR_10 == VAR_28)
                  break;
              }
          }
        }
    if (VAR_8->storage_class == VAR_39)
      (void) SyncImage(VAR_8);
    VAR_26=(unsigned char *) RelinquishMagickMemory(VAR_26);
    if (EOFBlob(VAR_8) != VAR_28)
      {
        ThrowFileException(VAR_1,VAR_31,""UnexpectedEndOfFile"",
          VAR_8->filename);
        break;
      }
    /* COMMENT_18 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_24.magic=ReadBlobMSBLong(VAR_8);
    if (VAR_24.magic == 0x59a66a95)
      {
        /* COMMENT_21 */
                                        
          
        AcquireNextImage(VAR_0,VAR_8);
        if (GetNextImageInList(VAR_8) == (Image *) NULL)
          {
            VAR_8=DestroyImageList(VAR_8);
            return((Image *) NULL);
          }
        VAR_8=SyncNextImageInList(VAR_8);
        VAR_10=SetImageProgress(VAR_8,VAR_41,TellBlob(VAR_8),
          GetBlobSize(VAR_8));
        if (VAR_10 == VAR_28)
          break;
      }
  } while (VAR_24.magic == 0x59a66a95);
  (void) CloseBlob(VAR_8);
  return(GetFirstImageInList(VAR_8));
}",ImageMagick/44cb8dfd4cbe6fc475c863a5946cff64e34c2088/sun.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -122,6 +122,8 @@
         size_t
           one;
 
+        if (sun_info.maplength > GetBlobSize(image))
+          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         image->colors=sun_info.maplength;
         one=1;
         if (sun_info.maptype == RMT_NONE)","{'deleted_lines': [], 'added_lines': ['        if (sun_info.maplength > GetBlobSize(image))', '          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");']}",True,"In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",7.5,HIGH,2,valid,2017-07-05T20:41:58Z,1
CVE-2017-12435,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/543,2dd8d55742fce7d079b6a16039c18e49c091224f,https://github.com/ImageMagick/ImageMagick/commit/2dd8d55742fce7d079b6a16039c18e49c091224f,coders/sun.c,RegisterSUNImage,"ModuleExport size_t RegisterSUNImage(void)
{
MagickInfo
*entry;
entry=AcquireMagickInfo(""SUN"",""RAS"",""SUN Rasterfile"");
entry->decoder=(DecodeImageHandler *) ReadSUNImage;
entry->encoder=(EncodeImageHandler *) WriteSUNImage;
entry->magick=(IsImageFormatHandler *) IsSUN;
(void) RegisterMagickInfo(entry);
entry=AcquireMagickInfo(""SUN"",""SUN"",""SUN Rasterfile"");
entry->decoder=(DecodeImageHandler *) ReadSUNImage;
entry->encoder=(EncodeImageHandler *) WriteSUNImage;
(void) RegisterMagickInfo(entry);
return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterSUNImage(void)
{
MagickInfo
*VAR_1;
VAR_1=AcquireMagickInfo(""SUN"",""RAS"",""SUN Rasterfile"");
VAR_1->decoder=(DecodeImageHandler *) VAR_2;
VAR_1->encoder=(EncodeImageHandler *) VAR_3;
VAR_1->magick=(IsImageFormatHandler *) VAR_4;
(void) RegisterMagickInfo(VAR_1);
VAR_1=AcquireMagickInfo(""SUN"",""SUN"",""SUN Rasterfile"");
VAR_1->decoder=(DecodeImageHandler *) VAR_2;
VAR_1->encoder=(EncodeImageHandler *) VAR_3;
(void) RegisterMagickInfo(VAR_1);
return(VAR_5);
}",,"ModuleExport size_t RegisterSUNImage(void)
{
  MagickInfo
    *entry;

  entry=AcquireMagickInfo(""SUN"",""RAS"",""SUN Rasterfile"");
  entry->decoder=(DecodeImageHandler *) ReadSUNImage;
  entry->encoder=(EncodeImageHandler *) WriteSUNImage;
  entry->magick=(IsImageFormatHandler *) IsSUN;
  entry->flags|=CoderDecoderSeekableStreamFlag;
  (void) RegisterMagickInfo(entry);
  entry=AcquireMagickInfo(""SUN"",""SUN"",""SUN Rasterfile"");
  entry->decoder=(DecodeImageHandler *) ReadSUNImage;
  entry->encoder=(EncodeImageHandler *) WriteSUNImage;
  entry->flags|=CoderDecoderSeekableStreamFlag;
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterSUNImage(void)
{
  MagickInfo
    *VAR_1;

  VAR_1=AcquireMagickInfo(""SUN"",""RAS"",""SUN Rasterfile"");
  VAR_1->decoder=(DecodeImageHandler *) VAR_2;
  VAR_1->encoder=(EncodeImageHandler *) VAR_3;
  VAR_1->magick=(IsImageFormatHandler *) VAR_4;
  VAR_1->flags|=VAR_5;
  (void) RegisterMagickInfo(VAR_1);
  VAR_1=AcquireMagickInfo(""SUN"",""SUN"",""SUN Rasterfile"");
  VAR_1->decoder=(DecodeImageHandler *) VAR_2;
  VAR_1->encoder=(EncodeImageHandler *) VAR_3;
  VAR_1->flags|=VAR_5;
  (void) RegisterMagickInfo(VAR_1);
  return(VAR_6);
}",,"--- func_before
+++ func_after
@@ -7,10 +7,12 @@
   entry->decoder=(DecodeImageHandler *) ReadSUNImage;
   entry->encoder=(EncodeImageHandler *) WriteSUNImage;
   entry->magick=(IsImageFormatHandler *) IsSUN;
+  entry->flags|=CoderDecoderSeekableStreamFlag;
   (void) RegisterMagickInfo(entry);
   entry=AcquireMagickInfo(""SUN"",""SUN"",""SUN Rasterfile"");
   entry->decoder=(DecodeImageHandler *) ReadSUNImage;
   entry->encoder=(EncodeImageHandler *) WriteSUNImage;
+  entry->flags|=CoderDecoderSeekableStreamFlag;
   (void) RegisterMagickInfo(entry);
   return(MagickImageCoderSignature);
 }","{'deleted_lines': [], 'added_lines': ['  entry->flags|=CoderDecoderSeekableStreamFlag;', '  entry->flags|=CoderDecoderSeekableStreamFlag;']}",True,"In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",7.5,HIGH,2,valid,2017-07-05T20:43:06Z,1
CVE-2017-12435,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/543,2dd8d55742fce7d079b6a16039c18e49c091224f,https://github.com/ImageMagick/ImageMagick/commit/2dd8d55742fce7d079b6a16039c18e49c091224f,coders/sun.c,ReadSUNImage,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*image;
int
bit;
MagickBooleanType
status;
MagickSizeType
number_pixels;
register Quantum
*q;
register ssize_t
i,
x;
register unsigned char
*p;
size_t
bytes_per_line,
extent,
height,
pixels_length,
quantum;
ssize_t
count,
y;
SUNInfo
sun_info;
unsigned char
*sun_data,
*sun_pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
sun_info.magic=ReadBlobMSBLong(image);
do
{
if (sun_info.magic != 0x59a66a95)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
sun_info.width=ReadBlobMSBLong(image);
sun_info.height=ReadBlobMSBLong(image);
sun_info.depth=ReadBlobMSBLong(image);
sun_info.length=ReadBlobMSBLong(image);
sun_info.type=ReadBlobMSBLong(image);
sun_info.maptype=ReadBlobMSBLong(image);
sun_info.maplength=ReadBlobMSBLong(image);
extent=sun_info.height*sun_info.width;
if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
(sun_info.type != RT_FORMAT_RGB))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.depth != 1) && (sun_info.depth != 8) &&
(sun_info.depth != 24) && (sun_info.depth != 32))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
(sun_info.maptype != RMT_RAW))
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
image->columns=sun_info.width;
image->rows=sun_info.height;
image->depth=sun_info.depth <= 8 ? sun_info.depth :
MAGICKCORE_QUANTUM_DEPTH;
if (sun_info.depth < 24)
{
size_t
one;
image->colors=sun_info.maplength;
one=1;
if (sun_info.maptype == RMT_NONE)
image->colors=one << sun_info.depth;
if (sun_info.maptype == RMT_EQUAL_RGB)
image->colors=sun_info.maplength/3;
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
switch (sun_info.maptype)
{
case RMT_NONE:
break;
case RMT_EQUAL_RGB:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
{
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
{
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
count=ReadBlob(image,image->colors,sun_colormap);
if (count != (ssize_t) image->colors)
{
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
for (i=0; i < (ssize_t) image->colors; i++)
image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
sun_colormap[i]);
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
break;
}
case RMT_RAW:
{
unsigned char
*sun_colormap;
sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
sizeof(*sun_colormap));
if (sun_colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,sun_info.maplength,sun_colormap);
sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
if (count != (ssize_t) sun_info.maplength)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
break;
}
default:
ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
}
image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
UndefinedPixelTrait;
image->columns=sun_info.width;
image->rows=sun_info.height;
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
if (sun_info.length == 0)
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
number_pixels=(MagickSizeType) (image->columns*image->rows);
if ((sun_info.type != RT_ENCODED) &&
((number_pixels*sun_info.depth) > (8UL*sun_info.length)))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
bytes_per_line=sun_info.width*sun_info.depth;
sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,
sizeof(*sun_data));
if (sun_data == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
if (count != (ssize_t) sun_info.length)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
}
height=sun_info.height;
if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
((bytes_per_line/sun_info.depth) != sun_info.width))
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
quantum=sun_info.depth == 1 ? 15 : 7;
bytes_per_line+=quantum;
bytes_per_line<<=1;
if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
bytes_per_line>>=4;
if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
pixels_length=height*bytes_per_line;
sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,
sizeof(*sun_pixels));
if (sun_pixels == (unsigned char *) NULL)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));
if (sun_info.type == RT_ENCODED)
{
status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);
if (status == MagickFalse)
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
}
else
{
if (sun_info.length > pixels_length)
{
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
}
(void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);
}
sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
p=sun_pixels;
if (sun_info.depth == 1)
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=7; bit >= 0; bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
q);
q+=GetPixelChannels(image);
}
p++;
}
if ((image->columns % 8) != 0)
{
for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
{
SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
0x01),q);
q+=GetPixelChannels(image);
}
p++;
}
if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
else
if (image->storage_class == PseudoClass)
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelIndex(image,ConstrainColormapIndex(image,*p,exception),q);
p++;
q+=GetPixelChannels(image);
}
if ((image->columns % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
{
size_t
bytes_per_pixel;
bytes_per_pixel=3;
if (image->alpha_trait != UndefinedPixelTrait)
bytes_per_pixel++;
if (bytes_per_line == 0)
bytes_per_line=bytes_per_pixel*image->columns;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (image->alpha_trait != UndefinedPixelTrait)
SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
if (sun_info.type == RT_STANDARD)
{
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
}
else
{
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
}
if (image->colors != 0)
{
SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelRed(image,q)].red),q);
SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelGreen(image,q)].green),q);
SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
GetPixelBlue(image,q)].blue),q);
}
q+=GetPixelChannels(image);
}
if (((bytes_per_pixel*image->columns) % 2) != 0)
p++;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
if (image->storage_class == PseudoClass)
(void) SyncImage(image,exception);
sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
sun_info.magic=ReadBlobMSBLong(image);
if (sun_info.magic == 0x59a66a95)
{
AcquireNextImage(image_info,image,exception);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while (sun_info.magic == 0x59a66a95);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3
typedef struct _SUNInfo
{
unsigned int
magic,
width,
height,
depth,
length,
type,
maptype,
maplength;
} SUNInfo;
Image
*VAR_8;
int
VAR_9;
MagickBooleanType
VAR_10;
MagickSizeType
VAR_11;
register Quantum
*VAR_12;
register ssize_t
VAR_13,
VAR_14;
register unsigned char
*VAR_15;
size_t
VAR_16,
VAR_17,
VAR_18,
VAR_19,
VAR_20;
ssize_t
VAR_21,
VAR_22;
SUNInfo
VAR_23;
unsigned char
*VAR_24,
*VAR_25;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_26);
if (VAR_0->debug != VAR_27)
(void) LogMagickEvent(VAR_28,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_26);
VAR_8=AcquireImage(VAR_0,VAR_1);
VAR_10=OpenBlob(VAR_0,VAR_8,VAR_29,VAR_1);
if (VAR_10 == VAR_27)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
(void) ResetMagickMemory(&VAR_23,0,sizeof(VAR_23));
VAR_23.magic=ReadBlobMSBLong(VAR_8);
do
{
if (VAR_23.magic != 0x59a66a95)
ThrowReaderException(VAR_30,""ImproperImageHeader"");
VAR_23.width=ReadBlobMSBLong(VAR_8);
VAR_23.height=ReadBlobMSBLong(VAR_8);
VAR_23.depth=ReadBlobMSBLong(VAR_8);
VAR_23.length=ReadBlobMSBLong(VAR_8);
VAR_23.type=ReadBlobMSBLong(VAR_8);
VAR_23.maptype=ReadBlobMSBLong(VAR_8);
VAR_23.maplength=ReadBlobMSBLong(VAR_8);
VAR_17=VAR_23.height*VAR_23.width;
if ((VAR_23.height != 0) && (VAR_23.width != VAR_17/VAR_23.height))
ThrowReaderException(VAR_30,""ImproperImageHeader"");
if ((VAR_23.type != VAR_5) && (VAR_23.type != VAR_6) &&
(VAR_23.type != VAR_7))
ThrowReaderException(VAR_30,""ImproperImageHeader"");
if ((VAR_23.maptype == VAR_3) && (VAR_23.maplength != 0))
ThrowReaderException(VAR_30,""ImproperImageHeader"");
if ((VAR_23.depth != 1) && (VAR_23.depth != 8) &&
(VAR_23.depth != 24) && (VAR_23.depth != 32))
ThrowReaderException(VAR_30,""ImproperImageHeader"");
if ((VAR_23.maptype != VAR_3) && (VAR_23.maptype != VAR_2) &&
(VAR_23.maptype != VAR_4))
ThrowReaderException(VAR_31,""ColormapTypeNotSupported"");
VAR_8->columns=VAR_23.width;
VAR_8->rows=VAR_23.height;
VAR_8->depth=VAR_23.depth <= 8 ? VAR_23.depth :
VAR_32;
if (VAR_23.depth < 24)
{
size_t
VAR_33;
VAR_8->colors=VAR_23.maplength;
VAR_33=1;
if (VAR_23.maptype == VAR_3)
VAR_8->colors=VAR_33 << VAR_23.depth;
if (VAR_23.maptype == VAR_2)
VAR_8->colors=VAR_23.maplength/3;
if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_27)
ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
}
switch (VAR_23.maptype)
{
case VAR_3:
break;
case VAR_2:
{
unsigned char
*VAR_35;
VAR_35=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
sizeof(*VAR_35));
if (VAR_35 == (unsigned char *) NULL)
ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
VAR_21=ReadBlob(VAR_8,VAR_8->colors,VAR_35);
if (VAR_21 != (ssize_t) VAR_8->colors)
{
VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
}
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
VAR_35[VAR_13]);
VAR_21=ReadBlob(VAR_8,VAR_8->colors,VAR_35);
if (VAR_21 != (ssize_t) VAR_8->colors)
{
VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
}
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
VAR_35[VAR_13]);
VAR_21=ReadBlob(VAR_8,VAR_8->colors,VAR_35);
if (VAR_21 != (ssize_t) VAR_8->colors)
{
VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
}
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
VAR_35[VAR_13]);
VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
break;
}
case VAR_4:
{
unsigned char
*VAR_35;
VAR_35=(unsigned char *) AcquireQuantumMemory(VAR_23.maplength,
sizeof(*VAR_35));
if (VAR_35 == (unsigned char *) NULL)
ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
VAR_21=ReadBlob(VAR_8,VAR_23.maplength,VAR_35);
VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
if (VAR_21 != (ssize_t) VAR_23.maplength)
ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
break;
}
default:
ThrowReaderException(VAR_31,""ColormapTypeNotSupported"");
}
VAR_8->alpha_trait=VAR_23.depth == 32 ? VAR_36 :
VAR_37;
VAR_8->columns=VAR_23.width;
VAR_8->rows=VAR_23.height;
if (VAR_0->ping != VAR_27)
{
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}
VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
if (VAR_10 == VAR_27)
return(DestroyImageList(VAR_8));
if (VAR_23.length == 0)
ThrowReaderException(VAR_34,""ImproperImageHeader"");
VAR_11=(MagickSizeType) (VAR_8->columns*VAR_8->rows);
if ((VAR_23.type != VAR_6) &&
((VAR_11*VAR_23.depth) > (8UL*VAR_23.length)))
ThrowReaderException(VAR_30,""ImproperImageHeader"");
if (HeapOverflowSanityCheck(VAR_23.width,VAR_23.depth) != VAR_27)
ThrowReaderException(VAR_30,""ImproperImageHeader"");
VAR_16=VAR_23.width*VAR_23.depth;
VAR_24=(unsigned char *) AcquireQuantumMemory(VAR_23.length,
sizeof(*VAR_24));
if (VAR_24 == (unsigned char *) NULL)
ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
VAR_21=(ssize_t) ReadBlob(VAR_8,VAR_23.length,VAR_24);
if (VAR_21 != (ssize_t) VAR_23.length)
{
VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
ThrowReaderException(VAR_30,""UnableToReadImageData"");
}
VAR_18=VAR_23.height;
if ((VAR_18 == 0) || (VAR_23.width == 0) || (VAR_23.depth == 0) ||
((VAR_16/VAR_23.depth) != VAR_23.width))
{
VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
ThrowReaderException(VAR_34,""ImproperImageHeader"");
}
VAR_20=VAR_23.depth == 1 ? 15 : 7;
VAR_16+=VAR_20;
VAR_16<<=1;
if ((VAR_16 >> 1) != (VAR_23.width*VAR_23.depth+VAR_20))
{
VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
ThrowReaderException(VAR_34,""ImproperImageHeader"");
}
VAR_16>>=4;
if (HeapOverflowSanityCheck(VAR_18,VAR_16) != VAR_27)
{
VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
ThrowReaderException(VAR_34,""ImproperImageHeader"");
}
VAR_19=VAR_18*VAR_16;
VAR_25=(unsigned char *) AcquireQuantumMemory(VAR_19+VAR_8->rows,
sizeof(*VAR_25));
if (VAR_25 == (unsigned char *) NULL)
{
VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
}
ResetMagickMemory(VAR_25,0,VAR_19*sizeof(*VAR_25));
if (VAR_23.type == VAR_6)
{
VAR_10=DecodeImage(VAR_24,VAR_23.length,VAR_25,VAR_19);
if (VAR_10 == VAR_27)
ThrowReaderException(VAR_30,""UnableToReadImageData"");
}
else
{
if (VAR_23.length > VAR_19)
{
VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
ThrowReaderException(VAR_34,""ImproperImageHeader"");
}
(void) CopyMagickMemory(VAR_25,VAR_24,VAR_23.length);
}
VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
VAR_15=VAR_25;
if (VAR_23.depth == 1)
for (VAR_22=0; VAR_22 < (ssize_t) VAR_8->rows; VAR_22++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_22,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
{
for (VAR_9=7; VAR_9 >= 0; VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((VAR_8->columns % 8) != 0)
{
for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
{
SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
0x01),VAR_12);
VAR_12+=GetPixelChannels(VAR_8);
}
VAR_15++;
}
if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_27)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_22,
VAR_8->rows);
if (VAR_10 == VAR_27)
break;
}
}
else
if (VAR_8->storage_class == VAR_39)
{
for (VAR_22=0; VAR_22 < (ssize_t) VAR_8->rows; VAR_22++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_22,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
SetPixelIndex(VAR_8,ConstrainColormapIndex(VAR_8,*VAR_15,VAR_1),VAR_12);
VAR_15++;
VAR_12+=GetPixelChannels(VAR_8);
}
if ((VAR_8->columns % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_27)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_22,
VAR_8->rows);
if (VAR_10 == VAR_27)
break;
}
}
}
else
{
size_t
VAR_40;
VAR_40=3;
if (VAR_8->alpha_trait != VAR_37)
VAR_40++;
if (VAR_16 == 0)
VAR_16=VAR_40*VAR_8->columns;
for (VAR_22=0; VAR_22 < (ssize_t) VAR_8->rows; VAR_22++)
{
VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_22,VAR_8->columns,1,VAR_1);
if (VAR_12 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
{
if (VAR_8->alpha_trait != VAR_37)
SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
if (VAR_23.type == VAR_5)
{
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
else
{
SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
}
if (VAR_8->colors != 0)
{
SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
}
VAR_12+=GetPixelChannels(VAR_8);
}
if (((VAR_40*VAR_8->columns) % 2) != 0)
VAR_15++;
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_27)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_22,
VAR_8->rows);
if (VAR_10 == VAR_27)
break;
}
}
}
if (VAR_8->storage_class == VAR_39)
(void) SyncImage(VAR_8,VAR_1);
VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
if (EOFBlob(VAR_8) != VAR_27)
{
ThrowFileException(VAR_1,VAR_30,""UnexpectedEndOfFile"",
VAR_8->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_23.magic=ReadBlobMSBLong(VAR_8);
if (VAR_23.magic == 0x59a66a95)
{
AcquireNextImage(VAR_0,VAR_8,VAR_1);
if (GetNextImageInList(VAR_8) == (Image *) NULL)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
VAR_8=SyncNextImageInList(VAR_8);
VAR_10=SetImageProgress(VAR_8,VAR_41,TellBlob(VAR_8),
GetBlobSize(VAR_8));
if (VAR_10 == VAR_27)
break;
}
} while (VAR_23.magic == 0x59a66a95);
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}",ImageMagick/2dd8d55742fce7d079b6a16039c18e49c091224f/sun.c/vul/before/1.json,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  size_t
    bytes_per_line,
    extent,
    height,
    pixels_length,
    quantum;

  ssize_t
    count,
    y;

  SUNInfo
    sun_info;

  unsigned char
    *sun_data,
    *sun_pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read SUN raster header.
  */
  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
  sun_info.magic=ReadBlobMSBLong(image);
  do
  {
    /*
      Verify SUN identifier.
    */
    if (sun_info.magic != 0x59a66a95)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    sun_info.width=ReadBlobMSBLong(image);
    sun_info.height=ReadBlobMSBLong(image);
    sun_info.depth=ReadBlobMSBLong(image);
    sun_info.length=ReadBlobMSBLong(image);
    sun_info.type=ReadBlobMSBLong(image);
    sun_info.maptype=ReadBlobMSBLong(image);
    sun_info.maplength=ReadBlobMSBLong(image);
    extent=sun_info.height*sun_info.width;
    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
        (sun_info.type != RT_FORMAT_RGB))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&
        (sun_info.depth != 24) && (sun_info.depth != 32))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
        (sun_info.maptype != RMT_RAW))
      ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    image->depth=sun_info.depth <= 8 ? sun_info.depth :
      MAGICKCORE_QUANTUM_DEPTH;
    if (sun_info.depth < 24)
      {
        size_t
          one;

        if (sun_info.maplength > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        image->colors=sun_info.maplength;
        one=1;
        if (sun_info.maptype == RMT_NONE)
          image->colors=one << sun_info.depth;
        if (sun_info.maptype == RMT_EQUAL_RGB)
          image->colors=sun_info.maplength/3;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    switch (sun_info.maptype)
    {
      case RMT_NONE:
        break;
      case RMT_EQUAL_RGB:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          {
            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
          }
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          {
            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
          }
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        count=ReadBlob(image,image->colors,sun_colormap);
        if (count != (ssize_t) image->colors)
          {
            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
          }
        for (i=0; i < (ssize_t) image->colors; i++)
          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
            sun_colormap[i]);
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        break;
      }
      case RMT_RAW:
      {
        unsigned char
          *sun_colormap;

        /*
          Read SUN raster colormap.
        */
        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
          sizeof(*sun_colormap));
        if (sun_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        count=ReadBlob(image,sun_info.maplength,sun_colormap);
        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
        if (count != (ssize_t) sun_info.maplength)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
      UndefinedPixelTrait;
    image->columns=sun_info.width;
    image->rows=sun_info.height;
    if (image_info->ping != MagickFalse)
      {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    if (sun_info.length == 0)
      ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
    number_pixels=(MagickSizeType) (image->columns*image->rows);
    if ((sun_info.type != RT_ENCODED) &&
        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bytes_per_line=sun_info.width*sun_info.depth;
    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,
      sizeof(*sun_data));
    if (sun_data == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
    if (count != (ssize_t) sun_info.length)
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      }
    height=sun_info.height;
    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
        ((bytes_per_line/sun_info.depth) != sun_info.width))
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
      }
    quantum=sun_info.depth == 1 ? 15 : 7;
    bytes_per_line+=quantum;
    bytes_per_line<<=1;
    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
      }
    bytes_per_line>>=4;
    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
      }
    pixels_length=height*bytes_per_line;
    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,
      sizeof(*sun_pixels));
    if (sun_pixels == (unsigned char *) NULL)
      {
        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));
    if (sun_info.type == RT_ENCODED)
      {
        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);
        if (status == MagickFalse)
          ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      }
    else
      {
        if (sun_info.length > pixels_length)
          {
            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
            ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
          }
        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);
      }
    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
    /*
      Convert SUN raster image to pixel packets.
    */
    p=sun_pixels;
    if (sun_info.depth == 1)
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=7; bit >= 0; bit--)
          {
            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
              q);
            q+=GetPixelChannels(image);
          }
          p++;
        }
        if ((image->columns % 8) != 0)
          {
            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
            {
              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
                0x01),q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
          p++;
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        if (image->previous == (Image *) NULL)
          {
            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
              image->rows);
            if (status == MagickFalse)
              break;
          }
      }
    else
      if (image->storage_class == PseudoClass)
        {
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelIndex(image,ConstrainColormapIndex(image,*p,exception),q);
              p++;
              q+=GetPixelChannels(image);
            }
            if ((image->columns % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
      else
        {
          size_t
            bytes_per_pixel;

          bytes_per_pixel=3;
          if (image->alpha_trait != UndefinedPixelTrait)
            bytes_per_pixel++;
          if (bytes_per_line == 0)
            bytes_per_line=bytes_per_pixel*image->columns;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
              if (sun_info.type == RT_STANDARD)
                {
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                }
              else
                {
                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                }
              if (image->colors != 0)
                {
                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelRed(image,q)].red),q);
                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelGreen(image,q)].green),q);
                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                    GetPixelBlue(image,q)].blue),q);
                }
              q+=GetPixelChannels(image);
            }
            if (((bytes_per_pixel*image->columns) % 2) != 0)
              p++;
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    sun_info.magic=ReadBlobMSBLong(image);
    if (sun_info.magic == 0x59a66a95)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (sun_info.magic == 0x59a66a95);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadSUNImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  0
#define VAR_4  2
#define VAR_5  1
#define VAR_6  2
#define VAR_7  3

  typedef struct _SUNInfo
  {
    unsigned int
      magic,
      width,
      height,
      depth,
      length,
      type,
      maptype,
      maplength;
  } SUNInfo;

  Image
    *VAR_8;

  int
    VAR_9;

  MagickBooleanType
    VAR_10;

  MagickSizeType
    VAR_11;

  register Quantum
    *VAR_12;

  register ssize_t
    VAR_13,
    VAR_14;

  register unsigned char
    *VAR_15;

  size_t
    VAR_16,
    VAR_17,
    VAR_18,
    VAR_19,
    VAR_20;

  ssize_t
    VAR_21,
    VAR_22;

  SUNInfo
    VAR_23;

  unsigned char
    *VAR_24,
    *VAR_25;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_26);
  if (VAR_0->debug != VAR_27)
    (void) LogMagickEvent(VAR_28,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_26);
  VAR_8=AcquireImage(VAR_0,VAR_1);
  VAR_10=OpenBlob(VAR_0,VAR_8,VAR_29,VAR_1);
  if (VAR_10 == VAR_27)
    {
      VAR_8=DestroyImageList(VAR_8);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                           
    
  (void) ResetMagickMemory(&VAR_23,0,sizeof(VAR_23));
  VAR_23.magic=ReadBlobMSBLong(VAR_8);
  do
  {
    /* COMMENT_6 */
                            
      
    if (VAR_23.magic != 0x59a66a95)
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    VAR_23.width=ReadBlobMSBLong(VAR_8);
    VAR_23.height=ReadBlobMSBLong(VAR_8);
    VAR_23.depth=ReadBlobMSBLong(VAR_8);
    VAR_23.length=ReadBlobMSBLong(VAR_8);
    VAR_23.type=ReadBlobMSBLong(VAR_8);
    VAR_23.maptype=ReadBlobMSBLong(VAR_8);
    VAR_23.maplength=ReadBlobMSBLong(VAR_8);
    VAR_17=VAR_23.height*VAR_23.width;
    if ((VAR_23.height != 0) && (VAR_23.width != VAR_17/VAR_23.height))
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    if ((VAR_23.type != VAR_5) && (VAR_23.type != VAR_6) &&
        (VAR_23.type != VAR_7))
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    if ((VAR_23.maptype == VAR_3) && (VAR_23.maplength != 0))
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    if ((VAR_23.depth != 1) && (VAR_23.depth != 8) &&
        (VAR_23.depth != 24) && (VAR_23.depth != 32))
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    if ((VAR_23.maptype != VAR_3) && (VAR_23.maptype != VAR_2) &&
        (VAR_23.maptype != VAR_4))
      ThrowReaderException(VAR_31,""ColormapTypeNotSupported"");
    VAR_8->columns=VAR_23.width;
    VAR_8->rows=VAR_23.height;
    VAR_8->depth=VAR_23.depth <= 8 ? VAR_23.depth :
      VAR_32;
    if (VAR_23.depth < 24)
      {
        size_t
          VAR_33;

        if (VAR_23.maplength > GetBlobSize(VAR_8))
          ThrowReaderException(VAR_30,""InsufficientImageDataInFile"");
        VAR_8->colors=VAR_23.maplength;
        VAR_33=1;
        if (VAR_23.maptype == VAR_3)
          VAR_8->colors=VAR_33 << VAR_23.depth;
        if (VAR_23.maptype == VAR_2)
          VAR_8->colors=VAR_23.maplength/3;
        if (AcquireImageColormap(VAR_8,VAR_8->colors,VAR_1) == VAR_27)
          ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
      }
    switch (VAR_23.maptype)
    {
      case VAR_3:
        break;
      case VAR_2:
      {
        unsigned char
          *VAR_35;

        /* COMMENT_9 */
                                   
          
        VAR_35=(unsigned char *) AcquireQuantumMemory(VAR_8->colors,
          sizeof(*VAR_35));
        if (VAR_35 == (unsigned char *) NULL)
          ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
        VAR_21=ReadBlob(VAR_8,VAR_8->colors,VAR_35);
        if (VAR_21 != (ssize_t) VAR_8->colors)
          {
            VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
            ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
          }
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].red=(MagickRealType) ScaleCharToQuantum(
            VAR_35[VAR_13]);
        VAR_21=ReadBlob(VAR_8,VAR_8->colors,VAR_35);
        if (VAR_21 != (ssize_t) VAR_8->colors)
          {
            VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
            ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
          }
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].green=(MagickRealType) ScaleCharToQuantum(
            VAR_35[VAR_13]);
        VAR_21=ReadBlob(VAR_8,VAR_8->colors,VAR_35);
        if (VAR_21 != (ssize_t) VAR_8->colors)
          {
            VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
            ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
          }
        for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->colors; VAR_13++)
          VAR_8->colormap[VAR_13].blue=(MagickRealType) ScaleCharToQuantum(
            VAR_35[VAR_13]);
        VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
        break;
      }
      case VAR_4:
      {
        unsigned char
          *VAR_35;

        /* COMMENT_12 */
                                   
          
        VAR_35=(unsigned char *) AcquireQuantumMemory(VAR_23.maplength,
          sizeof(*VAR_35));
        if (VAR_35 == (unsigned char *) NULL)
          ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
        VAR_21=ReadBlob(VAR_8,VAR_23.maplength,VAR_35);
        VAR_35=(unsigned char *) RelinquishMagickMemory(VAR_35);
        if (VAR_21 != (ssize_t) VAR_23.maplength)
          ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
        break;
      }
      default:
        ThrowReaderException(VAR_31,""ColormapTypeNotSupported"");
    }
    VAR_8->alpha_trait=VAR_23.depth == 32 ? VAR_36 :
      VAR_37;
    VAR_8->columns=VAR_23.width;
    VAR_8->rows=VAR_23.height;
    if (VAR_0->ping != VAR_27)
      {
        (void) CloseBlob(VAR_8);
        return(GetFirstImageInList(VAR_8));
      }
    VAR_10=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
    if (VAR_10 == VAR_27)
      return(DestroyImageList(VAR_8));
    if (VAR_23.length == 0)
      ThrowReaderException(VAR_34,""ImproperImageHeader"");
    VAR_11=(MagickSizeType) (VAR_8->columns*VAR_8->rows);
    if ((VAR_23.type != VAR_6) &&
        ((VAR_11*VAR_23.depth) > (8UL*VAR_23.length)))
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    if (HeapOverflowSanityCheck(VAR_23.width,VAR_23.depth) != VAR_27)
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    VAR_16=VAR_23.width*VAR_23.depth;
    VAR_24=(unsigned char *) AcquireQuantumMemory(VAR_23.length,
      sizeof(*VAR_24));
    if (VAR_24 == (unsigned char *) NULL)
      ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
    VAR_21=(ssize_t) ReadBlob(VAR_8,VAR_23.length,VAR_24);
    if (VAR_21 != (ssize_t) VAR_23.length)
      {
        VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
        ThrowReaderException(VAR_30,""UnableToReadImageData"");
      }
    VAR_18=VAR_23.height;
    if ((VAR_18 == 0) || (VAR_23.width == 0) || (VAR_23.depth == 0) ||
        ((VAR_16/VAR_23.depth) != VAR_23.width))
      {
        VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
        ThrowReaderException(VAR_34,""ImproperImageHeader"");
      }
    VAR_20=VAR_23.depth == 1 ? 15 : 7;
    VAR_16+=VAR_20;
    VAR_16<<=1;
    if ((VAR_16 >> 1) != (VAR_23.width*VAR_23.depth+VAR_20))
      {
        VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
        ThrowReaderException(VAR_34,""ImproperImageHeader"");
      }
    VAR_16>>=4;
    if (HeapOverflowSanityCheck(VAR_18,VAR_16) != VAR_27)
      {
        VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
        ThrowReaderException(VAR_34,""ImproperImageHeader"");
      }
    VAR_19=VAR_18*VAR_16;
    VAR_25=(unsigned char *) AcquireQuantumMemory(VAR_19+VAR_8->rows,
      sizeof(*VAR_25));
    if (VAR_25 == (unsigned char *) NULL)
      {
        VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
        ThrowReaderException(VAR_34,""MemoryAllocationFailed"");
      }
    ResetMagickMemory(VAR_25,0,VAR_19*sizeof(*VAR_25));
    if (VAR_23.type == VAR_6)
      {
        VAR_10=DecodeImage(VAR_24,VAR_23.length,VAR_25,VAR_19);
        if (VAR_10 == VAR_27)
          ThrowReaderException(VAR_30,""UnableToReadImageData"");
      }
    else
      {
        if (VAR_23.length > VAR_19)
          {
            VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
            VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
            ThrowReaderException(VAR_34,""ImproperImageHeader"");
          }
        (void) CopyMagickMemory(VAR_25,VAR_24,VAR_23.length);
      }
    VAR_24=(unsigned char *) RelinquishMagickMemory(VAR_24);
    /* COMMENT_15 */
                                                
      
    VAR_15=VAR_25;
    if (VAR_23.depth == 1)
      for (VAR_22=0; VAR_22 < (ssize_t) VAR_8->rows; VAR_22++)
      {
        VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_22,VAR_8->columns,1,VAR_1);
        if (VAR_12 == (Quantum *) NULL)
          break;
        for (VAR_14=0; VAR_14 < ((ssize_t) VAR_8->columns-7); VAR_14+=8)
        {
          for (VAR_9=7; VAR_9 >= 0; VAR_9--)
          {
            SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 : 0x01),
              VAR_12);
            VAR_12+=GetPixelChannels(VAR_8);
          }
          VAR_15++;
        }
        if ((VAR_8->columns % 8) != 0)
          {
            for (VAR_9=7; VAR_9 >= (int) (8-(VAR_8->columns % 8)); VAR_9--)
            {
              SetPixelIndex(VAR_8,(Quantum) ((*VAR_15) & (0x01 << VAR_9) ? 0x00 :
                0x01),VAR_12);
              VAR_12+=GetPixelChannels(VAR_8);
            }
            VAR_15++;
          }
        if ((((VAR_8->columns/8)+(VAR_8->columns % 8 ? 1 : 0)) % 2) != 0)
          VAR_15++;
        if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_27)
          break;
        if (VAR_8->previous == (Image *) NULL)
          {
            VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_22,
              VAR_8->rows);
            if (VAR_10 == VAR_27)
              break;
          }
      }
    else
      if (VAR_8->storage_class == VAR_39)
        {
          for (VAR_22=0; VAR_22 < (ssize_t) VAR_8->rows; VAR_22++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_22,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              SetPixelIndex(VAR_8,ConstrainColormapIndex(VAR_8,*VAR_15,VAR_1),VAR_12);
              VAR_15++;
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if ((VAR_8->columns % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_27)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_22,
                VAR_8->rows);
                if (VAR_10 == VAR_27)
                  break;
              }
          }
        }
      else
        {
          size_t
            VAR_40;

          VAR_40=3;
          if (VAR_8->alpha_trait != VAR_37)
            VAR_40++;
          if (VAR_16 == 0)
            VAR_16=VAR_40*VAR_8->columns;
          for (VAR_22=0; VAR_22 < (ssize_t) VAR_8->rows; VAR_22++)
          {
            VAR_12=QueueAuthenticPixels(VAR_8,0,VAR_22,VAR_8->columns,1,VAR_1);
            if (VAR_12 == (Quantum *) NULL)
              break;
            for (VAR_14=0; VAR_14 < (ssize_t) VAR_8->columns; VAR_14++)
            {
              if (VAR_8->alpha_trait != VAR_37)
                SetPixelAlpha(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
              if (VAR_23.type == VAR_5)
                {
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              else
                {
                  SetPixelRed(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelGreen(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                  SetPixelBlue(VAR_8,ScaleCharToQuantum(*VAR_15++),VAR_12);
                }
              if (VAR_8->colors != 0)
                {
                  SetPixelRed(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelRed(VAR_8,VAR_12)].red),VAR_12);
                  SetPixelGreen(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelGreen(VAR_8,VAR_12)].green),VAR_12);
                  SetPixelBlue(VAR_8,ClampToQuantum(VAR_8->colormap[(ssize_t)
                    GetPixelBlue(VAR_8,VAR_12)].blue),VAR_12);
                }
              VAR_12+=GetPixelChannels(VAR_8);
            }
            if (((VAR_40*VAR_8->columns) % 2) != 0)
              VAR_15++;
            if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_27)
              break;
            if (VAR_8->previous == (Image *) NULL)
              {
                VAR_10=SetImageProgress(VAR_8,VAR_38,(MagickOffsetType) VAR_22,
                VAR_8->rows);
                if (VAR_10 == VAR_27)
                  break;
              }
          }
        }
    if (VAR_8->storage_class == VAR_39)
      (void) SyncImage(VAR_8,VAR_1);
    VAR_25=(unsigned char *) RelinquishMagickMemory(VAR_25);
    if (EOFBlob(VAR_8) != VAR_27)
      {
        ThrowFileException(VAR_1,VAR_30,""UnexpectedEndOfFile"",
          VAR_8->filename);
        break;
      }
    /* COMMENT_18 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_8->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_23.magic=ReadBlobMSBLong(VAR_8);
    if (VAR_23.magic == 0x59a66a95)
      {
        /* COMMENT_21 */
                                        
          
        AcquireNextImage(VAR_0,VAR_8,VAR_1);
        if (GetNextImageInList(VAR_8) == (Image *) NULL)
          {
            VAR_8=DestroyImageList(VAR_8);
            return((Image *) NULL);
          }
        VAR_8=SyncNextImageInList(VAR_8);
        VAR_10=SetImageProgress(VAR_8,VAR_41,TellBlob(VAR_8),
          GetBlobSize(VAR_8));
        if (VAR_10 == VAR_27)
          break;
      }
  } while (VAR_23.magic == 0x59a66a95);
  (void) CloseBlob(VAR_8);
  return(GetFirstImageInList(VAR_8));
}",ImageMagick/2dd8d55742fce7d079b6a16039c18e49c091224f/sun.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -119,6 +119,8 @@
         size_t
           one;
 
+        if (sun_info.maplength > GetBlobSize(image))
+          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         image->colors=sun_info.maplength;
         one=1;
         if (sun_info.maptype == RMT_NONE)","{'deleted_lines': [], 'added_lines': ['        if (sun_info.maplength > GetBlobSize(image))', '          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");']}",True,"In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",7.5,HIGH,2,valid,2017-07-05T20:43:06Z,1
CVE-2017-12434,['CWE-617'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/547,6767f31cac3eacdc9dc41b3193a73bdd37610375,https://github.com/ImageMagick/ImageMagick/commit/6767f31cac3eacdc9dc41b3193a73bdd37610375,coders/mat.c,ReadMATImage,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image *image, *image2=NULL,
*rotated_image;
PixelPacket *q;
unsigned int status;
MATHeader MATLAB_HDR;
size_t size;
size_t CellType;
QuantumInfo *quantum_info;
ImageInfo *clone_info;
int i;
ssize_t ldblk;
unsigned char *BImgBuff = NULL;
double MinVal, MaxVal;
size_t Unknown6;
unsigned z, z2;
unsigned Frames;
int logging;
int sample_size;
MagickOffsetType filepos=0x80;
BlobInfo *blob;
size_t one;
unsigned int (*ReadBlobXXXLong)(Image *image);
unsigned short (*ReadBlobXXXShort)(Image *image);
void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
quantum_info=(QuantumInfo *) NULL;
image = AcquireImage(image_info);
status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
clone_info=(ImageInfo *) NULL;
if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
{
image2=ReadMATImageV4(image_info,image,exception);
if (image2  == NULL)
goto MATLAB_KO;
image=image2;
goto END_OF_READING;
}
MATLAB_HDR.Version = ReadBlobLSBShort(image);
if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
{
ReadBlobXXXLong = ReadBlobLSBLong;
ReadBlobXXXShort = ReadBlobLSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesLSB;
ReadBlobFloatsXXX = ReadBlobFloatsLSB;
image->endian = LSBEndian;
}
else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
{
ReadBlobXXXLong = ReadBlobMSBLong;
ReadBlobXXXShort = ReadBlobMSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesMSB;
ReadBlobFloatsXXX = ReadBlobFloatsMSB;
image->endian = MSBEndian;
}
else
goto MATLAB_KO;    
if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
filepos = TellBlob(image);
while(!EOFBlob(image)) 
{
Frames = 1;
(void) SeekBlob(image,filepos,SEEK_SET);
MATLAB_HDR.DataType = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))
goto MATLAB_KO;
filepos += MATLAB_HDR.ObjectSize + 4 + 4;
clone_info=CloneImageInfo(image_info);
image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
if(MATLAB_HDR.DataType == miCOMPRESSED)
{
image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
if(image2==NULL) continue;
MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
}
#endif
if(MATLAB_HDR.DataType!=miMATRIX) continue;  
MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
if(image!=image2)
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
switch(MATLAB_HDR.DimFlag)
{
case  8: z2=z=1; break;      
case 12: z2=z = ReadBlobXXXLong(image2);  
Unknown6 = ReadBlobXXXLong(image2);
(void) Unknown6;
if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: z2=z = ReadBlobXXXLong(image2);  
if(z!=3 && z!=1)
ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
Frames = ReadBlobXXXLong(image2);
if (Frames == 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
break;
default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
}
MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
MATLAB_HDR.StructureClass != mxINT8_CLASS &&
MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
MATLAB_HDR.StructureClass != mxINT16_CLASS &&
MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
MATLAB_HDR.StructureClass != mxINT32_CLASS &&
MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
MATLAB_HDR.StructureClass != mxINT64_CLASS &&
MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
switch (MATLAB_HDR.NameFlag)
{
case 0:
size = ReadBlobXXXLong(image2);  
size = 4 * (ssize_t) ((size + 3 + 1) / 4);
(void) SeekBlob(image2, size, SEEK_CUR);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(image2, 4, (unsigned char *) &size); 
break;
default:
goto MATLAB_KO;
}
CellType = ReadBlobXXXLong(image2);    
if (logging)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) CellType);
(void) ReadBlob(image2, 4, (unsigned char *) &size);     
NEXT_FRAME:
switch (CellType)
{
case miINT8:
case miUINT8:
sample_size = 8;
if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
image->depth = 1;
else
image->depth = 8;         
ldblk = (ssize_t) MATLAB_HDR.SizeX;
break;
case miINT16:
case miUINT16:
sample_size = 16;
image->depth = 16;        
ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
break;
case miINT32:
case miUINT32:
sample_size = 32;
image->depth = 32;        
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miINT64:
case miUINT64:
sample_size = 64;
image->depth = 64;        
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
case miSINGLE:
sample_size = 32;
image->depth = 32;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{              
}
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miDOUBLE:
sample_size = 64;
image->depth = 64;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
RestoreMSCWarning
ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{                         
}
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
default:
ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
}
(void) sample_size;
image->columns = MATLAB_HDR.SizeX;
image->rows = MATLAB_HDR.SizeY;
one=1;
image->colors = one << image->depth;
if (image->columns == 0 || image->rows == 0)
goto MATLAB_KO;
if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
goto MATLAB_KO;
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
{
SetImageColorspace(image,GRAYColorspace);
image->type=GrayscaleType;
}
if (image_info->ping)
{
size_t temp = image->columns;
image->columns = image->rows;
image->rows = temp;
goto done_reading; 
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
quantum_info=AcquireQuantumInfo(clone_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
if (BImgBuff == NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
MinVal = 0;
MaxVal = 0;
if (CellType==miDOUBLE || CellType==miSINGLE)        
{
CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
}
if(z==1) z=0; 
do
{
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto done_reading;    
}
if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
{
FixLogical((unsigned char *)BImgBuff,ldblk);
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
{
ImportQuantumPixelsFailed:
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
break;
}
}
else
{
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
goto ImportQuantumPixelsFailed;
if (z<=1 &&       
(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
FixSignedValues(q,MATLAB_HDR.SizeX);
}
if (!SyncAuthenticPixels(image,exception))
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
}
} while(z-- >= 2);
ExitLoop:
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{        
CellType = ReadBlobXXXLong(image2);    
i = ReadBlobXXXLong(image2);           
if (CellType==miDOUBLE || CellType==miSINGLE)
{
CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
}
if (CellType==miDOUBLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
}
if (CellType==miSINGLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
}
}
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
image->type=GrayscaleType;
if (image->depth == 1)
image->type=BilevelType;
if(image2==image)
image2 = NULL;    
rotated_image = RotateImage(image, 90.0, exception);
if (rotated_image != (Image *) NULL)
{
rotated_image->page.x=0;
rotated_image->page.y=0;
blob = rotated_image->blob;
rotated_image->blob = image->blob;
rotated_image->colors = image->colors;
image->blob = blob;
AppendImageToList(&image,rotated_image);
DeleteImageFromList(&image);
}
done_reading:
if(image2!=NULL)
if(image2!=image)
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
}
}
AcquireNextImage(image_info,image);
if (image->next == (Image *) NULL) break;
image=SyncNextImageInList(image);
image->columns=image->rows=0;
image->colors=0;
RelinquishMagickMemory(BImgBuff);
BImgBuff = NULL;
if(--Frames>0)
{
z = z2;
if(image2==NULL) image2 = image;
goto NEXT_FRAME;
}
if(image2!=NULL)
if(image2!=image)   
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) unlink(clone_info->filename);
}
}
}
}
RelinquishMagickMemory(BImgBuff);
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
clone_info=DestroyImageInfo(clone_info);
CloseBlob(image);
{
Image *p;
ssize_t scene=0;
p=image;
image=NULL;
while (p != (Image *) NULL)
{
Image *tmp=p;
if ((p->rows == 0) || (p->columns == 0)) {
p=p->previous;
DeleteImageFromList(&tmp);
} else {
image=p;
p=p->previous;
}
}
for (p=image; p != (Image *) NULL; p=p->next)
p->scene=scene++;
}
if(clone_info != NULL)  
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
DestroyImageInfo(clone_info);
clone_info = NULL;
}
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
if(image==NULL)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image *VAR_2, *VAR_3=NULL,
*VAR_4;
PixelPacket *VAR_5;
unsigned int VAR_6;
MATHeader VAR_7;
size_t VAR_8;
size_t VAR_9;
QuantumInfo *VAR_10;
ImageInfo *VAR_11;
int VAR_12;
ssize_t VAR_13;
unsigned char *VAR_14 = NULL;
double VAR_15, VAR_16;
size_t VAR_17;
unsigned VAR_18, VAR_19;
unsigned VAR_20;
int VAR_21;
int VAR_22;
MagickOffsetType VAR_23=0x80;
BlobInfo *VAR_24;
size_t VAR_25;
unsigned int (*VAR_26)(Image *VAR_2);
unsigned short (*VAR_27)(Image *VAR_2);
void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_32);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_32);
VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");
VAR_10=(QuantumInfo *) NULL;
VAR_2 = AcquireImage(VAR_0);
VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
if (VAR_6 == VAR_35)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_11=(ImageInfo *) NULL;
if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
{
VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
if (VAR_3  == NULL)
goto MATLAB_KO;
VAR_2=VAR_3;
goto END_OF_READING;
}
VAR_7.Version = ReadBlobLSBShort(VAR_2);
if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
{
VAR_26 = VAR_37;
VAR_27 = VAR_38;
VAR_28 = VAR_39;
VAR_31 = VAR_40;
VAR_2->endian = VAR_41;
}
else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
{
VAR_26 = VAR_42;
VAR_27 = VAR_43;
VAR_28 = VAR_44;
VAR_31 = VAR_45;
VAR_2->endian = VAR_46;
}
else
goto MATLAB_KO;    
if (strncmp(VAR_7.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(VAR_36,""ImproperImageHeader"");
VAR_23 = TellBlob(VAR_2);
while(!EOFBlob(VAR_2)) 
{
VAR_20 = 1;
(void) SeekBlob(VAR_2,VAR_23,VAR_47);
VAR_7.DataType = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
VAR_7.ObjectSize = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
if(VAR_7.ObjectSize+VAR_23 > GetBlobSize(VAR_2))
goto MATLAB_KO;
VAR_23 += VAR_7.ObjectSize + 4 + 4;
VAR_11=CloneImageInfo(VAR_0);
VAR_3 = VAR_2;
#if defined(VAR_48)
if(VAR_7.DataType == VAR_49)
{
VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
if(VAR_3==NULL) continue;
VAR_7.DataType = VAR_26(VAR_3); 
}
#endif
if(VAR_7.DataType!=VAR_50) continue;  
VAR_7.unknown1 = VAR_26(VAR_3);
VAR_7.unknown2 = VAR_26(VAR_3);
VAR_7.unknown5 = VAR_26(VAR_3);
VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;
VAR_7.unknown3 = VAR_26(VAR_3);
if(VAR_2!=VAR_3)
VAR_7.unknown4 = VAR_26(VAR_3);  
VAR_7.unknown4 = VAR_26(VAR_3);
VAR_7.DimFlag = VAR_26(VAR_3);
VAR_7.SizeX = VAR_26(VAR_3);
VAR_7.SizeY = VAR_26(VAR_3);
switch(VAR_7.DimFlag)
{
case  8: VAR_19=VAR_18=1; break;      
case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  
VAR_17 = VAR_26(VAR_3);
(void) VAR_17;
if(VAR_18!=3) ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  
if(VAR_18!=3 && VAR_18!=1)
ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
VAR_20 = VAR_26(VAR_3);
if (VAR_20 == 0)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
break;
default: ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
}
VAR_7.Flag1 = VAR_27(VAR_3);
VAR_7.NameFlag = VAR_27(VAR_3);
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
if (VAR_7.StructureClass != VAR_52 &&
VAR_7.StructureClass != VAR_53 &&    
VAR_7.StructureClass != VAR_54 &&    
VAR_7.StructureClass != VAR_55 &&
VAR_7.StructureClass != VAR_56 &&    
VAR_7.StructureClass != VAR_57 &&
VAR_7.StructureClass != VAR_58 &&    
VAR_7.StructureClass != VAR_59 &&
VAR_7.StructureClass != VAR_60 &&    
VAR_7.StructureClass != VAR_61 &&
VAR_7.StructureClass != VAR_62)    
ThrowReaderException(VAR_51,""UnsupportedCellTypeInTheMatrix"");
switch (VAR_7.NameFlag)
{
case 0:
VAR_8 = VAR_26(VAR_3);  
VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
(void) SeekBlob(VAR_3, VAR_8, VAR_63);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); 
break;
default:
goto MATLAB_KO;
}
VAR_9 = VAR_26(VAR_3);    
if (VAR_21)
(void) LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     
NEXT_FRAME:
switch (VAR_9)
{
case VAR_64:
case VAR_65:
VAR_22 = 8;
if(VAR_7.StructureFlag & VAR_66)
VAR_2->depth = 1;
else
VAR_2->depth = 8;         
VAR_13 = (ssize_t) VAR_7.SizeX;
break;
case VAR_67:
case VAR_68:
VAR_22 = 16;
VAR_2->depth = 16;        
VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
break;
case VAR_69:
case VAR_70:
VAR_22 = 32;
VAR_2->depth = 32;        
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_71:
case VAR_72:
VAR_22 = 64;
VAR_2->depth = 64;        
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
case VAR_73:
VAR_22 = 32;
VAR_2->depth = 32;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
if (VAR_7.StructureFlag & VAR_74)
{              
}
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_75:
VAR_22 = 64;
VAR_2->depth = 64;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
VAR_76
ThrowReaderException(VAR_51, ""IncompatibleSizeOfDouble"");
if (VAR_7.StructureFlag & VAR_74)
{                         
}
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
default:
ThrowReaderException(VAR_51, ""UnsupportedCellTypeInTheMatrix"");
}
(void) VAR_22;
VAR_2->columns = VAR_7.SizeX;
VAR_2->rows = VAR_7.SizeY;
VAR_25=1;
VAR_2->colors = VAR_25 << VAR_2->depth;
if (VAR_2->columns == 0 || VAR_2->rows == 0)
goto MATLAB_KO;
if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
goto MATLAB_KO;
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_74) == 0))
{
SetImageColorspace(VAR_2,VAR_77);
VAR_2->type=VAR_78;
}
if (VAR_0->ping)
{
size_t VAR_79 = VAR_2->columns;
VAR_2->columns = VAR_2->rows;
VAR_2->rows = VAR_79;
goto done_reading; 
}
VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
if (VAR_6 == VAR_35)
{
InheritException(VAR_1,&VAR_2->exception);
return(DestroyImageList(VAR_2));
}
VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
if (VAR_10 == (QuantumInfo *) NULL)
ThrowReaderException(VAR_80,""MemoryAllocationFailed"");
VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    
if (VAR_14 == NULL)
ThrowReaderException(VAR_80,""MemoryAllocationFailed"");
(void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));
VAR_15 = 0;
VAR_16 = 0;
if (VAR_9==VAR_75 || VAR_9==VAR_73)        
{
CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
}
if(VAR_18==1) VAR_18=0; 
do
{
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
if (VAR_5 == (PixelPacket *) NULL)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto done_reading;    
}
if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
if((VAR_9==VAR_64 || VAR_9==VAR_65) && (VAR_7.StructureFlag & VAR_66))
{
FixLogical((unsigned char *)VAR_14,VAR_13);
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
{
ImportQuantumPixelsFailed:
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
break;
}
}
else
{
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
goto ImportQuantumPixelsFailed;
if (VAR_18<=1 &&       
(VAR_9==VAR_64 || VAR_9==VAR_67 || VAR_9==VAR_69 || VAR_9==VAR_71))
FixSignedValues(VAR_5,VAR_7.SizeX);
}
if (!SyncAuthenticPixels(VAR_2,VAR_1))
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
}
} while(VAR_18-- >= 2);
ExitLoop:
if (VAR_7.StructureFlag & VAR_74)
{        
VAR_9 = VAR_26(VAR_3);    
VAR_12 = VAR_26(VAR_3);           
if (VAR_9==VAR_75 || VAR_9==VAR_73)
{
CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
}
if (VAR_9==VAR_75)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_28(VAR_3, VAR_13, (double *)VAR_14);
InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
if (VAR_9==VAR_73)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_31(VAR_3, VAR_13, (float *)VAR_14);
InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
}
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_74) == 0))
VAR_2->type=VAR_78;
if (VAR_2->depth == 1)
VAR_2->type=VAR_82;
if(VAR_3==VAR_2)
VAR_3 = NULL;    
VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
if (VAR_4 != (Image *) NULL)
{
VAR_4->page.x=0;
VAR_4->page.y=0;
VAR_24 = VAR_4->blob;
VAR_4->blob = VAR_2->blob;
VAR_4->colors = VAR_2->colors;
VAR_2->blob = VAR_24;
AppendImageToList(&VAR_2,VAR_4);
DeleteImageFromList(&VAR_2);
}
done_reading:
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
}
}
AcquireNextImage(VAR_0,VAR_2);
if (VAR_2->next == (Image *) NULL) break;
VAR_2=SyncNextImageInList(VAR_2);
VAR_2->columns=VAR_2->rows=0;
VAR_2->colors=0;
RelinquishMagickMemory(VAR_14);
VAR_14 = NULL;
if(--VAR_20>0)
{
VAR_18 = VAR_19;
if(VAR_3==NULL) VAR_3 = VAR_2;
goto NEXT_FRAME;
}
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)   
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) unlink(VAR_11->filename);
}
}
}
}
RelinquishMagickMemory(VAR_14);
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
VAR_11=DestroyImageInfo(VAR_11);
CloseBlob(VAR_2);
{
Image *VAR_83;
ssize_t VAR_84=0;
VAR_83=VAR_2;
VAR_2=NULL;
while (VAR_83 != (Image *) NULL)
{
Image *VAR_85=VAR_83;
if ((VAR_83->rows == 0) || (VAR_83->columns == 0)) {
VAR_83=VAR_83->previous;
DeleteImageFromList(&VAR_85);
} else {
VAR_2=VAR_83;
VAR_83=VAR_83->previous;
}
}
for (VAR_83=VAR_2; VAR_83 != (Image *) NULL; VAR_83=VAR_83->next)
VAR_83->scene=VAR_84++;
}
if(VAR_11 != NULL)  
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
DestroyImageInfo(VAR_11);
VAR_11 = NULL;
}
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
if(VAR_2==NULL)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
return (VAR_2);
}",ImageMagick/6767f31cac3eacdc9dc41b3193a73bdd37610375/mat.c/vul/before/0.json,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  quantum_info=(QuantumInfo *) NULL;
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=(ImageInfo *) NULL;
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
      /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image *VAR_2, *VAR_3=NULL,
   *VAR_4;
  PixelPacket *VAR_5;

  unsigned int VAR_6;
  MATHeader VAR_7;
  size_t VAR_8;
  size_t VAR_9;
  QuantumInfo *VAR_10;
  ImageInfo *VAR_11;
  int VAR_12;
  ssize_t VAR_13;
  unsigned char *VAR_14 = NULL;
  double VAR_15, VAR_16;
  size_t VAR_17;
  unsigned VAR_18, VAR_19;
  unsigned VAR_20;
  int VAR_21;
  int VAR_22;
  MagickOffsetType VAR_23=0x80;
  BlobInfo *VAR_24;
  size_t VAR_25;

  unsigned int (*VAR_26)(Image *VAR_2);
  unsigned short (*VAR_27)(Image *VAR_2);
  void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
  void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);


  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_32);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_32);
  VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");

  /* COMMENT_0 */
                     
     
  VAR_10=(QuantumInfo *) NULL;
  VAR_2 = AcquireImage(VAR_0);

  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
  if (VAR_6 == VAR_35)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                       
     
  VAR_11=(ImageInfo *) NULL;
  if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
    {
      VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
      if (VAR_3  == NULL)
        goto MATLAB_KO;
      VAR_2=VAR_3;
      goto END_OF_READING;
    }
  VAR_7.Version = ReadBlobLSBShort(VAR_2);
  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");

  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
        VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
  if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
  {
    VAR_26 = VAR_37;
    VAR_27 = VAR_38;
    VAR_28 = VAR_39;
    VAR_31 = VAR_40;
    VAR_2->endian = VAR_41;
  }
  else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
  {
    VAR_26 = VAR_42;
    VAR_27 = VAR_43;
    VAR_28 = VAR_44;
    VAR_31 = VAR_45;
    VAR_2->endian = VAR_46;
  }
  else
    goto MATLAB_KO;    /* COMMENT_6 */

  if (strncmp(VAR_7.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(VAR_36,""ImproperImageHeader"");

  VAR_23 = TellBlob(VAR_2);
  while(!EOFBlob(VAR_2)) /* COMMENT_7 */
  {
    VAR_20 = 1;
    (void) SeekBlob(VAR_2,VAR_23,VAR_47);
    /* COMMENT_8 */

    VAR_7.DataType = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    VAR_7.ObjectSize = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    if(VAR_7.ObjectSize+VAR_23 > GetBlobSize(VAR_2))
      goto MATLAB_KO;
    VAR_23 += VAR_7.ObjectSize + 4 + 4;

    VAR_11=CloneImageInfo(VAR_0);
    VAR_3 = VAR_2;
#if defined(VAR_48)
    if(VAR_7.DataType == VAR_49)
    {
      VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
      if(VAR_3==NULL) continue;
      VAR_7.DataType = VAR_26(VAR_3); /* COMMENT_9 */
    }
#endif

    if(VAR_7.DataType!=VAR_50) continue;  /* COMMENT_10 */

    VAR_7.unknown1 = VAR_26(VAR_3);
    VAR_7.unknown2 = VAR_26(VAR_3);

    VAR_7.unknown5 = VAR_26(VAR_3);
    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;

    VAR_7.unknown3 = VAR_26(VAR_3);
    if(VAR_2!=VAR_3)
      VAR_7.unknown4 = VAR_26(VAR_3);  /* COMMENT_11 */
    VAR_7.unknown4 = VAR_26(VAR_3);
    VAR_7.DimFlag = VAR_26(VAR_3);
    VAR_7.SizeX = VAR_26(VAR_3);
    VAR_7.SizeY = VAR_26(VAR_3);


    switch(VAR_7.DimFlag)
    {
      case  8: VAR_19=VAR_18=1; break;      /* COMMENT_12 */
      case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_13 */
           VAR_17 = VAR_26(VAR_3);
           (void) VAR_17;
         if(VAR_18!=3) ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_14 */
         if(VAR_18!=3 && VAR_18!=1)
           ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
         VAR_20 = VAR_26(VAR_3);
         if (VAR_20 == 0)
           ThrowReaderException(VAR_36,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(VAR_51, ""MultidimensionalMatricesAreNotSupported"");
    }

    VAR_7.Flag1 = VAR_27(VAR_3);
    VAR_7.NameFlag = VAR_27(VAR_3);

    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
    if (VAR_7.StructureClass != VAR_52 &&
        VAR_7.StructureClass != VAR_53 &&    /* COMMENT_15 */
        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_16 */
        VAR_7.StructureClass != VAR_55 &&
        VAR_7.StructureClass != VAR_56 &&    /* COMMENT_17 */
        VAR_7.StructureClass != VAR_57 &&
        VAR_7.StructureClass != VAR_58 &&    /* COMMENT_18 */
        VAR_7.StructureClass != VAR_59 &&
        VAR_7.StructureClass != VAR_60 &&    /* COMMENT_19 */
        VAR_7.StructureClass != VAR_61 &&
        VAR_7.StructureClass != VAR_62)    /* COMMENT_20 */
      ThrowReaderException(VAR_51,""UnsupportedCellTypeInTheMatrix"");

    switch (VAR_7.NameFlag)
    {
      case 0:
        VAR_8 = VAR_26(VAR_3);  /* COMMENT_21 */
        VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
        (void) SeekBlob(VAR_3, VAR_8, VAR_63);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_22 */
        break;
      default:
        goto MATLAB_KO;
    }

    VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
    if (VAR_21)
      (void) LogMagickEvent(VAR_33,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);

    (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     /* COMMENT_24 */

NEXT_FRAME:
    switch (VAR_9)
    {
      case VAR_64:
      case VAR_65:
        VAR_22 = 8;
        if(VAR_7.StructureFlag & VAR_66)
          VAR_2->depth = 1;
        else
          VAR_2->depth = 8;         /* COMMENT_25 */
        VAR_13 = (ssize_t) VAR_7.SizeX;
        break;
      case VAR_67:
      case VAR_68:
        VAR_22 = 16;
        VAR_2->depth = 16;        /* COMMENT_26 */
        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
        break;
      case VAR_69:
      case VAR_70:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_27 */
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_71:
      case VAR_72:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_28 */
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      case VAR_73:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
        if (VAR_7.StructureFlag & VAR_74)
  {              /* COMMENT_30 */
  }
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_75:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
VAR_76
          ThrowReaderException(VAR_51, ""IncompatibleSizeOfDouble"");
        if (VAR_7.StructureFlag & VAR_74)
  {                         /* COMMENT_31 */
  }
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      default:
        ThrowReaderException(VAR_51, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) VAR_22;
    VAR_2->columns = VAR_7.SizeX;
    VAR_2->rows = VAR_7.SizeY;
    VAR_25=1;
    VAR_2->colors = VAR_25 << VAR_2->depth;
    if (VAR_2->columns == 0 || VAR_2->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
      goto MATLAB_KO;
      /* COMMENT_32 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_74) == 0))
      {
        SetImageColorspace(VAR_2,VAR_77);
        VAR_2->type=VAR_78;
      }


    /* COMMENT_33 */
                                                                  
                             
      
    if (VAR_0->ping)
    {
      size_t VAR_79 = VAR_2->columns;
      VAR_2->columns = VAR_2->rows;
      VAR_2->rows = VAR_79;
      goto done_reading; /* COMMENT_37 */
    }
    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
    if (VAR_6 == VAR_35)
      {
        InheritException(VAR_1,&VAR_2->exception);
        return(DestroyImageList(VAR_2));
      }
    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
    if (VAR_10 == (QuantumInfo *) NULL)
      ThrowReaderException(VAR_80,""MemoryAllocationFailed"");

  /* COMMENT_38 */
    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_39 */
    if (VAR_14 == NULL)
      ThrowReaderException(VAR_80,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));

    VAR_15 = 0;
    VAR_16 = 0;
    if (VAR_9==VAR_75 || VAR_9==VAR_73)        /* COMMENT_40 */
    {
      CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
    }

    /* COMMENT_41 */
    if(VAR_18==1) VAR_18=0; /* COMMENT_42 */
    /* COMMENT_43 */
    do
    {
      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
      {
        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
        if (VAR_5 == (PixelPacket *) NULL)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto done_reading;    /* COMMENT_44 */
  }
        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
        if((VAR_9==VAR_64 || VAR_9==VAR_65) && (VAR_7.StructureFlag & VAR_66))
        {
          FixLogical((unsigned char *)VAR_14,VAR_13);
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
    {
ImportQuantumPixelsFailed:
      if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_81[VAR_18],VAR_14,VAR_1) <= 0)
      goto ImportQuantumPixelsFailed;


          if (VAR_18<=1 &&       /* COMMENT_45 */
          (VAR_9==VAR_64 || VAR_9==VAR_67 || VAR_9==VAR_69 || VAR_9==VAR_71))
      FixSignedValues(VAR_5,VAR_7.SizeX);
        }

        if (!SyncAuthenticPixels(VAR_2,VAR_1))
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
      }
    } while(VAR_18-- >= 2);
ExitLoop:


    /* COMMENT_46 */
    if (VAR_7.StructureFlag & VAR_74)
    {        /* COMMENT_47 */
      VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
      VAR_12 = VAR_26(VAR_3);           /* COMMENT_48 */

      if (VAR_9==VAR_75 || VAR_9==VAR_73)
      {
        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
      }

      if (VAR_9==VAR_75)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_28(VAR_3, VAR_13, (double *)VAR_14);
          InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }

      if (VAR_9==VAR_73)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_31(VAR_3, VAR_13, (float *)VAR_14);
          InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }
    }

      /* COMMENT_49 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_74) == 0))
      VAR_2->type=VAR_78;
    if (VAR_2->depth == 1)
      VAR_2->type=VAR_82;

    if(VAR_3==VAR_2)
        VAR_3 = NULL;    /* COMMENT_50 */

      /* COMMENT_51 */
    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
    if (VAR_4 != (Image *) NULL)
    {
        /* COMMENT_52 */
      VAR_4->page.x=0;
      VAR_4->page.y=0;

      VAR_24 = VAR_4->blob;
      VAR_4->blob = VAR_2->blob;
      VAR_4->colors = VAR_2->colors;
      VAR_2->blob = VAR_24;
      AppendImageToList(&VAR_2,VAR_4);
      DeleteImageFromList(&VAR_2);
    }

done_reading:

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)
      {
        DeleteImageFromList(&VAR_3);
  if(VAR_11)
  {
          if(VAR_11->file)
    {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) remove_utf8(VAR_11->filename);
    }
        }
      }

      /* COMMENT_53 */
    AcquireNextImage(VAR_0,VAR_2);
    if (VAR_2->next == (Image *) NULL) break;
    VAR_2=SyncNextImageInList(VAR_2);
    VAR_2->columns=VAR_2->rows=0;
    VAR_2->colors=0;

      /* COMMENT_54 */
    RelinquishMagickMemory(VAR_14);
    VAR_14 = NULL;

    if(--VAR_20>0)
    {
      VAR_18 = VAR_19;
      if(VAR_3==NULL) VAR_3 = VAR_2;
      goto NEXT_FRAME;
    }

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)   /* COMMENT_55 */
      {
/* COMMENT_56 */
        DeleteImageFromList(&VAR_3);
        if(VAR_11)
        {
          if(VAR_11->file)
          {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) unlink(VAR_11->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(VAR_14);
  if (VAR_10 != (QuantumInfo *) NULL)
    VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
  if (VAR_11)
    VAR_11=DestroyImageInfo(VAR_11);
  CloseBlob(VAR_2);


  {
    Image *VAR_83;
    ssize_t VAR_84=0;

    /* COMMENT_57 */
                                                             
      
    VAR_83=VAR_2;
    VAR_2=NULL;
    while (VAR_83 != (Image *) NULL)
      {
        Image *VAR_85=VAR_83;
        if ((VAR_83->rows == 0) || (VAR_83->columns == 0)) {
          VAR_83=VAR_83->previous;
          DeleteImageFromList(&VAR_85);
        } else {
          VAR_2=VAR_83;
          VAR_83=VAR_83->previous;
        }
      }

    /* COMMENT_60 */
                       
      
    for (VAR_83=VAR_2; VAR_83 != (Image *) NULL; VAR_83=VAR_83->next)
      VAR_83->scene=VAR_84++;
  }

  if(VAR_11 != NULL)  /* COMMENT_63 */
  {
    if(VAR_11->file)
    {
      fclose(VAR_11->file);
      VAR_11->file = NULL;
      (void) remove_utf8(VAR_11->filename);
    }
    DestroyImageInfo(VAR_11);
    VAR_11 = NULL;
  }
  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
  if(VAR_2==NULL)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  return (VAR_2);
}",ImageMagick/6767f31cac3eacdc9dc41b3193a73bdd37610375/mat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -461,7 +461,8 @@
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
-  clone_info=DestroyImageInfo(clone_info);
+  if (clone_info)
+    clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);
 
 ","{'deleted_lines': ['  clone_info=DestroyImageInfo(clone_info);'], 'added_lines': ['  if (clone_info)', '    clone_info=DestroyImageInfo(clone_info);']}",True,"In ImageMagick 7.0.6-1, a missing NULL check vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service (assertion failure) in DestroyImageInfo in image.c.",6.5,MEDIUM,1,valid,2017-07-06T12:08:43Z,1
CVE-2017-1000218,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,hfiref0x/LightFTP,"POSIX version fixes

Addressing issue #5",a964370a2f9b3dc8eabd8346407a4381f3e0610a,https://github.com/hfiref0x/LightFTP/commit/a964370a2f9b3dc8eabd8346407a4381f3e0610a,Source/Other/ftpserv.c,writelogentry,"int writelogentry(PFTPCONTEXT context, const char *logtext1, const char *logtext2)
{
charcvbuf[32], _text[512];
time_titm = time(NULL);
struct tmltm;
localtime_r(&itm, &ltm);
_text[0] = 0;
if ( ltm.tm_mday < 10 )
strcat(_text, ""0"");
ultostr(ltm.tm_mday, cvbuf);
strcat(_text, cvbuf);
strcat(_text, ""-"");
if ( ltm.tm_mon+1 < 10 )
strcat(_text, ""0"");
ultostr(ltm.tm_mon+1, cvbuf);
strcat(_text, cvbuf);
strcat(_text, ""-"");
ultostr(ltm.tm_year+1900, cvbuf);
strcat(_text, cvbuf);
strcat(_text, "" "");
if ( ltm.tm_hour < 10 )
strcat(_text, ""0"");
ultostr(ltm.tm_hour, cvbuf);
strcat(_text, cvbuf);
strcat(_text, "":"");
if ( ltm.tm_min < 10 )
strcat(_text, ""0"");
ultostr(ltm.tm_min, cvbuf);
strcat(_text, cvbuf);
strcat(_text, "":"");
if ( ltm.tm_sec < 10 )
strcat(_text, ""0"");
ultostr(ltm.tm_sec, cvbuf);
strcat(_text, cvbuf);
if (context) {
strcat(_text, "" S-id="");
ultostr(context->SessionID, cvbuf);
strcat(_text, cvbuf);
}
strcat(_text, "": "");
if (logtext1)
strcat(_text, logtext1);
if (logtext2)
strcat(_text, logtext2);
strcat(_text, CRLF);
return writeconsolestr(_text);
}","int writelogentry(PFTPCONTEXT VAR_0, const char *VAR_1, const char *VAR_2)
{
charVAR_3[32], VAR_4[512];
time_tVAR_5 = time(NULL);
struct tmVAR_6;
localtime_r(&VAR_5, &VAR_6);
VAR_4[0] = 0;
if ( VAR_6.tm_mday < 10 )
strcat(VAR_4, ""0"");
ultostr(VAR_6.tm_mday, VAR_3);
strcat(VAR_4, VAR_3);
strcat(VAR_4, ""-"");
if ( VAR_6.tm_mon+1 < 10 )
strcat(VAR_4, ""0"");
ultostr(VAR_6.tm_mon+1, VAR_3);
strcat(VAR_4, VAR_3);
strcat(VAR_4, ""-"");
ultostr(VAR_6.tm_year+1900, VAR_3);
strcat(VAR_4, VAR_3);
strcat(VAR_4, "" "");
if ( VAR_6.tm_hour < 10 )
strcat(VAR_4, ""0"");
ultostr(VAR_6.tm_hour, VAR_3);
strcat(VAR_4, VAR_3);
strcat(VAR_4, "":"");
if ( VAR_6.tm_min < 10 )
strcat(VAR_4, ""0"");
ultostr(VAR_6.tm_min, VAR_3);
strcat(VAR_4, VAR_3);
strcat(VAR_4, "":"");
if ( VAR_6.tm_sec < 10 )
strcat(VAR_4, ""0"");
ultostr(VAR_6.tm_sec, VAR_3);
strcat(VAR_4, VAR_3);
if (VAR_0) {
strcat(VAR_4, "" S-id="");
ultostr(VAR_0->SessionID, VAR_3);
strcat(VAR_4, VAR_3);
}
strcat(VAR_4, "": "");
if (VAR_1)
strcat(VAR_4, VAR_1);
if (VAR_2)
strcat(VAR_4, VAR_2);
strcat(VAR_4, VAR_7);
return writeconsolestr(VAR_4);
}",hfiref0x/LightFTP/a964370a2f9b3dc8eabd8346407a4381f3e0610a/ftpserv.c/vul/before/0.json,"int writelogentry(PFTPCONTEXT context, const char *logtext1, const char *logtext2)
{
	char		cvbuf[32], _text[PATH_MAX*4];
	time_t		itm = time(NULL);
	struct tm	ltm;

	localtime_r(&itm, &ltm);

	_text[0] = 0;

	if ( ltm.tm_mday < 10 )
		strcat(_text, ""0"");
	ultostr(ltm.tm_mday, cvbuf);
	strcat(_text, cvbuf);
	strcat(_text, ""-"");

	if ( ltm.tm_mon+1 < 10 )
		strcat(_text, ""0"");
	ultostr(ltm.tm_mon+1, cvbuf);
	strcat(_text, cvbuf);
	strcat(_text, ""-"");

	ultostr(ltm.tm_year+1900, cvbuf);
	strcat(_text, cvbuf);
	strcat(_text, "" "");

	if ( ltm.tm_hour < 10 )
		strcat(_text, ""0"");
	ultostr(ltm.tm_hour, cvbuf);
	strcat(_text, cvbuf);
	strcat(_text, "":"");

	if ( ltm.tm_min < 10 )
		strcat(_text, ""0"");
	ultostr(ltm.tm_min, cvbuf);
	strcat(_text, cvbuf);
	strcat(_text, "":"");

	if ( ltm.tm_sec < 10 )
		strcat(_text, ""0"");
	ultostr(ltm.tm_sec, cvbuf);
	strcat(_text, cvbuf);

	if (context) {
		strcat(_text, "" S-id="");
		ultostr(context->SessionID, cvbuf);
		strcat(_text, cvbuf);
	}
	strcat(_text, "": "");

	if (logtext1)
		strcat(_text, logtext1);

	if (logtext2)
		strcat(_text, logtext2);

	strcat(_text, CRLF);

	return writeconsolestr(_text);
}","int writelogentry(PFTPCONTEXT VAR_0, const char *VAR_1, const char *VAR_2)
{
	char		VAR_3[32], VAR_4[VAR_5*4];
	time_t		VAR_6 = time(NULL);
	struct tm	VAR_7;

	localtime_r(&VAR_6, &VAR_7);

	VAR_4[0] = 0;

	if ( VAR_7.tm_mday < 10 )
		strcat(VAR_4, ""0"");
	ultostr(VAR_7.tm_mday, VAR_3);
	strcat(VAR_4, VAR_3);
	strcat(VAR_4, ""-"");

	if ( VAR_7.tm_mon+1 < 10 )
		strcat(VAR_4, ""0"");
	ultostr(VAR_7.tm_mon+1, VAR_3);
	strcat(VAR_4, VAR_3);
	strcat(VAR_4, ""-"");

	ultostr(VAR_7.tm_year+1900, VAR_3);
	strcat(VAR_4, VAR_3);
	strcat(VAR_4, "" "");

	if ( VAR_7.tm_hour < 10 )
		strcat(VAR_4, ""0"");
	ultostr(VAR_7.tm_hour, VAR_3);
	strcat(VAR_4, VAR_3);
	strcat(VAR_4, "":"");

	if ( VAR_7.tm_min < 10 )
		strcat(VAR_4, ""0"");
	ultostr(VAR_7.tm_min, VAR_3);
	strcat(VAR_4, VAR_3);
	strcat(VAR_4, "":"");

	if ( VAR_7.tm_sec < 10 )
		strcat(VAR_4, ""0"");
	ultostr(VAR_7.tm_sec, VAR_3);
	strcat(VAR_4, VAR_3);

	if (VAR_0) {
		strcat(VAR_4, "" S-id="");
		ultostr(VAR_0->SessionID, VAR_3);
		strcat(VAR_4, VAR_3);
	}
	strcat(VAR_4, "": "");

	if (VAR_1)
		strcat(VAR_4, VAR_1);

	if (VAR_2)
		strcat(VAR_4, VAR_2);

	strcat(VAR_4, VAR_8);

	return writeconsolestr(VAR_4);
}",hfiref0x/LightFTP/a964370a2f9b3dc8eabd8346407a4381f3e0610a/ftpserv.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 int writelogentry(PFTPCONTEXT context, const char *logtext1, const char *logtext2)
 {
-	char		cvbuf[32], _text[512];
+	char		cvbuf[32], _text[PATH_MAX*4];
 	time_t		itm = time(NULL);
 	struct tm	ltm;
 ","{'deleted_lines': ['\tchar\t\tcvbuf[32], _text[512];'], 'added_lines': ['\tchar\t\tcvbuf[32], _text[PATH_MAX*4];']}",True,"LightFTP version 1.1 is vulnerable to a buffer overflow in the ""writelogentry"" function resulting a denial of services or a remote code execution.",9.8,CRITICAL,3,valid,2017-07-06T15:24:27Z,1
CVE-2017-1000424,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,electron,"fix a pdf-viewer's parsing logic, and this should resolve the related issue at https://github.com/electron/electron/issues/10007",9a7651a93faaaef0534df1ab77268d7deb9d3165,https://github.com/electron/electron/commit/9a7651a93faaaef0534df1ab77268d7deb9d3165,atom/browser/atom_web_ui_controller_factory.cc,AtomWebUIControllerFactory::CreateWebUIControllerForURL,"content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* web_ui,
const GURL& url) const {
if (url.host() == kPdfViewerUIHost) {
base::StringPairs toplevel_params;
base::SplitStringIntoKeyValuePairs(url.query(), '=', '&', &toplevel_params);
std::string stream_id, src;
for (const auto& param : toplevel_params) {
if (param.first == kPdfPluginSrc) {
src = param.second;
}
}
if (url.has_ref()) {
src = src + '#' + url.ref();
}
auto browser_context = web_ui->GetWebContents()->GetBrowserContext();
return new PdfViewerUI(browser_context, web_ui, src);
}
return nullptr;
}","content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* VAR_0,
const GURL& VAR_1) const {
if (VAR_1.host() == VAR_2) {
base::StringPairs VAR_3;
base::SplitStringIntoKeyValuePairs(VAR_1.query(), '=', '&', &VAR_3);
std::string VAR_4, VAR_5;
for (const auto& VAR_6 : VAR_3) {
if (VAR_6.first == VAR_7) {
VAR_5 = VAR_6.second;
}
}
if (VAR_1.has_ref()) {
VAR_5 = VAR_5 + '#' + VAR_1.ref();
}
auto VAR_8 = VAR_0->GetWebContents()->GetBrowserContext();
return new PdfViewerUI(VAR_8, VAR_0, VAR_5);
}
return nullptr;
}",electron/9a7651a93faaaef0534df1ab77268d7deb9d3165/atom_web_ui_controller_factory.cc/vul/before/0.json,"content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* web_ui,
                                                        const GURL& url) const {
  if (url.host() == kPdfViewerUIHost) {
    base::StringPairs toplevel_params;
    base::SplitStringIntoKeyValuePairs(url.query(), '=', '&', &toplevel_params);
    std::string stream_id, src;

    const net::UnescapeRule::Type unescape_rules =
      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |
      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;

    for (const auto& param : toplevel_params) {
      if (param.first == kPdfPluginSrc) {
        src = net::UnescapeURLComponent(param.second, unescape_rules);
      }
    }
    if (url.has_ref()) {
      src = src + '#' + url.ref();
    }
    auto browser_context = web_ui->GetWebContents()->GetBrowserContext();
    return new PdfViewerUI(browser_context, web_ui, src);
  }
  return nullptr;
}","content::WebUIController*
AtomWebUIControllerFactory::CreateWebUIControllerForURL(content::WebUI* VAR_0,
                                                        const GURL& VAR_1) const {
  if (VAR_1.host() == VAR_2) {
    base::StringPairs VAR_3;
    base::SplitStringIntoKeyValuePairs(VAR_1.query(), '=', '&', &VAR_3);
    std::string VAR_4, VAR_5;

    const net::UnescapeRule::Type VAR_6 =
      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |
      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;

    for (const auto& VAR_7 : VAR_3) {
      if (VAR_7.first == VAR_8) {
        VAR_5 = net::UnescapeURLComponent(VAR_7.second, VAR_6);
      }
    }
    if (VAR_1.has_ref()) {
      VAR_5 = VAR_5 + '#' + VAR_1.ref();
    }
    auto VAR_9 = VAR_0->GetWebContents()->GetBrowserContext();
    return new PdfViewerUI(VAR_9, VAR_0, VAR_5);
  }
  return nullptr;
}",electron/9a7651a93faaaef0534df1ab77268d7deb9d3165/atom_web_ui_controller_factory.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,9 +5,16 @@
     base::StringPairs toplevel_params;
     base::SplitStringIntoKeyValuePairs(url.query(), '=', '&', &toplevel_params);
     std::string stream_id, src;
+
+    const net::UnescapeRule::Type unescape_rules =
+      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |
+      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |
+      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |
+      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;
+
     for (const auto& param : toplevel_params) {
       if (param.first == kPdfPluginSrc) {
-        src = param.second;
+        src = net::UnescapeURLComponent(param.second, unescape_rules);
       }
     }
     if (url.has_ref()) {","{'deleted_lines': ['        src = param.second;'], 'added_lines': ['', '    const net::UnescapeRule::Type unescape_rules =', '      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |', '      net::UnescapeRule::SPACES | net::UnescapeRule::PATH_SEPARATORS |', '      net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |', '      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;', '', '        src = net::UnescapeURLComponent(param.second, unescape_rules);']}",True,Github Electron version 1.6.4 - 1.6.11 and 1.7.0 - 1.7.5 is vulnerable to a URL Spoofing problem when opening PDFs in PDFium resulting loading arbitrary PDFs that a hacker can control.,4.3,MEDIUM,1,valid,2017-07-14T04:09:14Z,1
CVE-2017-1000424,['CWE-Other'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,electron,"fix a pdf-viewer's parsing logic, and this should resolve the related issue at https://github.com/electron/electron/issues/10007",9a7651a93faaaef0534df1ab77268d7deb9d3165,https://github.com/electron/electron/commit/9a7651a93faaaef0534df1ab77268d7deb9d3165,atom/browser/atom_resource_dispatcher_host_delegate.cc,OnPdfResourceIntercepted,"void OnPdfResourceIntercepted(
const GURL& original_url,
const content::ResourceRequestInfo::WebContentsGetter&
web_contents_getter) {
content::WebContents* web_contents = web_contents_getter.Run();
if (!web_contents)
return;
if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) {
auto browser_context = web_contents->GetBrowserContext();
auto download_manager =
content::BrowserContext::GetDownloadManager(browser_context);
download_manager->DownloadUrl(
content::DownloadUrlParameters::CreateForWebContentsMainFrame(
web_contents, original_url));
return;
}
content::NavigationController::LoadURLParams params(
GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin,
kPdfPluginSrc, original_url.spec().c_str())));
web_contents->GetController().LoadURLWithParams(params);
}","void OnPdfResourceIntercepted(
const GURL& VAR_0,
const content::ResourceRequestInfo::WebContentsGetter&
VAR_1) {
content::WebContents* VAR_2 = VAR_1.Run();
if (!VAR_2)
return;
if (!WebContentsPreferences::IsPluginsEnabled(VAR_2)) {
auto VAR_3 = VAR_2->GetBrowserContext();
auto VAR_4 =
content::BrowserContext::GetDownloadManager(VAR_3);
VAR_4->DownloadUrl(
content::DownloadUrlParameters::CreateForWebContentsMainFrame(
VAR_2, VAR_0));
return;
}
content::NavigationController::LoadURLParams VAR_5(
GURL(base::StringPrintf(""%sindex.html?%s=%s"", VAR_6,
VAR_7, VAR_0.spec().c_str())));
VAR_2->GetController().LoadURLWithParams(VAR_5);
}",electron/9a7651a93faaaef0534df1ab77268d7deb9d3165/atom_resource_dispatcher_host_delegate.cc/vul/before/0.json,"void OnPdfResourceIntercepted(
    const GURL& original_url,
    const content::ResourceRequestInfo::WebContentsGetter&
        web_contents_getter) {
  content::WebContents* web_contents = web_contents_getter.Run();
  if (!web_contents)
    return;

  if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) {
    auto browser_context = web_contents->GetBrowserContext();
    auto download_manager =
      content::BrowserContext::GetDownloadManager(browser_context);

    download_manager->DownloadUrl(
        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
            web_contents, original_url));
    return;
  }

  // The URL passes the original pdf resource url, that will be requested
  // by the webui page.
  // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
  GURL escaped_url(net::EscapeUrlEncodedData(original_url.spec(), true));
  content::NavigationController::LoadURLParams params(
      GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin,
                              kPdfPluginSrc, escaped_url.spec().c_str())));
  web_contents->GetController().LoadURLWithParams(params);
}","void OnPdfResourceIntercepted(
    const GURL& VAR_0,
    const content::ResourceRequestInfo::WebContentsGetter&
        VAR_1) {
  content::WebContents* VAR_2 = VAR_1.Run();
  if (!VAR_2)
    return;

  if (!WebContentsPreferences::IsPluginsEnabled(VAR_2)) {
    auto VAR_3 = VAR_2->GetBrowserContext();
    auto VAR_4 =
      content::BrowserContext::GetDownloadManager(VAR_3);

    VAR_4->DownloadUrl(
        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
            VAR_2, VAR_0));
    return;
  }

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  GURL VAR_5(net::EscapeUrlEncodedData(VAR_0.spec(), true));
  content::NavigationController::LoadURLParams VAR_6(
      GURL(base::StringPrintf(""%sindex.html?%s=%s"", VAR_7,
                              VAR_8, VAR_5.spec().c_str())));
  VAR_2->GetController().LoadURLWithParams(VAR_6);
}",electron/9a7651a93faaaef0534df1ab77268d7deb9d3165/atom_resource_dispatcher_host_delegate.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,8 +20,9 @@
   // The URL passes the original pdf resource url, that will be requested
   // by the webui page.
   // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
+  GURL escaped_url(net::EscapeUrlEncodedData(original_url.spec(), true));
   content::NavigationController::LoadURLParams params(
       GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin,
-                              kPdfPluginSrc, original_url.spec().c_str())));
+                              kPdfPluginSrc, escaped_url.spec().c_str())));
   web_contents->GetController().LoadURLWithParams(params);
 }","{'deleted_lines': ['                              kPdfPluginSrc, original_url.spec().c_str())));'], 'added_lines': ['  GURL escaped_url(net::EscapeUrlEncodedData(original_url.spec(), true));', '                              kPdfPluginSrc, escaped_url.spec().c_str())));']}",True,Github Electron version 1.6.4 - 1.6.11 and 1.7.0 - 1.7.5 is vulnerable to a URL Spoofing problem when opening PDFs in PDFium resulting loading arbitrary PDFs that a hacker can control.,4.3,MEDIUM,1,valid,2017-07-14T04:09:14Z,1
CVE-2017-1000200,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,open-iscsi/tcmu-runner,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",bb80e9c7a798f035768260ebdadffb6eb0786178,https://github.com/open-iscsi/tcmu-runner/commit/bb80e9c7a798f035768260ebdadffb6eb0786178,main.c,on_handler_appeared,"static void
on_handler_appeared(GDBusConnection *connection,
const gchar     *name,
const gchar     *name_owner,
gpointer         user_data)
{
struct tcmur_handler *handler = user_data;
struct dbus_info *info = handler->opaque;
if (info->register_invocation) {
info->connection = connection;
tcmur_register_handler(handler);
dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
g_dbus_method_invocation_return_value(info->register_invocation,
g_variant_new(""(bs)"", TRUE, ""succeeded""));
info->register_invocation = NULL;
}
}","static void
on_handler_appeared(GDBusConnection *VAR_0,
const gchar     *VAR_1,
const gchar     *VAR_2,
gpointer         VAR_3)
{
struct tcmur_handler *VAR_4 = VAR_3;
struct dbus_info *VAR_5 = VAR_4->opaque;
if (VAR_5->register_invocation) {
VAR_5->connection = VAR_0;
tcmur_register_handler(VAR_4);
dbus_export_handler(VAR_4, G_CALLBACK(VAR_6));
g_dbus_method_invocation_return_value(VAR_5->register_invocation,
g_variant_new(""(bs)"", TRUE, ""succeeded""));
VAR_5->register_invocation = NULL;
}
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/before/0.json,"static void
on_handler_appeared(GDBusConnection *connection,
		    const gchar     *name,
		    const gchar     *name_owner,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;

	if (info->register_invocation) {
		info->connection = connection;
		tcmur_register_dbus_handler(handler);
		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
		g_dbus_method_invocation_return_value(info->register_invocation,
			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
		info->register_invocation = NULL;
	}
}","static void
on_handler_appeared(GDBusConnection *VAR_0,
		    const gchar     *VAR_1,
		    const gchar     *VAR_2,
		    gpointer         VAR_3)
{
	struct tcmur_handler *VAR_4 = VAR_3;
	struct dbus_info *VAR_5 = VAR_4->opaque;

	if (VAR_5->register_invocation) {
		VAR_5->connection = VAR_0;
		tcmur_register_dbus_handler(VAR_4);
		dbus_export_handler(VAR_4, G_CALLBACK(VAR_6));
		g_dbus_method_invocation_return_value(VAR_5->register_invocation,
			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
		VAR_5->register_invocation = NULL;
	}
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 
 	if (info->register_invocation) {
 		info->connection = connection;
-		tcmur_register_handler(handler);
+		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));","{'deleted_lines': ['\t\ttcmur_register_handler(handler);'], 'added_lines': ['\t\ttcmur_register_dbus_handler(handler);']}",True,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,7.5,HIGH,2,valid,2017-07-14T13:11:54Z,1
CVE-2017-1000200,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,open-iscsi/tcmu-runner,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",bb80e9c7a798f035768260ebdadffb6eb0786178,https://github.com/open-iscsi/tcmu-runner/commit/bb80e9c7a798f035768260ebdadffb6eb0786178,main.c,on_handler_vanished,"static void
on_handler_vanished(GDBusConnection *connection,
const gchar     *name,
gpointer         user_data)
{
struct tcmur_handler *handler = user_data;
struct dbus_info *info = handler->opaque;
if (info->register_invocation) {
char *reason;
reason = g_strdup_printf(""Cannot find handler bus name: ""
""org.kernel.TCMUService1.HandlerManager1.%s"",
handler->subtype);
g_dbus_method_invocation_return_value(info->register_invocation,
g_variant_new(""(bs)"", FALSE, reason));
g_free(reason);
}
tcmur_unregister_handler(handler);
dbus_unexport_handler(handler);
}","static void
on_handler_vanished(GDBusConnection *VAR_0,
const gchar     *VAR_1,
gpointer         VAR_2)
{
struct tcmur_handler *VAR_3 = VAR_2;
struct dbus_info *VAR_4 = VAR_3->opaque;
if (VAR_4->register_invocation) {
char *VAR_5;
VAR_5 = g_strdup_printf(""Cannot find handler bus name: ""
""org.kernel.TCMUService1.HandlerManager1.%s"",
VAR_3->subtype);
g_dbus_method_invocation_return_value(VAR_4->register_invocation,
g_variant_new(""(bs)"", FALSE, VAR_5));
g_free(VAR_5);
}
tcmur_unregister_handler(VAR_3);
dbus_unexport_handler(VAR_3);
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/before/1.json,"static void
on_handler_vanished(GDBusConnection *connection,
		    const gchar     *name,
		    gpointer         user_data)
{
	struct tcmur_handler *handler = user_data;
	struct dbus_info *info = handler->opaque;

	if (info->register_invocation) {
		char *reason;
		reason = g_strdup_printf(""Cannot find handler bus name: ""
				""org.kernel.TCMUService1.HandlerManager1.%s"",
				handler->subtype);
		g_dbus_method_invocation_return_value(info->register_invocation,
			    g_variant_new(""(bs)"", FALSE, reason));
		g_free(reason);
	}
	tcmur_unregister_dbus_handler(handler);
	dbus_unexport_handler(handler);
}","static void
on_handler_vanished(GDBusConnection *VAR_0,
		    const gchar     *VAR_1,
		    gpointer         VAR_2)
{
	struct tcmur_handler *VAR_3 = VAR_2;
	struct dbus_info *VAR_4 = VAR_3->opaque;

	if (VAR_4->register_invocation) {
		char *VAR_5;
		VAR_5 = g_strdup_printf(""Cannot find handler bus name: ""
				""org.kernel.TCMUService1.HandlerManager1.%s"",
				VAR_3->subtype);
		g_dbus_method_invocation_return_value(VAR_4->register_invocation,
			    g_variant_new(""(bs)"", FALSE, VAR_5));
		g_free(VAR_5);
	}
	tcmur_unregister_dbus_handler(VAR_3);
	dbus_unexport_handler(VAR_3);
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -15,6 +15,6 @@
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }","{'deleted_lines': ['\ttcmur_unregister_handler(handler);'], 'added_lines': ['\ttcmur_unregister_dbus_handler(handler);']}",True,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,7.5,HIGH,2,valid,2017-07-14T13:11:54Z,1
CVE-2017-1000200,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,open-iscsi/tcmu-runner,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",bb80e9c7a798f035768260ebdadffb6eb0786178,https://github.com/open-iscsi/tcmu-runner/commit/bb80e9c7a798f035768260ebdadffb6eb0786178,main.c,on_unregister_handler,"static gboolean
on_unregister_handler(TCMUService1HandlerManager1 *interface,
GDBusMethodInvocation *invocation,
gchar *subtype,
gpointer user_data)
{
struct tcmur_handler *handler = find_handler_by_subtype(subtype);
struct dbus_info *info = handler ? handler->opaque : NULL;
if (!handler) {
g_dbus_method_invocation_return_value(invocation,
g_variant_new(""(bs)"", FALSE,
""unknown subtype""));
return TRUE;
}
dbus_unexport_handler(handler);
tcmur_unregister_handler(handler);
g_bus_unwatch_name(info->watcher_id);
g_free(info);
g_free(handler);
g_dbus_method_invocation_return_value(invocation,
g_variant_new(""(bs)"", TRUE, ""succeeded""));
return TRUE;
}","static gboolean
on_unregister_handler(TCMUService1HandlerManager1 *VAR_0,
GDBusMethodInvocation *VAR_1,
gchar *VAR_2,
gpointer VAR_3)
{
struct tcmur_handler *VAR_4 = find_handler_by_subtype(VAR_2);
struct dbus_info *VAR_5 = VAR_4 ? VAR_4->opaque : NULL;
if (!VAR_4) {
g_dbus_method_invocation_return_value(VAR_1,
g_variant_new(""(bs)"", FALSE,
""unknown subtype""));
return TRUE;
}
dbus_unexport_handler(VAR_4);
tcmur_unregister_handler(VAR_4);
g_bus_unwatch_name(VAR_5->watcher_id);
g_free(VAR_5);
g_free(VAR_4);
g_dbus_method_invocation_return_value(VAR_1,
g_variant_new(""(bs)"", TRUE, ""succeeded""));
return TRUE;
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/before/2.json,"static gboolean
on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
				      ""unknown subtype""));
		return TRUE;
	}
	else if (handler->_is_dbus_handler != 1) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
				      ""cannot unregister internal handler""));
		return TRUE;
	}

	dbus_unexport_handler(handler);
	tcmur_unregister_dbus_handler(handler);

	g_bus_unwatch_name(info->watcher_id);
	g_free(info);
	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}","static gboolean
on_unregister_handler(TCMUService1HandlerManager1 *VAR_0,
		      GDBusMethodInvocation *VAR_1,
		      gchar *VAR_2,
		      gpointer VAR_3)
{
	struct tcmur_handler *VAR_4 = find_handler_by_subtype(VAR_2);
	struct dbus_info *VAR_5 = VAR_4 ? VAR_4->opaque : NULL;

	if (!VAR_4) {
		g_dbus_method_invocation_return_value(VAR_1,
			g_variant_new(""(bs)"", FALSE,
				      ""unknown subtype""));
		return TRUE;
	}
	else if (VAR_4->_is_dbus_handler != 1) {
		g_dbus_method_invocation_return_value(VAR_1,
			g_variant_new(""(bs)"", FALSE,
				      ""cannot unregister internal handler""));
		return TRUE;
	}

	dbus_unexport_handler(VAR_4);
	tcmur_unregister_dbus_handler(VAR_4);

	g_bus_unwatch_name(VAR_5->watcher_id);
	g_free(VAR_5);
	g_free(VAR_4);
	g_dbus_method_invocation_return_value(VAR_1,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -13,8 +13,16 @@
 				      ""unknown subtype""));
 		return TRUE;
 	}
+	else if (handler->_is_dbus_handler != 1) {
+		g_dbus_method_invocation_return_value(invocation,
+			g_variant_new(""(bs)"", FALSE,
+				      ""cannot unregister internal handler""));
+		return TRUE;
+	}
+
 	dbus_unexport_handler(handler);
-	tcmur_unregister_handler(handler);
+	tcmur_unregister_dbus_handler(handler);
+
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);","{'deleted_lines': ['\ttcmur_unregister_handler(handler);'], 'added_lines': ['\telse if (handler->_is_dbus_handler != 1) {', '\t\tg_dbus_method_invocation_return_value(invocation,', '\t\t\tg_variant_new(""(bs)"", FALSE,', '\t\t\t\t      ""cannot unregister internal handler""));', '\t\treturn TRUE;', '\t}', '', '\ttcmur_unregister_dbus_handler(handler);', '']}",True,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,7.5,HIGH,2,valid,2017-07-14T13:11:54Z,1
CVE-2017-1000200,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,open-iscsi/tcmu-runner,"only allow dynamic UnregisterHandler for external handlers, thereby fixing DoS

Trying to unregister an internal handler ended up in a SEGFAULT, because
the tcmur_handler->opaque was NULL. Way to reproduce:

dbus-send --system --print-reply --dest=org.kernel.TCMUService1 /org/kernel/TCMUService1/HandlerManager1 org.kernel.TCMUService1.HandlerManager1.UnregisterHandler string:qcow

we use a newly introduced boolean in struct tcmur_handler for keeping
track of external handlers. As suggested by mikechristie adjusting the
public data structure is acceptable.",bb80e9c7a798f035768260ebdadffb6eb0786178,https://github.com/open-iscsi/tcmu-runner/commit/bb80e9c7a798f035768260ebdadffb6eb0786178,main.c,on_register_handler,"static gboolean
on_register_handler(TCMUService1HandlerManager1 *interface,
GDBusMethodInvocation *invocation,
gchar *subtype,
gchar *cfg_desc,
gpointer user_data)
{
struct tcmur_handler *handler;
struct dbus_info *info;
char *bus_name;
bus_name = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
subtype);
handler               = g_new0(struct tcmur_handler, 1);
handler->subtype      = g_strdup(subtype);
handler->cfg_desc     = g_strdup(cfg_desc);
handler->open         = dbus_handler_open;
handler->close        = dbus_handler_close;
handler->handle_cmd   = dbus_handler_handle_cmd;
info = g_new0(struct dbus_info, 1);
info->register_invocation = invocation;
info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
bus_name,
G_BUS_NAME_WATCHER_FLAGS_NONE,
on_handler_appeared,
on_handler_vanished,
handler,
NULL);
g_free(bus_name);
handler->opaque = info;
return TRUE;
}","static gboolean
on_register_handler(TCMUService1HandlerManager1 *VAR_0,
GDBusMethodInvocation *VAR_1,
gchar *VAR_2,
gchar *VAR_3,
gpointer VAR_4)
{
struct tcmur_handler *VAR_5;
struct dbus_info *VAR_6;
char *VAR_7;
VAR_7 = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
VAR_2);
VAR_5               = g_new0(struct tcmur_handler, 1);
VAR_5->subtype      = g_strdup(VAR_2);
VAR_5->cfg_desc     = g_strdup(VAR_3);
VAR_5->open         = VAR_8;
VAR_5->close        = VAR_9;
VAR_5->handle_cmd   = VAR_10;
VAR_6 = g_new0(struct dbus_info, 1);
VAR_6->register_invocation = VAR_1;
VAR_6->watcher_id = g_bus_watch_name(VAR_11,
VAR_7,
VAR_12,
VAR_13,
VAR_14,
VAR_5,
NULL);
g_free(VAR_7);
VAR_5->opaque = VAR_6;
return TRUE;
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/before/3.json,"static gboolean
on_register_handler(TCMUService1HandlerManager1 *interface,
		    GDBusMethodInvocation *invocation,
		    gchar *subtype,
		    gchar *cfg_desc,
		    gpointer user_data)
{
	struct tcmur_handler *handler;
	struct dbus_info *info;
	char *bus_name;

	bus_name = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
				   subtype);

	handler               = g_new0(struct tcmur_handler, 1);
	handler->subtype      = g_strdup(subtype);
	handler->cfg_desc     = g_strdup(cfg_desc);
	handler->open         = dbus_handler_open;
	handler->close        = dbus_handler_close;
	handler->handle_cmd   = dbus_handler_handle_cmd;

	info = g_new0(struct dbus_info, 1);
	handler->opaque = info;
	handler->_is_dbus_handler = 1;
	info->register_invocation = invocation;
	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
					    bus_name,
					    G_BUS_NAME_WATCHER_FLAGS_NONE,
					    on_handler_appeared,
					    on_handler_vanished,
					    handler,
					    NULL);
	g_free(bus_name);
	handler->opaque = info;
	return TRUE;
}","static gboolean
on_register_handler(TCMUService1HandlerManager1 *VAR_0,
		    GDBusMethodInvocation *VAR_1,
		    gchar *VAR_2,
		    gchar *VAR_3,
		    gpointer VAR_4)
{
	struct tcmur_handler *VAR_5;
	struct dbus_info *VAR_6;
	char *VAR_7;

	VAR_7 = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"",
				   VAR_2);

	VAR_5               = g_new0(struct tcmur_handler, 1);
	VAR_5->subtype      = g_strdup(VAR_2);
	VAR_5->cfg_desc     = g_strdup(VAR_3);
	VAR_5->open         = VAR_8;
	VAR_5->close        = VAR_9;
	VAR_5->handle_cmd   = VAR_10;

	VAR_6 = g_new0(struct dbus_info, 1);
	VAR_5->opaque = VAR_6;
	VAR_5->_is_dbus_handler = 1;
	VAR_6->register_invocation = VAR_1;
	VAR_6->watcher_id = g_bus_watch_name(VAR_11,
					    VAR_7,
					    VAR_12,
					    VAR_13,
					    VAR_14,
					    VAR_5,
					    NULL);
	g_free(VAR_7);
	VAR_5->opaque = VAR_6;
	return TRUE;
}",open-iscsi/tcmu-runner/bb80e9c7a798f035768260ebdadffb6eb0786178/main.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -20,6 +20,8 @@
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
+	handler->opaque = info;
+	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,","{'deleted_lines': [], 'added_lines': ['\thandler->opaque = info;', '\thandler->_is_dbus_handler = 1;']}",True,tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service,7.5,HIGH,2,valid,2017-07-14T13:11:54Z,1
