cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2017-11644,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/587,418f88dd18af34b6cb64f709567c81b89865d7bc,https://github.com/ImageMagick/ImageMagick/commit/418f88dd18af34b6cb64f709567c81b89865d7bc,coders/mat.c,ReadMATImage,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image *image, *image2=NULL,
*rotated_image;
PixelPacket *q;
unsigned int status;
MATHeader MATLAB_HDR;
size_t size;
size_t CellType;
QuantumInfo *quantum_info;
ImageInfo *clone_info;
int i;
ssize_t ldblk;
unsigned char *BImgBuff = NULL;
double MinVal, MaxVal;
size_t Unknown6;
unsigned z, z2;
unsigned Frames;
int logging;
int sample_size;
MagickOffsetType filepos=0x80;
BlobInfo *blob;
size_t one;
unsigned int (*ReadBlobXXXLong)(Image *image);
unsigned short (*ReadBlobXXXShort)(Image *image);
void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
quantum_info=(QuantumInfo *) NULL;
image = AcquireImage(image_info);
status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
clone_info=(ImageInfo *) NULL;
if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
{
image2=ReadMATImageV4(image_info,image,exception);
if (image2  == NULL)
goto MATLAB_KO;
image=image2;
goto END_OF_READING;
}
MATLAB_HDR.Version = ReadBlobLSBShort(image);
if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
{
ReadBlobXXXLong = ReadBlobLSBLong;
ReadBlobXXXShort = ReadBlobLSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesLSB;
ReadBlobFloatsXXX = ReadBlobFloatsLSB;
image->endian = LSBEndian;
}
else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
{
ReadBlobXXXLong = ReadBlobMSBLong;
ReadBlobXXXShort = ReadBlobMSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesMSB;
ReadBlobFloatsXXX = ReadBlobFloatsMSB;
image->endian = MSBEndian;
}
else
goto MATLAB_KO;    
if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
{
MATLAB_KO:
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
filepos = TellBlob(image);
while(!EOFBlob(image)) 
{
Frames = 1;
(void) SeekBlob(image,filepos,SEEK_SET);
MATLAB_HDR.DataType = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
goto MATLAB_KO;
filepos += MATLAB_HDR.ObjectSize + 4 + 4;
clone_info=CloneImageInfo(image_info);
image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
if(MATLAB_HDR.DataType == miCOMPRESSED)
{
image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
if(image2==NULL) continue;
MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
}
#endif
if(MATLAB_HDR.DataType!=miMATRIX) continue;  
MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
if(image!=image2)
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
switch(MATLAB_HDR.DimFlag)
{
case  8: z2=z=1; break;      
case 12: z2=z = ReadBlobXXXLong(image2);  
Unknown6 = ReadBlobXXXLong(image2);
(void) Unknown6;
if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: z2=z = ReadBlobXXXLong(image2);  
if(z!=3 && z!=1)
ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
Frames = ReadBlobXXXLong(image2);
if (Frames == 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
break;
default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
}
MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
MATLAB_HDR.StructureClass != mxINT8_CLASS &&
MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
MATLAB_HDR.StructureClass != mxINT16_CLASS &&
MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
MATLAB_HDR.StructureClass != mxINT32_CLASS &&
MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
MATLAB_HDR.StructureClass != mxINT64_CLASS &&
MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
switch (MATLAB_HDR.NameFlag)
{
case 0:
size = ReadBlobXXXLong(image2);  
size = 4 * (ssize_t) ((size + 3 + 1) / 4);
(void) SeekBlob(image2, size, SEEK_CUR);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(image2, 4, (unsigned char *) &size); 
break;
default:
goto MATLAB_KO;
}
CellType = ReadBlobXXXLong(image2);    
if (logging)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) CellType);
(void) ReadBlob(image2, 4, (unsigned char *) &size);     
NEXT_FRAME:
switch (CellType)
{
case miINT8:
case miUINT8:
sample_size = 8;
if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
image->depth = 1;
else
image->depth = 8;         
ldblk = (ssize_t) MATLAB_HDR.SizeX;
break;
case miINT16:
case miUINT16:
sample_size = 16;
image->depth = 16;        
ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
break;
case miINT32:
case miUINT32:
sample_size = 32;
image->depth = 32;        
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miINT64:
case miUINT64:
sample_size = 64;
image->depth = 64;        
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
case miSINGLE:
sample_size = 32;
image->depth = 32;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{              
}
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miDOUBLE:
sample_size = 64;
image->depth = 64;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
RestoreMSCWarning
ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{                         
}
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
default:
ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
}
(void) sample_size;
image->columns = MATLAB_HDR.SizeX;
image->rows = MATLAB_HDR.SizeY;
one=1;
image->colors = one << image->depth;
if (image->columns == 0 || image->rows == 0)
goto MATLAB_KO;
if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
goto MATLAB_KO;
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
{
SetImageColorspace(image,GRAYColorspace);
image->type=GrayscaleType;
}
if (image_info->ping)
{
size_t temp = image->columns;
image->columns = image->rows;
image->rows = temp;
goto done_reading; 
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
quantum_info=AcquireQuantumInfo(clone_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
if (BImgBuff == NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
MinVal = 0;
MaxVal = 0;
if (CellType==miDOUBLE || CellType==miSINGLE)        
{
CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
}
if(z==1) z=0; 
do
{
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto done_reading;    
}
if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
{
FixLogical((unsigned char *)BImgBuff,ldblk);
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
{
ImportQuantumPixelsFailed:
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
break;
}
}
else
{
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
goto ImportQuantumPixelsFailed;
if (z<=1 &&       
(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
FixSignedValues(q,MATLAB_HDR.SizeX);
}
if (!SyncAuthenticPixels(image,exception))
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
}
} while(z-- >= 2);
ExitLoop:
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{        
CellType = ReadBlobXXXLong(image2);    
i = ReadBlobXXXLong(image2);           
if (CellType==miDOUBLE || CellType==miSINGLE)
{
CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
}
if (CellType==miDOUBLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
}
if (CellType==miSINGLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
}
}
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
image->type=GrayscaleType;
if (image->depth == 1)
image->type=BilevelType;
if(image2==image)
image2 = NULL;    
rotated_image = RotateImage(image, 90.0, exception);
if (rotated_image != (Image *) NULL)
{
rotated_image->page.x=0;
rotated_image->page.y=0;
blob = rotated_image->blob;
rotated_image->blob = image->blob;
rotated_image->colors = image->colors;
image->blob = blob;
AppendImageToList(&image,rotated_image);
DeleteImageFromList(&image);
}
done_reading:
if(image2!=NULL)
if(image2!=image)
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
}
}
AcquireNextImage(image_info,image);
if (image->next == (Image *) NULL) break;
image=SyncNextImageInList(image);
image->columns=image->rows=0;
image->colors=0;
RelinquishMagickMemory(BImgBuff);
BImgBuff = NULL;
if(--Frames>0)
{
z = z2;
if(image2==NULL) image2 = image;
goto NEXT_FRAME;
}
if(image2!=NULL)
if(image2!=image)   
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) unlink(clone_info->filename);
}
}
}
}
RelinquishMagickMemory(BImgBuff);
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
CloseBlob(image);
{
Image *p;
ssize_t scene=0;
p=image;
image=NULL;
while (p != (Image *) NULL)
{
Image *tmp=p;
if ((p->rows == 0) || (p->columns == 0)) {
p=p->previous;
DeleteImageFromList(&tmp);
} else {
image=p;
p=p->previous;
}
}
for (p=image; p != (Image *) NULL; p=p->next)
p->scene=scene++;
}
if(clone_info != NULL)  
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
DestroyImageInfo(clone_info);
clone_info = NULL;
}
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
if(image==NULL)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image *VAR_2, *VAR_3=NULL,
*VAR_4;
PixelPacket *VAR_5;
unsigned int VAR_6;
MATHeader VAR_7;
size_t VAR_8;
size_t VAR_9;
QuantumInfo *VAR_10;
ImageInfo *VAR_11;
int VAR_12;
ssize_t VAR_13;
unsigned char *VAR_14 = NULL;
double VAR_15, VAR_16;
size_t VAR_17;
unsigned VAR_18, VAR_19;
unsigned VAR_20;
int VAR_21;
int VAR_22;
MagickOffsetType VAR_23=0x80;
BlobInfo *VAR_24;
size_t VAR_25;
unsigned int (*VAR_26)(Image *VAR_2);
unsigned short (*VAR_27)(Image *VAR_2);
void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_32);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_32);
VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");
VAR_10=(QuantumInfo *) NULL;
VAR_2 = AcquireImage(VAR_0);
VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
if (VAR_6 == VAR_35)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_11=(ImageInfo *) NULL;
if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
{
VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
if (VAR_3  == NULL)
goto MATLAB_KO;
VAR_2=VAR_3;
goto END_OF_READING;
}
VAR_7.Version = ReadBlobLSBShort(VAR_2);
if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
{
VAR_26 = VAR_37;
VAR_27 = VAR_38;
VAR_28 = VAR_39;
VAR_31 = VAR_40;
VAR_2->endian = VAR_41;
}
else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
{
VAR_26 = VAR_42;
VAR_27 = VAR_43;
VAR_28 = VAR_44;
VAR_31 = VAR_45;
VAR_2->endian = VAR_46;
}
else
goto MATLAB_KO;    
if (strncmp(VAR_7.identific, ""MATLAB"", 6))
{
MATLAB_KO:
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_36,""ImproperImageHeader"");
}
VAR_23 = TellBlob(VAR_2);
while(!EOFBlob(VAR_2)) 
{
VAR_20 = 1;
(void) SeekBlob(VAR_2,VAR_23,VAR_47);
VAR_7.DataType = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
VAR_7.ObjectSize = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))
goto MATLAB_KO;
VAR_23 += VAR_7.ObjectSize + 4 + 4;
VAR_11=CloneImageInfo(VAR_0);
VAR_3 = VAR_2;
#if defined(VAR_49)
if(VAR_7.DataType == VAR_50)
{
VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
if(VAR_3==NULL) continue;
VAR_7.DataType = VAR_26(VAR_3); 
}
#endif
if(VAR_7.DataType!=VAR_51) continue;  
VAR_7.unknown1 = VAR_26(VAR_3);
VAR_7.unknown2 = VAR_26(VAR_3);
VAR_7.unknown5 = VAR_26(VAR_3);
VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;
VAR_7.unknown3 = VAR_26(VAR_3);
if(VAR_2!=VAR_3)
VAR_7.unknown4 = VAR_26(VAR_3);  
VAR_7.unknown4 = VAR_26(VAR_3);
VAR_7.DimFlag = VAR_26(VAR_3);
VAR_7.SizeX = VAR_26(VAR_3);
VAR_7.SizeY = VAR_26(VAR_3);
switch(VAR_7.DimFlag)
{
case  8: VAR_19=VAR_18=1; break;      
case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  
VAR_17 = VAR_26(VAR_3);
(void) VAR_17;
if(VAR_18!=3) ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  
if(VAR_18!=3 && VAR_18!=1)
ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
VAR_20 = VAR_26(VAR_3);
if (VAR_20 == 0)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
break;
default: ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
}
VAR_7.Flag1 = VAR_27(VAR_3);
VAR_7.NameFlag = VAR_27(VAR_3);
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
if (VAR_7.StructureClass != VAR_53 &&
VAR_7.StructureClass != VAR_54 &&    
VAR_7.StructureClass != VAR_55 &&    
VAR_7.StructureClass != VAR_56 &&
VAR_7.StructureClass != VAR_57 &&    
VAR_7.StructureClass != VAR_58 &&
VAR_7.StructureClass != VAR_59 &&    
VAR_7.StructureClass != VAR_60 &&
VAR_7.StructureClass != VAR_61 &&    
VAR_7.StructureClass != VAR_62 &&
VAR_7.StructureClass != VAR_63)    
ThrowReaderException(VAR_52,""UnsupportedCellTypeInTheMatrix"");
switch (VAR_7.NameFlag)
{
case 0:
VAR_8 = VAR_26(VAR_3);  
VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
(void) SeekBlob(VAR_3, VAR_8, VAR_64);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); 
break;
default:
goto MATLAB_KO;
}
VAR_9 = VAR_26(VAR_3);    
if (VAR_21)
(void) LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     
NEXT_FRAME:
switch (VAR_9)
{
case VAR_65:
case VAR_66:
VAR_22 = 8;
if(VAR_7.StructureFlag & VAR_67)
VAR_2->depth = 1;
else
VAR_2->depth = 8;         
VAR_13 = (ssize_t) VAR_7.SizeX;
break;
case VAR_68:
case VAR_69:
VAR_22 = 16;
VAR_2->depth = 16;        
VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
break;
case VAR_70:
case VAR_71:
VAR_22 = 32;
VAR_2->depth = 32;        
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_72:
case VAR_73:
VAR_22 = 64;
VAR_2->depth = 64;        
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
case VAR_74:
VAR_22 = 32;
VAR_2->depth = 32;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
if (VAR_7.StructureFlag & VAR_75)
{              
}
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_76:
VAR_22 = 64;
VAR_2->depth = 64;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
VAR_77
ThrowReaderException(VAR_52, ""IncompatibleSizeOfDouble"");
if (VAR_7.StructureFlag & VAR_75)
{                         
}
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
default:
ThrowReaderException(VAR_52, ""UnsupportedCellTypeInTheMatrix"");
}
(void) VAR_22;
VAR_2->columns = VAR_7.SizeX;
VAR_2->rows = VAR_7.SizeY;
VAR_25=1;
VAR_2->colors = VAR_25 << VAR_2->depth;
if (VAR_2->columns == 0 || VAR_2->rows == 0)
goto MATLAB_KO;
if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
goto MATLAB_KO;
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_75) == 0))
{
SetImageColorspace(VAR_2,VAR_78);
VAR_2->type=VAR_79;
}
if (VAR_0->ping)
{
size_t VAR_80 = VAR_2->columns;
VAR_2->columns = VAR_2->rows;
VAR_2->rows = VAR_80;
goto done_reading; 
}
VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
if (VAR_6 == VAR_35)
{
InheritException(VAR_1,&VAR_2->exception);
return(DestroyImageList(VAR_2));
}
VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
if (VAR_10 == (QuantumInfo *) NULL)
ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    
if (VAR_14 == NULL)
ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
(void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));
VAR_15 = 0;
VAR_16 = 0;
if (VAR_9==VAR_76 || VAR_9==VAR_74)        
{
CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
}
if(VAR_18==1) VAR_18=0; 
do
{
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
if (VAR_5 == (PixelPacket *) NULL)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto done_reading;    
}
if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))
{
FixLogical((unsigned char *)VAR_14,VAR_13);
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
{
ImportQuantumPixelsFailed:
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
break;
}
}
else
{
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
goto ImportQuantumPixelsFailed;
if (VAR_18<=1 &&       
(VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))
FixSignedValues(VAR_5,VAR_7.SizeX);
}
if (!SyncAuthenticPixels(VAR_2,VAR_1))
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
}
} while(VAR_18-- >= 2);
ExitLoop:
if (VAR_7.StructureFlag & VAR_75)
{        
VAR_9 = VAR_26(VAR_3);    
VAR_12 = VAR_26(VAR_3);           
if (VAR_9==VAR_76 || VAR_9==VAR_74)
{
CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
}
if (VAR_9==VAR_76)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_28(VAR_3, VAR_13, (double *)VAR_14);
InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
if (VAR_9==VAR_74)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_31(VAR_3, VAR_13, (float *)VAR_14);
InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
}
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_75) == 0))
VAR_2->type=VAR_79;
if (VAR_2->depth == 1)
VAR_2->type=VAR_83;
if(VAR_3==VAR_2)
VAR_3 = NULL;    
VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
if (VAR_4 != (Image *) NULL)
{
VAR_4->page.x=0;
VAR_4->page.y=0;
VAR_24 = VAR_4->blob;
VAR_4->blob = VAR_2->blob;
VAR_4->colors = VAR_2->colors;
VAR_2->blob = VAR_24;
AppendImageToList(&VAR_2,VAR_4);
DeleteImageFromList(&VAR_2);
}
done_reading:
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
}
}
AcquireNextImage(VAR_0,VAR_2);
if (VAR_2->next == (Image *) NULL) break;
VAR_2=SyncNextImageInList(VAR_2);
VAR_2->columns=VAR_2->rows=0;
VAR_2->colors=0;
RelinquishMagickMemory(VAR_14);
VAR_14 = NULL;
if(--VAR_20>0)
{
VAR_18 = VAR_19;
if(VAR_3==NULL) VAR_3 = VAR_2;
goto NEXT_FRAME;
}
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)   
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) unlink(VAR_11->filename);
}
}
}
}
RelinquishMagickMemory(VAR_14);
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
CloseBlob(VAR_2);
{
Image *VAR_84;
ssize_t VAR_85=0;
VAR_84=VAR_2;
VAR_2=NULL;
while (VAR_84 != (Image *) NULL)
{
Image *VAR_86=VAR_84;
if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {
VAR_84=VAR_84->previous;
DeleteImageFromList(&VAR_86);
} else {
VAR_2=VAR_84;
VAR_84=VAR_84->previous;
}
}
for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)
VAR_84->scene=VAR_85++;
}
if(VAR_11 != NULL)  
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
DestroyImageInfo(VAR_11);
VAR_11 = NULL;
}
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
if(VAR_2==NULL)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
return (VAR_2);
}",ImageMagick/418f88dd18af34b6cb64f709567c81b89865d7bc/mat.c/vul/before/0.json,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  quantum_info=(QuantumInfo *) NULL;
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=(ImageInfo *) NULL;
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
      /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if ((image != image2) && (image2 != (Image *) NULL))
    image2=DestroyImage(image2);
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image *VAR_2, *VAR_3=NULL,
   *VAR_4;
  PixelPacket *VAR_5;

  unsigned int VAR_6;
  MATHeader VAR_7;
  size_t VAR_8;
  size_t VAR_9;
  QuantumInfo *VAR_10;
  ImageInfo *VAR_11;
  int VAR_12;
  ssize_t VAR_13;
  unsigned char *VAR_14 = NULL;
  double VAR_15, VAR_16;
  size_t VAR_17;
  unsigned VAR_18, VAR_19;
  unsigned VAR_20;
  int VAR_21;
  int VAR_22;
  MagickOffsetType VAR_23=0x80;
  BlobInfo *VAR_24;
  size_t VAR_25;

  unsigned int (*VAR_26)(Image *VAR_2);
  unsigned short (*VAR_27)(Image *VAR_2);
  void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
  void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);


  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_32);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_32);
  VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");

  /* COMMENT_0 */
                     
     
  VAR_10=(QuantumInfo *) NULL;
  VAR_2 = AcquireImage(VAR_0);

  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
  if (VAR_6 == VAR_35)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                       
     
  VAR_11=(ImageInfo *) NULL;
  if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
    {
      VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
      if (VAR_3  == NULL)
        goto MATLAB_KO;
      VAR_2=VAR_3;
      goto END_OF_READING;
    }
  VAR_7.Version = ReadBlobLSBShort(VAR_2);
  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");

  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
        VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
  if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
  {
    VAR_26 = VAR_37;
    VAR_27 = VAR_38;
    VAR_28 = VAR_39;
    VAR_31 = VAR_40;
    VAR_2->endian = VAR_41;
  }
  else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
  {
    VAR_26 = VAR_42;
    VAR_27 = VAR_43;
    VAR_28 = VAR_44;
    VAR_31 = VAR_45;
    VAR_2->endian = VAR_46;
  }
  else
    goto MATLAB_KO;    /* COMMENT_6 */

  if (strncmp(VAR_7.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      VAR_11=DestroyImageInfo(VAR_11);
      ThrowReaderException(VAR_36,""ImproperImageHeader"");
    }

  VAR_23 = TellBlob(VAR_2);
  while(!EOFBlob(VAR_2)) /* COMMENT_7 */
  {
    VAR_20 = 1;
    (void) SeekBlob(VAR_2,VAR_23,VAR_47);
    /* COMMENT_8 */

    VAR_7.DataType = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    VAR_7.ObjectSize = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))
      goto MATLAB_KO;
    VAR_23 += VAR_7.ObjectSize + 4 + 4;

    VAR_11=CloneImageInfo(VAR_0);
    VAR_3 = VAR_2;
#if defined(VAR_49)
    if(VAR_7.DataType == VAR_50)
    {
      VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
      if(VAR_3==NULL) continue;
      VAR_7.DataType = VAR_26(VAR_3); /* COMMENT_9 */
    }
#endif

    if(VAR_7.DataType!=VAR_51) continue;  /* COMMENT_10 */

    VAR_7.unknown1 = VAR_26(VAR_3);
    VAR_7.unknown2 = VAR_26(VAR_3);

    VAR_7.unknown5 = VAR_26(VAR_3);
    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;

    VAR_7.unknown3 = VAR_26(VAR_3);
    if(VAR_2!=VAR_3)
      VAR_7.unknown4 = VAR_26(VAR_3);  /* COMMENT_11 */
    VAR_7.unknown4 = VAR_26(VAR_3);
    VAR_7.DimFlag = VAR_26(VAR_3);
    VAR_7.SizeX = VAR_26(VAR_3);
    VAR_7.SizeY = VAR_26(VAR_3);


    switch(VAR_7.DimFlag)
    {
      case  8: VAR_19=VAR_18=1; break;      /* COMMENT_12 */
      case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_13 */
           VAR_17 = VAR_26(VAR_3);
           (void) VAR_17;
         if(VAR_18!=3) ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_14 */
         if(VAR_18!=3 && VAR_18!=1)
           ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
         VAR_20 = VAR_26(VAR_3);
         if (VAR_20 == 0)
           ThrowReaderException(VAR_36,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
    }

    VAR_7.Flag1 = VAR_27(VAR_3);
    VAR_7.NameFlag = VAR_27(VAR_3);

    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
    if (VAR_7.StructureClass != VAR_53 &&
        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_15 */
        VAR_7.StructureClass != VAR_55 &&    /* COMMENT_16 */
        VAR_7.StructureClass != VAR_56 &&
        VAR_7.StructureClass != VAR_57 &&    /* COMMENT_17 */
        VAR_7.StructureClass != VAR_58 &&
        VAR_7.StructureClass != VAR_59 &&    /* COMMENT_18 */
        VAR_7.StructureClass != VAR_60 &&
        VAR_7.StructureClass != VAR_61 &&    /* COMMENT_19 */
        VAR_7.StructureClass != VAR_62 &&
        VAR_7.StructureClass != VAR_63)    /* COMMENT_20 */
      ThrowReaderException(VAR_52,""UnsupportedCellTypeInTheMatrix"");

    switch (VAR_7.NameFlag)
    {
      case 0:
        VAR_8 = VAR_26(VAR_3);  /* COMMENT_21 */
        VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
        (void) SeekBlob(VAR_3, VAR_8, VAR_64);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_22 */
        break;
      default:
        goto MATLAB_KO;
    }

    VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
    if (VAR_21)
      (void) LogMagickEvent(VAR_33,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);

    (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     /* COMMENT_24 */

NEXT_FRAME:
    switch (VAR_9)
    {
      case VAR_65:
      case VAR_66:
        VAR_22 = 8;
        if(VAR_7.StructureFlag & VAR_67)
          VAR_2->depth = 1;
        else
          VAR_2->depth = 8;         /* COMMENT_25 */
        VAR_13 = (ssize_t) VAR_7.SizeX;
        break;
      case VAR_68:
      case VAR_69:
        VAR_22 = 16;
        VAR_2->depth = 16;        /* COMMENT_26 */
        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
        break;
      case VAR_70:
      case VAR_71:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_27 */
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_72:
      case VAR_73:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_28 */
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      case VAR_74:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
        if (VAR_7.StructureFlag & VAR_75)
  {              /* COMMENT_30 */
  }
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_76:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
VAR_77
          ThrowReaderException(VAR_52, ""IncompatibleSizeOfDouble"");
        if (VAR_7.StructureFlag & VAR_75)
  {                         /* COMMENT_31 */
  }
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      default:
        ThrowReaderException(VAR_52, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) VAR_22;
    VAR_2->columns = VAR_7.SizeX;
    VAR_2->rows = VAR_7.SizeY;
    VAR_25=1;
    VAR_2->colors = VAR_25 << VAR_2->depth;
    if (VAR_2->columns == 0 || VAR_2->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
      goto MATLAB_KO;
      /* COMMENT_32 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_75) == 0))
      {
        SetImageColorspace(VAR_2,VAR_78);
        VAR_2->type=VAR_79;
      }


    /* COMMENT_33 */
                                                                  
                             
      
    if (VAR_0->ping)
    {
      size_t VAR_80 = VAR_2->columns;
      VAR_2->columns = VAR_2->rows;
      VAR_2->rows = VAR_80;
      goto done_reading; /* COMMENT_37 */
    }
    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
    if (VAR_6 == VAR_35)
      {
        InheritException(VAR_1,&VAR_2->exception);
        return(DestroyImageList(VAR_2));
      }
    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
    if (VAR_10 == (QuantumInfo *) NULL)
      ThrowReaderException(VAR_81,""MemoryAllocationFailed"");

  /* COMMENT_38 */
    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_39 */
    if (VAR_14 == NULL)
      ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));

    VAR_15 = 0;
    VAR_16 = 0;
    if (VAR_9==VAR_76 || VAR_9==VAR_74)        /* COMMENT_40 */
    {
      CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
    }

    /* COMMENT_41 */
    if(VAR_18==1) VAR_18=0; /* COMMENT_42 */
    /* COMMENT_43 */
    do
    {
      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
      {
        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
        if (VAR_5 == (PixelPacket *) NULL)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto done_reading;    /* COMMENT_44 */
  }
        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
        if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))
        {
          FixLogical((unsigned char *)VAR_14,VAR_13);
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
    {
ImportQuantumPixelsFailed:
      if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
      goto ImportQuantumPixelsFailed;


          if (VAR_18<=1 &&       /* COMMENT_45 */
          (VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))
      FixSignedValues(VAR_5,VAR_7.SizeX);
        }

        if (!SyncAuthenticPixels(VAR_2,VAR_1))
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
      }
    } while(VAR_18-- >= 2);
ExitLoop:


    /* COMMENT_46 */
    if (VAR_7.StructureFlag & VAR_75)
    {        /* COMMENT_47 */
      VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
      VAR_12 = VAR_26(VAR_3);           /* COMMENT_48 */

      if (VAR_9==VAR_76 || VAR_9==VAR_74)
      {
        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
      }

      if (VAR_9==VAR_76)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_28(VAR_3, VAR_13, (double *)VAR_14);
          InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }

      if (VAR_9==VAR_74)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_31(VAR_3, VAR_13, (float *)VAR_14);
          InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }
    }

      /* COMMENT_49 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_75) == 0))
      VAR_2->type=VAR_79;
    if (VAR_2->depth == 1)
      VAR_2->type=VAR_83;

    if(VAR_3==VAR_2)
        VAR_3 = NULL;    /* COMMENT_50 */

      /* COMMENT_51 */
    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
    if (VAR_4 != (Image *) NULL)
    {
        /* COMMENT_52 */
      VAR_4->page.x=0;
      VAR_4->page.y=0;

      VAR_24 = VAR_4->blob;
      VAR_4->blob = VAR_2->blob;
      VAR_4->colors = VAR_2->colors;
      VAR_2->blob = VAR_24;
      AppendImageToList(&VAR_2,VAR_4);
      DeleteImageFromList(&VAR_2);
    }

done_reading:

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)
      {
        DeleteImageFromList(&VAR_3);
  if(VAR_11)
  {
          if(VAR_11->file)
    {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) remove_utf8(VAR_11->filename);
    }
        }
      }

      /* COMMENT_53 */
    AcquireNextImage(VAR_0,VAR_2);
    if (VAR_2->next == (Image *) NULL) break;
    VAR_2=SyncNextImageInList(VAR_2);
    VAR_2->columns=VAR_2->rows=0;
    VAR_2->colors=0;

      /* COMMENT_54 */
    RelinquishMagickMemory(VAR_14);
    VAR_14 = NULL;

    if(--VAR_20>0)
    {
      VAR_18 = VAR_19;
      if(VAR_3==NULL) VAR_3 = VAR_2;
      goto NEXT_FRAME;
    }

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)   /* COMMENT_55 */
      {
/* COMMENT_56 */
        DeleteImageFromList(&VAR_3);
        if(VAR_11)
        {
          if(VAR_11->file)
          {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) unlink(VAR_11->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(VAR_14);
  if (VAR_10 != (QuantumInfo *) NULL)
    VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
  if (VAR_11)
    VAR_11=DestroyImageInfo(VAR_11);
  CloseBlob(VAR_2);


  {
    Image *VAR_84;
    ssize_t VAR_85=0;

    /* COMMENT_57 */
                                                             
      
    VAR_84=VAR_2;
    VAR_2=NULL;
    while (VAR_84 != (Image *) NULL)
      {
        Image *VAR_86=VAR_84;
        if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {
          VAR_84=VAR_84->previous;
          DeleteImageFromList(&VAR_86);
        } else {
          VAR_2=VAR_84;
          VAR_84=VAR_84->previous;
        }
      }

    /* COMMENT_60 */
                       
      
    for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)
      VAR_84->scene=VAR_85++;
  }

  if(VAR_11 != NULL)  /* COMMENT_63 */
  {
    if(VAR_11->file)
    {
      fclose(VAR_11->file);
      VAR_11->file = NULL;
      (void) remove_utf8(VAR_11->filename);
    }
    DestroyImageInfo(VAR_11);
    VAR_11 = NULL;
  }
  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
  if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
    VAR_3=DestroyImage(VAR_3);
  if(VAR_2==NULL)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  return (VAR_2);
}",ImageMagick/418f88dd18af34b6cb64f709567c81b89865d7bc/mat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -510,6 +510,8 @@
     clone_info = NULL;
   }
   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
+  if ((image != image2) && (image2 != (Image *) NULL))
+    image2=DestroyImage(image2);
   if(image==NULL)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   return (image);","{'deleted_lines': [], 'added_lines': ['  if ((image != image2) && (image2 != (Image *) NULL))', '    image2=DestroyImage(image2);']}",True,"When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a Memory Leak in the ReadMATImage() function in coders/mat.c.",6.5,MEDIUM,1,test,2017-07-18T22:28:49Z,2
CVE-2015-9252,['CWE-399'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,qpdf,"Detect recursion loops resolving objects (fixes #51)

During parsing of an object, sometimes parts of the object have to be
resolved. An example is stream lengths. If such an object directly or
indirectly points to the object being parsed, it can cause an infinite
loop. Guard against all cases of re-entrant resolution of objects.",701b518d5c56a1449825a3a37a716c58e05e1c3e,https://github.com/qpdf/qpdf/commit/701b518d5c56a1449825a3a37a716c58e05e1c3e,libqpdf/QPDF.cc,QPDF::resolve,"PointerHolder<QPDFObject>
QPDF::resolve(int objid, int generation)
{
QPDFObjGen og(objid, generation);
if (! this->obj_cache.count(og))
{
if (! this->xref_table.count(og))
{
return new QPDF_Null;
}
QPDFXRefEntry const& entry = this->xref_table[og];
switch (entry.getType())
{
case 1:
{
qpdf_offset_t offset = entry.getOffset();
int aobjid;
int ageneration;
QPDFObjectHandle oh =
readObjectAtOffset(true, offset, """", objid, generation,
aobjid, ageneration);
}
break;
case 2:
resolveObjectsInStream(entry.getObjStreamNumber());
break;
default:
throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), """", 0,
""object "" +
QUtil::int_to_string(objid) + ""/"" +
QUtil::int_to_string(generation) +
"" has unexpected xref entry type"");
}
}
return this->obj_cache[og].object;
}","PointerHolder<QPDFObject>
QPDF::resolve(int VAR_0, int VAR_1)
{
QPDFObjGen og(objid, generation);
if (! this->obj_cache.count(VAR_2))
{
if (! this->xref_table.count(VAR_2))
{
return new QPDF_Null;
}
QPDFXRefEntry const& VAR_3 = this->xref_table[VAR_2];
switch (VAR_3.getType())
{
case 1:
{
qpdf_offset_t VAR_4 = VAR_3.getOffset();
int VAR_5;
int VAR_6;
QPDFObjectHandle VAR_7 =
readObjectAtOffset(true, VAR_4, """", objid, generation,
VAR_5, VAR_6);
}
break;
case 2:
resolveObjectsInStream(VAR_3.getObjStreamNumber());
break;
default:
throw QPDFExc(VAR_8, this->file->getName(), """", 0,
""object "" +
QUtil::int_to_string(objid) + ""/"" +
QUtil::int_to_string(generation) +
"" has unexpected xref entry type"");
}
}
return this->obj_cache[VAR_2].object;
}",qpdf/701b518d5c56a1449825a3a37a716c58e05e1c3e/QPDF.cc/vul/before/0.json,"PointerHolder<QPDFObject>
QPDF::resolve(int objid, int generation)
{
    // Check object cache before checking xref table.  This allows us
    // to insert things into the object cache that don't actually
    // exist in the file.
    QPDFObjGen og(objid, generation);
    if (this->resolving.count(og))
    {
        // This can happen if an object references itself directly or
        // indirectly in some key that has to be resolved during
        // object parsing, such as stream length.
	QTC::TC(""qpdf"", ""QPDF recursion loop in resolve"");
	warn(QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),
		     """", this->file->getLastOffset(),
		     ""loop detected resolving object "" +
		     QUtil::int_to_string(objid) + "" "" +
		     QUtil::int_to_string(generation)));
        return new QPDF_Null;
    }
    ResolveRecorder rr(this, og);

    if (! this->obj_cache.count(og))
    {
	if (! this->xref_table.count(og))
	{
	    // PDF spec says unknown objects resolve to the null object.
	    return new QPDF_Null;
	}

	QPDFXRefEntry const& entry = this->xref_table[og];
	switch (entry.getType())
	{
	  case 1:
	    {
		qpdf_offset_t offset = entry.getOffset();
		// Object stored in cache by readObjectAtOffset
		int aobjid;
		int ageneration;
		QPDFObjectHandle oh =
		    readObjectAtOffset(true, offset, """", objid, generation,
				       aobjid, ageneration);
	    }
	    break;

	  case 2:
	    resolveObjectsInStream(entry.getObjStreamNumber());
	    break;

	  default:
	    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), """", 0,
			  ""object "" +
			  QUtil::int_to_string(objid) + ""/"" +
			  QUtil::int_to_string(generation) +
			  "" has unexpected xref entry type"");
	}
    }

    return this->obj_cache[og].object;
}","PointerHolder<QPDFObject>
QPDF::resolve(int VAR_0, int VAR_1)
{
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    QPDFObjGen og(objid, generation);
    if (this->resolving.count(VAR_2))
    {
        /* COMMENT_3 */
        /* COMMENT_4 */
        /* COMMENT_5 */
	QTC::TC(""qpdf"", ""QPDF recursion loop in resolve"");
	warn(QPDFExc(VAR_3, this->file->getName(),
		     """", this->file->getLastOffset(),
		     ""loop detected resolving object "" +
		     QUtil::int_to_string(objid) + "" "" +
		     QUtil::int_to_string(generation)));
        return new QPDF_Null;
    }
    ResolveRecorder VAR_4(this, VAR_2);

    if (! this->obj_cache.count(VAR_2))
    {
	if (! this->xref_table.count(VAR_2))
	{
	    /* COMMENT_6 */
	    return new QPDF_Null;
	}

	QPDFXRefEntry const& VAR_5 = this->xref_table[VAR_2];
	switch (VAR_5.getType())
	{
	  case 1:
	    {
		qpdf_offset_t VAR_6 = VAR_5.getOffset();
		/* COMMENT_7 */
		int VAR_7;
		int VAR_8;
		QPDFObjectHandle VAR_9 =
		    readObjectAtOffset(true, VAR_6, """", objid, generation,
				       VAR_7, VAR_8);
	    }
	    break;

	  case 2:
	    resolveObjectsInStream(VAR_5.getObjStreamNumber());
	    break;

	  default:
	    throw QPDFExc(VAR_3, this->file->getName(), """", 0,
			  ""object "" +
			  QUtil::int_to_string(objid) + ""/"" +
			  QUtil::int_to_string(generation) +
			  "" has unexpected xref entry type"");
	}
    }

    return this->obj_cache[VAR_2].object;
}",qpdf/701b518d5c56a1449825a3a37a716c58e05e1c3e/QPDF.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,21 @@
     // to insert things into the object cache that don't actually
     // exist in the file.
     QPDFObjGen og(objid, generation);
+    if (this->resolving.count(og))
+    {
+        // This can happen if an object references itself directly or
+        // indirectly in some key that has to be resolved during
+        // object parsing, such as stream length.
+	QTC::TC(""qpdf"", ""QPDF recursion loop in resolve"");
+	warn(QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),
+		     """", this->file->getLastOffset(),
+		     ""loop detected resolving object "" +
+		     QUtil::int_to_string(objid) + "" "" +
+		     QUtil::int_to_string(generation)));
+        return new QPDF_Null;
+    }
+    ResolveRecorder rr(this, og);
+
     if (! this->obj_cache.count(og))
     {
 	if (! this->xref_table.count(og))","{'deleted_lines': [], 'added_lines': ['    if (this->resolving.count(og))', '    {', '        // This can happen if an object references itself directly or', '        // indirectly in some key that has to be resolved during', '        // object parsing, such as stream length.', '\tQTC::TC(""qpdf"", ""QPDF recursion loop in resolve"");', '\twarn(QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),', '\t\t     """", this->file->getLastOffset(),', '\t\t     ""loop detected resolving object "" +', '\t\t     QUtil::int_to_string(objid) + "" "" +', '\t\t     QUtil::int_to_string(generation)));', '        return new QPDF_Null;', '    }', '    ResolveRecorder rr(this, og);', '']}",True,"An issue was discovered in QPDF before 7.0.0. Endless recursion causes stack exhaustion in QPDFTokenizer::resolveLiteral() in QPDFTokenizer.cc, related to the QPDF::resolve function in QPDF.cc.",5.5,MEDIUM,1,test,2017-07-26T09:03:38Z,2
CVE-2017-11665,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,ffmpeg,"avformat/rtmppkt: Convert ff_amf_get_field_value() to bytestream2

Fixes: out of array accesses

Found-by: JunDong Xie of Ant-financial Light-Year Security Lab
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",ffcc82219cef0928bed2d558b19ef6ea35634130,https://github.com/FFmpeg/FFmpeg/commit/ffcc82219cef0928bed2d558b19ef6ea35634130,libavformat/rtmppkt.c,ff_amf_get_field_value,"int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,
const uint8_t *name, uint8_t *dst, int dst_size)
{
int namelen = strlen(name);
int len;
while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {
len = ff_amf_tag_size(data, data_end);
if (len < 0)
len = data_end - data;
data += len;
}
if (data_end - data < 3)
return -1;
data++;
for (;;) {
int size = bytestream_get_be16(&data);
if (!size)
break;
if (size < 0 || size >= data_end - data)
return -1;
data += size;
if (size == namelen && !memcmp(data-size, name, namelen)) {
switch (*data++) {
case AMF_DATA_TYPE_NUMBER:
snprintf(dst, dst_size, ""%g"", av_int2double(AV_RB64(data)));
break;
case AMF_DATA_TYPE_BOOL:
snprintf(dst, dst_size, ""%s"", *data ? ""true"" : ""false"");
break;
case AMF_DATA_TYPE_STRING:
len = bytestream_get_be16(&data);
av_strlcpy(dst, data, FFMIN(len+1, dst_size));
break;
default:
return -1;
}
return 0;
}
len = ff_amf_tag_size(data, data_end);
if (len < 0 || len >= data_end - data)
return -1;
data += len;
}
return -1;
}","int ff_amf_get_field_value(const uint8_t *VAR_0, const uint8_t *VAR_1,
const uint8_t *VAR_2, uint8_t *VAR_3, int VAR_4)
{
int VAR_5 = strlen(VAR_2);
int VAR_6;
while (*VAR_0 != VAR_7 && VAR_0 < VAR_1) {
VAR_6 = ff_amf_tag_size(VAR_0, VAR_1);
if (VAR_6 < 0)
VAR_6 = VAR_1 - VAR_0;
VAR_0 += VAR_6;
}
if (VAR_1 - VAR_0 < 3)
return -1;
VAR_0++;
for (;;) {
int VAR_8 = bytestream_get_be16(&VAR_0);
if (!VAR_8)
break;
if (VAR_8 < 0 || VAR_8 >= VAR_1 - VAR_0)
return -1;
VAR_0 += VAR_8;
if (VAR_8 == VAR_5 && !memcmp(VAR_0-VAR_8, VAR_2, VAR_5)) {
switch (*VAR_0++) {
case VAR_9:
snprintf(VAR_3, VAR_4, ""%g"", av_int2double(AV_RB64(VAR_0)));
break;
case VAR_10:
snprintf(VAR_3, VAR_4, ""%s"", *VAR_0 ? ""true"" : ""false"");
break;
case VAR_11:
VAR_6 = bytestream_get_be16(&VAR_0);
av_strlcpy(VAR_3, VAR_0, FFMIN(VAR_6+1, VAR_4));
break;
default:
return -1;
}
return 0;
}
VAR_6 = ff_amf_tag_size(VAR_0, VAR_1);
if (VAR_6 < 0 || VAR_6 >= VAR_1 - VAR_0)
return -1;
VAR_0 += VAR_6;
}
return -1;
}",ffmpeg/ffcc82219cef0928bed2d558b19ef6ea35634130/rtmppkt.c/vul/before/0.json,"int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,
                           const uint8_t *name, uint8_t *dst, int dst_size)
{
    GetByteContext gb;

    if (data >= data_end)
        return -1;

    bytestream2_init(&gb, data, data_end - data);

    return amf_get_field_value2(&gb, name, dst, dst_size);
}","int ff_amf_get_field_value(const uint8_t *VAR_0, const uint8_t *VAR_1,
                           const uint8_t *VAR_2, uint8_t *VAR_3, int VAR_4)
{
    GetByteContext VAR_5;

    if (VAR_0 >= VAR_1)
        return -1;

    bytestream2_init(&VAR_5, VAR_0, VAR_1 - VAR_0);

    return amf_get_field_value2(&VAR_5, VAR_2, VAR_3, VAR_4);
}",ffmpeg/ffcc82219cef0928bed2d558b19ef6ea35634130/rtmppkt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,46 +1,12 @@
 int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,
                            const uint8_t *name, uint8_t *dst, int dst_size)
 {
-    int namelen = strlen(name);
-    int len;
+    GetByteContext gb;
 
-    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {
-        len = ff_amf_tag_size(data, data_end);
-        if (len < 0)
-            len = data_end - data;
-        data += len;
-    }
-    if (data_end - data < 3)
+    if (data >= data_end)
         return -1;
-    data++;
-    for (;;) {
-        int size = bytestream_get_be16(&data);
-        if (!size)
-            break;
-        if (size < 0 || size >= data_end - data)
-            return -1;
-        data += size;
-        if (size == namelen && !memcmp(data-size, name, namelen)) {
-            switch (*data++) {
-            case AMF_DATA_TYPE_NUMBER:
-                snprintf(dst, dst_size, ""%g"", av_int2double(AV_RB64(data)));
-                break;
-            case AMF_DATA_TYPE_BOOL:
-                snprintf(dst, dst_size, ""%s"", *data ? ""true"" : ""false"");
-                break;
-            case AMF_DATA_TYPE_STRING:
-                len = bytestream_get_be16(&data);
-                av_strlcpy(dst, data, FFMIN(len+1, dst_size));
-                break;
-            default:
-                return -1;
-            }
-            return 0;
-        }
-        len = ff_amf_tag_size(data, data_end);
-        if (len < 0 || len >= data_end - data)
-            return -1;
-        data += len;
-    }
-    return -1;
+
+    bytestream2_init(&gb, data, data_end - data);
+
+    return amf_get_field_value2(&gb, name, dst, dst_size);
 }","{'deleted_lines': ['    int namelen = strlen(name);', '    int len;', '    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {', '        len = ff_amf_tag_size(data, data_end);', '        if (len < 0)', '            len = data_end - data;', '        data += len;', '    }', '    if (data_end - data < 3)', '    data++;', '    for (;;) {', '        int size = bytestream_get_be16(&data);', '        if (!size)', '            break;', '        if (size < 0 || size >= data_end - data)', '            return -1;', '        data += size;', '        if (size == namelen && !memcmp(data-size, name, namelen)) {', '            switch (*data++) {', '            case AMF_DATA_TYPE_NUMBER:', '                snprintf(dst, dst_size, ""%g"", av_int2double(AV_RB64(data)));', '                break;', '            case AMF_DATA_TYPE_BOOL:', '                snprintf(dst, dst_size, ""%s"", *data ? ""true"" : ""false"");', '                break;', '            case AMF_DATA_TYPE_STRING:', '                len = bytestream_get_be16(&data);', '                av_strlcpy(dst, data, FFMIN(len+1, dst_size));', '                break;', '            default:', '                return -1;', '            }', '            return 0;', '        }', '        len = ff_amf_tag_size(data, data_end);', '        if (len < 0 || len >= data_end - data)', '            return -1;', '        data += len;', '    }', '    return -1;'], 'added_lines': ['    GetByteContext gb;', '    if (data >= data_end)', '', '    bytestream2_init(&gb, data, data_end - data);', '', '    return amf_get_field_value2(&gb, name, dst, dst_size);']}",True,The ff_amf_get_field_value function in libavformat/rtmppkt.c in FFmpeg 3.3.2 allows remote RTMP servers to cause a denial of service (Segmentation Violation and application crash) via a crafted stream.,7.5,HIGH,2,test,2017-07-28T12:37:26Z,2
CVE-2017-11751,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/631,b04e9c949d917a4a603f1a9bfe09737246229323,https://github.com/ImageMagick/ImageMagick/commit/b04e9c949d917a4a603f1a9bfe09737246229323,coders/xpm.c,WritePICONImage,"static MagickBooleanType WritePICONImage(const ImageInfo *image_info,
Image *image)
{
#define ColormapExtent  155
#define GraymapExtent  95
#define PiconGeometry  ""48x48>""
static unsigned char
Colormap[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
},
Graymap[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
};
#define MaxCixels  92
static const char
Cixel[MaxCixels+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";
char
buffer[MaxTextExtent],
basename[MaxTextExtent],
name[MaxTextExtent],
symbol[MaxTextExtent];
ExceptionInfo
*exception;
Image
*affinity_image,
*picon;
ImageInfo
*blob_info;
MagickBooleanType
status,
transparent;
MagickPixelPacket
pixel;
QuantizeInfo
*quantize_info;
RectangleInfo
geometry;
register const IndexPacket
*indexes;
register const PixelPacket
*p;
register ssize_t
i,
x;
register PixelPacket
*q;
size_t
characters_per_pixel,
colors;
ssize_t
j,
k,
y;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
if (status == MagickFalse)
return(status);
(void) TransformImageColorspace(image,sRGBColorspace);
SetGeometry(image,&geometry);
(void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,
&geometry.width,&geometry.height);
picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,1.0,
&image->exception);
blob_info=CloneImageInfo(image_info);
(void) AcquireUniqueFilename(blob_info->filename);
if ((image_info->type != TrueColorType) &&
(SetImageGray(image,&image->exception) != MagickFalse))
affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,
&image->exception);
else
affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,
&image->exception);
(void) RelinquishUniqueFileResource(blob_info->filename);
blob_info=DestroyImageInfo(blob_info);
if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))
return(MagickFalse);
quantize_info=AcquireQuantizeInfo(image_info);
status=RemapImage(quantize_info,picon,affinity_image);
quantize_info=DestroyQuantizeInfo(quantize_info);
affinity_image=DestroyImage(affinity_image);
transparent=MagickFalse;
exception=(&image->exception);
if (picon->storage_class == PseudoClass)
{
(void) CompressImageColormap(picon);
if (picon->matte != MagickFalse)
transparent=MagickTrue;
}
else
{
if (picon->matte != MagickFalse)
{
for (y=0; y < (ssize_t) picon->rows; y++)
{
q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
for (x=0; x < (ssize_t) picon->columns; x++)
{
if (q->opacity == (Quantum) TransparentOpacity)
transparent=MagickTrue;
else
SetPixelOpacity(q,OpaqueOpacity);
q++;
}
if (SyncAuthenticPixels(picon,exception) == MagickFalse)
break;
}
}
(void) SetImageType(picon,PaletteType);
}
colors=picon->colors;
if (transparent != MagickFalse)
{
register IndexPacket
*indexes;
colors++;
picon->colormap=(PixelPacket *) ResizeQuantumMemory((void **)
picon->colormap,(size_t) colors,sizeof(*picon->colormap));
if (picon->colormap == (PixelPacket *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationError"");
for (y=0; y < (ssize_t) picon->rows; y++)
{
q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(picon);
for (x=0; x < (ssize_t) picon->columns; x++)
{
if (q->opacity == (Quantum) TransparentOpacity)
SetPixelIndex(indexes+x,picon->colors);
q++;
}
if (SyncAuthenticPixels(picon,exception) == MagickFalse)
break;
}
}
characters_per_pixel=1;
for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)
characters_per_pixel++;
(void) WriteBlobString(image,""\n"");
GetPathComponent(picon->filename,BasePath,basename);
(void) FormatLocaleString(buffer,MaxTextExtent,
""static char *%s[] = {\n"",basename);
(void) WriteBlobString(image,buffer);
(void) WriteBlobString(image,""\n"");
(void) FormatLocaleString(buffer,MaxTextExtent,
""\""%.20g %.20g %.20g %.20g\"",\n"",(double) picon->columns,(double)
picon->rows,(double) colors,(double) characters_per_pixel);
(void) WriteBlobString(image,buffer);
GetMagickPixelPacket(image,&pixel);
for (i=0; i < (ssize_t) colors; i++)
{
SetMagickPixelPacket(image,picon->colormap+i,(IndexPacket *) NULL,&pixel);
pixel.colorspace=sRGBColorspace;
pixel.depth=8;
pixel.opacity=(MagickRealType) OpaqueOpacity;
(void) QueryMagickColorname(image,&pixel,XPMCompliance,name,
&image->exception);
if (transparent != MagickFalse)
{
if (i == (ssize_t) (colors-1))
(void) CopyMagickString(name,""grey75"",MaxTextExtent);
}
k=i % MaxCixels;
symbol[0]=Cixel[k];
for (j=1; j < (ssize_t) characters_per_pixel; j++)
{
k=((i-k)/MaxCixels) % MaxCixels;
symbol[j]=Cixel[k];
}
symbol[j]='\0';
(void) FormatLocaleString(buffer,MaxTextExtent,""\""%s c %s\"",\n"",
symbol,name);
(void) WriteBlobString(image,buffer);
}
(void) WriteBlobString(image,""\n"");
for (y=0; y < (ssize_t) picon->rows; y++)
{
p=GetVirtualPixels(picon,0,y,picon->columns,1,&picon->exception);
if (p == (const PixelPacket *) NULL)
break;
indexes=GetVirtualIndexQueue(picon);
(void) WriteBlobString(image,""\"""");
for (x=0; x < (ssize_t) picon->columns; x++)
{
k=((ssize_t) GetPixelIndex(indexes+x) % MaxCixels);
symbol[0]=Cixel[k];
for (j=1; j < (ssize_t) characters_per_pixel; j++)
{
k=(((int) GetPixelIndex(indexes+x)-k)/MaxCixels) % MaxCixels;
symbol[j]=Cixel[k];
}
symbol[j]='\0';
(void) CopyMagickString(buffer,symbol,MaxTextExtent);
(void) WriteBlobString(image,buffer);
}
(void) FormatLocaleString(buffer,MaxTextExtent,""\""%s\n"",
y == (ssize_t) (picon->rows-1) ? """" : "","");
(void) WriteBlobString(image,buffer);
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
picon->rows);
if (status == MagickFalse)
break;
}
picon=DestroyImage(picon);
(void) WriteBlobString(image,""};\n"");
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WritePICONImage(const ImageInfo *VAR_0,
Image *VAR_1)
{
#define VAR_2  155
#define VAR_3  95
#define VAR_4  ""48x48>""
static unsigned char
VAR_5[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
},
VAR_6[]=
{
0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
};
#define VAR_7  92
static const char
VAR_8[VAR_7+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";
char
VAR_9[VAR_10],
VAR_11[VAR_10],
VAR_12[VAR_10],
VAR_13[VAR_10];
ExceptionInfo
*VAR_14;
Image
*VAR_15,
*VAR_16;
ImageInfo
*VAR_17;
MagickBooleanType
VAR_18,
VAR_19;
MagickPixelPacket
VAR_20;
QuantizeInfo
*VAR_21;
RectangleInfo
VAR_22;
register const IndexPacket
*VAR_23;
register const PixelPacket
*VAR_24;
register ssize_t
VAR_25,
VAR_26;
register PixelPacket
*VAR_27;
size_t
VAR_28,
VAR_29;
ssize_t
VAR_30,
VAR_31,
VAR_32;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_33);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_33);
if (VAR_1->debug != VAR_34)
(void) LogMagickEvent(VAR_35,GetMagickModule(),""%s"",VAR_1->filename);
VAR_18=OpenBlob(VAR_0,VAR_1,VAR_36,&VAR_1->exception);
if (VAR_18 == VAR_34)
return(VAR_18);
(void) TransformImageColorspace(VAR_1,VAR_37);
SetGeometry(VAR_1,&VAR_22);
(void) ParseMetaGeometry(VAR_4,&VAR_22.x,&VAR_22.y,
&VAR_22.width,&VAR_22.height);
VAR_16=ResizeImage(VAR_1,VAR_22.width,VAR_22.height,VAR_38,1.0,
&VAR_1->exception);
VAR_17=CloneImageInfo(VAR_0);
(void) AcquireUniqueFilename(VAR_17->filename);
if ((VAR_0->type != VAR_39) &&
(SetImageGray(VAR_1,&VAR_1->exception) != VAR_34))
VAR_15=BlobToImage(VAR_17,VAR_6,VAR_3,
&VAR_1->exception);
else
VAR_15=BlobToImage(VAR_17,VAR_5,VAR_2,
&VAR_1->exception);
(void) RelinquishUniqueFileResource(VAR_17->filename);
VAR_17=DestroyImageInfo(VAR_17);
if ((VAR_16 == (Image *) NULL) || (VAR_15 == (Image *) NULL))
return(VAR_34);
VAR_21=AcquireQuantizeInfo(VAR_0);
VAR_18=RemapImage(VAR_21,VAR_16,VAR_15);
VAR_21=DestroyQuantizeInfo(VAR_21);
VAR_15=DestroyImage(VAR_15);
VAR_19=VAR_34;
VAR_14=(&VAR_1->exception);
if (VAR_16->storage_class == VAR_40)
{
(void) CompressImageColormap(VAR_16);
if (VAR_16->matte != VAR_34)
VAR_19=VAR_41;
}
else
{
if (VAR_16->matte != VAR_34)
{
for (VAR_32=0; VAR_32 < (ssize_t) VAR_16->rows; VAR_32++)
{
VAR_27=GetAuthenticPixels(VAR_16,0,VAR_32,VAR_16->columns,1,VAR_14);
if (VAR_27 == (PixelPacket *) NULL)
break;
for (VAR_26=0; VAR_26 < (ssize_t) VAR_16->columns; VAR_26++)
{
if (VAR_27->opacity == (Quantum) VAR_42)
VAR_19=VAR_41;
else
SetPixelOpacity(VAR_27,VAR_43);
VAR_27++;
}
if (SyncAuthenticPixels(VAR_16,VAR_14) == VAR_34)
break;
}
}
(void) SetImageType(VAR_16,VAR_44);
}
VAR_29=VAR_16->colors;
if (VAR_19 != VAR_34)
{
register IndexPacket
*VAR_23;
VAR_29++;
VAR_16->colormap=(PixelPacket *) ResizeQuantumMemory((void **)
VAR_16->colormap,(size_t) VAR_29,sizeof(*VAR_16->colormap));
if (VAR_16->colormap == (PixelPacket *) NULL)
ThrowWriterException(VAR_45,""MemoryAllocationError"");
for (VAR_32=0; VAR_32 < (ssize_t) VAR_16->rows; VAR_32++)
{
VAR_27=GetAuthenticPixels(VAR_16,0,VAR_32,VAR_16->columns,1,VAR_14);
if (VAR_27 == (PixelPacket *) NULL)
break;
VAR_23=GetAuthenticIndexQueue(VAR_16);
for (VAR_26=0; VAR_26 < (ssize_t) VAR_16->columns; VAR_26++)
{
if (VAR_27->opacity == (Quantum) VAR_42)
SetPixelIndex(VAR_23+VAR_26,VAR_16->colors);
VAR_27++;
}
if (SyncAuthenticPixels(VAR_16,VAR_14) == VAR_34)
break;
}
}
VAR_28=1;
for (VAR_31=VAR_7; (ssize_t) VAR_29 > VAR_31; VAR_31*=VAR_7)
VAR_28++;
(void) WriteBlobString(VAR_1,""\n"");
GetPathComponent(VAR_16->filename,VAR_46,VAR_11);
(void) FormatLocaleString(VAR_9,VAR_10,
""static char *%s[] = {\n"",VAR_11);
(void) WriteBlobString(VAR_1,VAR_9);
(void) WriteBlobString(VAR_1,""\n"");
(void) FormatLocaleString(VAR_9,VAR_10,
""\""%.20g %.20g %.20g %.20g\"",\n"",(double) VAR_16->columns,(double)
VAR_16->rows,(double) VAR_29,(double) VAR_28);
(void) WriteBlobString(VAR_1,VAR_9);
GetMagickPixelPacket(VAR_1,&VAR_20);
for (VAR_25=0; VAR_25 < (ssize_t) VAR_29; VAR_25++)
{
SetMagickPixelPacket(VAR_1,VAR_16->colormap+VAR_25,(IndexPacket *) NULL,&VAR_20);
VAR_20.colorspace=VAR_37;
VAR_20.depth=8;
VAR_20.opacity=(MagickRealType) VAR_43;
(void) QueryMagickColorname(VAR_1,&VAR_20,VAR_47,VAR_12,
&VAR_1->exception);
if (VAR_19 != VAR_34)
{
if (VAR_25 == (ssize_t) (VAR_29-1))
(void) CopyMagickString(VAR_12,""grey75"",VAR_10);
}
VAR_31=VAR_25 % VAR_7;
VAR_13[0]=VAR_8[VAR_31];
for (VAR_30=1; VAR_30 < (ssize_t) VAR_28; VAR_30++)
{
VAR_31=((VAR_25-VAR_31)/VAR_7) % VAR_7;
VAR_13[VAR_30]=VAR_8[VAR_31];
}
VAR_13[VAR_30]='\0';
(void) FormatLocaleString(VAR_9,VAR_10,""\""%s c %s\"",\n"",
VAR_13,VAR_12);
(void) WriteBlobString(VAR_1,VAR_9);
}
(void) WriteBlobString(VAR_1,""\n"");
for (VAR_32=0; VAR_32 < (ssize_t) VAR_16->rows; VAR_32++)
{
VAR_24=GetVirtualPixels(VAR_16,0,VAR_32,VAR_16->columns,1,&VAR_16->exception);
if (VAR_24 == (const PixelPacket *) NULL)
break;
VAR_23=GetVirtualIndexQueue(VAR_16);
(void) WriteBlobString(VAR_1,""\"""");
for (VAR_26=0; VAR_26 < (ssize_t) VAR_16->columns; VAR_26++)
{
VAR_31=((ssize_t) GetPixelIndex(VAR_23+VAR_26) % VAR_7);
VAR_13[0]=VAR_8[VAR_31];
for (VAR_30=1; VAR_30 < (ssize_t) VAR_28; VAR_30++)
{
VAR_31=(((int) GetPixelIndex(VAR_23+VAR_26)-VAR_31)/VAR_7) % VAR_7;
VAR_13[VAR_30]=VAR_8[VAR_31];
}
VAR_13[VAR_30]='\0';
(void) CopyMagickString(VAR_9,VAR_13,VAR_10);
(void) WriteBlobString(VAR_1,VAR_9);
}
(void) FormatLocaleString(VAR_9,VAR_10,""\""%s\n"",
VAR_32 == (ssize_t) (VAR_16->rows-1) ? """" : "","");
(void) WriteBlobString(VAR_1,VAR_9);
VAR_18=SetImageProgress(VAR_1,VAR_48,(MagickOffsetType) VAR_32,
VAR_16->rows);
if (VAR_18 == VAR_34)
break;
}
VAR_16=DestroyImage(VAR_16);
(void) WriteBlobString(VAR_1,""};\n"");
(void) CloseBlob(VAR_1);
return(VAR_41);
}",ImageMagick/b04e9c949d917a4a603f1a9bfe09737246229323/xpm.c/vul/before/0.json,"static MagickBooleanType WritePICONImage(const ImageInfo *image_info,
  Image *image)
{
#define ColormapExtent  155
#define GraymapExtent  95
#define PiconGeometry  ""48x48>""

  static unsigned char
    Colormap[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
    },
    Graymap[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
    };

#define MaxCixels  92

  static const char
    Cixel[MaxCixels+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
                         ""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";

  char
    buffer[MaxTextExtent],
    basename[MaxTextExtent],
    name[MaxTextExtent],
    symbol[MaxTextExtent];

  ExceptionInfo
    *exception;

  Image
    *affinity_image,
    *picon;

  ImageInfo
    *blob_info;

  MagickBooleanType
    status,
    transparent;

  MagickPixelPacket
    pixel;

  QuantizeInfo
    *quantize_info;

  RectangleInfo
    geometry;

  register const IndexPacket
    *indexes;

  register const PixelPacket
    *p;

  register ssize_t
    i,
    x;

  register PixelPacket
    *q;

  size_t
    characters_per_pixel,
    colors;

  ssize_t
    j,
    k,
    y;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
  (void) TransformImageColorspace(image,sRGBColorspace);
  SetGeometry(image,&geometry);
  (void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,
    &geometry.width,&geometry.height);
  picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,1.0,
    &image->exception);
  blob_info=CloneImageInfo(image_info);
  (void) AcquireUniqueFilename(blob_info->filename);
  if ((image_info->type != TrueColorType) &&
      (SetImageGray(image,&image->exception) != MagickFalse))
    affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,
      &image->exception);
  else
    affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,
      &image->exception);
  (void) RelinquishUniqueFileResource(blob_info->filename);
  blob_info=DestroyImageInfo(blob_info);
  if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))
    {
      if (affinity_image != (Image *) NULL)
        affinity_image=DestroyImage(affinity_image);
      if (picon != (Image *) NULL)
        picon=DestroyImage(picon);
      return(MagickFalse);
    }
  quantize_info=AcquireQuantizeInfo(image_info);
  status=RemapImage(quantize_info,picon,affinity_image);
  quantize_info=DestroyQuantizeInfo(quantize_info);
  affinity_image=DestroyImage(affinity_image);
  transparent=MagickFalse;
  exception=(&image->exception);
  if (picon->storage_class == PseudoClass)
    {
      (void) CompressImageColormap(picon);
      if (picon->matte != MagickFalse)
        transparent=MagickTrue;
    }
  else
    {
      /*
        Convert DirectClass to PseudoClass picon.
      */
      if (picon->matte != MagickFalse)
        {
          /*
            Map all the transparent pixels.
          */
          for (y=0; y < (ssize_t) picon->rows; y++)
          {
            q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
            if (q == (PixelPacket *) NULL)
              break;
            for (x=0; x < (ssize_t) picon->columns; x++)
            {
              if (q->opacity == (Quantum) TransparentOpacity)
                transparent=MagickTrue;
              else
                SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
            if (SyncAuthenticPixels(picon,exception) == MagickFalse)
              break;
          }
        }
      (void) SetImageType(picon,PaletteType);
    }
  colors=picon->colors;
  if (transparent != MagickFalse)
    {
      register IndexPacket
        *indexes;

      colors++;
      picon->colormap=(PixelPacket *) ResizeQuantumMemory((void **)
        picon->colormap,(size_t) colors,sizeof(*picon->colormap));
      if (picon->colormap == (PixelPacket *) NULL)
        ThrowWriterException(ResourceLimitError,""MemoryAllocationError"");
      for (y=0; y < (ssize_t) picon->rows; y++)
      {
        q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        indexes=GetAuthenticIndexQueue(picon);
        for (x=0; x < (ssize_t) picon->columns; x++)
        {
          if (q->opacity == (Quantum) TransparentOpacity)
            SetPixelIndex(indexes+x,picon->colors);
          q++;
        }
        if (SyncAuthenticPixels(picon,exception) == MagickFalse)
          break;
      }
    }
  /*
    Compute the character per pixel.
  */
  characters_per_pixel=1;
  for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)
    characters_per_pixel++;
  /*
    XPM header.
  */
  (void) WriteBlobString(image,""/* XPM */\n"");
  GetPathComponent(picon->filename,BasePath,basename);
  (void) FormatLocaleString(buffer,MaxTextExtent,
    ""static char *%s[] = {\n"",basename);
  (void) WriteBlobString(image,buffer);
  (void) WriteBlobString(image,""/* columns rows colors chars-per-pixel */\n"");
  (void) FormatLocaleString(buffer,MaxTextExtent,
    ""\""%.20g %.20g %.20g %.20g\"",\n"",(double) picon->columns,(double)
    picon->rows,(double) colors,(double) characters_per_pixel);
  (void) WriteBlobString(image,buffer);
  GetMagickPixelPacket(image,&pixel);
  for (i=0; i < (ssize_t) colors; i++)
  {
    /*
      Define XPM color.
    */
    SetMagickPixelPacket(image,picon->colormap+i,(IndexPacket *) NULL,&pixel);
    pixel.colorspace=sRGBColorspace;
    pixel.depth=8;
    pixel.opacity=(MagickRealType) OpaqueOpacity;
    (void) QueryMagickColorname(image,&pixel,XPMCompliance,name,
      &image->exception);
    if (transparent != MagickFalse)
      {
        if (i == (ssize_t) (colors-1))
          (void) CopyMagickString(name,""grey75"",MaxTextExtent);
      }
    /*
      Write XPM color.
    */
    k=i % MaxCixels;
    symbol[0]=Cixel[k];
    for (j=1; j < (ssize_t) characters_per_pixel; j++)
    {
      k=((i-k)/MaxCixels) % MaxCixels;
      symbol[j]=Cixel[k];
    }
    symbol[j]='\0';
    (void) FormatLocaleString(buffer,MaxTextExtent,""\""%s c %s\"",\n"",
       symbol,name);
    (void) WriteBlobString(image,buffer);
  }
  /*
    Define XPM pixels.
  */
  (void) WriteBlobString(image,""/* pixels */\n"");
  for (y=0; y < (ssize_t) picon->rows; y++)
  {
    p=GetVirtualPixels(picon,0,y,picon->columns,1,&picon->exception);
    if (p == (const PixelPacket *) NULL)
      break;
    indexes=GetVirtualIndexQueue(picon);
    (void) WriteBlobString(image,""\"""");
    for (x=0; x < (ssize_t) picon->columns; x++)
    {
      k=((ssize_t) GetPixelIndex(indexes+x) % MaxCixels);
      symbol[0]=Cixel[k];
      for (j=1; j < (ssize_t) characters_per_pixel; j++)
      {
        k=(((int) GetPixelIndex(indexes+x)-k)/MaxCixels) % MaxCixels;
        symbol[j]=Cixel[k];
      }
      symbol[j]='\0';
      (void) CopyMagickString(buffer,symbol,MaxTextExtent);
      (void) WriteBlobString(image,buffer);
    }
    (void) FormatLocaleString(buffer,MaxTextExtent,""\""%s\n"",
      y == (ssize_t) (picon->rows-1) ? """" : "","");
    (void) WriteBlobString(image,buffer);
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      picon->rows);
    if (status == MagickFalse)
      break;
  }
  picon=DestroyImage(picon);
  (void) WriteBlobString(image,""};\n"");
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WritePICONImage(const ImageInfo *VAR_0,
  Image *VAR_1)
{
#define VAR_2  155
#define VAR_3  95
#define VAR_4  ""48x48>""

  static unsigned char
    VAR_5[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,
      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,
      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,
      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,
      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,
      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,
      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,
      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,
      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,
      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,
      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,
    },
    VAR_6[]=
    {
      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,
      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,
      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,
      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,
      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,
      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,
      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,
      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,
    };

#define VAR_7  92

  static const char
    VAR_8[VAR_7+1] = "" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk""
                         ""lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|"";

  char
    VAR_9[VAR_10],
    VAR_11[VAR_10],
    VAR_12[VAR_10],
    VAR_13[VAR_10];

  ExceptionInfo
    *VAR_14;

  Image
    *VAR_15,
    *VAR_16;

  ImageInfo
    *VAR_17;

  MagickBooleanType
    VAR_18,
    VAR_19;

  MagickPixelPacket
    VAR_20;

  QuantizeInfo
    *VAR_21;

  RectangleInfo
    VAR_22;

  register const IndexPacket
    *VAR_23;

  register const PixelPacket
    *VAR_24;

  register ssize_t
    VAR_25,
    VAR_26;

  register PixelPacket
    *VAR_27;

  size_t
    VAR_28,
    VAR_29;

  ssize_t
    VAR_30,
    VAR_31,
    VAR_32;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_33);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_33);
  if (VAR_1->debug != VAR_34)
    (void) LogMagickEvent(VAR_35,GetMagickModule(),""%s"",VAR_1->filename);
  VAR_18=OpenBlob(VAR_0,VAR_1,VAR_36,&VAR_1->exception);
  if (VAR_18 == VAR_34)
    return(VAR_18);
  (void) TransformImageColorspace(VAR_1,VAR_37);
  SetGeometry(VAR_1,&VAR_22);
  (void) ParseMetaGeometry(VAR_4,&VAR_22.x,&VAR_22.y,
    &VAR_22.width,&VAR_22.height);
  VAR_16=ResizeImage(VAR_1,VAR_22.width,VAR_22.height,VAR_38,1.0,
    &VAR_1->exception);
  VAR_17=CloneImageInfo(VAR_0);
  (void) AcquireUniqueFilename(VAR_17->filename);
  if ((VAR_0->type != VAR_39) &&
      (SetImageGray(VAR_1,&VAR_1->exception) != VAR_34))
    VAR_15=BlobToImage(VAR_17,VAR_6,VAR_3,
      &VAR_1->exception);
  else
    VAR_15=BlobToImage(VAR_17,VAR_5,VAR_2,
      &VAR_1->exception);
  (void) RelinquishUniqueFileResource(VAR_17->filename);
  VAR_17=DestroyImageInfo(VAR_17);
  if ((VAR_16 == (Image *) NULL) || (VAR_15 == (Image *) NULL))
    {
      if (VAR_15 != (Image *) NULL)
        VAR_15=DestroyImage(VAR_15);
      if (VAR_16 != (Image *) NULL)
        VAR_16=DestroyImage(VAR_16);
      return(VAR_34);
    }
  VAR_21=AcquireQuantizeInfo(VAR_0);
  VAR_18=RemapImage(VAR_21,VAR_16,VAR_15);
  VAR_21=DestroyQuantizeInfo(VAR_21);
  VAR_15=DestroyImage(VAR_15);
  VAR_19=VAR_34;
  VAR_14=(&VAR_1->exception);
  if (VAR_16->storage_class == VAR_40)
    {
      (void) CompressImageColormap(VAR_16);
      if (VAR_16->matte != VAR_34)
        VAR_19=VAR_41;
    }
  else
    {
      /* COMMENT_3 */
                                                 
        
      if (VAR_16->matte != VAR_34)
        {
          /* COMMENT_6 */
                                           
            
          for (VAR_32=0; VAR_32 < (ssize_t) VAR_16->rows; VAR_32++)
          {
            VAR_27=GetAuthenticPixels(VAR_16,0,VAR_32,VAR_16->columns,1,VAR_14);
            if (VAR_27 == (PixelPacket *) NULL)
              break;
            for (VAR_26=0; VAR_26 < (ssize_t) VAR_16->columns; VAR_26++)
            {
              if (VAR_27->opacity == (Quantum) VAR_42)
                VAR_19=VAR_41;
              else
                SetPixelOpacity(VAR_27,VAR_43);
              VAR_27++;
            }
            if (SyncAuthenticPixels(VAR_16,VAR_14) == VAR_34)
              break;
          }
        }
      (void) SetImageType(VAR_16,VAR_44);
    }
  VAR_29=VAR_16->colors;
  if (VAR_19 != VAR_34)
    {
      register IndexPacket
        *VAR_23;

      VAR_29++;
      VAR_16->colormap=(PixelPacket *) ResizeQuantumMemory((void **)
        VAR_16->colormap,(size_t) VAR_29,sizeof(*VAR_16->colormap));
      if (VAR_16->colormap == (PixelPacket *) NULL)
        ThrowWriterException(VAR_45,""MemoryAllocationError"");
      for (VAR_32=0; VAR_32 < (ssize_t) VAR_16->rows; VAR_32++)
      {
        VAR_27=GetAuthenticPixels(VAR_16,0,VAR_32,VAR_16->columns,1,VAR_14);
        if (VAR_27 == (PixelPacket *) NULL)
          break;
        VAR_23=GetAuthenticIndexQueue(VAR_16);
        for (VAR_26=0; VAR_26 < (ssize_t) VAR_16->columns; VAR_26++)
        {
          if (VAR_27->opacity == (Quantum) VAR_42)
            SetPixelIndex(VAR_23+VAR_26,VAR_16->colors);
          VAR_27++;
        }
        if (SyncAuthenticPixels(VAR_16,VAR_14) == VAR_34)
          break;
      }
    }
  /* COMMENT_9 */
                                    
    
  VAR_28=1;
  for (VAR_31=VAR_7; (ssize_t) VAR_29 > VAR_31; VAR_31*=VAR_7)
    VAR_28++;
  /* COMMENT_12 */
               
    
  (void) WriteBlobString(VAR_1,""/* XPM */\n"");
  GetPathComponent(VAR_16->filename,VAR_46,VAR_11);
  (void) FormatLocaleString(VAR_9,VAR_10,
    ""static char *%s[] = {\n"",VAR_11);
  (void) WriteBlobString(VAR_1,VAR_9);
  (void) WriteBlobString(VAR_1,""/* columns rows colors chars-per-pixel */\n"");
  (void) FormatLocaleString(VAR_9,VAR_10,
    ""\""%.20g %.20g %.20g %.20g\"",\n"",(double) VAR_16->columns,(double)
    VAR_16->rows,(double) VAR_29,(double) VAR_28);
  (void) WriteBlobString(VAR_1,VAR_9);
  GetMagickPixelPacket(VAR_1,&VAR_20);
  for (VAR_25=0; VAR_25 < (ssize_t) VAR_29; VAR_25++)
  {
    /* COMMENT_15 */
                       
      
    SetMagickPixelPacket(VAR_1,VAR_16->colormap+VAR_25,(IndexPacket *) NULL,&VAR_20);
    VAR_20.colorspace=VAR_37;
    VAR_20.depth=8;
    VAR_20.opacity=(MagickRealType) VAR_43;
    (void) QueryMagickColorname(VAR_1,&VAR_20,VAR_47,VAR_12,
      &VAR_1->exception);
    if (VAR_19 != VAR_34)
      {
        if (VAR_25 == (ssize_t) (VAR_29-1))
          (void) CopyMagickString(VAR_12,""grey75"",VAR_10);
      }
    /* COMMENT_18 */
                      
      
    VAR_31=VAR_25 % VAR_7;
    VAR_13[0]=VAR_8[VAR_31];
    for (VAR_30=1; VAR_30 < (ssize_t) VAR_28; VAR_30++)
    {
      VAR_31=((VAR_25-VAR_31)/VAR_7) % VAR_7;
      VAR_13[VAR_30]=VAR_8[VAR_31];
    }
    VAR_13[VAR_30]='\0';
    (void) FormatLocaleString(VAR_9,VAR_10,""\""%s c %s\"",\n"",
       VAR_13,VAR_12);
    (void) WriteBlobString(VAR_1,VAR_9);
  }
  /* COMMENT_21 */
                      
    
  (void) WriteBlobString(VAR_1,""/* pixels */\n"");
  for (VAR_32=0; VAR_32 < (ssize_t) VAR_16->rows; VAR_32++)
  {
    VAR_24=GetVirtualPixels(VAR_16,0,VAR_32,VAR_16->columns,1,&VAR_16->exception);
    if (VAR_24 == (const PixelPacket *) NULL)
      break;
    VAR_23=GetVirtualIndexQueue(VAR_16);
    (void) WriteBlobString(VAR_1,""\"""");
    for (VAR_26=0; VAR_26 < (ssize_t) VAR_16->columns; VAR_26++)
    {
      VAR_31=((ssize_t) GetPixelIndex(VAR_23+VAR_26) % VAR_7);
      VAR_13[0]=VAR_8[VAR_31];
      for (VAR_30=1; VAR_30 < (ssize_t) VAR_28; VAR_30++)
      {
        VAR_31=(((int) GetPixelIndex(VAR_23+VAR_26)-VAR_31)/VAR_7) % VAR_7;
        VAR_13[VAR_30]=VAR_8[VAR_31];
      }
      VAR_13[VAR_30]='\0';
      (void) CopyMagickString(VAR_9,VAR_13,VAR_10);
      (void) WriteBlobString(VAR_1,VAR_9);
    }
    (void) FormatLocaleString(VAR_9,VAR_10,""\""%s\n"",
      VAR_32 == (ssize_t) (VAR_16->rows-1) ? """" : "","");
    (void) WriteBlobString(VAR_1,VAR_9);
    VAR_18=SetImageProgress(VAR_1,VAR_48,(MagickOffsetType) VAR_32,
      VAR_16->rows);
    if (VAR_18 == VAR_34)
      break;
  }
  VAR_16=DestroyImage(VAR_16);
  (void) WriteBlobString(VAR_1,""};\n"");
  (void) CloseBlob(VAR_1);
  return(VAR_41);
}",ImageMagick/b04e9c949d917a4a603f1a9bfe09737246229323/xpm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -121,7 +121,13 @@
   (void) RelinquishUniqueFileResource(blob_info->filename);
   blob_info=DestroyImageInfo(blob_info);
   if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))
-    return(MagickFalse);
+    {
+      if (affinity_image != (Image *) NULL)
+        affinity_image=DestroyImage(affinity_image);
+      if (picon != (Image *) NULL)
+        picon=DestroyImage(picon);
+      return(MagickFalse);
+    }
   quantize_info=AcquireQuantizeInfo(image_info);
   status=RemapImage(quantize_info,picon,affinity_image);
   quantize_info=DestroyQuantizeInfo(quantize_info);","{'deleted_lines': ['    return(MagickFalse);'], 'added_lines': ['    {', '      if (affinity_image != (Image *) NULL)', '        affinity_image=DestroyImage(affinity_image);', '      if (picon != (Image *) NULL)', '        picon=DestroyImage(picon);', '      return(MagickFalse);', '    }']}",True,The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file.,6.5,MEDIUM,1,test,2017-07-30T10:06:33Z,2
CVE-2017-13060,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/644,7d957e40e68c9af33f24d52f610d48ec758e88d9,https://github.com/ImageMagick/ImageMagick/commit/7d957e40e68c9af33f24d52f610d48ec758e88d9,coders/mat.c,ReadMATImage,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image *image, *image2=NULL,
*rotated_image;
PixelPacket *q;
unsigned int status;
MATHeader MATLAB_HDR;
size_t size;
size_t CellType;
QuantumInfo *quantum_info;
ImageInfo *clone_info;
int i;
ssize_t ldblk;
unsigned char *BImgBuff = NULL;
double MinVal, MaxVal;
size_t Unknown6;
unsigned z, z2;
unsigned Frames;
int logging;
int sample_size;
MagickOffsetType filepos=0x80;
BlobInfo *blob;
size_t one;
unsigned int (*ReadBlobXXXLong)(Image *image);
unsigned short (*ReadBlobXXXShort)(Image *image);
void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
quantum_info=(QuantumInfo *) NULL;
image = AcquireImage(image_info);
status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
clone_info=(ImageInfo *) NULL;
if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
{
image2=ReadMATImageV4(image_info,image,exception);
if (image2  == NULL)
goto MATLAB_KO;
image=image2;
goto END_OF_READING;
}
MATLAB_HDR.Version = ReadBlobLSBShort(image);
if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
{
ReadBlobXXXLong = ReadBlobLSBLong;
ReadBlobXXXShort = ReadBlobLSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesLSB;
ReadBlobFloatsXXX = ReadBlobFloatsLSB;
image->endian = LSBEndian;
}
else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
{
ReadBlobXXXLong = ReadBlobMSBLong;
ReadBlobXXXShort = ReadBlobMSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesMSB;
ReadBlobFloatsXXX = ReadBlobFloatsMSB;
image->endian = MSBEndian;
}
else
goto MATLAB_KO;    
if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
{
MATLAB_KO:
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
filepos = TellBlob(image);
while(!EOFBlob(image)) 
{
Frames = 1;
(void) SeekBlob(image,filepos,SEEK_SET);
MATLAB_HDR.DataType = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
goto MATLAB_KO;
filepos += MATLAB_HDR.ObjectSize + 4 + 4;
clone_info=CloneImageInfo(image_info);
image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
if(MATLAB_HDR.DataType == miCOMPRESSED)
{
image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
if(image2==NULL) continue;
MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
}
#endif
if(MATLAB_HDR.DataType!=miMATRIX) continue;  
MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
if(image!=image2)
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
switch(MATLAB_HDR.DimFlag)
{
case  8: z2=z=1; break;      
case 12: z2=z = ReadBlobXXXLong(image2);  
Unknown6 = ReadBlobXXXLong(image2);
(void) Unknown6;
if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: z2=z = ReadBlobXXXLong(image2);  
if(z!=3 && z!=1)
ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
Frames = ReadBlobXXXLong(image2);
if (Frames == 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
break;
default:
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
}
MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
MATLAB_HDR.StructureClass != mxINT8_CLASS &&
MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
MATLAB_HDR.StructureClass != mxINT16_CLASS &&
MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
MATLAB_HDR.StructureClass != mxINT32_CLASS &&
MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
MATLAB_HDR.StructureClass != mxINT64_CLASS &&
MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
switch (MATLAB_HDR.NameFlag)
{
case 0:
size = ReadBlobXXXLong(image2);  
size = 4 * (ssize_t) ((size + 3 + 1) / 4);
(void) SeekBlob(image2, size, SEEK_CUR);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(image2, 4, (unsigned char *) &size); 
break;
default:
goto MATLAB_KO;
}
CellType = ReadBlobXXXLong(image2);    
if (logging)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) CellType);
(void) ReadBlob(image2, 4, (unsigned char *) &size);     
NEXT_FRAME:
switch (CellType)
{
case miINT8:
case miUINT8:
sample_size = 8;
if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
image->depth = 1;
else
image->depth = 8;         
ldblk = (ssize_t) MATLAB_HDR.SizeX;
break;
case miINT16:
case miUINT16:
sample_size = 16;
image->depth = 16;        
ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
break;
case miINT32:
case miUINT32:
sample_size = 32;
image->depth = 32;        
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miINT64:
case miUINT64:
sample_size = 64;
image->depth = 64;        
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
case miSINGLE:
sample_size = 32;
image->depth = 32;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{              
}
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miDOUBLE:
sample_size = 64;
image->depth = 64;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
RestoreMSCWarning
ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{                         
}
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
default:
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
}
(void) sample_size;
image->columns = MATLAB_HDR.SizeX;
image->rows = MATLAB_HDR.SizeY;
one=1;
image->colors = one << image->depth;
if (image->columns == 0 || image->rows == 0)
goto MATLAB_KO;
if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
goto MATLAB_KO;
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
{
SetImageColorspace(image,GRAYColorspace);
image->type=GrayscaleType;
}
if (image_info->ping)
{
size_t temp = image->columns;
image->columns = image->rows;
image->rows = temp;
goto done_reading; 
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
quantum_info=AcquireQuantumInfo(clone_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
if (BImgBuff == NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
MinVal = 0;
MaxVal = 0;
if (CellType==miDOUBLE || CellType==miSINGLE)        
{
CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
}
if(z==1) z=0; 
do
{
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto done_reading;    
}
if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
{
FixLogical((unsigned char *)BImgBuff,ldblk);
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
{
ImportQuantumPixelsFailed:
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
break;
}
}
else
{
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
goto ImportQuantumPixelsFailed;
if (z<=1 &&       
(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
FixSignedValues(q,MATLAB_HDR.SizeX);
}
if (!SyncAuthenticPixels(image,exception))
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
}
} while(z-- >= 2);
ExitLoop:
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{        
CellType = ReadBlobXXXLong(image2);    
i = ReadBlobXXXLong(image2);           
if (CellType==miDOUBLE || CellType==miSINGLE)
{
CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
}
if (CellType==miDOUBLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
}
if (CellType==miSINGLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
}
}
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
image->type=GrayscaleType;
if (image->depth == 1)
image->type=BilevelType;
if(image2==image)
image2 = NULL;    
rotated_image = RotateImage(image, 90.0, exception);
if (rotated_image != (Image *) NULL)
{
rotated_image->page.x=0;
rotated_image->page.y=0;
blob = rotated_image->blob;
rotated_image->blob = image->blob;
rotated_image->colors = image->colors;
image->blob = blob;
AppendImageToList(&image,rotated_image);
DeleteImageFromList(&image);
}
done_reading:
if(image2!=NULL)
if(image2!=image)
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
}
}
AcquireNextImage(image_info,image);
if (image->next == (Image *) NULL) break;
image=SyncNextImageInList(image);
image->columns=image->rows=0;
image->colors=0;
RelinquishMagickMemory(BImgBuff);
BImgBuff = NULL;
if(--Frames>0)
{
z = z2;
if(image2==NULL) image2 = image;
goto NEXT_FRAME;
}
if(image2!=NULL)
if(image2!=image)   
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) unlink(clone_info->filename);
}
}
}
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
}
RelinquishMagickMemory(BImgBuff);
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
CloseBlob(image);
{
Image *p;
ssize_t scene=0;
p=image;
image=NULL;
while (p != (Image *) NULL)
{
Image *tmp=p;
if ((p->rows == 0) || (p->columns == 0)) {
p=p->previous;
DeleteImageFromList(&tmp);
} else {
image=p;
p=p->previous;
}
}
for (p=image; p != (Image *) NULL; p=p->next)
p->scene=scene++;
}
if(clone_info != NULL)  
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
DestroyImageInfo(clone_info);
clone_info = NULL;
}
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
if (image==NULL)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
else
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image *VAR_2, *VAR_3=NULL,
*VAR_4;
PixelPacket *VAR_5;
unsigned int VAR_6;
MATHeader VAR_7;
size_t VAR_8;
size_t VAR_9;
QuantumInfo *VAR_10;
ImageInfo *VAR_11;
int VAR_12;
ssize_t VAR_13;
unsigned char *VAR_14 = NULL;
double VAR_15, VAR_16;
size_t VAR_17;
unsigned VAR_18, VAR_19;
unsigned VAR_20;
int VAR_21;
int VAR_22;
MagickOffsetType VAR_23=0x80;
BlobInfo *VAR_24;
size_t VAR_25;
unsigned int (*VAR_26)(Image *VAR_2);
unsigned short (*VAR_27)(Image *VAR_2);
void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_32);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_32);
VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");
VAR_10=(QuantumInfo *) NULL;
VAR_2 = AcquireImage(VAR_0);
VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
if (VAR_6 == VAR_35)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_11=(ImageInfo *) NULL;
if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
{
VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
if (VAR_3  == NULL)
goto MATLAB_KO;
VAR_2=VAR_3;
goto END_OF_READING;
}
VAR_7.Version = ReadBlobLSBShort(VAR_2);
if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
{
VAR_26 = VAR_37;
VAR_27 = VAR_38;
VAR_28 = VAR_39;
VAR_31 = VAR_40;
VAR_2->endian = VAR_41;
}
else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
{
VAR_26 = VAR_42;
VAR_27 = VAR_43;
VAR_28 = VAR_44;
VAR_31 = VAR_45;
VAR_2->endian = VAR_46;
}
else
goto MATLAB_KO;    
if (strncmp(VAR_7.identific, ""MATLAB"", 6))
{
MATLAB_KO:
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_36,""ImproperImageHeader"");
}
VAR_23 = TellBlob(VAR_2);
while(!EOFBlob(VAR_2)) 
{
VAR_20 = 1;
(void) SeekBlob(VAR_2,VAR_23,VAR_47);
VAR_7.DataType = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
VAR_7.ObjectSize = VAR_26(VAR_2);
if(EOFBlob(VAR_2)) break;
if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))
goto MATLAB_KO;
VAR_23 += VAR_7.ObjectSize + 4 + 4;
VAR_11=CloneImageInfo(VAR_0);
VAR_3 = VAR_2;
#if defined(VAR_49)
if(VAR_7.DataType == VAR_50)
{
VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
if(VAR_3==NULL) continue;
VAR_7.DataType = VAR_26(VAR_3); 
}
#endif
if(VAR_7.DataType!=VAR_51) continue;  
VAR_7.unknown1 = VAR_26(VAR_3);
VAR_7.unknown2 = VAR_26(VAR_3);
VAR_7.unknown5 = VAR_26(VAR_3);
VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;
VAR_7.unknown3 = VAR_26(VAR_3);
if(VAR_2!=VAR_3)
VAR_7.unknown4 = VAR_26(VAR_3);  
VAR_7.unknown4 = VAR_26(VAR_3);
VAR_7.DimFlag = VAR_26(VAR_3);
VAR_7.SizeX = VAR_26(VAR_3);
VAR_7.SizeY = VAR_26(VAR_3);
switch(VAR_7.DimFlag)
{
case  8: VAR_19=VAR_18=1; break;      
case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  
VAR_17 = VAR_26(VAR_3);
(void) VAR_17;
if(VAR_18!=3) ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
break;
case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  
if(VAR_18!=3 && VAR_18!=1)
ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
VAR_20 = VAR_26(VAR_3);
if (VAR_20 == 0)
ThrowReaderException(VAR_36,""ImproperImageHeader"");
break;
default:
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
}
VAR_7.Flag1 = VAR_27(VAR_3);
VAR_7.NameFlag = VAR_27(VAR_3);
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
if (VAR_7.StructureClass != VAR_53 &&
VAR_7.StructureClass != VAR_54 &&    
VAR_7.StructureClass != VAR_55 &&    
VAR_7.StructureClass != VAR_56 &&
VAR_7.StructureClass != VAR_57 &&    
VAR_7.StructureClass != VAR_58 &&
VAR_7.StructureClass != VAR_59 &&    
VAR_7.StructureClass != VAR_60 &&
VAR_7.StructureClass != VAR_61 &&    
VAR_7.StructureClass != VAR_62 &&
VAR_7.StructureClass != VAR_63)    
ThrowReaderException(VAR_52,""UnsupportedCellTypeInTheMatrix"");
switch (VAR_7.NameFlag)
{
case 0:
VAR_8 = VAR_26(VAR_3);  
VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
(void) SeekBlob(VAR_3, VAR_8, VAR_64);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); 
break;
default:
goto MATLAB_KO;
}
VAR_9 = VAR_26(VAR_3);    
if (VAR_21)
(void) LogMagickEvent(VAR_33,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     
NEXT_FRAME:
switch (VAR_9)
{
case VAR_65:
case VAR_66:
VAR_22 = 8;
if(VAR_7.StructureFlag & VAR_67)
VAR_2->depth = 1;
else
VAR_2->depth = 8;         
VAR_13 = (ssize_t) VAR_7.SizeX;
break;
case VAR_68:
case VAR_69:
VAR_22 = 16;
VAR_2->depth = 16;        
VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
break;
case VAR_70:
case VAR_71:
VAR_22 = 32;
VAR_2->depth = 32;        
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_72:
case VAR_73:
VAR_22 = 64;
VAR_2->depth = 64;        
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
case VAR_74:
VAR_22 = 32;
VAR_2->depth = 32;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
if (VAR_7.StructureFlag & VAR_75)
{              
}
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_76:
VAR_22 = 64;
VAR_2->depth = 64;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
VAR_77
ThrowReaderException(VAR_52, ""IncompatibleSizeOfDouble"");
if (VAR_7.StructureFlag & VAR_75)
{                         
}
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
default:
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_52, ""UnsupportedCellTypeInTheMatrix"");
}
(void) VAR_22;
VAR_2->columns = VAR_7.SizeX;
VAR_2->rows = VAR_7.SizeY;
VAR_25=1;
VAR_2->colors = VAR_25 << VAR_2->depth;
if (VAR_2->columns == 0 || VAR_2->rows == 0)
goto MATLAB_KO;
if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
goto MATLAB_KO;
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_75) == 0))
{
SetImageColorspace(VAR_2,VAR_78);
VAR_2->type=VAR_79;
}
if (VAR_0->ping)
{
size_t VAR_80 = VAR_2->columns;
VAR_2->columns = VAR_2->rows;
VAR_2->rows = VAR_80;
goto done_reading; 
}
VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
if (VAR_6 == VAR_35)
{
InheritException(VAR_1,&VAR_2->exception);
return(DestroyImageList(VAR_2));
}
VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
if (VAR_10 == (QuantumInfo *) NULL)
ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    
if (VAR_14 == NULL)
ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
(void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));
VAR_15 = 0;
VAR_16 = 0;
if (VAR_9==VAR_76 || VAR_9==VAR_74)        
{
CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
}
if(VAR_18==1) VAR_18=0; 
do
{
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
if (VAR_5 == (PixelPacket *) NULL)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto done_reading;    
}
if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))
{
FixLogical((unsigned char *)VAR_14,VAR_13);
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
{
ImportQuantumPixelsFailed:
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
break;
}
}
else
{
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
goto ImportQuantumPixelsFailed;
if (VAR_18<=1 &&       
(VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))
FixSignedValues(VAR_5,VAR_7.SizeX);
}
if (!SyncAuthenticPixels(VAR_2,VAR_1))
{
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
}
} while(VAR_18-- >= 2);
ExitLoop:
if (VAR_7.StructureFlag & VAR_75)
{        
VAR_9 = VAR_26(VAR_3);    
VAR_12 = VAR_26(VAR_3);           
if (VAR_9==VAR_76 || VAR_9==VAR_74)
{
CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
}
if (VAR_9==VAR_76)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_28(VAR_3, VAR_13, (double *)VAR_14);
InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
if (VAR_9==VAR_74)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_31(VAR_3, VAR_13, (float *)VAR_14);
InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
}
}
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_75) == 0))
VAR_2->type=VAR_79;
if (VAR_2->depth == 1)
VAR_2->type=VAR_83;
if(VAR_3==VAR_2)
VAR_3 = NULL;    
VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
if (VAR_4 != (Image *) NULL)
{
VAR_4->page.x=0;
VAR_4->page.y=0;
VAR_24 = VAR_4->blob;
VAR_4->blob = VAR_2->blob;
VAR_4->colors = VAR_2->colors;
VAR_2->blob = VAR_24;
AppendImageToList(&VAR_2,VAR_4);
DeleteImageFromList(&VAR_2);
}
done_reading:
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
}
}
AcquireNextImage(VAR_0,VAR_2);
if (VAR_2->next == (Image *) NULL) break;
VAR_2=SyncNextImageInList(VAR_2);
VAR_2->columns=VAR_2->rows=0;
VAR_2->colors=0;
RelinquishMagickMemory(VAR_14);
VAR_14 = NULL;
if(--VAR_20>0)
{
VAR_18 = VAR_19;
if(VAR_3==NULL) VAR_3 = VAR_2;
goto NEXT_FRAME;
}
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)   
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) unlink(VAR_11->filename);
}
}
}
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
}
RelinquishMagickMemory(VAR_14);
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
CloseBlob(VAR_2);
{
Image *VAR_84;
ssize_t VAR_85=0;
VAR_84=VAR_2;
VAR_2=NULL;
while (VAR_84 != (Image *) NULL)
{
Image *VAR_86=VAR_84;
if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {
VAR_84=VAR_84->previous;
DeleteImageFromList(&VAR_86);
} else {
VAR_2=VAR_84;
VAR_84=VAR_84->previous;
}
}
for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)
VAR_84->scene=VAR_85++;
}
if(VAR_11 != NULL)  
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
DestroyImageInfo(VAR_11);
VAR_11 = NULL;
}
if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
if (VAR_2==NULL)
ThrowReaderException(VAR_36,""ImproperImageHeader"")
else
if ((image != VAR_3) && (VAR_3 != (Image *) VAR_87))
VAR_3=DestroyImage(VAR_3);
return (image);
}",ImageMagick/7d957e40e68c9af33f24d52f610d48ec758e88d9/mat.c/vul/before/0.json,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  quantum_info=(QuantumInfo *) NULL;
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  clone_info=(ImageInfo *) NULL;
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    /* unsupported endian */

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(!EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              /* complex float type cell */
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         /* complex double type cell */
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
      /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if (image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  else
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
  return (image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image *VAR_2, *VAR_3=NULL,
   *VAR_4;
  PixelPacket *VAR_5;

  unsigned int VAR_6;
  MATHeader VAR_7;
  size_t VAR_8;
  size_t VAR_9;
  QuantumInfo *VAR_10;
  ImageInfo *VAR_11;
  int VAR_12;
  ssize_t VAR_13;
  unsigned char *VAR_14 = NULL;
  double VAR_15, VAR_16;
  size_t VAR_17;
  unsigned VAR_18, VAR_19;
  unsigned VAR_20;
  int VAR_21;
  int VAR_22;
  MagickOffsetType VAR_23=0x80;
  BlobInfo *VAR_24;
  size_t VAR_25;

  unsigned int (*VAR_26)(Image *VAR_2);
  unsigned short (*VAR_27)(Image *VAR_2);
  void (*VAR_28)(Image * VAR_2, size_t VAR_29, double *VAR_30);
  void (*VAR_31)(Image * VAR_2, size_t VAR_29, float *VAR_30);


  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_32);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_32);
  VAR_21 = LogMagickEvent(VAR_33,GetMagickModule(),""enter"");

  /* COMMENT_0 */
                     
     
  VAR_10=(QuantumInfo *) NULL;
  VAR_2 = AcquireImage(VAR_0);

  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_34, VAR_1);
  if (VAR_6 == VAR_35)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                       
     
  VAR_11=(ImageInfo *) NULL;
  if(ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");
  if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
    {
      VAR_3=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
      if (VAR_3  == NULL)
        goto MATLAB_KO;
      VAR_2=VAR_3;
      goto END_OF_READING;
    }
  VAR_7.Version = ReadBlobLSBShort(VAR_2);
  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
    ThrowReaderException(VAR_36,""ImproperImageHeader"");

  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""  Endian %c%c"",
        VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
  if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
  {
    VAR_26 = VAR_37;
    VAR_27 = VAR_38;
    VAR_28 = VAR_39;
    VAR_31 = VAR_40;
    VAR_2->endian = VAR_41;
  }
  else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
  {
    VAR_26 = VAR_42;
    VAR_27 = VAR_43;
    VAR_28 = VAR_44;
    VAR_31 = VAR_45;
    VAR_2->endian = VAR_46;
  }
  else
    goto MATLAB_KO;    /* COMMENT_6 */

  if (strncmp(VAR_7.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
        VAR_3=DestroyImage(VAR_3);
      if (VAR_11 != (ImageInfo *) NULL)
        VAR_11=DestroyImageInfo(VAR_11);
      ThrowReaderException(VAR_36,""ImproperImageHeader"");
    }

  VAR_23 = TellBlob(VAR_2);
  while(!EOFBlob(VAR_2)) /* COMMENT_7 */
  {
    VAR_20 = 1;
    (void) SeekBlob(VAR_2,VAR_23,VAR_47);
    /* COMMENT_8 */

    VAR_7.DataType = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    VAR_7.ObjectSize = VAR_26(VAR_2);
    if(EOFBlob(VAR_2)) break;
    if((VAR_48) (VAR_7.ObjectSize+VAR_23) > GetBlobSize(VAR_2))
      goto MATLAB_KO;
    VAR_23 += VAR_7.ObjectSize + 4 + 4;

    VAR_11=CloneImageInfo(VAR_0);
    VAR_3 = VAR_2;
#if defined(VAR_49)
    if(VAR_7.DataType == VAR_50)
    {
      VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
      if(VAR_3==NULL) continue;
      VAR_7.DataType = VAR_26(VAR_3); /* COMMENT_9 */
    }
#endif

    if(VAR_7.DataType!=VAR_51) continue;  /* COMMENT_10 */

    VAR_7.unknown1 = VAR_26(VAR_3);
    VAR_7.unknown2 = VAR_26(VAR_3);

    VAR_7.unknown5 = VAR_26(VAR_3);
    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;

    VAR_7.unknown3 = VAR_26(VAR_3);
    if(VAR_2!=VAR_3)
      VAR_7.unknown4 = VAR_26(VAR_3);  /* COMMENT_11 */
    VAR_7.unknown4 = VAR_26(VAR_3);
    VAR_7.DimFlag = VAR_26(VAR_3);
    VAR_7.SizeX = VAR_26(VAR_3);
    VAR_7.SizeY = VAR_26(VAR_3);


    switch(VAR_7.DimFlag)
    {
      case  8: VAR_19=VAR_18=1; break;      /* COMMENT_12 */
      case 12: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_13 */
           VAR_17 = VAR_26(VAR_3);
           (void) VAR_17;
         if(VAR_18!=3) ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: VAR_19=VAR_18 = VAR_26(VAR_3);  /* COMMENT_14 */
         if(VAR_18!=3 && VAR_18!=1)
           ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
         VAR_20 = VAR_26(VAR_3);
         if (VAR_20 == 0)
           ThrowReaderException(VAR_36,""ImproperImageHeader"");
         break;
      default:
        if (VAR_11 != (ImageInfo *) NULL)
          VAR_11=DestroyImageInfo(VAR_11);
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        ThrowReaderException(VAR_52, ""MultidimensionalMatricesAreNotSupported"");
    }

    VAR_7.Flag1 = VAR_27(VAR_3);
    VAR_7.NameFlag = VAR_27(VAR_3);

    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
    if (VAR_7.StructureClass != VAR_53 &&
        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_15 */
        VAR_7.StructureClass != VAR_55 &&    /* COMMENT_16 */
        VAR_7.StructureClass != VAR_56 &&
        VAR_7.StructureClass != VAR_57 &&    /* COMMENT_17 */
        VAR_7.StructureClass != VAR_58 &&
        VAR_7.StructureClass != VAR_59 &&    /* COMMENT_18 */
        VAR_7.StructureClass != VAR_60 &&
        VAR_7.StructureClass != VAR_61 &&    /* COMMENT_19 */
        VAR_7.StructureClass != VAR_62 &&
        VAR_7.StructureClass != VAR_63)    /* COMMENT_20 */
      ThrowReaderException(VAR_52,""UnsupportedCellTypeInTheMatrix"");

    switch (VAR_7.NameFlag)
    {
      case 0:
        VAR_8 = VAR_26(VAR_3);  /* COMMENT_21 */
        VAR_8 = 4 * (ssize_t) ((VAR_8 + 3 + 1) / 4);
        (void) SeekBlob(VAR_3, VAR_8, VAR_64);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_22 */
        break;
      default:
        goto MATLAB_KO;
    }

    VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
    if (VAR_21)
      (void) LogMagickEvent(VAR_33,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);

    (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8);     /* COMMENT_24 */

NEXT_FRAME:
    switch (VAR_9)
    {
      case VAR_65:
      case VAR_66:
        VAR_22 = 8;
        if(VAR_7.StructureFlag & VAR_67)
          VAR_2->depth = 1;
        else
          VAR_2->depth = 8;         /* COMMENT_25 */
        VAR_13 = (ssize_t) VAR_7.SizeX;
        break;
      case VAR_68:
      case VAR_69:
        VAR_22 = 16;
        VAR_2->depth = 16;        /* COMMENT_26 */
        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
        break;
      case VAR_70:
      case VAR_71:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_27 */
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_72:
      case VAR_73:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_28 */
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      case VAR_74:
        VAR_22 = 32;
        VAR_2->depth = 32;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
        if (VAR_7.StructureFlag & VAR_75)
  {              /* COMMENT_30 */
  }
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_76:
        VAR_22 = 64;
        VAR_2->depth = 64;        /* COMMENT_29 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
VAR_77
          ThrowReaderException(VAR_52, ""IncompatibleSizeOfDouble"");
        if (VAR_7.StructureFlag & VAR_75)
  {                         /* COMMENT_31 */
  }
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      default:
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        if (VAR_11)
          VAR_11=DestroyImageInfo(VAR_11);
        ThrowReaderException(VAR_52, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) VAR_22;
    VAR_2->columns = VAR_7.SizeX;
    VAR_2->rows = VAR_7.SizeY;
    VAR_25=1;
    VAR_2->colors = VAR_25 << VAR_2->depth;
    if (VAR_2->columns == 0 || VAR_2->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
      goto MATLAB_KO;
      /* COMMENT_32 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_75) == 0))
      {
        SetImageColorspace(VAR_2,VAR_78);
        VAR_2->type=VAR_79;
      }


    /* COMMENT_33 */
                                                                  
                             
      
    if (VAR_0->ping)
    {
      size_t VAR_80 = VAR_2->columns;
      VAR_2->columns = VAR_2->rows;
      VAR_2->rows = VAR_80;
      goto done_reading; /* COMMENT_37 */
    }
    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows);
    if (VAR_6 == VAR_35)
      {
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        InheritException(VAR_1,&VAR_2->exception);
        return(DestroyImageList(VAR_2));
      }
    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
    if (VAR_10 == (QuantumInfo *) NULL)
      ThrowReaderException(VAR_81,""MemoryAllocationFailed"");

  /* COMMENT_38 */
    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_39 */
    if (VAR_14 == NULL)
      ThrowReaderException(VAR_81,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(VAR_14,0,VAR_13*sizeof(double));

    VAR_15 = 0;
    VAR_16 = 0;
    if (VAR_9==VAR_76 || VAR_9==VAR_74)        /* COMMENT_40 */
    {
      CalcMinMax(VAR_3, VAR_0->endian,  VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_10->minimum, &VAR_10->maximum);
    }

    /* COMMENT_41 */
    if(VAR_18==1) VAR_18=0; /* COMMENT_42 */
    /* COMMENT_43 */
    do
    {
      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
      {
        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
        if (VAR_5 == (PixelPacket *) NULL)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto done_reading;    /* COMMENT_44 */
  }
        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
        if((VAR_9==VAR_65 || VAR_9==VAR_66) && (VAR_7.StructureFlag & VAR_67))
        {
          FixLogical((unsigned char *)VAR_14,VAR_13);
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
    {
ImportQuantumPixelsFailed:
      if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_82[VAR_18],VAR_14,VAR_1) <= 0)
      goto ImportQuantumPixelsFailed;


          if (VAR_18<=1 &&       /* COMMENT_45 */
          (VAR_9==VAR_65 || VAR_9==VAR_68 || VAR_9==VAR_70 || VAR_9==VAR_72))
      FixSignedValues(VAR_5,VAR_7.SizeX);
        }

        if (!SyncAuthenticPixels(VAR_2,VAR_1))
  {
    if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
    goto ExitLoop;
  }
      }
    } while(VAR_18-- >= 2);
ExitLoop:


    /* COMMENT_46 */
    if (VAR_7.StructureFlag & VAR_75)
    {        /* COMMENT_47 */
      VAR_9 = VAR_26(VAR_3);    /* COMMENT_23 */
      VAR_12 = VAR_26(VAR_3);           /* COMMENT_48 */

      if (VAR_9==VAR_76 || VAR_9==VAR_74)
      {
        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
      }

      if (VAR_9==VAR_76)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_28(VAR_3, VAR_13, (double *)VAR_14);
          InsertComplexDoubleRow((double *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }

      if (VAR_9==VAR_74)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
  {
          VAR_31(VAR_3, VAR_13, (float *)VAR_14);
          InsertComplexFloatRow((float *)VAR_14, VAR_12, VAR_2, VAR_15, VAR_16);
  }
    }

      /* COMMENT_49 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_75) == 0))
      VAR_2->type=VAR_79;
    if (VAR_2->depth == 1)
      VAR_2->type=VAR_83;

    if(VAR_3==VAR_2)
        VAR_3 = NULL;    /* COMMENT_50 */

      /* COMMENT_51 */
    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
    if (VAR_4 != (Image *) NULL)
    {
        /* COMMENT_52 */
      VAR_4->page.x=0;
      VAR_4->page.y=0;

      VAR_24 = VAR_4->blob;
      VAR_4->blob = VAR_2->blob;
      VAR_4->colors = VAR_2->colors;
      VAR_2->blob = VAR_24;
      AppendImageToList(&VAR_2,VAR_4);
      DeleteImageFromList(&VAR_2);
    }

done_reading:

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)
      {
        DeleteImageFromList(&VAR_3);
  if(VAR_11)
  {
          if(VAR_11->file)
    {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) remove_utf8(VAR_11->filename);
    }
        }
      }

      /* COMMENT_53 */
    AcquireNextImage(VAR_0,VAR_2);
    if (VAR_2->next == (Image *) NULL) break;
    VAR_2=SyncNextImageInList(VAR_2);
    VAR_2->columns=VAR_2->rows=0;
    VAR_2->colors=0;

      /* COMMENT_54 */
    RelinquishMagickMemory(VAR_14);
    VAR_14 = NULL;

    if(--VAR_20>0)
    {
      VAR_18 = VAR_19;
      if(VAR_3==NULL) VAR_3 = VAR_2;
      goto NEXT_FRAME;
    }

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)   /* COMMENT_55 */
      {
/* COMMENT_56 */
        DeleteImageFromList(&VAR_3);
        if(VAR_11)
        {
          if(VAR_11->file)
          {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) unlink(VAR_11->filename);
          }
         }
       }
    if (VAR_10 != (QuantumInfo *) NULL)
      VAR_10=DestroyQuantumInfo(VAR_10);
    if (VAR_11)
      VAR_11=DestroyImageInfo(VAR_11);
  }

  RelinquishMagickMemory(VAR_14);
  if (VAR_10 != (QuantumInfo *) NULL)
    VAR_10=DestroyQuantumInfo(VAR_10);
END_OF_READING:
  if (VAR_11)
    VAR_11=DestroyImageInfo(VAR_11);
  CloseBlob(VAR_2);


  {
    Image *VAR_84;
    ssize_t VAR_85=0;

    /* COMMENT_57 */
                                                             
      
    VAR_84=VAR_2;
    VAR_2=NULL;
    while (VAR_84 != (Image *) NULL)
      {
        Image *VAR_86=VAR_84;
        if ((VAR_84->rows == 0) || (VAR_84->columns == 0)) {
          VAR_84=VAR_84->previous;
          DeleteImageFromList(&VAR_86);
        } else {
          VAR_2=VAR_84;
          VAR_84=VAR_84->previous;
        }
      }

    /* COMMENT_60 */
                       
      
    for (VAR_84=VAR_2; VAR_84 != (Image *) NULL; VAR_84=VAR_84->next)
      VAR_84->scene=VAR_85++;
  }

  if(VAR_11 != NULL)  /* COMMENT_63 */
  {
    if(VAR_11->file)
    {
      fclose(VAR_11->file);
      VAR_11->file = NULL;
      (void) remove_utf8(VAR_11->filename);
    }
    DestroyImageInfo(VAR_11);
    VAR_11 = NULL;
  }
  if (VAR_21) (void)LogMagickEvent(VAR_33,GetMagickModule(),""return"");
  if (VAR_2==NULL)
    ThrowReaderException(VAR_36,""ImproperImageHeader"")
  else
    if ((image != VAR_3) && (VAR_3 != (Image *) VAR_87))
      VAR_3=DestroyImage(VAR_3);
  return (image);
}",ImageMagick/7d957e40e68c9af33f24d52f610d48ec758e88d9/mat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -296,6 +296,8 @@
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
+        if ((image != image2) && (image2 != (Image *) NULL))
+          image2=DestroyImage(image2);
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }","{'deleted_lines': [], 'added_lines': ['        if ((image != image2) && (image2 != (Image *) NULL))', '          image2=DestroyImage(image2);']}",True,"In ImageMagick 7.0.6-5, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service via a crafted file.",6.5,MEDIUM,1,test,2017-08-04T11:18:29Z,2
CVE-2017-15127,['CWE-460'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"userfaultfd: hugetlbfs: remove superfluous page unlock in VM_SHARED case

huge_add_to_page_cache->add_to_page_cache implicitly unlocks the page
before returning in case of errors.

The error returned was -EEXIST by running UFFDIO_COPY on a non-hole
offset of a VM_SHARED hugetlbfs mapping.  It was an userland bug that
triggered it and the kernel must cope with it returning -EEXIST from
ioctl(UFFDIO_COPY) as expected.

  page dumped because: VM_BUG_ON_PAGE(!PageLocked(page))
  kernel BUG at mm/filemap.c:964!
  invalid opcode: 0000 [#1] SMP
  CPU: 1 PID: 22582 Comm: qemu-system-x86 Not tainted 4.11.11-300.fc26.x86_64 #1
  RIP: unlock_page+0x4a/0x50
  Call Trace:
    hugetlb_mcopy_atomic_pte+0xc0/0x320
    mcopy_atomic+0x96f/0xbe0
    userfaultfd_ioctl+0x218/0xe90
    do_vfs_ioctl+0xa5/0x600
    SyS_ioctl+0x79/0x90
    entry_SYSCALL_64_fastpath+0x1a/0xa9

Link: http://lkml.kernel.org/r/20170802165145.22628-2-aarcange@redhat.com
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Tested-by: Maxime Coquelin <maxime.coquelin@redhat.com>
Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
Cc: ""Dr. David Alan Gilbert"" <dgilbert@redhat.com>
Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
Cc: Alexey Perevalov <a.perevalov@samsung.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",5af10dfd0afc559bb4b0f7e3e8227a1578333995,https://github.com/torvalds/linux/commit/5af10dfd0afc559bb4b0f7e3e8227a1578333995,mm/hugetlb.c,hugetlb_mcopy_atomic_pte,"int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
pte_t *dst_pte,
struct vm_area_struct *dst_vma,
unsigned long dst_addr,
unsigned long src_addr,
struct page **pagep)
{
int vm_shared = dst_vma->vm_flags & VM_SHARED;
struct hstate *h = hstate_vma(dst_vma);
pte_t _dst_pte;
spinlock_t *ptl;
int ret;
struct page *page;
if (!*pagep) {
ret = -ENOMEM;
page = alloc_huge_page(dst_vma, dst_addr, 0);
if (IS_ERR(page))
goto out;
ret = copy_huge_page_from_user(page,
(const void __user *) src_addr,
pages_per_huge_page(h), false);
if (unlikely(ret)) {
ret = -EFAULT;
*pagep = page;
goto out;
}
} else {
page = *pagep;
*pagep = NULL;
}
__SetPageUptodate(page);
set_page_huge_active(page);
if (vm_shared) {
struct address_space *mapping = dst_vma->vm_file->f_mapping;
pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);
ret = huge_add_to_page_cache(page, mapping, idx);
if (ret)
goto out_release_nounlock;
}
ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
spin_lock(ptl);
ret = -EEXIST;
if (!huge_pte_none(huge_ptep_get(dst_pte)))
goto out_release_unlock;
if (vm_shared) {
page_dup_rmap(page, true);
} else {
ClearPagePrivate(page);
hugepage_add_new_anon_rmap(page, dst_vma, dst_addr);
}
_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);
if (dst_vma->vm_flags & VM_WRITE)
_dst_pte = huge_pte_mkdirty(_dst_pte);
_dst_pte = pte_mkyoung(_dst_pte);
set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);
(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,
dst_vma->vm_flags & VM_WRITE);
hugetlb_count_add(pages_per_huge_page(h), dst_mm);
update_mmu_cache(dst_vma, dst_addr, dst_pte);
spin_unlock(ptl);
if (vm_shared)
unlock_page(page);
ret = 0;
out:
return ret;
out_release_unlock:
spin_unlock(ptl);
out_release_nounlock:
if (vm_shared)
unlock_page(page);
put_page(page);
goto out;
}","int hugetlb_mcopy_atomic_pte(struct mm_struct *VAR_0,
pte_t *VAR_1,
struct vm_area_struct *VAR_2,
unsigned long VAR_3,
unsigned long VAR_4,
struct page **VAR_5)
{
int VAR_6 = VAR_2->vm_flags & VAR_7;
struct hstate *VAR_8 = hstate_vma(VAR_2);
pte_t VAR_9;
spinlock_t *VAR_10;
int VAR_11;
struct page *page;
if (!*VAR_5) {
VAR_11 = -VAR_12;
page = alloc_huge_page(VAR_2, VAR_3, 0);
if (IS_ERR(page))
goto out;
VAR_11 = copy_huge_page_from_user(page,
(const void __user *) VAR_4,
pages_per_huge_page(VAR_8), false);
if (unlikely(VAR_11)) {
VAR_11 = -VAR_13;
*VAR_5 = page;
goto out;
}
} else {
page = *VAR_5;
*VAR_5 = NULL;
}
__SetPageUptodate(page);
set_page_huge_active(page);
if (VAR_6) {
struct address_space *VAR_14 = VAR_2->vm_file->f_mapping;
pgoff_t VAR_15 = vma_hugecache_offset(VAR_8, VAR_2, VAR_3);
VAR_11 = huge_add_to_page_cache(page, VAR_14, VAR_15);
if (VAR_11)
goto out_release_nounlock;
}
VAR_10 = huge_pte_lockptr(VAR_8, VAR_0, VAR_1);
spin_lock(VAR_10);
VAR_11 = -VAR_16;
if (!huge_pte_none(huge_ptep_get(VAR_1)))
goto out_release_unlock;
if (VAR_6) {
page_dup_rmap(page, true);
} else {
ClearPagePrivate(page);
hugepage_add_new_anon_rmap(page, VAR_2, VAR_3);
}
VAR_9 = make_huge_pte(VAR_2, page, VAR_2->vm_flags & VAR_17);
if (VAR_2->vm_flags & VAR_17)
VAR_9 = huge_pte_mkdirty(VAR_9);
VAR_9 = pte_mkyoung(VAR_9);
set_huge_pte_at(VAR_0, VAR_3, VAR_1, VAR_9);
(void)huge_ptep_set_access_flags(VAR_2, VAR_3, VAR_1, VAR_9,
VAR_2->vm_flags & VAR_17);
hugetlb_count_add(pages_per_huge_page(VAR_8), VAR_0);
update_mmu_cache(VAR_2, VAR_3, VAR_1);
spin_unlock(VAR_10);
if (VAR_6)
unlock_page(page);
VAR_11 = 0;
out:
return VAR_11;
out_release_unlock:
spin_unlock(VAR_10);
out_release_nounlock:
if (VAR_6)
unlock_page(page);
put_page(page);
goto out;
}",torvalds/linux/5af10dfd0afc559bb4b0f7e3e8227a1578333995/hugetlb.c/vul/before/0.json,"int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
			    pte_t *dst_pte,
			    struct vm_area_struct *dst_vma,
			    unsigned long dst_addr,
			    unsigned long src_addr,
			    struct page **pagep)
{
	int vm_shared = dst_vma->vm_flags & VM_SHARED;
	struct hstate *h = hstate_vma(dst_vma);
	pte_t _dst_pte;
	spinlock_t *ptl;
	int ret;
	struct page *page;

	if (!*pagep) {
		ret = -ENOMEM;
		page = alloc_huge_page(dst_vma, dst_addr, 0);
		if (IS_ERR(page))
			goto out;

		ret = copy_huge_page_from_user(page,
						(const void __user *) src_addr,
						pages_per_huge_page(h), false);

		/* fallback to copy_from_user outside mmap_sem */
		if (unlikely(ret)) {
			ret = -EFAULT;
			*pagep = page;
			/* don't free the page */
			goto out;
		}
	} else {
		page = *pagep;
		*pagep = NULL;
	}

	/*
	 * The memory barrier inside __SetPageUptodate makes sure that
	 * preceding stores to the page contents become visible before
	 * the set_pte_at() write.
	 */
	__SetPageUptodate(page);
	set_page_huge_active(page);

	/*
	 * If shared, add to page cache
	 */
	if (vm_shared) {
		struct address_space *mapping = dst_vma->vm_file->f_mapping;
		pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);

		ret = huge_add_to_page_cache(page, mapping, idx);
		if (ret)
			goto out_release_nounlock;
	}

	ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
	spin_lock(ptl);

	ret = -EEXIST;
	if (!huge_pte_none(huge_ptep_get(dst_pte)))
		goto out_release_unlock;

	if (vm_shared) {
		page_dup_rmap(page, true);
	} else {
		ClearPagePrivate(page);
		hugepage_add_new_anon_rmap(page, dst_vma, dst_addr);
	}

	_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);
	if (dst_vma->vm_flags & VM_WRITE)
		_dst_pte = huge_pte_mkdirty(_dst_pte);
	_dst_pte = pte_mkyoung(_dst_pte);

	set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);

	(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,
					dst_vma->vm_flags & VM_WRITE);
	hugetlb_count_add(pages_per_huge_page(h), dst_mm);

	/* No need to invalidate - it was non-present before */
	update_mmu_cache(dst_vma, dst_addr, dst_pte);

	spin_unlock(ptl);
	if (vm_shared)
		unlock_page(page);
	ret = 0;
out:
	return ret;
out_release_unlock:
	spin_unlock(ptl);
	if (vm_shared)
		unlock_page(page);
out_release_nounlock:
	put_page(page);
	goto out;
}","int hugetlb_mcopy_atomic_pte(struct mm_struct *VAR_0,
			    pte_t *VAR_1,
			    struct vm_area_struct *VAR_2,
			    unsigned long VAR_3,
			    unsigned long VAR_4,
			    struct page **VAR_5)
{
	int VAR_6 = VAR_2->vm_flags & VAR_7;
	struct hstate *VAR_8 = hstate_vma(VAR_2);
	pte_t VAR_9;
	spinlock_t *VAR_10;
	int VAR_11;
	struct page *page;

	if (!*VAR_5) {
		VAR_11 = -VAR_12;
		page = alloc_huge_page(VAR_2, VAR_3, 0);
		if (IS_ERR(page))
			goto out;

		VAR_11 = copy_huge_page_from_user(page,
						(const void __user *) VAR_4,
						pages_per_huge_page(VAR_8), false);

		/* COMMENT_0 */
		if (unlikely(VAR_11)) {
			VAR_11 = -VAR_13;
			*VAR_5 = page;
			/* COMMENT_1 */
			goto out;
		}
	} else {
		page = *VAR_5;
		*VAR_5 = NULL;
	}

	/* COMMENT_2 */
                                                               
                                                               
                           
    
	__SetPageUptodate(page);
	set_page_huge_active(page);

	/* COMMENT_7 */
                                
    
	if (VAR_6) {
		struct address_space *VAR_14 = VAR_2->vm_file->f_mapping;
		pgoff_t VAR_15 = vma_hugecache_offset(VAR_8, VAR_2, VAR_3);

		VAR_11 = huge_add_to_page_cache(page, VAR_14, VAR_15);
		if (VAR_11)
			goto out_release_nounlock;
	}

	VAR_10 = huge_pte_lockptr(VAR_8, VAR_0, VAR_1);
	spin_lock(VAR_10);

	VAR_11 = -VAR_16;
	if (!huge_pte_none(huge_ptep_get(VAR_1)))
		goto out_release_unlock;

	if (VAR_6) {
		page_dup_rmap(page, true);
	} else {
		ClearPagePrivate(page);
		hugepage_add_new_anon_rmap(page, VAR_2, VAR_3);
	}

	VAR_9 = make_huge_pte(VAR_2, page, VAR_2->vm_flags & VAR_17);
	if (VAR_2->vm_flags & VAR_17)
		VAR_9 = huge_pte_mkdirty(VAR_9);
	VAR_9 = pte_mkyoung(VAR_9);

	set_huge_pte_at(VAR_0, VAR_3, VAR_1, VAR_9);

	(void)huge_ptep_set_access_flags(VAR_2, VAR_3, VAR_1, VAR_9,
					VAR_2->vm_flags & VAR_17);
	hugetlb_count_add(pages_per_huge_page(VAR_8), VAR_0);

	/* COMMENT_10 */
	update_mmu_cache(VAR_2, VAR_3, VAR_1);

	spin_unlock(VAR_10);
	if (VAR_6)
		unlock_page(page);
	VAR_11 = 0;
out:
	return VAR_11;
out_release_unlock:
	spin_unlock(VAR_10);
	if (VAR_6)
		unlock_page(page);
out_release_nounlock:
	put_page(page);
	goto out;
}",torvalds/linux/5af10dfd0afc559bb4b0f7e3e8227a1578333995/hugetlb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -90,9 +90,9 @@
 	return ret;
 out_release_unlock:
 	spin_unlock(ptl);
-out_release_nounlock:
 	if (vm_shared)
 		unlock_page(page);
+out_release_nounlock:
 	put_page(page);
 	goto out;
 }","{'deleted_lines': ['out_release_nounlock:'], 'added_lines': ['out_release_nounlock:']}",True,A flaw was found in the hugetlb_mcopy_atomic_pte function in mm/hugetlb.c in the Linux kernel before 4.13. A superfluous implicit page unlock for VM_SHARED hugetlbfs mapping could trigger a local denial of service (BUG).,5.5,MEDIUM,1,test,2017-08-10T22:23:38Z,2
CVE-2017-13134,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,Fixed buffer overflow reported in #670,1b234b4fe2ec864b2d5af898a31c06c9736da904,https://github.com/ImageMagick/ImageMagick/commit/1b234b4fe2ec864b2d5af898a31c06c9736da904,coders/sfw.c,SFWScan,"static unsigned char *SFWScan(unsigned char *p,const unsigned char *q,
const unsigned char *target,const size_t length)
{
register ssize_t
i;
if ((p+length) < q)
while (p < q)
{
for (i=0; i < (ssize_t) length; i++)
if (p[i] != target[i])
break;
if (i == (ssize_t) length)
return((unsigned char *) p);
p++;
}
return((unsigned char *) NULL);
}","static unsigned char *SFWScan(unsigned char *VAR_0,const unsigned char *VAR_1,
const unsigned char *VAR_2,const size_t VAR_3)
{
register ssize_t
VAR_4;
if ((VAR_0+VAR_3) < VAR_1)
while (VAR_0 < VAR_1)
{
for (VAR_4=0; VAR_4 < (ssize_t) VAR_3; VAR_4++)
if (VAR_0[VAR_4] != VAR_2[VAR_4])
break;
if (VAR_4 == (ssize_t) VAR_3)
return((unsigned char *) VAR_0);
VAR_0++;
}
return((unsigned char *) NULL);
}",ImageMagick/1b234b4fe2ec864b2d5af898a31c06c9736da904/sfw.c/vul/before/0.json,"static unsigned char *SFWScan(unsigned char *p,const unsigned char *q,
  const unsigned char *target,const size_t length)
{
  register ssize_t
    i;

  while ((p+length) < q)
  {
    for (i=0; i < (ssize_t) length; i++)
      if (p[i] != target[i])
        break;
    if (i == (ssize_t) length)
      return((unsigned char *) p);
    p++;
  }
  return((unsigned char *) NULL);
}","static unsigned char *SFWScan(unsigned char *VAR_0,const unsigned char *VAR_1,
  const unsigned char *VAR_2,const size_t VAR_3)
{
  register ssize_t
    VAR_4;

  while ((VAR_0+VAR_3) < VAR_1)
  {
    for (VAR_4=0; VAR_4 < (ssize_t) VAR_3; VAR_4++)
      if (VAR_0[VAR_4] != VAR_2[VAR_4])
        break;
    if (VAR_4 == (ssize_t) VAR_3)
      return((unsigned char *) VAR_0);
    VAR_0++;
  }
  return((unsigned char *) NULL);
}",ImageMagick/1b234b4fe2ec864b2d5af898a31c06c9736da904/sfw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,15 +4,14 @@
   register ssize_t
     i;
 
-  if ((p+length) < q)
-    while (p < q)
-    {
-      for (i=0; i < (ssize_t) length; i++)
-        if (p[i] != target[i])
-          break;
-      if (i == (ssize_t) length)
-        return((unsigned char *) p);
-      p++;
-    }
+  while ((p+length) < q)
+  {
+    for (i=0; i < (ssize_t) length; i++)
+      if (p[i] != target[i])
+        break;
+    if (i == (ssize_t) length)
+      return((unsigned char *) p);
+    p++;
+  }
   return((unsigned char *) NULL);
 }","{'deleted_lines': ['  if ((p+length) < q)', '    while (p < q)', '    {', '      for (i=0; i < (ssize_t) length; i++)', '        if (p[i] != target[i])', '          break;', '      if (i == (ssize_t) length)', '        return((unsigned char *) p);', '      p++;', '    }'], 'added_lines': ['  while ((p+length) < q)', '  {', '    for (i=0; i < (ssize_t) length; i++)', '      if (p[i] != target[i])', '        break;', '    if (i == (ssize_t) length)', '      return((unsigned char *) p);', '    p++;', '  }']}",True,"In ImageMagick 7.0.6-6 and GraphicsMagick 1.3.26, a heap-based buffer over-read was found in the function SFWScan in coders/sfw.c, which allows attackers to cause a denial of service via a crafted file.",6.5,MEDIUM,1,test,2017-08-12T08:44:51Z,2
CVE-2017-14152,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,uclouvain/openjpeg,Fix assertion in debug mode / heap-based buffer overflow in opj_write_bytes_LE for Cinema profiles with numresolutions = 1 (#985),4241ae6fbbf1de9658764a80944dc8108f2b4154,https://github.com/uclouvain/openjpeg/commit/4241ae6fbbf1de9658764a80944dc8108f2b4154,src/lib/openjp2/j2k.c,opj_j2k_set_cinema_parameters,"static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,
opj_image_t *image, opj_event_mgr_t *p_manager)
{
int i;
parameters->tile_size_on = OPJ_FALSE;
parameters->cp_tdx = 1;
parameters->cp_tdy = 1;
parameters->tp_flag = 'C';
parameters->tp_on = 1;
parameters->cp_tx0 = 0;
parameters->cp_ty0 = 0;
parameters->image_offset_x0 = 0;
parameters->image_offset_y0 = 0;
parameters->cblockw_init = 32;
parameters->cblockh_init = 32;
parameters->mode = 0;
parameters->roi_compno = -1;
parameters->subsampling_dx = 1;
parameters->subsampling_dy = 1;
parameters->irreversible = 1;
if (parameters->tcp_numlayers > 1) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""1 single quality layer""
""-> Number of layers forced to 1 (rather than %d)\n""
""-> Rate of the last layer (%3.1f) will be used"",
parameters->tcp_numlayers,
parameters->tcp_rates[parameters->tcp_numlayers - 1]);
parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
parameters->tcp_numlayers = 1;
}
switch (parameters->rsiz) {
case OPJ_PROFILE_CINEMA_2K:
if (parameters->numresolution > 6) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 (2k dc profile) requires:\n""
""Number of decomposition levels <= 5\n""
""-> Number of decomposition levels forced to 5 (rather than %d)\n"",
parameters->numresolution + 1);
parameters->numresolution = 6;
}
break;
case OPJ_PROFILE_CINEMA_4K:
if (parameters->numresolution < 2) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
""Number of decomposition levels >= 1 && <= 6\n""
""-> Number of decomposition levels forced to 1 (rather than %d)\n"",
parameters->numresolution + 1);
parameters->numresolution = 1;
} else if (parameters->numresolution > 7) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
""Number of decomposition levels >= 1 && <= 6\n""
""-> Number of decomposition levels forced to 6 (rather than %d)\n"",
parameters->numresolution + 1);
parameters->numresolution = 7;
}
break;
default :
break;
}
parameters->csty |= 0x01;
parameters->res_spec = parameters->numresolution - 1;
for (i = 0; i < parameters->res_spec; i++) {
parameters->prcw_init[i] = 256;
parameters->prch_init[i] = 256;
}
parameters->prog_order = OPJ_CPRL;
if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {
parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,
parameters->numresolution);
} else {
parameters->numpocs = 0;
}
parameters->cp_disto_alloc = 1;
if (parameters->max_cs_size <= 0) {
parameters->max_cs_size = OPJ_CINEMA_24_CS;
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1302083 compressed bytes @ 24fps\n""
""As no rate has been given, this limit will be used.\n"");
} else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1302083 compressed bytes @ 24fps\n""
""-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n"");
parameters->max_cs_size = OPJ_CINEMA_24_CS;
}
if (parameters->max_comp_size <= 0) {
parameters->max_comp_size = OPJ_CINEMA_24_COMP;
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1041666 compressed bytes @ 24fps\n""
""As no rate has been given, this limit will be used.\n"");
} else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1041666 compressed bytes @ 24fps\n""
""-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n"");
parameters->max_comp_size = OPJ_CINEMA_24_COMP;
}
parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *
image->comps[0].h * image->comps[0].prec) /
(OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *
image->comps[0].dy);
}","static void opj_j2k_set_cinema_parameters(opj_cparameters_t *VAR_0,
opj_image_t *VAR_1, opj_event_mgr_t *VAR_2)
{
int VAR_3;
VAR_0->tile_size_on = VAR_4;
VAR_0->cp_tdx = 1;
VAR_0->cp_tdy = 1;
VAR_0->tp_flag = 'C';
VAR_0->tp_on = 1;
VAR_0->cp_tx0 = 0;
VAR_0->cp_ty0 = 0;
VAR_0->image_offset_x0 = 0;
VAR_0->image_offset_y0 = 0;
VAR_0->cblockw_init = 32;
VAR_0->cblockh_init = 32;
VAR_0->mode = 0;
VAR_0->roi_compno = -1;
VAR_0->subsampling_dx = 1;
VAR_0->subsampling_dy = 1;
VAR_0->irreversible = 1;
if (VAR_0->tcp_numlayers > 1) {
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""1 single quality layer""
""-> Number of layers forced to 1 (rather than %d)\n""
""-> Rate of the last layer (%3.1f) will be used"",
VAR_0->tcp_numlayers,
VAR_0->tcp_rates[VAR_0->tcp_numlayers - 1]);
VAR_0->tcp_rates[0] = VAR_0->tcp_rates[VAR_0->tcp_numlayers - 1];
VAR_0->tcp_numlayers = 1;
}
switch (VAR_0->rsiz) {
case VAR_6:
if (VAR_0->numresolution > 6) {
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-3 (2k dc profile) requires:\n""
""Number of decomposition levels <= 5\n""
""-> Number of decomposition levels forced to 5 (rather than %d)\n"",
VAR_0->numresolution + 1);
VAR_0->numresolution = 6;
}
break;
case VAR_7:
if (VAR_0->numresolution < 2) {
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
""Number of decomposition levels >= 1 && <= 6\n""
""-> Number of decomposition levels forced to 1 (rather than %d)\n"",
VAR_0->numresolution + 1);
VAR_0->numresolution = 1;
} else if (VAR_0->numresolution > 7) {
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
""Number of decomposition levels >= 1 && <= 6\n""
""-> Number of decomposition levels forced to 6 (rather than %d)\n"",
VAR_0->numresolution + 1);
VAR_0->numresolution = 7;
}
break;
default :
break;
}
VAR_0->csty |= 0x01;
VAR_0->res_spec = VAR_0->numresolution - 1;
for (VAR_3 = 0; VAR_3 < VAR_0->res_spec; VAR_3++) {
VAR_0->prcw_init[VAR_3] = 256;
VAR_0->prch_init[VAR_3] = 256;
}
VAR_0->prog_order = VAR_8;
if (VAR_0->rsiz == VAR_7) {
VAR_0->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(VAR_0->POC,
VAR_0->numresolution);
} else {
VAR_0->numpocs = 0;
}
VAR_0->cp_disto_alloc = 1;
if (VAR_0->max_cs_size <= 0) {
VAR_0->max_cs_size = VAR_9;
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1302083 compressed bytes @ 24fps\n""
""As no rate has been given, this limit will be used.\n"");
} else if (VAR_0->max_cs_size > VAR_9) {
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1302083 compressed bytes @ 24fps\n""
""-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n"");
VAR_0->max_cs_size = VAR_9;
}
if (VAR_0->max_comp_size <= 0) {
VAR_0->max_comp_size = VAR_10;
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1041666 compressed bytes @ 24fps\n""
""As no rate has been given, this limit will be used.\n"");
} else if (VAR_0->max_comp_size > VAR_10) {
opj_event_msg(VAR_2, VAR_5,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1041666 compressed bytes @ 24fps\n""
""-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n"");
VAR_0->max_comp_size = VAR_10;
}
VAR_0->tcp_rates[0] = (VAR_11)(VAR_1->numcomps * VAR_1->comps[0].w *
VAR_1->comps[0].h * VAR_1->comps[0].prec) /
(VAR_11)(((OPJ_UINT32)VAR_0->max_cs_size) * 8 * VAR_1->comps[0].dx *
VAR_1->comps[0].dy);
}",uclouvain/openjpeg/4241ae6fbbf1de9658764a80944dc8108f2b4154/j2k.c/vul/before/0.json,"static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,
        opj_image_t *image, opj_event_mgr_t *p_manager)
{
    /* Configure cinema parameters */
    int i;

    /* No tiling */
    parameters->tile_size_on = OPJ_FALSE;
    parameters->cp_tdx = 1;
    parameters->cp_tdy = 1;

    /* One tile part for each component */
    parameters->tp_flag = 'C';
    parameters->tp_on = 1;

    /* Tile and Image shall be at (0,0) */
    parameters->cp_tx0 = 0;
    parameters->cp_ty0 = 0;
    parameters->image_offset_x0 = 0;
    parameters->image_offset_y0 = 0;

    /* Codeblock size= 32*32 */
    parameters->cblockw_init = 32;
    parameters->cblockh_init = 32;

    /* Codeblock style: no mode switch enabled */
    parameters->mode = 0;

    /* No ROI */
    parameters->roi_compno = -1;

    /* No subsampling */
    parameters->subsampling_dx = 1;
    parameters->subsampling_dy = 1;

    /* 9-7 transform */
    parameters->irreversible = 1;

    /* Number of layers */
    if (parameters->tcp_numlayers > 1) {
        opj_event_msg(p_manager, EVT_WARNING,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""1 single quality layer""
                      ""-> Number of layers forced to 1 (rather than %d)\n""
                      ""-> Rate of the last layer (%3.1f) will be used"",
                      parameters->tcp_numlayers,
                      parameters->tcp_rates[parameters->tcp_numlayers - 1]);
        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
        parameters->tcp_numlayers = 1;
    }

    /* Resolution levels */
    switch (parameters->rsiz) {
    case OPJ_PROFILE_CINEMA_2K:
        if (parameters->numresolution > 6) {
            opj_event_msg(p_manager, EVT_WARNING,
                          ""JPEG 2000 Profile-3 (2k dc profile) requires:\n""
                          ""Number of decomposition levels <= 5\n""
                          ""-> Number of decomposition levels forced to 5 (rather than %d)\n"",
                          parameters->numresolution + 1);
            parameters->numresolution = 6;
        }
        break;
    case OPJ_PROFILE_CINEMA_4K:
        if (parameters->numresolution < 2) {
            opj_event_msg(p_manager, EVT_WARNING,
                          ""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
                          ""Number of decomposition levels >= 1 && <= 6\n""
                          ""-> Number of decomposition levels forced to 1 (rather than %d)\n"",
                          parameters->numresolution + 1);
            parameters->numresolution = 1;
        } else if (parameters->numresolution > 7) {
            opj_event_msg(p_manager, EVT_WARNING,
                          ""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
                          ""Number of decomposition levels >= 1 && <= 6\n""
                          ""-> Number of decomposition levels forced to 6 (rather than %d)\n"",
                          parameters->numresolution + 1);
            parameters->numresolution = 7;
        }
        break;
    default :
        break;
    }

    /* Precincts */
    parameters->csty |= 0x01;
    if (parameters->numresolution == 1) {
        parameters->res_spec = 1;
        parameters->prcw_init[0] = 128;
        parameters->prch_init[0] = 128;
    } else {
        parameters->res_spec = parameters->numresolution - 1;
        for (i = 0; i < parameters->res_spec; i++) {
            parameters->prcw_init[i] = 256;
            parameters->prch_init[i] = 256;
        }
    }

    /* The progression order shall be CPRL */
    parameters->prog_order = OPJ_CPRL;

    /* Progression order changes for 4K, disallowed for 2K */
    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {
        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,
                              parameters->numresolution);
    } else {
        parameters->numpocs = 0;
    }

    /* Limited bit-rate */
    parameters->cp_disto_alloc = 1;
    if (parameters->max_cs_size <= 0) {
        /* No rate has been introduced, 24 fps is assumed */
        parameters->max_cs_size = OPJ_CINEMA_24_CS;
        opj_event_msg(p_manager, EVT_WARNING,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1302083 compressed bytes @ 24fps\n""
                      ""As no rate has been given, this limit will be used.\n"");
    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {
        opj_event_msg(p_manager, EVT_WARNING,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1302083 compressed bytes @ 24fps\n""
                      ""-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n"");
        parameters->max_cs_size = OPJ_CINEMA_24_CS;
    }

    if (parameters->max_comp_size <= 0) {
        /* No rate has been introduced, 24 fps is assumed */
        parameters->max_comp_size = OPJ_CINEMA_24_COMP;
        opj_event_msg(p_manager, EVT_WARNING,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1041666 compressed bytes @ 24fps\n""
                      ""As no rate has been given, this limit will be used.\n"");
    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {
        opj_event_msg(p_manager, EVT_WARNING,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1041666 compressed bytes @ 24fps\n""
                      ""-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n"");
        parameters->max_comp_size = OPJ_CINEMA_24_COMP;
    }

    parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *
                               image->comps[0].h * image->comps[0].prec) /
                               (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *
                                       image->comps[0].dy);

}","static void opj_j2k_set_cinema_parameters(opj_cparameters_t *VAR_0,
        opj_image_t *VAR_1, opj_event_mgr_t *VAR_2)
{
    /* COMMENT_0 */
    int VAR_3;

    /* COMMENT_1 */
    VAR_0->tile_size_on = VAR_4;
    VAR_0->cp_tdx = 1;
    VAR_0->cp_tdy = 1;

    /* COMMENT_2 */
    VAR_0->tp_flag = 'C';
    VAR_0->tp_on = 1;

    /* COMMENT_3 */
    VAR_0->cp_tx0 = 0;
    VAR_0->cp_ty0 = 0;
    VAR_0->image_offset_x0 = 0;
    VAR_0->image_offset_y0 = 0;

    /* COMMENT_4 */
    VAR_0->cblockw_init = 32;
    VAR_0->cblockh_init = 32;

    /* COMMENT_5 */
    VAR_0->mode = 0;

    /* COMMENT_6 */
    VAR_0->roi_compno = -1;

    /* COMMENT_7 */
    VAR_0->subsampling_dx = 1;
    VAR_0->subsampling_dy = 1;

    /* COMMENT_8 */
    VAR_0->irreversible = 1;

    /* COMMENT_9 */
    if (VAR_0->tcp_numlayers > 1) {
        opj_event_msg(VAR_2, VAR_5,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""1 single quality layer""
                      ""-> Number of layers forced to 1 (rather than %d)\n""
                      ""-> Rate of the last layer (%3.1f) will be used"",
                      VAR_0->tcp_numlayers,
                      VAR_0->tcp_rates[VAR_0->tcp_numlayers - 1]);
        VAR_0->tcp_rates[0] = VAR_0->tcp_rates[VAR_0->tcp_numlayers - 1];
        VAR_0->tcp_numlayers = 1;
    }

    /* COMMENT_10 */
    switch (VAR_0->rsiz) {
    case VAR_6:
        if (VAR_0->numresolution > 6) {
            opj_event_msg(VAR_2, VAR_5,
                          ""JPEG 2000 Profile-3 (2k dc profile) requires:\n""
                          ""Number of decomposition levels <= 5\n""
                          ""-> Number of decomposition levels forced to 5 (rather than %d)\n"",
                          VAR_0->numresolution + 1);
            VAR_0->numresolution = 6;
        }
        break;
    case VAR_7:
        if (VAR_0->numresolution < 2) {
            opj_event_msg(VAR_2, VAR_5,
                          ""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
                          ""Number of decomposition levels >= 1 && <= 6\n""
                          ""-> Number of decomposition levels forced to 1 (rather than %d)\n"",
                          VAR_0->numresolution + 1);
            VAR_0->numresolution = 1;
        } else if (VAR_0->numresolution > 7) {
            opj_event_msg(VAR_2, VAR_5,
                          ""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
                          ""Number of decomposition levels >= 1 && <= 6\n""
                          ""-> Number of decomposition levels forced to 6 (rather than %d)\n"",
                          VAR_0->numresolution + 1);
            VAR_0->numresolution = 7;
        }
        break;
    default :
        break;
    }

    /* COMMENT_11 */
    VAR_0->csty |= 0x01;
    if (VAR_0->numresolution == 1) {
        VAR_0->res_spec = 1;
        VAR_0->prcw_init[0] = 128;
        VAR_0->prch_init[0] = 128;
    } else {
        VAR_0->res_spec = VAR_0->numresolution - 1;
        for (VAR_3 = 0; VAR_3 < VAR_0->res_spec; VAR_3++) {
            VAR_0->prcw_init[VAR_3] = 256;
            VAR_0->prch_init[VAR_3] = 256;
        }
    }

    /* COMMENT_12 */
    VAR_0->prog_order = VAR_8;

    /* COMMENT_13 */
    if (VAR_0->rsiz == VAR_7) {
        VAR_0->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(VAR_0->POC,
                              VAR_0->numresolution);
    } else {
        VAR_0->numpocs = 0;
    }

    /* COMMENT_14 */
    VAR_0->cp_disto_alloc = 1;
    if (VAR_0->max_cs_size <= 0) {
        /* COMMENT_15 */
        VAR_0->max_cs_size = VAR_9;
        opj_event_msg(VAR_2, VAR_5,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1302083 compressed bytes @ 24fps\n""
                      ""As no rate has been given, this limit will be used.\n"");
    } else if (VAR_0->max_cs_size > VAR_9) {
        opj_event_msg(VAR_2, VAR_5,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1302083 compressed bytes @ 24fps\n""
                      ""-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n"");
        VAR_0->max_cs_size = VAR_9;
    }

    if (VAR_0->max_comp_size <= 0) {
        /* COMMENT_15 */
        VAR_0->max_comp_size = VAR_10;
        opj_event_msg(VAR_2, VAR_5,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1041666 compressed bytes @ 24fps\n""
                      ""As no rate has been given, this limit will be used.\n"");
    } else if (VAR_0->max_comp_size > VAR_10) {
        opj_event_msg(VAR_2, VAR_5,
                      ""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
                      ""Maximum 1041666 compressed bytes @ 24fps\n""
                      ""-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n"");
        VAR_0->max_comp_size = VAR_10;
    }

    VAR_0->tcp_rates[0] = (VAR_11)(VAR_1->numcomps * VAR_1->comps[0].w *
                               VAR_1->comps[0].h * VAR_1->comps[0].prec) /
                               (VAR_11)(((OPJ_UINT32)VAR_0->max_cs_size) * 8 * VAR_1->comps[0].dx *
                                       VAR_1->comps[0].dy);

}",uclouvain/openjpeg/4241ae6fbbf1de9658764a80944dc8108f2b4154/j2k.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -84,10 +84,16 @@
 
     /* Precincts */
     parameters->csty |= 0x01;
-    parameters->res_spec = parameters->numresolution - 1;
-    for (i = 0; i < parameters->res_spec; i++) {
-        parameters->prcw_init[i] = 256;
-        parameters->prch_init[i] = 256;
+    if (parameters->numresolution == 1) {
+        parameters->res_spec = 1;
+        parameters->prcw_init[0] = 128;
+        parameters->prch_init[0] = 128;
+    } else {
+        parameters->res_spec = parameters->numresolution - 1;
+        for (i = 0; i < parameters->res_spec; i++) {
+            parameters->prcw_init[i] = 256;
+            parameters->prch_init[i] = 256;
+        }
     }
 
     /* The progression order shall be CPRL */","{'deleted_lines': ['    parameters->res_spec = parameters->numresolution - 1;', '    for (i = 0; i < parameters->res_spec; i++) {', '        parameters->prcw_init[i] = 256;', '        parameters->prch_init[i] = 256;'], 'added_lines': ['    if (parameters->numresolution == 1) {', '        parameters->res_spec = 1;', '        parameters->prcw_init[0] = 128;', '        parameters->prch_init[0] = 128;', '    } else {', '        parameters->res_spec = parameters->numresolution - 1;', '        for (i = 0; i < parameters->res_spec; i++) {', '            parameters->prcw_init[i] = 256;', '            parameters->prch_init[i] = 256;', '        }']}",True,"A mishandled zero case was discovered in opj_j2k_set_cinema_parameters in lib/openjp2/j2k.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_write_bytes_LE in lib/openjp2/cio.c and opj_j2k_write_sot in lib/openjp2/j2k.c) or possibly remote code execution.",8.8,HIGH,2,test,2017-08-15T09:55:58Z,2
CVE-2017-14039,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,uclouvain/openjpeg,opj_t2_encode_packet(): fix potential write heap buffer overflow (#992),c535531f03369623b9b833ef41952c62257b507e,https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e,src/lib/openjp2/j2k.c,opj_j2k_write_sod,"static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,
opj_tcd_t * p_tile_coder,
OPJ_BYTE * p_data,
OPJ_UINT32 * p_data_written,
OPJ_UINT32 p_total_data_size,
const opj_stream_private_t *p_stream,
opj_event_mgr_t * p_manager
)
{
opj_codestream_info_t *l_cstr_info = 00;
OPJ_UINT32 l_remaining_data;
assert(p_j2k != 00);
assert(p_manager != 00);
assert(p_stream != 00);
OPJ_UNUSED(p_stream);
opj_write_bytes(p_data, J2K_MS_SOD,
2);                                 
p_data += 2;
l_remaining_data =  p_total_data_size - 4;
p_tile_coder->tp_num =
p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;
p_tile_coder->cur_tp_num =
p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
#ifdef USE_JPWL
assert(0 && ""TODO"");
#endif 
if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {
p_tile_coder->tcd_image->tiles->packno = 0;
if (l_cstr_info) {
l_cstr_info->packno = 0;
}
}
*p_data_written = 0;
if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,
p_data_written, l_remaining_data, l_cstr_info,
p_manager)) {
opj_event_msg(p_manager, EVT_ERROR, ""Cannot encode tile\n"");
return OPJ_FALSE;
}
*p_data_written += 2;
return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *VAR_0,
opj_tcd_t * VAR_1,
OPJ_BYTE * VAR_2,
OPJ_UINT32 * VAR_3,
OPJ_UINT32 VAR_4,
const opj_stream_private_t *VAR_5,
opj_event_mgr_t * VAR_6
)
{
opj_codestream_info_t *VAR_7 = 00;
OPJ_UINT32 VAR_8;
assert(VAR_0 != 00);
assert(VAR_6 != 00);
assert(VAR_5 != 00);
OPJ_UNUSED(VAR_5);
opj_write_bytes(VAR_2, VAR_9,
2);                                 
VAR_2 += 2;
VAR_8 =  VAR_4 - 4;
VAR_1->tp_num =
VAR_0->m_specific_param.m_encoder.m_current_poc_tile_part_number ;
VAR_1->cur_tp_num =
VAR_0->m_specific_param.m_encoder.m_current_tile_part_number;
#ifdef VAR_10
assert(0 && ""TODO"");
#endif 
if (VAR_0->m_specific_param.m_encoder.m_current_tile_part_number == 0) {
VAR_1->tcd_image->tiles->packno = 0;
if (VAR_7) {
VAR_7->packno = 0;
}
}
*VAR_3 = 0;
if (! opj_tcd_encode_tile(VAR_1, VAR_0->m_current_tile_number, VAR_2,
VAR_3, VAR_8, VAR_7,
VAR_6)) {
opj_event_msg(VAR_6, VAR_11, ""Cannot encode tile\n"");
return VAR_12;
}
*VAR_3 += 2;
return VAR_13;
}",uclouvain/openjpeg/c535531f03369623b9b833ef41952c62257b507e/j2k.c/vul/before/0.json,"static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,
                                  opj_tcd_t * p_tile_coder,
                                  OPJ_BYTE * p_data,
                                  OPJ_UINT32 * p_data_written,
                                  OPJ_UINT32 p_total_data_size,
                                  const opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    opj_codestream_info_t *l_cstr_info = 00;
    OPJ_UINT32 l_remaining_data;

    /* preconditions */
    assert(p_j2k != 00);
    assert(p_manager != 00);
    assert(p_stream != 00);

    OPJ_UNUSED(p_stream);

    if (p_total_data_size < 4) {
        opj_event_msg(p_manager, EVT_ERROR,
                      ""Not enough bytes in output buffer to write SOD marker\n"");
        return OPJ_FALSE;
    }

    opj_write_bytes(p_data, J2K_MS_SOD,
                    2);                                 /* SOD */
    p_data += 2;

    /* make room for the EOF marker */
    l_remaining_data =  p_total_data_size - 4;

    /* update tile coder */
    p_tile_coder->tp_num =
        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;
    p_tile_coder->cur_tp_num =
        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;

    /* INDEX >> */
    /* TODO mergeV2: check this part which use cstr_info */
    /*l_cstr_info = p_j2k->cstr_info;
    if (l_cstr_info) {
            if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {
                    //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;
                    l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;
            }
            else {*/
    /*
    TODO
    if
            (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))
    {
            cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);
    }*/
    /*}*/
    /* UniPG>> */
#ifdef USE_JPWL
    /* update markers struct */
    /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);
    */
    assert(0 && ""TODO"");
#endif /* USE_JPWL */
    /* <<UniPG */
    /*}*/
    /* << INDEX */

    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {
        p_tile_coder->tcd_image->tiles->packno = 0;
        if (l_cstr_info) {
            l_cstr_info->packno = 0;
        }
    }

    *p_data_written = 0;

    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,
                              p_data_written, l_remaining_data, l_cstr_info,
                              p_manager)) {
        opj_event_msg(p_manager, EVT_ERROR, ""Cannot encode tile\n"");
        return OPJ_FALSE;
    }

    *p_data_written += 2;

    return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *VAR_0,
                                  opj_tcd_t * VAR_1,
                                  OPJ_BYTE * VAR_2,
                                  OPJ_UINT32 * VAR_3,
                                  OPJ_UINT32 VAR_4,
                                  const opj_stream_private_t *VAR_5,
                                  opj_event_mgr_t * VAR_6
                                 )
{
    opj_codestream_info_t *VAR_7 = 00;
    OPJ_UINT32 VAR_8;

    /* COMMENT_0 */
    assert(VAR_0 != 00);
    assert(VAR_6 != 00);
    assert(VAR_5 != 00);

    OPJ_UNUSED(VAR_5);

    if (VAR_4 < 4) {
        opj_event_msg(VAR_6, VAR_9,
                      ""Not enough bytes in output buffer to write SOD marker\n"");
        return VAR_10;
    }

    opj_write_bytes(VAR_2, VAR_11,
                    2);                                 /* COMMENT_1 */
    VAR_2 += 2;

    /* COMMENT_2 */
    VAR_8 =  VAR_4 - 4;

    /* COMMENT_3 */
    VAR_1->tp_num =
        VAR_0->m_specific_param.m_encoder.m_current_poc_tile_part_number ;
    VAR_1->cur_tp_num =
        VAR_0->m_specific_param.m_encoder.m_current_tile_part_number;

    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
                      
                                                                                 
                                                                                                                                          
                                                                                                          
             
                    
    /* COMMENT_13 */
        
      
                                                                                                                           
     
                                                                                                                        
       
    /* COMMENT_20 */
    /* COMMENT_21 */
#ifdef VAR_12
    /* COMMENT_22 */
    /* COMMENT_23 */
      
    assert(0 && ""TODO"");
#endif /* COMMENT_25 */
    /* COMMENT_26 */
    /* COMMENT_20 */
    /* COMMENT_27 */

    if (VAR_0->m_specific_param.m_encoder.m_current_tile_part_number == 0) {
        VAR_1->tcd_image->tiles->packno = 0;
        if (VAR_7) {
            VAR_7->packno = 0;
        }
    }

    *VAR_3 = 0;

    if (! opj_tcd_encode_tile(VAR_1, VAR_0->m_current_tile_number, VAR_2,
                              VAR_3, VAR_8, VAR_7,
                              VAR_6)) {
        opj_event_msg(VAR_6, VAR_9, ""Cannot encode tile\n"");
        return VAR_10;
    }

    *VAR_3 += 2;

    return VAR_13;
}",uclouvain/openjpeg/c535531f03369623b9b833ef41952c62257b507e/j2k.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,6 +16,12 @@
     assert(p_stream != 00);
 
     OPJ_UNUSED(p_stream);
+
+    if (p_total_data_size < 4) {
+        opj_event_msg(p_manager, EVT_ERROR,
+                      ""Not enough bytes in output buffer to write SOD marker\n"");
+        return OPJ_FALSE;
+    }
 
     opj_write_bytes(p_data, J2K_MS_SOD,
                     2);                                 /* SOD */","{'deleted_lines': [], 'added_lines': ['', '    if (p_total_data_size < 4) {', '        opj_event_msg(p_manager, EVT_ERROR,', '                      ""Not enough bytes in output buffer to write SOD marker\\n"");', '        return OPJ_FALSE;', '    }']}",True,"A heap-based buffer overflow was discovered in the opj_t2_encode_packet function in lib/openjp2/t2.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly unspecified other impact.",8.8,HIGH,2,test,2017-08-16T15:20:29Z,2
CVE-2017-14039,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,uclouvain/openjpeg,opj_t2_encode_packet(): fix potential write heap buffer overflow (#992),c535531f03369623b9b833ef41952c62257b507e,https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e,src/lib/openjp2/t2.c,opj_t2_encode_packet,"static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno,
opj_tcd_tile_t * tile,
opj_tcp_t * tcp,
opj_pi_iterator_t *pi,
OPJ_BYTE *dest,
OPJ_UINT32 * p_data_written,
OPJ_UINT32 length,
opj_codestream_info_t *cstr_info,
J2K_T2_MODE p_t2_mode,
opj_event_mgr_t *p_manager)
{
OPJ_UINT32 bandno, cblkno;
OPJ_BYTE* c = dest;
OPJ_UINT32 l_nb_bytes;
OPJ_UINT32 compno = pi->compno;     
OPJ_UINT32 resno  = pi->resno;      
OPJ_UINT32 precno = pi->precno;     
OPJ_UINT32 layno  = pi->layno;      
OPJ_UINT32 l_nb_blocks;
opj_tcd_band_t *band = 00;
opj_tcd_cblk_enc_t* cblk = 00;
opj_tcd_pass_t *pass = 00;
opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
opj_tcd_resolution_t *res = &tilec->resolutions[resno];
opj_bio_t *bio = 00;    
OPJ_BOOL packet_empty = OPJ_TRUE;
if (tcp->csty & J2K_CP_CSTY_SOP) {
c[0] = 255;
c[1] = 145;
c[2] = 0;
c[3] = 4;
#if 0
c[4] = (tile->packno % 65536) / 256;
c[5] = (tile->packno % 65536) % 256;
#else
c[4] = (tile->packno >> 8) & 0xff; 
c[5] = tile->packno & 0xff;
#endif
c += 6;
length -= 6;
}
if (!layno) {
band = res->bands;
for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {
opj_tcd_precinct_t *prc;
if (opj_tcd_is_band_empty(band)) {
continue;
}
prc = &band->precincts[precno];
opj_tgt_reset(prc->incltree);
opj_tgt_reset(prc->imsbtree);
l_nb_blocks = prc->cw * prc->ch;
for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
cblk = &prc->cblks.enc[cblkno];
cblk->numpasses = 0;
opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32)cblk->numbps);
}
}
}
bio = opj_bio_create();
if (!bio) {
return OPJ_FALSE;
}
opj_bio_init_enc(bio, c, length);
band = res->bands;
for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {
opj_tcd_precinct_t *prc;
if (opj_tcd_is_band_empty(band)) {
continue;
}
prc = &band->precincts[precno];
l_nb_blocks = prc->cw * prc->ch;
cblk = prc->cblks.enc;
for (cblkno = 0; cblkno < l_nb_blocks; cblkno++, ++cblk) {
opj_tcd_layer_t *layer = &cblk->layers[layno];
if (!layer->numpasses) {
continue;
}
packet_empty = OPJ_FALSE;
break;
}
if (!packet_empty) {
break;
}
}
opj_bio_write(bio, packet_empty ? 0 : 1, 1);           
band = res->bands;
for (bandno = 0; !packet_empty &&
bandno < res->numbands; ++bandno, ++band)      {
opj_tcd_precinct_t *prc;
if (opj_tcd_is_band_empty(band)) {
continue;
}
prc = &band->precincts[precno];
l_nb_blocks = prc->cw * prc->ch;
cblk = prc->cblks.enc;
for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
opj_tcd_layer_t *layer = &cblk->layers[layno];
if (!cblk->numpasses && layer->numpasses) {
opj_tgt_setvalue(prc->incltree, cblkno, (OPJ_INT32)layno);
}
++cblk;
}
cblk = prc->cblks.enc;
for (cblkno = 0; cblkno < l_nb_blocks; cblkno++) {
opj_tcd_layer_t *layer = &cblk->layers[layno];
OPJ_UINT32 increment = 0;
OPJ_UINT32 nump = 0;
OPJ_UINT32 len = 0, passno;
OPJ_UINT32 l_nb_passes;
if (!cblk->numpasses) {
opj_tgt_encode(bio, prc->incltree, cblkno, (OPJ_INT32)(layno + 1));
} else {
opj_bio_write(bio, layer->numpasses != 0, 1);
}
if (!layer->numpasses) {
++cblk;
continue;
}
if (!cblk->numpasses) {
cblk->numlenbits = 3;
opj_tgt_encode(bio, prc->imsbtree, cblkno, 999);
}
opj_t2_putnumpasses(bio, layer->numpasses);
l_nb_passes = cblk->numpasses + layer->numpasses;
pass = cblk->passes +  cblk->numpasses;
for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
++nump;
len += pass->len;
if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
increment = (OPJ_UINT32)opj_int_max((OPJ_INT32)increment,
opj_int_floorlog2((OPJ_INT32)len) + 1
- ((OPJ_INT32)cblk->numlenbits + opj_int_floorlog2((OPJ_INT32)nump)));
len = 0;
nump = 0;
}
++pass;
}
opj_t2_putcommacode(bio, (OPJ_INT32)increment);
cblk->numlenbits += increment;
pass = cblk->passes +  cblk->numpasses;
for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
nump++;
len += pass->len;
if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
opj_bio_write(bio, (OPJ_UINT32)len,
cblk->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)nump));
len = 0;
nump = 0;
}
++pass;
}
++cblk;
}
}
if (!opj_bio_flush(bio)) {
opj_bio_destroy(bio);
return OPJ_FALSE;               
}
l_nb_bytes = (OPJ_UINT32)opj_bio_numbytes(bio);
c += l_nb_bytes;
length -= l_nb_bytes;
opj_bio_destroy(bio);
if (tcp->csty & J2K_CP_CSTY_EPH) {
c[0] = 255;
c[1] = 146;
c += 2;
length -= 2;
}
if (cstr_info && cstr_info->index_write) {
opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
info_PK->end_ph_pos = (OPJ_INT32)(c - dest);
}
band = res->bands;
for (bandno = 0; !packet_empty && bandno < res->numbands; bandno++, ++band) {
opj_tcd_precinct_t *prc;
if (opj_tcd_is_band_empty(band)) {
continue;
}
prc = &band->precincts[precno];
l_nb_blocks = prc->cw * prc->ch;
cblk = prc->cblks.enc;
for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
opj_tcd_layer_t *layer = &cblk->layers[layno];
if (!layer->numpasses) {
++cblk;
continue;
}
if (layer->len > length) {
if (p_t2_mode == FINAL_PASS) {
opj_event_msg(p_manager, EVT_ERROR,
""opj_t2_encode_packet(): only %u bytes remaining in ""
""output buffer. %u needed.\n"",
length, layer->len);
}
return OPJ_FALSE;
}
memcpy(c, layer->data, layer->len);
cblk->numpasses += layer->numpasses;
c += layer->len;
length -= layer->len;
if (cstr_info && cstr_info->index_write) {
opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
info_PK->disto += layer->disto;
if (cstr_info->D_max < info_PK->disto) {
cstr_info->D_max = info_PK->disto;
}
}
++cblk;
}
}
assert(c >= dest);
* p_data_written += (OPJ_UINT32)(c - dest);
return OPJ_TRUE;
}","static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 VAR_0,
opj_tcd_tile_t * VAR_1,
opj_tcp_t * VAR_2,
opj_pi_iterator_t *VAR_3,
OPJ_BYTE *VAR_4,
OPJ_UINT32 * VAR_5,
OPJ_UINT32 VAR_6,
opj_codestream_info_t *VAR_7,
J2K_T2_MODE VAR_8,
opj_event_mgr_t *VAR_9)
{
OPJ_UINT32 VAR_10, VAR_11;
OPJ_BYTE* VAR_12 = VAR_4;
OPJ_UINT32 VAR_13;
OPJ_UINT32 VAR_14 = VAR_3->compno;     
OPJ_UINT32 VAR_15  = VAR_3->resno;      
OPJ_UINT32 VAR_16 = VAR_3->precno;     
OPJ_UINT32 VAR_17  = VAR_3->layno;      
OPJ_UINT32 VAR_18;
opj_tcd_band_t *VAR_19 = 00;
opj_tcd_cblk_enc_t* VAR_20 = 00;
opj_tcd_pass_t *VAR_21 = 00;
opj_tcd_tilecomp_t *VAR_22 = &VAR_1->comps[VAR_14];
opj_tcd_resolution_t *VAR_23 = &VAR_22->resolutions[VAR_15];
opj_bio_t *VAR_24 = 00;    
OPJ_BOOL VAR_25 = VAR_26;
if (VAR_2->csty & VAR_27) {
VAR_12[0] = 255;
VAR_12[1] = 145;
VAR_12[2] = 0;
VAR_12[3] = 4;
#if 0
VAR_12[4] = (VAR_1->packno % 65536) / 256;
VAR_12[5] = (VAR_1->packno % 65536) % 256;
#else
VAR_12[4] = (VAR_1->packno >> 8) & 0xff; 
VAR_12[5] = VAR_1->packno & 0xff;
#endif
VAR_12 += 6;
VAR_6 -= 6;
}
if (!VAR_17) {
VAR_19 = VAR_23->bands;
for (VAR_10 = 0; VAR_10 < VAR_23->numbands; ++VAR_10, ++VAR_19) {
opj_tcd_precinct_t *VAR_28;
if (opj_tcd_is_band_empty(VAR_19)) {
continue;
}
VAR_28 = &VAR_19->precincts[VAR_16];
opj_tgt_reset(VAR_28->incltree);
opj_tgt_reset(VAR_28->imsbtree);
VAR_18 = VAR_28->cw * VAR_28->ch;
for (VAR_11 = 0; VAR_11 < VAR_18; ++VAR_11) {
VAR_20 = &VAR_28->cblks.enc[VAR_11];
VAR_20->numpasses = 0;
opj_tgt_setvalue(VAR_28->imsbtree, VAR_11, VAR_19->numbps - (OPJ_INT32)VAR_20->numbps);
}
}
}
VAR_24 = opj_bio_create();
if (!VAR_24) {
return VAR_29;
}
opj_bio_init_enc(VAR_24, VAR_12, VAR_6);
VAR_19 = VAR_23->bands;
for (VAR_10 = 0; VAR_10 < VAR_23->numbands; ++VAR_10, ++VAR_19) {
opj_tcd_precinct_t *VAR_28;
if (opj_tcd_is_band_empty(VAR_19)) {
continue;
}
VAR_28 = &VAR_19->precincts[VAR_16];
VAR_18 = VAR_28->cw * VAR_28->ch;
VAR_20 = VAR_28->cblks.enc;
for (VAR_11 = 0; VAR_11 < VAR_18; VAR_11++, ++VAR_20) {
opj_tcd_layer_t *VAR_30 = &VAR_20->layers[VAR_17];
if (!VAR_30->numpasses) {
continue;
}
VAR_25 = VAR_29;
break;
}
if (!VAR_25) {
break;
}
}
opj_bio_write(VAR_24, VAR_25 ? 0 : 1, 1);           
VAR_19 = VAR_23->bands;
for (VAR_10 = 0; !VAR_25 &&
VAR_10 < VAR_23->numbands; ++VAR_10, ++VAR_19)      {
opj_tcd_precinct_t *VAR_28;
if (opj_tcd_is_band_empty(VAR_19)) {
continue;
}
VAR_28 = &VAR_19->precincts[VAR_16];
VAR_18 = VAR_28->cw * VAR_28->ch;
VAR_20 = VAR_28->cblks.enc;
for (VAR_11 = 0; VAR_11 < VAR_18; ++VAR_11) {
opj_tcd_layer_t *VAR_30 = &VAR_20->layers[VAR_17];
if (!VAR_20->numpasses && VAR_30->numpasses) {
opj_tgt_setvalue(VAR_28->incltree, VAR_11, (OPJ_INT32)VAR_17);
}
++VAR_20;
}
VAR_20 = VAR_28->cblks.enc;
for (VAR_11 = 0; VAR_11 < VAR_18; VAR_11++) {
opj_tcd_layer_t *VAR_30 = &VAR_20->layers[VAR_17];
OPJ_UINT32 VAR_31 = 0;
OPJ_UINT32 VAR_32 = 0;
OPJ_UINT32 VAR_33 = 0, VAR_34;
OPJ_UINT32 VAR_35;
if (!VAR_20->numpasses) {
opj_tgt_encode(VAR_24, VAR_28->incltree, VAR_11, (OPJ_INT32)(VAR_17 + 1));
} else {
opj_bio_write(VAR_24, VAR_30->numpasses != 0, 1);
}
if (!VAR_30->numpasses) {
++VAR_20;
continue;
}
if (!VAR_20->numpasses) {
VAR_20->numlenbits = 3;
opj_tgt_encode(VAR_24, VAR_28->imsbtree, VAR_11, 999);
}
opj_t2_putnumpasses(VAR_24, VAR_30->numpasses);
VAR_35 = VAR_20->numpasses + VAR_30->numpasses;
VAR_21 = VAR_20->passes +  VAR_20->numpasses;
for (VAR_34 = VAR_20->numpasses; VAR_34 < VAR_35; ++VAR_34) {
++VAR_32;
VAR_33 += VAR_21->len;
if (VAR_21->term || VAR_34 == (VAR_20->numpasses + VAR_30->numpasses) - 1) {
VAR_31 = (OPJ_UINT32)opj_int_max((OPJ_INT32)VAR_31,
opj_int_floorlog2((OPJ_INT32)VAR_33) + 1
- ((OPJ_INT32)VAR_20->numlenbits + opj_int_floorlog2((OPJ_INT32)VAR_32)));
VAR_33 = 0;
VAR_32 = 0;
}
++VAR_21;
}
opj_t2_putcommacode(VAR_24, (OPJ_INT32)VAR_31);
VAR_20->numlenbits += VAR_31;
VAR_21 = VAR_20->passes +  VAR_20->numpasses;
for (VAR_34 = VAR_20->numpasses; VAR_34 < VAR_35; ++VAR_34) {
VAR_32++;
VAR_33 += VAR_21->len;
if (VAR_21->term || VAR_34 == (VAR_20->numpasses + VAR_30->numpasses) - 1) {
opj_bio_write(VAR_24, (OPJ_UINT32)VAR_33,
VAR_20->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)VAR_32));
VAR_33 = 0;
VAR_32 = 0;
}
++VAR_21;
}
++VAR_20;
}
}
if (!opj_bio_flush(VAR_24)) {
opj_bio_destroy(VAR_24);
return VAR_29;               
}
VAR_13 = (OPJ_UINT32)opj_bio_numbytes(VAR_24);
VAR_12 += VAR_13;
VAR_6 -= VAR_13;
opj_bio_destroy(VAR_24);
if (VAR_2->csty & VAR_36) {
VAR_12[0] = 255;
VAR_12[1] = 146;
VAR_12 += 2;
VAR_6 -= 2;
}
if (VAR_7 && VAR_7->index_write) {
opj_packet_info_t *VAR_37 = &VAR_7->tile[VAR_0].packet[VAR_7->packno];
VAR_37->end_ph_pos = (OPJ_INT32)(VAR_12 - VAR_4);
}
VAR_19 = VAR_23->bands;
for (VAR_10 = 0; !VAR_25 && VAR_10 < VAR_23->numbands; VAR_10++, ++VAR_19) {
opj_tcd_precinct_t *VAR_28;
if (opj_tcd_is_band_empty(VAR_19)) {
continue;
}
VAR_28 = &VAR_19->precincts[VAR_16];
VAR_18 = VAR_28->cw * VAR_28->ch;
VAR_20 = VAR_28->cblks.enc;
for (VAR_11 = 0; VAR_11 < VAR_18; ++VAR_11) {
opj_tcd_layer_t *VAR_30 = &VAR_20->layers[VAR_17];
if (!VAR_30->numpasses) {
++VAR_20;
continue;
}
if (VAR_30->len > VAR_6) {
if (VAR_8 == VAR_38) {
opj_event_msg(VAR_9, VAR_39,
""opj_t2_encode_packet(): only %u bytes remaining in ""
""output buffer. %u needed.\n"",
VAR_6, VAR_30->len);
}
return VAR_29;
}
memcpy(VAR_12, VAR_30->data, VAR_30->len);
VAR_20->numpasses += VAR_30->numpasses;
VAR_12 += VAR_30->len;
VAR_6 -= VAR_30->len;
if (VAR_7 && VAR_7->index_write) {
opj_packet_info_t *VAR_37 = &VAR_7->tile[VAR_0].packet[VAR_7->packno];
VAR_37->disto += VAR_30->disto;
if (VAR_7->D_max < VAR_37->disto) {
VAR_7->D_max = VAR_37->disto;
}
}
++VAR_20;
}
}
assert(VAR_12 >= VAR_4);
* VAR_5 += (OPJ_UINT32)(VAR_12 - VAR_4);
return VAR_26;
}",uclouvain/openjpeg/c535531f03369623b9b833ef41952c62257b507e/t2.c/vul/before/0.json,"static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 tileno,
                                     opj_tcd_tile_t * tile,
                                     opj_tcp_t * tcp,
                                     opj_pi_iterator_t *pi,
                                     OPJ_BYTE *dest,
                                     OPJ_UINT32 * p_data_written,
                                     OPJ_UINT32 length,
                                     opj_codestream_info_t *cstr_info,
                                     J2K_T2_MODE p_t2_mode,
                                     opj_event_mgr_t *p_manager)
{
    OPJ_UINT32 bandno, cblkno;
    OPJ_BYTE* c = dest;
    OPJ_UINT32 l_nb_bytes;
    OPJ_UINT32 compno = pi->compno;     /* component value */
    OPJ_UINT32 resno  = pi->resno;      /* resolution level value */
    OPJ_UINT32 precno = pi->precno;     /* precinct value */
    OPJ_UINT32 layno  = pi->layno;      /* quality layer value */
    OPJ_UINT32 l_nb_blocks;
    opj_tcd_band_t *band = 00;
    opj_tcd_cblk_enc_t* cblk = 00;
    opj_tcd_pass_t *pass = 00;

    opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
    opj_tcd_resolution_t *res = &tilec->resolutions[resno];

    opj_bio_t *bio = 00;    /* BIO component */
    OPJ_BOOL packet_empty = OPJ_TRUE;

    /* <SOP 0xff91> */
    if (tcp->csty & J2K_CP_CSTY_SOP) {
        if (length < 6) {
            if (p_t2_mode == FINAL_PASS) {
                opj_event_msg(p_manager, EVT_ERROR,
                              ""opj_t2_encode_packet(): only %u bytes remaining in ""
                              ""output buffer. %u needed.\n"",
                              length, 6);
            }
            return OPJ_FALSE;
        }
        c[0] = 255;
        c[1] = 145;
        c[2] = 0;
        c[3] = 4;
#if 0
        c[4] = (tile->packno % 65536) / 256;
        c[5] = (tile->packno % 65536) % 256;
#else
        c[4] = (tile->packno >> 8) & 0xff; /* packno is uint32_t */
        c[5] = tile->packno & 0xff;
#endif
        c += 6;
        length -= 6;
    }
    /* </SOP> */

    if (!layno) {
        band = res->bands;

        for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {
            opj_tcd_precinct_t *prc;

            /* Skip empty bands */
            if (opj_tcd_is_band_empty(band)) {
                continue;
            }

            prc = &band->precincts[precno];
            opj_tgt_reset(prc->incltree);
            opj_tgt_reset(prc->imsbtree);

            l_nb_blocks = prc->cw * prc->ch;
            for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
                cblk = &prc->cblks.enc[cblkno];

                cblk->numpasses = 0;
                opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32)cblk->numbps);
            }
        }
    }

    bio = opj_bio_create();
    if (!bio) {
        /* FIXME event manager error callback */
        return OPJ_FALSE;
    }
    opj_bio_init_enc(bio, c, length);

    /* Check if the packet is empty */
    /* Note: we could also skip that step and always write a packet header */
    band = res->bands;
    for (bandno = 0; bandno < res->numbands; ++bandno, ++band) {
        opj_tcd_precinct_t *prc;
        /* Skip empty bands */
        if (opj_tcd_is_band_empty(band)) {
            continue;
        }

        prc = &band->precincts[precno];
        l_nb_blocks = prc->cw * prc->ch;
        cblk = prc->cblks.enc;
        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++, ++cblk) {
            opj_tcd_layer_t *layer = &cblk->layers[layno];

            /* if cblk not included, go to the next cblk  */
            if (!layer->numpasses) {
                continue;
            }
            packet_empty = OPJ_FALSE;
            break;
        }
        if (!packet_empty) {
            break;
        }
    }

    opj_bio_write(bio, packet_empty ? 0 : 1, 1);           /* Empty header bit */


    /* Writing Packet header */
    band = res->bands;
    for (bandno = 0; !packet_empty &&
            bandno < res->numbands; ++bandno, ++band)      {
        opj_tcd_precinct_t *prc;

        /* Skip empty bands */
        if (opj_tcd_is_band_empty(band)) {
            continue;
        }

        prc = &band->precincts[precno];
        l_nb_blocks = prc->cw * prc->ch;
        cblk = prc->cblks.enc;

        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
            opj_tcd_layer_t *layer = &cblk->layers[layno];

            if (!cblk->numpasses && layer->numpasses) {
                opj_tgt_setvalue(prc->incltree, cblkno, (OPJ_INT32)layno);
            }

            ++cblk;
        }

        cblk = prc->cblks.enc;
        for (cblkno = 0; cblkno < l_nb_blocks; cblkno++) {
            opj_tcd_layer_t *layer = &cblk->layers[layno];
            OPJ_UINT32 increment = 0;
            OPJ_UINT32 nump = 0;
            OPJ_UINT32 len = 0, passno;
            OPJ_UINT32 l_nb_passes;

            /* cblk inclusion bits */
            if (!cblk->numpasses) {
                opj_tgt_encode(bio, prc->incltree, cblkno, (OPJ_INT32)(layno + 1));
            } else {
                opj_bio_write(bio, layer->numpasses != 0, 1);
            }

            /* if cblk not included, go to the next cblk  */
            if (!layer->numpasses) {
                ++cblk;
                continue;
            }

            /* if first instance of cblk --> zero bit-planes information */
            if (!cblk->numpasses) {
                cblk->numlenbits = 3;
                opj_tgt_encode(bio, prc->imsbtree, cblkno, 999);
            }

            /* number of coding passes included */
            opj_t2_putnumpasses(bio, layer->numpasses);
            l_nb_passes = cblk->numpasses + layer->numpasses;
            pass = cblk->passes +  cblk->numpasses;

            /* computation of the increase of the length indicator and insertion in the header     */
            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
                ++nump;
                len += pass->len;

                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
                    increment = (OPJ_UINT32)opj_int_max((OPJ_INT32)increment,
                                                        opj_int_floorlog2((OPJ_INT32)len) + 1
                                                        - ((OPJ_INT32)cblk->numlenbits + opj_int_floorlog2((OPJ_INT32)nump)));
                    len = 0;
                    nump = 0;
                }

                ++pass;
            }
            opj_t2_putcommacode(bio, (OPJ_INT32)increment);

            /* computation of the new Length indicator */
            cblk->numlenbits += increment;

            pass = cblk->passes +  cblk->numpasses;
            /* insertion of the codeword segment length */
            for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
                nump++;
                len += pass->len;

                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
                    opj_bio_write(bio, (OPJ_UINT32)len,
                                  cblk->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)nump));
                    len = 0;
                    nump = 0;
                }
                ++pass;
            }

            ++cblk;
        }
    }

    if (!opj_bio_flush(bio)) {
        opj_bio_destroy(bio);
        return OPJ_FALSE;               /* modified to eliminate longjmp !! */
    }

    l_nb_bytes = (OPJ_UINT32)opj_bio_numbytes(bio);
    c += l_nb_bytes;
    length -= l_nb_bytes;

    opj_bio_destroy(bio);

    /* <EPH 0xff92> */
    if (tcp->csty & J2K_CP_CSTY_EPH) {
        if (length < 2) {
            if (p_t2_mode == FINAL_PASS) {
                opj_event_msg(p_manager, EVT_ERROR,
                              ""opj_t2_encode_packet(): only %u bytes remaining in ""
                              ""output buffer. %u needed.\n"",
                              length, 2);
            }
            return OPJ_FALSE;
        }
        c[0] = 255;
        c[1] = 146;
        c += 2;
        length -= 2;
    }
    /* </EPH> */

    /* << INDEX */
    /* End of packet header position. Currently only represents the distance to start of packet
       Will be updated later by incrementing with packet start value*/
    if (cstr_info && cstr_info->index_write) {
        opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
        info_PK->end_ph_pos = (OPJ_INT32)(c - dest);
    }
    /* INDEX >> */

    /* Writing the packet body */
    band = res->bands;
    for (bandno = 0; !packet_empty && bandno < res->numbands; bandno++, ++band) {
        opj_tcd_precinct_t *prc;

        /* Skip empty bands */
        if (opj_tcd_is_band_empty(band)) {
            continue;
        }

        prc = &band->precincts[precno];
        l_nb_blocks = prc->cw * prc->ch;
        cblk = prc->cblks.enc;

        for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
            opj_tcd_layer_t *layer = &cblk->layers[layno];

            if (!layer->numpasses) {
                ++cblk;
                continue;
            }

            if (layer->len > length) {
                if (p_t2_mode == FINAL_PASS) {
                    opj_event_msg(p_manager, EVT_ERROR,
                                  ""opj_t2_encode_packet(): only %u bytes remaining in ""
                                  ""output buffer. %u needed.\n"",
                                  length, layer->len);
                }
                return OPJ_FALSE;
            }

            memcpy(c, layer->data, layer->len);
            cblk->numpasses += layer->numpasses;
            c += layer->len;
            length -= layer->len;

            /* << INDEX */
            if (cstr_info && cstr_info->index_write) {
                opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
                info_PK->disto += layer->disto;
                if (cstr_info->D_max < info_PK->disto) {
                    cstr_info->D_max = info_PK->disto;
                }
            }

            ++cblk;
            /* INDEX >> */
        }
    }

    assert(c >= dest);
    * p_data_written += (OPJ_UINT32)(c - dest);

    return OPJ_TRUE;
}","static OPJ_BOOL opj_t2_encode_packet(OPJ_UINT32 VAR_0,
                                     opj_tcd_tile_t * VAR_1,
                                     opj_tcp_t * VAR_2,
                                     opj_pi_iterator_t *VAR_3,
                                     OPJ_BYTE *VAR_4,
                                     OPJ_UINT32 * VAR_5,
                                     OPJ_UINT32 VAR_6,
                                     opj_codestream_info_t *VAR_7,
                                     J2K_T2_MODE VAR_8,
                                     opj_event_mgr_t *VAR_9)
{
    OPJ_UINT32 VAR_10, VAR_11;
    OPJ_BYTE* VAR_12 = VAR_4;
    OPJ_UINT32 VAR_13;
    OPJ_UINT32 VAR_14 = VAR_3->compno;     /* COMMENT_0 */
    OPJ_UINT32 VAR_15  = VAR_3->resno;      /* COMMENT_1 */
    OPJ_UINT32 VAR_16 = VAR_3->precno;     /* COMMENT_2 */
    OPJ_UINT32 VAR_17  = VAR_3->layno;      /* COMMENT_3 */
    OPJ_UINT32 VAR_18;
    opj_tcd_band_t *VAR_19 = 00;
    opj_tcd_cblk_enc_t* VAR_20 = 00;
    opj_tcd_pass_t *VAR_21 = 00;

    opj_tcd_tilecomp_t *VAR_22 = &VAR_1->comps[VAR_14];
    opj_tcd_resolution_t *VAR_23 = &VAR_22->resolutions[VAR_15];

    opj_bio_t *VAR_24 = 00;    /* COMMENT_4 */
    OPJ_BOOL VAR_25 = VAR_26;

    /* COMMENT_5 */
    if (VAR_2->csty & VAR_27) {
        if (VAR_6 < 6) {
            if (VAR_8 == VAR_28) {
                opj_event_msg(VAR_9, VAR_29,
                              ""opj_t2_encode_packet(): only %u bytes remaining in ""
                              ""output buffer. %u needed.\n"",
                              VAR_6, 6);
            }
            return VAR_30;
        }
        VAR_12[0] = 255;
        VAR_12[1] = 145;
        VAR_12[2] = 0;
        VAR_12[3] = 4;
#if 0
        VAR_12[4] = (VAR_1->packno % 65536) / 256;
        VAR_12[5] = (VAR_1->packno % 65536) % 256;
#else
        VAR_12[4] = (VAR_1->packno >> 8) & 0xff; /* COMMENT_6 */
        VAR_12[5] = VAR_1->packno & 0xff;
#endif
        VAR_12 += 6;
        VAR_6 -= 6;
    }
    /* COMMENT_7 */

    if (!VAR_17) {
        VAR_19 = VAR_23->bands;

        for (VAR_10 = 0; VAR_10 < VAR_23->numbands; ++VAR_10, ++VAR_19) {
            opj_tcd_precinct_t *VAR_31;

            /* COMMENT_8 */
            if (opj_tcd_is_band_empty(VAR_19)) {
                continue;
            }

            VAR_31 = &VAR_19->precincts[VAR_16];
            opj_tgt_reset(VAR_31->incltree);
            opj_tgt_reset(VAR_31->imsbtree);

            VAR_18 = VAR_31->cw * VAR_31->ch;
            for (VAR_11 = 0; VAR_11 < VAR_18; ++VAR_11) {
                VAR_20 = &VAR_31->cblks.enc[VAR_11];

                VAR_20->numpasses = 0;
                opj_tgt_setvalue(VAR_31->imsbtree, VAR_11, VAR_19->numbps - (OPJ_INT32)VAR_20->numbps);
            }
        }
    }

    VAR_24 = opj_bio_create();
    if (!VAR_24) {
        /* COMMENT_9 */
        return VAR_30;
    }
    opj_bio_init_enc(VAR_24, VAR_12, VAR_6);

    /* COMMENT_10 */
    /* COMMENT_11 */
    VAR_19 = VAR_23->bands;
    for (VAR_10 = 0; VAR_10 < VAR_23->numbands; ++VAR_10, ++VAR_19) {
        opj_tcd_precinct_t *VAR_31;
        /* COMMENT_8 */
        if (opj_tcd_is_band_empty(VAR_19)) {
            continue;
        }

        VAR_31 = &VAR_19->precincts[VAR_16];
        VAR_18 = VAR_31->cw * VAR_31->ch;
        VAR_20 = VAR_31->cblks.enc;
        for (VAR_11 = 0; VAR_11 < VAR_18; VAR_11++, ++VAR_20) {
            opj_tcd_layer_t *VAR_32 = &VAR_20->layers[VAR_17];

            /* COMMENT_12 */
            if (!VAR_32->numpasses) {
                continue;
            }
            VAR_25 = VAR_30;
            break;
        }
        if (!VAR_25) {
            break;
        }
    }

    opj_bio_write(VAR_24, VAR_25 ? 0 : 1, 1);           /* COMMENT_13 */


    /* COMMENT_14 */
    VAR_19 = VAR_23->bands;
    for (VAR_10 = 0; !VAR_25 &&
            VAR_10 < VAR_23->numbands; ++VAR_10, ++VAR_19)      {
        opj_tcd_precinct_t *VAR_31;

        /* COMMENT_8 */
        if (opj_tcd_is_band_empty(VAR_19)) {
            continue;
        }

        VAR_31 = &VAR_19->precincts[VAR_16];
        VAR_18 = VAR_31->cw * VAR_31->ch;
        VAR_20 = VAR_31->cblks.enc;

        for (VAR_11 = 0; VAR_11 < VAR_18; ++VAR_11) {
            opj_tcd_layer_t *VAR_32 = &VAR_20->layers[VAR_17];

            if (!VAR_20->numpasses && VAR_32->numpasses) {
                opj_tgt_setvalue(VAR_31->incltree, VAR_11, (OPJ_INT32)VAR_17);
            }

            ++VAR_20;
        }

        VAR_20 = VAR_31->cblks.enc;
        for (VAR_11 = 0; VAR_11 < VAR_18; VAR_11++) {
            opj_tcd_layer_t *VAR_32 = &VAR_20->layers[VAR_17];
            OPJ_UINT32 VAR_33 = 0;
            OPJ_UINT32 VAR_34 = 0;
            OPJ_UINT32 VAR_35 = 0, VAR_36;
            OPJ_UINT32 VAR_37;

            /* COMMENT_15 */
            if (!VAR_20->numpasses) {
                opj_tgt_encode(VAR_24, VAR_31->incltree, VAR_11, (OPJ_INT32)(VAR_17 + 1));
            } else {
                opj_bio_write(VAR_24, VAR_32->numpasses != 0, 1);
            }

            /* COMMENT_12 */
            if (!VAR_32->numpasses) {
                ++VAR_20;
                continue;
            }

            /* COMMENT_16 */
            if (!VAR_20->numpasses) {
                VAR_20->numlenbits = 3;
                opj_tgt_encode(VAR_24, VAR_31->imsbtree, VAR_11, 999);
            }

            /* COMMENT_17 */
            opj_t2_putnumpasses(VAR_24, VAR_32->numpasses);
            VAR_37 = VAR_20->numpasses + VAR_32->numpasses;
            VAR_21 = VAR_20->passes +  VAR_20->numpasses;

            /* COMMENT_18 */
            for (VAR_36 = VAR_20->numpasses; VAR_36 < VAR_37; ++VAR_36) {
                ++VAR_34;
                VAR_35 += VAR_21->len;

                if (VAR_21->term || VAR_36 == (VAR_20->numpasses + VAR_32->numpasses) - 1) {
                    VAR_33 = (OPJ_UINT32)opj_int_max((OPJ_INT32)VAR_33,
                                                        opj_int_floorlog2((OPJ_INT32)VAR_35) + 1
                                                        - ((OPJ_INT32)VAR_20->numlenbits + opj_int_floorlog2((OPJ_INT32)VAR_34)));
                    VAR_35 = 0;
                    VAR_34 = 0;
                }

                ++VAR_21;
            }
            opj_t2_putcommacode(VAR_24, (OPJ_INT32)VAR_33);

            /* COMMENT_19 */
            VAR_20->numlenbits += VAR_33;

            VAR_21 = VAR_20->passes +  VAR_20->numpasses;
            /* COMMENT_20 */
            for (VAR_36 = VAR_20->numpasses; VAR_36 < VAR_37; ++VAR_36) {
                VAR_34++;
                VAR_35 += VAR_21->len;

                if (VAR_21->term || VAR_36 == (VAR_20->numpasses + VAR_32->numpasses) - 1) {
                    opj_bio_write(VAR_24, (OPJ_UINT32)VAR_35,
                                  VAR_20->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)VAR_34));
                    VAR_35 = 0;
                    VAR_34 = 0;
                }
                ++VAR_21;
            }

            ++VAR_20;
        }
    }

    if (!opj_bio_flush(VAR_24)) {
        opj_bio_destroy(VAR_24);
        return VAR_30;               /* COMMENT_21 */
    }

    VAR_13 = (OPJ_UINT32)opj_bio_numbytes(VAR_24);
    VAR_12 += VAR_13;
    VAR_6 -= VAR_13;

    opj_bio_destroy(VAR_24);

    /* COMMENT_22 */
    if (VAR_2->csty & VAR_38) {
        if (VAR_6 < 2) {
            if (VAR_8 == VAR_28) {
                opj_event_msg(VAR_9, VAR_29,
                              ""opj_t2_encode_packet(): only %u bytes remaining in ""
                              ""output buffer. %u needed.\n"",
                              VAR_6, 2);
            }
            return VAR_30;
        }
        VAR_12[0] = 255;
        VAR_12[1] = 146;
        VAR_12 += 2;
        VAR_6 -= 2;
    }
    /* COMMENT_23 */

    /* COMMENT_24 */
    /* COMMENT_25 */
                                                                      
    if (VAR_7 && VAR_7->index_write) {
        opj_packet_info_t *VAR_39 = &VAR_7->tile[VAR_0].packet[VAR_7->packno];
        VAR_39->end_ph_pos = (OPJ_INT32)(VAR_12 - VAR_4);
    }
    /* COMMENT_27 */

    /* COMMENT_28 */
    VAR_19 = VAR_23->bands;
    for (VAR_10 = 0; !VAR_25 && VAR_10 < VAR_23->numbands; VAR_10++, ++VAR_19) {
        opj_tcd_precinct_t *VAR_31;

        /* COMMENT_8 */
        if (opj_tcd_is_band_empty(VAR_19)) {
            continue;
        }

        VAR_31 = &VAR_19->precincts[VAR_16];
        VAR_18 = VAR_31->cw * VAR_31->ch;
        VAR_20 = VAR_31->cblks.enc;

        for (VAR_11 = 0; VAR_11 < VAR_18; ++VAR_11) {
            opj_tcd_layer_t *VAR_32 = &VAR_20->layers[VAR_17];

            if (!VAR_32->numpasses) {
                ++VAR_20;
                continue;
            }

            if (VAR_32->len > VAR_6) {
                if (VAR_8 == VAR_28) {
                    opj_event_msg(VAR_9, VAR_29,
                                  ""opj_t2_encode_packet(): only %u bytes remaining in ""
                                  ""output buffer. %u needed.\n"",
                                  VAR_6, VAR_32->len);
                }
                return VAR_30;
            }

            memcpy(VAR_12, VAR_32->data, VAR_32->len);
            VAR_20->numpasses += VAR_32->numpasses;
            VAR_12 += VAR_32->len;
            VAR_6 -= VAR_32->len;

            /* COMMENT_24 */
            if (VAR_7 && VAR_7->index_write) {
                opj_packet_info_t *VAR_39 = &VAR_7->tile[VAR_0].packet[VAR_7->packno];
                VAR_39->disto += VAR_32->disto;
                if (VAR_7->D_max < VAR_39->disto) {
                    VAR_7->D_max = VAR_39->disto;
                }
            }

            ++VAR_20;
            /* COMMENT_27 */
        }
    }

    assert(VAR_12 >= VAR_4);
    * VAR_5 += (OPJ_UINT32)(VAR_12 - VAR_4);

    return VAR_26;
}",uclouvain/openjpeg/c535531f03369623b9b833ef41952c62257b507e/t2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,6 +29,15 @@
 
     /* <SOP 0xff91> */
     if (tcp->csty & J2K_CP_CSTY_SOP) {
+        if (length < 6) {
+            if (p_t2_mode == FINAL_PASS) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                              ""opj_t2_encode_packet(): only %u bytes remaining in ""
+                              ""output buffer. %u needed.\n"",
+                              length, 6);
+            }
+            return OPJ_FALSE;
+        }
         c[0] = 255;
         c[1] = 145;
         c[2] = 0;
@@ -217,6 +226,15 @@
 
     /* <EPH 0xff92> */
     if (tcp->csty & J2K_CP_CSTY_EPH) {
+        if (length < 2) {
+            if (p_t2_mode == FINAL_PASS) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                              ""opj_t2_encode_packet(): only %u bytes remaining in ""
+                              ""output buffer. %u needed.\n"",
+                              length, 2);
+            }
+            return OPJ_FALSE;
+        }
         c[0] = 255;
         c[1] = 146;
         c += 2;","{'deleted_lines': [], 'added_lines': ['        if (length < 6) {', '            if (p_t2_mode == FINAL_PASS) {', '                opj_event_msg(p_manager, EVT_ERROR,', '                              ""opj_t2_encode_packet(): only %u bytes remaining in ""', '                              ""output buffer. %u needed.\\n"",', '                              length, 6);', '            }', '            return OPJ_FALSE;', '        }', '        if (length < 2) {', '            if (p_t2_mode == FINAL_PASS) {', '                opj_event_msg(p_manager, EVT_ERROR,', '                              ""opj_t2_encode_packet(): only %u bytes remaining in ""', '                              ""output buffer. %u needed.\\n"",', '                              length, 2);', '            }', '            return OPJ_FALSE;', '        }']}",True,"A heap-based buffer overflow was discovered in the opj_t2_encode_packet function in lib/openjp2/t2.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly unspecified other impact.",8.8,HIGH,2,test,2017-08-16T15:20:29Z,2
CVE-2017-14039,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,uclouvain/openjpeg,opj_t2_encode_packet(): fix potential write heap buffer overflow (#992),c535531f03369623b9b833ef41952c62257b507e,https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e,src/lib/openjp2/j2k.c,opj_j2k_write_sot,"static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,
OPJ_BYTE * p_data,
OPJ_UINT32 p_total_data_size,
OPJ_UINT32 * p_data_written,
const opj_stream_private_t *p_stream,
opj_event_mgr_t * p_manager
)
{
assert(p_j2k != 00);
assert(p_manager != 00);
assert(p_stream != 00);
OPJ_UNUSED(p_stream);
OPJ_UNUSED(p_manager);
if (p_total_data_size < 12) {
opj_event_msg(p_manager, EVT_ERROR,
""Not enough bytes in output buffer to write SOT marker\n"");
return OPJ_FALSE;
}
opj_write_bytes(p_data, J2K_MS_SOT,
2);                                 
p_data += 2;
opj_write_bytes(p_data, 10,
2);                                                   
p_data += 2;
opj_write_bytes(p_data, p_j2k->m_current_tile_number,
2);                        
p_data += 2;
p_data += 4;
opj_write_bytes(p_data,
p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
1);                        
++p_data;
opj_write_bytes(p_data,
p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,
1);                      
++p_data;
#ifdef USE_JPWL
assert(0 && ""TODO"");
#endif 
* p_data_written = 12;
return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *VAR_0,
OPJ_BYTE * VAR_1,
OPJ_UINT32 VAR_2,
OPJ_UINT32 * VAR_3,
const opj_stream_private_t *VAR_4,
opj_event_mgr_t * VAR_5
)
{
assert(VAR_0 != 00);
assert(VAR_5 != 00);
assert(VAR_4 != 00);
OPJ_UNUSED(VAR_4);
OPJ_UNUSED(VAR_5);
if (VAR_2 < 12) {
opj_event_msg(VAR_5, VAR_6,
""Not enough bytes in output buffer to write SOT marker\n"");
return VAR_7;
}
opj_write_bytes(VAR_1, VAR_8,
2);                                 
VAR_1 += 2;
opj_write_bytes(VAR_1, 10,
2);                                                   
VAR_1 += 2;
opj_write_bytes(VAR_1, VAR_0->m_current_tile_number,
2);                        
VAR_1 += 2;
VAR_1 += 4;
opj_write_bytes(VAR_1,
VAR_0->m_specific_param.m_encoder.m_current_tile_part_number,
1);                        
++VAR_1;
opj_write_bytes(VAR_1,
VAR_0->m_cp.tcps[VAR_0->m_current_tile_number].m_nb_tile_parts,
1);                      
++VAR_1;
#ifdef VAR_9
assert(0 && ""TODO"");
#endif 
* VAR_3 = 12;
return VAR_10;
}",uclouvain/openjpeg/c535531f03369623b9b833ef41952c62257b507e/j2k.c/vul/before/1.json,"static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,
                                  OPJ_BYTE * p_data,
                                  OPJ_UINT32 p_total_data_size,
                                  OPJ_UINT32 * p_data_written,
                                  const opj_stream_private_t *p_stream,
                                  opj_event_mgr_t * p_manager
                                 )
{
    /* preconditions */
    assert(p_j2k != 00);
    assert(p_manager != 00);
    assert(p_stream != 00);

    OPJ_UNUSED(p_stream);

    if (p_total_data_size < 12) {
        opj_event_msg(p_manager, EVT_ERROR,
                      ""Not enough bytes in output buffer to write SOT marker\n"");
        return OPJ_FALSE;
    }

    opj_write_bytes(p_data, J2K_MS_SOT,
                    2);                                 /* SOT */
    p_data += 2;

    opj_write_bytes(p_data, 10,
                    2);                                                   /* Lsot */
    p_data += 2;

    opj_write_bytes(p_data, p_j2k->m_current_tile_number,
                    2);                        /* Isot */
    p_data += 2;

    /* Psot  */
    p_data += 4;

    opj_write_bytes(p_data,
                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,
                    1);                        /* TPsot */
    ++p_data;

    opj_write_bytes(p_data,
                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,
                    1);                      /* TNsot */
    ++p_data;

    /* UniPG>> */
#ifdef USE_JPWL
    /* update markers struct */
    /*
            OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOT, p_j2k->sot_start, len + 2);
    */
    assert(0 && ""TODO"");
#endif /* USE_JPWL */

    * p_data_written = 12;

    return OPJ_TRUE;
}","static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *VAR_0,
                                  OPJ_BYTE * VAR_1,
                                  OPJ_UINT32 VAR_2,
                                  OPJ_UINT32 * VAR_3,
                                  const opj_stream_private_t *VAR_4,
                                  opj_event_mgr_t * VAR_5
                                 )
{
    /* COMMENT_0 */
    assert(VAR_0 != 00);
    assert(VAR_5 != 00);
    assert(VAR_4 != 00);

    OPJ_UNUSED(VAR_4);

    if (VAR_2 < 12) {
        opj_event_msg(VAR_5, VAR_6,
                      ""Not enough bytes in output buffer to write SOT marker\n"");
        return VAR_7;
    }

    opj_write_bytes(VAR_1, VAR_8,
                    2);                                 /* COMMENT_1 */
    VAR_1 += 2;

    opj_write_bytes(VAR_1, 10,
                    2);                                                   /* COMMENT_2 */
    VAR_1 += 2;

    opj_write_bytes(VAR_1, VAR_0->m_current_tile_number,
                    2);                        /* COMMENT_3 */
    VAR_1 += 2;

    /* COMMENT_4 */
    VAR_1 += 4;

    opj_write_bytes(VAR_1,
                    VAR_0->m_specific_param.m_encoder.m_current_tile_part_number,
                    1);                        /* COMMENT_5 */
    ++VAR_1;

    opj_write_bytes(VAR_1,
                    VAR_0->m_cp.tcps[VAR_0->m_current_tile_number].m_nb_tile_parts,
                    1);                      /* COMMENT_6 */
    ++VAR_1;

    /* COMMENT_7 */
#ifdef VAR_9
    /* COMMENT_8 */
    /* COMMENT_9 */
                                                                                                   
      
    assert(0 && ""TODO"");
#endif /* COMMENT_12 */

    * VAR_3 = 12;

    return VAR_10;
}",uclouvain/openjpeg/c535531f03369623b9b833ef41952c62257b507e/j2k.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,7 +12,6 @@
     assert(p_stream != 00);
 
     OPJ_UNUSED(p_stream);
-    OPJ_UNUSED(p_manager);
 
     if (p_total_data_size < 12) {
         opj_event_msg(p_manager, EVT_ERROR,","{'deleted_lines': ['    OPJ_UNUSED(p_manager);'], 'added_lines': []}",True,"A heap-based buffer overflow was discovered in the opj_t2_encode_packet function in lib/openjp2/t2.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly unspecified other impact.",8.8,HIGH,2,test,2017-08-16T15:20:29Z,2
CVE-2017-13766,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"Fix potential oob write crashes

# Conflicts:
#	extcap/androiddump.c
#	plugins/profinet/packet-dcerpc-pn-io.c

Bug: 13847
Change-Id: I3a706db25204fe4c1fd1b7be3b17b8c55365dccf
Reviewed-on: https://code.wireshark.org/review/23169
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit 5574b78dae2f607d4ace66ab60d516d0c569357d)
Reviewed-on: https://code.wireshark.org/review/23170
Reviewed-on: https://code.wireshark.org/review/23171
Reviewed-by: Anders Broman <a.broman58@gmail.com>",2096bc1e5078732543e0a3ee115a2ce520a72bbc,https://github.com/wireshark/wireshark/commit/2096bc1e5078732543e0a3ee115a2ce520a72bbc,plugins/profinet/packet-dcerpc-pn-io.c,dissect_ExpectedSubmoduleBlockReq_block,"static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *tvb, int offset,
packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)
{
guint16     u16NumberOfAPIs;
guint32     u32Api;
guint16     u16SlotNr;
guint32     u32ModuleIdentNumber;
guint16     u16ModuleProperties;
guint16     u16NumberOfSubmodules;
guint16     u16SubslotNr;
guint32     u32SubmoduleIdentNumber;
guint16     u16SubmoduleProperties;
proto_item *api_item;
proto_tree *api_tree;
guint32     u32ApiStart;
proto_item *sub_item;
proto_tree *sub_tree;
proto_item *submodule_item;
proto_tree *submodule_tree;
guint32     u32SubStart;
const char vendorIdStr[] = ""VendorID=\"""";
const char deviceIdStr[] = ""DeviceID=\"""";
const char moduleStr[] = ""ModuleIdentNumber=\"""";
const char subModuleStr[] = ""SubmoduleIdentNumber=\"""";
const char profisafeStr[] = ""PROFIsafeSupported=\""true\"""";
const char fParameterStr[] = ""<F_ParameterRecordDataItem"";
const char fParameterIndexStr[] = ""Index="";
const char moduleNameInfo[] = ""<Name"";
const char moduleValueInfo[] = ""Value=\"""";
guint16  searchVendorID = 0;
guint16  searchDeviceID = 0;
gboolean vendorMatch;
gboolean deviceMatch;
conversation_t *conversation;
stationInfo    *station_info = NULL;
ioDataObject   *io_data_object = NULL; 
guint32  read_vendor_id;
guint32  read_device_id;
guint32  read_module_id;
guint32  read_submodule_id;
gboolean gsdmlFoundFlag;
gchar   tmp_moduletext[MAX_NAMELENGTH];
gchar   *convertStr;      
gchar   *pch;             
gchar   *puffer;          
gchar   *temp;            
gchar   *diropen = NULL;  
GDir    *dir;
FILE    *fp = NULL;       
const gchar *filename;    
convertStr = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_NAMELENGTH);
convertStr[0] = '\0';
pch = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
pch[0] = '\0';
puffer = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
puffer[0] = '\0';
temp = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
temp[0] = '\0';
io_data_object = wmem_new0(wmem_file_scope(), ioDataObject);
io_data_object->profisafeSupported = FALSE;
io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");
vendorMatch = FALSE;
deviceMatch = FALSE;
gsdmlFoundFlag = FALSE;
if (u8BlockVersionHigh != 1 || u8BlockVersionLow != 0) {
expert_add_info_format(pinfo, item, &ei_pn_io_block_version,
""Block version %u.%u not implemented yet!"", u8BlockVersionHigh, u8BlockVersionLow);
return offset;
}
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep,
hf_pn_io_number_of_apis, &u16NumberOfAPIs);
proto_item_append_text(item, "": APIs:%u"", u16NumberOfAPIs);
conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
if (conversation == NULL) {
conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
}
station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);
if (station_info != NULL) {
station_info->gsdFound = FALSE;
station_info->gsdPathLength = FALSE;
searchVendorID = station_info->u16Vendor_id;
searchDeviceID = station_info->u16Device_id;
if(pnio_ps_networkpath[0] != '\0') {   
station_info->gsdPathLength = TRUE;
if ((dir = g_dir_open(pnio_ps_networkpath, 0, NULL)) != NULL) {
while ((filename = g_dir_read_name(dir)) != NULL) {
diropen = wmem_strdup_printf(wmem_packet_scope(), ""%s"" G_DIR_SEPARATOR_S ""%s"", pnio_ps_networkpath, filename);
fp = ws_fopen(diropen, ""r"");
if(fp != NULL) {
while(fgets(puffer, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(puffer, vendorIdStr)) != NULL) {
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(puffer, vendorIdStr);
if (sscanf(pch, ""VendorID=\""%[^\""]"", convertStr) == 1) {
read_vendor_id = (guint32) strtoul (convertStr, NULL, 0);
if(read_vendor_id == searchVendorID) {
vendorMatch = TRUE;        
}
}
}
if((strstr(puffer, deviceIdStr)) != NULL) {
memset(convertStr, 0, sizeof(*convertStr));
pch = strstr(puffer, deviceIdStr);
if (sscanf(pch, ""DeviceID=\""%[^\""]"", convertStr) == 1) {
read_device_id = (guint32)strtoul(convertStr, NULL, 0);
if(read_device_id == searchDeviceID) {
deviceMatch = TRUE;        
}
}
}
}
fclose(fp);
fp = NULL;
if(vendorMatch && deviceMatch) {
break;        
}
else {
vendorMatch = FALSE;
deviceMatch = FALSE;
gsdmlFoundFlag = FALSE;
diropen = """";           
}
}
}
g_dir_close(dir);
}
if(vendorMatch && deviceMatch) {
gsdmlFoundFlag = TRUE;
station_info->gsdFound = TRUE;
station_info->gsdLocation = wmem_strdup(wmem_file_scope(), diropen);
}
else {
station_info->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" G_DIR_SEPARATOR_S ""*.xml"", pnio_ps_networkpath);
}
}
else {
station_info->gsdPathLength = FALSE;
}
}
while (u16NumberOfAPIs--) {
api_item = proto_tree_add_item(tree, hf_pn_io_api_tree, tvb, offset, 0, ENC_NA);
api_tree = proto_item_add_subtree(api_item, ett_pn_io_api);
u32ApiStart = offset;
offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_api, &u32Api);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_slot_nr, &u16SlotNr);
offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_module_ident_number, &u32ModuleIdentNumber);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_module_properties, &u16ModuleProperties);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_number_of_submodules, &u16NumberOfSubmodules);
proto_item_append_text(api_item, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
u32Api, u16SlotNr, u32ModuleIdentNumber, u16ModuleProperties, u16NumberOfSubmodules);
proto_item_append_text(item, "", Submodules:%u"", u16NumberOfSubmodules);
while (u16NumberOfSubmodules--) {
sub_item = proto_tree_add_item(api_tree, hf_pn_io_submodule_tree, tvb, offset, 0, ENC_NA);
sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_submodule);
u32SubStart = offset;
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,
hf_pn_io_subslot_nr, &u16SubslotNr);
offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,
hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber);
submodule_item = proto_tree_add_item(sub_tree, hf_pn_io_submodule_properties, tvb, offset, 2, ENC_BIG_ENDIAN);
submodule_tree = proto_item_add_subtree(submodule_item, ett_pn_io_submodule_properties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_reserved, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_discard_ioxs, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_reduce_output_submodule_data_length, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_reduce_input_submodule_data_length, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_shared_input, &u16SubmoduleProperties);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_type, &u16SubmoduleProperties);
io_data_object->slotNr = u16SlotNr;
io_data_object->subSlotNr = u16SubslotNr;
io_data_object->moduleIdentNr = u32ModuleIdentNumber;
io_data_object->subModuleIdentNr = u32SubmoduleIdentNumber;
io_data_object->discardIOXS = u16SubmoduleProperties & 0x0020;
io_data_object->amountInGSDML = 0;
io_data_object->fParameterIndexNr = 0;
io_data_object->profisafeSupported = FALSE;
if (diropen != NULL) {
fp = ws_fopen(diropen, ""r"");
}
if(gsdmlFoundFlag && fp != NULL) {
fseek(fp, 0, SEEK_SET);
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, fParameterStr)) != NULL) {
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(temp, fParameterIndexStr);
if (sscanf(pch, ""Index=\""%[^\""]"", convertStr) == 1) {
io_data_object->fParameterIndexNr = (guint32)strtoul(convertStr, NULL, 0);
}
break;    
}
}
memset (temp, 0, sizeof(*temp));
fseek(fp, 0, SEEK_SET);                
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, moduleStr)) != NULL) {                         
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(temp, moduleStr);                              
if (sscanf(pch, ""ModuleIdentNumber=\""%[^\""]"", convertStr) == 1) {  
read_module_id = (guint32)strtoul(convertStr, NULL, 0);     
if (read_module_id == io_data_object->moduleIdentNr) {
++io_data_object->amountInGSDML;    
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, moduleNameInfo)) != NULL) {                    
long filePosRecord;
if (sscanf(temp, ""%*s TextId=\""%[^\""]"", tmp_moduletext) != 1)        
break;
filePosRecord = ftell(fp);            
if (filePosRecord >= 0) {
while (fgets(temp, MAX_LINE_LENGTH, fp) != NULL && io_data_object->amountInGSDML == 1) {
if(((strstr(temp, tmp_moduletext)) != NULL) && ((strstr(temp, moduleValueInfo)) != NULL)) {
pch = strstr(temp, moduleValueInfo);
if (sscanf(pch, ""Value=\""%[^\""]"", io_data_object->moduleNameStr) == 1)
break;    
}
}
fseek(fp, filePosRecord, SEEK_SET);    
}
}
if((strstr(temp, subModuleStr)) != NULL) {
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(temp, subModuleStr);
if (sscanf(pch, ""SubmoduleIdentNumber=\""%[^\""]"", convertStr) == 1) {
read_submodule_id = (guint32) strtoul (convertStr, NULL, 0);    
if(read_submodule_id == io_data_object->subModuleIdentNr) {
if((strstr(temp, profisafeStr)) != NULL) {
io_data_object->profisafeSupported = TRUE;   
break;
}
else {    
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, profisafeStr)) != NULL) {
io_data_object->profisafeSupported = TRUE;
break;    
}
else if((strstr(temp, "">"")) != NULL) {
break;
}
}
}
}
break;    
}
}
}
}
}
}
}
fclose(fp);
fp = NULL;
}
switch (u16SubmoduleProperties & 0x03) {
case(0x00): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
case(0x01): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
case(0x02): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
case(0x03): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
}
proto_item_append_text(sub_item, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
u16SubslotNr, u32SubmoduleIdentNumber, u16SubmoduleProperties);
proto_item_set_len(sub_item, offset - u32SubStart);
}
proto_item_set_len(api_item, offset - u32ApiStart);
}
return offset;
}","static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *VAR_0, int VAR_1,
packet_info *VAR_2, proto_tree *VAR_3, proto_item *VAR_4, guint8 *VAR_5, guint8 VAR_6, guint8 VAR_7)
{
guint16     VAR_8;
guint32     VAR_9;
guint16     VAR_10;
guint32     VAR_11;
guint16     VAR_12;
guint16     VAR_13;
guint16     VAR_14;
guint32     VAR_15;
guint16     VAR_16;
proto_item *VAR_17;
proto_tree *VAR_18;
guint32     VAR_19;
proto_item *VAR_20;
proto_tree *VAR_21;
proto_item *VAR_22;
proto_tree *VAR_23;
guint32     VAR_24;
const char VAR_25[] = ""VendorID=\"""";
const char VAR_26[] = ""DeviceID=\"""";
const char VAR_27[] = ""ModuleIdentNumber=\"""";
const char VAR_28[] = ""SubmoduleIdentNumber=\"""";
const char VAR_29[] = ""PROFIsafeSupported=\""true\"""";
const char VAR_30[] = ""<F_ParameterRecordDataItem"";
const char VAR_31[] = ""Index="";
const char VAR_32[] = ""<Name"";
const char VAR_33[] = ""Value=\"""";
guint16  VAR_34 = 0;
guint16  VAR_35 = 0;
gboolean VAR_36;
gboolean VAR_37;
conversation_t *VAR_38;
stationInfo    *VAR_39 = NULL;
ioDataObject   *VAR_40 = NULL; 
guint32  VAR_41;
guint32  VAR_42;
guint32  VAR_43;
guint32  VAR_44;
gboolean VAR_45;
gchar   VAR_46[VAR_47];
gchar   *VAR_48;      
gchar   *VAR_49;             
gchar   *VAR_50;          
gchar   *VAR_51;            
gchar   *VAR_52 = NULL;  
GDir    *VAR_53;
FILE    *VAR_54 = NULL;       
const gchar *VAR_55;    
VAR_48 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_47);
VAR_48[0] = '\0';
VAR_49 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
VAR_49[0] = '\0';
VAR_50 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
VAR_50[0] = '\0';
VAR_51 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
VAR_51[0] = '\0';
VAR_40 = wmem_new0(wmem_file_scope(), ioDataObject);
VAR_40->profisafeSupported = FALSE;
VAR_40->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");
VAR_36 = FALSE;
VAR_37 = FALSE;
VAR_45 = FALSE;
if (VAR_6 != 1 || VAR_7 != 0) {
expert_add_info_format(VAR_2, VAR_4, &VAR_57,
""Block version %u.%u not implemented yet!"", VAR_6, VAR_7);
return VAR_1;
}
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5,
VAR_58, &VAR_8);
proto_item_append_text(VAR_4, "": APIs:%u"", VAR_8);
VAR_38 = find_conversation(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
if (VAR_38 == NULL) {
VAR_38 = conversation_new(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
}
VAR_39 = (stationInfo*)conversation_get_proto_data(VAR_38, VAR_60);
if (VAR_39 != NULL) {
VAR_39->gsdFound = FALSE;
VAR_39->gsdPathLength = FALSE;
VAR_34 = VAR_39->u16Vendor_id;
VAR_35 = VAR_39->u16Device_id;
if(VAR_61[0] != '\0') {   
VAR_39->gsdPathLength = TRUE;
if ((VAR_53 = g_dir_open(VAR_61, 0, NULL)) != NULL) {
while ((VAR_55 = g_dir_read_name(VAR_53)) != NULL) {
VAR_52 = wmem_strdup_printf(wmem_packet_scope(), ""%s"" VAR_62 ""%s"", VAR_61, VAR_55);
VAR_54 = ws_fopen(VAR_52, ""r"");
if(VAR_54 != NULL) {
while(fgets(VAR_50, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_50, VAR_25)) != NULL) {
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_50, VAR_25);
if (sscanf(VAR_49, ""VendorID=\""%[^\""]"", VAR_48) == 1) {
VAR_41 = (guint32) strtoul (VAR_48, NULL, 0);
if(VAR_41 == VAR_34) {
VAR_36 = TRUE;        
}
}
}
if((strstr(VAR_50, VAR_26)) != NULL) {
memset(VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_50, VAR_26);
if (sscanf(VAR_49, ""DeviceID=\""%[^\""]"", VAR_48) == 1) {
VAR_42 = (guint32)strtoul(VAR_48, NULL, 0);
if(VAR_42 == VAR_35) {
VAR_37 = TRUE;        
}
}
}
}
fclose(VAR_54);
VAR_54 = NULL;
if(VAR_36 && VAR_37) {
break;        
}
else {
VAR_36 = FALSE;
VAR_37 = FALSE;
VAR_45 = FALSE;
VAR_52 = """";           
}
}
}
g_dir_close(VAR_53);
}
if(VAR_36 && VAR_37) {
VAR_45 = TRUE;
VAR_39->gsdFound = TRUE;
VAR_39->gsdLocation = wmem_strdup(wmem_file_scope(), VAR_52);
}
else {
VAR_39->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" VAR_62 ""*.xml"", VAR_61);
}
}
else {
VAR_39->gsdPathLength = FALSE;
}
}
while (VAR_8--) {
VAR_17 = proto_tree_add_item(VAR_3, VAR_63, VAR_0, VAR_1, 0, VAR_64);
VAR_18 = proto_item_add_subtree(VAR_17, VAR_65);
VAR_19 = VAR_1;
VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_66, &VAR_9);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_67, &VAR_10);
VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_68, &VAR_11);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_69, &VAR_12);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_70, &VAR_13);
proto_item_append_text(VAR_17, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
VAR_9, VAR_10, VAR_11, VAR_12, VAR_13);
proto_item_append_text(VAR_4, "", Submodules:%u"", VAR_13);
while (VAR_13--) {
VAR_20 = proto_tree_add_item(VAR_18, VAR_71, VAR_0, VAR_1, 0, VAR_64);
VAR_21 = proto_item_add_subtree(VAR_20, VAR_72);
VAR_24 = VAR_1;
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
VAR_73, &VAR_14);
VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
VAR_74, &VAR_15);
VAR_22 = proto_tree_add_item(VAR_21, VAR_75, VAR_0, VAR_1, 2, VAR_76);
VAR_23 = proto_item_add_subtree(VAR_22, VAR_77);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_78, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_79, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_80, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_81, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_82, &VAR_16);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_83, &VAR_16);
VAR_40->slotNr = VAR_10;
VAR_40->subSlotNr = VAR_14;
VAR_40->moduleIdentNr = VAR_11;
VAR_40->subModuleIdentNr = VAR_15;
VAR_40->discardIOXS = VAR_16 & 0x0020;
VAR_40->amountInGSDML = 0;
VAR_40->fParameterIndexNr = 0;
VAR_40->profisafeSupported = FALSE;
if (VAR_52 != NULL) {
VAR_54 = ws_fopen(VAR_52, ""r"");
}
if(VAR_45 && VAR_54 != NULL) {
fseek(VAR_54, 0, VAR_84);
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_30)) != NULL) {
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_51, VAR_31);
if (sscanf(VAR_49, ""Index=\""%[^\""]"", VAR_48) == 1) {
VAR_40->fParameterIndexNr = (guint32)strtoul(VAR_48, NULL, 0);
}
break;    
}
}
memset (VAR_51, 0, sizeof(*VAR_51));
fseek(VAR_54, 0, VAR_84);                
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_27)) != NULL) {                         
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_51, VAR_27);                              
if (sscanf(VAR_49, ""ModuleIdentNumber=\""%[^\""]"", VAR_48) == 1) {  
VAR_43 = (guint32)strtoul(VAR_48, NULL, 0);     
if (VAR_43 == VAR_40->moduleIdentNr) {
++VAR_40->amountInGSDML;    
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_32)) != NULL) {                    
long VAR_85;
if (sscanf(VAR_51, ""%*s TextId=\""%[^\""]"", VAR_46) != 1)        
break;
VAR_85 = ftell(VAR_54);            
if (VAR_85 >= 0) {
while (fgets(VAR_51, VAR_56, VAR_54) != NULL && VAR_40->amountInGSDML == 1) {
if(((strstr(VAR_51, VAR_46)) != NULL) && ((strstr(VAR_51, VAR_33)) != NULL)) {
VAR_49 = strstr(VAR_51, VAR_33);
if (sscanf(VAR_49, ""Value=\""%[^\""]"", VAR_40->moduleNameStr) == 1)
break;    
}
}
fseek(VAR_54, VAR_85, VAR_84);    
}
}
if((strstr(VAR_51, VAR_28)) != NULL) {
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_51, VAR_28);
if (sscanf(VAR_49, ""SubmoduleIdentNumber=\""%[^\""]"", VAR_48) == 1) {
VAR_44 = (guint32) strtoul (VAR_48, NULL, 0);    
if(VAR_44 == VAR_40->subModuleIdentNr) {
if((strstr(VAR_51, VAR_29)) != NULL) {
VAR_40->profisafeSupported = TRUE;   
break;
}
else {    
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_29)) != NULL) {
VAR_40->profisafeSupported = TRUE;
break;    
}
else if((strstr(VAR_51, "">"")) != NULL) {
break;
}
}
}
}
break;    
}
}
}
}
}
}
}
fclose(VAR_54);
VAR_54 = NULL;
}
switch (VAR_16 & 0x03) {
case(0x00): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
case(0x01): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
case(0x02): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
case(0x03): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
}
proto_item_append_text(VAR_20, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
VAR_14, VAR_15, VAR_16);
proto_item_set_len(VAR_20, VAR_1 - VAR_24);
}
proto_item_set_len(VAR_17, VAR_1 - VAR_19);
}
return VAR_1;
}",wireshark/2096bc1e5078732543e0a3ee115a2ce520a72bbc/packet-dcerpc-pn-io.c/vul/before/0.json,"static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *tvb, int offset,
    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)
{
    guint16     u16NumberOfAPIs;
    guint32     u32Api;
    guint16     u16SlotNr;
    guint32     u32ModuleIdentNumber;
    guint16     u16ModuleProperties;
    guint16     u16NumberOfSubmodules;
    guint16     u16SubslotNr;
    guint32     u32SubmoduleIdentNumber;
    guint16     u16SubmoduleProperties;
    proto_item *api_item;
    proto_tree *api_tree;
    guint32     u32ApiStart;
    proto_item *sub_item;
    proto_tree *sub_tree;
    proto_item *submodule_item;
    proto_tree *submodule_tree;
    guint32     u32SubStart;

    /* Variable for the search of gsd file */
    const char vendorIdStr[] = ""VendorID=\"""";
    const char deviceIdStr[] = ""DeviceID=\"""";
    const char moduleStr[] = ""ModuleIdentNumber=\"""";
    const char subModuleStr[] = ""SubmoduleIdentNumber=\"""";
    const char profisafeStr[] = ""PROFIsafeSupported=\""true\"""";
    const char fParameterStr[] = ""<F_ParameterRecordDataItem"";
    const char fParameterIndexStr[] = ""Index="";
    const char moduleNameInfo[] = ""<Name"";
    const char moduleValueInfo[] = ""Value=\"""";

    guint16  searchVendorID = 0;
    guint16  searchDeviceID = 0;
    gboolean vendorMatch;
    gboolean deviceMatch;
    conversation_t *conversation;
    stationInfo    *station_info = NULL;
    ioDataObject   *io_data_object = NULL; /* Used to transfer data to fct. ""dissect_DataDescription()"" */

    /* Variable for the search of GSD-file */
    guint32  read_vendor_id;
    guint32  read_device_id;
    guint32  read_module_id;
    guint32  read_submodule_id;
    gboolean gsdmlFoundFlag;
    gchar   tmp_moduletext[MAX_NAMELENGTH];
    gchar   *convertStr;      /* GSD-file search */
    gchar   *pch;             /* helppointer, to save temp. the found Networkpath of GSD-file */
    gchar   *puffer;          /* used for fgets() during GSD-file search */
    gchar   *temp;            /* used for fgets() during GSD-file search */
    gchar   *diropen = NULL;  /* saves the final networkpath to open for GSD-files */
    GDir    *dir;
    FILE    *fp = NULL;       /* filepointer */
    const gchar *filename;    /* saves the found GSD-file name */

    /* Helppointer initial */
    convertStr = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_NAMELENGTH);
    convertStr[0] = '\0';
    pch = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
    pch[0] = '\0';
    puffer = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
    puffer[0] = '\0';
    temp = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
    temp[0] = '\0';

    /* Initial */
    io_data_object = wmem_new0(wmem_file_scope(), ioDataObject);
    io_data_object->profisafeSupported = FALSE;
    io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");
    vendorMatch = FALSE;
    deviceMatch = FALSE;
    gsdmlFoundFlag = FALSE;


    if (u8BlockVersionHigh != 1 || u8BlockVersionLow != 0) {
        expert_add_info_format(pinfo, item, &ei_pn_io_block_version,
            ""Block version %u.%u not implemented yet!"", u8BlockVersionHigh, u8BlockVersionLow);
        return offset;
    }

    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep,
                        hf_pn_io_number_of_apis, &u16NumberOfAPIs);

    proto_item_append_text(item, "": APIs:%u"", u16NumberOfAPIs);


    /* Get current conversation endpoints using MAC addresses */
    conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
    if (conversation == NULL) {
        conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
    }

    station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);
    if (station_info != NULL) {
        station_info->gsdFound = FALSE;
        station_info->gsdPathLength = FALSE;

        /* Set searchVendorID and searchDeviceID for GSDfile search */
        searchVendorID = station_info->u16Vendor_id;
        searchDeviceID = station_info->u16Device_id;

        /* Use the given GSD-file networkpath of the PNIO-Preference */
        if(pnio_ps_networkpath[0] != '\0') {   /* check the length of the given networkpath (array overflow protection) */
            station_info->gsdPathLength = TRUE;

            if ((dir = g_dir_open(pnio_ps_networkpath, 0, NULL)) != NULL) {
                /* Find all GSD-files within directory */
                while ((filename = g_dir_read_name(dir)) != NULL) {

                    /* ---- complete the path to open a GSD-file ---- */
                    diropen = wmem_strdup_printf(wmem_packet_scope(), ""%s"" G_DIR_SEPARATOR_S ""%s"", pnio_ps_networkpath, filename);

                    /* ---- Open the found GSD-file  ---- */
                    fp = ws_fopen(diropen, ""r"");

                    if(fp != NULL) {
                        /* ---- Get VendorID & DeviceID ---- */
                        while(fgets(puffer, MAX_LINE_LENGTH, fp) != NULL) {
                            /* ----- VendorID ------ */
                            if((strstr(puffer, vendorIdStr)) != NULL) {
                                memset (convertStr, 0, sizeof(*convertStr));
                                pch = strstr(puffer, vendorIdStr);
                                if (pch!= NULL && sscanf(pch, ""VendorID=\""%199[^\""]"", convertStr) == 1) {
                                    read_vendor_id = (guint32) strtoul (convertStr, NULL, 0);

                                    if(read_vendor_id == searchVendorID) {
                                        vendorMatch = TRUE;        /* found correct VendorID */
                                    }
                                }
                            }

                            /* ----- DeviceID ------ */
                            if((strstr(puffer, deviceIdStr)) != NULL) {
                                memset(convertStr, 0, sizeof(*convertStr));
                                pch = strstr(puffer, deviceIdStr);
                                if (pch != NULL && sscanf(pch, ""DeviceID=\""%199[^\""]"", convertStr) == 1) {
                                    read_device_id = (guint32)strtoul(convertStr, NULL, 0);

                                    if(read_device_id == searchDeviceID) {
                                        deviceMatch = TRUE;        /* found correct DeviceID */
                                    }
                                }
                            }
                        }

                        fclose(fp);
                        fp = NULL;

                        if(vendorMatch && deviceMatch) {
                            break;        /* Found correct GSD-file! -> Break the searchloop */
                        }
                        else {
                            /* Couldn't find the correct GSD-file to the corresponding device */
                            vendorMatch = FALSE;
                            deviceMatch = FALSE;
                            gsdmlFoundFlag = FALSE;
                            diropen = """";           /* reset array for next search */
                        }
                    }
                }

                g_dir_close(dir);
            }

            /* ---- Found the correct GSD-file -> set Flag and save the completed path ---- */
            if(vendorMatch && deviceMatch) {
                gsdmlFoundFlag = TRUE;
                station_info->gsdFound = TRUE;
                station_info->gsdLocation = wmem_strdup(wmem_file_scope(), diropen);
            }
            else {
                /* Copy searchpath to array for a detailed output message in cyclic data dissection */
                station_info->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" G_DIR_SEPARATOR_S ""*.xml"", pnio_ps_networkpath);
            }
        }
        else {
            /* will be used later on in cyclic RTC1 data dissection for detailed output message */
            station_info->gsdPathLength = FALSE;
        }
    }

    while (u16NumberOfAPIs--) {
        api_item = proto_tree_add_item(tree, hf_pn_io_api_tree, tvb, offset, 0, ENC_NA);
        api_tree = proto_item_add_subtree(api_item, ett_pn_io_api);
        u32ApiStart = offset;

        /* API */
        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_api, &u32Api);
        /* SlotNumber */
        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_slot_nr, &u16SlotNr);
        /* ModuleIdentNumber */
        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_module_ident_number, &u32ModuleIdentNumber);
        /* ModuleProperties */
        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_module_properties, &u16ModuleProperties);
        /* NumberOfSubmodules */
        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_number_of_submodules, &u16NumberOfSubmodules);

        proto_item_append_text(api_item, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
            u32Api, u16SlotNr, u32ModuleIdentNumber, u16ModuleProperties, u16NumberOfSubmodules);

        proto_item_append_text(item, "", Submodules:%u"", u16NumberOfSubmodules);

        while (u16NumberOfSubmodules--) {
            sub_item = proto_tree_add_item(api_tree, hf_pn_io_submodule_tree, tvb, offset, 0, ENC_NA);
            sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_submodule);
            u32SubStart = offset;

            /* Subslotnumber */
            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,
                                hf_pn_io_subslot_nr, &u16SubslotNr);
            /* SubmoduleIdentNumber */
            offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,
                            hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber);
            /* SubmoduleProperties */
            submodule_item = proto_tree_add_item(sub_tree, hf_pn_io_submodule_properties, tvb, offset, 2, ENC_BIG_ENDIAN);
            submodule_tree = proto_item_add_subtree(submodule_item, ett_pn_io_submodule_properties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_reserved, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_discard_ioxs, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_reduce_output_submodule_data_length, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_reduce_input_submodule_data_length, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_shared_input, &u16SubmoduleProperties);
            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_type, &u16SubmoduleProperties);

            io_data_object->slotNr = u16SlotNr;
            io_data_object->subSlotNr = u16SubslotNr;
            io_data_object->moduleIdentNr = u32ModuleIdentNumber;
            io_data_object->subModuleIdentNr = u32SubmoduleIdentNumber;
            io_data_object->discardIOXS = u16SubmoduleProperties & 0x0020;

            /* Search the moduleID and subModuleID, find if PROFIsafe and also search for F-Par. Indexnumber
             * ---------------------------------------------------------------------------------------------
             * Speical case: Module has several ModuleIdentNr. in one GSD-file
             * Also with the given parameters of wireshark, some modules were completely equal. For this
             * special case a compromise for this problem has been made, to set the module name will
             * be more generally displayed.
             * Also this searchloop will find the F-Parameter Indexnumber, so that Wireshark is able to
             * dissect those F-Parameters correctly, as this index can change between the vendors.
             */

            io_data_object->amountInGSDML = 0;
            io_data_object->fParameterIndexNr = 0;
            io_data_object->profisafeSupported = FALSE;

            if (diropen != NULL) {
                fp = ws_fopen(diropen, ""r"");
            }
            if(gsdmlFoundFlag && fp != NULL) {
                fseek(fp, 0, SEEK_SET);

                /* Find Indexnumber for fParameter */
                while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                    if((strstr(temp, fParameterStr)) != NULL) {
                        memset (convertStr, 0, sizeof(*convertStr));

                        pch = strstr(temp, fParameterIndexStr);
                        if (pch != NULL && sscanf(pch, ""Index=\""%199[^\""]"", convertStr) == 1) {
                            io_data_object->fParameterIndexNr = (guint32)strtoul(convertStr, NULL, 0);
                        }
                        break;    /* found Indexnumber -> break search loop */
                    }
                }

                memset (temp, 0, sizeof(*temp));
                fseek(fp, 0, SEEK_SET);                /* Set filepointer to the beginning */

                while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                    if((strstr(temp, moduleStr)) != NULL) {                         /* find the String ""ModuleIdentNumber="" */
                        memset (convertStr, 0, sizeof(*convertStr));
                        pch = strstr(temp, moduleStr);                              /* search for ""ModuleIdentNumber=\"""" within GSD-file */
                        if (pch != NULL && sscanf(pch, ""ModuleIdentNumber=\""%199[^\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */
                            read_module_id = (guint32)strtoul(convertStr, NULL, 0);     /* Change numeric string --> unsigned long; read_module_id contains the Value of the ModuleIdentNumber */

                            /* If the found ModuleID matches with the wanted ModuleID, search for the Submodule and break */
                            if (read_module_id == io_data_object->moduleIdentNr) {
                                ++io_data_object->amountInGSDML;    /* Save the amount of same (!) Module- & SubmoduleIdentNr in one GSD-file */

                                while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                                    if((strstr(temp, moduleNameInfo)) != NULL) {                    /* find the String ""<Name"" for the TextID */
                                        long filePosRecord;

                                        if (sscanf(temp, ""%*s TextId=\""%199[^\""]"", tmp_moduletext) != 1)        /* saves the correct TextId for the next searchloop */
                                            break;

                                        filePosRecord = ftell(fp);            /* save the current position of the filepointer (Offset) */
                                        /* ftell() may return -1 for error, don't move fp in this case */
                                        if (filePosRecord >= 0) {
                                            while (fgets(temp, MAX_LINE_LENGTH, fp) != NULL && io_data_object->amountInGSDML == 1) {
                                                /* Find a String with the saved TextID and with a fitting value for it in the same line. This value is the name of the Module! */
                                                if(((strstr(temp, tmp_moduletext)) != NULL) && ((strstr(temp, moduleValueInfo)) != NULL)) {
                                                    pch = strstr(temp, moduleValueInfo);
                                                    if (sscanf(pch, ""Value=\""%[^\""]"", io_data_object->moduleNameStr) == 1)
                                                        break;    /* Found the name of the module */
                                                }
                                            }

                                            fseek(fp, filePosRecord, SEEK_SET);    /* set filepointer to the correct TextID */
                                        }
                                    }

                                    /* Search for Submoduleidentnumber in GSD-file */
                                    if((strstr(temp, subModuleStr)) != NULL) {
                                        memset (convertStr, 0, sizeof(*convertStr));
                                        pch = strstr(temp, subModuleStr);
                                        if (pch != NULL && sscanf(pch, ""SubmoduleIdentNumber=\""%199[^\""]"", convertStr) == 1) {
                                            read_submodule_id = (guint32) strtoul (convertStr, NULL, 0);    /* read_submodule_id contains the Value of the SubModuleIdentNumber */

                                            /* Find ""PROFIsafeSupported"" flag of the module in GSD-file */
                                            if(read_submodule_id == io_data_object->subModuleIdentNr) {
                                                if((strstr(temp, profisafeStr)) != NULL) {
                                                    io_data_object->profisafeSupported = TRUE;   /* flag is in the same line as SubmoduleIdentNr */
                                                    break;
                                                }
                                                else {    /* flag is not in the same line as Submoduleidentnumber -> search for it */
                                                    while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                                                        if((strstr(temp, profisafeStr)) != NULL) {
                                                            io_data_object->profisafeSupported = TRUE;
                                                            break;    /* Found the PROFIsafeSupported flag of the module */
                                                        }

                                                        else if((strstr(temp, "">"")) != NULL) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            break;    /* Found the PROFIsafe Module */
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                fclose(fp);
                fp = NULL;
            }

            switch (u16SubmoduleProperties & 0x03) {
            case(0x00): /* no input and no output data (one Input DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            case(0x01): /* input data (one Input DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            case(0x02): /* output data (one Output DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            case(0x03): /* input and output data (one Input and one Output DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            }

            proto_item_append_text(sub_item, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
                u16SubslotNr, u32SubmoduleIdentNumber, u16SubmoduleProperties);
            proto_item_set_len(sub_item, offset - u32SubStart);
        }

        proto_item_set_len(api_item, offset - u32ApiStart);
    }

    return offset;
}","static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *VAR_0, int VAR_1,
    packet_info *VAR_2, proto_tree *VAR_3, proto_item *VAR_4, guint8 *VAR_5, guint8 VAR_6, guint8 VAR_7)
{
    guint16     VAR_8;
    guint32     VAR_9;
    guint16     VAR_10;
    guint32     VAR_11;
    guint16     VAR_12;
    guint16     VAR_13;
    guint16     VAR_14;
    guint32     VAR_15;
    guint16     VAR_16;
    proto_item *VAR_17;
    proto_tree *VAR_18;
    guint32     VAR_19;
    proto_item *VAR_20;
    proto_tree *VAR_21;
    proto_item *VAR_22;
    proto_tree *VAR_23;
    guint32     VAR_24;

    /* COMMENT_0 */
    const char VAR_25[] = ""VendorID=\"""";
    const char VAR_26[] = ""DeviceID=\"""";
    const char VAR_27[] = ""ModuleIdentNumber=\"""";
    const char VAR_28[] = ""SubmoduleIdentNumber=\"""";
    const char VAR_29[] = ""PROFIsafeSupported=\""true\"""";
    const char VAR_30[] = ""<F_ParameterRecordDataItem"";
    const char VAR_31[] = ""Index="";
    const char VAR_32[] = ""<Name"";
    const char VAR_33[] = ""Value=\"""";

    guint16  VAR_34 = 0;
    guint16  VAR_35 = 0;
    gboolean VAR_36;
    gboolean VAR_37;
    conversation_t *VAR_38;
    stationInfo    *VAR_39 = NULL;
    ioDataObject   *VAR_40 = NULL; /* COMMENT_1 */

    /* COMMENT_2 */
    guint32  VAR_41;
    guint32  VAR_42;
    guint32  VAR_43;
    guint32  VAR_44;
    gboolean VAR_45;
    gchar   VAR_46[VAR_47];
    gchar   *VAR_48;      /* COMMENT_3 */
    gchar   *VAR_49;             /* COMMENT_4 */
    gchar   *VAR_50;          /* COMMENT_5 */
    gchar   *VAR_51;            /* COMMENT_5 */
    gchar   *VAR_52 = NULL;  /* COMMENT_6 */
    GDir    *VAR_53;
    FILE    *VAR_54 = NULL;       /* COMMENT_7 */
    const gchar *VAR_55;    /* COMMENT_8 */

    /* COMMENT_9 */
    VAR_48 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_47);
    VAR_48[0] = '\0';
    VAR_49 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
    VAR_49[0] = '\0';
    VAR_50 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
    VAR_50[0] = '\0';
    VAR_51 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
    VAR_51[0] = '\0';

    /* COMMENT_10 */
    VAR_40 = wmem_new0(wmem_file_scope(), ioDataObject);
    VAR_40->profisafeSupported = FALSE;
    VAR_40->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");
    VAR_36 = FALSE;
    VAR_37 = FALSE;
    VAR_45 = FALSE;


    if (VAR_6 != 1 || VAR_7 != 0) {
        expert_add_info_format(VAR_2, VAR_4, &VAR_57,
            ""Block version %u.%u not implemented yet!"", VAR_6, VAR_7);
        return VAR_1;
    }

    VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5,
                        VAR_58, &VAR_8);

    proto_item_append_text(VAR_4, "": APIs:%u"", VAR_8);


    /* COMMENT_11 */
    VAR_38 = find_conversation(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
    if (VAR_38 == NULL) {
        VAR_38 = conversation_new(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
    }

    VAR_39 = (stationInfo*)conversation_get_proto_data(VAR_38, VAR_60);
    if (VAR_39 != NULL) {
        VAR_39->gsdFound = FALSE;
        VAR_39->gsdPathLength = FALSE;

        /* COMMENT_12 */
        VAR_34 = VAR_39->u16Vendor_id;
        VAR_35 = VAR_39->u16Device_id;

        /* COMMENT_13 */
        if(VAR_61[0] != '\0') {   /* COMMENT_14 */
            VAR_39->gsdPathLength = TRUE;

            if ((VAR_53 = g_dir_open(VAR_61, 0, NULL)) != NULL) {
                /* COMMENT_15 */
                while ((VAR_55 = g_dir_read_name(VAR_53)) != NULL) {

                    /* COMMENT_16 */
                    VAR_52 = wmem_strdup_printf(wmem_packet_scope(), ""%s"" VAR_62 ""%s"", VAR_61, VAR_55);

                    /* COMMENT_17 */
                    VAR_54 = ws_fopen(VAR_52, ""r"");

                    if(VAR_54 != NULL) {
                        /* COMMENT_18 */
                        while(fgets(VAR_50, VAR_56, VAR_54) != NULL) {
                            /* COMMENT_19 */
                            if((strstr(VAR_50, VAR_25)) != NULL) {
                                memset (VAR_48, 0, sizeof(*VAR_48));
                                VAR_49 = strstr(VAR_50, VAR_25);
                                if (VAR_49!= NULL && sscanf(VAR_49, ""VendorID=\""%199[^\""]"", VAR_48) == 1) {
                                    VAR_41 = (guint32) strtoul (VAR_48, NULL, 0);

                                    if(VAR_41 == VAR_34) {
                                        VAR_36 = TRUE;        /* COMMENT_20 */
                                    }
                                }
                            }

                            /* COMMENT_21 */
                            if((strstr(VAR_50, VAR_26)) != NULL) {
                                memset(VAR_48, 0, sizeof(*VAR_48));
                                VAR_49 = strstr(VAR_50, VAR_26);
                                if (VAR_49 != NULL && sscanf(VAR_49, ""DeviceID=\""%199[^\""]"", VAR_48) == 1) {
                                    VAR_42 = (guint32)strtoul(VAR_48, NULL, 0);

                                    if(VAR_42 == VAR_35) {
                                        VAR_37 = TRUE;        /* COMMENT_22 */
                                    }
                                }
                            }
                        }

                        fclose(VAR_54);
                        VAR_54 = NULL;

                        if(VAR_36 && VAR_37) {
                            break;        /* COMMENT_23 */
                        }
                        else {
                            /* COMMENT_24 */
                            VAR_36 = FALSE;
                            VAR_37 = FALSE;
                            VAR_45 = FALSE;
                            VAR_52 = """";           /* COMMENT_25 */
                        }
                    }
                }

                g_dir_close(VAR_53);
            }

            /* COMMENT_26 */
            if(VAR_36 && VAR_37) {
                VAR_45 = TRUE;
                VAR_39->gsdFound = TRUE;
                VAR_39->gsdLocation = wmem_strdup(wmem_file_scope(), VAR_52);
            }
            else {
                /* COMMENT_27 */
                VAR_39->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" VAR_62 ""*.xml"", VAR_61);
            }
        }
        else {
            /* COMMENT_28 */
            VAR_39->gsdPathLength = FALSE;
        }
    }

    while (VAR_8--) {
        VAR_17 = proto_tree_add_item(VAR_3, VAR_63, VAR_0, VAR_1, 0, VAR_64);
        VAR_18 = proto_item_add_subtree(VAR_17, VAR_65);
        VAR_19 = VAR_1;

        /* COMMENT_29 */
        VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_66, &VAR_9);
        /* COMMENT_30 */
        VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_67, &VAR_10);
        /* COMMENT_31 */
        VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_68, &VAR_11);
        /* COMMENT_32 */
        VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_69, &VAR_12);
        /* COMMENT_33 */
        VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_70, &VAR_13);

        proto_item_append_text(VAR_17, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
            VAR_9, VAR_10, VAR_11, VAR_12, VAR_13);

        proto_item_append_text(VAR_4, "", Submodules:%u"", VAR_13);

        while (VAR_13--) {
            VAR_20 = proto_tree_add_item(VAR_18, VAR_71, VAR_0, VAR_1, 0, VAR_64);
            VAR_21 = proto_item_add_subtree(VAR_20, VAR_72);
            VAR_24 = VAR_1;

            /* COMMENT_34 */
            VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
                                VAR_73, &VAR_14);
            /* COMMENT_35 */
            VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
                            VAR_74, &VAR_15);
            /* COMMENT_36 */
            VAR_22 = proto_tree_add_item(VAR_21, VAR_75, VAR_0, VAR_1, 2, VAR_76);
            VAR_23 = proto_item_add_subtree(VAR_22, VAR_77);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_78, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_79, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_80, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_81, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_82, &VAR_16);
            VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_83, &VAR_16);

            VAR_40->slotNr = VAR_10;
            VAR_40->subSlotNr = VAR_14;
            VAR_40->moduleIdentNr = VAR_11;
            VAR_40->subModuleIdentNr = VAR_15;
            VAR_40->discardIOXS = VAR_16 & 0x0020;

            /* COMMENT_37 */
                                                                                                            
                                                                              
                                                                                                        
                                                                                                    
                                           
                                                                                                       
                                                                                                  
               

            VAR_40->amountInGSDML = 0;
            VAR_40->fParameterIndexNr = 0;
            VAR_40->profisafeSupported = FALSE;

            if (VAR_52 != NULL) {
                VAR_54 = ws_fopen(VAR_52, ""r"");
            }
            if(VAR_45 && VAR_54 != NULL) {
                fseek(VAR_54, 0, VAR_84);

                /* COMMENT_46 */
                while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                    if((strstr(VAR_51, VAR_30)) != NULL) {
                        memset (VAR_48, 0, sizeof(*VAR_48));

                        VAR_49 = strstr(VAR_51, VAR_31);
                        if (VAR_49 != NULL && sscanf(VAR_49, ""Index=\""%199[^\""]"", VAR_48) == 1) {
                            VAR_40->fParameterIndexNr = (guint32)strtoul(VAR_48, NULL, 0);
                        }
                        break;    /* COMMENT_47 */
                    }
                }

                memset (VAR_51, 0, sizeof(*VAR_51));
                fseek(VAR_54, 0, VAR_84);                /* COMMENT_48 */

                while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                    if((strstr(VAR_51, VAR_27)) != NULL) {                         /* COMMENT_49 */
                        memset (VAR_48, 0, sizeof(*VAR_48));
                        VAR_49 = strstr(VAR_51, VAR_27);                              /* COMMENT_50 */
                        if (VAR_49 != NULL && sscanf(VAR_49, ""ModuleIdentNumber=\""%199[^\""]"", VAR_48) == 1) {  /* COMMENT_51 */
                            VAR_43 = (guint32)strtoul(VAR_48, NULL, 0);     /* COMMENT_52 */

                            /* COMMENT_53 */
                            if (VAR_43 == VAR_40->moduleIdentNr) {
                                ++VAR_40->amountInGSDML;    /* COMMENT_54 */

                                while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                                    if((strstr(VAR_51, VAR_32)) != NULL) {                    /* COMMENT_55 */
                                        long VAR_85;

                                        if (sscanf(VAR_51, ""%*s TextId=\""%199[^\""]"", VAR_46) != 1)        /* COMMENT_56 */
                                            break;

                                        VAR_85 = ftell(VAR_54);            /* COMMENT_57 */
                                        /* COMMENT_58 */
                                        if (VAR_85 >= 0) {
                                            while (fgets(VAR_51, VAR_56, VAR_54) != NULL && VAR_40->amountInGSDML == 1) {
                                                /* COMMENT_59 */
                                                if(((strstr(VAR_51, VAR_46)) != NULL) && ((strstr(VAR_51, VAR_33)) != NULL)) {
                                                    VAR_49 = strstr(VAR_51, VAR_33);
                                                    if (sscanf(VAR_49, ""Value=\""%[^\""]"", VAR_40->moduleNameStr) == 1)
                                                        break;    /* COMMENT_60 */
                                                }
                                            }

                                            fseek(VAR_54, VAR_85, VAR_84);    /* COMMENT_61 */
                                        }
                                    }

                                    /* COMMENT_62 */
                                    if((strstr(VAR_51, VAR_28)) != NULL) {
                                        memset (VAR_48, 0, sizeof(*VAR_48));
                                        VAR_49 = strstr(VAR_51, VAR_28);
                                        if (VAR_49 != NULL && sscanf(VAR_49, ""SubmoduleIdentNumber=\""%199[^\""]"", VAR_48) == 1) {
                                            VAR_44 = (guint32) strtoul (VAR_48, NULL, 0);    /* COMMENT_63 */

                                            /* COMMENT_64 */
                                            if(VAR_44 == VAR_40->subModuleIdentNr) {
                                                if((strstr(VAR_51, VAR_29)) != NULL) {
                                                    VAR_40->profisafeSupported = TRUE;   /* COMMENT_65 */
                                                    break;
                                                }
                                                else {    /* COMMENT_66 */
                                                    while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                                                        if((strstr(VAR_51, VAR_29)) != NULL) {
                                                            VAR_40->profisafeSupported = TRUE;
                                                            break;    /* COMMENT_67 */
                                                        }

                                                        else if((strstr(VAR_51, "">"")) != NULL) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            break;    /* COMMENT_68 */
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                fclose(VAR_54);
                VAR_54 = NULL;
            }

            switch (VAR_16 & 0x03) {
            case(0x00): /* COMMENT_69 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            case(0x01): /* COMMENT_70 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            case(0x02): /* COMMENT_71 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            case(0x03): /* COMMENT_72 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            }

            proto_item_append_text(VAR_20, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
                VAR_14, VAR_15, VAR_16);
            proto_item_set_len(VAR_20, VAR_1 - VAR_24);
        }

        proto_item_set_len(VAR_17, VAR_1 - VAR_19);
    }

    return VAR_1;
}",wireshark/2096bc1e5078732543e0a3ee115a2ce520a72bbc/packet-dcerpc-pn-io.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -122,7 +122,7 @@
                             if((strstr(puffer, vendorIdStr)) != NULL) {
                                 memset (convertStr, 0, sizeof(*convertStr));
                                 pch = strstr(puffer, vendorIdStr);
-                                if (sscanf(pch, ""VendorID=\""%[^\""]"", convertStr) == 1) {
+                                if (pch!= NULL && sscanf(pch, ""VendorID=\""%199[^\""]"", convertStr) == 1) {
                                     read_vendor_id = (guint32) strtoul (convertStr, NULL, 0);
 
                                     if(read_vendor_id == searchVendorID) {
@@ -135,7 +135,7 @@
                             if((strstr(puffer, deviceIdStr)) != NULL) {
                                 memset(convertStr, 0, sizeof(*convertStr));
                                 pch = strstr(puffer, deviceIdStr);
-                                if (sscanf(pch, ""DeviceID=\""%[^\""]"", convertStr) == 1) {
+                                if (pch != NULL && sscanf(pch, ""DeviceID=\""%199[^\""]"", convertStr) == 1) {
                                     read_device_id = (guint32)strtoul(convertStr, NULL, 0);
 
                                     if(read_device_id == searchDeviceID) {
@@ -266,7 +266,7 @@
                         memset (convertStr, 0, sizeof(*convertStr));
 
                         pch = strstr(temp, fParameterIndexStr);
-                        if (sscanf(pch, ""Index=\""%[^\""]"", convertStr) == 1) {
+                        if (pch != NULL && sscanf(pch, ""Index=\""%199[^\""]"", convertStr) == 1) {
                             io_data_object->fParameterIndexNr = (guint32)strtoul(convertStr, NULL, 0);
                         }
                         break;    /* found Indexnumber -> break search loop */
@@ -280,7 +280,7 @@
                     if((strstr(temp, moduleStr)) != NULL) {                         /* find the String ""ModuleIdentNumber="" */
                         memset (convertStr, 0, sizeof(*convertStr));
                         pch = strstr(temp, moduleStr);                              /* search for ""ModuleIdentNumber=\"""" within GSD-file */
-                        if (sscanf(pch, ""ModuleIdentNumber=\""%[^\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */
+                        if (pch != NULL && sscanf(pch, ""ModuleIdentNumber=\""%199[^\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */
                             read_module_id = (guint32)strtoul(convertStr, NULL, 0);     /* Change numeric string --> unsigned long; read_module_id contains the Value of the ModuleIdentNumber */
 
                             /* If the found ModuleID matches with the wanted ModuleID, search for the Submodule and break */
@@ -291,7 +291,7 @@
                                     if((strstr(temp, moduleNameInfo)) != NULL) {                    /* find the String ""<Name"" for the TextID */
                                         long filePosRecord;
 
-                                        if (sscanf(temp, ""%*s TextId=\""%[^\""]"", tmp_moduletext) != 1)        /* saves the correct TextId for the next searchloop */
+                                        if (sscanf(temp, ""%*s TextId=\""%199[^\""]"", tmp_moduletext) != 1)        /* saves the correct TextId for the next searchloop */
                                             break;
 
                                         filePosRecord = ftell(fp);            /* save the current position of the filepointer (Offset) */
@@ -314,7 +314,7 @@
                                     if((strstr(temp, subModuleStr)) != NULL) {
                                         memset (convertStr, 0, sizeof(*convertStr));
                                         pch = strstr(temp, subModuleStr);
-                                        if (sscanf(pch, ""SubmoduleIdentNumber=\""%[^\""]"", convertStr) == 1) {
+                                        if (pch != NULL && sscanf(pch, ""SubmoduleIdentNumber=\""%199[^\""]"", convertStr) == 1) {
                                             read_submodule_id = (guint32) strtoul (convertStr, NULL, 0);    /* read_submodule_id contains the Value of the SubModuleIdentNumber */
 
                                             /* Find ""PROFIsafeSupported"" flag of the module in GSD-file */","{'deleted_lines': ['                                if (sscanf(pch, ""VendorID=\\""%[^\\""]"", convertStr) == 1) {', '                                if (sscanf(pch, ""DeviceID=\\""%[^\\""]"", convertStr) == 1) {', '                        if (sscanf(pch, ""Index=\\""%[^\\""]"", convertStr) == 1) {', '                        if (sscanf(pch, ""ModuleIdentNumber=\\""%[^\\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */', '                                        if (sscanf(temp, ""%*s TextId=\\""%[^\\""]"", tmp_moduletext) != 1)        /* saves the correct TextId for the next searchloop */', '                                        if (sscanf(pch, ""SubmoduleIdentNumber=\\""%[^\\""]"", convertStr) == 1) {'], 'added_lines': ['                                if (pch!= NULL && sscanf(pch, ""VendorID=\\""%199[^\\""]"", convertStr) == 1) {', '                                if (pch != NULL && sscanf(pch, ""DeviceID=\\""%199[^\\""]"", convertStr) == 1) {', '                        if (pch != NULL && sscanf(pch, ""Index=\\""%199[^\\""]"", convertStr) == 1) {', '                        if (pch != NULL && sscanf(pch, ""ModuleIdentNumber=\\""%199[^\\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */', '                                        if (sscanf(temp, ""%*s TextId=\\""%199[^\\""]"", tmp_moduletext) != 1)        /* saves the correct TextId for the next searchloop */', '                                        if (pch != NULL && sscanf(pch, ""SubmoduleIdentNumber=\\""%199[^\\""]"", convertStr) == 1) {']}",True,"In Wireshark 2.4.0 and 2.2.0 to 2.2.8, the Profinet I/O dissector could crash with an out-of-bounds write. This was addressed in plugins/profinet/packet-dcerpc-pn-io.c by adding string validation.",7.5,HIGH,2,test,2017-08-23T01:52:29Z,2
CVE-2017-13766,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"Fix potential oob write crashes

# Conflicts:
#	extcap/androiddump.c
#	plugins/profinet/packet-dcerpc-pn-io.c

Bug: 13847
Change-Id: I3a706db25204fe4c1fd1b7be3b17b8c55365dccf
Reviewed-on: https://code.wireshark.org/review/23169
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit 5574b78dae2f607d4ace66ab60d516d0c569357d)
Reviewed-on: https://code.wireshark.org/review/23170
Reviewed-on: https://code.wireshark.org/review/23171
Reviewed-by: Anders Broman <a.broman58@gmail.com>",2096bc1e5078732543e0a3ee115a2ce520a72bbc,https://github.com/wireshark/wireshark/commit/2096bc1e5078732543e0a3ee115a2ce520a72bbc,extcap/androiddump.c,register_interfaces,"static int register_interfaces(extcap_parameters * extcap_conf, const char *adb_server_ip, unsigned short *adb_server_tcp_port) {
static char            packet[PACKET_LENGTH];
static char            helpful_packet[PACKET_LENGTH];
char                  *response;
char                  *device_list;
gssize                 data_length;
gssize                 device_length;
socket_handle_t        sock;
const char            *adb_transport_serial_templace = ""%04x""""host:transport:%s"";
const char            *adb_check_port_templace       = ""%04x""""shell:cat /proc/%s/net/tcp"";
const char            *adb_devices            = ""000E""""host:devices-l"";
const char            *adb_api_level          = ""0022""""shell:getprop ro.build.version.sdk"";
const char            *adb_hcidump_version    = ""0017""""shell:hcidump --version"";
const char            *adb_ps_droid_bluetooth = ""0018""""shell:ps droid.bluetooth"";
const char            *adb_ps_bluetooth_app   = ""001E""""shell:ps com.android.bluetooth"";
const char            *adb_tcpdump_help       = ""0010""""shell:tcpdump -h"";
char                   serial_number[SERIAL_NUMBER_LENGTH_MAX];
size_t                 serial_number_length;
char                   model_name[MODEL_NAME_LENGTH_MAX];
int                    result;
char                  *pos;
char                  *i_pos;
char                  *model_pos;
char                  *device_pos;
char                  *prev_pos;
int                    api_level;
int                    disable_interface;
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET)
return EXIT_CODE_INVALID_SOCKET_INTERFACES_LIST;
device_list = adb_send_and_receive(sock, adb_devices, packet, sizeof(packet), &device_length);
closesocket(sock);
if (!device_list) {
errmsg_print(""ERROR: Cannot get list of interfaces from devices"");
return EXIT_CODE_CANNOT_GET_INTERFACES_LIST;
}
device_list[device_length] = '\0';
pos = (char *) device_list;
while (pos < (char *) (device_list + device_length)) {
prev_pos = pos;
pos = strchr(pos, ' ');
i_pos = pos;
result = (int) (pos - prev_pos);
pos = strchr(pos, '\n') + 1;
if (result >= (int) sizeof(serial_number)) {
verbose_print(""WARNING: Serial number too long, ignore device\n"");
continue;
}
memcpy(serial_number, prev_pos, result);
serial_number[result] = '\0';
serial_number_length = strlen(serial_number);
model_name[0] = '\0';
model_pos = g_strstr_len(i_pos, pos - i_pos, ""model:"");
if (model_pos) {
device_pos = g_strstr_len(i_pos, pos - i_pos, ""device:"");
if (device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX) {
memcpy(model_name, model_pos + 6, device_pos - model_pos - 6 - 1);
model_name[device_pos - model_pos - 6 - 1] = '\0';
}
}
if (model_name[0] == '\0')
strcpy(model_name, ""unknown"");
verbose_print(""VERBOSE: Processing device: \""%s\"" <%s>\n"" , serial_number, model_name);
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET) continue;
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet for transport"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_1;
}
result = adb_send(sock, helpful_packet);
if (result) {
verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", helpful_packet);
closesocket(sock);
} else {
response = adb_send_and_read(sock, adb_tcpdump_help, helpful_packet, sizeof(helpful_packet), &data_length);
closesocket(sock);
if (response) {
response[data_length] = '\0';
if (strstr(response,""tcpdump version"")) {
new_interface(extcap_conf, INTERFACE_ANDROID_WIFI_TCPDUMP, model_name, serial_number, ""Android WiFi"");
}
} else {
verbose_print(""WARNING: Error on socket: <%s>\n"", helpful_packet);
}
}
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET) continue;
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_2;
}
result = adb_send(sock, helpful_packet);
if (result) {
verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", helpful_packet);
closesocket(sock);
continue;
}
response = adb_send_and_read(sock, adb_api_level, helpful_packet, sizeof(helpful_packet), &data_length);
closesocket(sock);
if (!response) {
verbose_print(""WARNING: Error on socket: <%s>\n"", helpful_packet);
continue;
}
response[data_length] = '\0';
api_level = (int) g_ascii_strtoll(response, NULL, 10);
verbose_print(""VERBOSE: Android API Level for %s is %i\n"", serial_number, api_level);
if (api_level < 21) {
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_MAIN,   model_name, serial_number, ""Android Logcat Main"");
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_SYSTEM, model_name, serial_number, ""Android Logcat System"");
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_RADIO,  model_name, serial_number, ""Android Logcat Radio"");
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_EVENTS, model_name, serial_number, ""Android Logcat Events"");
} else {
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_MAIN,   model_name, serial_number, ""Android Logcat Main"");
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_SYSTEM, model_name, serial_number, ""Android Logcat System"");
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_RADIO,  model_name, serial_number, ""Android Logcat Radio"");
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_EVENTS, model_name, serial_number, ""Android Logcat Events"");
new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_CRASH,  model_name, serial_number, ""Android Logcat Crash"");
}
if (api_level >= 5 && api_level < 17) {
disable_interface = 0;
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET) continue;
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_3;
}
result = adb_send(sock, helpful_packet);
if (result) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
closesocket(sock);
return EXIT_CODE_GENERIC;
}
response = adb_send_and_read(sock, adb_hcidump_version, helpful_packet, sizeof(helpful_packet), &data_length);
closesocket(sock);
if (!response || data_length < 1) {
verbose_print(""WARNING: Error while getting hcidump version by <%s> (%p len=%""G_GSSIZE_FORMAT"")\n"",
adb_hcidump_version, (void*)response, data_length);
verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", serial_number);
disable_interface = 1;
} else {
response[data_length] = '\0';
if (g_ascii_strtoull(response, NULL, 10) == 0) {
verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", serial_number);
disable_interface = 1;
} else {
verbose_print(""VERBOSE: Android hcidump version for %s is %s\n"", serial_number, response);
}
}
if (!disable_interface) {
new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_HCIDUMP, model_name, serial_number, ""Android Bluetooth Hcidump"");
}
}
if (api_level >= 17 && api_level < 21) {
disable_interface = 0;
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET) continue;
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_4;
}
result = adb_send(sock, helpful_packet);
if (result) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
closesocket(sock);
return EXIT_CODE_GENERIC;
}
response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length);
closesocket(sock);
if (!response || data_length < 1) {
verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
""(%p len=%""G_GSSIZE_FORMAT"")\n"", adb_hcidump_version, (void*)response, data_length);
verbose_print( ""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
disable_interface = 1;
} else {
char  *data_str;
char   pid[16];
memset(pid, 0, sizeof(pid));
response[data_length] = '\0';
data_str = strchr(response, '\n');
if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) {
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid);
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET)
return EXIT_CODE_INVALID_SOCKET_1;
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_5;
}
result = adb_send(sock, helpful_packet);
if (result) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
closesocket(sock);
return EXIT_CODE_GENERIC;
}
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_6;
}
response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length);
closesocket(sock);
if (!response) {
disable_interface = 1;
} else {
response[data_length] = '\0';
data_str = strchr(response, '\n');
if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""10EA"") == 0) {
verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is %s\n"", serial_number, pid + 9);
} else {
disable_interface = 1;
verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is unknown\n"", serial_number);
}
}
} else {
disable_interface = 1;
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
}
}
if (!disable_interface) {
new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER, model_name, serial_number, ""Android Bluetooth External Parser"");
}
}
if (api_level >= 21) {
disable_interface = 0;
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET) continue;
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_7;
}
result = adb_send(sock, helpful_packet);
if (result) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
closesocket(sock);
return EXIT_CODE_GENERIC;
}
if (api_level >= 23) {
response = adb_send_and_read(sock, adb_ps_bluetooth_app, helpful_packet, sizeof(helpful_packet), &data_length);
}  else
response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length);
closesocket(sock);
if (!response || data_length < 1) {
verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
""(%p len=%""G_GSSIZE_FORMAT"")\n"", adb_hcidump_version, (void*)response, data_length);
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
disable_interface = 1;
} else {
char  *data_str;
char   pid[16];
memset(pid, 0, sizeof(pid));
response[data_length] = '\0';
data_str = strchr(response, '\n');
if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) {
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid);
sock = adb_connect(adb_server_ip, adb_server_tcp_port);
if (sock == INVALID_SOCKET)
return EXIT_CODE_INVALID_SOCKET_2;
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_8;
}
result = adb_send(sock, helpful_packet);
if (result) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
closesocket(sock);
return EXIT_CODE_GENERIC;
}
result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid);
if (result <= 0 || result > PACKET_LENGTH) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(sock);
return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_9;
}
response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length);
closesocket(sock);
if (!response) {
disable_interface = 1;
} else {
response[data_length] = '\0';
data_str = strchr(response, '\n');
if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""22A8"") == 0) {
verbose_print(""VERBOSE: Btsnoop Net Port for %s is %s\n"", serial_number, pid + 9);
} else {
disable_interface = 1;
verbose_print(""VERBOSE: Btsnoop Net Port for %s is unknown\n"", serial_number);
}
}
} else {
disable_interface = 1;
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
}
}
if (!disable_interface) {
new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET, model_name, serial_number, ""Android Bluetooth Btsnoop Net"");
}
}
}
return EXIT_CODE_SUCCESS;
}","static int register_interfaces(extcap_parameters * VAR_0, const char *VAR_1, unsigned short *VAR_2) {
static char            VAR_3[VAR_4];
static char            VAR_5[VAR_4];
char                  *VAR_6;
char                  *VAR_7;
gssize                 VAR_8;
gssize                 VAR_9;
socket_handle_t        VAR_10;
const char            *VAR_11 = ""%04x""""host:transport:%s"";
const char            *VAR_12       = ""%04x""""shell:cat /proc/%s/net/tcp"";
const char            *VAR_13            = ""000E""""host:devices-l"";
const char            *VAR_14          = ""0022""""shell:getprop ro.build.version.sdk"";
const char            *VAR_15    = ""0017""""shell:hcidump --version"";
const char            *VAR_16 = ""0018""""shell:ps droid.bluetooth"";
const char            *VAR_17   = ""001E""""shell:ps com.android.bluetooth"";
const char            *VAR_18       = ""0010""""shell:tcpdump -h"";
char                   VAR_19[VAR_20];
size_t                 VAR_21;
char                   VAR_22[VAR_23];
int                    VAR_24;
char                  *VAR_25;
char                  *VAR_26;
char                  *VAR_27;
char                  *VAR_28;
char                  *VAR_29;
int                    VAR_30;
int                    VAR_31;
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32)
return VAR_33;
VAR_7 = adb_send_and_receive(VAR_10, VAR_13, VAR_3, sizeof(VAR_3), &VAR_9);
closesocket(VAR_10);
if (!VAR_7) {
errmsg_print(""ERROR: Cannot get list of interfaces from devices"");
return VAR_34;
}
VAR_7[VAR_9] = '\0';
VAR_25 = (char *) VAR_7;
while (VAR_25 < (char *) (VAR_7 + VAR_9)) {
VAR_29 = VAR_25;
VAR_25 = strchr(VAR_25, ' ');
VAR_26 = VAR_25;
VAR_24 = (int) (VAR_25 - VAR_29);
VAR_25 = strchr(VAR_25, '\n') + 1;
if (VAR_24 >= (int) sizeof(VAR_19)) {
verbose_print(""WARNING: Serial number too long, ignore device\n"");
continue;
}
memcpy(VAR_19, VAR_29, VAR_24);
VAR_19[VAR_24] = '\0';
VAR_21 = strlen(VAR_19);
VAR_22[0] = '\0';
VAR_27 = g_strstr_len(VAR_26, VAR_25 - VAR_26, ""model:"");
if (VAR_27) {
VAR_28 = g_strstr_len(VAR_26, VAR_25 - VAR_26, ""device:"");
if (VAR_28 && VAR_28 - VAR_27 - 6 - 1 < VAR_23) {
memcpy(VAR_22, VAR_27 + 6, VAR_28 - VAR_27 - 6 - 1);
VAR_22[VAR_28 - VAR_27 - 6 - 1] = '\0';
}
}
if (VAR_22[0] == '\0')
strcpy(VAR_22, ""unknown"");
verbose_print(""VERBOSE: Processing device: \""%s\"" <%s>\n"" , VAR_19, VAR_22);
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32) continue;
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet for transport"");
closesocket(VAR_10);
return VAR_35;
}
VAR_24 = adb_send(VAR_10, VAR_5);
if (VAR_24) {
verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", VAR_5);
closesocket(VAR_10);
} else {
VAR_6 = adb_send_and_read(VAR_10, VAR_18, VAR_5, sizeof(VAR_5), &VAR_8);
closesocket(VAR_10);
if (VAR_6) {
VAR_6[VAR_8] = '\0';
if (strstr(VAR_6,""tcpdump version"")) {
new_interface(VAR_0, VAR_36, VAR_22, VAR_19, ""Android WiFi"");
}
} else {
verbose_print(""WARNING: Error on socket: <%s>\n"", VAR_5);
}
}
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32) continue;
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_37;
}
VAR_24 = adb_send(VAR_10, VAR_5);
if (VAR_24) {
verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", VAR_5);
closesocket(VAR_10);
continue;
}
VAR_6 = adb_send_and_read(VAR_10, VAR_14, VAR_5, sizeof(VAR_5), &VAR_8);
closesocket(VAR_10);
if (!VAR_6) {
verbose_print(""WARNING: Error on socket: <%s>\n"", VAR_5);
continue;
}
VAR_6[VAR_8] = '\0';
VAR_30 = (int) g_ascii_strtoll(VAR_6, NULL, 10);
verbose_print(""VERBOSE: Android API Level for %s is %i\n"", VAR_19, VAR_30);
if (VAR_30 < 21) {
new_interface(VAR_0, VAR_38,   VAR_22, VAR_19, ""Android Logcat Main"");
new_interface(VAR_0, VAR_39, VAR_22, VAR_19, ""Android Logcat System"");
new_interface(VAR_0, VAR_40,  VAR_22, VAR_19, ""Android Logcat Radio"");
new_interface(VAR_0, VAR_41, VAR_22, VAR_19, ""Android Logcat Events"");
} else {
new_interface(VAR_0, VAR_42,   VAR_22, VAR_19, ""Android Logcat Main"");
new_interface(VAR_0, VAR_43, VAR_22, VAR_19, ""Android Logcat System"");
new_interface(VAR_0, VAR_44,  VAR_22, VAR_19, ""Android Logcat Radio"");
new_interface(VAR_0, VAR_45, VAR_22, VAR_19, ""Android Logcat Events"");
new_interface(VAR_0, VAR_46,  VAR_22, VAR_19, ""Android Logcat Crash"");
}
if (VAR_30 >= 5 && VAR_30 < 17) {
VAR_31 = 0;
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32) continue;
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_47;
}
VAR_24 = adb_send(VAR_10, VAR_5);
if (VAR_24) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
closesocket(VAR_10);
return VAR_48;
}
VAR_6 = adb_send_and_read(VAR_10, VAR_15, VAR_5, sizeof(VAR_5), &VAR_8);
closesocket(VAR_10);
if (!VAR_6 || VAR_8 < 1) {
verbose_print(""WARNING: Error while getting hcidump version by <%s> (%p len=%""VAR_49"")\n"",
VAR_15, (void*)VAR_6, VAR_8);
verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", VAR_19);
VAR_31 = 1;
} else {
VAR_6[VAR_8] = '\0';
if (g_ascii_strtoull(VAR_6, NULL, 10) == 0) {
verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", VAR_19);
VAR_31 = 1;
} else {
verbose_print(""VERBOSE: Android hcidump version for %s is %s\n"", VAR_19, VAR_6);
}
}
if (!VAR_31) {
new_interface(VAR_0, VAR_50, VAR_22, VAR_19, ""Android Bluetooth Hcidump"");
}
}
if (VAR_30 >= 17 && VAR_30 < 21) {
VAR_31 = 0;
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32) continue;
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_51;
}
VAR_24 = adb_send(VAR_10, VAR_5);
if (VAR_24) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
closesocket(VAR_10);
return VAR_48;
}
VAR_6 = adb_send_and_read(VAR_10, VAR_16, VAR_5, sizeof(VAR_5), &VAR_8);
closesocket(VAR_10);
if (!VAR_6 || VAR_8 < 1) {
verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
""(%p len=%""VAR_49"")\n"", VAR_15, (void*)VAR_6, VAR_8);
verbose_print( ""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
VAR_31 = 1;
} else {
char  *VAR_52;
char   VAR_53[16];
memset(VAR_53, 0, sizeof(VAR_53));
VAR_6[VAR_8] = '\0';
VAR_52 = strchr(VAR_6, '\n');
if (VAR_52 && sscanf(VAR_52, ""%*s %s"", VAR_53) == 1) {
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", VAR_19, VAR_53);
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32)
return VAR_54;
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_55;
}
VAR_24 = adb_send(VAR_10, VAR_5);
if (VAR_24) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
closesocket(VAR_10);
return VAR_48;
}
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_12, strlen(VAR_12) - 6 + strlen(VAR_53), VAR_53);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_56;
}
VAR_6 = adb_send_and_read(VAR_10, VAR_5, VAR_5, sizeof(VAR_5), &VAR_8);
closesocket(VAR_10);
if (!VAR_6) {
VAR_31 = 1;
} else {
VAR_6[VAR_8] = '\0';
VAR_52 = strchr(VAR_6, '\n');
if (VAR_52 && sscanf(VAR_52, ""%*s %s"", VAR_53) == 1 && strcmp(VAR_53 + 9, ""10EA"") == 0) {
verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is %s\n"", VAR_19, VAR_53 + 9);
} else {
VAR_31 = 1;
verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is unknown\n"", VAR_19);
}
}
} else {
VAR_31 = 1;
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
}
}
if (!VAR_31) {
new_interface(VAR_0, VAR_57, VAR_22, VAR_19, ""Android Bluetooth External Parser"");
}
}
if (VAR_30 >= 21) {
VAR_31 = 0;
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32) continue;
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_58;
}
VAR_24 = adb_send(VAR_10, VAR_5);
if (VAR_24) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
closesocket(VAR_10);
return VAR_48;
}
if (VAR_30 >= 23) {
VAR_6 = adb_send_and_read(VAR_10, VAR_17, VAR_5, sizeof(VAR_5), &VAR_8);
}  else
VAR_6 = adb_send_and_read(VAR_10, VAR_16, VAR_5, sizeof(VAR_5), &VAR_8);
closesocket(VAR_10);
if (!VAR_6 || VAR_8 < 1) {
verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
""(%p len=%""VAR_49"")\n"", VAR_15, (void*)VAR_6, VAR_8);
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
VAR_31 = 1;
} else {
char  *VAR_52;
char   VAR_53[16];
memset(VAR_53, 0, sizeof(VAR_53));
VAR_6[VAR_8] = '\0';
VAR_52 = strchr(VAR_6, '\n');
if (VAR_52 && sscanf(VAR_52, ""%*s %s"", VAR_53) == 1) {
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", VAR_19, VAR_53);
VAR_10 = adb_connect(VAR_1, VAR_2);
if (VAR_10 == VAR_32)
return VAR_59;
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_60;
}
VAR_24 = adb_send(VAR_10, VAR_5);
if (VAR_24) {
errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
closesocket(VAR_10);
return VAR_48;
}
VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_12, strlen(VAR_12) - 6 + strlen(VAR_53), VAR_53);
if (VAR_24 <= 0 || VAR_24 > VAR_4) {
errmsg_print(""ERROR: Error while completing adb packet"");
closesocket(VAR_10);
return VAR_61;
}
VAR_6 = adb_send_and_read(VAR_10, VAR_5, VAR_5, sizeof(VAR_5), &VAR_8);
closesocket(VAR_10);
if (!VAR_6) {
VAR_31 = 1;
} else {
VAR_6[VAR_8] = '\0';
VAR_52 = strchr(VAR_6, '\n');
if (VAR_52 && sscanf(VAR_52, ""%*s %s"", VAR_53) == 1 && strcmp(VAR_53 + 9, ""22A8"") == 0) {
verbose_print(""VERBOSE: Btsnoop Net Port for %s is %s\n"", VAR_19, VAR_53 + 9);
} else {
VAR_31 = 1;
verbose_print(""VERBOSE: Btsnoop Net Port for %s is unknown\n"", VAR_19);
}
}
} else {
VAR_31 = 1;
verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
}
}
if (!VAR_31) {
new_interface(VAR_0, VAR_62, VAR_22, VAR_19, ""Android Bluetooth Btsnoop Net"");
}
}
}
return VAR_63;
}",wireshark/2096bc1e5078732543e0a3ee115a2ce520a72bbc/androiddump.c/vul/before/0.json,"static int register_interfaces(extcap_parameters * extcap_conf, const char *adb_server_ip, unsigned short *adb_server_tcp_port) {
    static char            packet[PACKET_LENGTH];
    static char            helpful_packet[PACKET_LENGTH];
    char                  *response;
    char                  *device_list;
    gssize                 data_length;
    gssize                 device_length;
    socket_handle_t        sock;
    const char            *adb_transport_serial_templace = ""%04x""""host:transport:%s"";
    const char            *adb_check_port_templace       = ""%04x""""shell:cat /proc/%s/net/tcp"";
    const char            *adb_devices            = ""000E""""host:devices-l"";
    const char            *adb_api_level          = ""0022""""shell:getprop ro.build.version.sdk"";
    const char            *adb_hcidump_version    = ""0017""""shell:hcidump --version"";
    const char            *adb_ps_droid_bluetooth = ""0018""""shell:ps droid.bluetooth"";
    const char            *adb_ps_bluetooth_app   = ""001E""""shell:ps com.android.bluetooth"";
    const char            *adb_tcpdump_help       = ""0010""""shell:tcpdump -h"";
    char                   serial_number[SERIAL_NUMBER_LENGTH_MAX];
    size_t                 serial_number_length;
    char                   model_name[MODEL_NAME_LENGTH_MAX];
    int                    result;
    char                  *pos;
    char                  *i_pos;
    char                  *model_pos;
    char                  *device_pos;
    char                  *prev_pos;
    int                    api_level;
    int                    disable_interface;

/* NOTE: It seems that ""adb devices"" and ""adb shell"" closed connection
         so cannot send next command after them, there is need to reconnect */

    sock = adb_connect(adb_server_ip, adb_server_tcp_port);
    if (sock == INVALID_SOCKET)
        return EXIT_CODE_INVALID_SOCKET_INTERFACES_LIST;

    device_list = adb_send_and_receive(sock, adb_devices, packet, sizeof(packet), &device_length);
    closesocket(sock);

    if (!device_list) {
        errmsg_print(""ERROR: Cannot get list of interfaces from devices"");

        return EXIT_CODE_CANNOT_GET_INTERFACES_LIST;
    }

    device_list[device_length] = '\0';
    pos = (char *) device_list;

    while (pos < (char *) (device_list + device_length)) {
        prev_pos = pos;
        pos = strchr(pos, ' ');
        i_pos = pos;
        result = (int) (pos - prev_pos);
        pos = strchr(pos, '\n') + 1;
        if (result >= (int) sizeof(serial_number)) {
            verbose_print(""WARNING: Serial number too long, ignore device\n"");
            continue;
        }
        memcpy(serial_number, prev_pos, result);
        serial_number[result] = '\0';
        serial_number_length = strlen(serial_number);

        model_name[0] = '\0';
        model_pos = g_strstr_len(i_pos, pos - i_pos, ""model:"");
        if (model_pos) {
            device_pos = g_strstr_len(i_pos, pos - i_pos, ""device:"");
            if (device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX) {
                memcpy(model_name, model_pos + 6, device_pos - model_pos - 6 - 1);
                model_name[device_pos - model_pos - 6 - 1] = '\0';
            }
        }

        if (model_name[0] == '\0')
            strcpy(model_name, ""unknown"");

        verbose_print(""VERBOSE: Processing device: \""%s\"" <%s>\n"" , serial_number, model_name);

        /* Check for the presence of tcpdump in the android device. */

        sock = adb_connect(adb_server_ip, adb_server_tcp_port);
        if (sock == INVALID_SOCKET) continue;

        result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
        if (result <= 0 || result > PACKET_LENGTH) {
            errmsg_print(""ERROR: Error while completing adb packet for transport"");
            closesocket(sock);
            return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_1;
        }

        result = adb_send(sock, helpful_packet);
        if (result) {
            verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", helpful_packet);
            closesocket(sock);
        } else {
            response = adb_send_and_read(sock, adb_tcpdump_help, helpful_packet, sizeof(helpful_packet), &data_length);
            closesocket(sock);

            if (response) {
                response[data_length] = '\0';

                /* If tcpdump is found in the android device, add Android Wifi Tcpdump as an interface  */
                if (strstr(response,""tcpdump version"")) {
                    new_interface(extcap_conf, INTERFACE_ANDROID_WIFI_TCPDUMP, model_name, serial_number, ""Android WiFi"");
                }
            } else {
                verbose_print(""WARNING: Error on socket: <%s>\n"", helpful_packet);
            }
        }

        sock = adb_connect(adb_server_ip, adb_server_tcp_port);
        if (sock == INVALID_SOCKET) continue;

        result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
        if (result <= 0 || result > PACKET_LENGTH) {
            errmsg_print(""ERROR: Error while completing adb packet"");
            closesocket(sock);
            return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_2;
        }

        result = adb_send(sock, helpful_packet);
        if (result) {
            verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", helpful_packet);
            closesocket(sock);
            continue;
        }

        response = adb_send_and_read(sock, adb_api_level, helpful_packet, sizeof(helpful_packet), &data_length);
        closesocket(sock);

        if (!response) {
            verbose_print(""WARNING: Error on socket: <%s>\n"", helpful_packet);
            continue;
        }

        response[data_length] = '\0';
        api_level = (int) g_ascii_strtoll(response, NULL, 10);
        verbose_print(""VERBOSE: Android API Level for %s is %i\n"", serial_number, api_level);

        if (api_level < 21) {
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_MAIN,   model_name, serial_number, ""Android Logcat Main"");
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_SYSTEM, model_name, serial_number, ""Android Logcat System"");
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_RADIO,  model_name, serial_number, ""Android Logcat Radio"");
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_EVENTS, model_name, serial_number, ""Android Logcat Events"");
        } else {
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_MAIN,   model_name, serial_number, ""Android Logcat Main"");
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_SYSTEM, model_name, serial_number, ""Android Logcat System"");
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_RADIO,  model_name, serial_number, ""Android Logcat Radio"");
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_EVENTS, model_name, serial_number, ""Android Logcat Events"");
            new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_CRASH,  model_name, serial_number, ""Android Logcat Crash"");
        }

        if (api_level >= 5 && api_level < 17) {
            disable_interface = 0;

            sock = adb_connect(adb_server_ip, adb_server_tcp_port);
            if (sock == INVALID_SOCKET) continue;

            result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
            if (result <= 0 || result > PACKET_LENGTH) {
                errmsg_print(""ERROR: Error while completing adb packet"");
                closesocket(sock);
                return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_3;
            }

            result = adb_send(sock, helpful_packet);
            if (result) {
                errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
                closesocket(sock);
                return EXIT_CODE_GENERIC;
            }

            response = adb_send_and_read(sock, adb_hcidump_version, helpful_packet, sizeof(helpful_packet), &data_length);
            closesocket(sock);
            if (!response || data_length < 1) {
                verbose_print(""WARNING: Error while getting hcidump version by <%s> (%p len=%""G_GSSIZE_FORMAT"")\n"",
                    adb_hcidump_version, (void*)response, data_length);
                verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", serial_number);
                disable_interface = 1;
            } else {
                response[data_length] = '\0';

                if (g_ascii_strtoull(response, NULL, 10) == 0) {
                    verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", serial_number);
                    disable_interface = 1;
                } else {
                    verbose_print(""VERBOSE: Android hcidump version for %s is %s\n"", serial_number, response);
                }
            }

            if (!disable_interface) {
                new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_HCIDUMP, model_name, serial_number, ""Android Bluetooth Hcidump"");
            }
        }

        if (api_level >= 17 && api_level < 21) {
            disable_interface = 0;
            sock = adb_connect(adb_server_ip, adb_server_tcp_port);
            if (sock == INVALID_SOCKET) continue;

            result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
            if (result <= 0 || result > PACKET_LENGTH) {
                errmsg_print(""ERROR: Error while completing adb packet"");
                closesocket(sock);
                return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_4;
            }

            result = adb_send(sock, helpful_packet);
            if (result) {
                errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
                closesocket(sock);
                return EXIT_CODE_GENERIC;
            }

            response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length);
            closesocket(sock);
            if (!response || data_length < 1) {
                verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
                    ""(%p len=%""G_GSSIZE_FORMAT"")\n"", adb_hcidump_version, (void*)response, data_length);
                verbose_print( ""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
                disable_interface = 1;
            } else {
                char  *data_str;
                char   pid[16];

                memset(pid, 0, sizeof(pid));
                response[data_length] = '\0';

                data_str = strchr(response, '\n');
                if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1) {
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid);

                    sock = adb_connect(adb_server_ip, adb_server_tcp_port);
                    if (sock == INVALID_SOCKET)
                        return EXIT_CODE_INVALID_SOCKET_1;

                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
                    if (result <= 0 || result > PACKET_LENGTH) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(sock);
                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_5;
                    }

                    result = adb_send(sock, helpful_packet);
                    if (result) {
                        errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
                        closesocket(sock);
                        return EXIT_CODE_GENERIC;
                    }

                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid);
                    if (result <= 0 || result > PACKET_LENGTH) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(sock);
                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_6;
                    }

                    response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length);
                    closesocket(sock);

                    if (!response) {
                        disable_interface = 1;
                    } else {
                        response[data_length] = '\0';

                        data_str = strchr(response, '\n');
                        if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, ""10EA"") == 0) {
                            verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is %s\n"", serial_number, pid + 9);
                        } else {
                            disable_interface = 1;
                            verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is unknown\n"", serial_number);
                        }
                    }
                } else {
                    disable_interface = 1;
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
                }
            }

            if (!disable_interface) {
                new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER, model_name, serial_number, ""Android Bluetooth External Parser"");
            }
        }

        if (api_level >= 21) {
            disable_interface = 0;
            sock = adb_connect(adb_server_ip, adb_server_tcp_port);
            if (sock == INVALID_SOCKET) continue;

            result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
            if (result <= 0 || result > PACKET_LENGTH) {
                errmsg_print(""ERROR: Error while completing adb packet"");
                closesocket(sock);
                return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_7;
            }

            result = adb_send(sock, helpful_packet);
            if (result) {
                errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
                closesocket(sock);
                return EXIT_CODE_GENERIC;
            }

            if (api_level >= 23) {
                response = adb_send_and_read(sock, adb_ps_bluetooth_app, helpful_packet, sizeof(helpful_packet), &data_length);
            }  else
                response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length);
            closesocket(sock);
            if (!response || data_length < 1) {
                verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
                    ""(%p len=%""G_GSSIZE_FORMAT"")\n"", adb_hcidump_version, (void*)response, data_length);
                verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
                disable_interface = 1;
            } else {
                char  *data_str;
                char   pid[16];

                memset(pid, 0, sizeof(pid));
                response[data_length] = '\0';

                data_str = strchr(response, '\n');
                if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1) {
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid);

                    sock = adb_connect(adb_server_ip, adb_server_tcp_port);
                    if (sock == INVALID_SOCKET)
                        return EXIT_CODE_INVALID_SOCKET_2;

                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number);
                    if (result <= 0 || result > PACKET_LENGTH) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(sock);
                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_8;
                    }

                    result = adb_send(sock, helpful_packet);
                    if (result) {
                        errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet);
                        closesocket(sock);
                        return EXIT_CODE_GENERIC;
                    }

                    result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid);
                    if (result <= 0 || result > PACKET_LENGTH) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(sock);
                        return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_9;
                    }

                    response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length);
                    closesocket(sock);

                    if (!response) {
                        disable_interface = 1;
                    } else {
                        response[data_length] = '\0';

                        data_str = strchr(response, '\n');
                        if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, ""22A8"") == 0) {
                            verbose_print(""VERBOSE: Btsnoop Net Port for %s is %s\n"", serial_number, pid + 9);
                        } else {
                            disable_interface = 1;
                            verbose_print(""VERBOSE: Btsnoop Net Port for %s is unknown\n"", serial_number);
                        }
                    }
                } else {
                    disable_interface = 1;
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number);
                }
            }

            if (!disable_interface) {
                new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET, model_name, serial_number, ""Android Bluetooth Btsnoop Net"");
            }
        }
    }

    return EXIT_CODE_SUCCESS;
}","static int register_interfaces(extcap_parameters * VAR_0, const char *VAR_1, unsigned short *VAR_2) {
    static char            VAR_3[VAR_4];
    static char            VAR_5[VAR_4];
    char                  *VAR_6;
    char                  *VAR_7;
    gssize                 VAR_8;
    gssize                 VAR_9;
    socket_handle_t        VAR_10;
    const char            *VAR_11 = ""%04x""""host:transport:%s"";
    const char            *VAR_12       = ""%04x""""shell:cat /proc/%s/net/tcp"";
    const char            *VAR_13            = ""000E""""host:devices-l"";
    const char            *VAR_14          = ""0022""""shell:getprop ro.build.version.sdk"";
    const char            *VAR_15    = ""0017""""shell:hcidump --version"";
    const char            *VAR_16 = ""0018""""shell:ps droid.bluetooth"";
    const char            *VAR_17   = ""001E""""shell:ps com.android.bluetooth"";
    const char            *VAR_18       = ""0010""""shell:tcpdump -h"";
    char                   VAR_19[VAR_20];
    size_t                 VAR_21;
    char                   VAR_22[VAR_23];
    int                    VAR_24;
    char                  *VAR_25;
    char                  *VAR_26;
    char                  *VAR_27;
    char                  *VAR_28;
    char                  *VAR_29;
    int                    VAR_30;
    int                    VAR_31;

/* COMMENT_0 */
                                                                              

    VAR_10 = adb_connect(VAR_1, VAR_2);
    if (VAR_10 == VAR_32)
        return VAR_33;

    VAR_7 = adb_send_and_receive(VAR_10, VAR_13, VAR_3, sizeof(VAR_3), &VAR_9);
    closesocket(VAR_10);

    if (!VAR_7) {
        errmsg_print(""ERROR: Cannot get list of interfaces from devices"");

        return VAR_34;
    }

    VAR_7[VAR_9] = '\0';
    VAR_25 = (char *) VAR_7;

    while (VAR_25 < (char *) (VAR_7 + VAR_9)) {
        VAR_29 = VAR_25;
        VAR_25 = strchr(VAR_25, ' ');
        VAR_26 = VAR_25;
        VAR_24 = (int) (VAR_25 - VAR_29);
        VAR_25 = strchr(VAR_25, '\n') + 1;
        if (VAR_24 >= (int) sizeof(VAR_19)) {
            verbose_print(""WARNING: Serial number too long, ignore device\n"");
            continue;
        }
        memcpy(VAR_19, VAR_29, VAR_24);
        VAR_19[VAR_24] = '\0';
        VAR_21 = strlen(VAR_19);

        VAR_22[0] = '\0';
        VAR_27 = g_strstr_len(VAR_26, VAR_25 - VAR_26, ""model:"");
        if (VAR_27) {
            VAR_28 = g_strstr_len(VAR_26, VAR_25 - VAR_26, ""device:"");
            if (VAR_28 && VAR_28 - VAR_27 - 6 - 1 < VAR_23) {
                memcpy(VAR_22, VAR_27 + 6, VAR_28 - VAR_27 - 6 - 1);
                VAR_22[VAR_28 - VAR_27 - 6 - 1] = '\0';
            }
        }

        if (VAR_22[0] == '\0')
            strcpy(VAR_22, ""unknown"");

        verbose_print(""VERBOSE: Processing device: \""%s\"" <%s>\n"" , VAR_19, VAR_22);

        /* COMMENT_2 */

        VAR_10 = adb_connect(VAR_1, VAR_2);
        if (VAR_10 == VAR_32) continue;

        VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
        if (VAR_24 <= 0 || VAR_24 > VAR_4) {
            errmsg_print(""ERROR: Error while completing adb packet for transport"");
            closesocket(VAR_10);
            return VAR_35;
        }

        VAR_24 = adb_send(VAR_10, VAR_5);
        if (VAR_24) {
            verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", VAR_5);
            closesocket(VAR_10);
        } else {
            VAR_6 = adb_send_and_read(VAR_10, VAR_18, VAR_5, sizeof(VAR_5), &VAR_8);
            closesocket(VAR_10);

            if (VAR_6) {
                VAR_6[VAR_8] = '\0';

                /* COMMENT_3 */
                if (strstr(VAR_6,""tcpdump version"")) {
                    new_interface(VAR_0, VAR_36, VAR_22, VAR_19, ""Android WiFi"");
                }
            } else {
                verbose_print(""WARNING: Error on socket: <%s>\n"", VAR_5);
            }
        }

        VAR_10 = adb_connect(VAR_1, VAR_2);
        if (VAR_10 == VAR_32) continue;

        VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
        if (VAR_24 <= 0 || VAR_24 > VAR_4) {
            errmsg_print(""ERROR: Error while completing adb packet"");
            closesocket(VAR_10);
            return VAR_37;
        }

        VAR_24 = adb_send(VAR_10, VAR_5);
        if (VAR_24) {
            verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", VAR_5);
            closesocket(VAR_10);
            continue;
        }

        VAR_6 = adb_send_and_read(VAR_10, VAR_14, VAR_5, sizeof(VAR_5), &VAR_8);
        closesocket(VAR_10);

        if (!VAR_6) {
            verbose_print(""WARNING: Error on socket: <%s>\n"", VAR_5);
            continue;
        }

        VAR_6[VAR_8] = '\0';
        VAR_30 = (int) g_ascii_strtoll(VAR_6, NULL, 10);
        verbose_print(""VERBOSE: Android API Level for %s is %i\n"", VAR_19, VAR_30);

        if (VAR_30 < 21) {
            new_interface(VAR_0, VAR_38,   VAR_22, VAR_19, ""Android Logcat Main"");
            new_interface(VAR_0, VAR_39, VAR_22, VAR_19, ""Android Logcat System"");
            new_interface(VAR_0, VAR_40,  VAR_22, VAR_19, ""Android Logcat Radio"");
            new_interface(VAR_0, VAR_41, VAR_22, VAR_19, ""Android Logcat Events"");
        } else {
            new_interface(VAR_0, VAR_42,   VAR_22, VAR_19, ""Android Logcat Main"");
            new_interface(VAR_0, VAR_43, VAR_22, VAR_19, ""Android Logcat System"");
            new_interface(VAR_0, VAR_44,  VAR_22, VAR_19, ""Android Logcat Radio"");
            new_interface(VAR_0, VAR_45, VAR_22, VAR_19, ""Android Logcat Events"");
            new_interface(VAR_0, VAR_46,  VAR_22, VAR_19, ""Android Logcat Crash"");
        }

        if (VAR_30 >= 5 && VAR_30 < 17) {
            VAR_31 = 0;

            VAR_10 = adb_connect(VAR_1, VAR_2);
            if (VAR_10 == VAR_32) continue;

            VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
            if (VAR_24 <= 0 || VAR_24 > VAR_4) {
                errmsg_print(""ERROR: Error while completing adb packet"");
                closesocket(VAR_10);
                return VAR_47;
            }

            VAR_24 = adb_send(VAR_10, VAR_5);
            if (VAR_24) {
                errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
                closesocket(VAR_10);
                return VAR_48;
            }

            VAR_6 = adb_send_and_read(VAR_10, VAR_15, VAR_5, sizeof(VAR_5), &VAR_8);
            closesocket(VAR_10);
            if (!VAR_6 || VAR_8 < 1) {
                verbose_print(""WARNING: Error while getting hcidump version by <%s> (%p len=%""VAR_49"")\n"",
                    VAR_15, (void*)VAR_6, VAR_8);
                verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", VAR_19);
                VAR_31 = 1;
            } else {
                VAR_6[VAR_8] = '\0';

                if (g_ascii_strtoull(VAR_6, NULL, 10) == 0) {
                    verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", VAR_19);
                    VAR_31 = 1;
                } else {
                    verbose_print(""VERBOSE: Android hcidump version for %s is %s\n"", VAR_19, VAR_6);
                }
            }

            if (!VAR_31) {
                new_interface(VAR_0, VAR_50, VAR_22, VAR_19, ""Android Bluetooth Hcidump"");
            }
        }

        if (VAR_30 >= 17 && VAR_30 < 21) {
            VAR_31 = 0;
            VAR_10 = adb_connect(VAR_1, VAR_2);
            if (VAR_10 == VAR_32) continue;

            VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
            if (VAR_24 <= 0 || VAR_24 > VAR_4) {
                errmsg_print(""ERROR: Error while completing adb packet"");
                closesocket(VAR_10);
                return VAR_51;
            }

            VAR_24 = adb_send(VAR_10, VAR_5);
            if (VAR_24) {
                errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
                closesocket(VAR_10);
                return VAR_48;
            }

            VAR_6 = adb_send_and_read(VAR_10, VAR_16, VAR_5, sizeof(VAR_5), &VAR_8);
            closesocket(VAR_10);
            if (!VAR_6 || VAR_8 < 1) {
                verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
                    ""(%p len=%""VAR_49"")\n"", VAR_15, (void*)VAR_6, VAR_8);
                verbose_print( ""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
                VAR_31 = 1;
            } else {
                char  *VAR_52;
                char   VAR_53[16];

                memset(VAR_53, 0, sizeof(VAR_53));
                VAR_6[VAR_8] = '\0';

                VAR_52 = strchr(VAR_6, '\n');
                if (VAR_52 && sscanf(VAR_52, ""%*s %15s"", VAR_53) == 1) {
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", VAR_19, VAR_53);

                    VAR_10 = adb_connect(VAR_1, VAR_2);
                    if (VAR_10 == VAR_32)
                        return VAR_54;

                    VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
                    if (VAR_24 <= 0 || VAR_24 > VAR_4) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(VAR_10);
                        return VAR_55;
                    }

                    VAR_24 = adb_send(VAR_10, VAR_5);
                    if (VAR_24) {
                        errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
                        closesocket(VAR_10);
                        return VAR_48;
                    }

                    VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_12, strlen(VAR_12) - 6 + strlen(VAR_53), VAR_53);
                    if (VAR_24 <= 0 || VAR_24 > VAR_4) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(VAR_10);
                        return VAR_56;
                    }

                    VAR_6 = adb_send_and_read(VAR_10, VAR_5, VAR_5, sizeof(VAR_5), &VAR_8);
                    closesocket(VAR_10);

                    if (!VAR_6) {
                        VAR_31 = 1;
                    } else {
                        VAR_6[VAR_8] = '\0';

                        VAR_52 = strchr(VAR_6, '\n');
                        if (VAR_52 && sscanf(VAR_52, ""%*s %15s"", VAR_53) == 1 && strlen(VAR_53) > 10 && strcmp(VAR_53 + 9, ""10EA"") == 0) {
                            verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is %s\n"", VAR_19, VAR_53 + 9);
                        } else {
                            VAR_31 = 1;
                            verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is unknown\n"", VAR_19);
                        }
                    }
                } else {
                    VAR_31 = 1;
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
                }
            }

            if (!VAR_31) {
                new_interface(VAR_0, VAR_57, VAR_22, VAR_19, ""Android Bluetooth External Parser"");
            }
        }

        if (VAR_30 >= 21) {
            VAR_31 = 0;
            VAR_10 = adb_connect(VAR_1, VAR_2);
            if (VAR_10 == VAR_32) continue;

            VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
            if (VAR_24 <= 0 || VAR_24 > VAR_4) {
                errmsg_print(""ERROR: Error while completing adb packet"");
                closesocket(VAR_10);
                return VAR_58;
            }

            VAR_24 = adb_send(VAR_10, VAR_5);
            if (VAR_24) {
                errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
                closesocket(VAR_10);
                return VAR_48;
            }

            if (VAR_30 >= 23) {
                VAR_6 = adb_send_and_read(VAR_10, VAR_17, VAR_5, sizeof(VAR_5), &VAR_8);
            }  else
                VAR_6 = adb_send_and_read(VAR_10, VAR_16, VAR_5, sizeof(VAR_5), &VAR_8);
            closesocket(VAR_10);
            if (!VAR_6 || VAR_8 < 1) {
                verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> ""
                    ""(%p len=%""VAR_49"")\n"", VAR_15, (void*)VAR_6, VAR_8);
                verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
                VAR_31 = 1;
            } else {
                char  *VAR_52;
                char   VAR_53[16];

                memset(VAR_53, 0, sizeof(VAR_53));
                VAR_6[VAR_8] = '\0';

                VAR_52 = strchr(VAR_6, '\n');
                if (VAR_52 && sscanf(VAR_52, ""%*s %15s"", VAR_53) == 1) {
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", VAR_19, VAR_53);

                    VAR_10 = adb_connect(VAR_1, VAR_2);
                    if (VAR_10 == VAR_32)
                        return VAR_59;

                    VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_11, 15 + VAR_21, VAR_19);
                    if (VAR_24 <= 0 || VAR_24 > VAR_4) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(VAR_10);
                        return VAR_60;
                    }

                    VAR_24 = adb_send(VAR_10, VAR_5);
                    if (VAR_24) {
                        errmsg_print(""ERROR: Error while setting adb transport for <%s>"", VAR_5);
                        closesocket(VAR_10);
                        return VAR_48;
                    }

                    VAR_24 = g_snprintf((char *) VAR_5, VAR_4, VAR_12, strlen(VAR_12) - 6 + strlen(VAR_53), VAR_53);
                    if (VAR_24 <= 0 || VAR_24 > VAR_4) {
                        errmsg_print(""ERROR: Error while completing adb packet"");
                        closesocket(VAR_10);
                        return VAR_61;
                    }

                    VAR_6 = adb_send_and_read(VAR_10, VAR_5, VAR_5, sizeof(VAR_5), &VAR_8);
                    closesocket(VAR_10);

                    if (!VAR_6) {
                        VAR_31 = 1;
                    } else {
                        VAR_6[VAR_8] = '\0';

                        VAR_52 = strchr(VAR_6, '\n');
                        if (VAR_52 && sscanf(VAR_52, ""%*s %15s"", VAR_53) == 1 && strlen(VAR_53) > 10 && strcmp(VAR_53 + 9, ""22A8"") == 0) {
                            verbose_print(""VERBOSE: Btsnoop Net Port for %s is %s\n"", VAR_19, VAR_53 + 9);
                        } else {
                            VAR_31 = 1;
                            verbose_print(""VERBOSE: Btsnoop Net Port for %s is unknown\n"", VAR_19);
                        }
                    }
                } else {
                    VAR_31 = 1;
                    verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", VAR_19);
                }
            }

            if (!VAR_31) {
                new_interface(VAR_0, VAR_62, VAR_22, VAR_19, ""Android Bluetooth Btsnoop Net"");
            }
        }
    }

    return VAR_63;
}",wireshark/2096bc1e5078732543e0a3ee115a2ce520a72bbc/androiddump.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -225,7 +225,7 @@
                 response[data_length] = '\0';
 
                 data_str = strchr(response, '\n');
-                if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) {
+                if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1) {
                     verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid);
 
                     sock = adb_connect(adb_server_ip, adb_server_tcp_port);
@@ -262,7 +262,7 @@
                         response[data_length] = '\0';
 
                         data_str = strchr(response, '\n');
-                        if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""10EA"") == 0) {
+                        if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, ""10EA"") == 0) {
                             verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is %s\n"", serial_number, pid + 9);
                         } else {
                             disable_interface = 1;
@@ -317,7 +317,7 @@
                 response[data_length] = '\0';
 
                 data_str = strchr(response, '\n');
-                if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) {
+                if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1) {
                     verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid);
 
                     sock = adb_connect(adb_server_ip, adb_server_tcp_port);
@@ -354,7 +354,7 @@
                         response[data_length] = '\0';
 
                         data_str = strchr(response, '\n');
-                        if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""22A8"") == 0) {
+                        if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, ""22A8"") == 0) {
                             verbose_print(""VERBOSE: Btsnoop Net Port for %s is %s\n"", serial_number, pid + 9);
                         } else {
                             disable_interface = 1;","{'deleted_lines': ['                if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) {', '                        if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""10EA"") == 0) {', '                if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) {', '                        if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""22A8"") == 0) {'], 'added_lines': ['                if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1) {', '                        if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, ""10EA"") == 0) {', '                if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1) {', '                        if (data_str && sscanf(data_str, ""%*s %15s"", pid) == 1 && strlen(pid) > 10 && strcmp(pid + 9, ""22A8"") == 0) {']}",True,"In Wireshark 2.4.0 and 2.2.0 to 2.2.8, the Profinet I/O dissector could crash with an out-of-bounds write. This was addressed in plugins/profinet/packet-dcerpc-pn-io.c by adding string validation.",7.5,HIGH,2,test,2017-08-23T01:52:29Z,2
CVE-2017-7562,"['CWE-287', 'CWE-295']",AV:N/AC:L/Au:S/C:N/I:P/A:N,0.0,krb5,"Fix certauth built-in module returns

The PKINIT certauth eku module should never authoritatively authorize
a certificate, because an extended key usage does not establish a
relationship between the certificate and any specific user; it only
establishes that the certificate was created for PKINIT client
authentication.  Therefore, pkinit_eku_authorize() should return
KRB5_PLUGIN_NO_HANDLE on success, not 0.

The certauth san module should pass if it does not find any SANs of
the types it can match against; the presence of other types of SANs
should not cause it to explicitly deny a certificate.  Check for an
empty result from crypto_retrieve_cert_sans() in verify_client_san(),
instead of returning ENOENT from crypto_retrieve_cert_sans() when
there are no SANs at all.

ticket: 8561",50fe4074f188c2d4da0c421e96553acea8378db2,https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2,src/plugins/preauth/pkinit/pkinit_crypto_openssl.c,crypto_retrieve_X509_sans,"static krb5_error_code
crypto_retrieve_X509_sans(krb5_context context,
pkinit_plg_crypto_context plgctx,
pkinit_req_crypto_context reqctx,
X509 *cert,
krb5_principal **princs_ret,
krb5_principal **upn_ret,
unsigned char ***dns_ret)
{
krb5_error_code retval = EINVAL;
char buf[DN_BUF_LEN];
int p = 0, u = 0, d = 0, ret = 0, l;
krb5_principal *princs = NULL;
krb5_principal *upns = NULL;
unsigned char **dnss = NULL;
unsigned int i, num_found = 0, num_sans = 0;
X509_EXTENSION *ext = NULL;
GENERAL_NAMES *ialt = NULL;
GENERAL_NAME *gen = NULL;
if (princs_ret != NULL)
*princs_ret = NULL;
if (upn_ret != NULL)
*upn_ret = NULL;
if (dns_ret != NULL)
*dns_ret = NULL;
if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {
pkiDebug(""%s: nowhere to return any values!\n"", __FUNCTION__);
return retval;
}
if (cert == NULL) {
pkiDebug(""%s: no certificate!\n"", __FUNCTION__);
return retval;
}
X509_NAME_oneline(X509_get_subject_name(cert),
buf, sizeof(buf));
pkiDebug(""%s: looking for SANs in cert = %s\n"", __FUNCTION__, buf);
l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
if (l < 0)
return 0;
if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
retval = ENOENT;
goto cleanup;
}
num_sans = sk_GENERAL_NAME_num(ialt);
pkiDebug(""%s: found %d subject alt name extension(s)\n"", __FUNCTION__,
num_sans);
if (princs_ret != NULL) {
princs = calloc(num_sans + 1, sizeof(krb5_principal));
if (princs == NULL) {
retval = ENOMEM;
goto cleanup;
}
}
if (upn_ret != NULL) {
upns = calloc(num_sans + 1, sizeof(krb5_principal));
if (upns == NULL) {
retval = ENOMEM;
goto cleanup;
}
}
if (dns_ret != NULL) {
dnss = calloc(num_sans + 1, sizeof(*dnss));
if (dnss == NULL) {
retval = ENOMEM;
goto cleanup;
}
}
for (i = 0; i < num_sans; i++) {
krb5_data name = { 0, 0, NULL };
gen = sk_GENERAL_NAME_value(ialt, i);
switch (gen->type) {
case GEN_OTHERNAME:
name.length = gen->d.otherName->value->value.sequence->length;
name.data = (char *)gen->d.otherName->value->value.sequence->data;
if (princs != NULL &&
OBJ_cmp(plgctx->id_pkinit_san,
gen->d.otherName->type_id) == 0) {
#ifdef DEBUG_ASN1
print_buffer_bin((unsigned char *)name.data, name.length,
""/tmp/pkinit_san"");
#endif
ret = k5int_decode_krb5_principal_name(&name, &princs[p]);
if (ret) {
pkiDebug(""%s: failed decoding pkinit san value\n"",
__FUNCTION__);
} else {
p++;
num_found++;
}
} else if (upns != NULL &&
OBJ_cmp(plgctx->id_ms_san_upn,
gen->d.otherName->type_id) == 0) {
if (memchr(name.data, '\0', name.length))
break;
ret = krb5_parse_name_flags(context, name.data,
KRB5_PRINCIPAL_PARSE_ENTERPRISE,
&upns[u]);
if (ret) {
pkiDebug(""%s: failed parsing ms-upn san value\n"",
__FUNCTION__);
} else {
u++;
num_found++;
}
} else {
pkiDebug(""%s: unrecognized othername oid in SAN\n"",
__FUNCTION__);
continue;
}
break;
case GEN_DNS:
if (dnss != NULL) {
if (memchr(gen->d.dNSName->data, '\0', gen->d.dNSName->length))
break;
pkiDebug(""%s: found dns name = %s\n"", __FUNCTION__,
gen->d.dNSName->data);
dnss[d] = (unsigned char *)
strdup((char *)gen->d.dNSName->data);
if (dnss[d] == NULL) {
pkiDebug(""%s: failed to duplicate dns name\n"",
__FUNCTION__);
} else {
d++;
num_found++;
}
}
break;
default:
pkiDebug(""%s: SAN type = %d expecting %d\n"", __FUNCTION__,
gen->type, GEN_OTHERNAME);
}
}
sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
retval = 0;
if (princs)
*princs_ret = princs;
if (upns)
*upn_ret = upns;
if (dnss)
*dns_ret = dnss;
cleanup:
if (retval) {
if (princs != NULL) {
for (i = 0; princs[i] != NULL; i++)
krb5_free_principal(context, princs[i]);
free(princs);
}
if (upns != NULL) {
for (i = 0; upns[i] != NULL; i++)
krb5_free_principal(context, upns[i]);
free(upns);
}
if (dnss != NULL) {
for (i = 0; dnss[i] != NULL; i++)
free(dnss[i]);
free(dnss);
}
}
return retval;
}","static krb5_error_code
crypto_retrieve_X509_sans(krb5_context VAR_0,
pkinit_plg_crypto_context VAR_1,
pkinit_req_crypto_context VAR_2,
X509 *VAR_3,
krb5_principal **VAR_4,
krb5_principal **VAR_5,
unsigned char ***VAR_6)
{
krb5_error_code VAR_7 = VAR_8;
char VAR_9[VAR_10];
int VAR_11 = 0, VAR_12 = 0, VAR_13 = 0, VAR_14 = 0, VAR_15;
krb5_principal *VAR_16 = NULL;
krb5_principal *VAR_17 = NULL;
unsigned char **VAR_18 = NULL;
unsigned int VAR_19, VAR_20 = 0, VAR_21 = 0;
X509_EXTENSION *VAR_22 = NULL;
GENERAL_NAMES *VAR_23 = NULL;
GENERAL_NAME *VAR_24 = NULL;
if (VAR_4 != NULL)
*VAR_4 = NULL;
if (VAR_5 != NULL)
*VAR_5 = NULL;
if (VAR_6 != NULL)
*VAR_6 = NULL;
if (VAR_4 == NULL && VAR_5 == NULL && VAR_6 == NULL) {
pkiDebug(""%s: nowhere to return any values!\n"", VAR_25);
return VAR_7;
}
if (VAR_3 == NULL) {
pkiDebug(""%s: no certificate!\n"", VAR_25);
return VAR_7;
}
X509_NAME_oneline(X509_get_subject_name(VAR_3),
VAR_9, sizeof(VAR_9));
pkiDebug(""%s: looking for SANs in cert = %s\n"", VAR_25, VAR_9);
VAR_15 = X509_get_ext_by_NID(VAR_3, VAR_26, -1);
if (VAR_15 < 0)
return 0;
if (!(VAR_22 = X509_get_ext(VAR_3, VAR_15)) || !(VAR_23 = X509V3_EXT_d2i(VAR_22))) {
pkiDebug(""%s: found no subject alt name extensions\n"", VAR_25);
VAR_7 = VAR_27;
goto cleanup;
}
VAR_21 = sk_GENERAL_NAME_num(VAR_23);
pkiDebug(""%s: found %d subject alt name extension(s)\n"", VAR_25,
VAR_21);
if (VAR_4 != NULL) {
VAR_16 = calloc(VAR_21 + 1, sizeof(krb5_principal));
if (VAR_16 == NULL) {
VAR_7 = VAR_28;
goto cleanup;
}
}
if (VAR_5 != NULL) {
VAR_17 = calloc(VAR_21 + 1, sizeof(krb5_principal));
if (VAR_17 == NULL) {
VAR_7 = VAR_28;
goto cleanup;
}
}
if (VAR_6 != NULL) {
VAR_18 = calloc(VAR_21 + 1, sizeof(*VAR_18));
if (VAR_18 == NULL) {
VAR_7 = VAR_28;
goto cleanup;
}
}
for (VAR_19 = 0; VAR_19 < VAR_21; VAR_19++) {
krb5_data VAR_29 = { 0, 0, NULL };
VAR_24 = sk_GENERAL_NAME_value(VAR_23, VAR_19);
switch (VAR_24->type) {
case VAR_30:
VAR_29.length = VAR_24->d.otherName->value->value.sequence->length;
VAR_29.data = (char *)VAR_24->d.otherName->value->value.sequence->data;
if (VAR_16 != NULL &&
OBJ_cmp(VAR_1->id_pkinit_san,
VAR_24->d.otherName->type_id) == 0) {
#ifdef VAR_31
print_buffer_bin((unsigned char *)VAR_29.data, VAR_29.length,
""/tmp/pkinit_san"");
#endif
VAR_14 = k5int_decode_krb5_principal_name(&VAR_29, &VAR_16[VAR_11]);
if (VAR_14) {
pkiDebug(""%s: failed decoding pkinit san value\n"",
VAR_25);
} else {
VAR_11++;
VAR_20++;
}
} else if (VAR_17 != NULL &&
OBJ_cmp(VAR_1->id_ms_san_upn,
VAR_24->d.otherName->type_id) == 0) {
if (memchr(VAR_29.data, '\0', VAR_29.length))
break;
VAR_14 = krb5_parse_name_flags(VAR_0, VAR_29.data,
VAR_32,
&VAR_17[VAR_12]);
if (VAR_14) {
pkiDebug(""%s: failed parsing ms-upn san value\n"",
VAR_25);
} else {
VAR_12++;
VAR_20++;
}
} else {
pkiDebug(""%s: unrecognized othername oid in SAN\n"",
VAR_25);
continue;
}
break;
case VAR_33:
if (VAR_18 != NULL) {
if (memchr(VAR_24->d.dNSName->data, '\0', VAR_24->d.dNSName->length))
break;
pkiDebug(""%s: found dns name = %s\n"", VAR_25,
VAR_24->d.dNSName->data);
VAR_18[VAR_13] = (unsigned char *)
strdup((char *)VAR_24->d.dNSName->data);
if (VAR_18[VAR_13] == NULL) {
pkiDebug(""%s: failed to duplicate dns name\n"",
VAR_25);
} else {
VAR_13++;
VAR_20++;
}
}
break;
default:
pkiDebug(""%s: SAN type = %d expecting %d\n"", VAR_25,
VAR_24->type, VAR_30);
}
}
sk_GENERAL_NAME_pop_free(VAR_23, VAR_34);
VAR_7 = 0;
if (VAR_16)
*VAR_4 = VAR_16;
if (VAR_17)
*VAR_5 = VAR_17;
if (VAR_18)
*VAR_6 = VAR_18;
cleanup:
if (VAR_7) {
if (VAR_16 != NULL) {
for (VAR_19 = 0; VAR_16[VAR_19] != NULL; VAR_19++)
krb5_free_principal(VAR_0, VAR_16[VAR_19]);
free(VAR_16);
}
if (VAR_17 != NULL) {
for (VAR_19 = 0; VAR_17[VAR_19] != NULL; VAR_19++)
krb5_free_principal(VAR_0, VAR_17[VAR_19]);
free(VAR_17);
}
if (VAR_18 != NULL) {
for (VAR_19 = 0; VAR_18[VAR_19] != NULL; VAR_19++)
free(VAR_18[VAR_19]);
free(VAR_18);
}
}
return VAR_7;
}",krb5/50fe4074f188c2d4da0c421e96553acea8378db2/pkinit_crypto_openssl.c/vul/before/0.json,"static krb5_error_code
crypto_retrieve_X509_sans(krb5_context context,
                          pkinit_plg_crypto_context plgctx,
                          pkinit_req_crypto_context reqctx,
                          X509 *cert,
                          krb5_principal **princs_ret,
                          krb5_principal **upn_ret,
                          unsigned char ***dns_ret)
{
    krb5_error_code retval = EINVAL;
    char buf[DN_BUF_LEN];
    int p = 0, u = 0, d = 0, ret = 0, l;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    unsigned char **dnss = NULL;
    unsigned int i, num_found = 0, num_sans = 0;
    X509_EXTENSION *ext = NULL;
    GENERAL_NAMES *ialt = NULL;
    GENERAL_NAME *gen = NULL;

    if (princs_ret != NULL)
        *princs_ret = NULL;
    if (upn_ret != NULL)
        *upn_ret = NULL;
    if (dns_ret != NULL)
        *dns_ret = NULL;

    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {
        pkiDebug(""%s: nowhere to return any values!\n"", __FUNCTION__);
        return retval;
    }

    if (cert == NULL) {
        pkiDebug(""%s: no certificate!\n"", __FUNCTION__);
        return retval;
    }

    X509_NAME_oneline(X509_get_subject_name(cert),
                      buf, sizeof(buf));
    pkiDebug(""%s: looking for SANs in cert = %s\n"", __FUNCTION__, buf);

    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
    if (l < 0)
        return 0;

    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
        pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
        goto cleanup;
    }
    num_sans = sk_GENERAL_NAME_num(ialt);

    pkiDebug(""%s: found %d subject alt name extension(s)\n"", __FUNCTION__,
             num_sans);

    /* OK, we're likely returning something. Allocate return values */
    if (princs_ret != NULL) {
        princs = calloc(num_sans + 1, sizeof(krb5_principal));
        if (princs == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (upn_ret != NULL) {
        upns = calloc(num_sans + 1, sizeof(krb5_principal));
        if (upns == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }
    if (dns_ret != NULL) {
        dnss = calloc(num_sans + 1, sizeof(*dnss));
        if (dnss == NULL) {
            retval = ENOMEM;
            goto cleanup;
        }
    }

    for (i = 0; i < num_sans; i++) {
        krb5_data name = { 0, 0, NULL };

        gen = sk_GENERAL_NAME_value(ialt, i);
        switch (gen->type) {
        case GEN_OTHERNAME:
            name.length = gen->d.otherName->value->value.sequence->length;
            name.data = (char *)gen->d.otherName->value->value.sequence->data;
            if (princs != NULL &&
                OBJ_cmp(plgctx->id_pkinit_san,
                        gen->d.otherName->type_id) == 0) {
#ifdef DEBUG_ASN1
                print_buffer_bin((unsigned char *)name.data, name.length,
                                 ""/tmp/pkinit_san"");
#endif
                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);
                if (ret) {
                    pkiDebug(""%s: failed decoding pkinit san value\n"",
                             __FUNCTION__);
                } else {
                    p++;
                    num_found++;
                }
            } else if (upns != NULL &&
                       OBJ_cmp(plgctx->id_ms_san_upn,
                               gen->d.otherName->type_id) == 0) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(name.data, '\0', name.length))
                    break;
                ret = krb5_parse_name_flags(context, name.data,
                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,
                                            &upns[u]);
                if (ret) {
                    pkiDebug(""%s: failed parsing ms-upn san value\n"",
                             __FUNCTION__);
                } else {
                    u++;
                    num_found++;
                }
            } else {
                pkiDebug(""%s: unrecognized othername oid in SAN\n"",
                         __FUNCTION__);
                continue;
            }

            break;
        case GEN_DNS:
            if (dnss != NULL) {
                /* Prevent abuse of embedded null characters. */
                if (memchr(gen->d.dNSName->data, '\0', gen->d.dNSName->length))
                    break;
                pkiDebug(""%s: found dns name = %s\n"", __FUNCTION__,
                         gen->d.dNSName->data);
                dnss[d] = (unsigned char *)
                    strdup((char *)gen->d.dNSName->data);
                if (dnss[d] == NULL) {
                    pkiDebug(""%s: failed to duplicate dns name\n"",
                             __FUNCTION__);
                } else {
                    d++;
                    num_found++;
                }
            }
            break;
        default:
            pkiDebug(""%s: SAN type = %d expecting %d\n"", __FUNCTION__,
                     gen->type, GEN_OTHERNAME);
        }
    }
    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);

    retval = 0;
    if (princs != NULL && *princs != NULL) {
        *princs_ret = princs;
        princs = NULL;
    }
    if (upns != NULL && *upns != NULL) {
        *upn_ret = upns;
        upns = NULL;
    }
    if (dnss != NULL && *dnss != NULL) {
        *dns_ret = dnss;
        dnss = NULL;
    }

cleanup:
    for (i = 0; princs != NULL && princs[i] != NULL; i++)
        krb5_free_principal(context, princs[i]);
    free(princs);
    for (i = 0; upns != NULL && upns[i] != NULL; i++)
        krb5_free_principal(context, upns[i]);
    free(upns);
    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
        free(dnss[i]);
    free(dnss);
    return retval;
}","static krb5_error_code
crypto_retrieve_X509_sans(krb5_context VAR_0,
                          pkinit_plg_crypto_context VAR_1,
                          pkinit_req_crypto_context VAR_2,
                          X509 *VAR_3,
                          krb5_principal **VAR_4,
                          krb5_principal **VAR_5,
                          unsigned char ***VAR_6)
{
    krb5_error_code VAR_7 = VAR_8;
    char VAR_9[VAR_10];
    int VAR_11 = 0, VAR_12 = 0, VAR_13 = 0, VAR_14 = 0, VAR_15;
    krb5_principal *VAR_16 = NULL;
    krb5_principal *VAR_17 = NULL;
    unsigned char **VAR_18 = NULL;
    unsigned int VAR_19, VAR_20 = 0, VAR_21 = 0;
    X509_EXTENSION *VAR_22 = NULL;
    GENERAL_NAMES *VAR_23 = NULL;
    GENERAL_NAME *VAR_24 = NULL;

    if (VAR_4 != NULL)
        *VAR_4 = NULL;
    if (VAR_5 != NULL)
        *VAR_5 = NULL;
    if (VAR_6 != NULL)
        *VAR_6 = NULL;

    if (VAR_4 == NULL && VAR_5 == NULL && VAR_6 == NULL) {
        pkiDebug(""%s: nowhere to return any values!\n"", VAR_25);
        return VAR_7;
    }

    if (VAR_3 == NULL) {
        pkiDebug(""%s: no certificate!\n"", VAR_25);
        return VAR_7;
    }

    X509_NAME_oneline(X509_get_subject_name(VAR_3),
                      VAR_9, sizeof(VAR_9));
    pkiDebug(""%s: looking for SANs in cert = %s\n"", VAR_25, VAR_9);

    VAR_15 = X509_get_ext_by_NID(VAR_3, VAR_26, -1);
    if (VAR_15 < 0)
        return 0;

    if (!(VAR_22 = X509_get_ext(VAR_3, VAR_15)) || !(VAR_23 = X509V3_EXT_d2i(VAR_22))) {
        pkiDebug(""%s: found no subject alt name extensions\n"", VAR_25);
        goto cleanup;
    }
    VAR_21 = sk_GENERAL_NAME_num(VAR_23);

    pkiDebug(""%s: found %d subject alt name extension(s)\n"", VAR_25,
             VAR_21);

    /* COMMENT_0 */
    if (VAR_4 != NULL) {
        VAR_16 = calloc(VAR_21 + 1, sizeof(krb5_principal));
        if (VAR_16 == NULL) {
            VAR_7 = VAR_27;
            goto cleanup;
        }
    }
    if (VAR_5 != NULL) {
        VAR_17 = calloc(VAR_21 + 1, sizeof(krb5_principal));
        if (VAR_17 == NULL) {
            VAR_7 = VAR_27;
            goto cleanup;
        }
    }
    if (VAR_6 != NULL) {
        VAR_18 = calloc(VAR_21 + 1, sizeof(*VAR_18));
        if (VAR_18 == NULL) {
            VAR_7 = VAR_27;
            goto cleanup;
        }
    }

    for (VAR_19 = 0; VAR_19 < VAR_21; VAR_19++) {
        krb5_data VAR_28 = { 0, 0, NULL };

        VAR_24 = sk_GENERAL_NAME_value(VAR_23, VAR_19);
        switch (VAR_24->type) {
        case VAR_29:
            VAR_28.length = VAR_24->d.otherName->value->value.sequence->length;
            VAR_28.data = (char *)VAR_24->d.otherName->value->value.sequence->data;
            if (VAR_16 != NULL &&
                OBJ_cmp(VAR_1->id_pkinit_san,
                        VAR_24->d.otherName->type_id) == 0) {
#ifdef VAR_30
                print_buffer_bin((unsigned char *)VAR_28.data, VAR_28.length,
                                 ""/tmp/pkinit_san"");
#endif
                VAR_14 = k5int_decode_krb5_principal_name(&VAR_28, &VAR_16[VAR_11]);
                if (VAR_14) {
                    pkiDebug(""%s: failed decoding pkinit san value\n"",
                             VAR_25);
                } else {
                    VAR_11++;
                    VAR_20++;
                }
            } else if (VAR_17 != NULL &&
                       OBJ_cmp(VAR_1->id_ms_san_upn,
                               VAR_24->d.otherName->type_id) == 0) {
                /* COMMENT_1 */
                if (memchr(VAR_28.data, '\0', VAR_28.length))
                    break;
                VAR_14 = krb5_parse_name_flags(VAR_0, VAR_28.data,
                                            VAR_31,
                                            &VAR_17[VAR_12]);
                if (VAR_14) {
                    pkiDebug(""%s: failed parsing ms-upn san value\n"",
                             VAR_25);
                } else {
                    VAR_12++;
                    VAR_20++;
                }
            } else {
                pkiDebug(""%s: unrecognized othername oid in SAN\n"",
                         VAR_25);
                continue;
            }

            break;
        case VAR_32:
            if (VAR_18 != NULL) {
                /* COMMENT_1 */
                if (memchr(VAR_24->d.dNSName->data, '\0', VAR_24->d.dNSName->length))
                    break;
                pkiDebug(""%s: found dns name = %s\n"", VAR_25,
                         VAR_24->d.dNSName->data);
                VAR_18[VAR_13] = (unsigned char *)
                    strdup((char *)VAR_24->d.dNSName->data);
                if (VAR_18[VAR_13] == NULL) {
                    pkiDebug(""%s: failed to duplicate dns name\n"",
                             VAR_25);
                } else {
                    VAR_13++;
                    VAR_20++;
                }
            }
            break;
        default:
            pkiDebug(""%s: SAN type = %d expecting %d\n"", VAR_25,
                     VAR_24->type, VAR_29);
        }
    }
    sk_GENERAL_NAME_pop_free(VAR_23, VAR_33);

    VAR_7 = 0;
    if (VAR_16 != NULL && *VAR_16 != NULL) {
        *VAR_4 = VAR_16;
        VAR_16 = NULL;
    }
    if (VAR_17 != NULL && *VAR_17 != NULL) {
        *VAR_5 = VAR_17;
        VAR_17 = NULL;
    }
    if (VAR_18 != NULL && *VAR_18 != NULL) {
        *VAR_6 = VAR_18;
        VAR_18 = NULL;
    }

cleanup:
    for (VAR_19 = 0; VAR_16 != NULL && VAR_16[VAR_19] != NULL; VAR_19++)
        krb5_free_principal(VAR_0, VAR_16[VAR_19]);
    free(VAR_16);
    for (VAR_19 = 0; VAR_17 != NULL && VAR_17[VAR_19] != NULL; VAR_19++)
        krb5_free_principal(VAR_0, VAR_17[VAR_19]);
    free(VAR_17);
    for (VAR_19 = 0; VAR_18 != NULL && VAR_18[VAR_19] != NULL; VAR_19++)
        free(VAR_18[VAR_19]);
    free(VAR_18);
    return VAR_7;
}",krb5/50fe4074f188c2d4da0c421e96553acea8378db2/pkinit_crypto_openssl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,6 @@
 
     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
         pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
-        retval = ENOENT;
         goto cleanup;
     }
     num_sans = sk_GENERAL_NAME_num(ialt);
@@ -148,30 +147,28 @@
     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
 
     retval = 0;
-    if (princs)
+    if (princs != NULL && *princs != NULL) {
         *princs_ret = princs;
-    if (upns)
+        princs = NULL;
+    }
+    if (upns != NULL && *upns != NULL) {
         *upn_ret = upns;
-    if (dnss)
+        upns = NULL;
+    }
+    if (dnss != NULL && *dnss != NULL) {
         *dns_ret = dnss;
+        dnss = NULL;
+    }
 
 cleanup:
-    if (retval) {
-        if (princs != NULL) {
-            for (i = 0; princs[i] != NULL; i++)
-                krb5_free_principal(context, princs[i]);
-            free(princs);
-        }
-        if (upns != NULL) {
-            for (i = 0; upns[i] != NULL; i++)
-                krb5_free_principal(context, upns[i]);
-            free(upns);
-        }
-        if (dnss != NULL) {
-            for (i = 0; dnss[i] != NULL; i++)
-                free(dnss[i]);
-            free(dnss);
-        }
-    }
+    for (i = 0; princs != NULL && princs[i] != NULL; i++)
+        krb5_free_principal(context, princs[i]);
+    free(princs);
+    for (i = 0; upns != NULL && upns[i] != NULL; i++)
+        krb5_free_principal(context, upns[i]);
+    free(upns);
+    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
+        free(dnss[i]);
+    free(dnss);
     return retval;
 }","{'deleted_lines': ['        retval = ENOENT;', '    if (princs)', '    if (upns)', '    if (dnss)', '    if (retval) {', '        if (princs != NULL) {', '            for (i = 0; princs[i] != NULL; i++)', '                krb5_free_principal(context, princs[i]);', '            free(princs);', '        }', '        if (upns != NULL) {', '            for (i = 0; upns[i] != NULL; i++)', '                krb5_free_principal(context, upns[i]);', '            free(upns);', '        }', '        if (dnss != NULL) {', '            for (i = 0; dnss[i] != NULL; i++)', '                free(dnss[i]);', '            free(dnss);', '        }', '    }'], 'added_lines': ['    if (princs != NULL && *princs != NULL) {', '        princs = NULL;', '    }', '    if (upns != NULL && *upns != NULL) {', '        upns = NULL;', '    }', '    if (dnss != NULL && *dnss != NULL) {', '        dnss = NULL;', '    }', '    for (i = 0; princs != NULL && princs[i] != NULL; i++)', '        krb5_free_principal(context, princs[i]);', '    free(princs);', '    for (i = 0; upns != NULL && upns[i] != NULL; i++)', '        krb5_free_principal(context, upns[i]);', '    free(upns);', '    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)', '        free(dnss[i]);', '    free(dnss);']}",True,An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.,6.5,MEDIUM,1,test,2017-08-24T15:11:46Z,2
CVE-2017-7562,"['CWE-287', 'CWE-295']",AV:N/AC:L/Au:S/C:N/I:P/A:N,0.0,krb5,"Fix certauth built-in module returns

The PKINIT certauth eku module should never authoritatively authorize
a certificate, because an extended key usage does not establish a
relationship between the certificate and any specific user; it only
establishes that the certificate was created for PKINIT client
authentication.  Therefore, pkinit_eku_authorize() should return
KRB5_PLUGIN_NO_HANDLE on success, not 0.

The certauth san module should pass if it does not find any SANs of
the types it can match against; the presence of other types of SANs
should not cause it to explicitly deny a certificate.  Check for an
empty result from crypto_retrieve_cert_sans() in verify_client_san(),
instead of returning ENOENT from crypto_retrieve_cert_sans() when
there are no SANs at all.

ticket: 8561",50fe4074f188c2d4da0c421e96553acea8378db2,https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2,src/plugins/preauth/pkinit/pkinit_srv.c,verify_client_san,"static krb5_error_code
verify_client_san(krb5_context context,
pkinit_kdc_context plgctx,
pkinit_kdc_req_context reqctx,
krb5_kdcpreauth_callbacks cb,
krb5_kdcpreauth_rock rock,
krb5_const_principal client,
int *valid_san)
{
krb5_error_code retval;
krb5_principal *princs = NULL;
krb5_principal *upns = NULL;
int i;
#ifdef DEBUG_SAN_INFO
char *client_string = NULL, *san_string;
#endif
*valid_san = 0;
retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,
reqctx->cryptoctx, plgctx->idctx,
&princs,
plgctx->opts->allow_upn ? &upns : NULL,
NULL);
if (retval == ENOENT) {
TRACE_PKINIT_SERVER_NO_SAN(context);
goto out;
} else if (retval) {
pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
goto out;
}
#if 0
retval = call_san_checking_plugins(context, plgctx, reqctx, princs,
upns, NULL, &plugin_decision, &ignore);
pkiDebug(""%s: call_san_checking_plugins() returned retval %d\n"",
__FUNCTION__);
if (retval) {
retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
goto cleanup;
}
pkiDebug(""%s: call_san_checking_plugins() returned decision %d\n"",
__FUNCTION__, plugin_decision);
if (plugin_decision != NO_DECISION) {
retval = plugin_decision;
goto out;
}
#endif
#ifdef DEBUG_SAN_INFO
krb5_unparse_name(context, client, &client_string);
#endif
pkiDebug(""%s: Checking pkinit sans\n"", __FUNCTION__);
for (i = 0; princs != NULL && princs[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
krb5_unparse_name(context, princs[i], &san_string);
pkiDebug(""%s: Comparing client '%s' to pkinit san value '%s'\n"",
__FUNCTION__, client_string, san_string);
krb5_free_unparsed_name(context, san_string);
#endif
if (cb->match_client(context, rock, princs[i])) {
TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);
*valid_san = 1;
retval = 0;
goto out;
}
}
pkiDebug(""%s: no pkinit san match found\n"", __FUNCTION__);
if (upns == NULL) {
pkiDebug(""%s: no upn sans (or we wouldn't accept them anyway)\n"",
__FUNCTION__);
retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
goto out;
}
pkiDebug(""%s: Checking upn sans\n"", __FUNCTION__);
for (i = 0; upns[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
krb5_unparse_name(context, upns[i], &san_string);
pkiDebug(""%s: Comparing client '%s' to upn san value '%s'\n"",
__FUNCTION__, client_string, san_string);
krb5_free_unparsed_name(context, san_string);
#endif
if (cb->match_client(context, rock, upns[i])) {
TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);
*valid_san = 1;
retval = 0;
goto out;
}
}
pkiDebug(""%s: no upn san match found\n"", __FUNCTION__);
if (princs != NULL || upns != NULL) {
*valid_san = 0;
retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
}
retval = 0;
out:
if (princs != NULL) {
for (i = 0; princs[i] != NULL; i++)
krb5_free_principal(context, princs[i]);
free(princs);
}
if (upns != NULL) {
for (i = 0; upns[i] != NULL; i++)
krb5_free_principal(context, upns[i]);
free(upns);
}
#ifdef DEBUG_SAN_INFO
if (client_string != NULL)
krb5_free_unparsed_name(context, client_string);
#endif
pkiDebug(""%s: returning retval %d, valid_san %d\n"",
__FUNCTION__, retval, *valid_san);
return retval;
}","static krb5_error_code
verify_client_san(krb5_context VAR_0,
pkinit_kdc_context VAR_1,
pkinit_kdc_req_context VAR_2,
krb5_kdcpreauth_callbacks VAR_3,
krb5_kdcpreauth_rock VAR_4,
krb5_const_principal VAR_5,
int *VAR_6)
{
krb5_error_code VAR_7;
krb5_principal *VAR_8 = NULL;
krb5_principal *VAR_9 = NULL;
int VAR_10;
#ifdef VAR_11
char *VAR_12 = NULL, *VAR_13;
#endif
*VAR_6 = 0;
VAR_7 = crypto_retrieve_cert_sans(VAR_0, VAR_1->cryptoctx,
VAR_2->cryptoctx, VAR_1->idctx,
&VAR_8,
VAR_1->opts->allow_upn ? &VAR_9 : NULL,
NULL);
if (VAR_7 == VAR_14) {
TRACE_PKINIT_SERVER_NO_SAN(VAR_0);
goto out;
} else if (VAR_7) {
pkiDebug(""%s: error from retrieve_certificate_sans()\n"", VAR_15);
VAR_7 = VAR_16;
goto out;
}
#if 0
VAR_7 = call_san_checking_plugins(VAR_0, VAR_1, VAR_2, VAR_8,
VAR_9, NULL, &VAR_17, &VAR_18);
pkiDebug(""%s: call_san_checking_plugins() returned retval %d\n"",
VAR_15);
if (VAR_7) {
VAR_7 = VAR_16;
goto cleanup;
}
pkiDebug(""%s: call_san_checking_plugins() returned decision %d\n"",
VAR_15, VAR_17);
if (VAR_17 != VAR_19) {
VAR_7 = VAR_17;
goto out;
}
#endif
#ifdef VAR_11
krb5_unparse_name(VAR_0, VAR_5, &VAR_12);
#endif
pkiDebug(""%s: Checking pkinit sans\n"", VAR_15);
for (VAR_10 = 0; VAR_8 != NULL && VAR_8[VAR_10] != NULL; VAR_10++) {
#ifdef VAR_11
krb5_unparse_name(VAR_0, VAR_8[VAR_10], &VAR_13);
pkiDebug(""%s: Comparing client '%s' to pkinit san value '%s'\n"",
VAR_15, VAR_12, VAR_13);
krb5_free_unparsed_name(VAR_0, VAR_13);
#endif
if (VAR_3->match_client(VAR_0, VAR_4, VAR_8[VAR_10])) {
TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(VAR_0);
*VAR_6 = 1;
VAR_7 = 0;
goto out;
}
}
pkiDebug(""%s: no pkinit san match found\n"", VAR_15);
if (VAR_9 == NULL) {
pkiDebug(""%s: no upn sans (or we wouldn't accept them anyway)\n"",
VAR_15);
VAR_7 = VAR_16;
goto out;
}
pkiDebug(""%s: Checking upn sans\n"", VAR_15);
for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++) {
#ifdef VAR_11
krb5_unparse_name(VAR_0, VAR_9[VAR_10], &VAR_13);
pkiDebug(""%s: Comparing client '%s' to upn san value '%s'\n"",
VAR_15, VAR_12, VAR_13);
krb5_free_unparsed_name(VAR_0, VAR_13);
#endif
if (VAR_3->match_client(VAR_0, VAR_4, VAR_9[VAR_10])) {
TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(VAR_0);
*VAR_6 = 1;
VAR_7 = 0;
goto out;
}
}
pkiDebug(""%s: no upn san match found\n"", VAR_15);
if (VAR_8 != NULL || VAR_9 != NULL) {
*VAR_6 = 0;
VAR_7 = VAR_16;
}
VAR_7 = 0;
out:
if (VAR_8 != NULL) {
for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)
krb5_free_principal(VAR_0, VAR_8[VAR_10]);
free(VAR_8);
}
if (VAR_9 != NULL) {
for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)
krb5_free_principal(VAR_0, VAR_9[VAR_10]);
free(VAR_9);
}
#ifdef VAR_11
if (VAR_12 != NULL)
krb5_free_unparsed_name(VAR_0, VAR_12);
#endif
pkiDebug(""%s: returning retval %d, valid_san %d\n"",
VAR_15, VAR_7, *VAR_6);
return VAR_7;
}",krb5/50fe4074f188c2d4da0c421e96553acea8378db2/pkinit_srv.c/vul/before/0.json,"static krb5_error_code
verify_client_san(krb5_context context,
                  pkinit_kdc_context plgctx,
                  pkinit_kdc_req_context reqctx,
                  krb5_kdcpreauth_callbacks cb,
                  krb5_kdcpreauth_rock rock,
                  krb5_const_principal client,
                  int *valid_san)
{
    krb5_error_code retval;
    krb5_principal *princs = NULL;
    krb5_principal *upns = NULL;
    int i;
#ifdef DEBUG_SAN_INFO
    char *client_string = NULL, *san_string;
#endif

    *valid_san = 0;
    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx,
                                       &princs,
                                       plgctx->opts->allow_upn ? &upns : NULL,
                                       NULL);
    if (retval) {
        pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto out;
    }

    if (princs == NULL && upns == NULL) {
        TRACE_PKINIT_SERVER_NO_SAN(context);
        retval = ENOENT;
        goto out;
    }

    /* XXX Verify this is consistent with client side XXX */
#if 0
    retval = call_san_checking_plugins(context, plgctx, reqctx, princs,
                                       upns, NULL, &plugin_decision, &ignore);
    pkiDebug(""%s: call_san_checking_plugins() returned retval %d\n"",
             __FUNCTION__);
    if (retval) {
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto cleanup;
    }
    pkiDebug(""%s: call_san_checking_plugins() returned decision %d\n"",
             __FUNCTION__, plugin_decision);
    if (plugin_decision != NO_DECISION) {
        retval = plugin_decision;
        goto out;
    }
#endif

#ifdef DEBUG_SAN_INFO
    krb5_unparse_name(context, client, &client_string);
#endif
    pkiDebug(""%s: Checking pkinit sans\n"", __FUNCTION__);
    for (i = 0; princs != NULL && princs[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, princs[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to pkinit san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, princs[i])) {
            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no pkinit san match found\n"", __FUNCTION__);
    /*
     * XXX if cert has names but none match, should we
     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?
     */

    if (upns == NULL) {
        pkiDebug(""%s: no upn sans (or we wouldn't accept them anyway)\n"",
                 __FUNCTION__);
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
        goto out;
    }

    pkiDebug(""%s: Checking upn sans\n"", __FUNCTION__);
    for (i = 0; upns[i] != NULL; i++) {
#ifdef DEBUG_SAN_INFO
        krb5_unparse_name(context, upns[i], &san_string);
        pkiDebug(""%s: Comparing client '%s' to upn san value '%s'\n"",
                 __FUNCTION__, client_string, san_string);
        krb5_free_unparsed_name(context, san_string);
#endif
        if (cb->match_client(context, rock, upns[i])) {
            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);
            *valid_san = 1;
            retval = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no upn san match found\n"", __FUNCTION__);

    /* We found no match */
    if (princs != NULL || upns != NULL) {
        *valid_san = 0;
        /* XXX ??? If there was one or more name in the cert, but
         * none matched the client name, then return mismatch? */
        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
    }
    retval = 0;

out:
    if (princs != NULL) {
        for (i = 0; princs[i] != NULL; i++)
            krb5_free_principal(context, princs[i]);
        free(princs);
    }
    if (upns != NULL) {
        for (i = 0; upns[i] != NULL; i++)
            krb5_free_principal(context, upns[i]);
        free(upns);
    }
#ifdef DEBUG_SAN_INFO
    if (client_string != NULL)
        krb5_free_unparsed_name(context, client_string);
#endif
    pkiDebug(""%s: returning retval %d, valid_san %d\n"",
             __FUNCTION__, retval, *valid_san);
    return retval;
}","static krb5_error_code
verify_client_san(krb5_context VAR_0,
                  pkinit_kdc_context VAR_1,
                  pkinit_kdc_req_context VAR_2,
                  krb5_kdcpreauth_callbacks VAR_3,
                  krb5_kdcpreauth_rock VAR_4,
                  krb5_const_principal VAR_5,
                  int *VAR_6)
{
    krb5_error_code VAR_7;
    krb5_principal *VAR_8 = NULL;
    krb5_principal *VAR_9 = NULL;
    int VAR_10;
#ifdef VAR_11
    char *VAR_12 = NULL, *VAR_13;
#endif

    *VAR_6 = 0;
    VAR_7 = crypto_retrieve_cert_sans(VAR_0, VAR_1->cryptoctx,
                                       VAR_2->cryptoctx, VAR_1->idctx,
                                       &VAR_8,
                                       VAR_1->opts->allow_upn ? &VAR_9 : NULL,
                                       NULL);
    if (VAR_7) {
        pkiDebug(""%s: error from retrieve_certificate_sans()\n"", VAR_14);
        VAR_7 = VAR_15;
        goto out;
    }

    if (VAR_8 == NULL && VAR_9 == NULL) {
        TRACE_PKINIT_SERVER_NO_SAN(VAR_0);
        VAR_7 = VAR_16;
        goto out;
    }

    /* COMMENT_0 */
#if 0
    VAR_7 = call_san_checking_plugins(VAR_0, VAR_1, VAR_2, VAR_8,
                                       VAR_9, NULL, &VAR_17, &VAR_18);
    pkiDebug(""%s: call_san_checking_plugins() returned retval %d\n"",
             VAR_14);
    if (VAR_7) {
        VAR_7 = VAR_15;
        goto cleanup;
    }
    pkiDebug(""%s: call_san_checking_plugins() returned decision %d\n"",
             VAR_14, VAR_17);
    if (VAR_17 != VAR_19) {
        VAR_7 = VAR_17;
        goto out;
    }
#endif

#ifdef VAR_11
    krb5_unparse_name(VAR_0, VAR_5, &VAR_12);
#endif
    pkiDebug(""%s: Checking pkinit sans\n"", VAR_14);
    for (VAR_10 = 0; VAR_8 != NULL && VAR_8[VAR_10] != NULL; VAR_10++) {
#ifdef VAR_11
        krb5_unparse_name(VAR_0, VAR_8[VAR_10], &VAR_13);
        pkiDebug(""%s: Comparing client '%s' to pkinit san value '%s'\n"",
                 VAR_14, VAR_12, VAR_13);
        krb5_free_unparsed_name(VAR_0, VAR_13);
#endif
        if (VAR_3->match_client(VAR_0, VAR_4, VAR_8[VAR_10])) {
            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(VAR_0);
            *VAR_6 = 1;
            VAR_7 = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no pkinit san match found\n"", VAR_14);
    /* COMMENT_1 */
                                                      
                                                          
       

    if (VAR_9 == NULL) {
        pkiDebug(""%s: no upn sans (or we wouldn't accept them anyway)\n"",
                 VAR_14);
        VAR_7 = VAR_15;
        goto out;
    }

    pkiDebug(""%s: Checking upn sans\n"", VAR_14);
    for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++) {
#ifdef VAR_11
        krb5_unparse_name(VAR_0, VAR_9[VAR_10], &VAR_13);
        pkiDebug(""%s: Comparing client '%s' to upn san value '%s'\n"",
                 VAR_14, VAR_12, VAR_13);
        krb5_free_unparsed_name(VAR_0, VAR_13);
#endif
        if (VAR_3->match_client(VAR_0, VAR_4, VAR_9[VAR_10])) {
            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(VAR_0);
            *VAR_6 = 1;
            VAR_7 = 0;
            goto out;
        }
    }
    pkiDebug(""%s: no upn san match found\n"", VAR_14);

    /* COMMENT_5 */
    if (VAR_8 != NULL || VAR_9 != NULL) {
        *VAR_6 = 0;
        /* COMMENT_6 */
                                                                 
        VAR_7 = VAR_15;
    }
    VAR_7 = 0;

out:
    if (VAR_8 != NULL) {
        for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)
            krb5_free_principal(VAR_0, VAR_8[VAR_10]);
        free(VAR_8);
    }
    if (VAR_9 != NULL) {
        for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)
            krb5_free_principal(VAR_0, VAR_9[VAR_10]);
        free(VAR_9);
    }
#ifdef VAR_11
    if (VAR_12 != NULL)
        krb5_free_unparsed_name(VAR_0, VAR_12);
#endif
    pkiDebug(""%s: returning retval %d, valid_san %d\n"",
             VAR_14, VAR_7, *VAR_6);
    return VAR_7;
}",krb5/50fe4074f188c2d4da0c421e96553acea8378db2/pkinit_srv.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,14 +21,18 @@
                                        &princs,
                                        plgctx->opts->allow_upn ? &upns : NULL,
                                        NULL);
-    if (retval == ENOENT) {
-        TRACE_PKINIT_SERVER_NO_SAN(context);
-        goto out;
-    } else if (retval) {
+    if (retval) {
         pkiDebug(""%s: error from retrieve_certificate_sans()\n"", __FUNCTION__);
         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
         goto out;
     }
+
+    if (princs == NULL && upns == NULL) {
+        TRACE_PKINIT_SERVER_NO_SAN(context);
+        retval = ENOENT;
+        goto out;
+    }
+
     /* XXX Verify this is consistent with client side XXX */
 #if 0
     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,","{'deleted_lines': ['    if (retval == ENOENT) {', '        TRACE_PKINIT_SERVER_NO_SAN(context);', '        goto out;', '    } else if (retval) {'], 'added_lines': ['    if (retval) {', '', '    if (princs == NULL && upns == NULL) {', '        TRACE_PKINIT_SERVER_NO_SAN(context);', '        retval = ENOENT;', '        goto out;', '    }', '']}",True,An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.,6.5,MEDIUM,1,test,2017-08-24T15:11:46Z,2
CVE-2017-7562,"['CWE-287', 'CWE-295']",AV:N/AC:L/Au:S/C:N/I:P/A:N,0.0,krb5,"Fix certauth built-in module returns

The PKINIT certauth eku module should never authoritatively authorize
a certificate, because an extended key usage does not establish a
relationship between the certificate and any specific user; it only
establishes that the certificate was created for PKINIT client
authentication.  Therefore, pkinit_eku_authorize() should return
KRB5_PLUGIN_NO_HANDLE on success, not 0.

The certauth san module should pass if it does not find any SANs of
the types it can match against; the presence of other types of SANs
should not cause it to explicitly deny a certificate.  Check for an
empty result from crypto_retrieve_cert_sans() in verify_client_san(),
instead of returning ENOENT from crypto_retrieve_cert_sans() when
there are no SANs at all.

ticket: 8561",50fe4074f188c2d4da0c421e96553acea8378db2,https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2,src/plugins/preauth/pkinit/pkinit_srv.c,pkinit_eku_authorize,"static krb5_error_code
pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
const uint8_t *cert, size_t cert_len,
krb5_const_principal princ, const void *opts,
const struct _krb5_db_entry_new *db_entry,
char ***authinds_out)
{
krb5_error_code ret;
int valid_eku;
const struct certauth_req_opts *req_opts = opts;
*authinds_out = NULL;
ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,
&valid_eku);
if (ret)
return ret;
if (!valid_eku) {
TRACE_PKINIT_SERVER_EKU_REJECT(context);
return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
}
return 0;
}","static krb5_error_code
pkinit_eku_authorize(krb5_context VAR_0, krb5_certauth_moddata VAR_1,
const uint8_t *VAR_2, size_t VAR_3,
krb5_const_principal VAR_4, const void *VAR_5,
const struct _krb5_db_entry_new *VAR_6,
char ***VAR_7)
{
krb5_error_code VAR_8;
int VAR_9;
const struct certauth_req_opts *VAR_10 = VAR_5;
*VAR_7 = NULL;
VAR_8 = verify_client_eku(VAR_0, VAR_10->plgctx, VAR_10->reqctx,
&VAR_9);
if (VAR_8)
return VAR_8;
if (!VAR_9) {
TRACE_PKINIT_SERVER_EKU_REJECT(VAR_0);
return VAR_11;
}
return 0;
}",krb5/50fe4074f188c2d4da0c421e96553acea8378db2/pkinit_srv.c/vul/before/1.json,"static krb5_error_code
pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,
                     const uint8_t *cert, size_t cert_len,
                     krb5_const_principal princ, const void *opts,
                     const struct _krb5_db_entry_new *db_entry,
                     char ***authinds_out)
{
    krb5_error_code ret;
    int valid_eku;
    const struct certauth_req_opts *req_opts = opts;

    *authinds_out = NULL;

    /* Verify the client EKU. */
    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,
                            &valid_eku);
    if (ret)
        return ret;

    if (!valid_eku) {
        TRACE_PKINIT_SERVER_EKU_REJECT(context);
        return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
    }

    return KRB5_PLUGIN_NO_HANDLE;
}","static krb5_error_code
pkinit_eku_authorize(krb5_context VAR_0, krb5_certauth_moddata VAR_1,
                     const uint8_t *VAR_2, size_t VAR_3,
                     krb5_const_principal VAR_4, const void *VAR_5,
                     const struct _krb5_db_entry_new *VAR_6,
                     char ***VAR_7)
{
    krb5_error_code VAR_8;
    int VAR_9;
    const struct certauth_req_opts *VAR_10 = VAR_5;

    *VAR_7 = NULL;

    /* COMMENT_0 */
    VAR_8 = verify_client_eku(VAR_0, VAR_10->plgctx, VAR_10->reqctx,
                            &VAR_9);
    if (VAR_8)
        return VAR_8;

    if (!VAR_9) {
        TRACE_PKINIT_SERVER_EKU_REJECT(VAR_0);
        return VAR_11;
    }

    return VAR_12;
}",krb5/50fe4074f188c2d4da0c421e96553acea8378db2/pkinit_srv.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,5 +22,5 @@
         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
     }
 
-    return 0;
+    return KRB5_PLUGIN_NO_HANDLE;
 }","{'deleted_lines': ['    return 0;'], 'added_lines': ['    return KRB5_PLUGIN_NO_HANDLE;']}",True,An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.,6.5,MEDIUM,1,test,2017-08-24T15:11:46Z,2
CVE-2017-13766,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"PNIO: Fix another potential OOB write.

 Conflicts:
	plugins/profinet/packet-dcerpc-pn-io.c

Bug: 13847
Change-Id: I62bb519b8e37112a59a7d209b39780f034dbcd0c
Reviewed-on: https://code.wireshark.org/review/23267
Reviewed-by: Gerald Combs <gerald@wireshark.org>
Petri-Dish: Gerald Combs <gerald@wireshark.org>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit c9d05548405c6cc5c58dbede2e531c46732e009a)
Reviewed-on: https://code.wireshark.org/review/23275",af7b093ca528516c14247acb545046199d30843e,https://github.com/wireshark/wireshark/commit/af7b093ca528516c14247acb545046199d30843e,plugins/profinet/packet-dcerpc-pn-io.c,dissect_ExpectedSubmoduleBlockReq_block,"static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *tvb, int offset,
packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)
{
guint16     u16NumberOfAPIs;
guint32     u32Api;
guint16     u16SlotNr;
guint32     u32ModuleIdentNumber;
guint16     u16ModuleProperties;
guint16     u16NumberOfSubmodules;
guint16     u16SubslotNr;
guint32     u32SubmoduleIdentNumber;
guint16     u16SubmoduleProperties;
proto_item *api_item;
proto_tree *api_tree;
guint32     u32ApiStart;
proto_item *sub_item;
proto_tree *sub_tree;
proto_item *submodule_item;
proto_tree *submodule_tree;
guint32     u32SubStart;
const char vendorIdStr[] = ""VendorID=\"""";
const char deviceIdStr[] = ""DeviceID=\"""";
const char moduleStr[] = ""ModuleIdentNumber=\"""";
const char subModuleStr[] = ""SubmoduleIdentNumber=\"""";
const char profisafeStr[] = ""PROFIsafeSupported=\""true\"""";
const char fParameterStr[] = ""<F_ParameterRecordDataItem"";
const char fParameterIndexStr[] = ""Index="";
const char moduleNameInfo[] = ""<Name"";
const char moduleValueInfo[] = ""Value=\"""";
guint16  searchVendorID = 0;
guint16  searchDeviceID = 0;
gboolean vendorMatch;
gboolean deviceMatch;
conversation_t *conversation;
stationInfo    *station_info = NULL;
ioDataObject   *io_data_object = NULL; 
guint32  read_vendor_id;
guint32  read_device_id;
guint32  read_module_id;
guint32  read_submodule_id;
gboolean gsdmlFoundFlag;
gchar   tmp_moduletext[MAX_NAMELENGTH];
gchar   *convertStr;      
gchar   *pch;             
gchar   *puffer;          
gchar   *temp;            
gchar   *diropen = NULL;  
GDir    *dir;
FILE    *fp = NULL;       
const gchar *filename;    
convertStr = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_NAMELENGTH);
convertStr[0] = '\0';
pch = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
pch[0] = '\0';
puffer = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
puffer[0] = '\0';
temp = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
temp[0] = '\0';
io_data_object = wmem_new0(wmem_file_scope(), ioDataObject);
io_data_object->profisafeSupported = FALSE;
io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");
vendorMatch = FALSE;
deviceMatch = FALSE;
gsdmlFoundFlag = FALSE;
if (u8BlockVersionHigh != 1 || u8BlockVersionLow != 0) {
expert_add_info_format(pinfo, item, &ei_pn_io_block_version,
""Block version %u.%u not implemented yet!"", u8BlockVersionHigh, u8BlockVersionLow);
return offset;
}
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep,
hf_pn_io_number_of_apis, &u16NumberOfAPIs);
proto_item_append_text(item, "": APIs:%u"", u16NumberOfAPIs);
conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
if (conversation == NULL) {
conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
}
station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);
if (station_info != NULL) {
station_info->gsdFound = FALSE;
station_info->gsdPathLength = FALSE;
searchVendorID = station_info->u16Vendor_id;
searchDeviceID = station_info->u16Device_id;
if(pnio_ps_networkpath[0] != '\0') {   
station_info->gsdPathLength = TRUE;
if ((dir = g_dir_open(pnio_ps_networkpath, 0, NULL)) != NULL) {
while ((filename = g_dir_read_name(dir)) != NULL) {
diropen = wmem_strdup_printf(wmem_packet_scope(), ""%s"" G_DIR_SEPARATOR_S ""%s"", pnio_ps_networkpath, filename);
fp = ws_fopen(diropen, ""r"");
if(fp != NULL) {
while(fgets(puffer, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(puffer, vendorIdStr)) != NULL) {
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(puffer, vendorIdStr);
if (pch!= NULL && sscanf(pch, ""VendorID=\""%199[^\""]"", convertStr) == 1) {
read_vendor_id = (guint32) strtoul (convertStr, NULL, 0);
if(read_vendor_id == searchVendorID) {
vendorMatch = TRUE;        
}
}
}
if((strstr(puffer, deviceIdStr)) != NULL) {
memset(convertStr, 0, sizeof(*convertStr));
pch = strstr(puffer, deviceIdStr);
if (pch != NULL && sscanf(pch, ""DeviceID=\""%199[^\""]"", convertStr) == 1) {
read_device_id = (guint32)strtoul(convertStr, NULL, 0);
if(read_device_id == searchDeviceID) {
deviceMatch = TRUE;        
}
}
}
}
fclose(fp);
fp = NULL;
if(vendorMatch && deviceMatch) {
break;        
}
else {
vendorMatch = FALSE;
deviceMatch = FALSE;
gsdmlFoundFlag = FALSE;
diropen = """";           
}
}
}
g_dir_close(dir);
}
if(vendorMatch && deviceMatch) {
gsdmlFoundFlag = TRUE;
station_info->gsdFound = TRUE;
station_info->gsdLocation = wmem_strdup(wmem_file_scope(), diropen);
}
else {
station_info->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" G_DIR_SEPARATOR_S ""*.xml"", pnio_ps_networkpath);
}
}
else {
station_info->gsdPathLength = FALSE;
}
}
while (u16NumberOfAPIs--) {
api_item = proto_tree_add_item(tree, hf_pn_io_api_tree, tvb, offset, 0, ENC_NA);
api_tree = proto_item_add_subtree(api_item, ett_pn_io_api);
u32ApiStart = offset;
offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_api, &u32Api);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_slot_nr, &u16SlotNr);
offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_module_ident_number, &u32ModuleIdentNumber);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_module_properties, &u16ModuleProperties);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
hf_pn_io_number_of_submodules, &u16NumberOfSubmodules);
proto_item_append_text(api_item, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
u32Api, u16SlotNr, u32ModuleIdentNumber, u16ModuleProperties, u16NumberOfSubmodules);
proto_item_append_text(item, "", Submodules:%u"", u16NumberOfSubmodules);
while (u16NumberOfSubmodules--) {
sub_item = proto_tree_add_item(api_tree, hf_pn_io_submodule_tree, tvb, offset, 0, ENC_NA);
sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_submodule);
u32SubStart = offset;
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,
hf_pn_io_subslot_nr, &u16SubslotNr);
offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,
hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber);
submodule_item = proto_tree_add_item(sub_tree, hf_pn_io_submodule_properties, tvb, offset, 2, ENC_BIG_ENDIAN);
submodule_tree = proto_item_add_subtree(submodule_item, ett_pn_io_submodule_properties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_reserved, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_discard_ioxs, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_reduce_output_submodule_data_length, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_reduce_input_submodule_data_length, &u16SubmoduleProperties);
dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_shared_input, &u16SubmoduleProperties);
offset = dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
hf_pn_io_submodule_properties_type, &u16SubmoduleProperties);
io_data_object->slotNr = u16SlotNr;
io_data_object->subSlotNr = u16SubslotNr;
io_data_object->moduleIdentNr = u32ModuleIdentNumber;
io_data_object->subModuleIdentNr = u32SubmoduleIdentNumber;
io_data_object->discardIOXS = u16SubmoduleProperties & 0x0020;
io_data_object->amountInGSDML = 0;
io_data_object->fParameterIndexNr = 0;
io_data_object->profisafeSupported = FALSE;
if (diropen != NULL) {
fp = ws_fopen(diropen, ""r"");
}
if(gsdmlFoundFlag && fp != NULL) {
fseek(fp, 0, SEEK_SET);
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, fParameterStr)) != NULL) {
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(temp, fParameterIndexStr);
if (pch != NULL && sscanf(pch, ""Index=\""%199[^\""]"", convertStr) == 1) {
io_data_object->fParameterIndexNr = (guint32)strtoul(convertStr, NULL, 0);
}
break;    
}
}
memset (temp, 0, sizeof(*temp));
fseek(fp, 0, SEEK_SET);                
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, moduleStr)) != NULL) {                         
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(temp, moduleStr);                              
if (pch != NULL && sscanf(pch, ""ModuleIdentNumber=\""%199[^\""]"", convertStr) == 1) {  
read_module_id = (guint32)strtoul(convertStr, NULL, 0);     
if (read_module_id == io_data_object->moduleIdentNr) {
++io_data_object->amountInGSDML;    
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, moduleNameInfo)) != NULL) {                    
long filePosRecord;
if (sscanf(temp, ""%*s TextId=\""%199[^\""]"", tmp_moduletext) != 1)        
break;
filePosRecord = ftell(fp);            
if (filePosRecord >= 0) {
while (fgets(temp, MAX_LINE_LENGTH, fp) != NULL && io_data_object->amountInGSDML == 1) {
if(((strstr(temp, tmp_moduletext)) != NULL) && ((strstr(temp, moduleValueInfo)) != NULL)) {
pch = strstr(temp, moduleValueInfo);
if (sscanf(pch, ""Value=\""%[^\""]"", io_data_object->moduleNameStr) == 1)
break;    
}
}
fseek(fp, filePosRecord, SEEK_SET);    
}
}
if((strstr(temp, subModuleStr)) != NULL) {
memset (convertStr, 0, sizeof(*convertStr));
pch = strstr(temp, subModuleStr);
if (pch != NULL && sscanf(pch, ""SubmoduleIdentNumber=\""%199[^\""]"", convertStr) == 1) {
read_submodule_id = (guint32) strtoul (convertStr, NULL, 0);    
if(read_submodule_id == io_data_object->subModuleIdentNr) {
if((strstr(temp, profisafeStr)) != NULL) {
io_data_object->profisafeSupported = TRUE;   
break;
}
else {    
while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
if((strstr(temp, profisafeStr)) != NULL) {
io_data_object->profisafeSupported = TRUE;
break;    
}
else if((strstr(temp, "">"")) != NULL) {
break;
}
}
}
}
break;    
}
}
}
}
}
}
}
fclose(fp);
fp = NULL;
}
switch (u16SubmoduleProperties & 0x03) {
case(0x00): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
case(0x01): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
case(0x02): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
case(0x03): 
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
break;
}
proto_item_append_text(sub_item, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
u16SubslotNr, u32SubmoduleIdentNumber, u16SubmoduleProperties);
proto_item_set_len(sub_item, offset - u32SubStart);
}
proto_item_set_len(api_item, offset - u32ApiStart);
}
return offset;
}","static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *VAR_0, int VAR_1,
packet_info *VAR_2, proto_tree *VAR_3, proto_item *VAR_4, guint8 *VAR_5, guint8 VAR_6, guint8 VAR_7)
{
guint16     VAR_8;
guint32     VAR_9;
guint16     VAR_10;
guint32     VAR_11;
guint16     VAR_12;
guint16     VAR_13;
guint16     VAR_14;
guint32     VAR_15;
guint16     VAR_16;
proto_item *VAR_17;
proto_tree *VAR_18;
guint32     VAR_19;
proto_item *VAR_20;
proto_tree *VAR_21;
proto_item *VAR_22;
proto_tree *VAR_23;
guint32     VAR_24;
const char VAR_25[] = ""VendorID=\"""";
const char VAR_26[] = ""DeviceID=\"""";
const char VAR_27[] = ""ModuleIdentNumber=\"""";
const char VAR_28[] = ""SubmoduleIdentNumber=\"""";
const char VAR_29[] = ""PROFIsafeSupported=\""true\"""";
const char VAR_30[] = ""<F_ParameterRecordDataItem"";
const char VAR_31[] = ""Index="";
const char VAR_32[] = ""<Name"";
const char VAR_33[] = ""Value=\"""";
guint16  VAR_34 = 0;
guint16  VAR_35 = 0;
gboolean VAR_36;
gboolean VAR_37;
conversation_t *VAR_38;
stationInfo    *VAR_39 = NULL;
ioDataObject   *VAR_40 = NULL; 
guint32  VAR_41;
guint32  VAR_42;
guint32  VAR_43;
guint32  VAR_44;
gboolean VAR_45;
gchar   VAR_46[VAR_47];
gchar   *VAR_48;      
gchar   *VAR_49;             
gchar   *VAR_50;          
gchar   *VAR_51;            
gchar   *VAR_52 = NULL;  
GDir    *VAR_53;
FILE    *VAR_54 = NULL;       
const gchar *VAR_55;    
VAR_48 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_47);
VAR_48[0] = '\0';
VAR_49 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
VAR_49[0] = '\0';
VAR_50 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
VAR_50[0] = '\0';
VAR_51 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
VAR_51[0] = '\0';
VAR_40 = wmem_new0(wmem_file_scope(), ioDataObject);
VAR_40->profisafeSupported = FALSE;
VAR_40->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");
VAR_36 = FALSE;
VAR_37 = FALSE;
VAR_45 = FALSE;
if (VAR_6 != 1 || VAR_7 != 0) {
expert_add_info_format(VAR_2, VAR_4, &VAR_57,
""Block version %u.%u not implemented yet!"", VAR_6, VAR_7);
return VAR_1;
}
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5,
VAR_58, &VAR_8);
proto_item_append_text(VAR_4, "": APIs:%u"", VAR_8);
VAR_38 = find_conversation(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
if (VAR_38 == NULL) {
VAR_38 = conversation_new(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
}
VAR_39 = (stationInfo*)conversation_get_proto_data(VAR_38, VAR_60);
if (VAR_39 != NULL) {
VAR_39->gsdFound = FALSE;
VAR_39->gsdPathLength = FALSE;
VAR_34 = VAR_39->u16Vendor_id;
VAR_35 = VAR_39->u16Device_id;
if(VAR_61[0] != '\0') {   
VAR_39->gsdPathLength = TRUE;
if ((VAR_53 = g_dir_open(VAR_61, 0, NULL)) != NULL) {
while ((VAR_55 = g_dir_read_name(VAR_53)) != NULL) {
VAR_52 = wmem_strdup_printf(wmem_packet_scope(), ""%s"" VAR_62 ""%s"", VAR_61, VAR_55);
VAR_54 = ws_fopen(VAR_52, ""r"");
if(VAR_54 != NULL) {
while(fgets(VAR_50, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_50, VAR_25)) != NULL) {
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_50, VAR_25);
if (VAR_49!= NULL && sscanf(VAR_49, ""VendorID=\""%199[^\""]"", VAR_48) == 1) {
VAR_41 = (guint32) strtoul (VAR_48, NULL, 0);
if(VAR_41 == VAR_34) {
VAR_36 = TRUE;        
}
}
}
if((strstr(VAR_50, VAR_26)) != NULL) {
memset(VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_50, VAR_26);
if (VAR_49 != NULL && sscanf(VAR_49, ""DeviceID=\""%199[^\""]"", VAR_48) == 1) {
VAR_42 = (guint32)strtoul(VAR_48, NULL, 0);
if(VAR_42 == VAR_35) {
VAR_37 = TRUE;        
}
}
}
}
fclose(VAR_54);
VAR_54 = NULL;
if(VAR_36 && VAR_37) {
break;        
}
else {
VAR_36 = FALSE;
VAR_37 = FALSE;
VAR_45 = FALSE;
VAR_52 = """";           
}
}
}
g_dir_close(VAR_53);
}
if(VAR_36 && VAR_37) {
VAR_45 = TRUE;
VAR_39->gsdFound = TRUE;
VAR_39->gsdLocation = wmem_strdup(wmem_file_scope(), VAR_52);
}
else {
VAR_39->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" VAR_62 ""*.xml"", VAR_61);
}
}
else {
VAR_39->gsdPathLength = FALSE;
}
}
while (VAR_8--) {
VAR_17 = proto_tree_add_item(VAR_3, VAR_63, VAR_0, VAR_1, 0, VAR_64);
VAR_18 = proto_item_add_subtree(VAR_17, VAR_65);
VAR_19 = VAR_1;
VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_66, &VAR_9);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_67, &VAR_10);
VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_68, &VAR_11);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_69, &VAR_12);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
VAR_70, &VAR_13);
proto_item_append_text(VAR_17, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
VAR_9, VAR_10, VAR_11, VAR_12, VAR_13);
proto_item_append_text(VAR_4, "", Submodules:%u"", VAR_13);
while (VAR_13--) {
VAR_20 = proto_tree_add_item(VAR_18, VAR_71, VAR_0, VAR_1, 0, VAR_64);
VAR_21 = proto_item_add_subtree(VAR_20, VAR_72);
VAR_24 = VAR_1;
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
VAR_73, &VAR_14);
VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
VAR_74, &VAR_15);
VAR_22 = proto_tree_add_item(VAR_21, VAR_75, VAR_0, VAR_1, 2, VAR_76);
VAR_23 = proto_item_add_subtree(VAR_22, VAR_77);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_78, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_79, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_80, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_81, &VAR_16);
dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_82, &VAR_16);
VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
VAR_83, &VAR_16);
VAR_40->slotNr = VAR_10;
VAR_40->subSlotNr = VAR_14;
VAR_40->moduleIdentNr = VAR_11;
VAR_40->subModuleIdentNr = VAR_15;
VAR_40->discardIOXS = VAR_16 & 0x0020;
VAR_40->amountInGSDML = 0;
VAR_40->fParameterIndexNr = 0;
VAR_40->profisafeSupported = FALSE;
if (VAR_52 != NULL) {
VAR_54 = ws_fopen(VAR_52, ""r"");
}
if(VAR_45 && VAR_54 != NULL) {
fseek(VAR_54, 0, VAR_84);
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_30)) != NULL) {
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_51, VAR_31);
if (VAR_49 != NULL && sscanf(VAR_49, ""Index=\""%199[^\""]"", VAR_48) == 1) {
VAR_40->fParameterIndexNr = (guint32)strtoul(VAR_48, NULL, 0);
}
break;    
}
}
memset (VAR_51, 0, sizeof(*VAR_51));
fseek(VAR_54, 0, VAR_84);                
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_27)) != NULL) {                         
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_51, VAR_27);                              
if (VAR_49 != NULL && sscanf(VAR_49, ""ModuleIdentNumber=\""%199[^\""]"", VAR_48) == 1) {  
VAR_43 = (guint32)strtoul(VAR_48, NULL, 0);     
if (VAR_43 == VAR_40->moduleIdentNr) {
++VAR_40->amountInGSDML;    
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_32)) != NULL) {                    
long VAR_85;
if (sscanf(VAR_51, ""%*s TextId=\""%199[^\""]"", VAR_46) != 1)        
break;
VAR_85 = ftell(VAR_54);            
if (VAR_85 >= 0) {
while (fgets(VAR_51, VAR_56, VAR_54) != NULL && VAR_40->amountInGSDML == 1) {
if(((strstr(VAR_51, VAR_46)) != NULL) && ((strstr(VAR_51, VAR_33)) != NULL)) {
VAR_49 = strstr(VAR_51, VAR_33);
if (sscanf(VAR_49, ""Value=\""%[^\""]"", VAR_40->moduleNameStr) == 1)
break;    
}
}
fseek(VAR_54, VAR_85, VAR_84);    
}
}
if((strstr(VAR_51, VAR_28)) != NULL) {
memset (VAR_48, 0, sizeof(*VAR_48));
VAR_49 = strstr(VAR_51, VAR_28);
if (VAR_49 != NULL && sscanf(VAR_49, ""SubmoduleIdentNumber=\""%199[^\""]"", VAR_48) == 1) {
VAR_44 = (guint32) strtoul (VAR_48, NULL, 0);    
if(VAR_44 == VAR_40->subModuleIdentNr) {
if((strstr(VAR_51, VAR_29)) != NULL) {
VAR_40->profisafeSupported = TRUE;   
break;
}
else {    
while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
if((strstr(VAR_51, VAR_29)) != NULL) {
VAR_40->profisafeSupported = TRUE;
break;    
}
else if((strstr(VAR_51, "">"")) != NULL) {
break;
}
}
}
}
break;    
}
}
}
}
}
}
}
fclose(VAR_54);
VAR_54 = NULL;
}
switch (VAR_16 & 0x03) {
case(0x00): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
case(0x01): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
case(0x02): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
case(0x03): 
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
break;
}
proto_item_append_text(VAR_20, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
VAR_14, VAR_15, VAR_16);
proto_item_set_len(VAR_20, VAR_1 - VAR_24);
}
proto_item_set_len(VAR_17, VAR_1 - VAR_19);
}
return VAR_1;
}",wireshark/af7b093ca528516c14247acb545046199d30843e/packet-dcerpc-pn-io.c/vul/before/0.json,"static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *tvb, int offset,
    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)
{
    guint16     u16NumberOfAPIs;
    guint32     u32Api;
    guint16     u16SlotNr;
    guint32     u32ModuleIdentNumber;
    guint16     u16ModuleProperties;
    guint16     u16NumberOfSubmodules;
    guint16     u16SubslotNr;
    guint32     u32SubmoduleIdentNumber;
    guint16     u16SubmoduleProperties;
    proto_item *api_item;
    proto_tree *api_tree;
    guint32     u32ApiStart;
    proto_item *sub_item;
    proto_tree *sub_tree;
    proto_item *submodule_item;
    proto_tree *submodule_tree;
    guint32     u32SubStart;

    /* Variable for the search of gsd file */
    const char vendorIdStr[] = ""VendorID=\"""";
    const char deviceIdStr[] = ""DeviceID=\"""";
    const char moduleStr[] = ""ModuleIdentNumber=\"""";
    const char subModuleStr[] = ""SubmoduleIdentNumber=\"""";
    const char profisafeStr[] = ""PROFIsafeSupported=\""true\"""";
    const char fParameterStr[] = ""<F_ParameterRecordDataItem"";
    const char fParameterIndexStr[] = ""Index="";
    const char moduleNameInfo[] = ""<Name"";
    const char moduleValueInfo[] = ""Value=\"""";

    guint16  searchVendorID = 0;
    guint16  searchDeviceID = 0;
    gboolean vendorMatch;
    gboolean deviceMatch;
    conversation_t *conversation;
    stationInfo    *station_info = NULL;
    ioDataObject   *io_data_object = NULL; /* Used to transfer data to fct. ""dissect_DataDescription()"" */

    /* Variable for the search of GSD-file */
    guint32  read_vendor_id;
    guint32  read_device_id;
    guint32  read_module_id;
    guint32  read_submodule_id;
    gboolean gsdmlFoundFlag;
    gchar   tmp_moduletext[MAX_NAMELENGTH];
    gchar   *convertStr;      /* GSD-file search */
    gchar   *pch;             /* helppointer, to save temp. the found Networkpath of GSD-file */
    gchar   *puffer;          /* used for fgets() during GSD-file search */
    gchar   *temp;            /* used for fgets() during GSD-file search */
    gchar   *diropen = NULL;  /* saves the final networkpath to open for GSD-files */
    GDir    *dir;
    FILE    *fp = NULL;       /* filepointer */
    const gchar *filename;    /* saves the found GSD-file name */

    /* Helppointer initial */
    convertStr = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_NAMELENGTH);
    convertStr[0] = '\0';
    pch = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
    pch[0] = '\0';
    puffer = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
    puffer[0] = '\0';
    temp = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH);
    temp[0] = '\0';

    /* Initial */
    io_data_object = wmem_new0(wmem_file_scope(), ioDataObject);
    io_data_object->profisafeSupported = FALSE;
    io_data_object->moduleNameStr = (gchar*)wmem_alloc(wmem_file_scope(), MAX_NAMELENGTH);
    g_strlcpy(io_data_object->moduleNameStr, ""Unknown"", MAX_NAMELENGTH);
    vendorMatch = FALSE;
    deviceMatch = FALSE;
    gsdmlFoundFlag = FALSE;


    if (u8BlockVersionHigh != 1 || u8BlockVersionLow != 0) {
        expert_add_info_format(pinfo, item, &ei_pn_io_block_version,
            ""Block version %u.%u not implemented yet!"", u8BlockVersionHigh, u8BlockVersionLow);
        return offset;
    }

    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep,
                        hf_pn_io_number_of_apis, &u16NumberOfAPIs);

    proto_item_append_text(item, "": APIs:%u"", u16NumberOfAPIs);


    /* Get current conversation endpoints using MAC addresses */
    conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
    if (conversation == NULL) {
        conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0);
    }

    station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp);
    if (station_info != NULL) {
        station_info->gsdFound = FALSE;
        station_info->gsdPathLength = FALSE;

        /* Set searchVendorID and searchDeviceID for GSDfile search */
        searchVendorID = station_info->u16Vendor_id;
        searchDeviceID = station_info->u16Device_id;

        /* Use the given GSD-file networkpath of the PNIO-Preference */
        if(pnio_ps_networkpath[0] != '\0') {   /* check the length of the given networkpath (array overflow protection) */
            station_info->gsdPathLength = TRUE;

            if ((dir = g_dir_open(pnio_ps_networkpath, 0, NULL)) != NULL) {
                /* Find all GSD-files within directory */
                while ((filename = g_dir_read_name(dir)) != NULL) {

                    /* ---- complete the path to open a GSD-file ---- */
                    diropen = wmem_strdup_printf(wmem_packet_scope(), ""%s"" G_DIR_SEPARATOR_S ""%s"", pnio_ps_networkpath, filename);

                    /* ---- Open the found GSD-file  ---- */
                    fp = ws_fopen(diropen, ""r"");

                    if(fp != NULL) {
                        /* ---- Get VendorID & DeviceID ---- */
                        while(fgets(puffer, MAX_LINE_LENGTH, fp) != NULL) {
                            /* ----- VendorID ------ */
                            if((strstr(puffer, vendorIdStr)) != NULL) {
                                memset (convertStr, 0, sizeof(*convertStr));
                                pch = strstr(puffer, vendorIdStr);
                                if (pch!= NULL && sscanf(pch, ""VendorID=\""%199[^\""]"", convertStr) == 1) {
                                    read_vendor_id = (guint32) strtoul (convertStr, NULL, 0);

                                    if(read_vendor_id == searchVendorID) {
                                        vendorMatch = TRUE;        /* found correct VendorID */
                                    }
                                }
                            }

                            /* ----- DeviceID ------ */
                            if((strstr(puffer, deviceIdStr)) != NULL) {
                                memset(convertStr, 0, sizeof(*convertStr));
                                pch = strstr(puffer, deviceIdStr);
                                if (pch != NULL && sscanf(pch, ""DeviceID=\""%199[^\""]"", convertStr) == 1) {
                                    read_device_id = (guint32)strtoul(convertStr, NULL, 0);

                                    if(read_device_id == searchDeviceID) {
                                        deviceMatch = TRUE;        /* found correct DeviceID */
                                    }
                                }
                            }
                        }

                        fclose(fp);
                        fp = NULL;

                        if(vendorMatch && deviceMatch) {
                            break;        /* Found correct GSD-file! -> Break the searchloop */
                        }
                        else {
                            /* Couldn't find the correct GSD-file to the corresponding device */
                            vendorMatch = FALSE;
                            deviceMatch = FALSE;
                            gsdmlFoundFlag = FALSE;
                            diropen = """";           /* reset array for next search */
                        }
                    }
                }

                g_dir_close(dir);
            }

            /* ---- Found the correct GSD-file -> set Flag and save the completed path ---- */
            if(vendorMatch && deviceMatch) {
                gsdmlFoundFlag = TRUE;
                station_info->gsdFound = TRUE;
                station_info->gsdLocation = wmem_strdup(wmem_file_scope(), diropen);
            }
            else {
                /* Copy searchpath to array for a detailed output message in cyclic data dissection */
                station_info->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" G_DIR_SEPARATOR_S ""*.xml"", pnio_ps_networkpath);
            }
        }
        else {
            /* will be used later on in cyclic RTC1 data dissection for detailed output message */
            station_info->gsdPathLength = FALSE;
        }
    }

    while (u16NumberOfAPIs--) {
        api_item = proto_tree_add_item(tree, hf_pn_io_api_tree, tvb, offset, 0, ENC_NA);
        api_tree = proto_item_add_subtree(api_item, ett_pn_io_api);
        u32ApiStart = offset;

        /* API */
        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_api, &u32Api);
        /* SlotNumber */
        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_slot_nr, &u16SlotNr);
        /* ModuleIdentNumber */
        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_module_ident_number, &u32ModuleIdentNumber);
        /* ModuleProperties */
        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_module_properties, &u16ModuleProperties);
        /* NumberOfSubmodules */
        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,
                            hf_pn_io_number_of_submodules, &u16NumberOfSubmodules);

        proto_item_append_text(api_item, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
            u32Api, u16SlotNr, u32ModuleIdentNumber, u16ModuleProperties, u16NumberOfSubmodules);

        proto_item_append_text(item, "", Submodules:%u"", u16NumberOfSubmodules);

        while (u16NumberOfSubmodules--) {
            sub_item = proto_tree_add_item(api_tree, hf_pn_io_submodule_tree, tvb, offset, 0, ENC_NA);
            sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_submodule);
            u32SubStart = offset;

            /* Subslotnumber */
            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,
                                hf_pn_io_subslot_nr, &u16SubslotNr);
            /* SubmoduleIdentNumber */
            offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,
                            hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber);
            /* SubmoduleProperties */
            submodule_item = proto_tree_add_item(sub_tree, hf_pn_io_submodule_properties, tvb, offset, 2, ENC_BIG_ENDIAN);
            submodule_tree = proto_item_add_subtree(submodule_item, ett_pn_io_submodule_properties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_reserved, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_discard_ioxs, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_reduce_output_submodule_data_length, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_reduce_input_submodule_data_length, &u16SubmoduleProperties);
            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_shared_input, &u16SubmoduleProperties);
            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,
                            hf_pn_io_submodule_properties_type, &u16SubmoduleProperties);

            io_data_object->slotNr = u16SlotNr;
            io_data_object->subSlotNr = u16SubslotNr;
            io_data_object->moduleIdentNr = u32ModuleIdentNumber;
            io_data_object->subModuleIdentNr = u32SubmoduleIdentNumber;
            io_data_object->discardIOXS = u16SubmoduleProperties & 0x0020;

            /* Search the moduleID and subModuleID, find if PROFIsafe and also search for F-Par. Indexnumber
             * ---------------------------------------------------------------------------------------------
             * Speical case: Module has several ModuleIdentNr. in one GSD-file
             * Also with the given parameters of wireshark, some modules were completely equal. For this
             * special case a compromise for this problem has been made, to set the module name will
             * be more generally displayed.
             * Also this searchloop will find the F-Parameter Indexnumber, so that Wireshark is able to
             * dissect those F-Parameters correctly, as this index can change between the vendors.
             */

            io_data_object->amountInGSDML = 0;
            io_data_object->fParameterIndexNr = 0;
            io_data_object->profisafeSupported = FALSE;

            if (diropen != NULL) {
                fp = ws_fopen(diropen, ""r"");
            }
            if(gsdmlFoundFlag && fp != NULL) {
                fseek(fp, 0, SEEK_SET);

                /* Find Indexnumber for fParameter */
                while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                    if((strstr(temp, fParameterStr)) != NULL) {
                        memset (convertStr, 0, sizeof(*convertStr));

                        pch = strstr(temp, fParameterIndexStr);
                        if (pch != NULL && sscanf(pch, ""Index=\""%199[^\""]"", convertStr) == 1) {
                            io_data_object->fParameterIndexNr = (guint32)strtoul(convertStr, NULL, 0);
                        }
                        break;    /* found Indexnumber -> break search loop */
                    }
                }

                memset (temp, 0, sizeof(*temp));
                fseek(fp, 0, SEEK_SET);                /* Set filepointer to the beginning */

                while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                    if((strstr(temp, moduleStr)) != NULL) {                         /* find the String ""ModuleIdentNumber="" */
                        memset (convertStr, 0, sizeof(*convertStr));
                        pch = strstr(temp, moduleStr);                              /* search for ""ModuleIdentNumber=\"""" within GSD-file */
                        if (pch != NULL && sscanf(pch, ""ModuleIdentNumber=\""%199[^\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */
                            read_module_id = (guint32)strtoul(convertStr, NULL, 0);     /* Change numeric string --> unsigned long; read_module_id contains the Value of the ModuleIdentNumber */

                            /* If the found ModuleID matches with the wanted ModuleID, search for the Submodule and break */
                            if (read_module_id == io_data_object->moduleIdentNr) {
                                ++io_data_object->amountInGSDML;    /* Save the amount of same (!) Module- & SubmoduleIdentNr in one GSD-file */

                                while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                                    if((strstr(temp, moduleNameInfo)) != NULL) {                    /* find the String ""<Name"" for the TextID */
                                        long filePosRecord;

                                        if (sscanf(temp, ""%*s TextId=\""%199[^\""]"", tmp_moduletext) != 1)        /* saves the correct TextId for the next searchloop */
                                            break;

                                        filePosRecord = ftell(fp);            /* save the current position of the filepointer (Offset) */
                                        /* ftell() may return -1 for error, don't move fp in this case */
                                        if (filePosRecord >= 0) {
                                            while (fgets(temp, MAX_LINE_LENGTH, fp) != NULL && io_data_object->amountInGSDML == 1) {
                                                /* Find a String with the saved TextID and with a fitting value for it in the same line. This value is the name of the Module! */
                                                if(((strstr(temp, tmp_moduletext)) != NULL) && ((strstr(temp, moduleValueInfo)) != NULL)) {
                                                    pch = strstr(temp, moduleValueInfo);
                                                    if (pch != NULL && sscanf(pch, ""Value=\""%199[^\""]"", io_data_object->moduleNameStr) == 1)
                                                        break;    /* Found the name of the module */
                                                }
                                            }

                                            fseek(fp, filePosRecord, SEEK_SET);    /* set filepointer to the correct TextID */
                                        }
                                    }

                                    /* Search for Submoduleidentnumber in GSD-file */
                                    if((strstr(temp, subModuleStr)) != NULL) {
                                        memset (convertStr, 0, sizeof(*convertStr));
                                        pch = strstr(temp, subModuleStr);
                                        if (pch != NULL && sscanf(pch, ""SubmoduleIdentNumber=\""%199[^\""]"", convertStr) == 1) {
                                            read_submodule_id = (guint32) strtoul (convertStr, NULL, 0);    /* read_submodule_id contains the Value of the SubModuleIdentNumber */

                                            /* Find ""PROFIsafeSupported"" flag of the module in GSD-file */
                                            if(read_submodule_id == io_data_object->subModuleIdentNr) {
                                                if((strstr(temp, profisafeStr)) != NULL) {
                                                    io_data_object->profisafeSupported = TRUE;   /* flag is in the same line as SubmoduleIdentNr */
                                                    break;
                                                }
                                                else {    /* flag is not in the same line as Submoduleidentnumber -> search for it */
                                                    while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {
                                                        if((strstr(temp, profisafeStr)) != NULL) {
                                                            io_data_object->profisafeSupported = TRUE;
                                                            break;    /* Found the PROFIsafeSupported flag of the module */
                                                        }

                                                        else if((strstr(temp, "">"")) != NULL) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            break;    /* Found the PROFIsafe Module */
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                fclose(fp);
                fp = NULL;
            }

            switch (u16SubmoduleProperties & 0x03) {
            case(0x00): /* no input and no output data (one Input DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            case(0x01): /* input data (one Input DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            case(0x02): /* output data (one Output DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            case(0x03): /* input and output data (one Input and one Output DataDescription Block follows) */
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object);
                break;
            }

            proto_item_append_text(sub_item, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
                u16SubslotNr, u32SubmoduleIdentNumber, u16SubmoduleProperties);
            proto_item_set_len(sub_item, offset - u32SubStart);
        }

        proto_item_set_len(api_item, offset - u32ApiStart);
    }

    return offset;
}","static int
dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *VAR_0, int VAR_1,
    packet_info *VAR_2, proto_tree *VAR_3, proto_item *VAR_4, guint8 *VAR_5, guint8 VAR_6, guint8 VAR_7)
{
    guint16     VAR_8;
    guint32     VAR_9;
    guint16     VAR_10;
    guint32     VAR_11;
    guint16     VAR_12;
    guint16     VAR_13;
    guint16     VAR_14;
    guint32     VAR_15;
    guint16     VAR_16;
    proto_item *VAR_17;
    proto_tree *VAR_18;
    guint32     VAR_19;
    proto_item *VAR_20;
    proto_tree *VAR_21;
    proto_item *VAR_22;
    proto_tree *VAR_23;
    guint32     VAR_24;

    /* COMMENT_0 */
    const char VAR_25[] = ""VendorID=\"""";
    const char VAR_26[] = ""DeviceID=\"""";
    const char VAR_27[] = ""ModuleIdentNumber=\"""";
    const char VAR_28[] = ""SubmoduleIdentNumber=\"""";
    const char VAR_29[] = ""PROFIsafeSupported=\""true\"""";
    const char VAR_30[] = ""<F_ParameterRecordDataItem"";
    const char VAR_31[] = ""Index="";
    const char VAR_32[] = ""<Name"";
    const char VAR_33[] = ""Value=\"""";

    guint16  VAR_34 = 0;
    guint16  VAR_35 = 0;
    gboolean VAR_36;
    gboolean VAR_37;
    conversation_t *VAR_38;
    stationInfo    *VAR_39 = NULL;
    ioDataObject   *VAR_40 = NULL; /* COMMENT_1 */

    /* COMMENT_2 */
    guint32  VAR_41;
    guint32  VAR_42;
    guint32  VAR_43;
    guint32  VAR_44;
    gboolean VAR_45;
    gchar   VAR_46[VAR_47];
    gchar   *VAR_48;      /* COMMENT_3 */
    gchar   *VAR_49;             /* COMMENT_4 */
    gchar   *VAR_50;          /* COMMENT_5 */
    gchar   *VAR_51;            /* COMMENT_5 */
    gchar   *VAR_52 = NULL;  /* COMMENT_6 */
    GDir    *VAR_53;
    FILE    *VAR_54 = NULL;       /* COMMENT_7 */
    const gchar *VAR_55;    /* COMMENT_8 */

    /* COMMENT_9 */
    VAR_48 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_47);
    VAR_48[0] = '\0';
    VAR_49 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
    VAR_49[0] = '\0';
    VAR_50 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
    VAR_50[0] = '\0';
    VAR_51 = (gchar*)wmem_alloc(wmem_packet_scope(), VAR_56);
    VAR_51[0] = '\0';

    /* COMMENT_10 */
    VAR_40 = wmem_new0(wmem_file_scope(), ioDataObject);
    VAR_40->profisafeSupported = FALSE;
    VAR_40->moduleNameStr = (gchar*)wmem_alloc(wmem_file_scope(), VAR_47);
    g_strlcpy(VAR_40->moduleNameStr, ""Unknown"", VAR_47);
    VAR_36 = FALSE;
    VAR_37 = FALSE;
    VAR_45 = FALSE;


    if (VAR_6 != 1 || VAR_7 != 0) {
        expert_add_info_format(VAR_2, VAR_4, &VAR_57,
            ""Block version %u.%u not implemented yet!"", VAR_6, VAR_7);
        return VAR_1;
    }

    VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5,
                        VAR_58, &VAR_8);

    proto_item_append_text(VAR_4, "": APIs:%u"", VAR_8);


    /* COMMENT_11 */
    VAR_38 = find_conversation(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
    if (VAR_38 == NULL) {
        VAR_38 = conversation_new(VAR_2->num, &VAR_2->dl_src, &VAR_2->dl_dst, VAR_59, 0, 0, 0);
    }

    VAR_39 = (stationInfo*)conversation_get_proto_data(VAR_38, VAR_60);
    if (VAR_39 != NULL) {
        VAR_39->gsdFound = FALSE;
        VAR_39->gsdPathLength = FALSE;

        /* COMMENT_12 */
        VAR_34 = VAR_39->u16Vendor_id;
        VAR_35 = VAR_39->u16Device_id;

        /* COMMENT_13 */
        if(VAR_61[0] != '\0') {   /* COMMENT_14 */
            VAR_39->gsdPathLength = TRUE;

            if ((VAR_53 = g_dir_open(VAR_61, 0, NULL)) != NULL) {
                /* COMMENT_15 */
                while ((VAR_55 = g_dir_read_name(VAR_53)) != NULL) {

                    /* COMMENT_16 */
                    VAR_52 = wmem_strdup_printf(wmem_packet_scope(), ""%s"" VAR_62 ""%s"", VAR_61, VAR_55);

                    /* COMMENT_17 */
                    VAR_54 = ws_fopen(VAR_52, ""r"");

                    if(VAR_54 != NULL) {
                        /* COMMENT_18 */
                        while(fgets(VAR_50, VAR_56, VAR_54) != NULL) {
                            /* COMMENT_19 */
                            if((strstr(VAR_50, VAR_25)) != NULL) {
                                memset (VAR_48, 0, sizeof(*VAR_48));
                                VAR_49 = strstr(VAR_50, VAR_25);
                                if (VAR_49!= NULL && sscanf(VAR_49, ""VendorID=\""%199[^\""]"", VAR_48) == 1) {
                                    VAR_41 = (guint32) strtoul (VAR_48, NULL, 0);

                                    if(VAR_41 == VAR_34) {
                                        VAR_36 = TRUE;        /* COMMENT_20 */
                                    }
                                }
                            }

                            /* COMMENT_21 */
                            if((strstr(VAR_50, VAR_26)) != NULL) {
                                memset(VAR_48, 0, sizeof(*VAR_48));
                                VAR_49 = strstr(VAR_50, VAR_26);
                                if (VAR_49 != NULL && sscanf(VAR_49, ""DeviceID=\""%199[^\""]"", VAR_48) == 1) {
                                    VAR_42 = (guint32)strtoul(VAR_48, NULL, 0);

                                    if(VAR_42 == VAR_35) {
                                        VAR_37 = TRUE;        /* COMMENT_22 */
                                    }
                                }
                            }
                        }

                        fclose(VAR_54);
                        VAR_54 = NULL;

                        if(VAR_36 && VAR_37) {
                            break;        /* COMMENT_23 */
                        }
                        else {
                            /* COMMENT_24 */
                            VAR_36 = FALSE;
                            VAR_37 = FALSE;
                            VAR_45 = FALSE;
                            VAR_52 = """";           /* COMMENT_25 */
                        }
                    }
                }

                g_dir_close(VAR_53);
            }

            /* COMMENT_26 */
            if(VAR_36 && VAR_37) {
                VAR_45 = TRUE;
                VAR_39->gsdFound = TRUE;
                VAR_39->gsdLocation = wmem_strdup(wmem_file_scope(), VAR_52);
            }
            else {
                /* COMMENT_27 */
                VAR_39->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" VAR_62 ""*.xml"", VAR_61);
            }
        }
        else {
            /* COMMENT_28 */
            VAR_39->gsdPathLength = FALSE;
        }
    }

    while (VAR_8--) {
        VAR_17 = proto_tree_add_item(VAR_3, VAR_63, VAR_0, VAR_1, 0, VAR_64);
        VAR_18 = proto_item_add_subtree(VAR_17, VAR_65);
        VAR_19 = VAR_1;

        /* COMMENT_29 */
        VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_66, &VAR_9);
        /* COMMENT_30 */
        VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_67, &VAR_10);
        /* COMMENT_31 */
        VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_68, &VAR_11);
        /* COMMENT_32 */
        VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_69, &VAR_12);
        /* COMMENT_33 */
        VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_18, VAR_5,
                            VAR_70, &VAR_13);

        proto_item_append_text(VAR_17, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",
            VAR_9, VAR_10, VAR_11, VAR_12, VAR_13);

        proto_item_append_text(VAR_4, "", Submodules:%u"", VAR_13);

        while (VAR_13--) {
            VAR_20 = proto_tree_add_item(VAR_18, VAR_71, VAR_0, VAR_1, 0, VAR_64);
            VAR_21 = proto_item_add_subtree(VAR_20, VAR_72);
            VAR_24 = VAR_1;

            /* COMMENT_34 */
            VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
                                VAR_73, &VAR_14);
            /* COMMENT_35 */
            VAR_1 = dissect_dcerpc_uint32(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5,
                            VAR_74, &VAR_15);
            /* COMMENT_36 */
            VAR_22 = proto_tree_add_item(VAR_21, VAR_75, VAR_0, VAR_1, 2, VAR_76);
            VAR_23 = proto_item_add_subtree(VAR_22, VAR_77);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_78, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_79, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_80, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_81, &VAR_16);
            dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_82, &VAR_16);
            VAR_1 = dissect_dcerpc_uint16(VAR_0, VAR_1, VAR_2, VAR_23, VAR_5,
                            VAR_83, &VAR_16);

            VAR_40->slotNr = VAR_10;
            VAR_40->subSlotNr = VAR_14;
            VAR_40->moduleIdentNr = VAR_11;
            VAR_40->subModuleIdentNr = VAR_15;
            VAR_40->discardIOXS = VAR_16 & 0x0020;

            /* COMMENT_37 */
                                                                                                            
                                                                              
                                                                                                        
                                                                                                    
                                           
                                                                                                       
                                                                                                  
               

            VAR_40->amountInGSDML = 0;
            VAR_40->fParameterIndexNr = 0;
            VAR_40->profisafeSupported = FALSE;

            if (VAR_52 != NULL) {
                VAR_54 = ws_fopen(VAR_52, ""r"");
            }
            if(VAR_45 && VAR_54 != NULL) {
                fseek(VAR_54, 0, VAR_84);

                /* COMMENT_46 */
                while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                    if((strstr(VAR_51, VAR_30)) != NULL) {
                        memset (VAR_48, 0, sizeof(*VAR_48));

                        VAR_49 = strstr(VAR_51, VAR_31);
                        if (VAR_49 != NULL && sscanf(VAR_49, ""Index=\""%199[^\""]"", VAR_48) == 1) {
                            VAR_40->fParameterIndexNr = (guint32)strtoul(VAR_48, NULL, 0);
                        }
                        break;    /* COMMENT_47 */
                    }
                }

                memset (VAR_51, 0, sizeof(*VAR_51));
                fseek(VAR_54, 0, VAR_84);                /* COMMENT_48 */

                while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                    if((strstr(VAR_51, VAR_27)) != NULL) {                         /* COMMENT_49 */
                        memset (VAR_48, 0, sizeof(*VAR_48));
                        VAR_49 = strstr(VAR_51, VAR_27);                              /* COMMENT_50 */
                        if (VAR_49 != NULL && sscanf(VAR_49, ""ModuleIdentNumber=\""%199[^\""]"", VAR_48) == 1) {  /* COMMENT_51 */
                            VAR_43 = (guint32)strtoul(VAR_48, NULL, 0);     /* COMMENT_52 */

                            /* COMMENT_53 */
                            if (VAR_43 == VAR_40->moduleIdentNr) {
                                ++VAR_40->amountInGSDML;    /* COMMENT_54 */

                                while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                                    if((strstr(VAR_51, VAR_32)) != NULL) {                    /* COMMENT_55 */
                                        long VAR_85;

                                        if (sscanf(VAR_51, ""%*s TextId=\""%199[^\""]"", VAR_46) != 1)        /* COMMENT_56 */
                                            break;

                                        VAR_85 = ftell(VAR_54);            /* COMMENT_57 */
                                        /* COMMENT_58 */
                                        if (VAR_85 >= 0) {
                                            while (fgets(VAR_51, VAR_56, VAR_54) != NULL && VAR_40->amountInGSDML == 1) {
                                                /* COMMENT_59 */
                                                if(((strstr(VAR_51, VAR_46)) != NULL) && ((strstr(VAR_51, VAR_33)) != NULL)) {
                                                    VAR_49 = strstr(VAR_51, VAR_33);
                                                    if (VAR_49 != NULL && sscanf(VAR_49, ""Value=\""%199[^\""]"", VAR_40->moduleNameStr) == 1)
                                                        break;    /* COMMENT_60 */
                                                }
                                            }

                                            fseek(VAR_54, VAR_85, VAR_84);    /* COMMENT_61 */
                                        }
                                    }

                                    /* COMMENT_62 */
                                    if((strstr(VAR_51, VAR_28)) != NULL) {
                                        memset (VAR_48, 0, sizeof(*VAR_48));
                                        VAR_49 = strstr(VAR_51, VAR_28);
                                        if (VAR_49 != NULL && sscanf(VAR_49, ""SubmoduleIdentNumber=\""%199[^\""]"", VAR_48) == 1) {
                                            VAR_44 = (guint32) strtoul (VAR_48, NULL, 0);    /* COMMENT_63 */

                                            /* COMMENT_64 */
                                            if(VAR_44 == VAR_40->subModuleIdentNr) {
                                                if((strstr(VAR_51, VAR_29)) != NULL) {
                                                    VAR_40->profisafeSupported = TRUE;   /* COMMENT_65 */
                                                    break;
                                                }
                                                else {    /* COMMENT_66 */
                                                    while(fgets(VAR_51, VAR_56, VAR_54) != NULL) {
                                                        if((strstr(VAR_51, VAR_29)) != NULL) {
                                                            VAR_40->profisafeSupported = TRUE;
                                                            break;    /* COMMENT_67 */
                                                        }

                                                        else if((strstr(VAR_51, "">"")) != NULL) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            break;    /* COMMENT_68 */
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                fclose(VAR_54);
                VAR_54 = NULL;
            }

            switch (VAR_16 & 0x03) {
            case(0x00): /* COMMENT_69 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            case(0x01): /* COMMENT_70 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            case(0x02): /* COMMENT_71 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            case(0x03): /* COMMENT_72 */
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                VAR_1 = dissect_DataDescription(VAR_0, VAR_1, VAR_2, VAR_21, VAR_5, VAR_40);
                break;
            }

            proto_item_append_text(VAR_20, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",
                VAR_14, VAR_15, VAR_16);
            proto_item_set_len(VAR_20, VAR_1 - VAR_24);
        }

        proto_item_set_len(VAR_17, VAR_1 - VAR_19);
    }

    return VAR_1;
}",wireshark/af7b093ca528516c14247acb545046199d30843e/packet-dcerpc-pn-io.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -68,7 +68,8 @@
     /* Initial */
     io_data_object = wmem_new0(wmem_file_scope(), ioDataObject);
     io_data_object->profisafeSupported = FALSE;
-    io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");
+    io_data_object->moduleNameStr = (gchar*)wmem_alloc(wmem_file_scope(), MAX_NAMELENGTH);
+    g_strlcpy(io_data_object->moduleNameStr, ""Unknown"", MAX_NAMELENGTH);
     vendorMatch = FALSE;
     deviceMatch = FALSE;
     gsdmlFoundFlag = FALSE;
@@ -301,7 +302,7 @@
                                                 /* Find a String with the saved TextID and with a fitting value for it in the same line. This value is the name of the Module! */
                                                 if(((strstr(temp, tmp_moduletext)) != NULL) && ((strstr(temp, moduleValueInfo)) != NULL)) {
                                                     pch = strstr(temp, moduleValueInfo);
-                                                    if (sscanf(pch, ""Value=\""%[^\""]"", io_data_object->moduleNameStr) == 1)
+                                                    if (pch != NULL && sscanf(pch, ""Value=\""%199[^\""]"", io_data_object->moduleNameStr) == 1)
                                                         break;    /* Found the name of the module */
                                                 }
                                             }","{'deleted_lines': ['    io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"");', '                                                    if (sscanf(pch, ""Value=\\""%[^\\""]"", io_data_object->moduleNameStr) == 1)'], 'added_lines': ['    io_data_object->moduleNameStr = (gchar*)wmem_alloc(wmem_file_scope(), MAX_NAMELENGTH);', '    g_strlcpy(io_data_object->moduleNameStr, ""Unknown"", MAX_NAMELENGTH);', '                                                    if (pch != NULL && sscanf(pch, ""Value=\\""%199[^\\""]"", io_data_object->moduleNameStr) == 1)']}",True,"In Wireshark 2.4.0 and 2.2.0 to 2.2.8, the Profinet I/O dissector could crash with an out-of-bounds write. This was addressed in plugins/profinet/packet-dcerpc-pn-io.c by adding string validation.",7.5,HIGH,2,test,2017-08-28T17:30:05Z,2
CVE-2017-14169,['CWE-20'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ffmpeg,"avformat/mxfdec: Fix Sign error in mxf_read_primer_pack()

Fixes: 20170829B.mxf

Co-Author: ()"" <wangchu.zhl@alibaba-inc.com>
Found-by: Xiaohei and Wangchu from Alibaba Security Team
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad,https://github.com/FFmpeg/FFmpeg/commit/9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad,libavformat/mxfdec.c,mxf_read_primer_pack,"static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)
{
MXFContext *mxf = arg;
int item_num = avio_rb32(pb);
int item_len = avio_rb32(pb);
if (item_len != 18) {
avpriv_request_sample(pb, ""Primer pack item length %d"", item_len);
return AVERROR_PATCHWELCOME;
}
if (item_num > 65536) {
av_log(mxf->fc, AV_LOG_ERROR, ""item_num %d is too large\n"", item_num);
return AVERROR_INVALIDDATA;
}
if (mxf->local_tags)
av_log(mxf->fc, AV_LOG_VERBOSE, ""Multiple primer packs\n"");
av_free(mxf->local_tags);
mxf->local_tags_count = 0;
mxf->local_tags = av_calloc(item_num, item_len);
if (!mxf->local_tags)
return AVERROR(ENOMEM);
mxf->local_tags_count = item_num;
avio_read(pb, mxf->local_tags, item_num*item_len);
return 0;
}","static int mxf_read_primer_pack(void *VAR_0, AVIOContext *VAR_1, int VAR_2, int VAR_3, UID VAR_4, int64_t VAR_5)
{
MXFContext *VAR_6 = VAR_0;
int VAR_7 = avio_rb32(VAR_1);
int VAR_8 = avio_rb32(VAR_1);
if (VAR_8 != 18) {
avpriv_request_sample(VAR_1, ""Primer pack item length %d"", VAR_8);
return VAR_9;
}
if (VAR_7 > 65536) {
av_log(VAR_6->fc, VAR_10, ""item_num %d is too large\n"", VAR_7);
return VAR_11;
}
if (VAR_6->local_tags)
av_log(VAR_6->fc, VAR_12, ""Multiple primer packs\n"");
av_free(VAR_6->local_tags);
VAR_6->local_tags_count = 0;
VAR_6->local_tags = av_calloc(VAR_7, VAR_8);
if (!VAR_6->local_tags)
return AVERROR(VAR_13);
VAR_6->local_tags_count = VAR_7;
avio_read(VAR_1, VAR_6->local_tags, VAR_7*VAR_8);
return 0;
}",ffmpeg/9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad/mxfdec.c/vul/before/0.json,"static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)
{
    MXFContext *mxf = arg;
    int item_num = avio_rb32(pb);
    int item_len = avio_rb32(pb);

    if (item_len != 18) {
        avpriv_request_sample(pb, ""Primer pack item length %d"", item_len);
        return AVERROR_PATCHWELCOME;
    }
    if (item_num > 65536 || item_num < 0) {
        av_log(mxf->fc, AV_LOG_ERROR, ""item_num %d is too large\n"", item_num);
        return AVERROR_INVALIDDATA;
    }
    if (mxf->local_tags)
        av_log(mxf->fc, AV_LOG_VERBOSE, ""Multiple primer packs\n"");
    av_free(mxf->local_tags);
    mxf->local_tags_count = 0;
    mxf->local_tags = av_calloc(item_num, item_len);
    if (!mxf->local_tags)
        return AVERROR(ENOMEM);
    mxf->local_tags_count = item_num;
    avio_read(pb, mxf->local_tags, item_num*item_len);
    return 0;
}","static int mxf_read_primer_pack(void *VAR_0, AVIOContext *VAR_1, int VAR_2, int VAR_3, UID VAR_4, int64_t VAR_5)
{
    MXFContext *VAR_6 = VAR_0;
    int VAR_7 = avio_rb32(VAR_1);
    int VAR_8 = avio_rb32(VAR_1);

    if (VAR_8 != 18) {
        avpriv_request_sample(VAR_1, ""Primer pack item length %d"", VAR_8);
        return VAR_9;
    }
    if (VAR_7 > 65536 || VAR_7 < 0) {
        av_log(VAR_6->fc, VAR_10, ""item_num %d is too large\n"", VAR_7);
        return VAR_11;
    }
    if (VAR_6->local_tags)
        av_log(VAR_6->fc, VAR_12, ""Multiple primer packs\n"");
    av_free(VAR_6->local_tags);
    VAR_6->local_tags_count = 0;
    VAR_6->local_tags = av_calloc(VAR_7, VAR_8);
    if (!VAR_6->local_tags)
        return AVERROR(VAR_13);
    VAR_6->local_tags_count = VAR_7;
    avio_read(VAR_1, VAR_6->local_tags, VAR_7*VAR_8);
    return 0;
}",ffmpeg/9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad/mxfdec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
         avpriv_request_sample(pb, ""Primer pack item length %d"", item_len);
         return AVERROR_PATCHWELCOME;
     }
-    if (item_num > 65536) {
+    if (item_num > 65536 || item_num < 0) {
         av_log(mxf->fc, AV_LOG_ERROR, ""item_num %d is too large\n"", item_num);
         return AVERROR_INVALIDDATA;
     }","{'deleted_lines': ['    if (item_num > 65536) {'], 'added_lines': ['    if (item_num > 65536 || item_num < 0) {']}",True,"In the mxf_read_primer_pack function in libavformat/mxfdec.c in FFmpeg 3.3.3 -> 2.4, an integer signedness error might occur when a crafted file, which claims a large ""item_num"" field such as 0xffffffff, is provided. As a result, the variable ""item_num"" turns negative, bypassing the check for a large value.",8.8,HIGH,2,test,2017-08-29T21:59:21Z,2
CVE-2017-14171,['CWE-834'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,ffmpeg,"avformat/nsvdec: Fix DoS due to lack of eof check in nsvs_file_offset loop.

Fixes: 20170829.nsv

Co-Author: ()"" <wangchu.zhl@alibaba-inc.com>
Found-by: Xiaohei and Wangchu from Alibaba Security Team
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",c24bcb553650b91e9eff15ef6e54ca73de2453b7,https://github.com/FFmpeg/FFmpeg/commit/c24bcb553650b91e9eff15ef6e54ca73de2453b7,libavformat/nsvdec.c,nsv_parse_NSVf_header,"static int nsv_parse_NSVf_header(AVFormatContext *s)
{
NSVContext *nsv = s->priv_data;
AVIOContext *pb = s->pb;
unsigned int av_unused file_size;
unsigned int size;
int64_t duration;
int strings_size;
int table_entries;
int table_entries_used;
nsv->state = NSV_UNSYNC; 
size = avio_rl32(pb);
if (size < 28)
return -1;
nsv->NSVf_end = size;
file_size = (uint32_t)avio_rl32(pb);
av_log(s, AV_LOG_TRACE, ""NSV NSVf chunk_size %u\n"", size);
av_log(s, AV_LOG_TRACE, ""NSV NSVf file_size %u\n"", file_size);
nsv->duration = duration = avio_rl32(pb); 
av_log(s, AV_LOG_TRACE, ""NSV NSVf duration %""PRId64"" ms\n"", duration);
strings_size = avio_rl32(pb);
table_entries = avio_rl32(pb);
table_entries_used = avio_rl32(pb);
av_log(s, AV_LOG_TRACE, ""NSV NSVf info-strings size: %d, table entries: %d, bis %d\n"",
strings_size, table_entries, table_entries_used);
if (avio_feof(pb))
return -1;
av_log(s, AV_LOG_TRACE, ""NSV got header; filepos %""PRId64""\n"", avio_tell(pb));
if (strings_size > 0) {
char *strings; 
char *p, *endp;
char *token, *value;
char quote;
p = strings = av_mallocz((size_t)strings_size + 1);
if (!p)
return AVERROR(ENOMEM);
endp = strings + strings_size;
avio_read(pb, strings, strings_size);
while (p < endp) {
while (*p == ' ')
p++; 
if (p >= endp-2)
break;
token = p;
p = strchr(p, '=');
if (!p || p >= endp-2)
break;
*p++ = '\0';
quote = *p++;
value = p;
p = strchr(p, quote);
if (!p || p >= endp)
break;
*p++ = '\0';
av_log(s, AV_LOG_TRACE, ""NSV NSVf INFO: %s='%s'\n"", token, value);
av_dict_set(&s->metadata, token, value, 0);
}
av_free(strings);
}
if (avio_feof(pb))
return -1;
av_log(s, AV_LOG_TRACE, ""NSV got infos; filepos %""PRId64""\n"", avio_tell(pb));
if (table_entries_used > 0) {
int i;
nsv->index_entries = table_entries_used;
if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))
return -1;
nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));
if (!nsv->nsvs_file_offset)
return AVERROR(ENOMEM);
for(i=0;i<table_entries_used;i++)
nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;
if(table_entries > table_entries_used &&
avio_rl32(pb) == MKTAG('T','O','C','2')) {
nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));
if (!nsv->nsvs_timestamps)
return AVERROR(ENOMEM);
for(i=0;i<table_entries_used;i++) {
nsv->nsvs_timestamps[i] = avio_rl32(pb);
}
}
}
av_log(s, AV_LOG_TRACE, ""NSV got index; filepos %""PRId64""\n"", avio_tell(pb));
avio_seek(pb, nsv->base_offset + size, SEEK_SET); 
if (avio_feof(pb))
return -1;
nsv->state = NSV_HAS_READ_NSVF;
return 0;
}","static int nsv_parse_NSVf_header(AVFormatContext *VAR_0)
{
NSVContext *VAR_1 = VAR_0->priv_data;
AVIOContext *VAR_2 = VAR_0->pb;
unsigned int VAR_3 VAR_4;
unsigned int VAR_5;
int64_t VAR_6;
int VAR_7;
int VAR_8;
int VAR_9;
VAR_1->state = VAR_10; 
VAR_5 = avio_rl32(VAR_2);
if (VAR_5 < 28)
return -1;
VAR_1->NSVf_end = VAR_5;
VAR_4 = (uint32_t)avio_rl32(VAR_2);
av_log(VAR_0, VAR_11, ""NSV NSVf chunk_size %u\n"", VAR_5);
av_log(VAR_0, VAR_11, ""NSV NSVf file_size %u\n"", VAR_4);
VAR_1->duration = VAR_6 = avio_rl32(VAR_2); 
av_log(VAR_0, VAR_11, ""NSV NSVf duration %""VAR_12"" ms\n"", VAR_6);
VAR_7 = avio_rl32(VAR_2);
VAR_8 = avio_rl32(VAR_2);
VAR_9 = avio_rl32(VAR_2);
av_log(VAR_0, VAR_11, ""NSV NSVf info-strings size: %d, table entries: %d, bis %d\n"",
VAR_7, VAR_8, VAR_9);
if (avio_feof(VAR_2))
return -1;
av_log(VAR_0, VAR_11, ""NSV got header; filepos %""VAR_12""\n"", avio_tell(VAR_2));
if (VAR_7 > 0) {
char *VAR_13; 
char *VAR_14, *VAR_15;
char *VAR_16, *VAR_17;
char VAR_18;
VAR_14 = VAR_13 = av_mallocz((size_t)VAR_7 + 1);
if (!VAR_14)
return AVERROR(VAR_19);
VAR_15 = VAR_13 + VAR_7;
avio_read(VAR_2, VAR_13, VAR_7);
while (VAR_14 < VAR_15) {
while (*VAR_14 == ' ')
VAR_14++; 
if (VAR_14 >= VAR_15-2)
break;
VAR_16 = VAR_14;
VAR_14 = strchr(VAR_14, '=');
if (!VAR_14 || VAR_14 >= VAR_15-2)
break;
*VAR_14++ = '\0';
VAR_18 = *VAR_14++;
VAR_17 = VAR_14;
VAR_14 = strchr(VAR_14, VAR_18);
if (!VAR_14 || VAR_14 >= VAR_15)
break;
*VAR_14++ = '\0';
av_log(VAR_0, VAR_11, ""NSV NSVf INFO: %s='%s'\n"", VAR_16, VAR_17);
av_dict_set(&VAR_0->metadata, VAR_16, VAR_17, 0);
}
av_free(VAR_13);
}
if (avio_feof(VAR_2))
return -1;
av_log(VAR_0, VAR_11, ""NSV got infos; filepos %""VAR_12""\n"", avio_tell(VAR_2));
if (VAR_9 > 0) {
int VAR_20;
VAR_1->index_entries = VAR_9;
if((unsigned)VAR_9 >= VAR_21 / sizeof(uint32_t))
return -1;
VAR_1->nsvs_file_offset = av_malloc_array((unsigned)VAR_9, sizeof(uint32_t));
if (!VAR_1->nsvs_file_offset)
return AVERROR(VAR_19);
for(VAR_20=0;VAR_20<VAR_9;VAR_20++)
VAR_1->nsvs_file_offset[VAR_20] = avio_rl32(VAR_2) + VAR_5;
if(VAR_8 > VAR_9 &&
avio_rl32(VAR_2) == MKTAG('T','O','C','2')) {
VAR_1->nsvs_timestamps = av_malloc_array((unsigned)VAR_9, sizeof(uint32_t));
if (!VAR_1->nsvs_timestamps)
return AVERROR(VAR_19);
for(VAR_20=0;VAR_20<VAR_9;VAR_20++) {
VAR_1->nsvs_timestamps[VAR_20] = avio_rl32(VAR_2);
}
}
}
av_log(VAR_0, VAR_11, ""NSV got index; filepos %""VAR_12""\n"", avio_tell(VAR_2));
avio_seek(VAR_2, VAR_1->base_offset + VAR_5, VAR_22); 
if (avio_feof(VAR_2))
return -1;
VAR_1->state = VAR_23;
return 0;
}",ffmpeg/c24bcb553650b91e9eff15ef6e54ca73de2453b7/nsvdec.c/vul/before/0.json,"static int nsv_parse_NSVf_header(AVFormatContext *s)
{
    NSVContext *nsv = s->priv_data;
    AVIOContext *pb = s->pb;
    unsigned int av_unused file_size;
    unsigned int size;
    int64_t duration;
    int strings_size;
    int table_entries;
    int table_entries_used;

    nsv->state = NSV_UNSYNC; /* in case we fail */

    size = avio_rl32(pb);
    if (size < 28)
        return -1;
    nsv->NSVf_end = size;

    file_size = (uint32_t)avio_rl32(pb);
    av_log(s, AV_LOG_TRACE, ""NSV NSVf chunk_size %u\n"", size);
    av_log(s, AV_LOG_TRACE, ""NSV NSVf file_size %u\n"", file_size);

    nsv->duration = duration = avio_rl32(pb); /* in ms */
    av_log(s, AV_LOG_TRACE, ""NSV NSVf duration %""PRId64"" ms\n"", duration);
    // XXX: store it in AVStreams

    strings_size = avio_rl32(pb);
    table_entries = avio_rl32(pb);
    table_entries_used = avio_rl32(pb);
    av_log(s, AV_LOG_TRACE, ""NSV NSVf info-strings size: %d, table entries: %d, bis %d\n"",
            strings_size, table_entries, table_entries_used);
    if (avio_feof(pb))
        return -1;

    av_log(s, AV_LOG_TRACE, ""NSV got header; filepos %""PRId64""\n"", avio_tell(pb));

    if (strings_size > 0) {
        char *strings; /* last byte will be '\0' to play safe with str*() */
        char *p, *endp;
        char *token, *value;
        char quote;

        p = strings = av_mallocz((size_t)strings_size + 1);
        if (!p)
            return AVERROR(ENOMEM);
        endp = strings + strings_size;
        avio_read(pb, strings, strings_size);
        while (p < endp) {
            while (*p == ' ')
                p++; /* strip out spaces */
            if (p >= endp-2)
                break;
            token = p;
            p = strchr(p, '=');
            if (!p || p >= endp-2)
                break;
            *p++ = '\0';
            quote = *p++;
            value = p;
            p = strchr(p, quote);
            if (!p || p >= endp)
                break;
            *p++ = '\0';
            av_log(s, AV_LOG_TRACE, ""NSV NSVf INFO: %s='%s'\n"", token, value);
            av_dict_set(&s->metadata, token, value, 0);
        }
        av_free(strings);
    }
    if (avio_feof(pb))
        return -1;

    av_log(s, AV_LOG_TRACE, ""NSV got infos; filepos %""PRId64""\n"", avio_tell(pb));

    if (table_entries_used > 0) {
        int i;
        nsv->index_entries = table_entries_used;
        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))
            return -1;
        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));
        if (!nsv->nsvs_file_offset)
            return AVERROR(ENOMEM);

        for(i=0;i<table_entries_used;i++) {
            if (avio_feof(pb))
                return AVERROR_INVALIDDATA;
            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;
        }

        if(table_entries > table_entries_used &&
           avio_rl32(pb) == MKTAG('T','O','C','2')) {
            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));
            if (!nsv->nsvs_timestamps)
                return AVERROR(ENOMEM);
            for(i=0;i<table_entries_used;i++) {
                nsv->nsvs_timestamps[i] = avio_rl32(pb);
            }
        }
    }

    av_log(s, AV_LOG_TRACE, ""NSV got index; filepos %""PRId64""\n"", avio_tell(pb));

    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */

    if (avio_feof(pb))
        return -1;
    nsv->state = NSV_HAS_READ_NSVF;
    return 0;
}","static int nsv_parse_NSVf_header(AVFormatContext *VAR_0)
{
    NSVContext *VAR_1 = VAR_0->priv_data;
    AVIOContext *VAR_2 = VAR_0->pb;
    unsigned int VAR_3 VAR_4;
    unsigned int VAR_5;
    int64_t VAR_6;
    int VAR_7;
    int VAR_8;
    int VAR_9;

    VAR_1->state = VAR_10; /* COMMENT_0 */

    VAR_5 = avio_rl32(VAR_2);
    if (VAR_5 < 28)
        return -1;
    VAR_1->NSVf_end = VAR_5;

    VAR_4 = (uint32_t)avio_rl32(VAR_2);
    av_log(VAR_0, VAR_11, ""NSV NSVf chunk_size %u\n"", VAR_5);
    av_log(VAR_0, VAR_11, ""NSV NSVf file_size %u\n"", VAR_4);

    VAR_1->duration = VAR_6 = avio_rl32(VAR_2); /* COMMENT_1 */
    av_log(VAR_0, VAR_11, ""NSV NSVf duration %""VAR_12"" ms\n"", VAR_6);
    /* COMMENT_2 */

    VAR_7 = avio_rl32(VAR_2);
    VAR_8 = avio_rl32(VAR_2);
    VAR_9 = avio_rl32(VAR_2);
    av_log(VAR_0, VAR_11, ""NSV NSVf info-strings size: %d, table entries: %d, bis %d\n"",
            VAR_7, VAR_8, VAR_9);
    if (avio_feof(VAR_2))
        return -1;

    av_log(VAR_0, VAR_11, ""NSV got header; filepos %""VAR_12""\n"", avio_tell(VAR_2));

    if (VAR_7 > 0) {
        char *VAR_13; /* COMMENT_3 */
        char *VAR_14, *VAR_15;
        char *VAR_16, *VAR_17;
        char VAR_18;

        VAR_14 = VAR_13 = av_mallocz((size_t)VAR_7 + 1);
        if (!VAR_14)
            return AVERROR(VAR_19);
        VAR_15 = VAR_13 + VAR_7;
        avio_read(VAR_2, VAR_13, VAR_7);
        while (VAR_14 < VAR_15) {
            while (*VAR_14 == ' ')
                VAR_14++; /* COMMENT_4 */
            if (VAR_14 >= VAR_15-2)
                break;
            VAR_16 = VAR_14;
            VAR_14 = strchr(VAR_14, '=');
            if (!VAR_14 || VAR_14 >= VAR_15-2)
                break;
            *VAR_14++ = '\0';
            VAR_18 = *VAR_14++;
            VAR_17 = VAR_14;
            VAR_14 = strchr(VAR_14, VAR_18);
            if (!VAR_14 || VAR_14 >= VAR_15)
                break;
            *VAR_14++ = '\0';
            av_log(VAR_0, VAR_11, ""NSV NSVf INFO: %s='%s'\n"", VAR_16, VAR_17);
            av_dict_set(&VAR_0->metadata, VAR_16, VAR_17, 0);
        }
        av_free(VAR_13);
    }
    if (avio_feof(VAR_2))
        return -1;

    av_log(VAR_0, VAR_11, ""NSV got infos; filepos %""VAR_12""\n"", avio_tell(VAR_2));

    if (VAR_9 > 0) {
        int VAR_20;
        VAR_1->index_entries = VAR_9;
        if((unsigned)VAR_9 >= VAR_21 / sizeof(uint32_t))
            return -1;
        VAR_1->nsvs_file_offset = av_malloc_array((unsigned)VAR_9, sizeof(uint32_t));
        if (!VAR_1->nsvs_file_offset)
            return AVERROR(VAR_19);

        for(VAR_20=0;VAR_20<VAR_9;VAR_20++) {
            if (avio_feof(VAR_2))
                return VAR_22;
            VAR_1->nsvs_file_offset[VAR_20] = avio_rl32(VAR_2) + VAR_5;
        }

        if(VAR_8 > VAR_9 &&
           avio_rl32(VAR_2) == MKTAG('T','O','C','2')) {
            VAR_1->nsvs_timestamps = av_malloc_array((unsigned)VAR_9, sizeof(uint32_t));
            if (!VAR_1->nsvs_timestamps)
                return AVERROR(VAR_19);
            for(VAR_20=0;VAR_20<VAR_9;VAR_20++) {
                VAR_1->nsvs_timestamps[VAR_20] = avio_rl32(VAR_2);
            }
        }
    }

    av_log(VAR_0, VAR_11, ""NSV got index; filepos %""VAR_12""\n"", avio_tell(VAR_2));

    avio_seek(VAR_2, VAR_1->base_offset + VAR_5, VAR_23); /* COMMENT_5 */

    if (avio_feof(VAR_2))
        return -1;
    VAR_1->state = VAR_24;
    return 0;
}",ffmpeg/c24bcb553650b91e9eff15ef6e54ca73de2453b7/nsvdec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -80,8 +80,11 @@
         if (!nsv->nsvs_file_offset)
             return AVERROR(ENOMEM);
 
-        for(i=0;i<table_entries_used;i++)
+        for(i=0;i<table_entries_used;i++) {
+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;
             nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;
+        }
 
         if(table_entries > table_entries_used &&
            avio_rl32(pb) == MKTAG('T','O','C','2')) {","{'deleted_lines': ['        for(i=0;i<table_entries_used;i++)'], 'added_lines': ['        for(i=0;i<table_entries_used;i++) {', '            if (avio_feof(pb))', '                return AVERROR_INVALIDDATA;', '        }']}",True,"In libavformat/nsvdec.c in FFmpeg 2.4 and 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large ""table_entries_used"" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.",6.5,MEDIUM,1,test,2017-08-29T21:59:21Z,2
CVE-2017-14060,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/710,c535e1f1a6b1faaa35e007df4fc535ec08daa97c,https://github.com/ImageMagick/ImageMagick/commit/c535e1f1a6b1faaa35e007df4fc535ec08daa97c,coders/cut.c,ReadCUTImage,"static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image *image,*palette;
ImageInfo *clone_info;
MagickBooleanType status;
MagickOffsetType
offset;
size_t EncodedByte;
unsigned char RunCount,RunValue,RunCountMasked;
CUTHeader  Header;
CUTPalHeader PalHeader;
ssize_t depth;
ssize_t i,j;
ssize_t ldblk;
unsigned char *BImgBuff=NULL,*ptrB;
register Quantum *q;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
palette=NULL;
clone_info=NULL;
Header.Width=ReadBlobLSBShort(image);
Header.Height=ReadBlobLSBShort(image);
Header.Reserved=ReadBlobLSBShort(image);
if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)
CUT_KO:  ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
EncodedByte=ReadBlobLSBShort(image);
RunCount=(unsigned char) ReadBlobByte(image);
RunCountMasked=RunCount & 0x7F;
ldblk=0;
while((int) RunCountMasked!=0)  
{
i=1;
if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;
offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);
if (offset < 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if(EOFBlob(image) != MagickFalse) goto CUT_KO;  
EncodedByte-=i+1;
ldblk+=(ssize_t) RunCountMasked;
RunCount=(unsigned char) ReadBlobByte(image);
if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  
RunCountMasked=RunCount & 0x7F;
}
if(EncodedByte!=1) goto CUT_KO;  
i=0;        
if(ldblk==(int) Header.Width)   i=8;
if(2*ldblk==(int) Header.Width) i=4;
if(8*ldblk==(int) Header.Width) i=1;
if(i==0) goto CUT_KO;    
depth=i;
image->columns=Header.Width;
image->rows=Header.Height;
image->depth=8;
image->colors=(size_t) (GetQuantumRange(1UL*i)+1);
if (image_info->ping != MagickFalse) goto Finish;
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;
i=(ssize_t) strlen(clone_info->filename);
j=i;
while(--i>0)
{
if(clone_info->filename[i]=='.')
{
break;
}
if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\' ||
clone_info->filename[i]==':' )
{
i=j;
break;
}
}
(void) CopyMagickString(clone_info->filename+i,"".PAL"",(size_t)
(MagickPathExtent-i));
if((clone_info->file=fopen_utf8(clone_info->filename,""rb""))==NULL)
{
(void) CopyMagickString(clone_info->filename+i,"".pal"",(size_t)
(MagickPathExtent-i));
if((clone_info->file=fopen_utf8(clone_info->filename,""rb""))==NULL)
{
clone_info->filename[i]='\0';
if((clone_info->file=fopen_utf8(clone_info->filename,""rb""))==NULL)
{
clone_info=DestroyImageInfo(clone_info);
clone_info=NULL;
goto NoPalette;
}
}
}
if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;
status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
ErasePalette:
palette=DestroyImage(palette);
palette=NULL;
goto NoPalette;
}
if(palette!=NULL)
{
(void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);
if(strncmp(PalHeader.FileId,""AH"",2) != 0) goto ErasePalette;
PalHeader.Version=ReadBlobLSBShort(palette);
PalHeader.Size=ReadBlobLSBShort(palette);
PalHeader.FileType=(char) ReadBlobByte(palette);
PalHeader.SubType=(char) ReadBlobByte(palette);
PalHeader.BoardID=ReadBlobLSBShort(palette);
PalHeader.GraphicsMode=ReadBlobLSBShort(palette);
PalHeader.MaxIndex=ReadBlobLSBShort(palette);
PalHeader.MaxRed=ReadBlobLSBShort(palette);
PalHeader.MaxGreen=ReadBlobLSBShort(palette);
PalHeader.MaxBlue=ReadBlobLSBShort(palette);
(void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);
if(PalHeader.MaxIndex<1) goto ErasePalette;
image->colors=PalHeader.MaxIndex+1;
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;
if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  
if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;
if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;
for(i=0;i<=(int) PalHeader.MaxIndex;i++)
{      
j=(ssize_t) TellBlob(palette);
if((j % 512)>512-6)
{
j=((j / 512)+1)*512;
offset=SeekBlob(palette,j,SEEK_SET);
if (offset < 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);
if (QuantumRange != (Quantum) PalHeader.MaxRed)
{
image->colormap[i].red=ClampToQuantum(((double)
image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/
PalHeader.MaxRed);
}
image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);
if (QuantumRange != (Quantum) PalHeader.MaxGreen)
{
image->colormap[i].green=ClampToQuantum
(((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);
}
image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);
if (QuantumRange != (Quantum) PalHeader.MaxBlue)
{
image->colormap[i].blue=ClampToQuantum
(((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);
}
}
}
NoPalette:
if(palette==NULL)
{
image->colors=256;
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
{
NoMemory:
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
for (i=0; i < (ssize_t)image->colors; i++)
{
image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);
image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);
image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);
}
}
BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
sizeof(*BImgBuff));  
if(BImgBuff==NULL) goto NoMemory;
offset=SeekBlob(image,6 ,SEEK_SET);
if (offset < 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
for (i=0; i < (int) Header.Height; i++)
{
EncodedByte=ReadBlobLSBShort(image);
ptrB=BImgBuff;
j=ldblk;
RunCount=(unsigned char) ReadBlobByte(image);
RunCountMasked=RunCount & 0x7F;
while ((int) RunCountMasked != 0)
{
if((ssize_t) RunCountMasked>j)
{    
RunCountMasked=(unsigned char) j;
if(j==0)
{
break;
}
}
if((int) RunCount>0x80)
{
RunValue=(unsigned char) ReadBlobByte(image);
(void) ResetMagickMemory(ptrB,(int) RunValue,(size_t) RunCountMasked);
}
else {
(void) ReadBlob(image,(size_t) RunCountMasked,ptrB);
}
ptrB+=(int) RunCountMasked;
j-=(int) RunCountMasked;
if (EOFBlob(image) != MagickFalse) goto Finish;  
RunCount=(unsigned char) ReadBlobByte(image);
RunCountMasked=RunCount & 0x7F;
}
InsertRow(image,depth,BImgBuff,i,exception);
}
(void) SyncImage(image,exception);
if(palette==NULL)
{    
if ((image->storage_class == PseudoClass) &&
(SetImageGray(image,exception) != MagickFalse))
{
if(GetCutColors(image,exception)==2)
{
for (i=0; i < (ssize_t)image->colors; i++)
{
register Quantum
sample;
sample=ScaleCharToQuantum((unsigned char) i);
if(image->colormap[i].red!=sample) goto Finish;
if(image->colormap[i].green!=sample) goto Finish;
if(image->colormap[i].blue!=sample) goto Finish;
}
image->colormap[1].red=image->colormap[1].green=
image->colormap[1].blue=QuantumRange;
for (i=0; i < (ssize_t)image->rows; i++)
{
q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);
for (j=0; j < (ssize_t)image->columns; j++)
{
if (GetPixelRed(image,q) == ScaleCharToQuantum(1))
{
SetPixelRed(image,QuantumRange,q);
SetPixelGreen(image,QuantumRange,q);
SetPixelBlue(image,QuantumRange,q);
}
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;
}
}
}
}
Finish:
if (BImgBuff != NULL)
BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
if (palette != NULL)
palette=DestroyImage(palette);
if (clone_info != NULL)
clone_info=DestroyImageInfo(clone_info);
if (EOFBlob(image) != MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadCUTImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image *VAR_2,*VAR_3;
ImageInfo *VAR_4;
MagickBooleanType VAR_5;
MagickOffsetType
VAR_6;
size_t VAR_7;
unsigned char VAR_8,VAR_9,VAR_10;
CUTHeader  VAR_11;
CUTPalHeader VAR_12;
ssize_t VAR_13;
ssize_t VAR_14,VAR_15;
ssize_t VAR_16;
unsigned char *VAR_17=NULL,*VAR_18;
register Quantum *VAR_19;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_20);
if (VAR_0->debug != VAR_21)
(void) LogMagickEvent(VAR_22,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_20);
VAR_2=AcquireImage(VAR_0,VAR_1);
VAR_5=OpenBlob(VAR_0,VAR_2,VAR_23,VAR_1);
if (VAR_5 == VAR_21)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_3=NULL;
VAR_4=NULL;
VAR_11.Width=ReadBlobLSBShort(VAR_2);
VAR_11.Height=ReadBlobLSBShort(VAR_2);
VAR_11.Reserved=ReadBlobLSBShort(VAR_2);
if (VAR_11.Width==0 || VAR_11.Height==0 || VAR_11.Reserved!=0)
CUT_KO:  ThrowReaderException(VAR_24,""ImproperImageHeader"");
VAR_7=ReadBlobLSBShort(VAR_2);
VAR_8=(unsigned char) ReadBlobByte(VAR_2);
VAR_10=VAR_8 & 0x7F;
VAR_16=0;
while((int) VAR_10!=0)  
{
VAR_14=1;
if((int) VAR_8<0x80) VAR_14=(ssize_t) VAR_10;
VAR_6=SeekBlob(VAR_2,TellBlob(VAR_2)+VAR_14,VAR_25);
if (VAR_6 < 0)
ThrowReaderException(VAR_24,""ImproperImageHeader"");
if(EOFBlob(VAR_2) != VAR_21) goto CUT_KO;  
VAR_7-=VAR_14+1;
VAR_16+=(ssize_t) VAR_10;
VAR_8=(unsigned char) ReadBlobByte(VAR_2);
if(EOFBlob(VAR_2) != VAR_21)  goto CUT_KO;  
VAR_10=VAR_8 & 0x7F;
}
if(VAR_7!=1) goto CUT_KO;  
VAR_14=0;        
if(VAR_16==(int) VAR_11.Width)   VAR_14=8;
if(2*VAR_16==(int) VAR_11.Width) VAR_14=4;
if(8*VAR_16==(int) VAR_11.Width) VAR_14=1;
if(VAR_14==0) goto CUT_KO;    
VAR_13=VAR_14;
VAR_2->columns=VAR_11.Width;
VAR_2->rows=VAR_11.Height;
VAR_2->depth=8;
VAR_2->colors=(size_t) (GetQuantumRange(1UL*VAR_14)+1);
if (VAR_0->ping != VAR_21) goto Finish;
VAR_5=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows,VAR_1);
if (VAR_5 == VAR_21)
return(DestroyImageList(VAR_2));
if ((VAR_4=CloneImageInfo(VAR_0)) == NULL) goto NoPalette;
VAR_14=(ssize_t) strlen(VAR_4->filename);
VAR_15=VAR_14;
while(--VAR_14>0)
{
if(VAR_4->filename[VAR_14]=='.')
{
break;
}
if(VAR_4->filename[VAR_14]=='/' || VAR_4->filename[VAR_14]=='\\' ||
VAR_4->filename[VAR_14]==':' )
{
VAR_14=VAR_15;
break;
}
}
(void) CopyMagickString(VAR_4->filename+VAR_14,"".PAL"",(size_t)
(VAR_26-VAR_14));
if((VAR_4->file=fopen_utf8(VAR_4->filename,""rb""))==NULL)
{
(void) CopyMagickString(VAR_4->filename+VAR_14,"".pal"",(size_t)
(VAR_26-VAR_14));
if((VAR_4->file=fopen_utf8(VAR_4->filename,""rb""))==NULL)
{
VAR_4->filename[VAR_14]='\0';
if((VAR_4->file=fopen_utf8(VAR_4->filename,""rb""))==NULL)
{
VAR_4=DestroyImageInfo(VAR_4);
VAR_4=NULL;
goto NoPalette;
}
}
}
if( (VAR_3=AcquireImage(VAR_4,VAR_1))==NULL ) goto NoPalette;
VAR_5=OpenBlob(VAR_4,VAR_3,VAR_23,VAR_1);
if (VAR_5 == VAR_21)
{
ErasePalette:
VAR_3=DestroyImage(VAR_3);
VAR_3=NULL;
goto NoPalette;
}
if(VAR_3!=NULL)
{
(void) ReadBlob(VAR_3,2,(unsigned char *) VAR_12.FileId);
if(strncmp(VAR_12.FileId,""AH"",2) != 0) goto ErasePalette;
VAR_12.Version=ReadBlobLSBShort(VAR_3);
VAR_12.Size=ReadBlobLSBShort(VAR_3);
VAR_12.FileType=(char) ReadBlobByte(VAR_3);
VAR_12.SubType=(char) ReadBlobByte(VAR_3);
VAR_12.BoardID=ReadBlobLSBShort(VAR_3);
VAR_12.GraphicsMode=ReadBlobLSBShort(VAR_3);
VAR_12.MaxIndex=ReadBlobLSBShort(VAR_3);
VAR_12.MaxRed=ReadBlobLSBShort(VAR_3);
VAR_12.MaxGreen=ReadBlobLSBShort(VAR_3);
VAR_12.MaxBlue=ReadBlobLSBShort(VAR_3);
(void) ReadBlob(VAR_3,20,(unsigned char *) VAR_12.PaletteId);
if(VAR_12.MaxIndex<1) goto ErasePalette;
VAR_2->colors=VAR_12.MaxIndex+1;
if (AcquireImageColormap(VAR_2,VAR_2->colors,VAR_1) == VAR_21) goto NoMemory;
if(VAR_12.MaxRed==0) VAR_12.MaxRed=(unsigned int) VAR_27;  
if(VAR_12.MaxGreen==0) VAR_12.MaxGreen=(unsigned int) VAR_27;
if(VAR_12.MaxBlue==0) VAR_12.MaxBlue=(unsigned int) VAR_27;
for(VAR_14=0;VAR_14<=(int) VAR_12.MaxIndex;VAR_14++)
{      
VAR_15=(ssize_t) TellBlob(VAR_3);
if((VAR_15 % 512)>512-6)
{
VAR_15=((VAR_15 / 512)+1)*512;
VAR_6=SeekBlob(VAR_3,VAR_15,VAR_25);
if (VAR_6 < 0)
ThrowReaderException(VAR_24,""ImproperImageHeader"");
}
VAR_2->colormap[VAR_14].red=(Quantum) ReadBlobLSBShort(VAR_3);
if (VAR_27 != (Quantum) VAR_12.MaxRed)
{
VAR_2->colormap[VAR_14].red=ClampToQuantum(((double)
VAR_2->colormap[VAR_14].red*VAR_27+(VAR_12.MaxRed>>1))/
VAR_12.MaxRed);
}
VAR_2->colormap[VAR_14].green=(Quantum) ReadBlobLSBShort(VAR_3);
if (VAR_27 != (Quantum) VAR_12.MaxGreen)
{
VAR_2->colormap[VAR_14].green=ClampToQuantum
(((double) VAR_2->colormap[VAR_14].green*VAR_27+(VAR_12.MaxGreen>>1))/VAR_12.MaxGreen);
}
VAR_2->colormap[VAR_14].blue=(Quantum) ReadBlobLSBShort(VAR_3);
if (VAR_27 != (Quantum) VAR_12.MaxBlue)
{
VAR_2->colormap[VAR_14].blue=ClampToQuantum
(((double)VAR_2->colormap[VAR_14].blue*VAR_27+(VAR_12.MaxBlue>>1))/VAR_12.MaxBlue);
}
}
}
NoPalette:
if(VAR_3==NULL)
{
VAR_2->colors=256;
if (AcquireImageColormap(VAR_2,VAR_2->colors,VAR_1) == VAR_21)
{
NoMemory:
ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
}
for (VAR_14=0; VAR_14 < (ssize_t)VAR_2->colors; VAR_14++)
{
VAR_2->colormap[VAR_14].red=ScaleCharToQuantum((unsigned char) VAR_14);
VAR_2->colormap[VAR_14].green=ScaleCharToQuantum((unsigned char) VAR_14);
VAR_2->colormap[VAR_14].blue=ScaleCharToQuantum((unsigned char) VAR_14);
}
}
VAR_17=(unsigned char *) AcquireQuantumMemory((size_t) VAR_16,
sizeof(*VAR_17));  
if(VAR_17==NULL) goto NoMemory;
VAR_6=SeekBlob(VAR_2,6 ,VAR_25);
if (VAR_6 < 0)
ThrowReaderException(VAR_24,""ImproperImageHeader"");
for (VAR_14=0; VAR_14 < (int) VAR_11.Height; VAR_14++)
{
VAR_7=ReadBlobLSBShort(VAR_2);
VAR_18=VAR_17;
VAR_15=VAR_16;
VAR_8=(unsigned char) ReadBlobByte(VAR_2);
VAR_10=VAR_8 & 0x7F;
while ((int) VAR_10 != 0)
{
if((ssize_t) VAR_10>VAR_15)
{    
VAR_10=(unsigned char) VAR_15;
if(VAR_15==0)
{
break;
}
}
if((int) VAR_8>0x80)
{
VAR_9=(unsigned char) ReadBlobByte(VAR_2);
(void) ResetMagickMemory(VAR_18,(int) VAR_9,(size_t) VAR_10);
}
else {
(void) ReadBlob(VAR_2,(size_t) VAR_10,VAR_18);
}
VAR_18+=(int) VAR_10;
VAR_15-=(int) VAR_10;
if (EOFBlob(VAR_2) != VAR_21) goto Finish;  
VAR_8=(unsigned char) ReadBlobByte(VAR_2);
VAR_10=VAR_8 & 0x7F;
}
InsertRow(VAR_2,VAR_13,VAR_17,VAR_14,VAR_1);
}
(void) SyncImage(VAR_2,VAR_1);
if(VAR_3==NULL)
{    
if ((VAR_2->storage_class == VAR_29) &&
(SetImageGray(VAR_2,VAR_1) != VAR_21))
{
if(GetCutColors(VAR_2,VAR_1)==2)
{
for (VAR_14=0; VAR_14 < (ssize_t)VAR_2->colors; VAR_14++)
{
register Quantum
VAR_30;
VAR_30=ScaleCharToQuantum((unsigned char) VAR_14);
if(VAR_2->colormap[VAR_14].red!=VAR_30) goto Finish;
if(VAR_2->colormap[VAR_14].green!=VAR_30) goto Finish;
if(VAR_2->colormap[VAR_14].blue!=VAR_30) goto Finish;
}
VAR_2->colormap[1].red=VAR_2->colormap[1].green=
VAR_2->colormap[1].blue=VAR_27;
for (VAR_14=0; VAR_14 < (ssize_t)VAR_2->rows; VAR_14++)
{
VAR_19=QueueAuthenticPixels(VAR_2,0,VAR_14,VAR_2->columns,1,VAR_1);
for (VAR_15=0; VAR_15 < (ssize_t)VAR_2->columns; VAR_15++)
{
if (GetPixelRed(VAR_2,VAR_19) == ScaleCharToQuantum(1))
{
SetPixelRed(VAR_2,VAR_27,VAR_19);
SetPixelGreen(VAR_2,VAR_27,VAR_19);
SetPixelBlue(VAR_2,VAR_27,VAR_19);
}
VAR_19+=GetPixelChannels(VAR_2);
}
if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_21) goto Finish;
}
}
}
}
Finish:
if (VAR_17 != NULL)
VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17);
if (VAR_3 != NULL)
VAR_3=DestroyImage(VAR_3);
if (VAR_4 != NULL)
VAR_4=DestroyImageInfo(VAR_4);
if (EOFBlob(VAR_2) != VAR_21)
ThrowFileException(VAR_1,VAR_24,""UnexpectedEndOfFile"",
VAR_2->filename);
(void) CloseBlob(VAR_2);
return(GetFirstImageInList(VAR_2));
}",ImageMagick/c535e1f1a6b1faaa35e007df4fc535ec08daa97c/cut.c/vul/before/0.json,"static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image,*palette;
  ImageInfo *clone_info;
  MagickBooleanType status;

  MagickOffsetType
    offset;

  size_t EncodedByte;
  unsigned char RunCount,RunValue,RunCountMasked;
  CUTHeader  Header;
  CUTPalHeader PalHeader;
  ssize_t depth;
  ssize_t i,j;
  ssize_t ldblk;
  unsigned char *BImgBuff=NULL,*ptrB;
  register Quantum *q;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read CUT image.
  */
  palette=NULL;
  clone_info=NULL;
  Header.Width=ReadBlobLSBShort(image);
  Header.Height=ReadBlobLSBShort(image);
  Header.Reserved=ReadBlobLSBShort(image);

  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)
    CUT_KO:  ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  /*---This code checks first line of image---*/
  EncodedByte=ReadBlobLSBShort(image);
  RunCount=(unsigned char) ReadBlobByte(image);
  RunCountMasked=RunCount & 0x7F;
  ldblk=0;
  while((int) RunCountMasked!=0)  /*end of line?*/
    {
      i=1;
      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;
      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);
      if (offset < 0)
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/
      EncodedByte-=i+1;
      ldblk+=(ssize_t) RunCountMasked;

      RunCount=(unsigned char) ReadBlobByte(image);
      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/
      RunCountMasked=RunCount & 0x7F;
    }
  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/
  i=0;        /*guess a number of bit planes*/
  if(ldblk==(int) Header.Width)   i=8;
  if(2*ldblk==(int) Header.Width) i=4;
  if(8*ldblk==(int) Header.Width) i=1;
  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/
  depth=i;

  image->columns=Header.Width;
  image->rows=Header.Height;
  image->depth=8;
  image->colors=(size_t) (GetQuantumRange(1UL*i)+1);

  if (image_info->ping != MagickFalse) goto Finish;
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));

  /* ----- Do something with palette ----- */
  if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;


  i=(ssize_t) strlen(clone_info->filename);
  j=i;
  while(--i>0)
    {
      if(clone_info->filename[i]=='.')
        {
          break;
        }
      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\' ||
         clone_info->filename[i]==':' )
        {
          i=j;
          break;
        }
    }

  (void) CopyMagickString(clone_info->filename+i,"".PAL"",(size_t)
    (MagickPathExtent-i));
  if((clone_info->file=fopen_utf8(clone_info->filename,""rb""))==NULL)
    {
      (void) CopyMagickString(clone_info->filename+i,"".pal"",(size_t)
        (MagickPathExtent-i));
      if((clone_info->file=fopen_utf8(clone_info->filename,""rb""))==NULL)
        {
          clone_info->filename[i]='\0';
          if((clone_info->file=fopen_utf8(clone_info->filename,""rb""))==NULL)
            {
              clone_info=DestroyImageInfo(clone_info);
              clone_info=NULL;
              goto NoPalette;
            }
        }
    }

  if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;
  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
    ErasePalette:
      palette=DestroyImage(palette);
      palette=NULL;
      goto NoPalette;
    }


  if(palette!=NULL)
    {
      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);
      if(strncmp(PalHeader.FileId,""AH"",2) != 0) goto ErasePalette;
      PalHeader.Version=ReadBlobLSBShort(palette);
      PalHeader.Size=ReadBlobLSBShort(palette);
      PalHeader.FileType=(char) ReadBlobByte(palette);
      PalHeader.SubType=(char) ReadBlobByte(palette);
      PalHeader.BoardID=ReadBlobLSBShort(palette);
      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);
      PalHeader.MaxIndex=ReadBlobLSBShort(palette);
      PalHeader.MaxRed=ReadBlobLSBShort(palette);
      PalHeader.MaxGreen=ReadBlobLSBShort(palette);
      PalHeader.MaxBlue=ReadBlobLSBShort(palette);
      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);

      if(PalHeader.MaxIndex<1) goto ErasePalette;
      image->colors=PalHeader.MaxIndex+1;
      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;

      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/
      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;
      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;

      for(i=0;i<=(int) PalHeader.MaxIndex;i++)
        {      /*this may be wrong- I don't know why is palette such strange*/
          j=(ssize_t) TellBlob(palette);
          if((j % 512)>512-6)
            {
              j=((j / 512)+1)*512;
              offset=SeekBlob(palette,j,SEEK_SET);
              if (offset < 0)
                ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
            }
          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);
          if (QuantumRange != (Quantum) PalHeader.MaxRed)
            {
              image->colormap[i].red=ClampToQuantum(((double)
                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/
                PalHeader.MaxRed);
            }
          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);
          if (QuantumRange != (Quantum) PalHeader.MaxGreen)
            {
              image->colormap[i].green=ClampToQuantum
                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);
            }
          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);
          if (QuantumRange != (Quantum) PalHeader.MaxBlue)
            {
              image->colormap[i].blue=ClampToQuantum
                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);
            }

        }
    }



 NoPalette:
  if(palette==NULL)
    {

      image->colors=256;
      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
        {
        NoMemory:
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            }

      for (i=0; i < (ssize_t)image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);
          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);
          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);
        }
    }


  /* ----- Load RLE compressed raster ----- */
  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
    sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/
  if(BImgBuff==NULL) goto NoMemory;

  offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);
  if (offset < 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  for (i=0; i < (int) Header.Height; i++)
  {
      EncodedByte=ReadBlobLSBShort(image);

      ptrB=BImgBuff;
      j=ldblk;

      RunCount=(unsigned char) ReadBlobByte(image);
      RunCountMasked=RunCount & 0x7F;

      while ((int) RunCountMasked != 0)
      {
          if((ssize_t) RunCountMasked>j)
            {    /*Wrong Data*/
              RunCountMasked=(unsigned char) j;
              if(j==0)
                {
                  break;
                }
            }

          if((int) RunCount>0x80)
            {
              RunValue=(unsigned char) ReadBlobByte(image);
              (void) ResetMagickMemory(ptrB,(int) RunValue,(size_t) RunCountMasked);
            }
          else {
            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);
          }

          ptrB+=(int) RunCountMasked;
          j-=(int) RunCountMasked;

          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */
          RunCount=(unsigned char) ReadBlobByte(image);
          RunCountMasked=RunCount & 0x7F;
        }

      InsertRow(image,depth,BImgBuff,i,exception);
    }
  (void) SyncImage(image,exception);


  /*detect monochrome image*/

  if(palette==NULL)
    {    /*attempt to detect binary (black&white) images*/
      if ((image->storage_class == PseudoClass) &&
          (SetImageGray(image,exception) != MagickFalse))
        {
          if(GetCutColors(image,exception)==2)
            {
              for (i=0; i < (ssize_t)image->colors; i++)
                {
                  register Quantum
                    sample;
                  sample=ScaleCharToQuantum((unsigned char) i);
                  if(image->colormap[i].red!=sample) goto Finish;
                  if(image->colormap[i].green!=sample) goto Finish;
                  if(image->colormap[i].blue!=sample) goto Finish;
                }

              image->colormap[1].red=image->colormap[1].green=
                image->colormap[1].blue=QuantumRange;
              for (i=0; i < (ssize_t)image->rows; i++)
                {
                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);
                  if (q == (Quantum *) NULL)
                    break;
                  for (j=0; j < (ssize_t)image->columns; j++)
                    {
                      if (GetPixelRed(image,q) == ScaleCharToQuantum(1))
                        {
                          SetPixelRed(image,QuantumRange,q);
                          SetPixelGreen(image,QuantumRange,q);
                          SetPixelBlue(image,QuantumRange,q);
                        }
                      q+=GetPixelChannels(image);
                    }
                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;
                }
            }
        }
    }

 Finish:
  if (BImgBuff != NULL)
    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
  if (palette != NULL)
    palette=DestroyImage(palette);
  if (clone_info != NULL)
    clone_info=DestroyImageInfo(clone_info);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadCUTImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image *VAR_2,*VAR_3;
  ImageInfo *VAR_4;
  MagickBooleanType VAR_5;

  MagickOffsetType
    VAR_6;

  size_t VAR_7;
  unsigned char VAR_8,VAR_9,VAR_10;
  CUTHeader  VAR_11;
  CUTPalHeader VAR_12;
  ssize_t VAR_13;
  ssize_t VAR_14,VAR_15;
  ssize_t VAR_16;
  unsigned char *VAR_17=NULL,*VAR_18;
  register Quantum *VAR_19;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_20);
  if (VAR_0->debug != VAR_21)
    (void) LogMagickEvent(VAR_22,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_20);
  VAR_2=AcquireImage(VAR_0,VAR_1);
  VAR_5=OpenBlob(VAR_0,VAR_2,VAR_23,VAR_1);
  if (VAR_5 == VAR_21)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                   
    
  VAR_3=NULL;
  VAR_4=NULL;
  VAR_11.Width=ReadBlobLSBShort(VAR_2);
  VAR_11.Height=ReadBlobLSBShort(VAR_2);
  VAR_11.Reserved=ReadBlobLSBShort(VAR_2);

  if (VAR_11.Width==0 || VAR_11.Height==0 || VAR_11.Reserved!=0)
    CUT_KO:  ThrowReaderException(VAR_24,""ImproperImageHeader"");

  /* COMMENT_6 */
  VAR_7=ReadBlobLSBShort(VAR_2);
  VAR_8=(unsigned char) ReadBlobByte(VAR_2);
  VAR_10=VAR_8 & 0x7F;
  VAR_16=0;
  while((int) VAR_10!=0)  /* COMMENT_7 */
    {
      VAR_14=1;
      if((int) VAR_8<0x80) VAR_14=(ssize_t) VAR_10;
      VAR_6=SeekBlob(VAR_2,TellBlob(VAR_2)+VAR_14,VAR_25);
      if (VAR_6 < 0)
        ThrowReaderException(VAR_24,""ImproperImageHeader"");
      if(EOFBlob(VAR_2) != VAR_21) goto CUT_KO;  /* COMMENT_8 */
      VAR_7-=VAR_14+1;
      VAR_16+=(ssize_t) VAR_10;

      VAR_8=(unsigned char) ReadBlobByte(VAR_2);
      if(EOFBlob(VAR_2) != VAR_21)  goto CUT_KO;  /* COMMENT_9 */
      VAR_10=VAR_8 & 0x7F;
    }
  if(VAR_7!=1) goto CUT_KO;  /* COMMENT_10 */
  VAR_14=0;        /* COMMENT_11 */
  if(VAR_16==(int) VAR_11.Width)   VAR_14=8;
  if(2*VAR_16==(int) VAR_11.Width) VAR_14=4;
  if(8*VAR_16==(int) VAR_11.Width) VAR_14=1;
  if(VAR_14==0) goto CUT_KO;    /* COMMENT_12 */
  VAR_13=VAR_14;

  VAR_2->columns=VAR_11.Width;
  VAR_2->rows=VAR_11.Height;
  VAR_2->depth=8;
  VAR_2->colors=(size_t) (GetQuantumRange(1UL*VAR_14)+1);

  if (VAR_0->ping != VAR_21) goto Finish;
  VAR_5=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows,VAR_1);
  if (VAR_5 == VAR_21)
    return(DestroyImageList(VAR_2));

  /* COMMENT_13 */
  if ((VAR_4=CloneImageInfo(VAR_0)) == NULL) goto NoPalette;


  VAR_14=(ssize_t) strlen(VAR_4->filename);
  VAR_15=VAR_14;
  while(--VAR_14>0)
    {
      if(VAR_4->filename[VAR_14]=='.')
        {
          break;
        }
      if(VAR_4->filename[VAR_14]=='/' || VAR_4->filename[VAR_14]=='\\' ||
         VAR_4->filename[VAR_14]==':' )
        {
          VAR_14=VAR_15;
          break;
        }
    }

  (void) CopyMagickString(VAR_4->filename+VAR_14,"".PAL"",(size_t)
    (VAR_26-VAR_14));
  if((VAR_4->file=fopen_utf8(VAR_4->filename,""rb""))==NULL)
    {
      (void) CopyMagickString(VAR_4->filename+VAR_14,"".pal"",(size_t)
        (VAR_26-VAR_14));
      if((VAR_4->file=fopen_utf8(VAR_4->filename,""rb""))==NULL)
        {
          VAR_4->filename[VAR_14]='\0';
          if((VAR_4->file=fopen_utf8(VAR_4->filename,""rb""))==NULL)
            {
              VAR_4=DestroyImageInfo(VAR_4);
              VAR_4=NULL;
              goto NoPalette;
            }
        }
    }

  if( (VAR_3=AcquireImage(VAR_4,VAR_1))==NULL ) goto NoPalette;
  VAR_5=OpenBlob(VAR_4,VAR_3,VAR_23,VAR_1);
  if (VAR_5 == VAR_21)
    {
    ErasePalette:
      VAR_3=DestroyImage(VAR_3);
      VAR_3=NULL;
      goto NoPalette;
    }


  if(VAR_3!=NULL)
    {
      (void) ReadBlob(VAR_3,2,(unsigned char *) VAR_12.FileId);
      if(strncmp(VAR_12.FileId,""AH"",2) != 0) goto ErasePalette;
      VAR_12.Version=ReadBlobLSBShort(VAR_3);
      VAR_12.Size=ReadBlobLSBShort(VAR_3);
      VAR_12.FileType=(char) ReadBlobByte(VAR_3);
      VAR_12.SubType=(char) ReadBlobByte(VAR_3);
      VAR_12.BoardID=ReadBlobLSBShort(VAR_3);
      VAR_12.GraphicsMode=ReadBlobLSBShort(VAR_3);
      VAR_12.MaxIndex=ReadBlobLSBShort(VAR_3);
      VAR_12.MaxRed=ReadBlobLSBShort(VAR_3);
      VAR_12.MaxGreen=ReadBlobLSBShort(VAR_3);
      VAR_12.MaxBlue=ReadBlobLSBShort(VAR_3);
      (void) ReadBlob(VAR_3,20,(unsigned char *) VAR_12.PaletteId);

      if(VAR_12.MaxIndex<1) goto ErasePalette;
      VAR_2->colors=VAR_12.MaxIndex+1;
      if (AcquireImageColormap(VAR_2,VAR_2->colors,VAR_1) == VAR_21) goto NoMemory;

      if(VAR_12.MaxRed==0) VAR_12.MaxRed=(unsigned int) VAR_27;  /* COMMENT_14 */
      if(VAR_12.MaxGreen==0) VAR_12.MaxGreen=(unsigned int) VAR_27;
      if(VAR_12.MaxBlue==0) VAR_12.MaxBlue=(unsigned int) VAR_27;

      for(VAR_14=0;VAR_14<=(int) VAR_12.MaxIndex;VAR_14++)
        {      /* COMMENT_15 */
          VAR_15=(ssize_t) TellBlob(VAR_3);
          if((VAR_15 % 512)>512-6)
            {
              VAR_15=((VAR_15 / 512)+1)*512;
              VAR_6=SeekBlob(VAR_3,VAR_15,VAR_25);
              if (VAR_6 < 0)
                ThrowReaderException(VAR_24,""ImproperImageHeader"");
            }
          VAR_2->colormap[VAR_14].red=(Quantum) ReadBlobLSBShort(VAR_3);
          if (VAR_27 != (Quantum) VAR_12.MaxRed)
            {
              VAR_2->colormap[VAR_14].red=ClampToQuantum(((double)
                VAR_2->colormap[VAR_14].red*VAR_27+(VAR_12.MaxRed>>1))/
                VAR_12.MaxRed);
            }
          VAR_2->colormap[VAR_14].green=(Quantum) ReadBlobLSBShort(VAR_3);
          if (VAR_27 != (Quantum) VAR_12.MaxGreen)
            {
              VAR_2->colormap[VAR_14].green=ClampToQuantum
                (((double) VAR_2->colormap[VAR_14].green*VAR_27+(VAR_12.MaxGreen>>1))/VAR_12.MaxGreen);
            }
          VAR_2->colormap[VAR_14].blue=(Quantum) ReadBlobLSBShort(VAR_3);
          if (VAR_27 != (Quantum) VAR_12.MaxBlue)
            {
              VAR_2->colormap[VAR_14].blue=ClampToQuantum
                (((double)VAR_2->colormap[VAR_14].blue*VAR_27+(VAR_12.MaxBlue>>1))/VAR_12.MaxBlue);
            }

        }
    }



 NoPalette:
  if(VAR_3==NULL)
    {

      VAR_2->colors=256;
      if (AcquireImageColormap(VAR_2,VAR_2->colors,VAR_1) == VAR_21)
        {
        NoMemory:
          ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
            }

      for (VAR_14=0; VAR_14 < (ssize_t)VAR_2->colors; VAR_14++)
        {
          VAR_2->colormap[VAR_14].red=ScaleCharToQuantum((unsigned char) VAR_14);
          VAR_2->colormap[VAR_14].green=ScaleCharToQuantum((unsigned char) VAR_14);
          VAR_2->colormap[VAR_14].blue=ScaleCharToQuantum((unsigned char) VAR_14);
        }
    }


  /* COMMENT_16 */
  VAR_17=(unsigned char *) AcquireQuantumMemory((size_t) VAR_16,
    sizeof(*VAR_17));  /* COMMENT_17 */
  if(VAR_17==NULL) goto NoMemory;

  VAR_6=SeekBlob(VAR_2,6 /* COMMENT_18 */,VAR_25);
  if (VAR_6 < 0)
    ThrowReaderException(VAR_24,""ImproperImageHeader"");
  for (VAR_14=0; VAR_14 < (int) VAR_11.Height; VAR_14++)
  {
      VAR_7=ReadBlobLSBShort(VAR_2);

      VAR_18=VAR_17;
      VAR_15=VAR_16;

      VAR_8=(unsigned char) ReadBlobByte(VAR_2);
      VAR_10=VAR_8 & 0x7F;

      while ((int) VAR_10 != 0)
      {
          if((ssize_t) VAR_10>VAR_15)
            {    /* COMMENT_19 */
              VAR_10=(unsigned char) VAR_15;
              if(VAR_15==0)
                {
                  break;
                }
            }

          if((int) VAR_8>0x80)
            {
              VAR_9=(unsigned char) ReadBlobByte(VAR_2);
              (void) ResetMagickMemory(VAR_18,(int) VAR_9,(size_t) VAR_10);
            }
          else {
            (void) ReadBlob(VAR_2,(size_t) VAR_10,VAR_18);
          }

          VAR_18+=(int) VAR_10;
          VAR_15-=(int) VAR_10;

          if (EOFBlob(VAR_2) != VAR_21) goto Finish;  /* COMMENT_20 */
          VAR_8=(unsigned char) ReadBlobByte(VAR_2);
          VAR_10=VAR_8 & 0x7F;
        }

      InsertRow(VAR_2,VAR_13,VAR_17,VAR_14,VAR_1);
    }
  (void) SyncImage(VAR_2,VAR_1);


  /* COMMENT_21 */

  if(VAR_3==NULL)
    {    /* COMMENT_22 */
      if ((VAR_2->storage_class == VAR_29) &&
          (SetImageGray(VAR_2,VAR_1) != VAR_21))
        {
          if(GetCutColors(VAR_2,VAR_1)==2)
            {
              for (VAR_14=0; VAR_14 < (ssize_t)VAR_2->colors; VAR_14++)
                {
                  register Quantum
                    VAR_30;
                  VAR_30=ScaleCharToQuantum((unsigned char) VAR_14);
                  if(VAR_2->colormap[VAR_14].red!=VAR_30) goto Finish;
                  if(VAR_2->colormap[VAR_14].green!=VAR_30) goto Finish;
                  if(VAR_2->colormap[VAR_14].blue!=VAR_30) goto Finish;
                }

              VAR_2->colormap[1].red=VAR_2->colormap[1].green=
                VAR_2->colormap[1].blue=VAR_27;
              for (VAR_14=0; VAR_14 < (ssize_t)VAR_2->rows; VAR_14++)
                {
                  VAR_19=QueueAuthenticPixels(VAR_2,0,VAR_14,VAR_2->columns,1,VAR_1);
                  if (VAR_19 == (Quantum *) NULL)
                    break;
                  for (VAR_15=0; VAR_15 < (ssize_t)VAR_2->columns; VAR_15++)
                    {
                      if (GetPixelRed(VAR_2,VAR_19) == ScaleCharToQuantum(1))
                        {
                          SetPixelRed(VAR_2,VAR_27,VAR_19);
                          SetPixelGreen(VAR_2,VAR_27,VAR_19);
                          SetPixelBlue(VAR_2,VAR_27,VAR_19);
                        }
                      VAR_19+=GetPixelChannels(VAR_2);
                    }
                  if (SyncAuthenticPixels(VAR_2,VAR_1) == VAR_21) goto Finish;
                }
            }
        }
    }

 Finish:
  if (VAR_17 != NULL)
    VAR_17=(unsigned char *) RelinquishMagickMemory(VAR_17);
  if (VAR_3 != NULL)
    VAR_3=DestroyImage(VAR_3);
  if (VAR_4 != NULL)
    VAR_4=DestroyImageInfo(VAR_4);
  if (EOFBlob(VAR_2) != VAR_21)
    ThrowFileException(VAR_1,VAR_24,""UnexpectedEndOfFile"",
      VAR_2->filename);
  (void) CloseBlob(VAR_2);
  return(GetFirstImageInList(VAR_2));
}",ImageMagick/c535e1f1a6b1faaa35e007df4fc535ec08daa97c/cut.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -287,6 +287,8 @@
               for (i=0; i < (ssize_t)image->rows; i++)
                 {
                   q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);
+                  if (q == (Quantum *) NULL)
+                    break;
                   for (j=0; j < (ssize_t)image->columns; j++)
                     {
                       if (GetPixelRed(image,q) == ScaleCharToQuantum(1))","{'deleted_lines': [], 'added_lines': ['                  if (q == (Quantum *) NULL)', '                    break;']}",True,"In ImageMagick 7.0.6-10, a NULL Pointer Dereference issue is present in the ReadCUTImage function in coders/cut.c that could allow an attacker to cause a Denial of Service (in the QueueAuthenticPixelCacheNexus function within the MagickCore/cache.c file) by submitting a malformed image file.",6.5,MEDIUM,1,test,2017-08-31T13:16:40Z,2
CVE-2017-14174,['CWE-834'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/714,f68a98a9d385838a1c73ec960a14102949940a64,https://github.com/ImageMagick/ImageMagick/commit/f68a98a9d385838a1c73ec960a14102949940a64,coders/psd.c,ReadPSDLayersInternal,"static MagickBooleanType ReadPSDLayersInternal(Image *image,
const ImageInfo *image_info,const PSDInfo *psd_info,
const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
char
type[4];
LayerInfo
*layer_info;
MagickSizeType
size;
MagickBooleanType
status;
register ssize_t
i;
ssize_t
count,
j,
number_layers;
size=GetPSDSize(psd_info,image);
if (size == 0)
{
(void) ReadBlobLong(image);
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
status=MagickFalse;
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
return(MagickTrue);
else
{
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
size=GetPSDSize(psd_info,image);
else
return(MagickTrue);
}
}
status=MagickTrue;
if (size != 0)
{
layer_info=(LayerInfo *) NULL;
number_layers=(short) ReadBlobShort(image);
if (number_layers < 0)
{
number_layers=MagickAbsoluteValue(number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  negative layer count corrected for"");
image->matte=MagickTrue;
}
if (skip_layers != MagickFalse)
return(MagickTrue);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  image contains %.20g layers"",(double) number_layers);
if (number_layers == 0)
ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
image->filename);
layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
sizeof(*layer_info));
if (layer_info == (LayerInfo *) NULL)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
(void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
sizeof(*layer_info));
for (i=0; i < number_layers; i++)
{
ssize_t
x,
y;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading layer #%.20g"",(double) i+1);
layer_info[i].page.y=ReadBlobSignedLong(image);
layer_info[i].page.x=ReadBlobSignedLong(image);
y=ReadBlobSignedLong(image);
x=ReadBlobSignedLong(image);
layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
layer_info[i].channels=ReadBlobShort(image);
if (layer_info[i].channels > MaxPSDChannels)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
image->filename);
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) layer_info[i].page.x,(double) layer_info[i].page.y,
(double) layer_info[i].page.height,(double)
layer_info[i].page.width,(double) layer_info[i].channels);
for (j=0; j < (ssize_t) layer_info[i].channels; j++)
{
layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
image);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
(double) layer_info[i].channel_info[j].type,
(double) layer_info[i].channel_info[j].size);
}
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", type);
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
image->filename);
}
(void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
ReversePSDString(image,layer_info[i].blendkey,4);
layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(image));
layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
layer_info[i].flags=(unsigned char) ReadBlobByte(image);
layer_info[i].visible=!(layer_info[i].flags & 0x02);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
layer_info[i].blendkey,(double) layer_info[i].opacity,
layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
layer_info[i].visible ? ""true"" : ""false"");
(void) ReadBlobByte(image);  
size=ReadBlobLong(image);
if (size != 0)
{
MagickSizeType
combined_length,
length;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    layer contains additional info"");
length=ReadBlobLong(image);
combined_length=length+4;
if (length != 0)
{
layer_info[i].mask.page.y=ReadBlobSignedLong(image);
layer_info[i].mask.page.x=ReadBlobSignedLong(image);
layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-
layer_info[i].mask.page.y);
layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-
layer_info[i].mask.page.x);
layer_info[i].mask.background=(unsigned char) ReadBlobByte(
image);
layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
if (!(layer_info[i].mask.flags & 0x01))
{
layer_info[i].mask.page.y=layer_info[i].mask.page.y-
layer_info[i].page.y;
layer_info[i].mask.page.x=layer_info[i].mask.page.x-
layer_info[i].page.x;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) layer_info[i].mask.page.x,(double)
layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
(double) layer_info[i].mask.page.height,(double)
((MagickOffsetType) length)-18);
if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
}
}
length=ReadBlobLong(image);
combined_length+=length+4;
if (length != 0)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) length));
for (j=0; j < (ssize_t) length; j+=8)
{
size_t blend_source=ReadBlobLong(image);
size_t blend_dest=ReadBlobLong(image);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
blend_source,(unsigned int) blend_dest);
}
}
length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
combined_length+=length+1;
if (length > 0)
(void) ReadBlob(image,(size_t) length++,layer_info[i].name);
layer_info[i].name[length]='\0';
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer name: %s"",layer_info[i].name);
if ((length % 4) != 0)
{
length=4-(length % 4);
combined_length+=length;
if (DiscardBlobBytes(image,length) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
length=(MagickSizeType) size-combined_length;
if (length > 0)
{
unsigned char
*info;
if (length > GetBlobSize(image))
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""InsufficientImageDataInFile"",image->filename);
}
layer_info[i].info=AcquireStringInfo((const size_t) length);
info=GetStringInfoDatum(layer_info[i].info);
(void) ReadBlob(image,(const size_t) length,info);
}
}
}
for (i=0; i < number_layers; i++)
{
if ((layer_info[i].page.width == 0) ||
(layer_info[i].page.height == 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer data is empty"");
if (layer_info[i].info != (StringInfo *) NULL)
layer_info[i].info=DestroyStringInfo(layer_info[i].info);
continue;
}
layer_info[i].image=CloneImage(image,layer_info[i].page.width,
layer_info[i].page.height,MagickFalse,exception);
if (layer_info[i].image == (Image *) NULL)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) i);
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
if (layer_info[i].info != (StringInfo *) NULL)
{
(void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
layer_info[i].info);
layer_info[i].info=DestroyStringInfo(layer_info[i].info);
}
}
if (image_info->ping == MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=0; j < layer_info[i].channels; j++)
{
if (DiscardBlobBytes(image,(MagickSizeType)
layer_info[i].channel_info[j].size) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
continue;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading data for layer %.20g"",(double) i);
status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
exception);
if (status == MagickFalse)
break;
status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
number_layers);
if (status == MagickFalse)
break;
}
}
if (status != MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=i; j < number_layers - 1; j++)
layer_info[j] = layer_info[j+1];
number_layers--;
i--;
}
}
if (number_layers > 0)
{
for (i=0; i < number_layers; i++)
{
if (i > 0)
layer_info[i].image->previous=layer_info[i-1].image;
if (i < (number_layers-1))
layer_info[i].image->next=layer_info[i+1].image;
layer_info[i].image->page=layer_info[i].page;
}
image->next=layer_info[0].image;
layer_info[0].image->previous=image;
}
layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
}
else
layer_info=DestroyLayerInfo(layer_info,number_layers);
}
return(status);
}","static MagickBooleanType ReadPSDLayersInternal(Image *VAR_0,
const ImageInfo *VAR_1,const PSDInfo *VAR_2,
const MagickBooleanType VAR_3,ExceptionInfo *VAR_4)
{
char
VAR_5[4];
LayerInfo
*VAR_6;
MagickSizeType
VAR_7;
MagickBooleanType
VAR_8;
register ssize_t
VAR_9;
ssize_t
VAR_10,
VAR_11,
VAR_12;
VAR_7=GetPSDSize(VAR_2,VAR_0);
if (VAR_7 == 0)
{
(void) ReadBlobLong(VAR_0);
VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
ReversePSDString(VAR_0,VAR_5,4);
VAR_8=VAR_13;
if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
return(VAR_14);
else
{
VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
ReversePSDString(VAR_0,VAR_5,4);
if ((VAR_10 != 0) && (LocaleNCompare(VAR_5,""Lr16"",4) == 0))
VAR_7=GetPSDSize(VAR_2,VAR_0);
else
return(VAR_14);
}
}
VAR_8=VAR_14;
if (VAR_7 != 0)
{
VAR_6=(LayerInfo *) NULL;
VAR_12=(short) ReadBlobShort(VAR_0);
if (VAR_12 < 0)
{
VAR_12=MagickAbsoluteValue(VAR_12);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  negative layer count corrected for"");
VAR_0->matte=VAR_14;
}
if (VAR_3 != VAR_13)
return(VAR_14);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  image contains %.20g layers"",(double) VAR_12);
if (VAR_12 == 0)
ThrowBinaryException(VAR_16,""InvalidNumberOfLayers"",
VAR_0->filename);
VAR_6=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_12,
sizeof(*VAR_6));
if (VAR_6 == (LayerInfo *) NULL)
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(VAR_17,""MemoryAllocationFailed"",
VAR_0->filename);
}
(void) ResetMagickMemory(VAR_6,0,(size_t) VAR_12*
sizeof(*VAR_6));
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
ssize_t
VAR_18,
VAR_19;
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  reading layer #%.20g"",(double) VAR_9+1);
VAR_6[VAR_9].page.y=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].page.x=ReadBlobSignedLong(VAR_0);
VAR_19=ReadBlobSignedLong(VAR_0);
VAR_18=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].page.width=(size_t) (VAR_18-VAR_6[VAR_9].page.x);
VAR_6[VAR_9].page.height=(size_t) (VAR_19-VAR_6[VAR_9].page.y);
VAR_6[VAR_9].channels=ReadBlobShort(VAR_0);
if (VAR_6[VAR_9].channels > VAR_20)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_16,""MaximumChannelsExceeded"",
VAR_0->filename);
}
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) VAR_6[VAR_9].page.x,(double) VAR_6[VAR_9].page.y,
(double) VAR_6[VAR_9].page.height,(double)
VAR_6[VAR_9].page.width,(double) VAR_6[VAR_9].channels);
for (VAR_11=0; VAR_11 < (ssize_t) VAR_6[VAR_9].channels; VAR_11++)
{
VAR_6[VAR_9].channel_info[VAR_11].type=(short) ReadBlobShort(VAR_0);
VAR_6[VAR_9].channel_info[VAR_11].size=(size_t) GetPSDSize(VAR_2,
VAR_0);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_11,
(double) VAR_6[VAR_9].channel_info[VAR_11].type,
(double) VAR_6[VAR_9].channel_info[VAR_11].size);
}
VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
ReversePSDString(VAR_0,VAR_5,4);
if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", VAR_5);
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_16,""ImproperImageHeader"",
VAR_0->filename);
}
(void) ReadBlob(VAR_0,4,(unsigned char *) VAR_6[VAR_9].blendkey);
ReversePSDString(VAR_0,VAR_6[VAR_9].blendkey,4);
VAR_6[VAR_9].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(VAR_0));
VAR_6[VAR_9].clipping=(unsigned char) ReadBlobByte(VAR_0);
VAR_6[VAR_9].flags=(unsigned char) ReadBlobByte(VAR_0);
VAR_6[VAR_9].visible=!(VAR_6[VAR_9].flags & 0x02);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
VAR_6[VAR_9].blendkey,(double) VAR_6[VAR_9].opacity,
VAR_6[VAR_9].clipping ? ""true"" : ""false"",VAR_6[VAR_9].flags,
VAR_6[VAR_9].visible ? ""true"" : ""false"");
(void) ReadBlobByte(VAR_0);  
VAR_7=ReadBlobLong(VAR_0);
if (VAR_7 != 0)
{
MagickSizeType
VAR_21,
VAR_22;
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""    layer contains additional info"");
VAR_22=ReadBlobLong(VAR_0);
VAR_21=VAR_22+4;
if (VAR_22 != 0)
{
VAR_6[VAR_9].mask.page.y=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].mask.page.x=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].mask.page.height=(size_t) (ReadBlobSignedLong(VAR_0)-
VAR_6[VAR_9].mask.page.y);
VAR_6[VAR_9].mask.page.width=(size_t) (ReadBlobSignedLong(VAR_0)-
VAR_6[VAR_9].mask.page.x);
VAR_6[VAR_9].mask.background=(unsigned char) ReadBlobByte(
VAR_0);
VAR_6[VAR_9].mask.flags=(unsigned char) ReadBlobByte(VAR_0);
if (!(VAR_6[VAR_9].mask.flags & 0x01))
{
VAR_6[VAR_9].mask.page.y=VAR_6[VAR_9].mask.page.y-
VAR_6[VAR_9].page.y;
VAR_6[VAR_9].mask.page.x=VAR_6[VAR_9].mask.page.x-
VAR_6[VAR_9].page.x;
}
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) VAR_6[VAR_9].mask.page.x,(double)
VAR_6[VAR_9].mask.page.y,(double) VAR_6[VAR_9].mask.page.width,
(double) VAR_6[VAR_9].mask.page.height,(double)
((MagickOffsetType) VAR_22)-18);
if (DiscardBlobBytes(VAR_0,(MagickSizeType) (VAR_22-18)) == VAR_13)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_16,""UnexpectedEndOfFile"",
VAR_0->filename);
}
}
VAR_22=ReadBlobLong(VAR_0);
VAR_21+=VAR_22+4;
if (VAR_22 != 0)
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) VAR_22));
for (VAR_11=0; VAR_11 < (ssize_t) VAR_22; VAR_11+=8)
{
size_t VAR_23=ReadBlobLong(VAR_0);
size_t VAR_24=ReadBlobLong(VAR_0);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
VAR_23,(unsigned int) VAR_24);
}
}
VAR_22=(MagickSizeType) (unsigned char) ReadBlobByte(VAR_0);
VAR_21+=VAR_22+1;
if (VAR_22 > 0)
(void) ReadBlob(VAR_0,(size_t) VAR_22++,VAR_6[VAR_9].name);
VAR_6[VAR_9].name[VAR_22]='\0';
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer name: %s"",VAR_6[VAR_9].name);
if ((VAR_22 % 4) != 0)
{
VAR_22=4-(VAR_22 % 4);
VAR_21+=VAR_22;
if (DiscardBlobBytes(VAR_0,VAR_22) == VAR_13)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_16,
""UnexpectedEndOfFile"",VAR_0->filename);
}
}
VAR_22=(MagickSizeType) VAR_7-VAR_21;
if (VAR_22 > 0)
{
unsigned char
*VAR_25;
if (VAR_22 > GetBlobSize(VAR_0))
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_16,
""InsufficientImageDataInFile"",VAR_0->filename);
}
VAR_6[VAR_9].info=AcquireStringInfo((const size_t) VAR_22);
VAR_25=GetStringInfoDatum(VAR_6[VAR_9].info);
(void) ReadBlob(VAR_0,(const size_t) VAR_22,VAR_25);
}
}
}
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if ((VAR_6[VAR_9].page.width == 0) ||
(VAR_6[VAR_9].page.height == 0))
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer data is empty"");
if (VAR_6[VAR_9].info != (StringInfo *) NULL)
VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
continue;
}
VAR_6[VAR_9].image=CloneImage(VAR_0,VAR_6[VAR_9].page.width,
VAR_6[VAR_9].page.height,VAR_13,VAR_4);
if (VAR_6[VAR_9].image == (Image *) NULL)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) VAR_9);
ThrowBinaryException(VAR_17,""MemoryAllocationFailed"",
VAR_0->filename);
}
if (VAR_6[VAR_9].info != (StringInfo *) NULL)
{
(void) SetImageProfile(VAR_6[VAR_9].image,""psd:additional-info"",
VAR_6[VAR_9].info);
VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
}
}
if (VAR_1->ping == VAR_13)
{
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if (VAR_6[VAR_9].image == (Image *) NULL)
{
for (VAR_11=0; VAR_11 < VAR_6[VAR_9].channels; VAR_11++)
{
if (DiscardBlobBytes(VAR_0,(MagickSizeType)
VAR_6[VAR_9].channel_info[VAR_11].size) == VAR_13)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_16,
""UnexpectedEndOfFile"",VAR_0->filename);
}
}
continue;
}
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  reading data for layer %.20g"",(double) VAR_9);
VAR_8=ReadPSDLayer(VAR_0,VAR_1,VAR_2,&VAR_6[VAR_9],
VAR_4);
if (VAR_8 == VAR_13)
break;
VAR_8=SetImageProgress(VAR_0,VAR_26,VAR_9,(MagickSizeType)
VAR_12);
if (VAR_8 == VAR_13)
break;
}
}
if (VAR_8 != VAR_13)
{
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if (VAR_6[VAR_9].image == (Image *) NULL)
{
for (VAR_11=VAR_9; VAR_11 < VAR_12 - 1; VAR_11++)
VAR_6[VAR_11] = VAR_6[VAR_11+1];
VAR_12--;
VAR_9--;
}
}
if (VAR_12 > 0)
{
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if (VAR_9 > 0)
VAR_6[VAR_9].image->previous=VAR_6[VAR_9-1].image;
if (VAR_9 < (VAR_12-1))
VAR_6[VAR_9].image->next=VAR_6[VAR_9+1].image;
VAR_6[VAR_9].image->page=VAR_6[VAR_9].page;
}
VAR_0->next=VAR_6[0].image;
VAR_6[0].image->previous=VAR_0;
}
VAR_6=(LayerInfo *) RelinquishMagickMemory(VAR_6);
}
else
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
}
return(VAR_8);
}",ImageMagick/f68a98a9d385838a1c73ec960a14102949940a64/psd.c/vul/before/0.json,"static MagickBooleanType ReadPSDLayersInternal(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      /*
        Skip layers & masks.
      */
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          /*
            The first alpha channel in the merged result contains the
            transparency data for the merged result.
          */
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->matte=MagickTrue;
        }

      /*
        We only need to know if the image has an alpha channel
      */
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  /* filler */

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                /*
                  Layer mask info.
                */
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                    (double) layer_info[i].mask.page.height,(double)
                    ((MagickOffsetType) length)-18);
                /*
                  Skip over the rest of the layer mask information.
                */
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                /*
                  Layer blending ranges info.
                */
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                /*
                  We read it, but don't use it...
                */
                for (j=0; j < (ssize_t) length; j+=8)
                {
                  size_t blend_source=ReadBlobLong(image);
                  size_t blend_dest=ReadBlobLong(image);
                  if (EOFBlob(image) != MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""InsufficientImageDataInFile"",image->filename);
                    }
                  if (image->debug != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      blend_source,(unsigned int) blend_dest);
                }
              }
            /*
              Layer name.
            */
            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                /* Skip over the padding of the layer name */
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                if (length > GetBlobSize(image))
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""InsufficientImageDataInFile"",image->filename);
                  }
                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) ||
              (layer_info[i].page.height == 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer data is empty"");
            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
            continue;
          }

        /*
          Allocate layered image.
        */
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);
            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}","static MagickBooleanType ReadPSDLayersInternal(Image *VAR_0,
  const ImageInfo *VAR_1,const PSDInfo *VAR_2,
  const MagickBooleanType VAR_3,ExceptionInfo *VAR_4)
{
  char
    VAR_5[4];

  LayerInfo
    *VAR_6;

  MagickSizeType
    VAR_7;

  MagickBooleanType
    VAR_8;

  register ssize_t
    VAR_9;

  ssize_t
    VAR_10,
    VAR_11,
    VAR_12;

  VAR_7=GetPSDSize(VAR_2,VAR_0);
  if (VAR_7 == 0)
    {
      /* COMMENT_0 */
                            
        
      (void) ReadBlobLong(VAR_0);
      VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
      ReversePSDString(VAR_0,VAR_5,4);
      VAR_8=VAR_13;
      if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
        return(VAR_14);
      else
        {
          VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
          ReversePSDString(VAR_0,VAR_5,4);
          if ((VAR_10 != 0) && (LocaleNCompare(VAR_5,""Lr16"",4) == 0))
            VAR_7=GetPSDSize(VAR_2,VAR_0);
          else
            return(VAR_14);
        }
    }
  VAR_8=VAR_14;
  if (VAR_7 != 0)
    {
      VAR_6=(LayerInfo *) NULL;
      VAR_12=(short) ReadBlobShort(VAR_0);

      if (VAR_12 < 0)
        {
          /* COMMENT_3 */
                                                                     
                                                    
            
          VAR_12=MagickAbsoluteValue(VAR_12);
          if (VAR_0->debug != VAR_13)
            (void) LogMagickEvent(VAR_15,GetMagickModule(),
              ""  negative layer count corrected for"");
          VAR_0->matte=VAR_14;
        }

      /* COMMENT_7 */
                                                              
        
      if (VAR_3 != VAR_13)
        return(VAR_14);

      if (VAR_0->debug != VAR_13)
        (void) LogMagickEvent(VAR_15,GetMagickModule(),
          ""  image contains %.20g layers"",(double) VAR_12);

      if (VAR_12 == 0)
        ThrowBinaryException(VAR_16,""InvalidNumberOfLayers"",
          VAR_0->filename);

      VAR_6=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_12,
        sizeof(*VAR_6));
      if (VAR_6 == (LayerInfo *) NULL)
        {
          if (VAR_0->debug != VAR_13)
            (void) LogMagickEvent(VAR_15,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(VAR_17,""MemoryAllocationFailed"",
            VAR_0->filename);
        }
      (void) ResetMagickMemory(VAR_6,0,(size_t) VAR_12*
        sizeof(*VAR_6));

      for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
      {
        ssize_t
          VAR_18,
          VAR_19;

        if (VAR_0->debug != VAR_13)
          (void) LogMagickEvent(VAR_15,GetMagickModule(),
            ""  reading layer #%.20g"",(double) VAR_9+1);
        VAR_6[VAR_9].page.y=ReadBlobSignedLong(VAR_0);
        VAR_6[VAR_9].page.x=ReadBlobSignedLong(VAR_0);
        VAR_19=ReadBlobSignedLong(VAR_0);
        VAR_18=ReadBlobSignedLong(VAR_0);
        VAR_6[VAR_9].page.width=(size_t) (VAR_18-VAR_6[VAR_9].page.x);
        VAR_6[VAR_9].page.height=(size_t) (VAR_19-VAR_6[VAR_9].page.y);
        VAR_6[VAR_9].channels=ReadBlobShort(VAR_0);
        if (VAR_6[VAR_9].channels > VAR_20)
          {
            VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
            ThrowBinaryException(VAR_16,""MaximumChannelsExceeded"",
              VAR_0->filename);
          }
        if (VAR_0->debug != VAR_13)
          (void) LogMagickEvent(VAR_15,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) VAR_6[VAR_9].page.x,(double) VAR_6[VAR_9].page.y,
            (double) VAR_6[VAR_9].page.height,(double)
            VAR_6[VAR_9].page.width,(double) VAR_6[VAR_9].channels);
        for (VAR_11=0; VAR_11 < (ssize_t) VAR_6[VAR_9].channels; VAR_11++)
        {
          VAR_6[VAR_9].channel_info[VAR_11].type=(short) ReadBlobShort(VAR_0);
          VAR_6[VAR_9].channel_info[VAR_11].size=(size_t) GetPSDSize(VAR_2,
            VAR_0);
          if (VAR_0->debug != VAR_13)
            (void) LogMagickEvent(VAR_15,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_11,
              (double) VAR_6[VAR_9].channel_info[VAR_11].type,
              (double) VAR_6[VAR_9].channel_info[VAR_11].size);
        }
        VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
        ReversePSDString(VAR_0,VAR_5,4);
        if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
          {
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", VAR_5);
            VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
            ThrowBinaryException(VAR_16,""ImproperImageHeader"",
              VAR_0->filename);
          }
        (void) ReadBlob(VAR_0,4,(unsigned char *) VAR_6[VAR_9].blendkey);
        ReversePSDString(VAR_0,VAR_6[VAR_9].blendkey,4);
        VAR_6[VAR_9].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(VAR_0));
        VAR_6[VAR_9].clipping=(unsigned char) ReadBlobByte(VAR_0);
        VAR_6[VAR_9].flags=(unsigned char) ReadBlobByte(VAR_0);
        VAR_6[VAR_9].visible=!(VAR_6[VAR_9].flags & 0x02);
        if (VAR_0->debug != VAR_13)
          (void) LogMagickEvent(VAR_15,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            VAR_6[VAR_9].blendkey,(double) VAR_6[VAR_9].opacity,
            VAR_6[VAR_9].clipping ? ""true"" : ""false"",VAR_6[VAR_9].flags,
            VAR_6[VAR_9].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(VAR_0);  /* COMMENT_10 */

        VAR_7=ReadBlobLong(VAR_0);
        if (VAR_7 != 0)
          {
            MagickSizeType
              VAR_21,
              VAR_22;

            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""    layer contains additional info"");
            VAR_22=ReadBlobLong(VAR_0);
            VAR_21=VAR_22+4;
            if (VAR_22 != 0)
              {
                /* COMMENT_11 */
                                  
                  
                VAR_6[VAR_9].mask.page.y=ReadBlobSignedLong(VAR_0);
                VAR_6[VAR_9].mask.page.x=ReadBlobSignedLong(VAR_0);
                VAR_6[VAR_9].mask.page.height=(size_t) (ReadBlobSignedLong(VAR_0)-
                  VAR_6[VAR_9].mask.page.y);
                VAR_6[VAR_9].mask.page.width=(size_t) (ReadBlobSignedLong(VAR_0)-
                  VAR_6[VAR_9].mask.page.x);
                VAR_6[VAR_9].mask.background=(unsigned char) ReadBlobByte(
                  VAR_0);
                VAR_6[VAR_9].mask.flags=(unsigned char) ReadBlobByte(VAR_0);
                if (!(VAR_6[VAR_9].mask.flags & 0x01))
                  {
                    VAR_6[VAR_9].mask.page.y=VAR_6[VAR_9].mask.page.y-
                      VAR_6[VAR_9].page.y;
                    VAR_6[VAR_9].mask.page.x=VAR_6[VAR_9].mask.page.x-
                      VAR_6[VAR_9].page.x;
                  }
                if (VAR_0->debug != VAR_13)
                  (void) LogMagickEvent(VAR_15,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) VAR_6[VAR_9].mask.page.x,(double)
                    VAR_6[VAR_9].mask.page.y,(double) VAR_6[VAR_9].mask.page.width,
                    (double) VAR_6[VAR_9].mask.page.height,(double)
                    ((MagickOffsetType) VAR_22)-18);
                /* COMMENT_14 */
                                                                   
                  
                if (DiscardBlobBytes(VAR_0,(MagickSizeType) (VAR_22-18)) == VAR_13)
                  {
                    VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                    ThrowBinaryException(VAR_16,""UnexpectedEndOfFile"",
                      VAR_0->filename);
                  }
              }
            VAR_22=ReadBlobLong(VAR_0);
            VAR_21+=VAR_22+4;
            if (VAR_22 != 0)
              {
                /* COMMENT_17 */
                                             
                  
                if (VAR_0->debug != VAR_13)
                  (void) LogMagickEvent(VAR_15,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) VAR_22));
                /* COMMENT_20 */
                                                 
                  
                for (VAR_11=0; VAR_11 < (ssize_t) VAR_22; VAR_11+=8)
                {
                  size_t VAR_23=ReadBlobLong(VAR_0);
                  size_t VAR_24=ReadBlobLong(VAR_0);
                  if (EOFBlob(VAR_0) != VAR_13)
                    {
                      VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                      ThrowBinaryException(VAR_16,
                        ""InsufficientImageDataInFile"",VAR_0->filename);
                    }
                  if (VAR_0->debug != VAR_13)
                    (void) LogMagickEvent(VAR_15,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      VAR_23,(unsigned int) VAR_24);
                }
              }
            /* COMMENT_23 */
                         
              
            VAR_22=(MagickSizeType) (unsigned char) ReadBlobByte(VAR_0);
            VAR_21+=VAR_22+1;
            if (VAR_22 > 0)
              (void) ReadBlob(VAR_0,(size_t) VAR_22++,VAR_6[VAR_9].name);
            VAR_6[VAR_9].name[VAR_22]='\0';
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""      layer name: %s"",VAR_6[VAR_9].name);
            if ((VAR_22 % 4) != 0)
              {
                VAR_22=4-(VAR_22 % 4);
                VAR_21+=VAR_22;
                /* COMMENT_26 */
                if (DiscardBlobBytes(VAR_0,VAR_22) == VAR_13)
                  {
                    VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                    ThrowBinaryException(VAR_16,
                      ""UnexpectedEndOfFile"",VAR_0->filename);
                  }
              }
            VAR_22=(MagickSizeType) VAR_7-VAR_21;
            if (VAR_22 > 0)
              {
                unsigned char
                  *VAR_25;

                if (VAR_22 > GetBlobSize(VAR_0))
                  {
                    VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                    ThrowBinaryException(VAR_16,
                      ""InsufficientImageDataInFile"",VAR_0->filename);
                  }
                VAR_6[VAR_9].info=AcquireStringInfo((const size_t) VAR_22);
                VAR_25=GetStringInfoDatum(VAR_6[VAR_9].info);
                (void) ReadBlob(VAR_0,(const size_t) VAR_22,VAR_25);
              }
          }
      }

      for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
      {
        if ((VAR_6[VAR_9].page.width == 0) ||
              (VAR_6[VAR_9].page.height == 0))
          {
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""      layer data is empty"");
            if (VAR_6[VAR_9].info != (StringInfo *) NULL)
              VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
            continue;
          }

        /* COMMENT_27 */
                                 
          
        VAR_6[VAR_9].image=CloneImage(VAR_0,VAR_6[VAR_9].page.width,
          VAR_6[VAR_9].page.height,VAR_13,VAR_4);
        if (VAR_6[VAR_9].image == (Image *) NULL)
          {
            VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) VAR_9);
            ThrowBinaryException(VAR_17,""MemoryAllocationFailed"",
              VAR_0->filename);
          }

        if (VAR_6[VAR_9].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(VAR_6[VAR_9].image,""psd:additional-info"",
              VAR_6[VAR_9].info);
            VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
          }
      }

      if (VAR_1->ping == VAR_13)
        {
          for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
          {
            if (VAR_6[VAR_9].image == (Image *) NULL)
              {
                for (VAR_11=0; VAR_11 < VAR_6[VAR_9].channels; VAR_11++)
                {
                  if (DiscardBlobBytes(VAR_0,(MagickSizeType)
                      VAR_6[VAR_9].channel_info[VAR_11].size) == VAR_13)
                    {
                      VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                      ThrowBinaryException(VAR_16,
                        ""UnexpectedEndOfFile"",VAR_0->filename);
                    }
                }
                continue;
              }

            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) VAR_9);
            VAR_8=ReadPSDLayer(VAR_0,VAR_1,VAR_2,&VAR_6[VAR_9],
              VAR_4);
            if (VAR_8 == VAR_13)
              break;

            VAR_8=SetImageProgress(VAR_0,VAR_26,VAR_9,(MagickSizeType)
              VAR_12);
            if (VAR_8 == VAR_13)
              break;
          }
        }

      if (VAR_8 != VAR_13)
        {
          for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
          {
            if (VAR_6[VAR_9].image == (Image *) NULL)
              {
                for (VAR_11=VAR_9; VAR_11 < VAR_12 - 1; VAR_11++)
                  VAR_6[VAR_11] = VAR_6[VAR_11+1];
                VAR_12--;
                VAR_9--;
              }
          }

          if (VAR_12 > 0)
            {
              for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
              {
                if (VAR_9 > 0)
                  VAR_6[VAR_9].image->previous=VAR_6[VAR_9-1].image;
                if (VAR_9 < (VAR_12-1))
                  VAR_6[VAR_9].image->next=VAR_6[VAR_9+1].image;
                VAR_6[VAR_9].image->page=VAR_6[VAR_9].page;
              }
              VAR_0->next=VAR_6[0].image;
              VAR_6[0].image->previous=VAR_0;
            }
          VAR_6=(LayerInfo *) RelinquishMagickMemory(VAR_6);
        }
      else
        VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
    }

  return(VAR_8);
}",ImageMagick/f68a98a9d385838a1c73ec960a14102949940a64/psd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -223,6 +223,12 @@
                 {
                   size_t blend_source=ReadBlobLong(image);
                   size_t blend_dest=ReadBlobLong(image);
+                  if (EOFBlob(image) != MagickFalse)
+                    {
+                      layer_info=DestroyLayerInfo(layer_info,number_layers);
+                      ThrowBinaryException(CorruptImageError,
+                        ""InsufficientImageDataInFile"",image->filename);
+                    }
                   if (image->debug != MagickFalse)
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""        source(%x), dest(%x)"",(unsigned int)","{'deleted_lines': [], 'added_lines': ['                  if (EOFBlob(image) != MagickFalse)', '                    {', '                      layer_info=DestroyLayerInfo(layer_info,number_layers);', '                      ThrowBinaryException(CorruptImageError,', '                        ""InsufficientImageDataInFile"",image->filename);', '                    }']}",True,"In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large ""length"" field in the header but does not contain sufficient backing data, is provided, the loop over ""length"" would consume huge CPU resources, since there is no EOF check inside the loop.",6.5,MEDIUM,1,test,2017-08-31T14:27:46Z,2
CVE-2017-14174,['CWE-834'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,ImageMagick,Slightly different fix for #714,04a567494786d5bb50894fc8bb8fea0cf496bea8,https://github.com/ImageMagick/ImageMagick/commit/04a567494786d5bb50894fc8bb8fea0cf496bea8,coders/psd.c,ReadPSDChannel,"static MagickBooleanType ReadPSDChannel(Image *image,
const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
const size_t channel,const PSDCompressionType compression,
ExceptionInfo *exception)
{
Image
*channel_image,
*mask;
MagickOffsetType
offset;
MagickBooleanType
status;
channel_image=image;
mask=(Image *) NULL;
if ((layer_info->channel_info[channel].type < -1) &&
(layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))
{
const char
*option;
option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
if ((layer_info->channel_info[channel].type != -2) ||
(layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
(IsStringTrue(option) == MagickFalse)))
{
SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
return(MagickTrue);
}
mask=CloneImage(image,layer_info->mask.page.width,
layer_info->mask.page.height,MagickFalse,exception);
if (mask != (Image *) NULL)
{
SetImageType(mask,GrayscaleType,exception);
channel_image=mask;
}
}
offset=TellBlob(image);
status=MagickFalse;
switch(compression)
{
case Raw:
status=ReadPSDChannelRaw(channel_image,psd_info->channels,
layer_info->channel_info[channel].type,exception);
break;
case RLE:
{
MagickOffsetType
*sizes;
sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
if (sizes == (MagickOffsetType *) NULL)
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
status=ReadPSDChannelRLE(channel_image,psd_info,
layer_info->channel_info[channel].type,sizes,exception);
sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
}
break;
case ZipWithPrediction:
case ZipWithoutPrediction:
#ifdef MAGICKCORE_ZLIB_DELEGATE
status=ReadPSDChannelZip(channel_image,layer_info->channels,
layer_info->channel_info[channel].type,compression,
layer_info->channel_info[channel].size-2,exception);
#else
(void) ThrowMagickException(exception,GetMagickModule(),
MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
""'%s' (ZLIB)"",image->filename);
#endif
break;
default:
(void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
""CompressionNotSupported"",""'%.20g'"",(double) compression);
break;
}
SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
if (status == MagickFalse)
{
if (mask != (Image *) NULL)
DestroyImage(mask);
ThrowBinaryException(CoderError,""UnableToDecompressImage"",
image->filename);
}
layer_info->mask.image=mask;
return(status);
}","static MagickBooleanType ReadPSDChannel(Image *VAR_0,
const ImageInfo *VAR_1,const PSDInfo *VAR_2,LayerInfo* VAR_3,
const size_t VAR_4,const PSDCompressionType VAR_5,
ExceptionInfo *VAR_6)
{
Image
*VAR_7,
*VAR_8;
MagickOffsetType
VAR_9;
MagickBooleanType
VAR_10;
VAR_7=VAR_0;
VAR_8=(Image *) NULL;
if ((VAR_3->channel_info[VAR_4].type < -1) &&
(VAR_3->mask.page.width > 0) && (VAR_3->mask.page.height > 0))
{
const char
*VAR_11;
VAR_11=GetImageOption(VAR_1,""psd:preserve-opacity-mask"");
if ((VAR_3->channel_info[VAR_4].type != -2) ||
(VAR_3->mask.flags > 2) || ((VAR_3->mask.flags & 0x02) &&
(IsStringTrue(VAR_11) == VAR_12)))
{
SeekBlob(VAR_0,VAR_3->channel_info[VAR_4].size-2,VAR_13);
return(VAR_14);
}
VAR_8=CloneImage(VAR_0,VAR_3->mask.page.width,
VAR_3->mask.page.height,VAR_12,VAR_6);
if (VAR_8 != (Image *) NULL)
{
SetImageType(VAR_8,VAR_15,VAR_6);
VAR_7=VAR_8;
}
}
VAR_9=TellBlob(VAR_0);
VAR_10=VAR_12;
switch(VAR_5)
{
case VAR_16:
VAR_10=ReadPSDChannelRaw(VAR_7,VAR_2->channels,
VAR_3->channel_info[VAR_4].type,VAR_6);
break;
case VAR_17:
{
MagickOffsetType
*VAR_18;
VAR_18=ReadPSDRLESizes(VAR_7,VAR_2,VAR_7->rows);
if (VAR_18 == (MagickOffsetType *) NULL)
ThrowBinaryException(VAR_19,""MemoryAllocationFailed"",
VAR_0->filename);
VAR_10=ReadPSDChannelRLE(VAR_7,VAR_2,
VAR_3->channel_info[VAR_4].type,VAR_18,VAR_6);
VAR_18=(MagickOffsetType *) RelinquishMagickMemory(VAR_18);
}
break;
case VAR_20:
case VAR_21:
#ifdef VAR_22
VAR_10=ReadPSDChannelZip(VAR_7,VAR_3->channels,
VAR_3->channel_info[VAR_4].type,VAR_5,
VAR_3->channel_info[VAR_4].size-2,VAR_6);
#else
(void) ThrowMagickException(VAR_6,GetMagickModule(),
VAR_23,""DelegateLibrarySupportNotBuiltIn"",
""'%s' (ZLIB)"",VAR_0->filename);
#endif
break;
default:
(void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_24,
""CompressionNotSupported"",""'%.20g'"",(double) VAR_5);
break;
}
SeekBlob(VAR_0,VAR_9+VAR_3->channel_info[VAR_4].size-2,VAR_25);
if (VAR_10 == VAR_12)
{
if (VAR_8 != (Image *) NULL)
DestroyImage(VAR_8);
ThrowBinaryException(VAR_26,""UnableToDecompressImage"",
VAR_0->filename);
}
VAR_3->mask.image=VAR_8;
return(VAR_10);
}",ImageMagick/04a567494786d5bb50894fc8bb8fea0cf496bea8/psd.c/vul/before/1.json,"static MagickBooleanType ReadPSDChannel(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
  const size_t channel,const PSDCompressionType compression,
  ExceptionInfo *exception)
{
  Image
    *channel_image,
    *mask;

  MagickOffsetType
    offset;

  MagickBooleanType
    status;

  channel_image=image;
  mask=(Image *) NULL;
  if ((layer_info->channel_info[channel].type < -1) &&
      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))
    {
      const char
        *option;

      /*
        Ignore mask that is not a user supplied layer mask, if the mask is
        disabled or if the flags have unsupported values.
      */
      option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
      if ((layer_info->channel_info[channel].type != -2) ||
          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
           (IsStringTrue(option) == MagickFalse)))
        {
          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
          return(MagickTrue);
        }
      mask=CloneImage(image,layer_info->mask.page.width,
        layer_info->mask.page.height,MagickFalse,exception);
      if (mask != (Image *) NULL)
        {
          SetImageType(mask,GrayscaleType,exception);
          channel_image=mask;
        }
    }

  offset=TellBlob(image);
  status=MagickFalse;
  switch(compression)
  {
    case Raw:
      status=ReadPSDChannelRaw(channel_image,psd_info->channels,
        layer_info->channel_info[channel].type,exception);
      break;
    case RLE:
      {
        MagickOffsetType
          *sizes;

        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
        if (sizes == (MagickOffsetType *) NULL)
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        status=ReadPSDChannelRLE(channel_image,psd_info,
          layer_info->channel_info[channel].type,sizes,exception);
        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
      }
      break;
    case ZipWithPrediction:
    case ZipWithoutPrediction:
#ifdef MAGICKCORE_ZLIB_DELEGATE
      status=ReadPSDChannelZip(channel_image,layer_info->channels,
        layer_info->channel_info[channel].type,compression,
        layer_info->channel_info[channel].size-2,exception);
#else
      (void) ThrowMagickException(exception,GetMagickModule(),
          MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
            ""'%s' (ZLIB)"",image->filename);
#endif
      break;
    default:
      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
        ""CompressionNotSupported"",""'%.20g'"",(double) compression);
      break;
  }

  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
  if (status == MagickFalse)
    {
      if (mask != (Image *) NULL)
        DestroyImage(mask);
      ThrowBinaryException(CoderError,""UnableToDecompressImage"",
        image->filename);
    }
  layer_info->mask.image=mask;
  return(status);
}","static MagickBooleanType ReadPSDChannel(Image *VAR_0,
  const ImageInfo *VAR_1,const PSDInfo *VAR_2,LayerInfo* VAR_3,
  const size_t VAR_4,const PSDCompressionType VAR_5,
  ExceptionInfo *VAR_6)
{
  Image
    *VAR_7,
    *VAR_8;

  MagickOffsetType
    VAR_9;

  MagickBooleanType
    VAR_10;

  VAR_7=VAR_0;
  VAR_8=(Image *) NULL;
  if ((VAR_3->channel_info[VAR_4].type < -1) &&
      (VAR_3->mask.page.width > 0) && (VAR_3->mask.page.height > 0))
    {
      const char
        *VAR_11;

      /* COMMENT_0 */
                                                                          
                                                         
        
      VAR_11=GetImageOption(VAR_1,""psd:preserve-opacity-mask"");
      if ((VAR_3->channel_info[VAR_4].type != -2) ||
          (VAR_3->mask.flags > 2) || ((VAR_3->mask.flags & 0x02) &&
           (IsStringTrue(VAR_11) == VAR_12)))
        {
          SeekBlob(VAR_0,VAR_3->channel_info[VAR_4].size-2,VAR_13);
          return(VAR_14);
        }
      VAR_8=CloneImage(VAR_0,VAR_3->mask.page.width,
        VAR_3->mask.page.height,VAR_12,VAR_6);
      if (VAR_8 != (Image *) NULL)
        {
          SetImageType(VAR_8,VAR_15,VAR_6);
          VAR_7=VAR_8;
        }
    }

  VAR_9=TellBlob(VAR_0);
  VAR_10=VAR_12;
  switch(VAR_5)
  {
    case VAR_16:
      VAR_10=ReadPSDChannelRaw(VAR_7,VAR_2->channels,
        VAR_3->channel_info[VAR_4].type,VAR_6);
      break;
    case VAR_17:
      {
        MagickOffsetType
          *VAR_18;

        VAR_18=ReadPSDRLESizes(VAR_7,VAR_2,VAR_7->rows);
        if (VAR_18 == (MagickOffsetType *) NULL)
          ThrowBinaryException(VAR_19,""MemoryAllocationFailed"",
            VAR_0->filename);
        VAR_10=ReadPSDChannelRLE(VAR_7,VAR_2,
          VAR_3->channel_info[VAR_4].type,VAR_18,VAR_6);
        VAR_18=(MagickOffsetType *) RelinquishMagickMemory(VAR_18);
      }
      break;
    case VAR_20:
    case VAR_21:
#ifdef VAR_22
      VAR_10=ReadPSDChannelZip(VAR_7,VAR_3->channels,
        VAR_3->channel_info[VAR_4].type,VAR_5,
        VAR_3->channel_info[VAR_4].size-2,VAR_6);
#else
      (void) ThrowMagickException(VAR_6,GetMagickModule(),
          VAR_23,""DelegateLibrarySupportNotBuiltIn"",
            ""'%s' (ZLIB)"",VAR_0->filename);
#endif
      break;
    default:
      (void) ThrowMagickException(VAR_6,GetMagickModule(),VAR_24,
        ""CompressionNotSupported"",""'%.20g'"",(double) VAR_5);
      break;
  }

  SeekBlob(VAR_0,VAR_9+VAR_3->channel_info[VAR_4].size-2,VAR_25);
  if (VAR_10 == VAR_12)
    {
      if (VAR_8 != (Image *) NULL)
        DestroyImage(VAR_8);
      ThrowBinaryException(VAR_26,""UnableToDecompressImage"",
        VAR_0->filename);
    }
  VAR_3->mask.image=VAR_8;
  return(VAR_10);
}",ImageMagick/04a567494786d5bb50894fc8bb8fea0cf496bea8/psd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -29,10 +29,10 @@
       if ((layer_info->channel_info[channel].type != -2) ||
           (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
            (IsStringTrue(option) == MagickFalse)))
-      {
-        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
-        return(MagickTrue);
-      }
+        {
+          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
+          return(MagickTrue);
+        }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
       if (mask != (Image *) NULL)","{'deleted_lines': ['      {', '        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);', '        return(MagickTrue);', '      }'], 'added_lines': ['        {', '          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);', '          return(MagickTrue);', '        }']}",True,"In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large ""length"" field in the header but does not contain sufficient backing data, is provided, the loop over ""length"" would consume huge CPU resources, since there is no EOF check inside the loop.",6.5,MEDIUM,1,test,2017-08-31T18:49:19Z,2
CVE-2017-14174,['CWE-834'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,ImageMagick,Slightly different fix for #714,04a567494786d5bb50894fc8bb8fea0cf496bea8,https://github.com/ImageMagick/ImageMagick/commit/04a567494786d5bb50894fc8bb8fea0cf496bea8,coders/psd.c,ReadPSDLayersInternal,"static MagickBooleanType ReadPSDLayersInternal(Image *image,
const ImageInfo *image_info,const PSDInfo *psd_info,
const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
char
type[4];
LayerInfo
*layer_info;
MagickSizeType
size;
MagickBooleanType
status;
register ssize_t
i;
ssize_t
count,
j,
number_layers;
size=GetPSDSize(psd_info,image);
if (size == 0)
{
(void) ReadBlobLong(image);
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
status=MagickFalse;
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
return(MagickTrue);
else
{
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
size=GetPSDSize(psd_info,image);
else
return(MagickTrue);
}
}
status=MagickTrue;
if (size != 0)
{
layer_info=(LayerInfo *) NULL;
number_layers=(short) ReadBlobShort(image);
if (number_layers < 0)
{
number_layers=MagickAbsoluteValue(number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  negative layer count corrected for"");
image->alpha_trait=BlendPixelTrait;
}
if (skip_layers != MagickFalse)
return(MagickTrue);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  image contains %.20g layers"",(double) number_layers);
if (number_layers == 0)
ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
image->filename);
layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
sizeof(*layer_info));
if (layer_info == (LayerInfo *) NULL)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
(void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
sizeof(*layer_info));
for (i=0; i < number_layers; i++)
{
ssize_t
x,
y;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading layer #%.20g"",(double) i+1);
layer_info[i].page.y=ReadBlobSignedLong(image);
layer_info[i].page.x=ReadBlobSignedLong(image);
y=ReadBlobSignedLong(image);
x=ReadBlobSignedLong(image);
layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
layer_info[i].channels=ReadBlobShort(image);
if (layer_info[i].channels > MaxPSDChannels)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
image->filename);
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) layer_info[i].page.x,(double) layer_info[i].page.y,
(double) layer_info[i].page.height,(double)
layer_info[i].page.width,(double) layer_info[i].channels);
for (j=0; j < (ssize_t) layer_info[i].channels; j++)
{
layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
image);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
(double) layer_info[i].channel_info[j].type,
(double) layer_info[i].channel_info[j].size);
}
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", type);
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
image->filename);
}
count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
ReversePSDString(image,layer_info[i].blendkey,4);
layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(image));
layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
layer_info[i].flags=(unsigned char) ReadBlobByte(image);
layer_info[i].visible=!(layer_info[i].flags & 0x02);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
layer_info[i].blendkey,(double) layer_info[i].opacity,
layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
layer_info[i].visible ? ""true"" : ""false"");
(void) ReadBlobByte(image);  
size=ReadBlobLong(image);
if (size != 0)
{
MagickSizeType
combined_length,
length;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    layer contains additional info"");
length=ReadBlobLong(image);
combined_length=length+4;
if (length != 0)
{
layer_info[i].mask.page.y=ReadBlobSignedLong(image);
layer_info[i].mask.page.x=ReadBlobSignedLong(image);
layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-
layer_info[i].mask.page.y);
layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-
layer_info[i].mask.page.x);
layer_info[i].mask.background=(unsigned char) ReadBlobByte(
image);
layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
if (!(layer_info[i].mask.flags & 0x01))
{
layer_info[i].mask.page.y=layer_info[i].mask.page.y-
layer_info[i].page.y;
layer_info[i].mask.page.x=layer_info[i].mask.page.x-
layer_info[i].page.x;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) layer_info[i].mask.page.x,(double)
layer_info[i].mask.page.y,(double)
layer_info[i].mask.page.width,(double)
layer_info[i].mask.page.height,(double) ((MagickOffsetType)
length)-18);
if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
length=ReadBlobLong(image);
combined_length+=length+4;
if (length != 0)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) length));
for (j=0; j < (ssize_t) length; j+=8)
{
size_t blend_source=ReadBlobLong(image);
size_t blend_dest=ReadBlobLong(image);
if (EOFBlob(image) != MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""InsufficientImageDataInFile"",image->filename);
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
blend_source,(unsigned int) blend_dest);
}
}
length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
combined_length+=length+1;
if (length > 0)
(void) ReadBlob(image,(size_t) length++,layer_info[i].name);
layer_info[i].name[length]='\0';
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer name: %s"",layer_info[i].name);
if ((length % 4) != 0)
{
length=4-(length % 4);
combined_length+=length;
if (DiscardBlobBytes(image,length) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
length=(MagickSizeType) size-combined_length;
if (length > 0)
{
unsigned char
*info;
if (length > GetBlobSize(image))
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""InsufficientImageDataInFile"",image->filename);
}
layer_info[i].info=AcquireStringInfo((const size_t) length);
info=GetStringInfoDatum(layer_info[i].info);
(void) ReadBlob(image,(const size_t) length,info);
}
}
}
for (i=0; i < number_layers; i++)
{
if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer data is empty"");
if (layer_info[i].info != (StringInfo *) NULL)
layer_info[i].info=DestroyStringInfo(layer_info[i].info);
continue;
}
layer_info[i].image=CloneImage(image,layer_info[i].page.width,
layer_info[i].page.height,MagickFalse,exception);
if (layer_info[i].image == (Image *) NULL)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) i);
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
if (layer_info[i].info != (StringInfo *) NULL)
{
(void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
layer_info[i].info,exception);
layer_info[i].info=DestroyStringInfo(layer_info[i].info);
}
}
if (image_info->ping == MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=0; j < layer_info[i].channels; j++)
{
if (DiscardBlobBytes(image,(MagickSizeType)
layer_info[i].channel_info[j].size) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
continue;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading data for layer %.20g"",(double) i);
status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
exception);
if (status == MagickFalse)
break;
status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
number_layers);
if (status == MagickFalse)
break;
}
}
if (status != MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=i; j < number_layers - 1; j++)
layer_info[j] = layer_info[j+1];
number_layers--;
i--;
}
}
if (number_layers > 0)
{
for (i=0; i < number_layers; i++)
{
if (i > 0)
layer_info[i].image->previous=layer_info[i-1].image;
if (i < (number_layers-1))
layer_info[i].image->next=layer_info[i+1].image;
layer_info[i].image->page=layer_info[i].page;
}
image->next=layer_info[0].image;
layer_info[0].image->previous=image;
}
layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
}
else
layer_info=DestroyLayerInfo(layer_info,number_layers);
}
return(status);
}","static MagickBooleanType ReadPSDLayersInternal(Image *VAR_0,
const ImageInfo *VAR_1,const PSDInfo *VAR_2,
const MagickBooleanType VAR_3,ExceptionInfo *VAR_4)
{
char
VAR_5[4];
LayerInfo
*VAR_6;
MagickSizeType
VAR_7;
MagickBooleanType
VAR_8;
register ssize_t
VAR_9;
ssize_t
VAR_10,
VAR_11,
VAR_12;
VAR_7=GetPSDSize(VAR_2,VAR_0);
if (VAR_7 == 0)
{
(void) ReadBlobLong(VAR_0);
VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
ReversePSDString(VAR_0,VAR_5,4);
VAR_8=VAR_13;
if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
return(VAR_14);
else
{
VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
ReversePSDString(VAR_0,VAR_5,4);
if ((VAR_10 != 0) && (LocaleNCompare(VAR_5,""Lr16"",4) == 0))
VAR_7=GetPSDSize(VAR_2,VAR_0);
else
return(VAR_14);
}
}
VAR_8=VAR_14;
if (VAR_7 != 0)
{
VAR_6=(LayerInfo *) NULL;
VAR_12=(short) ReadBlobShort(VAR_0);
if (VAR_12 < 0)
{
VAR_12=MagickAbsoluteValue(VAR_12);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  negative layer count corrected for"");
VAR_0->alpha_trait=VAR_16;
}
if (VAR_3 != VAR_13)
return(VAR_14);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  image contains %.20g layers"",(double) VAR_12);
if (VAR_12 == 0)
ThrowBinaryException(VAR_17,""InvalidNumberOfLayers"",
VAR_0->filename);
VAR_6=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_12,
sizeof(*VAR_6));
if (VAR_6 == (LayerInfo *) NULL)
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_0->filename);
}
(void) ResetMagickMemory(VAR_6,0,(size_t) VAR_12*
sizeof(*VAR_6));
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
ssize_t
VAR_19,
VAR_20;
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  reading layer #%.20g"",(double) VAR_9+1);
VAR_6[VAR_9].page.y=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].page.x=ReadBlobSignedLong(VAR_0);
VAR_20=ReadBlobSignedLong(VAR_0);
VAR_19=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].page.width=(size_t) (VAR_19-VAR_6[VAR_9].page.x);
VAR_6[VAR_9].page.height=(size_t) (VAR_20-VAR_6[VAR_9].page.y);
VAR_6[VAR_9].channels=ReadBlobShort(VAR_0);
if (VAR_6[VAR_9].channels > VAR_21)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_17,""MaximumChannelsExceeded"",
VAR_0->filename);
}
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) VAR_6[VAR_9].page.x,(double) VAR_6[VAR_9].page.y,
(double) VAR_6[VAR_9].page.height,(double)
VAR_6[VAR_9].page.width,(double) VAR_6[VAR_9].channels);
for (VAR_11=0; VAR_11 < (ssize_t) VAR_6[VAR_9].channels; VAR_11++)
{
VAR_6[VAR_9].channel_info[VAR_11].type=(short) ReadBlobShort(VAR_0);
VAR_6[VAR_9].channel_info[VAR_11].size=(size_t) GetPSDSize(VAR_2,
VAR_0);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_11,
(double) VAR_6[VAR_9].channel_info[VAR_11].type,
(double) VAR_6[VAR_9].channel_info[VAR_11].size);
}
VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
ReversePSDString(VAR_0,VAR_5,4);
if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", VAR_5);
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_17,""ImproperImageHeader"",
VAR_0->filename);
}
VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_6[VAR_9].blendkey);
ReversePSDString(VAR_0,VAR_6[VAR_9].blendkey,4);
VAR_6[VAR_9].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(VAR_0));
VAR_6[VAR_9].clipping=(unsigned char) ReadBlobByte(VAR_0);
VAR_6[VAR_9].flags=(unsigned char) ReadBlobByte(VAR_0);
VAR_6[VAR_9].visible=!(VAR_6[VAR_9].flags & 0x02);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
VAR_6[VAR_9].blendkey,(double) VAR_6[VAR_9].opacity,
VAR_6[VAR_9].clipping ? ""true"" : ""false"",VAR_6[VAR_9].flags,
VAR_6[VAR_9].visible ? ""true"" : ""false"");
(void) ReadBlobByte(VAR_0);  
VAR_7=ReadBlobLong(VAR_0);
if (VAR_7 != 0)
{
MagickSizeType
VAR_22,
VAR_23;
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""    layer contains additional info"");
VAR_23=ReadBlobLong(VAR_0);
VAR_22=VAR_23+4;
if (VAR_23 != 0)
{
VAR_6[VAR_9].mask.page.y=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].mask.page.x=ReadBlobSignedLong(VAR_0);
VAR_6[VAR_9].mask.page.height=(size_t) (ReadBlobSignedLong(VAR_0)-
VAR_6[VAR_9].mask.page.y);
VAR_6[VAR_9].mask.page.width=(size_t) (ReadBlobSignedLong(VAR_0)-
VAR_6[VAR_9].mask.page.x);
VAR_6[VAR_9].mask.background=(unsigned char) ReadBlobByte(
VAR_0);
VAR_6[VAR_9].mask.flags=(unsigned char) ReadBlobByte(VAR_0);
if (!(VAR_6[VAR_9].mask.flags & 0x01))
{
VAR_6[VAR_9].mask.page.y=VAR_6[VAR_9].mask.page.y-
VAR_6[VAR_9].page.y;
VAR_6[VAR_9].mask.page.x=VAR_6[VAR_9].mask.page.x-
VAR_6[VAR_9].page.x;
}
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) VAR_6[VAR_9].mask.page.x,(double)
VAR_6[VAR_9].mask.page.y,(double)
VAR_6[VAR_9].mask.page.width,(double)
VAR_6[VAR_9].mask.page.height,(double) ((MagickOffsetType)
VAR_23)-18);
if (DiscardBlobBytes(VAR_0,(MagickSizeType) (VAR_23-18)) == VAR_13)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_17,
""UnexpectedEndOfFile"",VAR_0->filename);
}
}
VAR_23=ReadBlobLong(VAR_0);
VAR_22+=VAR_23+4;
if (VAR_23 != 0)
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) VAR_23));
for (VAR_11=0; VAR_11 < (ssize_t) VAR_23; VAR_11+=8)
{
size_t VAR_24=ReadBlobLong(VAR_0);
size_t VAR_25=ReadBlobLong(VAR_0);
if (EOFBlob(VAR_0) != VAR_13)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_17,
""InsufficientImageDataInFile"",VAR_0->filename);
}
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
VAR_24,(unsigned int) VAR_25);
}
}
VAR_23=(MagickSizeType) (unsigned char) ReadBlobByte(VAR_0);
VAR_22+=VAR_23+1;
if (VAR_23 > 0)
(void) ReadBlob(VAR_0,(size_t) VAR_23++,VAR_6[VAR_9].name);
VAR_6[VAR_9].name[VAR_23]='\0';
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer name: %s"",VAR_6[VAR_9].name);
if ((VAR_23 % 4) != 0)
{
VAR_23=4-(VAR_23 % 4);
VAR_22+=VAR_23;
if (DiscardBlobBytes(VAR_0,VAR_23) == VAR_13)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_17,
""UnexpectedEndOfFile"",VAR_0->filename);
}
}
VAR_23=(MagickSizeType) VAR_7-VAR_22;
if (VAR_23 > 0)
{
unsigned char
*VAR_26;
if (VAR_23 > GetBlobSize(VAR_0))
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_17,
""InsufficientImageDataInFile"",VAR_0->filename);
}
VAR_6[VAR_9].info=AcquireStringInfo((const size_t) VAR_23);
VAR_26=GetStringInfoDatum(VAR_6[VAR_9].info);
(void) ReadBlob(VAR_0,(const size_t) VAR_23,VAR_26);
}
}
}
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if ((VAR_6[VAR_9].page.width == 0) || (VAR_6[VAR_9].page.height == 0))
{
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""      layer data is empty"");
if (VAR_6[VAR_9].info != (StringInfo *) NULL)
VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
continue;
}
VAR_6[VAR_9].image=CloneImage(VAR_0,VAR_6[VAR_9].page.width,
VAR_6[VAR_9].page.height,VAR_13,VAR_4);
if (VAR_6[VAR_9].image == (Image *) NULL)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) VAR_9);
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_0->filename);
}
if (VAR_6[VAR_9].info != (StringInfo *) NULL)
{
(void) SetImageProfile(VAR_6[VAR_9].image,""psd:additional-info"",
VAR_6[VAR_9].info,VAR_4);
VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
}
}
if (VAR_1->ping == VAR_13)
{
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if (VAR_6[VAR_9].image == (Image *) NULL)
{
for (VAR_11=0; VAR_11 < VAR_6[VAR_9].channels; VAR_11++)
{
if (DiscardBlobBytes(VAR_0,(MagickSizeType)
VAR_6[VAR_9].channel_info[VAR_11].size) == VAR_13)
{
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
ThrowBinaryException(VAR_17,
""UnexpectedEndOfFile"",VAR_0->filename);
}
}
continue;
}
if (VAR_0->debug != VAR_13)
(void) LogMagickEvent(VAR_15,GetMagickModule(),
""  reading data for layer %.20g"",(double) VAR_9);
VAR_8=ReadPSDLayer(VAR_0,VAR_1,VAR_2,&VAR_6[VAR_9],
VAR_4);
if (VAR_8 == VAR_13)
break;
VAR_8=SetImageProgress(VAR_0,VAR_27,VAR_9,(MagickSizeType)
VAR_12);
if (VAR_8 == VAR_13)
break;
}
}
if (VAR_8 != VAR_13)
{
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if (VAR_6[VAR_9].image == (Image *) NULL)
{
for (VAR_11=VAR_9; VAR_11 < VAR_12 - 1; VAR_11++)
VAR_6[VAR_11] = VAR_6[VAR_11+1];
VAR_12--;
VAR_9--;
}
}
if (VAR_12 > 0)
{
for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
{
if (VAR_9 > 0)
VAR_6[VAR_9].image->previous=VAR_6[VAR_9-1].image;
if (VAR_9 < (VAR_12-1))
VAR_6[VAR_9].image->next=VAR_6[VAR_9+1].image;
VAR_6[VAR_9].image->page=VAR_6[VAR_9].page;
}
VAR_0->next=VAR_6[0].image;
VAR_6[0].image->previous=VAR_0;
}
VAR_6=(LayerInfo *) RelinquishMagickMemory(VAR_6);
}
else
VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
}
return(VAR_8);
}",ImageMagick/04a567494786d5bb50894fc8bb8fea0cf496bea8/psd.c/vul/before/0.json,"static MagickBooleanType ReadPSDLayersInternal(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      /*
        Skip layers & masks.
      */
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          /*
            The first alpha channel in the merged result contains the
            transparency data for the merged result.
          */
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->alpha_trait=BlendPixelTrait;
        }

      /*
        We only need to know if the image has an alpha channel
      */
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  /* filler */

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                /*
                  Layer mask info.
                */
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double)
                    layer_info[i].mask.page.width,(double)
                    layer_info[i].mask.page.height,(double) ((MagickOffsetType)
                    length)-18);
                /*
                  Skip over the rest of the layer mask information.
                */
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                /*
                  Layer blending ranges info.
                */
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            /*
              Layer name.
            */
            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                /* Skip over the padding of the layer name */
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                if (length > GetBlobSize(image))
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""InsufficientImageDataInFile"",image->filename);
                  }
                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer data is empty"");
            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
            continue;
          }

        /*
          Allocate layered image.
        */
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info,exception);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);

            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}","static MagickBooleanType ReadPSDLayersInternal(Image *VAR_0,
  const ImageInfo *VAR_1,const PSDInfo *VAR_2,
  const MagickBooleanType VAR_3,ExceptionInfo *VAR_4)
{
  char
    VAR_5[4];

  LayerInfo
    *VAR_6;

  MagickSizeType
    VAR_7;

  MagickBooleanType
    VAR_8;

  register ssize_t
    VAR_9;

  ssize_t
    VAR_10,
    VAR_11,
    VAR_12;

  VAR_7=GetPSDSize(VAR_2,VAR_0);
  if (VAR_7 == 0)
    {
      /* COMMENT_0 */
                            
        
      (void) ReadBlobLong(VAR_0);
      VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
      ReversePSDString(VAR_0,VAR_5,4);
      VAR_8=VAR_13;
      if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
        return(VAR_14);
      else
        {
          VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
          ReversePSDString(VAR_0,VAR_5,4);
          if ((VAR_10 != 0) && (LocaleNCompare(VAR_5,""Lr16"",4) == 0))
            VAR_7=GetPSDSize(VAR_2,VAR_0);
          else
            return(VAR_14);
        }
    }
  VAR_8=VAR_14;
  if (VAR_7 != 0)
    {
      VAR_6=(LayerInfo *) NULL;
      VAR_12=(short) ReadBlobShort(VAR_0);

      if (VAR_12 < 0)
        {
          /* COMMENT_3 */
                                                                     
                                                    
            
          VAR_12=MagickAbsoluteValue(VAR_12);
          if (VAR_0->debug != VAR_13)
            (void) LogMagickEvent(VAR_15,GetMagickModule(),
              ""  negative layer count corrected for"");
          VAR_0->alpha_trait=VAR_16;
        }

      /* COMMENT_7 */
                                                              
        
      if (VAR_3 != VAR_13)
        return(VAR_14);

      if (VAR_0->debug != VAR_13)
        (void) LogMagickEvent(VAR_15,GetMagickModule(),
          ""  image contains %.20g layers"",(double) VAR_12);

      if (VAR_12 == 0)
        ThrowBinaryException(VAR_17,""InvalidNumberOfLayers"",
          VAR_0->filename);

      VAR_6=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_12,
        sizeof(*VAR_6));
      if (VAR_6 == (LayerInfo *) NULL)
        {
          if (VAR_0->debug != VAR_13)
            (void) LogMagickEvent(VAR_15,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
            VAR_0->filename);
        }
      (void) ResetMagickMemory(VAR_6,0,(size_t) VAR_12*
        sizeof(*VAR_6));

      for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
      {
        ssize_t
          VAR_19,
          VAR_20;

        if (VAR_0->debug != VAR_13)
          (void) LogMagickEvent(VAR_15,GetMagickModule(),
            ""  reading layer #%.20g"",(double) VAR_9+1);
        VAR_6[VAR_9].page.y=ReadBlobSignedLong(VAR_0);
        VAR_6[VAR_9].page.x=ReadBlobSignedLong(VAR_0);
        VAR_20=ReadBlobSignedLong(VAR_0);
        VAR_19=ReadBlobSignedLong(VAR_0);
        VAR_6[VAR_9].page.width=(size_t) (VAR_19-VAR_6[VAR_9].page.x);
        VAR_6[VAR_9].page.height=(size_t) (VAR_20-VAR_6[VAR_9].page.y);
        VAR_6[VAR_9].channels=ReadBlobShort(VAR_0);
        if (VAR_6[VAR_9].channels > VAR_21)
          {
            VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
            ThrowBinaryException(VAR_17,""MaximumChannelsExceeded"",
              VAR_0->filename);
          }
        if (VAR_0->debug != VAR_13)
          (void) LogMagickEvent(VAR_15,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) VAR_6[VAR_9].page.x,(double) VAR_6[VAR_9].page.y,
            (double) VAR_6[VAR_9].page.height,(double)
            VAR_6[VAR_9].page.width,(double) VAR_6[VAR_9].channels);
        for (VAR_11=0; VAR_11 < (ssize_t) VAR_6[VAR_9].channels; VAR_11++)
        {
          VAR_6[VAR_9].channel_info[VAR_11].type=(short) ReadBlobShort(VAR_0);
          VAR_6[VAR_9].channel_info[VAR_11].size=(size_t) GetPSDSize(VAR_2,
            VAR_0);
          if (VAR_0->debug != VAR_13)
            (void) LogMagickEvent(VAR_15,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_11,
              (double) VAR_6[VAR_9].channel_info[VAR_11].type,
              (double) VAR_6[VAR_9].channel_info[VAR_11].size);
        }
        VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_5);
        ReversePSDString(VAR_0,VAR_5,4);
        if ((VAR_10 == 0) || (LocaleNCompare(VAR_5,""8BIM"",4) != 0))
          {
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", VAR_5);
            VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
            ThrowBinaryException(VAR_17,""ImproperImageHeader"",
              VAR_0->filename);
          }
        VAR_10=ReadBlob(VAR_0,4,(unsigned char *) VAR_6[VAR_9].blendkey);
        ReversePSDString(VAR_0,VAR_6[VAR_9].blendkey,4);
        VAR_6[VAR_9].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(VAR_0));
        VAR_6[VAR_9].clipping=(unsigned char) ReadBlobByte(VAR_0);
        VAR_6[VAR_9].flags=(unsigned char) ReadBlobByte(VAR_0);
        VAR_6[VAR_9].visible=!(VAR_6[VAR_9].flags & 0x02);
        if (VAR_0->debug != VAR_13)
          (void) LogMagickEvent(VAR_15,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            VAR_6[VAR_9].blendkey,(double) VAR_6[VAR_9].opacity,
            VAR_6[VAR_9].clipping ? ""true"" : ""false"",VAR_6[VAR_9].flags,
            VAR_6[VAR_9].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(VAR_0);  /* COMMENT_10 */

        VAR_7=ReadBlobLong(VAR_0);
        if (VAR_7 != 0)
          {
            MagickSizeType
              VAR_22,
              VAR_23;

            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""    layer contains additional info"");
            VAR_23=ReadBlobLong(VAR_0);
            VAR_22=VAR_23+4;
            if (VAR_23 != 0)
              {
                /* COMMENT_11 */
                                  
                  
                VAR_6[VAR_9].mask.page.y=ReadBlobSignedLong(VAR_0);
                VAR_6[VAR_9].mask.page.x=ReadBlobSignedLong(VAR_0);
                VAR_6[VAR_9].mask.page.height=(size_t) (ReadBlobSignedLong(VAR_0)-
                  VAR_6[VAR_9].mask.page.y);
                VAR_6[VAR_9].mask.page.width=(size_t) (ReadBlobSignedLong(VAR_0)-
                  VAR_6[VAR_9].mask.page.x);
                VAR_6[VAR_9].mask.background=(unsigned char) ReadBlobByte(
                  VAR_0);
                VAR_6[VAR_9].mask.flags=(unsigned char) ReadBlobByte(VAR_0);
                if (!(VAR_6[VAR_9].mask.flags & 0x01))
                  {
                    VAR_6[VAR_9].mask.page.y=VAR_6[VAR_9].mask.page.y-
                      VAR_6[VAR_9].page.y;
                    VAR_6[VAR_9].mask.page.x=VAR_6[VAR_9].mask.page.x-
                      VAR_6[VAR_9].page.x;
                  }
                if (VAR_0->debug != VAR_13)
                  (void) LogMagickEvent(VAR_15,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) VAR_6[VAR_9].mask.page.x,(double)
                    VAR_6[VAR_9].mask.page.y,(double)
                    VAR_6[VAR_9].mask.page.width,(double)
                    VAR_6[VAR_9].mask.page.height,(double) ((MagickOffsetType)
                    VAR_23)-18);
                /* COMMENT_14 */
                                                                   
                  
                if (DiscardBlobBytes(VAR_0,(MagickSizeType) (VAR_23-18)) == VAR_13)
                  {
                    VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                    ThrowBinaryException(VAR_17,
                      ""UnexpectedEndOfFile"",VAR_0->filename);
                  }
              }
            VAR_23=ReadBlobLong(VAR_0);
            VAR_22+=VAR_23+4;
            if (VAR_23 != 0)
              {
                /* COMMENT_17 */
                                             
                  
                if (VAR_0->debug != VAR_13)
                  (void) LogMagickEvent(VAR_15,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) VAR_23));
                if (DiscardBlobBytes(VAR_0,VAR_23) == VAR_13)
                  {
                    VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                    ThrowBinaryException(VAR_17,
                      ""UnexpectedEndOfFile"",VAR_0->filename);
                  }
              }
            /* COMMENT_20 */
                         
              
            VAR_23=(MagickSizeType) (unsigned char) ReadBlobByte(VAR_0);
            VAR_22+=VAR_23+1;
            if (VAR_23 > 0)
              (void) ReadBlob(VAR_0,(size_t) VAR_23++,VAR_6[VAR_9].name);
            VAR_6[VAR_9].name[VAR_23]='\0';
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""      layer name: %s"",VAR_6[VAR_9].name);
            if ((VAR_23 % 4) != 0)
              {
                VAR_23=4-(VAR_23 % 4);
                VAR_22+=VAR_23;
                /* COMMENT_23 */
                if (DiscardBlobBytes(VAR_0,VAR_23) == VAR_13)
                  {
                    VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                    ThrowBinaryException(VAR_17,
                      ""UnexpectedEndOfFile"",VAR_0->filename);
                  }
              }
            VAR_23=(MagickSizeType) VAR_7-VAR_22;
            if (VAR_23 > 0)
              {
                unsigned char
                  *VAR_24;

                if (VAR_23 > GetBlobSize(VAR_0))
                  {
                    VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                    ThrowBinaryException(VAR_17,
                      ""InsufficientImageDataInFile"",VAR_0->filename);
                  }
                VAR_6[VAR_9].info=AcquireStringInfo((const size_t) VAR_23);
                VAR_24=GetStringInfoDatum(VAR_6[VAR_9].info);
                (void) ReadBlob(VAR_0,(const size_t) VAR_23,VAR_24);
              }
          }
      }

      for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
      {
        if ((VAR_6[VAR_9].page.width == 0) || (VAR_6[VAR_9].page.height == 0))
          {
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""      layer data is empty"");
            if (VAR_6[VAR_9].info != (StringInfo *) NULL)
              VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
            continue;
          }

        /* COMMENT_24 */
                                 
          
        VAR_6[VAR_9].image=CloneImage(VAR_0,VAR_6[VAR_9].page.width,
          VAR_6[VAR_9].page.height,VAR_13,VAR_4);
        if (VAR_6[VAR_9].image == (Image *) NULL)
          {
            VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) VAR_9);
            ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
              VAR_0->filename);
          }

        if (VAR_6[VAR_9].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(VAR_6[VAR_9].image,""psd:additional-info"",
              VAR_6[VAR_9].info,VAR_4);
            VAR_6[VAR_9].info=DestroyStringInfo(VAR_6[VAR_9].info);
          }
      }

      if (VAR_1->ping == VAR_13)
        {
          for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
          {
            if (VAR_6[VAR_9].image == (Image *) NULL)
              {
                for (VAR_11=0; VAR_11 < VAR_6[VAR_9].channels; VAR_11++)
                {
                  if (DiscardBlobBytes(VAR_0,(MagickSizeType)
                      VAR_6[VAR_9].channel_info[VAR_11].size) == VAR_13)
                    {
                      VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
                      ThrowBinaryException(VAR_17,
                        ""UnexpectedEndOfFile"",VAR_0->filename);
                    }
                }
                continue;
              }

            if (VAR_0->debug != VAR_13)
              (void) LogMagickEvent(VAR_15,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) VAR_9);

            VAR_8=ReadPSDLayer(VAR_0,VAR_1,VAR_2,&VAR_6[VAR_9],
              VAR_4);
            if (VAR_8 == VAR_13)
              break;

            VAR_8=SetImageProgress(VAR_0,VAR_25,VAR_9,(MagickSizeType)
              VAR_12);
            if (VAR_8 == VAR_13)
              break;
          }
        }

      if (VAR_8 != VAR_13)
        {
          for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
          {
            if (VAR_6[VAR_9].image == (Image *) NULL)
              {
                for (VAR_11=VAR_9; VAR_11 < VAR_12 - 1; VAR_11++)
                  VAR_6[VAR_11] = VAR_6[VAR_11+1];
                VAR_12--;
                VAR_9--;
              }
          }

          if (VAR_12 > 0)
            {
              for (VAR_9=0; VAR_9 < VAR_12; VAR_9++)
              {
                if (VAR_9 > 0)
                  VAR_6[VAR_9].image->previous=VAR_6[VAR_9-1].image;
                if (VAR_9 < (VAR_12-1))
                  VAR_6[VAR_9].image->next=VAR_6[VAR_9+1].image;
                VAR_6[VAR_9].image->page=VAR_6[VAR_9].page;
              }
              VAR_0->next=VAR_6[0].image;
              VAR_6[0].image->previous=VAR_0;
            }
          VAR_6=(LayerInfo *) RelinquishMagickMemory(VAR_6);
        }
      else
        VAR_6=DestroyLayerInfo(VAR_6,VAR_12);
    }

  return(VAR_8);
}",ImageMagick/04a567494786d5bb50894fc8bb8fea0cf496bea8/psd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -217,24 +217,12 @@
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""      layer blending ranges: length=%.20g"",(double)
                     ((MagickOffsetType) length));
-                /*
-                  We read it, but don't use it...
-                */
-                for (j=0; j < (ssize_t) length; j+=8)
-                {
-                  size_t blend_source=ReadBlobLong(image);
-                  size_t blend_dest=ReadBlobLong(image);
-                  if (EOFBlob(image) != MagickFalse)
-                    {
-                      layer_info=DestroyLayerInfo(layer_info,number_layers);
-                      ThrowBinaryException(CorruptImageError,
-                        ""InsufficientImageDataInFile"",image->filename);
-                    }
-                  if (image->debug != MagickFalse)
-                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
-                      ""        source(%x), dest(%x)"",(unsigned int)
-                      blend_source,(unsigned int) blend_dest);
-                }
+                if (DiscardBlobBytes(image,length) == MagickFalse)
+                  {
+                    layer_info=DestroyLayerInfo(layer_info,number_layers);
+                    ThrowBinaryException(CorruptImageError,
+                      ""UnexpectedEndOfFile"",image->filename);
+                  }
               }
             /*
               Layer name.","{'deleted_lines': ['                /*', ""                  We read it, but don't use it..."", '                */', '                for (j=0; j < (ssize_t) length; j+=8)', '                {', '                  size_t blend_source=ReadBlobLong(image);', '                  size_t blend_dest=ReadBlobLong(image);', '                  if (EOFBlob(image) != MagickFalse)', '                    {', '                      layer_info=DestroyLayerInfo(layer_info,number_layers);', '                      ThrowBinaryException(CorruptImageError,', '                        ""InsufficientImageDataInFile"",image->filename);', '                    }', '                  if (image->debug != MagickFalse)', '                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),', '                      ""        source(%x), dest(%x)"",(unsigned int)', '                      blend_source,(unsigned int) blend_dest);', '                }'], 'added_lines': ['                if (DiscardBlobBytes(image,length) == MagickFalse)', '                  {', '                    layer_info=DestroyLayerInfo(layer_info,number_layers);', '                    ThrowBinaryException(CorruptImageError,', '                      ""UnexpectedEndOfFile"",image->filename);', '                  }']}",True,"In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large ""length"" field in the header but does not contain sufficient backing data, is provided, the loop over ""length"" would consume huge CPU resources, since there is no EOF check inside the loop.",6.5,MEDIUM,1,test,2017-08-31T18:49:19Z,2
CVE-2017-14248,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/717,c5402b6e0fcf8b694ae2af6a6652ebb8ce0ccf46,https://github.com/ImageMagick/ImageMagick/commit/c5402b6e0fcf8b694ae2af6a6652ebb8ce0ccf46,MagickCore/resize.c,SampleImage,"MagickExport Image *SampleImage(const Image *image,const size_t columns,
const size_t rows,ExceptionInfo *exception)
{
#define SampleImageTag  ""Sample/Image""
CacheView
*image_view,
*sample_view;
Image
*sample_image;
MagickBooleanType
status;
MagickOffsetType
progress;
register ssize_t
x1;
ssize_t
*x_offset,
y;
PointInfo
sample_offset;
assert(image != (const Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
if ((columns == 0) || (rows == 0))
ThrowImageException(ImageError,""NegativeOrZeroImageSize"");
if ((columns == image->columns) && (rows == image->rows))
return(CloneImage(image,0,0,MagickTrue,exception));
sample_image=CloneImage(image,columns,rows,MagickTrue,exception);
if (sample_image == (Image *) NULL)
return((Image *) NULL);
sample_offset.x=sample_offset.y=0.5-MagickEpsilon;
{
const char
*value;
value=GetImageArtifact(image,""sample:offset"");
if (value != (char *) NULL)
{
GeometryInfo
geometry_info;
MagickStatusType
flags;
(void) ParseGeometry(value,&geometry_info);
flags=ParseGeometry(value,&geometry_info);
sample_offset.x=sample_offset.y=geometry_info.rho/100.0-MagickEpsilon;
if ((flags & SigmaValue) != 0)
sample_offset.y=geometry_info.sigma/100.0-MagickEpsilon;
}
}
x_offset=(ssize_t *) AcquireQuantumMemory((size_t) sample_image->columns,
sizeof(*x_offset));
if (x_offset == (ssize_t *) NULL)
{
sample_image=DestroyImage(sample_image);
ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
}
for (x1=0; x1 < (ssize_t) sample_image->columns; x1++)
x_offset[x1]=(ssize_t) ((((double) x1+sample_offset.x)*image->columns)/
sample_image->columns);
status=MagickTrue;
progress=0;
image_view=AcquireVirtualCacheView(image,exception);
sample_view=AcquireAuthenticCacheView(sample_image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp parallel for schedule(static,4) shared(status) \
magick_threads(image,sample_image,1,1)
#endif
for (y=0; y < (ssize_t) sample_image->rows; y++)
{
register const Quantum
*magick_restrict p;
register Quantum
*magick_restrict q;
register ssize_t
x;
ssize_t
y_offset;
if (status == MagickFalse)
continue;
y_offset=(ssize_t) ((((double) y+sample_offset.y)*image->rows)/
sample_image->rows);
p=GetCacheViewVirtualPixels(image_view,0,y_offset,image->columns,1,
exception);
q=QueueCacheViewAuthenticPixels(sample_view,0,y,sample_image->columns,1,
exception);
if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
{
status=MagickFalse;
continue;
}
for (x=0; x < (ssize_t) sample_image->columns; x++)
{
register ssize_t
i;
if (GetPixelWriteMask(sample_image,q) <= (QuantumRange/2))
{
q+=GetPixelChannels(sample_image);
continue;
}
for (i=0; i < (ssize_t) GetPixelChannels(sample_image); i++)
{
PixelChannel
channel;
PixelTrait
sample_traits,
traits;
channel=GetPixelChannelChannel(image,i);
traits=GetPixelChannelTraits(image,channel);
sample_traits=GetPixelChannelTraits(sample_image,channel);
if ((traits == UndefinedPixelTrait) ||
(sample_traits == UndefinedPixelTrait))
continue;
SetPixelChannel(sample_image,channel,p[x_offset[x]*GetPixelChannels(
image)+i],q);
}
q+=GetPixelChannels(sample_image);
}
if (SyncCacheViewAuthenticPixels(sample_view,exception) == MagickFalse)
status=MagickFalse;
if (image->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
proceed;
#if defined(MAGICKCORE_OPENMP_SUPPORT)
#pragma omp critical (MagickCore_SampleImage)
#endif
proceed=SetImageProgress(image,SampleImageTag,progress++,image->rows);
if (proceed == MagickFalse)
status=MagickFalse;
}
}
image_view=DestroyCacheView(image_view);
sample_view=DestroyCacheView(sample_view);
x_offset=(ssize_t *) RelinquishMagickMemory(x_offset);
sample_image->type=image->type;
if (status == MagickFalse)
sample_image=DestroyImage(sample_image);
return(sample_image);
}","MagickExport VAR_0 *SampleImage(const Image *VAR_1,const size_t VAR_2,
const size_t VAR_3,ExceptionInfo *VAR_4)
{
#define VAR_5  ""Sample/Image""
CacheView
*VAR_6,
*VAR_7;
Image
*VAR_8;
MagickBooleanType
VAR_9;
MagickOffsetType
VAR_10;
register ssize_t
VAR_11;
ssize_t
*VAR_12,
VAR_13;
PointInfo
VAR_14;
assert(VAR_1 != (const Image *) NULL);
assert(VAR_1->signature == VAR_15);
if (VAR_1->debug != VAR_16)
(void) LogMagickEvent(VAR_17,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_4 != (ExceptionInfo *) NULL);
assert(VAR_4->signature == VAR_15);
if ((VAR_2 == 0) || (VAR_3 == 0))
ThrowImageException(VAR_18,""NegativeOrZeroImageSize"");
if ((VAR_2 == VAR_1->columns) && (VAR_3 == VAR_1->rows))
return(CloneImage(VAR_1,0,0,VAR_19,VAR_4));
VAR_8=CloneImage(VAR_1,VAR_2,VAR_3,VAR_19,VAR_4);
if (VAR_8 == (Image *) NULL)
return((Image *) NULL);
VAR_14.x=VAR_14.y=0.5-VAR_20;
{
const char
*VAR_21;
VAR_21=GetImageArtifact(VAR_1,""sample:offset"");
if (VAR_21 != (char *) NULL)
{
GeometryInfo
VAR_22;
MagickStatusType
VAR_23;
(void) ParseGeometry(VAR_21,&VAR_22);
VAR_23=ParseGeometry(VAR_21,&VAR_22);
VAR_14.x=VAR_14.y=VAR_22.rho/100.0-VAR_20;
if ((VAR_23 & VAR_24) != 0)
VAR_14.y=VAR_22.sigma/100.0-VAR_20;
}
}
VAR_12=(ssize_t *) AcquireQuantumMemory((size_t) VAR_8->columns,
sizeof(*VAR_12));
if (VAR_12 == (ssize_t *) NULL)
{
VAR_8=DestroyImage(VAR_8);
ThrowImageException(VAR_25,""MemoryAllocationFailed"");
}
for (VAR_11=0; VAR_11 < (ssize_t) VAR_8->columns; VAR_11++)
VAR_12[VAR_11]=(ssize_t) ((((double) VAR_11+VAR_14.x)*VAR_1->columns)/
VAR_8->columns);
VAR_9=VAR_19;
VAR_10=0;
VAR_6=AcquireVirtualCacheView(VAR_1,VAR_4);
VAR_7=AcquireAuthenticCacheView(VAR_8,VAR_4);
#if defined(VAR_26)
#pragma omp parallel for schedule(static,4) shared(status) \
magick_threads(image,sample_image,1,1)
#endif
for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->rows; VAR_13++)
{
register const Quantum
*magick_restrict VAR_27;
register Quantum
*magick_restrict VAR_28;
register ssize_t
VAR_29;
ssize_t
VAR_30;
if (VAR_9 == VAR_16)
continue;
VAR_30=(ssize_t) ((((double) VAR_13+VAR_14.y)*VAR_1->rows)/
VAR_8->rows);
VAR_27=GetCacheViewVirtualPixels(VAR_6,0,VAR_30,VAR_1->columns,1,
VAR_4);
VAR_28=QueueCacheViewAuthenticPixels(VAR_7,0,VAR_13,VAR_8->columns,1,
VAR_4);
if ((VAR_27 == (const Quantum *) NULL) || (VAR_28 == (Quantum *) NULL))
{
VAR_9=VAR_16;
continue;
}
for (VAR_29=0; VAR_29 < (ssize_t) VAR_8->columns; VAR_29++)
{
register ssize_t
VAR_31;
if (GetPixelWriteMask(VAR_8,VAR_28) <= (VAR_32/2))
{
VAR_28+=GetPixelChannels(VAR_8);
continue;
}
for (VAR_31=0; VAR_31 < (ssize_t) GetPixelChannels(VAR_8); VAR_31++)
{
PixelChannel
VAR_33;
PixelTrait
VAR_34,
VAR_35;
VAR_33=GetPixelChannelChannel(VAR_1,VAR_31);
VAR_35=GetPixelChannelTraits(VAR_1,VAR_33);
VAR_34=GetPixelChannelTraits(VAR_8,VAR_33);
if ((VAR_35 == VAR_36) ||
(VAR_34 == VAR_36))
continue;
SetPixelChannel(VAR_8,VAR_33,VAR_27[VAR_12[VAR_29]*GetPixelChannels(
VAR_1)+VAR_31],VAR_28);
}
VAR_28+=GetPixelChannels(VAR_8);
}
if (SyncCacheViewAuthenticPixels(VAR_7,VAR_4) == VAR_16)
VAR_9=VAR_16;
if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
{
MagickBooleanType
VAR_37;
#if defined(VAR_26)
#pragma omp critical (MagickCore_SampleImage)
#endif
VAR_37=SetImageProgress(VAR_1,VAR_5,VAR_10++,VAR_1->rows);
if (VAR_37 == VAR_16)
VAR_9=VAR_16;
}
}
VAR_6=DestroyCacheView(VAR_6);
VAR_7=DestroyCacheView(VAR_7);
VAR_12=(ssize_t *) RelinquishMagickMemory(VAR_12);
VAR_8->type=VAR_1->type;
if (VAR_9 == VAR_16)
VAR_8=DestroyImage(VAR_8);
return(VAR_8);
}",,"MagickExport Image *SampleImage(const Image *image,const size_t columns,
  const size_t rows,ExceptionInfo *exception)
{
#define SampleImageTag  ""Sample/Image""

  CacheView
    *image_view,
    *sample_view;

  Image
    *sample_image;

  MagickBooleanType
    status;

  MagickOffsetType
    progress;

  register ssize_t
    x1;

  ssize_t
    *x_offset,
    y;

  PointInfo
    sample_offset;

  /*
    Initialize sampled image attributes.
  */
  assert(image != (const Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  if ((columns == 0) || (rows == 0))
    ThrowImageException(ImageError,""NegativeOrZeroImageSize"");
  if ((columns == image->columns) && (rows == image->rows))
    return(CloneImage(image,0,0,MagickTrue,exception));
  sample_image=CloneImage(image,columns,rows,MagickTrue,exception);
  if (sample_image == (Image *) NULL)
    return((Image *) NULL);
  /*
    Set the sampling offset, default is in the mid-point of sample regions.
  */
  sample_offset.x=sample_offset.y=0.5-MagickEpsilon;
  {
    const char
      *value;

    value=GetImageArtifact(image,""sample:offset"");
    if (value != (char *) NULL)
      {
        GeometryInfo
          geometry_info;

        MagickStatusType
          flags;

        (void) ParseGeometry(value,&geometry_info);
        flags=ParseGeometry(value,&geometry_info);
        sample_offset.x=sample_offset.y=geometry_info.rho/100.0-MagickEpsilon;
        if ((flags & SigmaValue) != 0)
          sample_offset.y=geometry_info.sigma/100.0-MagickEpsilon;
      }
  }
  /*
    Allocate scan line buffer and column offset buffers.
  */
  x_offset=(ssize_t *) AcquireQuantumMemory((size_t) sample_image->columns,
    sizeof(*x_offset));
  if (x_offset == (ssize_t *) NULL)
    {
      sample_image=DestroyImage(sample_image);
      ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  for (x1=0; x1 < (ssize_t) sample_image->columns; x1++)
    x_offset[x1]=(ssize_t) ((((double) x1+sample_offset.x)*image->columns)/
      sample_image->columns);
  /*
    Sample each row.
  */
  status=MagickTrue;
  progress=0;
  image_view=AcquireVirtualCacheView(image,exception);
  sample_view=AcquireAuthenticCacheView(sample_image,exception);
#if defined(MAGICKCORE_OPENMP_SUPPORT)
  #pragma omp parallel for schedule(static,4) shared(status) \
    magick_threads(image,sample_image,1,1)
#endif
  for (y=0; y < (ssize_t) sample_image->rows; y++)
  {
    register const Quantum
      *magick_restrict p;

    register Quantum
      *magick_restrict q;

    register ssize_t
      x;

    ssize_t
      y_offset;

    if (status == MagickFalse)
      continue;
    y_offset=(ssize_t) ((((double) y+sample_offset.y)*image->rows)/
      sample_image->rows);
    p=GetCacheViewVirtualPixels(image_view,0,y_offset,image->columns,1,
      exception);
    q=QueueCacheViewAuthenticPixels(sample_view,0,y,sample_image->columns,1,
      exception);
    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
      {
        status=MagickFalse;
        continue;
      }
    /*
      Sample each column.
    */
    for (x=0; x < (ssize_t) sample_image->columns; x++)
    {
      register ssize_t
        i;

      if (GetPixelWriteMask(sample_image,q) <= (QuantumRange/2))
        {
          q+=GetPixelChannels(sample_image);
          continue;
        }
      for (i=0; i < (ssize_t) GetPixelChannels(sample_image); i++)
      {
        PixelChannel
          channel;

        PixelTrait
          image_traits,
          traits;

        channel=GetPixelChannelChannel(sample_image,i);
        traits=GetPixelChannelTraits(sample_image,channel);
        image_traits=GetPixelChannelTraits(image,channel);
        if ((traits == UndefinedPixelTrait) ||
            (image_traits == UndefinedPixelTrait))
          continue;
        SetPixelChannel(sample_image,channel,p[x_offset[x]*GetPixelChannels(
          image)+i],q);
      }
      q+=GetPixelChannels(sample_image);
    }
    if (SyncCacheViewAuthenticPixels(sample_view,exception) == MagickFalse)
      status=MagickFalse;
    if (image->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          proceed;

#if defined(MAGICKCORE_OPENMP_SUPPORT)
        #pragma omp critical (MagickCore_SampleImage)
#endif
        proceed=SetImageProgress(image,SampleImageTag,progress++,image->rows);
        if (proceed == MagickFalse)
          status=MagickFalse;
      }
  }
  image_view=DestroyCacheView(image_view);
  sample_view=DestroyCacheView(sample_view);
  x_offset=(ssize_t *) RelinquishMagickMemory(x_offset);
  sample_image->type=image->type;
  if (status == MagickFalse)
    sample_image=DestroyImage(sample_image);
  return(sample_image);
}","MagickExport VAR_0 *SampleImage(const Image *VAR_1,const size_t VAR_2,
  const size_t VAR_3,ExceptionInfo *VAR_4)
{
#define VAR_5  ""Sample/Image""

  CacheView
    *VAR_6,
    *VAR_7;

  Image
    *VAR_8;

  MagickBooleanType
    VAR_9;

  MagickOffsetType
    VAR_10;

  register ssize_t
    VAR_11;

  ssize_t
    *VAR_12,
    VAR_13;

  PointInfo
    VAR_14;

  /* COMMENT_0 */
                                        
    
  assert(VAR_1 != (const Image *) NULL);
  assert(VAR_1->signature == VAR_15);
  if (VAR_1->debug != VAR_16)
    (void) LogMagickEvent(VAR_17,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_4 != (ExceptionInfo *) NULL);
  assert(VAR_4->signature == VAR_15);
  if ((VAR_2 == 0) || (VAR_3 == 0))
    ThrowImageException(VAR_18,""NegativeOrZeroImageSize"");
  if ((VAR_2 == VAR_1->columns) && (VAR_3 == VAR_1->rows))
    return(CloneImage(VAR_1,0,0,VAR_19,VAR_4));
  VAR_8=CloneImage(VAR_1,VAR_2,VAR_3,VAR_19,VAR_4);
  if (VAR_8 == (Image *) NULL)
    return((Image *) NULL);
  /* COMMENT_3 */
                                                                           
    
  VAR_14.x=VAR_14.y=0.5-VAR_20;
  {
    const char
      *VAR_21;

    VAR_21=GetImageArtifact(VAR_1,""sample:offset"");
    if (VAR_21 != (char *) NULL)
      {
        GeometryInfo
          VAR_22;

        MagickStatusType
          VAR_23;

        (void) ParseGeometry(VAR_21,&VAR_22);
        VAR_23=ParseGeometry(VAR_21,&VAR_22);
        VAR_14.x=VAR_14.y=VAR_22.rho/100.0-VAR_20;
        if ((VAR_23 & VAR_24) != 0)
          VAR_14.y=VAR_22.sigma/100.0-VAR_20;
      }
  }
  /* COMMENT_6 */
                                                        
    
  VAR_12=(ssize_t *) AcquireQuantumMemory((size_t) VAR_8->columns,
    sizeof(*VAR_12));
  if (VAR_12 == (ssize_t *) NULL)
    {
      VAR_8=DestroyImage(VAR_8);
      ThrowImageException(VAR_25,""MemoryAllocationFailed"");
    }
  for (VAR_11=0; VAR_11 < (ssize_t) VAR_8->columns; VAR_11++)
    VAR_12[VAR_11]=(ssize_t) ((((double) VAR_11+VAR_14.x)*VAR_1->columns)/
      VAR_8->columns);
  /* COMMENT_9 */
                    
    
  VAR_9=VAR_19;
  VAR_10=0;
  VAR_6=AcquireVirtualCacheView(VAR_1,VAR_4);
  VAR_7=AcquireAuthenticCacheView(VAR_8,VAR_4);
#if defined(VAR_26)
  #pragma omp parallel for schedule(static,4) shared(status) \
    magick_threads(image,sample_image,1,1)
#endif
  for (VAR_13=0; VAR_13 < (ssize_t) VAR_8->rows; VAR_13++)
  {
    register const Quantum
      *magick_restrict VAR_27;

    register Quantum
      *magick_restrict VAR_28;

    register ssize_t
      VAR_29;

    ssize_t
      VAR_30;

    if (VAR_9 == VAR_16)
      continue;
    VAR_30=(ssize_t) ((((double) VAR_13+VAR_14.y)*VAR_1->rows)/
      VAR_8->rows);
    VAR_27=GetCacheViewVirtualPixels(VAR_6,0,VAR_30,VAR_1->columns,1,
      VAR_4);
    VAR_28=QueueCacheViewAuthenticPixels(VAR_7,0,VAR_13,VAR_8->columns,1,
      VAR_4);
    if ((VAR_27 == (const Quantum *) NULL) || (VAR_28 == (Quantum *) NULL))
      {
        VAR_9=VAR_16;
        continue;
      }
    /* COMMENT_12 */
                         
      
    for (VAR_29=0; VAR_29 < (ssize_t) VAR_8->columns; VAR_29++)
    {
      register ssize_t
        VAR_31;

      if (GetPixelWriteMask(VAR_8,VAR_28) <= (VAR_32/2))
        {
          VAR_28+=GetPixelChannels(VAR_8);
          continue;
        }
      for (VAR_31=0; VAR_31 < (ssize_t) GetPixelChannels(VAR_8); VAR_31++)
      {
        PixelChannel
          VAR_33;

        PixelTrait
          VAR_34,
          VAR_35;

        VAR_33=GetPixelChannelChannel(VAR_8,VAR_31);
        VAR_35=GetPixelChannelTraits(VAR_8,VAR_33);
        VAR_34=GetPixelChannelTraits(VAR_1,VAR_33);
        if ((VAR_35 == VAR_36) ||
            (VAR_34 == VAR_36))
          continue;
        SetPixelChannel(VAR_8,VAR_33,VAR_27[VAR_12[VAR_29]*GetPixelChannels(
          VAR_1)+VAR_31],VAR_28);
      }
      VAR_28+=GetPixelChannels(VAR_8);
    }
    if (SyncCacheViewAuthenticPixels(VAR_7,VAR_4) == VAR_16)
      VAR_9=VAR_16;
    if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
      {
        MagickBooleanType
          VAR_37;

#if defined(VAR_26)
        #pragma omp critical (MagickCore_SampleImage)
#endif
        VAR_37=SetImageProgress(VAR_1,VAR_5,VAR_10++,VAR_1->rows);
        if (VAR_37 == VAR_16)
          VAR_9=VAR_16;
      }
  }
  VAR_6=DestroyCacheView(VAR_6);
  VAR_7=DestroyCacheView(VAR_7);
  VAR_12=(ssize_t *) RelinquishMagickMemory(VAR_12);
  VAR_8->type=VAR_1->type;
  if (VAR_9 == VAR_16)
    VAR_8=DestroyImage(VAR_8);
  return(VAR_8);
}",,"--- func_before
+++ func_after
@@ -136,14 +136,14 @@
           channel;
 
         PixelTrait
-          sample_traits,
+          image_traits,
           traits;
 
-        channel=GetPixelChannelChannel(image,i);
-        traits=GetPixelChannelTraits(image,channel);
-        sample_traits=GetPixelChannelTraits(sample_image,channel);
+        channel=GetPixelChannelChannel(sample_image,i);
+        traits=GetPixelChannelTraits(sample_image,channel);
+        image_traits=GetPixelChannelTraits(image,channel);
         if ((traits == UndefinedPixelTrait) ||
-            (sample_traits == UndefinedPixelTrait))
+            (image_traits == UndefinedPixelTrait))
           continue;
         SetPixelChannel(sample_image,channel,p[x_offset[x]*GetPixelChannels(
           image)+i],q);","{'deleted_lines': ['          sample_traits,', '        channel=GetPixelChannelChannel(image,i);', '        traits=GetPixelChannelTraits(image,channel);', '        sample_traits=GetPixelChannelTraits(sample_image,channel);', '            (sample_traits == UndefinedPixelTrait))'], 'added_lines': ['          image_traits,', '        channel=GetPixelChannelChannel(sample_image,i);', '        traits=GetPixelChannelTraits(sample_image,channel);', '        image_traits=GetPixelChannelTraits(image,channel);', '            (image_traits == UndefinedPixelTrait))']}",True,A heap-based buffer over-read in SampleImage() in MagickCore/resize.c in ImageMagick 7.0.6-8 Q16 allows remote attackers to cause a denial of service via a crafted file.,6.5,MEDIUM,1,test,2017-09-01T12:38:36Z,2
CVE-2017-14173,"['CWE-190', 'CWE-835']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/713,50f54462076648ac2e36c3f58f4dadd4babbf1c9,https://github.com/ImageMagick/ImageMagick/commit/50f54462076648ac2e36c3f58f4dadd4babbf1c9,coders/txt.c,ReadTXTImage,"static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
char
colorspace[MagickPathExtent],
text[MagickPathExtent];
Image
*image;
long
x_offset,
y_offset;
PixelInfo
pixel;
MagickBooleanType
status;
QuantumAny
range;
register ssize_t
i,
x;
register Quantum
*q;
ssize_t
count,
type,
y;
unsigned long
depth,
height,
max_value,
width;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(text,0,sizeof(text));
(void) ReadBlobString(image,text);
if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
do
{
width=0;
height=0;
max_value=0;
*colorspace='\0';
count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
colorspace);
if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
image->columns=width;
image->rows=height;
for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
image->depth=depth;
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
LocaleLower(colorspace);
i=(ssize_t) strlen(colorspace)-1;
image->alpha_trait=UndefinedPixelTrait;
if ((i > 0) && (colorspace[i] == 'a'))
{
colorspace[i]='\0';
image->alpha_trait=BlendPixelTrait;
}
type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
if (type < 0)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
(void) SetImageBackgroundColor(image,exception);
(void) SetImageColorspace(image,(ColorspaceType) type,exception);
GetPixelInfo(image,&pixel);
range=GetQuantumRange(image->depth);
for (y=0; y < (ssize_t) image->rows; y++)
{
double
alpha,
black,
blue,
green,
red;
red=0.0;
green=0.0;
blue=0.0;
black=0.0;
alpha=0.0;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (ReadBlobString(image,text) == (char *) NULL)
break;
switch (image->colorspace)
{
case GRAYColorspace:
{
if (image->alpha_trait != UndefinedPixelTrait)
{
count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
&x_offset,&y_offset,&red,&alpha);
green=red;
blue=red;
break;
}
count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,
&y_offset,&red);
green=red;
blue=red;
break;       
}
case CMYKColorspace:
{
if (image->alpha_trait != UndefinedPixelTrait)
{
count=(ssize_t) sscanf(text,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&x_offset,&y_offset,&red,&green,&blue,&black,&alpha);
break;
}
count=(ssize_t) sscanf(text,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
&y_offset,&red,&green,&blue,&black);
break;
}
default:
{
if (image->alpha_trait != UndefinedPixelTrait)
{
count=(ssize_t) sscanf(text,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&x_offset,&y_offset,&red,&green,&blue,&alpha);
break;
}
count=(ssize_t) sscanf(text,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
&y_offset,&red,&green,&blue);
break;       
}
}
if (strchr(text,'%') != (char *) NULL)
{
red*=0.01*range;
green*=0.01*range;
blue*=0.01*range;
black*=0.01*range;
alpha*=0.01*range;
}
if (image->colorspace == LabColorspace)
{
green+=(range+1)/2.0;
blue+=(range+1)/2.0;
}
pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
range);
pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
range);
pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
range);
pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),
range);
pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),
range);
q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
exception);
if (q == (Quantum *) NULL)
continue;
SetPixelViaPixelInfo(image,&pixel,q);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
}
}
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
(void) ReadBlobString(image,text);
if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
{
AcquireNextImage(image_info,image,exception);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadTXTImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
char
VAR_2[VAR_3],
VAR_4[VAR_3];
Image
*VAR_5;
long
VAR_6,
VAR_7;
PixelInfo
VAR_8;
MagickBooleanType
VAR_9;
QuantumAny
VAR_10;
register ssize_t
VAR_11,
VAR_12;
register Quantum
*VAR_13;
ssize_t
VAR_14,
VAR_15,
VAR_16;
unsigned long
VAR_17,
VAR_18,
VAR_19,
VAR_20;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_21);
if (VAR_0->debug != VAR_22)
(void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_21);
VAR_5=AcquireImage(VAR_0,VAR_1);
VAR_9=OpenBlob(VAR_0,VAR_5,VAR_24,VAR_1);
if (VAR_9 == VAR_22)
{
VAR_5=DestroyImageList(VAR_5);
return((Image *) NULL);
}
(void) ResetMagickMemory(VAR_4,0,sizeof(VAR_4));
(void) ReadBlobString(VAR_5,VAR_4);
if (LocaleNCompare((char *) VAR_4,VAR_25,strlen(VAR_25)) != 0)
ThrowReaderException(VAR_26,""ImproperImageHeader"");
do
{
VAR_20=0;
VAR_18=0;
VAR_19=0;
*VAR_2='\0';
VAR_14=(ssize_t) sscanf(VAR_4+32,""%lu,%lu,%lu,%s"",&VAR_20,&VAR_18,&VAR_19,
VAR_2);
if ((VAR_14 != 4) || (VAR_20 == 0) || (VAR_18 == 0) || (VAR_19 == 0))
ThrowReaderException(VAR_26,""ImproperImageHeader"");
VAR_5->columns=VAR_20;
VAR_5->rows=VAR_18;
for (VAR_17=1; (GetQuantumRange(VAR_17)+1) < VAR_19; VAR_17++) ;
VAR_5->depth=VAR_17;
VAR_9=SetImageExtent(VAR_5,VAR_5->columns,VAR_5->rows,VAR_1);
if (VAR_9 == VAR_22)
return(DestroyImageList(VAR_5));
LocaleLower(VAR_2);
VAR_11=(ssize_t) strlen(VAR_2)-1;
VAR_5->alpha_trait=VAR_27;
if ((VAR_11 > 0) && (VAR_2[VAR_11] == 'a'))
{
VAR_2[VAR_11]='\0';
VAR_5->alpha_trait=VAR_28;
}
VAR_15=ParseCommandOption(VAR_29,VAR_22,VAR_2);
if (VAR_15 < 0)
ThrowReaderException(VAR_26,""ImproperImageHeader"");
(void) SetImageBackgroundColor(VAR_5,VAR_1);
(void) SetImageColorspace(VAR_5,(ColorspaceType) VAR_15,VAR_1);
GetPixelInfo(VAR_5,&VAR_8);
VAR_10=GetQuantumRange(VAR_5->depth);
for (VAR_16=0; VAR_16 < (ssize_t) VAR_5->rows; VAR_16++)
{
double
VAR_30,
VAR_31,
VAR_32,
VAR_33,
VAR_34;
VAR_34=0.0;
VAR_33=0.0;
VAR_32=0.0;
VAR_31=0.0;
VAR_30=0.0;
for (VAR_12=0; VAR_12 < (ssize_t) VAR_5->columns; VAR_12++)
{
if (ReadBlobString(VAR_5,VAR_4) == (char *) NULL)
break;
switch (VAR_5->colorspace)
{
case VAR_35:
{
if (VAR_5->alpha_trait != VAR_27)
{
VAR_14=(ssize_t) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
&VAR_6,&VAR_7,&VAR_34,&VAR_30);
VAR_33=VAR_34;
VAR_32=VAR_34;
break;
}
VAR_14=(ssize_t) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]"",&VAR_6,
&VAR_7,&VAR_34);
VAR_33=VAR_34;
VAR_32=VAR_34;
break;       
}
case VAR_36:
{
if (VAR_5->alpha_trait != VAR_27)
{
VAR_14=(ssize_t) sscanf(VAR_4,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&VAR_6,&VAR_7,&VAR_34,&VAR_33,&VAR_32,&VAR_31,&VAR_30);
break;
}
VAR_14=(ssize_t) sscanf(VAR_4,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&VAR_6,
&VAR_7,&VAR_34,&VAR_33,&VAR_32,&VAR_31);
break;
}
default:
{
if (VAR_5->alpha_trait != VAR_27)
{
VAR_14=(ssize_t) sscanf(VAR_4,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
&VAR_6,&VAR_7,&VAR_34,&VAR_33,&VAR_32,&VAR_30);
break;
}
VAR_14=(ssize_t) sscanf(VAR_4,
""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&VAR_6,
&VAR_7,&VAR_34,&VAR_33,&VAR_32);
break;       
}
}
if (strchr(VAR_4,'%') != (char *) NULL)
{
VAR_34*=0.01*VAR_10;
VAR_33*=0.01*VAR_10;
VAR_32*=0.01*VAR_10;
VAR_31*=0.01*VAR_10;
VAR_30*=0.01*VAR_10;
}
if (VAR_5->colorspace == VAR_37)
{
VAR_33+=(VAR_10+1)/2.0;
VAR_32+=(VAR_10+1)/2.0;
}
VAR_8.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_34+0.5),
VAR_10);
VAR_8.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_33+0.5),
VAR_10);
VAR_8.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_32+0.5),
VAR_10);
VAR_8.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_31+0.5),
VAR_10);
VAR_8.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_30+0.5),
VAR_10);
VAR_13=GetAuthenticPixels(VAR_5,(ssize_t) VAR_6,(ssize_t) VAR_7,1,1,
VAR_1);
if (VAR_13 == (Quantum *) NULL)
continue;
SetPixelViaPixelInfo(VAR_5,&VAR_8,VAR_13);
if (SyncAuthenticPixels(VAR_5,VAR_1) == VAR_22)
break;
}
}
if (EOFBlob(VAR_5) != VAR_22)
{
ThrowFileException(VAR_1,VAR_26,""UnexpectedEndOfFile"",
VAR_5->filename);
break;
}
(void) ReadBlobString(VAR_5,VAR_4);
if (LocaleNCompare((char *) VAR_4,VAR_25,strlen(VAR_25)) == 0)
{
AcquireNextImage(VAR_0,VAR_5,VAR_1);
if (GetNextImageInList(VAR_5) == (Image *) NULL)
{
VAR_5=DestroyImageList(VAR_5);
return((Image *) NULL);
}
VAR_5=SyncNextImageInList(VAR_5);
VAR_9=SetImageProgress(VAR_5,VAR_38,TellBlob(VAR_5),
GetBlobSize(VAR_5));
if (VAR_9 == VAR_22)
break;
}
} while (LocaleNCompare((char *) VAR_4,VAR_25,strlen(VAR_25)) == 0);
(void) CloseBlob(VAR_5);
return(GetFirstImageInList(VAR_5));
}",ImageMagick/50f54462076648ac2e36c3f58f4dadd4babbf1c9/txt.c/vul/before/0.json,"static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    colorspace[MagickPathExtent],
    text[MagickPathExtent];

  Image
    *image;

  long
    x_offset,
    y_offset;

  PixelInfo
    pixel;

  MagickBooleanType
    status;

  QuantumAny
    range;

  register ssize_t
    i,
    x;

  register Quantum
    *q;

  ssize_t
    count,
    type,
    y;

  unsigned long
    depth,
    height,
    max_value,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(text,0,sizeof(text));
  (void) ReadBlobString(image,text);
  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    width=0;
    height=0;
    max_value=0;
    *colorspace='\0';
    count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
      colorspace);
    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    image->columns=width;
    image->rows=height;
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)
      if (depth >= 64)
        break;
    image->depth=depth;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    LocaleLower(colorspace);
    i=(ssize_t) strlen(colorspace)-1;
    image->alpha_trait=UndefinedPixelTrait;
    if ((i > 0) && (colorspace[i] == 'a'))
      {
        colorspace[i]='\0';
        image->alpha_trait=BlendPixelTrait;
      }
    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
    if (type < 0)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    (void) SetImageBackgroundColor(image,exception);
    (void) SetImageColorspace(image,(ColorspaceType) type,exception);
    GetPixelInfo(image,&pixel);
    range=GetQuantumRange(image->depth);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      double
        alpha,
        black,
        blue,
        green,
        red;

      red=0.0;
      green=0.0;
      blue=0.0;
      black=0.0;
      alpha=0.0;
      for (x=0; x < (ssize_t) image->columns; x++)
      {
        if (ReadBlobString(image,text) == (char *) NULL)
          break;
        switch (image->colorspace)
        {
          case GRAYColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&alpha);
                green=red;
                blue=red;
                break;
              }
            count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,
              &y_offset,&red);
            green=red;
            blue=red;
            break;       
          }
          case CMYKColorspace:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue,&black);
            break;
          }
          default:
          {
            if (image->alpha_trait != UndefinedPixelTrait)
              {
                count=(ssize_t) sscanf(text,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &x_offset,&y_offset,&red,&green,&blue,&alpha);
                break;
              }
            count=(ssize_t) sscanf(text,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
              &y_offset,&red,&green,&blue);
            break;       
          }
        }
        if (strchr(text,'%') != (char *) NULL)
          {
            red*=0.01*range;
            green*=0.01*range;
            blue*=0.01*range;
            black*=0.01*range;
            alpha*=0.01*range;
          }
        if (image->colorspace == LabColorspace)
          {
            green+=(range+1)/2.0;
            blue+=(range+1)/2.0;
          }
        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
          range);
        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
          range);
        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
          range);
        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),
          range);
        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),
          range);
        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
          exception);
        if (q == (Quantum *) NULL)
          continue;
        SetPixelViaPixelInfo(image,&pixel,q);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
    }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    (void) ReadBlobString(image,text);
    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadTXTImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  char
    VAR_2[VAR_3],
    VAR_4[VAR_3];

  Image
    *VAR_5;

  long
    VAR_6,
    VAR_7;

  PixelInfo
    VAR_8;

  MagickBooleanType
    VAR_9;

  QuantumAny
    VAR_10;

  register ssize_t
    VAR_11,
    VAR_12;

  register Quantum
    *VAR_13;

  ssize_t
    VAR_14,
    VAR_15,
    VAR_16;

  unsigned long
    VAR_17,
    VAR_18,
    VAR_19,
    VAR_20;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_21);
  if (VAR_0->debug != VAR_22)
    (void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_21);
  VAR_5=AcquireImage(VAR_0,VAR_1);
  VAR_9=OpenBlob(VAR_0,VAR_5,VAR_24,VAR_1);
  if (VAR_9 == VAR_22)
    {
      VAR_5=DestroyImageList(VAR_5);
      return((Image *) NULL);
    }
  (void) ResetMagickMemory(VAR_4,0,sizeof(VAR_4));
  (void) ReadBlobString(VAR_5,VAR_4);
  if (LocaleNCompare((char *) VAR_4,VAR_25,strlen(VAR_25)) != 0)
    ThrowReaderException(VAR_26,""ImproperImageHeader"");
  do
  {
    VAR_20=0;
    VAR_18=0;
    VAR_19=0;
    *VAR_2='\0';
    VAR_14=(ssize_t) sscanf(VAR_4+32,""%lu,%lu,%lu,%s"",&VAR_20,&VAR_18,&VAR_19,
      VAR_2);
    if ((VAR_14 != 4) || (VAR_20 == 0) || (VAR_18 == 0) || (VAR_19 == 0))
      ThrowReaderException(VAR_26,""ImproperImageHeader"");
    VAR_5->columns=VAR_20;
    VAR_5->rows=VAR_18;
    for (VAR_17=1; (GetQuantumRange(VAR_17)+1) < VAR_19; VAR_17++)
      if (VAR_17 >= 64)
        break;
    VAR_5->depth=VAR_17;
    VAR_9=SetImageExtent(VAR_5,VAR_5->columns,VAR_5->rows,VAR_1);
    if (VAR_9 == VAR_22)
      return(DestroyImageList(VAR_5));
    LocaleLower(VAR_2);
    VAR_11=(ssize_t) strlen(VAR_2)-1;
    VAR_5->alpha_trait=VAR_27;
    if ((VAR_11 > 0) && (VAR_2[VAR_11] == 'a'))
      {
        VAR_2[VAR_11]='\0';
        VAR_5->alpha_trait=VAR_28;
      }
    VAR_15=ParseCommandOption(VAR_29,VAR_22,VAR_2);
    if (VAR_15 < 0)
      ThrowReaderException(VAR_26,""ImproperImageHeader"");
    (void) SetImageBackgroundColor(VAR_5,VAR_1);
    (void) SetImageColorspace(VAR_5,(ColorspaceType) VAR_15,VAR_1);
    GetPixelInfo(VAR_5,&VAR_8);
    VAR_10=GetQuantumRange(VAR_5->depth);
    for (VAR_16=0; VAR_16 < (ssize_t) VAR_5->rows; VAR_16++)
    {
      double
        VAR_30,
        VAR_31,
        VAR_32,
        VAR_33,
        VAR_34;

      VAR_34=0.0;
      VAR_33=0.0;
      VAR_32=0.0;
      VAR_31=0.0;
      VAR_30=0.0;
      for (VAR_12=0; VAR_12 < (ssize_t) VAR_5->columns; VAR_12++)
      {
        if (ReadBlobString(VAR_5,VAR_4) == (char *) NULL)
          break;
        switch (VAR_5->colorspace)
        {
          case VAR_35:
          {
            if (VAR_5->alpha_trait != VAR_27)
              {
                VAR_14=(ssize_t) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
                  &VAR_6,&VAR_7,&VAR_34,&VAR_30);
                VAR_33=VAR_34;
                VAR_32=VAR_34;
                break;
              }
            VAR_14=(ssize_t) sscanf(VAR_4,""%ld,%ld: (%lf%*[%,]"",&VAR_6,
              &VAR_7,&VAR_34);
            VAR_33=VAR_34;
            VAR_32=VAR_34;
            break;       
          }
          case VAR_36:
          {
            if (VAR_5->alpha_trait != VAR_27)
              {
                VAR_14=(ssize_t) sscanf(VAR_4,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &VAR_6,&VAR_7,&VAR_34,&VAR_33,&VAR_32,&VAR_31,&VAR_30);
                break;
              }
            VAR_14=(ssize_t) sscanf(VAR_4,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&VAR_6,
              &VAR_7,&VAR_34,&VAR_33,&VAR_32,&VAR_31);
            break;
          }
          default:
          {
            if (VAR_5->alpha_trait != VAR_27)
              {
                VAR_14=(ssize_t) sscanf(VAR_4,
                  ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                  &VAR_6,&VAR_7,&VAR_34,&VAR_33,&VAR_32,&VAR_30);
                break;
              }
            VAR_14=(ssize_t) sscanf(VAR_4,
              ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&VAR_6,
              &VAR_7,&VAR_34,&VAR_33,&VAR_32);
            break;       
          }
        }
        if (strchr(VAR_4,'%') != (char *) NULL)
          {
            VAR_34*=0.01*VAR_10;
            VAR_33*=0.01*VAR_10;
            VAR_32*=0.01*VAR_10;
            VAR_31*=0.01*VAR_10;
            VAR_30*=0.01*VAR_10;
          }
        if (VAR_5->colorspace == VAR_37)
          {
            VAR_33+=(VAR_10+1)/2.0;
            VAR_32+=(VAR_10+1)/2.0;
          }
        VAR_8.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_34+0.5),
          VAR_10);
        VAR_8.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_33+0.5),
          VAR_10);
        VAR_8.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_32+0.5),
          VAR_10);
        VAR_8.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_31+0.5),
          VAR_10);
        VAR_8.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (VAR_30+0.5),
          VAR_10);
        VAR_13=GetAuthenticPixels(VAR_5,(ssize_t) VAR_6,(ssize_t) VAR_7,1,1,
          VAR_1);
        if (VAR_13 == (Quantum *) NULL)
          continue;
        SetPixelViaPixelInfo(VAR_5,&VAR_8,VAR_13);
        if (SyncAuthenticPixels(VAR_5,VAR_1) == VAR_22)
          break;
      }
    }
    if (EOFBlob(VAR_5) != VAR_22)
      {
        ThrowFileException(VAR_1,VAR_26,""UnexpectedEndOfFile"",
          VAR_5->filename);
        break;
      }
    (void) ReadBlobString(VAR_5,VAR_4);
    if (LocaleNCompare((char *) VAR_4,VAR_25,strlen(VAR_25)) == 0)
      {
        /* COMMENT_3 */
                                        
          
        AcquireNextImage(VAR_0,VAR_5,VAR_1);
        if (GetNextImageInList(VAR_5) == (Image *) NULL)
          {
            VAR_5=DestroyImageList(VAR_5);
            return((Image *) NULL);
          }
        VAR_5=SyncNextImageInList(VAR_5);
        VAR_9=SetImageProgress(VAR_5,VAR_38,TellBlob(VAR_5),
          GetBlobSize(VAR_5));
        if (VAR_9 == VAR_22)
          break;
      }
  } while (LocaleNCompare((char *) VAR_4,VAR_25,strlen(VAR_25)) == 0);
  (void) CloseBlob(VAR_5);
  return(GetFirstImageInList(VAR_5));
}",ImageMagick/50f54462076648ac2e36c3f58f4dadd4babbf1c9/txt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -71,7 +71,9 @@
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     image->columns=width;
     image->rows=height;
-    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
+    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)
+      if (depth >= 64)
+        break;
     image->depth=depth;
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)","{'deleted_lines': ['    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;'], 'added_lines': ['    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)', '      if (depth >= 64)', '        break;']}",True,"In the function ReadTXTImage() in coders/txt.c in ImageMagick 7.0.6-10, an integer overflow might occur for the addition operation ""GetQuantumRange(depth)+1"" when ""depth"" is large, producing a smaller value than expected. As a result, an infinite loop would occur for a crafted TXT file that claims a very large ""max_value"" value.",6.5,MEDIUM,1,test,2017-09-01T13:22:37Z,2
CVE-2017-9798,['CWE-416'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,apache/httpd,"core: Disallow Methods' registration at run time (.htaccess), they may be
used only if registered at init time (httpd.conf).

Calling ap_method_register() in children processes is not the right scope
since it won't be shared for all requests.


git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1807655 13f79535-47bb-0310-9956-ffa450edef68",4cc27823899e070268b906ca677ee838d07cf67a,https://github.com/apache/httpd/commit/4cc27823899e070268b906ca677ee838d07cf67a,server/core.c,ap_limit_section,"AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,
void *dummy,
const char *arg)
{
const char *endp = ap_strrchr_c(arg, '>');
const char *limited_methods;
void *tog = cmd->cmd->cmd_data;
apr_int64_t limited = 0;
apr_int64_t old_limited = cmd->limited;
const char *errmsg;
if (endp == NULL) {
return unclosed_directive(cmd);
}
limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);
if (!limited_methods[0]) {
return missing_container_arg(cmd);
}
while (limited_methods[0]) {
char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);
int methnum;
methnum = ap_method_number_of(method);
if (methnum == M_TRACE && !tog) {
return ""TRACE cannot be controlled by <Limit>, see TraceEnable"";
}
else if (methnum == M_INVALID) {
methnum = ap_method_register(cmd->pool,
apr_pstrdup(cmd->pool, method));
}
limited |= (AP_METHOD_BIT << methnum);
}
limited = tog ? ~limited : limited;
if (!(old_limited & limited)) {
return apr_pstrcat(cmd->pool, cmd->cmd->name,
""> directive excludes all methods"", NULL);
}
else if ((old_limited & limited) == old_limited) {
return apr_pstrcat(cmd->pool, cmd->cmd->name,
""> directive specifies methods already excluded"",
NULL);
}
cmd->limited &= limited;
errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);
cmd->limited = old_limited;
return errmsg;
}","VAR_0(const char *) ap_limit_section(cmd_parms *VAR_1,
void *VAR_2,
const char *VAR_3)
{
const char *VAR_4 = ap_strrchr_c(VAR_3, '>');
const char *VAR_5;
void *VAR_6 = VAR_1->cmd->cmd_data;
apr_int64_t VAR_7 = 0;
apr_int64_t VAR_8 = VAR_1->limited;
const char *VAR_9;
if (VAR_4 == NULL) {
return unclosed_directive(VAR_1);
}
VAR_5 = apr_pstrmemdup(VAR_1->temp_pool, VAR_3, VAR_4 - VAR_3);
if (!VAR_5[0]) {
return missing_container_arg(VAR_1);
}
while (VAR_5[0]) {
char *VAR_10 = ap_getword_conf(VAR_1->temp_pool, &VAR_5);
int VAR_11;
VAR_11 = ap_method_number_of(VAR_10);
if (VAR_11 == VAR_12 && !VAR_6) {
return ""TRACE cannot be controlled by <Limit>, see TraceEnable"";
}
else if (VAR_11 == VAR_13) {
VAR_11 = ap_method_register(VAR_1->pool,
apr_pstrdup(VAR_1->pool, VAR_10));
}
VAR_7 |= (VAR_14 << VAR_11);
}
VAR_7 = VAR_6 ? ~VAR_7 : VAR_7;
if (!(VAR_8 & VAR_7)) {
return apr_pstrcat(VAR_1->pool, VAR_1->cmd->name,
""> directive excludes all methods"", NULL);
}
else if ((VAR_8 & VAR_7) == VAR_8) {
return apr_pstrcat(VAR_1->pool, VAR_1->cmd->name,
""> directive specifies methods already excluded"",
NULL);
}
VAR_1->limited &= VAR_7;
VAR_9 = ap_walk_config(VAR_1->directive->first_child, VAR_1, VAR_1->context);
VAR_1->limited = VAR_8;
return VAR_9;
}",,"AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,
                                                      void *dummy,
                                                      const char *arg)
{
    const char *endp = ap_strrchr_c(arg, '>');
    const char *limited_methods;
    void *tog = cmd->cmd->cmd_data;
    apr_int64_t limited = 0;
    apr_int64_t old_limited = cmd->limited;
    const char *errmsg;

    if (endp == NULL) {
        return unclosed_directive(cmd);
    }

    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);

    if (!limited_methods[0]) {
        return missing_container_arg(cmd);
    }

    while (limited_methods[0]) {
        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);
        int methnum;

        /* check for builtin or module registered method number */
        methnum = ap_method_number_of(method);

        if (methnum == M_TRACE && !tog) {
            return ""TRACE cannot be controlled by <Limit>, see TraceEnable"";
        }
        else if (methnum == M_INVALID) {
            /* method has not been registered yet, but resource restriction
             * is always checked before method handling, so register it.
             */
            if (cmd->pool == cmd->temp_pool) {
                /* In .htaccess, we can't globally register new methods. */
                return apr_psprintf(cmd->pool, ""Could not register method '%s' ""
                                   ""for %s from .htaccess configuration"",
                                    method, cmd->cmd->name);
            }
            methnum = ap_method_register(cmd->pool,
                                         apr_pstrdup(cmd->pool, method));
        }

        limited |= (AP_METHOD_BIT << methnum);
    }

    /* Killing two features with one function,
     * if (tog == NULL) <Limit>, else <LimitExcept>
     */
    limited = tog ? ~limited : limited;

    if (!(old_limited & limited)) {
        return apr_pstrcat(cmd->pool, cmd->cmd->name,
                           ""> directive excludes all methods"", NULL);
    }
    else if ((old_limited & limited) == old_limited) {
        return apr_pstrcat(cmd->pool, cmd->cmd->name,
                           ""> directive specifies methods already excluded"",
                           NULL);
    }

    cmd->limited &= limited;

    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);

    cmd->limited = old_limited;

    return errmsg;
}","VAR_0(const char *) ap_limit_section(cmd_parms *VAR_1,
                                                      void *VAR_2,
                                                      const char *VAR_3)
{
    const char *VAR_4 = ap_strrchr_c(VAR_3, '>');
    const char *VAR_5;
    void *VAR_6 = VAR_1->cmd->cmd_data;
    apr_int64_t VAR_7 = 0;
    apr_int64_t VAR_8 = VAR_1->limited;
    const char *VAR_9;

    if (VAR_4 == NULL) {
        return unclosed_directive(VAR_1);
    }

    VAR_5 = apr_pstrmemdup(VAR_1->temp_pool, VAR_3, VAR_4 - VAR_3);

    if (!VAR_5[0]) {
        return missing_container_arg(VAR_1);
    }

    while (VAR_5[0]) {
        char *VAR_10 = ap_getword_conf(VAR_1->temp_pool, &VAR_5);
        int VAR_11;

        /* COMMENT_0 */
        VAR_11 = ap_method_number_of(VAR_10);

        if (VAR_11 == VAR_12 && !VAR_6) {
            return ""TRACE cannot be controlled by <Limit>, see TraceEnable"";
        }
        else if (VAR_11 == VAR_13) {
            /* COMMENT_1 */
                                                                        
               
            if (VAR_1->pool == VAR_1->temp_pool) {
                /* COMMENT_4 */
                return apr_psprintf(VAR_1->pool, ""Could not register method '%s' ""
                                   ""for %s from .htaccess configuration"",
                                    VAR_10, VAR_1->cmd->name);
            }
            VAR_11 = ap_method_register(VAR_1->pool,
                                         apr_pstrdup(VAR_1->pool, VAR_10));
        }

        VAR_7 |= (VAR_14 << VAR_11);
    }

    /* COMMENT_5 */
                                                   
       
    VAR_7 = VAR_6 ? ~VAR_7 : VAR_7;

    if (!(VAR_8 & VAR_7)) {
        return apr_pstrcat(VAR_1->pool, VAR_1->cmd->name,
                           ""> directive excludes all methods"", NULL);
    }
    else if ((VAR_8 & VAR_7) == VAR_8) {
        return apr_pstrcat(VAR_1->pool, VAR_1->cmd->name,
                           ""> directive specifies methods already excluded"",
                           NULL);
    }

    VAR_1->limited &= VAR_7;

    VAR_9 = ap_walk_config(VAR_1->directive->first_child, VAR_1, VAR_1->context);

    VAR_1->limited = VAR_8;

    return VAR_9;
}",,"--- func_before
+++ func_after
@@ -33,6 +33,12 @@
             /* method has not been registered yet, but resource restriction
              * is always checked before method handling, so register it.
              */
+            if (cmd->pool == cmd->temp_pool) {
+                /* In .htaccess, we can't globally register new methods. */
+                return apr_psprintf(cmd->pool, ""Could not register method '%s' ""
+                                   ""for %s from .htaccess configuration"",
+                                    method, cmd->cmd->name);
+            }
             methnum = ap_method_register(cmd->pool,
                                          apr_pstrdup(cmd->pool, method));
         }","{'deleted_lines': [], 'added_lines': ['            if (cmd->pool == cmd->temp_pool) {', ""                /* In .htaccess, we can't globally register new methods. */"", '                return apr_psprintf(cmd->pool, ""Could not register method \'%s\' ""', '                                   ""for %s from .htaccess configuration"",', '                                    method, cmd->cmd->name);', '            }']}",True,"Apache httpd allows remote attackers to read secret data from process memory if the Limit directive can be set in a user's .htaccess file, or if httpd.conf has certain misconfigurations, aka Optionsbleed. This affects the Apache HTTP Server through 2.2.34 and 2.4.x through 2.4.27. The attacker sends an unauthenticated OPTIONS HTTP request when attempting to read secret data. This is a use-after-free issue and thus secret data is not always sent, and the specific data depends on many factors including configuration. Exploitation with .htaccess can be blocked with a patch to the ap_limit_section function in server/core.c.",7.5,HIGH,2,test,2017-09-07T22:43:41Z,2
CVE-2017-14638,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,axiomatic-systems/Bento4,fix for #182,be7185faf7f52674028977dcf501c6039ff03aa5,https://github.com/axiomatic-systems/Bento4/commit/be7185faf7f52674028977dcf501c6039ff03aa5,Source/C++/Core/Ap4AtomFactory.cpp,AP4_AtomFactory::CreateAtomFromStream,"AP4_Result
AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& stream, 
AP4_UI32        type,
AP4_UI32        size_32,
AP4_UI64        size_64,
AP4_Atom*&      atom)
{
bool atom_is_large = (size_32 == 1);
bool force_64 = (size_32==1 && ((size_64>>32) == 0));
if (GetContext() == AP4_ATOM_TYPE_STSD) {
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
switch (type) {
case AP4_ATOM_TYPE_MP4A:
atom = new AP4_Mp4aSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_MP4V:
atom = new AP4_Mp4vSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_MP4S:
atom = new AP4_Mp4sSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_ENCA:
atom = new AP4_EncaSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_ENCV:
atom = new AP4_EncvSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_DRMS:
atom = new AP4_DrmsSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_DRMI:
atom = new AP4_DrmiSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_AVC1:
case AP4_ATOM_TYPE_AVC2:
case AP4_ATOM_TYPE_AVC3:
case AP4_ATOM_TYPE_AVC4:
case AP4_ATOM_TYPE_DVAV:
case AP4_ATOM_TYPE_DVA1:
atom = new AP4_AvcSampleEntry(type, size_32, stream, *this);
break;
case AP4_ATOM_TYPE_HEV1:
case AP4_ATOM_TYPE_HVC1:
case AP4_ATOM_TYPE_DVHE:
case AP4_ATOM_TYPE_DVH1:
atom = new AP4_HevcSampleEntry(type, size_32, stream, *this);
break;
case AP4_ATOM_TYPE_ALAC:
case AP4_ATOM_TYPE_AC_3:
case AP4_ATOM_TYPE_EC_3:
case AP4_ATOM_TYPE_DTSC:
case AP4_ATOM_TYPE_DTSH:
case AP4_ATOM_TYPE_DTSL:
case AP4_ATOM_TYPE_DTSE:
atom = new AP4_AudioSampleEntry(type, size_32, stream, *this);
break;
case AP4_ATOM_TYPE_RTP_:
atom = new AP4_RtpHintSampleEntry(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_STPP:
atom = new AP4_SubtitleSampleEntry(type, size_32, stream, *this);
break;
default: {
AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();
while (handler_item) {
TypeHandler* handler = handler_item->GetData();
if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {
break;
}
handler_item = handler_item->GetNext();
}
if (atom == NULL) {
atom = new AP4_UnknownSampleEntry(type, (AP4_UI32)size_64, stream);
}
break;
}
}
} else {
switch (type) {
case AP4_ATOM_TYPE_MOOV:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_MoovAtom::Create(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_MVHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_MvhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_MEHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_MehdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_MFHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_MfhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TRAK:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TrakAtom::Create(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_TREX:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TrexAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_HDLR:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_HdlrAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TKHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TkhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TFHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TfhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TRUN:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TrunAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TFRA:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TfraAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_MFRO:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_MfroAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_MDHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_MdhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_STSD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_StsdAtom::Create(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_STSC:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_StscAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_STCO:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_StcoAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_CO64:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_Co64Atom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_STSZ:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_StszAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_STZ2:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_Stz2Atom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_STTS:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SttsAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_CTTS:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_CttsAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_STSS:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_StssAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_IODS:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_IodsAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_ESDS:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_EsdsAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_AVCC:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_AvccAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_HVCC:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_HvccAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_DVCC:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_DvccAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_HVCE:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_HvccAtom::Create(size_32, stream);
atom->SetType(AP4_ATOM_TYPE_HVCE);
break;
case AP4_ATOM_TYPE_AVCE:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_AvccAtom::Create(size_32, stream);
atom->SetType(AP4_ATOM_TYPE_AVCE);
break;
#if !defined(AP4_CONFIG_MINI_BUILD)
case AP4_ATOM_TYPE_UUID: {
AP4_UI08 uuid[16];
AP4_Result result = stream.Read(uuid, 16);
if (AP4_FAILED(result)) return result;
if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_TRACK_ENCRYPTION_ATOM, 16) == 0) {
atom = AP4_PiffTrackEncryptionAtom::Create((AP4_UI32)size_64, stream);
} else if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_SAMPLE_ENCRYPTION_ATOM, 16) == 0) {
atom = AP4_PiffSampleEncryptionAtom::Create((AP4_UI32)size_64, stream);
} else {
atom = new AP4_UnknownUuidAtom(size_64, uuid, stream);
}
break;
}
case AP4_ATOM_TYPE_8ID_:
atom = new AP4_NullTerminatedStringAtom(type, size_64, stream);
break;
case AP4_ATOM_TYPE_8BDL:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_8bdlAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_DREF:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_DrefAtom::Create(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_URL:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_UrlAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_ELST:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_ElstAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_VMHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_VmhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SMHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SmhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_NMHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_NmhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_STHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SthdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_HMHD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_HmhdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_FRMA:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_FrmaAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SCHM:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SchmAtom::Create(size_32, &m_ContextStack, stream);
break;
case AP4_ATOM_TYPE_FTYP:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_FtypAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TIMS:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TimsAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SDP_:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SdpAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_IKMS:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_IkmsAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_ISFM:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_IsfmAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_ISLT:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_IsltAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_ODHE:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_OdheAtom::Create(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_OHDR:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_OhdrAtom::Create(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_ODDA:
atom = AP4_OddaAtom::Create(size_64, stream);
break;
case AP4_ATOM_TYPE_ODAF:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_OdafAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_GRPI:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_GrpiAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_IPRO:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_IproAtom::Create(size_32, stream, *this);
break;
case AP4_ATOM_TYPE_RTP_:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_RtpAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TFDT:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TfdtAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_TENC:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TencAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SENC:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SencAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SAIZ:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SaizAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SAIO:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SaioAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_PDIN:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_PdinAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_BLOC:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_BlocAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_AINF:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_AinfAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_PSSH:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_PsshAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SIDX:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SidxAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SBGP:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SbgpAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_SGPD:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_SgpdAtom::Create(size_32, stream);
break;
case AP4_ATOM_TYPE_MKID:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
if (GetContext() == AP4_ATOM_TYPE_MARL) {
atom = AP4_MkidAtom::Create(size_32, stream);
}
break;
case AP4_ATOM_TYPE_DEC3:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
if (GetContext() == AP4_ATOM_TYPE_EC_3 || GetContext() == AP4_ATOM_TYPE_ENCA) {
atom = AP4_Dec3Atom::Create(size_32, stream);
}
break;
case AP4_ATOM_TYPE_HINT:
case AP4_ATOM_TYPE_CDSC:
case AP4_ATOM_TYPE_SYNC:
case AP4_ATOM_TYPE_MPOD:
case AP4_ATOM_TYPE_DPND:
case AP4_ATOM_TYPE_IPIR:
case AP4_ATOM_TYPE_ALIS:
case AP4_ATOM_TYPE_CHAP:
if (GetContext() == AP4_ATOM_TYPE_TREF) {
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_TrefTypeAtom::Create(type, size_32, stream);
}
break;
#endif 
case AP4_ATOM_TYPE_MOOF:
case AP4_ATOM_TYPE_MVEX:
case AP4_ATOM_TYPE_TRAF:
case AP4_ATOM_TYPE_TREF:
case AP4_ATOM_TYPE_MFRA:
case AP4_ATOM_TYPE_HNTI:
case AP4_ATOM_TYPE_STBL:
case AP4_ATOM_TYPE_MDIA:
case AP4_ATOM_TYPE_DINF:
case AP4_ATOM_TYPE_MINF:
case AP4_ATOM_TYPE_SCHI:
case AP4_ATOM_TYPE_SINF:
case AP4_ATOM_TYPE_UDTA:
case AP4_ATOM_TYPE_ILST:
case AP4_ATOM_TYPE_EDTS: 
case AP4_ATOM_TYPE_MDRI:
case AP4_ATOM_TYPE_WAVE:
if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);
break;
case AP4_ATOM_TYPE_MARL:
if (GetContext() == 0) {
atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);
}
break;
case AP4_ATOM_TYPE_META:
case AP4_ATOM_TYPE_ODRM:
case AP4_ATOM_TYPE_ODKM:
atom = AP4_ContainerAtom::Create(type, size_64, true, force_64, stream, *this);
break;
case AP4_ATOM_TYPE_FREE:
case AP4_ATOM_TYPE_WIDE:
case AP4_ATOM_TYPE_MDAT:
break;
default: {
AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();
while (handler_item) {
TypeHandler* handler = handler_item->GetData();
if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {
break;
}
handler_item = handler_item->GetNext();
}
break;
}
}
}
return AP4_SUCCESS;
}","AP4_Result
AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& VAR_0, 
AP4_UI32        VAR_1,
AP4_UI32        VAR_2,
AP4_UI64        VAR_3,
AP4_Atom*&      VAR_4)
{
bool VAR_5 = (VAR_2 == 1);
bool VAR_6 = (VAR_2==1 && ((VAR_3>>32) == 0));
if (GetContext() == VAR_7) {
if (VAR_5) return VAR_8;
switch (VAR_1) {
case VAR_9:
VAR_4 = new AP4_Mp4aSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_10:
VAR_4 = new AP4_Mp4vSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_11:
VAR_4 = new AP4_Mp4sSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_12:
VAR_4 = new AP4_EncaSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_13:
VAR_4 = new AP4_EncvSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_14:
VAR_4 = new AP4_DrmsSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_15:
VAR_4 = new AP4_DrmiSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
VAR_4 = new AP4_AvcSampleEntry(VAR_1, VAR_2, VAR_0, *this);
break;
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
VAR_4 = new AP4_HevcSampleEntry(VAR_1, VAR_2, VAR_0, *this);
break;
case VAR_26:
case VAR_27:
case VAR_28:
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
VAR_4 = new AP4_AudioSampleEntry(VAR_1, VAR_2, VAR_0, *this);
break;
case VAR_33:
VAR_4 = new AP4_RtpHintSampleEntry(VAR_2, VAR_0, *this);
break;
case VAR_34:
VAR_4 = new AP4_SubtitleSampleEntry(VAR_1, VAR_2, VAR_0, *this);
break;
default: {
AP4_List<TypeHandler>::Item* VAR_35 = VAR_36.FirstItem();
while (VAR_35) {
TypeHandler* VAR_37 = VAR_35->GetData();
if (AP4_SUCCEEDED(VAR_37->CreateAtom(VAR_1, VAR_2, VAR_0, GetContext(), VAR_4))) {
break;
}
VAR_35 = VAR_35->GetNext();
}
if (VAR_4 == NULL) {
VAR_4 = new AP4_UnknownSampleEntry(VAR_1, (AP4_UI32)VAR_3, VAR_0);
}
break;
}
}
} else {
switch (VAR_1) {
case VAR_38:
if (VAR_5) return VAR_8;
VAR_4 = AP4_MoovAtom::Create(VAR_2, VAR_0, *this);
break;
case VAR_39:
if (VAR_5) return VAR_8;
VAR_4 = AP4_MvhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_40:
if (VAR_5) return VAR_8;
VAR_4 = AP4_MehdAtom::Create(VAR_2, VAR_0);
break;
case VAR_41:
if (VAR_5) return VAR_8;
VAR_4 = AP4_MfhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_42:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TrakAtom::Create(VAR_2, VAR_0, *this);
break;
case VAR_43:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TrexAtom::Create(VAR_2, VAR_0);
break;
case VAR_44:
if (VAR_5) return VAR_8;
VAR_4 = AP4_HdlrAtom::Create(VAR_2, VAR_0);
break;
case VAR_45:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TkhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_46:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TfhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_47:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TrunAtom::Create(VAR_2, VAR_0);
break;
case VAR_48:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TfraAtom::Create(VAR_2, VAR_0);
break;
case VAR_49:
if (VAR_5) return VAR_8;
VAR_4 = AP4_MfroAtom::Create(VAR_2, VAR_0);
break;
case VAR_50:
if (VAR_5) return VAR_8;
VAR_4 = AP4_MdhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_7:
if (VAR_5) return VAR_8;
VAR_4 = AP4_StsdAtom::Create(VAR_2, VAR_0, *this);
break;
case VAR_51:
if (VAR_5) return VAR_8;
VAR_4 = AP4_StscAtom::Create(VAR_2, VAR_0);
break;
case VAR_52:
if (VAR_5) return VAR_8;
VAR_4 = AP4_StcoAtom::Create(VAR_2, VAR_0);
break;
case VAR_53:
if (VAR_5) return VAR_8;
VAR_4 = AP4_Co64Atom::Create(VAR_2, VAR_0);
break;
case VAR_54:
if (VAR_5) return VAR_8;
VAR_4 = AP4_StszAtom::Create(VAR_2, VAR_0);
break;
case VAR_55:
if (VAR_5) return VAR_8;
VAR_4 = AP4_Stz2Atom::Create(VAR_2, VAR_0);
break;
case VAR_56:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SttsAtom::Create(VAR_2, VAR_0);
break;
case VAR_57:
if (VAR_5) return VAR_8;
VAR_4 = AP4_CttsAtom::Create(VAR_2, VAR_0);
break;
case VAR_58:
if (VAR_5) return VAR_8;
VAR_4 = AP4_StssAtom::Create(VAR_2, VAR_0);
break;
case VAR_59:
if (VAR_5) return VAR_8;
VAR_4 = AP4_IodsAtom::Create(VAR_2, VAR_0);
break;
case VAR_60:
if (VAR_5) return VAR_8;
VAR_4 = AP4_EsdsAtom::Create(VAR_2, VAR_0);
break;
case VAR_61:
if (VAR_5) return VAR_8;
VAR_4 = AP4_AvccAtom::Create(VAR_2, VAR_0);
break;
case VAR_62:
if (VAR_5) return VAR_8;
VAR_4 = AP4_HvccAtom::Create(VAR_2, VAR_0);
break;
case VAR_63:
if (VAR_5) return VAR_8;
VAR_4 = AP4_DvccAtom::Create(VAR_2, VAR_0);
break;
case VAR_64:
if (VAR_5) return VAR_8;
VAR_4 = AP4_HvccAtom::Create(VAR_2, VAR_0);
VAR_4->SetType(VAR_64);
break;
case VAR_65:
if (VAR_5) return VAR_8;
VAR_4 = AP4_AvccAtom::Create(VAR_2, VAR_0);
VAR_4->SetType(VAR_65);
break;
#if !defined(VAR_66)
case VAR_67: {
AP4_UI08 VAR_68[16];
AP4_Result VAR_69 = VAR_0.Read(VAR_68, 16);
if (AP4_FAILED(VAR_69)) return VAR_69;
if (AP4_CompareMemory(VAR_68, VAR_70, 16) == 0) {
VAR_4 = AP4_PiffTrackEncryptionAtom::Create((AP4_UI32)VAR_3, VAR_0);
} else if (AP4_CompareMemory(VAR_68, VAR_71, 16) == 0) {
VAR_4 = AP4_PiffSampleEncryptionAtom::Create((AP4_UI32)VAR_3, VAR_0);
} else {
VAR_4 = new AP4_UnknownUuidAtom(VAR_3, VAR_68, VAR_0);
}
break;
}
case VAR_72:
VAR_4 = new AP4_NullTerminatedStringAtom(VAR_1, VAR_3, VAR_0);
break;
case VAR_73:
if (VAR_5) return VAR_8;
VAR_4 = AP4_8bdlAtom::Create(VAR_2, VAR_0);
break;
case VAR_74:
if (VAR_5) return VAR_8;
VAR_4 = AP4_DrefAtom::Create(VAR_2, VAR_0, *this);
break;
case VAR_75:
if (VAR_5) return VAR_8;
VAR_4 = AP4_UrlAtom::Create(VAR_2, VAR_0);
break;
case VAR_76:
if (VAR_5) return VAR_8;
VAR_4 = AP4_ElstAtom::Create(VAR_2, VAR_0);
break;
case VAR_77:
if (VAR_5) return VAR_8;
VAR_4 = AP4_VmhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_78:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SmhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_79:
if (VAR_5) return VAR_8;
VAR_4 = AP4_NmhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_80:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SthdAtom::Create(VAR_2, VAR_0);
break;
case VAR_81:
if (VAR_5) return VAR_8;
VAR_4 = AP4_HmhdAtom::Create(VAR_2, VAR_0);
break;
case VAR_82:
if (VAR_5) return VAR_8;
VAR_4 = AP4_FrmaAtom::Create(VAR_2, VAR_0);
break;
case VAR_83:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SchmAtom::Create(VAR_2, &VAR_84, VAR_0);
break;
case VAR_85:
if (VAR_5) return VAR_8;
VAR_4 = AP4_FtypAtom::Create(VAR_2, VAR_0);
break;
case VAR_86:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TimsAtom::Create(VAR_2, VAR_0);
break;
case VAR_87:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SdpAtom::Create(VAR_2, VAR_0);
break;
case VAR_88:
if (VAR_5) return VAR_8;
VAR_4 = AP4_IkmsAtom::Create(VAR_2, VAR_0);
break;
case VAR_89:
if (VAR_5) return VAR_8;
VAR_4 = AP4_IsfmAtom::Create(VAR_2, VAR_0);
break;
case VAR_90:
if (VAR_5) return VAR_8;
VAR_4 = AP4_IsltAtom::Create(VAR_2, VAR_0);
break;
case VAR_91:
if (VAR_5) return VAR_8;
VAR_4 = AP4_OdheAtom::Create(VAR_2, VAR_0, *this);
break;
case VAR_92:
if (VAR_5) return VAR_8;
VAR_4 = AP4_OhdrAtom::Create(VAR_2, VAR_0, *this);
break;
case VAR_93:
VAR_4 = AP4_OddaAtom::Create(VAR_3, VAR_0);
break;
case VAR_94:
if (VAR_5) return VAR_8;
VAR_4 = AP4_OdafAtom::Create(VAR_2, VAR_0);
break;
case VAR_95:
if (VAR_5) return VAR_8;
VAR_4 = AP4_GrpiAtom::Create(VAR_2, VAR_0);
break;
case VAR_96:
if (VAR_5) return VAR_8;
VAR_4 = AP4_IproAtom::Create(VAR_2, VAR_0, *this);
break;
case VAR_33:
if (VAR_5) return VAR_8;
VAR_4 = AP4_RtpAtom::Create(VAR_2, VAR_0);
break;
case VAR_97:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TfdtAtom::Create(VAR_2, VAR_0);
break;
case VAR_98:
if (VAR_5) return VAR_8;
VAR_4 = AP4_TencAtom::Create(VAR_2, VAR_0);
break;
case VAR_99:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SencAtom::Create(VAR_2, VAR_0);
break;
case VAR_100:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SaizAtom::Create(VAR_2, VAR_0);
break;
case VAR_101:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SaioAtom::Create(VAR_2, VAR_0);
break;
case VAR_102:
if (VAR_5) return VAR_8;
VAR_4 = AP4_PdinAtom::Create(VAR_2, VAR_0);
break;
case VAR_103:
if (VAR_5) return VAR_8;
VAR_4 = AP4_BlocAtom::Create(VAR_2, VAR_0);
break;
case VAR_104:
if (VAR_5) return VAR_8;
VAR_4 = AP4_AinfAtom::Create(VAR_2, VAR_0);
break;
case VAR_105:
if (VAR_5) return VAR_8;
VAR_4 = AP4_PsshAtom::Create(VAR_2, VAR_0);
break;
case VAR_106:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SidxAtom::Create(VAR_2, VAR_0);
break;
case VAR_107:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SbgpAtom::Create(VAR_2, VAR_0);
break;
case VAR_108:
if (VAR_5) return VAR_8;
VAR_4 = AP4_SgpdAtom::Create(VAR_2, VAR_0);
break;
case VAR_109:
if (VAR_5) return VAR_8;
if (GetContext() == VAR_110) {
VAR_4 = AP4_MkidAtom::Create(VAR_2, VAR_0);
}
break;
case VAR_111:
if (VAR_5) return VAR_8;
if (GetContext() == VAR_28 || GetContext() == VAR_12) {
VAR_4 = AP4_Dec3Atom::Create(VAR_2, VAR_0);
}
break;
case VAR_112:
case VAR_113:
case VAR_114:
case VAR_115:
case VAR_116:
case VAR_117:
case VAR_118:
case VAR_119:
if (GetContext() == VAR_120) {
if (VAR_5) return VAR_8;
VAR_4 = AP4_TrefTypeAtom::Create(VAR_1, VAR_2, VAR_0);
}
break;
#endif 
case VAR_121:
case VAR_122:
case VAR_123:
case VAR_120:
case VAR_124:
case VAR_125:
case VAR_126:
case VAR_127:
case VAR_128:
case VAR_129:
case VAR_130:
case VAR_131:
case VAR_132:
case VAR_133:
case VAR_134: 
case VAR_135:
case VAR_136:
if (VAR_5) return VAR_8;
VAR_4 = AP4_ContainerAtom::Create(VAR_1, VAR_3, false, VAR_6, VAR_0, *this);
break;
case VAR_110:
if (GetContext() == 0) {
VAR_4 = AP4_ContainerAtom::Create(VAR_1, VAR_3, false, VAR_6, VAR_0, *this);
}
break;
case VAR_137:
case VAR_138:
case VAR_139:
VAR_4 = AP4_ContainerAtom::Create(VAR_1, VAR_3, true, VAR_6, VAR_0, *this);
break;
case VAR_140:
case VAR_141:
case VAR_142:
break;
default: {
AP4_List<TypeHandler>::Item* VAR_35 = VAR_36.FirstItem();
while (VAR_35) {
TypeHandler* VAR_37 = VAR_35->GetData();
if (AP4_SUCCEEDED(VAR_37->CreateAtom(VAR_1, VAR_2, VAR_0, GetContext(), VAR_4))) {
break;
}
VAR_35 = VAR_35->GetNext();
}
break;
}
}
}
return VAR_143;
}",axiomatic-systems/Bento4/be7185faf7f52674028977dcf501c6039ff03aa5/Ap4AtomFactory.cpp/vul/before/0.json,"AP4_Result
AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& stream, 
                                      AP4_UI32        type,
                                      AP4_UI32        size_32,
                                      AP4_UI64        size_64,
                                      AP4_Atom*&      atom)
{
    bool atom_is_large = (size_32 == 1);
    bool force_64 = (size_32==1 && ((size_64>>32) == 0));
    
    // create the atom
    if (GetContext() == AP4_ATOM_TYPE_STSD) {
        // sample entry
        if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
        switch (type) {
          case AP4_ATOM_TYPE_MP4A:
            atom = new AP4_Mp4aSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_MP4V:
            atom = new AP4_Mp4vSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_MP4S:
            atom = new AP4_Mp4sSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_ENCA:
            atom = new AP4_EncaSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_ENCV:
            atom = new AP4_EncvSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_DRMS:
            atom = new AP4_DrmsSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_DRMI:
            atom = new AP4_DrmiSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_AVC1:
          case AP4_ATOM_TYPE_AVC2:
          case AP4_ATOM_TYPE_AVC3:
          case AP4_ATOM_TYPE_AVC4:
          case AP4_ATOM_TYPE_DVAV:
          case AP4_ATOM_TYPE_DVA1:
            atom = new AP4_AvcSampleEntry(type, size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_HEV1:
          case AP4_ATOM_TYPE_HVC1:
          case AP4_ATOM_TYPE_DVHE:
          case AP4_ATOM_TYPE_DVH1:
            atom = new AP4_HevcSampleEntry(type, size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_ALAC:
          case AP4_ATOM_TYPE_AC_3:
          case AP4_ATOM_TYPE_EC_3:
          case AP4_ATOM_TYPE_DTSC:
          case AP4_ATOM_TYPE_DTSH:
          case AP4_ATOM_TYPE_DTSL:
          case AP4_ATOM_TYPE_DTSE:
            atom = new AP4_AudioSampleEntry(type, size_32, stream, *this);
            break;
            
          case AP4_ATOM_TYPE_RTP_:
            atom = new AP4_RtpHintSampleEntry(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_STPP:
            atom = new AP4_SubtitleSampleEntry(type, size_32, stream, *this);
            break;

          default: {
            // try all the external type handlers
            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();
            while (handler_item) {
                TypeHandler* handler = handler_item->GetData();
                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {
                    break;
                }
                handler_item = handler_item->GetNext();
            }

            // no custom handler, create a generic entry
            if (atom == NULL) {
                atom = new AP4_UnknownSampleEntry(type, (AP4_UI32)size_64, stream);
            }

            break;
          }
        }
    } else {
        // regular atom
        switch (type) {
          case AP4_ATOM_TYPE_MOOV:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_MoovAtom::Create(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_MVHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_MvhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_MEHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_MehdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_MFHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_MfhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_TRAK:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TrakAtom::Create(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_TREX:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TrexAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_HDLR:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_HdlrAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_TKHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TkhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_TFHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TfhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_TRUN:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TrunAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_TFRA:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TfraAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_MFRO:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_MfroAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_MDHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_MdhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_STSD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_StsdAtom::Create(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_STSC:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_StscAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_STCO:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_StcoAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_CO64:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_Co64Atom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_STSZ:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_StszAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_STZ2:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_Stz2Atom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_STTS:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SttsAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_CTTS:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_CttsAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_STSS:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_StssAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_IODS:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_IodsAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_ESDS:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_EsdsAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_AVCC:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_AvccAtom::Create(size_32, stream);
            break;
            
          case AP4_ATOM_TYPE_HVCC:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_HvccAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_DVCC:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_DvccAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_HVCE:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_HvccAtom::Create(size_32, stream);
            if (atom) {
                atom->SetType(AP4_ATOM_TYPE_HVCE);
            }
            break;

          case AP4_ATOM_TYPE_AVCE:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_AvccAtom::Create(size_32, stream);
            if (atom) {
                atom->SetType(AP4_ATOM_TYPE_AVCE);
            }
            break;

    #if !defined(AP4_CONFIG_MINI_BUILD)
          case AP4_ATOM_TYPE_UUID: {
              AP4_UI08 uuid[16];
              AP4_Result result = stream.Read(uuid, 16);
              if (AP4_FAILED(result)) return result;
              
              if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_TRACK_ENCRYPTION_ATOM, 16) == 0) {
                  atom = AP4_PiffTrackEncryptionAtom::Create((AP4_UI32)size_64, stream);
              } else if (AP4_CompareMemory(uuid, AP4_UUID_PIFF_SAMPLE_ENCRYPTION_ATOM, 16) == 0) {
                  atom = AP4_PiffSampleEncryptionAtom::Create((AP4_UI32)size_64, stream);
              } else {
                  atom = new AP4_UnknownUuidAtom(size_64, uuid, stream);
              }
              break;
          }
            
          case AP4_ATOM_TYPE_8ID_:
            atom = new AP4_NullTerminatedStringAtom(type, size_64, stream);
            break;

          case AP4_ATOM_TYPE_8BDL:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_8bdlAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_DREF:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_DrefAtom::Create(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_URL:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_UrlAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_ELST:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_ElstAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_VMHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_VmhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SMHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SmhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_NMHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_NmhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_STHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SthdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_HMHD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_HmhdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_FRMA:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_FrmaAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SCHM:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SchmAtom::Create(size_32, &m_ContextStack, stream);
            break;

          case AP4_ATOM_TYPE_FTYP:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_FtypAtom::Create(size_32, stream);
            break;
                        
          case AP4_ATOM_TYPE_TIMS:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TimsAtom::Create(size_32, stream);
            break;
     
          case AP4_ATOM_TYPE_SDP_:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SdpAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_IKMS:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_IkmsAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_ISFM:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_IsfmAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_ISLT:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_IsltAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_ODHE:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_OdheAtom::Create(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_OHDR:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_OhdrAtom::Create(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_ODDA:
            atom = AP4_OddaAtom::Create(size_64, stream);
            break;

          case AP4_ATOM_TYPE_ODAF:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_OdafAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_GRPI:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_GrpiAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_IPRO:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_IproAtom::Create(size_32, stream, *this);
            break;

          case AP4_ATOM_TYPE_RTP_:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_RtpAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_TFDT:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TfdtAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_TENC:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_TencAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SENC:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SencAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SAIZ:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SaizAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SAIO:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SaioAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_PDIN:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_PdinAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_BLOC:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_BlocAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_AINF:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_AinfAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_PSSH:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_PsshAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SIDX:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SidxAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SBGP:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SbgpAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_SGPD:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_SgpdAtom::Create(size_32, stream);
            break;

          case AP4_ATOM_TYPE_MKID:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            if (GetContext() == AP4_ATOM_TYPE_MARL) {
                atom = AP4_MkidAtom::Create(size_32, stream);
            }
            break;

          case AP4_ATOM_TYPE_DEC3:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            if (GetContext() == AP4_ATOM_TYPE_EC_3 || GetContext() == AP4_ATOM_TYPE_ENCA) {
                atom = AP4_Dec3Atom::Create(size_32, stream);
            }
            break;

          // track ref types
          case AP4_ATOM_TYPE_HINT:
          case AP4_ATOM_TYPE_CDSC:
          case AP4_ATOM_TYPE_SYNC:
          case AP4_ATOM_TYPE_MPOD:
          case AP4_ATOM_TYPE_DPND:
          case AP4_ATOM_TYPE_IPIR:
          case AP4_ATOM_TYPE_ALIS:
          case AP4_ATOM_TYPE_CHAP:
            if (GetContext() == AP4_ATOM_TYPE_TREF) {
                if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
                atom = AP4_TrefTypeAtom::Create(type, size_32, stream);
            }
            break;

    #endif // AP4_CONFIG_MINI_BUILD

          // container atoms
          case AP4_ATOM_TYPE_MOOF:
          case AP4_ATOM_TYPE_MVEX:
          case AP4_ATOM_TYPE_TRAF:
          case AP4_ATOM_TYPE_TREF:
          case AP4_ATOM_TYPE_MFRA:
          case AP4_ATOM_TYPE_HNTI:
          case AP4_ATOM_TYPE_STBL:
          case AP4_ATOM_TYPE_MDIA:
          case AP4_ATOM_TYPE_DINF:
          case AP4_ATOM_TYPE_MINF:
          case AP4_ATOM_TYPE_SCHI:
          case AP4_ATOM_TYPE_SINF:
          case AP4_ATOM_TYPE_UDTA:
          case AP4_ATOM_TYPE_ILST:
          case AP4_ATOM_TYPE_EDTS: 
          case AP4_ATOM_TYPE_MDRI:
          case AP4_ATOM_TYPE_WAVE:
            if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
            atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);
            break;

          // containers, only at the top
          case AP4_ATOM_TYPE_MARL:
            if (GetContext() == 0) {
                atom = AP4_ContainerAtom::Create(type, size_64, false, force_64, stream, *this);
            }
            break;
            
          // full container atoms
          case AP4_ATOM_TYPE_META:
          case AP4_ATOM_TYPE_ODRM:
          case AP4_ATOM_TYPE_ODKM:
            atom = AP4_ContainerAtom::Create(type, size_64, true, force_64, stream, *this);
            break;

          case AP4_ATOM_TYPE_FREE:
          case AP4_ATOM_TYPE_WIDE:
          case AP4_ATOM_TYPE_MDAT:
            // generic atoms
            break;
            
          default: {
            // try all the external type handlers
            AP4_List<TypeHandler>::Item* handler_item = m_TypeHandlers.FirstItem();
            while (handler_item) {
                TypeHandler* handler = handler_item->GetData();
                if (AP4_SUCCEEDED(handler->CreateAtom(type, size_32, stream, GetContext(), atom))) {
                    break;
                }
                handler_item = handler_item->GetNext();
            }

            break;
          }
        }
    }
    
    return AP4_SUCCESS;
}","AP4_Result
AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& VAR_0, 
                                      AP4_UI32        VAR_1,
                                      AP4_UI32        VAR_2,
                                      AP4_UI64        VAR_3,
                                      AP4_Atom*&      VAR_4)
{
    bool VAR_5 = (VAR_2 == 1);
    bool VAR_6 = (VAR_2==1 && ((VAR_3>>32) == 0));
    
    /* COMMENT_0 */
    if (GetContext() == VAR_7) {
        /* COMMENT_1 */
        if (VAR_5) return VAR_8;
        switch (VAR_1) {
          case VAR_9:
            VAR_4 = new AP4_Mp4aSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_10:
            VAR_4 = new AP4_Mp4vSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_11:
            VAR_4 = new AP4_Mp4sSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_12:
            VAR_4 = new AP4_EncaSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_13:
            VAR_4 = new AP4_EncvSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_14:
            VAR_4 = new AP4_DrmsSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_15:
            VAR_4 = new AP4_DrmiSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_16:
          case VAR_17:
          case VAR_18:
          case VAR_19:
          case VAR_20:
          case VAR_21:
            VAR_4 = new AP4_AvcSampleEntry(VAR_1, VAR_2, VAR_0, *this);
            break;

          case VAR_22:
          case VAR_23:
          case VAR_24:
          case VAR_25:
            VAR_4 = new AP4_HevcSampleEntry(VAR_1, VAR_2, VAR_0, *this);
            break;

          case VAR_26:
          case VAR_27:
          case VAR_28:
          case VAR_29:
          case VAR_30:
          case VAR_31:
          case VAR_32:
            VAR_4 = new AP4_AudioSampleEntry(VAR_1, VAR_2, VAR_0, *this);
            break;
            
          case VAR_33:
            VAR_4 = new AP4_RtpHintSampleEntry(VAR_2, VAR_0, *this);
            break;

          case VAR_34:
            VAR_4 = new AP4_SubtitleSampleEntry(VAR_1, VAR_2, VAR_0, *this);
            break;

          default: {
            /* COMMENT_2 */
            AP4_List<TypeHandler>::Item* VAR_35 = VAR_36.FirstItem();
            while (VAR_35) {
                TypeHandler* VAR_37 = VAR_35->GetData();
                if (AP4_SUCCEEDED(VAR_37->CreateAtom(VAR_1, VAR_2, VAR_0, GetContext(), VAR_4))) {
                    break;
                }
                VAR_35 = VAR_35->GetNext();
            }

            /* COMMENT_3 */
            if (VAR_4 == NULL) {
                VAR_4 = new AP4_UnknownSampleEntry(VAR_1, (AP4_UI32)VAR_3, VAR_0);
            }

            break;
          }
        }
    } else {
        /* COMMENT_4 */
        switch (VAR_1) {
          case VAR_38:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_MoovAtom::Create(VAR_2, VAR_0, *this);
            break;

          case VAR_39:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_MvhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_40:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_MehdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_41:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_MfhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_42:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TrakAtom::Create(VAR_2, VAR_0, *this);
            break;

          case VAR_43:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TrexAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_44:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_HdlrAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_45:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TkhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_46:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TfhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_47:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TrunAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_48:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TfraAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_49:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_MfroAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_50:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_MdhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_7:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_StsdAtom::Create(VAR_2, VAR_0, *this);
            break;

          case VAR_51:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_StscAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_52:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_StcoAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_53:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_Co64Atom::Create(VAR_2, VAR_0);
            break;

          case VAR_54:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_StszAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_55:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_Stz2Atom::Create(VAR_2, VAR_0);
            break;

          case VAR_56:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SttsAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_57:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_CttsAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_58:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_StssAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_59:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_IodsAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_60:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_EsdsAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_61:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_AvccAtom::Create(VAR_2, VAR_0);
            break;
            
          case VAR_62:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_HvccAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_63:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_DvccAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_64:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_HvccAtom::Create(VAR_2, VAR_0);
            if (VAR_4) {
                VAR_4->SetType(VAR_64);
            }
            break;

          case VAR_65:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_AvccAtom::Create(VAR_2, VAR_0);
            if (VAR_4) {
                VAR_4->SetType(VAR_65);
            }
            break;

    #if !defined(VAR_66)
          case VAR_67: {
              AP4_UI08 VAR_68[16];
              AP4_Result VAR_69 = VAR_0.Read(VAR_68, 16);
              if (AP4_FAILED(VAR_69)) return VAR_69;
              
              if (AP4_CompareMemory(VAR_68, VAR_70, 16) == 0) {
                  VAR_4 = AP4_PiffTrackEncryptionAtom::Create((AP4_UI32)VAR_3, VAR_0);
              } else if (AP4_CompareMemory(VAR_68, VAR_71, 16) == 0) {
                  VAR_4 = AP4_PiffSampleEncryptionAtom::Create((AP4_UI32)VAR_3, VAR_0);
              } else {
                  VAR_4 = new AP4_UnknownUuidAtom(VAR_3, VAR_68, VAR_0);
              }
              break;
          }
            
          case VAR_72:
            VAR_4 = new AP4_NullTerminatedStringAtom(VAR_1, VAR_3, VAR_0);
            break;

          case VAR_73:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_8bdlAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_74:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_DrefAtom::Create(VAR_2, VAR_0, *this);
            break;

          case VAR_75:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_UrlAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_76:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_ElstAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_77:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_VmhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_78:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SmhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_79:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_NmhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_80:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SthdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_81:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_HmhdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_82:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_FrmaAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_83:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SchmAtom::Create(VAR_2, &VAR_84, VAR_0);
            break;

          case VAR_85:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_FtypAtom::Create(VAR_2, VAR_0);
            break;
                        
          case VAR_86:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TimsAtom::Create(VAR_2, VAR_0);
            break;
     
          case VAR_87:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SdpAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_88:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_IkmsAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_89:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_IsfmAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_90:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_IsltAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_91:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_OdheAtom::Create(VAR_2, VAR_0, *this);
            break;

          case VAR_92:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_OhdrAtom::Create(VAR_2, VAR_0, *this);
            break;

          case VAR_93:
            VAR_4 = AP4_OddaAtom::Create(VAR_3, VAR_0);
            break;

          case VAR_94:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_OdafAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_95:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_GrpiAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_96:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_IproAtom::Create(VAR_2, VAR_0, *this);
            break;

          case VAR_33:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_RtpAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_97:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TfdtAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_98:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_TencAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_99:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SencAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_100:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SaizAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_101:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SaioAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_102:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_PdinAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_103:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_BlocAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_104:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_AinfAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_105:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_PsshAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_106:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SidxAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_107:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SbgpAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_108:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_SgpdAtom::Create(VAR_2, VAR_0);
            break;

          case VAR_109:
            if (VAR_5) return VAR_8;
            if (GetContext() == VAR_110) {
                VAR_4 = AP4_MkidAtom::Create(VAR_2, VAR_0);
            }
            break;

          case VAR_111:
            if (VAR_5) return VAR_8;
            if (GetContext() == VAR_28 || GetContext() == VAR_12) {
                VAR_4 = AP4_Dec3Atom::Create(VAR_2, VAR_0);
            }
            break;

          /* COMMENT_5 */
          case VAR_112:
          case VAR_113:
          case VAR_114:
          case VAR_115:
          case VAR_116:
          case VAR_117:
          case VAR_118:
          case VAR_119:
            if (GetContext() == VAR_120) {
                if (VAR_5) return VAR_8;
                VAR_4 = AP4_TrefTypeAtom::Create(VAR_1, VAR_2, VAR_0);
            }
            break;

    #endif /* COMMENT_6 */

          /* COMMENT_7 */
          case VAR_121:
          case VAR_122:
          case VAR_123:
          case VAR_120:
          case VAR_124:
          case VAR_125:
          case VAR_126:
          case VAR_127:
          case VAR_128:
          case VAR_129:
          case VAR_130:
          case VAR_131:
          case VAR_132:
          case VAR_133:
          case VAR_134: 
          case VAR_135:
          case VAR_136:
            if (VAR_5) return VAR_8;
            VAR_4 = AP4_ContainerAtom::Create(VAR_1, VAR_3, false, VAR_6, VAR_0, *this);
            break;

          /* COMMENT_8 */
          case VAR_110:
            if (GetContext() == 0) {
                VAR_4 = AP4_ContainerAtom::Create(VAR_1, VAR_3, false, VAR_6, VAR_0, *this);
            }
            break;
            
          /* COMMENT_9 */
          case VAR_137:
          case VAR_138:
          case VAR_139:
            VAR_4 = AP4_ContainerAtom::Create(VAR_1, VAR_3, true, VAR_6, VAR_0, *this);
            break;

          case VAR_140:
          case VAR_141:
          case VAR_142:
            /* COMMENT_10 */
            break;
            
          default: {
            /* COMMENT_2 */
            AP4_List<TypeHandler>::Item* VAR_35 = VAR_36.FirstItem();
            while (VAR_35) {
                TypeHandler* VAR_37 = VAR_35->GetData();
                if (AP4_SUCCEEDED(VAR_37->CreateAtom(VAR_1, VAR_2, VAR_0, GetContext(), VAR_4))) {
                    break;
                }
                VAR_35 = VAR_35->GetNext();
            }

            break;
          }
        }
    }
    
    return VAR_143;
}",axiomatic-systems/Bento4/be7185faf7f52674028977dcf501c6039ff03aa5/Ap4AtomFactory.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -235,13 +235,17 @@
           case AP4_ATOM_TYPE_HVCE:
             if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
             atom = AP4_HvccAtom::Create(size_32, stream);
-            atom->SetType(AP4_ATOM_TYPE_HVCE);
+            if (atom) {
+                atom->SetType(AP4_ATOM_TYPE_HVCE);
+            }
             break;
 
           case AP4_ATOM_TYPE_AVCE:
             if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
             atom = AP4_AvccAtom::Create(size_32, stream);
-            atom->SetType(AP4_ATOM_TYPE_AVCE);
+            if (atom) {
+                atom->SetType(AP4_ATOM_TYPE_AVCE);
+            }
             break;
 
     #if !defined(AP4_CONFIG_MINI_BUILD)","{'deleted_lines': ['            atom->SetType(AP4_ATOM_TYPE_HVCE);', '            atom->SetType(AP4_ATOM_TYPE_AVCE);'], 'added_lines': ['            if (atom) {', '                atom->SetType(AP4_ATOM_TYPE_HVCE);', '            }', '            if (atom) {', '                atom->SetType(AP4_ATOM_TYPE_AVCE);', '            }']}",True,"AP4_AtomFactory::CreateAtomFromStream in Core/Ap4AtomFactory.cpp in Bento4 version 1.5.0-617 has missing NULL checks, leading to a NULL pointer dereference, segmentation fault, and application crash in AP4_Atom::SetType in Core/Ap4Atom.h.",6.5,MEDIUM,1,test,2017-09-09T17:36:28Z,2
CVE-2017-14640,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,axiomatic-systems/Bento4,fix for #183,2f267f89f957088197f4b1fc254632d1645b415d,https://github.com/axiomatic-systems/Bento4/commit/2f267f89f957088197f4b1fc254632d1645b415d,Source/C++/Core/Ap4AtomSampleTable.cpp,AP4_AtomSampleTable::GetSample,"AP4_Result
AP4_AtomSampleTable::GetSample(AP4_Ordinal index, 
AP4_Sample& sample)
{
AP4_Result result;
if (!m_StscAtom) {
return AP4_ERROR_INVALID_FORMAT;
}
if (m_StcoAtom == NULL && m_Co64Atom == NULL) {
return AP4_ERROR_INVALID_FORMAT;
}
index++;
AP4_Ordinal chunk, skip, desc;
result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);
if (AP4_FAILED(result)) return result;
if (skip > index) return AP4_ERROR_INTERNAL;
AP4_UI64 offset;
if (m_StcoAtom) {
AP4_UI32 offset_32;
result = m_StcoAtom->GetChunkOffset(chunk, offset_32);
offset = offset_32;
} else {
result = m_Co64Atom->GetChunkOffset(chunk, offset);
}
if (AP4_FAILED(result)) return result;
for (unsigned int i = index-skip; i < index; i++) {
AP4_Size size = 0;
if (m_StszAtom) {
result = m_StszAtom->GetSampleSize(i, size); 
} else if (m_Stz2Atom) {
result = m_Stz2Atom->GetSampleSize(i, size); 
} else {
result = AP4_ERROR_INVALID_FORMAT;
}
if (AP4_FAILED(result)) return result;
offset += size;
}
sample.SetDescriptionIndex(desc-1); 
AP4_UI32 cts_offset = 0;
AP4_UI64 dts        = 0;
AP4_UI32 duration   = 0;
result = m_SttsAtom->GetDts(index, dts, &duration);
if (AP4_FAILED(result)) return result;
sample.SetDuration(duration);
sample.SetDts(dts);
if (m_CttsAtom == NULL) {
sample.SetCts(dts);
} else {
result = m_CttsAtom->GetCtsOffset(index, cts_offset); 
if (AP4_FAILED(result)) return result;
sample.SetCtsDelta(cts_offset);
}     
AP4_Size sample_size = 0;
if (m_StszAtom) {
result = m_StszAtom->GetSampleSize(index, sample_size); 
} else if (m_Stz2Atom) {
result = m_Stz2Atom->GetSampleSize(index, sample_size); 
} else {
result = AP4_ERROR_INVALID_FORMAT;
}
if (AP4_FAILED(result)) return result;
sample.SetSize(sample_size);
if (m_StssAtom == NULL) {
sample.SetSync(true);
} else {
sample.SetSync(m_StssAtom->IsSampleSync(index));
}
sample.SetOffset(offset);
sample.SetDataStream(m_SampleStream);
return AP4_SUCCESS;
}","AP4_Result
AP4_AtomSampleTable::GetSample(AP4_Ordinal VAR_0, 
AP4_Sample& VAR_1)
{
AP4_Result VAR_2;
if (!VAR_3) {
return VAR_4;
}
if (VAR_5 == NULL && VAR_6 == NULL) {
return VAR_4;
}
VAR_0++;
AP4_Ordinal VAR_7, VAR_8, VAR_9;
VAR_2 = VAR_3->GetChunkForSample(VAR_0, VAR_7, VAR_8, VAR_9);
if (AP4_FAILED(VAR_2)) return VAR_2;
if (VAR_8 > VAR_0) return VAR_10;
AP4_UI64 VAR_11;
if (VAR_5) {
AP4_UI32 VAR_12;
VAR_2 = VAR_5->GetChunkOffset(VAR_7, VAR_12);
VAR_11 = VAR_12;
} else {
VAR_2 = VAR_6->GetChunkOffset(VAR_7, VAR_11);
}
if (AP4_FAILED(VAR_2)) return VAR_2;
for (unsigned int VAR_13 = VAR_0-VAR_8; VAR_13 < VAR_0; VAR_13++) {
AP4_Size VAR_14 = 0;
if (VAR_15) {
VAR_2 = VAR_15->GetSampleSize(VAR_13, VAR_14); 
} else if (VAR_16) {
VAR_2 = VAR_16->GetSampleSize(VAR_13, VAR_14); 
} else {
VAR_2 = VAR_4;
}
if (AP4_FAILED(VAR_2)) return VAR_2;
VAR_11 += VAR_14;
}
VAR_1.SetDescriptionIndex(VAR_9-1); 
AP4_UI32 VAR_17 = 0;
AP4_UI64 VAR_18        = 0;
AP4_UI32 VAR_19   = 0;
VAR_2 = VAR_20->GetDts(VAR_0, VAR_18, &VAR_19);
if (AP4_FAILED(VAR_2)) return VAR_2;
VAR_1.SetDuration(VAR_19);
VAR_1.SetDts(VAR_18);
if (VAR_21 == NULL) {
VAR_1.SetCts(VAR_18);
} else {
VAR_2 = VAR_21->GetCtsOffset(VAR_0, VAR_17); 
if (AP4_FAILED(VAR_2)) return VAR_2;
VAR_1.SetCtsDelta(VAR_17);
}     
AP4_Size VAR_22 = 0;
if (VAR_15) {
VAR_2 = VAR_15->GetSampleSize(VAR_0, VAR_22); 
} else if (VAR_16) {
VAR_2 = VAR_16->GetSampleSize(VAR_0, VAR_22); 
} else {
VAR_2 = VAR_4;
}
if (AP4_FAILED(VAR_2)) return VAR_2;
VAR_1.SetSize(VAR_22);
if (VAR_23 == NULL) {
VAR_1.SetSync(true);
} else {
VAR_1.SetSync(VAR_23->IsSampleSync(VAR_0));
}
VAR_1.SetOffset(VAR_11);
VAR_1.SetDataStream(VAR_24);
return VAR_25;
}",axiomatic-systems/Bento4/2f267f89f957088197f4b1fc254632d1645b415d/Ap4AtomSampleTable.cpp/vul/before/0.json,"AP4_Result
AP4_AtomSampleTable::GetSample(AP4_Ordinal index, 
                               AP4_Sample& sample)
{
    AP4_Result result;

    // check that we have an stsc atom
    if (!m_StscAtom) {
        return AP4_ERROR_INVALID_FORMAT;
    }
    
    // check that we have a chunk offset table
    if (m_StcoAtom == NULL && m_Co64Atom == NULL) {
        return AP4_ERROR_INVALID_FORMAT;
    }

    // MP4 uses 1-based indexes internally, so adjust by one
    index++;

    // find out in which chunk this sample is located
    AP4_Ordinal chunk, skip, desc;
    result = m_StscAtom->GetChunkForSample(index, chunk, skip, desc);
    if (AP4_FAILED(result)) return result;
    
    // check that the result is within bounds
    if (skip > index) return AP4_ERROR_INTERNAL;

    // get the atom offset for this chunk
    AP4_UI64 offset;
    if (m_StcoAtom) {
        AP4_UI32 offset_32;
        result = m_StcoAtom->GetChunkOffset(chunk, offset_32);
        offset = offset_32;
    } else {
        result = m_Co64Atom->GetChunkOffset(chunk, offset);
    }
    if (AP4_FAILED(result)) return result;
    
    // compute the additional offset inside the chunk
    for (unsigned int i = index-skip; i < index; i++) {
        AP4_Size size = 0;
        if (m_StszAtom) {
            result = m_StszAtom->GetSampleSize(i, size); 
        } else if (m_Stz2Atom) {
            result = m_Stz2Atom->GetSampleSize(i, size); 
        } else {
            result = AP4_ERROR_INVALID_FORMAT;
        }
        if (AP4_FAILED(result)) return result;
        offset += size;
    }

    // set the description index
    sample.SetDescriptionIndex(desc-1); // adjust for 0-based indexes

    // set the dts and cts
    AP4_UI32 cts_offset = 0;
    AP4_UI64 dts        = 0;
    AP4_UI32 duration   = 0;
    if (m_SttsAtom) {
        result = m_SttsAtom->GetDts(index, dts, &duration);
        if (AP4_FAILED(result)) return result;
    }
    sample.SetDuration(duration);
    sample.SetDts(dts);
    if (m_CttsAtom == NULL) {
        sample.SetCts(dts);
    } else {
        result = m_CttsAtom->GetCtsOffset(index, cts_offset); 
	    if (AP4_FAILED(result)) return result;
        sample.SetCtsDelta(cts_offset);
    }     

    // set the size
    AP4_Size sample_size = 0;
    if (m_StszAtom) {
        result = m_StszAtom->GetSampleSize(index, sample_size); 
    } else if (m_Stz2Atom) {
        result = m_Stz2Atom->GetSampleSize(index, sample_size); 
    } else {
        result = AP4_ERROR_INVALID_FORMAT;
    }
    if (AP4_FAILED(result)) return result;
    sample.SetSize(sample_size);

    // set the sync flag
    if (m_StssAtom == NULL) {
        sample.SetSync(true);
    } else {
        sample.SetSync(m_StssAtom->IsSampleSync(index));
    }

    // set the offset
    sample.SetOffset(offset);

    // set the data stream
    sample.SetDataStream(m_SampleStream);


    return AP4_SUCCESS;
}","AP4_Result
AP4_AtomSampleTable::GetSample(AP4_Ordinal VAR_0, 
                               AP4_Sample& VAR_1)
{
    AP4_Result VAR_2;

    /* COMMENT_0 */
    if (!VAR_3) {
        return VAR_4;
    }
    
    /* COMMENT_1 */
    if (VAR_5 == NULL && VAR_6 == NULL) {
        return VAR_4;
    }

    /* COMMENT_2 */
    VAR_0++;

    /* COMMENT_3 */
    AP4_Ordinal VAR_7, VAR_8, VAR_9;
    VAR_2 = VAR_3->GetChunkForSample(VAR_0, VAR_7, VAR_8, VAR_9);
    if (AP4_FAILED(VAR_2)) return VAR_2;
    
    /* COMMENT_4 */
    if (VAR_8 > VAR_0) return VAR_10;

    /* COMMENT_5 */
    AP4_UI64 VAR_11;
    if (VAR_5) {
        AP4_UI32 VAR_12;
        VAR_2 = VAR_5->GetChunkOffset(VAR_7, VAR_12);
        VAR_11 = VAR_12;
    } else {
        VAR_2 = VAR_6->GetChunkOffset(VAR_7, VAR_11);
    }
    if (AP4_FAILED(VAR_2)) return VAR_2;
    
    /* COMMENT_6 */
    for (unsigned int VAR_13 = VAR_0-VAR_8; VAR_13 < VAR_0; VAR_13++) {
        AP4_Size VAR_14 = 0;
        if (VAR_15) {
            VAR_2 = VAR_15->GetSampleSize(VAR_13, VAR_14); 
        } else if (VAR_16) {
            VAR_2 = VAR_16->GetSampleSize(VAR_13, VAR_14); 
        } else {
            VAR_2 = VAR_4;
        }
        if (AP4_FAILED(VAR_2)) return VAR_2;
        VAR_11 += VAR_14;
    }

    /* COMMENT_7 */
    VAR_1.SetDescriptionIndex(VAR_9-1); /* COMMENT_8 */

    /* COMMENT_9 */
    AP4_UI32 VAR_17 = 0;
    AP4_UI64 VAR_18        = 0;
    AP4_UI32 VAR_19   = 0;
    if (VAR_20) {
        VAR_2 = VAR_20->GetDts(VAR_0, VAR_18, &VAR_19);
        if (AP4_FAILED(VAR_2)) return VAR_2;
    }
    VAR_1.SetDuration(VAR_19);
    VAR_1.SetDts(VAR_18);
    if (VAR_21 == NULL) {
        VAR_1.SetCts(VAR_18);
    } else {
        VAR_2 = VAR_21->GetCtsOffset(VAR_0, VAR_17); 
	    if (AP4_FAILED(VAR_2)) return VAR_2;
        VAR_1.SetCtsDelta(VAR_17);
    }     

    /* COMMENT_10 */
    AP4_Size VAR_22 = 0;
    if (VAR_15) {
        VAR_2 = VAR_15->GetSampleSize(VAR_0, VAR_22); 
    } else if (VAR_16) {
        VAR_2 = VAR_16->GetSampleSize(VAR_0, VAR_22); 
    } else {
        VAR_2 = VAR_4;
    }
    if (AP4_FAILED(VAR_2)) return VAR_2;
    VAR_1.SetSize(VAR_22);

    /* COMMENT_11 */
    if (VAR_23 == NULL) {
        VAR_1.SetSync(true);
    } else {
        VAR_1.SetSync(VAR_23->IsSampleSync(VAR_0));
    }

    /* COMMENT_12 */
    VAR_1.SetOffset(VAR_11);

    /* COMMENT_13 */
    VAR_1.SetDataStream(VAR_24);


    return VAR_25;
}",axiomatic-systems/Bento4/2f267f89f957088197f4b1fc254632d1645b415d/Ap4AtomSampleTable.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -57,8 +57,10 @@
     AP4_UI32 cts_offset = 0;
     AP4_UI64 dts        = 0;
     AP4_UI32 duration   = 0;
-    result = m_SttsAtom->GetDts(index, dts, &duration);
-    if (AP4_FAILED(result)) return result;
+    if (m_SttsAtom) {
+        result = m_SttsAtom->GetDts(index, dts, &duration);
+        if (AP4_FAILED(result)) return result;
+    }
     sample.SetDuration(duration);
     sample.SetDts(dts);
     if (m_CttsAtom == NULL) {","{'deleted_lines': ['    result = m_SttsAtom->GetDts(index, dts, &duration);', '    if (AP4_FAILED(result)) return result;'], 'added_lines': ['    if (m_SttsAtom) {', '        result = m_SttsAtom->GetDts(index, dts, &duration);', '        if (AP4_FAILED(result)) return result;', '    }']}",True,"A NULL pointer dereference was discovered in AP4_AtomSampleTable::GetSample in Core/Ap4AtomSampleTable.cpp in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash, which leads to remote denial of service.",6.5,MEDIUM,1,test,2017-09-09T17:42:03Z,2
CVE-2018-1091,['CWE-119'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"powerpc/tm: Flush TM only if CPU has TM feature

Commit cd63f3c (""powerpc/tm: Fix saving of TM SPRs in core dump"")
added code to access TM SPRs in flush_tmregs_to_thread(). However
flush_tmregs_to_thread() does not check if TM feature is available on
CPU before trying to access TM SPRs in order to copy live state to
thread structures. flush_tmregs_to_thread() is indeed guarded by
CONFIG_PPC_TRANSACTIONAL_MEM but it might be the case that kernel
was compiled with CONFIG_PPC_TRANSACTIONAL_MEM enabled and ran on
a CPU without TM feature available, thus rendering the execution
of TM instructions that are treated by the CPU as illegal instructions.

The fix is just to add proper checking in flush_tmregs_to_thread()
if CPU has the TM feature before accessing any TM-specific resource,
returning immediately if TM is no available on the CPU. Adding
that checking in flush_tmregs_to_thread() instead of in places
where it is called, like in vsr_get() and vsr_set(), is better because
avoids the same problem cropping up elsewhere.

Cc: stable@vger.kernel.org # v4.13+
Fixes: cd63f3c (""powerpc/tm: Fix saving of TM SPRs in core dump"")
Signed-off-by: Gustavo Romero <gromero@linux.vnet.ibm.com>
Reviewed-by: Cyril Bur <cyrilbur@gmail.com>
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>",c1fa0768a8713b135848f78fd43ffc208d8ded70,https://github.com/torvalds/linux/commit/c1fa0768a8713b135848f78fd43ffc208d8ded70,arch/powerpc/kernel/ptrace.c,flush_tmregs_to_thread,"static void flush_tmregs_to_thread(struct task_struct *tsk)
{
if (tsk != current)
return;
if (MSR_TM_SUSPENDED(mfmsr())) {
tm_reclaim_current(TM_CAUSE_SIGNAL);
} else {
tm_enable();
tm_save_sprs(&(tsk->thread));
}
}","static void flush_tmregs_to_thread(struct task_struct *VAR_0)
{
if (VAR_0 != VAR_1)
return;
if (MSR_TM_SUSPENDED(mfmsr())) {
tm_reclaim_current(VAR_2);
} else {
tm_enable();
tm_save_sprs(&(VAR_0->thread));
}
}",torvalds/linux/c1fa0768a8713b135848f78fd43ffc208d8ded70/ptrace.c/vul/before/0.json,"static void flush_tmregs_to_thread(struct task_struct *tsk)
{
	/*
	 * If task is not current, it will have been flushed already to
	 * it's thread_struct during __switch_to().
	 *
	 * A reclaim flushes ALL the state or if not in TM save TM SPRs
	 * in the appropriate thread structures from live.
	 */

	if ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))
		return;

	if (MSR_TM_SUSPENDED(mfmsr())) {
		tm_reclaim_current(TM_CAUSE_SIGNAL);
	} else {
		tm_enable();
		tm_save_sprs(&(tsk->thread));
	}
}","static void flush_tmregs_to_thread(struct task_struct *VAR_0)
{
	/* COMMENT_0 */
                                                                
                                            
   
                                                                
                                                   
    

	if ((!cpu_has_feature(VAR_1)) || (VAR_0 != VAR_2))
		return;

	if (MSR_TM_SUSPENDED(mfmsr())) {
		tm_reclaim_current(VAR_3);
	} else {
		tm_enable();
		tm_save_sprs(&(VAR_0->thread));
	}
}",torvalds/linux/c1fa0768a8713b135848f78fd43ffc208d8ded70/ptrace.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 	 * in the appropriate thread structures from live.
 	 */
 
-	if (tsk != current)
+	if ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))
 		return;
 
 	if (MSR_TM_SUSPENDED(mfmsr())) {","{'deleted_lines': ['\tif (tsk != current)'], 'added_lines': ['\tif ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))']}",True,"In the flush_tmregs_to_thread function in arch/powerpc/kernel/ptrace.c in the Linux kernel before 4.13.5, a guest kernel crash can be triggered from unprivileged userspace during a core dump on a POWER host due to a missing processor feature check and an erroneous use of transactional memory (TM) instructions in the core dump path, leading to a denial of service.",5.5,MEDIUM,1,test,2017-09-14T02:13:48Z,2
CVE-2017-16526,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"uwb: properly check kthread_run return value

uwbd_start() calls kthread_run() and checks that the return value is
not NULL. But the return value is not NULL in case kthread_run() fails,
it takes the form of ERR_PTR(-EINTR).

Use IS_ERR() instead.

Also add a check to uwbd_stop().

Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",bbf26183b7a6236ba602f4d6a2f7cade35bba043,https://github.com/torvalds/linux/commit/bbf26183b7a6236ba602f4d6a2f7cade35bba043,drivers/uwb/uwbd.c,uwbd_stop,"void uwbd_stop(struct uwb_rc *rc)
{
kthread_stop(rc->uwbd.task);
uwbd_flush(rc);
}","void uwbd_stop(struct uwb_rc *VAR_0)
{
kthread_stop(VAR_0->uwbd.task);
uwbd_flush(VAR_0);
}",torvalds/linux/bbf26183b7a6236ba602f4d6a2f7cade35bba043/uwbd.c/vul/before/0.json,"void uwbd_stop(struct uwb_rc *rc)
{
	if (rc->uwbd.task)
		kthread_stop(rc->uwbd.task);
	uwbd_flush(rc);
}","void uwbd_stop(struct uwb_rc *VAR_0)
{
	if (VAR_0->uwbd.task)
		kthread_stop(VAR_0->uwbd.task);
	uwbd_flush(VAR_0);
}",torvalds/linux/bbf26183b7a6236ba602f4d6a2f7cade35bba043/uwbd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 void uwbd_stop(struct uwb_rc *rc)
 {
-	kthread_stop(rc->uwbd.task);
+	if (rc->uwbd.task)
+		kthread_stop(rc->uwbd.task);
 	uwbd_flush(rc);
 }","{'deleted_lines': ['\tkthread_stop(rc->uwbd.task);'], 'added_lines': ['\tif (rc->uwbd.task)', '\t\tkthread_stop(rc->uwbd.task);']}",True,drivers/uwb/uwbd.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (general protection fault and system crash) or possibly have unspecified other impact via a crafted USB device.,7.8,HIGH,2,test,2017-09-14T12:30:55Z,2
CVE-2017-16526,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"uwb: properly check kthread_run return value

uwbd_start() calls kthread_run() and checks that the return value is
not NULL. But the return value is not NULL in case kthread_run() fails,
it takes the form of ERR_PTR(-EINTR).

Use IS_ERR() instead.

Also add a check to uwbd_stop().

Signed-off-by: Andrey Konovalov <andreyknvl@google.com>
Cc: stable <stable@vger.kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",bbf26183b7a6236ba602f4d6a2f7cade35bba043,https://github.com/torvalds/linux/commit/bbf26183b7a6236ba602f4d6a2f7cade35bba043,drivers/uwb/uwbd.c,uwbd_start,"void uwbd_start(struct uwb_rc *rc)
{
rc->uwbd.task = kthread_run(uwbd, rc, ""uwbd"");
if (rc->uwbd.task == NULL)
printk(KERN_ERR ""UWB: Cannot start management daemon; ""
""UWB won't work\n"");
else
rc->uwbd.pid = rc->uwbd.task->pid;
}","void uwbd_start(struct uwb_rc *VAR_0)
{
VAR_0->uwbd.task = kthread_run(VAR_1, VAR_0, ""uwbd"");
if (VAR_0->uwbd.task == NULL)
printk(KERN_ERR ""UWB: Cannot start management daemon; ""
""UWB won't work\n"");
else
VAR_0->uwbd.pid = VAR_0->uwbd.task->pid;
}",torvalds/linux/bbf26183b7a6236ba602f4d6a2f7cade35bba043/uwbd.c/vul/before/1.json,"void uwbd_start(struct uwb_rc *rc)
{
	struct task_struct *task = kthread_run(uwbd, rc, ""uwbd"");
	if (IS_ERR(task)) {
		rc->uwbd.task = NULL;
		printk(KERN_ERR ""UWB: Cannot start management daemon; ""
		       ""UWB won't work\n"");
	} else {
		rc->uwbd.task = task;
		rc->uwbd.pid = rc->uwbd.task->pid;
	}
}","void uwbd_start(struct uwb_rc *VAR_0)
{
	struct task_struct *VAR_1 = kthread_run(VAR_2, VAR_0, ""uwbd"");
	if (IS_ERR(VAR_1)) {
		VAR_0->uwbd.task = NULL;
		printk(KERN_ERR ""UWB: Cannot start management daemon; ""
		       ""UWB won't work\n"");
	} else {
		VAR_0->uwbd.task = VAR_1;
		VAR_0->uwbd.pid = VAR_0->uwbd.task->pid;
	}
}",torvalds/linux/bbf26183b7a6236ba602f4d6a2f7cade35bba043/uwbd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,9 +1,12 @@
 void uwbd_start(struct uwb_rc *rc)
 {
-	rc->uwbd.task = kthread_run(uwbd, rc, ""uwbd"");
-	if (rc->uwbd.task == NULL)
+	struct task_struct *task = kthread_run(uwbd, rc, ""uwbd"");
+	if (IS_ERR(task)) {
+		rc->uwbd.task = NULL;
 		printk(KERN_ERR ""UWB: Cannot start management daemon; ""
 		       ""UWB won't work\n"");
-	else
+	} else {
+		rc->uwbd.task = task;
 		rc->uwbd.pid = rc->uwbd.task->pid;
+	}
 }","{'deleted_lines': ['\trc->uwbd.task = kthread_run(uwbd, rc, ""uwbd"");', '\tif (rc->uwbd.task == NULL)', '\telse'], 'added_lines': ['\tstruct task_struct *task = kthread_run(uwbd, rc, ""uwbd"");', '\tif (IS_ERR(task)) {', '\t\trc->uwbd.task = NULL;', '\t} else {', '\t\trc->uwbd.task = task;', '\t}']}",True,drivers/uwb/uwbd.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (general protection fault and system crash) or possibly have unspecified other impact via a crafted USB device.,7.8,HIGH,2,test,2017-09-14T12:30:55Z,2
CVE-2017-13760,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sleuthkit,fixes #906 and increments counter to find bitmap,ed2072153ad5168635b309d3308190c9e28c1c1c,https://github.com/sleuthkit/sleuthkit/commit/ed2072153ad5168635b309d3308190c9e28c1c1c,tsk/fs/exfatfs.c,exfatfs_get_alloc_bitmap,"static uint8_t
exfatfs_get_alloc_bitmap(FATFS_INFO *a_fatfs)
{
const char *func_name = ""exfatfs_get_alloc_bitmap"";
TSK_FS_INFO *fs = &(a_fatfs->fs_info);
TSK_DADDR_T current_sector = 0;
TSK_DADDR_T last_sector_of_data_area = 0;
char *sector_buf = NULL;
EXFATFS_ALLOC_BITMAP_DIR_ENTRY *dentry = NULL;
uint64_t i = 0;
uint64_t first_sector_of_alloc_bitmap = 0;
uint64_t alloc_bitmap_length_in_bytes = 0;
uint64_t last_sector_of_alloc_bitmap = 0;
assert(a_fatfs != NULL);
if ((sector_buf = (char*)tsk_malloc(a_fatfs->ssize)) == NULL) {
return FATFS_FAIL;
}
current_sector = a_fatfs->rootsect;
last_sector_of_data_area = a_fatfs->firstdatasect + (a_fatfs->clustcnt * a_fatfs->csize) - 1;
while (current_sector < last_sector_of_data_area) {
ssize_t bytes_read = 0;
bytes_read = tsk_fs_read_block(fs, current_sector, sector_buf, a_fatfs->ssize);
if (bytes_read != a_fatfs->ssize) {
if (bytes_read >= 0) {
tsk_error_reset();
tsk_error_set_errno(TSK_ERR_FS_READ);
}
tsk_error_set_errstr2(""%s: sector: %"" PRIuDADDR, func_name, current_sector);
free(sector_buf);
return FATFS_FAIL;
}
for (i = 0; i < a_fatfs->ssize; i += sizeof(FATFS_DENTRY)) {
dentry = (EXFATFS_ALLOC_BITMAP_DIR_ENTRY*)&(sector_buf[i]); 
if (exfatfs_get_enum_from_type(dentry->entry_type) == EXFATFS_DIR_ENTRY_TYPE_ALLOC_BITMAP) {
if (!exfatfs_is_alloc_bitmap_dentry((FATFS_DENTRY*)dentry, FATFS_DATA_UNIT_ALLOC_STATUS_UNKNOWN, a_fatfs)) {
continue;
}
if (~(dentry->flags & 0x01)) {
first_sector_of_alloc_bitmap = FATFS_CLUST_2_SECT(a_fatfs, tsk_getu32(fs->endian, dentry->first_cluster_of_bitmap));
alloc_bitmap_length_in_bytes = tsk_getu64(fs->endian, dentry->length_of_alloc_bitmap_in_bytes);
last_sector_of_alloc_bitmap = first_sector_of_alloc_bitmap + (roundup(alloc_bitmap_length_in_bytes, a_fatfs->ssize) / a_fatfs->ssize) - 1;
if ((first_sector_of_alloc_bitmap >= a_fatfs->firstdatasect) &&
(last_sector_of_alloc_bitmap <= last_sector_of_data_area) &&
(alloc_bitmap_length_in_bytes >= (a_fatfs->clustcnt + 7) / 8))
{
a_fatfs->EXFATFS_INFO.first_sector_of_alloc_bitmap = first_sector_of_alloc_bitmap; 
a_fatfs->EXFATFS_INFO.length_of_alloc_bitmap_in_bytes = alloc_bitmap_length_in_bytes;
free(sector_buf);
return FATFS_OK;
}
}
}
}
}
free(sector_buf);
return FATFS_FAIL;
}","static uint8_t
exfatfs_get_alloc_bitmap(FATFS_INFO *VAR_0)
{
const char *VAR_1 = ""exfatfs_get_alloc_bitmap"";
TSK_FS_INFO *VAR_2 = &(VAR_0->fs_info);
TSK_DADDR_T VAR_3 = 0;
TSK_DADDR_T VAR_4 = 0;
char *VAR_5 = NULL;
EXFATFS_ALLOC_BITMAP_DIR_ENTRY *VAR_6 = NULL;
uint64_t VAR_7 = 0;
uint64_t VAR_8 = 0;
uint64_t VAR_9 = 0;
uint64_t VAR_10 = 0;
assert(VAR_0 != NULL);
if ((VAR_5 = (char*)tsk_malloc(VAR_0->ssize)) == NULL) {
return VAR_11;
}
VAR_3 = VAR_0->rootsect;
VAR_4 = VAR_0->firstdatasect + (VAR_0->clustcnt * VAR_0->csize) - 1;
while (VAR_3 < VAR_4) {
ssize_t VAR_12 = 0;
VAR_12 = tsk_fs_read_block(VAR_2, VAR_3, VAR_5, VAR_0->ssize);
if (VAR_12 != VAR_0->ssize) {
if (VAR_12 >= 0) {
tsk_error_reset();
tsk_error_set_errno(VAR_13);
}
tsk_error_set_errstr2(""%s: sector: %"" VAR_14, VAR_1, VAR_3);
free(VAR_5);
return VAR_11;
}
for (VAR_7 = 0; VAR_7 < VAR_0->ssize; VAR_7 += sizeof(VAR_15)) {
VAR_6 = (EXFATFS_ALLOC_BITMAP_DIR_ENTRY*)&(VAR_5[VAR_7]); 
if (exfatfs_get_enum_from_type(VAR_6->entry_type) == VAR_16) {
if (!exfatfs_is_alloc_bitmap_dentry((FATFS_DENTRY*)VAR_6, VAR_17, VAR_0)) {
continue;
}
if (~(VAR_6->flags & 0x01)) {
VAR_8 = FATFS_CLUST_2_SECT(VAR_0, tsk_getu32(VAR_2->endian, VAR_6->first_cluster_of_bitmap));
VAR_9 = tsk_getu64(VAR_2->endian, VAR_6->length_of_alloc_bitmap_in_bytes);
VAR_10 = VAR_8 + (roundup(VAR_9, VAR_0->ssize) / VAR_0->ssize) - 1;
if ((VAR_8 >= VAR_0->firstdatasect) &&
(VAR_10 <= VAR_4) &&
(VAR_9 >= (VAR_0->clustcnt + 7) / 8))
{
VAR_0->EXFATFS_INFO.first_sector_of_alloc_bitmap = VAR_8; 
VAR_0->EXFATFS_INFO.length_of_alloc_bitmap_in_bytes = VAR_9;
free(VAR_5);
return VAR_18;
}
}
}
}
}
free(VAR_5);
return VAR_11;
}",sleuthkit/ed2072153ad5168635b309d3308190c9e28c1c1c/exfatfs.c/vul/before/0.json,"static uint8_t
exfatfs_get_alloc_bitmap(FATFS_INFO *a_fatfs)
{
    const char *func_name = ""exfatfs_get_alloc_bitmap"";
    TSK_FS_INFO *fs = &(a_fatfs->fs_info);
    TSK_DADDR_T current_sector = 0;
    TSK_DADDR_T last_sector_of_data_area = 0;
    char *sector_buf = NULL;
    EXFATFS_ALLOC_BITMAP_DIR_ENTRY *dentry = NULL;
    uint64_t i = 0;
    uint64_t first_sector_of_alloc_bitmap = 0;
    uint64_t alloc_bitmap_length_in_bytes = 0;
    uint64_t last_sector_of_alloc_bitmap = 0;

    assert(a_fatfs != NULL);
    
    if ((sector_buf = (char*)tsk_malloc(a_fatfs->ssize)) == NULL) {
        return FATFS_FAIL;
    }

    last_sector_of_data_area = a_fatfs->firstdatasect + (a_fatfs->clustcnt * a_fatfs->csize) - 1;
    for (current_sector = a_fatfs->rootsect; current_sector < last_sector_of_data_area; current_sector++) {
        ssize_t bytes_read = 0;

        /* Read in a sector from the root directory. The allocation bitmap
         * directory entries will probably be near the beginning of the 
         * directory, probably in the first sector. */
        bytes_read = tsk_fs_read_block(fs, current_sector, sector_buf, a_fatfs->ssize);
        if (bytes_read != a_fatfs->ssize) {
            if (bytes_read >= 0) {
                tsk_error_reset();
                tsk_error_set_errno(TSK_ERR_FS_READ);
            }
            tsk_error_set_errstr2(""%s: sector: %"" PRIuDADDR, func_name, current_sector);
            free(sector_buf);
            return FATFS_FAIL;
        }

        /* Read the directory entries in the sector, looking for allocation
         * bitmap entries. There will be one entry unless the file system is 
         * TexFAT (transactional exFAT), in which case there will be two. */
        for (i = 0; i < a_fatfs->ssize; i += sizeof(FATFS_DENTRY)) {
            dentry = (EXFATFS_ALLOC_BITMAP_DIR_ENTRY*)&(sector_buf[i]); 

            /* The type of the directory entry is encoded in the first byte 
             * of the entry. See EXFATFS_DIR_ENTRY_TYPE_ENUM. */ 
            if (exfatfs_get_enum_from_type(dentry->entry_type) == EXFATFS_DIR_ENTRY_TYPE_ALLOC_BITMAP) {
                /* Do an in-depth test. */
                if (!exfatfs_is_alloc_bitmap_dentry((FATFS_DENTRY*)dentry, FATFS_DATA_UNIT_ALLOC_STATUS_UNKNOWN, a_fatfs)) {
                    continue;
                }

                /* The first bit of the flags byte is 0 for the first 
                 * allocation bitmap directory entry and 1 for the second 
                 * bitmap directory entry. If TexFAT is in use and there are
                 * two allocation bitmaps, the first bitmap should be the
                 * stable copy of the last known good allocation bitmap. 
                 * Therefore, the SleuthKit will use the first bitmap to 
                 * determine which clusters are allocated. */
                if (~(dentry->flags & 0x01)) {
                    first_sector_of_alloc_bitmap = FATFS_CLUST_2_SECT(a_fatfs, tsk_getu32(fs->endian, dentry->first_cluster_of_bitmap));
                    alloc_bitmap_length_in_bytes = tsk_getu64(fs->endian, dentry->length_of_alloc_bitmap_in_bytes);
                    last_sector_of_alloc_bitmap = first_sector_of_alloc_bitmap + (roundup(alloc_bitmap_length_in_bytes, a_fatfs->ssize) / a_fatfs->ssize) - 1;

                    /* The allocation bitmap must lie within the boundaries of the data area. 
                     * It also must be big enough for the number of clusters reported in the VBR. */
                    if ((first_sector_of_alloc_bitmap >= a_fatfs->firstdatasect) &&
                        (last_sector_of_alloc_bitmap <= last_sector_of_data_area) &&
                        (alloc_bitmap_length_in_bytes >= (a_fatfs->clustcnt + 7) / 8))
                    {
                        a_fatfs->EXFATFS_INFO.first_sector_of_alloc_bitmap = first_sector_of_alloc_bitmap; 
                        a_fatfs->EXFATFS_INFO.length_of_alloc_bitmap_in_bytes = alloc_bitmap_length_in_bytes;
                        free(sector_buf);
                        return FATFS_OK;
                    }
                }
            }
        }
    }
    free(sector_buf);

    return FATFS_FAIL;
}","static uint8_t
exfatfs_get_alloc_bitmap(FATFS_INFO *VAR_0)
{
    const char *VAR_1 = ""exfatfs_get_alloc_bitmap"";
    TSK_FS_INFO *VAR_2 = &(VAR_0->fs_info);
    TSK_DADDR_T VAR_3 = 0;
    TSK_DADDR_T VAR_4 = 0;
    char *VAR_5 = NULL;
    EXFATFS_ALLOC_BITMAP_DIR_ENTRY *VAR_6 = NULL;
    uint64_t VAR_7 = 0;
    uint64_t VAR_8 = 0;
    uint64_t VAR_9 = 0;
    uint64_t VAR_10 = 0;

    assert(VAR_0 != NULL);
    
    if ((VAR_5 = (char*)tsk_malloc(VAR_0->ssize)) == NULL) {
        return VAR_11;
    }

    VAR_4 = VAR_0->firstdatasect + (VAR_0->clustcnt * VAR_0->csize) - 1;
    for (VAR_3 = VAR_0->rootsect; VAR_3 < VAR_4; VAR_3++) {
        ssize_t VAR_12 = 0;

        /* COMMENT_0 */
                                                                        
                                                      
        VAR_12 = tsk_fs_read_block(VAR_2, VAR_3, VAR_5, VAR_0->ssize);
        if (VAR_12 != VAR_0->ssize) {
            if (VAR_12 >= 0) {
                tsk_error_reset();
                tsk_error_set_errno(VAR_13);
            }
            tsk_error_set_errstr2(""%s: sector: %"" VAR_14, VAR_1, VAR_3);
            free(VAR_5);
            return VAR_11;
        }

        /* COMMENT_3 */
                                                                             
                                                                            
        for (VAR_7 = 0; VAR_7 < VAR_0->ssize; VAR_7 += sizeof(VAR_15)) {
            VAR_6 = (EXFATFS_ALLOC_BITMAP_DIR_ENTRY*)&(VAR_5[VAR_7]); 

            /* COMMENT_6 */
                                                                 
            if (exfatfs_get_enum_from_type(VAR_6->entry_type) == VAR_16) {
                /* COMMENT_8 */
                if (!exfatfs_is_alloc_bitmap_dentry((FATFS_DENTRY*)VAR_6, VAR_17, VAR_0)) {
                    continue;
                }

                /* COMMENT_9 */
                                                                          
                                                                            
                                                                         
                                                                         
                                                                         
                                                             
                if (~(VAR_6->flags & 0x01)) {
                    VAR_8 = FATFS_CLUST_2_SECT(VAR_0, tsk_getu32(VAR_2->endian, VAR_6->first_cluster_of_bitmap));
                    VAR_9 = tsk_getu64(VAR_2->endian, VAR_6->length_of_alloc_bitmap_in_bytes);
                    VAR_10 = VAR_8 + (roundup(VAR_9, VAR_0->ssize) / VAR_0->ssize) - 1;

                    /* COMMENT_16 */
                                                                                                    
                    if ((VAR_8 >= VAR_0->firstdatasect) &&
                        (VAR_10 <= VAR_4) &&
                        (VAR_9 >= (VAR_0->clustcnt + 7) / 8))
                    {
                        VAR_0->EXFATFS_INFO.first_sector_of_alloc_bitmap = VAR_8; 
                        VAR_0->EXFATFS_INFO.length_of_alloc_bitmap_in_bytes = VAR_9;
                        free(VAR_5);
                        return VAR_18;
                    }
                }
            }
        }
    }
    free(VAR_5);

    return VAR_11;
}",sleuthkit/ed2072153ad5168635b309d3308190c9e28c1c1c/exfatfs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,9 +18,8 @@
         return FATFS_FAIL;
     }
 
-    current_sector = a_fatfs->rootsect;
     last_sector_of_data_area = a_fatfs->firstdatasect + (a_fatfs->clustcnt * a_fatfs->csize) - 1;
-    while (current_sector < last_sector_of_data_area) {
+    for (current_sector = a_fatfs->rootsect; current_sector < last_sector_of_data_area; current_sector++) {
         ssize_t bytes_read = 0;
 
         /* Read in a sector from the root directory. The allocation bitmap","{'deleted_lines': ['    current_sector = a_fatfs->rootsect;', '    while (current_sector < last_sector_of_data_area) {'], 'added_lines': ['    for (current_sector = a_fatfs->rootsect; current_sector < last_sector_of_data_area; current_sector++) {']}",True,"In The Sleuth Kit (TSK) 4.4.2, fls hangs on a corrupt exfat image in tsk_img_read() in tsk/img/img_io.c in libtskimg.a.",5.5,MEDIUM,1,test,2017-09-14T17:41:15Z,2
CVE-2017-15190,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"RTSP: fix stack use after scope error reported by ASan

Bug: 14077
Change-Id: I9fa0e62fe354b1c18687ba9041029de97719343c
Reviewed-on: https://code.wireshark.org/review/23635
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",e27870eaa6efa1c2dac08aa41a67fe9f0839e6e0,https://github.com/wireshark/wireshark/commit/e27870eaa6efa1c2dac08aa41a67fe9f0839e6e0,epan/dissectors/packet-rtsp.c,rtsp_create_conversation,"static void
rtsp_create_conversation(packet_info *pinfo, proto_item *ti,
const guchar *line_begin, size_t line_len,
gint rdt_feature_level,
rtsp_type_t rtsp_type_packet)
{
conversation_t  *conv;
guchar    buf[256];
guchar   *tmp;
gboolean  rtp_udp_transport = FALSE;
gboolean  rtp_tcp_transport = FALSE;
gboolean  rdt_transport = FALSE;
guint     c_data_port, c_mon_port;
guint     s_data_port, s_mon_port;
guint     ipv4_1, ipv4_2, ipv4_3, ipv4_4;
gboolean  is_video      = FALSE; 
address   src_addr;
address   dst_addr;
if (rtsp_type_packet != RTSP_REPLY) {
return;
}
src_addr=pinfo->src;
dst_addr=pinfo->dst;
if (line_len > sizeof(buf) - 1)
{
line_len = sizeof(buf) - 1;
}
memcpy(buf, line_begin, line_len);
buf[line_len] = '\0';
tmp = buf + STRLEN_CONST(rtsp_transport);
while (*tmp && g_ascii_isspace(*tmp))
tmp++;
if (g_ascii_strncasecmp(tmp, rtsp_rtp_udp, strlen(rtsp_rtp_udp)) == 0)
{
rtp_udp_transport = TRUE;
}
else if (g_ascii_strncasecmp(tmp, rtsp_rtp_tcp, strlen(rtsp_rtp_tcp)) == 0)
{
rtp_tcp_transport = TRUE;
}
else if (g_ascii_strncasecmp(tmp, rtsp_rtp_udp_default, strlen(rtsp_rtp_udp_default)) == 0)
{
rtp_udp_transport = TRUE;
}
else if (g_ascii_strncasecmp(tmp, rtsp_real_rdt, strlen(rtsp_real_rdt)) == 0 ||
g_ascii_strncasecmp(tmp, rtsp_real_tng, strlen(rtsp_real_tng)) == 0)
{
rdt_transport = TRUE;
}
else
{
expert_add_info(pinfo, ti, &ei_rtsp_unknown_transport_type);
return;
}
c_data_port = c_mon_port = 0;
s_data_port = s_mon_port = 0;
if ((tmp = strstr(buf, rtsp_sps_server_port))) {
tmp += strlen(rtsp_sps_server_port);
if (sscanf(tmp, ""%u-%u"", &s_data_port, &s_mon_port) < 1) {
expert_add_info(pinfo, ti, &ei_rtsp_bad_server_port);
return;
}
}
else if ((tmp = strstr(buf, rtsp_sps_dest_addr))) {
tmp += strlen(rtsp_sps_dest_addr);
if (sscanf(tmp, ""\"":%u\"""", &s_data_port) == 1) {
if (s_data_port == 9) {
s_data_port = 0;
}
}
else if (sscanf(tmp, ""\""%u.%u.%u.%u:%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &s_data_port) == 5) {
guchar *tmp2;
guchar *tmp3;
guint32 ip4_addr;
tmp++;
tmp2=strstr(tmp,"":"");
tmp3=g_strndup(tmp,tmp2-tmp);
if (!str_to_ip(tmp3, &ip4_addr)) {
g_free(tmp3);
expert_add_info(pinfo, ti, &ei_rtsp_bad_server_ip_address);
return;
}
set_address(&dst_addr, AT_IPv4, 4, &ip4_addr);
g_free(tmp3);
}
else if (sscanf(tmp, ""\""%u.%u.%u.%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4) == 4) {
guchar *tmp2;
guchar *tmp3;
guint32 ip4_addr;
tmp++;
tmp2=strstr(tmp,""\"""");
tmp3=g_strndup(tmp,tmp2-tmp);
if (!str_to_ip(tmp3, &ip4_addr)) {
g_free(tmp3);
expert_add_info(pinfo, ti, &ei_rtsp_bad_server_ip_address);
return;
}
set_address(&dst_addr, AT_IPv4, 4, &ip4_addr);
g_free(tmp3);
}
else
{
expert_add_info(pinfo, ti, &ei_rtsp_bad_server_port);
return;
}
}
if ((tmp = strstr(buf, rtsp_cps_server_port))) {
tmp += strlen(rtsp_cps_server_port);
if (sscanf(tmp, ""%u-%u"", &c_data_port, &c_mon_port) < 1) {
expert_add_info(pinfo, ti, &ei_rtsp_bad_client_port);
return;
}
}
else if ((tmp = strstr(buf, rtsp_cps_src_addr))) {
tmp += strlen(rtsp_cps_src_addr);
if (sscanf(tmp, ""\""%u.%u.%u.%u:%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &c_data_port) == 5) {
guchar *tmp2;
guchar *tmp3;
guint32 ip4_addr;
tmp++;
tmp2=strstr(tmp,"":"");
tmp3=g_strndup(tmp,tmp2-tmp);
if (!str_to_ip(tmp3, &ip4_addr)) {
g_free(tmp3);
expert_add_info(pinfo, ti, &ei_rtsp_bad_client_ip_address);
return;
}
set_address(&src_addr, AT_IPv4, 4, &ip4_addr);
g_free(tmp3);
}
}
if (strstr(buf, rtsp_inter) != NULL) {
rtsp_conversation_data_t    *data;
guint               s_data_chan, s_mon_chan;
int             i;
tmp = strstr(buf, rtsp_inter);
tmp += strlen(rtsp_inter);
i = sscanf(tmp, ""%u-%u"", &s_data_chan, &s_mon_chan);
if (i < 1)
{
expert_add_info(pinfo, ti, &ei_rtsp_bad_interleaved_channel);
return;
}
conv = find_or_create_conversation(pinfo);
data = (rtsp_conversation_data_t *)conversation_get_proto_data(conv, proto_rtsp);
if (!data)
{
data = wmem_new0(wmem_file_scope(), rtsp_conversation_data_t);
conversation_add_proto_data(conv, proto_rtsp, data);
}
if (rtp_tcp_transport)
{
if (s_data_chan < RTSP_MAX_INTERLEAVED) {
data->interleaved[s_data_chan].dissector =
rtp_handle;
}
if (i > 1 && s_mon_chan < RTSP_MAX_INTERLEAVED) {
data->interleaved[s_mon_chan].dissector =
rtcp_handle;
}
}
else if (rdt_transport)
{
if (s_data_chan < RTSP_MAX_INTERLEAVED) {
data->interleaved[s_data_chan].dissector =
rdt_handle;
}
}
return;
}
else if (rtp_udp_transport)
{
if (c_data_port)
{
rtp_add_address(pinfo, PT_UDP, &dst_addr, c_data_port, s_data_port,
""RTSP"", pinfo->num, is_video, NULL);
}
if (c_mon_port)
{
rtcp_add_address(pinfo, &pinfo->dst, c_mon_port, s_mon_port,
""RTSP"", pinfo->num);
}
}
else if (rtp_tcp_transport)
{
rtp_add_address(pinfo, PT_TCP, &src_addr, c_data_port, s_data_port,
""RTSP"", pinfo->num, is_video, NULL);
}
else if (rdt_transport)
{
rdt_add_address(pinfo, &pinfo->dst, c_data_port, s_data_port,
""RTSP"", rdt_feature_level);
}
return;
}","static void
rtsp_create_conversation(packet_info *VAR_0, proto_item *VAR_1,
const guchar *VAR_2, size_t VAR_3,
gint VAR_4,
rtsp_type_t VAR_5)
{
conversation_t  *VAR_6;
guchar    VAR_7[256];
guchar   *VAR_8;
gboolean  VAR_9 = FALSE;
gboolean  VAR_10 = FALSE;
gboolean  VAR_11 = FALSE;
guint     VAR_12, VAR_13;
guint     VAR_14, VAR_15;
guint     VAR_16, VAR_17, VAR_18, VAR_19;
gboolean  VAR_20      = FALSE; 
address   VAR_21;
address   VAR_22;
if (VAR_5 != VAR_23) {
return;
}
VAR_21=VAR_0->src;
VAR_22=VAR_0->dst;
if (VAR_3 > sizeof(VAR_7) - 1)
{
VAR_3 = sizeof(VAR_7) - 1;
}
memcpy(VAR_7, VAR_2, VAR_3);
VAR_7[VAR_3] = '\0';
VAR_8 = VAR_7 + STRLEN_CONST(VAR_24);
while (*VAR_8 && g_ascii_isspace(*VAR_8))
VAR_8++;
if (g_ascii_strncasecmp(VAR_8, VAR_25, strlen(VAR_25)) == 0)
{
VAR_9 = TRUE;
}
else if (g_ascii_strncasecmp(VAR_8, VAR_26, strlen(VAR_26)) == 0)
{
VAR_10 = TRUE;
}
else if (g_ascii_strncasecmp(VAR_8, VAR_27, strlen(VAR_27)) == 0)
{
VAR_9 = TRUE;
}
else if (g_ascii_strncasecmp(VAR_8, VAR_28, strlen(VAR_28)) == 0 ||
g_ascii_strncasecmp(VAR_8, VAR_29, strlen(VAR_29)) == 0)
{
VAR_11 = TRUE;
}
else
{
expert_add_info(VAR_0, VAR_1, &VAR_30);
return;
}
VAR_12 = VAR_13 = 0;
VAR_14 = VAR_15 = 0;
if ((VAR_8 = strstr(VAR_7, VAR_31))) {
VAR_8 += strlen(VAR_31);
if (sscanf(VAR_8, ""%u-%u"", &VAR_14, &VAR_15) < 1) {
expert_add_info(VAR_0, VAR_1, &VAR_32);
return;
}
}
else if ((VAR_8 = strstr(VAR_7, VAR_33))) {
VAR_8 += strlen(VAR_33);
if (sscanf(VAR_8, ""\"":%u\"""", &VAR_14) == 1) {
if (VAR_14 == 9) {
VAR_14 = 0;
}
}
else if (sscanf(VAR_8, ""\""%u.%u.%u.%u:%u\"""", &VAR_16, &VAR_17, &VAR_18, &VAR_19, &VAR_14) == 5) {
guchar *VAR_34;
guchar *VAR_35;
guint32 VAR_36;
VAR_8++;
VAR_34=strstr(VAR_8,"":"");
VAR_35=g_strndup(VAR_8,VAR_34-VAR_8);
if (!str_to_ip(VAR_35, &VAR_36)) {
g_free(VAR_35);
expert_add_info(VAR_0, VAR_1, &VAR_37);
return;
}
set_address(&VAR_22, VAR_38, 4, &VAR_36);
g_free(VAR_35);
}
else if (sscanf(VAR_8, ""\""%u.%u.%u.%u\"""", &VAR_16, &VAR_17, &VAR_18, &VAR_19) == 4) {
guchar *VAR_34;
guchar *VAR_35;
guint32 VAR_36;
VAR_8++;
VAR_34=strstr(VAR_8,""\"""");
VAR_35=g_strndup(VAR_8,VAR_34-VAR_8);
if (!str_to_ip(VAR_35, &VAR_36)) {
g_free(VAR_35);
expert_add_info(VAR_0, VAR_1, &VAR_37);
return;
}
set_address(&VAR_22, VAR_38, 4, &VAR_36);
g_free(VAR_35);
}
else
{
expert_add_info(VAR_0, VAR_1, &VAR_32);
return;
}
}
if ((VAR_8 = strstr(VAR_7, VAR_39))) {
VAR_8 += strlen(VAR_39);
if (sscanf(VAR_8, ""%u-%u"", &VAR_12, &VAR_13) < 1) {
expert_add_info(VAR_0, VAR_1, &VAR_40);
return;
}
}
else if ((VAR_8 = strstr(VAR_7, VAR_41))) {
VAR_8 += strlen(VAR_41);
if (sscanf(VAR_8, ""\""%u.%u.%u.%u:%u\"""", &VAR_16, &VAR_17, &VAR_18, &VAR_19, &VAR_12) == 5) {
guchar *VAR_34;
guchar *VAR_35;
guint32 VAR_36;
VAR_8++;
VAR_34=strstr(VAR_8,"":"");
VAR_35=g_strndup(VAR_8,VAR_34-VAR_8);
if (!str_to_ip(VAR_35, &VAR_36)) {
g_free(VAR_35);
expert_add_info(VAR_0, VAR_1, &VAR_42);
return;
}
set_address(&VAR_21, VAR_38, 4, &VAR_36);
g_free(VAR_35);
}
}
if (strstr(VAR_7, VAR_43) != NULL) {
rtsp_conversation_data_t    *VAR_44;
guint               VAR_45, VAR_46;
int             VAR_47;
VAR_8 = strstr(VAR_7, VAR_43);
VAR_8 += strlen(VAR_43);
VAR_47 = sscanf(VAR_8, ""%u-%u"", &VAR_45, &VAR_46);
if (VAR_47 < 1)
{
expert_add_info(VAR_0, VAR_1, &VAR_48);
return;
}
VAR_6 = find_or_create_conversation(VAR_0);
VAR_44 = (rtsp_conversation_data_t *)conversation_get_proto_data(VAR_6, VAR_49);
if (!VAR_44)
{
VAR_44 = wmem_new0(wmem_file_scope(), rtsp_conversation_data_t);
conversation_add_proto_data(VAR_6, VAR_49, VAR_44);
}
if (VAR_10)
{
if (VAR_45 < VAR_50) {
VAR_44->interleaved[VAR_45].dissector =
VAR_51;
}
if (VAR_47 > 1 && VAR_46 < VAR_50) {
VAR_44->interleaved[VAR_46].dissector =
VAR_52;
}
}
else if (VAR_11)
{
if (VAR_45 < VAR_50) {
VAR_44->interleaved[VAR_45].dissector =
VAR_53;
}
}
return;
}
else if (VAR_9)
{
if (VAR_12)
{
rtp_add_address(VAR_0, VAR_54, &VAR_22, VAR_12, VAR_14,
""RTSP"", VAR_0->num, VAR_20, NULL);
}
if (VAR_13)
{
rtcp_add_address(VAR_0, &VAR_0->dst, VAR_13, VAR_15,
""RTSP"", VAR_0->num);
}
}
else if (VAR_10)
{
rtp_add_address(VAR_0, VAR_55, &VAR_21, VAR_12, VAR_14,
""RTSP"", VAR_0->num, VAR_20, NULL);
}
else if (VAR_11)
{
rdt_add_address(VAR_0, &VAR_0->dst, VAR_12, VAR_14,
""RTSP"", VAR_4);
}
return;
}",wireshark/e27870eaa6efa1c2dac08aa41a67fe9f0839e6e0/packet-rtsp.c/vul/before/0.json,"static void
rtsp_create_conversation(packet_info *pinfo, proto_item *ti,
                         const guchar *line_begin, size_t line_len,
                         gint rdt_feature_level,
                         rtsp_type_t rtsp_type_packet)
{
    conversation_t  *conv;
    guchar    buf[256];
    guchar   *tmp;
    gboolean  rtp_udp_transport = FALSE;
    gboolean  rtp_tcp_transport = FALSE;
    gboolean  rdt_transport = FALSE;
    guint     c_data_port, c_mon_port;
    guint     s_data_port, s_mon_port;
    guint     ipv4_1, ipv4_2, ipv4_3, ipv4_4;
    gboolean  is_video      = FALSE; /* FIX ME - need to indicate video or not */
    address   src_addr;
    address   dst_addr;
    guint32   ip4_addr;

    if (rtsp_type_packet != RTSP_REPLY) {
        return;
    }

    src_addr=pinfo->src;
    dst_addr=pinfo->dst;

    /* Copy line into buf */
    if (line_len > sizeof(buf) - 1)
    {
        /* Don't overflow the buffer. */
        line_len = sizeof(buf) - 1;
    }
    memcpy(buf, line_begin, line_len);
    buf[line_len] = '\0';

    /* Get past ""Transport:"" and spaces */
    tmp = buf + STRLEN_CONST(rtsp_transport);
    while (*tmp && g_ascii_isspace(*tmp))
        tmp++;

    /* Work out which transport type is here */
    if (g_ascii_strncasecmp(tmp, rtsp_rtp_udp, strlen(rtsp_rtp_udp)) == 0)
    {
        rtp_udp_transport = TRUE;
    }
    else if (g_ascii_strncasecmp(tmp, rtsp_rtp_tcp, strlen(rtsp_rtp_tcp)) == 0)
    {
        rtp_tcp_transport = TRUE;
    }
    else if (g_ascii_strncasecmp(tmp, rtsp_rtp_udp_default, strlen(rtsp_rtp_udp_default)) == 0)
    {
        rtp_udp_transport = TRUE;
    }
    else if (g_ascii_strncasecmp(tmp, rtsp_real_rdt, strlen(rtsp_real_rdt)) == 0 ||
                 g_ascii_strncasecmp(tmp, rtsp_real_tng, strlen(rtsp_real_tng)) == 0)
    {
        rdt_transport = TRUE;
    }
    else
    {
        /* Give up on unknown transport types */
        expert_add_info(pinfo, ti, &ei_rtsp_unknown_transport_type);
        return;
    }

    c_data_port = c_mon_port = 0;
    s_data_port = s_mon_port = 0;

    /* Look for server port */
    if ((tmp = strstr(buf, rtsp_sps_server_port))) {
        tmp += strlen(rtsp_sps_server_port);
        if (sscanf(tmp, ""%u-%u"", &s_data_port, &s_mon_port) < 1) {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_server_port);
            return;
        }
    }
    else if ((tmp = strstr(buf, rtsp_sps_dest_addr))) {
        tmp += strlen(rtsp_sps_dest_addr);
        if (sscanf(tmp, ""\"":%u\"""", &s_data_port) == 1) {
            /* :9 mean ignore */
            if (s_data_port == 9) {
                s_data_port = 0;
            }
        }
        else if (sscanf(tmp, ""\""%u.%u.%u.%u:%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &s_data_port) == 5) {
            guchar *tmp2;
            guchar *tmp3;

            /* Skip leading "" */
            tmp++;
            tmp2=strstr(tmp,"":"");
            tmp3=g_strndup(tmp,tmp2-tmp);
            if (!str_to_ip(tmp3, &ip4_addr)) {
                g_free(tmp3);
                expert_add_info(pinfo, ti, &ei_rtsp_bad_server_ip_address);
                return;
            }
            set_address(&dst_addr, AT_IPv4, 4, &ip4_addr);
            g_free(tmp3);
        }
        else if (sscanf(tmp, ""\""%u.%u.%u.%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4) == 4) {
            guchar *tmp2;
            guchar *tmp3;

            /* Skip leading "" */
            tmp++;
            tmp2=strstr(tmp,""\"""");
            tmp3=g_strndup(tmp,tmp2-tmp);
            if (!str_to_ip(tmp3, &ip4_addr)) {
                g_free(tmp3);
                expert_add_info(pinfo, ti, &ei_rtsp_bad_server_ip_address);
                return;
            }
            set_address(&dst_addr, AT_IPv4, 4, &ip4_addr);
            g_free(tmp3);
        }
        else
        {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_server_port);
            return;
        }
    }


    /* Look for client port */
    if ((tmp = strstr(buf, rtsp_cps_server_port))) {
        tmp += strlen(rtsp_cps_server_port);
        if (sscanf(tmp, ""%u-%u"", &c_data_port, &c_mon_port) < 1) {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_client_port);
            return;
        }
    }
    else if ((tmp = strstr(buf, rtsp_cps_src_addr))) {
        tmp += strlen(rtsp_cps_src_addr);
        if (sscanf(tmp, ""\""%u.%u.%u.%u:%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &c_data_port) == 5) {
            guchar *tmp2;
            guchar *tmp3;

            /* Skip leading "" */
            tmp++;
            tmp2=strstr(tmp,"":"");
            tmp3=g_strndup(tmp,tmp2-tmp);
            if (!str_to_ip(tmp3, &ip4_addr)) {
                g_free(tmp3);
                expert_add_info(pinfo, ti, &ei_rtsp_bad_client_ip_address);
                return;
            }
            set_address(&src_addr, AT_IPv4, 4, &ip4_addr);
            g_free(tmp3);
        }
    }

    /* Deal with RTSP TCP-interleaved conversations. */
    if (strstr(buf, rtsp_inter) != NULL) {
        rtsp_conversation_data_t    *data;
        guint               s_data_chan, s_mon_chan;
        int             i;

        /* Move tmp to beyone interleaved string */
        tmp = strstr(buf, rtsp_inter);
        tmp += strlen(rtsp_inter);
        /* Look for channel number(s) */
        i = sscanf(tmp, ""%u-%u"", &s_data_chan, &s_mon_chan);
        if (i < 1)
        {
            expert_add_info(pinfo, ti, &ei_rtsp_bad_interleaved_channel);
            return;
        }

        /* At least data channel present, look for conversation (presumably TCP) */
        conv = find_or_create_conversation(pinfo);

        /* Look for previous data */
        data = (rtsp_conversation_data_t *)conversation_get_proto_data(conv, proto_rtsp);

        /* Create new data if necessary */
        if (!data)
        {
            data = wmem_new0(wmem_file_scope(), rtsp_conversation_data_t);
            conversation_add_proto_data(conv, proto_rtsp, data);
        }

        /* Now set the dissector handle of the interleaved channel
           according to the transport protocol used */
        if (rtp_tcp_transport)
        {
            if (s_data_chan < RTSP_MAX_INTERLEAVED) {
                data->interleaved[s_data_chan].dissector =
                    rtp_handle;
            }
            if (i > 1 && s_mon_chan < RTSP_MAX_INTERLEAVED) {
                data->interleaved[s_mon_chan].dissector =
                    rtcp_handle;
            }
        }
        else if (rdt_transport)
        {
            if (s_data_chan < RTSP_MAX_INTERLEAVED) {
                data->interleaved[s_data_chan].dissector =
                    rdt_handle;
            }
        }
        return;
    }
    /* Noninterleaved options follow */
    /*
     * We only want to match on the destination address, not the
     * source address, because the server might send back a packet
     * from an address other than the address to which its client
     * sent the packet, so we construct a conversation with no
     * second address.
     */
    else if (rtp_udp_transport)
    {
        /* RTP only if indicated */
        if (c_data_port)
        {
            rtp_add_address(pinfo, PT_UDP, &dst_addr, c_data_port, s_data_port,
                            ""RTSP"", pinfo->num, is_video, NULL);
        }

        /* RTCP only if indicated */
        if (c_mon_port)
        {
            rtcp_add_address(pinfo, &pinfo->dst, c_mon_port, s_mon_port,
                             ""RTSP"", pinfo->num);
        }
    }
    else if (rtp_tcp_transport)
    {
        /* RTP only if indicated */
        rtp_add_address(pinfo, PT_TCP, &src_addr, c_data_port, s_data_port,
                        ""RTSP"", pinfo->num, is_video, NULL);
    }
    else if (rdt_transport)
    {
        /* Real Data Transport */
        rdt_add_address(pinfo, &pinfo->dst, c_data_port, s_data_port,
                        ""RTSP"", rdt_feature_level);
    }
    return;
}","static void
rtsp_create_conversation(packet_info *VAR_0, proto_item *VAR_1,
                         const guchar *VAR_2, size_t VAR_3,
                         gint VAR_4,
                         rtsp_type_t VAR_5)
{
    conversation_t  *VAR_6;
    guchar    VAR_7[256];
    guchar   *VAR_8;
    gboolean  VAR_9 = FALSE;
    gboolean  VAR_10 = FALSE;
    gboolean  VAR_11 = FALSE;
    guint     VAR_12, VAR_13;
    guint     VAR_14, VAR_15;
    guint     VAR_16, VAR_17, VAR_18, VAR_19;
    gboolean  VAR_20      = FALSE; /* COMMENT_0 */
    address   VAR_21;
    address   VAR_22;
    guint32   VAR_23;

    if (VAR_5 != VAR_24) {
        return;
    }

    VAR_21=VAR_0->src;
    VAR_22=VAR_0->dst;

    /* COMMENT_1 */
    if (VAR_3 > sizeof(VAR_7) - 1)
    {
        /* COMMENT_2 */
        VAR_3 = sizeof(VAR_7) - 1;
    }
    memcpy(VAR_7, VAR_2, VAR_3);
    VAR_7[VAR_3] = '\0';

    /* COMMENT_3 */
    VAR_8 = VAR_7 + STRLEN_CONST(VAR_25);
    while (*VAR_8 && g_ascii_isspace(*VAR_8))
        VAR_8++;

    /* COMMENT_4 */
    if (g_ascii_strncasecmp(VAR_8, VAR_26, strlen(VAR_26)) == 0)
    {
        VAR_9 = TRUE;
    }
    else if (g_ascii_strncasecmp(VAR_8, VAR_27, strlen(VAR_27)) == 0)
    {
        VAR_10 = TRUE;
    }
    else if (g_ascii_strncasecmp(VAR_8, VAR_28, strlen(VAR_28)) == 0)
    {
        VAR_9 = TRUE;
    }
    else if (g_ascii_strncasecmp(VAR_8, VAR_29, strlen(VAR_29)) == 0 ||
                 g_ascii_strncasecmp(VAR_8, VAR_30, strlen(VAR_30)) == 0)
    {
        VAR_11 = TRUE;
    }
    else
    {
        /* COMMENT_5 */
        expert_add_info(VAR_0, VAR_1, &VAR_31);
        return;
    }

    VAR_12 = VAR_13 = 0;
    VAR_14 = VAR_15 = 0;

    /* COMMENT_6 */
    if ((VAR_8 = strstr(VAR_7, VAR_32))) {
        VAR_8 += strlen(VAR_32);
        if (sscanf(VAR_8, ""%u-%u"", &VAR_14, &VAR_15) < 1) {
            expert_add_info(VAR_0, VAR_1, &VAR_33);
            return;
        }
    }
    else if ((VAR_8 = strstr(VAR_7, VAR_34))) {
        VAR_8 += strlen(VAR_34);
        if (sscanf(VAR_8, ""\"":%u\"""", &VAR_14) == 1) {
            /* COMMENT_7 */
            if (VAR_14 == 9) {
                VAR_14 = 0;
            }
        }
        else if (sscanf(VAR_8, ""\""%u.%u.%u.%u:%u\"""", &VAR_16, &VAR_17, &VAR_18, &VAR_19, &VAR_14) == 5) {
            guchar *VAR_35;
            guchar *VAR_36;

            /* COMMENT_8 */
            VAR_8++;
            VAR_35=strstr(VAR_8,"":"");
            VAR_36=g_strndup(VAR_8,VAR_35-VAR_8);
            if (!str_to_ip(VAR_36, &VAR_23)) {
                g_free(VAR_36);
                expert_add_info(VAR_0, VAR_1, &VAR_37);
                return;
            }
            set_address(&VAR_22, VAR_38, 4, &VAR_23);
            g_free(VAR_36);
        }
        else if (sscanf(VAR_8, ""\""%u.%u.%u.%u\"""", &VAR_16, &VAR_17, &VAR_18, &VAR_19) == 4) {
            guchar *VAR_35;
            guchar *VAR_36;

            /* COMMENT_8 */
            VAR_8++;
            VAR_35=strstr(VAR_8,""\"""");
            VAR_36=g_strndup(VAR_8,VAR_35-VAR_8);
            if (!str_to_ip(VAR_36, &VAR_23)) {
                g_free(VAR_36);
                expert_add_info(VAR_0, VAR_1, &VAR_37);
                return;
            }
            set_address(&VAR_22, VAR_38, 4, &VAR_23);
            g_free(VAR_36);
        }
        else
        {
            expert_add_info(VAR_0, VAR_1, &VAR_33);
            return;
        }
    }


    /* COMMENT_9 */
    if ((VAR_8 = strstr(VAR_7, VAR_39))) {
        VAR_8 += strlen(VAR_39);
        if (sscanf(VAR_8, ""%u-%u"", &VAR_12, &VAR_13) < 1) {
            expert_add_info(VAR_0, VAR_1, &VAR_40);
            return;
        }
    }
    else if ((VAR_8 = strstr(VAR_7, VAR_41))) {
        VAR_8 += strlen(VAR_41);
        if (sscanf(VAR_8, ""\""%u.%u.%u.%u:%u\"""", &VAR_16, &VAR_17, &VAR_18, &VAR_19, &VAR_12) == 5) {
            guchar *VAR_35;
            guchar *VAR_36;

            /* COMMENT_8 */
            VAR_8++;
            VAR_35=strstr(VAR_8,"":"");
            VAR_36=g_strndup(VAR_8,VAR_35-VAR_8);
            if (!str_to_ip(VAR_36, &VAR_23)) {
                g_free(VAR_36);
                expert_add_info(VAR_0, VAR_1, &VAR_42);
                return;
            }
            set_address(&VAR_21, VAR_38, 4, &VAR_23);
            g_free(VAR_36);
        }
    }

    /* COMMENT_10 */
    if (strstr(VAR_7, VAR_43) != NULL) {
        rtsp_conversation_data_t    *VAR_44;
        guint               VAR_45, VAR_46;
        int             VAR_47;

        /* COMMENT_11 */
        VAR_8 = strstr(VAR_7, VAR_43);
        VAR_8 += strlen(VAR_43);
        /* COMMENT_12 */
        VAR_47 = sscanf(VAR_8, ""%u-%u"", &VAR_45, &VAR_46);
        if (VAR_47 < 1)
        {
            expert_add_info(VAR_0, VAR_1, &VAR_48);
            return;
        }

        /* COMMENT_13 */
        VAR_6 = find_or_create_conversation(VAR_0);

        /* COMMENT_14 */
        VAR_44 = (rtsp_conversation_data_t *)conversation_get_proto_data(VAR_6, VAR_49);

        /* COMMENT_15 */
        if (!VAR_44)
        {
            VAR_44 = wmem_new0(wmem_file_scope(), rtsp_conversation_data_t);
            conversation_add_proto_data(VAR_6, VAR_49, VAR_44);
        }

        /* COMMENT_16 */
                                                      
        if (VAR_10)
        {
            if (VAR_45 < VAR_50) {
                VAR_44->interleaved[VAR_45].dissector =
                    VAR_51;
            }
            if (VAR_47 > 1 && VAR_46 < VAR_50) {
                VAR_44->interleaved[VAR_46].dissector =
                    VAR_52;
            }
        }
        else if (VAR_11)
        {
            if (VAR_45 < VAR_50) {
                VAR_44->interleaved[VAR_45].dissector =
                    VAR_53;
            }
        }
        return;
    }
    /* COMMENT_18 */
    /* COMMENT_19 */
                                                                
                                                                  
                                                                 
                                                              
                      
       
    else if (VAR_9)
    {
        /* COMMENT_26 */
        if (VAR_12)
        {
            rtp_add_address(VAR_0, VAR_54, &VAR_22, VAR_12, VAR_14,
                            ""RTSP"", VAR_0->num, VAR_20, NULL);
        }

        /* COMMENT_27 */
        if (VAR_13)
        {
            rtcp_add_address(VAR_0, &VAR_0->dst, VAR_13, VAR_15,
                             ""RTSP"", VAR_0->num);
        }
    }
    else if (VAR_10)
    {
        /* COMMENT_26 */
        rtp_add_address(VAR_0, VAR_55, &VAR_21, VAR_12, VAR_14,
                        ""RTSP"", VAR_0->num, VAR_20, NULL);
    }
    else if (VAR_11)
    {
        /* COMMENT_28 */
        rdt_add_address(VAR_0, &VAR_0->dst, VAR_12, VAR_14,
                        ""RTSP"", VAR_4);
    }
    return;
}",wireshark/e27870eaa6efa1c2dac08aa41a67fe9f0839e6e0/packet-rtsp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,6 +16,7 @@
     gboolean  is_video      = FALSE; /* FIX ME - need to indicate video or not */
     address   src_addr;
     address   dst_addr;
+    guint32   ip4_addr;
 
     if (rtsp_type_packet != RTSP_REPLY) {
         return;
@@ -85,7 +86,6 @@
         else if (sscanf(tmp, ""\""%u.%u.%u.%u:%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &s_data_port) == 5) {
             guchar *tmp2;
             guchar *tmp3;
-            guint32 ip4_addr;
 
             /* Skip leading "" */
             tmp++;
@@ -102,7 +102,6 @@
         else if (sscanf(tmp, ""\""%u.%u.%u.%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4) == 4) {
             guchar *tmp2;
             guchar *tmp3;
-            guint32 ip4_addr;
 
             /* Skip leading "" */
             tmp++;
@@ -137,7 +136,6 @@
         if (sscanf(tmp, ""\""%u.%u.%u.%u:%u\"""", &ipv4_1, &ipv4_2, &ipv4_3, &ipv4_4, &c_data_port) == 5) {
             guchar *tmp2;
             guchar *tmp3;
-            guint32 ip4_addr;
 
             /* Skip leading "" */
             tmp++;","{'deleted_lines': ['            guint32 ip4_addr;', '            guint32 ip4_addr;', '            guint32 ip4_addr;'], 'added_lines': ['    guint32   ip4_addr;']}",True,"In Wireshark 2.4.0 to 2.4.1, the RTSP dissector could crash. This was addressed in epan/dissectors/packet-rtsp.c by correcting the scope of a variable.",7.5,HIGH,2,test,2017-09-20T08:14:56Z,2
CVE-2017-12190,['CWE-400'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"fix unbalanced page refcounting in bio_map_user_iov

bio_map_user_iov and bio_unmap_user do unbalanced pages refcounting if
IO vector has small consecutive buffers belonging to the same page.
bio_add_pc_page merges them into one, but the page reference is never
dropped.

Cc: stable@vger.kernel.org
Signed-off-by: Vitaly Mayatskikh <v.mayatskih@gmail.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",95d78c28b5a85bacbc29b8dba7c04babb9b0d467,https://github.com/torvalds/linux/commit/95d78c28b5a85bacbc29b8dba7c04babb9b0d467,block/bio.c,bio_map_user_iov,"struct bio *bio_map_user_iov(struct request_queue *q,
const struct iov_iter *iter,
gfp_t gfp_mask)
{
int j;
int nr_pages = 0;
struct page **pages;
struct bio *bio;
int cur_page = 0;
int ret, offset;
struct iov_iter i;
struct iovec iov;
iov_for_each(iov, i, *iter) {
unsigned long uaddr = (unsigned long) iov.iov_base;
unsigned long len = iov.iov_len;
unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
unsigned long start = uaddr >> PAGE_SHIFT;
if (end < start)
return ERR_PTR(-EINVAL);
nr_pages += end - start;
if (uaddr & queue_dma_alignment(q))
return ERR_PTR(-EINVAL);
}
if (!nr_pages)
return ERR_PTR(-EINVAL);
bio = bio_kmalloc(gfp_mask, nr_pages);
if (!bio)
return ERR_PTR(-ENOMEM);
ret = -ENOMEM;
pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);
if (!pages)
goto out;
iov_for_each(iov, i, *iter) {
unsigned long uaddr = (unsigned long) iov.iov_base;
unsigned long len = iov.iov_len;
unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
unsigned long start = uaddr >> PAGE_SHIFT;
const int local_nr_pages = end - start;
const int page_limit = cur_page + local_nr_pages;
ret = get_user_pages_fast(uaddr, local_nr_pages,
(iter->type & WRITE) != WRITE,
&pages[cur_page]);
if (ret < local_nr_pages) {
ret = -EFAULT;
goto out_unmap;
}
offset = offset_in_page(uaddr);
for (j = cur_page; j < page_limit; j++) {
unsigned int bytes = PAGE_SIZE - offset;
if (len <= 0)
break;
if (bytes > len)
bytes = len;
if (bio_add_pc_page(q, bio, pages[j], bytes, offset) <
bytes)
break;
len -= bytes;
offset = 0;
}
cur_page = j;
while (j < page_limit)
put_page(pages[j++]);
}
kfree(pages);
bio_set_flag(bio, BIO_USER_MAPPED);
bio_get(bio);
return bio;
out_unmap:
for (j = 0; j < nr_pages; j++) {
if (!pages[j])
break;
put_page(pages[j]);
}
out:
kfree(pages);
bio_put(bio);
return ERR_PTR(ret);
}","struct bio *bio_map_user_iov(struct request_queue *VAR_0,
const struct iov_iter *VAR_1,
gfp_t VAR_2)
{
int VAR_3;
int VAR_4 = 0;
struct page **VAR_5;
struct bio *bio;
int VAR_6 = 0;
int VAR_7, VAR_8;
struct iov_iter VAR_9;
struct iovec VAR_10;
iov_for_each(VAR_10, VAR_9, *VAR_1) {
unsigned long VAR_11 = (unsigned long) VAR_10.iov_base;
unsigned long VAR_12 = VAR_10.iov_len;
unsigned long VAR_13 = (VAR_11 + VAR_12 + VAR_14 - 1) >> VAR_15;
unsigned long VAR_16 = VAR_11 >> VAR_15;
if (VAR_13 < VAR_16)
return ERR_PTR(-VAR_17);
VAR_4 += VAR_13 - VAR_16;
if (VAR_11 & queue_dma_alignment(VAR_0))
return ERR_PTR(-VAR_17);
}
if (!VAR_4)
return ERR_PTR(-VAR_17);
bio = bio_kmalloc(VAR_2, VAR_4);
if (!bio)
return ERR_PTR(-VAR_18);
VAR_7 = -VAR_18;
VAR_5 = kcalloc(VAR_4, sizeof(struct page *), VAR_2);
if (!VAR_5)
goto out;
iov_for_each(VAR_10, VAR_9, *VAR_1) {
unsigned long VAR_11 = (unsigned long) VAR_10.iov_base;
unsigned long VAR_12 = VAR_10.iov_len;
unsigned long VAR_13 = (VAR_11 + VAR_12 + VAR_14 - 1) >> VAR_15;
unsigned long VAR_16 = VAR_11 >> VAR_15;
const int VAR_19 = VAR_13 - VAR_16;
const int VAR_20 = VAR_6 + VAR_19;
VAR_7 = get_user_pages_fast(VAR_11, VAR_19,
(VAR_1->type & VAR_21) != VAR_21,
&VAR_5[VAR_6]);
if (VAR_7 < VAR_19) {
VAR_7 = -VAR_22;
goto out_unmap;
}
VAR_8 = offset_in_page(VAR_11);
for (VAR_3 = VAR_6; VAR_3 < VAR_20; VAR_3++) {
unsigned int VAR_23 = VAR_14 - VAR_8;
if (VAR_12 <= 0)
break;
if (VAR_23 > VAR_12)
VAR_23 = VAR_12;
if (bio_add_pc_page(VAR_0, bio, VAR_5[VAR_3], VAR_23, VAR_8) <
VAR_23)
break;
VAR_12 -= VAR_23;
VAR_8 = 0;
}
VAR_6 = VAR_3;
while (VAR_3 < VAR_20)
put_page(VAR_5[VAR_3++]);
}
kfree(VAR_5);
bio_set_flag(bio, VAR_24);
bio_get(bio);
return bio;
out_unmap:
for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++) {
if (!VAR_5[VAR_3])
break;
put_page(VAR_5[VAR_3]);
}
out:
kfree(VAR_5);
bio_put(bio);
return ERR_PTR(VAR_7);
}",torvalds/linux/95d78c28b5a85bacbc29b8dba7c04babb9b0d467/bio.c/vul/before/0.json,"struct bio *bio_map_user_iov(struct request_queue *q,
			     const struct iov_iter *iter,
			     gfp_t gfp_mask)
{
	int j;
	int nr_pages = 0;
	struct page **pages;
	struct bio *bio;
	int cur_page = 0;
	int ret, offset;
	struct iov_iter i;
	struct iovec iov;

	iov_for_each(iov, i, *iter) {
		unsigned long uaddr = (unsigned long) iov.iov_base;
		unsigned long len = iov.iov_len;
		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
		unsigned long start = uaddr >> PAGE_SHIFT;

		/*
		 * Overflow, abort
		 */
		if (end < start)
			return ERR_PTR(-EINVAL);

		nr_pages += end - start;
		/*
		 * buffer must be aligned to at least logical block size for now
		 */
		if (uaddr & queue_dma_alignment(q))
			return ERR_PTR(-EINVAL);
	}

	if (!nr_pages)
		return ERR_PTR(-EINVAL);

	bio = bio_kmalloc(gfp_mask, nr_pages);
	if (!bio)
		return ERR_PTR(-ENOMEM);

	ret = -ENOMEM;
	pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);
	if (!pages)
		goto out;

	iov_for_each(iov, i, *iter) {
		unsigned long uaddr = (unsigned long) iov.iov_base;
		unsigned long len = iov.iov_len;
		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
		unsigned long start = uaddr >> PAGE_SHIFT;
		const int local_nr_pages = end - start;
		const int page_limit = cur_page + local_nr_pages;

		ret = get_user_pages_fast(uaddr, local_nr_pages,
				(iter->type & WRITE) != WRITE,
				&pages[cur_page]);
		if (ret < local_nr_pages) {
			ret = -EFAULT;
			goto out_unmap;
		}

		offset = offset_in_page(uaddr);
		for (j = cur_page; j < page_limit; j++) {
			unsigned int bytes = PAGE_SIZE - offset;
			unsigned short prev_bi_vcnt = bio->bi_vcnt;

			if (len <= 0)
				break;
			
			if (bytes > len)
				bytes = len;

			/*
			 * sorry...
			 */
			if (bio_add_pc_page(q, bio, pages[j], bytes, offset) <
					    bytes)
				break;

			/*
			 * check if vector was merged with previous
			 * drop page reference if needed
			 */
			if (bio->bi_vcnt == prev_bi_vcnt)
				put_page(pages[j]);

			len -= bytes;
			offset = 0;
		}

		cur_page = j;
		/*
		 * release the pages we didn't map into the bio, if any
		 */
		while (j < page_limit)
			put_page(pages[j++]);
	}

	kfree(pages);

	bio_set_flag(bio, BIO_USER_MAPPED);

	/*
	 * subtle -- if bio_map_user_iov() ended up bouncing a bio,
	 * it would normally disappear when its bi_end_io is run.
	 * however, we need it for the unmap, so grab an extra
	 * reference to it
	 */
	bio_get(bio);
	return bio;

 out_unmap:
	for (j = 0; j < nr_pages; j++) {
		if (!pages[j])
			break;
		put_page(pages[j]);
	}
 out:
	kfree(pages);
	bio_put(bio);
	return ERR_PTR(ret);
}","struct bio *bio_map_user_iov(struct request_queue *VAR_0,
			     const struct iov_iter *VAR_1,
			     gfp_t VAR_2)
{
	int VAR_3;
	int VAR_4 = 0;
	struct page **VAR_5;
	struct bio *bio;
	int VAR_6 = 0;
	int VAR_7, VAR_8;
	struct iov_iter VAR_9;
	struct iovec VAR_10;

	iov_for_each(VAR_10, VAR_9, *VAR_1) {
		unsigned long VAR_11 = (unsigned long) VAR_10.iov_base;
		unsigned long VAR_12 = VAR_10.iov_len;
		unsigned long VAR_13 = (VAR_11 + VAR_12 + VAR_14 - 1) >> VAR_15;
		unsigned long VAR_16 = VAR_11 >> VAR_15;

		/* COMMENT_0 */
                    
     
		if (VAR_13 < VAR_16)
			return ERR_PTR(-VAR_17);

		VAR_4 += VAR_13 - VAR_16;
		/* COMMENT_3 */
                                                                  
     
		if (VAR_11 & queue_dma_alignment(VAR_0))
			return ERR_PTR(-VAR_17);
	}

	if (!VAR_4)
		return ERR_PTR(-VAR_17);

	bio = bio_kmalloc(VAR_2, VAR_4);
	if (!bio)
		return ERR_PTR(-VAR_18);

	VAR_7 = -VAR_18;
	VAR_5 = kcalloc(VAR_4, sizeof(struct page *), VAR_2);
	if (!VAR_5)
		goto out;

	iov_for_each(VAR_10, VAR_9, *VAR_1) {
		unsigned long VAR_11 = (unsigned long) VAR_10.iov_base;
		unsigned long VAR_12 = VAR_10.iov_len;
		unsigned long VAR_13 = (VAR_11 + VAR_12 + VAR_14 - 1) >> VAR_15;
		unsigned long VAR_16 = VAR_11 >> VAR_15;
		const int VAR_19 = VAR_13 - VAR_16;
		const int VAR_20 = VAR_6 + VAR_19;

		VAR_7 = get_user_pages_fast(VAR_11, VAR_19,
				(VAR_1->type & VAR_21) != VAR_21,
				&VAR_5[VAR_6]);
		if (VAR_7 < VAR_19) {
			VAR_7 = -VAR_22;
			goto out_unmap;
		}

		VAR_8 = offset_in_page(VAR_11);
		for (VAR_3 = VAR_6; VAR_3 < VAR_20; VAR_3++) {
			unsigned int VAR_23 = VAR_14 - VAR_8;
			unsigned short VAR_24 = bio->bi_vcnt;

			if (VAR_12 <= 0)
				break;
			
			if (VAR_23 > VAR_12)
				VAR_23 = VAR_12;

			/* COMMENT_6 */
              
      
			if (bio_add_pc_page(VAR_0, bio, VAR_5[VAR_3], VAR_23, VAR_8) <
					    VAR_23)
				break;

			/* COMMENT_9 */
                                              
                                   
      
			if (bio->bi_vcnt == VAR_24)
				put_page(VAR_5[VAR_3]);

			VAR_12 -= VAR_23;
			VAR_8 = 0;
		}

		VAR_6 = VAR_3;
		/* COMMENT_13 */
                                                         
     
		while (VAR_3 < VAR_20)
			put_page(VAR_5[VAR_3++]);
	}

	kfree(VAR_5);

	bio_set_flag(bio, VAR_25);

	/* COMMENT_16 */
                                                            
                                                          
                                                       
                   
    
	bio_get(bio);
	return bio;

 out_unmap:
	for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++) {
		if (!VAR_5[VAR_3])
			break;
		put_page(VAR_5[VAR_3]);
	}
 out:
	kfree(VAR_5);
	bio_put(bio);
	return ERR_PTR(VAR_7);
}",torvalds/linux/95d78c28b5a85bacbc29b8dba7c04babb9b0d467/bio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -62,6 +62,7 @@
 		offset = offset_in_page(uaddr);
 		for (j = cur_page; j < page_limit; j++) {
 			unsigned int bytes = PAGE_SIZE - offset;
+			unsigned short prev_bi_vcnt = bio->bi_vcnt;
 
 			if (len <= 0)
 				break;
@@ -75,6 +76,13 @@
 			if (bio_add_pc_page(q, bio, pages[j], bytes, offset) <
 					    bytes)
 				break;
+
+			/*
+			 * check if vector was merged with previous
+			 * drop page reference if needed
+			 */
+			if (bio->bi_vcnt == prev_bi_vcnt)
+				put_page(pages[j]);
 
 			len -= bytes;
 			offset = 0;","{'deleted_lines': [], 'added_lines': ['\t\t\tunsigned short prev_bi_vcnt = bio->bi_vcnt;', '', '\t\t\t/*', '\t\t\t * check if vector was merged with previous', '\t\t\t * drop page reference if needed', '\t\t\t */', '\t\t\tif (bio->bi_vcnt == prev_bi_vcnt)', '\t\t\t\tput_page(pages[j]);']}",True,"The bio_map_user_iov and bio_unmap_user functions in block/bio.c in the Linux kernel before 4.13.8 do unbalanced refcounting when a SCSI I/O vector has small consecutive buffers belonging to the same page. The bio_add_pc_page function merges them into one, but the page reference is never dropped. This causes a memory leak and possible system lockup (exploitable against the host OS by a guest OS user, if a SCSI disk is passed through to a virtual machine) due to an out-of-memory condition.",6.5,MEDIUM,1,test,2017-09-22T05:18:39Z,2
CVE-2017-12190,['CWE-400'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"more bio_map_user_iov() leak fixes

we need to take care of failure exit as well - pages already
in bio should be dropped by analogue of bio_unmap_pages(),
since their refcounts had been bumped only once per reference
in bio.

Cc: stable@vger.kernel.org
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058,https://github.com/torvalds/linux/commit/2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058,block/bio.c,bio_map_user_iov,"struct bio *bio_map_user_iov(struct request_queue *q,
const struct iov_iter *iter,
gfp_t gfp_mask)
{
int j;
int nr_pages = 0;
struct page **pages;
struct bio *bio;
int cur_page = 0;
int ret, offset;
struct iov_iter i;
struct iovec iov;
iov_for_each(iov, i, *iter) {
unsigned long uaddr = (unsigned long) iov.iov_base;
unsigned long len = iov.iov_len;
unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
unsigned long start = uaddr >> PAGE_SHIFT;
if (end < start)
return ERR_PTR(-EINVAL);
nr_pages += end - start;
if (uaddr & queue_dma_alignment(q))
return ERR_PTR(-EINVAL);
}
if (!nr_pages)
return ERR_PTR(-EINVAL);
bio = bio_kmalloc(gfp_mask, nr_pages);
if (!bio)
return ERR_PTR(-ENOMEM);
ret = -ENOMEM;
pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);
if (!pages)
goto out;
iov_for_each(iov, i, *iter) {
unsigned long uaddr = (unsigned long) iov.iov_base;
unsigned long len = iov.iov_len;
unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
unsigned long start = uaddr >> PAGE_SHIFT;
const int local_nr_pages = end - start;
const int page_limit = cur_page + local_nr_pages;
ret = get_user_pages_fast(uaddr, local_nr_pages,
(iter->type & WRITE) != WRITE,
&pages[cur_page]);
if (ret < local_nr_pages) {
ret = -EFAULT;
goto out_unmap;
}
offset = offset_in_page(uaddr);
for (j = cur_page; j < page_limit; j++) {
unsigned int bytes = PAGE_SIZE - offset;
unsigned short prev_bi_vcnt = bio->bi_vcnt;
if (len <= 0)
break;
if (bytes > len)
bytes = len;
if (bio_add_pc_page(q, bio, pages[j], bytes, offset) <
bytes)
break;
if (bio->bi_vcnt == prev_bi_vcnt)
put_page(pages[j]);
len -= bytes;
offset = 0;
}
cur_page = j;
while (j < page_limit)
put_page(pages[j++]);
}
kfree(pages);
bio_set_flag(bio, BIO_USER_MAPPED);
bio_get(bio);
return bio;
out_unmap:
for (j = 0; j < nr_pages; j++) {
if (!pages[j])
break;
put_page(pages[j]);
}
out:
kfree(pages);
bio_put(bio);
return ERR_PTR(ret);
}","struct bio *bio_map_user_iov(struct request_queue *VAR_0,
const struct iov_iter *VAR_1,
gfp_t VAR_2)
{
int VAR_3;
int VAR_4 = 0;
struct page **VAR_5;
struct bio *bio;
int VAR_6 = 0;
int VAR_7, VAR_8;
struct iov_iter VAR_9;
struct iovec VAR_10;
iov_for_each(VAR_10, VAR_9, *VAR_1) {
unsigned long VAR_11 = (unsigned long) VAR_10.iov_base;
unsigned long VAR_12 = VAR_10.iov_len;
unsigned long VAR_13 = (VAR_11 + VAR_12 + VAR_14 - 1) >> VAR_15;
unsigned long VAR_16 = VAR_11 >> VAR_15;
if (VAR_13 < VAR_16)
return ERR_PTR(-VAR_17);
VAR_4 += VAR_13 - VAR_16;
if (VAR_11 & queue_dma_alignment(VAR_0))
return ERR_PTR(-VAR_17);
}
if (!VAR_4)
return ERR_PTR(-VAR_17);
bio = bio_kmalloc(VAR_2, VAR_4);
if (!bio)
return ERR_PTR(-VAR_18);
VAR_7 = -VAR_18;
VAR_5 = kcalloc(VAR_4, sizeof(struct page *), VAR_2);
if (!VAR_5)
goto out;
iov_for_each(VAR_10, VAR_9, *VAR_1) {
unsigned long VAR_11 = (unsigned long) VAR_10.iov_base;
unsigned long VAR_12 = VAR_10.iov_len;
unsigned long VAR_13 = (VAR_11 + VAR_12 + VAR_14 - 1) >> VAR_15;
unsigned long VAR_16 = VAR_11 >> VAR_15;
const int VAR_19 = VAR_13 - VAR_16;
const int VAR_20 = VAR_6 + VAR_19;
VAR_7 = get_user_pages_fast(VAR_11, VAR_19,
(VAR_1->type & VAR_21) != VAR_21,
&VAR_5[VAR_6]);
if (VAR_7 < VAR_19) {
VAR_7 = -VAR_22;
goto out_unmap;
}
VAR_8 = offset_in_page(VAR_11);
for (VAR_3 = VAR_6; VAR_3 < VAR_20; VAR_3++) {
unsigned int VAR_23 = VAR_14 - VAR_8;
unsigned short VAR_24 = bio->bi_vcnt;
if (VAR_12 <= 0)
break;
if (VAR_23 > VAR_12)
VAR_23 = VAR_12;
if (bio_add_pc_page(VAR_0, bio, VAR_5[VAR_3], VAR_23, VAR_8) <
VAR_23)
break;
if (bio->bi_vcnt == VAR_24)
put_page(VAR_5[VAR_3]);
VAR_12 -= VAR_23;
VAR_8 = 0;
}
VAR_6 = VAR_3;
while (VAR_3 < VAR_20)
put_page(VAR_5[VAR_3++]);
}
kfree(VAR_5);
bio_set_flag(bio, VAR_25);
bio_get(bio);
return bio;
out_unmap:
for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++) {
if (!VAR_5[VAR_3])
break;
put_page(VAR_5[VAR_3]);
}
out:
kfree(VAR_5);
bio_put(bio);
return ERR_PTR(VAR_7);
}",torvalds/linux/2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058/bio.c/vul/before/0.json,"struct bio *bio_map_user_iov(struct request_queue *q,
			     const struct iov_iter *iter,
			     gfp_t gfp_mask)
{
	int j;
	int nr_pages = 0;
	struct page **pages;
	struct bio *bio;
	int cur_page = 0;
	int ret, offset;
	struct iov_iter i;
	struct iovec iov;
	struct bio_vec *bvec;

	iov_for_each(iov, i, *iter) {
		unsigned long uaddr = (unsigned long) iov.iov_base;
		unsigned long len = iov.iov_len;
		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
		unsigned long start = uaddr >> PAGE_SHIFT;

		/*
		 * Overflow, abort
		 */
		if (end < start)
			return ERR_PTR(-EINVAL);

		nr_pages += end - start;
		/*
		 * buffer must be aligned to at least logical block size for now
		 */
		if (uaddr & queue_dma_alignment(q))
			return ERR_PTR(-EINVAL);
	}

	if (!nr_pages)
		return ERR_PTR(-EINVAL);

	bio = bio_kmalloc(gfp_mask, nr_pages);
	if (!bio)
		return ERR_PTR(-ENOMEM);

	ret = -ENOMEM;
	pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);
	if (!pages)
		goto out;

	iov_for_each(iov, i, *iter) {
		unsigned long uaddr = (unsigned long) iov.iov_base;
		unsigned long len = iov.iov_len;
		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
		unsigned long start = uaddr >> PAGE_SHIFT;
		const int local_nr_pages = end - start;
		const int page_limit = cur_page + local_nr_pages;

		ret = get_user_pages_fast(uaddr, local_nr_pages,
				(iter->type & WRITE) != WRITE,
				&pages[cur_page]);
		if (unlikely(ret < local_nr_pages)) {
			for (j = cur_page; j < page_limit; j++) {
				if (!pages[j])
					break;
				put_page(pages[j]);
			}
			ret = -EFAULT;
			goto out_unmap;
		}

		offset = offset_in_page(uaddr);
		for (j = cur_page; j < page_limit; j++) {
			unsigned int bytes = PAGE_SIZE - offset;
			unsigned short prev_bi_vcnt = bio->bi_vcnt;

			if (len <= 0)
				break;
			
			if (bytes > len)
				bytes = len;

			/*
			 * sorry...
			 */
			if (bio_add_pc_page(q, bio, pages[j], bytes, offset) <
					    bytes)
				break;

			/*
			 * check if vector was merged with previous
			 * drop page reference if needed
			 */
			if (bio->bi_vcnt == prev_bi_vcnt)
				put_page(pages[j]);

			len -= bytes;
			offset = 0;
		}

		cur_page = j;
		/*
		 * release the pages we didn't map into the bio, if any
		 */
		while (j < page_limit)
			put_page(pages[j++]);
	}

	kfree(pages);

	bio_set_flag(bio, BIO_USER_MAPPED);

	/*
	 * subtle -- if bio_map_user_iov() ended up bouncing a bio,
	 * it would normally disappear when its bi_end_io is run.
	 * however, we need it for the unmap, so grab an extra
	 * reference to it
	 */
	bio_get(bio);
	return bio;

 out_unmap:
	bio_for_each_segment_all(bvec, bio, j) {
		put_page(bvec->bv_page);
	}
 out:
	kfree(pages);
	bio_put(bio);
	return ERR_PTR(ret);
}","struct bio *bio_map_user_iov(struct request_queue *VAR_0,
			     const struct iov_iter *VAR_1,
			     gfp_t VAR_2)
{
	int VAR_3;
	int VAR_4 = 0;
	struct page **VAR_5;
	struct bio *bio;
	int VAR_6 = 0;
	int VAR_7, VAR_8;
	struct iov_iter VAR_9;
	struct iovec VAR_10;
	struct bio_vec *VAR_11;

	iov_for_each(VAR_10, VAR_9, *VAR_1) {
		unsigned long VAR_12 = (unsigned long) VAR_10.iov_base;
		unsigned long VAR_13 = VAR_10.iov_len;
		unsigned long VAR_14 = (VAR_12 + VAR_13 + VAR_15 - 1) >> VAR_16;
		unsigned long VAR_17 = VAR_12 >> VAR_16;

		/* COMMENT_0 */
                    
     
		if (VAR_14 < VAR_17)
			return ERR_PTR(-VAR_18);

		VAR_4 += VAR_14 - VAR_17;
		/* COMMENT_3 */
                                                                  
     
		if (VAR_12 & queue_dma_alignment(VAR_0))
			return ERR_PTR(-VAR_18);
	}

	if (!VAR_4)
		return ERR_PTR(-VAR_18);

	bio = bio_kmalloc(VAR_2, VAR_4);
	if (!bio)
		return ERR_PTR(-VAR_19);

	VAR_7 = -VAR_19;
	VAR_5 = kcalloc(VAR_4, sizeof(struct page *), VAR_2);
	if (!VAR_5)
		goto out;

	iov_for_each(VAR_10, VAR_9, *VAR_1) {
		unsigned long VAR_12 = (unsigned long) VAR_10.iov_base;
		unsigned long VAR_13 = VAR_10.iov_len;
		unsigned long VAR_14 = (VAR_12 + VAR_13 + VAR_15 - 1) >> VAR_16;
		unsigned long VAR_17 = VAR_12 >> VAR_16;
		const int VAR_20 = VAR_14 - VAR_17;
		const int VAR_21 = VAR_6 + VAR_20;

		VAR_7 = get_user_pages_fast(VAR_12, VAR_20,
				(VAR_1->type & VAR_22) != VAR_22,
				&VAR_5[VAR_6]);
		if (unlikely(VAR_7 < VAR_20)) {
			for (VAR_3 = VAR_6; VAR_3 < VAR_21; VAR_3++) {
				if (!VAR_5[VAR_3])
					break;
				put_page(VAR_5[VAR_3]);
			}
			VAR_7 = -VAR_23;
			goto out_unmap;
		}

		VAR_8 = offset_in_page(VAR_12);
		for (VAR_3 = VAR_6; VAR_3 < VAR_21; VAR_3++) {
			unsigned int VAR_24 = VAR_15 - VAR_8;
			unsigned short VAR_25 = bio->bi_vcnt;

			if (VAR_13 <= 0)
				break;
			
			if (VAR_24 > VAR_13)
				VAR_24 = VAR_13;

			/* COMMENT_6 */
              
      
			if (bio_add_pc_page(VAR_0, bio, VAR_5[VAR_3], VAR_24, VAR_8) <
					    VAR_24)
				break;

			/* COMMENT_9 */
                                              
                                   
      
			if (bio->bi_vcnt == VAR_25)
				put_page(VAR_5[VAR_3]);

			VAR_13 -= VAR_24;
			VAR_8 = 0;
		}

		VAR_6 = VAR_3;
		/* COMMENT_13 */
                                                         
     
		while (VAR_3 < VAR_21)
			put_page(VAR_5[VAR_3++]);
	}

	kfree(VAR_5);

	bio_set_flag(bio, VAR_26);

	/* COMMENT_16 */
                                                            
                                                          
                                                       
                   
    
	bio_get(bio);
	return bio;

 out_unmap:
	bio_for_each_segment_all(VAR_11, bio, VAR_3) {
		put_page(VAR_11->bv_page);
	}
 out:
	kfree(VAR_5);
	bio_put(bio);
	return ERR_PTR(VAR_7);
}",torvalds/linux/2b04e8f6bbb196cab4b232af0f8d48ff2c7a8058/bio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,7 @@
 	int ret, offset;
 	struct iov_iter i;
 	struct iovec iov;
+	struct bio_vec *bvec;
 
 	iov_for_each(iov, i, *iter) {
 		unsigned long uaddr = (unsigned long) iov.iov_base;
@@ -54,7 +55,12 @@
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				(iter->type & WRITE) != WRITE,
 				&pages[cur_page]);
-		if (ret < local_nr_pages) {
+		if (unlikely(ret < local_nr_pages)) {
+			for (j = cur_page; j < page_limit; j++) {
+				if (!pages[j])
+					break;
+				put_page(pages[j]);
+			}
 			ret = -EFAULT;
 			goto out_unmap;
 		}
@@ -110,10 +116,8 @@
 	return bio;
 
  out_unmap:
-	for (j = 0; j < nr_pages; j++) {
-		if (!pages[j])
-			break;
-		put_page(pages[j]);
+	bio_for_each_segment_all(bvec, bio, j) {
+		put_page(bvec->bv_page);
 	}
  out:
 	kfree(pages);","{'deleted_lines': ['\t\tif (ret < local_nr_pages) {', '\tfor (j = 0; j < nr_pages; j++) {', '\t\tif (!pages[j])', '\t\t\tbreak;', '\t\tput_page(pages[j]);'], 'added_lines': ['\tstruct bio_vec *bvec;', '\t\tif (unlikely(ret < local_nr_pages)) {', '\t\t\tfor (j = cur_page; j < page_limit; j++) {', '\t\t\t\tif (!pages[j])', '\t\t\t\t\tbreak;', '\t\t\t\tput_page(pages[j]);', '\t\t\t}', '\tbio_for_each_segment_all(bvec, bio, j) {', '\t\tput_page(bvec->bv_page);']}",True,"The bio_map_user_iov and bio_unmap_user functions in block/bio.c in the Linux kernel before 4.13.8 do unbalanced refcounting when a SCSI I/O vector has small consecutive buffers belonging to the same page. The bio_add_pc_page function merges them into one, but the page reference is never dropped. This causes a memory leak and possible system lockup (exploitable against the host OS by a guest OS user, if a SCSI disk is passed through to a virtual machine) due to an out-of-memory condition.",6.5,MEDIUM,1,test,2017-09-23T19:51:23Z,2
CVE-2017-1000450,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,opencv,Fix out of bounds write,c58152d94ba878b2d7d76bcac59146312199b9eb,https://github.com/opencv/opencv/commit/c58152d94ba878b2d7d76bcac59146312199b9eb,modules/imgcodecs/src/grfmt_bmp.cpp,BmpDecoder::readData,"bool  BmpDecoder::readData( Mat& img )
{
uchar* data = img.ptr();
int step = validateToInt(img.step);
bool color = img.channels() > 1;
uchar  gray_palette[256] = {0};
bool   result = false;
int  src_pitch = ((m_width*(m_bpp != 15 ? m_bpp : 16) + 7)/8 + 3) & -4;
int  nch = color ? 3 : 1;
int  y, width3 = m_width*nch;
if( m_offset < 0 || !m_strm.isOpened())
return false;
if( m_origin == IPL_ORIGIN_BL )
{
data += (m_height - 1)*(size_t)step;
step = -step;
}
AutoBuffer<uchar> _src, _bgr;
_src.allocate(src_pitch + 32);
if( !color )
{
if( m_bpp <= 8 )
{
CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );
}
_bgr.allocate(m_width*3 + 32);
}
uchar *src = _src, *bgr = _bgr;
try
{
m_strm.setPos( m_offset );
switch( m_bpp )
{
case 1:
for( y = 0; y < m_height; y++, data += step )
{
m_strm.getBytes( src, src_pitch );
FillColorRow1( color ? data : bgr, src, m_width, m_palette );
if( !color )
icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1) );
}
result = true;
break;
case 4:
if( m_rle_code == BMP_RGB )
{
for( y = 0; y < m_height; y++, data += step )
{
m_strm.getBytes( src, src_pitch );
if( color )
FillColorRow4( data, src, m_width, m_palette );
else
FillGrayRow4( data, src, m_width, gray_palette );
}
result = true;
}
else if( m_rle_code == BMP_RLE4 )             {
uchar* line_end = data + width3;
y = 0;
for(;;)
{
int code = m_strm.getWord();
int len = code & 255;
code >>= 8;
if( len != 0 )                     {
PaletteEntry clr[2];
uchar gray_clr[2];
int t = 0;
clr[0] = m_palette[code >> 4];
clr[1] = m_palette[code & 15];
gray_clr[0] = gray_palette[code >> 4];
gray_clr[1] = gray_palette[code & 15];
uchar* end = data + len*nch;
if( end > line_end ) goto decode_rle4_bad;
do
{
if( color )
WRITE_PIX( data, clr[t] );
else
*data = gray_clr[t];
t ^= 1;
}
while( (data += nch) < end );
}
else if( code > 2 )                     {
if( data + code*nch > line_end ) goto decode_rle4_bad;
int sz = (((code + 1)>>1) + 1) & (~1);
CV_Assert((size_t)sz < _src.size());
m_strm.getBytes(src, sz);
if( color )
data = FillColorRow4( data, src, code, m_palette );
else
data = FillGrayRow4( data, src, code, gray_palette );
}
else
{
int x_shift3 = (int)(line_end - data);
int y_shift = m_height - y;
if( code == 2 )
{
x_shift3 = m_strm.getByte()*nch;
y_shift = m_strm.getByte();
}
len = x_shift3 + ((y_shift * width3) & ((code == 0) - 1));
if( color )
data = FillUniColor( data, line_end, step, width3,
y, m_height, x_shift3,
m_palette[0] );
else
data = FillUniGray( data, line_end, step, width3,
y, m_height, x_shift3,
gray_palette[0] );
if( y >= m_height )
break;
}
}
result = true;
decode_rle4_bad: ;
}
break;
case 8:
if( m_rle_code == BMP_RGB )
{
for( y = 0; y < m_height; y++, data += step )
{
m_strm.getBytes( src, src_pitch );
if( color )
FillColorRow8( data, src, m_width, m_palette );
else
FillGrayRow8( data, src, m_width, gray_palette );
}
result = true;
}
else if( m_rle_code == BMP_RLE8 )             {
uchar* line_end = data + width3;
int line_end_flag = 0;
y = 0;
for(;;)
{
int code = m_strm.getWord();
int len = code & 255;
code >>= 8;
if( len != 0 )                     {
int prev_y = y;
len *= nch;
if( data + len > line_end )
goto decode_rle8_bad;
if( color )
data = FillUniColor( data, line_end, step, width3,
y, m_height, len,
m_palette[code] );
else
data = FillUniGray( data, line_end, step, width3,
y, m_height, len,
gray_palette[code] );
line_end_flag = y - prev_y;
}
else if( code > 2 )                     {
int prev_y = y;
int code3 = code*nch;
if( data + code3 > line_end )
goto decode_rle8_bad;
int sz = (code + 1) & (~1);
CV_Assert((size_t)sz < _src.size());
m_strm.getBytes(src, sz);
if( color )
data = FillColorRow8( data, src, code, m_palette );
else
data = FillGrayRow8( data, src, code, gray_palette );
line_end_flag = y - prev_y;
}
else
{
int x_shift3 = (int)(line_end - data);
int y_shift = m_height - y;
if( code || !line_end_flag || x_shift3 < width3 )
{
if( code == 2 )
{
x_shift3 = m_strm.getByte()*nch;
y_shift = m_strm.getByte();
}
x_shift3 += (y_shift * width3) & ((code == 0) - 1);
if( y >= m_height )
break;
if( color )
data = FillUniColor( data, line_end, step, width3,
y, m_height, x_shift3,
m_palette[0] );
else
data = FillUniGray( data, line_end, step, width3,
y, m_height, x_shift3,
gray_palette[0] );
if( y >= m_height )
break;
}
line_end_flag = 0;
if( y >= m_height )
break;
}
}
result = true;
decode_rle8_bad: ;
}
break;
case 15:
for( y = 0; y < m_height; y++, data += step )
{
m_strm.getBytes( src, src_pitch );
if( !color )
icvCvt_BGR5552Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );
else
icvCvt_BGR5552BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );
}
result = true;
break;
case 16:
for( y = 0; y < m_height; y++, data += step )
{
m_strm.getBytes( src, src_pitch );
if( !color )
icvCvt_BGR5652Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );
else
icvCvt_BGR5652BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );
}
result = true;
break;
case 24:
for( y = 0; y < m_height; y++, data += step )
{
m_strm.getBytes( src, src_pitch );
if(!color)
icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1) );
else
memcpy( data, src, m_width*3 );
}
result = true;
break;
case 32:
for( y = 0; y < m_height; y++, data += step )
{
m_strm.getBytes( src, src_pitch );
if( !color )
icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1) );
else
icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1) );
}
result = true;
break;
default:
CV_ErrorNoReturn(cv::Error::StsError, ""Invalid/unsupported mode"");
}
}
catch(...)
{
throw;
}
return result;
}","bool  BmpDecoder::readData( Mat& VAR_0 )
{
uchar* VAR_1 = VAR_0.ptr();
int VAR_2 = validateToInt(VAR_0.step);
bool VAR_3 = VAR_0.channels() > 1;
uchar  VAR_4[256] = {0};
bool   VAR_5 = false;
int  VAR_6 = ((VAR_7*(VAR_8 != 15 ? VAR_8 : 16) + 7)/8 + 3) & -4;
int  VAR_9 = VAR_3 ? 3 : 1;
int  VAR_10, VAR_11 = VAR_7*VAR_9;
if( VAR_12 < 0 || !VAR_13.isOpened())
return false;
if( VAR_14 == VAR_15 )
{
VAR_1 += (VAR_16 - 1)*(size_t)VAR_2;
VAR_2 = -VAR_2;
}
AutoBuffer<uchar> VAR_17, VAR_18;
VAR_17.allocate(VAR_6 + 32);
if( !VAR_3 )
{
if( VAR_8 <= 8 )
{
CvtPaletteToGray( VAR_19, VAR_4, 1 << VAR_8 );
}
VAR_18.allocate(VAR_7*3 + 32);
}
uchar *VAR_20 = VAR_17, *VAR_21 = VAR_18;
try
{
VAR_13.setPos( VAR_12 );
switch( VAR_8 )
{
case 1:
for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
{
VAR_13.getBytes( VAR_20, VAR_6 );
FillColorRow1( VAR_3 ? VAR_1 : VAR_21, VAR_20, VAR_7, VAR_19 );
if( !VAR_3 )
icvCvt_BGR2Gray_8u_C3C1R( VAR_21, 0, VAR_1, 0, cvSize(VAR_7,1) );
}
VAR_5 = true;
break;
case 4:
if( VAR_22 == VAR_23 )
{
for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
{
VAR_13.getBytes( VAR_20, VAR_6 );
if( VAR_3 )
FillColorRow4( VAR_1, VAR_20, VAR_7, VAR_19 );
else
FillGrayRow4( VAR_1, VAR_20, VAR_7, VAR_4 );
}
VAR_5 = true;
}
else if( VAR_22 == VAR_24 ) 
{
uchar* VAR_25 = VAR_1 + VAR_11;
VAR_10 = 0;
for(;;)
{
int VAR_26 = VAR_13.getWord();
int VAR_27 = VAR_26 & 255;
VAR_26 >>= 8;
if( VAR_27 != 0 ) 
{
PaletteEntry VAR_28[2];
uchar VAR_29[2];
int VAR_30 = 0;
VAR_28[0] = VAR_19[VAR_26 >> 4];
VAR_28[1] = VAR_19[VAR_26 & 15];
VAR_29[0] = VAR_4[VAR_26 >> 4];
VAR_29[1] = VAR_4[VAR_26 & 15];
uchar* VAR_31 = VAR_1 + VAR_27*VAR_9;
if( VAR_31 > VAR_25 ) goto decode_rle4_bad;
do
{
if( VAR_3 )
WRITE_PIX( VAR_1, VAR_28[VAR_30] );
else
*VAR_1 = VAR_29[VAR_30];
VAR_30 ^= 1;
}
while( (VAR_1 += VAR_9) < VAR_31 );
}
else if( VAR_26 > 2 ) 
{
if( VAR_1 + VAR_26*VAR_9 > VAR_25 ) goto decode_rle4_bad;
int VAR_32 = (((VAR_26 + 1)>>1) + 1) & (~1);
CV_Assert((size_t)VAR_32 < VAR_17.size());
VAR_13.getBytes(VAR_20, VAR_32);
if( VAR_3 )
VAR_1 = FillColorRow4( VAR_1, VAR_20, VAR_26, VAR_19 );
else
VAR_1 = FillGrayRow4( VAR_1, VAR_20, VAR_26, VAR_4 );
}
else
{
int VAR_33 = (int)(VAR_25 - VAR_1);
int VAR_34 = VAR_16 - VAR_10;
if( VAR_26 == 2 )
{
VAR_33 = VAR_13.getByte()*VAR_9;
VAR_34 = VAR_13.getByte();
}
VAR_27 = VAR_33 + ((VAR_34 * VAR_11) & ((VAR_26 == 0) - 1));
if( VAR_3 )
VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,
VAR_10, VAR_16, VAR_33,
VAR_19[0] );
else
VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,
VAR_10, VAR_16, VAR_33,
VAR_4[0] );
if( VAR_10 >= VAR_16 )
break;
}
}
VAR_5 = true;
decode_rle4_bad: ;
}
break;
case 8:
if( VAR_22 == VAR_23 )
{
for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
{
VAR_13.getBytes( VAR_20, VAR_6 );
if( VAR_3 )
FillColorRow8( VAR_1, VAR_20, VAR_7, VAR_19 );
else
FillGrayRow8( VAR_1, VAR_20, VAR_7, VAR_4 );
}
VAR_5 = true;
}
else if( VAR_22 == VAR_35 ) 
{
uchar* VAR_25 = VAR_1 + VAR_11;
int VAR_36 = 0;
VAR_10 = 0;
for(;;)
{
int VAR_26 = VAR_13.getWord();
int VAR_27 = VAR_26 & 255;
VAR_26 >>= 8;
if( VAR_27 != 0 ) 
{
int VAR_37 = VAR_10;
VAR_27 *= VAR_9;
if( VAR_1 + VAR_27 > VAR_25 )
goto decode_rle8_bad;
if( VAR_3 )
VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,
VAR_10, VAR_16, VAR_27,
VAR_19[VAR_26] );
else
VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,
VAR_10, VAR_16, VAR_27,
VAR_4[VAR_26] );
VAR_36 = VAR_10 - VAR_37;
}
else if( VAR_26 > 2 ) 
{
int VAR_37 = VAR_10;
int VAR_38 = VAR_26*VAR_9;
if( VAR_1 + VAR_38 > VAR_25 )
goto decode_rle8_bad;
int VAR_32 = (VAR_26 + 1) & (~1);
CV_Assert((size_t)VAR_32 < VAR_17.size());
VAR_13.getBytes(VAR_20, VAR_32);
if( VAR_3 )
VAR_1 = FillColorRow8( VAR_1, VAR_20, VAR_26, VAR_19 );
else
VAR_1 = FillGrayRow8( VAR_1, VAR_20, VAR_26, VAR_4 );
VAR_36 = VAR_10 - VAR_37;
}
else
{
int VAR_33 = (int)(VAR_25 - VAR_1);
int VAR_34 = VAR_16 - VAR_10;
if( VAR_26 || !VAR_36 || VAR_33 < VAR_11 )
{
if( VAR_26 == 2 )
{
VAR_33 = VAR_13.getByte()*VAR_9;
VAR_34 = VAR_13.getByte();
}
VAR_33 += (VAR_34 * VAR_11) & ((VAR_26 == 0) - 1);
if( VAR_10 >= VAR_16 )
break;
if( VAR_3 )
VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,
VAR_10, VAR_16, VAR_33,
VAR_19[0] );
else
VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,
VAR_10, VAR_16, VAR_33,
VAR_4[0] );
if( VAR_10 >= VAR_16 )
break;
}
VAR_36 = 0;
if( VAR_10 >= VAR_16 )
break;
}
}
VAR_5 = true;
decode_rle8_bad: ;
}
break;
case 15:
for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
{
VAR_13.getBytes( VAR_20, VAR_6 );
if( !VAR_3 )
icvCvt_BGR5552Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
else
icvCvt_BGR5552BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
}
VAR_5 = true;
break;
case 16:
for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
{
VAR_13.getBytes( VAR_20, VAR_6 );
if( !VAR_3 )
icvCvt_BGR5652Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
else
icvCvt_BGR5652BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
}
VAR_5 = true;
break;
case 24:
for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
{
VAR_13.getBytes( VAR_20, VAR_6 );
if(!VAR_3)
icvCvt_BGR2Gray_8u_C3C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
else
memcpy( VAR_1, VAR_20, VAR_7*3 );
}
VAR_5 = true;
break;
case 32:
for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
{
VAR_13.getBytes( VAR_20, VAR_6 );
if( !VAR_3 )
icvCvt_BGRA2Gray_8u_C4C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
else
icvCvt_BGRA2BGR_8u_C4C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
}
VAR_5 = true;
break;
default:
CV_ErrorNoReturn(cv::Error::StsError, ""Invalid/unsupported mode"");
}
}
catch(...)
{
throw;
}
return VAR_5;
}",,"bool  BmpDecoder::readData( Mat& img )
{
    uchar* data = img.ptr();
    int step = validateToInt(img.step);
    bool color = img.channels() > 1;
    uchar  gray_palette[256] = {0};
    bool   result = false;
    int  src_pitch = ((m_width*(m_bpp != 15 ? m_bpp : 16) + 7)/8 + 3) & -4;
    int  nch = color ? 3 : 1;
    int  y, width3 = m_width*nch;

    if( m_offset < 0 || !m_strm.isOpened())
        return false;

    if( m_origin == IPL_ORIGIN_BL )
    {
        data += (m_height - 1)*(size_t)step;
        step = -step;
    }

    AutoBuffer<uchar> _src, _bgr;
    _src.allocate(src_pitch + 32);

    if( !color )
    {
        if( m_bpp <= 8 )
        {
            CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp );
        }
        _bgr.allocate(m_width*3 + 32);
    }
    uchar *src = _src, *bgr = _bgr;

    try
    {
        m_strm.setPos( m_offset );

        switch( m_bpp )
        {
        /************************* 1 BPP ************************/
        case 1:
            for( y = 0; y < m_height; y++, data += step )
            {
                m_strm.getBytes( src, src_pitch );
                FillColorRow1( color ? data : bgr, src, m_width, m_palette );
                if( !color )
                    icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1) );
            }
            result = true;
            break;

        /************************* 4 BPP ************************/
        case 4:
            if( m_rle_code == BMP_RGB )
            {
                for( y = 0; y < m_height; y++, data += step )
                {
                    m_strm.getBytes( src, src_pitch );
                    if( color )
                        FillColorRow4( data, src, m_width, m_palette );
                    else
                        FillGrayRow4( data, src, m_width, gray_palette );
                }
                result = true;
            }
            else if( m_rle_code == BMP_RLE4 ) // rle4 compression
            {
                uchar* line_end = data + width3;
                y = 0;

                for(;;)
                {
                    int code = m_strm.getWord();
                    int len = code & 255;
                    code >>= 8;
                    if( len != 0 ) // encoded mode
                    {
                        PaletteEntry clr[2];
                        uchar gray_clr[2];
                        int t = 0;

                        clr[0] = m_palette[code >> 4];
                        clr[1] = m_palette[code & 15];
                        gray_clr[0] = gray_palette[code >> 4];
                        gray_clr[1] = gray_palette[code & 15];

                        uchar* end = data + len*nch;
                        if( end > line_end ) goto decode_rle4_bad;
                        do
                        {
                            if( color )
                                WRITE_PIX( data, clr[t] );
                            else
                                *data = gray_clr[t];
                            t ^= 1;
                        }
                        while( (data += nch) < end );
                    }
                    else if( code > 2 ) // absolute mode
                    {
                        if( data + code*nch > line_end ) goto decode_rle4_bad;
                        int sz = (((code + 1)>>1) + 1) & (~1);
                        CV_Assert((size_t)sz < _src.size());
                        m_strm.getBytes(src, sz);
                        if( color )
                            data = FillColorRow4( data, src, code, m_palette );
                        else
                            data = FillGrayRow4( data, src, code, gray_palette );
                    }
                    else
                    {
                        int x_shift3 = (int)(line_end - data);
                        int y_shift = m_height - y;

                        if( code == 2 )
                        {
                            x_shift3 = m_strm.getByte()*nch;
                            y_shift = m_strm.getByte();
                        }

                        len = x_shift3 + ((y_shift * width3) & ((code == 0) - 1));

                        if( color )
                            data = FillUniColor( data, line_end, step, width3,
                                                 y, m_height, x_shift3,
                                                 m_palette[0] );
                        else
                            data = FillUniGray( data, line_end, step, width3,
                                                y, m_height, x_shift3,
                                                gray_palette[0] );

                        if( y >= m_height )
                            break;
                    }
                }

                result = true;
decode_rle4_bad: ;
            }
            break;

        /************************* 8 BPP ************************/
        case 8:
            if( m_rle_code == BMP_RGB )
            {
                for( y = 0; y < m_height; y++, data += step )
                {
                    m_strm.getBytes( src, src_pitch );
                    if( color )
                        FillColorRow8( data, src, m_width, m_palette );
                    else
                        FillGrayRow8( data, src, m_width, gray_palette );
                }
                result = true;
            }
            else if( m_rle_code == BMP_RLE8 ) // rle8 compression
            {
                uchar* line_end = data + width3;
                int line_end_flag = 0;
                y = 0;

                for(;;)
                {
                    int code = m_strm.getWord();
                    int len = code & 255;
                    code >>= 8;
                    if( len != 0 ) // encoded mode
                    {
                        int prev_y = y;
                        len *= nch;

                        if( data + len > line_end )
                            goto decode_rle8_bad;

                        if( color )
                            data = FillUniColor( data, line_end, step, width3,
                                                 y, m_height, len,
                                                 m_palette[code] );
                        else
                            data = FillUniGray( data, line_end, step, width3,
                                                y, m_height, len,
                                                gray_palette[code] );

                        line_end_flag = y - prev_y;

                        if( y >= m_height )
                            break;
                    }
                    else if( code > 2 ) // absolute mode
                    {
                        int prev_y = y;
                        int code3 = code*nch;

                        if( data + code3 > line_end )
                            goto decode_rle8_bad;
                        int sz = (code + 1) & (~1);
                        CV_Assert((size_t)sz < _src.size());
                        m_strm.getBytes(src, sz);
                        if( color )
                            data = FillColorRow8( data, src, code, m_palette );
                        else
                            data = FillGrayRow8( data, src, code, gray_palette );

                        line_end_flag = y - prev_y;
                    }
                    else
                    {
                        int x_shift3 = (int)(line_end - data);
                        int y_shift = m_height - y;

                        if( code || !line_end_flag || x_shift3 < width3 )
                        {
                            if( code == 2 )
                            {
                                x_shift3 = m_strm.getByte()*nch;
                                y_shift = m_strm.getByte();
                            }

                            x_shift3 += (y_shift * width3) & ((code == 0) - 1);

                            if( y >= m_height )
                                break;

                            if( color )
                                data = FillUniColor( data, line_end, step, width3,
                                                     y, m_height, x_shift3,
                                                     m_palette[0] );
                            else
                                data = FillUniGray( data, line_end, step, width3,
                                                    y, m_height, x_shift3,
                                                    gray_palette[0] );

                            if( y >= m_height )
                                break;
                        }

                        line_end_flag = 0;
                        if( y >= m_height )
                            break;
                    }
                }

                result = true;
decode_rle8_bad: ;
            }
            break;
        /************************* 15 BPP ************************/
        case 15:
            for( y = 0; y < m_height; y++, data += step )
            {
                m_strm.getBytes( src, src_pitch );
                if( !color )
                    icvCvt_BGR5552Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );
                else
                    icvCvt_BGR5552BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );
            }
            result = true;
            break;
        /************************* 16 BPP ************************/
        case 16:
            for( y = 0; y < m_height; y++, data += step )
            {
                m_strm.getBytes( src, src_pitch );
                if( !color )
                    icvCvt_BGR5652Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) );
                else
                    icvCvt_BGR5652BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) );
            }
            result = true;
            break;
        /************************* 24 BPP ************************/
        case 24:
            for( y = 0; y < m_height; y++, data += step )
            {
                m_strm.getBytes( src, src_pitch );
                if(!color)
                    icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1) );
                else
                    memcpy( data, src, m_width*3 );
            }
            result = true;
            break;
        /************************* 32 BPP ************************/
        case 32:
            for( y = 0; y < m_height; y++, data += step )
            {
                m_strm.getBytes( src, src_pitch );

                if( !color )
                    icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1) );
                else
                    icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1) );
            }
            result = true;
            break;
        default:
            CV_ErrorNoReturn(cv::Error::StsError, ""Invalid/unsupported mode"");
        }
    }
    catch(...)
    {
        throw;
    }

    return result;
}","bool  BmpDecoder::readData( Mat& VAR_0 )
{
    uchar* VAR_1 = VAR_0.ptr();
    int VAR_2 = validateToInt(VAR_0.step);
    bool VAR_3 = VAR_0.channels() > 1;
    uchar  VAR_4[256] = {0};
    bool   VAR_5 = false;
    int  VAR_6 = ((VAR_7*(VAR_8 != 15 ? VAR_8 : 16) + 7)/8 + 3) & -4;
    int  VAR_9 = VAR_3 ? 3 : 1;
    int  VAR_10, VAR_11 = VAR_7*VAR_9;

    if( VAR_12 < 0 || !VAR_13.isOpened())
        return false;

    if( VAR_14 == VAR_15 )
    {
        VAR_1 += (VAR_16 - 1)*(size_t)VAR_2;
        VAR_2 = -VAR_2;
    }

    AutoBuffer<uchar> VAR_17, VAR_18;
    VAR_17.allocate(VAR_6 + 32);

    if( !VAR_3 )
    {
        if( VAR_8 <= 8 )
        {
            CvtPaletteToGray( VAR_19, VAR_4, 1 << VAR_8 );
        }
        VAR_18.allocate(VAR_7*3 + 32);
    }
    uchar *VAR_20 = VAR_17, *VAR_21 = VAR_18;

    try
    {
        VAR_13.setPos( VAR_12 );

        switch( VAR_8 )
        {
        /* COMMENT_0 */
        case 1:
            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
            {
                VAR_13.getBytes( VAR_20, VAR_6 );
                FillColorRow1( VAR_3 ? VAR_1 : VAR_21, VAR_20, VAR_7, VAR_19 );
                if( !VAR_3 )
                    icvCvt_BGR2Gray_8u_C3C1R( VAR_21, 0, VAR_1, 0, cvSize(VAR_7,1) );
            }
            VAR_5 = true;
            break;

        /* COMMENT_1 */
        case 4:
            if( VAR_22 == VAR_23 )
            {
                for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
                {
                    VAR_13.getBytes( VAR_20, VAR_6 );
                    if( VAR_3 )
                        FillColorRow4( VAR_1, VAR_20, VAR_7, VAR_19 );
                    else
                        FillGrayRow4( VAR_1, VAR_20, VAR_7, VAR_4 );
                }
                VAR_5 = true;
            }
            else if( VAR_22 == VAR_24 ) /* COMMENT_2 */
            {
                uchar* VAR_25 = VAR_1 + VAR_11;
                VAR_10 = 0;

                for(;;)
                {
                    int VAR_26 = VAR_13.getWord();
                    int VAR_27 = VAR_26 & 255;
                    VAR_26 >>= 8;
                    if( VAR_27 != 0 ) /* COMMENT_3 */
                    {
                        PaletteEntry VAR_28[2];
                        uchar VAR_29[2];
                        int VAR_30 = 0;

                        VAR_28[0] = VAR_19[VAR_26 >> 4];
                        VAR_28[1] = VAR_19[VAR_26 & 15];
                        VAR_29[0] = VAR_4[VAR_26 >> 4];
                        VAR_29[1] = VAR_4[VAR_26 & 15];

                        uchar* VAR_31 = VAR_1 + VAR_27*VAR_9;
                        if( VAR_31 > VAR_25 ) goto decode_rle4_bad;
                        do
                        {
                            if( VAR_3 )
                                WRITE_PIX( VAR_1, VAR_28[VAR_30] );
                            else
                                *VAR_1 = VAR_29[VAR_30];
                            VAR_30 ^= 1;
                        }
                        while( (VAR_1 += VAR_9) < VAR_31 );
                    }
                    else if( VAR_26 > 2 ) /* COMMENT_4 */
                    {
                        if( VAR_1 + VAR_26*VAR_9 > VAR_25 ) goto decode_rle4_bad;
                        int VAR_32 = (((VAR_26 + 1)>>1) + 1) & (~1);
                        CV_Assert((size_t)VAR_32 < VAR_17.size());
                        VAR_13.getBytes(VAR_20, VAR_32);
                        if( VAR_3 )
                            VAR_1 = FillColorRow4( VAR_1, VAR_20, VAR_26, VAR_19 );
                        else
                            VAR_1 = FillGrayRow4( VAR_1, VAR_20, VAR_26, VAR_4 );
                    }
                    else
                    {
                        int VAR_33 = (int)(VAR_25 - VAR_1);
                        int VAR_34 = VAR_16 - VAR_10;

                        if( VAR_26 == 2 )
                        {
                            VAR_33 = VAR_13.getByte()*VAR_9;
                            VAR_34 = VAR_13.getByte();
                        }

                        VAR_27 = VAR_33 + ((VAR_34 * VAR_11) & ((VAR_26 == 0) - 1));

                        if( VAR_3 )
                            VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,
                                                 VAR_10, VAR_16, VAR_33,
                                                 VAR_19[0] );
                        else
                            VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,
                                                VAR_10, VAR_16, VAR_33,
                                                VAR_4[0] );

                        if( VAR_10 >= VAR_16 )
                            break;
                    }
                }

                VAR_5 = true;
decode_rle4_bad: ;
            }
            break;

        /* COMMENT_5 */
        case 8:
            if( VAR_22 == VAR_23 )
            {
                for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
                {
                    VAR_13.getBytes( VAR_20, VAR_6 );
                    if( VAR_3 )
                        FillColorRow8( VAR_1, VAR_20, VAR_7, VAR_19 );
                    else
                        FillGrayRow8( VAR_1, VAR_20, VAR_7, VAR_4 );
                }
                VAR_5 = true;
            }
            else if( VAR_22 == VAR_35 ) /* COMMENT_6 */
            {
                uchar* VAR_25 = VAR_1 + VAR_11;
                int VAR_36 = 0;
                VAR_10 = 0;

                for(;;)
                {
                    int VAR_26 = VAR_13.getWord();
                    int VAR_27 = VAR_26 & 255;
                    VAR_26 >>= 8;
                    if( VAR_27 != 0 ) /* COMMENT_3 */
                    {
                        int VAR_37 = VAR_10;
                        VAR_27 *= VAR_9;

                        if( VAR_1 + VAR_27 > VAR_25 )
                            goto decode_rle8_bad;

                        if( VAR_3 )
                            VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,
                                                 VAR_10, VAR_16, VAR_27,
                                                 VAR_19[VAR_26] );
                        else
                            VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,
                                                VAR_10, VAR_16, VAR_27,
                                                VAR_4[VAR_26] );

                        VAR_36 = VAR_10 - VAR_37;

                        if( VAR_10 >= VAR_16 )
                            break;
                    }
                    else if( VAR_26 > 2 ) /* COMMENT_4 */
                    {
                        int VAR_37 = VAR_10;
                        int VAR_38 = VAR_26*VAR_9;

                        if( VAR_1 + VAR_38 > VAR_25 )
                            goto decode_rle8_bad;
                        int VAR_32 = (VAR_26 + 1) & (~1);
                        CV_Assert((size_t)VAR_32 < VAR_17.size());
                        VAR_13.getBytes(VAR_20, VAR_32);
                        if( VAR_3 )
                            VAR_1 = FillColorRow8( VAR_1, VAR_20, VAR_26, VAR_19 );
                        else
                            VAR_1 = FillGrayRow8( VAR_1, VAR_20, VAR_26, VAR_4 );

                        VAR_36 = VAR_10 - VAR_37;
                    }
                    else
                    {
                        int VAR_33 = (int)(VAR_25 - VAR_1);
                        int VAR_34 = VAR_16 - VAR_10;

                        if( VAR_26 || !VAR_36 || VAR_33 < VAR_11 )
                        {
                            if( VAR_26 == 2 )
                            {
                                VAR_33 = VAR_13.getByte()*VAR_9;
                                VAR_34 = VAR_13.getByte();
                            }

                            VAR_33 += (VAR_34 * VAR_11) & ((VAR_26 == 0) - 1);

                            if( VAR_10 >= VAR_16 )
                                break;

                            if( VAR_3 )
                                VAR_1 = FillUniColor( VAR_1, VAR_25, VAR_2, VAR_11,
                                                     VAR_10, VAR_16, VAR_33,
                                                     VAR_19[0] );
                            else
                                VAR_1 = FillUniGray( VAR_1, VAR_25, VAR_2, VAR_11,
                                                    VAR_10, VAR_16, VAR_33,
                                                    VAR_4[0] );

                            if( VAR_10 >= VAR_16 )
                                break;
                        }

                        VAR_36 = 0;
                        if( VAR_10 >= VAR_16 )
                            break;
                    }
                }

                VAR_5 = true;
decode_rle8_bad: ;
            }
            break;
        /* COMMENT_7 */
        case 15:
            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
            {
                VAR_13.getBytes( VAR_20, VAR_6 );
                if( !VAR_3 )
                    icvCvt_BGR5552Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
                else
                    icvCvt_BGR5552BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
            }
            VAR_5 = true;
            break;
        /* COMMENT_8 */
        case 16:
            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
            {
                VAR_13.getBytes( VAR_20, VAR_6 );
                if( !VAR_3 )
                    icvCvt_BGR5652Gray_8u_C2C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
                else
                    icvCvt_BGR5652BGR_8u_C2C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
            }
            VAR_5 = true;
            break;
        /* COMMENT_9 */
        case 24:
            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
            {
                VAR_13.getBytes( VAR_20, VAR_6 );
                if(!VAR_3)
                    icvCvt_BGR2Gray_8u_C3C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
                else
                    memcpy( VAR_1, VAR_20, VAR_7*3 );
            }
            VAR_5 = true;
            break;
        /* COMMENT_10 */
        case 32:
            for( VAR_10 = 0; VAR_10 < VAR_16; VAR_10++, VAR_1 += VAR_2 )
            {
                VAR_13.getBytes( VAR_20, VAR_6 );

                if( !VAR_3 )
                    icvCvt_BGRA2Gray_8u_C4C1R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
                else
                    icvCvt_BGRA2BGR_8u_C4C3R( VAR_20, 0, VAR_1, 0, cvSize(VAR_7,1) );
            }
            VAR_5 = true;
            break;
        default:
            CV_ErrorNoReturn(cv::Error::StsError, ""Invalid/unsupported mode"");
        }
    }
    catch(...)
    {
        throw;
    }

    return VAR_5;
}",,"--- func_before
+++ func_after
@@ -182,6 +182,9 @@
                                                 gray_palette[code] );
 
                         line_end_flag = y - prev_y;
+
+                        if( y >= m_height )
+                            break;
                     }
                     else if( code > 2 ) // absolute mode
                     {","{'deleted_lines': [], 'added_lines': ['', '                        if( y >= m_height )', '                            break;']}",True,"In opencv/modules/imgcodecs/src/utils.cpp, functions FillUniColor and FillUniGray do not check the input length, which can lead to integer overflow. If the image is from remote, may lead to remote code execution or denial of service. This affects Opencv 3.3 and earlier.",8.8,HIGH,2,test,2017-09-27T06:04:01Z,2
CVE-2017-12678,['CWE-434'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,taglib,"Don't assume TDRC is an instance of TextIdentificationFrame (#831)

If TDRC is encrypted, FrameFactory::createFrame() returns UnknownFrame
which causes problems in rebuildAggregateFrames() when it is assumed
that TDRC is a TextIdentificationFrame",cb9f07d9dcd791b63e622da43f7b232adaec0a9a,https://github.com/taglib/taglib/commit/cb9f07d9dcd791b63e622da43f7b232adaec0a9a,taglib/mpeg/id3v2/id3v2framefactory.cpp,FrameFactory::rebuildAggregateFrames,"void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const
{
if(tag->header()->majorVersion() < 4 &&
tag->frameList(""TDRC"").size() == 1 &&
tag->frameList(""TDAT"").size() == 1)
{
TextIdentificationFrame *tdrc =
static_cast<TextIdentificationFrame *>(tag->frameList(""TDRC"").front());
UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(""TDAT"").front());
if(tdrc->fieldList().size() == 1 &&
tdrc->fieldList().front().size() == 4 &&
tdat->data().size() >= 5)
{
String date(tdat->data().mid(1), String::Type(tdat->data()[0]));
if(date.length() == 4) {
tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));
if(tag->frameList(""TIME"").size() == 1) {
UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(""TIME"").front());
if(timeframe->data().size() >= 5) {
String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));
if(time.length() == 4) {
tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));
}
}
}
}
}
}
}","void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *VAR_0) const
{
if(VAR_0->header()->majorVersion() < 4 &&
VAR_0->frameList(""TDRC"").size() == 1 &&
VAR_0->frameList(""TDAT"").size() == 1)
{
TextIdentificationFrame *VAR_1 =
VAR_2<TextIdentificationFrame *>(VAR_0->frameList(""TDRC"").front());
UnknownFrame *VAR_3 = VAR_2<UnknownFrame *>(VAR_0->frameList(""TDAT"").front());
if(VAR_1->fieldList().size() == 1 &&
VAR_1->fieldList().front().size() == 4 &&
VAR_3->data().size() >= 5)
{
String VAR_4(VAR_3->data().mid(1), String::Type(VAR_3->data()[0]));
if(VAR_4.length() == 4) {
VAR_1->setText(VAR_1->toString() + '-' + VAR_4.substr(2, 2) + '-' + VAR_4.substr(0, 2));
if(VAR_0->frameList(""TIME"").size() == 1) {
UnknownFrame *VAR_5 = VAR_2<UnknownFrame *>(VAR_0->frameList(""TIME"").front());
if(VAR_5->data().size() >= 5) {
String VAR_6(VAR_5->data().mid(1), String::Type(VAR_5->data()[0]));
if(VAR_6.length() == 4) {
VAR_1->setText(VAR_1->toString() + 'T' + VAR_6.substr(0, 2) + ':' + VAR_6.substr(2, 2));
}
}
}
}
}
}
}",taglib/cb9f07d9dcd791b63e622da43f7b232adaec0a9a/id3v2framefactory.cpp/vul/before/0.json,"void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const
{
  if(tag->header()->majorVersion() < 4 &&
     tag->frameList(""TDRC"").size() == 1 &&
     tag->frameList(""TDAT"").size() == 1)
  {
    TextIdentificationFrame *tdrc =
      dynamic_cast<TextIdentificationFrame *>(tag->frameList(""TDRC"").front());
    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(""TDAT"").front());

    if(tdrc &&
       tdrc->fieldList().size() == 1 &&
       tdrc->fieldList().front().size() == 4 &&
       tdat->data().size() >= 5)
    {
      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));
      if(date.length() == 4) {
        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));
        if(tag->frameList(""TIME"").size() == 1) {
          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(""TIME"").front());
          if(timeframe->data().size() >= 5) {
            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));
            if(time.length() == 4) {
              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));
            }
          }
        }
      }
    }
  }
}","void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *VAR_0) const
{
  if(VAR_0->header()->majorVersion() < 4 &&
     VAR_0->frameList(""TDRC"").size() == 1 &&
     VAR_0->frameList(""TDAT"").size() == 1)
  {
    TextIdentificationFrame *VAR_1 =
      VAR_2<TextIdentificationFrame *>(VAR_0->frameList(""TDRC"").front());
    UnknownFrame *VAR_3 = VAR_4<UnknownFrame *>(VAR_0->frameList(""TDAT"").front());

    if(VAR_1 &&
       VAR_1->fieldList().size() == 1 &&
       VAR_1->fieldList().front().size() == 4 &&
       VAR_3->data().size() >= 5)
    {
      String VAR_5(VAR_3->data().mid(1), String::Type(VAR_3->data()[0]));
      if(VAR_5.length() == 4) {
        VAR_1->setText(VAR_1->toString() + '-' + VAR_5.substr(2, 2) + '-' + VAR_5.substr(0, 2));
        if(VAR_0->frameList(""TIME"").size() == 1) {
          UnknownFrame *VAR_6 = VAR_4<UnknownFrame *>(VAR_0->frameList(""TIME"").front());
          if(VAR_6->data().size() >= 5) {
            String VAR_7(VAR_6->data().mid(1), String::Type(VAR_6->data()[0]));
            if(VAR_7.length() == 4) {
              VAR_1->setText(VAR_1->toString() + 'T' + VAR_7.substr(0, 2) + ':' + VAR_7.substr(2, 2));
            }
          }
        }
      }
    }
  }
}",taglib/cb9f07d9dcd791b63e622da43f7b232adaec0a9a/id3v2framefactory.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,10 +5,11 @@
      tag->frameList(""TDAT"").size() == 1)
   {
     TextIdentificationFrame *tdrc =
-      static_cast<TextIdentificationFrame *>(tag->frameList(""TDRC"").front());
+      dynamic_cast<TextIdentificationFrame *>(tag->frameList(""TDRC"").front());
     UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(""TDAT"").front());
 
-    if(tdrc->fieldList().size() == 1 &&
+    if(tdrc &&
+       tdrc->fieldList().size() == 1 &&
        tdrc->fieldList().front().size() == 4 &&
        tdat->data().size() >= 5)
     {","{'deleted_lines': ['      static_cast<TextIdentificationFrame *>(tag->frameList(""TDRC"").front());', '    if(tdrc->fieldList().size() == 1 &&'], 'added_lines': ['      dynamic_cast<TextIdentificationFrame *>(tag->frameList(""TDRC"").front());', '    if(tdrc &&', '       tdrc->fieldList().size() == 1 &&']}",True,"In TagLib 1.11.1, the rebuildAggregateFrames function in id3v2framefactory.cpp has a pointer to cast vulnerability, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted audio file.",8.8,HIGH,2,test,2017-09-30T15:15:41Z,2
CVE-2017-15594,['CWE-Other'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0.0,xen-project/xen,"x86/cpu: Fix IST handling during PCPU bringup

Clear IST references in newly allocated IDTs.  Nothing good will come of
having them set before the TSS is suitably constructed (although the chances
of the CPU surviving such an IST interrupt/exception is extremely slim).

Uniformly set the IST references after the TSS is in place.  This fixes an
issue on AMD hardware, where onlining a PCPU while PCPU0 is in HVM context
will cause IST_NONE to be copied into the new IDT, making that PCPU vulnerable
to privilege escalation from PV guests until it subsequently schedules an HVM
guest.

This is XSA-244.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",cc08c73c8c1f5ba5ed0f8274548db6725e1c3157,https://github.com/xen-project/xen/commit/cc08c73c8c1f5ba5ed0f8274548db6725e1c3157,xen/arch/x86/cpu/common.c,load_system_tables,"void load_system_tables(void)
{
unsigned int cpu = smp_processor_id();
unsigned long stack_bottom = get_stack_bottom(),
stack_top = stack_bottom & ~(STACK_SIZE - 1);
struct tss_struct *tss = &this_cpu(init_tss);
struct desc_struct *gdt =
this_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY;
struct desc_struct *compat_gdt =
this_cpu(compat_gdt_table) - FIRST_RESERVED_GDT_ENTRY;
const struct desc_ptr gdtr = {
.base = (unsigned long)gdt,
.limit = LAST_RESERVED_GDT_BYTE,
};
const struct desc_ptr idtr = {
.base = (unsigned long)idt_tables[cpu],
.limit = (IDT_ENTRIES * sizeof(idt_entry_t)) - 1,
};
*tss = (struct tss_struct){
.rsp0 = stack_bottom,
.rsp1 = 0x8600111111111111ul,
.rsp2 = 0x8600111111111111ul,
.ist = {
[IST_MCE - 1] = stack_top + IST_MCE * PAGE_SIZE,
[IST_DF  - 1] = stack_top + IST_DF  * PAGE_SIZE,
[IST_NMI - 1] = stack_top + IST_NMI * PAGE_SIZE,
[IST_MAX ... ARRAY_SIZE(tss->ist) - 1] =
0x8600111111111111ul,
},
.bitmap = IOBMP_INVALID_OFFSET,
};
_set_tssldt_desc(
gdt + TSS_ENTRY,
(unsigned long)tss,
offsetof(struct tss_struct, __cacheline_filler) - 1,
SYS_DESC_tss_avail);
_set_tssldt_desc(
compat_gdt + TSS_ENTRY,
(unsigned long)tss,
offsetof(struct tss_struct, __cacheline_filler) - 1,
SYS_DESC_tss_busy);
asm volatile (""lgdt %0""  : : ""m""  (gdtr) );
asm volatile (""lidt %0""  : : ""m""  (idtr) );
asm volatile (""ltr  %w0"" : : ""rm"" (TSS_ENTRY << 3) );
asm volatile (""lldt %w0"" : : ""rm"" (0) );
BUILD_BUG_ON((sizeof(struct cpu_info) -
offsetof(struct cpu_info, guest_cpu_user_regs.es)) & 0xf);
BUG_ON(system_state != SYS_STATE_early_boot && (stack_bottom & 0xf));
}","void load_system_tables(void)
{
unsigned int VAR_0 = smp_processor_id();
unsigned long VAR_1 = get_stack_bottom(),
VAR_2 = VAR_1 & ~(VAR_3 - 1);
struct tss_struct *VAR_4 = &this_cpu(VAR_5);
struct desc_struct *VAR_6 =
this_cpu(VAR_7) - VAR_8;
struct desc_struct *VAR_9 =
this_cpu(VAR_10) - VAR_8;
const struct desc_ptr VAR_11 = {
.base = (unsigned long)VAR_6,
.limit = VAR_12,
};
const struct desc_ptr VAR_13 = {
.base = (unsigned long)VAR_14[VAR_0],
.limit = (VAR_15 * sizeof(VAR_16)) - 1,
};
*VAR_4 = (struct tss_struct){
.rsp0 = VAR_1,
.rsp1 = 0x8600111111111111ul,
.rsp2 = 0x8600111111111111ul,
.ist = {
[VAR_17 - 1] = VAR_2 + VAR_17 * VAR_18,
[VAR_19  - 1] = VAR_2 + VAR_19  * VAR_18,
[VAR_20 - 1] = VAR_2 + VAR_20 * VAR_18,
[VAR_21 ... ARRAY_SIZE(VAR_4->ist) - 1] =
0x8600111111111111ul,
},
.bitmap = VAR_22,
};
_set_tssldt_desc(
VAR_6 + VAR_23,
(unsigned long)VAR_4,
offsetof(struct tss_struct, VAR_24) - 1,
VAR_25);
_set_tssldt_desc(
VAR_9 + VAR_23,
(unsigned long)VAR_4,
offsetof(struct tss_struct, VAR_24) - 1,
VAR_26);
asm volatile (""lgdt %0""  : : ""m""  (VAR_11) );
asm volatile (""lidt %0""  : : ""m""  (VAR_13) );
asm volatile (""ltr  %w0"" : : ""rm"" (VAR_23 << 3) );
asm volatile (""lldt %w0"" : : ""rm"" (0) );
BUILD_BUG_ON((sizeof(struct cpu_info) -
offsetof(struct cpu_info, VAR_27.es)) & 0xf);
BUG_ON(VAR_28 != VAR_29 && (VAR_1 & 0xf));
}",xen-project/xen/cc08c73c8c1f5ba5ed0f8274548db6725e1c3157/common.c/vul/before/0.json,"void load_system_tables(void)
{
	unsigned int cpu = smp_processor_id();
	unsigned long stack_bottom = get_stack_bottom(),
		stack_top = stack_bottom & ~(STACK_SIZE - 1);

	struct tss_struct *tss = &this_cpu(init_tss);
	struct desc_struct *gdt =
		this_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY;
	struct desc_struct *compat_gdt =
		this_cpu(compat_gdt_table) - FIRST_RESERVED_GDT_ENTRY;

	const struct desc_ptr gdtr = {
		.base = (unsigned long)gdt,
		.limit = LAST_RESERVED_GDT_BYTE,
	};
	const struct desc_ptr idtr = {
		.base = (unsigned long)idt_tables[cpu],
		.limit = (IDT_ENTRIES * sizeof(idt_entry_t)) - 1,
	};

	*tss = (struct tss_struct){
		/* Main stack for interrupts/exceptions. */
		.rsp0 = stack_bottom,

		/* Ring 1 and 2 stacks poisoned. */
		.rsp1 = 0x8600111111111111ul,
		.rsp2 = 0x8600111111111111ul,

		/*
		 * MCE, NMI and Double Fault handlers get their own stacks.
		 * All others poisoned.
		 */
		.ist = {
			[IST_MCE - 1] = stack_top + IST_MCE * PAGE_SIZE,
			[IST_DF  - 1] = stack_top + IST_DF  * PAGE_SIZE,
			[IST_NMI - 1] = stack_top + IST_NMI * PAGE_SIZE,

			[IST_MAX ... ARRAY_SIZE(tss->ist) - 1] =
				0x8600111111111111ul,
		},

		.bitmap = IOBMP_INVALID_OFFSET,
	};

	_set_tssldt_desc(
		gdt + TSS_ENTRY,
		(unsigned long)tss,
		offsetof(struct tss_struct, __cacheline_filler) - 1,
		SYS_DESC_tss_avail);
	_set_tssldt_desc(
		compat_gdt + TSS_ENTRY,
		(unsigned long)tss,
		offsetof(struct tss_struct, __cacheline_filler) - 1,
		SYS_DESC_tss_busy);

	asm volatile (""lgdt %0""  : : ""m""  (gdtr) );
	asm volatile (""lidt %0""  : : ""m""  (idtr) );
	asm volatile (""ltr  %w0"" : : ""rm"" (TSS_ENTRY << 3) );
	asm volatile (""lldt %w0"" : : ""rm"" (0) );

	set_ist(&idt_tables[cpu][TRAP_double_fault],  IST_DF);
	set_ist(&idt_tables[cpu][TRAP_nmi],	      IST_NMI);
	set_ist(&idt_tables[cpu][TRAP_machine_check], IST_MCE);

	/*
	 * Bottom-of-stack must be 16-byte aligned!
	 *
	 * Defer checks until exception support is sufficiently set up.
	 */
	BUILD_BUG_ON((sizeof(struct cpu_info) -
		      offsetof(struct cpu_info, guest_cpu_user_regs.es)) & 0xf);
	BUG_ON(system_state != SYS_STATE_early_boot && (stack_bottom & 0xf));
}","void load_system_tables(void)
{
	unsigned int VAR_0 = smp_processor_id();
	unsigned long VAR_1 = get_stack_bottom(),
		VAR_2 = VAR_1 & ~(VAR_3 - 1);

	struct tss_struct *VAR_4 = &this_cpu(VAR_5);
	struct desc_struct *VAR_6 =
		this_cpu(VAR_7) - VAR_8;
	struct desc_struct *VAR_9 =
		this_cpu(VAR_10) - VAR_8;

	const struct desc_ptr VAR_11 = {
		.base = (unsigned long)VAR_6,
		.limit = VAR_12,
	};
	const struct desc_ptr VAR_13 = {
		.base = (unsigned long)VAR_14[VAR_0],
		.limit = (VAR_15 * sizeof(VAR_16)) - 1,
	};

	*VAR_4 = (struct tss_struct){
		/* COMMENT_0 */
		.rsp0 = VAR_1,

		/* COMMENT_1 */
		.rsp1 = 0x8600111111111111ul,
		.rsp2 = 0x8600111111111111ul,

		/* COMMENT_2 */
                                                             
                         
     
		.ist = {
			[VAR_17 - 1] = VAR_2 + VAR_17 * VAR_18,
			[VAR_19  - 1] = VAR_2 + VAR_19  * VAR_18,
			[VAR_20 - 1] = VAR_2 + VAR_20 * VAR_18,

			[VAR_21 ... ARRAY_SIZE(VAR_4->ist) - 1] =
				0x8600111111111111ul,
		},

		.bitmap = VAR_22,
	};

	_set_tssldt_desc(
		VAR_6 + VAR_23,
		(unsigned long)VAR_4,
		offsetof(struct tss_struct, VAR_24) - 1,
		VAR_25);
	_set_tssldt_desc(
		VAR_9 + VAR_23,
		(unsigned long)VAR_4,
		offsetof(struct tss_struct, VAR_24) - 1,
		VAR_26);

	asm volatile (""lgdt %0""  : : ""m""  (VAR_11) );
	asm volatile (""lidt %0""  : : ""m""  (VAR_13) );
	asm volatile (""ltr  %w0"" : : ""rm"" (VAR_23 << 3) );
	asm volatile (""lldt %w0"" : : ""rm"" (0) );

	set_ist(&VAR_14[VAR_0][VAR_27],  VAR_19);
	set_ist(&VAR_14[VAR_0][VAR_28],	      VAR_20);
	set_ist(&VAR_14[VAR_0][VAR_29], VAR_17);

	/* COMMENT_6 */
                                            
   
                                                                
    
	BUILD_BUG_ON((sizeof(struct cpu_info) -
		      offsetof(struct cpu_info, VAR_30.es)) & 0xf);
	BUG_ON(VAR_31 != VAR_32 && (VAR_1 & 0xf));
}",xen-project/xen/cc08c73c8c1f5ba5ed0f8274548db6725e1c3157/common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -59,6 +59,10 @@
 	asm volatile (""ltr  %w0"" : : ""rm"" (TSS_ENTRY << 3) );
 	asm volatile (""lldt %w0"" : : ""rm"" (0) );
 
+	set_ist(&idt_tables[cpu][TRAP_double_fault],  IST_DF);
+	set_ist(&idt_tables[cpu][TRAP_nmi],	      IST_NMI);
+	set_ist(&idt_tables[cpu][TRAP_machine_check], IST_MCE);
+
 	/*
 	 * Bottom-of-stack must be 16-byte aligned!
 	 *","{'deleted_lines': [], 'added_lines': ['\tset_ist(&idt_tables[cpu][TRAP_double_fault],  IST_DF);', '\tset_ist(&idt_tables[cpu][TRAP_nmi],\t      IST_NMI);', '\tset_ist(&idt_tables[cpu][TRAP_machine_check], IST_MCE);', '']}",True,An issue was discovered in Xen through 4.9.x allowing x86 SVM PV guest OS users to cause a denial of service (hypervisor crash) or gain privileges because IDT settings are mishandled during CPU hotplugging.,8.8,HIGH,2,test,2017-10-12T12:50:31Z,2
CVE-2017-15594,['CWE-Other'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0.0,xen-project/xen,"x86/cpu: Fix IST handling during PCPU bringup

Clear IST references in newly allocated IDTs.  Nothing good will come of
having them set before the TSS is suitably constructed (although the chances
of the CPU surviving such an IST interrupt/exception is extremely slim).

Uniformly set the IST references after the TSS is in place.  This fixes an
issue on AMD hardware, where onlining a PCPU while PCPU0 is in HVM context
will cause IST_NONE to be copied into the new IDT, making that PCPU vulnerable
to privilege escalation from PV guests until it subsequently schedules an HVM
guest.

This is XSA-244.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",cc08c73c8c1f5ba5ed0f8274548db6725e1c3157,https://github.com/xen-project/xen/commit/cc08c73c8c1f5ba5ed0f8274548db6725e1c3157,xen/arch/x86/smpboot.c,cpu_smpboot_alloc,"static int cpu_smpboot_alloc(unsigned int cpu)
{
unsigned int i, order, memflags = 0;
nodeid_t node = cpu_to_node(cpu);
struct desc_struct *gdt;
unsigned long stub_page;
if ( node != NUMA_NO_NODE )
memflags = MEMF_node(node);
stack_base[cpu] = alloc_xenheap_pages(STACK_ORDER, memflags);
if ( stack_base[cpu] == NULL )
goto oom;
memguard_guard_stack(stack_base[cpu]);
order = get_order_from_pages(NR_RESERVED_GDT_PAGES);
per_cpu(gdt_table, cpu) = gdt = alloc_xenheap_pages(order, memflags);
if ( gdt == NULL )
goto oom;
memcpy(gdt, boot_cpu_gdt_table, NR_RESERVED_GDT_PAGES * PAGE_SIZE);
BUILD_BUG_ON(NR_CPUS > 0x10000);
gdt[PER_CPU_GDT_ENTRY - FIRST_RESERVED_GDT_ENTRY].a = cpu;
per_cpu(compat_gdt_table, cpu) = gdt = alloc_xenheap_pages(order, memflags);
if ( gdt == NULL )
goto oom;
memcpy(gdt, boot_cpu_compat_gdt_table, NR_RESERVED_GDT_PAGES * PAGE_SIZE);
gdt[PER_CPU_GDT_ENTRY - FIRST_RESERVED_GDT_ENTRY].a = cpu;
order = get_order_from_bytes(IDT_ENTRIES * sizeof(idt_entry_t));
idt_tables[cpu] = alloc_xenheap_pages(order, memflags);
if ( idt_tables[cpu] == NULL )
goto oom;
memcpy(idt_tables[cpu], idt_table, IDT_ENTRIES * sizeof(idt_entry_t));
for ( stub_page = 0, i = cpu & ~(STUBS_PER_PAGE - 1);
i < nr_cpu_ids && i <= (cpu | (STUBS_PER_PAGE - 1)); ++i )
if ( cpu_online(i) && cpu_to_node(i) == node )
{
per_cpu(stubs.mfn, cpu) = per_cpu(stubs.mfn, i);
break;
}
BUG_ON(i == cpu);
stub_page = alloc_stub_page(cpu, &per_cpu(stubs.mfn, cpu));
if ( !stub_page )
goto oom;
per_cpu(stubs.addr, cpu) = stub_page + STUB_BUF_CPU_OFFS(cpu);
if ( secondary_socket_cpumask == NULL &&
(secondary_socket_cpumask = xzalloc(cpumask_t)) == NULL )
goto oom;
if ( zalloc_cpumask_var(&per_cpu(cpu_sibling_mask, cpu)) &&
zalloc_cpumask_var(&per_cpu(cpu_core_mask, cpu)) &&
alloc_cpumask_var(&per_cpu(scratch_cpumask, cpu)) )
return 0;
oom:
cpu_smpboot_free(cpu);
return -ENOMEM;
}","static int cpu_smpboot_alloc(unsigned int VAR_0)
{
unsigned int VAR_1, VAR_2, VAR_3 = 0;
nodeid_t VAR_4 = cpu_to_node(VAR_0);
struct desc_struct *VAR_5;
unsigned long VAR_6;
if ( VAR_4 != VAR_7 )
VAR_3 = MEMF_node(VAR_4);
VAR_8[VAR_0] = alloc_xenheap_pages(VAR_9, VAR_3);
if ( VAR_8[VAR_0] == NULL )
goto oom;
memguard_guard_stack(VAR_8[VAR_0]);
VAR_2 = get_order_from_pages(VAR_10);
per_cpu(VAR_11, VAR_0) = VAR_5 = alloc_xenheap_pages(VAR_2, VAR_3);
if ( VAR_5 == NULL )
goto oom;
memcpy(VAR_5, VAR_12, VAR_10 * VAR_13);
BUILD_BUG_ON(VAR_14 > 0x10000);
VAR_5[VAR_15 - VAR_16].a = VAR_0;
per_cpu(VAR_17, VAR_0) = VAR_5 = alloc_xenheap_pages(VAR_2, VAR_3);
if ( VAR_5 == NULL )
goto oom;
memcpy(VAR_5, VAR_18, VAR_10 * VAR_13);
VAR_5[VAR_15 - VAR_16].a = VAR_0;
VAR_2 = get_order_from_bytes(VAR_19 * sizeof(VAR_20));
VAR_21[VAR_0] = alloc_xenheap_pages(VAR_2, VAR_3);
if ( VAR_21[VAR_0] == NULL )
goto oom;
memcpy(VAR_21[VAR_0], VAR_22, VAR_19 * sizeof(VAR_20));
for ( VAR_6 = 0, VAR_1 = VAR_0 & ~(VAR_23 - 1);
VAR_1 < VAR_24 && VAR_1 <= (VAR_0 | (VAR_23 - 1)); ++VAR_1 )
if ( cpu_online(VAR_1) && cpu_to_node(VAR_1) == VAR_4 )
{
per_cpu(VAR_25.mfn, VAR_0) = per_cpu(VAR_25.mfn, VAR_1);
break;
}
BUG_ON(VAR_1 == VAR_0);
VAR_6 = alloc_stub_page(VAR_0, &per_cpu(VAR_25.mfn, VAR_0));
if ( !VAR_6 )
goto oom;
per_cpu(VAR_25.addr, VAR_0) = VAR_6 + STUB_BUF_CPU_OFFS(VAR_0);
if ( VAR_26 == NULL &&
(VAR_26 = xzalloc(VAR_27)) == NULL )
goto oom;
if ( zalloc_cpumask_var(&per_cpu(VAR_28, VAR_0)) &&
zalloc_cpumask_var(&per_cpu(VAR_29, VAR_0)) &&
alloc_cpumask_var(&per_cpu(VAR_30, VAR_0)) )
return 0;
oom:
cpu_smpboot_free(VAR_0);
return -VAR_31;
}",xen-project/xen/cc08c73c8c1f5ba5ed0f8274548db6725e1c3157/smpboot.c/vul/before/0.json,"static int cpu_smpboot_alloc(unsigned int cpu)
{
    unsigned int i, order, memflags = 0;
    nodeid_t node = cpu_to_node(cpu);
    struct desc_struct *gdt;
    unsigned long stub_page;

    if ( node != NUMA_NO_NODE )
        memflags = MEMF_node(node);

    stack_base[cpu] = alloc_xenheap_pages(STACK_ORDER, memflags);
    if ( stack_base[cpu] == NULL )
        goto oom;
    memguard_guard_stack(stack_base[cpu]);

    order = get_order_from_pages(NR_RESERVED_GDT_PAGES);
    per_cpu(gdt_table, cpu) = gdt = alloc_xenheap_pages(order, memflags);
    if ( gdt == NULL )
        goto oom;
    memcpy(gdt, boot_cpu_gdt_table, NR_RESERVED_GDT_PAGES * PAGE_SIZE);
    BUILD_BUG_ON(NR_CPUS > 0x10000);
    gdt[PER_CPU_GDT_ENTRY - FIRST_RESERVED_GDT_ENTRY].a = cpu;

    per_cpu(compat_gdt_table, cpu) = gdt = alloc_xenheap_pages(order, memflags);
    if ( gdt == NULL )
        goto oom;
    memcpy(gdt, boot_cpu_compat_gdt_table, NR_RESERVED_GDT_PAGES * PAGE_SIZE);
    gdt[PER_CPU_GDT_ENTRY - FIRST_RESERVED_GDT_ENTRY].a = cpu;

    order = get_order_from_bytes(IDT_ENTRIES * sizeof(idt_entry_t));
    idt_tables[cpu] = alloc_xenheap_pages(order, memflags);
    if ( idt_tables[cpu] == NULL )
        goto oom;
    memcpy(idt_tables[cpu], idt_table, IDT_ENTRIES * sizeof(idt_entry_t));
    set_ist(&idt_tables[cpu][TRAP_double_fault],  IST_NONE);
    set_ist(&idt_tables[cpu][TRAP_nmi],           IST_NONE);
    set_ist(&idt_tables[cpu][TRAP_machine_check], IST_NONE);

    for ( stub_page = 0, i = cpu & ~(STUBS_PER_PAGE - 1);
          i < nr_cpu_ids && i <= (cpu | (STUBS_PER_PAGE - 1)); ++i )
        if ( cpu_online(i) && cpu_to_node(i) == node )
        {
            per_cpu(stubs.mfn, cpu) = per_cpu(stubs.mfn, i);
            break;
        }
    BUG_ON(i == cpu);
    stub_page = alloc_stub_page(cpu, &per_cpu(stubs.mfn, cpu));
    if ( !stub_page )
        goto oom;
    per_cpu(stubs.addr, cpu) = stub_page + STUB_BUF_CPU_OFFS(cpu);

    if ( secondary_socket_cpumask == NULL &&
         (secondary_socket_cpumask = xzalloc(cpumask_t)) == NULL )
        goto oom;

    if ( zalloc_cpumask_var(&per_cpu(cpu_sibling_mask, cpu)) &&
         zalloc_cpumask_var(&per_cpu(cpu_core_mask, cpu)) &&
         alloc_cpumask_var(&per_cpu(scratch_cpumask, cpu)) )
        return 0;

 oom:
    cpu_smpboot_free(cpu);
    return -ENOMEM;
}","static int cpu_smpboot_alloc(unsigned int VAR_0)
{
    unsigned int VAR_1, VAR_2, VAR_3 = 0;
    nodeid_t VAR_4 = cpu_to_node(VAR_0);
    struct desc_struct *VAR_5;
    unsigned long VAR_6;

    if ( VAR_4 != VAR_7 )
        VAR_3 = MEMF_node(VAR_4);

    VAR_8[VAR_0] = alloc_xenheap_pages(VAR_9, VAR_3);
    if ( VAR_8[VAR_0] == NULL )
        goto oom;
    memguard_guard_stack(VAR_8[VAR_0]);

    VAR_2 = get_order_from_pages(VAR_10);
    per_cpu(VAR_11, VAR_0) = VAR_5 = alloc_xenheap_pages(VAR_2, VAR_3);
    if ( VAR_5 == NULL )
        goto oom;
    memcpy(VAR_5, VAR_12, VAR_10 * VAR_13);
    BUILD_BUG_ON(VAR_14 > 0x10000);
    VAR_5[VAR_15 - VAR_16].a = VAR_0;

    per_cpu(VAR_17, VAR_0) = VAR_5 = alloc_xenheap_pages(VAR_2, VAR_3);
    if ( VAR_5 == NULL )
        goto oom;
    memcpy(VAR_5, VAR_18, VAR_10 * VAR_13);
    VAR_5[VAR_15 - VAR_16].a = VAR_0;

    VAR_2 = get_order_from_bytes(VAR_19 * sizeof(VAR_20));
    VAR_21[VAR_0] = alloc_xenheap_pages(VAR_2, VAR_3);
    if ( VAR_21[VAR_0] == NULL )
        goto oom;
    memcpy(VAR_21[VAR_0], VAR_22, VAR_19 * sizeof(VAR_20));
    set_ist(&VAR_21[VAR_0][VAR_23],  VAR_24);
    set_ist(&VAR_21[VAR_0][VAR_25],           VAR_24);
    set_ist(&VAR_21[VAR_0][VAR_26], VAR_24);

    for ( VAR_6 = 0, VAR_1 = VAR_0 & ~(VAR_27 - 1);
          VAR_1 < VAR_28 && VAR_1 <= (VAR_0 | (VAR_27 - 1)); ++VAR_1 )
        if ( cpu_online(VAR_1) && cpu_to_node(VAR_1) == VAR_4 )
        {
            per_cpu(VAR_29.mfn, VAR_0) = per_cpu(VAR_29.mfn, VAR_1);
            break;
        }
    BUG_ON(VAR_1 == VAR_0);
    VAR_6 = alloc_stub_page(VAR_0, &per_cpu(VAR_29.mfn, VAR_0));
    if ( !VAR_6 )
        goto oom;
    per_cpu(VAR_29.addr, VAR_0) = VAR_6 + STUB_BUF_CPU_OFFS(VAR_0);

    if ( VAR_30 == NULL &&
         (VAR_30 = xzalloc(VAR_31)) == NULL )
        goto oom;

    if ( zalloc_cpumask_var(&per_cpu(VAR_32, VAR_0)) &&
         zalloc_cpumask_var(&per_cpu(VAR_33, VAR_0)) &&
         alloc_cpumask_var(&per_cpu(VAR_34, VAR_0)) )
        return 0;

 oom:
    cpu_smpboot_free(VAR_0);
    return -VAR_35;
}",xen-project/xen/cc08c73c8c1f5ba5ed0f8274548db6725e1c3157/smpboot.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,6 +32,9 @@
     if ( idt_tables[cpu] == NULL )
         goto oom;
     memcpy(idt_tables[cpu], idt_table, IDT_ENTRIES * sizeof(idt_entry_t));
+    set_ist(&idt_tables[cpu][TRAP_double_fault],  IST_NONE);
+    set_ist(&idt_tables[cpu][TRAP_nmi],           IST_NONE);
+    set_ist(&idt_tables[cpu][TRAP_machine_check], IST_NONE);
 
     for ( stub_page = 0, i = cpu & ~(STUBS_PER_PAGE - 1);
           i < nr_cpu_ids && i <= (cpu | (STUBS_PER_PAGE - 1)); ++i )","{'deleted_lines': [], 'added_lines': ['    set_ist(&idt_tables[cpu][TRAP_double_fault],  IST_NONE);', '    set_ist(&idt_tables[cpu][TRAP_nmi],           IST_NONE);', '    set_ist(&idt_tables[cpu][TRAP_machine_check], IST_NONE);']}",True,An issue was discovered in Xen through 4.9.x allowing x86 SVM PV guest OS users to cause a denial of service (hypervisor crash) or gain privileges because IDT settings are mishandled during CPU hotplugging.,8.8,HIGH,2,test,2017-10-12T12:50:31Z,2
CVE-2017-15115,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"sctp: do not peel off an assoc from one netns to another one

Now when peeling off an association to the sock in another netns, all
transports in this assoc are not to be rehashed and keep use the old
key in hashtable.

As a transport uses sk->net as the hash key to insert into hashtable,
it would miss removing these transports from hashtable due to the new
netns when closing the sock and all transports are being freeed, then
later an use-after-free issue could be caused when looking up an asoc
and dereferencing those transports.

This is a very old issue since very beginning, ChunYu found it with
syzkaller fuzz testing with this series:

  socket$inet6_sctp()
  bind$inet6()
  sendto$inet6()
  unshare(0x40000000)
  getsockopt$inet_sctp6_SCTP_GET_ASSOC_ID_LIST()
  getsockopt$inet_sctp6_SCTP_SOCKOPT_PEELOFF()

This patch is to block this call when peeling one assoc off from one
netns to another one, so that the netns of all transport would not
go out-sync with the key in hashtable.

Note that this patch didn't fix it by rehashing transports, as it's
difficult to handle the situation when the tuple is already in use
in the new netns. Besides, no one would like to peel off one assoc
to another netns, considering ipaddrs, ifaces, etc. are usually
different.

Reported-by: ChunYu Wang <chunwang@redhat.com>
Signed-off-by: Xin Long <lucien.xin@gmail.com>
Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Acked-by: Neil Horman <nhorman@tuxdriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74,net/sctp/socket.c,sctp_do_peeloff,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
struct sctp_association *asoc = sctp_id2assoc(sk, id);
struct sctp_sock *sp = sctp_sk(sk);
struct socket *sock;
int err = 0;
if (!asoc)
return -EINVAL;
if (waitqueue_active(&asoc->wait))
return -EBUSY;
if (!sctp_style(sk, UDP))
return -EINVAL;
err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
if (err < 0)
return err;
sctp_copy_sock(sock->sk, sk, asoc);
sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);
sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);
*sockp = sock;
return err;
}","int sctp_do_peeloff(struct sock *VAR_0, sctp_assoc_t VAR_1, struct socket **VAR_2)
{
struct sctp_association *VAR_3 = sctp_id2assoc(VAR_0, VAR_1);
struct sctp_sock *VAR_4 = sctp_sk(VAR_0);
struct socket *sock;
int VAR_5 = 0;
if (!VAR_3)
return -VAR_6;
if (waitqueue_active(&VAR_3->wait))
return -VAR_7;
if (!sctp_style(VAR_0, VAR_8))
return -VAR_6;
VAR_5 = sock_create(VAR_0->sk_family, VAR_9, VAR_10, &sock);
if (VAR_5 < 0)
return VAR_5;
sctp_copy_sock(sock->sk, VAR_0, VAR_3);
VAR_4->pf->to_sk_daddr(&VAR_3->peer.primary_addr, VAR_0);
sctp_sock_migrate(VAR_0, sock->sk, VAR_3, VAR_11);
*VAR_2 = sock;
return VAR_5;
}",torvalds/linux/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74/socket.c/vul/before/0.json,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
	struct socket *sock;
	int err = 0;

	/* Do not peel off from one netns to another one. */
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

	if (!asoc)
		return -EINVAL;

	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}","int sctp_do_peeloff(struct sock *VAR_0, sctp_assoc_t VAR_1, struct socket **VAR_2)
{
	struct sctp_association *VAR_3 = sctp_id2assoc(VAR_0, VAR_1);
	struct sctp_sock *VAR_4 = sctp_sk(VAR_0);
	struct socket *sock;
	int VAR_5 = 0;

	/* COMMENT_0 */
	if (!net_eq(VAR_6->nsproxy->net_ns, sock_net(VAR_0)))
		return -VAR_7;

	if (!VAR_3)
		return -VAR_7;

	/* COMMENT_1 */
                                              
    
	if (waitqueue_active(&VAR_3->wait))
		return -VAR_8;

	/* COMMENT_4 */
                                                        
    
	if (!sctp_style(VAR_0, VAR_9))
		return -VAR_7;

	/* COMMENT_7 */
	VAR_5 = sock_create(VAR_0->sk_family, VAR_10, VAR_11, &sock);
	if (VAR_5 < 0)
		return VAR_5;

	sctp_copy_sock(sock->sk, VAR_0, VAR_3);

	/* COMMENT_8 */
                                                            
    
	VAR_4->pf->to_sk_daddr(&VAR_3->peer.primary_addr, VAR_0);

	/* COMMENT_11 */
                      
    
	sctp_sock_migrate(VAR_0, sock->sk, VAR_3, VAR_12);

	*VAR_2 = sock;

	return VAR_5;
}",torvalds/linux/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74/socket.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,10 @@
 	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
+
+	/* Do not peel off from one netns to another one. */
+	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
+		return -EINVAL;
 
 	if (!asoc)
 		return -EINVAL;","{'deleted_lines': [], 'added_lines': ['', '\t/* Do not peel off from one netns to another one. */', '\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))', '\t\treturn -EINVAL;']}",True,"The sctp_do_peeloff function in net/sctp/socket.c in the Linux kernel before 4.14 does not check whether the intended netns is used in a peel-off action, which allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls.",7.8,HIGH,2,test,2017-10-17T15:26:10Z,2
CVE-2017-15088,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,krb5,"Fix PKINIT cert matching data construction

Rewrite X509_NAME_oneline_ex() and its call sites to use dynamic
allocation and to perform proper error checking.

ticket: 8617
target_version: 1.16
target_version: 1.15-next
target_version: 1.14-next
tags: pullup",fbb687db1088ddd894d975996e5f6a4252b9a2b4,https://github.com/krb5/krb5/commit/fbb687db1088ddd894d975996e5f6a4252b9a2b4,src/plugins/preauth/pkinit/pkinit_crypto_openssl.c,get_matching_data,"static krb5_error_code
get_matching_data(krb5_context context,
pkinit_plg_crypto_context plg_cryptoctx,
pkinit_req_crypto_context req_cryptoctx, X509 *cert,
pkinit_cert_matching_data **md_out)
{
krb5_error_code ret = ENOMEM;
pkinit_cert_matching_data *md = NULL;
krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;
size_t i, j;
char buf[DN_BUF_LEN];
unsigned int bufsize = sizeof(buf);
*md_out = NULL;
md = calloc(1, sizeof(*md));
if (md == NULL)
goto cleanup;
X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,
XN_FLAG_SEP_COMMA_PLUS);
md->subject_dn = strdup(buf);
if (md->subject_dn == NULL) {
ret = ENOMEM;
goto cleanup;
}
X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,
XN_FLAG_SEP_COMMA_PLUS);
md->issuer_dn = strdup(buf);
if (md->issuer_dn == NULL) {
ret = ENOMEM;
goto cleanup;
}
ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,
cert, &pkinit_sans, &upn_sans, NULL);
if (ret)
goto cleanup;
j = 0;
if (pkinit_sans != NULL) {
for (i = 0; pkinit_sans[i] != NULL; i++)
j++;
}
if (upn_sans != NULL) {
for (i = 0; upn_sans[i] != NULL; i++)
j++;
}
if (j != 0) {
md->sans = calloc((size_t)j+1, sizeof(*md->sans));
if (md->sans == NULL) {
ret = ENOMEM;
goto cleanup;
}
j = 0;
if (pkinit_sans != NULL) {
for (i = 0; pkinit_sans[i] != NULL; i++)
md->sans[j++] = pkinit_sans[i];
free(pkinit_sans);
}
if (upn_sans != NULL) {
for (i = 0; upn_sans[i] != NULL; i++)
md->sans[j++] = upn_sans[i];
free(upn_sans);
}
md->sans[j] = NULL;
} else
md->sans = NULL;
ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,
req_cryptoctx, cert, &md->ku_bits,
&md->eku_bits);
if (ret)
goto cleanup;
*md_out = md;
md = NULL;
cleanup:
crypto_cert_free_matching_data(context, md);
return ret;
}","static krb5_error_code
get_matching_data(krb5_context VAR_0,
pkinit_plg_crypto_context VAR_1,
pkinit_req_crypto_context VAR_2, X509 *VAR_3,
pkinit_cert_matching_data **VAR_4)
{
krb5_error_code VAR_5 = VAR_6;
pkinit_cert_matching_data *VAR_7 = NULL;
krb5_principal *VAR_8 = NULL, *VAR_9 = NULL;
size_t VAR_10, VAR_11;
char VAR_12[VAR_13];
unsigned int VAR_14 = sizeof(VAR_12);
*VAR_4 = NULL;
VAR_7 = calloc(1, sizeof(*VAR_7));
if (VAR_7 == NULL)
goto cleanup;
X509_NAME_oneline_ex(X509_get_subject_name(VAR_3), VAR_12, &VAR_14,
VAR_15);
VAR_7->subject_dn = strdup(VAR_12);
if (VAR_7->subject_dn == NULL) {
VAR_5 = VAR_6;
goto cleanup;
}
X509_NAME_oneline_ex(X509_get_issuer_name(VAR_3), VAR_12, &VAR_14,
VAR_15);
VAR_7->issuer_dn = strdup(VAR_12);
if (VAR_7->issuer_dn == NULL) {
VAR_5 = VAR_6;
goto cleanup;
}
VAR_5 = crypto_retrieve_X509_sans(VAR_0, VAR_1, VAR_2,
VAR_3, &VAR_8, &VAR_9, NULL);
if (VAR_5)
goto cleanup;
VAR_11 = 0;
if (VAR_8 != NULL) {
for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)
VAR_11++;
}
if (VAR_9 != NULL) {
for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)
VAR_11++;
}
if (VAR_11 != 0) {
VAR_7->sans = calloc((size_t)VAR_11+1, sizeof(*VAR_7->sans));
if (VAR_7->sans == NULL) {
VAR_5 = VAR_6;
goto cleanup;
}
VAR_11 = 0;
if (VAR_8 != NULL) {
for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)
VAR_7->sans[VAR_11++] = VAR_8[VAR_10];
free(VAR_8);
}
if (VAR_9 != NULL) {
for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)
VAR_7->sans[VAR_11++] = VAR_9[VAR_10];
free(VAR_9);
}
VAR_7->sans[VAR_11] = NULL;
} else
VAR_7->sans = NULL;
VAR_5 = crypto_retrieve_X509_key_usage(VAR_0, VAR_1,
VAR_2, VAR_3, &VAR_7->ku_bits,
&VAR_7->eku_bits);
if (VAR_5)
goto cleanup;
*VAR_4 = VAR_7;
VAR_7 = NULL;
cleanup:
crypto_cert_free_matching_data(VAR_0, VAR_7);
return VAR_5;
}",krb5/fbb687db1088ddd894d975996e5f6a4252b9a2b4/pkinit_crypto_openssl.c/vul/before/0.json,"static krb5_error_code
get_matching_data(krb5_context context,
                  pkinit_plg_crypto_context plg_cryptoctx,
                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,
                  pkinit_cert_matching_data **md_out)
{
    krb5_error_code ret = ENOMEM;
    pkinit_cert_matching_data *md = NULL;
    krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;
    size_t i, j;

    *md_out = NULL;

    md = calloc(1, sizeof(*md));
    if (md == NULL)
        goto cleanup;

    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);
    if (ret)
        goto cleanup;
    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);
    if (ret)
        goto cleanup;

    /* Get the SAN data. */
    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,
                                    cert, &pkinit_sans, &upn_sans, NULL);
    if (ret)
        goto cleanup;

    j = 0;
    if (pkinit_sans != NULL) {
        for (i = 0; pkinit_sans[i] != NULL; i++)
            j++;
    }
    if (upn_sans != NULL) {
        for (i = 0; upn_sans[i] != NULL; i++)
            j++;
    }
    if (j != 0) {
        md->sans = calloc((size_t)j+1, sizeof(*md->sans));
        if (md->sans == NULL) {
            ret = ENOMEM;
            goto cleanup;
        }
        j = 0;
        if (pkinit_sans != NULL) {
            for (i = 0; pkinit_sans[i] != NULL; i++)
                md->sans[j++] = pkinit_sans[i];
            free(pkinit_sans);
        }
        if (upn_sans != NULL) {
            for (i = 0; upn_sans[i] != NULL; i++)
                md->sans[j++] = upn_sans[i];
            free(upn_sans);
        }
        md->sans[j] = NULL;
    } else
        md->sans = NULL;

    /* Get the KU and EKU data. */
    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,
                                         req_cryptoctx, cert, &md->ku_bits,
                                         &md->eku_bits);
    if (ret)
        goto cleanup;

    *md_out = md;
    md = NULL;

cleanup:
    crypto_cert_free_matching_data(context, md);
    return ret;
}","static krb5_error_code
get_matching_data(krb5_context VAR_0,
                  pkinit_plg_crypto_context VAR_1,
                  pkinit_req_crypto_context VAR_2, X509 *VAR_3,
                  pkinit_cert_matching_data **VAR_4)
{
    krb5_error_code VAR_5 = VAR_6;
    pkinit_cert_matching_data *VAR_7 = NULL;
    krb5_principal *VAR_8 = NULL, *VAR_9 = NULL;
    size_t VAR_10, VAR_11;

    *VAR_4 = NULL;

    VAR_7 = calloc(1, sizeof(*VAR_7));
    if (VAR_7 == NULL)
        goto cleanup;

    VAR_5 = rfc2253_name(X509_get_subject_name(VAR_3), &VAR_7->subject_dn);
    if (VAR_5)
        goto cleanup;
    VAR_5 = rfc2253_name(X509_get_issuer_name(VAR_3), &VAR_7->issuer_dn);
    if (VAR_5)
        goto cleanup;

    /* COMMENT_0 */
    VAR_5 = crypto_retrieve_X509_sans(VAR_0, VAR_1, VAR_2,
                                    VAR_3, &VAR_8, &VAR_9, NULL);
    if (VAR_5)
        goto cleanup;

    VAR_11 = 0;
    if (VAR_8 != NULL) {
        for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)
            VAR_11++;
    }
    if (VAR_9 != NULL) {
        for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)
            VAR_11++;
    }
    if (VAR_11 != 0) {
        VAR_7->sans = calloc((size_t)VAR_11+1, sizeof(*VAR_7->sans));
        if (VAR_7->sans == NULL) {
            VAR_5 = VAR_6;
            goto cleanup;
        }
        VAR_11 = 0;
        if (VAR_8 != NULL) {
            for (VAR_10 = 0; VAR_8[VAR_10] != NULL; VAR_10++)
                VAR_7->sans[VAR_11++] = VAR_8[VAR_10];
            free(VAR_8);
        }
        if (VAR_9 != NULL) {
            for (VAR_10 = 0; VAR_9[VAR_10] != NULL; VAR_10++)
                VAR_7->sans[VAR_11++] = VAR_9[VAR_10];
            free(VAR_9);
        }
        VAR_7->sans[VAR_11] = NULL;
    } else
        VAR_7->sans = NULL;

    /* COMMENT_1 */
    VAR_5 = crypto_retrieve_X509_key_usage(VAR_0, VAR_1,
                                         VAR_2, VAR_3, &VAR_7->ku_bits,
                                         &VAR_7->eku_bits);
    if (VAR_5)
        goto cleanup;

    *VAR_4 = VAR_7;
    VAR_7 = NULL;

cleanup:
    crypto_cert_free_matching_data(VAR_0, VAR_7);
    return VAR_5;
}",krb5/fbb687db1088ddd894d975996e5f6a4252b9a2b4/pkinit_crypto_openssl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,8 +8,6 @@
     pkinit_cert_matching_data *md = NULL;
     krb5_principal *pkinit_sans = NULL, *upn_sans = NULL;
     size_t i, j;
-    char buf[DN_BUF_LEN];
-    unsigned int bufsize = sizeof(buf);
 
     *md_out = NULL;
 
@@ -17,23 +15,12 @@
     if (md == NULL)
         goto cleanup;
 
-    /* Get the subject name (in rfc2253 format). */
-    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,
-                         XN_FLAG_SEP_COMMA_PLUS);
-    md->subject_dn = strdup(buf);
-    if (md->subject_dn == NULL) {
-        ret = ENOMEM;
+    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);
+    if (ret)
         goto cleanup;
-    }
-
-    /* Get the issuer name (in rfc2253 format). */
-    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,
-                         XN_FLAG_SEP_COMMA_PLUS);
-    md->issuer_dn = strdup(buf);
-    if (md->issuer_dn == NULL) {
-        ret = ENOMEM;
+    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);
+    if (ret)
         goto cleanup;
-    }
 
     /* Get the SAN data. */
     ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,","{'deleted_lines': ['    char buf[DN_BUF_LEN];', '    unsigned int bufsize = sizeof(buf);', '    /* Get the subject name (in rfc2253 format). */', '    X509_NAME_oneline_ex(X509_get_subject_name(cert), buf, &bufsize,', '                         XN_FLAG_SEP_COMMA_PLUS);', '    md->subject_dn = strdup(buf);', '    if (md->subject_dn == NULL) {', '        ret = ENOMEM;', '    }', '', '    /* Get the issuer name (in rfc2253 format). */', '    X509_NAME_oneline_ex(X509_get_issuer_name(cert), buf, &bufsize,', '                         XN_FLAG_SEP_COMMA_PLUS);', '    md->issuer_dn = strdup(buf);', '    if (md->issuer_dn == NULL) {', '        ret = ENOMEM;', '    }'], 'added_lines': ['    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);', '    if (ret)', '    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);', '    if (ret)']}",True,"plugins/preauth/pkinit/pkinit_crypto_openssl.c in MIT Kerberos 5 (aka krb5) through 1.15.2 mishandles Distinguished Name (DN) fields, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) in situations involving untrusted X.509 data, related to the get_matching_data and X509_NAME_oneline_ex functions. NOTE: this has security relevance only in use cases outside of the MIT Kerberos distribution, e.g., the use of get_matching_data in KDC certauth plugin code that is specific to Red Hat.",9.8,CRITICAL,3,test,2017-10-17T22:50:15Z,2
CVE-2018-25062,['CWE-404'],AV:A/AC:M/Au:S/C:N/I:N/A:P,0.0,flar2/ElementalX-N9,"ipsec: Fix aborted xfrm policy dump crash

An independent security researcher, Mohamed Ghannam, has reported
this vulnerability to Beyond Security's SecuriTeam Secure Disclosure
program.

The xfrm_dump_policy_done function expects xfrm_dump_policy to
have been called at least once or it will crash.  This can be
triggered if a dump fails because the target socket's receive
buffer is full.

This patch fixes it by using the cb->start mechanism to ensure that
the initialisation is always done regardless of the buffer situation.

Change-Id: Id41cdd41c4e43e0c3ac30c5d03c15b8046d70845
Fixes: 12a169e7d8f4 (""ipsec: Put dumpers on the dump list"")
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>",1df72c9f0f61304437f4f1037df03b5fb36d5a79,https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79,net/xfrm/xfrm_user.c,xfrm_dump_policy,"static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)
{
struct net *net = sock_net(skb->sk);
struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];
struct xfrm_dump_info info;
BUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >
sizeof(cb->args) - sizeof(cb->args[0]));
info.in_skb = cb->skb;
info.out_skb = skb;
info.nlmsg_seq = cb->nlh->nlmsg_seq;
info.nlmsg_flags = NLM_F_MULTI;
if (!cb->args[0]) {
cb->args[0] = 1;
xfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);
}
(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);
return skb->len;
}","static int xfrm_dump_policy(struct sk_buff *VAR_0, struct netlink_callback *VAR_1)
{
struct net *net = sock_net(VAR_0->sk);
struct xfrm_policy_walk *VAR_2 = (struct xfrm_policy_walk *) &VAR_1->args[1];
struct xfrm_dump_info VAR_3;
BUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >
sizeof(VAR_1->args) - sizeof(VAR_1->args[0]));
VAR_3.in_skb = VAR_1->skb;
VAR_3.out_skb = VAR_0;
VAR_3.nlmsg_seq = VAR_1->nlh->nlmsg_seq;
VAR_3.nlmsg_flags = VAR_4;
if (!VAR_1->args[0]) {
VAR_1->args[0] = 1;
xfrm_policy_walk_init(VAR_2, VAR_5);
}
(void) xfrm_policy_walk(net, VAR_2, VAR_6, &VAR_3);
return VAR_0->len;
}",flar2/ElementalX-N9/1df72c9f0f61304437f4f1037df03b5fb36d5a79/xfrm_user.c/vul/before/0.json,"static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct net *net = sock_net(skb->sk);
	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;
	struct xfrm_dump_info info;

	info.in_skb = cb->skb;
	info.out_skb = skb;
	info.nlmsg_seq = cb->nlh->nlmsg_seq;
	info.nlmsg_flags = NLM_F_MULTI;

	(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);

	return skb->len;
}","static int xfrm_dump_policy(struct sk_buff *VAR_0, struct netlink_callback *VAR_1)
{
	struct net *net = sock_net(VAR_0->sk);
	struct xfrm_policy_walk *VAR_2 = (struct xfrm_policy_walk *)VAR_1->args;
	struct xfrm_dump_info VAR_3;

	VAR_3.in_skb = VAR_1->skb;
	VAR_3.out_skb = VAR_0;
	VAR_3.nlmsg_seq = VAR_1->nlh->nlmsg_seq;
	VAR_3.nlmsg_flags = VAR_4;

	(void) xfrm_policy_walk(net, VAR_2, VAR_5, &VAR_3);

	return VAR_0->len;
}",flar2/ElementalX-N9/1df72c9f0f61304437f4f1037df03b5fb36d5a79/xfrm_user.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,22 +1,14 @@
 static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)
 {
 	struct net *net = sock_net(skb->sk);
-	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];
+	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;
 	struct xfrm_dump_info info;
-
-	BUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >
-		     sizeof(cb->args) - sizeof(cb->args[0]));
 
 	info.in_skb = cb->skb;
 	info.out_skb = skb;
 	info.nlmsg_seq = cb->nlh->nlmsg_seq;
 	info.nlmsg_flags = NLM_F_MULTI;
 
-	if (!cb->args[0]) {
-		cb->args[0] = 1;
-		xfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);
-	}
-
 	(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);
 
 	return skb->len;","{'deleted_lines': ['\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];', '', '\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >', '\t\t     sizeof(cb->args) - sizeof(cb->args[0]));', '\tif (!cb->args[0]) {', '\t\tcb->args[0] = 1;', '\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);', '\t}', ''], 'added_lines': ['\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;']}",True,A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152.,7.5,HIGH,2,test,2017-10-19T12:51:10Z,2
CVE-2018-25062,['CWE-404'],AV:A/AC:M/Au:S/C:N/I:N/A:P,0.0,flar2/ElementalX-N9,"ipsec: Fix aborted xfrm policy dump crash

An independent security researcher, Mohamed Ghannam, has reported
this vulnerability to Beyond Security's SecuriTeam Secure Disclosure
program.

The xfrm_dump_policy_done function expects xfrm_dump_policy to
have been called at least once or it will crash.  This can be
triggered if a dump fails because the target socket's receive
buffer is full.

This patch fixes it by using the cb->start mechanism to ensure that
the initialisation is always done regardless of the buffer situation.

Change-Id: Id41cdd41c4e43e0c3ac30c5d03c15b8046d70845
Fixes: 12a169e7d8f4 (""ipsec: Put dumpers on the dump list"")
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>",1df72c9f0f61304437f4f1037df03b5fb36d5a79,https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79,net/xfrm/xfrm_user.c,xfrm_user_rcv_msg,"static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
{
struct net *net = sock_net(skb->sk);
struct nlattr *attrs[XFRMA_MAX+1];
const struct xfrm_link *link;
int type, err;
type = nlh->nlmsg_type;
if (type > XFRM_MSG_MAX)
return -EINVAL;
type -= XFRM_MSG_BASE;
link = &xfrm_dispatch[type];
if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
return -EPERM;
if ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||
type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&
(nlh->nlmsg_flags & NLM_F_DUMP)) {
if (link->dump == NULL)
return -EINVAL;
{
struct netlink_dump_control c = {
.dump = link->dump,
.done = link->done,
};
return netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);
}
}
err = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,
xfrma_policy);
if (err < 0)
return err;
if (link->doit == NULL)
return -EINVAL;
return link->doit(skb, nlh, attrs);
}","static int xfrm_user_rcv_msg(struct sk_buff *VAR_0, struct nlmsghdr *VAR_1)
{
struct net *net = sock_net(VAR_0->sk);
struct nlattr *VAR_2[VAR_3+1];
const struct xfrm_link *VAR_4;
int VAR_5, VAR_6;
VAR_5 = VAR_1->nlmsg_type;
if (VAR_5 > VAR_7)
return -VAR_8;
VAR_5 -= VAR_9;
VAR_4 = &VAR_10[VAR_5];
if (!ns_capable(net->user_ns, VAR_11))
return -VAR_12;
if ((VAR_5 == (VAR_13 - VAR_9) ||
VAR_5 == (VAR_14 - VAR_9)) &&
(VAR_1->nlmsg_flags & VAR_15)) {
if (VAR_4->dump == NULL)
return -VAR_8;
{
struct netlink_dump_control VAR_16 = {
.dump = VAR_4->dump,
.done = VAR_4->done,
};
return netlink_dump_start(net->xfrm.nlsk, VAR_0, VAR_1, &VAR_16);
}
}
VAR_6 = nlmsg_parse(VAR_1, VAR_17[VAR_5], VAR_2, VAR_3,
VAR_18);
if (VAR_6 < 0)
return VAR_6;
if (VAR_4->doit == NULL)
return -VAR_8;
return VAR_4->doit(VAR_0, VAR_1, VAR_2);
}",flar2/ElementalX-N9/1df72c9f0f61304437f4f1037df03b5fb36d5a79/xfrm_user.c/vul/before/2.json,"static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct nlattr *attrs[XFRMA_MAX+1];
	const struct xfrm_link *link;
	int type, err;

	type = nlh->nlmsg_type;
	if (type > XFRM_MSG_MAX)
		return -EINVAL;

	type -= XFRM_MSG_BASE;
	link = &xfrm_dispatch[type];

	/* All operations require privileges, even GET */
	if (!ns_capable(net->user_ns, CAP_NET_ADMIN))
		return -EPERM;

	if ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||
	     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&
	    (nlh->nlmsg_flags & NLM_F_DUMP)) {
		if (link->dump == NULL)
			return -EINVAL;

		{
			struct netlink_dump_control c = {
				.start = link->start,
				.dump = link->dump,
				.done = link->done,
			};
			return netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);
		}
	}

	err = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,
			  xfrma_policy);
	if (err < 0)
		return err;

	if (link->doit == NULL)
		return -EINVAL;

	return link->doit(skb, nlh, attrs);
}","static int xfrm_user_rcv_msg(struct sk_buff *VAR_0, struct nlmsghdr *VAR_1)
{
	struct net *net = sock_net(VAR_0->sk);
	struct nlattr *VAR_2[VAR_3+1];
	const struct xfrm_link *VAR_4;
	int VAR_5, VAR_6;

	VAR_5 = VAR_1->nlmsg_type;
	if (VAR_5 > VAR_7)
		return -VAR_8;

	VAR_5 -= VAR_9;
	VAR_4 = &VAR_10[VAR_5];

	/* COMMENT_0 */
	if (!ns_capable(net->user_ns, VAR_11))
		return -VAR_12;

	if ((VAR_5 == (VAR_13 - VAR_9) ||
	     VAR_5 == (VAR_14 - VAR_9)) &&
	    (VAR_1->nlmsg_flags & VAR_15)) {
		if (VAR_4->dump == NULL)
			return -VAR_8;

		{
			struct netlink_dump_control VAR_16 = {
				.start = VAR_4->start,
				.dump = VAR_4->dump,
				.done = VAR_4->done,
			};
			return netlink_dump_start(net->xfrm.nlsk, VAR_0, VAR_1, &VAR_16);
		}
	}

	VAR_6 = nlmsg_parse(VAR_1, VAR_17[VAR_5], VAR_2, VAR_3,
			  VAR_18);
	if (VAR_6 < 0)
		return VAR_6;

	if (VAR_4->doit == NULL)
		return -VAR_8;

	return VAR_4->doit(VAR_0, VAR_1, VAR_2);
}",flar2/ElementalX-N9/1df72c9f0f61304437f4f1037df03b5fb36d5a79/xfrm_user.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -24,6 +24,7 @@
 
 		{
 			struct netlink_dump_control c = {
+				.start = link->start,
 				.dump = link->dump,
 				.done = link->done,
 			};","{'deleted_lines': [], 'added_lines': ['\t\t\t\t.start = link->start,']}",True,A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152.,7.5,HIGH,2,test,2017-10-19T12:51:10Z,2
CVE-2018-25062,['CWE-404'],AV:A/AC:M/Au:S/C:N/I:N/A:P,0.0,flar2/ElementalX-N9,"ipsec: Fix aborted xfrm policy dump crash

An independent security researcher, Mohamed Ghannam, has reported
this vulnerability to Beyond Security's SecuriTeam Secure Disclosure
program.

The xfrm_dump_policy_done function expects xfrm_dump_policy to
have been called at least once or it will crash.  This can be
triggered if a dump fails because the target socket's receive
buffer is full.

This patch fixes it by using the cb->start mechanism to ensure that
the initialisation is always done regardless of the buffer situation.

Change-Id: Id41cdd41c4e43e0c3ac30c5d03c15b8046d70845
Fixes: 12a169e7d8f4 (""ipsec: Put dumpers on the dump list"")
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>",1df72c9f0f61304437f4f1037df03b5fb36d5a79,https://github.com/flar2/ElementalX-N9/commit/1df72c9f0f61304437f4f1037df03b5fb36d5a79,net/xfrm/xfrm_user.c,xfrm_dump_policy_done,"static int xfrm_dump_policy_done(struct netlink_callback *cb)
{
struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];
xfrm_policy_walk_done(walk);
return 0;
}","static int xfrm_dump_policy_done(struct netlink_callback *VAR_0)
{
struct xfrm_policy_walk *VAR_1 = (struct xfrm_policy_walk *) &VAR_0->args[1];
xfrm_policy_walk_done(VAR_1);
return 0;
}",flar2/ElementalX-N9/1df72c9f0f61304437f4f1037df03b5fb36d5a79/xfrm_user.c/vul/before/1.json,"static int xfrm_dump_policy_done(struct netlink_callback *cb)
{
	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;

	xfrm_policy_walk_done(walk);
	return 0;
}","static int xfrm_dump_policy_done(struct netlink_callback *VAR_0)
{
	struct xfrm_policy_walk *VAR_1 = (struct xfrm_policy_walk *)VAR_0->args;

	xfrm_policy_walk_done(VAR_1);
	return 0;
}",flar2/ElementalX-N9/1df72c9f0f61304437f4f1037df03b5fb36d5a79/xfrm_user.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int xfrm_dump_policy_done(struct netlink_callback *cb)
 {
-	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];
+	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;
 
 	xfrm_policy_walk_done(walk);
 	return 0;","{'deleted_lines': ['\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];'], 'added_lines': ['\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;']}",True,A vulnerability classified as problematic has been found in flar2 ElementalX up to 6.x on Nexus 9. Affected is the function xfrm_dump_policy_done of the file net/xfrm/xfrm_user.c of the component ipsec. The manipulation leads to denial of service. Upgrading to version 7.00 is able to address this issue. The name of the patch is 1df72c9f0f61304437f4f1037df03b5fb36d5a79. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-217152.,7.5,HIGH,2,test,2017-10-19T12:51:10Z,2
CVE-2017-16643,['CWE-125'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"Input: gtco - fix potential out-of-bound access

parse_hid_report_descriptor() has a while (i < length) loop, which
only guarantees that there's at least 1 byte in the buffer, but the
loop body can read multiple bytes which causes out-of-bounds access.

Reported-by: Andrey Konovalov <andreyknvl@google.com>
Reviewed-by: Andrey Konovalov <andreyknvl@google.com>
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",a50829479f58416a013a4ccca791336af3c584c7,https://github.com/torvalds/linux/commit/a50829479f58416a013a4ccca791336af3c584c7,drivers/input/tablet/gtco.c,parse_hid_report_descriptor,"static void parse_hid_report_descriptor(struct gtco *device, char * report,
int length)
{
struct device *ddev = &device->intf->dev;
int   x, i = 0;
__u8   prefix;
__u8   size;
__u8   tag;
__u8   type;
__u8   data   = 0;
__u16  data16 = 0;
__u32  data32 = 0;
int   inputnum = 0;
__u32 usage = 0;
__u32 globalval[TAG_GLOB_MAX];
__u32 oldval[TAG_GLOB_MAX];
char  maintype = 'x';
char  globtype[12];
int   indent = 0;
char  indentstr[10] = """";
dev_dbg(ddev, ""======>>>>>>PARSE<<<<<<======\n"");
while (i < length) {
prefix = report[i];
i++;
size = PREF_SIZE(prefix);
switch (size) {
case 1:
data = report[i];
break;
case 2:
data16 = get_unaligned_le16(&report[i]);
break;
case 3:
size = 4;
data32 = get_unaligned_le32(&report[i]);
break;
}
i += size;
tag  = PREF_TAG(prefix);
type = PREF_TYPE(prefix);
switch (type) {
case TYPE_MAIN:
strcpy(globtype, """");
switch (tag) {
case TAG_MAIN_INPUT:
maintype = 'I';
if (data == 2)
strcpy(globtype, ""Variable"");
else if (data == 3)
strcpy(globtype, ""Var|Const"");
dev_dbg(ddev, ""::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\n"",
globalval[TAG_GLOB_REPORT_ID], inputnum,
globalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],
globalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],
globalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);
switch (inputnum) {
case 0:  
dev_dbg(ddev, ""GER: X Usage: 0x%x\n"", usage);
if (device->max_X == 0) {
device->max_X = globalval[TAG_GLOB_LOG_MAX];
device->min_X = globalval[TAG_GLOB_LOG_MIN];
}
break;
case 1:  
dev_dbg(ddev, ""GER: Y Usage: 0x%x\n"", usage);
if (device->max_Y == 0) {
device->max_Y = globalval[TAG_GLOB_LOG_MAX];
device->min_Y = globalval[TAG_GLOB_LOG_MIN];
}
break;
default:
if (usage == DIGITIZER_USAGE_TILT_X) {
if (device->maxtilt_X == 0) {
device->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];
device->mintilt_X = globalval[TAG_GLOB_LOG_MIN];
}
}
if (usage == DIGITIZER_USAGE_TILT_Y) {
if (device->maxtilt_Y == 0) {
device->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];
device->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];
}
}
if (usage == DIGITIZER_USAGE_TIP_PRESSURE) {
if (device->maxpressure == 0) {
device->maxpressure = globalval[TAG_GLOB_LOG_MAX];
device->minpressure = globalval[TAG_GLOB_LOG_MIN];
}
}
break;
}
inputnum++;
break;
case TAG_MAIN_OUTPUT:
maintype = 'O';
break;
case TAG_MAIN_FEATURE:
maintype = 'F';
break;
case TAG_MAIN_COL_START:
maintype = 'S';
if (data == 0) {
dev_dbg(ddev, ""======>>>>>> Physical\n"");
strcpy(globtype, ""Physical"");
} else
dev_dbg(ddev, ""======>>>>>>\n"");
indent++;
for (x = 0; x < indent; x++)
indentstr[x] = '-';
indentstr[x] = 0;
for (x = 0; x < TAG_GLOB_MAX; x++)
oldval[x] = globalval[x];
break;
case TAG_MAIN_COL_END:
dev_dbg(ddev, ""<<<<<<======\n"");
maintype = 'E';
indent--;
for (x = 0; x < indent; x++)
indentstr[x] = '-';
indentstr[x] = 0;
for (x = 0; x < TAG_GLOB_MAX; x++)
globalval[x] = oldval[x];
break;
}
switch (size) {
case 1:
dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
indentstr, tag, maintype, size, globtype, data);
break;
case 2:
dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
indentstr, tag, maintype, size, globtype, data16);
break;
case 4:
dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
indentstr, tag, maintype, size, globtype, data32);
break;
}
break;
case TYPE_GLOBAL:
switch (tag) {
case TAG_GLOB_USAGE:
if (device->usage == 0)
device->usage = data;
strcpy(globtype, ""USAGE"");
break;
case TAG_GLOB_LOG_MIN:
strcpy(globtype, ""LOG_MIN"");
break;
case TAG_GLOB_LOG_MAX:
strcpy(globtype, ""LOG_MAX"");
break;
case TAG_GLOB_PHYS_MIN:
strcpy(globtype, ""PHYS_MIN"");
break;
case TAG_GLOB_PHYS_MAX:
strcpy(globtype, ""PHYS_MAX"");
break;
case TAG_GLOB_UNIT_EXP:
strcpy(globtype, ""EXP"");
break;
case TAG_GLOB_UNIT:
strcpy(globtype, ""UNIT"");
break;
case TAG_GLOB_REPORT_SZ:
strcpy(globtype, ""REPORT_SZ"");
break;
case TAG_GLOB_REPORT_ID:
strcpy(globtype, ""REPORT_ID"");
inputnum = 0;
break;
case TAG_GLOB_REPORT_CNT:
strcpy(globtype, ""REPORT_CNT"");
break;
case TAG_GLOB_PUSH:
strcpy(globtype, ""PUSH"");
break;
case TAG_GLOB_POP:
strcpy(globtype, ""POP"");
break;
}
if (tag < TAG_GLOB_MAX) {
switch (size) {
case 1:
dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
indentstr, globtype, tag, size, data);
globalval[tag] = data;
break;
case 2:
dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
indentstr, globtype, tag, size, data16);
globalval[tag] = data16;
break;
case 4:
dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
indentstr, globtype, tag, size, data32);
globalval[tag] = data32;
break;
}
} else {
dev_dbg(ddev, ""%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\n"",
indentstr, tag, size);
}
break;
case TYPE_LOCAL:
switch (tag) {
case TAG_GLOB_USAGE:
strcpy(globtype, ""USAGE"");
usage = data;
break;
case TAG_GLOB_LOG_MIN:
strcpy(globtype, ""MIN"");
break;
case TAG_GLOB_LOG_MAX:
strcpy(globtype, ""MAX"");
break;
default:
strcpy(globtype, ""UNKNOWN"");
break;
}
switch (size) {
case 1:
dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
indentstr, tag, globtype, size, data);
break;
case 2:
dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
indentstr, tag, globtype, size, data16);
break;
case 4:
dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
indentstr, tag, globtype, size, data32);
break;
}
break;
}
}
}","static void parse_hid_report_descriptor(struct gtco *VAR_0, char * VAR_1,
int VAR_2)
{
struct device *VAR_3 = &device->intf->dev;
int   VAR_4, VAR_5 = 0;
__u8   VAR_6;
__u8   VAR_7;
__u8   VAR_8;
__u8   VAR_9;
__u8   VAR_10   = 0;
__u16  VAR_11 = 0;
__u32  VAR_12 = 0;
int   VAR_13 = 0;
__u32 VAR_14 = 0;
__u32 VAR_15[VAR_16];
__u32 VAR_17[VAR_16];
char  VAR_18 = 'x';
char  VAR_19[12];
int   VAR_20 = 0;
char  VAR_21[10] = """";
dev_dbg(VAR_3, ""======>>>>>>PARSE<<<<<<======\n"");
while (VAR_5 < VAR_2) {
VAR_6 = VAR_1[VAR_5];
VAR_5++;
VAR_7 = PREF_SIZE(VAR_6);
switch (VAR_7) {
case 1:
VAR_10 = VAR_1[VAR_5];
break;
case 2:
VAR_11 = get_unaligned_le16(&VAR_1[VAR_5]);
break;
case 3:
VAR_7 = 4;
VAR_12 = get_unaligned_le32(&VAR_1[VAR_5]);
break;
}
VAR_5 += VAR_7;
VAR_8  = PREF_TAG(VAR_6);
VAR_9 = PREF_TYPE(VAR_6);
switch (VAR_9) {
case VAR_22:
strcpy(VAR_19, """");
switch (VAR_8) {
case VAR_23:
VAR_18 = 'I';
if (VAR_10 == 2)
strcpy(VAR_19, ""Variable"");
else if (VAR_10 == 3)
strcpy(VAR_19, ""Var|Const"");
dev_dbg(VAR_3, ""::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\n"",
VAR_15[VAR_24], VAR_13,
VAR_15[VAR_25], VAR_15[VAR_25],
VAR_15[VAR_26], VAR_15[VAR_26],
VAR_15[VAR_27] * VAR_15[VAR_28]);
switch (VAR_13) {
case 0:  
dev_dbg(VAR_3, ""GER: X Usage: 0x%x\n"", VAR_14);
if (device->max_X == 0) {
device->max_X = VAR_15[VAR_25];
device->min_X = VAR_15[VAR_26];
}
break;
case 1:  
dev_dbg(VAR_3, ""GER: Y Usage: 0x%x\n"", VAR_14);
if (device->max_Y == 0) {
device->max_Y = VAR_15[VAR_25];
device->min_Y = VAR_15[VAR_26];
}
break;
default:
if (VAR_14 == VAR_29) {
if (device->maxtilt_X == 0) {
device->maxtilt_X = VAR_15[VAR_25];
device->mintilt_X = VAR_15[VAR_26];
}
}
if (VAR_14 == VAR_30) {
if (device->maxtilt_Y == 0) {
device->maxtilt_Y = VAR_15[VAR_25];
device->mintilt_Y = VAR_15[VAR_26];
}
}
if (VAR_14 == VAR_31) {
if (device->maxpressure == 0) {
device->maxpressure = VAR_15[VAR_25];
device->minpressure = VAR_15[VAR_26];
}
}
break;
}
VAR_13++;
break;
case VAR_32:
VAR_18 = 'O';
break;
case VAR_33:
VAR_18 = 'F';
break;
case VAR_34:
VAR_18 = 'S';
if (VAR_10 == 0) {
dev_dbg(VAR_3, ""======>>>>>> Physical\n"");
strcpy(VAR_19, ""Physical"");
} else
dev_dbg(VAR_3, ""======>>>>>>\n"");
VAR_20++;
for (VAR_4 = 0; VAR_4 < VAR_20; VAR_4++)
VAR_21[VAR_4] = '-';
VAR_21[VAR_4] = 0;
for (VAR_4 = 0; VAR_4 < VAR_16; VAR_4++)
VAR_17[VAR_4] = VAR_15[VAR_4];
break;
case VAR_35:
dev_dbg(VAR_3, ""<<<<<<======\n"");
VAR_18 = 'E';
VAR_20--;
for (VAR_4 = 0; VAR_4 < VAR_20; VAR_4++)
VAR_21[VAR_4] = '-';
VAR_21[VAR_4] = 0;
for (VAR_4 = 0; VAR_4 < VAR_16; VAR_4++)
VAR_15[VAR_4] = VAR_17[VAR_4];
break;
}
switch (VAR_7) {
case 1:
dev_dbg(VAR_3, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
VAR_21, VAR_8, VAR_18, VAR_7, VAR_19, VAR_10);
break;
case 2:
dev_dbg(VAR_3, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
VAR_21, VAR_8, VAR_18, VAR_7, VAR_19, VAR_11);
break;
case 4:
dev_dbg(VAR_3, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
VAR_21, VAR_8, VAR_18, VAR_7, VAR_19, VAR_12);
break;
}
break;
case VAR_36:
switch (VAR_8) {
case VAR_37:
if (device->usage == 0)
device->usage = VAR_10;
strcpy(VAR_19, ""USAGE"");
break;
case VAR_26:
strcpy(VAR_19, ""LOG_MIN"");
break;
case VAR_25:
strcpy(VAR_19, ""LOG_MAX"");
break;
case VAR_38:
strcpy(VAR_19, ""PHYS_MIN"");
break;
case VAR_39:
strcpy(VAR_19, ""PHYS_MAX"");
break;
case VAR_40:
strcpy(VAR_19, ""EXP"");
break;
case VAR_41:
strcpy(VAR_19, ""UNIT"");
break;
case VAR_27:
strcpy(VAR_19, ""REPORT_SZ"");
break;
case VAR_24:
strcpy(VAR_19, ""REPORT_ID"");
VAR_13 = 0;
break;
case VAR_28:
strcpy(VAR_19, ""REPORT_CNT"");
break;
case VAR_42:
strcpy(VAR_19, ""PUSH"");
break;
case VAR_43:
strcpy(VAR_19, ""POP"");
break;
}
if (VAR_8 < VAR_16) {
switch (VAR_7) {
case 1:
dev_dbg(VAR_3, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
VAR_21, VAR_19, VAR_8, VAR_7, VAR_10);
VAR_15[VAR_8] = VAR_10;
break;
case 2:
dev_dbg(VAR_3, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
VAR_21, VAR_19, VAR_8, VAR_7, VAR_11);
VAR_15[VAR_8] = VAR_11;
break;
case 4:
dev_dbg(VAR_3, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
VAR_21, VAR_19, VAR_8, VAR_7, VAR_12);
VAR_15[VAR_8] = VAR_12;
break;
}
} else {
dev_dbg(VAR_3, ""%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\n"",
VAR_21, VAR_8, VAR_7);
}
break;
case VAR_44:
switch (VAR_8) {
case VAR_37:
strcpy(VAR_19, ""USAGE"");
VAR_14 = VAR_10;
break;
case VAR_26:
strcpy(VAR_19, ""MIN"");
break;
case VAR_25:
strcpy(VAR_19, ""MAX"");
break;
default:
strcpy(VAR_19, ""UNKNOWN"");
break;
}
switch (VAR_7) {
case 1:
dev_dbg(VAR_3, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
VAR_21, VAR_8, VAR_19, VAR_7, VAR_10);
break;
case 2:
dev_dbg(VAR_3, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
VAR_21, VAR_8, VAR_19, VAR_7, VAR_11);
break;
case 4:
dev_dbg(VAR_3, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
VAR_21, VAR_8, VAR_19, VAR_7, VAR_12);
break;
}
break;
}
}
}",torvalds/linux/a50829479f58416a013a4ccca791336af3c584c7/gtco.c/vul/before/0.json,"static void parse_hid_report_descriptor(struct gtco *device, char * report,
					int length)
{
	struct device *ddev = &device->intf->dev;
	int   x, i = 0;

	/* Tag primitive vars */
	__u8   prefix;
	__u8   size;
	__u8   tag;
	__u8   type;
	__u8   data   = 0;
	__u16  data16 = 0;
	__u32  data32 = 0;

	/* For parsing logic */
	int   inputnum = 0;
	__u32 usage = 0;

	/* Global Values, indexed by TAG */
	__u32 globalval[TAG_GLOB_MAX];
	__u32 oldval[TAG_GLOB_MAX];

	/* Debug stuff */
	char  maintype = 'x';
	char  globtype[12];
	int   indent = 0;
	char  indentstr[10] = """";


	dev_dbg(ddev, ""======>>>>>>PARSE<<<<<<======\n"");

	/* Walk  this report and pull out the info we need */
	while (i < length) {
		prefix = report[i++];

		/* Determine data size and save the data in the proper variable */
		size = (1U << PREF_SIZE(prefix)) >> 1;
		if (i + size > length) {
			dev_err(ddev,
				""Not enough data (need %d, have %d)\n"",
				i + size, length);
			break;
		}

		switch (size) {
		case 1:
			data = report[i];
			break;
		case 2:
			data16 = get_unaligned_le16(&report[i]);
			break;
		case 4:
			data32 = get_unaligned_le32(&report[i]);
			break;
		}

		/* Skip size of data */
		i += size;

		/* What we do depends on the tag type */
		tag  = PREF_TAG(prefix);
		type = PREF_TYPE(prefix);
		switch (type) {
		case TYPE_MAIN:
			strcpy(globtype, """");
			switch (tag) {

			case TAG_MAIN_INPUT:
				/*
				 * The INPUT MAIN tag signifies this is
				 * information from a report.  We need to
				 * figure out what it is and store the
				 * min/max values
				 */

				maintype = 'I';
				if (data == 2)
					strcpy(globtype, ""Variable"");
				else if (data == 3)
					strcpy(globtype, ""Var|Const"");

				dev_dbg(ddev, ""::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\n"",
					globalval[TAG_GLOB_REPORT_ID], inputnum,
					globalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],
					globalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],
					globalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);


				/*
				  We can assume that the first two input items
				  are always the X and Y coordinates.  After
				  that, we look for everything else by
				  local usage value
				 */
				switch (inputnum) {
				case 0:  /* X coord */
					dev_dbg(ddev, ""GER: X Usage: 0x%x\n"", usage);
					if (device->max_X == 0) {
						device->max_X = globalval[TAG_GLOB_LOG_MAX];
						device->min_X = globalval[TAG_GLOB_LOG_MIN];
					}
					break;

				case 1:  /* Y coord */
					dev_dbg(ddev, ""GER: Y Usage: 0x%x\n"", usage);
					if (device->max_Y == 0) {
						device->max_Y = globalval[TAG_GLOB_LOG_MAX];
						device->min_Y = globalval[TAG_GLOB_LOG_MIN];
					}
					break;

				default:
					/* Tilt X */
					if (usage == DIGITIZER_USAGE_TILT_X) {
						if (device->maxtilt_X == 0) {
							device->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];
							device->mintilt_X = globalval[TAG_GLOB_LOG_MIN];
						}
					}

					/* Tilt Y */
					if (usage == DIGITIZER_USAGE_TILT_Y) {
						if (device->maxtilt_Y == 0) {
							device->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];
							device->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];
						}
					}

					/* Pressure */
					if (usage == DIGITIZER_USAGE_TIP_PRESSURE) {
						if (device->maxpressure == 0) {
							device->maxpressure = globalval[TAG_GLOB_LOG_MAX];
							device->minpressure = globalval[TAG_GLOB_LOG_MIN];
						}
					}

					break;
				}

				inputnum++;
				break;

			case TAG_MAIN_OUTPUT:
				maintype = 'O';
				break;

			case TAG_MAIN_FEATURE:
				maintype = 'F';
				break;

			case TAG_MAIN_COL_START:
				maintype = 'S';

				if (data == 0) {
					dev_dbg(ddev, ""======>>>>>> Physical\n"");
					strcpy(globtype, ""Physical"");
				} else
					dev_dbg(ddev, ""======>>>>>>\n"");

				/* Indent the debug output */
				indent++;
				for (x = 0; x < indent; x++)
					indentstr[x] = '-';
				indentstr[x] = 0;

				/* Save global tags */
				for (x = 0; x < TAG_GLOB_MAX; x++)
					oldval[x] = globalval[x];

				break;

			case TAG_MAIN_COL_END:
				dev_dbg(ddev, ""<<<<<<======\n"");
				maintype = 'E';
				indent--;
				for (x = 0; x < indent; x++)
					indentstr[x] = '-';
				indentstr[x] = 0;

				/* Copy global tags back */
				for (x = 0; x < TAG_GLOB_MAX; x++)
					globalval[x] = oldval[x];

				break;
			}

			switch (size) {
			case 1:
				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
					indentstr, tag, maintype, size, globtype, data);
				break;

			case 2:
				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
					indentstr, tag, maintype, size, globtype, data16);
				break;

			case 4:
				dev_dbg(ddev, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
					indentstr, tag, maintype, size, globtype, data32);
				break;
			}
			break;

		case TYPE_GLOBAL:
			switch (tag) {
			case TAG_GLOB_USAGE:
				/*
				 * First time we hit the global usage tag,
				 * it should tell us the type of device
				 */
				if (device->usage == 0)
					device->usage = data;

				strcpy(globtype, ""USAGE"");
				break;

			case TAG_GLOB_LOG_MIN:
				strcpy(globtype, ""LOG_MIN"");
				break;

			case TAG_GLOB_LOG_MAX:
				strcpy(globtype, ""LOG_MAX"");
				break;

			case TAG_GLOB_PHYS_MIN:
				strcpy(globtype, ""PHYS_MIN"");
				break;

			case TAG_GLOB_PHYS_MAX:
				strcpy(globtype, ""PHYS_MAX"");
				break;

			case TAG_GLOB_UNIT_EXP:
				strcpy(globtype, ""EXP"");
				break;

			case TAG_GLOB_UNIT:
				strcpy(globtype, ""UNIT"");
				break;

			case TAG_GLOB_REPORT_SZ:
				strcpy(globtype, ""REPORT_SZ"");
				break;

			case TAG_GLOB_REPORT_ID:
				strcpy(globtype, ""REPORT_ID"");
				/* New report, restart numbering */
				inputnum = 0;
				break;

			case TAG_GLOB_REPORT_CNT:
				strcpy(globtype, ""REPORT_CNT"");
				break;

			case TAG_GLOB_PUSH:
				strcpy(globtype, ""PUSH"");
				break;

			case TAG_GLOB_POP:
				strcpy(globtype, ""POP"");
				break;
			}

			/* Check to make sure we have a good tag number
			   so we don't overflow array */
			if (tag < TAG_GLOB_MAX) {
				switch (size) {
				case 1:
					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
						indentstr, globtype, tag, size, data);
					globalval[tag] = data;
					break;

				case 2:
					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
						indentstr, globtype, tag, size, data16);
					globalval[tag] = data16;
					break;

				case 4:
					dev_dbg(ddev, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
						indentstr, globtype, tag, size, data32);
					globalval[tag] = data32;
					break;
				}
			} else {
				dev_dbg(ddev, ""%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\n"",
					indentstr, tag, size);
			}
			break;

		case TYPE_LOCAL:
			switch (tag) {
			case TAG_GLOB_USAGE:
				strcpy(globtype, ""USAGE"");
				/* Always 1 byte */
				usage = data;
				break;

			case TAG_GLOB_LOG_MIN:
				strcpy(globtype, ""MIN"");
				break;

			case TAG_GLOB_LOG_MAX:
				strcpy(globtype, ""MAX"");
				break;

			default:
				strcpy(globtype, ""UNKNOWN"");
				break;
			}

			switch (size) {
			case 1:
				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
					indentstr, tag, globtype, size, data);
				break;

			case 2:
				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
					indentstr, tag, globtype, size, data16);
				break;

			case 4:
				dev_dbg(ddev, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
					indentstr, tag, globtype, size, data32);
				break;
			}

			break;
		}
	}
}","static void parse_hid_report_descriptor(struct gtco *VAR_0, char * VAR_1,
					int VAR_2)
{
	struct device *VAR_3 = &device->intf->dev;
	int   VAR_4, VAR_5 = 0;

	/* COMMENT_0 */
	__u8   VAR_6;
	__u8   VAR_7;
	__u8   VAR_8;
	__u8   VAR_9;
	__u8   VAR_10   = 0;
	__u16  VAR_11 = 0;
	__u32  VAR_12 = 0;

	/* COMMENT_1 */
	int   VAR_13 = 0;
	__u32 VAR_14 = 0;

	/* COMMENT_2 */
	__u32 VAR_15[VAR_16];
	__u32 VAR_17[VAR_16];

	/* COMMENT_3 */
	char  VAR_18 = 'x';
	char  VAR_19[12];
	int   VAR_20 = 0;
	char  VAR_21[10] = """";


	dev_dbg(VAR_3, ""======>>>>>>PARSE<<<<<<======\n"");

	/* COMMENT_4 */
	while (VAR_5 < VAR_2) {
		VAR_6 = VAR_1[VAR_5++];

		/* COMMENT_5 */
		VAR_7 = (1U << PREF_SIZE(VAR_6)) >> 1;
		if (VAR_5 + VAR_7 > VAR_2) {
			dev_err(VAR_3,
				""Not enough data (need %d, have %d)\n"",
				VAR_5 + VAR_7, VAR_2);
			break;
		}

		switch (VAR_7) {
		case 1:
			VAR_10 = VAR_1[VAR_5];
			break;
		case 2:
			VAR_11 = get_unaligned_le16(&VAR_1[VAR_5]);
			break;
		case 4:
			VAR_12 = get_unaligned_le32(&VAR_1[VAR_5]);
			break;
		}

		/* COMMENT_6 */
		VAR_5 += VAR_7;

		/* COMMENT_7 */
		VAR_8  = PREF_TAG(VAR_6);
		VAR_9 = PREF_TYPE(VAR_6);
		switch (VAR_9) {
		case VAR_22:
			strcpy(VAR_19, """");
			switch (VAR_8) {

			case VAR_23:
				/* COMMENT_8 */
                                           
                                             
                                          
                     
       

				VAR_18 = 'I';
				if (VAR_10 == 2)
					strcpy(VAR_19, ""Variable"");
				else if (VAR_10 == 3)
					strcpy(VAR_19, ""Var|Const"");

				dev_dbg(VAR_3, ""::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\n"",
					VAR_15[VAR_24], VAR_13,
					VAR_15[VAR_25], VAR_15[VAR_25],
					VAR_15[VAR_26], VAR_15[VAR_26],
					VAR_15[VAR_27] * VAR_15[VAR_28]);


				/* COMMENT_14 */
                                                  
                                                
                                          
                       
       
				switch (VAR_13) {
				case 0:  /* COMMENT_20 */
					dev_dbg(VAR_3, ""GER: X Usage: 0x%x\n"", VAR_14);
					if (device->max_X == 0) {
						device->max_X = VAR_15[VAR_25];
						device->min_X = VAR_15[VAR_26];
					}
					break;

				case 1:  /* COMMENT_21 */
					dev_dbg(VAR_3, ""GER: Y Usage: 0x%x\n"", VAR_14);
					if (device->max_Y == 0) {
						device->max_Y = VAR_15[VAR_25];
						device->min_Y = VAR_15[VAR_26];
					}
					break;

				default:
					/* COMMENT_22 */
					if (VAR_14 == VAR_29) {
						if (device->maxtilt_X == 0) {
							device->maxtilt_X = VAR_15[VAR_25];
							device->mintilt_X = VAR_15[VAR_26];
						}
					}

					/* COMMENT_23 */
					if (VAR_14 == VAR_30) {
						if (device->maxtilt_Y == 0) {
							device->maxtilt_Y = VAR_15[VAR_25];
							device->mintilt_Y = VAR_15[VAR_26];
						}
					}

					/* COMMENT_24 */
					if (VAR_14 == VAR_31) {
						if (device->maxpressure == 0) {
							device->maxpressure = VAR_15[VAR_25];
							device->minpressure = VAR_15[VAR_26];
						}
					}

					break;
				}

				VAR_13++;
				break;

			case VAR_32:
				VAR_18 = 'O';
				break;

			case VAR_33:
				VAR_18 = 'F';
				break;

			case VAR_34:
				VAR_18 = 'S';

				if (VAR_10 == 0) {
					dev_dbg(VAR_3, ""======>>>>>> Physical\n"");
					strcpy(VAR_19, ""Physical"");
				} else
					dev_dbg(VAR_3, ""======>>>>>>\n"");

				/* COMMENT_25 */
				VAR_20++;
				for (VAR_4 = 0; VAR_4 < VAR_20; VAR_4++)
					VAR_21[VAR_4] = '-';
				VAR_21[VAR_4] = 0;

				/* COMMENT_26 */
				for (VAR_4 = 0; VAR_4 < VAR_16; VAR_4++)
					VAR_17[VAR_4] = VAR_15[VAR_4];

				break;

			case VAR_35:
				dev_dbg(VAR_3, ""<<<<<<======\n"");
				VAR_18 = 'E';
				VAR_20--;
				for (VAR_4 = 0; VAR_4 < VAR_20; VAR_4++)
					VAR_21[VAR_4] = '-';
				VAR_21[VAR_4] = 0;

				/* COMMENT_27 */
				for (VAR_4 = 0; VAR_4 < VAR_16; VAR_4++)
					VAR_15[VAR_4] = VAR_17[VAR_4];

				break;
			}

			switch (VAR_7) {
			case 1:
				dev_dbg(VAR_3, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
					VAR_21, VAR_8, VAR_18, VAR_7, VAR_19, VAR_10);
				break;

			case 2:
				dev_dbg(VAR_3, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
					VAR_21, VAR_8, VAR_18, VAR_7, VAR_19, VAR_11);
				break;

			case 4:
				dev_dbg(VAR_3, ""%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\n"",
					VAR_21, VAR_8, VAR_18, VAR_7, VAR_19, VAR_12);
				break;
			}
			break;

		case VAR_36:
			switch (VAR_8) {
			case VAR_37:
				/* COMMENT_28 */
                                              
                                           
       
				if (device->usage == 0)
					device->usage = VAR_10;

				strcpy(VAR_19, ""USAGE"");
				break;

			case VAR_26:
				strcpy(VAR_19, ""LOG_MIN"");
				break;

			case VAR_25:
				strcpy(VAR_19, ""LOG_MAX"");
				break;

			case VAR_38:
				strcpy(VAR_19, ""PHYS_MIN"");
				break;

			case VAR_39:
				strcpy(VAR_19, ""PHYS_MAX"");
				break;

			case VAR_40:
				strcpy(VAR_19, ""EXP"");
				break;

			case VAR_41:
				strcpy(VAR_19, ""UNIT"");
				break;

			case VAR_27:
				strcpy(VAR_19, ""REPORT_SZ"");
				break;

			case VAR_24:
				strcpy(VAR_19, ""REPORT_ID"");
				/* COMMENT_32 */
				VAR_13 = 0;
				break;

			case VAR_28:
				strcpy(VAR_19, ""REPORT_CNT"");
				break;

			case VAR_42:
				strcpy(VAR_19, ""PUSH"");
				break;

			case VAR_43:
				strcpy(VAR_19, ""POP"");
				break;
			}

			/* COMMENT_33 */
                                   
			if (VAR_8 < VAR_16) {
				switch (VAR_7) {
				case 1:
					dev_dbg(VAR_3, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
						VAR_21, VAR_19, VAR_8, VAR_7, VAR_10);
					VAR_15[VAR_8] = VAR_10;
					break;

				case 2:
					dev_dbg(VAR_3, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
						VAR_21, VAR_19, VAR_8, VAR_7, VAR_11);
					VAR_15[VAR_8] = VAR_11;
					break;

				case 4:
					dev_dbg(VAR_3, ""%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\n"",
						VAR_21, VAR_19, VAR_8, VAR_7, VAR_12);
					VAR_15[VAR_8] = VAR_12;
					break;
				}
			} else {
				dev_dbg(VAR_3, ""%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\n"",
					VAR_21, VAR_8, VAR_7);
			}
			break;

		case VAR_44:
			switch (VAR_8) {
			case VAR_37:
				strcpy(VAR_19, ""USAGE"");
				/* COMMENT_35 */
				VAR_14 = VAR_10;
				break;

			case VAR_26:
				strcpy(VAR_19, ""MIN"");
				break;

			case VAR_25:
				strcpy(VAR_19, ""MAX"");
				break;

			default:
				strcpy(VAR_19, ""UNKNOWN"");
				break;
			}

			switch (VAR_7) {
			case 1:
				dev_dbg(VAR_3, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
					VAR_21, VAR_8, VAR_19, VAR_7, VAR_10);
				break;

			case 2:
				dev_dbg(VAR_3, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
					VAR_21, VAR_8, VAR_19, VAR_7, VAR_11);
				break;

			case 4:
				dev_dbg(VAR_3, ""%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\n"",
					VAR_21, VAR_8, VAR_19, VAR_7, VAR_12);
				break;
			}

			break;
		}
	}
}",torvalds/linux/a50829479f58416a013a4ccca791336af3c584c7/gtco.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,13 +32,17 @@
 
 	/* Walk  this report and pull out the info we need */
 	while (i < length) {
-		prefix = report[i];
-
-		/* Skip over prefix */
-		i++;
+		prefix = report[i++];
 
 		/* Determine data size and save the data in the proper variable */
-		size = PREF_SIZE(prefix);
+		size = (1U << PREF_SIZE(prefix)) >> 1;
+		if (i + size > length) {
+			dev_err(ddev,
+				""Not enough data (need %d, have %d)\n"",
+				i + size, length);
+			break;
+		}
+
 		switch (size) {
 		case 1:
 			data = report[i];
@@ -46,8 +50,7 @@
 		case 2:
 			data16 = get_unaligned_le16(&report[i]);
 			break;
-		case 3:
-			size = 4;
+		case 4:
 			data32 = get_unaligned_le32(&report[i]);
 			break;
 		}","{'deleted_lines': ['\t\tprefix = report[i];', '', '\t\t/* Skip over prefix */', '\t\ti++;', '\t\tsize = PREF_SIZE(prefix);', '\t\tcase 3:', '\t\t\tsize = 4;'], 'added_lines': ['\t\tprefix = report[i++];', '\t\tsize = (1U << PREF_SIZE(prefix)) >> 1;', '\t\tif (i + size > length) {', '\t\t\tdev_err(ddev,', '\t\t\t\t""Not enough data (need %d, have %d)\\n"",', '\t\t\t\ti + size, length);', '\t\t\tbreak;', '\t\t}', '', '\t\tcase 4:']}",True,The parse_hid_report_descriptor function in drivers/input/tablet/gtco.c in the Linux kernel before 4.13.11 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.,6.6,MEDIUM,1,test,2017-10-23T23:46:00Z,2
CVE-2017-15908,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,systemd,"resolved: fix loop on packets with pseudo dns types

Reported by Karim Hossen & Thomas Imbert from Sogeti ESEC R&D.

https://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1725351",9f939335a07085aa9a9663efd1dca06ef6405d62,https://github.com/systemd/systemd/commit/9f939335a07085aa9a9663efd1dca06ef6405d62,src/resolve/resolved-dns-packet.c,dns_packet_read_type_window,"static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {
uint8_t window;
uint8_t length;
const uint8_t *bitmap;
uint8_t bit = 0;
unsigned i;
bool found = false;
_cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;
int r;
assert(p);
assert(types);
INIT_REWINDER(rewinder, p);
r = bitmap_ensure_allocated(types);
if (r < 0)
return r;
r = dns_packet_read_uint8(p, &window, NULL);
if (r < 0)
return r;
r = dns_packet_read_uint8(p, &length, NULL);
if (r < 0)
return r;
if (length == 0 || length > 32)
return -EBADMSG;
r = dns_packet_read(p, length, (const void **)&bitmap, NULL);
if (r < 0)
return r;
for (i = 0; i < length; i++) {
uint8_t bitmask = 1 << 7;
if (!bitmap[i]) {
found = false;
bit += 8;
continue;
}
found = true;
while (bitmask) {
if (bitmap[i] & bitmask) {
uint16_t n;
n = (uint16_t) window << 8 | (uint16_t) bit;
if (dns_type_is_pseudo(n))
continue;
r = bitmap_set(*types, n);
if (r < 0)
return r;
}
bit++;
bitmask >>= 1;
}
}
if (!found)
return -EBADMSG;
if (start)
*start = rewinder.saved_rindex;
CANCEL_REWINDER(rewinder);
return 0;
}","static int dns_packet_read_type_window(DnsPacket *VAR_0, Bitmap **VAR_1, size_t *VAR_2) {
uint8_t VAR_3;
uint8_t VAR_4;
const uint8_t *VAR_5;
uint8_t VAR_6 = 0;
unsigned VAR_7;
bool VAR_8 = false;
VAR_9(rewind_dns_packet) VAR_10 VAR_11;
int VAR_12;
assert(VAR_0);
assert(VAR_1);
INIT_REWINDER(VAR_11, VAR_0);
VAR_12 = bitmap_ensure_allocated(VAR_1);
if (VAR_12 < 0)
return VAR_12;
VAR_12 = dns_packet_read_uint8(VAR_0, &VAR_3, NULL);
if (VAR_12 < 0)
return VAR_12;
VAR_12 = dns_packet_read_uint8(VAR_0, &VAR_4, NULL);
if (VAR_12 < 0)
return VAR_12;
if (VAR_4 == 0 || VAR_4 > 32)
return -VAR_13;
VAR_12 = dns_packet_read(VAR_0, VAR_4, (const void **)&VAR_5, NULL);
if (VAR_12 < 0)
return VAR_12;
for (VAR_7 = 0; VAR_7 < VAR_4; VAR_7++) {
uint8_t VAR_14 = 1 << 7;
if (!VAR_5[VAR_7]) {
VAR_8 = false;
VAR_6 += 8;
continue;
}
VAR_8 = true;
while (VAR_14) {
if (VAR_5[VAR_7] & VAR_14) {
uint16_t VAR_15;
VAR_15 = (uint16_t) VAR_3 << 8 | (uint16_t) VAR_6;
if (dns_type_is_pseudo(VAR_15))
continue;
VAR_12 = bitmap_set(*VAR_1, VAR_15);
if (VAR_12 < 0)
return VAR_12;
}
VAR_6++;
VAR_14 >>= 1;
}
}
if (!VAR_8)
return -VAR_13;
if (VAR_2)
*VAR_2 = VAR_11.saved_rindex;
CANCEL_REWINDER(VAR_11);
return 0;
}",systemd/9f939335a07085aa9a9663efd1dca06ef6405d62/resolved-dns-packet.c/vul/before/0.json,"static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {
        uint8_t window;
        uint8_t length;
        const uint8_t *bitmap;
        uint8_t bit = 0;
        unsigned i;
        bool found = false;
        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;
        int r;

        assert(p);
        assert(types);
        INIT_REWINDER(rewinder, p);

        r = bitmap_ensure_allocated(types);
        if (r < 0)
                return r;

        r = dns_packet_read_uint8(p, &window, NULL);
        if (r < 0)
                return r;

        r = dns_packet_read_uint8(p, &length, NULL);
        if (r < 0)
                return r;

        if (length == 0 || length > 32)
                return -EBADMSG;

        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);
        if (r < 0)
                return r;

        for (i = 0; i < length; i++) {
                uint8_t bitmask = 1 << 7;

                if (!bitmap[i]) {
                        found = false;
                        bit += 8;
                        continue;
                }

                found = true;

                for (; bitmask; bit++, bitmask >>= 1)
                        if (bitmap[i] & bitmask) {
                                uint16_t n;

                                n = (uint16_t) window << 8 | (uint16_t) bit;

                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */
                                if (dns_type_is_pseudo(n))
                                        continue;

                                r = bitmap_set(*types, n);
                                if (r < 0)
                                        return r;
                        }
        }

        if (!found)
                return -EBADMSG;

        if (start)
                *start = rewinder.saved_rindex;
        CANCEL_REWINDER(rewinder);

        return 0;
}","static int dns_packet_read_type_window(DnsPacket *VAR_0, Bitmap **VAR_1, size_t *VAR_2) {
        uint8_t VAR_3;
        uint8_t VAR_4;
        const uint8_t *VAR_5;
        uint8_t VAR_6 = 0;
        unsigned VAR_7;
        bool VAR_8 = false;
        VAR_9(rewind_dns_packet) VAR_10 VAR_11;
        int VAR_12;

        assert(VAR_0);
        assert(VAR_1);
        INIT_REWINDER(VAR_11, VAR_0);

        VAR_12 = bitmap_ensure_allocated(VAR_1);
        if (VAR_12 < 0)
                return VAR_12;

        VAR_12 = dns_packet_read_uint8(VAR_0, &VAR_3, NULL);
        if (VAR_12 < 0)
                return VAR_12;

        VAR_12 = dns_packet_read_uint8(VAR_0, &VAR_4, NULL);
        if (VAR_12 < 0)
                return VAR_12;

        if (VAR_4 == 0 || VAR_4 > 32)
                return -VAR_13;

        VAR_12 = dns_packet_read(VAR_0, VAR_4, (const void **)&VAR_5, NULL);
        if (VAR_12 < 0)
                return VAR_12;

        for (VAR_7 = 0; VAR_7 < VAR_4; VAR_7++) {
                uint8_t VAR_14 = 1 << 7;

                if (!VAR_5[VAR_7]) {
                        VAR_8 = false;
                        VAR_6 += 8;
                        continue;
                }

                VAR_8 = true;

                for (; VAR_14; VAR_6++, VAR_14 >>= 1)
                        if (VAR_5[VAR_7] & VAR_14) {
                                uint16_t VAR_15;

                                VAR_15 = (uint16_t) VAR_3 << 8 | (uint16_t) VAR_6;

                                /* COMMENT_0 */
                                if (dns_type_is_pseudo(VAR_15))
                                        continue;

                                VAR_12 = bitmap_set(*VAR_1, VAR_15);
                                if (VAR_12 < 0)
                                        return VAR_12;
                        }
        }

        if (!VAR_8)
                return -VAR_13;

        if (VAR_2)
                *VAR_2 = VAR_11.saved_rindex;
        CANCEL_REWINDER(VAR_11);

        return 0;
}",systemd/9f939335a07085aa9a9663efd1dca06ef6405d62/resolved-dns-packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -42,7 +42,7 @@
 
                 found = true;
 
-                while (bitmask) {
+                for (; bitmask; bit++, bitmask >>= 1)
                         if (bitmap[i] & bitmask) {
                                 uint16_t n;
 
@@ -56,10 +56,6 @@
                                 if (r < 0)
                                         return r;
                         }
-
-                        bit++;
-                        bitmask >>= 1;
-                }
         }
 
         if (!found)","{'deleted_lines': ['                while (bitmask) {', '', '                        bit++;', '                        bitmask >>= 1;', '                }'], 'added_lines': ['                for (; bitmask; bit++, bitmask >>= 1)']}",True,"In systemd 223 through 235, a remote DNS server can respond with a custom crafted DNS NSEC resource record to trigger an infinite loop in the dns_packet_read_type_window() function of the 'systemd-resolved' service and cause a DoS of the affected service.",7.5,HIGH,2,test,2017-10-25T09:19:19Z,2
CVE-2017-18216,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0.0,torvalds/linux,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,fs/ocfs2/cluster/nodemanager.c,o2nm_node_ipv4_address_store,"static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
const char *page,
size_t count)
{
struct o2nm_node *node = to_o2nm_node(item);
struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
int ret, i;
struct rb_node **p, *parent;
unsigned int octets[4];
__be32 ipv4_addr = 0;
ret = sscanf(page, ""%3u.%3u.%3u.%3u"", &octets[3], &octets[2],
&octets[1], &octets[0]);
if (ret != 4)
return -EINVAL;
for (i = 0; i < ARRAY_SIZE(octets); i++) {
if (octets[i] > 255)
return -ERANGE;
be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
}
ret = 0;
write_lock(&cluster->cl_nodes_lock);
if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
ret = -EEXIST;
else if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,
&node->nd_set_attributes))
ret = -EBUSY;
else {
rb_link_node(&node->nd_ip_node, parent, p);
rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
}
write_unlock(&cluster->cl_nodes_lock);
if (ret)
return ret;
memcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));
return count;
}","static ssize_t o2nm_node_ipv4_address_store(struct config_item *VAR_0,
const char *VAR_1,
size_t VAR_2)
{
struct o2nm_node *VAR_3 = to_o2nm_node(VAR_0);
struct o2nm_cluster *VAR_4 = to_o2nm_cluster_from_node(VAR_3);
int VAR_5, VAR_6;
struct rb_node **VAR_7, *VAR_8;
unsigned int VAR_9[4];
__be32 VAR_10 = 0;
VAR_5 = sscanf(VAR_1, ""%3u.%3u.%3u.%3u"", &VAR_9[3], &VAR_9[2],
&VAR_9[1], &VAR_9[0]);
if (VAR_5 != 4)
return -VAR_11;
for (VAR_6 = 0; VAR_6 < ARRAY_SIZE(VAR_9); VAR_6++) {
if (VAR_9[VAR_6] > 255)
return -VAR_12;
be32_add_cpu(&VAR_10, VAR_9[VAR_6] << (VAR_6 * 8));
}
VAR_5 = 0;
write_lock(&VAR_4->cl_nodes_lock);
if (o2nm_node_ip_tree_lookup(VAR_4, VAR_10, &VAR_7, &VAR_8))
VAR_5 = -VAR_13;
else if (test_and_set_bit(VAR_14,
&VAR_3->nd_set_attributes))
VAR_5 = -VAR_15;
else {
rb_link_node(&VAR_3->nd_ip_node, VAR_8, VAR_7);
rb_insert_color(&VAR_3->nd_ip_node, &VAR_4->cl_node_ip_tree);
}
write_unlock(&VAR_4->cl_nodes_lock);
if (VAR_5)
return VAR_5;
memcpy(&VAR_3->nd_ipv4_address, &VAR_10, sizeof(VAR_10));
return VAR_2;
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/before/2.json,"static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
					    const char *page,
					    size_t count)
{
	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
	int ret, i;
	struct rb_node **p, *parent;
	unsigned int octets[4];
	__be32 ipv4_addr = 0;

	ret = sscanf(page, ""%3u.%3u.%3u.%3u"", &octets[3], &octets[2],
		     &octets[1], &octets[0]);
	if (ret != 4)
		return -EINVAL;

	for (i = 0; i < ARRAY_SIZE(octets); i++) {
		if (octets[i] > 255)
			return -ERANGE;
		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
	}

	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

	ret = 0;
	write_lock(&cluster->cl_nodes_lock);
	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else {
		rb_link_node(&node->nd_ip_node, parent, p);
		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
	}
	write_unlock(&cluster->cl_nodes_lock);
	o2nm_unlock_subsystem();

	if (ret)
		return ret;

	memcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));

	return count;
}","static ssize_t o2nm_node_ipv4_address_store(struct config_item *VAR_0,
					    const char *VAR_1,
					    size_t VAR_2)
{
	struct o2nm_node *VAR_3 = to_o2nm_node(VAR_0);
	struct o2nm_cluster *VAR_4;
	int VAR_5, VAR_6;
	struct rb_node **VAR_7, *VAR_8;
	unsigned int VAR_9[4];
	__be32 VAR_10 = 0;

	VAR_5 = sscanf(VAR_1, ""%3u.%3u.%3u.%3u"", &VAR_9[3], &VAR_9[2],
		     &VAR_9[1], &VAR_9[0]);
	if (VAR_5 != 4)
		return -VAR_11;

	for (VAR_6 = 0; VAR_6 < ARRAY_SIZE(VAR_9); VAR_6++) {
		if (VAR_9[VAR_6] > 255)
			return -VAR_12;
		be32_add_cpu(&VAR_10, VAR_9[VAR_6] << (VAR_6 * 8));
	}

	o2nm_lock_subsystem();
	VAR_4 = to_o2nm_cluster_from_node(VAR_3);
	if (!VAR_4) {
		o2nm_unlock_subsystem();
		return -VAR_11;
	}

	VAR_5 = 0;
	write_lock(&VAR_4->cl_nodes_lock);
	if (o2nm_node_ip_tree_lookup(VAR_4, VAR_10, &VAR_7, &VAR_8))
		VAR_5 = -VAR_13;
	else if (test_and_set_bit(VAR_14,
			&VAR_3->nd_set_attributes))
		VAR_5 = -VAR_15;
	else {
		rb_link_node(&VAR_3->nd_ip_node, VAR_8, VAR_7);
		rb_insert_color(&VAR_3->nd_ip_node, &VAR_4->cl_node_ip_tree);
	}
	write_unlock(&VAR_4->cl_nodes_lock);
	o2nm_unlock_subsystem();

	if (VAR_5)
		return VAR_5;

	memcpy(&VAR_3->nd_ipv4_address, &VAR_10, sizeof(VAR_10));

	return VAR_2;
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
@@ -20,6 +20,13 @@
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
@@ -32,6 +39,8 @@
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 ","{'deleted_lines': ['\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);'], 'added_lines': ['\tstruct o2nm_cluster *cluster;', '\to2nm_lock_subsystem();', '\tcluster = to_o2nm_cluster_from_node(node);', '\tif (!cluster) {', '\t\to2nm_unlock_subsystem();', '\t\treturn -EINVAL;', '\t}', '', '\to2nm_unlock_subsystem();', '']}",True,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",5.5,MEDIUM,1,test,2017-11-16T01:31:48Z,2
CVE-2017-18216,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0.0,torvalds/linux,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,fs/ocfs2/cluster/nodemanager.c,o2nm_node_num_store,"static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
size_t count)
{
struct o2nm_node *node = to_o2nm_node(item);
struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
unsigned long tmp;
char *p = (char *)page;
int ret = 0;
tmp = simple_strtoul(p, &p, 0);
if (!p || (*p && (*p != '\n')))
return -EINVAL;
if (tmp >= O2NM_MAX_NODES)
return -ERANGE;
if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
!test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
return -EINVAL; 
write_lock(&cluster->cl_nodes_lock);
if (cluster->cl_nodes[tmp])
ret = -EEXIST;
else if (test_and_set_bit(O2NM_NODE_ATTR_NUM,
&node->nd_set_attributes))
ret = -EBUSY;
else  {
cluster->cl_nodes[tmp] = node;
node->nd_num = tmp;
set_bit(tmp, cluster->cl_nodes_bitmap);
}
write_unlock(&cluster->cl_nodes_lock);
if (ret)
return ret;
return count;
}","static ssize_t o2nm_node_num_store(struct config_item *VAR_0, const char *VAR_1,
size_t VAR_2)
{
struct o2nm_node *VAR_3 = to_o2nm_node(VAR_0);
struct o2nm_cluster *VAR_4 = to_o2nm_cluster_from_node(VAR_3);
unsigned long VAR_5;
char *VAR_6 = (char *)VAR_1;
int VAR_7 = 0;
VAR_5 = simple_strtoul(VAR_6, &VAR_6, 0);
if (!VAR_6 || (*VAR_6 && (*VAR_6 != '\n')))
return -VAR_8;
if (VAR_5 >= VAR_9)
return -VAR_10;
if (!test_bit(VAR_11, &VAR_3->nd_set_attributes) ||
!test_bit(VAR_12, &VAR_3->nd_set_attributes))
return -VAR_8; 
write_lock(&VAR_4->cl_nodes_lock);
if (VAR_4->cl_nodes[VAR_5])
VAR_7 = -VAR_13;
else if (test_and_set_bit(VAR_14,
&VAR_3->nd_set_attributes))
VAR_7 = -VAR_15;
else  {
VAR_4->cl_nodes[VAR_5] = VAR_3;
VAR_3->nd_num = VAR_5;
set_bit(VAR_5, VAR_4->cl_nodes_bitmap);
}
write_unlock(&VAR_4->cl_nodes_lock);
if (VAR_7)
return VAR_7;
return VAR_2;
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/before/3.json,"static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
				   size_t count)
{
	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
	unsigned long tmp;
	char *p = (char *)page;
	int ret = 0;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	if (tmp >= O2NM_MAX_NODES)
		return -ERANGE;

	/* once we're in the cl_nodes tree networking can look us up by
	 * node number and try to use our address and port attributes
	 * to connect to this node.. make sure that they've been set
	 * before writing the node attribute? */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
		return -EINVAL; /* XXX */

	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

	write_lock(&cluster->cl_nodes_lock);
	if (cluster->cl_nodes[tmp])
		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_NUM,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else  {
		cluster->cl_nodes[tmp] = node;
		node->nd_num = tmp;
		set_bit(tmp, cluster->cl_nodes_bitmap);
	}
	write_unlock(&cluster->cl_nodes_lock);
	o2nm_unlock_subsystem();

	if (ret)
		return ret;

	return count;
}","static ssize_t o2nm_node_num_store(struct config_item *VAR_0, const char *VAR_1,
				   size_t VAR_2)
{
	struct o2nm_node *VAR_3 = to_o2nm_node(VAR_0);
	struct o2nm_cluster *VAR_4;
	unsigned long VAR_5;
	char *VAR_6 = (char *)VAR_1;
	int VAR_7 = 0;

	VAR_5 = simple_strtoul(VAR_6, &VAR_6, 0);
	if (!VAR_6 || (*VAR_6 && (*VAR_6 != '\n')))
		return -VAR_8;

	if (VAR_5 >= VAR_9)
		return -VAR_10;

	/* COMMENT_0 */
                                                              
                                                             
                                         
	if (!test_bit(VAR_11, &VAR_3->nd_set_attributes) ||
	    !test_bit(VAR_12, &VAR_3->nd_set_attributes))
		return -VAR_8; /* COMMENT_4 */

	o2nm_lock_subsystem();
	VAR_4 = to_o2nm_cluster_from_node(VAR_3);
	if (!VAR_4) {
		o2nm_unlock_subsystem();
		return -VAR_8;
	}

	write_lock(&VAR_4->cl_nodes_lock);
	if (VAR_4->cl_nodes[VAR_5])
		VAR_7 = -VAR_13;
	else if (test_and_set_bit(VAR_14,
			&VAR_3->nd_set_attributes))
		VAR_7 = -VAR_15;
	else  {
		VAR_4->cl_nodes[VAR_5] = VAR_3;
		VAR_3->nd_num = VAR_5;
		set_bit(VAR_5, VAR_4->cl_nodes_bitmap);
	}
	write_unlock(&VAR_4->cl_nodes_lock);
	o2nm_unlock_subsystem();

	if (VAR_7)
		return VAR_7;

	return VAR_2;
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;
@@ -22,6 +22,13 @@
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		o2nm_unlock_subsystem();
+		return -EINVAL;
+	}
+
 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
@@ -34,6 +41,8 @@
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
+	o2nm_unlock_subsystem();
+
 	if (ret)
 		return ret;
 ","{'deleted_lines': ['\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);'], 'added_lines': ['\tstruct o2nm_cluster *cluster;', '\to2nm_lock_subsystem();', '\tcluster = to_o2nm_cluster_from_node(node);', '\tif (!cluster) {', '\t\to2nm_unlock_subsystem();', '\t\treturn -EINVAL;', '\t}', '', '\to2nm_unlock_subsystem();', '']}",True,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",5.5,MEDIUM,1,test,2017-11-16T01:31:48Z,2
CVE-2017-18216,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0.0,torvalds/linux,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,fs/ocfs2/cluster/nodemanager.c,o2nm_node_local_store,"static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
size_t count)
{
struct o2nm_node *node = to_o2nm_node(item);
struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
unsigned long tmp;
char *p = (char *)page;
ssize_t ret;
tmp = simple_strtoul(p, &p, 0);
if (!p || (*p && (*p != '\n')))
return -EINVAL;
tmp = !!tmp; 
if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
!test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||
!test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
return -EINVAL; 
if (tmp && tmp == cluster->cl_has_local &&
cluster->cl_local_node != node->nd_num)
return -EBUSY;
if (tmp && !cluster->cl_has_local) {
ret = o2net_start_listening(node);
if (ret)
return ret;
}
if (!tmp && cluster->cl_has_local &&
cluster->cl_local_node == node->nd_num) {
o2net_stop_listening(node);
cluster->cl_local_node = O2NM_INVALID_NODE_NUM;
}
node->nd_local = tmp;
if (node->nd_local) {
cluster->cl_has_local = tmp;
cluster->cl_local_node = node->nd_num;
}
return count;
}","static ssize_t o2nm_node_local_store(struct config_item *VAR_0, const char *VAR_1,
size_t VAR_2)
{
struct o2nm_node *VAR_3 = to_o2nm_node(VAR_0);
struct o2nm_cluster *VAR_4 = to_o2nm_cluster_from_node(VAR_3);
unsigned long VAR_5;
char *VAR_6 = (char *)VAR_1;
ssize_t VAR_7;
VAR_5 = simple_strtoul(VAR_6, &VAR_6, 0);
if (!VAR_6 || (*VAR_6 && (*VAR_6 != '\n')))
return -VAR_8;
VAR_5 = !!VAR_5; 
if (!test_bit(VAR_9, &VAR_3->nd_set_attributes) ||
!test_bit(VAR_10, &VAR_3->nd_set_attributes) ||
!test_bit(VAR_11, &VAR_3->nd_set_attributes))
return -VAR_8; 
if (VAR_5 && VAR_5 == VAR_4->cl_has_local &&
VAR_4->cl_local_node != VAR_3->nd_num)
return -VAR_12;
if (VAR_5 && !VAR_4->cl_has_local) {
VAR_7 = o2net_start_listening(VAR_3);
if (VAR_7)
return VAR_7;
}
if (!VAR_5 && VAR_4->cl_has_local &&
VAR_4->cl_local_node == VAR_3->nd_num) {
o2net_stop_listening(VAR_3);
VAR_4->cl_local_node = VAR_13;
}
VAR_3->nd_local = VAR_5;
if (VAR_3->nd_local) {
VAR_4->cl_has_local = VAR_5;
VAR_4->cl_local_node = VAR_3->nd_num;
}
return VAR_2;
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/before/1.json,"static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
				     size_t count)
{
	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
	unsigned long tmp;
	char *p = (char *)page;
	ssize_t ret;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	tmp = !!tmp; /* boolean of whether this node wants to be local */

	/* setting local turns on networking rx for now so we require having
	 * set everything else first */
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
	    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||
	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
		return -EINVAL; /* XXX */

	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		ret = -EINVAL;
		goto out;
	}

	/* the only failure case is trying to set a new local node
	 * when a different one is already set */
	if (tmp && tmp == cluster->cl_has_local &&
	    cluster->cl_local_node != node->nd_num) {
		ret = -EBUSY;
		goto out;
	}

	/* bring up the rx thread if we're setting the new local node. */
	if (tmp && !cluster->cl_has_local) {
		ret = o2net_start_listening(node);
		if (ret)
			goto out;
	}

	if (!tmp && cluster->cl_has_local &&
	    cluster->cl_local_node == node->nd_num) {
		o2net_stop_listening(node);
		cluster->cl_local_node = O2NM_INVALID_NODE_NUM;
	}

	node->nd_local = tmp;
	if (node->nd_local) {
		cluster->cl_has_local = tmp;
		cluster->cl_local_node = node->nd_num;
	}

	ret = count;

out:
	o2nm_unlock_subsystem();
	return ret;
}","static ssize_t o2nm_node_local_store(struct config_item *VAR_0, const char *VAR_1,
				     size_t VAR_2)
{
	struct o2nm_node *VAR_3 = to_o2nm_node(VAR_0);
	struct o2nm_cluster *VAR_4;
	unsigned long VAR_5;
	char *VAR_6 = (char *)VAR_1;
	ssize_t VAR_7;

	VAR_5 = simple_strtoul(VAR_6, &VAR_6, 0);
	if (!VAR_6 || (*VAR_6 && (*VAR_6 != '\n')))
		return -VAR_8;

	VAR_5 = !!VAR_5; /* COMMENT_0 */

	/* COMMENT_1 */
                                
	if (!test_bit(VAR_9, &VAR_3->nd_set_attributes) ||
	    !test_bit(VAR_10, &VAR_3->nd_set_attributes) ||
	    !test_bit(VAR_11, &VAR_3->nd_set_attributes))
		return -VAR_8; /* COMMENT_3 */

	o2nm_lock_subsystem();
	VAR_4 = to_o2nm_cluster_from_node(VAR_3);
	if (!VAR_4) {
		VAR_7 = -VAR_8;
		goto out;
	}

	/* COMMENT_4 */
                                          
	if (VAR_5 && VAR_5 == VAR_4->cl_has_local &&
	    VAR_4->cl_local_node != VAR_3->nd_num) {
		VAR_7 = -VAR_12;
		goto out;
	}

	/* COMMENT_6 */
	if (VAR_5 && !VAR_4->cl_has_local) {
		VAR_7 = o2net_start_listening(VAR_3);
		if (VAR_7)
			goto out;
	}

	if (!VAR_5 && VAR_4->cl_has_local &&
	    VAR_4->cl_local_node == VAR_3->nd_num) {
		o2net_stop_listening(VAR_3);
		VAR_4->cl_local_node = VAR_13;
	}

	VAR_3->nd_local = VAR_5;
	if (VAR_3->nd_local) {
		VAR_4->cl_has_local = VAR_5;
		VAR_4->cl_local_node = VAR_3->nd_num;
	}

	VAR_7 = VAR_2;

out:
	o2nm_unlock_subsystem();
	return VAR_7;
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
-	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
+	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;
@@ -20,17 +20,26 @@
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL; /* XXX */
 
+	o2nm_lock_subsystem();
+	cluster = to_o2nm_cluster_from_node(node);
+	if (!cluster) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	/* the only failure case is trying to set a new local node
 	 * when a different one is already set */
 	if (tmp && tmp == cluster->cl_has_local &&
-	    cluster->cl_local_node != node->nd_num)
-		return -EBUSY;
+	    cluster->cl_local_node != node->nd_num) {
+		ret = -EBUSY;
+		goto out;
+	}
 
 	/* bring up the rx thread if we're setting the new local node. */
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
-			return ret;
+			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
@@ -45,5 +54,9 @@
 		cluster->cl_local_node = node->nd_num;
 	}
 
-	return count;
+	ret = count;
+
+out:
+	o2nm_unlock_subsystem();
+	return ret;
 }","{'deleted_lines': ['\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);', '\t    cluster->cl_local_node != node->nd_num)', '\t\treturn -EBUSY;', '\t\t\treturn ret;', '\treturn count;'], 'added_lines': ['\tstruct o2nm_cluster *cluster;', '\to2nm_lock_subsystem();', '\tcluster = to_o2nm_cluster_from_node(node);', '\tif (!cluster) {', '\t\tret = -EINVAL;', '\t\tgoto out;', '\t}', '', '\t    cluster->cl_local_node != node->nd_num) {', '\t\tret = -EBUSY;', '\t\tgoto out;', '\t}', '\t\t\tgoto out;', '\tret = count;', '', 'out:', '\to2nm_unlock_subsystem();', '\treturn ret;']}",True,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",5.5,MEDIUM,1,test,2017-11-16T01:31:48Z,2
CVE-2017-18216,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0.0,torvalds/linux,"ocfs2: subsystem.su_mutex is required while accessing the item->ci_parent

The subsystem.su_mutex is required while accessing the item->ci_parent,
otherwise, NULL pointer dereference to the item->ci_parent will be
triggered in the following situation:

add node                     delete node
sys_write
 vfs_write
  configfs_write_file
   o2nm_node_store
    o2nm_node_local_write
                             do_rmdir
                              vfs_rmdir
                               configfs_rmdir
                                mutex_lock(&subsys->su_mutex);
                                unlink_obj
                                 item->ci_group = NULL;
                                 item->ci_parent = NULL;
	 to_o2nm_cluster_from_node
	  node->nd_item.ci_parent->ci_parent
	  BUG since of NULL pointer dereference to nd_item.ci_parent

Moreover, the o2nm_cluster also should be protected by the
subsystem.su_mutex.

[alex.chen@huawei.com: v2]
  Link: http://lkml.kernel.org/r/59EEAA69.9080703@huawei.com
Link: http://lkml.kernel.org/r/59E9B36A.10700@huawei.com
Signed-off-by: Alex Chen <alex.chen@huawei.com>
Reviewed-by: Jun Piao <piaojun@huawei.com>
Reviewed-by: Joseph Qi <jiangqi903@gmail.com>
Cc: Mark Fasheh <mfasheh@versity.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Junxiao Bi <junxiao.bi@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2,fs/ocfs2/cluster/nodemanager.c,to_o2nm_cluster_from_node,"static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
{
return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
}","static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *VAR_0)
{
return to_o2nm_cluster(VAR_0->nd_item.ci_parent->ci_parent);
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/before/0.json,"static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
{
	/* through the first node_set .parent
	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
	if (node->nd_item.ci_parent)
		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
	else
		return NULL;
}","static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *VAR_0)
{
	/* COMMENT_0 */
                                                                         
	if (VAR_0->nd_item.ci_parent)
		return to_o2nm_cluster(VAR_0->nd_item.ci_parent->ci_parent);
	else
		return NULL;
}",torvalds/linux/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2/nodemanager.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,5 +2,8 @@
 {
 	/* through the first node_set .parent
 	 * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */
-	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	if (node->nd_item.ci_parent)
+		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
+	else
+		return NULL;
 }","{'deleted_lines': ['\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);'], 'added_lines': ['\tif (node->nd_item.ci_parent)', '\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);', '\telse', '\t\treturn NULL;']}",True,"In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used.",5.5,MEDIUM,1,test,2017-11-16T01:31:48Z,2
CVE-2017-17499,['CWE-416'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,ImageMagick,Added missing return to avoid use after free.,8c35502217c1879cb8257c617007282eee3fe1cc,https://github.com/ImageMagick/ImageMagick/commit/8c35502217c1879cb8257c617007282eee3fe1cc,Magick++/lib/Image.cpp,Magick::Image::read,"void Magick::Image::read(MagickCore::Image *image,
MagickCore::ExceptionInfo *exceptionInfo)
{
if (image != (MagickCore::Image *) NULL &&
image->next != (MagickCore::Image *) NULL)
{
MagickCore::Image
*next;
next=image->next;
image->next=(MagickCore::Image *) NULL;
next->previous=(MagickCore::Image *) NULL;
DestroyImageList(next);
}
replaceImage(image);
if (exceptionInfo->severity == MagickCore::UndefinedException &&
image == (MagickCore::Image *) NULL)
{
(void) MagickCore::DestroyExceptionInfo(exceptionInfo);
if (!quiet())
throwExceptionExplicit(MagickCore::ImageWarning,
""No image was loaded."");
}
ThrowImageException;
}","void Magick::Image::read(MagickCore::Image *VAR_0,
MagickCore::ExceptionInfo *VAR_1)
{
if (VAR_0 != (MagickCore::Image *) NULL &&
VAR_0->next != (MagickCore::Image *) NULL)
{
MagickCore::Image
*VAR_2;
VAR_2=VAR_0->next;
VAR_0->next=(MagickCore::Image *) NULL;
VAR_2->previous=(MagickCore::Image *) NULL;
DestroyImageList(VAR_2);
}
replaceImage(VAR_0);
if (VAR_1->severity == MagickCore::UndefinedException &&
VAR_0 == (MagickCore::Image *) NULL)
{
(void) MagickCore::DestroyExceptionInfo(VAR_1);
if (!quiet())
throwExceptionExplicit(MagickCore::ImageWarning,
""No image was loaded."");
}
VAR_3;
}",ImageMagick/8c35502217c1879cb8257c617007282eee3fe1cc/Image.cpp/vul/before/0.json,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  // Ensure that multiple image frames were not read.
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;

      // Destroy any extra image frames
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
      return;
    }
  ThrowImageException;
}","void Magick::Image::read(MagickCore::Image *VAR_0,
  MagickCore::ExceptionInfo *VAR_1)
{
  /* COMMENT_0 */
  if (VAR_0 != (MagickCore::Image *) NULL &&
      VAR_0->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *VAR_2;

      /* COMMENT_1 */
      VAR_2=VAR_0->next;
      VAR_0->next=(MagickCore::Image *) NULL;
      VAR_2->previous=(MagickCore::Image *) NULL;
      DestroyImageList(VAR_2);
    }
  replaceImage(VAR_0);
  if (VAR_1->severity == MagickCore::UndefinedException &&
      VAR_0 == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(VAR_1);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
      return;
    }
  VAR_3;
}",ImageMagick/8c35502217c1879cb8257c617007282eee3fe1cc/Image.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,7 @@
       if (!quiet())
         throwExceptionExplicit(MagickCore::ImageWarning,
           ""No image was loaded."");
+      return;
     }
   ThrowImageException;
 }","{'deleted_lines': [], 'added_lines': ['      return;']}",True,ImageMagick before 6.9.9-24 and 7.x before 7.0.7-12 has a use-after-free in Magick::Image::read in Magick++/lib/Image.cpp.,9.8,CRITICAL,3,test,2017-11-18T09:23:27Z,2
CVE-2017-16909,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,LibRaw,SECUNIA advisory 76000 #1 (wrong fuji width set via tiff tag,f1394822a0152ceed77815eafa5cac4e8baab10a,https://github.com/LibRaw/LibRaw/commit/f1394822a0152ceed77815eafa5cac4e8baab10a,internal/dcraw_common.cpp,panasonic_load_raw,"void CLASS panasonic_load_raw()
{
int row, col, i, j, sh = 0, pred[2], nonz[2];
pana_bits(0);
for (row = 0; row < height; row++)
{
#ifdef LIBRAW_LIBRARY_BUILD
checkCancel();
#endif
for (col = 0; col < raw_width; col++)
{
if ((i = col % 14) == 0)
pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
if (i % 3 == 2)
sh = 4 >> (3 - pana_bits(2));
if (nonz[i & 1])
{
if ((j = pana_bits(8)))
{
if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)
pred[i & 1] &= ~((~0u) << sh);
pred[i & 1] += j << sh;
}
}
else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)
derror();
}
}
}","void VAR_0 panasonic_load_raw()
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5 = 0, VAR_6[2], VAR_7[2];
pana_bits(0);
for (VAR_1 = 0; VAR_1 < VAR_8; VAR_1++)
{
#ifdef VAR_9
checkCancel();
#endif
for (VAR_2 = 0; VAR_2 < VAR_10; VAR_2++)
{
if ((VAR_3 = VAR_2 % 14) == 0)
VAR_6[0] = VAR_6[1] = VAR_7[0] = VAR_7[1] = 0;
if (VAR_3 % 3 == 2)
VAR_5 = 4 >> (3 - pana_bits(2));
if (VAR_7[VAR_3 & 1])
{
if ((VAR_4 = pana_bits(8)))
{
if ((VAR_6[VAR_3 & 1] -= 0x80 << VAR_5) < 0 || VAR_5 == 4)
VAR_6[VAR_3 & 1] &= ~((~0u) << VAR_5);
VAR_6[VAR_3 & 1] += VAR_4 << VAR_5;
}
}
else if ((VAR_7[VAR_3 & 1] = pana_bits(8)) || VAR_3 > 11)
VAR_6[VAR_3 & 1] = VAR_7[VAR_3 & 1] << 4 | pana_bits(4);
if ((RAW(VAR_1, VAR_2) = VAR_6[VAR_2 & 1]) > 4098 && VAR_2 < VAR_11)
derror();
}
}
}",,"void CLASS panasonic_load_raw()
{
  int row, col, i, j, sh = 0, pred[2], nonz[2];

  pana_bits(0);
  for (row = 0; row < raw_height; row++)
  {
#ifdef LIBRAW_LIBRARY_BUILD
    checkCancel();
#endif
    for (col = 0; col < raw_width; col++)
    {
      if ((i = col % 14) == 0)
        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
      if (i % 3 == 2)
        sh = 4 >> (3 - pana_bits(2));
      if (nonz[i & 1])
      {
        if ((j = pana_bits(8)))
        {
          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)
            pred[i & 1] &= ~((~0u) << sh);
          pred[i & 1] += j << sh;
        }
      }
      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)
        derror();
    }
  }
}","void VAR_0 panasonic_load_raw()
{
  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5 = 0, VAR_6[2], VAR_7[2];

  pana_bits(0);
  for (VAR_1 = 0; VAR_1 < VAR_8; VAR_1++)
  {
#ifdef VAR_9
    checkCancel();
#endif
    for (VAR_2 = 0; VAR_2 < VAR_10; VAR_2++)
    {
      if ((VAR_3 = VAR_2 % 14) == 0)
        VAR_6[0] = VAR_6[1] = VAR_7[0] = VAR_7[1] = 0;
      if (VAR_3 % 3 == 2)
        VAR_5 = 4 >> (3 - pana_bits(2));
      if (VAR_7[VAR_3 & 1])
      {
        if ((VAR_4 = pana_bits(8)))
        {
          if ((VAR_6[VAR_3 & 1] -= 0x80 << VAR_5) < 0 || VAR_5 == 4)
            VAR_6[VAR_3 & 1] &= ~((~0u) << VAR_5);
          VAR_6[VAR_3 & 1] += VAR_4 << VAR_5;
        }
      }
      else if ((VAR_7[VAR_3 & 1] = pana_bits(8)) || VAR_3 > 11)
        VAR_6[VAR_3 & 1] = VAR_7[VAR_3 & 1] << 4 | pana_bits(4);
      if ((RAW(VAR_1, VAR_2) = VAR_6[VAR_2 & 1]) > 4098 && VAR_2 < VAR_11 && VAR_1 < VAR_12)
        derror();
    }
  }
}",,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
   int row, col, i, j, sh = 0, pred[2], nonz[2];
 
   pana_bits(0);
-  for (row = 0; row < height; row++)
+  for (row = 0; row < raw_height; row++)
   {
 #ifdef LIBRAW_LIBRARY_BUILD
     checkCancel();
@@ -25,7 +25,7 @@
       }
       else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
         pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
-      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)
+      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)
         derror();
     }
   }","{'deleted_lines': ['  for (row = 0; row < height; row++)', '      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)'], 'added_lines': ['  for (row = 0; row < raw_height; row++)', '      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)']}",True,"An error related to the ""LibRaw::panasonic_load_raw()"" function (dcraw_common.cpp) in LibRaw versions prior to 0.18.6 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash via a specially crafted TIFF image.",8.8,HIGH,2,test,2017-12-02T09:01:40Z,2
CVE-2017-16909,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,LibRaw,SECUNIA advisory 76000 #1 (wrong fuji width set via tiff tag,f1394822a0152ceed77815eafa5cac4e8baab10a,https://github.com/LibRaw/LibRaw/commit/f1394822a0152ceed77815eafa5cac4e8baab10a,dcraw/dcraw.c,panasonic_load_raw,"void CLASS panasonic_load_raw()
{
int row, col, i, j, sh = 0, pred[2], nonz[2];
pana_bits(0);
for (row = 0; row < height; row++)
{
#ifdef LIBRAW_LIBRARY_BUILD
checkCancel();
#endif
for (col = 0; col < raw_width; col++)
{
if ((i = col % 14) == 0)
pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
if (i % 3 == 2)
sh = 4 >> (3 - pana_bits(2));
if (nonz[i & 1])
{
if ((j = pana_bits(8)))
{
if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)
pred[i & 1] &= ~((~0u) << sh);
pred[i & 1] += j << sh;
}
}
else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)
derror();
}
}
}","void VAR_0 panasonic_load_raw()
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5 = 0, VAR_6[2], VAR_7[2];
pana_bits(0);
for (VAR_1 = 0; VAR_1 < VAR_8; VAR_1++)
{
#ifdef VAR_9
checkCancel();
#endif
for (VAR_2 = 0; VAR_2 < VAR_10; VAR_2++)
{
if ((VAR_3 = VAR_2 % 14) == 0)
VAR_6[0] = VAR_6[1] = VAR_7[0] = VAR_7[1] = 0;
if (VAR_3 % 3 == 2)
VAR_5 = 4 >> (3 - pana_bits(2));
if (VAR_7[VAR_3 & 1])
{
if ((VAR_4 = pana_bits(8)))
{
if ((VAR_6[VAR_3 & 1] -= 0x80 << VAR_5) < 0 || VAR_5 == 4)
VAR_6[VAR_3 & 1] &= ~((~0u) << VAR_5);
VAR_6[VAR_3 & 1] += VAR_4 << VAR_5;
}
}
else if ((VAR_7[VAR_3 & 1] = pana_bits(8)) || VAR_3 > 11)
VAR_6[VAR_3 & 1] = VAR_7[VAR_3 & 1] << 4 | pana_bits(4);
if ((RAW(VAR_1, VAR_2) = VAR_6[VAR_2 & 1]) > 4098 && VAR_2 < VAR_11)
derror();
}
}
}",,"void CLASS panasonic_load_raw()
{
  int row, col, i, j, sh = 0, pred[2], nonz[2];

  pana_bits(0);
  for (row = 0; row < raw_height; row++)
  {
#ifdef LIBRAW_LIBRARY_BUILD
    checkCancel();
#endif
    for (col = 0; col < raw_width; col++)
    {
      if ((i = col % 14) == 0)
        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
      if (i % 3 == 2)
        sh = 4 >> (3 - pana_bits(2));
      if (nonz[i & 1])
      {
        if ((j = pana_bits(8)))
        {
          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)
            pred[i & 1] &= ~((~0u) << sh);
          pred[i & 1] += j << sh;
        }
      }
      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)
        derror();
    }
  }
}","void VAR_0 panasonic_load_raw()
{
  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5 = 0, VAR_6[2], VAR_7[2];

  pana_bits(0);
  for (VAR_1 = 0; VAR_1 < VAR_8; VAR_1++)
  {
#ifdef VAR_9
    checkCancel();
#endif
    for (VAR_2 = 0; VAR_2 < VAR_10; VAR_2++)
    {
      if ((VAR_3 = VAR_2 % 14) == 0)
        VAR_6[0] = VAR_6[1] = VAR_7[0] = VAR_7[1] = 0;
      if (VAR_3 % 3 == 2)
        VAR_5 = 4 >> (3 - pana_bits(2));
      if (VAR_7[VAR_3 & 1])
      {
        if ((VAR_4 = pana_bits(8)))
        {
          if ((VAR_6[VAR_3 & 1] -= 0x80 << VAR_5) < 0 || VAR_5 == 4)
            VAR_6[VAR_3 & 1] &= ~((~0u) << VAR_5);
          VAR_6[VAR_3 & 1] += VAR_4 << VAR_5;
        }
      }
      else if ((VAR_7[VAR_3 & 1] = pana_bits(8)) || VAR_3 > 11)
        VAR_6[VAR_3 & 1] = VAR_7[VAR_3 & 1] << 4 | pana_bits(4);
      if ((RAW(VAR_1, VAR_2) = VAR_6[VAR_2 & 1]) > 4098 && VAR_2 < VAR_11 && VAR_1 < VAR_12)
        derror();
    }
  }
}",,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
   int row, col, i, j, sh = 0, pred[2], nonz[2];
 
   pana_bits(0);
-  for (row = 0; row < height; row++)
+  for (row = 0; row < raw_height; row++)
   {
 #ifdef LIBRAW_LIBRARY_BUILD
     checkCancel();
@@ -25,7 +25,7 @@
       }
       else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
         pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
-      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)
+      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)
         derror();
     }
   }","{'deleted_lines': ['  for (row = 0; row < height; row++)', '      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)'], 'added_lines': ['  for (row = 0; row < raw_height; row++)', '      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)']}",True,"An error related to the ""LibRaw::panasonic_load_raw()"" function (dcraw_common.cpp) in LibRaw versions prior to 0.18.6 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash via a specially crafted TIFF image.",8.8,HIGH,2,test,2017-12-02T09:01:40Z,2
CVE-2017-16909,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,LibRaw,SECUNIA advisory 76000 #1 (wrong fuji width set via tiff tag,f1394822a0152ceed77815eafa5cac4e8baab10a,https://github.com/LibRaw/LibRaw/commit/f1394822a0152ceed77815eafa5cac4e8baab10a,dcraw/dcraw.c,parse_fuji,"void CLASS parse_fuji(int offset)
{
unsigned entries, tag, len, save, c;
fseek(ifp, offset, SEEK_SET);
entries = get4();
if (entries > 255)
return;
while (entries--)
{
tag = get2();
len = get2();
save = ftell(ifp);
if (tag == 0x100)
{
raw_height = get2();
raw_width = get2();
}
else if (tag == 0x121)
{
height = get2();
if ((width = get2()) == 4284)
width += 3;
}
else if (tag == 0x130)
{
fuji_layout = fgetc(ifp) >> 7;
fuji_width = !(fgetc(ifp) & 8);
}
else if (tag == 0x131)
{
filters = 9;
FORC(36)
{
int q = fgetc(ifp);
xtrans_abs[0][35 - c] = MAX(0,MIN(q,2)); 
}
}
else if (tag == 0x2ff0)
{
FORC4 cam_mul[c ^ 1] = get2();
#ifdef LIBRAW_LIBRARY_BUILD
}
else if (tag == 0x9650)
{
short a = (short)get2();
float b = fMAX(1.0f, get2());
imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;
}
else if (tag == 0x2f00)
{
int nWBs = get4();
nWBs = MIN(nWBs, 6);
for (int wb_ind = 0; wb_ind < nWBs; wb_ind++)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + wb_ind][c ^ 1] = get2();
fseek(ifp, 8, SEEK_CUR);
}
}
else if (tag == 0x2000)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ 1] = get2();
}
else if (tag == 0x2100)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][c ^ 1] = get2();
}
else if (tag == 0x2200)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ 1] = get2();
}
else if (tag == 0x2300)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();
}
else if (tag == 0x2301)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();
}
else if (tag == 0x2302)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();
}
else if (tag == 0x2310)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();
}
else if (tag == 0x2400)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();
}
else if (tag == 0x2410)
{
FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ 1] = get2();
#endif
}
else if (tag == 0xc000)
{
c = order;
order = 0x4949;
if ((tag = get4()) > 10000)
tag = get4();
if (tag > 10000)
tag = get4();
width = tag;
height = get4();
#ifdef LIBRAW_LIBRARY_BUILD
if (!strcmp(model, ""X-A3"") || !strcmp(model, ""X-A10""))
{
int wb[4];
int nWB, tWB, pWB;
int iCCT = 0;
int cnt;
fseek(ifp, save + 0x200, SEEK_SET);
for (int wb_ind = 0; wb_ind < 42; wb_ind++)
{
nWB = get4();
tWB = get4();
wb[0] = get4() << 1;
wb[1] = get4();
wb[3] = get4();
wb[2] = get4() << 1;
if (tWB && (iCCT < 255))
{
imgdata.color.WBCT_Coeffs[iCCT][0] = tWB;
for (cnt = 0; cnt < 4; cnt++)
imgdata.color.WBCT_Coeffs[iCCT][cnt + 1] = wb[cnt];
iCCT++;
}
if (nWB != 70)
{
for (pWB = 1; pWB < nFuji_wb_list2; pWB += 2)
{
if (Fuji_wb_list2[pWB] == nWB)
{
for (cnt = 0; cnt < 4; cnt++)
imgdata.color.WB_Coeffs[Fuji_wb_list2[pWB - 1]][cnt] = wb[cnt];
break;
}
}
}
}
}
else
{
libraw_internal_data.unpacker_data.posRAFData = save;
libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);
}
#endif
order = c;
}
fseek(ifp, save + len, SEEK_SET);
}
height <<= fuji_layout;
width >>= fuji_layout;
}","void VAR_0 parse_fuji(int VAR_1)
{
unsigned VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;
fseek(VAR_7, VAR_1, VAR_8);
VAR_2 = get4();
if (VAR_2 > 255)
return;
while (VAR_2--)
{
VAR_3 = get2();
VAR_4 = get2();
VAR_5 = ftell(VAR_7);
if (VAR_3 == 0x100)
{
VAR_9 = get2();
VAR_10 = get2();
}
else if (VAR_3 == 0x121)
{
VAR_11 = get2();
if ((VAR_12 = get2()) == 4284)
VAR_12 += 3;
}
else if (VAR_3 == 0x130)
{
VAR_13 = fgetc(VAR_7) >> 7;
VAR_14 = !(fgetc(VAR_7) & 8);
}
else if (VAR_3 == 0x131)
{
VAR_15 = 9;
FORC(36)
{
int VAR_16 = fgetc(VAR_7);
VAR_17[0][35 - VAR_6] = MAX(0,MIN(VAR_16,2)); 
}
}
else if (VAR_3 == 0x2ff0)
{
FORC4 VAR_18[VAR_6 ^ 1] = get2();
#ifdef VAR_19
}
else if (VAR_3 == 0x9650)
{
short VAR_20 = (short)get2();
float VAR_21 = fMAX(1.0f, get2());
VAR_22.makernotes.fuji.FujiExpoMidPointShift = VAR_20 / VAR_21;
}
else if (VAR_3 == 0x2f00)
{
int VAR_23 = get4();
VAR_23 = MIN(VAR_23, 6);
for (int VAR_24 = 0; VAR_24 < VAR_23; VAR_24++)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_27 + VAR_24][VAR_6 ^ 1] = get2();
fseek(VAR_7, 8, VAR_28);
}
}
else if (VAR_3 == 0x2000)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_29][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2100)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_30][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2200)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_31][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2300)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_32][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2301)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_33][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2302)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_34][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2310)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_35][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2400)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_36][VAR_6 ^ 1] = get2();
}
else if (VAR_3 == 0x2410)
{
FORC4 VAR_22.VAR_25.VAR_26[VAR_37][VAR_6 ^ 1] = get2();
#endif
}
else if (tag == 0xc000)
{
VAR_6 = VAR_38;
VAR_38 = 0x4949;
if ((tag = get4()) > 10000)
tag = get4();
if (tag > 10000)
tag = get4();
VAR_12 = tag;
VAR_11 = get4();
#ifdef VAR_19
if (!strcmp(VAR_39, ""X-A3"") || !strcmp(VAR_39, ""X-A10""))
{
int VAR_40[4];
int VAR_41, VAR_42, VAR_43;
int VAR_44 = 0;
int VAR_45;
fseek(VAR_7, VAR_5 + 0x200, VAR_8);
for (int VAR_24 = 0; VAR_24 < 42; VAR_24++)
{
VAR_41 = get4();
VAR_42 = get4();
VAR_40[0] = get4() << 1;
VAR_40[1] = get4();
VAR_40[3] = get4();
VAR_40[2] = get4() << 1;
if (VAR_42 && (VAR_44 < 255))
{
VAR_22.color.WBCT_Coeffs[VAR_44][0] = VAR_42;
for (VAR_45 = 0; VAR_45 < 4; VAR_45++)
VAR_22.color.WBCT_Coeffs[VAR_44][VAR_45 + 1] = VAR_40[VAR_45];
VAR_44++;
}
if (VAR_41 != 70)
{
for (VAR_43 = 1; VAR_43 < VAR_46; VAR_43 += 2)
{
if (VAR_47[VAR_43] == VAR_41)
{
for (VAR_45 = 0; VAR_45 < 4; VAR_45++)
VAR_22.color.WB_Coeffs[VAR_47[VAR_43 - 1]][VAR_45] = VAR_40[VAR_45];
break;
}
}
}
}
}
else
{
VAR_48.unpacker_data.posRAFData = VAR_5;
VAR_48.unpacker_data.lenRAFData = (VAR_4 >> 1);
}
#endif
VAR_38 = VAR_6;
}
fseek(VAR_7, VAR_5 + VAR_4, VAR_8);
}
VAR_11 <<= VAR_13;
VAR_12 >>= VAR_13;
}",,"void CLASS parse_fuji(int offset)
{
  unsigned entries, tag, len, save, c;

  fseek(ifp, offset, SEEK_SET);
  entries = get4();
  if (entries > 255)
    return;
#ifdef LIBRAW_LIBRARY_BUILD
  imgdata.process_warnings |=  LIBRAW_WARN_PARSEFUJI_PROCESSED; 
#endif
  while (entries--)
  {
    tag = get2();
    len = get2();
    save = ftell(ifp);

    if (tag == 0x100)
    {
      raw_height = get2();
      raw_width = get2();
    }
    else if (tag == 0x121)
    {
      height = get2();
      if ((width = get2()) == 4284)
        width += 3;
    }
    else if (tag == 0x130)
    {
      fuji_layout = fgetc(ifp) >> 7;
      fuji_width = !(fgetc(ifp) & 8);
    }
    else if (tag == 0x131)
    {
      filters = 9;
      FORC(36)
        {
	   int q = fgetc(ifp);
	   xtrans_abs[0][35 - c] = MAX(0,MIN(q,2)); /* & 3;*/
	}
    }
    else if (tag == 0x2ff0)
    {
      FORC4 cam_mul[c ^ 1] = get2();

// IB start
#ifdef LIBRAW_LIBRARY_BUILD
    }
    else if (tag == 0x9650)
    {
      short a = (short)get2();
      float b = fMAX(1.0f, get2());
      imgdata.makernotes.fuji.FujiExpoMidPointShift = a / b;
    }

    else if (tag == 0x2f00)
    {
      int nWBs = get4();
      nWBs = MIN(nWBs, 6);
      for (int wb_ind = 0; wb_ind < nWBs; wb_ind++)
      {
        FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Custom1 + wb_ind][c ^ 1] = get2();
        fseek(ifp, 8, SEEK_CUR);
      }
    }

    else if (tag == 0x2000)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Auto][c ^ 1] = get2();
    }
    else if (tag == 0x2100)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FineWeather][c ^ 1] = get2();
    }
    else if (tag == 0x2200)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ 1] = get2();
    }
    else if (tag == 0x2300)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][c ^ 1] = get2();
    }
    else if (tag == 0x2301)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][c ^ 1] = get2();
    }
    else if (tag == 0x2302)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][c ^ 1] = get2();
    }
    else if (tag == 0x2310)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_L][c ^ 1] = get2();
    }
    else if (tag == 0x2400)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ 1] = get2();
    }
    else if (tag == 0x2410)
    {
      FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ 1] = get2();
#endif
      // IB end
    }
    else if (tag == 0xc000)
    /* 0xc000 tag versions, second ushort; valid if the first ushort is 0
    X100F	0x0259
    X100T	0x0153
    X-E2	0x014f	0x024f depends on firmware
    X-A1	0x014e
    XQ2		0x0150
    XQ1		0x0150
    X100S	0x0149	0x0249 depends on firmware
    X30		0x0152
    X20		0x0146
    X-T10	0x0154
    X-T2	0x0258
    X-M1	0x014d
    X-E2s	0x0355
    X-A2	0x014e
    X-T20	0x025b
    GFX 50S	0x025a
    X-T1	0x0151	0x0251 0x0351 depends on firmware
    X70		0x0155
    X-Pro2	0x0255
    */
    {
      c = order;
      order = 0x4949;
      if ((tag = get4()) > 10000)
        tag = get4();
      if (tag > 10000)
        tag = get4();
      width = tag;
      height = get4();
#ifdef LIBRAW_LIBRARY_BUILD
      if (!strcmp(model, ""X-A3"") || !strcmp(model, ""X-A10""))
      {
        int wb[4];
        int nWB, tWB, pWB;
        int iCCT = 0;
        int cnt;
        fseek(ifp, save + 0x200, SEEK_SET);
        for (int wb_ind = 0; wb_ind < 42; wb_ind++)
        {
          nWB = get4();
          tWB = get4();
          wb[0] = get4() << 1;
          wb[1] = get4();
          wb[3] = get4();
          wb[2] = get4() << 1;
          if (tWB && (iCCT < 255))
          {
            imgdata.color.WBCT_Coeffs[iCCT][0] = tWB;
            for (cnt = 0; cnt < 4; cnt++)
              imgdata.color.WBCT_Coeffs[iCCT][cnt + 1] = wb[cnt];
            iCCT++;
          }
          if (nWB != 70)
          {
            for (pWB = 1; pWB < nFuji_wb_list2; pWB += 2)
            {
              if (Fuji_wb_list2[pWB] == nWB)
              {
                for (cnt = 0; cnt < 4; cnt++)
                  imgdata.color.WB_Coeffs[Fuji_wb_list2[pWB - 1]][cnt] = wb[cnt];
                break;
              }
            }
          }
        }
      }
      else
      {
        libraw_internal_data.unpacker_data.posRAFData = save;
        libraw_internal_data.unpacker_data.lenRAFData = (len >> 1);
      }
#endif
      order = c;
    }
    fseek(ifp, save + len, SEEK_SET);
  }
  height <<= fuji_layout;
  width >>= fuji_layout;
}","void VAR_0 parse_fuji(int VAR_1)
{
  unsigned VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;

  fseek(VAR_7, VAR_1, VAR_8);
  VAR_2 = get4();
  if (VAR_2 > 255)
    return;
#ifdef VAR_9
  VAR_10.process_warnings |=  VAR_11; 
#endif
  while (VAR_2--)
  {
    VAR_3 = get2();
    VAR_4 = get2();
    VAR_5 = ftell(VAR_7);

    if (VAR_3 == 0x100)
    {
      VAR_12 = get2();
      VAR_13 = get2();
    }
    else if (VAR_3 == 0x121)
    {
      VAR_14 = get2();
      if ((VAR_15 = get2()) == 4284)
        VAR_15 += 3;
    }
    else if (VAR_3 == 0x130)
    {
      VAR_16 = fgetc(VAR_7) >> 7;
      VAR_17 = !(fgetc(VAR_7) & 8);
    }
    else if (VAR_3 == 0x131)
    {
      VAR_18 = 9;
      FORC(36)
        {
	   int VAR_19 = fgetc(VAR_7);
	   VAR_20[0][35 - VAR_6] = MAX(0,MIN(VAR_19,2)); /* COMMENT_0 */
	}
    }
    else if (VAR_3 == 0x2ff0)
    {
      FORC4 VAR_21[VAR_6 ^ 1] = get2();

/* COMMENT_1 */
#ifdef VAR_9
    }
    else if (VAR_3 == 0x9650)
    {
      short VAR_22 = (short)get2();
      float VAR_23 = fMAX(1.0f, get2());
      VAR_10.makernotes.fuji.FujiExpoMidPointShift = VAR_22 / VAR_23;
    }

    else if (VAR_3 == 0x2f00)
    {
      int VAR_24 = get4();
      VAR_24 = MIN(VAR_24, 6);
      for (int VAR_25 = 0; VAR_25 < VAR_24; VAR_25++)
      {
        FORC4 VAR_10.VAR_26.VAR_27[VAR_28 + VAR_25][VAR_6 ^ 1] = get2();
        fseek(VAR_7, 8, VAR_29);
      }
    }

    else if (VAR_3 == 0x2000)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_30][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2100)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_31][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2200)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_32][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2300)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_33][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2301)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_34][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2302)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_35][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2310)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_36][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2400)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_37][VAR_6 ^ 1] = get2();
    }
    else if (VAR_3 == 0x2410)
    {
      FORC4 VAR_10.VAR_26.VAR_27[VAR_38][VAR_6 ^ 1] = get2();
#endif/* COMMENT_2 */
               
    }
    else if (tag == 0xc000)
    /* COMMENT_4 */
                
                
                                          
               
               
               
                                           
               
               
                
               
               
                
               
                
                  
                                                 
               
                 
      
    {
      VAR_6 = VAR_39;
      VAR_39 = 0x4949;
      if ((tag = get4()) > 10000)
        tag = get4();
      if (tag > 10000)
        tag = get4();
      VAR_15 = tag;
      VAR_14 = get4();
#ifdef VAR_9
      if (!strcmp(VAR_40, ""X-A3"") || !strcmp(VAR_40, ""X-A10""))
      {
        int VAR_41[4];
        int VAR_42, VAR_43, VAR_44;
        int VAR_45 = 0;
        int VAR_46;
        fseek(VAR_7, VAR_5 + 0x200, VAR_8);
        for (int VAR_25 = 0; VAR_25 < 42; VAR_25++)
        {
          VAR_42 = get4();
          VAR_43 = get4();
          VAR_41[0] = get4() << 1;
          VAR_41[1] = get4();
          VAR_41[3] = get4();
          VAR_41[2] = get4() << 1;
          if (VAR_43 && (VAR_45 < 255))
          {
            VAR_10.color.WBCT_Coeffs[VAR_45][0] = VAR_43;
            for (VAR_46 = 0; VAR_46 < 4; VAR_46++)
              VAR_10.color.WBCT_Coeffs[VAR_45][VAR_46 + 1] = VAR_41[VAR_46];
            VAR_45++;
          }
          if (VAR_42 != 70)
          {
            for (VAR_44 = 1; VAR_44 < VAR_47; VAR_44 += 2)
            {
              if (VAR_48[VAR_44] == VAR_42)
              {
                for (VAR_46 = 0; VAR_46 < 4; VAR_46++)
                  VAR_10.color.WB_Coeffs[VAR_48[VAR_44 - 1]][VAR_46] = VAR_41[VAR_46];
                break;
              }
            }
          }
        }
      }
      else
      {
        VAR_49.unpacker_data.posRAFData = VAR_5;
        VAR_49.unpacker_data.lenRAFData = (VAR_4 >> 1);
      }
#endif
      VAR_39 = VAR_6;
    }
    fseek(VAR_7, VAR_5 + VAR_4, VAR_8);
  }
  VAR_14 <<= VAR_16;
  VAR_15 >>= VAR_16;
}",,"--- func_before
+++ func_after
@@ -6,6 +6,9 @@
   entries = get4();
   if (entries > 255)
     return;
+#ifdef LIBRAW_LIBRARY_BUILD
+  imgdata.process_warnings |=  LIBRAW_WARN_PARSEFUJI_PROCESSED; 
+#endif
   while (entries--)
   {
     tag = get2();","{'deleted_lines': [], 'added_lines': ['#ifdef LIBRAW_LIBRARY_BUILD', '  imgdata.process_warnings |=  LIBRAW_WARN_PARSEFUJI_PROCESSED; ', '#endif']}",True,"An error related to the ""LibRaw::panasonic_load_raw()"" function (dcraw_common.cpp) in LibRaw versions prior to 0.18.6 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash via a specially crafted TIFF image.",8.8,HIGH,2,test,2017-12-02T09:01:40Z,2
CVE-2017-17712,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"net: ipv4: fix for a race condition in raw_sendmsg

inet->hdrincl is racy, and could lead to uninitialized stack pointer
usage, so its value should be read only once.

Fixes: c008ba5bdc9f (""ipv4: Avoid reading user iov twice after raw_probe_proto_opt"")
Signed-off-by: Mohamed Ghannam <simo.ghannam@gmail.com>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,https://github.com/torvalds/linux/commit/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483,net/ipv4/raw.c,raw_sendmsg,"static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
{
struct inet_sock *inet = inet_sk(sk);
struct net *net = sock_net(sk);
struct ipcm_cookie ipc;
struct rtable *rt = NULL;
struct flowi4 fl4;
int free = 0;
__be32 daddr;
__be32 saddr;
u8  tos;
int err;
struct ip_options_data opt_copy;
struct raw_frag_vec rfv;
err = -EMSGSIZE;
if (len > 0xFFFF)
goto out;
err = -EOPNOTSUPP;
if (msg->msg_flags & MSG_OOB)
goto out;               
if (msg->msg_namelen) {
DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
err = -EINVAL;
if (msg->msg_namelen < sizeof(*usin))
goto out;
if (usin->sin_family != AF_INET) {
pr_info_once(""%s: %s forgot to set AF_INET. Fix it!\n"",
__func__, current->comm);
err = -EAFNOSUPPORT;
if (usin->sin_family)
goto out;
}
daddr = usin->sin_addr.s_addr;
} else {
err = -EDESTADDRREQ;
if (sk->sk_state != TCP_ESTABLISHED)
goto out;
daddr = inet->inet_daddr;
}
ipc.sockc.tsflags = sk->sk_tsflags;
ipc.addr = inet->inet_saddr;
ipc.opt = NULL;
ipc.tx_flags = 0;
ipc.ttl = 0;
ipc.tos = -1;
ipc.oif = sk->sk_bound_dev_if;
if (msg->msg_controllen) {
err = ip_cmsg_send(sk, msg, &ipc, false);
if (unlikely(err)) {
kfree(ipc.opt);
goto out;
}
if (ipc.opt)
free = 1;
}
saddr = ipc.addr;
ipc.addr = daddr;
if (!ipc.opt) {
struct ip_options_rcu *inet_opt;
rcu_read_lock();
inet_opt = rcu_dereference(inet->inet_opt);
if (inet_opt) {
memcpy(&opt_copy, inet_opt,
sizeof(*inet_opt) + inet_opt->opt.optlen);
ipc.opt = &opt_copy.opt;
}
rcu_read_unlock();
}
if (ipc.opt) {
err = -EINVAL;
if (inet->hdrincl)
goto done;
if (ipc.opt->opt.srr) {
if (!daddr)
goto done;
daddr = ipc.opt->opt.faddr;
}
}
tos = get_rtconn_flags(&ipc, sk);
if (msg->msg_flags & MSG_DONTROUTE)
tos |= RTO_ONLINK;
if (ipv4_is_multicast(daddr)) {
if (!ipc.oif)
ipc.oif = inet->mc_index;
if (!saddr)
saddr = inet->mc_addr;
} else if (!ipc.oif)
ipc.oif = inet->uc_index;
flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
RT_SCOPE_UNIVERSE,
inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,
inet_sk_flowi_flags(sk) |
(inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),
daddr, saddr, 0, 0, sk->sk_uid);
if (!inet->hdrincl) {
rfv.msg = msg;
rfv.hlen = 0;
err = raw_probe_proto_opt(&rfv, &fl4);
if (err)
goto done;
}
security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
rt = ip_route_output_flow(net, &fl4, sk);
if (IS_ERR(rt)) {
err = PTR_ERR(rt);
rt = NULL;
goto done;
}
err = -EACCES;
if (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))
goto done;
if (msg->msg_flags & MSG_CONFIRM)
goto do_confirm;
back_from_confirm:
if (inet->hdrincl)
err = raw_send_hdrinc(sk, &fl4, msg, len,
&rt, msg->msg_flags, &ipc.sockc);
else {
sock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);
if (!ipc.addr)
ipc.addr = fl4.daddr;
lock_sock(sk);
err = ip_append_data(sk, &fl4, raw_getfrag,
&rfv, len, 0,
&ipc, &rt, msg->msg_flags);
if (err)
ip_flush_pending_frames(sk);
else if (!(msg->msg_flags & MSG_MORE)) {
err = ip_push_pending_frames(sk, &fl4);
if (err == -ENOBUFS && !inet->recverr)
err = 0;
}
release_sock(sk);
}
done:
if (free)
kfree(ipc.opt);
ip_rt_put(rt);
out:
if (err < 0)
return err;
return len;
do_confirm:
if (msg->msg_flags & MSG_PROBE)
dst_confirm_neigh(&rt->dst, &fl4.daddr);
if (!(msg->msg_flags & MSG_PROBE) || len)
goto back_from_confirm;
err = 0;
goto done;
}","static int raw_sendmsg(struct sock *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
struct inet_sock *VAR_3 = inet_sk(VAR_0);
struct net *net = sock_net(VAR_0);
struct ipcm_cookie VAR_4;
struct rtable *VAR_5 = NULL;
struct flowi4 VAR_6;
int VAR_7 = 0;
__be32 VAR_8;
__be32 VAR_9;
u8  VAR_10;
int VAR_11;
struct ip_options_data VAR_12;
struct raw_frag_vec VAR_13;
VAR_11 = -VAR_14;
if (VAR_2 > 0xFFFF)
goto out;
VAR_11 = -VAR_15;
if (VAR_1->msg_flags & VAR_16)
goto out;               
if (VAR_1->msg_namelen) {
VAR_17(struct sockaddr_in *, VAR_18, VAR_1->msg_name);
VAR_11 = -VAR_19;
if (VAR_1->msg_namelen < sizeof(*VAR_18))
goto out;
if (VAR_18->sin_family != VAR_20) {
pr_info_once(""%s: %s forgot to set AF_INET. Fix it!\n"",
VAR_21, VAR_22->comm);
VAR_11 = -VAR_23;
if (VAR_18->sin_family)
goto out;
}
VAR_8 = VAR_18->sin_addr.s_addr;
} else {
VAR_11 = -VAR_24;
if (VAR_0->sk_state != VAR_25)
goto out;
VAR_8 = VAR_3->inet_daddr;
}
VAR_4.sockc.tsflags = VAR_0->sk_tsflags;
VAR_4.addr = VAR_3->inet_saddr;
VAR_4.opt = NULL;
VAR_4.tx_flags = 0;
VAR_4.ttl = 0;
VAR_4.tos = -1;
VAR_4.oif = VAR_0->sk_bound_dev_if;
if (VAR_1->msg_controllen) {
VAR_11 = ip_cmsg_send(VAR_0, VAR_1, &VAR_4, false);
if (unlikely(VAR_11)) {
kfree(VAR_4.opt);
goto out;
}
if (VAR_4.opt)
VAR_7 = 1;
}
VAR_9 = VAR_4.addr;
VAR_4.addr = VAR_8;
if (!VAR_4.opt) {
struct ip_options_rcu *VAR_26;
rcu_read_lock();
VAR_26 = rcu_dereference(VAR_3->inet_opt);
if (VAR_26) {
memcpy(&VAR_12, VAR_26,
sizeof(*VAR_26) + VAR_26->opt.optlen);
VAR_4.opt = &VAR_12.opt;
}
rcu_read_unlock();
}
if (VAR_4.opt) {
VAR_11 = -VAR_19;
if (VAR_3->hdrincl)
goto done;
if (VAR_4.opt->opt.srr) {
if (!VAR_8)
goto done;
VAR_8 = VAR_4.opt->opt.faddr;
}
}
VAR_10 = get_rtconn_flags(&VAR_4, VAR_0);
if (VAR_1->msg_flags & VAR_27)
VAR_10 |= VAR_28;
if (ipv4_is_multicast(VAR_8)) {
if (!VAR_4.oif)
VAR_4.oif = VAR_3->mc_index;
if (!VAR_9)
VAR_9 = VAR_3->mc_addr;
} else if (!VAR_4.oif)
VAR_4.oif = VAR_3->uc_index;
flowi4_init_output(&VAR_6, VAR_4.oif, VAR_0->sk_mark, VAR_10,
VAR_29,
VAR_3->hdrincl ? VAR_30 : VAR_0->sk_protocol,
inet_sk_flowi_flags(VAR_0) |
(VAR_3->hdrincl ? VAR_31 : 0),
VAR_8, VAR_9, 0, 0, VAR_0->sk_uid);
if (!VAR_3->hdrincl) {
VAR_13.msg = VAR_1;
VAR_13.hlen = 0;
VAR_11 = raw_probe_proto_opt(&VAR_13, &VAR_6);
if (VAR_11)
goto done;
}
security_sk_classify_flow(VAR_0, flowi4_to_flowi(&VAR_6));
VAR_5 = ip_route_output_flow(net, &VAR_6, VAR_0);
if (IS_ERR(VAR_5)) {
VAR_11 = PTR_ERR(VAR_5);
VAR_5 = NULL;
goto done;
}
VAR_11 = -VAR_32;
if (VAR_5->rt_flags & VAR_33 && !sock_flag(VAR_0, VAR_34))
goto done;
if (VAR_1->msg_flags & VAR_35)
goto do_confirm;
back_from_confirm:
if (VAR_3->hdrincl)
VAR_11 = raw_send_hdrinc(VAR_0, &VAR_6, VAR_1, VAR_2,
&VAR_5, VAR_1->msg_flags, &VAR_4.sockc);
else {
sock_tx_timestamp(VAR_0, VAR_4.sockc.tsflags, &VAR_4.tx_flags);
if (!VAR_4.addr)
VAR_4.addr = VAR_6.daddr;
lock_sock(VAR_0);
VAR_11 = ip_append_data(VAR_0, &VAR_6, VAR_36,
&VAR_13, VAR_2, 0,
&VAR_4, &VAR_5, VAR_1->msg_flags);
if (VAR_11)
ip_flush_pending_frames(VAR_0);
else if (!(VAR_1->msg_flags & VAR_37)) {
VAR_11 = ip_push_pending_frames(VAR_0, &VAR_6);
if (VAR_11 == -VAR_38 && !VAR_3->recverr)
VAR_11 = 0;
}
release_sock(VAR_0);
}
done:
if (VAR_7)
kfree(VAR_4.opt);
ip_rt_put(VAR_5);
out:
if (VAR_11 < 0)
return VAR_11;
return VAR_2;
do_confirm:
if (VAR_1->msg_flags & VAR_39)
dst_confirm_neigh(&VAR_5->dst, &VAR_6.daddr);
if (!(VAR_1->msg_flags & VAR_39) || VAR_2)
goto back_from_confirm;
VAR_11 = 0;
goto done;
}",torvalds/linux/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483/raw.c/vul/before/0.json,"static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct net *net = sock_net(sk);
	struct ipcm_cookie ipc;
	struct rtable *rt = NULL;
	struct flowi4 fl4;
	int free = 0;
	__be32 daddr;
	__be32 saddr;
	u8  tos;
	int err;
	struct ip_options_data opt_copy;
	struct raw_frag_vec rfv;
	int hdrincl;

	err = -EMSGSIZE;
	if (len > 0xFFFF)
		goto out;

	/* hdrincl should be READ_ONCE(inet->hdrincl)
	 * but READ_ONCE() doesn't work with bit fields
	 */
	hdrincl = inet->hdrincl;
	/*
	 *	Check the flags.
	 */

	err = -EOPNOTSUPP;
	if (msg->msg_flags & MSG_OOB)	/* Mirror BSD error message */
		goto out;               /* compatibility */

	/*
	 *	Get and verify the address.
	 */

	if (msg->msg_namelen) {
		DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
		err = -EINVAL;
		if (msg->msg_namelen < sizeof(*usin))
			goto out;
		if (usin->sin_family != AF_INET) {
			pr_info_once(""%s: %s forgot to set AF_INET. Fix it!\n"",
				     __func__, current->comm);
			err = -EAFNOSUPPORT;
			if (usin->sin_family)
				goto out;
		}
		daddr = usin->sin_addr.s_addr;
		/* ANK: I did not forget to get protocol from port field.
		 * I just do not know, who uses this weirdness.
		 * IP_HDRINCL is much more convenient.
		 */
	} else {
		err = -EDESTADDRREQ;
		if (sk->sk_state != TCP_ESTABLISHED)
			goto out;
		daddr = inet->inet_daddr;
	}

	ipc.sockc.tsflags = sk->sk_tsflags;
	ipc.addr = inet->inet_saddr;
	ipc.opt = NULL;
	ipc.tx_flags = 0;
	ipc.ttl = 0;
	ipc.tos = -1;
	ipc.oif = sk->sk_bound_dev_if;

	if (msg->msg_controllen) {
		err = ip_cmsg_send(sk, msg, &ipc, false);
		if (unlikely(err)) {
			kfree(ipc.opt);
			goto out;
		}
		if (ipc.opt)
			free = 1;
	}

	saddr = ipc.addr;
	ipc.addr = daddr;

	if (!ipc.opt) {
		struct ip_options_rcu *inet_opt;

		rcu_read_lock();
		inet_opt = rcu_dereference(inet->inet_opt);
		if (inet_opt) {
			memcpy(&opt_copy, inet_opt,
			       sizeof(*inet_opt) + inet_opt->opt.optlen);
			ipc.opt = &opt_copy.opt;
		}
		rcu_read_unlock();
	}

	if (ipc.opt) {
		err = -EINVAL;
		/* Linux does not mangle headers on raw sockets,
		 * so that IP options + IP_HDRINCL is non-sense.
		 */
		if (hdrincl)
			goto done;
		if (ipc.opt->opt.srr) {
			if (!daddr)
				goto done;
			daddr = ipc.opt->opt.faddr;
		}
	}
	tos = get_rtconn_flags(&ipc, sk);
	if (msg->msg_flags & MSG_DONTROUTE)
		tos |= RTO_ONLINK;

	if (ipv4_is_multicast(daddr)) {
		if (!ipc.oif)
			ipc.oif = inet->mc_index;
		if (!saddr)
			saddr = inet->mc_addr;
	} else if (!ipc.oif)
		ipc.oif = inet->uc_index;

	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
			   RT_SCOPE_UNIVERSE,
			   hdrincl ? IPPROTO_RAW : sk->sk_protocol,
			   inet_sk_flowi_flags(sk) |
			    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),
			   daddr, saddr, 0, 0, sk->sk_uid);

	if (!hdrincl) {
		rfv.msg = msg;
		rfv.hlen = 0;

		err = raw_probe_proto_opt(&rfv, &fl4);
		if (err)
			goto done;
	}

	security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
	rt = ip_route_output_flow(net, &fl4, sk);
	if (IS_ERR(rt)) {
		err = PTR_ERR(rt);
		rt = NULL;
		goto done;
	}

	err = -EACCES;
	if (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))
		goto done;

	if (msg->msg_flags & MSG_CONFIRM)
		goto do_confirm;
back_from_confirm:

	if (hdrincl)
		err = raw_send_hdrinc(sk, &fl4, msg, len,
				      &rt, msg->msg_flags, &ipc.sockc);

	 else {
		sock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);

		if (!ipc.addr)
			ipc.addr = fl4.daddr;
		lock_sock(sk);
		err = ip_append_data(sk, &fl4, raw_getfrag,
				     &rfv, len, 0,
				     &ipc, &rt, msg->msg_flags);
		if (err)
			ip_flush_pending_frames(sk);
		else if (!(msg->msg_flags & MSG_MORE)) {
			err = ip_push_pending_frames(sk, &fl4);
			if (err == -ENOBUFS && !inet->recverr)
				err = 0;
		}
		release_sock(sk);
	}
done:
	if (free)
		kfree(ipc.opt);
	ip_rt_put(rt);

out:
	if (err < 0)
		return err;
	return len;

do_confirm:
	if (msg->msg_flags & MSG_PROBE)
		dst_confirm_neigh(&rt->dst, &fl4.daddr);
	if (!(msg->msg_flags & MSG_PROBE) || len)
		goto back_from_confirm;
	err = 0;
	goto done;
}","static int raw_sendmsg(struct sock *VAR_0, struct msghdr *VAR_1, size_t VAR_2)
{
	struct inet_sock *VAR_3 = inet_sk(VAR_0);
	struct net *net = sock_net(VAR_0);
	struct ipcm_cookie VAR_4;
	struct rtable *VAR_5 = NULL;
	struct flowi4 VAR_6;
	int VAR_7 = 0;
	__be32 VAR_8;
	__be32 VAR_9;
	u8  VAR_10;
	int VAR_11;
	struct ip_options_data VAR_12;
	struct raw_frag_vec VAR_13;
	int VAR_14;

	VAR_11 = -VAR_15;
	if (VAR_2 > 0xFFFF)
		goto out;

	/* COMMENT_0 */
                                                
    
	VAR_14 = VAR_3->hdrincl;
	/* COMMENT_3 */
                    
    

	VAR_11 = -VAR_16;
	if (VAR_1->msg_flags & VAR_17)	/* COMMENT_6 */
		goto out;               /* COMMENT_7 */

	/* COMMENT_8 */
                               
    

	if (VAR_1->msg_namelen) {
		VAR_18(struct sockaddr_in *, VAR_19, VAR_1->msg_name);
		VAR_11 = -VAR_20;
		if (VAR_1->msg_namelen < sizeof(*VAR_19))
			goto out;
		if (VAR_19->sin_family != VAR_21) {
			pr_info_once(""%s: %s forgot to set AF_INET. Fix it!\n"",
				     VAR_22, VAR_23->comm);
			VAR_11 = -VAR_24;
			if (VAR_19->sin_family)
				goto out;
		}
		VAR_8 = VAR_19->sin_addr.s_addr;
		/* COMMENT_11 */
                                                 
                                        
     
	} else {
		VAR_11 = -VAR_25;
		if (VAR_0->sk_state != VAR_26)
			goto out;
		VAR_8 = VAR_3->inet_daddr;
	}

	VAR_4.sockc.tsflags = VAR_0->sk_tsflags;
	VAR_4.addr = VAR_3->inet_saddr;
	VAR_4.opt = NULL;
	VAR_4.tx_flags = 0;
	VAR_4.ttl = 0;
	VAR_4.tos = -1;
	VAR_4.oif = VAR_0->sk_bound_dev_if;

	if (VAR_1->msg_controllen) {
		VAR_11 = ip_cmsg_send(VAR_0, VAR_1, &VAR_4, false);
		if (unlikely(VAR_11)) {
			kfree(VAR_4.opt);
			goto out;
		}
		if (VAR_4.opt)
			VAR_7 = 1;
	}

	VAR_9 = VAR_4.addr;
	VAR_4.addr = VAR_8;

	if (!VAR_4.opt) {
		struct ip_options_rcu *VAR_27;

		rcu_read_lock();
		VAR_27 = rcu_dereference(VAR_3->inet_opt);
		if (VAR_27) {
			memcpy(&VAR_12, VAR_27,
			       sizeof(*VAR_27) + VAR_27->opt.optlen);
			VAR_4.opt = &VAR_12.opt;
		}
		rcu_read_unlock();
	}

	if (VAR_4.opt) {
		VAR_11 = -VAR_20;
		/* COMMENT_15 */
                                                  
     
		if (VAR_14)
			goto done;
		if (VAR_4.opt->opt.srr) {
			if (!VAR_8)
				goto done;
			VAR_8 = VAR_4.opt->opt.faddr;
		}
	}
	VAR_10 = get_rtconn_flags(&VAR_4, VAR_0);
	if (VAR_1->msg_flags & VAR_28)
		VAR_10 |= VAR_29;

	if (ipv4_is_multicast(VAR_8)) {
		if (!VAR_4.oif)
			VAR_4.oif = VAR_3->mc_index;
		if (!VAR_9)
			VAR_9 = VAR_3->mc_addr;
	} else if (!VAR_4.oif)
		VAR_4.oif = VAR_3->uc_index;

	flowi4_init_output(&VAR_6, VAR_4.oif, VAR_0->sk_mark, VAR_10,
			   VAR_30,
			   VAR_14 ? VAR_31 : VAR_0->sk_protocol,
			   inet_sk_flowi_flags(VAR_0) |
			    (VAR_14 ? VAR_32 : 0),
			   VAR_8, VAR_9, 0, 0, VAR_0->sk_uid);

	if (!VAR_14) {
		VAR_13.msg = VAR_1;
		VAR_13.hlen = 0;

		VAR_11 = raw_probe_proto_opt(&VAR_13, &VAR_6);
		if (VAR_11)
			goto done;
	}

	security_sk_classify_flow(VAR_0, flowi4_to_flowi(&VAR_6));
	VAR_5 = ip_route_output_flow(net, &VAR_6, VAR_0);
	if (IS_ERR(VAR_5)) {
		VAR_11 = PTR_ERR(VAR_5);
		VAR_5 = NULL;
		goto done;
	}

	VAR_11 = -VAR_33;
	if (VAR_5->rt_flags & VAR_34 && !sock_flag(VAR_0, VAR_35))
		goto done;

	if (VAR_1->msg_flags & VAR_36)
		goto do_confirm;
back_from_confirm:

	if (VAR_14)
		VAR_11 = raw_send_hdrinc(VAR_0, &VAR_6, VAR_1, VAR_2,
				      &VAR_5, VAR_1->msg_flags, &VAR_4.sockc);

	 else {
		sock_tx_timestamp(VAR_0, VAR_4.sockc.tsflags, &VAR_4.tx_flags);

		if (!VAR_4.addr)
			VAR_4.addr = VAR_6.daddr;
		lock_sock(VAR_0);
		VAR_11 = ip_append_data(VAR_0, &VAR_6, VAR_37,
				     &VAR_13, VAR_2, 0,
				     &VAR_4, &VAR_5, VAR_1->msg_flags);
		if (VAR_11)
			ip_flush_pending_frames(VAR_0);
		else if (!(VAR_1->msg_flags & VAR_38)) {
			VAR_11 = ip_push_pending_frames(VAR_0, &VAR_6);
			if (VAR_11 == -VAR_39 && !VAR_3->recverr)
				VAR_11 = 0;
		}
		release_sock(VAR_0);
	}
done:
	if (VAR_7)
		kfree(VAR_4.opt);
	ip_rt_put(VAR_5);

out:
	if (VAR_11 < 0)
		return VAR_11;
	return VAR_2;

do_confirm:
	if (VAR_1->msg_flags & VAR_40)
		dst_confirm_neigh(&VAR_5->dst, &VAR_6.daddr);
	if (!(VAR_1->msg_flags & VAR_40) || VAR_2)
		goto back_from_confirm;
	VAR_11 = 0;
	goto done;
}",torvalds/linux/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483/raw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,11 +12,16 @@
 	int err;
 	struct ip_options_data opt_copy;
 	struct raw_frag_vec rfv;
+	int hdrincl;
 
 	err = -EMSGSIZE;
 	if (len > 0xFFFF)
 		goto out;
 
+	/* hdrincl should be READ_ONCE(inet->hdrincl)
+	 * but READ_ONCE() doesn't work with bit fields
+	 */
+	hdrincl = inet->hdrincl;
 	/*
 	 *	Check the flags.
 	 */
@@ -92,7 +97,7 @@
 		/* Linux does not mangle headers on raw sockets,
 		 * so that IP options + IP_HDRINCL is non-sense.
 		 */
-		if (inet->hdrincl)
+		if (hdrincl)
 			goto done;
 		if (ipc.opt->opt.srr) {
 			if (!daddr)
@@ -114,12 +119,12 @@
 
 	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
 			   RT_SCOPE_UNIVERSE,
-			   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,
+			   hdrincl ? IPPROTO_RAW : sk->sk_protocol,
 			   inet_sk_flowi_flags(sk) |
-			    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),
+			    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),
 			   daddr, saddr, 0, 0, sk->sk_uid);
 
-	if (!inet->hdrincl) {
+	if (!hdrincl) {
 		rfv.msg = msg;
 		rfv.hlen = 0;
 
@@ -144,7 +149,7 @@
 		goto do_confirm;
 back_from_confirm:
 
-	if (inet->hdrincl)
+	if (hdrincl)
 		err = raw_send_hdrinc(sk, &fl4, msg, len,
 				      &rt, msg->msg_flags, &ipc.sockc);
 ","{'deleted_lines': ['\t\tif (inet->hdrincl)', '\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,', '\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),', '\tif (!inet->hdrincl) {', '\tif (inet->hdrincl)'], 'added_lines': ['\tint hdrincl;', '\t/* hdrincl should be READ_ONCE(inet->hdrincl)', ""\t * but READ_ONCE() doesn't work with bit fields"", '\t */', '\thdrincl = inet->hdrincl;', '\t\tif (hdrincl)', '\t\t\t   hdrincl ? IPPROTO_RAW : sk->sk_protocol,', '\t\t\t    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),', '\tif (!hdrincl) {', '\tif (hdrincl)']}",True,The raw_sendmsg() function in net/ipv4/raw.c in the Linux kernel through 4.14.6 has a race condition in inet->hdrincl that leads to uninitialized stack pointer usage; this allows a local user to execute code and gain privileges.,7.0,HIGH,2,test,2017-12-10T03:50:58Z,2
CVE-2017-17853,['CWE-119'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"bpf/verifier: fix bounds calculation on BPF_RSH

Incorrect signed bounds were being computed.
If the old upper signed bound was positive and the old lower signed bound was
negative, this could cause the new upper signed bound to be too low,
leading to security issues.

Fixes: b03c9f9fdc37 (""bpf/verifier: track signed and unsigned min/max values"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Edward Cree <ecree@solarflare.com>
Acked-by: Alexei Starovoitov <ast@kernel.org>
[jannh@google.com: changed description to reflect bug impact]
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>",4374f256ce8182019353c0c639bb8d0695b4c941,https://github.com/torvalds/linux/commit/4374f256ce8182019353c0c639bb8d0695b4c941,kernel/bpf/verifier.c,adjust_scalar_min_max_vals,"static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
struct bpf_insn *insn,
struct bpf_reg_state *dst_reg,
struct bpf_reg_state src_reg)
{
struct bpf_reg_state *regs = cur_regs(env);
u8 opcode = BPF_OP(insn->code);
bool src_known, dst_known;
s64 smin_val, smax_val;
u64 umin_val, umax_val;
if (BPF_CLASS(insn->code) != BPF_ALU64) {
coerce_reg_to_32(dst_reg);
coerce_reg_to_32(&src_reg);
}
smin_val = src_reg.smin_value;
smax_val = src_reg.smax_value;
umin_val = src_reg.umin_value;
umax_val = src_reg.umax_value;
src_known = tnum_is_const(src_reg.var_off);
dst_known = tnum_is_const(dst_reg->var_off);
switch (opcode) {
case BPF_ADD:
if (signed_add_overflows(dst_reg->smin_value, smin_val) ||
signed_add_overflows(dst_reg->smax_value, smax_val)) {
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value += smin_val;
dst_reg->smax_value += smax_val;
}
if (dst_reg->umin_value + umin_val < umin_val ||
dst_reg->umax_value + umax_val < umax_val) {
dst_reg->umin_value = 0;
dst_reg->umax_value = U64_MAX;
} else {
dst_reg->umin_value += umin_val;
dst_reg->umax_value += umax_val;
}
dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);
break;
case BPF_SUB:
if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||
signed_sub_overflows(dst_reg->smax_value, smin_val)) {
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value -= smax_val;
dst_reg->smax_value -= smin_val;
}
if (dst_reg->umin_value < umax_val) {
dst_reg->umin_value = 0;
dst_reg->umax_value = U64_MAX;
} else {
dst_reg->umin_value -= umax_val;
dst_reg->umax_value -= umin_val;
}
dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);
break;
case BPF_MUL:
dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);
if (smin_val < 0 || dst_reg->smin_value < 0) {
__mark_reg_unbounded(dst_reg);
__update_reg_bounds(dst_reg);
break;
}
if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {
__mark_reg_unbounded(dst_reg);
__update_reg_bounds(dst_reg);
break;
}
dst_reg->umin_value *= umin_val;
dst_reg->umax_value *= umax_val;
if (dst_reg->umax_value > S64_MAX) {
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value = dst_reg->umin_value;
dst_reg->smax_value = dst_reg->umax_value;
}
break;
case BPF_AND:
if (src_known && dst_known) {
__mark_reg_known(dst_reg, dst_reg->var_off.value &
src_reg.var_off.value);
break;
}
dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);
dst_reg->umin_value = dst_reg->var_off.value;
dst_reg->umax_value = min(dst_reg->umax_value, umax_val);
if (dst_reg->smin_value < 0 || smin_val < 0) {
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value = dst_reg->umin_value;
dst_reg->smax_value = dst_reg->umax_value;
}
__update_reg_bounds(dst_reg);
break;
case BPF_OR:
if (src_known && dst_known) {
__mark_reg_known(dst_reg, dst_reg->var_off.value |
src_reg.var_off.value);
break;
}
dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);
dst_reg->umin_value = max(dst_reg->umin_value, umin_val);
dst_reg->umax_value = dst_reg->var_off.value |
dst_reg->var_off.mask;
if (dst_reg->smin_value < 0 || smin_val < 0) {
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value = dst_reg->umin_value;
dst_reg->smax_value = dst_reg->umax_value;
}
__update_reg_bounds(dst_reg);
break;
case BPF_LSH:
if (umax_val > 63) {
mark_reg_unknown(env, regs, insn->dst_reg);
break;
}
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
if (dst_reg->umax_value > 1ULL << (63 - umax_val)) {
dst_reg->umin_value = 0;
dst_reg->umax_value = U64_MAX;
} else {
dst_reg->umin_value <<= umin_val;
dst_reg->umax_value <<= umax_val;
}
if (src_known)
dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);
else
dst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);
__update_reg_bounds(dst_reg);
break;
case BPF_RSH:
if (umax_val > 63) {
mark_reg_unknown(env, regs, insn->dst_reg);
break;
}
if (dst_reg->smin_value < 0) {
if (umin_val) {
dst_reg->smin_value = 0;
} else {
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
}
} else {
dst_reg->smin_value =
(u64)(dst_reg->smin_value) >> umax_val;
}
if (src_known)
dst_reg->var_off = tnum_rshift(dst_reg->var_off,
umin_val);
else
dst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);
dst_reg->umin_value >>= umax_val;
dst_reg->umax_value >>= umin_val;
__update_reg_bounds(dst_reg);
break;
default:
mark_reg_unknown(env, regs, insn->dst_reg);
break;
}
__reg_deduce_bounds(dst_reg);
__reg_bound_offset(dst_reg);
return 0;
}","static int adjust_scalar_min_max_vals(struct bpf_verifier_env *VAR_0,
struct bpf_insn *VAR_1,
struct bpf_reg_state *VAR_2,
struct bpf_reg_state VAR_3)
{
struct bpf_reg_state *VAR_4 = cur_regs(VAR_0);
u8 VAR_5 = BPF_OP(VAR_1->code);
bool VAR_6, VAR_7;
s64 VAR_8, VAR_9;
u64 VAR_10, VAR_11;
if (BPF_CLASS(VAR_1->code) != VAR_12) {
coerce_reg_to_32(VAR_2);
coerce_reg_to_32(&VAR_3);
}
VAR_8 = VAR_3.smin_value;
VAR_9 = VAR_3.smax_value;
VAR_10 = VAR_3.umin_value;
VAR_11 = VAR_3.umax_value;
VAR_6 = tnum_is_const(VAR_3.var_off);
VAR_7 = tnum_is_const(VAR_2->var_off);
switch (VAR_5) {
case VAR_13:
if (signed_add_overflows(VAR_2->smin_value, VAR_8) ||
signed_add_overflows(VAR_2->smax_value, VAR_9)) {
VAR_2->smin_value = VAR_14;
VAR_2->smax_value = VAR_15;
} else {
VAR_2->smin_value += VAR_8;
VAR_2->smax_value += VAR_9;
}
if (VAR_2->umin_value + VAR_10 < VAR_10 ||
VAR_2->umax_value + VAR_11 < VAR_11) {
VAR_2->umin_value = 0;
VAR_2->umax_value = VAR_16;
} else {
VAR_2->umin_value += VAR_10;
VAR_2->umax_value += VAR_11;
}
VAR_2->var_off = tnum_add(VAR_2->var_off, VAR_3.var_off);
break;
case VAR_17:
if (signed_sub_overflows(VAR_2->smin_value, VAR_9) ||
signed_sub_overflows(VAR_2->smax_value, VAR_8)) {
VAR_2->smin_value = VAR_14;
VAR_2->smax_value = VAR_15;
} else {
VAR_2->smin_value -= VAR_9;
VAR_2->smax_value -= VAR_8;
}
if (VAR_2->umin_value < VAR_11) {
VAR_2->umin_value = 0;
VAR_2->umax_value = VAR_16;
} else {
VAR_2->umin_value -= VAR_11;
VAR_2->umax_value -= VAR_10;
}
VAR_2->var_off = tnum_sub(VAR_2->var_off, VAR_3.var_off);
break;
case VAR_18:
VAR_2->var_off = tnum_mul(VAR_2->var_off, VAR_3.var_off);
if (VAR_8 < 0 || VAR_2->smin_value < 0) {
__mark_reg_unbounded(VAR_2);
__update_reg_bounds(VAR_2);
break;
}
if (VAR_11 > VAR_19 || VAR_2->umax_value > VAR_19) {
__mark_reg_unbounded(VAR_2);
__update_reg_bounds(VAR_2);
break;
}
VAR_2->umin_value *= VAR_10;
VAR_2->umax_value *= VAR_11;
if (VAR_2->umax_value > VAR_15) {
VAR_2->smin_value = VAR_14;
VAR_2->smax_value = VAR_15;
} else {
VAR_2->smin_value = VAR_2->umin_value;
VAR_2->smax_value = VAR_2->umax_value;
}
break;
case VAR_20:
if (VAR_6 && VAR_7) {
__mark_reg_known(VAR_2, VAR_2->var_off.value &
VAR_3.var_off.value);
break;
}
VAR_2->var_off = tnum_and(VAR_2->var_off, VAR_3.var_off);
VAR_2->umin_value = VAR_2->var_off.value;
VAR_2->umax_value = min(VAR_2->umax_value, VAR_11);
if (VAR_2->smin_value < 0 || VAR_8 < 0) {
VAR_2->smin_value = VAR_14;
VAR_2->smax_value = VAR_15;
} else {
VAR_2->smin_value = VAR_2->umin_value;
VAR_2->smax_value = VAR_2->umax_value;
}
__update_reg_bounds(VAR_2);
break;
case VAR_21:
if (VAR_6 && VAR_7) {
__mark_reg_known(VAR_2, VAR_2->var_off.value |
VAR_3.var_off.value);
break;
}
VAR_2->var_off = tnum_or(VAR_2->var_off, VAR_3.var_off);
VAR_2->umin_value = max(VAR_2->umin_value, VAR_10);
VAR_2->umax_value = VAR_2->var_off.value |
VAR_2->var_off.mask;
if (VAR_2->smin_value < 0 || VAR_8 < 0) {
VAR_2->smin_value = VAR_14;
VAR_2->smax_value = VAR_15;
} else {
VAR_2->smin_value = VAR_2->umin_value;
VAR_2->smax_value = VAR_2->umax_value;
}
__update_reg_bounds(VAR_2);
break;
case VAR_22:
if (VAR_11 > 63) {
mark_reg_unknown(VAR_0, VAR_4, VAR_1->dst_reg);
break;
}
VAR_2->smin_value = VAR_14;
VAR_2->smax_value = VAR_15;
if (VAR_2->umax_value > 1ULL << (63 - VAR_11)) {
VAR_2->umin_value = 0;
VAR_2->umax_value = VAR_16;
} else {
VAR_2->umin_value <<= VAR_10;
VAR_2->umax_value <<= VAR_11;
}
if (VAR_6)
VAR_2->var_off = tnum_lshift(VAR_2->var_off, VAR_10);
else
VAR_2->var_off = tnum_lshift(VAR_23, VAR_10);
__update_reg_bounds(VAR_2);
break;
case VAR_24:
if (VAR_11 > 63) {
mark_reg_unknown(VAR_0, VAR_4, VAR_1->dst_reg);
break;
}
if (VAR_2->smin_value < 0) {
if (VAR_10) {
VAR_2->smin_value = 0;
} else {
VAR_2->smin_value = VAR_14;
VAR_2->smax_value = VAR_15;
}
} else {
VAR_2->smin_value =
(u64)(VAR_2->smin_value) >> VAR_11;
}
if (VAR_6)
VAR_2->var_off = tnum_rshift(VAR_2->var_off,
VAR_10);
else
VAR_2->var_off = tnum_rshift(VAR_23, VAR_10);
VAR_2->umin_value >>= VAR_11;
VAR_2->umax_value >>= VAR_10;
__update_reg_bounds(VAR_2);
break;
default:
mark_reg_unknown(VAR_0, VAR_4, VAR_1->dst_reg);
break;
}
__reg_deduce_bounds(VAR_2);
__reg_bound_offset(VAR_2);
return 0;
}",torvalds/linux/4374f256ce8182019353c0c639bb8d0695b4c941/verifier.c/vul/before/0.json,"static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
				      struct bpf_insn *insn,
				      struct bpf_reg_state *dst_reg,
				      struct bpf_reg_state src_reg)
{
	struct bpf_reg_state *regs = cur_regs(env);
	u8 opcode = BPF_OP(insn->code);
	bool src_known, dst_known;
	s64 smin_val, smax_val;
	u64 umin_val, umax_val;

	if (BPF_CLASS(insn->code) != BPF_ALU64) {
		/* 32-bit ALU ops are (32,32)->64 */
		coerce_reg_to_32(dst_reg);
		coerce_reg_to_32(&src_reg);
	}
	smin_val = src_reg.smin_value;
	smax_val = src_reg.smax_value;
	umin_val = src_reg.umin_value;
	umax_val = src_reg.umax_value;
	src_known = tnum_is_const(src_reg.var_off);
	dst_known = tnum_is_const(dst_reg->var_off);

	switch (opcode) {
	case BPF_ADD:
		if (signed_add_overflows(dst_reg->smin_value, smin_val) ||
		    signed_add_overflows(dst_reg->smax_value, smax_val)) {
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			dst_reg->smin_value += smin_val;
			dst_reg->smax_value += smax_val;
		}
		if (dst_reg->umin_value + umin_val < umin_val ||
		    dst_reg->umax_value + umax_val < umax_val) {
			dst_reg->umin_value = 0;
			dst_reg->umax_value = U64_MAX;
		} else {
			dst_reg->umin_value += umin_val;
			dst_reg->umax_value += umax_val;
		}
		dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);
		break;
	case BPF_SUB:
		if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||
		    signed_sub_overflows(dst_reg->smax_value, smin_val)) {
			/* Overflow possible, we know nothing */
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			dst_reg->smin_value -= smax_val;
			dst_reg->smax_value -= smin_val;
		}
		if (dst_reg->umin_value < umax_val) {
			/* Overflow possible, we know nothing */
			dst_reg->umin_value = 0;
			dst_reg->umax_value = U64_MAX;
		} else {
			/* Cannot overflow (as long as bounds are consistent) */
			dst_reg->umin_value -= umax_val;
			dst_reg->umax_value -= umin_val;
		}
		dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);
		break;
	case BPF_MUL:
		dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);
		if (smin_val < 0 || dst_reg->smin_value < 0) {
			/* Ain't nobody got time to multiply that sign */
			__mark_reg_unbounded(dst_reg);
			__update_reg_bounds(dst_reg);
			break;
		}
		/* Both values are positive, so we can work with unsigned and
		 * copy the result to signed (unless it exceeds S64_MAX).
		 */
		if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {
			/* Potential overflow, we know nothing */
			__mark_reg_unbounded(dst_reg);
			/* (except what we can learn from the var_off) */
			__update_reg_bounds(dst_reg);
			break;
		}
		dst_reg->umin_value *= umin_val;
		dst_reg->umax_value *= umax_val;
		if (dst_reg->umax_value > S64_MAX) {
			/* Overflow possible, we know nothing */
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			dst_reg->smin_value = dst_reg->umin_value;
			dst_reg->smax_value = dst_reg->umax_value;
		}
		break;
	case BPF_AND:
		if (src_known && dst_known) {
			__mark_reg_known(dst_reg, dst_reg->var_off.value &
						  src_reg.var_off.value);
			break;
		}
		/* We get our minimum from the var_off, since that's inherently
		 * bitwise.  Our maximum is the minimum of the operands' maxima.
		 */
		dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);
		dst_reg->umin_value = dst_reg->var_off.value;
		dst_reg->umax_value = min(dst_reg->umax_value, umax_val);
		if (dst_reg->smin_value < 0 || smin_val < 0) {
			/* Lose signed bounds when ANDing negative numbers,
			 * ain't nobody got time for that.
			 */
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			/* ANDing two positives gives a positive, so safe to
			 * cast result into s64.
			 */
			dst_reg->smin_value = dst_reg->umin_value;
			dst_reg->smax_value = dst_reg->umax_value;
		}
		/* We may learn something more from the var_off */
		__update_reg_bounds(dst_reg);
		break;
	case BPF_OR:
		if (src_known && dst_known) {
			__mark_reg_known(dst_reg, dst_reg->var_off.value |
						  src_reg.var_off.value);
			break;
		}
		/* We get our maximum from the var_off, and our minimum is the
		 * maximum of the operands' minima
		 */
		dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);
		dst_reg->umin_value = max(dst_reg->umin_value, umin_val);
		dst_reg->umax_value = dst_reg->var_off.value |
				      dst_reg->var_off.mask;
		if (dst_reg->smin_value < 0 || smin_val < 0) {
			/* Lose signed bounds when ORing negative numbers,
			 * ain't nobody got time for that.
			 */
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			/* ORing two positives gives a positive, so safe to
			 * cast result into s64.
			 */
			dst_reg->smin_value = dst_reg->umin_value;
			dst_reg->smax_value = dst_reg->umax_value;
		}
		/* We may learn something more from the var_off */
		__update_reg_bounds(dst_reg);
		break;
	case BPF_LSH:
		if (umax_val > 63) {
			/* Shifts greater than 63 are undefined.  This includes
			 * shifts by a negative number.
			 */
			mark_reg_unknown(env, regs, insn->dst_reg);
			break;
		}
		/* We lose all sign bit information (except what we can pick
		 * up from var_off)
		 */
		dst_reg->smin_value = S64_MIN;
		dst_reg->smax_value = S64_MAX;
		/* If we might shift our top bit out, then we know nothing */
		if (dst_reg->umax_value > 1ULL << (63 - umax_val)) {
			dst_reg->umin_value = 0;
			dst_reg->umax_value = U64_MAX;
		} else {
			dst_reg->umin_value <<= umin_val;
			dst_reg->umax_value <<= umax_val;
		}
		if (src_known)
			dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);
		else
			dst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);
		/* We may learn something more from the var_off */
		__update_reg_bounds(dst_reg);
		break;
	case BPF_RSH:
		if (umax_val > 63) {
			/* Shifts greater than 63 are undefined.  This includes
			 * shifts by a negative number.
			 */
			mark_reg_unknown(env, regs, insn->dst_reg);
			break;
		}
		/* BPF_RSH is an unsigned shift.  If the value in dst_reg might
		 * be negative, then either:
		 * 1) src_reg might be zero, so the sign bit of the result is
		 *    unknown, so we lose our signed bounds
		 * 2) it's known negative, thus the unsigned bounds capture the
		 *    signed bounds
		 * 3) the signed bounds cross zero, so they tell us nothing
		 *    about the result
		 * If the value in dst_reg is known nonnegative, then again the
		 * unsigned bounts capture the signed bounds.
		 * Thus, in all cases it suffices to blow away our signed bounds
		 * and rely on inferring new ones from the unsigned bounds and
		 * var_off of the result.
		 */
		dst_reg->smin_value = S64_MIN;
		dst_reg->smax_value = S64_MAX;
		if (src_known)
			dst_reg->var_off = tnum_rshift(dst_reg->var_off,
						       umin_val);
		else
			dst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);
		dst_reg->umin_value >>= umax_val;
		dst_reg->umax_value >>= umin_val;
		/* We may learn something more from the var_off */
		__update_reg_bounds(dst_reg);
		break;
	default:
		mark_reg_unknown(env, regs, insn->dst_reg);
		break;
	}

	__reg_deduce_bounds(dst_reg);
	__reg_bound_offset(dst_reg);
	return 0;
}","static int adjust_scalar_min_max_vals(struct bpf_verifier_env *VAR_0,
				      struct bpf_insn *VAR_1,
				      struct bpf_reg_state *VAR_2,
				      struct bpf_reg_state VAR_3)
{
	struct bpf_reg_state *VAR_4 = cur_regs(VAR_0);
	u8 VAR_5 = BPF_OP(VAR_1->code);
	bool VAR_6, VAR_7;
	s64 VAR_8, VAR_9;
	u64 VAR_10, VAR_11;

	if (BPF_CLASS(VAR_1->code) != VAR_12) {
		/* COMMENT_0 */
		coerce_reg_to_32(VAR_2);
		coerce_reg_to_32(&VAR_3);
	}
	VAR_8 = VAR_3.smin_value;
	VAR_9 = VAR_3.smax_value;
	VAR_10 = VAR_3.umin_value;
	VAR_11 = VAR_3.umax_value;
	VAR_6 = tnum_is_const(VAR_3.var_off);
	VAR_7 = tnum_is_const(VAR_2->var_off);

	switch (VAR_5) {
	case VAR_13:
		if (signed_add_overflows(VAR_2->smin_value, VAR_8) ||
		    signed_add_overflows(VAR_2->smax_value, VAR_9)) {
			VAR_2->smin_value = VAR_14;
			VAR_2->smax_value = VAR_15;
		} else {
			VAR_2->smin_value += VAR_8;
			VAR_2->smax_value += VAR_9;
		}
		if (VAR_2->umin_value + VAR_10 < VAR_10 ||
		    VAR_2->umax_value + VAR_11 < VAR_11) {
			VAR_2->umin_value = 0;
			VAR_2->umax_value = VAR_16;
		} else {
			VAR_2->umin_value += VAR_10;
			VAR_2->umax_value += VAR_11;
		}
		VAR_2->var_off = tnum_add(VAR_2->var_off, VAR_3.var_off);
		break;
	case VAR_17:
		if (signed_sub_overflows(VAR_2->smin_value, VAR_9) ||
		    signed_sub_overflows(VAR_2->smax_value, VAR_8)) {
			/* COMMENT_1 */
			VAR_2->smin_value = VAR_14;
			VAR_2->smax_value = VAR_15;
		} else {
			VAR_2->smin_value -= VAR_9;
			VAR_2->smax_value -= VAR_8;
		}
		if (VAR_2->umin_value < VAR_11) {
			/* COMMENT_1 */
			VAR_2->umin_value = 0;
			VAR_2->umax_value = VAR_16;
		} else {
			/* COMMENT_2 */
			VAR_2->umin_value -= VAR_11;
			VAR_2->umax_value -= VAR_10;
		}
		VAR_2->var_off = tnum_sub(VAR_2->var_off, VAR_3.var_off);
		break;
	case VAR_18:
		VAR_2->var_off = tnum_mul(VAR_2->var_off, VAR_3.var_off);
		if (VAR_8 < 0 || VAR_2->smin_value < 0) {
			/* COMMENT_3 */
			__mark_reg_unbounded(VAR_2);
			__update_reg_bounds(VAR_2);
			break;
		}
		/* COMMENT_4 */
                                                           
     
		if (VAR_11 > VAR_19 || VAR_2->umax_value > VAR_19) {
			/* COMMENT_7 */
			__mark_reg_unbounded(VAR_2);
			/* COMMENT_8 */
			__update_reg_bounds(VAR_2);
			break;
		}
		VAR_2->umin_value *= VAR_10;
		VAR_2->umax_value *= VAR_11;
		if (VAR_2->umax_value > VAR_15) {
			/* COMMENT_1 */
			VAR_2->smin_value = VAR_14;
			VAR_2->smax_value = VAR_15;
		} else {
			VAR_2->smin_value = VAR_2->umin_value;
			VAR_2->smax_value = VAR_2->umax_value;
		}
		break;
	case VAR_20:
		if (VAR_6 && VAR_7) {
			__mark_reg_known(VAR_2, VAR_2->var_off.value &
						  VAR_3.var_off.value);
			break;
		}
		/* COMMENT_9 */
                                                                  
     
		VAR_2->var_off = tnum_and(VAR_2->var_off, VAR_3.var_off);
		VAR_2->umin_value = VAR_2->var_off.value;
		VAR_2->umax_value = min(VAR_2->umax_value, VAR_11);
		if (VAR_2->smin_value < 0 || VAR_8 < 0) {
			/* COMMENT_12 */
                                     
      
			VAR_2->smin_value = VAR_14;
			VAR_2->smax_value = VAR_15;
		} else {
			/* COMMENT_15 */
                           
      
			VAR_2->smin_value = VAR_2->umin_value;
			VAR_2->smax_value = VAR_2->umax_value;
		}
		/* COMMENT_18 */
		__update_reg_bounds(VAR_2);
		break;
	case VAR_21:
		if (VAR_6 && VAR_7) {
			__mark_reg_known(VAR_2, VAR_2->var_off.value |
						  VAR_3.var_off.value);
			break;
		}
		/* COMMENT_19 */
                                    
     
		VAR_2->var_off = tnum_or(VAR_2->var_off, VAR_3.var_off);
		VAR_2->umin_value = max(VAR_2->umin_value, VAR_10);
		VAR_2->umax_value = VAR_2->var_off.value |
				      VAR_2->var_off.mask;
		if (VAR_2->smin_value < 0 || VAR_8 < 0) {
			/* COMMENT_22 */
                                     
      
			VAR_2->smin_value = VAR_14;
			VAR_2->smax_value = VAR_15;
		} else {
			/* COMMENT_25 */
                           
      
			VAR_2->smin_value = VAR_2->umin_value;
			VAR_2->smax_value = VAR_2->umax_value;
		}
		/* COMMENT_18 */
		__update_reg_bounds(VAR_2);
		break;
	case VAR_22:
		if (VAR_11 > 63) {
			/* COMMENT_28 */
                                  
      
			mark_reg_unknown(VAR_0, VAR_4, VAR_1->dst_reg);
			break;
		}
		/* COMMENT_31 */
                     
     
		VAR_2->smin_value = VAR_14;
		VAR_2->smax_value = VAR_15;
		/* COMMENT_34 */
		if (VAR_2->umax_value > 1ULL << (63 - VAR_11)) {
			VAR_2->umin_value = 0;
			VAR_2->umax_value = VAR_16;
		} else {
			VAR_2->umin_value <<= VAR_10;
			VAR_2->umax_value <<= VAR_11;
		}
		if (VAR_6)
			VAR_2->var_off = tnum_lshift(VAR_2->var_off, VAR_10);
		else
			VAR_2->var_off = tnum_lshift(VAR_23, VAR_10);
		/* COMMENT_18 */
		__update_reg_bounds(VAR_2);
		break;
	case VAR_24:
		if (VAR_11 > 63) {
			/* COMMENT_35 */
                                  
      
			mark_reg_unknown(VAR_0, VAR_4, VAR_1->dst_reg);
			break;
		}
		/* COMMENT_38 */
                              
                                                               
                                             
                                                                 
                     
                                                             
                        
                                                                 
                                               
                                                                  
                                                                
                           
     
		VAR_2->smin_value = VAR_14;
		VAR_2->smax_value = VAR_15;
		if (VAR_6)
			VAR_2->var_off = tnum_rshift(VAR_2->var_off,
						       VAR_10);
		else
			VAR_2->var_off = tnum_rshift(VAR_23, VAR_10);
		VAR_2->umin_value >>= VAR_11;
		VAR_2->umax_value >>= VAR_10;
		/* COMMENT_18 */
		__update_reg_bounds(VAR_2);
		break;
	default:
		mark_reg_unknown(VAR_0, VAR_4, VAR_1->dst_reg);
		break;
	}

	__reg_deduce_bounds(VAR_2);
	__reg_bound_offset(VAR_2);
	return 0;
}",torvalds/linux/4374f256ce8182019353c0c639bb8d0695b4c941/verifier.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -184,20 +184,22 @@
 			mark_reg_unknown(env, regs, insn->dst_reg);
 			break;
 		}
-		/* BPF_RSH is an unsigned shift, so make the appropriate casts */
-		if (dst_reg->smin_value < 0) {
-			if (umin_val) {
-				/* Sign bit will be cleared */
-				dst_reg->smin_value = 0;
-			} else {
-				/* Lost sign bit information */
-				dst_reg->smin_value = S64_MIN;
-				dst_reg->smax_value = S64_MAX;
-			}
-		} else {
-			dst_reg->smin_value =
-				(u64)(dst_reg->smin_value) >> umax_val;
-		}
+		/* BPF_RSH is an unsigned shift.  If the value in dst_reg might
+		 * be negative, then either:
+		 * 1) src_reg might be zero, so the sign bit of the result is
+		 *    unknown, so we lose our signed bounds
+		 * 2) it's known negative, thus the unsigned bounds capture the
+		 *    signed bounds
+		 * 3) the signed bounds cross zero, so they tell us nothing
+		 *    about the result
+		 * If the value in dst_reg is known nonnegative, then again the
+		 * unsigned bounts capture the signed bounds.
+		 * Thus, in all cases it suffices to blow away our signed bounds
+		 * and rely on inferring new ones from the unsigned bounds and
+		 * var_off of the result.
+		 */
+		dst_reg->smin_value = S64_MIN;
+		dst_reg->smax_value = S64_MAX;
 		if (src_known)
 			dst_reg->var_off = tnum_rshift(dst_reg->var_off,
 						       umin_val);","{'deleted_lines': ['\t\t/* BPF_RSH is an unsigned shift, so make the appropriate casts */', '\t\tif (dst_reg->smin_value < 0) {', '\t\t\tif (umin_val) {', '\t\t\t\t/* Sign bit will be cleared */', '\t\t\t\tdst_reg->smin_value = 0;', '\t\t\t} else {', '\t\t\t\t/* Lost sign bit information */', '\t\t\t\tdst_reg->smin_value = S64_MIN;', '\t\t\t\tdst_reg->smax_value = S64_MAX;', '\t\t\t}', '\t\t} else {', '\t\t\tdst_reg->smin_value =', '\t\t\t\t(u64)(dst_reg->smin_value) >> umax_val;', '\t\t}'], 'added_lines': ['\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might', '\t\t * be negative, then either:', '\t\t * 1) src_reg might be zero, so the sign bit of the result is', '\t\t *    unknown, so we lose our signed bounds', ""\t\t * 2) it's known negative, thus the unsigned bounds capture the"", '\t\t *    signed bounds', '\t\t * 3) the signed bounds cross zero, so they tell us nothing', '\t\t *    about the result', '\t\t * If the value in dst_reg is known nonnegative, then again the', '\t\t * unsigned bounts capture the signed bounds.', '\t\t * Thus, in all cases it suffices to blow away our signed bounds', '\t\t * and rely on inferring new ones from the unsigned bounds and', '\t\t * var_off of the result.', '\t\t */', '\t\tdst_reg->smin_value = S64_MIN;', '\t\tdst_reg->smax_value = S64_MAX;']}",True,kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging incorrect BPF_RSH signed bounds calculations.,7.8,HIGH,2,test,2017-12-19T04:11:53Z,2
CVE-2017-17789,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,GNOME/gimp,"Bug 790849 - (CVE-2017-17789) CVE-2017-17789 Heap buffer overflow...

... in PSP importer.
Check if declared block length is valid (i.e. within the actual file)
before going further.
Consider the file as broken otherwise and fail loading it.

(cherry picked from commit 28e95fbeb5720e6005a088fa811f5bf3c1af48b8)",01898f10f87a094665a7fdcf7153990f4e511d3f,https://github.com/GNOME/gimp/commit/01898f10f87a094665a7fdcf7153990f4e511d3f,plug-ins/common/file-psp.c,load_image,"static gint32
load_image (const gchar  *filename,
GError      **error)
{
FILE *f;
struct stat st;
char buf[32];
PSPimage ia;
guint32 block_init_len, block_total_len;
long block_start;
PSPBlockID id = -1;
gint block_number;
gint32 image_ID = -1;
if (g_stat (filename, &st) == -1)
return -1;
f = g_fopen (filename, ""rb"");
if (f == NULL)
{
g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),
_(""Could not open '%s' for reading: %s""),
gimp_filename_to_utf8 (filename), g_strerror (errno));
return -1;
}
if (fread (buf, 32, 1, f) < 1
|| fread (&psp_ver_major, 2, 1, f) < 1
|| fread (&psp_ver_minor, 2, 1, f) < 1)
{
g_message (""Error reading file header"");
goto error;
}
if (memcmp (buf, ""Paint Shop Pro Image File\n\032\0\0\0\0\0"", 32) != 0)
{
g_message (""Incorrect file signature"");
goto error;
}
psp_ver_major = GUINT16_FROM_LE (psp_ver_major);
psp_ver_minor = GUINT16_FROM_LE (psp_ver_minor);
if (psp_ver_major < 3)
{
g_message (""Unsupported PSP file format version ""
""%d.%d, only knows 3.0 (and later?)"",
psp_ver_major, psp_ver_minor);
goto error;
}
else if ((psp_ver_major == 3)
|| (psp_ver_major == 4)
|| (psp_ver_major == 5)
|| (psp_ver_major == 6))
; 
else
{
g_message (""Unsupported PSP file format version %d.%d"",
psp_ver_major, psp_ver_minor);
goto error;
}
block_number = 0;
IFDBG(3) g_message (""size = %d"", (int)st.st_size);
while (ftell (f) != st.st_size
&& (id = read_block_header (f, &block_init_len,
&block_total_len)) != -1)
{
block_start = ftell (f);
if (id == PSP_IMAGE_BLOCK)
{
if (block_number != 0)
{
g_message (""Duplicate General Image Attributes block"");
goto error;
}
if (read_general_image_attribute_block (f, block_init_len,
block_total_len, &ia) == -1)
{
goto error;
}
IFDBG(2) g_message (""%d dpi %dx%d %s"",
(int) ia.resolution,
ia.width, ia.height,
compression_name (ia.compression));
image_ID = gimp_image_new (ia.width, ia.height,
ia.greyscale ? GIMP_GRAY : GIMP_RGB);
if (image_ID == -1)
{
goto error;
}
gimp_image_set_filename (image_ID, filename);
gimp_image_set_resolution (image_ID, ia.resolution, ia.resolution);
}
else
{
if (block_number == 0)
{
g_message (""Missing General Image Attributes block"");
goto error;
}
switch (id)
{
case PSP_CREATOR_BLOCK:
if (read_creator_block (f, image_ID, block_total_len, &ia) == -1)
goto error;
break;
case PSP_COLOR_BLOCK:
break;            
case PSP_LAYER_START_BLOCK:
if (read_layer_block (f, image_ID, block_total_len, &ia) == -1)
goto error;
break;
case PSP_SELECTION_BLOCK:
break;            
case PSP_ALPHA_BANK_BLOCK:
break;            
case PSP_THUMBNAIL_BLOCK:
break;            
case PSP_EXTENDED_DATA_BLOCK:
break;            
case PSP_TUBE_BLOCK:
if (read_tube_block (f, image_ID, block_total_len, &ia) == -1)
goto error;
break;
case PSP_COMPOSITE_IMAGE_BANK_BLOCK:
break;            
case PSP_LAYER_BLOCK:
case PSP_CHANNEL_BLOCK:
case PSP_ALPHA_CHANNEL_BLOCK:
case PSP_ADJUSTMENT_EXTENSION_BLOCK:
case PSP_VECTOR_EXTENSION_BLOCK:
case PSP_SHAPE_BLOCK:
case PSP_PAINTSTYLE_BLOCK:
case PSP_COMPOSITE_ATTRIBUTES_BLOCK:
case PSP_JPEG_BLOCK:
g_message (""Sub-block %s should not occur ""
""at main level of file"",
block_name (id));
break;
default:
g_message (""Unrecognized block id %d"", id);
break;
}
}
if (block_start + block_total_len >= st.st_size)
break;
if (try_fseek (f, block_start + block_total_len, SEEK_SET) < 0)
goto error;
block_number++;
}
if (id == -1)
{
error:
fclose (f);
if (image_ID != -1)
gimp_image_delete (image_ID);
return -1;
}
fclose (f);
return image_ID;
}","static gint32
load_image (const gchar  *VAR_0,
GError      **VAR_1)
{
FILE *VAR_2;
struct stat VAR_3;
char VAR_4[32];
PSPimage VAR_5;
guint32 VAR_6, VAR_7;
long VAR_8;
PSPBlockID VAR_9 = -1;
gint VAR_10;
gint32 VAR_11 = -1;
if (g_stat (VAR_0, &VAR_3) == -1)
return -1;
VAR_2 = g_fopen (VAR_0, ""rb"");
if (VAR_2 == NULL)
{
g_set_error (VAR_1, VAR_12, g_file_error_from_errno (VAR_13),
_(""Could not open '%s' for reading: %s""),
gimp_filename_to_utf8 (VAR_0), g_strerror (VAR_13));
return -1;
}
if (fread (VAR_4, 32, 1, VAR_2) < 1
|| fread (&VAR_14, 2, 1, VAR_2) < 1
|| fread (&VAR_15, 2, 1, VAR_2) < 1)
{
g_message (""Error reading file header"");
goto error;
}
if (memcmp (VAR_4, ""Paint Shop Pro Image File\n\032\0\0\0\0\0"", 32) != 0)
{
g_message (""Incorrect file signature"");
goto error;
}
VAR_14 = GUINT16_FROM_LE (VAR_14);
VAR_15 = GUINT16_FROM_LE (VAR_15);
if (VAR_14 < 3)
{
g_message (""Unsupported PSP file format version ""
""%d.%d, only knows 3.0 (and later?)"",
VAR_14, VAR_15);
goto error;
}
else if ((VAR_14 == 3)
|| (VAR_14 == 4)
|| (VAR_14 == 5)
|| (VAR_14 == 6))
; 
else
{
g_message (""Unsupported PSP file format version %d.%d"",
VAR_14, VAR_15);
goto error;
}
VAR_10 = 0;
IFDBG(3) VAR_16 (""size = %d"", (int)VAR_3.st_size);
while (ftell (VAR_2) != VAR_3.st_size
&& (VAR_9 = read_block_header (VAR_2, &VAR_6,
&VAR_7)) != -1)
{
VAR_8 = ftell (VAR_2);
if (VAR_9 == VAR_17)
{
if (VAR_10 != 0)
{
VAR_16 (""Duplicate General Image Attributes block"");
goto error;
}
if (read_general_image_attribute_block (VAR_2, VAR_6,
VAR_7, &VAR_5) == -1)
{
goto error;
}
IFDBG(2) VAR_16 (""%d dpi %dx%d %s"",
(int) VAR_5.resolution,
VAR_5.width, VAR_5.height,
compression_name (VAR_5.compression));
VAR_11 = gimp_image_new (VAR_5.width, VAR_5.height,
VAR_5.greyscale ? VAR_18 : VAR_19);
if (VAR_11 == -1)
{
goto error;
}
gimp_image_set_filename (VAR_11, VAR_0);
gimp_image_set_resolution (VAR_11, VAR_5.resolution, VAR_5.resolution);
}
else
{
if (VAR_10 == 0)
{
VAR_16 (""Missing General Image Attributes block"");
goto error;
}
switch (VAR_9)
{
case VAR_20:
if (read_creator_block (VAR_2, VAR_11, VAR_7, &VAR_5) == -1)
goto error;
break;
case VAR_21:
break;            
case VAR_22:
if (read_layer_block (VAR_2, VAR_11, VAR_7, &VAR_5) == -1)
goto error;
break;
case VAR_23:
break;            
case VAR_24:
break;            
case VAR_25:
break;            
case VAR_26:
break;            
case VAR_27:
if (read_tube_block (VAR_2, VAR_11, VAR_7, &VAR_5) == -1)
goto error;
break;
case VAR_28:
break;            
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
case VAR_33:
case VAR_34:
case VAR_35:
case VAR_36:
case VAR_37:
VAR_16 (""Sub-block %s should not occur ""
""at main level of file"",
block_name (VAR_9));
break;
default:
VAR_16 (""Unrecognized block id %d"", VAR_9);
break;
}
}
if (VAR_8 + VAR_7 >= VAR_3.st_size)
break;
if (try_fseek (VAR_2, VAR_8 + VAR_7, VAR_38) < 0)
goto error;
VAR_10++;
}
if (VAR_9 == -1)
{
error:
fclose (VAR_2);
if (VAR_11 != -1)
gimp_image_delete (VAR_11);
return -1;
}
fclose (VAR_2);
return VAR_11;
}",GNOME/gimp/01898f10f87a094665a7fdcf7153990f4e511d3f/file-psp.c/vul/before/0.json,"static gint32
load_image (const gchar  *filename,
            GError      **error)
{
  FILE *f;
  struct stat st;
  char buf[32];
  PSPimage ia;
  guint32 block_init_len, block_total_len;
  long block_start;
  PSPBlockID id = -1;
  gint block_number;

  gint32 image_ID = -1;

  if (g_stat (filename, &st) == -1)
    return -1;

  f = g_fopen (filename, ""rb"");
  if (f == NULL)
    {
      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),
                   _(""Could not open '%s' for reading: %s""),
                   gimp_filename_to_utf8 (filename), g_strerror (errno));
      return -1;
    }

  /* Read the PSP File Header and determine file version */
  if (fread (buf, 32, 1, f) < 1
      || fread (&psp_ver_major, 2, 1, f) < 1
      || fread (&psp_ver_minor, 2, 1, f) < 1)
    {
      g_message (""Error reading file header"");
      goto error;
    }

  if (memcmp (buf, ""Paint Shop Pro Image File\n\032\0\0\0\0\0"", 32) != 0)
    {
      g_message (""Incorrect file signature"");
      goto error;
    }

  psp_ver_major = GUINT16_FROM_LE (psp_ver_major);
  psp_ver_minor = GUINT16_FROM_LE (psp_ver_minor);

  /* I only have the documentation for file format version 3.0,
   * but PSP 6 writes version 4.0. Let's hope it's backwards compatible.
   * Earlier versions probably don't have all the fields I expect
   * so don't accept those.
   */
  if (psp_ver_major < 3)
    {
      g_message (""Unsupported PSP file format version ""
                 ""%d.%d, only knows 3.0 (and later?)"",
                 psp_ver_major, psp_ver_minor);
      goto error;
    }
  else if ((psp_ver_major == 3)
        || (psp_ver_major == 4)
        || (psp_ver_major == 5)
        || (psp_ver_major == 6))
    ; /* OK */
  else
    {
      g_message (""Unsupported PSP file format version %d.%d"",
                 psp_ver_major, psp_ver_minor);
      goto error;
    }

  /* Read all the blocks */
  block_number = 0;

  IFDBG(3) g_message (""size = %d"", (int)st.st_size);
  while (ftell (f) != st.st_size
         && (id = read_block_header (f, &block_init_len,
                                     &block_total_len)) != -1)
    {
      block_start = ftell (f);

      if (block_start + block_total_len > st.st_size)
        {
          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                       _(""Could not open '%s' for reading: %s""),
                       gimp_filename_to_utf8 (filename),
                       _(""invalid block size""));
          goto error;
        }

      if (id == PSP_IMAGE_BLOCK)
        {
          if (block_number != 0)
            {
              g_message (""Duplicate General Image Attributes block"");
              goto error;
            }
          if (read_general_image_attribute_block (f, block_init_len,
                                                  block_total_len, &ia) == -1)
            {
              goto error;
            }

          IFDBG(2) g_message (""%d dpi %dx%d %s"",
                              (int) ia.resolution,
                              ia.width, ia.height,
                              compression_name (ia.compression));

          image_ID = gimp_image_new (ia.width, ia.height,
                                     ia.greyscale ? GIMP_GRAY : GIMP_RGB);
          if (image_ID == -1)
            {
              goto error;
            }

          gimp_image_set_filename (image_ID, filename);

          gimp_image_set_resolution (image_ID, ia.resolution, ia.resolution);
        }
      else
        {
          if (block_number == 0)
            {
              g_message (""Missing General Image Attributes block"");
              goto error;
            }

          switch (id)
            {
            case PSP_CREATOR_BLOCK:
              if (read_creator_block (f, image_ID, block_total_len, &ia) == -1)
                goto error;
              break;

            case PSP_COLOR_BLOCK:
              break;            /* Not yet implemented */

            case PSP_LAYER_START_BLOCK:
              if (read_layer_block (f, image_ID, block_total_len, &ia) == -1)
                goto error;
              break;

            case PSP_SELECTION_BLOCK:
              break;            /* Not yet implemented */

            case PSP_ALPHA_BANK_BLOCK:
              break;            /* Not yet implemented */

            case PSP_THUMBNAIL_BLOCK:
              break;            /* No use for it */

            case PSP_EXTENDED_DATA_BLOCK:
              break;            /* Not yet implemented */

            case PSP_TUBE_BLOCK:
              if (read_tube_block (f, image_ID, block_total_len, &ia) == -1)
                goto error;
              break;

            case PSP_COMPOSITE_IMAGE_BANK_BLOCK:
              break;            /* Not yet implemented */

            case PSP_LAYER_BLOCK:
            case PSP_CHANNEL_BLOCK:
            case PSP_ALPHA_CHANNEL_BLOCK:
            case PSP_ADJUSTMENT_EXTENSION_BLOCK:
            case PSP_VECTOR_EXTENSION_BLOCK:
            case PSP_SHAPE_BLOCK:
            case PSP_PAINTSTYLE_BLOCK:
            case PSP_COMPOSITE_ATTRIBUTES_BLOCK:
            case PSP_JPEG_BLOCK:
              g_message (""Sub-block %s should not occur ""
                         ""at main level of file"",
                         block_name (id));
              break;

            default:
              g_message (""Unrecognized block id %d"", id);
              break;
            }
        }

      if (block_start + block_total_len >= st.st_size)
        break;

      if (try_fseek (f, block_start + block_total_len, SEEK_SET) < 0)
        goto error;

      block_number++;
    }

  if (id == -1)
    {
    error:
      fclose (f);
      if (image_ID != -1)
        gimp_image_delete (image_ID);
      return -1;
    }

  fclose (f);

  return image_ID;
}","static gint32
load_image (const gchar  *VAR_0,
            GError      **VAR_1)
{
  FILE *VAR_2;
  struct stat VAR_3;
  char VAR_4[32];
  PSPimage VAR_5;
  guint32 VAR_6, VAR_7;
  long VAR_8;
  PSPBlockID VAR_9 = -1;
  gint VAR_10;

  gint32 VAR_11 = -1;

  if (g_stat (VAR_0, &VAR_3) == -1)
    return -1;

  VAR_2 = g_fopen (VAR_0, ""rb"");
  if (VAR_2 == NULL)
    {
      g_set_error (VAR_1, VAR_12, g_file_error_from_errno (VAR_13),
                   _(""Could not open '%s' for reading: %s""),
                   gimp_filename_to_utf8 (VAR_0), g_strerror (VAR_13));
      return -1;
    }

  /* COMMENT_0 */
  if (fread (VAR_4, 32, 1, VAR_2) < 1
      || fread (&VAR_14, 2, 1, VAR_2) < 1
      || fread (&VAR_15, 2, 1, VAR_2) < 1)
    {
      g_message (""Error reading file header"");
      goto error;
    }

  if (memcmp (VAR_4, ""Paint Shop Pro Image File\n\032\0\0\0\0\0"", 32) != 0)
    {
      g_message (""Incorrect file signature"");
      goto error;
    }

  VAR_14 = GUINT16_FROM_LE (VAR_14);
  VAR_15 = GUINT16_FROM_LE (VAR_15);

  /* COMMENT_1 */
                                                                        
                                                                 
                           
     
  if (VAR_14 < 3)
    {
      g_message (""Unsupported PSP file format version ""
                 ""%d.%d, only knows 3.0 (and later?)"",
                 VAR_14, VAR_15);
      goto error;
    }
  else if ((VAR_14 == 3)
        || (VAR_14 == 4)
        || (VAR_14 == 5)
        || (VAR_14 == 6))
    ; /* COMMENT_6 */
  else
    {
      g_message (""Unsupported PSP file format version %d.%d"",
                 VAR_14, VAR_15);
      goto error;
    }

  /* COMMENT_7 */
  VAR_10 = 0;

  IFDBG(3) VAR_16 (""size = %d"", (int)VAR_3.st_size);
  while (ftell (VAR_2) != VAR_3.st_size
         && (VAR_9 = read_block_header (VAR_2, &VAR_6,
                                     &VAR_7)) != -1)
    {
      VAR_8 = ftell (VAR_2);

      if (VAR_8 + VAR_7 > VAR_3.st_size)
        {
          g_set_error (VAR_1, VAR_12, VAR_17,
                       _(""Could not open '%s' for reading: %s""),
                       gimp_filename_to_utf8 (VAR_0),
                       _(""invalid block size""));
          goto error;
        }

      if (VAR_9 == VAR_18)
        {
          if (VAR_10 != 0)
            {
              VAR_16 (""Duplicate General Image Attributes block"");
              goto error;
            }
          if (read_general_image_attribute_block (VAR_2, VAR_6,
                                                  VAR_7, &VAR_5) == -1)
            {
              goto error;
            }

          IFDBG(2) VAR_16 (""%d dpi %dx%d %s"",
                              (int) VAR_5.resolution,
                              VAR_5.width, VAR_5.height,
                              compression_name (VAR_5.compression));

          VAR_11 = gimp_image_new (VAR_5.width, VAR_5.height,
                                     VAR_5.greyscale ? VAR_19 : VAR_20);
          if (VAR_11 == -1)
            {
              goto error;
            }

          gimp_image_set_filename (VAR_11, VAR_0);

          gimp_image_set_resolution (VAR_11, VAR_5.resolution, VAR_5.resolution);
        }
      else
        {
          if (VAR_10 == 0)
            {
              VAR_16 (""Missing General Image Attributes block"");
              goto error;
            }

          switch (VAR_9)
            {
            case VAR_21:
              if (read_creator_block (VAR_2, VAR_11, VAR_7, &VAR_5) == -1)
                goto error;
              break;

            case VAR_22:
              break;            /* COMMENT_8 */

            case VAR_23:
              if (read_layer_block (VAR_2, VAR_11, VAR_7, &VAR_5) == -1)
                goto error;
              break;

            case VAR_24:
              break;            /* COMMENT_8 */

            case VAR_25:
              break;            /* COMMENT_8 */

            case VAR_26:
              break;            /* COMMENT_9 */

            case VAR_27:
              break;            /* COMMENT_8 */

            case VAR_28:
              if (read_tube_block (VAR_2, VAR_11, VAR_7, &VAR_5) == -1)
                goto error;
              break;

            case VAR_29:
              break;            /* COMMENT_8 */

            case VAR_30:
            case VAR_31:
            case VAR_32:
            case VAR_33:
            case VAR_34:
            case VAR_35:
            case VAR_36:
            case VAR_37:
            case VAR_38:
              VAR_16 (""Sub-block %s should not occur ""
                         ""at main level of file"",
                         block_name (VAR_9));
              break;

            default:
              VAR_16 (""Unrecognized block id %d"", VAR_9);
              break;
            }
        }

      if (VAR_8 + VAR_7 >= VAR_3.st_size)
        break;

      if (try_fseek (VAR_2, VAR_8 + VAR_7, VAR_39) < 0)
        goto error;

      VAR_10++;
    }

  if (VAR_9 == -1)
    {
    error:
      fclose (VAR_2);
      if (VAR_11 != -1)
        gimp_image_delete (VAR_11);
      return -1;
    }

  fclose (VAR_2);

  return VAR_11;
}",GNOME/gimp/01898f10f87a094665a7fdcf7153990f4e511d3f/file-psp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -77,6 +77,15 @@
     {
       block_start = ftell (f);
 
+      if (block_start + block_total_len > st.st_size)
+        {
+          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
+                       _(""Could not open '%s' for reading: %s""),
+                       gimp_filename_to_utf8 (filename),
+                       _(""invalid block size""));
+          goto error;
+        }
+
       if (id == PSP_IMAGE_BLOCK)
         {
           if (block_number != 0)","{'deleted_lines': [], 'added_lines': ['      if (block_start + block_total_len > st.st_size)', '        {', '          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,', '                       _(""Could not open \'%s\' for reading: %s""),', '                       gimp_filename_to_utf8 (filename),', '                       _(""invalid block size""));', '          goto error;', '        }', '']}",True,"In GIMP 2.8.22, there is a heap-based buffer overflow in read_channel_data in plug-ins/common/file-psp.c.",7.8,HIGH,2,test,2017-12-20T15:44:20Z,2
CVE-2018-5268,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,opencv,imgcodecs: add more Jasper checks for supported and tested cases,435a3e337bd9d4e11af61cf8b8afca067bf1a8aa,https://github.com/opencv/opencv/commit/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa,modules/imgcodecs/src/grfmt_jpeg2000.cpp,Jpeg2KDecoder::readHeader,"bool  Jpeg2KDecoder::readHeader()
{
bool result = false;
close();
jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), ""rb"" );
m_stream = stream;
if( stream )
{
jas_image_t* image = jas_image_decode( stream, -1, 0 );
m_image = image;
if( image ) {
m_width = jas_image_width( image );
m_height = jas_image_height( image );
int cntcmpts = 0;             int numcmpts = jas_image_numcmpts( image );
int depth = 0;
for( int i = 0; i < numcmpts; i++ )
{
int depth_i = jas_image_cmptprec( image, i );
depth = MAX(depth, depth_i);
if( jas_image_cmpttype( image, i ) > 2 )
continue;
cntcmpts++;
}
if( cntcmpts )
{
m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);
result = true;
}
}
}
if( !result )
close();
return result;
}","bool  Jpeg2KDecoder::readHeader()
{
bool VAR_0 = false;
close();
jas_stream_t* VAR_1 = jas_stream_fopen( VAR_2.c_str(), ""rb"" );
VAR_3 = VAR_1;
if( VAR_1 )
{
jas_image_t* VAR_4 = jas_image_decode( VAR_1, -1, 0 );
VAR_5 = VAR_4;
if( VAR_4 ) {
VAR_6 = jas_image_width( VAR_4 );
VAR_7 = jas_image_height( VAR_4 );
int VAR_8 = 0; 
int VAR_9 = jas_image_numcmpts( VAR_4 );
int VAR_10 = 0;
for( int VAR_11 = 0; VAR_11 < VAR_9; VAR_11++ )
{
int VAR_12 = jas_image_cmptprec( VAR_4, VAR_11 );
VAR_10 = MAX(VAR_10, VAR_12);
if( jas_image_cmpttype( VAR_4, VAR_11 ) > 2 )
continue;
VAR_8++;
}
if( VAR_8 )
{
VAR_13 = CV_MAKETYPE(VAR_10 <= 8 ? VAR_14 : VAR_15, VAR_8 > 1 ? 3 : 1);
VAR_0 = true;
}
}
}
if( !VAR_0 )
close();
return VAR_0;
}",opencv/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa/grfmt_jpeg2000.cpp/vul/before/0.json,"bool  Jpeg2KDecoder::readHeader()
{
    bool result = false;

    close();
    jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), ""rb"" );
    m_stream = stream;

    if( stream )
    {
        jas_image_t* image = jas_image_decode( stream, -1, 0 );
        m_image = image;
        if( image ) {
            CV_Assert(0 == (jas_image_tlx(image)) && ""not supported"");
            CV_Assert(0 == (jas_image_tly(image)) && ""not supported"");
            m_width = jas_image_width( image );
            m_height = jas_image_height( image );

            int cntcmpts = 0; // count the known components
            int numcmpts = jas_image_numcmpts( image );
            int depth = 0;
            for( int i = 0; i < numcmpts; i++ )
            {
                int depth_i = jas_image_cmptprec( image, i );
                CV_Assert(depth == 0 || depth == depth_i); // component data type mismatch
                depth = MAX(depth, depth_i);
                if( jas_image_cmpttype( image, i ) > 2 )
                    continue;
                int sgnd = jas_image_cmptsgnd(image, i);
                int xstart = jas_image_cmpttlx(image, i);
                int xend = jas_image_cmptbrx(image, i);
                int xstep = jas_image_cmpthstep(image, i);
                int ystart = jas_image_cmpttly(image, i);
                int yend = jas_image_cmptbry(image, i);
                int ystep = jas_image_cmptvstep(image, i);
                CV_Assert(sgnd == 0 && ""not supported"");
                CV_Assert(xstart == 0 && ""not supported"");
                CV_Assert(ystart == 0 && ""not supported"");
                CV_Assert(xstep == 1 && ""not supported"");
                CV_Assert(ystep == 1 && ""not supported"");
                CV_Assert(xend == m_width);
                CV_Assert(yend == m_height);
                cntcmpts++;
            }

            if( cntcmpts )
            {
                CV_Assert(depth == 8 || depth == 16);
                CV_Assert(cntcmpts == 1 || cntcmpts == 3);
                m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);
                result = true;
            }
        }
    }

    if( !result )
        close();

    return result;
}","bool  Jpeg2KDecoder::readHeader()
{
    bool VAR_0 = false;

    close();
    jas_stream_t* VAR_1 = jas_stream_fopen( VAR_2.c_str(), ""rb"" );
    VAR_3 = VAR_1;

    if( VAR_1 )
    {
        jas_image_t* VAR_4 = jas_image_decode( VAR_1, -1, 0 );
        VAR_5 = VAR_4;
        if( VAR_4 ) {
            CV_Assert(0 == (jas_image_tlx(VAR_4)) && ""not supported"");
            CV_Assert(0 == (jas_image_tly(VAR_4)) && ""not supported"");
            VAR_6 = jas_image_width( VAR_4 );
            VAR_7 = jas_image_height( VAR_4 );

            int VAR_8 = 0; /* COMMENT_0 */
            int VAR_9 = jas_image_numcmpts( VAR_4 );
            int VAR_10 = 0;
            for( int VAR_11 = 0; VAR_11 < VAR_9; VAR_11++ )
            {
                int VAR_12 = jas_image_cmptprec( VAR_4, VAR_11 );
                CV_Assert(VAR_10 == 0 || VAR_10 == VAR_12); /* COMMENT_1 */
                VAR_10 = MAX(VAR_10, VAR_12);
                if( jas_image_cmpttype( VAR_4, VAR_11 ) > 2 )
                    continue;
                int VAR_13 = jas_image_cmptsgnd(VAR_4, VAR_11);
                int VAR_14 = jas_image_cmpttlx(VAR_4, VAR_11);
                int VAR_15 = jas_image_cmptbrx(VAR_4, VAR_11);
                int VAR_16 = jas_image_cmpthstep(VAR_4, VAR_11);
                int VAR_17 = jas_image_cmpttly(VAR_4, VAR_11);
                int VAR_18 = jas_image_cmptbry(VAR_4, VAR_11);
                int VAR_19 = jas_image_cmptvstep(VAR_4, VAR_11);
                CV_Assert(VAR_13 == 0 && ""not supported"");
                CV_Assert(VAR_14 == 0 && ""not supported"");
                CV_Assert(VAR_17 == 0 && ""not supported"");
                CV_Assert(VAR_16 == 1 && ""not supported"");
                CV_Assert(VAR_19 == 1 && ""not supported"");
                CV_Assert(VAR_15 == VAR_6);
                CV_Assert(VAR_18 == VAR_7);
                VAR_8++;
            }

            if( VAR_8 )
            {
                CV_Assert(VAR_10 == 8 || VAR_10 == 16);
                CV_Assert(VAR_8 == 1 || VAR_8 == 3);
                VAR_20 = CV_MAKETYPE(VAR_10 <= 8 ? VAR_21 : VAR_22, VAR_8 > 1 ? 3 : 1);
                VAR_0 = true;
            }
        }
    }

    if( !VAR_0 )
        close();

    return VAR_0;
}",opencv/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa/grfmt_jpeg2000.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,8 @@
         jas_image_t* image = jas_image_decode( stream, -1, 0 );
         m_image = image;
         if( image ) {
+            CV_Assert(0 == (jas_image_tlx(image)) && ""not supported"");
+            CV_Assert(0 == (jas_image_tly(image)) && ""not supported"");
             m_width = jas_image_width( image );
             m_height = jas_image_height( image );
 
@@ -20,14 +22,31 @@
             for( int i = 0; i < numcmpts; i++ )
             {
                 int depth_i = jas_image_cmptprec( image, i );
+                CV_Assert(depth == 0 || depth == depth_i); // component data type mismatch
                 depth = MAX(depth, depth_i);
                 if( jas_image_cmpttype( image, i ) > 2 )
                     continue;
+                int sgnd = jas_image_cmptsgnd(image, i);
+                int xstart = jas_image_cmpttlx(image, i);
+                int xend = jas_image_cmptbrx(image, i);
+                int xstep = jas_image_cmpthstep(image, i);
+                int ystart = jas_image_cmpttly(image, i);
+                int yend = jas_image_cmptbry(image, i);
+                int ystep = jas_image_cmptvstep(image, i);
+                CV_Assert(sgnd == 0 && ""not supported"");
+                CV_Assert(xstart == 0 && ""not supported"");
+                CV_Assert(ystart == 0 && ""not supported"");
+                CV_Assert(xstep == 1 && ""not supported"");
+                CV_Assert(ystep == 1 && ""not supported"");
+                CV_Assert(xend == m_width);
+                CV_Assert(yend == m_height);
                 cntcmpts++;
             }
 
             if( cntcmpts )
             {
+                CV_Assert(depth == 8 || depth == 16);
+                CV_Assert(cntcmpts == 1 || cntcmpts == 3);
                 m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1);
                 result = true;
             }","{'deleted_lines': [], 'added_lines': ['            CV_Assert(0 == (jas_image_tlx(image)) && ""not supported"");', '            CV_Assert(0 == (jas_image_tly(image)) && ""not supported"");', '                CV_Assert(depth == 0 || depth == depth_i); // component data type mismatch', '                int sgnd = jas_image_cmptsgnd(image, i);', '                int xstart = jas_image_cmpttlx(image, i);', '                int xend = jas_image_cmptbrx(image, i);', '                int xstep = jas_image_cmpthstep(image, i);', '                int ystart = jas_image_cmpttly(image, i);', '                int yend = jas_image_cmptbry(image, i);', '                int ystep = jas_image_cmptvstep(image, i);', '                CV_Assert(sgnd == 0 && ""not supported"");', '                CV_Assert(xstart == 0 && ""not supported"");', '                CV_Assert(ystart == 0 && ""not supported"");', '                CV_Assert(xstep == 1 && ""not supported"");', '                CV_Assert(ystep == 1 && ""not supported"");', '                CV_Assert(xend == m_width);', '                CV_Assert(yend == m_height);', '                CV_Assert(depth == 8 || depth == 16);', '                CV_Assert(cntcmpts == 1 || cntcmpts == 3);']}",True,"In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",5.5,MEDIUM,1,test,2018-01-09T14:36:57Z,2
CVE-2018-5268,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,opencv,imgcodecs: add more Jasper checks for supported and tested cases,435a3e337bd9d4e11af61cf8b8afca067bf1a8aa,https://github.com/opencv/opencv/commit/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa,modules/imgcodecs/src/grfmt_jpeg2000.cpp,Jpeg2KDecoder::Jpeg2KDecoder,"Jpeg2KDecoder::Jpeg2KDecoder()
{
m_signature = '\0' + String() + '\0' + String() + '\0' + String(""\x0cjP  \r\n\x87\n"");
m_stream = 0;
m_image = 0;
}","Jpeg2KDecoder::Jpeg2KDecoder()
{
VAR_0 = '\0' + String() + '\0' + String() + '\0' + String(""\x0cjP  \r\n\x87\n"");
VAR_1 = 0;
VAR_2 = 0;
}",opencv/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa/grfmt_jpeg2000.cpp/vul/before/1.json,"Jpeg2KDecoder::Jpeg2KDecoder()
{
    static const unsigned char signature_[12] = { 0, 0, 0, 0x0c, 'j', 'P', ' ', ' ', 13, 10, 0x87, 10};
    m_signature = String((const char*)signature_, (const char*)signature_ + sizeof(signature_));
    m_stream = 0;
    m_image = 0;
}","Jpeg2KDecoder::Jpeg2KDecoder()
{
    static const unsigned char VAR_0[12] = { 0, 0, 0, 0x0c, 'j', 'P', ' ', ' ', 13, 10, 0x87, 10};
    VAR_1 = String((const char*)VAR_0, (const char*)VAR_0 + sizeof(VAR_0));
    VAR_2 = 0;
    VAR_3 = 0;
}",opencv/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa/grfmt_jpeg2000.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 Jpeg2KDecoder::Jpeg2KDecoder()
 {
-    m_signature = '\0' + String() + '\0' + String() + '\0' + String(""\x0cjP  \r\n\x87\n"");
+    static const unsigned char signature_[12] = { 0, 0, 0, 0x0c, 'j', 'P', ' ', ' ', 13, 10, 0x87, 10};
+    m_signature = String((const char*)signature_, (const char*)signature_ + sizeof(signature_));
     m_stream = 0;
     m_image = 0;
 }","{'deleted_lines': ['    m_signature = \'\\0\' + String() + \'\\0\' + String() + \'\\0\' + String(""\\x0cjP  \\r\\n\\x87\\n"");'], 'added_lines': [""    static const unsigned char signature_[12] = { 0, 0, 0, 0x0c, 'j', 'P', ' ', ' ', 13, 10, 0x87, 10};"", '    m_signature = String((const char*)signature_, (const char*)signature_ + sizeof(signature_));']}",True,"In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",5.5,MEDIUM,1,test,2018-01-09T14:36:57Z,2
CVE-2018-5268,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,opencv,imgcodecs: add more Jasper checks for supported and tested cases,435a3e337bd9d4e11af61cf8b8afca067bf1a8aa,https://github.com/opencv/opencv/commit/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa,modules/imgcodecs/src/grfmt_jpeg2000.cpp,Jpeg2KDecoder::readData,"bool  Jpeg2KDecoder::readData( Mat& img )
{
bool result = false;
int color = img.channels() > 1;
uchar* data = img.ptr();
size_t step = img.step;
jas_stream_t* stream = (jas_stream_t*)m_stream;
jas_image_t* image = (jas_image_t*)m_image;
#ifndef _WIN32
Mat clr;
if (CV_MAT_CN(img.type()) < CV_MAT_CN(this->type()))
{
clr.create(img.size().height, img.size().width, this->type());
color = true;
data = clr.ptr();
step = (int)clr.step;
}
#endif
if( stream && image )
{
bool convert;
int colorspace;
if( color )
{
convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);
colorspace = JAS_CLRSPC_SRGB;
}
else
{
convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);
colorspace = JAS_CLRSPC_SGRAY;         }
if( convert )
{
jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );
if( clrprof )
{
jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );
if( _img )
{
jas_image_destroy( image );
m_image = image = _img;
result = true;
}
else
fprintf(stderr, ""JPEG 2000 LOADER ERROR: cannot convert colorspace\n"");
jas_cmprof_destroy( clrprof );
}
else
fprintf(stderr, ""JPEG 2000 LOADER ERROR: unable to create colorspace\n"");
}
else
result = true;
if( result )
{
int ncmpts;
int cmptlut[3];
if( color )
{
cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );
cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );
cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );
if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 )
result = false;
ncmpts = 3;
}
else
{
cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );
if( cmptlut[0] < 0 )
result = false;
ncmpts = 1;
}
if( result )
{
for( int i = 0; i < ncmpts; i++ )
{
int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );
int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;
int yend = jas_image_cmptbry( image, cmptlut[i] );
int ystep = jas_image_cmptvstep( image, cmptlut[i] );
int xend = jas_image_cmptbrx( image, cmptlut[i] );
int xstep = jas_image_cmpthstep( image, cmptlut[i] );
jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );
if( buffer )
{
if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))
{
if( img.depth() == CV_8U )
result = readComponent8u( data + i, buffer, validateToInt(step), cmptlut[i], maxval, offset, ncmpts );
else
result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );
if( !result )
{
i = ncmpts;
result = false;
}
}
jas_matrix_destroy( buffer );
}
}
}
}
else
fprintf(stderr, ""JPEG2000 LOADER ERROR: colorspace conversion failed\n"" );
}
close();
#ifndef _WIN32
if (!clr.empty())
{
cv::cvtColor(clr, img, COLOR_BGR2GRAY);
}
#endif
return result;
}","bool  Jpeg2KDecoder::readData( Mat& VAR_0 )
{
bool VAR_1 = false;
int VAR_2 = VAR_0.channels() > 1;
uchar* VAR_3 = VAR_0.ptr();
size_t VAR_4 = VAR_0.step;
jas_stream_t* VAR_5 = (jas_stream_t*)VAR_6;
jas_image_t* VAR_7 = (jas_image_t*)VAR_8;
#ifndef VAR_9
Mat VAR_10;
if (CV_MAT_CN(VAR_0.type()) < CV_MAT_CN(this->type()))
{
VAR_10.create(VAR_0.size().height, VAR_0.size().width, this->type());
VAR_2 = true;
VAR_3 = VAR_10.ptr();
VAR_4 = (int)VAR_10.step;
}
#endif
if( VAR_5 && VAR_7 )
{
bool VAR_11;
int VAR_12;
if( VAR_2 )
{
VAR_11 = (jas_image_clrspc( VAR_7 ) != VAR_13);
VAR_12 = VAR_13;
}
else
{
VAR_11 = (jas_clrspc_fam( jas_image_clrspc( VAR_7 ) ) != VAR_14);
VAR_12 = VAR_15; 
}
if( VAR_11 )
{
jas_cmprof_t *VAR_16 = jas_cmprof_createfromclrspc( VAR_12 );
if( VAR_16 )
{
jas_image_t *VAR_17 = jas_image_chclrspc( VAR_7, VAR_16, VAR_18 );
if( VAR_17 )
{
jas_image_destroy( VAR_7 );
VAR_8 = VAR_7 = VAR_17;
VAR_1 = true;
}
else
fprintf(VAR_19, ""JPEG 2000 LOADER ERROR: cannot convert colorspace\n"");
jas_cmprof_destroy( VAR_16 );
}
else
fprintf(VAR_19, ""JPEG 2000 LOADER ERROR: unable to create colorspace\n"");
}
else
VAR_1 = true;
if( VAR_1 )
{
int VAR_20;
int VAR_21[3];
if( VAR_2 )
{
VAR_21[0] = jas_image_getcmptbytype( VAR_7, VAR_22 );
VAR_21[1] = jas_image_getcmptbytype( VAR_7, VAR_23 );
VAR_21[2] = jas_image_getcmptbytype( VAR_7, VAR_24 );
if( VAR_21[0] < 0 || VAR_21[1] < 0 || VAR_21[2] < 0 )
VAR_1 = false;
VAR_20 = 3;
}
else
{
VAR_21[0] = jas_image_getcmptbytype( VAR_7, VAR_25 );
if( VAR_21[0] < 0 )
VAR_1 = false;
VAR_20 = 1;
}
if( VAR_1 )
{
for( int VAR_26 = 0; VAR_26 < VAR_20; VAR_26++ )
{
int VAR_27 = 1 << jas_image_cmptprec( VAR_7, VAR_21[VAR_26] );
int VAR_28 =  jas_image_cmptsgnd( VAR_7, VAR_21[VAR_26] ) ? VAR_27 / 2 : 0;
int VAR_29 = jas_image_cmptbry( VAR_7, VAR_21[VAR_26] );
int VAR_30 = jas_image_cmptvstep( VAR_7, VAR_21[VAR_26] );
int VAR_31 = jas_image_cmptbrx( VAR_7, VAR_21[VAR_26] );
int VAR_32 = jas_image_cmpthstep( VAR_7, VAR_21[VAR_26] );
jas_matrix_t *VAR_33 = jas_matrix_create( VAR_29 / VAR_30, VAR_31 / VAR_32 );
if( VAR_33 )
{
if( !jas_image_readcmpt( VAR_7, VAR_21[VAR_26], 0, 0, VAR_31 / VAR_32, VAR_29 / VAR_30, VAR_33 ))
{
if( VAR_0.depth() == VAR_34 )
VAR_1 = readComponent8u( VAR_3 + VAR_26, VAR_33, validateToInt(VAR_4), VAR_21[VAR_26], VAR_27, VAR_28, VAR_20 );
else
VAR_1 = readComponent16u( ((unsigned short *)VAR_3) + VAR_26, VAR_33, validateToInt(VAR_4 / 2), VAR_21[VAR_26], VAR_27, VAR_28, VAR_20 );
if( !VAR_1 )
{
VAR_26 = VAR_20;
VAR_1 = false;
}
}
jas_matrix_destroy( VAR_33 );
}
}
}
}
else
fprintf(VAR_19, ""JPEG2000 LOADER ERROR: colorspace conversion failed\n"" );
}
close();
#ifndef VAR_9
if (!VAR_10.empty())
{
cv::cvtColor(VAR_10, VAR_0, VAR_35);
}
#endif
return VAR_1;
}",opencv/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa/grfmt_jpeg2000.cpp/vul/before/2.json,"bool  Jpeg2KDecoder::readData( Mat& img )
{
    Ptr<Jpeg2KDecoder> close_this(this, Jpeg2KDecoder_close);
    bool result = false;
    int color = img.channels() > 1;
    uchar* data = img.ptr();
    size_t step = img.step;
    jas_stream_t* stream = (jas_stream_t*)m_stream;
    jas_image_t* image = (jas_image_t*)m_image;

#ifndef _WIN32
    // At least on some Linux instances the
    // system libjasper segfaults when
    // converting color to grey.
    // We do this conversion manually at the end.
    Mat clr;
    if (CV_MAT_CN(img.type()) < CV_MAT_CN(this->type()))
    {
        clr.create(img.size().height, img.size().width, this->type());
        color = true;
        data = clr.ptr();
        step = (int)clr.step;
    }
#endif

    if( stream && image )
    {
        bool convert;
        int colorspace;
        if( color )
        {
            convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB);
            colorspace = JAS_CLRSPC_SRGB;
        }
        else
        {
            convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY);
            colorspace = JAS_CLRSPC_SGRAY; // TODO GENGRAY or SGRAY? (GENGRAY fails on Win.)
        }

        // convert to the desired colorspace
        if( convert )
        {
            jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace );
            if( clrprof )
            {
                jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR );
                if( _img )
                {
                    jas_image_destroy( image );
                    m_image = image = _img;
                    result = true;
                }
                else
                {
                    jas_cmprof_destroy(clrprof);
                    CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: cannot convert colorspace"");
                }
                jas_cmprof_destroy( clrprof );
            }
            else
            {
                CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: unable to create colorspace"");
            }
        }
        else
            result = true;

        if( result )
        {
            int ncmpts;
            int cmptlut[3];
            if( color )
            {
                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B );
                cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G );
                cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R );
                if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 )
                    result = false;
                ncmpts = 3;
            }
            else
            {
                cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y );
                if( cmptlut[0] < 0 )
                    result = false;
                ncmpts = 1;
            }

            if( result )
            {
                for( int i = 0; i < ncmpts; i++ )
                {
                    int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] );
                    int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0;

                    int yend = jas_image_cmptbry( image, cmptlut[i] );
                    int ystep = jas_image_cmptvstep( image, cmptlut[i] );
                    int xend = jas_image_cmptbrx( image, cmptlut[i] );
                    int xstep = jas_image_cmpthstep( image, cmptlut[i] );

                    jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep );
                    if( buffer )
                    {
                        if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer ))
                        {
                            if( img.depth() == CV_8U )
                                result = readComponent8u( data + i, buffer, validateToInt(step), cmptlut[i], maxval, offset, ncmpts );
                            else
                                result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );
                            if( !result )
                            {
                                jas_matrix_destroy( buffer );
                                CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: failed to read component"");
                            }
                        }
                        jas_matrix_destroy( buffer );
                    }
                }
            }
        }
        else
        {
            CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: colorspace conversion failed"");
        }
    }

    CV_Assert(result == true);

#ifndef _WIN32
    if (!clr.empty())
    {
        cv::cvtColor(clr, img, COLOR_BGR2GRAY);
    }
#endif

    return result;
}","bool  Jpeg2KDecoder::readData( Mat& VAR_0 )
{
    Ptr<Jpeg2KDecoder> VAR_1(this, VAR_2);
    bool VAR_3 = false;
    int VAR_4 = VAR_0.channels() > 1;
    uchar* VAR_5 = VAR_0.ptr();
    size_t VAR_6 = VAR_0.step;
    jas_stream_t* VAR_7 = (jas_stream_t*)VAR_8;
    jas_image_t* VAR_9 = (jas_image_t*)VAR_10;

#ifndef VAR_11
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    Mat VAR_12;
    if (CV_MAT_CN(VAR_0.type()) < CV_MAT_CN(this->type()))
    {
        VAR_12.create(VAR_0.size().height, VAR_0.size().width, this->type());
        VAR_4 = true;
        VAR_5 = VAR_12.ptr();
        VAR_6 = (int)VAR_12.step;
    }
#endif

    if( VAR_7 && VAR_9 )
    {
        bool VAR_13;
        int VAR_14;
        if( VAR_4 )
        {
            VAR_13 = (jas_image_clrspc( VAR_9 ) != VAR_15);
            VAR_14 = VAR_15;
        }
        else
        {
            VAR_13 = (jas_clrspc_fam( jas_image_clrspc( VAR_9 ) ) != VAR_16);
            VAR_14 = VAR_17; /* COMMENT_4 */
        }

        /* COMMENT_5 */
        if( VAR_13 )
        {
            jas_cmprof_t *VAR_18 = jas_cmprof_createfromclrspc( VAR_14 );
            if( VAR_18 )
            {
                jas_image_t *VAR_19 = jas_image_chclrspc( VAR_9, VAR_18, VAR_20 );
                if( VAR_19 )
                {
                    jas_image_destroy( VAR_9 );
                    VAR_10 = VAR_9 = VAR_19;
                    VAR_3 = true;
                }
                else
                {
                    jas_cmprof_destroy(VAR_18);
                    CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: cannot convert colorspace"");
                }
                jas_cmprof_destroy( VAR_18 );
            }
            else
            {
                CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: unable to create colorspace"");
            }
        }
        else
            VAR_3 = true;

        if( VAR_3 )
        {
            int VAR_21;
            int VAR_22[3];
            if( VAR_4 )
            {
                VAR_22[0] = jas_image_getcmptbytype( VAR_9, VAR_23 );
                VAR_22[1] = jas_image_getcmptbytype( VAR_9, VAR_24 );
                VAR_22[2] = jas_image_getcmptbytype( VAR_9, VAR_25 );
                if( VAR_22[0] < 0 || VAR_22[1] < 0 || VAR_22[2] < 0 )
                    VAR_3 = false;
                VAR_21 = 3;
            }
            else
            {
                VAR_22[0] = jas_image_getcmptbytype( VAR_9, VAR_26 );
                if( VAR_22[0] < 0 )
                    VAR_3 = false;
                VAR_21 = 1;
            }

            if( VAR_3 )
            {
                for( int VAR_27 = 0; VAR_27 < VAR_21; VAR_27++ )
                {
                    int VAR_28 = 1 << jas_image_cmptprec( VAR_9, VAR_22[VAR_27] );
                    int VAR_29 =  jas_image_cmptsgnd( VAR_9, VAR_22[VAR_27] ) ? VAR_28 / 2 : 0;

                    int VAR_30 = jas_image_cmptbry( VAR_9, VAR_22[VAR_27] );
                    int VAR_31 = jas_image_cmptvstep( VAR_9, VAR_22[VAR_27] );
                    int VAR_32 = jas_image_cmptbrx( VAR_9, VAR_22[VAR_27] );
                    int VAR_33 = jas_image_cmpthstep( VAR_9, VAR_22[VAR_27] );

                    jas_matrix_t *VAR_34 = jas_matrix_create( VAR_30 / VAR_31, VAR_32 / VAR_33 );
                    if( VAR_34 )
                    {
                        if( !jas_image_readcmpt( VAR_9, VAR_22[VAR_27], 0, 0, VAR_32 / VAR_33, VAR_30 / VAR_31, VAR_34 ))
                        {
                            if( VAR_0.depth() == VAR_35 )
                                VAR_3 = readComponent8u( VAR_5 + VAR_27, VAR_34, validateToInt(VAR_6), VAR_22[VAR_27], VAR_28, VAR_29, VAR_21 );
                            else
                                VAR_3 = readComponent16u( ((unsigned short *)VAR_5) + VAR_27, VAR_34, validateToInt(VAR_6 / 2), VAR_22[VAR_27], VAR_28, VAR_29, VAR_21 );
                            if( !VAR_3 )
                            {
                                jas_matrix_destroy( VAR_34 );
                                CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: failed to read component"");
                            }
                        }
                        jas_matrix_destroy( VAR_34 );
                    }
                }
            }
        }
        else
        {
            CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: colorspace conversion failed"");
        }
    }

    CV_Assert(VAR_3 == true);

#ifndef VAR_11
    if (!VAR_12.empty())
    {
        cv::cvtColor(VAR_12, VAR_0, VAR_36);
    }
#endif

    return VAR_3;
}",opencv/435a3e337bd9d4e11af61cf8b8afca067bf1a8aa/grfmt_jpeg2000.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 bool  Jpeg2KDecoder::readData( Mat& img )
 {
+    Ptr<Jpeg2KDecoder> close_this(this, Jpeg2KDecoder_close);
     bool result = false;
     int color = img.channels() > 1;
     uchar* data = img.ptr();
@@ -51,11 +52,16 @@
                     result = true;
                 }
                 else
-                    fprintf(stderr, ""JPEG 2000 LOADER ERROR: cannot convert colorspace\n"");
+                {
+                    jas_cmprof_destroy(clrprof);
+                    CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: cannot convert colorspace"");
+                }
                 jas_cmprof_destroy( clrprof );
             }
             else
-                fprintf(stderr, ""JPEG 2000 LOADER ERROR: unable to create colorspace\n"");
+            {
+                CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: unable to create colorspace"");
+            }
         }
         else
             result = true;
@@ -104,8 +110,8 @@
                                 result = readComponent16u( ((unsigned short *)data) + i, buffer, validateToInt(step / 2), cmptlut[i], maxval, offset, ncmpts );
                             if( !result )
                             {
-                                i = ncmpts;
-                                result = false;
+                                jas_matrix_destroy( buffer );
+                                CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: failed to read component"");
                             }
                         }
                         jas_matrix_destroy( buffer );
@@ -114,10 +120,12 @@
             }
         }
         else
-            fprintf(stderr, ""JPEG2000 LOADER ERROR: colorspace conversion failed\n"" );
+        {
+            CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: colorspace conversion failed"");
+        }
     }
 
-    close();
+    CV_Assert(result == true);
 
 #ifndef _WIN32
     if (!clr.empty())","{'deleted_lines': ['                    fprintf(stderr, ""JPEG 2000 LOADER ERROR: cannot convert colorspace\\n"");', '                fprintf(stderr, ""JPEG 2000 LOADER ERROR: unable to create colorspace\\n"");', '                                i = ncmpts;', '                                result = false;', '            fprintf(stderr, ""JPEG2000 LOADER ERROR: colorspace conversion failed\\n"" );', '    close();'], 'added_lines': ['    Ptr<Jpeg2KDecoder> close_this(this, Jpeg2KDecoder_close);', '                {', '                    jas_cmprof_destroy(clrprof);', '                    CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: cannot convert colorspace"");', '                }', '            {', '                CV_Error(Error::StsError, ""JPEG 2000 LOADER ERROR: unable to create colorspace"");', '            }', '                                jas_matrix_destroy( buffer );', '                                CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: failed to read component"");', '        {', '            CV_Error(Error::StsError, ""JPEG2000 LOADER ERROR: colorspace conversion failed"");', '        }', '    CV_Assert(result == true);']}",True,"In OpenCV 3.3.1, a heap-based buffer overflow happens in cv::Jpeg2KDecoder::readComponent8u in modules/imgcodecs/src/grfmt_jpeg2000.cpp when parsing a crafted image file.",5.5,MEDIUM,1,test,2018-01-09T14:36:57Z,2
CVE-2018-5294,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,libming,"Fix integer overflow vulnerability in util/read.c.

This vulnerability is caused by a regression introduced in
d468907.

In this commit we cast the result of readUInt8(f) before left
shifting by 24 in order to avoid out of range shift.

This commit fixes CVE-2018-5251 (fixes #98).",c14d07ef20c3f403fcfa59502b74c66933473431,https://github.com/libming/libming/commit/c14d07ef20c3f403fcfa59502b74c66933473431,util/read.c,readSInt32,"long readSInt32(FILE *f)
{
long result = 0;
result |= readUInt8(f);
result |= readUInt8(f) << 8;
result |= readUInt8(f) << 16;
result |= readUInt8(f) << 24;
return result;
}","long readSInt32(FILE *VAR_0)
{
long VAR_1 = 0;
VAR_1 |= readUInt8(VAR_0);
VAR_1 |= readUInt8(VAR_0) << 8;
VAR_1 |= readUInt8(VAR_0) << 16;
VAR_1 |= readUInt8(VAR_0) << 24;
return VAR_1;
}",libming/c14d07ef20c3f403fcfa59502b74c66933473431/read.c/vul/before/1.json,"long readSInt32(FILE *f)
{
  long result = 0;
  result |= readUInt8(f);
  result |= readUInt8(f) << 8;
  result |= readUInt8(f) << 16;
  result |= (long) readUInt8(f) << 24;
  return result;
}","long readSInt32(FILE *VAR_0)
{
  long VAR_1 = 0;
  VAR_1 |= readUInt8(VAR_0);
  VAR_1 |= readUInt8(VAR_0) << 8;
  VAR_1 |= readUInt8(VAR_0) << 16;
  VAR_1 |= (long) readUInt8(VAR_0) << 24;
  return VAR_1;
}",libming/c14d07ef20c3f403fcfa59502b74c66933473431/read.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,6 +4,6 @@
   result |= readUInt8(f);
   result |= readUInt8(f) << 8;
   result |= readUInt8(f) << 16;
-  result |= readUInt8(f) << 24;
+  result |= (long) readUInt8(f) << 24;
   return result;
 }","{'deleted_lines': ['  result |= readUInt8(f) << 24;'], 'added_lines': ['  result |= (long) readUInt8(f) << 24;']}",True,"In libming 0.4.8, there is an integer overflow (caused by an out-of-range left shift) in the readUInt32 function (util/read.c). Remote attackers could leverage this vulnerability to cause a denial-of-service via a crafted swf file.",6.5,MEDIUM,1,test,2018-01-17T09:49:41Z,2
CVE-2018-5294,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,libming,"Fix integer overflow vulnerability in util/read.c.

This vulnerability is caused by a regression introduced in
d468907.

In this commit we cast the result of readUInt8(f) before left
shifting by 24 in order to avoid out of range shift.

This commit fixes CVE-2018-5251 (fixes #98).",c14d07ef20c3f403fcfa59502b74c66933473431,https://github.com/libming/libming/commit/c14d07ef20c3f403fcfa59502b74c66933473431,util/read.c,readUInt32,"unsigned long readUInt32(FILE *f)
{
unsigned long result = 0u;
result |= readUInt8(f);
result |= readUInt8(f) << 8;
result |= readUInt8(f) << 16;
result |= readUInt8(f) << 24;
return result;
}","unsigned long readUInt32(FILE *VAR_0)
{
unsigned long VAR_1 = 0u;
VAR_1 |= readUInt8(VAR_0);
VAR_1 |= readUInt8(VAR_0) << 8;
VAR_1 |= readUInt8(VAR_0) << 16;
VAR_1 |= readUInt8(VAR_0) << 24;
return VAR_1;
}",libming/c14d07ef20c3f403fcfa59502b74c66933473431/read.c/vul/before/0.json,"unsigned long readUInt32(FILE *f)
{
  unsigned long result = 0u;
  result |= readUInt8(f);
  result |= readUInt8(f) << 8;
  result |= readUInt8(f) << 16;
  result |= (unsigned long) readUInt8(f) << 24;
  return result;
}","unsigned long readUInt32(FILE *VAR_0)
{
  unsigned long VAR_1 = 0u;
  VAR_1 |= readUInt8(VAR_0);
  VAR_1 |= readUInt8(VAR_0) << 8;
  VAR_1 |= readUInt8(VAR_0) << 16;
  VAR_1 |= (unsigned long) readUInt8(VAR_0) << 24;
  return VAR_1;
}",libming/c14d07ef20c3f403fcfa59502b74c66933473431/read.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,6 @@
   result |= readUInt8(f);
   result |= readUInt8(f) << 8;
   result |= readUInt8(f) << 16;
-  result |= readUInt8(f) << 24;
+  result |= (unsigned long) readUInt8(f) << 24;
   return result;
 }","{'deleted_lines': ['  result |= readUInt8(f) << 24;'], 'added_lines': ['  result |= (unsigned long) readUInt8(f) << 24;']}",True,"In libming 0.4.8, there is an integer overflow (caused by an out-of-range left shift) in the readUInt32 function (util/read.c). Remote attackers could leverage this vulnerability to cause a denial-of-service via a crafted swf file.",6.5,MEDIUM,1,test,2018-01-17T09:49:41Z,2
CVE-2018-6198,['CWE-59'],AV:L/AC:M/Au:N/C:N/I:P/A:P,0.0,tats/w3m,Make temporary directory safely when ~/.w3m is unwritable,18dcbadf2771cdb0c18509b14e4e73505b242753,https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753,main.c,w3m_exit,"void
w3m_exit(int i)
{
#ifdef USE_MIGEMO
init_migemo();
#endif
stopDownload();
deleteFiles();
#ifdef USE_SSL
free_ssl_ctx();
#endif
disconnectFTP();
#ifdef USE_NNTP
disconnectNews();
#endif
#ifdef __MINGW32_VERSION
WSACleanup();
#endif
exit(i);
}","void
w3m_exit(int VAR_0)
{
#ifdef VAR_1
init_migemo();
#endif
stopDownload();
deleteFiles();
#ifdef VAR_2
free_ssl_ctx();
#endif
disconnectFTP();
#ifdef VAR_3
disconnectNews();
#endif
#ifdef VAR_4
WSACleanup();
#endif
exit(VAR_0);
}",tats/w3m/18dcbadf2771cdb0c18509b14e4e73505b242753/main.c/vul/before/0.json,"void
w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		/* close pipe to migemo */
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
#endif
#ifdef __MINGW32_VERSION
    WSACleanup();
#endif
#ifdef HAVE_MKDTEMP
    if (no_rc_dir && tmp_dir != rc_dir)
	if (rmdir(tmp_dir) != 0) {
	    fprintf(stderr, ""Can't remove temporary directory (%s)!\n"", tmp_dir);
	    exit(1);
	}
#endif
    exit(i);
}","void
w3m_exit(int VAR_0)
{
#ifdef VAR_1
    init_migemo();		/* COMMENT_0 */
#endif
    stopDownload();
    deleteFiles();
#ifdef VAR_2
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef VAR_3
    disconnectNews();
#endif
#ifdef VAR_4
    WSACleanup();
#endif
#ifdef VAR_5
    if (VAR_6 && VAR_7 != VAR_8)
	if (rmdir(VAR_7) != 0) {
	    fprintf(VAR_9, ""Can't remove temporary directory (%s)!\n"", VAR_7);
	    exit(1);
	}
#endif
    exit(VAR_0);
}",tats/w3m/18dcbadf2771cdb0c18509b14e4e73505b242753/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,5 +16,12 @@
 #ifdef __MINGW32_VERSION
     WSACleanup();
 #endif
+#ifdef HAVE_MKDTEMP
+    if (no_rc_dir && tmp_dir != rc_dir)
+	if (rmdir(tmp_dir) != 0) {
+	    fprintf(stderr, ""Can't remove temporary directory (%s)!\n"", tmp_dir);
+	    exit(1);
+	}
+#endif
     exit(i);
 }","{'deleted_lines': [], 'added_lines': ['#ifdef HAVE_MKDTEMP', '    if (no_rc_dir && tmp_dir != rc_dir)', '\tif (rmdir(tmp_dir) != 0) {', '\t    fprintf(stderr, ""Can\'t remove temporary directory (%s)!\\n"", tmp_dir);', '\t    exit(1);', '\t}', '#endif']}",True,"w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",4.7,MEDIUM,1,test,2018-01-20T16:29:10Z,2
CVE-2018-6198,['CWE-59'],AV:L/AC:M/Au:N/C:N/I:P/A:P,0.0,tats/w3m,Make temporary directory safely when ~/.w3m is unwritable,18dcbadf2771cdb0c18509b14e4e73505b242753,https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753,rc.c,init_rc,"void
init_rc(void)
{
int i;
struct stat st;
FILE *f;
if (rc_dir != NULL)
goto open_rc;
rc_dir = expandPath(RC_DIR);
i = strlen(rc_dir);
if (i > 1 && rc_dir[i - 1] == '/')
rc_dir[i - 1] = '\0';
#ifdef USE_M17N
display_charset_str = wc_get_ces_list();
document_charset_str = display_charset_str;
system_charset_str = display_charset_str;
#endif
if (stat(rc_dir, &st) < 0) {
if (errno == ENOENT) {
if (do_mkdir(rc_dir, 0700) < 0) {
goto rc_dir_err;
}
else {
stat(rc_dir, &st);
}
}
else {
goto rc_dir_err;
}
}
if (!S_ISDIR(st.st_mode)) {
goto rc_dir_err;
}
if (!(st.st_mode & S_IWUSR)) {
goto rc_dir_err;
}
no_rc_dir = FALSE;
tmp_dir = rc_dir;
if (config_file == NULL)
config_file = rcFile(CONFIG_FILE);
create_option_search_table();
open_rc:
if ((f = fopen(etcFile(W3MCONFIG), ""rt"")) != NULL) {
interpret_rc(f);
fclose(f);
}
if ((f = fopen(confFile(CONFIG_FILE), ""rt"")) != NULL) {
interpret_rc(f);
fclose(f);
}
if (config_file && (f = fopen(config_file, ""rt"")) != NULL) {
interpret_rc(f);
fclose(f);
}
return;
rc_dir_err:
no_rc_dir = TRUE;
if (((tmp_dir = getenv(""TMPDIR"")) == NULL || *tmp_dir == '\0') &&
((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
tmp_dir = ""/tmp"";
create_option_search_table();
goto open_rc;
}","void
init_rc(void)
{
int VAR_0;
struct stat VAR_1;
FILE *VAR_2;
if (VAR_3 != NULL)
goto open_rc;
VAR_3 = expandPath(VAR_4);
VAR_0 = strlen(VAR_3);
if (VAR_0 > 1 && VAR_3[VAR_0 - 1] == '/')
VAR_3[VAR_0 - 1] = '\0';
#ifdef VAR_5
VAR_6 = wc_get_ces_list();
VAR_7 = VAR_6;
VAR_8 = VAR_6;
#endif
if (stat(VAR_3, &VAR_1) < 0) {
if (VAR_9 == VAR_10) {
if (do_mkdir(VAR_3, 0700) < 0) {
goto rc_dir_err;
}
else {
stat(VAR_3, &VAR_1);
}
}
else {
goto rc_dir_err;
}
}
if (!S_ISDIR(VAR_1.st_mode)) {
goto rc_dir_err;
}
if (!(VAR_1.st_mode & VAR_11)) {
goto rc_dir_err;
}
VAR_12 = FALSE;
VAR_13 = VAR_3;
if (VAR_14 == NULL)
VAR_14 = rcFile(VAR_15);
create_option_search_table();
open_rc:
if ((VAR_2 = fopen(etcFile(VAR_16), ""rt"")) != NULL) {
interpret_rc(VAR_2);
fclose(VAR_2);
}
if ((VAR_2 = fopen(confFile(VAR_15), ""rt"")) != NULL) {
interpret_rc(VAR_2);
fclose(VAR_2);
}
if (VAR_14 && (VAR_2 = fopen(VAR_14, ""rt"")) != NULL) {
interpret_rc(VAR_2);
fclose(VAR_2);
}
return;
rc_dir_err:
VAR_12 = TRUE;
if (((VAR_13 = getenv(""TMPDIR"")) == NULL || *VAR_13 == '\0') &&
((VAR_13 = getenv(""TMP"")) == NULL || *VAR_13 == '\0') &&
((VAR_13 = getenv(""TEMP"")) == NULL || *VAR_13 == '\0'))
VAR_13 = ""/tmp"";
create_option_search_table();
goto open_rc;
}",tats/w3m/18dcbadf2771cdb0c18509b14e4e73505b242753/rc.c/vul/before/0.json,"void
init_rc(void)
{
    int i;
    struct stat st;
    FILE *f;

    if (rc_dir != NULL)
	goto open_rc;

    rc_dir = expandPath(RC_DIR);
    i = strlen(rc_dir);
    if (i > 1 && rc_dir[i - 1] == '/')
	rc_dir[i - 1] = '\0';

#ifdef USE_M17N
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
#endif

    if (stat(rc_dir, &st) < 0) {
	if (errno == ENOENT) {	/* no directory */
	    if (do_mkdir(rc_dir, 0700) < 0) {
		/* fprintf(stderr, ""Can't create config directory (%s)!\n"", rc_dir); */
		goto rc_dir_err;
	    }
	    else {
		stat(rc_dir, &st);
	    }
	}
	else {
	    /* fprintf(stderr, ""Can't open config directory (%s)!\n"", rc_dir); */
	    goto rc_dir_err;
	}
    }
    if (!S_ISDIR(st.st_mode)) {
	/* not a directory */
	/* fprintf(stderr, ""%s is not a directory!\n"", rc_dir); */
	goto rc_dir_err;
    }
    if (!(st.st_mode & S_IWUSR)) {
	/* fprintf(stderr, ""%s is not writable!\n"", rc_dir); */
	goto rc_dir_err;
    }
    no_rc_dir = FALSE;
    tmp_dir = rc_dir;

    if (config_file == NULL)
	config_file = rcFile(CONFIG_FILE);

    create_option_search_table();

  open_rc:
    /* open config file */
    if ((f = fopen(etcFile(W3MCONFIG), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if ((f = fopen(confFile(CONFIG_FILE), ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    if (config_file && (f = fopen(config_file, ""rt"")) != NULL) {
	interpret_rc(f);
	fclose(f);
    }
    return;

  rc_dir_err:
    no_rc_dir = TRUE;
    if (((tmp_dir = getenv(""TMPDIR"")) == NULL || *tmp_dir == '\0') &&
	((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
	((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
	tmp_dir = ""/tmp"";
#ifdef HAVE_MKDTEMP
    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);
    if (tmp_dir == NULL)
	tmp_dir = rc_dir;
#endif
    create_option_search_table();
    goto open_rc;
}","void
init_rc(void)
{
    int VAR_0;
    struct stat VAR_1;
    FILE *VAR_2;

    if (VAR_3 != NULL)
	goto open_rc;

    VAR_3 = expandPath(VAR_4);
    VAR_0 = strlen(VAR_3);
    if (VAR_0 > 1 && VAR_3[VAR_0 - 1] == '/')
	VAR_3[VAR_0 - 1] = '\0';

#ifdef VAR_5
    VAR_6 = wc_get_ces_list();
    VAR_7 = VAR_6;
    VAR_8 = VAR_6;
#endif

    if (stat(VAR_3, &VAR_1) < 0) {
	if (VAR_9 == VAR_10) {	/* COMMENT_0 */
	    if (do_mkdir(VAR_3, 0700) < 0) {
		/* COMMENT_1 */
		goto rc_dir_err;
	    }
	    else {
		stat(VAR_3, &VAR_1);
	    }
	}
	else {
	    /* COMMENT_2 */
	    goto rc_dir_err;
	}
    }
    if (!S_ISDIR(VAR_1.st_mode)) {
	/* COMMENT_3 */
	/* COMMENT_4 */
	goto rc_dir_err;
    }
    if (!(VAR_1.st_mode & VAR_11)) {
	/* COMMENT_5 */
	goto rc_dir_err;
    }
    VAR_12 = FALSE;
    VAR_13 = VAR_3;

    if (VAR_14 == NULL)
	VAR_14 = rcFile(VAR_15);

    create_option_search_table();

  open_rc:
    /* COMMENT_6 */
    if ((VAR_2 = fopen(etcFile(VAR_16), ""rt"")) != NULL) {
	interpret_rc(VAR_2);
	fclose(VAR_2);
    }
    if ((VAR_2 = fopen(confFile(VAR_15), ""rt"")) != NULL) {
	interpret_rc(VAR_2);
	fclose(VAR_2);
    }
    if (VAR_14 && (VAR_2 = fopen(VAR_14, ""rt"")) != NULL) {
	interpret_rc(VAR_2);
	fclose(VAR_2);
    }
    return;

  rc_dir_err:
    VAR_12 = TRUE;
    if (((VAR_13 = getenv(""TMPDIR"")) == NULL || *VAR_13 == '\0') &&
	((VAR_13 = getenv(""TMP"")) == NULL || *VAR_13 == '\0') &&
	((VAR_13 = getenv(""TEMP"")) == NULL || *VAR_13 == '\0'))
	VAR_13 = ""/tmp"";
#ifdef VAR_17
    VAR_13 = mkdtemp(Strnew_m_charp(VAR_13, ""/w3m-XXXXXX"", NULL)->ptr);
    if (VAR_13 == NULL)
	VAR_13 = VAR_3;
#endif
    create_option_search_table();
    goto open_rc;
}",tats/w3m/18dcbadf2771cdb0c18509b14e4e73505b242753/rc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -73,6 +73,11 @@
 	((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') &&
 	((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0'))
 	tmp_dir = ""/tmp"";
+#ifdef HAVE_MKDTEMP
+    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);
+    if (tmp_dir == NULL)
+	tmp_dir = rc_dir;
+#endif
     create_option_search_table();
     goto open_rc;
 }","{'deleted_lines': [], 'added_lines': ['#ifdef HAVE_MKDTEMP', '    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, ""/w3m-XXXXXX"", NULL)->ptr);', '    if (tmp_dir == NULL)', '\ttmp_dir = rc_dir;', '#endif']}",True,"w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",4.7,MEDIUM,1,test,2018-01-20T16:29:10Z,2
CVE-2018-1000038,"['CWE-416', 'CWE-787']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ArtifexSoftware/mupdf,"Bug 698883: Reset cmap splay tree pointer, handling resized tree.

Without this change a resized cmap splay tree leads to using stale pointers.",f597300439e62f5e921f0d7b1e880b5c1a1f1607,https://github.com/ArtifexSoftware/mupdf/commit/f597300439e62f5e921f0d7b1e880b5c1a1f1607,source/pdf/pdf-cmap.c,add_range,"static void
add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
int current;
cmap_splay *tree;
if (low > high)
{
fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
return;
}
tree = cmap->tree;
if (cmap->tlen)
{
unsigned int move = cmap->ttop;
unsigned int gt = EMPTY;
unsigned int lt = EMPTY;
if (check_for_overlap)
{
do
{
current = move;
if (low <= tree[current].low && tree[current].low <= high)
{
tree[current].out += high + 1 - tree[current].low;
tree[current].low = high + 1;
if (tree[current].low > tree[current].high)
{
move = delete_node(cmap, current);
current = EMPTY;
continue;
}
}
else if (low <= tree[current].high && tree[current].high <= high)
{
tree[current].high = low - 1;
assert(tree[current].low <= tree[current].high);
}
else if (tree[current].low < low && high < tree[current].high)
{
int new_high = tree[current].high;
tree[current].high = low-1;
add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
}
if (tree[current].low > high) {
move = tree[current].left;
gt = current;
}
else
{
move = tree[current].right;
lt = current;
}
}
while (move != EMPTY);
}
else
{
do
{
current = move;
if (tree[current].low > high)
{
move = tree[current].left;
gt = current;
}
else
{
move = tree[current].right;
lt = current;
}
} while (move != EMPTY);
}
if (!many)
{
if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
{
tree[lt].high = high;
if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
{
tree[lt].high = tree[gt].high;
delete_node(cmap, gt);
}
goto exit;
}
if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
{
tree[gt].low = low;
tree[gt].out = out;
goto exit;
}
}
}
else
current = EMPTY;
if (cmap->tlen == cmap->tcap)
{
int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
cmap->tcap = new_cap;
}
tree[cmap->tlen].low = low;
tree[cmap->tlen].high = high;
tree[cmap->tlen].out = out;
tree[cmap->tlen].parent = current;
tree[cmap->tlen].left = EMPTY;
tree[cmap->tlen].right = EMPTY;
tree[cmap->tlen].many = many;
cmap->tlen++;
if (current == EMPTY)
cmap->ttop = 0;
else if (tree[current].low > high)
tree[current].left = cmap->tlen-1;
else
{
assert(tree[current].high < low);
tree[current].right = cmap->tlen-1;
}
move_to_root(tree, cmap->tlen-1);
cmap->ttop = cmap->tlen-1;
exit:
{}
#ifdef CHECK_SPLAY
check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}","static void
add_range(fz_context *VAR_0, pdf_cmap *VAR_1, unsigned int VAR_2, unsigned int VAR_3, unsigned int VAR_4, int VAR_5, int VAR_6)
{
int VAR_7;
cmap_splay *VAR_8;
if (VAR_2 > VAR_3)
{
fz_warn(VAR_0, ""range limits out of range in cmap %s"", VAR_1->cmap_name);
return;
}
VAR_8 = VAR_1->tree;
if (VAR_1->tlen)
{
unsigned int VAR_9 = VAR_1->ttop;
unsigned int VAR_10 = VAR_11;
unsigned int VAR_12 = VAR_11;
if (VAR_5)
{
do
{
VAR_7 = VAR_9;
if (VAR_2 <= VAR_8[VAR_7].low && VAR_8[VAR_7].low <= VAR_3)
{
VAR_8[VAR_7].out += VAR_3 + 1 - VAR_8[VAR_7].low;
VAR_8[VAR_7].low = VAR_3 + 1;
if (VAR_8[VAR_7].low > VAR_8[VAR_7].high)
{
VAR_9 = delete_node(VAR_1, VAR_7);
VAR_7 = VAR_11;
continue;
}
}
else if (VAR_2 <= VAR_8[VAR_7].high && VAR_8[VAR_7].high <= VAR_3)
{
VAR_8[VAR_7].high = VAR_2 - 1;
assert(VAR_8[VAR_7].low <= VAR_8[VAR_7].high);
}
else if (VAR_8[VAR_7].low < VAR_2 && VAR_3 < VAR_8[VAR_7].high)
{
int VAR_13 = VAR_8[VAR_7].high;
VAR_8[VAR_7].high = VAR_2-1;
add_range(VAR_0, VAR_1, VAR_3+1, VAR_13, VAR_8[VAR_7].out + VAR_3 + 1 - VAR_8[VAR_7].low, 0, VAR_8[VAR_7].many);
}
if (VAR_8[VAR_7].low > VAR_3) {
VAR_9 = VAR_8[VAR_7].left;
VAR_10 = VAR_7;
}
else
{
VAR_9 = VAR_8[VAR_7].right;
VAR_12 = VAR_7;
}
}
while (VAR_9 != VAR_11);
}
else
{
do
{
VAR_7 = VAR_9;
if (VAR_8[VAR_7].low > VAR_3)
{
VAR_9 = VAR_8[VAR_7].left;
VAR_10 = VAR_7;
}
else
{
VAR_9 = VAR_8[VAR_7].right;
VAR_12 = VAR_7;
}
} while (VAR_9 != VAR_11);
}
if (!VAR_6)
{
if (VAR_12 != VAR_11 && !VAR_8[VAR_12].many && VAR_8[VAR_12].high == VAR_2-1 && VAR_8[VAR_12].out - VAR_8[VAR_12].low == VAR_4 - VAR_2)
{
VAR_8[VAR_12].high = VAR_3;
if (VAR_10 != VAR_11 && !VAR_8[VAR_10].many && VAR_8[VAR_10].low == VAR_3+1 && VAR_8[VAR_10].out - VAR_8[VAR_10].low == VAR_4 - VAR_2)
{
VAR_8[VAR_12].high = VAR_8[VAR_10].high;
delete_node(VAR_1, VAR_10);
}
goto exit;
}
if (VAR_10 != VAR_11 && !VAR_8[VAR_10].many && VAR_8[VAR_10].low == VAR_3+1 && VAR_8[VAR_10].out - VAR_8[VAR_10].low == VAR_4 - VAR_2)
{
VAR_8[VAR_10].low = VAR_2;
VAR_8[VAR_10].out = VAR_4;
goto exit;
}
}
}
else
VAR_7 = VAR_11;
if (VAR_1->tlen == VAR_1->tcap)
{
int VAR_14 = VAR_1->tcap ? VAR_1->tcap * 2 : 256;
VAR_8 = VAR_1->tree = fz_resize_array(VAR_0, VAR_1->tree, VAR_14, sizeof *VAR_1->tree);
VAR_1->tcap = VAR_14;
}
VAR_8[VAR_1->tlen].low = VAR_2;
VAR_8[VAR_1->tlen].high = VAR_3;
VAR_8[VAR_1->tlen].out = VAR_4;
VAR_8[VAR_1->tlen].parent = VAR_7;
VAR_8[VAR_1->tlen].left = VAR_11;
VAR_8[VAR_1->tlen].right = VAR_11;
VAR_8[VAR_1->tlen].many = VAR_6;
VAR_1->tlen++;
if (VAR_7 == VAR_11)
VAR_1->ttop = 0;
else if (VAR_8[VAR_7].low > VAR_3)
VAR_8[VAR_7].left = VAR_1->tlen-1;
else
{
assert(VAR_8[VAR_7].high < VAR_2);
VAR_8[VAR_7].right = VAR_1->tlen-1;
}
move_to_root(VAR_8, VAR_1->tlen-1);
VAR_1->ttop = VAR_1->tlen-1;
exit:
{}
#ifdef VAR_15
check_splay(VAR_1->tree, VAR_1->ttop, 0);
#endif
#ifdef VAR_16
dump_splay(VAR_1->tree, VAR_1->ttop, 0, """");
#endif
}",ArtifexSoftware/mupdf/f597300439e62f5e921f0d7b1e880b5c1a1f1607/pdf-cmap.c/vul/before/0.json,"static void
add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)
{
	int current;
	cmap_splay *tree;

	if (low > high)
	{
		fz_warn(ctx, ""range limits out of range in cmap %s"", cmap->cmap_name);
		return;
	}

	tree = cmap->tree;

	if (cmap->tlen)
	{
		unsigned int move = cmap->ttop;
		unsigned int gt = EMPTY;
		unsigned int lt = EMPTY;
		if (check_for_overlap)
		{
			/* Check for collision with the current node */
			do
			{
				current = move;
				/* Cases we might meet:
				 * tree[i]:        <----->
				 * case 0:     <->
				 * case 1:     <------->
				 * case 2:     <------------->
				 * case 3:           <->
				 * case 4:           <------->
				 * case 5:                 <->
				 */
				if (low <= tree[current].low && tree[current].low <= high)
				{
					/* case 1, reduces to case 0 */
					/* or case 2, deleting the node */
					tree[current].out += high + 1 - tree[current].low;
					tree[current].low = high + 1;
					if (tree[current].low > tree[current].high)
					{
						move = delete_node(cmap, current);
						current = EMPTY;
						continue;
					}
				}
				else if (low <= tree[current].high && tree[current].high <= high)
				{
					/* case 4, reduces to case 5 */
					tree[current].high = low - 1;
					assert(tree[current].low <= tree[current].high);
				}
				else if (tree[current].low < low && high < tree[current].high)
				{
					/* case 3, reduces to case 5 */
					int new_high = tree[current].high;
					tree[current].high = low-1;
					add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
					tree = cmap->tree;
				}
				/* Now look for where to move to next (left for case 0, right for case 5) */
				if (tree[current].low > high) {
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			}
			while (move != EMPTY);
		}
		else
		{
			do
			{
				current = move;
				if (tree[current].low > high)
				{
					move = tree[current].left;
					gt = current;
				}
				else
				{
					move = tree[current].right;
					lt = current;
				}
			} while (move != EMPTY);
		}
		/* current is now the node to which we would be adding the new node */
		/* lt is the last node we traversed which is lt the new node. */
		/* gt is the last node we traversed which is gt the new node. */

		if (!many)
		{
			/* Check for the 'merge' cases. */
			if (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)
			{
				tree[lt].high = high;
				if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
				{
					tree[lt].high = tree[gt].high;
					delete_node(cmap, gt);
				}
				goto exit;
			}
			if (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)
			{
				tree[gt].low = low;
				tree[gt].out = out;
				goto exit;
			}
		}
	}
	else
		current = EMPTY;

	if (cmap->tlen == cmap->tcap)
	{
		int new_cap = cmap->tcap ? cmap->tcap * 2 : 256;
		tree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);
		cmap->tcap = new_cap;
	}
	tree[cmap->tlen].low = low;
	tree[cmap->tlen].high = high;
	tree[cmap->tlen].out = out;
	tree[cmap->tlen].parent = current;
	tree[cmap->tlen].left = EMPTY;
	tree[cmap->tlen].right = EMPTY;
	tree[cmap->tlen].many = many;
	cmap->tlen++;
	if (current == EMPTY)
		cmap->ttop = 0;
	else if (tree[current].low > high)
		tree[current].left = cmap->tlen-1;
	else
	{
		assert(tree[current].high < low);
		tree[current].right = cmap->tlen-1;
	}
	move_to_root(tree, cmap->tlen-1);
	cmap->ttop = cmap->tlen-1;
exit:
	{}
#ifdef CHECK_SPLAY
	check_splay(cmap->tree, cmap->ttop, 0);
#endif
#ifdef DUMP_SPLAY
	dump_splay(cmap->tree, cmap->ttop, 0, """");
#endif
}","static void
add_range(fz_context *VAR_0, pdf_cmap *VAR_1, unsigned int VAR_2, unsigned int VAR_3, unsigned int VAR_4, int VAR_5, int VAR_6)
{
	int VAR_7;
	cmap_splay *VAR_8;

	if (VAR_2 > VAR_3)
	{
		fz_warn(VAR_0, ""range limits out of range in cmap %s"", VAR_1->cmap_name);
		return;
	}

	VAR_8 = VAR_1->tree;

	if (VAR_1->tlen)
	{
		unsigned int VAR_9 = VAR_1->ttop;
		unsigned int VAR_10 = VAR_11;
		unsigned int VAR_12 = VAR_11;
		if (VAR_5)
		{
			/* COMMENT_0 */
			do
			{
				VAR_7 = VAR_9;
				/* COMMENT_1 */
                              
                      
                            
                                  
                            
                                  
                                  
       
				if (VAR_2 <= VAR_8[VAR_7].low && VAR_8[VAR_7].low <= VAR_3)
				{
					/* COMMENT_10 */
					/* COMMENT_11 */
					VAR_8[VAR_7].out += VAR_3 + 1 - VAR_8[VAR_7].low;
					VAR_8[VAR_7].low = VAR_3 + 1;
					if (VAR_8[VAR_7].low > VAR_8[VAR_7].high)
					{
						VAR_9 = delete_node(VAR_1, VAR_7);
						VAR_7 = VAR_11;
						continue;
					}
				}
				else if (VAR_2 <= VAR_8[VAR_7].high && VAR_8[VAR_7].high <= VAR_3)
				{
					/* COMMENT_12 */
					VAR_8[VAR_7].high = VAR_2 - 1;
					assert(VAR_8[VAR_7].low <= VAR_8[VAR_7].high);
				}
				else if (VAR_8[VAR_7].low < VAR_2 && VAR_3 < VAR_8[VAR_7].high)
				{
					/* COMMENT_13 */
					int VAR_13 = VAR_8[VAR_7].high;
					VAR_8[VAR_7].high = VAR_2-1;
					add_range(VAR_0, VAR_1, VAR_3+1, VAR_13, VAR_8[VAR_7].out + VAR_3 + 1 - VAR_8[VAR_7].low, 0, VAR_8[VAR_7].many);
					VAR_8 = VAR_1->tree;
				}
				/* COMMENT_14 */
				if (VAR_8[VAR_7].low > VAR_3) {
					VAR_9 = VAR_8[VAR_7].left;
					VAR_10 = VAR_7;
				}
				else
				{
					VAR_9 = VAR_8[VAR_7].right;
					VAR_12 = VAR_7;
				}
			}
			while (VAR_9 != VAR_11);
		}
		else
		{
			do
			{
				VAR_7 = VAR_9;
				if (VAR_8[VAR_7].low > VAR_3)
				{
					VAR_9 = VAR_8[VAR_7].left;
					VAR_10 = VAR_7;
				}
				else
				{
					VAR_9 = VAR_8[VAR_7].right;
					VAR_12 = VAR_7;
				}
			} while (VAR_9 != VAR_11);
		}
		/* COMMENT_15 */
		/* COMMENT_16 */
		/* COMMENT_17 */

		if (!VAR_6)
		{
			/* COMMENT_18 */
			if (VAR_12 != VAR_11 && !VAR_8[VAR_12].many && VAR_8[VAR_12].high == VAR_2-1 && VAR_8[VAR_12].out - VAR_8[VAR_12].low == VAR_4 - VAR_2)
			{
				VAR_8[VAR_12].high = VAR_3;
				if (VAR_10 != VAR_11 && !VAR_8[VAR_10].many && VAR_8[VAR_10].low == VAR_3+1 && VAR_8[VAR_10].out - VAR_8[VAR_10].low == VAR_4 - VAR_2)
				{
					VAR_8[VAR_12].high = VAR_8[VAR_10].high;
					delete_node(VAR_1, VAR_10);
				}
				goto exit;
			}
			if (VAR_10 != VAR_11 && !VAR_8[VAR_10].many && VAR_8[VAR_10].low == VAR_3+1 && VAR_8[VAR_10].out - VAR_8[VAR_10].low == VAR_4 - VAR_2)
			{
				VAR_8[VAR_10].low = VAR_2;
				VAR_8[VAR_10].out = VAR_4;
				goto exit;
			}
		}
	}
	else
		VAR_7 = VAR_11;

	if (VAR_1->tlen == VAR_1->tcap)
	{
		int VAR_14 = VAR_1->tcap ? VAR_1->tcap * 2 : 256;
		VAR_8 = VAR_1->tree = fz_resize_array(VAR_0, VAR_1->tree, VAR_14, sizeof *VAR_1->tree);
		VAR_1->tcap = VAR_14;
	}
	VAR_8[VAR_1->tlen].low = VAR_2;
	VAR_8[VAR_1->tlen].high = VAR_3;
	VAR_8[VAR_1->tlen].out = VAR_4;
	VAR_8[VAR_1->tlen].parent = VAR_7;
	VAR_8[VAR_1->tlen].left = VAR_11;
	VAR_8[VAR_1->tlen].right = VAR_11;
	VAR_8[VAR_1->tlen].many = VAR_6;
	VAR_1->tlen++;
	if (VAR_7 == VAR_11)
		VAR_1->ttop = 0;
	else if (VAR_8[VAR_7].low > VAR_3)
		VAR_8[VAR_7].left = VAR_1->tlen-1;
	else
	{
		assert(VAR_8[VAR_7].high < VAR_2);
		VAR_8[VAR_7].right = VAR_1->tlen-1;
	}
	move_to_root(VAR_8, VAR_1->tlen-1);
	VAR_1->ttop = VAR_1->tlen-1;
exit:
	{}
#ifdef VAR_15
	check_splay(VAR_1->tree, VAR_1->ttop, 0);
#endif
#ifdef VAR_16
	dump_splay(VAR_1->tree, VAR_1->ttop, 0, """");
#endif
}",ArtifexSoftware/mupdf/f597300439e62f5e921f0d7b1e880b5c1a1f1607/pdf-cmap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -57,6 +57,7 @@
 					int new_high = tree[current].high;
 					tree[current].high = low-1;
 					add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, tree[current].many);
+					tree = cmap->tree;
 				}
 				/* Now look for where to move to next (left for case 0, right for case 5) */
 				if (tree[current].low > high) {","{'deleted_lines': [], 'added_lines': ['\t\t\t\t\ttree = cmap->tree;']}",True,"In MuPDF 1.12.0 and earlier, a stack buffer overflow in function pdf_lookup_cmap_full in pdf/pdf-cmap.c could allow an attacker to execute arbitrary code via a crafted file.",7.8,HIGH,2,test,2018-01-23T22:02:16Z,2
CVE-2018-6192,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ArtifexSoftware/mupdf,Bug 698916: Indirect object numbers must be in range.,5e411a99604ff6be5db9e273ee84737204113299,https://github.com/ArtifexSoftware/mupdf/commit/5e411a99604ff6be5db9e273ee84737204113299,source/pdf/pdf-parse.c,pdf_parse_ind_obj,"pdf_obj *
pdf_parse_ind_obj(fz_context *ctx, pdf_document *doc,
fz_stream *file, pdf_lexbuf *buf,
int *onum, int *ogen, int64_t *ostmofs, int *try_repair)
{
pdf_obj *obj = NULL;
int num = 0, gen = 0;
int64_t stm_ofs;
pdf_token tok;
int64_t a, b;
int read_next_token = 1;
fz_var(obj);
tok = pdf_lex(ctx, file, buf);
if (tok != PDF_TOK_INT)
{
if (try_repair)
*try_repair = 1;
fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected object number"");
}
num = buf->i;
tok = pdf_lex(ctx, file, buf);
if (tok != PDF_TOK_INT)
{
if (try_repair)
*try_repair = 1;
fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected generation number (%d ? obj)"", num);
}
gen = buf->i;
tok = pdf_lex(ctx, file, buf);
if (tok != PDF_TOK_OBJ)
{
if (try_repair)
*try_repair = 1;
fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected 'obj' keyword (%d %d ?)"", num, gen);
}
tok = pdf_lex(ctx, file, buf);
switch (tok)
{
case PDF_TOK_OPEN_ARRAY:
obj = pdf_parse_array(ctx, doc, file, buf);
break;
case PDF_TOK_OPEN_DICT:
obj = pdf_parse_dict(ctx, doc, file, buf);
break;
case PDF_TOK_NAME: obj = pdf_new_name(ctx, doc, buf->scratch); break;
case PDF_TOK_REAL: obj = pdf_new_real(ctx, doc, buf->f); break;
case PDF_TOK_STRING: obj = pdf_new_string(ctx, doc, buf->scratch, buf->len); break;
case PDF_TOK_TRUE: obj = pdf_new_bool(ctx, doc, 1); break;
case PDF_TOK_FALSE: obj = pdf_new_bool(ctx, doc, 0); break;
case PDF_TOK_NULL: obj = pdf_new_null(ctx, doc); break;
case PDF_TOK_INT:
a = buf->i;
tok = pdf_lex(ctx, file, buf);
if (tok == PDF_TOK_STREAM || tok == PDF_TOK_ENDOBJ)
{
obj = pdf_new_int(ctx, doc, a);
read_next_token = 0;
break;
}
else if (tok == PDF_TOK_INT)
{
b = buf->i;
tok = pdf_lex(ctx, file, buf);
if (tok == PDF_TOK_R)
{
obj = pdf_new_indirect(ctx, doc, a, b);
break;
}
}
fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected 'R' keyword (%d %d R)"", num, gen);
case PDF_TOK_ENDOBJ:
obj = pdf_new_null(ctx, doc);
read_next_token = 0;
break;
default:
fz_throw(ctx, FZ_ERROR_SYNTAX, ""syntax error in object (%d %d R)"", num, gen);
}
fz_try(ctx)
{
if (read_next_token)
tok = pdf_lex(ctx, file, buf);
if (tok == PDF_TOK_STREAM)
{
int c = fz_read_byte(ctx, file);
while (c == ' ')
c = fz_read_byte(ctx, file);
if (c == '\r')
{
c = fz_peek_byte(ctx, file);
if (c != '\n')
fz_warn(ctx, ""line feed missing after stream begin marker (%d %d R)"", num, gen);
else
fz_read_byte(ctx, file);
}
stm_ofs = fz_tell(ctx, file);
}
else if (tok == PDF_TOK_ENDOBJ)
{
stm_ofs = 0;
}
else
{
fz_warn(ctx, ""expected 'endobj' or 'stream' keyword (%d %d R)"", num, gen);
stm_ofs = 0;
}
}
fz_catch(ctx)
{
pdf_drop_obj(ctx, obj);
fz_rethrow(ctx);
}
if (onum) *onum = num;
if (ogen) *ogen = gen;
if (ostmofs) *ostmofs = stm_ofs;
return obj;
}","pdf_obj *
pdf_parse_ind_obj(fz_context *VAR_0, pdf_document *VAR_1,
fz_stream *VAR_2, pdf_lexbuf *VAR_3,
int *VAR_4, int *VAR_5, int64_t *VAR_6, int *VAR_7)
{
pdf_obj *VAR_8 = NULL;
int VAR_9 = 0, VAR_10 = 0;
int64_t VAR_11;
pdf_token VAR_12;
int64_t VAR_13, VAR_14;
int VAR_15 = 1;
fz_var(VAR_8);
VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
if (VAR_12 != VAR_16)
{
if (VAR_7)
*VAR_7 = 1;
fz_throw(VAR_0, VAR_17, ""expected object number"");
}
VAR_9 = VAR_3->i;
VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
if (VAR_12 != VAR_16)
{
if (VAR_7)
*VAR_7 = 1;
fz_throw(VAR_0, VAR_17, ""expected generation number (%d ? obj)"", VAR_9);
}
VAR_10 = VAR_3->i;
VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
if (VAR_12 != VAR_18)
{
if (VAR_7)
*VAR_7 = 1;
fz_throw(VAR_0, VAR_17, ""expected 'obj' keyword (%d %d ?)"", VAR_9, VAR_10);
}
VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
switch (VAR_12)
{
case VAR_19:
VAR_8 = pdf_parse_array(VAR_0, VAR_1, VAR_2, VAR_3);
break;
case VAR_20:
VAR_8 = pdf_parse_dict(VAR_0, VAR_1, VAR_2, VAR_3);
break;
case VAR_21: VAR_8 = pdf_new_name(VAR_0, VAR_1, VAR_3->scratch); break;
case VAR_22: VAR_8 = pdf_new_real(VAR_0, VAR_1, VAR_3->f); break;
case VAR_23: VAR_8 = pdf_new_string(VAR_0, VAR_1, VAR_3->scratch, VAR_3->len); break;
case VAR_24: VAR_8 = pdf_new_bool(VAR_0, VAR_1, 1); break;
case VAR_25: VAR_8 = pdf_new_bool(VAR_0, VAR_1, 0); break;
case VAR_26: VAR_8 = pdf_new_null(VAR_0, VAR_1); break;
case VAR_16:
VAR_13 = VAR_3->i;
VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
if (VAR_12 == VAR_27 || VAR_12 == VAR_28)
{
VAR_8 = pdf_new_int(VAR_0, VAR_1, VAR_13);
VAR_15 = 0;
break;
}
else if (VAR_12 == VAR_16)
{
VAR_14 = VAR_3->i;
VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
if (VAR_12 == VAR_29)
{
VAR_8 = pdf_new_indirect(VAR_0, VAR_1, VAR_13, VAR_14);
break;
}
}
fz_throw(VAR_0, VAR_17, ""expected 'R' keyword (%d %d R)"", VAR_9, VAR_10);
case VAR_28:
VAR_8 = pdf_new_null(VAR_0, VAR_1);
VAR_15 = 0;
break;
default:
fz_throw(VAR_0, VAR_17, ""syntax error in object (%d %d R)"", VAR_9, VAR_10);
}
fz_try(VAR_0)
{
if (VAR_15)
VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
if (VAR_12 == VAR_27)
{
int VAR_30 = fz_read_byte(VAR_0, VAR_2);
while (VAR_30 == ' ')
VAR_30 = fz_read_byte(VAR_0, VAR_2);
if (VAR_30 == '\r')
{
VAR_30 = fz_peek_byte(VAR_0, VAR_2);
if (VAR_30 != '\n')
fz_warn(VAR_0, ""line feed missing after stream begin marker (%d %d R)"", VAR_9, VAR_10);
else
fz_read_byte(VAR_0, VAR_2);
}
VAR_11 = fz_tell(VAR_0, VAR_2);
}
else if (VAR_12 == VAR_28)
{
VAR_11 = 0;
}
else
{
fz_warn(VAR_0, ""expected 'endobj' or 'stream' keyword (%d %d R)"", VAR_9, VAR_10);
VAR_11 = 0;
}
}
fz_catch(VAR_0)
{
pdf_drop_obj(VAR_0, VAR_8);
fz_rethrow(VAR_0);
}
if (VAR_4) *VAR_4 = VAR_9;
if (VAR_5) *VAR_5 = VAR_10;
if (VAR_6) *VAR_6 = VAR_11;
return VAR_8;
}",ArtifexSoftware/mupdf/5e411a99604ff6be5db9e273ee84737204113299/pdf-parse.c/vul/before/0.json,"pdf_obj *
pdf_parse_ind_obj(fz_context *ctx, pdf_document *doc,
	fz_stream *file, pdf_lexbuf *buf,
	int *onum, int *ogen, int64_t *ostmofs, int *try_repair)
{
	pdf_obj *obj = NULL;
	int num = 0, gen = 0;
	int64_t stm_ofs;
	pdf_token tok;
	int64_t a, b;
	int read_next_token = 1;

	fz_var(obj);

	tok = pdf_lex(ctx, file, buf);
	if (tok != PDF_TOK_INT)
	{
		if (try_repair)
			*try_repair = 1;
		fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected object number"");
	}
	num = buf->i;
	if (num < 0 || num > PDF_MAX_OBJECT_NUMBER)
		fz_throw(ctx, FZ_ERROR_SYNTAX, ""object number out of range"");

	tok = pdf_lex(ctx, file, buf);
	if (tok != PDF_TOK_INT)
	{
		if (try_repair)
			*try_repair = 1;
		fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected generation number (%d ? obj)"", num);
	}
	gen = buf->i;

	tok = pdf_lex(ctx, file, buf);
	if (tok != PDF_TOK_OBJ)
	{
		if (try_repair)
			*try_repair = 1;
		fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected 'obj' keyword (%d %d ?)"", num, gen);
	}

	tok = pdf_lex(ctx, file, buf);

	switch (tok)
	{
	case PDF_TOK_OPEN_ARRAY:
		obj = pdf_parse_array(ctx, doc, file, buf);
		break;

	case PDF_TOK_OPEN_DICT:
		obj = pdf_parse_dict(ctx, doc, file, buf);
		break;

	case PDF_TOK_NAME: obj = pdf_new_name(ctx, doc, buf->scratch); break;
	case PDF_TOK_REAL: obj = pdf_new_real(ctx, doc, buf->f); break;
	case PDF_TOK_STRING: obj = pdf_new_string(ctx, doc, buf->scratch, buf->len); break;
	case PDF_TOK_TRUE: obj = pdf_new_bool(ctx, doc, 1); break;
	case PDF_TOK_FALSE: obj = pdf_new_bool(ctx, doc, 0); break;
	case PDF_TOK_NULL: obj = pdf_new_null(ctx, doc); break;

	case PDF_TOK_INT:
		a = buf->i;
		tok = pdf_lex(ctx, file, buf);

		if (tok == PDF_TOK_STREAM || tok == PDF_TOK_ENDOBJ)
		{
			obj = pdf_new_int(ctx, doc, a);
			read_next_token = 0;
			break;
		}
		else if (tok == PDF_TOK_INT)
		{
			b = buf->i;
			tok = pdf_lex(ctx, file, buf);
			if (tok == PDF_TOK_R)
			{
				obj = pdf_new_indirect(ctx, doc, a, b);
				break;
			}
		}
		fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected 'R' keyword (%d %d R)"", num, gen);

	case PDF_TOK_ENDOBJ:
		obj = pdf_new_null(ctx, doc);
		read_next_token = 0;
		break;

	default:
		fz_throw(ctx, FZ_ERROR_SYNTAX, ""syntax error in object (%d %d R)"", num, gen);
	}

	fz_try(ctx)
	{
		if (read_next_token)
			tok = pdf_lex(ctx, file, buf);

		if (tok == PDF_TOK_STREAM)
		{
			int c = fz_read_byte(ctx, file);
			while (c == ' ')
				c = fz_read_byte(ctx, file);
			if (c == '\r')
			{
				c = fz_peek_byte(ctx, file);
				if (c != '\n')
					fz_warn(ctx, ""line feed missing after stream begin marker (%d %d R)"", num, gen);
				else
					fz_read_byte(ctx, file);
			}
			stm_ofs = fz_tell(ctx, file);
		}
		else if (tok == PDF_TOK_ENDOBJ)
		{
			stm_ofs = 0;
		}
		else
		{
			fz_warn(ctx, ""expected 'endobj' or 'stream' keyword (%d %d R)"", num, gen);
			stm_ofs = 0;
		}
	}
	fz_catch(ctx)
	{
		pdf_drop_obj(ctx, obj);
		fz_rethrow(ctx);
	}

	if (onum) *onum = num;
	if (ogen) *ogen = gen;
	if (ostmofs) *ostmofs = stm_ofs;

	return obj;
}","pdf_obj *
pdf_parse_ind_obj(fz_context *VAR_0, pdf_document *VAR_1,
	fz_stream *VAR_2, pdf_lexbuf *VAR_3,
	int *VAR_4, int *VAR_5, int64_t *VAR_6, int *VAR_7)
{
	pdf_obj *VAR_8 = NULL;
	int VAR_9 = 0, VAR_10 = 0;
	int64_t VAR_11;
	pdf_token VAR_12;
	int64_t VAR_13, VAR_14;
	int VAR_15 = 1;

	fz_var(VAR_8);

	VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
	if (VAR_12 != VAR_16)
	{
		if (VAR_7)
			*VAR_7 = 1;
		fz_throw(VAR_0, VAR_17, ""expected object number"");
	}
	VAR_9 = VAR_3->i;
	if (VAR_9 < 0 || VAR_9 > VAR_18)
		fz_throw(VAR_0, VAR_17, ""object number out of range"");

	VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
	if (VAR_12 != VAR_16)
	{
		if (VAR_7)
			*VAR_7 = 1;
		fz_throw(VAR_0, VAR_17, ""expected generation number (%d ? obj)"", VAR_9);
	}
	VAR_10 = VAR_3->i;

	VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
	if (VAR_12 != VAR_19)
	{
		if (VAR_7)
			*VAR_7 = 1;
		fz_throw(VAR_0, VAR_17, ""expected 'obj' keyword (%d %d ?)"", VAR_9, VAR_10);
	}

	VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);

	switch (VAR_12)
	{
	case VAR_20:
		VAR_8 = pdf_parse_array(VAR_0, VAR_1, VAR_2, VAR_3);
		break;

	case VAR_21:
		VAR_8 = pdf_parse_dict(VAR_0, VAR_1, VAR_2, VAR_3);
		break;

	case VAR_22: VAR_8 = pdf_new_name(VAR_0, VAR_1, VAR_3->scratch); break;
	case VAR_23: VAR_8 = pdf_new_real(VAR_0, VAR_1, VAR_3->f); break;
	case VAR_24: VAR_8 = pdf_new_string(VAR_0, VAR_1, VAR_3->scratch, VAR_3->len); break;
	case VAR_25: VAR_8 = pdf_new_bool(VAR_0, VAR_1, 1); break;
	case VAR_26: VAR_8 = pdf_new_bool(VAR_0, VAR_1, 0); break;
	case VAR_27: VAR_8 = pdf_new_null(VAR_0, VAR_1); break;

	case VAR_16:
		VAR_13 = VAR_3->i;
		VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);

		if (VAR_12 == VAR_28 || VAR_12 == VAR_29)
		{
			VAR_8 = pdf_new_int(VAR_0, VAR_1, VAR_13);
			VAR_15 = 0;
			break;
		}
		else if (VAR_12 == VAR_16)
		{
			VAR_14 = VAR_3->i;
			VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);
			if (VAR_12 == VAR_30)
			{
				VAR_8 = pdf_new_indirect(VAR_0, VAR_1, VAR_13, VAR_14);
				break;
			}
		}
		fz_throw(VAR_0, VAR_17, ""expected 'R' keyword (%d %d R)"", VAR_9, VAR_10);

	case VAR_29:
		VAR_8 = pdf_new_null(VAR_0, VAR_1);
		VAR_15 = 0;
		break;

	default:
		fz_throw(VAR_0, VAR_17, ""syntax error in object (%d %d R)"", VAR_9, VAR_10);
	}

	fz_try(VAR_0)
	{
		if (VAR_15)
			VAR_12 = pdf_lex(VAR_0, VAR_2, VAR_3);

		if (VAR_12 == VAR_28)
		{
			int VAR_31 = fz_read_byte(VAR_0, VAR_2);
			while (VAR_31 == ' ')
				VAR_31 = fz_read_byte(VAR_0, VAR_2);
			if (VAR_31 == '\r')
			{
				VAR_31 = fz_peek_byte(VAR_0, VAR_2);
				if (VAR_31 != '\n')
					fz_warn(VAR_0, ""line feed missing after stream begin marker (%d %d R)"", VAR_9, VAR_10);
				else
					fz_read_byte(VAR_0, VAR_2);
			}
			VAR_11 = fz_tell(VAR_0, VAR_2);
		}
		else if (VAR_12 == VAR_29)
		{
			VAR_11 = 0;
		}
		else
		{
			fz_warn(VAR_0, ""expected 'endobj' or 'stream' keyword (%d %d R)"", VAR_9, VAR_10);
			VAR_11 = 0;
		}
	}
	fz_catch(VAR_0)
	{
		pdf_drop_obj(VAR_0, VAR_8);
		fz_rethrow(VAR_0);
	}

	if (VAR_4) *VAR_4 = VAR_9;
	if (VAR_5) *VAR_5 = VAR_10;
	if (VAR_6) *VAR_6 = VAR_11;

	return VAR_8;
}",ArtifexSoftware/mupdf/5e411a99604ff6be5db9e273ee84737204113299/pdf-parse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,6 +20,8 @@
 		fz_throw(ctx, FZ_ERROR_SYNTAX, ""expected object number"");
 	}
 	num = buf->i;
+	if (num < 0 || num > PDF_MAX_OBJECT_NUMBER)
+		fz_throw(ctx, FZ_ERROR_SYNTAX, ""object number out of range"");
 
 	tok = pdf_lex(ctx, file, buf);
 	if (tok != PDF_TOK_INT)","{'deleted_lines': [], 'added_lines': ['\tif (num < 0 || num > PDF_MAX_OBJECT_NUMBER)', '\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, ""object number out of range"");']}",True,"In Artifex MuPDF 1.12.0, the pdf_read_new_xref function in pdf/pdf-xref.c allows remote attackers to cause a denial of service (segmentation violation and application crash) via a crafted pdf file.",5.5,MEDIUM,1,test,2018-01-30T01:05:57Z,2
CVE-2018-6192,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ArtifexSoftware/mupdf,Bug 698916: Indirect object numbers must be in range.,5e411a99604ff6be5db9e273ee84737204113299,https://github.com/ArtifexSoftware/mupdf/commit/5e411a99604ff6be5db9e273ee84737204113299,source/pdf/pdf-xref.c,pdf_get_populating_xref_entry,"pdf_xref_entry *pdf_get_populating_xref_entry(fz_context *ctx, pdf_document *doc, int num)
{
pdf_xref *xref;
pdf_xref_subsec *sub;
if (doc->num_xref_sections == 0)
{
doc->xref_sections = fz_malloc_struct(ctx, pdf_xref);
doc->num_xref_sections = 1;
}
if (num < 0)
fz_throw(ctx, FZ_ERROR_GENERIC, ""object number must not be negative (%d)"", num);
xref = &doc->xref_sections[doc->num_xref_sections-1];
for (sub = xref->subsec; sub != NULL; sub = sub->next)
{
if (num >= sub->start && num < sub->start + sub->len)
return &sub->table[num-sub->start];
}
ensure_solid_xref(ctx, doc, num+1, doc->num_xref_sections-1);
xref = &doc->xref_sections[doc->num_xref_sections-1];
sub = xref->subsec;
return &sub->table[num-sub->start];
}","pdf_xref_entry *pdf_get_populating_xref_entry(fz_context *VAR_0, pdf_document *VAR_1, int VAR_2)
{
pdf_xref *VAR_3;
pdf_xref_subsec *VAR_4;
if (VAR_1->num_xref_sections == 0)
{
VAR_1->xref_sections = fz_malloc_struct(VAR_0, pdf_xref);
VAR_1->num_xref_sections = 1;
}
if (VAR_2 < 0)
fz_throw(VAR_0, VAR_5, ""object number must not be negative (%d)"", VAR_2);
VAR_3 = &VAR_1->xref_sections[VAR_1->num_xref_sections-1];
for (VAR_4 = VAR_3->subsec; VAR_4 != NULL; VAR_4 = VAR_4->next)
{
if (VAR_2 >= VAR_4->start && VAR_2 < VAR_4->start + VAR_4->len)
return &VAR_4->table[VAR_2-VAR_4->start];
}
ensure_solid_xref(VAR_0, VAR_1, VAR_2+1, VAR_1->num_xref_sections-1);
VAR_3 = &VAR_1->xref_sections[VAR_1->num_xref_sections-1];
VAR_4 = VAR_3->subsec;
return &VAR_4->table[VAR_2-VAR_4->start];
}",ArtifexSoftware/mupdf/5e411a99604ff6be5db9e273ee84737204113299/pdf-xref.c/vul/before/0.json,"pdf_xref_entry *pdf_get_populating_xref_entry(fz_context *ctx, pdf_document *doc, int num)
{
	/* Return an entry within the xref currently being populated */
	pdf_xref *xref;
	pdf_xref_subsec *sub;

	if (doc->num_xref_sections == 0)
	{
		doc->xref_sections = fz_malloc_struct(ctx, pdf_xref);
		doc->num_xref_sections = 1;
	}

	/* Prevent accidental heap underflow */
	if (num < 0 || num > PDF_MAX_OBJECT_NUMBER)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""object number out of range (%d)"", num);

	/* Return the pointer to the entry in the last section. */
	xref = &doc->xref_sections[doc->num_xref_sections-1];

	for (sub = xref->subsec; sub != NULL; sub = sub->next)
	{
		if (num >= sub->start && num < sub->start + sub->len)
			return &sub->table[num-sub->start];
	}

	/* We've been asked for an object that's not in a subsec. */
	ensure_solid_xref(ctx, doc, num+1, doc->num_xref_sections-1);
	xref = &doc->xref_sections[doc->num_xref_sections-1];
	sub = xref->subsec;

	return &sub->table[num-sub->start];
}","pdf_xref_entry *pdf_get_populating_xref_entry(fz_context *VAR_0, pdf_document *VAR_1, int VAR_2)
{
	/* COMMENT_0 */
	pdf_xref *VAR_3;
	pdf_xref_subsec *VAR_4;

	if (VAR_1->num_xref_sections == 0)
	{
		VAR_1->xref_sections = fz_malloc_struct(VAR_0, pdf_xref);
		VAR_1->num_xref_sections = 1;
	}

	/* COMMENT_1 */
	if (VAR_2 < 0 || VAR_2 > VAR_5)
		fz_throw(VAR_0, VAR_6, ""object number out of range (%d)"", VAR_2);

	/* COMMENT_2 */
	VAR_3 = &VAR_1->xref_sections[VAR_1->num_xref_sections-1];

	for (VAR_4 = VAR_3->subsec; VAR_4 != NULL; VAR_4 = VAR_4->next)
	{
		if (VAR_2 >= VAR_4->start && VAR_2 < VAR_4->start + VAR_4->len)
			return &VAR_4->table[VAR_2-VAR_4->start];
	}

	/* COMMENT_3 */
	ensure_solid_xref(VAR_0, VAR_1, VAR_2+1, VAR_1->num_xref_sections-1);
	VAR_3 = &VAR_1->xref_sections[VAR_1->num_xref_sections-1];
	VAR_4 = VAR_3->subsec;

	return &VAR_4->table[VAR_2-VAR_4->start];
}",ArtifexSoftware/mupdf/5e411a99604ff6be5db9e273ee84737204113299/pdf-xref.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,8 +11,8 @@
 	}
 
 	/* Prevent accidental heap underflow */
-	if (num < 0)
-		fz_throw(ctx, FZ_ERROR_GENERIC, ""object number must not be negative (%d)"", num);
+	if (num < 0 || num > PDF_MAX_OBJECT_NUMBER)
+		fz_throw(ctx, FZ_ERROR_GENERIC, ""object number out of range (%d)"", num);
 
 	/* Return the pointer to the entry in the last section. */
 	xref = &doc->xref_sections[doc->num_xref_sections-1];","{'deleted_lines': ['\tif (num < 0)', '\t\tfz_throw(ctx, FZ_ERROR_GENERIC, ""object number must not be negative (%d)"", num);'], 'added_lines': ['\tif (num < 0 || num > PDF_MAX_OBJECT_NUMBER)', '\t\tfz_throw(ctx, FZ_ERROR_GENERIC, ""object number out of range (%d)"", num);']}",True,"In Artifex MuPDF 1.12.0, the pdf_read_new_xref function in pdf/pdf-xref.c allows remote attackers to cause a denial of service (segmentation violation and application crash) via a crafted pdf file.",5.5,MEDIUM,1,test,2018-01-30T01:05:57Z,2
CVE-2018-7325,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"RPKI-Router: Sanity check length field to prevent infinite loop

Bug: 14414
Change-Id: I39843e8959510a0efa1add51a16e207fc63f88b1
Reviewed-on: https://code.wireshark.org/review/25742
Reviewed-by: Michael Mann <mmann78@netscape.net>
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 5e8391ff900db18ccf8663918919b16085406874)
Reviewed-on: https://code.wireshark.org/review/25749",7be234d06ea39ab6a88115ae41d71060f1f15e3c,https://github.com/wireshark/wireshark/commit/7be234d06ea39ab6a88115ae41d71060f1f15e3c,epan/dissectors/packet-rpki-rtr.c,dissect_rpkirtr_pdu,"static int dissect_rpkirtr_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
proto_item *ti = NULL, *ti_flags, *ti_type;
proto_tree *rpkirtr_tree = NULL, *flags_tree = NULL;
int offset = 0;
guint8 pdu_type, version;
guint length;
while (tvb_reported_length_remaining(tvb, offset) != 0) {
ti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA);
rpkirtr_tree = proto_item_add_subtree(ti, ett_rpkirtr);
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_version, tvb, offset, 1, ENC_BIG_ENDIAN);
version = tvb_get_guint8(tvb, offset);
offset += 1;
ti_type = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);
pdu_type = tvb_get_guint8(tvb, offset);
col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, val_to_str(pdu_type, rtr_pdu_type_vals, ""Unknown (%d)""));
proto_item_append_text(ti, "" (%s)"", val_to_str(pdu_type, rtr_pdu_type_vals, ""Unknown %d""));
offset += 1;
length = tvb_get_ntohl(tvb, offset);
switch (pdu_type) {
case RPKI_RTR_SERIAL_NOTIFY_PDU: 
case RPKI_RTR_SERIAL_QUERY_PDU:  
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
break;
case RPKI_RTR_RESET_QUERY_PDU:  
case RPKI_RTR_CACHE_RESET_PDU:  
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
offset += 2;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
break;
case RPKI_RTR_CACHE_RESPONSE_PDU:  
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
break;
case RPKI_RTR_IPV4_PREFIX_PDU: 
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
offset += 2;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);
flags_tree = proto_item_add_subtree(ti_flags, ett_flags);
proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv4_prefix,      tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
break;
case RPKI_RTR_IPV6_PREFIX_PDU: 
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
offset += 2;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);
flags_tree = proto_item_add_subtree(ti_flags, ett_flags);
proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv6_prefix,      tvb, offset, 16, ENC_NA);
offset += 16;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
break;
case RPKI_RTR_END_OF_DATA_PDU: 
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
if (version >= 1){
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_refresh_interval, tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_retry_interval,   tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_expire_interval,  tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
}
break;
case RPKI_RTR_ROUTER_KEY: 
if(version < 1){
expert_add_info(pinfo, ti_type, &ei_rpkirtr_wrong_version_router_key);
} else {
asn1_ctx_t asn1_ctx;
ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);
flags_tree = proto_item_add_subtree(ti_flags, ett_flags_nd);
proto_tree_add_item(flags_tree, hf_rpkirtr_flags_rk,           tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
offset += 1;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_subject_key_identifier, tvb, offset, 20, ENC_NA);
offset += 20;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);
offset = dissect_x509af_SubjectPublicKeyInfo(FALSE, tvb, offset, &asn1_ctx, rpkirtr_tree, hf_rpkirtr_subject_public_key_info);
}
break;
case RPKI_RTR_ERROR_REPORT_PDU: 
{
guint32 len_pdu, len_text;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_code,       tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_pdu,       tvb, offset, 4, ENC_BIG_ENDIAN);
len_pdu =                                                      tvb_get_ntohl(tvb, offset);
offset += 4;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_pdu,        tvb, offset, len_pdu, ENC_NA);
offset +=  len_pdu;
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_text,      tvb, offset, 4, ENC_BIG_ENDIAN);
len_text =                                                     tvb_get_ntohl(tvb, offset);
offset += 4,
proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_text,   tvb, offset, len_text, ENC_ASCII|ENC_NA);
offset += len_text;
}
break;
default:
offset += length;
break;
}
}
return tvb_reported_length(tvb);
}","static int dissect_rpkirtr_pdu(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void* VAR_3 _U_)
{
proto_item *VAR_4 = NULL, *VAR_5, *VAR_6;
proto_tree *VAR_7 = NULL, *VAR_8 = NULL;
int VAR_9 = 0;
guint8 VAR_10, VAR_11;
guint VAR_12;
while (tvb_reported_length_remaining(VAR_0, VAR_9) != 0) {
VAR_4 = proto_tree_add_item(VAR_2, VAR_13, VAR_0, 0, -1, VAR_14);
VAR_7 = proto_item_add_subtree(VAR_4, VAR_15);
proto_tree_add_item(VAR_7, VAR_16, VAR_0, VAR_9, 1, VAR_17);
VAR_11 = tvb_get_guint8(VAR_0, VAR_9);
VAR_9 += 1;
VAR_6 = proto_tree_add_item(VAR_7, VAR_18, VAR_0, VAR_9, 1, VAR_17);
VAR_10 = tvb_get_guint8(VAR_0, VAR_9);
col_append_sep_str(VAR_1->cinfo, VAR_19, NULL, val_to_str(VAR_10, VAR_20, ""Unknown (%d)""));
proto_item_append_text(VAR_4, "" (%s)"", val_to_str(VAR_10, VAR_20, ""Unknown %d""));
VAR_9 += 1;
VAR_12 = tvb_get_ntohl(VAR_0, VAR_9);
switch (VAR_10) {
case VAR_21: 
case VAR_22:  
proto_tree_add_item(VAR_7, VAR_23,       VAR_0, VAR_9, 2, VAR_17);
VAR_9 += 2;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_25,    VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
break;
case VAR_26:  
case VAR_27:  
proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
VAR_9 += 2;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
break;
case VAR_29:  
proto_tree_add_item(VAR_7, VAR_23,       VAR_0, VAR_9, 2, VAR_17);
VAR_9 += 2;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
break;
case VAR_30: 
proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
VAR_9 += 2;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
VAR_5 = proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_9, 1, VAR_17);
VAR_8 = proto_item_add_subtree(VAR_5, VAR_32);
proto_tree_add_item(VAR_8, VAR_33,           VAR_0, VAR_9, 1, VAR_17);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_34,    VAR_0, VAR_9, 1, VAR_17);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_35,       VAR_0, VAR_9, 1, VAR_17);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 1, VAR_14);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_36,      VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_37,        VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
break;
case VAR_38: 
proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
VAR_9 += 2;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
VAR_5 = proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_9, 1, VAR_17);
VAR_8 = proto_item_add_subtree(VAR_5, VAR_32);
proto_tree_add_item(VAR_8, VAR_33,           VAR_0, VAR_9, 1, VAR_17);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_34,    VAR_0, VAR_9, 1, VAR_17);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_35,       VAR_0, VAR_9, 1, VAR_17);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 1, VAR_14);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_39,      VAR_0, VAR_9, 16, VAR_14);
VAR_9 += 16;
proto_tree_add_item(VAR_7, VAR_37,        VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
break;
case VAR_40: 
proto_tree_add_item(VAR_7, VAR_23,       VAR_0, VAR_9, 2, VAR_17);
VAR_9 += 2;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_25,    VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
if (VAR_11 >= 1){
proto_tree_add_item(VAR_7, VAR_41, VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_42,   VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_43,  VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
}
break;
case VAR_44: 
if(VAR_11 < 1){
expert_add_info(VAR_1, VAR_6, &VAR_45);
} else {
asn1_ctx_t VAR_46;
VAR_5 = proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_9, 1, VAR_17);
VAR_8 = proto_item_add_subtree(VAR_5, VAR_47);
proto_tree_add_item(VAR_8, VAR_48,           VAR_0, VAR_9, 1, VAR_17);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
VAR_9 += 1;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_49, VAR_0, VAR_9, 20, VAR_14);
VAR_9 += 20;
proto_tree_add_item(VAR_7, VAR_37, VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
asn1_ctx_init(&VAR_46, VAR_50, TRUE, VAR_1);
VAR_9 = dissect_x509af_SubjectPublicKeyInfo(FALSE, VAR_0, VAR_9, &VAR_46, VAR_7, VAR_51);
}
break;
case VAR_52: 
{
guint32 VAR_53, VAR_54;
proto_tree_add_item(VAR_7, VAR_55,       VAR_0, VAR_9, 2, VAR_17);
VAR_9 += 2;
proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_56,       VAR_0, VAR_9, 4, VAR_17);
VAR_53 =                                                      tvb_get_ntohl(VAR_0, VAR_9);
VAR_9 += 4;
proto_tree_add_item(VAR_7, VAR_57,        VAR_0, VAR_9, VAR_53, VAR_14);
VAR_9 +=  VAR_53;
proto_tree_add_item(VAR_7, VAR_58,      VAR_0, VAR_9, 4, VAR_17);
VAR_54 =                                                     tvb_get_ntohl(VAR_0, VAR_9);
VAR_9 += 4,
proto_tree_add_item(VAR_7, VAR_59,   VAR_0, VAR_9, VAR_54, VAR_60|VAR_14);
VAR_9 += VAR_54;
}
break;
default:
VAR_9 += VAR_12;
break;
}
}
return tvb_reported_length(VAR_0);
}",,"static int dissect_rpkirtr_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{

    proto_item *ti = NULL, *ti_flags, *ti_type;
    proto_tree *rpkirtr_tree = NULL, *flags_tree = NULL;
    int offset = 0;
    guint8 pdu_type, version;
    guint length;

    while (tvb_reported_length_remaining(tvb, offset) > 0) {

        ti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA);

        rpkirtr_tree = proto_item_add_subtree(ti, ett_rpkirtr);

        proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_version, tvb, offset, 1, ENC_BIG_ENDIAN);
        version = tvb_get_guint8(tvb, offset);
        offset += 1;

        ti_type = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);
        pdu_type = tvb_get_guint8(tvb, offset);
        col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, val_to_str(pdu_type, rtr_pdu_type_vals, ""Unknown (%d)""));
        proto_item_append_text(ti, "" (%s)"", val_to_str(pdu_type, rtr_pdu_type_vals, ""Unknown %d""));
        offset += 1;

        length = tvb_get_ntohl(tvb, offset);

        switch (pdu_type) {
            case RPKI_RTR_SERIAL_NOTIFY_PDU: /* Serial Notify (0) */
            case RPKI_RTR_SERIAL_QUERY_PDU:  /* Serial Query (1)  */
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);
                offset += 2;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                /* TODO: Add check length ? */
                offset += 4;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;
                break;
            case RPKI_RTR_RESET_QUERY_PDU:  /* Reset Query (2) */
            case RPKI_RTR_CACHE_RESET_PDU:  /* Cache Reset (8) */
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
                offset += 2;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                /* TODO: Add check length ? */
                offset += 4;
                break;
            case RPKI_RTR_CACHE_RESPONSE_PDU:  /* Cache Response (3) */
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);
                offset += 2;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                /* TODO: Add check length ? */
                offset += 4;
                break;
            case RPKI_RTR_IPV4_PREFIX_PDU: /* IPv4 Prefix (4) */
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
                offset += 2;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                /* TODO: Add check length ? */
                offset += 4;
                ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);
                flags_tree = proto_item_add_subtree(ti_flags, ett_flags);
                proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv4_prefix,      tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;
                break;
            case RPKI_RTR_IPV6_PREFIX_PDU: /* IPv6 Prefix (6) */
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
                offset += 2;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                /* TODO: Add check length ? */
                offset += 4;
                ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);
                flags_tree = proto_item_add_subtree(ti_flags, ett_flags);
                proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);
                offset += 1;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv6_prefix,      tvb, offset, 16, ENC_NA);
                offset += 16;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;
                break;
            case RPKI_RTR_END_OF_DATA_PDU: /* End Of Data (7) */
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);
                offset += 2;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                /* TODO: Add check length ? */
                offset += 4;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;

                if (version >= 1){
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_refresh_interval, tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;

                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_retry_interval,   tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;

                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_expire_interval,  tvb, offset, 4, ENC_BIG_ENDIAN);
                offset += 4;
                }
                break;

            case RPKI_RTR_ROUTER_KEY: /* Router Key (9) */
                if(version < 1){
                    /* Error about wrong version... */
                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_wrong_version_router_key);
                } else {
                    asn1_ctx_t asn1_ctx;

                    ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);
                    flags_tree = proto_item_add_subtree(ti_flags, ett_flags_nd);
                    proto_tree_add_item(flags_tree, hf_rpkirtr_flags_rk,           tvb, offset, 1, ENC_BIG_ENDIAN);
                    offset += 1;
                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);
                    offset += 1;
                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                    /* TODO: Add check length ? */
                    offset += 4;
                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_subject_key_identifier, tvb, offset, 20, ENC_NA);
                    offset += 20;

                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN);
                    offset += 4;
                    asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);
                    offset = dissect_x509af_SubjectPublicKeyInfo(FALSE, tvb, offset, &asn1_ctx, rpkirtr_tree, hf_rpkirtr_subject_public_key_info);

                }
                break;
            case RPKI_RTR_ERROR_REPORT_PDU: /* Error Report (10) */
            {
                guint32 len_pdu, len_text;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_code,       tvb, offset, 2, ENC_BIG_ENDIAN);
                offset += 2;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);
                /* TODO: Add check length ? */
                offset += 4;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_pdu,       tvb, offset, 4, ENC_BIG_ENDIAN);
                len_pdu =                                                      tvb_get_ntohl(tvb, offset);
                offset += 4;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_pdu,        tvb, offset, len_pdu, ENC_NA);
                offset +=  len_pdu;
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_text,      tvb, offset, 4, ENC_BIG_ENDIAN);
                len_text =                                                     tvb_get_ntohl(tvb, offset);
                offset += 4,
                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_text,   tvb, offset, len_text, ENC_ASCII|ENC_NA);
                offset += len_text;
            }
            break;
            default:
                /* No default ? At least sanity check the length*/
                if (length > tvb_reported_length(tvb)) {
                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_bad_length);
                    return tvb_reported_length(tvb);
                }

                offset += length;
                break;
        }
    }

    return tvb_reported_length(tvb);
}","static int dissect_rpkirtr_pdu(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void* VAR_3 _U_)
{

    proto_item *VAR_4 = NULL, *VAR_5, *VAR_6;
    proto_tree *VAR_7 = NULL, *VAR_8 = NULL;
    int VAR_9 = 0;
    guint8 VAR_10, VAR_11;
    guint VAR_12;

    while (tvb_reported_length_remaining(VAR_0, VAR_9) > 0) {

        VAR_4 = proto_tree_add_item(VAR_2, VAR_13, VAR_0, 0, -1, VAR_14);

        VAR_7 = proto_item_add_subtree(VAR_4, VAR_15);

        proto_tree_add_item(VAR_7, VAR_16, VAR_0, VAR_9, 1, VAR_17);
        VAR_11 = tvb_get_guint8(VAR_0, VAR_9);
        VAR_9 += 1;

        VAR_6 = proto_tree_add_item(VAR_7, VAR_18, VAR_0, VAR_9, 1, VAR_17);
        VAR_10 = tvb_get_guint8(VAR_0, VAR_9);
        col_append_sep_str(VAR_1->cinfo, VAR_19, NULL, val_to_str(VAR_10, VAR_20, ""Unknown (%d)""));
        proto_item_append_text(VAR_4, "" (%s)"", val_to_str(VAR_10, VAR_20, ""Unknown %d""));
        VAR_9 += 1;

        VAR_12 = tvb_get_ntohl(VAR_0, VAR_9);

        switch (VAR_10) {
            case VAR_21: /* COMMENT_0 */
            case VAR_22:  /* COMMENT_1 */
                proto_tree_add_item(VAR_7, VAR_23,       VAR_0, VAR_9, 2, VAR_17);
                VAR_9 += 2;
                proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                /* COMMENT_2 */
                VAR_9 += 4;
                proto_tree_add_item(VAR_7, VAR_25,    VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;
                break;
            case VAR_26:  /* COMMENT_3 */
            case VAR_27:  /* COMMENT_4 */
                proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
                VAR_9 += 2;
                proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                /* COMMENT_2 */
                VAR_9 += 4;
                break;
            case VAR_29:  /* COMMENT_5 */
                proto_tree_add_item(VAR_7, VAR_23,       VAR_0, VAR_9, 2, VAR_17);
                VAR_9 += 2;
                proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                /* COMMENT_2 */
                VAR_9 += 4;
                break;
            case VAR_30: /* COMMENT_6 */
                proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
                VAR_9 += 2;
                proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                /* COMMENT_2 */
                VAR_9 += 4;
                VAR_5 = proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_9, 1, VAR_17);
                VAR_8 = proto_item_add_subtree(VAR_5, VAR_32);
                proto_tree_add_item(VAR_8, VAR_33,           VAR_0, VAR_9, 1, VAR_17);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_34,    VAR_0, VAR_9, 1, VAR_17);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_35,       VAR_0, VAR_9, 1, VAR_17);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 1, VAR_14);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_36,      VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;
                proto_tree_add_item(VAR_7, VAR_37,        VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;
                break;
            case VAR_38: /* COMMENT_7 */
                proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
                VAR_9 += 2;
                proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                /* COMMENT_2 */
                VAR_9 += 4;
                VAR_5 = proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_9, 1, VAR_17);
                VAR_8 = proto_item_add_subtree(VAR_5, VAR_32);
                proto_tree_add_item(VAR_8, VAR_33,           VAR_0, VAR_9, 1, VAR_17);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_34,    VAR_0, VAR_9, 1, VAR_17);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_35,       VAR_0, VAR_9, 1, VAR_17);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 1, VAR_14);
                VAR_9 += 1;
                proto_tree_add_item(VAR_7, VAR_39,      VAR_0, VAR_9, 16, VAR_14);
                VAR_9 += 16;
                proto_tree_add_item(VAR_7, VAR_37,        VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;
                break;
            case VAR_40: /* COMMENT_8 */
                proto_tree_add_item(VAR_7, VAR_23,       VAR_0, VAR_9, 2, VAR_17);
                VAR_9 += 2;
                proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                /* COMMENT_2 */
                VAR_9 += 4;
                proto_tree_add_item(VAR_7, VAR_25,    VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;

                if (VAR_11 >= 1){
                proto_tree_add_item(VAR_7, VAR_41, VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;

                proto_tree_add_item(VAR_7, VAR_42,   VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;

                proto_tree_add_item(VAR_7, VAR_43,  VAR_0, VAR_9, 4, VAR_17);
                VAR_9 += 4;
                }
                break;

            case VAR_44: /* COMMENT_9 */
                if(VAR_11 < 1){
                    /* COMMENT_10 */
                    expert_add_info(VAR_1, VAR_6, &VAR_45);
                } else {
                    asn1_ctx_t VAR_46;

                    VAR_5 = proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_9, 1, VAR_17);
                    VAR_8 = proto_item_add_subtree(VAR_5, VAR_47);
                    proto_tree_add_item(VAR_8, VAR_48,           VAR_0, VAR_9, 1, VAR_17);
                    VAR_9 += 1;
                    proto_tree_add_item(VAR_7, VAR_28,         VAR_0, VAR_9, 2, VAR_14);
                    VAR_9 += 1;
                    proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                    /* COMMENT_2 */
                    VAR_9 += 4;
                    proto_tree_add_item(VAR_7, VAR_49, VAR_0, VAR_9, 20, VAR_14);
                    VAR_9 += 20;

                    proto_tree_add_item(VAR_7, VAR_37, VAR_0, VAR_9, 4, VAR_17);
                    VAR_9 += 4;
                    asn1_ctx_init(&VAR_46, VAR_50, TRUE, VAR_1);
                    VAR_9 = dissect_x509af_SubjectPublicKeyInfo(FALSE, VAR_0, VAR_9, &VAR_46, VAR_7, VAR_51);

                }
                break;
            case VAR_52: /* COMMENT_11 */
            {
                guint32 VAR_53, VAR_54;
                proto_tree_add_item(VAR_7, VAR_55,       VAR_0, VAR_9, 2, VAR_17);
                VAR_9 += 2;
                proto_tree_add_item(VAR_7, VAR_24,           VAR_0, VAR_9, 4, VAR_17);
                /* COMMENT_2 */
                VAR_9 += 4;
                proto_tree_add_item(VAR_7, VAR_56,       VAR_0, VAR_9, 4, VAR_17);
                VAR_53 =                                                      tvb_get_ntohl(VAR_0, VAR_9);
                VAR_9 += 4;
                proto_tree_add_item(VAR_7, VAR_57,        VAR_0, VAR_9, VAR_53, VAR_14);
                VAR_9 +=  VAR_53;
                proto_tree_add_item(VAR_7, VAR_58,      VAR_0, VAR_9, 4, VAR_17);
                VAR_54 =                                                     tvb_get_ntohl(VAR_0, VAR_9);
                VAR_9 += 4,
                proto_tree_add_item(VAR_7, VAR_59,   VAR_0, VAR_9, VAR_54, VAR_60|VAR_14);
                VAR_9 += VAR_54;
            }
            break;
            default:
                /* COMMENT_12 */
                if (VAR_12 > tvb_reported_length(VAR_0)) {
                    expert_add_info(VAR_1, VAR_6, &VAR_61);
                    return tvb_reported_length(VAR_0);
                }

                VAR_9 += VAR_12;
                break;
        }
    }

    return tvb_reported_length(VAR_0);
}",,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
     guint8 pdu_type, version;
     guint length;
 
-    while (tvb_reported_length_remaining(tvb, offset) != 0) {
+    while (tvb_reported_length_remaining(tvb, offset) > 0) {
 
         ti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA);
 
@@ -161,7 +161,12 @@
             }
             break;
             default:
-                /* No default ? */
+                /* No default ? At least sanity check the length*/
+                if (length > tvb_reported_length(tvb)) {
+                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_bad_length);
+                    return tvb_reported_length(tvb);
+                }
+
                 offset += length;
                 break;
         }","{'deleted_lines': ['    while (tvb_reported_length_remaining(tvb, offset) != 0) {', '                /* No default ? */'], 'added_lines': ['    while (tvb_reported_length_remaining(tvb, offset) > 0) {', '                /* No default ? At least sanity check the length*/', '                if (length > tvb_reported_length(tvb)) {', '                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_bad_length);', '                    return tvb_reported_length(tvb);', '                }', '']}",True,"In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpki-rtr.c had an infinite loop that was addressed by validating a length field.",7.5,HIGH,2,test,2018-02-12T01:17:39Z,2
CVE-2018-7325,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"RPKI-Router: Sanity check length field to prevent infinite loop

Bug: 14414
Change-Id: I39843e8959510a0efa1add51a16e207fc63f88b1
Reviewed-on: https://code.wireshark.org/review/25742
Reviewed-by: Michael Mann <mmann78@netscape.net>
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 5e8391ff900db18ccf8663918919b16085406874)
Reviewed-on: https://code.wireshark.org/review/25749",7be234d06ea39ab6a88115ae41d71060f1f15e3c,https://github.com/wireshark/wireshark/commit/7be234d06ea39ab6a88115ae41d71060f1f15e3c,epan/dissectors/packet-rpki-rtr.c,proto_register_rpkirtr,"void
proto_register_rpkirtr(void)
{
module_t *rpkirtr_module;
static hf_register_info hf[] = {
{ &hf_rpkirtr_version,
{ ""Version"", ""rpki-rtr.version"",
FT_UINT8, BASE_DEC, NULL, 0x0,
""Denoting the version of this protocol (currently 0)"", HFILL }
},
{ &hf_rpkirtr_pdu_type,
{ ""PDU Type"", ""rpki-rtr.pdu_type"",
FT_UINT8, BASE_DEC, VALS(rtr_pdu_type_vals), 0x0,
""Denoting the type of the PDU"", HFILL }
},
{ &hf_rpkirtr_reserved,
{ ""Reserved"", ""rpki-rtr.reserved"",
FT_BYTES, BASE_NONE, NULL, 0x0,
""Must be zero"", HFILL }
},
{ &hf_rpkirtr_session_id,
{ ""Session ID"", ""rpki-rtr.session_id"",
FT_UINT16, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_length,
{ ""Length"", ""rpki-rtr.length"",
FT_UINT32, BASE_DEC, NULL, 0x0,
""Value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field"", HFILL }
},
{ &hf_rpkirtr_serial_number,
{ ""Serial Number"", ""rpki-rtr.serial_number"",
FT_UINT32, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_flags,
{ ""Flags"", ""rpki-rtr.flags"",
FT_UINT8, BASE_HEX, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_flags_aw,
{ ""Flag AW"", ""rpki-rtr.flags.aw"",
FT_BOOLEAN, 8, TFS(&tfs_flag_type_aw), 0x01,
NULL, HFILL }
},
{ &hf_rpkirtr_flags_rk,
{ ""Flag Router Key"", ""rpki-rtr.flags.rk"",
FT_BOOLEAN, 8, TFS(&tfs_flag_type_rk), 0x01,
NULL, HFILL }
},
{ &hf_rpkirtr_prefix_length,
{ ""Prefix Length"", ""rpki-rtr.prefix_length"",
FT_UINT8, BASE_DEC, NULL, 0x0,
""Denoting the shortest prefix allowed for the prefix"", HFILL }
},
{ &hf_rpkirtr_max_length,
{ ""Max length"", ""rpki-rtr.max_length"",
FT_UINT8, BASE_DEC, NULL, 0x0,
""Denoting the longest prefix allowed by the prefix.  This MUST NOT be less than the Prefix Length element"", HFILL }
},
{ &hf_rpkirtr_ipv4_prefix,
{ ""IPv4 Prefix"", ""rpki-rtr.ipv4_prefix"",
FT_IPv4, BASE_NONE, NULL, 0x0,
""The IPv4 prefix of the ROA"", HFILL }
},
{ &hf_rpkirtr_ipv6_prefix,
{ ""IPv6 Prefix"", ""rpki-rtr.ipv6_prefix"",
FT_IPv6, BASE_NONE, NULL, 0x0,
""The IPv6 prefix of the ROA"", HFILL }
},
{ &hf_rpkirtr_as_number,
{ ""AS Number"", ""rpki-rtr.as_number"",
FT_UINT32, BASE_DEC, NULL, 0x0,
""Autonomous System Number allowed to announce this prefix"", HFILL }
},
{ &hf_rpkirtr_error_code,
{ ""Error Code"", ""rpki-rtr.error_code"",
FT_UINT16, BASE_DEC, VALS(rtr_error_code_vals), 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_length_pdu,
{ ""Length of Encapsulated PDU"", ""rpki-rtr.length_pdu"",
FT_UINT32, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_error_pdu,
{ ""Erroneous PDU"", ""rpki-rtr.error_pdu"",
FT_BYTES, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_length_text,
{ ""Length of text"", ""rpki-rtr.length_text"",
FT_UINT32, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_error_text,
{ ""Erroneous Text"", ""rpki-rtr.error_text"",
FT_STRING, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_refresh_interval,
{ ""Refresh Interval"", ""rpki-rtr.refresh_interval"",
FT_UINT32, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_retry_interval,
{ ""Retry Interval"", ""rpki-rtr.retry_interval"",
FT_UINT32, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_expire_interval,
{ ""Expire Interval"", ""rpki-rtr.expire_interval"",
FT_UINT32, BASE_DEC, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_subject_key_identifier,
{ ""Subject Key Identifier"", ""rpki-rtr.subject_key_identifier"",
FT_BYTES, BASE_NONE, NULL, 0x0,
NULL, HFILL }
},
{ &hf_rpkirtr_subject_public_key_info,
{ ""Subject Public Key Info"", ""rpki-rtr.subject_public_key_info"",
FT_NONE, BASE_NONE, NULL, 0x0,
NULL, HFILL }
}
};
static gint *ett[] = {
&ett_rpkirtr,
&ett_flags,
&ett_flags_nd
};
static ei_register_info ei[] = {
{ &ei_rpkirtr_wrong_version_router_key, { ""rpkirtr.router_key.wrong_version"", PI_MALFORMED, PI_WARN, ""Wrong version for Router Key type"", EXPFILL }},
};
expert_module_t *expert_rpkirtr;
proto_rpkirtr = proto_register_protocol(""RPKI-Router Protocol"",
""RPKI-Router Protocol"", ""rpkirtr"");
proto_register_field_array(proto_rpkirtr, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
rpkirtr_module = prefs_register_protocol(proto_rpkirtr,
proto_reg_handoff_rpkirtr);
prefs_register_uint_preference(rpkirtr_module, ""tcp.rpkirtr_tls.port"", ""RPKI-RTR TCP TLS Port"",
""RPKI-Router Protocol TCP TLS port if other than the default"",
10, &g_port_rpkirtr_tls);
expert_rpkirtr = expert_register_protocol(proto_rpkirtr);
expert_register_field_array(expert_rpkirtr, ei, array_length(ei));
rpkirtr_handle = register_dissector(""rpkirtr"", dissect_rpkirtr, proto_rpkirtr);
}","void
proto_register_rpkirtr(void)
{
module_t *VAR_0;
static hf_register_info VAR_1[] = {
{ &VAR_2,
{ ""Version"", ""rpki-rtr.version"",
VAR_3, VAR_4, NULL, 0x0,
""Denoting the version of this protocol (currently 0)"", VAR_5 }
},
{ &VAR_6,
{ ""PDU Type"", ""rpki-rtr.pdu_type"",
VAR_3, VAR_4, VALS(VAR_7), 0x0,
""Denoting the type of the PDU"", VAR_5 }
},
{ &VAR_8,
{ ""Reserved"", ""rpki-rtr.reserved"",
VAR_9, VAR_10, NULL, 0x0,
""Must be zero"", VAR_5 }
},
{ &VAR_11,
{ ""Session ID"", ""rpki-rtr.session_id"",
VAR_12, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_13,
{ ""Length"", ""rpki-rtr.length"",
VAR_14, VAR_4, NULL, 0x0,
""Value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field"", VAR_5 }
},
{ &VAR_15,
{ ""Serial Number"", ""rpki-rtr.serial_number"",
VAR_14, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_16,
{ ""Flags"", ""rpki-rtr.flags"",
VAR_3, VAR_17, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_18,
{ ""Flag AW"", ""rpki-rtr.flags.aw"",
VAR_19, 8, TFS(&VAR_20), 0x01,
NULL, VAR_5 }
},
{ &VAR_21,
{ ""Flag Router Key"", ""rpki-rtr.flags.rk"",
VAR_19, 8, TFS(&VAR_22), 0x01,
NULL, VAR_5 }
},
{ &VAR_23,
{ ""Prefix Length"", ""rpki-rtr.prefix_length"",
VAR_3, VAR_4, NULL, 0x0,
""Denoting the shortest prefix allowed for the prefix"", VAR_5 }
},
{ &VAR_24,
{ ""Max length"", ""rpki-rtr.max_length"",
VAR_3, VAR_4, NULL, 0x0,
""Denoting the longest prefix allowed by the prefix.  This MUST NOT be less than the Prefix Length element"", VAR_5 }
},
{ &VAR_25,
{ ""IPv4 Prefix"", ""rpki-rtr.ipv4_prefix"",
VAR_26, VAR_10, NULL, 0x0,
""The IPv4 prefix of the ROA"", VAR_5 }
},
{ &VAR_27,
{ ""IPv6 Prefix"", ""rpki-rtr.ipv6_prefix"",
VAR_28, VAR_10, NULL, 0x0,
""The IPv6 prefix of the ROA"", VAR_5 }
},
{ &VAR_29,
{ ""AS Number"", ""rpki-rtr.as_number"",
VAR_14, VAR_4, NULL, 0x0,
""Autonomous System Number allowed to announce this prefix"", VAR_5 }
},
{ &VAR_30,
{ ""Error Code"", ""rpki-rtr.error_code"",
VAR_12, VAR_4, VALS(VAR_31), 0x0,
NULL, VAR_5 }
},
{ &VAR_32,
{ ""Length of Encapsulated PDU"", ""rpki-rtr.length_pdu"",
VAR_14, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_33,
{ ""Erroneous PDU"", ""rpki-rtr.error_pdu"",
VAR_9, VAR_10, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_34,
{ ""Length of text"", ""rpki-rtr.length_text"",
VAR_14, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_35,
{ ""Erroneous Text"", ""rpki-rtr.error_text"",
VAR_36, VAR_10, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_37,
{ ""Refresh Interval"", ""rpki-rtr.refresh_interval"",
VAR_14, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_38,
{ ""Retry Interval"", ""rpki-rtr.retry_interval"",
VAR_14, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_39,
{ ""Expire Interval"", ""rpki-rtr.expire_interval"",
VAR_14, VAR_4, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_40,
{ ""Subject Key Identifier"", ""rpki-rtr.subject_key_identifier"",
VAR_9, VAR_10, NULL, 0x0,
NULL, VAR_5 }
},
{ &VAR_41,
{ ""Subject Public Key Info"", ""rpki-rtr.subject_public_key_info"",
VAR_42, VAR_10, NULL, 0x0,
NULL, VAR_5 }
}
};
static gint *VAR_43[] = {
&VAR_44,
&VAR_45,
&VAR_46
};
static ei_register_info VAR_47[] = {
{ &VAR_48, { ""rpkirtr.router_key.wrong_version"", VAR_49, VAR_50, ""Wrong version for Router Key type"", VAR_51 }},
};
expert_module_t *VAR_52;
VAR_53 = proto_register_protocol(""RPKI-Router Protocol"",
""RPKI-Router Protocol"", ""rpkirtr"");
proto_register_field_array(VAR_53, VAR_1, array_length(VAR_1));
proto_register_subtree_array(VAR_43, array_length(VAR_43));
VAR_0 = prefs_register_protocol(VAR_53,
VAR_54);
prefs_register_uint_preference(VAR_0, ""tcp.rpkirtr_tls.port"", ""RPKI-RTR TCP TLS Port"",
""RPKI-Router Protocol TCP TLS port if other than the default"",
10, &VAR_55);
VAR_52 = expert_register_protocol(VAR_53);
expert_register_field_array(VAR_52, VAR_47, array_length(VAR_47));
VAR_56 = register_dissector(""rpkirtr"", VAR_57, VAR_53);
}",wireshark/7be234d06ea39ab6a88115ae41d71060f1f15e3c/packet-rpki-rtr.c/vul/before/1.json,"void
proto_register_rpkirtr(void)
{
    module_t *rpkirtr_module;

    static hf_register_info hf[] = {
        { &hf_rpkirtr_version,
            { ""Version"", ""rpki-rtr.version"",
            FT_UINT8, BASE_DEC, NULL, 0x0,
            ""Denoting the version of this protocol (currently 0)"", HFILL }
        },
        { &hf_rpkirtr_pdu_type,
            { ""PDU Type"", ""rpki-rtr.pdu_type"",
            FT_UINT8, BASE_DEC, VALS(rtr_pdu_type_vals), 0x0,
            ""Denoting the type of the PDU"", HFILL }
        },
        { &hf_rpkirtr_reserved,
            { ""Reserved"", ""rpki-rtr.reserved"",
            FT_BYTES, BASE_NONE, NULL, 0x0,
            ""Must be zero"", HFILL }
        },
        { &hf_rpkirtr_session_id,
            { ""Session ID"", ""rpki-rtr.session_id"",
            FT_UINT16, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_length,
            { ""Length"", ""rpki-rtr.length"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            ""Value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field"", HFILL }
        },
        { &hf_rpkirtr_serial_number,
            { ""Serial Number"", ""rpki-rtr.serial_number"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_flags,
            { ""Flags"", ""rpki-rtr.flags"",
            FT_UINT8, BASE_HEX, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_flags_aw,
            { ""Flag AW"", ""rpki-rtr.flags.aw"",
            FT_BOOLEAN, 8, TFS(&tfs_flag_type_aw), 0x01,
            NULL, HFILL }
        },
        { &hf_rpkirtr_flags_rk,
            { ""Flag Router Key"", ""rpki-rtr.flags.rk"",
            FT_BOOLEAN, 8, TFS(&tfs_flag_type_rk), 0x01,
            NULL, HFILL }
        },
        { &hf_rpkirtr_prefix_length,
            { ""Prefix Length"", ""rpki-rtr.prefix_length"",
            FT_UINT8, BASE_DEC, NULL, 0x0,
            ""Denoting the shortest prefix allowed for the prefix"", HFILL }
        },
        { &hf_rpkirtr_max_length,
            { ""Max length"", ""rpki-rtr.max_length"",
            FT_UINT8, BASE_DEC, NULL, 0x0,
            ""Denoting the longest prefix allowed by the prefix.  This MUST NOT be less than the Prefix Length element"", HFILL }
        },
        { &hf_rpkirtr_ipv4_prefix,
            { ""IPv4 Prefix"", ""rpki-rtr.ipv4_prefix"",
            FT_IPv4, BASE_NONE, NULL, 0x0,
            ""The IPv4 prefix of the ROA"", HFILL }
        },
        { &hf_rpkirtr_ipv6_prefix,
            { ""IPv6 Prefix"", ""rpki-rtr.ipv6_prefix"",
            FT_IPv6, BASE_NONE, NULL, 0x0,
            ""The IPv6 prefix of the ROA"", HFILL }
        },
        { &hf_rpkirtr_as_number,
            { ""AS Number"", ""rpki-rtr.as_number"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            ""Autonomous System Number allowed to announce this prefix"", HFILL }
        },
        { &hf_rpkirtr_error_code,
            { ""Error Code"", ""rpki-rtr.error_code"",
            FT_UINT16, BASE_DEC, VALS(rtr_error_code_vals), 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_length_pdu,
            { ""Length of Encapsulated PDU"", ""rpki-rtr.length_pdu"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_error_pdu,
            { ""Erroneous PDU"", ""rpki-rtr.error_pdu"",
            FT_BYTES, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_length_text,
            { ""Length of text"", ""rpki-rtr.length_text"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_error_text,
            { ""Erroneous Text"", ""rpki-rtr.error_text"",
            FT_STRING, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_refresh_interval,
            { ""Refresh Interval"", ""rpki-rtr.refresh_interval"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_retry_interval,
            { ""Retry Interval"", ""rpki-rtr.retry_interval"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_expire_interval,
            { ""Expire Interval"", ""rpki-rtr.expire_interval"",
            FT_UINT32, BASE_DEC, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_subject_key_identifier,
            { ""Subject Key Identifier"", ""rpki-rtr.subject_key_identifier"",
            FT_BYTES, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        },
        { &hf_rpkirtr_subject_public_key_info,
            { ""Subject Public Key Info"", ""rpki-rtr.subject_public_key_info"",
            FT_NONE, BASE_NONE, NULL, 0x0,
            NULL, HFILL }
        }
    };

    static gint *ett[] = {
        &ett_rpkirtr,
        &ett_flags,
        &ett_flags_nd
    };

    static ei_register_info ei[] = {
        { &ei_rpkirtr_wrong_version_router_key, { ""rpkirtr.router_key.wrong_version"", PI_MALFORMED, PI_WARN, ""Wrong version for Router Key type"", EXPFILL }},
        { &ei_rpkirtr_bad_length, { ""rpkirtr.bad_length"", PI_MALFORMED, PI_ERROR, ""Invalid length field"", EXPFILL }},
    };

    expert_module_t *expert_rpkirtr;

    proto_rpkirtr = proto_register_protocol(""RPKI-Router Protocol"",
        ""RPKI-Router Protocol"", ""rpkirtr"");

    proto_register_field_array(proto_rpkirtr, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));

    rpkirtr_module = prefs_register_protocol(proto_rpkirtr,
        proto_reg_handoff_rpkirtr);

    prefs_register_uint_preference(rpkirtr_module, ""tcp.rpkirtr_tls.port"", ""RPKI-RTR TCP TLS Port"",
         ""RPKI-Router Protocol TCP TLS port if other than the default"",
         10, &g_port_rpkirtr_tls);

    expert_rpkirtr = expert_register_protocol(proto_rpkirtr);
    expert_register_field_array(expert_rpkirtr, ei, array_length(ei));
    rpkirtr_handle = register_dissector(""rpkirtr"", dissect_rpkirtr, proto_rpkirtr);
}","void
proto_register_rpkirtr(void)
{
    module_t *VAR_0;

    static hf_register_info VAR_1[] = {
        { &VAR_2,
            { ""Version"", ""rpki-rtr.version"",
            VAR_3, VAR_4, NULL, 0x0,
            ""Denoting the version of this protocol (currently 0)"", VAR_5 }
        },
        { &VAR_6,
            { ""PDU Type"", ""rpki-rtr.pdu_type"",
            VAR_3, VAR_4, VALS(VAR_7), 0x0,
            ""Denoting the type of the PDU"", VAR_5 }
        },
        { &VAR_8,
            { ""Reserved"", ""rpki-rtr.reserved"",
            VAR_9, VAR_10, NULL, 0x0,
            ""Must be zero"", VAR_5 }
        },
        { &VAR_11,
            { ""Session ID"", ""rpki-rtr.session_id"",
            VAR_12, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_13,
            { ""Length"", ""rpki-rtr.length"",
            VAR_14, VAR_4, NULL, 0x0,
            ""Value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field"", VAR_5 }
        },
        { &VAR_15,
            { ""Serial Number"", ""rpki-rtr.serial_number"",
            VAR_14, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_16,
            { ""Flags"", ""rpki-rtr.flags"",
            VAR_3, VAR_17, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_18,
            { ""Flag AW"", ""rpki-rtr.flags.aw"",
            VAR_19, 8, TFS(&VAR_20), 0x01,
            NULL, VAR_5 }
        },
        { &VAR_21,
            { ""Flag Router Key"", ""rpki-rtr.flags.rk"",
            VAR_19, 8, TFS(&VAR_22), 0x01,
            NULL, VAR_5 }
        },
        { &VAR_23,
            { ""Prefix Length"", ""rpki-rtr.prefix_length"",
            VAR_3, VAR_4, NULL, 0x0,
            ""Denoting the shortest prefix allowed for the prefix"", VAR_5 }
        },
        { &VAR_24,
            { ""Max length"", ""rpki-rtr.max_length"",
            VAR_3, VAR_4, NULL, 0x0,
            ""Denoting the longest prefix allowed by the prefix.  This MUST NOT be less than the Prefix Length element"", VAR_5 }
        },
        { &VAR_25,
            { ""IPv4 Prefix"", ""rpki-rtr.ipv4_prefix"",
            VAR_26, VAR_10, NULL, 0x0,
            ""The IPv4 prefix of the ROA"", VAR_5 }
        },
        { &VAR_27,
            { ""IPv6 Prefix"", ""rpki-rtr.ipv6_prefix"",
            VAR_28, VAR_10, NULL, 0x0,
            ""The IPv6 prefix of the ROA"", VAR_5 }
        },
        { &VAR_29,
            { ""AS Number"", ""rpki-rtr.as_number"",
            VAR_14, VAR_4, NULL, 0x0,
            ""Autonomous System Number allowed to announce this prefix"", VAR_5 }
        },
        { &VAR_30,
            { ""Error Code"", ""rpki-rtr.error_code"",
            VAR_12, VAR_4, VALS(VAR_31), 0x0,
            NULL, VAR_5 }
        },
        { &VAR_32,
            { ""Length of Encapsulated PDU"", ""rpki-rtr.length_pdu"",
            VAR_14, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_33,
            { ""Erroneous PDU"", ""rpki-rtr.error_pdu"",
            VAR_9, VAR_10, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_34,
            { ""Length of text"", ""rpki-rtr.length_text"",
            VAR_14, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_35,
            { ""Erroneous Text"", ""rpki-rtr.error_text"",
            VAR_36, VAR_10, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_37,
            { ""Refresh Interval"", ""rpki-rtr.refresh_interval"",
            VAR_14, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_38,
            { ""Retry Interval"", ""rpki-rtr.retry_interval"",
            VAR_14, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_39,
            { ""Expire Interval"", ""rpki-rtr.expire_interval"",
            VAR_14, VAR_4, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_40,
            { ""Subject Key Identifier"", ""rpki-rtr.subject_key_identifier"",
            VAR_9, VAR_10, NULL, 0x0,
            NULL, VAR_5 }
        },
        { &VAR_41,
            { ""Subject Public Key Info"", ""rpki-rtr.subject_public_key_info"",
            VAR_42, VAR_10, NULL, 0x0,
            NULL, VAR_5 }
        }
    };

    static gint *VAR_43[] = {
        &VAR_44,
        &VAR_45,
        &VAR_46
    };

    static ei_register_info VAR_47[] = {
        { &VAR_48, { ""rpkirtr.router_key.wrong_version"", VAR_49, VAR_50, ""Wrong version for Router Key type"", VAR_51 }},
        { &VAR_52, { ""rpkirtr.bad_length"", VAR_49, VAR_53, ""Invalid length field"", VAR_51 }},
    };

    expert_module_t *VAR_54;

    VAR_55 = proto_register_protocol(""RPKI-Router Protocol"",
        ""RPKI-Router Protocol"", ""rpkirtr"");

    proto_register_field_array(VAR_55, VAR_1, array_length(VAR_1));
    proto_register_subtree_array(VAR_43, array_length(VAR_43));

    VAR_0 = prefs_register_protocol(VAR_55,
        VAR_56);

    prefs_register_uint_preference(VAR_0, ""tcp.rpkirtr_tls.port"", ""RPKI-RTR TCP TLS Port"",
         ""RPKI-Router Protocol TCP TLS port if other than the default"",
         10, &VAR_57);

    VAR_54 = expert_register_protocol(VAR_55);
    expert_register_field_array(VAR_54, VAR_47, array_length(VAR_47));
    VAR_58 = register_dissector(""rpkirtr"", VAR_59, VAR_55);
}",wireshark/7be234d06ea39ab6a88115ae41d71060f1f15e3c/packet-rpki-rtr.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -134,6 +134,7 @@
 
     static ei_register_info ei[] = {
         { &ei_rpkirtr_wrong_version_router_key, { ""rpkirtr.router_key.wrong_version"", PI_MALFORMED, PI_WARN, ""Wrong version for Router Key type"", EXPFILL }},
+        { &ei_rpkirtr_bad_length, { ""rpkirtr.bad_length"", PI_MALFORMED, PI_ERROR, ""Invalid length field"", EXPFILL }},
     };
 
     expert_module_t *expert_rpkirtr;","{'deleted_lines': [], 'added_lines': ['        { &ei_rpkirtr_bad_length, { ""rpkirtr.bad_length"", PI_MALFORMED, PI_ERROR, ""Invalid length field"", EXPFILL }},']}",True,"In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpki-rtr.c had an infinite loop that was addressed by validating a length field.",7.5,HIGH,2,test,2018-02-12T01:17:39Z,2
CVE-2018-7326,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"LLTD: use wider variables to prevent overflow and infinite loops

Bug: 14419
Change-Id: I1adf186a56e87a043077d330d59f18b8e5823cd7
Reviewed-on: https://code.wireshark.org/review/25871
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit 8760999f646fb398fa0c824f3539cee4a4911d13)
Reviewed-on: https://code.wireshark.org/review/25878",293b999425e998d6cde0d9149648e421ea7687d0,https://github.com/wireshark/wireshark/commit/293b999425e998d6cde0d9149648e421ea7687d0,epan/dissectors/packet-lltd.c,dissect_lltd_tlv,"static int
dissect_lltd_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, gboolean* end)
{
guint8     i, type, length = 0;
proto_item *tlv_item, *type_item;
proto_tree *tlv_tree, *type_tree;
guint32 temp32;
type = tvb_get_guint8(tvb, offset);
if (type == 0)
{
tlv_tree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_tlv_item, &tlv_item, ""TLV Item (End of Property List)"");
*end = TRUE;
}
else
{
length = tvb_get_guint8(tvb, offset+1);
tlv_tree = proto_tree_add_subtree_format(tree, tvb, offset, length+2, ett_tlv_item, &tlv_item,
""TLV Item (%s)"", val_to_str(type, lltd_tlv_type_vals, ""Unknown (0x%02x)""));
*end = FALSE;
}
proto_tree_add_item(tlv_tree, hf_lltd_tlv_type, tvb, offset, 1, ENC_NA);
if (type != 0)
proto_tree_add_item(tlv_tree, hf_lltd_tlv_length, tvb, offset+1, 1, ENC_NA);
if ((type != 0) && (length > tvb_reported_length_remaining(tvb, offset+2)))
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""TLV Length field too big"");
*end = TRUE;
return 2;
}
switch(type)
{
case 0x00: 
return 1;
case 0x01: 
if (length != 6)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Host ID length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_host_id, tvb, offset+2, 6, ENC_NA);
break;
case 0x02: 
if (length != 4)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Characteristics length"");
}
else
{
type_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_characteristics, &type_item, ""Characteristics"");
proto_tree_add_item(type_tree, hf_lltd_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_char_x, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_char_f, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_char_m, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_char_l, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);
if (tvb_get_ntohl(tvb, offset+2) & LLTD_CHARACTERISTIC_RESERVE_MASK)
expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);
}
break;
case 0x03: 
if (length != 4)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Physical Medium length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_physical_medium, tvb, offset+2, 4, ENC_BIG_ENDIAN);
break;
case 0x04: 
if (length != 1)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Wireless Mode length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_wireless_mode, tvb, offset+2, 1, ENC_BIG_ENDIAN);
break;
case 0x05: 
if (length != 6)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid BSSID length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_bssid, tvb, offset+2, 6, ENC_NA);
break;
case 0x06: 
if (length > 32)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""SSID length too large"");
}
proto_tree_add_item(tlv_tree, hf_lltd_ssid, tvb, offset+2, length, ENC_NA|ENC_ASCII);
break;
case 0x07: 
if (length != 4)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid IPv4 Address length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_ipv4_address, tvb, offset+2, 4, ENC_BIG_ENDIAN);
break;
case 0x08: 
if (length != 16)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid IPv6 Address length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_ipv6_address, tvb, offset+2, 16, ENC_NA);
break;
case 0x09: 
if (length != 2)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Maximum Operation Rate length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_max_operation_rate, tvb, offset+2, 2, ENC_BIG_ENDIAN);
break;
case 0x0A: 
if (length != 8)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Performance Counter Frequency length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_performance_count_freq, tvb, offset+2, 8, ENC_BIG_ENDIAN);
break;
case 0x0C: 
if (length != 4)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Link Speed length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_link_speed, tvb, offset+2, 4, ENC_BIG_ENDIAN);
break;
case 0x0D: 
if (length != 4)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid RSSI length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_rssi, tvb, offset+2, 4, ENC_BIG_ENDIAN);
break;
case 0x0F: 
if (length > 32)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Machine Name length too large"");
}
proto_tree_add_item(tlv_tree, hf_lltd_machine_name, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);
break;
case 0x10: 
if (length > 64)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Support Information length too large"");
}
proto_tree_add_item(tlv_tree, hf_lltd_support_info, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);
break;
case 0x11: 
if (length != 0)
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Friendly Name length"");
break;
case 0x12: 
if (length != 22)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Device UUID length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_device_uuid, tvb, offset+2, 22, ENC_NA);
break;
case 0x13: 
if (length != 0)
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Hardware ID length"");
break;
case 0x14: 
if (length != 4)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""QoS Characteristics length"");
}
else
{
type_tree = proto_tree_add_subtree(tlv_tree, tvb, offset+2, 4, ett_qos_characteristics, &type_item, ""QoS Characteristics"");
proto_tree_add_item(type_tree, hf_lltd_qos_char_e, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_qos_char_q, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_qos_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(type_tree, hf_lltd_qos_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);
temp32 = tvb_get_ntohl(tvb, offset+2);
if (temp32 & LLTD_QOS_CHARACTERISTIC_RESERVE_MASK)
expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);
}
break;
case 0x15: 
if (length != 1)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid 802.11 Phyiscal Medium length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_80211_physical_medium, tvb, offset+2, 1, ENC_BIG_ENDIAN);
break;
case 0x19: 
if (length != 2)
{
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Sees-List Working Set length"");
}
proto_tree_add_item(tlv_tree, hf_lltd_sees_list_working_set, tvb, offset+2, 2, ENC_BIG_ENDIAN);
break;
case 0x1B: 
type_tree = proto_tree_add_subtree(tree, tvb, offset+2, length, ett_repeater_ap_lineage, NULL, ""Repeater AP Lineage"");
for (i = 0; i < length; i += 6)
proto_tree_add_item(type_tree, hf_lltd_repeater_ap_lineage, tvb, offset+2+i, 6, ENC_NA);
if (length > 36)
expert_add_info(pinfo, tlv_item, &ei_lltd_too_many_paths);
break;
case 0x0E: 
case 0x16: 
case 0x18: 
case 0x1A: 
case 0x1C: 
if (length != 0)
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid length"");
break;
default:
expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_type, ""Invalid TLV Type 0x%02x"", type);
break;
}
return length+2;
}","static int
dissect_lltd_tlv(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, guint32 VAR_3, gboolean* VAR_4)
{
guint8     VAR_5, VAR_6, VAR_7 = 0;
proto_item *VAR_8, *VAR_9;
proto_tree *VAR_10, *VAR_11;
guint32 VAR_12;
VAR_6 = tvb_get_guint8(VAR_0, VAR_3);
if (VAR_6 == 0)
{
VAR_10 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3, 1, VAR_13, &VAR_8, ""TLV Item (End of Property List)"");
*VAR_4 = TRUE;
}
else
{
VAR_7 = tvb_get_guint8(VAR_0, VAR_3+1);
VAR_10 = proto_tree_add_subtree_format(VAR_2, VAR_0, VAR_3, VAR_7+2, VAR_13, &VAR_8,
""TLV Item (%s)"", val_to_str(VAR_6, VAR_14, ""Unknown (0x%02x)""));
*VAR_4 = FALSE;
}
proto_tree_add_item(VAR_10, VAR_15, VAR_0, VAR_3, 1, VAR_16);
if (VAR_6 != 0)
proto_tree_add_item(VAR_10, VAR_17, VAR_0, VAR_3+1, 1, VAR_16);
if ((VAR_6 != 0) && (VAR_7 > tvb_reported_length_remaining(VAR_0, VAR_3+2)))
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""TLV Length field too big"");
*VAR_4 = TRUE;
return 2;
}
switch(VAR_6)
{
case 0x00: 
return 1;
case 0x01: 
if (VAR_7 != 6)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Host ID length"");
}
proto_tree_add_item(VAR_10, VAR_19, VAR_0, VAR_3+2, 6, VAR_16);
break;
case 0x02: 
if (VAR_7 != 4)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Characteristics length"");
}
else
{
VAR_11 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3+2, 4, VAR_20, &VAR_9, ""Characteristics"");
proto_tree_add_item(VAR_11, VAR_21, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_23, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_24, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_25, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_26, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_27, VAR_0, VAR_3+2, 4, VAR_22);
if (tvb_get_ntohl(VAR_0, VAR_3+2) & VAR_28)
expert_add_info(VAR_1, VAR_9, &VAR_29);
}
break;
case 0x03: 
if (VAR_7 != 4)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Physical Medium length"");
}
proto_tree_add_item(VAR_10, VAR_30, VAR_0, VAR_3+2, 4, VAR_22);
break;
case 0x04: 
if (VAR_7 != 1)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Wireless Mode length"");
}
proto_tree_add_item(VAR_10, VAR_31, VAR_0, VAR_3+2, 1, VAR_22);
break;
case 0x05: 
if (VAR_7 != 6)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid BSSID length"");
}
proto_tree_add_item(VAR_10, VAR_32, VAR_0, VAR_3+2, 6, VAR_16);
break;
case 0x06: 
if (VAR_7 > 32)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""SSID length too large"");
}
proto_tree_add_item(VAR_10, VAR_33, VAR_0, VAR_3+2, VAR_7, VAR_16|VAR_34);
break;
case 0x07: 
if (VAR_7 != 4)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid IPv4 Address length"");
}
proto_tree_add_item(VAR_10, VAR_35, VAR_0, VAR_3+2, 4, VAR_22);
break;
case 0x08: 
if (VAR_7 != 16)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid IPv6 Address length"");
}
proto_tree_add_item(VAR_10, VAR_36, VAR_0, VAR_3+2, 16, VAR_16);
break;
case 0x09: 
if (VAR_7 != 2)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Maximum Operation Rate length"");
}
proto_tree_add_item(VAR_10, VAR_37, VAR_0, VAR_3+2, 2, VAR_22);
break;
case 0x0A: 
if (VAR_7 != 8)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Performance Counter Frequency length"");
}
proto_tree_add_item(VAR_10, VAR_38, VAR_0, VAR_3+2, 8, VAR_22);
break;
case 0x0C: 
if (VAR_7 != 4)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Link Speed length"");
}
proto_tree_add_item(VAR_10, VAR_39, VAR_0, VAR_3+2, 4, VAR_22);
break;
case 0x0D: 
if (VAR_7 != 4)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid RSSI length"");
}
proto_tree_add_item(VAR_10, VAR_40, VAR_0, VAR_3+2, 4, VAR_22);
break;
case 0x0F: 
if (VAR_7 > 32)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Machine Name length too large"");
}
proto_tree_add_item(VAR_10, VAR_41, VAR_0, VAR_3+2, VAR_7, VAR_42|VAR_43);
break;
case 0x10: 
if (VAR_7 > 64)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Support Information length too large"");
}
proto_tree_add_item(VAR_10, VAR_44, VAR_0, VAR_3+2, VAR_7, VAR_42|VAR_43);
break;
case 0x11: 
if (VAR_7 != 0)
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Friendly Name length"");
break;
case 0x12: 
if (VAR_7 != 22)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Device UUID length"");
}
proto_tree_add_item(VAR_10, VAR_45, VAR_0, VAR_3+2, 22, VAR_16);
break;
case 0x13: 
if (VAR_7 != 0)
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Hardware ID length"");
break;
case 0x14: 
if (VAR_7 != 4)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""QoS Characteristics length"");
}
else
{
VAR_11 = proto_tree_add_subtree(VAR_10, VAR_0, VAR_3+2, 4, VAR_46, &VAR_9, ""QoS Characteristics"");
proto_tree_add_item(VAR_11, VAR_47, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_48, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_49, VAR_0, VAR_3+2, 4, VAR_22);
proto_tree_add_item(VAR_11, VAR_50, VAR_0, VAR_3+2, 4, VAR_22);
VAR_12 = tvb_get_ntohl(VAR_0, VAR_3+2);
if (VAR_12 & VAR_51)
expert_add_info(VAR_1, VAR_9, &VAR_29);
}
break;
case 0x15: 
if (VAR_7 != 1)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid 802.11 Phyiscal Medium length"");
}
proto_tree_add_item(VAR_10, VAR_52, VAR_0, VAR_3+2, 1, VAR_22);
break;
case 0x19: 
if (VAR_7 != 2)
{
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid Sees-List Working Set length"");
}
proto_tree_add_item(VAR_10, VAR_53, VAR_0, VAR_3+2, 2, VAR_22);
break;
case 0x1B: 
VAR_11 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3+2, VAR_7, VAR_54, NULL, ""Repeater AP Lineage"");
for (VAR_5 = 0; VAR_5 < VAR_7; VAR_5 += 6)
proto_tree_add_item(VAR_11, VAR_55, VAR_0, VAR_3+2+VAR_5, 6, VAR_16);
if (VAR_7 > 36)
expert_add_info(VAR_1, VAR_8, &VAR_56);
break;
case 0x0E: 
case 0x16: 
case 0x18: 
case 0x1A: 
case 0x1C: 
if (VAR_7 != 0)
expert_add_info_format(VAR_1, VAR_8, &VAR_18, ""Invalid length"");
break;
default:
expert_add_info_format(VAR_1, VAR_8, &VAR_57, ""Invalid TLV Type 0x%02x"", VAR_6);
break;
}
return VAR_7+2;
}",wireshark/293b999425e998d6cde0d9149648e421ea7687d0/packet-lltd.c/vul/before/0.json,"static int
dissect_lltd_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, gboolean* end)
{
    guint8     type, length = 0;
    proto_item *tlv_item, *type_item;
    proto_tree *tlv_tree, *type_tree;
    guint32 i, temp32;

    type = tvb_get_guint8(tvb, offset);
    if (type == 0)
    {
        /* End of Property type doesn't have length */
        tlv_tree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_tlv_item, &tlv_item, ""TLV Item (End of Property List)"");
        *end = TRUE;
    }
    else
    {
        length = tvb_get_guint8(tvb, offset+1);
        tlv_tree = proto_tree_add_subtree_format(tree, tvb, offset, length+2, ett_tlv_item, &tlv_item,
                    ""TLV Item (%s)"", val_to_str(type, lltd_tlv_type_vals, ""Unknown (0x%02x)""));
        *end = FALSE;
    }

    proto_tree_add_item(tlv_tree, hf_lltd_tlv_type, tvb, offset, 1, ENC_NA);
    if (type != 0)
        proto_tree_add_item(tlv_tree, hf_lltd_tlv_length, tvb, offset+1, 1, ENC_NA);


    if ((type != 0) && (length > tvb_reported_length_remaining(tvb, offset+2)))
    {
        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""TLV Length field too big"");
        *end = TRUE;
        return 2;
    }

    switch(type)
    {
    case 0x00: /* End of Property List */
        /* No data, no length field */
        return 1;
    case 0x01: /* Host ID */
        if (length != 6)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Host ID length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_host_id, tvb, offset+2, 6, ENC_NA);
        break;
    case 0x02: /* Characteristics */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Characteristics length"");
        }
        else
        {
            type_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_characteristics, &type_item, ""Characteristics"");
            proto_tree_add_item(type_tree, hf_lltd_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_x, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_f, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_m, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_l, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            if (tvb_get_ntohl(tvb, offset+2) & LLTD_CHARACTERISTIC_RESERVE_MASK)
                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);
        }
        break;
    case 0x03: /* Physical Medium */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Physical Medium length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_physical_medium, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x04: /* Wireless Mode */
        if (length != 1)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Wireless Mode length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_wireless_mode, tvb, offset+2, 1, ENC_BIG_ENDIAN);
        break;
    case 0x05: /* 802.11 BSSID */
        if (length != 6)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid BSSID length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_bssid, tvb, offset+2, 6, ENC_NA);
        break;
    case 0x06: /* 802.11 SSID */
        if (length > 32)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""SSID length too large"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_ssid, tvb, offset+2, length, ENC_NA|ENC_ASCII);
        break;
    case 0x07: /* IPv4 Address */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid IPv4 Address length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_ipv4_address, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x08: /* IPv6 Address */
        if (length != 16)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid IPv6 Address length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_ipv6_address, tvb, offset+2, 16, ENC_NA);
        break;
    case 0x09: /* 802.11 Maximum Operation Rate */
        if (length != 2)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Maximum Operation Rate length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_max_operation_rate, tvb, offset+2, 2, ENC_BIG_ENDIAN);
        break;
    case 0x0A: /* Performance Counter Frequency */
        if (length != 8)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Performance Counter Frequency length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_performance_count_freq, tvb, offset+2, 8, ENC_BIG_ENDIAN);
        break;
    case 0x0C: /* Link Speed */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Link Speed length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_link_speed, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x0D: /* 802.11 RSSI */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid RSSI length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_rssi, tvb, offset+2, 4, ENC_BIG_ENDIAN);
        break;
    case 0x0F: /* Machine Name */
        if (length > 32)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Machine Name length too large"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_machine_name, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);
        break;
    case 0x10: /* Support Information */
        if (length > 64)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Support Information length too large"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_support_info, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);
        break;
    case 0x11: /* Friendly Name */
        if (length != 0)
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Friendly Name length"");
        break;
    case 0x12: /* Device UUID */
        if (length != 22)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Device UUID length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_device_uuid, tvb, offset+2, 22, ENC_NA);
        break;
    case 0x13: /* Hardware ID */
        if (length != 0)
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Hardware ID length"");
        break;
    case 0x14: /* QoS Characteristics */
        if (length != 4)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""QoS Characteristics length"");
        }
        else
        {
            type_tree = proto_tree_add_subtree(tlv_tree, tvb, offset+2, 4, ett_qos_characteristics, &type_item, ""QoS Characteristics"");
            proto_tree_add_item(type_tree, hf_lltd_qos_char_e, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_qos_char_q, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_qos_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(type_tree, hf_lltd_qos_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);
            temp32 = tvb_get_ntohl(tvb, offset+2);
            if (temp32 & LLTD_QOS_CHARACTERISTIC_RESERVE_MASK)
                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);
        }
        break;
    case 0x15: /* 802.11 Physical Medium */
        if (length != 1)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid 802.11 Phyiscal Medium length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_80211_physical_medium, tvb, offset+2, 1, ENC_BIG_ENDIAN);
        break;
    case 0x19: /* Sees-List Working Set */
        if (length != 2)
        {
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid Sees-List Working Set length"");
        }

        proto_tree_add_item(tlv_tree, hf_lltd_sees_list_working_set, tvb, offset+2, 2, ENC_BIG_ENDIAN);
        break;
    case 0x1B: /* Repeater AP Lineage */
        type_tree = proto_tree_add_subtree(tree, tvb, offset+2, length, ett_repeater_ap_lineage, NULL, ""Repeater AP Lineage"");
        for (i = 0; i < length; i += 6)
            proto_tree_add_item(type_tree, hf_lltd_repeater_ap_lineage, tvb, offset+2+i, 6, ENC_NA);

        if (length > 36)
            expert_add_info(pinfo, tlv_item, &ei_lltd_too_many_paths);
        break;
    case 0x0E: /* Icon Image */
    case 0x16: /* AP Association Table */
    case 0x18: /* Detailed Icon Image */
    case 0x1A: /* Component Table */
    case 0x1C: /* Repeater AP Table */
        if (length != 0)
            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, ""Invalid length"");
        break;
    default:
        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_type, ""Invalid TLV Type 0x%02x"", type);
        break;
    }

    return length+2;
}","static int
dissect_lltd_tlv(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, guint32 VAR_3, gboolean* VAR_4)
{
    guint8     VAR_5, VAR_6 = 0;
    proto_item *VAR_7, *VAR_8;
    proto_tree *VAR_9, *VAR_10;
    guint32 VAR_11, VAR_12;

    VAR_5 = tvb_get_guint8(VAR_0, VAR_3);
    if (VAR_5 == 0)
    {
        /* COMMENT_0 */
        VAR_9 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3, 1, VAR_13, &VAR_7, ""TLV Item (End of Property List)"");
        *VAR_4 = TRUE;
    }
    else
    {
        VAR_6 = tvb_get_guint8(VAR_0, VAR_3+1);
        VAR_9 = proto_tree_add_subtree_format(VAR_2, VAR_0, VAR_3, VAR_6+2, VAR_13, &VAR_7,
                    ""TLV Item (%s)"", val_to_str(VAR_5, VAR_14, ""Unknown (0x%02x)""));
        *VAR_4 = FALSE;
    }

    proto_tree_add_item(VAR_9, VAR_15, VAR_0, VAR_3, 1, VAR_16);
    if (VAR_5 != 0)
        proto_tree_add_item(VAR_9, VAR_17, VAR_0, VAR_3+1, 1, VAR_16);


    if ((VAR_5 != 0) && (VAR_6 > tvb_reported_length_remaining(VAR_0, VAR_3+2)))
    {
        expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""TLV Length field too big"");
        *VAR_4 = TRUE;
        return 2;
    }

    switch(VAR_5)
    {
    case 0x00: /* COMMENT_1 */
        /* COMMENT_2 */
        return 1;
    case 0x01: /* COMMENT_3 */
        if (VAR_6 != 6)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Host ID length"");
        }

        proto_tree_add_item(VAR_9, VAR_19, VAR_0, VAR_3+2, 6, VAR_16);
        break;
    case 0x02: /* COMMENT_4 */
        if (VAR_6 != 4)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Characteristics length"");
        }
        else
        {
            VAR_10 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3+2, 4, VAR_20, &VAR_8, ""Characteristics"");
            proto_tree_add_item(VAR_10, VAR_21, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_23, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_24, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_25, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_26, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_27, VAR_0, VAR_3+2, 4, VAR_22);
            if (tvb_get_ntohl(VAR_0, VAR_3+2) & VAR_28)
                expert_add_info(VAR_1, VAR_8, &VAR_29);
        }
        break;
    case 0x03: /* COMMENT_5 */
        if (VAR_6 != 4)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Physical Medium length"");
        }

        proto_tree_add_item(VAR_9, VAR_30, VAR_0, VAR_3+2, 4, VAR_22);
        break;
    case 0x04: /* COMMENT_6 */
        if (VAR_6 != 1)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Wireless Mode length"");
        }

        proto_tree_add_item(VAR_9, VAR_31, VAR_0, VAR_3+2, 1, VAR_22);
        break;
    case 0x05: /* COMMENT_7 */
        if (VAR_6 != 6)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid BSSID length"");
        }

        proto_tree_add_item(VAR_9, VAR_32, VAR_0, VAR_3+2, 6, VAR_16);
        break;
    case 0x06: /* COMMENT_8 */
        if (VAR_6 > 32)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""SSID length too large"");
        }

        proto_tree_add_item(VAR_9, VAR_33, VAR_0, VAR_3+2, VAR_6, VAR_16|VAR_34);
        break;
    case 0x07: /* COMMENT_9 */
        if (VAR_6 != 4)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid IPv4 Address length"");
        }

        proto_tree_add_item(VAR_9, VAR_35, VAR_0, VAR_3+2, 4, VAR_22);
        break;
    case 0x08: /* COMMENT_10 */
        if (VAR_6 != 16)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid IPv6 Address length"");
        }

        proto_tree_add_item(VAR_9, VAR_36, VAR_0, VAR_3+2, 16, VAR_16);
        break;
    case 0x09: /* COMMENT_11 */
        if (VAR_6 != 2)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Maximum Operation Rate length"");
        }

        proto_tree_add_item(VAR_9, VAR_37, VAR_0, VAR_3+2, 2, VAR_22);
        break;
    case 0x0A: /* COMMENT_12 */
        if (VAR_6 != 8)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Performance Counter Frequency length"");
        }

        proto_tree_add_item(VAR_9, VAR_38, VAR_0, VAR_3+2, 8, VAR_22);
        break;
    case 0x0C: /* COMMENT_13 */
        if (VAR_6 != 4)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Link Speed length"");
        }

        proto_tree_add_item(VAR_9, VAR_39, VAR_0, VAR_3+2, 4, VAR_22);
        break;
    case 0x0D: /* COMMENT_14 */
        if (VAR_6 != 4)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid RSSI length"");
        }

        proto_tree_add_item(VAR_9, VAR_40, VAR_0, VAR_3+2, 4, VAR_22);
        break;
    case 0x0F: /* COMMENT_15 */
        if (VAR_6 > 32)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Machine Name length too large"");
        }

        proto_tree_add_item(VAR_9, VAR_41, VAR_0, VAR_3+2, VAR_6, VAR_42|VAR_43);
        break;
    case 0x10: /* COMMENT_16 */
        if (VAR_6 > 64)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Support Information length too large"");
        }

        proto_tree_add_item(VAR_9, VAR_44, VAR_0, VAR_3+2, VAR_6, VAR_42|VAR_43);
        break;
    case 0x11: /* COMMENT_17 */
        if (VAR_6 != 0)
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Friendly Name length"");
        break;
    case 0x12: /* COMMENT_18 */
        if (VAR_6 != 22)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Device UUID length"");
        }

        proto_tree_add_item(VAR_9, VAR_45, VAR_0, VAR_3+2, 22, VAR_16);
        break;
    case 0x13: /* COMMENT_19 */
        if (VAR_6 != 0)
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Hardware ID length"");
        break;
    case 0x14: /* COMMENT_20 */
        if (VAR_6 != 4)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""QoS Characteristics length"");
        }
        else
        {
            VAR_10 = proto_tree_add_subtree(VAR_9, VAR_0, VAR_3+2, 4, VAR_46, &VAR_8, ""QoS Characteristics"");
            proto_tree_add_item(VAR_10, VAR_47, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_48, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_49, VAR_0, VAR_3+2, 4, VAR_22);
            proto_tree_add_item(VAR_10, VAR_50, VAR_0, VAR_3+2, 4, VAR_22);
            VAR_12 = tvb_get_ntohl(VAR_0, VAR_3+2);
            if (VAR_12 & VAR_51)
                expert_add_info(VAR_1, VAR_8, &VAR_29);
        }
        break;
    case 0x15: /* COMMENT_21 */
        if (VAR_6 != 1)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid 802.11 Phyiscal Medium length"");
        }

        proto_tree_add_item(VAR_9, VAR_52, VAR_0, VAR_3+2, 1, VAR_22);
        break;
    case 0x19: /* COMMENT_22 */
        if (VAR_6 != 2)
        {
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid Sees-List Working Set length"");
        }

        proto_tree_add_item(VAR_9, VAR_53, VAR_0, VAR_3+2, 2, VAR_22);
        break;
    case 0x1B: /* COMMENT_23 */
        VAR_10 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_3+2, VAR_6, VAR_54, NULL, ""Repeater AP Lineage"");
        for (VAR_11 = 0; VAR_11 < VAR_6; VAR_11 += 6)
            proto_tree_add_item(VAR_10, VAR_55, VAR_0, VAR_3+2+VAR_11, 6, VAR_16);

        if (VAR_6 > 36)
            expert_add_info(VAR_1, VAR_7, &VAR_56);
        break;
    case 0x0E: /* COMMENT_24 */
    case 0x16: /* COMMENT_25 */
    case 0x18: /* COMMENT_26 */
    case 0x1A: /* COMMENT_27 */
    case 0x1C: /* COMMENT_28 */
        if (VAR_6 != 0)
            expert_add_info_format(VAR_1, VAR_7, &VAR_18, ""Invalid length"");
        break;
    default:
        expert_add_info_format(VAR_1, VAR_7, &VAR_57, ""Invalid TLV Type 0x%02x"", VAR_5);
        break;
    }

    return VAR_6+2;
}",wireshark/293b999425e998d6cde0d9149648e421ea7687d0/packet-lltd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,10 +1,10 @@
 static int
 dissect_lltd_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, gboolean* end)
 {
-    guint8     i, type, length = 0;
+    guint8     type, length = 0;
     proto_item *tlv_item, *type_item;
     proto_tree *tlv_tree, *type_tree;
-    guint32 temp32;
+    guint32 i, temp32;
 
     type = tvb_get_guint8(tvb, offset);
     if (type == 0)","{'deleted_lines': ['    guint8     i, type, length = 0;', '    guint32 temp32;'], 'added_lines': ['    guint8     type, length = 0;', '    guint32 i, temp32;']}",True,"In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-lltd.c had an infinite loop that was addressed by using a correct integer data type.",7.5,HIGH,2,test,2018-02-17T18:33:44Z,2
CVE-2018-1068,['CWE-787'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"netfilter: ebtables: CONFIG_COMPAT: don't trust userland offsets

We need to make sure the offsets are not out of range of the
total size.
Also check that they are in ascending order.

The WARN_ON triggered by syzkaller (it sets panic_on_warn) is
changed to also bail out, no point in continuing parsing.

Briefly tested with simple ruleset of
-A INPUT --limit 1/s' --log
plus jump to custom chains using 32bit ebtables binary.

Reported-by: <syzbot+845a53d13171abf8bf29@syzkaller.appspotmail.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",b71812168571fa55e44cdd0254471331b9c4c4c6,https://github.com/torvalds/linux/commit/b71812168571fa55e44cdd0254471331b9c4c4c6,net/bridge/netfilter/ebtables.c,ebt_size_mwt,"static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,
unsigned int size_left, enum compat_mwt type,
struct ebt_entries_buf_state *state, const void *base)
{
int growth = 0;
char *buf;
if (size_left == 0)
return 0;
buf = (char *) match32;
while (size_left >= sizeof(*match32)) {
struct ebt_entry_match *match_kern;
int ret;
match_kern = (struct ebt_entry_match *) state->buf_kern_start;
if (match_kern) {
char *tmp;
tmp = state->buf_kern_start + state->buf_kern_offset;
match_kern = (struct ebt_entry_match *) tmp;
}
ret = ebt_buf_add(state, buf, sizeof(*match32));
if (ret < 0)
return ret;
size_left -= sizeof(*match32);
ret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());
if (ret < 0)
return ret;
if (match32->match_size > size_left)
return -EINVAL;
size_left -= match32->match_size;
ret = compat_mtw_from_user(match32, type, state, base);
if (ret < 0)
return ret;
if (WARN_ON(ret < match32->match_size))
return -EINVAL;
growth += ret - match32->match_size;
growth += ebt_compat_entry_padsize();
buf += sizeof(*match32);
buf += match32->match_size;
if (match_kern)
match_kern->match_size = ret;
WARN_ON(type == EBT_COMPAT_TARGET && size_left);
match32 = (struct compat_ebt_entry_mwt *) buf;
}
return growth;
}","static int ebt_size_mwt(struct compat_ebt_entry_mwt *VAR_0,
unsigned int VAR_1, enum compat_mwt VAR_2,
struct ebt_entries_buf_state *VAR_3, const void *VAR_4)
{
int VAR_5 = 0;
char *VAR_6;
if (VAR_1 == 0)
return 0;
VAR_6 = (char *) VAR_0;
while (VAR_1 >= sizeof(*VAR_0)) {
struct ebt_entry_match *VAR_7;
int VAR_8;
VAR_7 = (struct ebt_entry_match *) VAR_3->buf_kern_start;
if (VAR_7) {
char *VAR_9;
VAR_9 = VAR_3->buf_kern_start + VAR_3->buf_kern_offset;
VAR_7 = (struct ebt_entry_match *) VAR_9;
}
VAR_8 = ebt_buf_add(VAR_3, VAR_6, sizeof(*VAR_0));
if (VAR_8 < 0)
return VAR_8;
VAR_1 -= sizeof(*VAR_0);
VAR_8 = ebt_buf_add_pad(VAR_3, ebt_compat_entry_padsize());
if (VAR_8 < 0)
return VAR_8;
if (VAR_0->match_size > VAR_1)
return -VAR_10;
VAR_1 -= VAR_0->match_size;
VAR_8 = compat_mtw_from_user(VAR_0, VAR_2, VAR_3, VAR_4);
if (VAR_8 < 0)
return VAR_8;
if (WARN_ON(VAR_8 < VAR_0->match_size))
return -VAR_10;
VAR_5 += VAR_8 - VAR_0->match_size;
VAR_5 += ebt_compat_entry_padsize();
VAR_6 += sizeof(*VAR_0);
VAR_6 += VAR_0->match_size;
if (VAR_7)
VAR_7->match_size = VAR_8;
WARN_ON(VAR_2 == VAR_11 && VAR_1);
VAR_0 = (struct compat_ebt_entry_mwt *) VAR_6;
}
return VAR_5;
}",torvalds/linux/b71812168571fa55e44cdd0254471331b9c4c4c6/ebtables.c/vul/before/1.json,"static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,
			unsigned int size_left, enum compat_mwt type,
			struct ebt_entries_buf_state *state, const void *base)
{
	int growth = 0;
	char *buf;

	if (size_left == 0)
		return 0;

	buf = (char *) match32;

	while (size_left >= sizeof(*match32)) {
		struct ebt_entry_match *match_kern;
		int ret;

		match_kern = (struct ebt_entry_match *) state->buf_kern_start;
		if (match_kern) {
			char *tmp;
			tmp = state->buf_kern_start + state->buf_kern_offset;
			match_kern = (struct ebt_entry_match *) tmp;
		}
		ret = ebt_buf_add(state, buf, sizeof(*match32));
		if (ret < 0)
			return ret;
		size_left -= sizeof(*match32);

		/* add padding before match->data (if any) */
		ret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());
		if (ret < 0)
			return ret;

		if (match32->match_size > size_left)
			return -EINVAL;

		size_left -= match32->match_size;

		ret = compat_mtw_from_user(match32, type, state, base);
		if (ret < 0)
			return ret;

		if (WARN_ON(ret < match32->match_size))
			return -EINVAL;
		growth += ret - match32->match_size;
		growth += ebt_compat_entry_padsize();

		buf += sizeof(*match32);
		buf += match32->match_size;

		if (match_kern)
			match_kern->match_size = ret;

		if (WARN_ON(type == EBT_COMPAT_TARGET && size_left))
			return -EINVAL;

		match32 = (struct compat_ebt_entry_mwt *) buf;
	}

	return growth;
}","static int ebt_size_mwt(struct compat_ebt_entry_mwt *VAR_0,
			unsigned int VAR_1, enum compat_mwt VAR_2,
			struct ebt_entries_buf_state *VAR_3, const void *VAR_4)
{
	int VAR_5 = 0;
	char *VAR_6;

	if (VAR_1 == 0)
		return 0;

	VAR_6 = (char *) VAR_0;

	while (VAR_1 >= sizeof(*VAR_0)) {
		struct ebt_entry_match *VAR_7;
		int VAR_8;

		VAR_7 = (struct ebt_entry_match *) VAR_3->buf_kern_start;
		if (VAR_7) {
			char *VAR_9;
			VAR_9 = VAR_3->buf_kern_start + VAR_3->buf_kern_offset;
			VAR_7 = (struct ebt_entry_match *) VAR_9;
		}
		VAR_8 = ebt_buf_add(VAR_3, VAR_6, sizeof(*VAR_0));
		if (VAR_8 < 0)
			return VAR_8;
		VAR_1 -= sizeof(*VAR_0);

		/* COMMENT_0 */
		VAR_8 = ebt_buf_add_pad(VAR_3, ebt_compat_entry_padsize());
		if (VAR_8 < 0)
			return VAR_8;

		if (VAR_0->match_size > VAR_1)
			return -VAR_10;

		VAR_1 -= VAR_0->match_size;

		VAR_8 = compat_mtw_from_user(VAR_0, VAR_2, VAR_3, VAR_4);
		if (VAR_8 < 0)
			return VAR_8;

		if (WARN_ON(VAR_8 < VAR_0->match_size))
			return -VAR_10;
		VAR_5 += VAR_8 - VAR_0->match_size;
		VAR_5 += ebt_compat_entry_padsize();

		VAR_6 += sizeof(*VAR_0);
		VAR_6 += VAR_0->match_size;

		if (VAR_7)
			VAR_7->match_size = VAR_8;

		if (WARN_ON(VAR_2 == VAR_11 && VAR_1))
			return -VAR_10;

		VAR_0 = (struct compat_ebt_entry_mwt *) VAR_6;
	}

	return VAR_5;
}",torvalds/linux/b71812168571fa55e44cdd0254471331b9c4c4c6/ebtables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -50,7 +50,9 @@
 		if (match_kern)
 			match_kern->match_size = ret;
 
-		WARN_ON(type == EBT_COMPAT_TARGET && size_left);
+		if (WARN_ON(type == EBT_COMPAT_TARGET && size_left))
+			return -EINVAL;
+
 		match32 = (struct compat_ebt_entry_mwt *) buf;
 	}
 ","{'deleted_lines': ['\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);'], 'added_lines': ['\t\tif (WARN_ON(type == EBT_COMPAT_TARGET && size_left))', '\t\t\treturn -EINVAL;', '']}",True,A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.,6.7,MEDIUM,1,test,2018-02-19T00:24:15Z,2
CVE-2018-1068,['CWE-787'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"netfilter: ebtables: CONFIG_COMPAT: don't trust userland offsets

We need to make sure the offsets are not out of range of the
total size.
Also check that they are in ascending order.

The WARN_ON triggered by syzkaller (it sets panic_on_warn) is
changed to also bail out, no point in continuing parsing.

Briefly tested with simple ruleset of
-A INPUT --limit 1/s' --log
plus jump to custom chains using 32bit ebtables binary.

Reported-by: <syzbot+845a53d13171abf8bf29@syzkaller.appspotmail.com>
Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",b71812168571fa55e44cdd0254471331b9c4c4c6,https://github.com/torvalds/linux/commit/b71812168571fa55e44cdd0254471331b9c4c4c6,net/bridge/netfilter/ebtables.c,size_entry_mwt,"static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,
unsigned int *total,
struct ebt_entries_buf_state *state)
{
unsigned int i, j, startoff, new_offset = 0;
unsigned int offsets[4];
unsigned int *offsets_update = NULL;
int ret;
char *buf_start;
if (*total < sizeof(struct ebt_entries))
return -EINVAL;
if (!entry->bitmask) {
*total -= sizeof(struct ebt_entries);
return ebt_buf_add(state, entry, sizeof(struct ebt_entries));
}
if (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))
return -EINVAL;
startoff = state->buf_user_offset;
ret = ebt_buf_add(state, entry,
offsetof(struct ebt_entry, watchers_offset));
if (ret < 0)
return ret;
offsets[0] = sizeof(struct ebt_entry); 
memcpy(&offsets[1], &entry->watchers_offset,
sizeof(offsets) - sizeof(offsets[0]));
if (state->buf_kern_start) {
buf_start = state->buf_kern_start + state->buf_kern_offset;
offsets_update = (unsigned int *) buf_start;
}
ret = ebt_buf_add(state, &offsets[1],
sizeof(offsets) - sizeof(offsets[0]));
if (ret < 0)
return ret;
buf_start = (char *) entry;
for (i = 0, j = 1 ; j < 4 ; j++, i++) {
struct compat_ebt_entry_mwt *match32;
unsigned int size;
char *buf = buf_start + offsets[i];
if (offsets[i] > offsets[j])
return -EINVAL;
match32 = (struct compat_ebt_entry_mwt *) buf;
size = offsets[j] - offsets[i];
ret = ebt_size_mwt(match32, size, i, state, base);
if (ret < 0)
return ret;
new_offset += ret;
if (offsets_update && new_offset) {
pr_debug(""change offset %d to %d\n"",
offsets_update[i], offsets[j] + new_offset);
offsets_update[i] = offsets[j] + new_offset;
}
}
if (state->buf_kern_start == NULL) {
unsigned int offset = buf_start - (char *) base;
ret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);
if (ret < 0)
return ret;
}
startoff = state->buf_user_offset - startoff;
if (WARN_ON(*total < startoff))
return -EINVAL;
*total -= startoff;
return 0;
}","static int size_entry_mwt(struct ebt_entry *VAR_0, const unsigned char *VAR_1,
unsigned int *VAR_2,
struct ebt_entries_buf_state *VAR_3)
{
unsigned int VAR_4, VAR_5, VAR_6, VAR_7 = 0;
unsigned int VAR_8[4];
unsigned int *VAR_9 = NULL;
int VAR_10;
char *VAR_11;
if (*VAR_2 < sizeof(struct ebt_entries))
return -VAR_12;
if (!VAR_0->bitmask) {
*VAR_2 -= sizeof(struct ebt_entries);
return ebt_buf_add(VAR_3, VAR_0, sizeof(struct ebt_entries));
}
if (*VAR_2 < sizeof(*VAR_0) || VAR_0->next_offset < sizeof(*VAR_0))
return -VAR_12;
VAR_6 = VAR_3->buf_user_offset;
VAR_10 = ebt_buf_add(VAR_3, VAR_0,
offsetof(struct ebt_entry, VAR_13));
if (VAR_10 < 0)
return VAR_10;
VAR_8[0] = sizeof(struct ebt_entry); 
memcpy(&VAR_8[1], &VAR_0->watchers_offset,
sizeof(VAR_8) - sizeof(VAR_8[0]));
if (VAR_3->buf_kern_start) {
VAR_11 = VAR_3->buf_kern_start + VAR_3->buf_kern_offset;
VAR_9 = (unsigned int *) VAR_11;
}
VAR_10 = ebt_buf_add(VAR_3, &VAR_8[1],
sizeof(VAR_8) - sizeof(VAR_8[0]));
if (VAR_10 < 0)
return VAR_10;
VAR_11 = (char *) VAR_0;
for (VAR_4 = 0, VAR_5 = 1 ; VAR_5 < 4 ; VAR_5++, VAR_4++) {
struct compat_ebt_entry_mwt *VAR_14;
unsigned int VAR_15;
char *VAR_16 = VAR_11 + VAR_8[VAR_4];
if (VAR_8[VAR_4] > VAR_8[VAR_5])
return -VAR_12;
VAR_14 = (struct compat_ebt_entry_mwt *) VAR_16;
VAR_15 = VAR_8[VAR_5] - VAR_8[VAR_4];
VAR_10 = ebt_size_mwt(VAR_14, VAR_15, VAR_4, VAR_3, VAR_1);
if (VAR_10 < 0)
return VAR_10;
VAR_7 += VAR_10;
if (VAR_9 && VAR_7) {
pr_debug(""change offset %d to %d\n"",
VAR_9[VAR_4], VAR_8[VAR_5] + VAR_7);
VAR_9[VAR_4] = VAR_8[VAR_5] + VAR_7;
}
}
if (VAR_3->buf_kern_start == NULL) {
unsigned int VAR_17 = VAR_11 - (char *) VAR_1;
VAR_10 = xt_compat_add_offset(VAR_18, VAR_17, VAR_7);
if (VAR_10 < 0)
return VAR_10;
}
VAR_6 = VAR_3->buf_user_offset - VAR_6;
if (WARN_ON(*VAR_2 < VAR_6))
return -VAR_12;
*VAR_2 -= VAR_6;
return 0;
}",torvalds/linux/b71812168571fa55e44cdd0254471331b9c4c4c6/ebtables.c/vul/before/0.json,"static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,
			  unsigned int *total,
			  struct ebt_entries_buf_state *state)
{
	unsigned int i, j, startoff, new_offset = 0;
	/* stores match/watchers/targets & offset of next struct ebt_entry: */
	unsigned int offsets[4];
	unsigned int *offsets_update = NULL;
	int ret;
	char *buf_start;

	if (*total < sizeof(struct ebt_entries))
		return -EINVAL;

	if (!entry->bitmask) {
		*total -= sizeof(struct ebt_entries);
		return ebt_buf_add(state, entry, sizeof(struct ebt_entries));
	}
	if (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))
		return -EINVAL;

	startoff = state->buf_user_offset;
	/* pull in most part of ebt_entry, it does not need to be changed. */
	ret = ebt_buf_add(state, entry,
			offsetof(struct ebt_entry, watchers_offset));
	if (ret < 0)
		return ret;

	offsets[0] = sizeof(struct ebt_entry); /* matches come first */
	memcpy(&offsets[1], &entry->watchers_offset,
			sizeof(offsets) - sizeof(offsets[0]));

	if (state->buf_kern_start) {
		buf_start = state->buf_kern_start + state->buf_kern_offset;
		offsets_update = (unsigned int *) buf_start;
	}
	ret = ebt_buf_add(state, &offsets[1],
			sizeof(offsets) - sizeof(offsets[0]));
	if (ret < 0)
		return ret;
	buf_start = (char *) entry;
	/* 0: matches offset, always follows ebt_entry.
	 * 1: watchers offset, from ebt_entry structure
	 * 2: target offset, from ebt_entry structure
	 * 3: next ebt_entry offset, from ebt_entry structure
	 *
	 * offsets are relative to beginning of struct ebt_entry (i.e., 0).
	 */
	for (i = 0; i < 4 ; ++i) {
		if (offsets[i] >= *total)
			return -EINVAL;
		if (i == 0)
			continue;
		if (offsets[i-1] > offsets[i])
			return -EINVAL;
	}

	for (i = 0, j = 1 ; j < 4 ; j++, i++) {
		struct compat_ebt_entry_mwt *match32;
		unsigned int size;
		char *buf = buf_start + offsets[i];

		if (offsets[i] > offsets[j])
			return -EINVAL;

		match32 = (struct compat_ebt_entry_mwt *) buf;
		size = offsets[j] - offsets[i];
		ret = ebt_size_mwt(match32, size, i, state, base);
		if (ret < 0)
			return ret;
		new_offset += ret;
		if (offsets_update && new_offset) {
			pr_debug(""change offset %d to %d\n"",
				offsets_update[i], offsets[j] + new_offset);
			offsets_update[i] = offsets[j] + new_offset;
		}
	}

	if (state->buf_kern_start == NULL) {
		unsigned int offset = buf_start - (char *) base;

		ret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);
		if (ret < 0)
			return ret;
	}

	startoff = state->buf_user_offset - startoff;

	if (WARN_ON(*total < startoff))
		return -EINVAL;
	*total -= startoff;
	return 0;
}","static int size_entry_mwt(struct ebt_entry *VAR_0, const unsigned char *VAR_1,
			  unsigned int *VAR_2,
			  struct ebt_entries_buf_state *VAR_3)
{
	unsigned int VAR_4, VAR_5, VAR_6, VAR_7 = 0;
	/* COMMENT_0 */
	unsigned int VAR_8[4];
	unsigned int *VAR_9 = NULL;
	int VAR_10;
	char *VAR_11;

	if (*VAR_2 < sizeof(struct ebt_entries))
		return -VAR_12;

	if (!VAR_0->bitmask) {
		*VAR_2 -= sizeof(struct ebt_entries);
		return ebt_buf_add(VAR_3, VAR_0, sizeof(struct ebt_entries));
	}
	if (*VAR_2 < sizeof(*VAR_0) || VAR_0->next_offset < sizeof(*VAR_0))
		return -VAR_12;

	VAR_6 = VAR_3->buf_user_offset;
	/* COMMENT_1 */
	VAR_10 = ebt_buf_add(VAR_3, VAR_0,
			offsetof(struct ebt_entry, VAR_13));
	if (VAR_10 < 0)
		return VAR_10;

	VAR_8[0] = sizeof(struct ebt_entry); /* COMMENT_2 */
	memcpy(&VAR_8[1], &VAR_0->watchers_offset,
			sizeof(VAR_8) - sizeof(VAR_8[0]));

	if (VAR_3->buf_kern_start) {
		VAR_11 = VAR_3->buf_kern_start + VAR_3->buf_kern_offset;
		VAR_9 = (unsigned int *) VAR_11;
	}
	VAR_10 = ebt_buf_add(VAR_3, &VAR_8[1],
			sizeof(VAR_8) - sizeof(VAR_8[0]));
	if (VAR_10 < 0)
		return VAR_10;
	VAR_11 = (char *) VAR_0;
	/* COMMENT_3 */
                                                
                                              
                                                      
   
                                                                    
    
	for (VAR_4 = 0; VAR_4 < 4 ; ++VAR_4) {
		if (VAR_8[VAR_4] >= *VAR_2)
			return -VAR_12;
		if (VAR_4 == 0)
			continue;
		if (VAR_8[VAR_4-1] > VAR_8[VAR_4])
			return -VAR_12;
	}

	for (VAR_4 = 0, VAR_5 = 1 ; VAR_5 < 4 ; VAR_5++, VAR_4++) {
		struct compat_ebt_entry_mwt *VAR_14;
		unsigned int VAR_15;
		char *VAR_16 = VAR_11 + VAR_8[VAR_4];

		if (VAR_8[VAR_4] > VAR_8[VAR_5])
			return -VAR_12;

		VAR_14 = (struct compat_ebt_entry_mwt *) VAR_16;
		VAR_15 = VAR_8[VAR_5] - VAR_8[VAR_4];
		VAR_10 = ebt_size_mwt(VAR_14, VAR_15, VAR_4, VAR_3, VAR_1);
		if (VAR_10 < 0)
			return VAR_10;
		VAR_7 += VAR_10;
		if (VAR_9 && VAR_7) {
			pr_debug(""change offset %d to %d\n"",
				VAR_9[VAR_4], VAR_8[VAR_5] + VAR_7);
			VAR_9[VAR_4] = VAR_8[VAR_5] + VAR_7;
		}
	}

	if (VAR_3->buf_kern_start == NULL) {
		unsigned int VAR_17 = VAR_11 - (char *) VAR_1;

		VAR_10 = xt_compat_add_offset(VAR_18, VAR_17, VAR_7);
		if (VAR_10 < 0)
			return VAR_10;
	}

	VAR_6 = VAR_3->buf_user_offset - VAR_6;

	if (WARN_ON(*VAR_2 < VAR_6))
		return -VAR_12;
	*VAR_2 -= VAR_6;
	return 0;
}",torvalds/linux/b71812168571fa55e44cdd0254471331b9c4c4c6/ebtables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,6 +46,15 @@
 	 *
 	 * offsets are relative to beginning of struct ebt_entry (i.e., 0).
 	 */
+	for (i = 0; i < 4 ; ++i) {
+		if (offsets[i] >= *total)
+			return -EINVAL;
+		if (i == 0)
+			continue;
+		if (offsets[i-1] > offsets[i])
+			return -EINVAL;
+	}
+
 	for (i = 0, j = 1 ; j < 4 ; j++, i++) {
 		struct compat_ebt_entry_mwt *match32;
 		unsigned int size;","{'deleted_lines': [], 'added_lines': ['\tfor (i = 0; i < 4 ; ++i) {', '\t\tif (offsets[i] >= *total)', '\t\t\treturn -EINVAL;', '\t\tif (i == 0)', '\t\t\tcontinue;', '\t\tif (offsets[i-1] > offsets[i])', '\t\t\treturn -EINVAL;', '\t}', '']}",True,A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.,6.7,MEDIUM,1,test,2018-02-19T00:24:15Z,2
CVE-2019-1010044,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,archivesunleashed/graphpass,Fix buffer overflow vulnerability.  Issue #4.,f407fd23a2d03cd6d1c25da76b1a571126ea8d96,https://github.com/archivesunleashed/graphpass/commit/f407fd23a2d03cd6d1c25da76b1a571126ea8d96,Include/borg-reducer.h,write_report,"int write_report(igraph_t *graph) {
printf(""Write report ... \n"");
char dir[150];
struct stat st = {0};
strcpy(dir, output);
strcat(dir, ""REPORT/"");
char filepath[150];
strcpy(filepath, dir);
strcat(filepath, ""report.txt"");
printf(""%s "", filepath);
if (stat(dir, &st) == -1) {
mkdir(dir, 0700);
}
FILE *fs;
time_t t;
igraph_vector_t gtypes, vtypes, etypes;
igraph_strvector_t gnames, vnames, enames;
igraph_vector_init(&gtypes, 0);
igraph_vector_init(&vtypes, 0);
igraph_vector_init(&etypes, 0);
igraph_strvector_init(&gnames, 0);
igraph_strvector_init(&vnames, 0);
igraph_strvector_init(&enames, 0);
igraph_cattribute_list(&g, &gnames, &gtypes, &vnames, &vtypes,
&enames, &etypes);
fs = fopen(filepath, ""a"");
t = time(NULL);
fprintf( fs, ""REPORT: %s "", ctime(&t));
fprintf( fs, ""-------------------- \n\n"");
fprintf( fs, ""ORIGINAL GRAPH: *%s.gexf*\n\n"", filename);
for (int i=0; i<igraph_strvector_size(&gnames); i++) {
fprintf(fs, ""%s : %f \n"", STR(gnames, i), GAN(&g, STR(gnames, i)));
}
fprintf(fs, ""TRAIT COMPARISON BY FILTERING METHOD \n"");
fprintf(fs, ""------------------------------------ \n"");
fprintf(fs, ""Percent Filtered: %-2f\n"", percent);
fprintf(fs, ""\n| Method          |  Edges   |  Assort |  Dens.  |  Recipr |  C(Deg.)|\n"");
fprintf(fs, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
while (asshead != NULL) {
fprintf(fs,
""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
asshead->abbrev, (GAN(&g, ""EDGES"") - edges->val), (GAN(&g, ""ASSORTATIVITY"") - asshead->val),
(GAN(&g, ""DENSITY"") - density->val) , (GAN(&g, ""RECIPROCITY"") - reciprocity->val),
(GAN(&g, ""centralizationDegree"") - degcent->val)
);
asshead = asshead->next;
density = density->next;
edges = edges->next;
reciprocity = reciprocity->next;
degcent = degcent->next;
}
fprintf (fs, ""|                 |           |          |          |          |          |\n\n"");
fprintf(fs, ""\n| Method          |  Diameter|  Pathlen|  Cluster|  C(Betw)|  C(Page)|\n"");
fprintf(fs, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
while (clustering != NULL) {
fprintf(fs,
""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
clustering->abbrev, (GAN(&g, ""DIAMETER"") - diameter->val), (GAN(&g, ""AVG_PATH_LENGTH"") - pathlength->val),
(GAN(&g, ""OVERALL_CLUSTERING"") - clustering->val) , (GAN(&g, ""centralizationBetweenness"") - betcent->val),
(GAN(&g, ""centralizationPageRank"") - pagecent->val)
);
clustering = clustering->next;
diameter = diameter->next;
pathlength = pathlength->next;
betcent = betcent->next;
pagecent = pagecent->next;
}
fprintf (fs, ""|                 |           |          |          |          |          |\n\n"");
fclose(fs);
igraph_vector_destroy(&gtypes);
igraph_vector_destroy(&vtypes);
igraph_vector_destroy(&etypes);
igraph_strvector_destroy(&gnames);
igraph_strvector_destroy(&vnames);
igraph_strvector_destroy(&enames);
return 0;
}","int write_report(igraph_t *VAR_0) {
printf(""Write report ... \n"");
char VAR_1[150];
struct stat VAR_2 = {0};
strcpy(VAR_1, VAR_3);
strcat(VAR_1, ""REPORT/"");
char VAR_4[150];
strcpy(VAR_4, VAR_1);
strcat(VAR_4, ""report.txt"");
printf(""%s "", VAR_4);
if (stat(VAR_1, &VAR_2) == -1) {
mkdir(VAR_1, 0700);
}
FILE *VAR_5;
time_t VAR_6;
igraph_vector_t VAR_7, VAR_8, VAR_9;
igraph_strvector_t VAR_10, VAR_11, VAR_12;
igraph_vector_init(&VAR_7, 0);
igraph_vector_init(&VAR_8, 0);
igraph_vector_init(&VAR_9, 0);
igraph_strvector_init(&VAR_10, 0);
igraph_strvector_init(&VAR_11, 0);
igraph_strvector_init(&VAR_12, 0);
igraph_cattribute_list(&VAR_13, &VAR_10, &VAR_7, &VAR_11, &VAR_8,
&VAR_12, &VAR_9);
VAR_5 = fopen(VAR_4, ""a"");
VAR_6 = time(NULL);
fprintf( VAR_5, ""REPORT: %s "", ctime(&VAR_6));
fprintf( VAR_5, ""-------------------- \n\n"");
fprintf( VAR_5, ""ORIGINAL GRAPH: *%s.gexf*\n\n"", VAR_14);
for (int VAR_15=0; VAR_15<igraph_strvector_size(&VAR_10); VAR_15++) {
fprintf(VAR_5, ""%s : %f \n"", STR(VAR_10, VAR_15), GAN(&VAR_13, STR(VAR_10, VAR_15)));
}
fprintf(VAR_5, ""TRAIT COMPARISON BY FILTERING METHOD \n"");
fprintf(VAR_5, ""------------------------------------ \n"");
fprintf(VAR_5, ""Percent Filtered: %-2f\n"", VAR_16);
fprintf(VAR_5, ""\n| Method          |  Edges   |  Assort |  Dens.  |  Recipr |  C(Deg.)|\n"");
fprintf(VAR_5, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
while (VAR_17 != NULL) {
fprintf(VAR_5,
""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
VAR_17->abbrev, (GAN(&VAR_13, ""EDGES"") - VAR_18->val), (GAN(&VAR_13, ""ASSORTATIVITY"") - VAR_17->val),
(GAN(&VAR_13, ""DENSITY"") - VAR_19->val) , (GAN(&VAR_13, ""RECIPROCITY"") - VAR_20->val),
(GAN(&VAR_13, ""centralizationDegree"") - VAR_21->val)
);
VAR_17 = VAR_17->next;
VAR_19 = VAR_19->next;
VAR_18 = VAR_18->next;
VAR_20 = VAR_20->next;
VAR_21 = VAR_21->next;
}
fprintf (VAR_5, ""|                 |           |          |          |          |          |\n\n"");
fprintf(VAR_5, ""\n| Method          |  Diameter|  Pathlen|  Cluster|  C(Betw)|  C(Page)|\n"");
fprintf(VAR_5, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
while (VAR_22 != NULL) {
fprintf(VAR_5,
""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
VAR_22->abbrev, (GAN(&VAR_13, ""DIAMETER"") - VAR_23->val), (GAN(&VAR_13, ""AVG_PATH_LENGTH"") - VAR_24->val),
(GAN(&VAR_13, ""OVERALL_CLUSTERING"") - VAR_22->val) , (GAN(&VAR_13, ""centralizationBetweenness"") - VAR_25->val),
(GAN(&VAR_13, ""centralizationPageRank"") - VAR_26->val)
);
VAR_22 = VAR_22->next;
VAR_23 = VAR_23->next;
VAR_24 = VAR_24->next;
VAR_25 = VAR_25->next;
VAR_26 = VAR_26->next;
}
fprintf (VAR_5, ""|                 |           |          |          |          |          |\n\n"");
fclose(VAR_5);
igraph_vector_destroy(&VAR_7);
igraph_vector_destroy(&VAR_8);
igraph_vector_destroy(&VAR_9);
igraph_strvector_destroy(&VAR_10);
igraph_strvector_destroy(&VAR_11);
igraph_strvector_destroy(&VAR_12);
return 0;
}",archivesunleashed/graphpass/f407fd23a2d03cd6d1c25da76b1a571126ea8d96/borg-reducer.h/vul/before/0.json,"int write_report(igraph_t *graph) {
  printf(""Write report ... \n"");
  char* dir;
  struct stat st = {0};
  strcpy(dir, output);
  strcat(dir, ""REPORT/"");
  char* filepath;
  strcpy(filepath, dir);
  strcat(filepath, ""report.txt"");
  printf(""%s "", filepath);
  if (stat(dir, &st) == -1) {
    mkdir(dir, 0700);
  }
  FILE *fs;
  time_t t;
  igraph_vector_t gtypes, vtypes, etypes;
  igraph_strvector_t gnames, vnames, enames;
  igraph_vector_init(&gtypes, 0);
  igraph_vector_init(&vtypes, 0);
  igraph_vector_init(&etypes, 0);
  igraph_strvector_init(&gnames, 0);
  igraph_strvector_init(&vnames, 0);
  igraph_strvector_init(&enames, 0);
  igraph_cattribute_list(&g, &gnames, &gtypes, &vnames, &vtypes,
			 &enames, &etypes);
  fs = fopen(filepath, ""a"");
  t = time(NULL);
  fprintf( fs, ""REPORT: %s "", ctime(&t));
  fprintf( fs, ""-------------------- \n\n"");
  fprintf( fs, ""ORIGINAL GRAPH: *%s.gexf*\n\n"", filename);
  for (int i=0; i<igraph_strvector_size(&gnames); i++) {
    fprintf(fs, ""%s : %f \n"", STR(gnames, i), GAN(&g, STR(gnames, i)));
  }
  /* print names (use asshead) */
  fprintf(fs, ""TRAIT COMPARISON BY FILTERING METHOD \n"");
  fprintf(fs, ""------------------------------------ \n"");
  fprintf(fs, ""Percent Filtered: %-2f\n"", percent);
  fprintf(fs, ""\n| Method          |  Edges   |  Assort |  Dens.  |  Recipr |  C(Deg.)|\n"");
  fprintf(fs, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
  while (asshead != NULL) {
    fprintf(fs,
      ""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
      asshead->abbrev, (GAN(&g, ""EDGES"") - edges->val), (GAN(&g, ""ASSORTATIVITY"") - asshead->val),
      (GAN(&g, ""DENSITY"") - density->val) , (GAN(&g, ""RECIPROCITY"") - reciprocity->val),
      (GAN(&g, ""centralizationDegree"") - degcent->val)
      );
    asshead = asshead->next;
    density = density->next;
    edges = edges->next;
    reciprocity = reciprocity->next;
    degcent = degcent->next;
  }
  fprintf (fs, ""|                 |           |          |          |          |          |\n\n"");

  fprintf(fs, ""\n| Method          |  Diameter|  Pathlen|  Cluster|  C(Betw)|  C(Page)|\n"");
  fprintf(fs, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
  while (clustering != NULL) {
    fprintf(fs,
      ""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
      clustering->abbrev, (GAN(&g, ""DIAMETER"") - diameter->val), (GAN(&g, ""AVG_PATH_LENGTH"") - pathlength->val),
      (GAN(&g, ""OVERALL_CLUSTERING"") - clustering->val) , (GAN(&g, ""centralizationBetweenness"") - betcent->val),
      (GAN(&g, ""centralizationPageRank"") - pagecent->val)
      );
    clustering = clustering->next;
    diameter = diameter->next;
    pathlength = pathlength->next;
    betcent = betcent->next;
    pagecent = pagecent->next;
  }
  fprintf (fs, ""|                 |           |          |          |          |          |\n\n"");
  fclose(fs);
  igraph_vector_destroy(&gtypes);
  igraph_vector_destroy(&vtypes);
  igraph_vector_destroy(&etypes);
  igraph_strvector_destroy(&gnames);
  igraph_strvector_destroy(&vnames);
  igraph_strvector_destroy(&enames);
  return 0;
}","int write_report(igraph_t *VAR_0) {
  printf(""Write report ... \n"");
  char* VAR_1;
  struct stat VAR_2 = {0};
  strcpy(VAR_1, VAR_3);
  strcat(VAR_1, ""REPORT/"");
  char* VAR_4;
  strcpy(VAR_4, VAR_1);
  strcat(VAR_4, ""report.txt"");
  printf(""%s "", VAR_4);
  if (stat(VAR_1, &VAR_2) == -1) {
    mkdir(VAR_1, 0700);
  }
  FILE *VAR_5;
  time_t VAR_6;
  igraph_vector_t VAR_7, VAR_8, VAR_9;
  igraph_strvector_t VAR_10, VAR_11, VAR_12;
  igraph_vector_init(&VAR_7, 0);
  igraph_vector_init(&VAR_8, 0);
  igraph_vector_init(&VAR_9, 0);
  igraph_strvector_init(&VAR_10, 0);
  igraph_strvector_init(&VAR_11, 0);
  igraph_strvector_init(&VAR_12, 0);
  igraph_cattribute_list(&VAR_13, &VAR_10, &VAR_7, &VAR_11, &VAR_8,
			 &VAR_12, &VAR_9);
  VAR_5 = fopen(VAR_4, ""a"");
  VAR_6 = time(NULL);
  fprintf( VAR_5, ""REPORT: %s "", ctime(&VAR_6));
  fprintf( VAR_5, ""-------------------- \n\n"");
  fprintf( VAR_5, ""ORIGINAL GRAPH: *%s.gexf*\n\n"", VAR_14);
  for (int VAR_15=0; VAR_15<igraph_strvector_size(&VAR_10); VAR_15++) {
    fprintf(VAR_5, ""%s : %f \n"", STR(VAR_10, VAR_15), GAN(&VAR_13, STR(VAR_10, VAR_15)));
  }
  /* COMMENT_0 */
  fprintf(VAR_5, ""TRAIT COMPARISON BY FILTERING METHOD \n"");
  fprintf(VAR_5, ""------------------------------------ \n"");
  fprintf(VAR_5, ""Percent Filtered: %-2f\n"", VAR_16);
  fprintf(VAR_5, ""\n| Method          |  Edges   |  Assort |  Dens.  |  Recipr |  C(Deg.)|\n"");
  fprintf(VAR_5, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
  while (VAR_17 != NULL) {
    fprintf(VAR_5,
      ""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
      VAR_17->abbrev, (GAN(&VAR_13, ""EDGES"") - VAR_18->val), (GAN(&VAR_13, ""ASSORTATIVITY"") - VAR_17->val),
      (GAN(&VAR_13, ""DENSITY"") - VAR_19->val) , (GAN(&VAR_13, ""RECIPROCITY"") - VAR_20->val),
      (GAN(&VAR_13, ""centralizationDegree"") - VAR_21->val)
      );
    VAR_17 = VAR_17->next;
    VAR_19 = VAR_19->next;
    VAR_18 = VAR_18->next;
    VAR_20 = VAR_20->next;
    VAR_21 = VAR_21->next;
  }
  fprintf (VAR_5, ""|                 |           |          |          |          |          |\n\n"");

  fprintf(VAR_5, ""\n| Method          |  Diameter|  Pathlen|  Cluster|  C(Betw)|  C(Page)|\n"");
  fprintf(VAR_5, ""|-----------------|-----------|----------|----------|----------|----------|\n"");
  while (VAR_22 != NULL) {
    fprintf(VAR_5,
      ""| %-16s| %-10f|%-10f|%-10f|%-10f|%-10f|\n"",
      VAR_22->abbrev, (GAN(&VAR_13, ""DIAMETER"") - VAR_23->val), (GAN(&VAR_13, ""AVG_PATH_LENGTH"") - VAR_24->val),
      (GAN(&VAR_13, ""OVERALL_CLUSTERING"") - VAR_22->val) , (GAN(&VAR_13, ""centralizationBetweenness"") - VAR_25->val),
      (GAN(&VAR_13, ""centralizationPageRank"") - VAR_26->val)
      );
    VAR_22 = VAR_22->next;
    VAR_23 = VAR_23->next;
    VAR_24 = VAR_24->next;
    VAR_25 = VAR_25->next;
    VAR_26 = VAR_26->next;
  }
  fprintf (VAR_5, ""|                 |           |          |          |          |          |\n\n"");
  fclose(VAR_5);
  igraph_vector_destroy(&VAR_7);
  igraph_vector_destroy(&VAR_8);
  igraph_vector_destroy(&VAR_9);
  igraph_strvector_destroy(&VAR_10);
  igraph_strvector_destroy(&VAR_11);
  igraph_strvector_destroy(&VAR_12);
  return 0;
}",archivesunleashed/graphpass/f407fd23a2d03cd6d1c25da76b1a571126ea8d96/borg-reducer.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,10 +1,10 @@
 int write_report(igraph_t *graph) {
   printf(""Write report ... \n"");
-  char dir[150];
+  char* dir;
   struct stat st = {0};
   strcpy(dir, output);
   strcat(dir, ""REPORT/"");
-  char filepath[150];
+  char* filepath;
   strcpy(filepath, dir);
   strcat(filepath, ""report.txt"");
   printf(""%s "", filepath);","{'deleted_lines': ['  char dir[150];', '  char filepath[150];'], 'added_lines': ['  char* dir;', '  char* filepath;']}",True,borg-reducer c6d5240 is affected by: Buffer Overflow. The impact is: Possible code execution and denial of service. The component is: Output parameter within the executable.,9.8,CRITICAL,3,test,2018-03-04T17:50:25Z,2
CVE-2018-6358,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,libming,"Fix heap buffer overflow in listfdb.c

listfdb reads nGlyphs + 1 glyphs and stores them in an array of size
nGlyphs*sizeof(int), resulting in a heap buffer overflow.

In this commit we replace for(i=0; i<=nGlyphs; ++i)
by for(i=0; i < nGlyphs; ++i) so that only nGlyphs glyphs are read.

This patch addresses CVE-2018-6358 (fixes #104).",cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe,https://github.com/libming/libming/commit/cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe,util/listfdb.c,printDefineFont2,"void printDefineFont2(FILE *f)
{
int flags, nGlyphs, namelen, off, i, fillBits, lineBits;
int here = fileOffset;
unsigned int *offset;
flags = readUInt8(f);
readUInt8(f); 
namelen = readUInt8(f);
printf(""%sFont Name: "", indent());
for(; namelen>0; --namelen)
putchar((unsigned char)readUInt8(f));
putchar('\n');
nGlyphs = readUInt16(f);
printf(""%snumber of glyphs: %i\n\n"", indent(), nGlyphs);
offset = (unsigned int *)malloc(nGlyphs*sizeof(int));
here = fileOffset;
for(i=0; i<=nGlyphs; ++i)
{
if(flags & FONTINFO2_WIDEOFFSETS)
off = readUInt32(f);
else
off = readUInt16(f);
offset[i] = off-nGlyphs*4-4;
printf(""%sOffset%i: %i\n"", indent(), i, offset[i]);
}
here = fileOffset;
for(i=0; i<nGlyphs; ++i)
{
byteAlign();
printf(""%sGlyph %i:\n"", indent(), i);
fillBits = readBits(f, 4);
lineBits = readBits(f, 4);
byteAlign();
while(printShapeRec(f, &fillBits, &lineBits, 2)) ;
putchar('\n');
}
for(i=0; i<nGlyphs; ++i)
{
if(flags & FONTINFO2_WIDECODES)
printf(""%sglyph code %i: %i\n"", indent(), i, readUInt16(f));
else
printf(""%sglyph code %i: %i\n"", indent(), i, readUInt8(f));
}
if(flags & FONTINFO2_HASLAYOUT)
{
int kernCount, code1, code2;
printf(""%sascender height: %i\n"", indent(), readSInt16(f));
printf(""%sdescender height: %i\n"", indent(), readSInt16(f));
printf(""%sleading height: %i\n"", indent(), readSInt16(f));
for(i=0; i<nGlyphs; ++i)
printf(""\tadvance %i: %i\n"", i, readSInt16(f));
for(i=0; i<nGlyphs; ++i)
{
printf(""%sbounds %i: "", indent(), i);
printRect(f);
putchar('\n');
}
kernCount = readUInt16(f);
for(i=0; i<kernCount; ++i)
{
code1 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
code2 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
printf(""%s(%i,%i): adjustment = %i\n"", indent(), code1, code2, readSInt16(f));
}
}
putchar('\n');
}","void printDefineFont2(FILE *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;
int VAR_8 = VAR_9;
unsigned int *VAR_10;
VAR_1 = readUInt8(VAR_0);
readUInt8(VAR_0); 
VAR_3 = readUInt8(VAR_0);
printf(""%sFont Name: "", indent());
for(; VAR_3>0; --VAR_3)
putchar((unsigned char)readUInt8(VAR_0));
putchar('\n');
VAR_2 = readUInt16(VAR_0);
printf(""%snumber of glyphs: %i\n\n"", indent(), VAR_2);
VAR_10 = (unsigned int *)malloc(VAR_2*sizeof(int));
VAR_8 = VAR_9;
for(VAR_5=0; VAR_5<=VAR_2; ++VAR_5)
{
if(VAR_1 & VAR_11)
VAR_4 = readUInt32(VAR_0);
else
VAR_4 = readUInt16(VAR_0);
VAR_10[VAR_5] = VAR_4-VAR_2*4-4;
printf(""%sOffset%i: %i\n"", indent(), VAR_5, VAR_10[VAR_5]);
}
VAR_8 = VAR_9;
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
{
byteAlign();
printf(""%sGlyph %i:\n"", indent(), VAR_5);
VAR_6 = readBits(VAR_0, 4);
VAR_7 = readBits(VAR_0, 4);
byteAlign();
while(printShapeRec(VAR_0, &VAR_6, &VAR_7, 2)) ;
putchar('\n');
}
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
{
if(VAR_1 & VAR_12)
printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt16(VAR_0));
else
printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt8(VAR_0));
}
if(VAR_1 & VAR_13)
{
int VAR_14, VAR_15, VAR_16;
printf(""%sascender height: %i\n"", indent(), readSInt16(VAR_0));
printf(""%sdescender height: %i\n"", indent(), readSInt16(VAR_0));
printf(""%sleading height: %i\n"", indent(), readSInt16(VAR_0));
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
printf(""\tadvance %i: %i\n"", VAR_5, readSInt16(VAR_0));
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
{
printf(""%sbounds %i: "", indent(), VAR_5);
printRect(VAR_0);
putchar('\n');
}
VAR_14 = readUInt16(VAR_0);
for(VAR_5=0; VAR_5<VAR_14; ++VAR_5)
{
VAR_15 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);
VAR_16 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);
printf(""%s(%i,%i): adjustment = %i\n"", indent(), VAR_15, VAR_16, readSInt16(VAR_0));
}
}
putchar('\n');
}",libming/cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe/listfdb.c/vul/before/0.json,"void printDefineFont2(FILE *f)
{
  int flags, nGlyphs, namelen, off, i, fillBits, lineBits;
  int here = fileOffset;
  unsigned int *offset;

  flags = readUInt8(f);

  readUInt8(f); /* ""reserved"" */

  namelen = readUInt8(f);

  printf(""%sFont Name: "", indent());

  for(; namelen>0; --namelen)
    putchar((unsigned char)readUInt8(f));

  putchar('\n');

  nGlyphs = readUInt16(f);
  printf(""%snumber of glyphs: %i\n\n"", indent(), nGlyphs);

  offset = (unsigned int *)malloc(nGlyphs*sizeof(int));

  /* offset table */

  here = fileOffset;

  for(i=0; i<nGlyphs; ++i)
  {
    if(flags & FONTINFO2_WIDEOFFSETS)
      off = readUInt32(f);
    else
      off = readUInt16(f);

    offset[i] = off-nGlyphs*4-4;
    printf(""%sOffset%i: %i\n"", indent(), i, offset[i]);
  }

  here = fileOffset;

  /* shape table */
  for(i=0; i<nGlyphs; ++i)
  {
    byteAlign();
    printf(""%sGlyph %i:\n"", indent(), i);

    fillBits = readBits(f, 4);
    lineBits = readBits(f, 4);

    byteAlign();
    while(printShapeRec(f, &fillBits, &lineBits, 2)) ;

    putchar('\n');
  }

  /* code table */
  for(i=0; i<nGlyphs; ++i)
  {
    if(flags & FONTINFO2_WIDECODES)
      printf(""%sglyph code %i: %i\n"", indent(), i, readUInt16(f));
    else
      printf(""%sglyph code %i: %i\n"", indent(), i, readUInt8(f));
  }

  if(flags & FONTINFO2_HASLAYOUT)
  {
    int kernCount, code1, code2;

    printf(""%sascender height: %i\n"", indent(), readSInt16(f));
    printf(""%sdescender height: %i\n"", indent(), readSInt16(f));
    printf(""%sleading height: %i\n"", indent(), readSInt16(f));

    for(i=0; i<nGlyphs; ++i)
      printf(""\tadvance %i: %i\n"", i, readSInt16(f));

    for(i=0; i<nGlyphs; ++i)
    {
      printf(""%sbounds %i: "", indent(), i);
      printRect(f);
      putchar('\n');
    }

    kernCount = readUInt16(f);

    for(i=0; i<kernCount; ++i)
    {
      code1 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
      code2 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
      printf(""%s(%i,%i): adjustment = %i\n"", indent(), code1, code2, readSInt16(f));
    }
  }

  putchar('\n');
}","void printDefineFont2(FILE *VAR_0)
{
  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;
  int VAR_8 = VAR_9;
  unsigned int *VAR_10;

  VAR_1 = readUInt8(VAR_0);

  readUInt8(VAR_0); /* COMMENT_0 */

  VAR_3 = readUInt8(VAR_0);

  printf(""%sFont Name: "", indent());

  for(; VAR_3>0; --VAR_3)
    putchar((unsigned char)readUInt8(VAR_0));

  putchar('\n');

  VAR_2 = readUInt16(VAR_0);
  printf(""%snumber of glyphs: %i\n\n"", indent(), VAR_2);

  VAR_10 = (unsigned int *)malloc(VAR_2*sizeof(int));

  /* COMMENT_1 */

  VAR_8 = VAR_9;

  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
  {
    if(VAR_1 & VAR_11)
      VAR_4 = readUInt32(VAR_0);
    else
      VAR_4 = readUInt16(VAR_0);

    VAR_10[VAR_5] = VAR_4-VAR_2*4-4;
    printf(""%sOffset%i: %i\n"", indent(), VAR_5, VAR_10[VAR_5]);
  }

  VAR_8 = VAR_9;

  /* COMMENT_2 */
  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
  {
    byteAlign();
    printf(""%sGlyph %i:\n"", indent(), VAR_5);

    VAR_6 = readBits(VAR_0, 4);
    VAR_7 = readBits(VAR_0, 4);

    byteAlign();
    while(printShapeRec(VAR_0, &VAR_6, &VAR_7, 2)) ;

    putchar('\n');
  }

  /* COMMENT_3 */
  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
  {
    if(VAR_1 & VAR_12)
      printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt16(VAR_0));
    else
      printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt8(VAR_0));
  }

  if(VAR_1 & VAR_13)
  {
    int VAR_14, VAR_15, VAR_16;

    printf(""%sascender height: %i\n"", indent(), readSInt16(VAR_0));
    printf(""%sdescender height: %i\n"", indent(), readSInt16(VAR_0));
    printf(""%sleading height: %i\n"", indent(), readSInt16(VAR_0));

    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
      printf(""\tadvance %i: %i\n"", VAR_5, readSInt16(VAR_0));

    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
    {
      printf(""%sbounds %i: "", indent(), VAR_5);
      printRect(VAR_0);
      putchar('\n');
    }

    VAR_14 = readUInt16(VAR_0);

    for(VAR_5=0; VAR_5<VAR_14; ++VAR_5)
    {
      VAR_15 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);
      VAR_16 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);
      printf(""%s(%i,%i): adjustment = %i\n"", indent(), VAR_15, VAR_16, readSInt16(VAR_0));
    }
  }

  putchar('\n');
}",libming/cff9a3bd2c428ad0cd8c8deb538031e11f29a0fe/listfdb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,7 +26,7 @@
 
   here = fileOffset;
 
-  for(i=0; i<=nGlyphs; ++i)
+  for(i=0; i<nGlyphs; ++i)
   {
     if(flags & FONTINFO2_WIDEOFFSETS)
       off = readUInt32(f);","{'deleted_lines': ['  for(i=0; i<=nGlyphs; ++i)'], 'added_lines': ['  for(i=0; i<nGlyphs; ++i)']}",True,"The printDefineFont2 function (util/listfdb.c) in libming through 0.4.8 is vulnerable to a heap-based buffer overflow, which may allow attackers to cause a denial of service or unspecified other impact via a crafted FDB file.",8.8,HIGH,2,test,2018-03-11T20:58:51Z,2
CVE-2018-6358,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,libming,"Fix various compiler warnings.

Remove useless variables blockstart, blockoffset and here.",03498cf4e0319d8836aba96ce8a817beaabb441e,https://github.com/libming/libming/commit/03498cf4e0319d8836aba96ce8a817beaabb441e,util/listfdb.c,printDefineFont2,"void printDefineFont2(FILE *f)
{
int flags, nGlyphs, namelen, off, i, fillBits, lineBits;
int here = fileOffset;
unsigned int *offset;
flags = readUInt8(f);
readUInt8(f); 
namelen = readUInt8(f);
printf(""%sFont Name: "", indent());
for(; namelen>0; --namelen)
putchar((unsigned char)readUInt8(f));
putchar('\n');
nGlyphs = readUInt16(f);
printf(""%snumber of glyphs: %i\n\n"", indent(), nGlyphs);
offset = (unsigned int *)malloc(nGlyphs*sizeof(int));
here = fileOffset;
for(i=0; i<nGlyphs; ++i)
{
if(flags & FONTINFO2_WIDEOFFSETS)
off = readUInt32(f);
else
off = readUInt16(f);
offset[i] = off-nGlyphs*4-4;
printf(""%sOffset%i: %i\n"", indent(), i, offset[i]);
}
here = fileOffset;
for(i=0; i<nGlyphs; ++i)
{
byteAlign();
printf(""%sGlyph %i:\n"", indent(), i);
fillBits = readBits(f, 4);
lineBits = readBits(f, 4);
byteAlign();
while(printShapeRec(f, &fillBits, &lineBits, 2)) ;
putchar('\n');
}
for(i=0; i<nGlyphs; ++i)
{
if(flags & FONTINFO2_WIDECODES)
printf(""%sglyph code %i: %i\n"", indent(), i, readUInt16(f));
else
printf(""%sglyph code %i: %i\n"", indent(), i, readUInt8(f));
}
if(flags & FONTINFO2_HASLAYOUT)
{
int kernCount, code1, code2;
printf(""%sascender height: %i\n"", indent(), readSInt16(f));
printf(""%sdescender height: %i\n"", indent(), readSInt16(f));
printf(""%sleading height: %i\n"", indent(), readSInt16(f));
for(i=0; i<nGlyphs; ++i)
printf(""\tadvance %i: %i\n"", i, readSInt16(f));
for(i=0; i<nGlyphs; ++i)
{
printf(""%sbounds %i: "", indent(), i);
printRect(f);
putchar('\n');
}
kernCount = readUInt16(f);
for(i=0; i<kernCount; ++i)
{
code1 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
code2 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
printf(""%s(%i,%i): adjustment = %i\n"", indent(), code1, code2, readSInt16(f));
}
}
putchar('\n');
}","void printDefineFont2(FILE *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;
int VAR_8 = VAR_9;
unsigned int *VAR_10;
VAR_1 = readUInt8(VAR_0);
readUInt8(VAR_0); 
VAR_3 = readUInt8(VAR_0);
printf(""%sFont Name: "", indent());
for(; VAR_3>0; --VAR_3)
putchar((unsigned char)readUInt8(VAR_0));
putchar('\n');
VAR_2 = readUInt16(VAR_0);
printf(""%snumber of glyphs: %i\n\n"", indent(), VAR_2);
VAR_10 = (unsigned int *)malloc(VAR_2*sizeof(int));
VAR_8 = VAR_9;
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
{
if(VAR_1 & VAR_11)
VAR_4 = readUInt32(VAR_0);
else
VAR_4 = readUInt16(VAR_0);
VAR_10[VAR_5] = VAR_4-VAR_2*4-4;
printf(""%sOffset%i: %i\n"", indent(), VAR_5, VAR_10[VAR_5]);
}
VAR_8 = VAR_9;
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
{
byteAlign();
printf(""%sGlyph %i:\n"", indent(), VAR_5);
VAR_6 = readBits(VAR_0, 4);
VAR_7 = readBits(VAR_0, 4);
byteAlign();
while(printShapeRec(VAR_0, &VAR_6, &VAR_7, 2)) ;
putchar('\n');
}
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
{
if(VAR_1 & VAR_12)
printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt16(VAR_0));
else
printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt8(VAR_0));
}
if(VAR_1 & VAR_13)
{
int VAR_14, VAR_15, VAR_16;
printf(""%sascender height: %i\n"", indent(), readSInt16(VAR_0));
printf(""%sdescender height: %i\n"", indent(), readSInt16(VAR_0));
printf(""%sleading height: %i\n"", indent(), readSInt16(VAR_0));
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
printf(""\tadvance %i: %i\n"", VAR_5, readSInt16(VAR_0));
for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
{
printf(""%sbounds %i: "", indent(), VAR_5);
printRect(VAR_0);
putchar('\n');
}
VAR_14 = readUInt16(VAR_0);
for(VAR_5=0; VAR_5<VAR_14; ++VAR_5)
{
VAR_15 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);
VAR_16 = (VAR_1 & VAR_12) ? readUInt16(VAR_0) : readUInt8(VAR_0);
printf(""%s(%i,%i): adjustment = %i\n"", indent(), VAR_15, VAR_16, readSInt16(VAR_0));
}
}
putchar('\n');
}",libming/03498cf4e0319d8836aba96ce8a817beaabb441e/listfdb.c/vul/before/0.json,"void printDefineFont2(FILE *f)
{
  int flags, nGlyphs, namelen, off, i, fillBits, lineBits;
  unsigned int *offset;

  flags = readUInt8(f);

  readUInt8(f); /* ""reserved"" */

  namelen = readUInt8(f);

  printf(""%sFont Name: "", indent());

  for(; namelen>0; --namelen)
    putchar((unsigned char)readUInt8(f));

  putchar('\n');

  nGlyphs = readUInt16(f);
  printf(""%snumber of glyphs: %i\n\n"", indent(), nGlyphs);

  offset = (unsigned int *)malloc(nGlyphs*sizeof(int));

  /* offset table */

  for(i=0; i<nGlyphs; ++i)
  {
    if(flags & FONTINFO2_WIDEOFFSETS)
      off = readUInt32(f);
    else
      off = readUInt16(f);

    offset[i] = off-nGlyphs*4-4;
    printf(""%sOffset%i: %i\n"", indent(), i, offset[i]);
  }

  /* shape table */
  for(i=0; i<nGlyphs; ++i)
  {
    byteAlign();
    printf(""%sGlyph %i:\n"", indent(), i);

    fillBits = readBits(f, 4);
    lineBits = readBits(f, 4);

    byteAlign();
    while(printShapeRec(f, &fillBits, &lineBits, 2)) ;

    putchar('\n');
  }

  /* code table */
  for(i=0; i<nGlyphs; ++i)
  {
    if(flags & FONTINFO2_WIDECODES)
      printf(""%sglyph code %i: %i\n"", indent(), i, readUInt16(f));
    else
      printf(""%sglyph code %i: %i\n"", indent(), i, readUInt8(f));
  }

  if(flags & FONTINFO2_HASLAYOUT)
  {
    int kernCount, code1, code2;

    printf(""%sascender height: %i\n"", indent(), readSInt16(f));
    printf(""%sdescender height: %i\n"", indent(), readSInt16(f));
    printf(""%sleading height: %i\n"", indent(), readSInt16(f));

    for(i=0; i<nGlyphs; ++i)
      printf(""\tadvance %i: %i\n"", i, readSInt16(f));

    for(i=0; i<nGlyphs; ++i)
    {
      printf(""%sbounds %i: "", indent(), i);
      printRect(f);
      putchar('\n');
    }

    kernCount = readUInt16(f);

    for(i=0; i<kernCount; ++i)
    {
      code1 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
      code2 = (flags & FONTINFO2_WIDECODES) ? readUInt16(f) : readUInt8(f);
      printf(""%s(%i,%i): adjustment = %i\n"", indent(), code1, code2, readSInt16(f));
    }
  }

  putchar('\n');
}","void printDefineFont2(FILE *VAR_0)
{
  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;
  unsigned int *VAR_8;

  VAR_1 = readUInt8(VAR_0);

  readUInt8(VAR_0); /* COMMENT_0 */

  VAR_3 = readUInt8(VAR_0);

  printf(""%sFont Name: "", indent());

  for(; VAR_3>0; --VAR_3)
    putchar((unsigned char)readUInt8(VAR_0));

  putchar('\n');

  VAR_2 = readUInt16(VAR_0);
  printf(""%snumber of glyphs: %i\n\n"", indent(), VAR_2);

  VAR_8 = (unsigned int *)malloc(VAR_2*sizeof(int));

  /* COMMENT_1 */

  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
  {
    if(VAR_1 & VAR_9)
      VAR_4 = readUInt32(VAR_0);
    else
      VAR_4 = readUInt16(VAR_0);

    VAR_8[VAR_5] = VAR_4-VAR_2*4-4;
    printf(""%sOffset%i: %i\n"", indent(), VAR_5, VAR_8[VAR_5]);
  }

  /* COMMENT_2 */
  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
  {
    byteAlign();
    printf(""%sGlyph %i:\n"", indent(), VAR_5);

    VAR_6 = readBits(VAR_0, 4);
    VAR_7 = readBits(VAR_0, 4);

    byteAlign();
    while(printShapeRec(VAR_0, &VAR_6, &VAR_7, 2)) ;

    putchar('\n');
  }

  /* COMMENT_3 */
  for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
  {
    if(VAR_1 & VAR_10)
      printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt16(VAR_0));
    else
      printf(""%sglyph code %i: %i\n"", indent(), VAR_5, readUInt8(VAR_0));
  }

  if(VAR_1 & VAR_11)
  {
    int VAR_12, VAR_13, VAR_14;

    printf(""%sascender height: %i\n"", indent(), readSInt16(VAR_0));
    printf(""%sdescender height: %i\n"", indent(), readSInt16(VAR_0));
    printf(""%sleading height: %i\n"", indent(), readSInt16(VAR_0));

    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
      printf(""\tadvance %i: %i\n"", VAR_5, readSInt16(VAR_0));

    for(VAR_5=0; VAR_5<VAR_2; ++VAR_5)
    {
      printf(""%sbounds %i: "", indent(), VAR_5);
      printRect(VAR_0);
      putchar('\n');
    }

    VAR_12 = readUInt16(VAR_0);

    for(VAR_5=0; VAR_5<VAR_12; ++VAR_5)
    {
      VAR_13 = (VAR_1 & VAR_10) ? readUInt16(VAR_0) : readUInt8(VAR_0);
      VAR_14 = (VAR_1 & VAR_10) ? readUInt16(VAR_0) : readUInt8(VAR_0);
      printf(""%s(%i,%i): adjustment = %i\n"", indent(), VAR_13, VAR_14, readSInt16(VAR_0));
    }
  }

  putchar('\n');
}",libming/03498cf4e0319d8836aba96ce8a817beaabb441e/listfdb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,6 @@
 void printDefineFont2(FILE *f)
 {
   int flags, nGlyphs, namelen, off, i, fillBits, lineBits;
-  int here = fileOffset;
   unsigned int *offset;
 
   flags = readUInt8(f);
@@ -24,8 +23,6 @@
 
   /* offset table */
 
-  here = fileOffset;
-
   for(i=0; i<nGlyphs; ++i)
   {
     if(flags & FONTINFO2_WIDEOFFSETS)
@@ -36,8 +33,6 @@
     offset[i] = off-nGlyphs*4-4;
     printf(""%sOffset%i: %i\n"", indent(), i, offset[i]);
   }
-
-  here = fileOffset;
 
   /* shape table */
   for(i=0; i<nGlyphs; ++i)","{'deleted_lines': ['  int here = fileOffset;', '  here = fileOffset;', '', '', '  here = fileOffset;'], 'added_lines': []}",True,"The printDefineFont2 function (util/listfdb.c) in libming through 0.4.8 is vulnerable to a heap-based buffer overflow, which may allow attackers to cause a denial of service or unspecified other impact via a crafted FDB file.",8.8,HIGH,2,test,2018-03-11T21:18:39Z,2
CVE-2018-6358,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,libming,"Fix various compiler warnings.

Remove useless variables blockstart, blockoffset and here.",03498cf4e0319d8836aba96ce8a817beaabb441e,https://github.com/libming/libming/commit/03498cf4e0319d8836aba96ce8a817beaabb441e,util/main.c,readMovie,"static void readMovie(FILE *f)
{
int block, type, blockstart, blockoffset, length, nextFrame=0;
SWF_Parserstruct *blockp;
for (;;)
{
blockoffset = fileOffset;
if(filelen_check_fails(2))
break;
block = readUInt16 (f);
type = block >> 6;
length = block & ((1 << 6) - 1);
if (length == 63) 
{
if(filelen_check_fails(4))
break;
unsigned long real_length = readUInt32 (f);
if (real_length > INT_MAX) {
SWF_warn("" Could not process long block with length %lu:""
"" blocks with length > %d not supported on this system\n"",
real_length, INT_MAX);
continue;
} else {
length = (int) real_length;
}
}
blockstart = fileOffset;
nextFrame = fileOffset+length;
if(filelen_check_fails(length))
break;
blockp= blockParse(f, length, type);
if( ftell(f) != nextFrame ) 
{
SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
"" %ld but expecting %d.\n"", type, blockName(type),
ftell(f),nextFrame);
}
if( blockp ) 
{
outputBlock( type, blockp, f);
free(blockp);
} else {
SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
type, length);
}
if (type == 0 || fileOffset >= m.size)
break;
fseek(f, nextFrame, SEEK_SET);
fileOffset = ftell(f);
}
putchar ('\n');
if (fileOffset < m.size)
{
SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
dumpBytes (f, m.size - fileOffset);
printf (""\n\n"");
}
outputTrailer(&m);
}","static void readMovie(FILE *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6=0;
SWF_Parserstruct *VAR_7;
for (;;)
{
VAR_4 = VAR_8;
if(filelen_check_fails(2))
break;
VAR_1 = readUInt16 (VAR_0);
VAR_2 = VAR_1 >> 6;
VAR_5 = VAR_1 & ((1 << 6) - 1);
if (VAR_5 == 63) 
{
if(filelen_check_fails(4))
break;
unsigned long VAR_9 = readUInt32 (VAR_0);
if (VAR_9 > VAR_10) {
SWF_warn("" Could not process long block with length %lu:""
"" blocks with length > %d not supported on this system\n"",
VAR_9, VAR_10);
continue;
} else {
VAR_5 = (int) VAR_9;
}
}
VAR_3 = VAR_8;
VAR_6 = VAR_8+VAR_5;
if(filelen_check_fails(VAR_5))
break;
VAR_7= blockParse(VAR_0, VAR_5, VAR_2);
if( ftell(VAR_0) != VAR_6 ) 
{
SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
"" %ld but expecting %d.\n"", VAR_2, blockName(VAR_2),
ftell(VAR_0),VAR_6);
}
if( VAR_7 ) 
{
outputBlock( VAR_2, VAR_7, VAR_0);
free(VAR_7);
} else {
SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
VAR_2, VAR_5);
}
if (VAR_2 == 0 || VAR_8 >= VAR_11.size)
break;
fseek(VAR_0, VAR_6, VAR_12);
VAR_8 = ftell(VAR_0);
}
putchar ('\n');
if (VAR_8 < VAR_11.size)
{
SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
dumpBytes (VAR_0, VAR_11.size - VAR_8);
printf (""\n\n"");
}
outputTrailer(&VAR_11);
}",libming/03498cf4e0319d8836aba96ce8a817beaabb441e/main.c/vul/before/0.json,"static void readMovie(FILE *f)
{
	int block, type, length, nextFrame=0;
	SWF_Parserstruct *blockp;
	for (;;)
	{
		if(filelen_check_fails(2))
			break;
		block = readUInt16 (f);
		type = block >> 6;

		length = block & ((1 << 6) - 1);

		if (length == 63)		/* it's a long block. */ 
		{
			if(filelen_check_fails(4))
				break;
			unsigned long real_length = readUInt32 (f);

                        if (real_length > INT_MAX) {
		            SWF_warn("" Could not process long block with length %lu:""
                                     "" blocks with length > %d not supported on this system\n"",
                                     real_length, INT_MAX);
                            continue;
                        } else {
                            length = (int) real_length;
                        }
		}
		
		//      printf (""Found Block: %s (%i), %i bytes\n"", blockName (type), type, length);
		nextFrame = fileOffset+length;
		
		if(filelen_check_fails(length))
			break;
		blockp= blockParse(f, length, type);

		if( ftell(f) != nextFrame ) 
		{
			// will SEEK_SET later, so this is not a critical error
		        SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
				"" %ld but expecting %d.\n"", type, blockName(type),
				ftell(f),nextFrame);
		}

		if( blockp ) 
		{
			outputBlock( type, blockp, f);
			free(blockp);	
		} else {
			SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
				type, length);
		}

		if (type == 0 || fileOffset >= m.size)
			break;
	
		fseek(f, nextFrame, SEEK_SET);
		fileOffset = ftell(f);
	}
	putchar ('\n');

	if (fileOffset < m.size)
	{
		SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
		dumpBytes (f, m.size - fileOffset);
		printf (""\n\n"");
	}
	outputTrailer(&m);
}","static void readMovie(FILE *VAR_0)
{
	int VAR_1, VAR_2, VAR_3, VAR_4=0;
	SWF_Parserstruct *VAR_5;
	for (;;)
	{
		if(filelen_check_fails(2))
			break;
		VAR_1 = readUInt16 (VAR_0);
		VAR_2 = VAR_1 >> 6;

		VAR_3 = VAR_1 & ((1 << 6) - 1);

		if (VAR_3 == 63)		/* COMMENT_0 */ 
		{
			if(filelen_check_fails(4))
				break;
			unsigned long VAR_6 = readUInt32 (VAR_0);

                        if (VAR_6 > VAR_7) {
		            SWF_warn("" Could not process long block with length %lu:""
                                     "" blocks with length > %d not supported on this system\n"",
                                     VAR_6, VAR_7);
                            continue;
                        } else {
                            VAR_3 = (int) VAR_6;
                        }
		}
		
		/* COMMENT_1 */
		VAR_4 = VAR_8+VAR_3;
		
		if(filelen_check_fails(VAR_3))
			break;
		VAR_5= blockParse(VAR_0, VAR_3, VAR_2);

		if( ftell(VAR_0) != VAR_4 ) 
		{
			/* COMMENT_2 */
		        SWF_warn("" Stream out of sync after parse of blocktype %d (%s).""
				"" %ld but expecting %d.\n"", VAR_2, blockName(VAR_2),
				ftell(VAR_0),VAR_4);
		}

		if( VAR_5 ) 
		{
			outputBlock( VAR_2, VAR_5, VAR_0);
			free(VAR_5);	
		} else {
			SWF_warn(""Error parsing block (unknown block type: %d, length %d)\n"", 
				VAR_2, VAR_3);
		}

		if (VAR_2 == 0 || VAR_8 >= VAR_9.size)
			break;
	
		fseek(VAR_0, VAR_4, VAR_10);
		VAR_8 = ftell(VAR_0);
	}
	putchar ('\n');

	if (VAR_8 < VAR_9.size)
	{
		SWF_warn(""extra garbage (i.e., we messed up in main): \n"");
		dumpBytes (VAR_0, VAR_9.size - VAR_8);
		printf (""\n\n"");
	}
	outputTrailer(&VAR_9);
}",libming/03498cf4e0319d8836aba96ce8a817beaabb441e/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,13 +1,9 @@
 static void readMovie(FILE *f)
 {
-	int block, type, blockstart, blockoffset, length, nextFrame=0;
+	int block, type, length, nextFrame=0;
 	SWF_Parserstruct *blockp;
 	for (;;)
 	{
-		blockoffset = fileOffset;
-
-		// printf (""Block offset: %d %d\n"", fileOffset, m.size);
-
 		if(filelen_check_fails(2))
 			break;
 		block = readUInt16 (f);
@@ -32,7 +28,6 @@
 		}
 		
 		//      printf (""Found Block: %s (%i), %i bytes\n"", blockName (type), type, length);
-		blockstart = fileOffset;
 		nextFrame = fileOffset+length;
 		
 		if(filelen_check_fails(length))","{'deleted_lines': ['\tint block, type, blockstart, blockoffset, length, nextFrame=0;', '\t\tblockoffset = fileOffset;', '', '\t\t// printf (""Block offset: %d %d\\n"", fileOffset, m.size);', '', '\t\tblockstart = fileOffset;'], 'added_lines': ['\tint block, type, length, nextFrame=0;']}",True,"The printDefineFont2 function (util/listfdb.c) in libming through 0.4.8 is vulnerable to a heap-based buffer overflow, which may allow attackers to cause a denial of service or unspecified other impact via a crafted FDB file.",8.8,HIGH,2,test,2018-03-11T21:18:39Z,2
CVE-2018-7725,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,gdraheim/zziplib,check zlib space to be within buffer #39,1ba660b3300d67b8ce9f6b96bbae0b36fa2d6b06,https://github.com/gdraheim/zziplib/commit/1ba660b3300d67b8ce9f6b96bbae0b36fa2d6b06,zzip/memdisk.c,zzip_mem_entry_fopen,"zzip__new__ ZZIP_MEM_DISK_FILE *
zzip_mem_entry_fopen(ZZIP_MEM_DISK * dir, ZZIP_MEM_ENTRY * entry)
{
ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_MEM_DISK_FILE));
if (! file)
return file;
file->buffer = dir->disk->buffer;
file->endbuf = dir->disk->endbuf;
file->avail = zzip_mem_entry_usize(entry);
if (! file->avail || zzip_mem_entry_data_stored(entry))
{ file->stored = zzip_mem_entry_to_data (entry); return file; }
file->stored = 0;
file->zlib.opaque = 0;
file->zlib.zalloc = Z_NULL;
file->zlib.zfree = Z_NULL;
file->zlib.avail_in = zzip_mem_entry_csize(entry);
file->zlib.next_in = zzip_mem_entry_to_data(entry);
if (! zzip_mem_entry_data_deflated(entry) ||
inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
{ free (file); return 0; }
return file;
}","zzip__new__ VAR_0 *
zzip_mem_entry_fopen(ZZIP_MEM_DISK * VAR_1, ZZIP_MEM_ENTRY * VAR_2)
{
ZZIP_DISK_FILE *VAR_3 = malloc(sizeof(VAR_0));
if (! VAR_3)
return VAR_3;
VAR_3->buffer = VAR_1->disk->buffer;
VAR_3->endbuf = VAR_1->disk->endbuf;
VAR_3->avail = zzip_mem_entry_usize(VAR_2);
if (! VAR_3->avail || zzip_mem_entry_data_stored(VAR_2))
{ VAR_3->stored = zzip_mem_entry_to_data (VAR_2); return VAR_3; }
VAR_3->stored = 0;
VAR_3->zlib.opaque = 0;
VAR_3->zlib.zalloc = VAR_4;
VAR_3->zlib.zfree = VAR_4;
VAR_3->zlib.avail_in = zzip_mem_entry_csize(VAR_2);
VAR_3->zlib.next_in = zzip_mem_entry_to_data(VAR_2);
if (! zzip_mem_entry_data_deflated(VAR_2) ||
inflateInit2(&VAR_3->zlib, -VAR_5) != VAR_6)
{ free (VAR_3); return 0; }
return VAR_3;
}",,"zzip__new__ ZZIP_MEM_DISK_FILE *
zzip_mem_entry_fopen(ZZIP_MEM_DISK * dir, ZZIP_MEM_ENTRY * entry)
{
    /* keep this in sync with zzip_disk_entry_fopen */
    ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_MEM_DISK_FILE));
    if (! file)
        return file;
    file->buffer = dir->disk->buffer;
    file->endbuf = dir->disk->endbuf;
    file->avail = zzip_mem_entry_usize(entry);

    if (! file->avail || zzip_mem_entry_data_stored(entry))
        { file->stored = zzip_mem_entry_to_data (entry); return file; }

    file->stored = 0;
    file->zlib.opaque = 0;
    file->zlib.zalloc = Z_NULL;
    file->zlib.zfree = Z_NULL;
    file->zlib.avail_in = zzip_mem_entry_csize(entry);
    file->zlib.next_in = zzip_mem_entry_to_data(entry);

    debug2(""compressed size %i"", (int) file->zlib.avail_in);
    if (file->zlib.next_in + file->zlib.avail_in >= file->endbuf)
         goto error;
    if (file->zlib.next_in < file->buffer)
         goto error;

    if (! zzip_mem_entry_data_deflated(entry) ||
        inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
        { free (file); return 0; }

    return file;
error:
    errno = EBADMSG;
    return NULL;
}","zzip__new__ VAR_0 *
zzip_mem_entry_fopen(ZZIP_MEM_DISK * VAR_1, ZZIP_MEM_ENTRY * VAR_2)
{
    /* COMMENT_0 */
    ZZIP_DISK_FILE *VAR_3 = malloc(sizeof(VAR_0));
    if (! VAR_3)
        return VAR_3;
    VAR_3->buffer = VAR_1->disk->buffer;
    VAR_3->endbuf = VAR_1->disk->endbuf;
    VAR_3->avail = zzip_mem_entry_usize(VAR_2);

    if (! VAR_3->avail || zzip_mem_entry_data_stored(VAR_2))
        { VAR_3->stored = zzip_mem_entry_to_data (VAR_2); return VAR_3; }

    VAR_3->stored = 0;
    VAR_3->zlib.opaque = 0;
    VAR_3->zlib.zalloc = VAR_4;
    VAR_3->zlib.zfree = VAR_4;
    VAR_3->zlib.avail_in = zzip_mem_entry_csize(VAR_2);
    VAR_3->zlib.next_in = zzip_mem_entry_to_data(VAR_2);

    debug2(""compressed size %i"", (int) VAR_3->zlib.avail_in);
    if (VAR_3->zlib.next_in + VAR_3->zlib.avail_in >= VAR_3->endbuf)
         goto error;
    if (VAR_3->zlib.next_in < VAR_3->buffer)
         goto error;

    if (! zzip_mem_entry_data_deflated(VAR_2) ||
        inflateInit2(&VAR_3->zlib, -VAR_5) != VAR_6)
        { free (VAR_3); return 0; }

    return VAR_3;
error:
    VAR_7 = VAR_8;
    return NULL;
}",,"--- func_before
+++ func_after
@@ -19,9 +19,18 @@
     file->zlib.avail_in = zzip_mem_entry_csize(entry);
     file->zlib.next_in = zzip_mem_entry_to_data(entry);
 
+    debug2(""compressed size %i"", (int) file->zlib.avail_in);
+    if (file->zlib.next_in + file->zlib.avail_in >= file->endbuf)
+         goto error;
+    if (file->zlib.next_in < file->buffer)
+         goto error;
+
     if (! zzip_mem_entry_data_deflated(entry) ||
         inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
         { free (file); return 0; }
 
     return file;
+error:
+    errno = EBADMSG;
+    return NULL;
 }","{'deleted_lines': [], 'added_lines': ['    debug2(""compressed size %i"", (int) file->zlib.avail_in);', '    if (file->zlib.next_in + file->zlib.avail_in >= file->endbuf)', '         goto error;', '    if (file->zlib.next_in < file->buffer)', '         goto error;', '', 'error:', '    errno = EBADMSG;', '    return NULL;']}",True,"An issue was discovered in ZZIPlib 0.13.68. An invalid memory address dereference was discovered in zzip_disk_fread in mmapped.c. The vulnerability causes an application crash, which leads to denial of service.",6.5,MEDIUM,1,test,2018-03-13T00:29:44Z,2
CVE-2018-7725,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,gdraheim/zziplib,check zlib space to be within buffer #39,1ba660b3300d67b8ce9f6b96bbae0b36fa2d6b06,https://github.com/gdraheim/zziplib/commit/1ba660b3300d67b8ce9f6b96bbae0b36fa2d6b06,zzip/mmapped.c,zzip_disk_entry_fopen,"zzip__new__ ZZIP_DISK_FILE *
zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
{
struct zzip_file_header *header =
zzip_disk_entry_to_file_header(disk, entry);
if (! header)
return 0; 
___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));
if (! file)
return 0; 
file->buffer = disk->buffer;
file->endbuf = disk->endbuf;
file->avail = zzip_file_header_usize(header);
if (! file->avail || zzip_file_header_data_stored(header))
{ 
file->stored = zzip_file_header_to_data (header);
DBG2(""stored size %i"", (int) file->avail);
if (file->stored + file->avail >= disk->endbuf)
goto error;
return file; 
}
file->stored = 0;
file->zlib.opaque = 0;
file->zlib.zalloc = Z_NULL;
file->zlib.zfree = Z_NULL;
file->zlib.avail_in = zzip_file_header_csize(header);
file->zlib.next_in = zzip_file_header_to_data(header);
DBG2(""compressed size %i"", (int) file->zlib.avail_in);
if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)
goto error;
if (! zzip_file_header_data_deflated(header))
goto error;
if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
goto error;
return file;
error:
free (file);
errno = EBADMSG;
return 0; 
____;
}","zzip__new__ VAR_0 *
zzip_disk_entry_fopen(ZZIP_DISK * VAR_1, ZZIP_DISK_ENTRY * VAR_2)
{
struct zzip_file_header *VAR_3 =
zzip_disk_entry_to_file_header(VAR_1, VAR_2);
if (! VAR_3)
return 0; 
___ VAR_0 *VAR_4 = malloc(sizeof(VAR_0));
if (! VAR_4)
return 0; 
VAR_4->buffer = VAR_1->buffer;
VAR_4->endbuf = VAR_1->endbuf;
VAR_4->avail = zzip_file_header_usize(VAR_3);
if (! VAR_4->avail || zzip_file_header_data_stored(VAR_3))
{ 
VAR_4->stored = zzip_file_header_to_data (VAR_3);
DBG2(""stored size %i"", (int) VAR_4->avail);
if (VAR_4->stored + VAR_4->avail >= VAR_1->endbuf)
goto error;
return VAR_4; 
}
VAR_4->stored = 0;
VAR_4->zlib.opaque = 0;
VAR_4->zlib.zalloc = VAR_5;
VAR_4->zlib.zfree = VAR_5;
VAR_4->zlib.avail_in = zzip_file_header_csize(VAR_3);
VAR_4->zlib.next_in = zzip_file_header_to_data(VAR_3);
DBG2(""compressed size %i"", (int) VAR_4->zlib.avail_in);
if (VAR_4->zlib.next_in + VAR_4->zlib.avail_in >= VAR_1->endbuf)
goto error;
if (! zzip_file_header_data_deflated(VAR_3))
goto error;
if (inflateInit2(&VAR_4->zlib, -VAR_6) != VAR_7)
goto error;
return VAR_4;
error:
free (VAR_4);
VAR_8 = VAR_9;
return 0; 
VAR_10;
}",,"zzip__new__ ZZIP_DISK_FILE *
zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry)
{
    /* keep this in sync with zzip_mem_entry_fopen */
    struct zzip_file_header *header =
        zzip_disk_entry_to_file_header(disk, entry);
    if (! header)
        return 0; /* EBADMSG */
    ___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE));
    if (! file)
        return 0; /* ENOMEM */
    file->buffer = disk->buffer;
    file->endbuf = disk->endbuf;
    file->avail = zzip_file_header_usize(header);

    if (! file->avail || zzip_file_header_data_stored(header))
    { 
         file->stored = zzip_file_header_to_data (header);
         DBG2(""stored size %i"", (int) file->avail);
         if (file->stored + file->avail >= disk->endbuf)
             goto error;
         return file; 
    }

    file->stored = 0;
    file->zlib.opaque = 0;
    file->zlib.zalloc = Z_NULL;
    file->zlib.zfree = Z_NULL;
    file->zlib.avail_in = zzip_file_header_csize(header);
    file->zlib.next_in = zzip_file_header_to_data(header);

    DBG2(""compressed size %i"", (int) file->zlib.avail_in);
    if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)
         goto error;
    if (file->zlib.next_in < disk->buffer)
         goto error;

    if (! zzip_file_header_data_deflated(header))
        goto error;
    if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
        goto error;

    return file;
error:
    free (file);
    errno = EBADMSG;
    return 0; 
    ____;
}","zzip__new__ VAR_0 *
zzip_disk_entry_fopen(ZZIP_DISK * VAR_1, ZZIP_DISK_ENTRY * VAR_2)
{
    /* COMMENT_0 */
    struct zzip_file_header *VAR_3 =
        zzip_disk_entry_to_file_header(VAR_1, VAR_2);
    if (! VAR_3)
        return 0; /* COMMENT_1 */
    ___ VAR_0 *VAR_4 = malloc(sizeof(VAR_0));
    if (! VAR_4)
        return 0; /* COMMENT_2 */
    VAR_4->buffer = VAR_1->buffer;
    VAR_4->endbuf = VAR_1->endbuf;
    VAR_4->avail = zzip_file_header_usize(VAR_3);

    if (! VAR_4->avail || zzip_file_header_data_stored(VAR_3))
    { 
         VAR_4->stored = zzip_file_header_to_data (VAR_3);
         DBG2(""stored size %i"", (int) VAR_4->avail);
         if (VAR_4->stored + VAR_4->avail >= VAR_1->endbuf)
             goto error;
         return VAR_4; 
    }

    VAR_4->stored = 0;
    VAR_4->zlib.opaque = 0;
    VAR_4->zlib.zalloc = VAR_5;
    VAR_4->zlib.zfree = VAR_5;
    VAR_4->zlib.avail_in = zzip_file_header_csize(VAR_3);
    VAR_4->zlib.next_in = zzip_file_header_to_data(VAR_3);

    DBG2(""compressed size %i"", (int) VAR_4->zlib.avail_in);
    if (VAR_4->zlib.next_in + VAR_4->zlib.avail_in >= VAR_1->endbuf)
         goto error;
    if (VAR_4->zlib.next_in < VAR_1->buffer)
         goto error;

    if (! zzip_file_header_data_deflated(VAR_3))
        goto error;
    if (inflateInit2(&VAR_4->zlib, -VAR_6) != VAR_7)
        goto error;

    return VAR_4;
error:
    free (VAR_4);
    VAR_8 = VAR_9;
    return 0; 
    VAR_10;
}",,"--- func_before
+++ func_after
@@ -32,6 +32,8 @@
     DBG2(""compressed size %i"", (int) file->zlib.avail_in);
     if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf)
          goto error;
+    if (file->zlib.next_in < disk->buffer)
+         goto error;
 
     if (! zzip_file_header_data_deflated(header))
         goto error;","{'deleted_lines': [], 'added_lines': ['    if (file->zlib.next_in < disk->buffer)', '         goto error;']}",True,"An issue was discovered in ZZIPlib 0.13.68. An invalid memory address dereference was discovered in zzip_disk_fread in mmapped.c. The vulnerability causes an application crash, which leads to denial of service.",6.5,MEDIUM,1,test,2018-03-13T00:29:44Z,2
CVE-2019-16921,['CWE-665'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,torvalds/linux,"RDMA/hns: Fix init resp when alloc ucontext

The data in resp will be copied from kernel to userspace, thus it needs to
be initialized to zeros to avoid copying uninited stack memory.

Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
Fixes: e088a685eae9 (""RDMA/hns: Support rq record doorbell for the user space"")
Signed-off-by: Yixian Liu <liuyixian@huawei.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>",df7e40425813c50cd252e6f5e348a81ef1acae56,https://github.com/torvalds/linux/commit/df7e40425813c50cd252e6f5e348a81ef1acae56,drivers/infiniband/hw/hns/hns_roce_main.c,hns_roce_alloc_ucontext,"static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,
struct ib_udata *udata)
{
int ret = 0;
struct hns_roce_ucontext *context;
struct hns_roce_ib_alloc_ucontext_resp resp;
struct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);
resp.qp_tab_size = hr_dev->caps.num_qps;
context = kmalloc(sizeof(*context), GFP_KERNEL);
if (!context)
return ERR_PTR(-ENOMEM);
ret = hns_roce_uar_alloc(hr_dev, &context->uar);
if (ret)
goto error_fail_uar_alloc;
if (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {
INIT_LIST_HEAD(&context->page_list);
mutex_init(&context->page_mutex);
}
ret = ib_copy_to_udata(udata, &resp, sizeof(resp));
if (ret)
goto error_fail_copy_to_udata;
return &context->ibucontext;
error_fail_copy_to_udata:
hns_roce_uar_free(hr_dev, &context->uar);
error_fail_uar_alloc:
kfree(context);
return ERR_PTR(ret);
}","static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *VAR_0,
struct ib_udata *VAR_1)
{
int VAR_2 = 0;
struct hns_roce_ucontext *VAR_3;
struct hns_roce_ib_alloc_ucontext_resp VAR_4;
struct hns_roce_dev *VAR_5 = to_hr_dev(VAR_0);
VAR_4.qp_tab_size = VAR_5->caps.num_qps;
VAR_3 = kmalloc(sizeof(*VAR_3), VAR_6);
if (!VAR_3)
return ERR_PTR(-VAR_7);
VAR_2 = hns_roce_uar_alloc(VAR_5, &VAR_3->uar);
if (VAR_2)
goto error_fail_uar_alloc;
if (VAR_5->caps.flags & VAR_8) {
INIT_LIST_HEAD(&VAR_3->page_list);
mutex_init(&VAR_3->page_mutex);
}
VAR_2 = ib_copy_to_udata(VAR_1, &VAR_4, sizeof(VAR_4));
if (VAR_2)
goto error_fail_copy_to_udata;
return &VAR_3->ibucontext;
error_fail_copy_to_udata:
hns_roce_uar_free(VAR_5, &VAR_3->uar);
error_fail_uar_alloc:
kfree(VAR_3);
return ERR_PTR(VAR_2);
}",torvalds/linux/df7e40425813c50cd252e6f5e348a81ef1acae56/hns_roce_main.c/vul/before/0.json,"static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,
						   struct ib_udata *udata)
{
	int ret = 0;
	struct hns_roce_ucontext *context;
	struct hns_roce_ib_alloc_ucontext_resp resp = {};
	struct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);

	resp.qp_tab_size = hr_dev->caps.num_qps;

	context = kmalloc(sizeof(*context), GFP_KERNEL);
	if (!context)
		return ERR_PTR(-ENOMEM);

	ret = hns_roce_uar_alloc(hr_dev, &context->uar);
	if (ret)
		goto error_fail_uar_alloc;

	if (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {
		INIT_LIST_HEAD(&context->page_list);
		mutex_init(&context->page_mutex);
	}

	ret = ib_copy_to_udata(udata, &resp, sizeof(resp));
	if (ret)
		goto error_fail_copy_to_udata;

	return &context->ibucontext;

error_fail_copy_to_udata:
	hns_roce_uar_free(hr_dev, &context->uar);

error_fail_uar_alloc:
	kfree(context);

	return ERR_PTR(ret);
}","static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *VAR_0,
						   struct ib_udata *VAR_1)
{
	int VAR_2 = 0;
	struct hns_roce_ucontext *VAR_3;
	struct hns_roce_ib_alloc_ucontext_resp VAR_4 = {};
	struct hns_roce_dev *VAR_5 = to_hr_dev(VAR_0);

	VAR_4.qp_tab_size = VAR_5->caps.num_qps;

	VAR_3 = kmalloc(sizeof(*VAR_3), VAR_6);
	if (!VAR_3)
		return ERR_PTR(-VAR_7);

	VAR_2 = hns_roce_uar_alloc(VAR_5, &VAR_3->uar);
	if (VAR_2)
		goto error_fail_uar_alloc;

	if (VAR_5->caps.flags & VAR_8) {
		INIT_LIST_HEAD(&VAR_3->page_list);
		mutex_init(&VAR_3->page_mutex);
	}

	VAR_2 = ib_copy_to_udata(VAR_1, &VAR_4, sizeof(VAR_4));
	if (VAR_2)
		goto error_fail_copy_to_udata;

	return &VAR_3->ibucontext;

error_fail_copy_to_udata:
	hns_roce_uar_free(VAR_5, &VAR_3->uar);

error_fail_uar_alloc:
	kfree(VAR_3);

	return ERR_PTR(VAR_2);
}",torvalds/linux/df7e40425813c50cd252e6f5e348a81ef1acae56/hns_roce_main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
 	int ret = 0;
 	struct hns_roce_ucontext *context;
-	struct hns_roce_ib_alloc_ucontext_resp resp;
+	struct hns_roce_ib_alloc_ucontext_resp resp = {};
 	struct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);
 
 	resp.qp_tab_size = hr_dev->caps.num_qps;","{'deleted_lines': ['\tstruct hns_roce_ib_alloc_ucontext_resp resp;'], 'added_lines': ['\tstruct hns_roce_ib_alloc_ucontext_resp resp = {};']}",True,"In the Linux kernel before 4.17, hns_roce_alloc_ucontext in drivers/infiniband/hw/hns/hns_roce_main.c does not initialize the resp data structure, which might allow attackers to obtain sensitive information from kernel stack memory, aka CID-df7e40425813.",7.5,HIGH,2,test,2018-03-19T13:36:07Z,2
CVE-2018-17965,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1052,e92492afac23315358850e5e050144930049e9cb,https://github.com/ImageMagick/ImageMagick/commit/e92492afac23315358850e5e050144930049e9cb,coders/sgi.c,WriteSGIImage,"static MagickBooleanType WriteSGIImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
CompressionType
compression;
const char
*value;
MagickBooleanType
status;
MagickOffsetType
scene;
MagickSizeType
number_pixels;
MemoryInfo
*pixel_info;
SGIInfo
iris_info;
register const Quantum
*p;
register ssize_t
i,
x;
register unsigned char
*q;
ssize_t
y,
z;
unsigned char
*pixels,
*packets;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
if ((image->columns > 65535UL) || (image->rows > 65535UL))
ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
scene=0;
do
{
(void) TransformImageColorspace(image,sRGBColorspace,exception);
(void) memset(&iris_info,0,sizeof(iris_info));
iris_info.magic=0x01DA;
compression=image->compression;
if (image_info->compression != UndefinedCompression)
compression=image_info->compression;
if (image->depth > 8)
compression=NoCompression;
if (compression == NoCompression)
iris_info.storage=(unsigned char) 0x00;
else
iris_info.storage=(unsigned char) 0x01;
iris_info.bytes_per_pixel=(unsigned char) (image->depth > 8 ? 2 : 1);
iris_info.dimension=3;
iris_info.columns=(unsigned short) image->columns;
iris_info.rows=(unsigned short) image->rows;
if (image->alpha_trait != UndefinedPixelTrait)
iris_info.depth=4;
else
{
if ((image_info->type != TrueColorType) &&
(SetImageGray(image,exception) != MagickFalse))
{
iris_info.dimension=2;
iris_info.depth=1;
}
else
iris_info.depth=3;
}
iris_info.minimum_value=0;
iris_info.maximum_value=(size_t) (image->depth <= 8 ?
1UL*ScaleQuantumToChar(QuantumRange) :
1UL*ScaleQuantumToShort(QuantumRange));
(void) WriteBlobMSBShort(image,iris_info.magic);
(void) WriteBlobByte(image,iris_info.storage);
(void) WriteBlobByte(image,iris_info.bytes_per_pixel);
(void) WriteBlobMSBShort(image,iris_info.dimension);
(void) WriteBlobMSBShort(image,iris_info.columns);
(void) WriteBlobMSBShort(image,iris_info.rows);
(void) WriteBlobMSBShort(image,iris_info.depth);
(void) WriteBlobMSBLong(image,(unsigned int) iris_info.minimum_value);
(void) WriteBlobMSBLong(image,(unsigned int) iris_info.maximum_value);
(void) WriteBlobMSBLong(image,(unsigned int) iris_info.sans);
value=GetImageProperty(image,""label"",exception);
if (value != (const char *) NULL)
(void) CopyMagickString(iris_info.name,value,sizeof(iris_info.name));
(void) WriteBlob(image,sizeof(iris_info.name),(unsigned char *)
iris_info.name);
(void) WriteBlobMSBLong(image,(unsigned int) iris_info.pixel_format);
(void) WriteBlob(image,sizeof(iris_info.filler),iris_info.filler);
number_pixels=(MagickSizeType) image->columns*image->rows;
if ((4*iris_info.bytes_per_pixel*number_pixels) !=
((MagickSizeType) (size_t) (4*iris_info.bytes_per_pixel*number_pixels)))
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
pixel_info=AcquireVirtualMemory((size_t) number_pixels,4*
iris_info.bytes_per_pixel*sizeof(*pixels));
if (pixel_info == (MemoryInfo *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
if (image->depth <= 8)
for (x=0; x < (ssize_t) image->columns; x++)
{
register unsigned char
*q;
q=(unsigned char *) pixels;
q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;
*q++=ScaleQuantumToChar(GetPixelRed(image,p));
*q++=ScaleQuantumToChar(GetPixelGreen(image,p));
*q++=ScaleQuantumToChar(GetPixelBlue(image,p));
*q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
p+=GetPixelChannels(image);
}
else
for (x=0; x < (ssize_t) image->columns; x++)
{
register unsigned short
*q;
q=(unsigned short *) pixels;
q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;
*q++=ScaleQuantumToShort(GetPixelRed(image,p));
*q++=ScaleQuantumToShort(GetPixelGreen(image,p));
*q++=ScaleQuantumToShort(GetPixelBlue(image,p));
*q++=ScaleQuantumToShort(GetPixelAlpha(image,p));
p+=GetPixelChannels(image);
}
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
switch (compression)
{
case NoCompression:
{
for (z=0; z < (ssize_t) iris_info.depth; z++)
{
for (y=0; y < (ssize_t) iris_info.rows; y++)
{
if (image->depth <= 8)
for (x=0; x < (ssize_t) iris_info.columns; x++)
{
register unsigned char
*q;
q=(unsigned char *) pixels;
q+=y*(4*iris_info.columns)+4*x+z;
(void) WriteBlobByte(image,*q);
}
else
for (x=0; x < (ssize_t) iris_info.columns; x++)
{
register unsigned short
*q;
q=(unsigned short *) pixels;
q+=y*(4*iris_info.columns)+4*x+z;
(void) WriteBlobMSBShort(image,*q);
}
}
}
break;
}
default:
{
MemoryInfo
*packet_info;
size_t
length,
number_packets,
*runlength;
ssize_t
offset,
*offsets;
offsets=(ssize_t *) AcquireQuantumMemory(iris_info.rows,
iris_info.depth*sizeof(*offsets));
runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,
iris_info.depth*sizeof(*runlength));
packet_info=AcquireVirtualMemory((2*(size_t) iris_info.columns+10)*
image->rows,4*sizeof(*packets));
if ((offsets == (ssize_t *) NULL) ||
(runlength == (size_t *) NULL) ||
(packet_info == (MemoryInfo *) NULL))
{
if (offsets != (ssize_t *) NULL)
offsets=(ssize_t *) RelinquishMagickMemory(offsets);
if (runlength != (size_t *) NULL)
runlength=(size_t *) RelinquishMagickMemory(runlength);
if (packet_info != (MemoryInfo *) NULL)
packet_info=RelinquishVirtualMemory(packet_info);
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
}
packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);
offset=512+4*2*((ssize_t) iris_info.rows*iris_info.depth);
number_packets=0;
q=pixels;
for (y=0; y < (ssize_t) iris_info.rows; y++)
{
for (z=0; z < (ssize_t) iris_info.depth; z++)
{
length=SGIEncode(q+z,(size_t) iris_info.columns,packets+
number_packets);
number_packets+=length;
offsets[y+z*iris_info.rows]=offset;
runlength[y+z*iris_info.rows]=(size_t) length;
offset+=(ssize_t) length;
}
q+=(iris_info.columns*4);
}
for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
(void) WriteBlobMSBLong(image,(unsigned int) offsets[i]);
for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
(void) WriteBlobMSBLong(image,(unsigned int) runlength[i]);
(void) WriteBlob(image,number_packets,packets);
offsets=(ssize_t *) RelinquishMagickMemory(offsets);
runlength=(size_t *) RelinquishMagickMemory(runlength);
packet_info=RelinquishVirtualMemory(packet_info);
break;
}
}
pixel_info=RelinquishVirtualMemory(pixel_info);
if (GetNextImageInList(image) == (Image *) NULL)
break;
image=SyncNextImageInList(image);
status=SetImageProgress(image,SaveImagesTag,scene++,
GetImageListLength(image));
if (status == MagickFalse)
break;
} while (image_info->adjoin != MagickFalse);
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WriteSGIImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
CompressionType
VAR_3;
const char
*VAR_4;
MagickBooleanType
VAR_5;
MagickOffsetType
VAR_6;
MagickSizeType
VAR_7;
MemoryInfo
*VAR_8;
SGIInfo
VAR_9;
register const Quantum
*VAR_10;
register ssize_t
VAR_11,
VAR_12;
register unsigned char
*VAR_13;
ssize_t
VAR_14,
VAR_15;
unsigned char
*VAR_16,
*VAR_17;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_18);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_18);
if (VAR_1->debug != VAR_19)
(void) LogMagickEvent(VAR_20,GetMagickModule(),""%s"",VAR_1->filename);
if ((VAR_1->columns > 65535UL) || (VAR_1->rows > 65535UL))
ThrowWriterException(VAR_21,""WidthOrHeightExceedsLimit"");
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_18);
VAR_5=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);
if (VAR_5 == VAR_19)
return(VAR_5);
VAR_6=0;
do
{
(void) TransformImageColorspace(VAR_1,VAR_23,VAR_2);
(void) memset(&VAR_9,0,sizeof(VAR_9));
VAR_9.magic=0x01DA;
VAR_3=VAR_1->compression;
if (VAR_0->compression != VAR_24)
VAR_3=VAR_0->compression;
if (VAR_1->depth > 8)
VAR_3=VAR_25;
if (VAR_3 == VAR_25)
VAR_9.storage=(unsigned char) 0x00;
else
VAR_9.storage=(unsigned char) 0x01;
VAR_9.bytes_per_pixel=(unsigned char) (VAR_1->depth > 8 ? 2 : 1);
VAR_9.dimension=3;
VAR_9.columns=(unsigned short) VAR_1->columns;
VAR_9.rows=(unsigned short) VAR_1->rows;
if (VAR_1->alpha_trait != VAR_26)
VAR_9.depth=4;
else
{
if ((VAR_0->type != VAR_27) &&
(SetImageGray(VAR_1,VAR_2) != VAR_19))
{
VAR_9.dimension=2;
VAR_9.depth=1;
}
else
VAR_9.depth=3;
}
VAR_9.minimum_value=0;
VAR_9.maximum_value=(size_t) (VAR_1->depth <= 8 ?
1UL*ScaleQuantumToChar(VAR_28) :
1UL*ScaleQuantumToShort(VAR_28));
(void) WriteBlobMSBShort(VAR_1,VAR_9.magic);
(void) WriteBlobByte(VAR_1,VAR_9.storage);
(void) WriteBlobByte(VAR_1,VAR_9.bytes_per_pixel);
(void) WriteBlobMSBShort(VAR_1,VAR_9.dimension);
(void) WriteBlobMSBShort(VAR_1,VAR_9.columns);
(void) WriteBlobMSBShort(VAR_1,VAR_9.rows);
(void) WriteBlobMSBShort(VAR_1,VAR_9.depth);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.minimum_value);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.maximum_value);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.sans);
VAR_4=GetImageProperty(VAR_1,""label"",VAR_2);
if (VAR_4 != (const char *) NULL)
(void) CopyMagickString(VAR_9.name,VAR_4,sizeof(VAR_9.name));
(void) WriteBlob(VAR_1,sizeof(VAR_9.name),(unsigned char *)
VAR_9.name);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.pixel_format);
(void) WriteBlob(VAR_1,sizeof(VAR_9.filler),VAR_9.filler);
VAR_7=(MagickSizeType) VAR_1->columns*VAR_1->rows;
if ((4*VAR_9.bytes_per_pixel*VAR_7) !=
((MagickSizeType) (size_t) (4*VAR_9.bytes_per_pixel*VAR_7)))
ThrowWriterException(VAR_29,""MemoryAllocationFailed"");
VAR_8=AcquireVirtualMemory((size_t) VAR_7,4*
VAR_9.bytes_per_pixel*sizeof(*VAR_16));
if (VAR_8 == (MemoryInfo *) NULL)
ThrowWriterException(VAR_29,""MemoryAllocationFailed"");
VAR_16=(unsigned char *) GetVirtualMemoryBlob(VAR_8);
for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
{
VAR_10=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
if (VAR_10 == (const Quantum *) NULL)
break;
if (VAR_1->depth <= 8)
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
{
register unsigned char
*VAR_13;
VAR_13=(unsigned char *) VAR_16;
VAR_13+=((VAR_9.rows-1)-VAR_14)*(4*VAR_9.columns)+4*VAR_12;
*VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_10));
VAR_10+=GetPixelChannels(VAR_1);
}
else
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
{
register unsigned short
*VAR_13;
VAR_13=(unsigned short *) VAR_16;
VAR_13+=((VAR_9.rows-1)-VAR_14)*(4*VAR_9.columns)+4*VAR_12;
*VAR_13++=ScaleQuantumToShort(GetPixelRed(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToShort(GetPixelGreen(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToShort(GetPixelBlue(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToShort(GetPixelAlpha(VAR_1,VAR_10));
VAR_10+=GetPixelChannels(VAR_1);
}
if (VAR_1->previous == (Image *) NULL)
{
VAR_5=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_14,
VAR_1->rows);
if (VAR_5 == VAR_19)
break;
}
}
switch (VAR_3)
{
case VAR_25:
{
for (VAR_15=0; VAR_15 < (ssize_t) VAR_9.depth; VAR_15++)
{
for (VAR_14=0; VAR_14 < (ssize_t) VAR_9.rows; VAR_14++)
{
if (VAR_1->depth <= 8)
for (VAR_12=0; VAR_12 < (ssize_t) VAR_9.columns; VAR_12++)
{
register unsigned char
*VAR_13;
VAR_13=(unsigned char *) VAR_16;
VAR_13+=VAR_14*(4*VAR_9.columns)+4*VAR_12+VAR_15;
(void) WriteBlobByte(VAR_1,*VAR_13);
}
else
for (VAR_12=0; VAR_12 < (ssize_t) VAR_9.columns; VAR_12++)
{
register unsigned short
*VAR_13;
VAR_13=(unsigned short *) VAR_16;
VAR_13+=VAR_14*(4*VAR_9.columns)+4*VAR_12+VAR_15;
(void) WriteBlobMSBShort(VAR_1,*VAR_13);
}
}
}
break;
}
default:
{
MemoryInfo
*VAR_31;
size_t
VAR_32,
VAR_33,
*VAR_34;
ssize_t
VAR_35,
*VAR_36;
VAR_36=(ssize_t *) AcquireQuantumMemory(VAR_9.rows,
VAR_9.depth*sizeof(*VAR_36));
VAR_34=(size_t *) AcquireQuantumMemory(VAR_9.rows,
VAR_9.depth*sizeof(*VAR_34));
VAR_31=AcquireVirtualMemory((2*(size_t) VAR_9.columns+10)*
VAR_1->rows,4*sizeof(*VAR_17));
if ((VAR_36 == (ssize_t *) NULL) ||
(VAR_34 == (size_t *) NULL) ||
(VAR_31 == (MemoryInfo *) NULL))
{
if (VAR_36 != (ssize_t *) NULL)
VAR_36=(ssize_t *) RelinquishMagickMemory(VAR_36);
if (VAR_34 != (size_t *) NULL)
VAR_34=(size_t *) RelinquishMagickMemory(VAR_34);
if (VAR_31 != (MemoryInfo *) NULL)
VAR_31=RelinquishVirtualMemory(VAR_31);
ThrowWriterException(VAR_29,""MemoryAllocationFailed"");
}
VAR_17=(unsigned char *) GetVirtualMemoryBlob(VAR_31);
VAR_35=512+4*2*((ssize_t) VAR_9.rows*VAR_9.depth);
VAR_33=0;
VAR_13=VAR_16;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_9.rows; VAR_14++)
{
for (VAR_15=0; VAR_15 < (ssize_t) VAR_9.depth; VAR_15++)
{
VAR_32=SGIEncode(VAR_13+VAR_15,(size_t) VAR_9.columns,VAR_17+
VAR_33);
VAR_33+=VAR_32;
VAR_36[VAR_14+VAR_15*VAR_9.rows]=VAR_35;
VAR_34[VAR_14+VAR_15*VAR_9.rows]=(size_t) VAR_32;
VAR_35+=(ssize_t) VAR_32;
}
VAR_13+=(VAR_9.columns*4);
}
for (VAR_11=0; VAR_11 < (ssize_t) (VAR_9.rows*VAR_9.depth); VAR_11++)
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_36[VAR_11]);
for (VAR_11=0; VAR_11 < (ssize_t) (VAR_9.rows*VAR_9.depth); VAR_11++)
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_34[VAR_11]);
(void) WriteBlob(VAR_1,VAR_33,VAR_17);
VAR_36=(ssize_t *) RelinquishMagickMemory(VAR_36);
VAR_34=(size_t *) RelinquishMagickMemory(VAR_34);
VAR_31=RelinquishVirtualMemory(VAR_31);
break;
}
}
VAR_8=RelinquishVirtualMemory(VAR_8);
if (GetNextImageInList(VAR_1) == (Image *) NULL)
break;
VAR_1=SyncNextImageInList(VAR_1);
VAR_5=SetImageProgress(VAR_1,VAR_37,VAR_6++,
GetImageListLength(VAR_1));
if (VAR_5 == VAR_19)
break;
} while (VAR_0->adjoin != VAR_19);
(void) CloseBlob(VAR_1);
return(VAR_38);
}",ImageMagick/e92492afac23315358850e5e050144930049e9cb/sgi.c/vul/before/0.json,"static MagickBooleanType WriteSGIImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  CompressionType
    compression;

  const char
    *value;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  SGIInfo
    iris_info;

  register const Quantum
    *p;

  register ssize_t
    i,
    x;

  register unsigned char
    *q;

  ssize_t
    y,
    z;

  unsigned char
    *pixels,
    *packets;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if ((image->columns > 65535UL) || (image->rows > 65535UL))
    ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  scene=0;
  do
  {
    /*
      Initialize SGI raster file header.
    */
    (void) TransformImageColorspace(image,sRGBColorspace,exception);
    (void) memset(&iris_info,0,sizeof(iris_info));
    iris_info.magic=0x01DA;
    compression=image->compression;
    if (image_info->compression != UndefinedCompression)
      compression=image_info->compression;
    if (image->depth > 8)
      compression=NoCompression;
    if (compression == NoCompression)
      iris_info.storage=(unsigned char) 0x00;
    else
      iris_info.storage=(unsigned char) 0x01;
    iris_info.bytes_per_pixel=(unsigned char) (image->depth > 8 ? 2 : 1);
    iris_info.dimension=3;
    iris_info.columns=(unsigned short) image->columns;
    iris_info.rows=(unsigned short) image->rows;
    if (image->alpha_trait != UndefinedPixelTrait)
      iris_info.depth=4;
    else
      {
        if ((image_info->type != TrueColorType) &&
            (SetImageGray(image,exception) != MagickFalse))
          {
            iris_info.dimension=2;
            iris_info.depth=1;
          }
        else
          iris_info.depth=3;
      }
    iris_info.minimum_value=0;
    iris_info.maximum_value=(size_t) (image->depth <= 8 ?
      1UL*ScaleQuantumToChar(QuantumRange) :
      1UL*ScaleQuantumToShort(QuantumRange));
    /*
      Write SGI header.
    */
    (void) WriteBlobMSBShort(image,iris_info.magic);
    (void) WriteBlobByte(image,iris_info.storage);
    (void) WriteBlobByte(image,iris_info.bytes_per_pixel);
    (void) WriteBlobMSBShort(image,iris_info.dimension);
    (void) WriteBlobMSBShort(image,iris_info.columns);
    (void) WriteBlobMSBShort(image,iris_info.rows);
    (void) WriteBlobMSBShort(image,iris_info.depth);
    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.minimum_value);
    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.maximum_value);
    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.sans);
    value=GetImageProperty(image,""label"",exception);
    if (value != (const char *) NULL)
      (void) CopyMagickString(iris_info.name,value,sizeof(iris_info.name));
    (void) WriteBlob(image,sizeof(iris_info.name),(unsigned char *)
      iris_info.name);
    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.pixel_format);
    (void) WriteBlob(image,sizeof(iris_info.filler),iris_info.filler);
    /*
      Allocate SGI pixels.
    */
    number_pixels=(MagickSizeType) image->columns*image->rows;
    if ((4*iris_info.bytes_per_pixel*number_pixels) !=
        ((MagickSizeType) (size_t) (4*iris_info.bytes_per_pixel*number_pixels)))
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory((size_t) number_pixels,4*
      iris_info.bytes_per_pixel*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    /*
      Convert image pixels to uncompressed SGI pixels.
    */
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      p=GetVirtualPixels(image,0,y,image->columns,1,exception);
      if (p == (const Quantum *) NULL)
        break;
      if (image->depth <= 8)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          register unsigned char
            *q;

          q=(unsigned char *) pixels;
          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;
          *q++=ScaleQuantumToChar(GetPixelRed(image,p));
          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
          *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
          p+=GetPixelChannels(image);
        }
      else
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          register unsigned short
            *q;

          q=(unsigned short *) pixels;
          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;
          *q++=ScaleQuantumToShort(GetPixelRed(image,p));
          *q++=ScaleQuantumToShort(GetPixelGreen(image,p));
          *q++=ScaleQuantumToShort(GetPixelBlue(image,p));
          *q++=ScaleQuantumToShort(GetPixelAlpha(image,p));
          p+=GetPixelChannels(image);
        }
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    switch (compression)
    {
      case NoCompression:
      {
        /*
          Write uncompressed SGI pixels.
        */
        for (z=0; z < (ssize_t) iris_info.depth; z++)
        {
          for (y=0; y < (ssize_t) iris_info.rows; y++)
          {
            if (image->depth <= 8)
              for (x=0; x < (ssize_t) iris_info.columns; x++)
              {
                register unsigned char
                  *q;

                q=(unsigned char *) pixels;
                q+=y*(4*iris_info.columns)+4*x+z;
                (void) WriteBlobByte(image,*q);
              }
            else
              for (x=0; x < (ssize_t) iris_info.columns; x++)
              {
                register unsigned short
                  *q;

                q=(unsigned short *) pixels;
                q+=y*(4*iris_info.columns)+4*x+z;
                (void) WriteBlobMSBShort(image,*q);
              }
          }
        }
        break;
      }
      default:
      {
        MemoryInfo
          *packet_info;

        size_t
          length,
          number_packets,
          *runlength;

        ssize_t
          offset,
          *offsets;

        /*
          Convert SGI uncompressed pixels.
        */
        offsets=(ssize_t *) AcquireQuantumMemory(iris_info.rows,
          iris_info.depth*sizeof(*offsets));
        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,
          iris_info.depth*sizeof(*runlength));
        packet_info=AcquireVirtualMemory((2*(size_t) iris_info.columns+10)*
          image->rows,4*sizeof(*packets));
        if ((offsets == (ssize_t *) NULL) ||
            (runlength == (size_t *) NULL) ||
            (packet_info == (MemoryInfo *) NULL))
          {
            if (offsets != (ssize_t *) NULL)
              offsets=(ssize_t *) RelinquishMagickMemory(offsets);
            if (runlength != (size_t *) NULL)
              runlength=(size_t *) RelinquishMagickMemory(runlength);
            if (packet_info != (MemoryInfo *) NULL)
              packet_info=RelinquishVirtualMemory(packet_info);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);
        offset=512+4*2*((ssize_t) iris_info.rows*iris_info.depth);
        number_packets=0;
        q=pixels;
        for (y=0; y < (ssize_t) iris_info.rows; y++)
        {
          for (z=0; z < (ssize_t) iris_info.depth; z++)
          {
            length=SGIEncode(q+z,(size_t) iris_info.columns,packets+
              number_packets);
            number_packets+=length;
            offsets[y+z*iris_info.rows]=offset;
            runlength[y+z*iris_info.rows]=(size_t) length;
            offset+=(ssize_t) length;
          }
          q+=(iris_info.columns*4);
        }
        /*
          Write out line start and length tables and runlength-encoded pixels.
        */
        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
          (void) WriteBlobMSBLong(image,(unsigned int) offsets[i]);
        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
          (void) WriteBlobMSBLong(image,(unsigned int) runlength[i]);
        (void) WriteBlob(image,number_packets,packets);
        /*
          Relinquish resources.
        */
        offsets=(ssize_t *) RelinquishMagickMemory(offsets);
        runlength=(size_t *) RelinquishMagickMemory(runlength);
        packet_info=RelinquishVirtualMemory(packet_info);
        break;
      }
    }
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene++,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WriteSGIImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  CompressionType
    VAR_3;

  const char
    *VAR_4;

  MagickBooleanType
    VAR_5;

  MagickOffsetType
    VAR_6;

  MagickSizeType
    VAR_7;

  MemoryInfo
    *VAR_8;

  SGIInfo
    VAR_9;

  register const Quantum
    *VAR_10;

  register ssize_t
    VAR_11,
    VAR_12;

  register unsigned char
    *VAR_13;

  ssize_t
    VAR_14,
    VAR_15;

  unsigned char
    *VAR_16,
    *VAR_17;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_18);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_18);
  if (VAR_1->debug != VAR_19)
    (void) LogMagickEvent(VAR_20,GetMagickModule(),""%s"",VAR_1->filename);
  if ((VAR_1->columns > 65535UL) || (VAR_1->rows > 65535UL))
    ThrowWriterException(VAR_21,""WidthOrHeightExceedsLimit"");
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_18);
  VAR_5=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);
  if (VAR_5 == VAR_19)
    return(VAR_5);
  VAR_6=0;
  do
  {
    /* COMMENT_3 */
                                        
      
    (void) TransformImageColorspace(VAR_1,VAR_23,VAR_2);
    (void) memset(&VAR_9,0,sizeof(VAR_9));
    VAR_9.magic=0x01DA;
    VAR_3=VAR_1->compression;
    if (VAR_0->compression != VAR_24)
      VAR_3=VAR_0->compression;
    if (VAR_1->depth > 8)
      VAR_3=VAR_25;
    if (VAR_3 == VAR_25)
      VAR_9.storage=(unsigned char) 0x00;
    else
      VAR_9.storage=(unsigned char) 0x01;
    VAR_9.bytes_per_pixel=(unsigned char) (VAR_1->depth > 8 ? 2 : 1);
    VAR_9.dimension=3;
    VAR_9.columns=(unsigned short) VAR_1->columns;
    VAR_9.rows=(unsigned short) VAR_1->rows;
    if (VAR_1->alpha_trait != VAR_26)
      VAR_9.depth=4;
    else
      {
        if ((VAR_0->type != VAR_27) &&
            (SetImageGray(VAR_1,VAR_2) != VAR_19))
          {
            VAR_9.dimension=2;
            VAR_9.depth=1;
          }
        else
          VAR_9.depth=3;
      }
    VAR_9.minimum_value=0;
    VAR_9.maximum_value=(size_t) (VAR_1->depth <= 8 ?
      1UL*ScaleQuantumToChar(VAR_28) :
      1UL*ScaleQuantumToShort(VAR_28));
    /* COMMENT_6 */
                       
      
    (void) WriteBlobMSBShort(VAR_1,VAR_9.magic);
    (void) WriteBlobByte(VAR_1,VAR_9.storage);
    (void) WriteBlobByte(VAR_1,VAR_9.bytes_per_pixel);
    (void) WriteBlobMSBShort(VAR_1,VAR_9.dimension);
    (void) WriteBlobMSBShort(VAR_1,VAR_9.columns);
    (void) WriteBlobMSBShort(VAR_1,VAR_9.rows);
    (void) WriteBlobMSBShort(VAR_1,VAR_9.depth);
    (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.minimum_value);
    (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.maximum_value);
    (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.sans);
    VAR_4=GetImageProperty(VAR_1,""label"",VAR_2);
    if (VAR_4 != (const char *) NULL)
      (void) CopyMagickString(VAR_9.name,VAR_4,sizeof(VAR_9.name));
    (void) WriteBlob(VAR_1,sizeof(VAR_9.name),(unsigned char *)
      VAR_9.name);
    (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_9.pixel_format);
    (void) WriteBlob(VAR_1,sizeof(VAR_9.filler),VAR_9.filler);
    /* COMMENT_9 */
                          
      
    VAR_7=(MagickSizeType) VAR_1->columns*VAR_1->rows;
    if ((4*VAR_9.bytes_per_pixel*VAR_7) !=
        ((MagickSizeType) (size_t) (4*VAR_9.bytes_per_pixel*VAR_7)))
      ThrowWriterException(VAR_29,""MemoryAllocationFailed"");
    VAR_8=AcquireVirtualMemory((size_t) VAR_7,4*
      VAR_9.bytes_per_pixel*sizeof(*VAR_16));
    if (VAR_8 == (MemoryInfo *) NULL)
      ThrowWriterException(VAR_29,""MemoryAllocationFailed"");
    VAR_16=(unsigned char *) GetVirtualMemoryBlob(VAR_8);
    /* COMMENT_12 */
                                                      
      
    for (VAR_14=0; VAR_14 < (ssize_t) VAR_1->rows; VAR_14++)
    {
      VAR_10=GetVirtualPixels(VAR_1,0,VAR_14,VAR_1->columns,1,VAR_2);
      if (VAR_10 == (const Quantum *) NULL)
        break;
      if (VAR_1->depth <= 8)
        for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
        {
          register unsigned char
            *VAR_13;

          VAR_13=(unsigned char *) VAR_16;
          VAR_13+=((VAR_9.rows-1)-VAR_14)*(4*VAR_9.columns)+4*VAR_12;
          *VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));
          *VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));
          *VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));
          *VAR_13++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_10));
          VAR_10+=GetPixelChannels(VAR_1);
        }
      else
        for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
        {
          register unsigned short
            *VAR_13;

          VAR_13=(unsigned short *) VAR_16;
          VAR_13+=((VAR_9.rows-1)-VAR_14)*(4*VAR_9.columns)+4*VAR_12;
          *VAR_13++=ScaleQuantumToShort(GetPixelRed(VAR_1,VAR_10));
          *VAR_13++=ScaleQuantumToShort(GetPixelGreen(VAR_1,VAR_10));
          *VAR_13++=ScaleQuantumToShort(GetPixelBlue(VAR_1,VAR_10));
          *VAR_13++=ScaleQuantumToShort(GetPixelAlpha(VAR_1,VAR_10));
          VAR_10+=GetPixelChannels(VAR_1);
        }
      if (VAR_1->previous == (Image *) NULL)
        {
          VAR_5=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_14,
            VAR_1->rows);
          if (VAR_5 == VAR_19)
            break;
        }
    }
    switch (VAR_3)
    {
      case VAR_25:
      {
        /* COMMENT_15 */
                                        
          
        for (VAR_15=0; VAR_15 < (ssize_t) VAR_9.depth; VAR_15++)
        {
          for (VAR_14=0; VAR_14 < (ssize_t) VAR_9.rows; VAR_14++)
          {
            if (VAR_1->depth <= 8)
              for (VAR_12=0; VAR_12 < (ssize_t) VAR_9.columns; VAR_12++)
              {
                register unsigned char
                  *VAR_13;

                VAR_13=(unsigned char *) VAR_16;
                VAR_13+=VAR_14*(4*VAR_9.columns)+4*VAR_12+VAR_15;
                (void) WriteBlobByte(VAR_1,*VAR_13);
              }
            else
              for (VAR_12=0; VAR_12 < (ssize_t) VAR_9.columns; VAR_12++)
              {
                register unsigned short
                  *VAR_13;

                VAR_13=(unsigned short *) VAR_16;
                VAR_13+=VAR_14*(4*VAR_9.columns)+4*VAR_12+VAR_15;
                (void) WriteBlobMSBShort(VAR_1,*VAR_13);
              }
          }
        }
        break;
      }
      default:
      {
        MemoryInfo
          *VAR_31;

        size_t
          VAR_32,
          VAR_33,
          *VAR_34;

        ssize_t
          VAR_35,
          *VAR_36;

        /* COMMENT_18 */
                                          
          
        VAR_36=(ssize_t *) AcquireQuantumMemory(VAR_9.rows,
          VAR_9.depth*sizeof(*VAR_36));
        VAR_34=(size_t *) AcquireQuantumMemory(VAR_9.rows,
          VAR_9.depth*sizeof(*VAR_34));
        VAR_31=AcquireVirtualMemory((2*(size_t) VAR_9.columns+10)*
          VAR_1->rows,4*sizeof(*VAR_17));
        if ((VAR_36 == (ssize_t *) NULL) ||
            (VAR_34 == (size_t *) NULL) ||
            (VAR_31 == (MemoryInfo *) NULL))
          {
            if (VAR_36 != (ssize_t *) NULL)
              VAR_36=(ssize_t *) RelinquishMagickMemory(VAR_36);
            if (VAR_34 != (size_t *) NULL)
              VAR_34=(size_t *) RelinquishMagickMemory(VAR_34);
            if (VAR_31 != (MemoryInfo *) NULL)
              VAR_31=RelinquishVirtualMemory(VAR_31);
            VAR_8=RelinquishVirtualMemory(VAR_8);
            ThrowWriterException(VAR_29,""MemoryAllocationFailed"");
          }
        VAR_17=(unsigned char *) GetVirtualMemoryBlob(VAR_31);
        VAR_35=512+4*2*((ssize_t) VAR_9.rows*VAR_9.depth);
        VAR_33=0;
        VAR_13=VAR_16;
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_9.rows; VAR_14++)
        {
          for (VAR_15=0; VAR_15 < (ssize_t) VAR_9.depth; VAR_15++)
          {
            VAR_32=SGIEncode(VAR_13+VAR_15,(size_t) VAR_9.columns,VAR_17+
              VAR_33);
            VAR_33+=VAR_32;
            VAR_36[VAR_14+VAR_15*VAR_9.rows]=VAR_35;
            VAR_34[VAR_14+VAR_15*VAR_9.rows]=(size_t) VAR_32;
            VAR_35+=(ssize_t) VAR_32;
          }
          VAR_13+=(VAR_9.columns*4);
        }
        /* COMMENT_21 */
                                                                              
          
        for (VAR_11=0; VAR_11 < (ssize_t) (VAR_9.rows*VAR_9.depth); VAR_11++)
          (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_36[VAR_11]);
        for (VAR_11=0; VAR_11 < (ssize_t) (VAR_9.rows*VAR_9.depth); VAR_11++)
          (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_34[VAR_11]);
        (void) WriteBlob(VAR_1,VAR_33,VAR_17);
        /* COMMENT_24 */
                               
          
        VAR_36=(ssize_t *) RelinquishMagickMemory(VAR_36);
        VAR_34=(size_t *) RelinquishMagickMemory(VAR_34);
        VAR_31=RelinquishVirtualMemory(VAR_31);
        break;
      }
    }
    VAR_8=RelinquishVirtualMemory(VAR_8);
    if (GetNextImageInList(VAR_1) == (Image *) NULL)
      break;
    VAR_1=SyncNextImageInList(VAR_1);
    VAR_5=SetImageProgress(VAR_1,VAR_37,VAR_6++,
      GetImageListLength(VAR_1));
    if (VAR_5 == VAR_19)
      break;
  } while (VAR_0->adjoin != VAR_19);
  (void) CloseBlob(VAR_1);
  return(VAR_38);
}",ImageMagick/e92492afac23315358850e5e050144930049e9cb/sgi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -239,6 +239,7 @@
               runlength=(size_t *) RelinquishMagickMemory(runlength);
             if (packet_info != (MemoryInfo *) NULL)
               packet_info=RelinquishVirtualMemory(packet_info);
+            pixel_info=RelinquishVirtualMemory(pixel_info);
             ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);","{'deleted_lines': [], 'added_lines': ['            pixel_info=RelinquishVirtualMemory(pixel_info);']}",True,ImageMagick 7.0.7-28 has a memory leak vulnerability in WriteSGIImage in coders/sgi.c.,6.5,MEDIUM,1,test,2018-03-24T16:42:46Z,2
CVE-2018-11381,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,radareorg/radare2,Fix #9902 - Fix oobread in RBin.string_scan_range,3fcf41ed96ffa25b38029449520c8d0a198745f3,https://github.com/radareorg/radare2/commit/3fcf41ed96ffa25b38029449520c8d0a198745f3,libr/bin/file.c,string_scan_range,"static int string_scan_range(RList *list, RBinFile *bf, int min,
const ut64 from, const ut64 to, int type) {
ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];
ut64 str_start, needle = from;
int count = 0, i, rc, runes;
int str_type = R_STRING_TYPE_DETECT;
if (type == -1) {
type = R_STRING_TYPE_DETECT;
}
if (from >= to) {
eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
return -1;
}
ut8 *buf = calloc (to - from, 1);
if (!buf || !min) {
return -1;
}
r_buf_read_at (bf->buf, from, buf, to - from);
while (needle < to) {
rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
if (!rc) {
needle++;
continue;
}
if (type == R_STRING_TYPE_DETECT) {
char *w = (char *)buf + needle + rc - from;
if ((to - needle) > 5) {
bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
if (is_wide32) {
str_type = R_STRING_TYPE_WIDE32;
} else {
bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];
str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
}
} else {
str_type = R_STRING_TYPE_ASCII;
}
} else {
str_type = type;
}
runes = 0;
str_start = needle;
for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {
RRune r = {0};
if (str_type == R_STRING_TYPE_WIDE32) {
rc = r_utf32le_decode (buf + needle - from, to - needle, &r);
if (rc) {
rc = 4;
}
} else if (str_type == R_STRING_TYPE_WIDE) {
rc = r_utf16le_decode (buf + needle - from, to - needle, &r);
if (rc == 1) {
rc = 2;
}
} else {
rc = r_utf8_decode (buf + needle - from, to - needle, &r);
if (rc > 1) {
str_type = R_STRING_TYPE_UTF8;
}
}
if (!rc) {
needle++;
break;
}
needle += rc;
if (r_isprint (r) && r != '\\') {
if (str_type == R_STRING_TYPE_WIDE32) {
if (r == 0xff) {
r = 0;
}
}
rc = r_utf8_encode (&tmp[i], r);
runes++;
} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) {
if ((i + 32) < sizeof (tmp) && r < 93) {
tmp[i + 0] = '\\';
tmp[i + 1] = ""       abtnvfr             e  ""
""                              ""
""                              ""
""  \\""[r];
} else {
break;
}
rc = 2;
runes++;
} else {
break;
}
}
tmp[i++] = '\0';
if (runes >= min) {
if (str_type == R_STRING_TYPE_ASCII) {
int j;
for (j = 0; j < i; j++) {
char ch = tmp[j];
if (ch != '\n' && ch != '\r' && ch != '\t') {
if (!IS_PRINTABLE (tmp[j])) {
continue;
}
}
}
}
RBinString *bs = R_NEW0 (RBinString);
if (!bs) {
break;
}
bs->type = str_type;
bs->length = runes;
bs->size = needle - str_start;
bs->ordinal = count++;
switch (str_type) {
case R_STRING_TYPE_WIDE:
if (str_start -from> 1) {
const ut8 *p = buf + str_start - 2 - from;
if (p[0] == 0xff && p[1] == 0xfe) {
str_start -= 2; }
}
break;
case R_STRING_TYPE_WIDE32:
if (str_start -from> 3) {
const ut8 *p = buf + str_start - 4 - from;
if (p[0] == 0xff && p[1] == 0xfe) {
str_start -= 4; }
}
break;
}
bs->paddr = bs->vaddr = str_start;
bs->string = r_str_ndup ((const char *)tmp, i);
if (list) {
r_list_append (list, bs);
} else {
print_string (bs, bf);
r_bin_string_free (bs);
}
}
}
free (buf);
return count;
}","static int string_scan_range(RList *VAR_0, RBinFile *VAR_1, int VAR_2,
const ut64 VAR_3, const ut64 VAR_4, int VAR_5) {
ut8 VAR_6[VAR_7];
ut64 VAR_8, VAR_9 = VAR_3;
int VAR_10 = 0, VAR_11, VAR_12, VAR_13;
int VAR_14 = VAR_15;
if (VAR_5 == -1) {
VAR_5 = VAR_15;
}
if (VAR_3 >= VAR_4) {
eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", VAR_3, VAR_4);
return -1;
}
ut8 *VAR_16 = calloc (VAR_4 - VAR_3, 1);
if (!VAR_16 || !VAR_2) {
return -1;
}
r_buf_read_at (VAR_1->buf, VAR_3, VAR_16, VAR_4 - VAR_3);
while (VAR_9 < VAR_4) {
VAR_12 = r_utf8_decode (VAR_16 + VAR_9 - VAR_3, VAR_4 - VAR_9, NULL);
if (!VAR_12) {
VAR_9++;
continue;
}
if (VAR_5 == VAR_15) {
char *VAR_17 = (char *)VAR_16 + VAR_9 + VAR_12 - VAR_3;
if ((VAR_4 - VAR_9) > 5) {
bool VAR_18 = VAR_9 + VAR_12 + 2 < VAR_4 && !VAR_17[0] && !VAR_17[1] && !VAR_17[2] && VAR_17[3] && !VAR_17[4];
if (VAR_18) {
VAR_14 = VAR_19;
} else {
bool VAR_20 = VAR_9 + VAR_12 + 2 < VAR_4 && !VAR_17[0] && VAR_17[1] && !VAR_17[2];
VAR_14 = VAR_20? VAR_21: VAR_22;
}
} else {
VAR_14 = VAR_22;
}
} else {
VAR_14 = VAR_5;
}
VAR_13 = 0;
VAR_8 = VAR_9;
for (VAR_12 = VAR_11 = 0; VAR_11 < sizeof (VAR_6) - 3 && VAR_9 < VAR_4; VAR_11 += VAR_12) {
RRune VAR_23 = {0};
if (VAR_14 == VAR_19) {
VAR_12 = r_utf32le_decode (VAR_16 + VAR_9 - VAR_3, VAR_4 - VAR_9, &VAR_23);
if (VAR_12) {
VAR_12 = 4;
}
} else if (VAR_14 == VAR_21) {
VAR_12 = r_utf16le_decode (VAR_16 + VAR_9 - VAR_3, VAR_4 - VAR_9, &VAR_23);
if (VAR_12 == 1) {
VAR_12 = 2;
}
} else {
VAR_12 = r_utf8_decode (VAR_16 + VAR_9 - VAR_3, VAR_4 - VAR_9, &VAR_23);
if (VAR_12 > 1) {
VAR_14 = VAR_24;
}
}
if (!VAR_12) {
VAR_9++;
break;
}
VAR_9 += VAR_12;
if (r_isprint (VAR_23) && VAR_23 != '\\') {
if (VAR_14 == VAR_19) {
if (VAR_23 == 0xff) {
VAR_23 = 0;
}
}
VAR_12 = r_utf8_encode (&VAR_6[VAR_11], VAR_23);
VAR_13++;
} else if (VAR_23 && VAR_23 < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)VAR_23)) {
if ((VAR_11 + 32) < sizeof (VAR_6) && VAR_23 < 93) {
VAR_6[VAR_11 + 0] = '\\';
VAR_6[VAR_11 + 1] = ""       abtnvfr             e  ""
""                              ""
""                              ""
""  \\""[VAR_23];
} else {
break;
}
VAR_12 = 2;
VAR_13++;
} else {
break;
}
}
VAR_6[VAR_11++] = '\0';
if (VAR_13 >= VAR_2) {
if (VAR_14 == VAR_22) {
int VAR_25;
for (VAR_25 = 0; VAR_25 < VAR_11; VAR_25++) {
char VAR_26 = VAR_6[VAR_25];
if (VAR_26 != '\n' && VAR_26 != '\r' && VAR_26 != '\t') {
if (!IS_PRINTABLE (VAR_6[VAR_25])) {
continue;
}
}
}
}
RBinString *VAR_27 = R_NEW0 (RBinString);
if (!VAR_27) {
break;
}
VAR_27->type = VAR_14;
VAR_27->length = VAR_13;
VAR_27->size = VAR_9 - VAR_8;
VAR_27->ordinal = VAR_10++;
switch (VAR_14) {
case VAR_21:
if (VAR_8 -VAR_3> 1) {
const ut8 *VAR_28 = VAR_16 + VAR_8 - 2 - VAR_3;
if (VAR_28[0] == 0xff && VAR_28[1] == 0xfe) {
VAR_8 -= 2; 
}
}
break;
case VAR_19:
if (VAR_8 -VAR_3> 3) {
const ut8 *VAR_28 = VAR_16 + VAR_8 - 4 - VAR_3;
if (VAR_28[0] == 0xff && VAR_28[1] == 0xfe) {
VAR_8 -= 4; 
}
}
break;
}
VAR_27->paddr = VAR_27->vaddr = VAR_8;
VAR_27->string = r_str_ndup ((const char *)VAR_6, VAR_11);
if (VAR_0) {
r_list_append (VAR_0, VAR_27);
} else {
print_string (VAR_27, VAR_1);
r_bin_string_free (VAR_27);
}
}
}
free (VAR_16);
return VAR_10;
}",radareorg/radare2/3fcf41ed96ffa25b38029449520c8d0a198745f3/file.c/vul/before/0.json,"static int string_scan_range(RList *list, RBinFile *bf, int min,
			      const ut64 from, const ut64 to, int type) {
	ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];
	ut64 str_start, needle = from;
	int count = 0, i, rc, runes;
	int str_type = R_STRING_TYPE_DETECT;

	if (type == -1) {
		type = R_STRING_TYPE_DETECT;
	}
	if (from >= to) {
		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
		return -1;
	}
	int len = to - from;
	ut8 *buf = calloc (len, 1);
	if (!buf || !min) {
		return -1;
	}
	r_buf_read_at (bf->buf, from, buf, len);
	// may oobread
	while (needle < to) {
		rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
		if (!rc) {
			needle++;
			continue;
		}
		if (type == R_STRING_TYPE_DETECT) {
			char *w = (char *)buf + needle + rc - from;
			if ((to - needle) > 5 + rc) {
				bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
				if (is_wide32) {
					str_type = R_STRING_TYPE_WIDE32;
				} else {
					bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];
					str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
				}
			} else {
				str_type = R_STRING_TYPE_ASCII;
			}
		} else {
			str_type = type;
		}
		runes = 0;
		str_start = needle;

		/* Eat a whole C string */
		for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {
			RRune r = {0};

			if (str_type == R_STRING_TYPE_WIDE32) {
				rc = r_utf32le_decode (buf + needle - from, to - needle, &r);
				if (rc) {
					rc = 4;
				}
			} else if (str_type == R_STRING_TYPE_WIDE) {
				rc = r_utf16le_decode (buf + needle - from, to - needle, &r);
				if (rc == 1) {
					rc = 2;
				}
			} else {
				rc = r_utf8_decode (buf + needle - from, to - needle, &r);
				if (rc > 1) {
					str_type = R_STRING_TYPE_UTF8;
				}
			}

			/* Invalid sequence detected */
			if (!rc) {
				needle++;
				break;
			}

			needle += rc;

			if (r_isprint (r) && r != '\\') {
				if (str_type == R_STRING_TYPE_WIDE32) {
					if (r == 0xff) {
						r = 0;
					}
				}
				rc = r_utf8_encode (&tmp[i], r);
				runes++;
				/* Print the escape code */
			} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) {
				if ((i + 32) < sizeof (tmp) && r < 93) {
					tmp[i + 0] = '\\';
					tmp[i + 1] = ""       abtnvfr             e  ""
					             ""                              ""
					             ""                              ""
					             ""  \\""[r];
				} else {
					// string too long
					break;
				}
				rc = 2;
				runes++;
			} else {
				/* \0 marks the end of C-strings */
				break;
			}
		}

		tmp[i++] = '\0';

		if (runes >= min) {
			if (str_type == R_STRING_TYPE_ASCII) {
				// reduce false positives
				int j;
				for (j = 0; j < i; j++) {
					char ch = tmp[j];
					if (ch != '\n' && ch != '\r' && ch != '\t') {
						if (!IS_PRINTABLE (tmp[j])) {
							continue;
						}
					}
				}
			}
			RBinString *bs = R_NEW0 (RBinString);
			if (!bs) {
				break;
			}
			bs->type = str_type;
			bs->length = runes;
			bs->size = needle - str_start;
			bs->ordinal = count++;
			// TODO: move into adjust_offset
			switch (str_type) {
			case R_STRING_TYPE_WIDE:
				if (str_start -from> 1) {
					const ut8 *p = buf + str_start - 2 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 2; // \xff\xfe
					}
				}
				break;
			case R_STRING_TYPE_WIDE32:
				if (str_start -from> 3) {
					const ut8 *p = buf + str_start - 4 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 4; // \xff\xfe\x00\x00
					}
				}
				break;
			}
			bs->paddr = bs->vaddr = str_start;
			bs->string = r_str_ndup ((const char *)tmp, i);
			if (list) {
				r_list_append (list, bs);
			} else {
				print_string (bs, bf);
				r_bin_string_free (bs);
			}
		}
	}
	free (buf);
	return count;
}","static int string_scan_range(RList *VAR_0, RBinFile *VAR_1, int VAR_2,
			      const ut64 VAR_3, const ut64 VAR_4, int VAR_5) {
	ut8 VAR_6[VAR_7];
	ut64 VAR_8, VAR_9 = VAR_3;
	int VAR_10 = 0, VAR_11, VAR_12, VAR_13;
	int VAR_14 = VAR_15;

	if (VAR_5 == -1) {
		VAR_5 = VAR_15;
	}
	if (VAR_3 >= VAR_4) {
		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", VAR_3, VAR_4);
		return -1;
	}
	int VAR_16 = VAR_4 - VAR_3;
	ut8 *VAR_17 = calloc (VAR_16, 1);
	if (!VAR_17 || !VAR_2) {
		return -1;
	}
	r_buf_read_at (VAR_1->buf, VAR_3, VAR_17, VAR_16);
	/* COMMENT_0 */
	while (VAR_9 < VAR_4) {
		VAR_12 = r_utf8_decode (VAR_17 + VAR_9 - VAR_3, VAR_4 - VAR_9, NULL);
		if (!VAR_12) {
			VAR_9++;
			continue;
		}
		if (VAR_5 == VAR_15) {
			char *VAR_18 = (char *)VAR_17 + VAR_9 + VAR_12 - VAR_3;
			if ((VAR_4 - VAR_9) > 5 + VAR_12) {
				bool VAR_19 = (VAR_9 + VAR_12 + 2 < VAR_4) && (!VAR_18[0] && !VAR_18[1] && !VAR_18[2] && VAR_18[3] && !VAR_18[4]);
				if (VAR_19) {
					VAR_14 = VAR_20;
				} else {
					bool VAR_21 = VAR_9 + VAR_12 + 2 < VAR_4 && !VAR_18[0] && VAR_18[1] && !VAR_18[2];
					VAR_14 = VAR_21? VAR_22: VAR_23;
				}
			} else {
				VAR_14 = VAR_23;
			}
		} else {
			VAR_14 = VAR_5;
		}
		VAR_13 = 0;
		VAR_8 = VAR_9;

		/* COMMENT_1 */
		for (VAR_12 = VAR_11 = 0; VAR_11 < sizeof (VAR_6) - 3 && VAR_9 < VAR_4; VAR_11 += VAR_12) {
			RRune VAR_24 = {0};

			if (VAR_14 == VAR_20) {
				VAR_12 = r_utf32le_decode (VAR_17 + VAR_9 - VAR_3, VAR_4 - VAR_9, &VAR_24);
				if (VAR_12) {
					VAR_12 = 4;
				}
			} else if (VAR_14 == VAR_22) {
				VAR_12 = r_utf16le_decode (VAR_17 + VAR_9 - VAR_3, VAR_4 - VAR_9, &VAR_24);
				if (VAR_12 == 1) {
					VAR_12 = 2;
				}
			} else {
				VAR_12 = r_utf8_decode (VAR_17 + VAR_9 - VAR_3, VAR_4 - VAR_9, &VAR_24);
				if (VAR_12 > 1) {
					VAR_14 = VAR_25;
				}
			}

			/* COMMENT_2 */
			if (!VAR_12) {
				VAR_9++;
				break;
			}

			VAR_9 += VAR_12;

			if (r_isprint (VAR_24) && VAR_24 != '\\') {
				if (VAR_14 == VAR_20) {
					if (VAR_24 == 0xff) {
						VAR_24 = 0;
					}
				}
				VAR_12 = r_utf8_encode (&VAR_6[VAR_11], VAR_24);
				VAR_13++;
				/* COMMENT_3 */
			} else if (VAR_24 && VAR_24 < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)VAR_24)) {
				if ((VAR_11 + 32) < sizeof (VAR_6) && VAR_24 < 93) {
					VAR_6[VAR_11 + 0] = '\\';
					VAR_6[VAR_11 + 1] = ""       abtnvfr             e  ""
					             ""                              ""
					             ""                              ""
					             ""  \\""[VAR_24];
				} else {
					/* COMMENT_4 */
					break;
				}
				VAR_12 = 2;
				VAR_13++;
			} else {
				/* COMMENT_5 */
				break;
			}
		}

		VAR_6[VAR_11++] = '\0';

		if (VAR_13 >= VAR_2) {
			if (VAR_14 == VAR_23) {
				/* COMMENT_6 */
				int VAR_26;
				for (VAR_26 = 0; VAR_26 < VAR_11; VAR_26++) {
					char VAR_27 = VAR_6[VAR_26];
					if (VAR_27 != '\n' && VAR_27 != '\r' && VAR_27 != '\t') {
						if (!IS_PRINTABLE (VAR_6[VAR_26])) {
							continue;
						}
					}
				}
			}
			RBinString *VAR_28 = R_NEW0 (RBinString);
			if (!VAR_28) {
				break;
			}
			VAR_28->type = VAR_14;
			VAR_28->length = VAR_13;
			VAR_28->size = VAR_9 - VAR_8;
			VAR_28->ordinal = VAR_10++;
			/* COMMENT_7 */
			switch (VAR_14) {
			case VAR_22:
				if (VAR_8 -VAR_3> 1) {
					const ut8 *VAR_29 = VAR_17 + VAR_8 - 2 - VAR_3;
					if (VAR_29[0] == 0xff && VAR_29[1] == 0xfe) {
						VAR_8 -= 2; /* COMMENT_8 */
					}
				}
				break;
			case VAR_20:
				if (VAR_8 -VAR_3> 3) {
					const ut8 *VAR_29 = VAR_17 + VAR_8 - 4 - VAR_3;
					if (VAR_29[0] == 0xff && VAR_29[1] == 0xfe) {
						VAR_8 -= 4; /* COMMENT_9 */
					}
				}
				break;
			}
			VAR_28->paddr = VAR_28->vaddr = VAR_8;
			VAR_28->string = r_str_ndup ((const char *)VAR_6, VAR_11);
			if (VAR_0) {
				r_list_append (VAR_0, VAR_28);
			} else {
				print_string (VAR_28, VAR_1);
				r_bin_string_free (VAR_28);
			}
		}
	}
	free (VAR_17);
	return VAR_10;
}",radareorg/radare2/3fcf41ed96ffa25b38029449520c8d0a198745f3/file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,11 +12,12 @@
 		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
 		return -1;
 	}
-	ut8 *buf = calloc (to - from, 1);
+	int len = to - from;
+	ut8 *buf = calloc (len, 1);
 	if (!buf || !min) {
 		return -1;
 	}
-	r_buf_read_at (bf->buf, from, buf, to - from);
+	r_buf_read_at (bf->buf, from, buf, len);
 	// may oobread
 	while (needle < to) {
 		rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
@@ -26,8 +27,8 @@
 		}
 		if (type == R_STRING_TYPE_DETECT) {
 			char *w = (char *)buf + needle + rc - from;
-			if ((to - needle) > 5) {
-				bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
+			if ((to - needle) > 5 + rc) {
+				bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
 				if (is_wide32) {
 					str_type = R_STRING_TYPE_WIDE32;
 				} else {","{'deleted_lines': ['\tut8 *buf = calloc (to - from, 1);', '\tr_buf_read_at (bf->buf, from, buf, to - from);', '\t\t\tif ((to - needle) > 5) {', '\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];'], 'added_lines': ['\tint len = to - from;', '\tut8 *buf = calloc (len, 1);', '\tr_buf_read_at (bf->buf, from, buf, len);', '\t\t\tif ((to - needle) > 5 + rc) {', '\t\t\t\tbool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);']}",True,The string_scan_range() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.,5.5,MEDIUM,1,test,2018-04-18T11:36:45Z,2
CVE-2018-11219,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,redis,"Security: update Lua struct package for security.

During an auditing Apple found that the ""struct"" Lua package
we ship with Redis (http://www.inf.puc-rio.br/~roberto/struct/) contains
a security problem. A bound-checking statement fails because of integer
overflow. The bug exists since we initially integrated this package with
Lua, when scripting was introduced, so every version of Redis with
EVAL/EVALSHA capabilities exposed is affected.

Instead of just fixing the bug, the library was updated to the latest
version shipped by the author.",1eb08bcd4634ae42ec45e8284923ac048beaa4c3,https://github.com/redis/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,deps/lua/src/lua_struct.c,controloptions,"static void controloptions (lua_State *L, int opt, const char **fmt,
Header *h) {
switch (opt) {
case  ' ': return;  
case '>': h->endian = BIG; return;
case '<': h->endian = LITTLE; return;
case '!': {
int a = getnum(L, fmt, MAXALIGN);
if (!isp2(a))
luaL_error(L, ""alignment %d is not a power of 2"", a);
h->align = a;
return;
}
default: {
const char *msg = lua_pushfstring(L, ""invalid format option '%c'"", opt);
luaL_argerror(L, 1, msg);
}
}
}","static void controloptions (lua_State *VAR_0, int VAR_1, const char **VAR_2,
Header *VAR_3) {
switch (VAR_1) {
case  ' ': return;  
case '>': VAR_3->endian = VAR_4; return;
case '<': VAR_3->endian = VAR_5; return;
case '!': {
int VAR_6 = getnum(VAR_0, VAR_2, VAR_7);
if (!isp2(VAR_6))
luaL_error(VAR_0, ""alignment %d is not a power of 2"", VAR_6);
VAR_3->align = VAR_6;
return;
}
default: {
const char *VAR_8 = lua_pushfstring(VAR_0, ""invalid format option '%c'"", VAR_1);
luaL_argerror(VAR_0, 1, VAR_8);
}
}
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/before/3.json,"static void controloptions (lua_State *L, int opt, const char **fmt,
                            Header *h) {
  switch (opt) {
    case  ' ': return;  /* ignore white spaces */
    case '>': h->endian = BIG; return;
    case '<': h->endian = LITTLE; return;
    case '!': {
      int a = getnum(fmt, MAXALIGN);
      if (!isp2(a))
        luaL_error(L, ""alignment %d is not a power of 2"", a);
      h->align = a;
      return;
    }
    default: {
      const char *msg = lua_pushfstring(L, ""invalid format option '%c'"", opt);
      luaL_argerror(L, 1, msg);
    }
  }
}","static void controloptions (lua_State *VAR_0, int VAR_1, const char **VAR_2,
                            Header *VAR_3) {
  switch (VAR_1) {
    case  ' ': return;  /* COMMENT_0 */
    case '>': VAR_3->endian = VAR_4; return;
    case '<': VAR_3->endian = VAR_5; return;
    case '!': {
      int VAR_6 = getnum(VAR_2, VAR_7);
      if (!isp2(VAR_6))
        luaL_error(VAR_0, ""alignment %d is not a power of 2"", VAR_6);
      VAR_3->align = VAR_6;
      return;
    }
    default: {
      const char *VAR_8 = lua_pushfstring(VAR_0, ""invalid format option '%c'"", VAR_1);
      luaL_argerror(VAR_0, 1, VAR_8);
    }
  }
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
     case '>': h->endian = BIG; return;
     case '<': h->endian = LITTLE; return;
     case '!': {
-      int a = getnum(L, fmt, MAXALIGN);
+      int a = getnum(fmt, MAXALIGN);
       if (!isp2(a))
         luaL_error(L, ""alignment %d is not a power of 2"", a);
       h->align = a;","{'deleted_lines': ['      int a = getnum(L, fmt, MAXALIGN);'], 'added_lines': ['      int a = getnum(fmt, MAXALIGN);']}",True,"An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking.",9.8,CRITICAL,3,test,2018-05-14T15:49:06Z,2
CVE-2018-11219,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,redis,"Security: update Lua struct package for security.

During an auditing Apple found that the ""struct"" Lua package
we ship with Redis (http://www.inf.puc-rio.br/~roberto/struct/) contains
a security problem. A bound-checking statement fails because of integer
overflow. The bug exists since we initially integrated this package with
Lua, when scripting was introduced, so every version of Redis with
EVAL/EVALSHA capabilities exposed is affected.

Instead of just fixing the bug, the library was updated to the latest
version shipped by the author.",1eb08bcd4634ae42ec45e8284923ac048beaa4c3,https://github.com/redis/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,deps/lua/src/lua_struct.c,optsize,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
switch (opt) {
case 'B': case 'b': return sizeof(char);
case 'H': case 'h': return sizeof(short);
case 'L': case 'l': return sizeof(long);
case 'T': return sizeof(size_t);
case 'f':  return sizeof(float);
case 'd':  return sizeof(double);
case 'x': return 1;
case 'c': return getnum(L, fmt, 1);
case 'i': case 'I': {
int sz = getnum(L, fmt, sizeof(int));
if (sz > MAXINTSIZE)
luaL_error(L, ""integral size %d is larger than limit of %d"",
sz, MAXINTSIZE);
return sz;
}
default: return 0;  
}
}","static size_t optsize (lua_State *VAR_0, char VAR_1, const char **VAR_2) {
switch (VAR_1) {
case 'B': case 'b': return sizeof(char);
case 'H': case 'h': return sizeof(short);
case 'L': case 'l': return sizeof(long);
case 'T': return sizeof(size_t);
case 'f':  return sizeof(float);
case 'd':  return sizeof(double);
case 'x': return 1;
case 'c': return getnum(VAR_0, VAR_2, 1);
case 'i': case 'I': {
int VAR_3 = getnum(VAR_0, VAR_2, sizeof(int));
if (VAR_3 > VAR_4)
luaL_error(VAR_0, ""integral size %d is larger than limit of %d"",
VAR_3, VAR_4);
return VAR_3;
}
default: return 0;  
}
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/before/2.json,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}","static size_t optsize (lua_State *VAR_0, char VAR_1, const char **VAR_2) {
  switch (VAR_1) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(VAR_2, 1);
    case 'i': case 'I': {
      int VAR_3 = getnum(VAR_2, sizeof(int));
      if (VAR_3 > VAR_4)
        luaL_error(VAR_0, ""integral size %d is larger than limit of %d"",
                       VAR_3, VAR_4);
      return VAR_3;
    }
    default: return 0;  /* COMMENT_0 */
  }
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -7,9 +7,9 @@
     case 'f':  return sizeof(float);
     case 'd':  return sizeof(double);
     case 'x': return 1;
-    case 'c': return getnum(L, fmt, 1);
+    case 'c': return getnum(fmt, 1);
     case 'i': case 'I': {
-      int sz = getnum(L, fmt, sizeof(int));
+      int sz = getnum(fmt, sizeof(int));
       if (sz > MAXINTSIZE)
         luaL_error(L, ""integral size %d is larger than limit of %d"",
                        sz, MAXINTSIZE);","{'deleted_lines': [""    case 'c': return getnum(L, fmt, 1);"", '      int sz = getnum(L, fmt, sizeof(int));'], 'added_lines': [""    case 'c': return getnum(fmt, 1);"", '      int sz = getnum(fmt, sizeof(int));']}",True,"An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking.",9.8,CRITICAL,3,test,2018-05-14T15:49:06Z,2
CVE-2018-11219,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,redis,"Security: update Lua struct package for security.

During an auditing Apple found that the ""struct"" Lua package
we ship with Redis (http://www.inf.puc-rio.br/~roberto/struct/) contains
a security problem. A bound-checking statement fails because of integer
overflow. The bug exists since we initially integrated this package with
Lua, when scripting was introduced, so every version of Redis with
EVAL/EVALSHA capabilities exposed is affected.

Instead of just fixing the bug, the library was updated to the latest
version shipped by the author.",1eb08bcd4634ae42ec45e8284923ac048beaa4c3,https://github.com/redis/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,deps/lua/src/lua_struct.c,getnum,"static int getnum (lua_State *L, const char **fmt, int df) {
if (!isdigit(**fmt))  
return df;  
else {
int a = 0;
do {
if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))
luaL_error(L, ""integral size overflow"");
a = a*10 + *((*fmt)++) - '0';
} while (isdigit(**fmt));
return a;
}
}","static int getnum (lua_State *VAR_0, const char **VAR_1, int VAR_2) {
if (!isdigit(**VAR_1))  
return VAR_2;  
else {
int VAR_3 = 0;
do {
if (VAR_3 > (VAR_4 / 10) || VAR_3 * 10 > (VAR_4 - (**VAR_1 - '0')))
luaL_error(VAR_0, ""integral size overflow"");
VAR_3 = VAR_3*10 + *((*VAR_1)++) - '0';
} while (isdigit(**VAR_1));
return VAR_3;
}
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/before/1.json,"static int getnum (const char **fmt, int df) {
  if (!isdigit(**fmt))  /* no number? */
    return df;  /* return default value */
  else {
    int a = 0;
    do {
      a = a*10 + *((*fmt)++) - '0';
    } while (isdigit(**fmt));
    return a;
  }
}","static int getnum (const char **VAR_0, int VAR_1) {
  if (!isdigit(**VAR_0))  /* COMMENT_0 */
    return VAR_1;  /* COMMENT_1 */
  else {
    int VAR_2 = 0;
    do {
      VAR_2 = VAR_2*10 + *((*VAR_0)++) - '0';
    } while (isdigit(**VAR_0));
    return VAR_2;
  }
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,11 +1,9 @@
-static int getnum (lua_State *L, const char **fmt, int df) {
+static int getnum (const char **fmt, int df) {
   if (!isdigit(**fmt))  /* no number? */
     return df;  /* return default value */
   else {
     int a = 0;
     do {
-      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))
-        luaL_error(L, ""integral size overflow"");
       a = a*10 + *((*fmt)++) - '0';
     } while (isdigit(**fmt));
     return a;","{'deleted_lines': ['static int getnum (lua_State *L, const char **fmt, int df) {', ""      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))"", '        luaL_error(L, ""integral size overflow"");'], 'added_lines': ['static int getnum (const char **fmt, int df) {']}",True,"An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking.",9.8,CRITICAL,3,test,2018-05-14T15:49:06Z,2
CVE-2018-11219,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,redis,"Security: update Lua struct package for security.

During an auditing Apple found that the ""struct"" Lua package
we ship with Redis (http://www.inf.puc-rio.br/~roberto/struct/) contains
a security problem. A bound-checking statement fails because of integer
overflow. The bug exists since we initially integrated this package with
Lua, when scripting was introduced, so every version of Redis with
EVAL/EVALSHA capabilities exposed is affected.

Instead of just fixing the bug, the library was updated to the latest
version shipped by the author.",1eb08bcd4634ae42ec45e8284923ac048beaa4c3,https://github.com/redis/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,deps/lua/src/lua_struct.c,b_unpack,"static int b_unpack (lua_State *L) {
Header h;
const char *fmt = luaL_checkstring(L, 1);
size_t ld;
const char *data = luaL_checklstring(L, 2, &ld);
size_t pos = luaL_optinteger(L, 3, 1) - 1;
defaultoptions(&h);
lua_settop(L, 2);
while (*fmt) {
int opt = *fmt++;
size_t size = optsize(L, opt, &fmt);
pos += gettoalign(pos, &h, opt, size);
luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
luaL_checkstack(L, 1, ""too many results"");
switch (opt) {
case 'b': case 'B': case 'h': case 'H':
case 'l': case 'L': case 'T': case 'i':  case 'I': {  
int issigned = islower(opt);
lua_Number res = getinteger(data+pos, h.endian, issigned, size);
lua_pushnumber(L, res);
break;
}
case 'x': {
break;
}
case 'f': {
float f;
memcpy(&f, data+pos, size);
correctbytes((char *)&f, sizeof(f), h.endian);
lua_pushnumber(L, f);
break;
}
case 'd': {
double d;
memcpy(&d, data+pos, size);
correctbytes((char *)&d, sizeof(d), h.endian);
lua_pushnumber(L, d);
break;
}
case 'c': {
if (size == 0) {
if (!lua_isnumber(L, -1))
luaL_error(L, ""format `c0' needs a previous size"");
size = lua_tonumber(L, -1);
lua_pop(L, 1);
luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
}
lua_pushlstring(L, data+pos, size);
break;
}
case 's': {
const char *e = (const char *)memchr(data+pos, '\0', ld - pos);
if (e == NULL)
luaL_error(L, ""unfinished string in data"");
size = (e - (data+pos)) + 1;
lua_pushlstring(L, data+pos, size - 1);
break;
}
default: controloptions(L, opt, &fmt, &h);
}
pos += size;
}
lua_pushinteger(L, pos + 1);
return lua_gettop(L) - 2;
}","static int b_unpack (lua_State *VAR_0) {
Header VAR_1;
const char *VAR_2 = luaL_checkstring(VAR_0, 1);
size_t VAR_3;
const char *VAR_4 = luaL_checklstring(VAR_0, 2, &VAR_3);
size_t VAR_5 = luaL_optinteger(VAR_0, 3, 1) - 1;
defaultoptions(&VAR_1);
lua_settop(VAR_0, 2);
while (*VAR_2) {
int VAR_6 = *VAR_2++;
size_t VAR_7 = optsize(VAR_0, VAR_6, &VAR_2);
VAR_5 += gettoalign(VAR_5, &VAR_1, VAR_6, VAR_7);
luaL_argcheck(VAR_0, VAR_5+VAR_7 <= VAR_3, 2, ""data string too short"");
luaL_checkstack(VAR_0, 1, ""too many results"");
switch (VAR_6) {
case 'b': case 'B': case 'h': case 'H':
case 'l': case 'L': case 'T': case 'i':  case 'I': {  
int VAR_8 = islower(VAR_6);
lua_Number VAR_9 = getinteger(VAR_4+VAR_5, VAR_1.endian, VAR_8, VAR_7);
lua_pushnumber(VAR_0, VAR_9);
break;
}
case 'x': {
break;
}
case 'f': {
float VAR_10;
memcpy(&VAR_10, VAR_4+VAR_5, VAR_7);
correctbytes((char *)&VAR_10, sizeof(VAR_10), VAR_1.endian);
lua_pushnumber(VAR_0, VAR_10);
break;
}
case 'd': {
double VAR_11;
memcpy(&VAR_11, VAR_4+VAR_5, VAR_7);
correctbytes((char *)&VAR_11, sizeof(VAR_11), VAR_1.endian);
lua_pushnumber(VAR_0, VAR_11);
break;
}
case 'c': {
if (VAR_7 == 0) {
if (!lua_isnumber(VAR_0, -1))
luaL_error(VAR_0, ""format `c0' needs a previous size"");
VAR_7 = lua_tonumber(VAR_0, -1);
lua_pop(VAR_0, 1);
luaL_argcheck(VAR_0, VAR_5+VAR_7 <= VAR_3, 2, ""data string too short"");
}
lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_7);
break;
}
case 's': {
const char *VAR_12 = (const char *)memchr(VAR_4+VAR_5, '\0', VAR_3 - VAR_5);
if (VAR_12 == NULL)
luaL_error(VAR_0, ""unfinished string in data"");
VAR_7 = (VAR_12 - (VAR_4+VAR_5)) + 1;
lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_7 - 1);
break;
}
default: controloptions(VAR_0, VAR_6, &VAR_2, &VAR_1);
}
VAR_5 += VAR_7;
}
lua_pushinteger(VAR_0, VAR_5 + 1);
return lua_gettop(VAR_0) - 2;
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/before/0.json,"static int b_unpack (lua_State *L) {
  Header h;
  const char *fmt = luaL_checkstring(L, 1);
  size_t ld;
  const char *data = luaL_checklstring(L, 2, &ld);
  size_t pos = luaL_optinteger(L, 3, 1) - 1;
  int n = 0;  /* number of results */
  defaultoptions(&h);
  while (*fmt) {
    int opt = *fmt++;
    size_t size = optsize(L, opt, &fmt);
    pos += gettoalign(pos, &h, opt, size);
    luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
    /* stack space for item + next position */
    luaL_checkstack(L, 2, ""too many results"");
    switch (opt) {
      case 'b': case 'B': case 'h': case 'H':
      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */
        int issigned = islower(opt);
        lua_Number res = getinteger(data+pos, h.endian, issigned, size);
        lua_pushnumber(L, res); n++;
        break;
      }
      case 'x': {
        break;
      }
      case 'f': {
        float f;
        memcpy(&f, data+pos, size);
        correctbytes((char *)&f, sizeof(f), h.endian);
        lua_pushnumber(L, f); n++;
        break;
      }
      case 'd': {
        double d;
        memcpy(&d, data+pos, size);
        correctbytes((char *)&d, sizeof(d), h.endian);
        lua_pushnumber(L, d); n++;
        break;
      }
      case 'c': {
        if (size == 0) {
          if (n == 0 || !lua_isnumber(L, -1))
            luaL_error(L, ""format 'c0' needs a previous size"");
          size = lua_tonumber(L, -1);
          lua_pop(L, 1); n--;
          luaL_argcheck(L, size <= ld && pos <= ld - size,
                           2, ""data string too short"");
        }
        lua_pushlstring(L, data+pos, size); n++;
        break;
      }
      case 's': {
        const char *e = (const char *)memchr(data+pos, '\0', ld - pos);
        if (e == NULL)
          luaL_error(L, ""unfinished string in data"");
        size = (e - (data+pos)) + 1;
        lua_pushlstring(L, data+pos, size - 1); n++;
        break;
      }
      default: controloptions(L, opt, &fmt, &h);
    }
    pos += size;
  }
  lua_pushinteger(L, pos + 1);  /* next position */
  return n + 1;
}","static int b_unpack (lua_State *VAR_0) {
  Header VAR_1;
  const char *VAR_2 = luaL_checkstring(VAR_0, 1);
  size_t VAR_3;
  const char *VAR_4 = luaL_checklstring(VAR_0, 2, &VAR_3);
  size_t VAR_5 = luaL_optinteger(VAR_0, 3, 1) - 1;
  int VAR_6 = 0;  /* COMMENT_0 */
  defaultoptions(&VAR_1);
  while (*VAR_2) {
    int VAR_7 = *VAR_2++;
    size_t VAR_8 = optsize(VAR_0, VAR_7, &VAR_2);
    VAR_5 += gettoalign(VAR_5, &VAR_1, VAR_7, VAR_8);
    luaL_argcheck(VAR_0, VAR_5+VAR_8 <= VAR_3, 2, ""data string too short"");
    /* COMMENT_1 */
    luaL_checkstack(VAR_0, 2, ""too many results"");
    switch (VAR_7) {
      case 'b': case 'B': case 'h': case 'H':
      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* COMMENT_2 */
        int VAR_9 = islower(VAR_7);
        lua_Number VAR_10 = getinteger(VAR_4+VAR_5, VAR_1.endian, VAR_9, VAR_8);
        lua_pushnumber(VAR_0, VAR_10); VAR_6++;
        break;
      }
      case 'x': {
        break;
      }
      case 'f': {
        float VAR_11;
        memcpy(&VAR_11, VAR_4+VAR_5, VAR_8);
        correctbytes((char *)&VAR_11, sizeof(VAR_11), VAR_1.endian);
        lua_pushnumber(VAR_0, VAR_11); VAR_6++;
        break;
      }
      case 'd': {
        double VAR_12;
        memcpy(&VAR_12, VAR_4+VAR_5, VAR_8);
        correctbytes((char *)&VAR_12, sizeof(VAR_12), VAR_1.endian);
        lua_pushnumber(VAR_0, VAR_12); VAR_6++;
        break;
      }
      case 'c': {
        if (VAR_8 == 0) {
          if (VAR_6 == 0 || !lua_isnumber(VAR_0, -1))
            luaL_error(VAR_0, ""format 'c0' needs a previous size"");
          VAR_8 = lua_tonumber(VAR_0, -1);
          lua_pop(VAR_0, 1); VAR_6--;
          luaL_argcheck(VAR_0, VAR_8 <= VAR_3 && VAR_5 <= VAR_3 - VAR_8,
                           2, ""data string too short"");
        }
        lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_8); VAR_6++;
        break;
      }
      case 's': {
        const char *VAR_13 = (const char *)memchr(VAR_4+VAR_5, '\0', VAR_3 - VAR_5);
        if (VAR_13 == NULL)
          luaL_error(VAR_0, ""unfinished string in data"");
        VAR_8 = (VAR_13 - (VAR_4+VAR_5)) + 1;
        lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_8 - 1); VAR_6++;
        break;
      }
      default: controloptions(VAR_0, VAR_7, &VAR_2, &VAR_1);
    }
    VAR_5 += VAR_8;
  }
  lua_pushinteger(VAR_0, VAR_5 + 1);  /* COMMENT_3 */
  return VAR_6 + 1;
}",redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3/lua_struct.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,20 +4,21 @@
   size_t ld;
   const char *data = luaL_checklstring(L, 2, &ld);
   size_t pos = luaL_optinteger(L, 3, 1) - 1;
+  int n = 0;  /* number of results */
   defaultoptions(&h);
-  lua_settop(L, 2);
   while (*fmt) {
     int opt = *fmt++;
     size_t size = optsize(L, opt, &fmt);
     pos += gettoalign(pos, &h, opt, size);
     luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
-    luaL_checkstack(L, 1, ""too many results"");
+    /* stack space for item + next position */
+    luaL_checkstack(L, 2, ""too many results"");
     switch (opt) {
       case 'b': case 'B': case 'h': case 'H':
       case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */
         int issigned = islower(opt);
         lua_Number res = getinteger(data+pos, h.endian, issigned, size);
-        lua_pushnumber(L, res);
+        lua_pushnumber(L, res); n++;
         break;
       }
       case 'x': {
@@ -27,25 +28,26 @@
         float f;
         memcpy(&f, data+pos, size);
         correctbytes((char *)&f, sizeof(f), h.endian);
-        lua_pushnumber(L, f);
+        lua_pushnumber(L, f); n++;
         break;
       }
       case 'd': {
         double d;
         memcpy(&d, data+pos, size);
         correctbytes((char *)&d, sizeof(d), h.endian);
-        lua_pushnumber(L, d);
+        lua_pushnumber(L, d); n++;
         break;
       }
       case 'c': {
         if (size == 0) {
-          if (!lua_isnumber(L, -1))
-            luaL_error(L, ""format `c0' needs a previous size"");
+          if (n == 0 || !lua_isnumber(L, -1))
+            luaL_error(L, ""format 'c0' needs a previous size"");
           size = lua_tonumber(L, -1);
-          lua_pop(L, 1);
-          luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
+          lua_pop(L, 1); n--;
+          luaL_argcheck(L, size <= ld && pos <= ld - size,
+                           2, ""data string too short"");
         }
-        lua_pushlstring(L, data+pos, size);
+        lua_pushlstring(L, data+pos, size); n++;
         break;
       }
       case 's': {
@@ -53,13 +55,13 @@
         if (e == NULL)
           luaL_error(L, ""unfinished string in data"");
         size = (e - (data+pos)) + 1;
-        lua_pushlstring(L, data+pos, size - 1);
+        lua_pushlstring(L, data+pos, size - 1); n++;
         break;
       }
       default: controloptions(L, opt, &fmt, &h);
     }
     pos += size;
   }
-  lua_pushinteger(L, pos + 1);
-  return lua_gettop(L) - 2;
+  lua_pushinteger(L, pos + 1);  /* next position */
+  return n + 1;
 }","{'deleted_lines': ['  lua_settop(L, 2);', '    luaL_checkstack(L, 1, ""too many results"");', '        lua_pushnumber(L, res);', '        lua_pushnumber(L, f);', '        lua_pushnumber(L, d);', '          if (!lua_isnumber(L, -1))', '            luaL_error(L, ""format `c0\' needs a previous size"");', '          lua_pop(L, 1);', '          luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");', '        lua_pushlstring(L, data+pos, size);', '        lua_pushlstring(L, data+pos, size - 1);', '  lua_pushinteger(L, pos + 1);', '  return lua_gettop(L) - 2;'], 'added_lines': ['  int n = 0;  /* number of results */', '    /* stack space for item + next position */', '    luaL_checkstack(L, 2, ""too many results"");', '        lua_pushnumber(L, res); n++;', '        lua_pushnumber(L, f); n++;', '        lua_pushnumber(L, d); n++;', '          if (n == 0 || !lua_isnumber(L, -1))', '            luaL_error(L, ""format \'c0\' needs a previous size"");', '          lua_pop(L, 1); n--;', '          luaL_argcheck(L, size <= ld && pos <= ld - size,', '                           2, ""data string too short"");', '        lua_pushlstring(L, data+pos, size); n++;', '        lua_pushlstring(L, data+pos, size - 1); n++;', '  lua_pushinteger(L, pos + 1);  /* next position */', '  return n + 1;']}",True,"An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking.",9.8,CRITICAL,3,test,2018-05-14T15:49:06Z,2
CVE-2018-14344,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"ISMP: fix tuple decoding

EDP_TUPLE_HOLD dissection was broken due to a length parameter mixup in
v1.99.1rc0-224-g6720c80bab. The TLV length calculation was changed in
commit ed5453d892, but the only pcap I could find for which it made a
difference includes the TL lengths in the length field.

Since commit 067a076179, the IPXNET type was wrongly decoded, fixed now.
Check IPX address length to avoid a buffer overrun (read) in
get_ether_name by at most 5 bytes.

Bug: 4943
Bug: 14672
Link: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=6451
Change-Id: Ia99ab15578ecae6d5a3ec22989507d64f9926933
Reviewed-on: https://code.wireshark.org/review/27554
Petri-Dish: Peter Wu <peter@lekensteyn.nl>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit e67283ddca70a7652b7dd41ef8883ee3278501d0)
Reviewed-on: https://code.wireshark.org/review/27925
Reviewed-by: Guy Harris <guy@alum.mit.edu>",4f7153685b39a164aea09ba7f96ebb648b8328ae,https://github.com/wireshark/wireshark/commit/4f7153685b39a164aea09ba7f96ebb648b8328ae,epan/dissectors/packet-ismp.c,dissect_ismp_edp,"static void
dissect_ismp_edp(tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *ismp_tree)
{
int neighbors_count = 0;
int tuples_count = 0;
guint16 device_type = 0;
guint16 num_neighbors = 0;
guint16 num_tuples = 0;
guint16 tuple_type = 0;
guint16 tuple_length = 0;
proto_item *edp_ti, *ti;
proto_tree *edp_tree;
proto_item *edp_neighbors_ti;
proto_tree *edp_neighbors_tree;
proto_tree *edp_neighbors_leaf_tree;
proto_item *edp_tuples_ti;
proto_tree *edp_tuples_tree;
proto_tree *edp_tuples_leaf_tree;
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""ISMP.EDP"");
col_clear(pinfo->cinfo, COL_INFO);
edp_ti  = proto_tree_add_item(ismp_tree, hf_ismp_edp, tvb, offset, -1, ENC_NA);
edp_tree = proto_item_add_subtree(edp_ti, ett_ismp_edp);
col_add_fstr(pinfo->cinfo, COL_INFO, ""MIP %s, MMAC %s, ifIdx %d"",
tvb_ip_to_str(tvb, offset+2),
tvb_ether_to_str(tvb, offset+6),
tvb_get_ntohl(tvb, offset+12));
proto_tree_add_item(edp_tree, hf_ismp_edp_version, tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
proto_tree_add_item(edp_tree, hf_ismp_edp_module_ip, tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(edp_tree, hf_ismp_edp_module_mac, tvb, offset, 6, ENC_NA);
offset += 6;
proto_tree_add_item(edp_tree, hf_ismp_edp_module_port, tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_mac, tvb, offset, 6, ENC_NA);
offset += 6;
proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_ip, tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 4;
device_type = tvb_get_ntohs(tvb, offset);
proto_tree_add_item(edp_tree, hf_ismp_edp_device_type, tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
proto_tree_add_uint_format_value(edp_tree, hf_ismp_edp_module_rev, tvb, offset, 4, tvb_get_ntohl(tvb, offset),
""%02x.%02x.%02x.%02x"", tvb_get_guint8(tvb, offset),
tvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2), tvb_get_guint8(tvb, offset+3));
offset += 4;
switch (device_type) {
case EDP_DEVICE_TYPE_SFS17:
case EDP_DEVICE_TYPE_SFS18:
{
static const gint *options[] = {
&hf_ismp_edp_sfs_option_uplink_flood,
&hf_ismp_edp_sfs_option_uplink_port,
&hf_ismp_edp_sfs_option_uplink_core,
&hf_ismp_edp_sfs_option_uplink_switch,
&hf_ismp_edp_sfs_option_isolated,
&hf_ismp_edp_sfs_option_redun,
&hf_ismp_edp_sfs_option_conmsg,
&hf_ismp_edp_sfs_option_calltap,
&hf_ismp_edp_sfs_option_tagflood,
&hf_ismp_edp_sfs_option_unused2,
&hf_ismp_edp_sfs_option_resolve,
&hf_ismp_edp_sfs_option_flood,
&hf_ismp_edp_sfs_option_lsp,
&hf_ismp_edp_sfs_option_sfssup,
&hf_ismp_edp_sfs_option_unused1,
NULL
};
proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
}
break;
case EDP_DEVICE_TYPE_ROUTER:
{
static const gint *options[] = {
&hf_ismp_edp_rtr_option_level1,
&hf_ismp_edp_rtr_option_trans,
&hf_ismp_edp_rtr_option_route,
&hf_ismp_edp_rtr_option_igmp_snoop,
&hf_ismp_edp_rtr_option_gmrp,
&hf_ismp_edp_rtr_option_gvrp,
&hf_ismp_edp_rtr_option_8021q,
&hf_ismp_edp_rtr_option_dvmrp,
&hf_ismp_edp_rtr_option_ospf,
&hf_ismp_edp_rtr_option_bgp,
&hf_ismp_edp_rtr_option_rip,
&hf_ismp_edp_rtr_option_igmp,
&hf_ismp_edp_rtr_option_ssr,
NULL
};
proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
}
break;
case EDP_DEVICE_TYPE_BRIDGE:
{
static const gint *options[] = {
&hf_ismp_edp_switch_option_level1,
&hf_ismp_edp_switch_option_trans,
&hf_ismp_edp_switch_option_route,
&hf_ismp_edp_switch_option_igmp,
&hf_ismp_edp_switch_option_gmrp,
&hf_ismp_edp_switch_option_gvrp,
&hf_ismp_edp_switch_option_8021q,
NULL
};
proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
}
break;
case EDP_DEVICE_TYPE_NTSERVER:
case EDP_DEVICE_TYPE_NTCLIENT:
case EDP_DEVICE_TYPE_WIN95:
case EDP_DEVICE_TYPE_WIN98:
case EDP_DEVICE_TYPE_UNIXSERVER:
case EDP_DEVICE_TYPE_UNIXCLIENT:
{
static const gint *options[] = {
&hf_ismp_edp_end_station_option_ad,
&hf_ismp_edp_end_station_option_dns,
&hf_ismp_edp_end_station_option_dhcp,
NULL
};
proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
}
break;
case EDP_DEVICE_TYPE_VLANMAN:
case EDP_DEVICE_TYPE_ACCESSPOINT:
default:
proto_tree_add_item(edp_tree, hf_ismp_edp_options, tvb, offset, 4, ENC_BIG_ENDIAN);
break;
}
offset += 4;
num_neighbors = tvb_get_ntohs(tvb, offset);
proto_tree_add_item(edp_tree, hf_ismp_edp_num_neighbors, tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
if (num_neighbors > 0)
{
edp_neighbors_ti = proto_tree_add_item(edp_tree, hf_ismp_edp_neighbors, tvb,
offset, num_neighbors*10, ENC_NA);
edp_neighbors_tree = proto_item_add_subtree(edp_neighbors_ti, ett_ismp_edp_neighbors);
while ( neighbors_count < num_neighbors && tvb_reported_length_remaining(tvb, offset) >= 10)
{
edp_neighbors_leaf_tree = proto_tree_add_subtree_format(edp_neighbors_tree, tvb, offset, 10,
ett_ismp_edp_neighbors_leaf, NULL, ""Neighbor%d"", (neighbors_count+1));
proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_neighborhood_mac_address, tvb, offset, 6, ENC_NA);
proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_assigned_neighbor_state, tvb, offset, 4, ENC_BIG_ENDIAN);
offset += 10;
neighbors_count++;
}
if (neighbors_count != num_neighbors)
{
proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);
return;
}
}
if (tvb_reported_length_remaining(tvb, offset) != 0 &&
tvb_reported_length_remaining(tvb, offset) >= 2)
{
num_tuples = tvb_get_ntohs(tvb, offset);
proto_tree_add_item(edp_tree, hf_ismp_edp_num_tuples, tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
}
else if (tvb_reported_length_remaining(tvb, offset) > 0) {
proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);
return;
}
else
{
return;
}
if (num_tuples && tvb_reported_length_remaining(tvb, offset) >= 4)
{
edp_tuples_ti = proto_tree_add_bytes_format(edp_tree, hf_ismp_edp_tuples, tvb,
offset, -1, NULL, ""Tuples"");
edp_tuples_tree = proto_item_add_subtree(edp_tuples_ti, ett_ismp_edp_tuples);
while ( (tuples_count < num_tuples) && (tvb_reported_length_remaining(tvb, offset) >= 4) )
{
tuple_length = tvb_get_ntohs(tvb, offset+2);
edp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, tuple_length,
ett_ismp_edp_tuples_leaf, NULL, ""Tuple%d"", tuples_count+1);
tuple_type = tvb_get_ntohs(tvb, offset);
proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_type, tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN);
offset += 2;
if (tvb_reported_length_remaining(tvb, offset) >= tuple_length)
{
switch (tuple_type)
{
case EDP_TUPLE_HOLD:
ti = proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, hf_ismp_hold_time, ENC_BIG_ENDIAN);
proto_item_set_len(ti, tuple_length);
break;
case EDP_TUPLE_INT_NAME:
proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_interface_name, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
col_append_fstr(pinfo->cinfo, COL_INFO, "", ifName %s"",
tvb_format_text(tvb, offset, tuple_length));
break;
case EDP_TUPLE_SYS_DESCRIPT:
proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_system_description, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
break;
case EDP_TUPLE_IPX_ADDR:
proto_tree_add_string(edp_tuples_leaf_tree, hf_ismp_interface_ipx_address ,tvb, offset, tuple_length,
ipx_addr_to_str(tvb_get_ntohl(tvb, offset),
tvb_get_string_enc(wmem_packet_scope(), tvb, offset+4, tuple_length-4, ENC_ASCII)));
break;
case EDP_TUPLE_UNKNOWN:
default:
proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_unknown_tuple_data, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
break;
}
}
offset += tuple_length;
tuples_count++;
}
if (tuples_count != num_tuples)
proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);
return;
}
}","static void
dissect_ismp_edp(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, proto_tree *VAR_3)
{
int VAR_4 = 0;
int VAR_5 = 0;
guint16 VAR_6 = 0;
guint16 VAR_7 = 0;
guint16 VAR_8 = 0;
guint16 VAR_9 = 0;
guint16 VAR_10 = 0;
proto_item *VAR_11, *VAR_12;
proto_tree *VAR_13;
proto_item *VAR_14;
proto_tree *VAR_15;
proto_tree *VAR_16;
proto_item *VAR_17;
proto_tree *VAR_18;
proto_tree *VAR_19;
col_set_str(VAR_1->cinfo, VAR_20, ""ISMP.EDP"");
col_clear(VAR_1->cinfo, VAR_21);
VAR_11  = proto_tree_add_item(VAR_3, VAR_22, VAR_0, VAR_2, -1, VAR_23);
VAR_13 = proto_item_add_subtree(VAR_11, VAR_24);
col_add_fstr(VAR_1->cinfo, VAR_21, ""MIP %s, MMAC %s, ifIdx %d"",
tvb_ip_to_str(VAR_0, VAR_2+2),
tvb_ether_to_str(VAR_0, VAR_2+6),
tvb_get_ntohl(VAR_0, VAR_2+12));
proto_tree_add_item(VAR_13, VAR_25, VAR_0, VAR_2, 2, VAR_26);
VAR_2 += 2;
proto_tree_add_item(VAR_13, VAR_27, VAR_0, VAR_2, 4, VAR_26);
VAR_2 += 4;
proto_tree_add_item(VAR_13, VAR_28, VAR_0, VAR_2, 6, VAR_23);
VAR_2 += 6;
proto_tree_add_item(VAR_13, VAR_29, VAR_0, VAR_2, 4, VAR_26);
VAR_2 += 4;
proto_tree_add_item(VAR_13, VAR_30, VAR_0, VAR_2, 6, VAR_23);
VAR_2 += 6;
proto_tree_add_item(VAR_13, VAR_31, VAR_0, VAR_2, 4, VAR_26);
VAR_2 += 4;
VAR_6 = tvb_get_ntohs(VAR_0, VAR_2);
proto_tree_add_item(VAR_13, VAR_32, VAR_0, VAR_2, 2, VAR_26);
VAR_2 += 2;
proto_tree_add_uint_format_value(VAR_13, VAR_33, VAR_0, VAR_2, 4, tvb_get_ntohl(VAR_0, VAR_2),
""%02x.%02x.%02x.%02x"", tvb_get_guint8(VAR_0, VAR_2),
tvb_get_guint8(VAR_0, VAR_2+1), tvb_get_guint8(VAR_0, VAR_2+2), tvb_get_guint8(VAR_0, VAR_2+3));
VAR_2 += 4;
switch (VAR_6) {
case VAR_34:
case VAR_35:
{
static const gint *VAR_36[] = {
&VAR_37,
&VAR_38,
&VAR_39,
&VAR_40,
&VAR_41,
&VAR_42,
&VAR_43,
&VAR_44,
&VAR_45,
&VAR_46,
&VAR_47,
&VAR_48,
&VAR_49,
&VAR_50,
&VAR_51,
NULL
};
proto_tree_add_bitmask(VAR_13, VAR_0, VAR_2, VAR_52, VAR_53, VAR_36, VAR_26);
}
break;
case VAR_54:
{
static const gint *VAR_36[] = {
&VAR_55,
&VAR_56,
&VAR_57,
&VAR_58,
&VAR_59,
&VAR_60,
&VAR_61,
&VAR_62,
&VAR_63,
&VAR_64,
&VAR_65,
&VAR_66,
&VAR_67,
NULL
};
proto_tree_add_bitmask(VAR_13, VAR_0, VAR_2, VAR_52, VAR_53, VAR_36, VAR_26);
}
break;
case VAR_68:
{
static const gint *VAR_36[] = {
&VAR_69,
&VAR_70,
&VAR_71,
&VAR_72,
&VAR_73,
&VAR_74,
&VAR_75,
NULL
};
proto_tree_add_bitmask(VAR_13, VAR_0, VAR_2, VAR_52, VAR_53, VAR_36, VAR_26);
}
break;
case VAR_76:
case VAR_77:
case VAR_78:
case VAR_79:
case VAR_80:
case VAR_81:
{
static const gint *VAR_36[] = {
&VAR_82,
&VAR_83,
&VAR_84,
NULL
};
proto_tree_add_bitmask(VAR_13, VAR_0, VAR_2, VAR_52, VAR_53, VAR_36, VAR_26);
}
break;
case VAR_85:
case VAR_86:
default:
proto_tree_add_item(VAR_13, VAR_52, VAR_0, VAR_2, 4, VAR_26);
break;
}
VAR_2 += 4;
VAR_7 = tvb_get_ntohs(VAR_0, VAR_2);
proto_tree_add_item(VAR_13, VAR_87, VAR_0, VAR_2, 2, VAR_26);
VAR_2 += 2;
if (VAR_7 > 0)
{
VAR_14 = proto_tree_add_item(VAR_13, VAR_88, VAR_0,
VAR_2, VAR_7*10, VAR_23);
VAR_15 = proto_item_add_subtree(VAR_14, VAR_89);
while ( VAR_4 < VAR_7 && tvb_reported_length_remaining(VAR_0, VAR_2) >= 10)
{
VAR_16 = proto_tree_add_subtree_format(VAR_15, VAR_0, VAR_2, 10,
VAR_90, NULL, ""Neighbor%d"", (VAR_4+1));
proto_tree_add_item(VAR_16, VAR_91, VAR_0, VAR_2, 6, VAR_23);
proto_tree_add_item(VAR_16, VAR_92, VAR_0, VAR_2, 4, VAR_26);
VAR_2 += 10;
VAR_4++;
}
if (VAR_4 != VAR_7)
{
proto_tree_add_expert(VAR_13, VAR_1, &VAR_93, VAR_0, VAR_2, -1);
return;
}
}
if (tvb_reported_length_remaining(VAR_0, VAR_2) != 0 &&
tvb_reported_length_remaining(VAR_0, VAR_2) >= 2)
{
VAR_8 = tvb_get_ntohs(VAR_0, VAR_2);
proto_tree_add_item(VAR_13, VAR_94, VAR_0, VAR_2, 2, VAR_26);
VAR_2 += 2;
}
else if (tvb_reported_length_remaining(VAR_0, VAR_2) > 0) {
proto_tree_add_expert(VAR_13, VAR_1, &VAR_93, VAR_0, VAR_2, -1);
return;
}
else
{
return;
}
if (VAR_8 && tvb_reported_length_remaining(VAR_0, VAR_2) >= 4)
{
VAR_17 = proto_tree_add_bytes_format(VAR_13, VAR_95, VAR_0,
VAR_2, -1, NULL, ""Tuples"");
VAR_18 = proto_item_add_subtree(VAR_17, VAR_96);
while ( (VAR_5 < VAR_8) && (tvb_reported_length_remaining(VAR_0, VAR_2) >= 4) )
{
VAR_10 = tvb_get_ntohs(VAR_0, VAR_2+2);
VAR_19 = proto_tree_add_subtree_format(VAR_18, VAR_0, VAR_2, VAR_10,
VAR_97, NULL, ""Tuple%d"", VAR_5+1);
VAR_9 = tvb_get_ntohs(VAR_0, VAR_2);
proto_tree_add_item(VAR_19, VAR_98, VAR_0, VAR_2, 2, VAR_26);
VAR_2 += 2;
proto_tree_add_item(VAR_19, VAR_99, VAR_0, VAR_2, 2, VAR_26);
VAR_2 += 2;
if (tvb_reported_length_remaining(VAR_0, VAR_2) >= VAR_10)
{
switch (VAR_9)
{
case VAR_100:
VAR_12 = proto_tree_add_item(VAR_19, VAR_101, VAR_0, VAR_2, VAR_101, VAR_26);
proto_item_set_len(VAR_12, VAR_10);
break;
case VAR_102:
proto_tree_add_item(VAR_19, VAR_103, VAR_0, VAR_2, VAR_10, VAR_23|VAR_104);
col_append_fstr(VAR_1->cinfo, VAR_21, "", ifName %s"",
tvb_format_text(VAR_0, VAR_2, VAR_10));
break;
case VAR_105:
proto_tree_add_item(VAR_19, VAR_106, VAR_0, VAR_2, VAR_10, VAR_23|VAR_104);
break;
case VAR_107:
proto_tree_add_string(VAR_19, VAR_108 ,VAR_0, VAR_2, VAR_10,
ipx_addr_to_str(tvb_get_ntohl(VAR_0, VAR_2),
tvb_get_string_enc(wmem_packet_scope(), VAR_0, VAR_2+4, VAR_10-4, VAR_104)));
break;
case VAR_109:
default:
proto_tree_add_item(VAR_19, VAR_110, VAR_0, VAR_2, VAR_10, VAR_23|VAR_104);
break;
}
}
VAR_2 += VAR_10;
VAR_5++;
}
if (VAR_5 != VAR_8)
proto_tree_add_expert(VAR_13, VAR_1, &VAR_93, VAR_0, VAR_2, -1);
return;
}
}",wireshark/4f7153685b39a164aea09ba7f96ebb648b8328ae/packet-ismp.c/vul/before/0.json,"static void
dissect_ismp_edp(tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *ismp_tree)
{
	/* local variables used for EDP dissection */
	int neighbors_count = 0;
	int tuples_count = 0;
	guint16 device_type = 0;
	guint16 num_neighbors = 0;
	guint16 num_tuples = 0;
	guint16 tuple_type = 0;
	guint32 tuple_length = 0;

	/* Set up structures needed to add the protocol subtree and manage it */
	proto_item *edp_ti;
	proto_tree *edp_tree;

	proto_item *edp_neighbors_ti;
	proto_tree *edp_neighbors_tree;

	proto_tree *edp_neighbors_leaf_tree;

	proto_item *edp_tuples_ti;
	proto_tree *edp_tuples_tree;

	proto_tree *edp_tuples_leaf_tree;

	/* add column information marking this as EDP (Enterasys Discover Protocol */
	col_set_str(pinfo->cinfo, COL_PROTOCOL, ""ISMP.EDP"");
	col_clear(pinfo->cinfo, COL_INFO);

	/* create display subtree for EDP */
		edp_ti  = proto_tree_add_item(ismp_tree, hf_ismp_edp, tvb, offset, -1, ENC_NA);
		edp_tree = proto_item_add_subtree(edp_ti, ett_ismp_edp);

		col_add_fstr(pinfo->cinfo, COL_INFO, ""MIP %s, MMAC %s, ifIdx %d"",
			tvb_ip_to_str(tvb, offset+2),
			tvb_ether_to_str(tvb, offset+6),
			tvb_get_ntohl(tvb, offset+12));

		proto_tree_add_item(edp_tree, hf_ismp_edp_version, tvb, offset, 2, ENC_BIG_ENDIAN);
		offset += 2;
		proto_tree_add_item(edp_tree, hf_ismp_edp_module_ip, tvb, offset, 4, ENC_BIG_ENDIAN);
		offset += 4;
		proto_tree_add_item(edp_tree, hf_ismp_edp_module_mac, tvb, offset, 6, ENC_NA);
		offset += 6;
		proto_tree_add_item(edp_tree, hf_ismp_edp_module_port, tvb, offset, 4, ENC_BIG_ENDIAN);
		offset += 4;
		proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_mac, tvb, offset, 6, ENC_NA);
		offset += 6;
		proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_ip, tvb, offset, 4, ENC_BIG_ENDIAN);
		offset += 4;
		device_type = tvb_get_ntohs(tvb, offset);
		proto_tree_add_item(edp_tree, hf_ismp_edp_device_type, tvb, offset, 2, ENC_BIG_ENDIAN);
		offset += 2;
		proto_tree_add_uint_format_value(edp_tree, hf_ismp_edp_module_rev, tvb, offset, 4, tvb_get_ntohl(tvb, offset),
			""%02x.%02x.%02x.%02x"", tvb_get_guint8(tvb, offset),
			tvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2), tvb_get_guint8(tvb, offset+3));
		offset += 4;

		/* depending on device_type, show the appropriate options */
		switch (device_type) {
			case EDP_DEVICE_TYPE_SFS17:
			case EDP_DEVICE_TYPE_SFS18:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_sfs_option_uplink_flood,
			        &hf_ismp_edp_sfs_option_uplink_port,
			        &hf_ismp_edp_sfs_option_uplink_core,
			        &hf_ismp_edp_sfs_option_uplink_switch,
			        &hf_ismp_edp_sfs_option_isolated,
			        &hf_ismp_edp_sfs_option_redun,
			        &hf_ismp_edp_sfs_option_conmsg,
			        &hf_ismp_edp_sfs_option_calltap,
			        &hf_ismp_edp_sfs_option_tagflood,
			        &hf_ismp_edp_sfs_option_unused2,
			        &hf_ismp_edp_sfs_option_resolve,
			        &hf_ismp_edp_sfs_option_flood,
			        &hf_ismp_edp_sfs_option_lsp,
			        &hf_ismp_edp_sfs_option_sfssup,
			        &hf_ismp_edp_sfs_option_unused1,
		            NULL
		        };
		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_ROUTER:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_rtr_option_level1,
			        &hf_ismp_edp_rtr_option_trans,
			        &hf_ismp_edp_rtr_option_route,
			        &hf_ismp_edp_rtr_option_igmp_snoop,
			        &hf_ismp_edp_rtr_option_gmrp,
			        &hf_ismp_edp_rtr_option_gvrp,
			        &hf_ismp_edp_rtr_option_8021q,
			        &hf_ismp_edp_rtr_option_dvmrp,
			        &hf_ismp_edp_rtr_option_ospf,
			        &hf_ismp_edp_rtr_option_bgp,
			        &hf_ismp_edp_rtr_option_rip,
			        &hf_ismp_edp_rtr_option_igmp,
			        &hf_ismp_edp_rtr_option_ssr,
		            NULL
		        };

		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_BRIDGE:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_switch_option_level1,
			        &hf_ismp_edp_switch_option_trans,
			        &hf_ismp_edp_switch_option_route,
			        &hf_ismp_edp_switch_option_igmp,
			        &hf_ismp_edp_switch_option_gmrp,
			        &hf_ismp_edp_switch_option_gvrp,
			        &hf_ismp_edp_switch_option_8021q,
		            NULL
		        };

		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_NTSERVER:
			case EDP_DEVICE_TYPE_NTCLIENT:
			case EDP_DEVICE_TYPE_WIN95:
			case EDP_DEVICE_TYPE_WIN98:
			case EDP_DEVICE_TYPE_UNIXSERVER:
			case EDP_DEVICE_TYPE_UNIXCLIENT:
                {
		        static const gint *options[] = {
			        &hf_ismp_edp_end_station_option_ad,
			        &hf_ismp_edp_end_station_option_dns,
			        &hf_ismp_edp_end_station_option_dhcp,
		            NULL
		        };

		        proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN);
                }
				break;
			case EDP_DEVICE_TYPE_VLANMAN:
			case EDP_DEVICE_TYPE_ACCESSPOINT:
			default:
		        proto_tree_add_item(edp_tree, hf_ismp_edp_options, tvb, offset, 4, ENC_BIG_ENDIAN);
				break;
		}
		offset += 4;

		/* determine the number of neighbors and create EDP neighbors subtree */
		num_neighbors = tvb_get_ntohs(tvb, offset);
		proto_tree_add_item(edp_tree, hf_ismp_edp_num_neighbors, tvb, offset, 2, ENC_BIG_ENDIAN);
		offset += 2;
		if (num_neighbors > 0)
		{
			edp_neighbors_ti = proto_tree_add_item(edp_tree, hf_ismp_edp_neighbors, tvb,
										offset, num_neighbors*10, ENC_NA);
			edp_neighbors_tree = proto_item_add_subtree(edp_neighbors_ti, ett_ismp_edp_neighbors);
			while ( neighbors_count < num_neighbors && tvb_reported_length_remaining(tvb, offset) >= 10)
			{
				edp_neighbors_leaf_tree = proto_tree_add_subtree_format(edp_neighbors_tree, tvb, offset, 10,
										ett_ismp_edp_neighbors_leaf, NULL, ""Neighbor%d"", (neighbors_count+1));

				proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_neighborhood_mac_address, tvb, offset, 6, ENC_NA);
				proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_assigned_neighbor_state, tvb, offset, 4, ENC_BIG_ENDIAN);
				offset += 10;
				neighbors_count++;
			}
			if (neighbors_count != num_neighbors)
			{
				proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);
				return;
			}
		}

		/* determine data remains, if so, count tuples
		   and create EDP tuples subtree */
		if (tvb_reported_length_remaining(tvb, offset) != 0 &&
			tvb_reported_length_remaining(tvb, offset) >= 2)
		{
			num_tuples = tvb_get_ntohs(tvb, offset);
			proto_tree_add_item(edp_tree, hf_ismp_edp_num_tuples, tvb, offset, 2, ENC_BIG_ENDIAN);
			offset += 2;
		}
		else if (tvb_reported_length_remaining(tvb, offset) > 0) {
			proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);
			return;
		}
		else
		{
			return;
		}

		/* start populating tuple information */
		if (num_tuples && tvb_reported_length_remaining(tvb, offset) >= 4)
		{
			edp_tuples_ti = proto_tree_add_bytes_format(edp_tree, hf_ismp_edp_tuples, tvb,
				offset, -1, NULL, ""Tuples"");
			edp_tuples_tree = proto_item_add_subtree(edp_tuples_ti, ett_ismp_edp_tuples);

			while ( (tuples_count < num_tuples) && (tvb_reported_length_remaining(tvb, offset) >= 4) )
			{

				edp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, 4,
					ett_ismp_edp_tuples_leaf, NULL, ""Tuple%d"", tuples_count+1);

				tuple_type = tvb_get_ntohs(tvb, offset);
				proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_type, tvb, offset, 2, ENC_BIG_ENDIAN);
				offset += 2;
				proto_tree_add_item_ret_uint(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN, &tuple_length);
				if (tuple_length < 4) {
					proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, 2);
					return;
				}
				offset += 2;
				proto_item_set_len(edp_tuples_leaf_tree, tuple_length);
				tuple_length -= 4;

				if ((guint)tvb_reported_length_remaining(tvb, offset) >= tuple_length)
				{
					switch (tuple_type)
					{
						case EDP_TUPLE_HOLD:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, tuple_length, ENC_BIG_ENDIAN);
							break;
						case EDP_TUPLE_INT_NAME:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_interface_name, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
							col_append_fstr(pinfo->cinfo, COL_INFO, "", ifName %s"",
								tvb_format_text(tvb, offset, tuple_length));
							break;
						case EDP_TUPLE_SYS_DESCRIPT:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_system_description, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
							break;
						case EDP_TUPLE_IPX_ADDR:
							if (tuple_length != 4+6) {
								proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, tuple_length);
								return;
							}
							proto_tree_add_string(edp_tuples_leaf_tree, hf_ismp_interface_ipx_address ,tvb, offset, tuple_length,
								ipx_addr_to_str(tvb_get_ntohl(tvb, offset),
								tvb_get_ptr(tvb, offset+4, tuple_length-4)));
							break;
						case EDP_TUPLE_UNKNOWN:
						default:
							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_unknown_tuple_data, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
							break;
					}
				}
				offset += tuple_length;

				tuples_count++;
			}
			if (tuples_count != num_tuples)
				proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1);

			return;
		}
}","static void
dissect_ismp_edp(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, proto_tree *VAR_3)
{
	/* COMMENT_0 */
	int VAR_4 = 0;
	int VAR_5 = 0;
	guint16 VAR_6 = 0;
	guint16 VAR_7 = 0;
	guint16 VAR_8 = 0;
	guint16 VAR_9 = 0;
	guint32 VAR_10 = 0;

	/* COMMENT_1 */
	proto_item *VAR_11;
	proto_tree *VAR_12;

	proto_item *VAR_13;
	proto_tree *VAR_14;

	proto_tree *VAR_15;

	proto_item *VAR_16;
	proto_tree *VAR_17;

	proto_tree *VAR_18;

	/* COMMENT_2 */
	col_set_str(VAR_1->cinfo, VAR_19, ""ISMP.EDP"");
	col_clear(VAR_1->cinfo, VAR_20);

	/* COMMENT_3 */
		VAR_11  = proto_tree_add_item(VAR_3, VAR_21, VAR_0, VAR_2, -1, VAR_22);
		VAR_12 = proto_item_add_subtree(VAR_11, VAR_23);

		col_add_fstr(VAR_1->cinfo, VAR_20, ""MIP %s, MMAC %s, ifIdx %d"",
			tvb_ip_to_str(VAR_0, VAR_2+2),
			tvb_ether_to_str(VAR_0, VAR_2+6),
			tvb_get_ntohl(VAR_0, VAR_2+12));

		proto_tree_add_item(VAR_12, VAR_24, VAR_0, VAR_2, 2, VAR_25);
		VAR_2 += 2;
		proto_tree_add_item(VAR_12, VAR_26, VAR_0, VAR_2, 4, VAR_25);
		VAR_2 += 4;
		proto_tree_add_item(VAR_12, VAR_27, VAR_0, VAR_2, 6, VAR_22);
		VAR_2 += 6;
		proto_tree_add_item(VAR_12, VAR_28, VAR_0, VAR_2, 4, VAR_25);
		VAR_2 += 4;
		proto_tree_add_item(VAR_12, VAR_29, VAR_0, VAR_2, 6, VAR_22);
		VAR_2 += 6;
		proto_tree_add_item(VAR_12, VAR_30, VAR_0, VAR_2, 4, VAR_25);
		VAR_2 += 4;
		VAR_6 = tvb_get_ntohs(VAR_0, VAR_2);
		proto_tree_add_item(VAR_12, VAR_31, VAR_0, VAR_2, 2, VAR_25);
		VAR_2 += 2;
		proto_tree_add_uint_format_value(VAR_12, VAR_32, VAR_0, VAR_2, 4, tvb_get_ntohl(VAR_0, VAR_2),
			""%02x.%02x.%02x.%02x"", tvb_get_guint8(VAR_0, VAR_2),
			tvb_get_guint8(VAR_0, VAR_2+1), tvb_get_guint8(VAR_0, VAR_2+2), tvb_get_guint8(VAR_0, VAR_2+3));
		VAR_2 += 4;

		/* COMMENT_4 */
		switch (VAR_6) {
			case VAR_33:
			case VAR_34:
                {
		        static const gint *VAR_35[] = {
			        &VAR_36,
			        &VAR_37,
			        &VAR_38,
			        &VAR_39,
			        &VAR_40,
			        &VAR_41,
			        &VAR_42,
			        &VAR_43,
			        &VAR_44,
			        &VAR_45,
			        &VAR_46,
			        &VAR_47,
			        &VAR_48,
			        &VAR_49,
			        &VAR_50,
		            NULL
		        };
		        proto_tree_add_bitmask(VAR_12, VAR_0, VAR_2, VAR_51, VAR_52, VAR_35, VAR_25);
                }
				break;
			case VAR_53:
                {
		        static const gint *VAR_35[] = {
			        &VAR_54,
			        &VAR_55,
			        &VAR_56,
			        &VAR_57,
			        &VAR_58,
			        &VAR_59,
			        &VAR_60,
			        &VAR_61,
			        &VAR_62,
			        &VAR_63,
			        &VAR_64,
			        &VAR_65,
			        &VAR_66,
		            NULL
		        };

		        proto_tree_add_bitmask(VAR_12, VAR_0, VAR_2, VAR_51, VAR_52, VAR_35, VAR_25);
                }
				break;
			case VAR_67:
                {
		        static const gint *VAR_35[] = {
			        &VAR_68,
			        &VAR_69,
			        &VAR_70,
			        &VAR_71,
			        &VAR_72,
			        &VAR_73,
			        &VAR_74,
		            NULL
		        };

		        proto_tree_add_bitmask(VAR_12, VAR_0, VAR_2, VAR_51, VAR_52, VAR_35, VAR_25);
                }
				break;
			case VAR_75:
			case VAR_76:
			case VAR_77:
			case VAR_78:
			case VAR_79:
			case VAR_80:
                {
		        static const gint *VAR_35[] = {
			        &VAR_81,
			        &VAR_82,
			        &VAR_83,
		            NULL
		        };

		        proto_tree_add_bitmask(VAR_12, VAR_0, VAR_2, VAR_51, VAR_52, VAR_35, VAR_25);
                }
				break;
			case VAR_84:
			case VAR_85:
			default:
		        proto_tree_add_item(VAR_12, VAR_51, VAR_0, VAR_2, 4, VAR_25);
				break;
		}
		VAR_2 += 4;

		/* COMMENT_5 */
		VAR_7 = tvb_get_ntohs(VAR_0, VAR_2);
		proto_tree_add_item(VAR_12, VAR_86, VAR_0, VAR_2, 2, VAR_25);
		VAR_2 += 2;
		if (VAR_7 > 0)
		{
			VAR_13 = proto_tree_add_item(VAR_12, VAR_87, VAR_0,
										VAR_2, VAR_7*10, VAR_22);
			VAR_14 = proto_item_add_subtree(VAR_13, VAR_88);
			while ( VAR_4 < VAR_7 && tvb_reported_length_remaining(VAR_0, VAR_2) >= 10)
			{
				VAR_15 = proto_tree_add_subtree_format(VAR_14, VAR_0, VAR_2, 10,
										VAR_89, NULL, ""Neighbor%d"", (VAR_4+1));

				proto_tree_add_item(VAR_15, VAR_90, VAR_0, VAR_2, 6, VAR_22);
				proto_tree_add_item(VAR_15, VAR_91, VAR_0, VAR_2, 4, VAR_25);
				VAR_2 += 10;
				VAR_4++;
			}
			if (VAR_4 != VAR_7)
			{
				proto_tree_add_expert(VAR_12, VAR_1, &VAR_92, VAR_0, VAR_2, -1);
				return;
			}
		}

		/* COMMENT_6 */
                                     
		if (tvb_reported_length_remaining(VAR_0, VAR_2) != 0 &&
			tvb_reported_length_remaining(VAR_0, VAR_2) >= 2)
		{
			VAR_8 = tvb_get_ntohs(VAR_0, VAR_2);
			proto_tree_add_item(VAR_12, VAR_93, VAR_0, VAR_2, 2, VAR_25);
			VAR_2 += 2;
		}
		else if (tvb_reported_length_remaining(VAR_0, VAR_2) > 0) {
			proto_tree_add_expert(VAR_12, VAR_1, &VAR_92, VAR_0, VAR_2, -1);
			return;
		}
		else
		{
			return;
		}

		/* COMMENT_8 */
		if (VAR_8 && tvb_reported_length_remaining(VAR_0, VAR_2) >= 4)
		{
			VAR_16 = proto_tree_add_bytes_format(VAR_12, VAR_94, VAR_0,
				VAR_2, -1, NULL, ""Tuples"");
			VAR_17 = proto_item_add_subtree(VAR_16, VAR_95);

			while ( (VAR_5 < VAR_8) && (tvb_reported_length_remaining(VAR_0, VAR_2) >= 4) )
			{

				VAR_18 = proto_tree_add_subtree_format(VAR_17, VAR_0, VAR_2, 4,
					VAR_96, NULL, ""Tuple%d"", VAR_5+1);

				VAR_9 = tvb_get_ntohs(VAR_0, VAR_2);
				proto_tree_add_item(VAR_18, VAR_97, VAR_0, VAR_2, 2, VAR_25);
				VAR_2 += 2;
				proto_tree_add_item_ret_uint(VAR_18, VAR_98, VAR_0, VAR_2, 2, VAR_25, &VAR_10);
				if (VAR_10 < 4) {
					proto_tree_add_expert(VAR_12, VAR_1, &VAR_92, VAR_0, VAR_2, 2);
					return;
				}
				VAR_2 += 2;
				proto_item_set_len(VAR_18, VAR_10);
				VAR_10 -= 4;

				if ((guint)tvb_reported_length_remaining(VAR_0, VAR_2) >= VAR_10)
				{
					switch (VAR_9)
					{
						case VAR_99:
							proto_tree_add_item(VAR_18, VAR_100, VAR_0, VAR_2, VAR_10, VAR_25);
							break;
						case VAR_101:
							proto_tree_add_item(VAR_18, VAR_102, VAR_0, VAR_2, VAR_10, VAR_22|VAR_103);
							col_append_fstr(VAR_1->cinfo, VAR_20, "", ifName %s"",
								tvb_format_text(VAR_0, VAR_2, VAR_10));
							break;
						case VAR_104:
							proto_tree_add_item(VAR_18, VAR_105, VAR_0, VAR_2, VAR_10, VAR_22|VAR_103);
							break;
						case VAR_106:
							if (VAR_10 != 4+6) {
								proto_tree_add_expert(VAR_12, VAR_1, &VAR_92, VAR_0, VAR_2, VAR_10);
								return;
							}
							proto_tree_add_string(VAR_18, VAR_107 ,VAR_0, VAR_2, VAR_10,
								ipx_addr_to_str(tvb_get_ntohl(VAR_0, VAR_2),
								tvb_get_ptr(VAR_0, VAR_2+4, VAR_10-4)));
							break;
						case VAR_108:
						default:
							proto_tree_add_item(VAR_18, VAR_109, VAR_0, VAR_2, VAR_10, VAR_22|VAR_103);
							break;
					}
				}
				VAR_2 += VAR_10;

				VAR_5++;
			}
			if (VAR_5 != VAR_8)
				proto_tree_add_expert(VAR_12, VAR_1, &VAR_92, VAR_0, VAR_2, -1);

			return;
		}
}",wireshark/4f7153685b39a164aea09ba7f96ebb648b8328ae/packet-ismp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,10 +8,10 @@
 	guint16 num_neighbors = 0;
 	guint16 num_tuples = 0;
 	guint16 tuple_type = 0;
-	guint16 tuple_length = 0;
+	guint32 tuple_length = 0;
 
 	/* Set up structures needed to add the protocol subtree and manage it */
-	proto_item *edp_ti, *ti;
+	proto_item *edp_ti;
 	proto_tree *edp_tree;
 
 	proto_item *edp_neighbors_ti;
@@ -200,23 +200,27 @@
 			while ( (tuples_count < num_tuples) && (tvb_reported_length_remaining(tvb, offset) >= 4) )
 			{
 
-				tuple_length = tvb_get_ntohs(tvb, offset+2);
-				edp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, tuple_length,
+				edp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, 4,
 					ett_ismp_edp_tuples_leaf, NULL, ""Tuple%d"", tuples_count+1);
 
 				tuple_type = tvb_get_ntohs(tvb, offset);
 				proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_type, tvb, offset, 2, ENC_BIG_ENDIAN);
 				offset += 2;
-				proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN);
+				proto_tree_add_item_ret_uint(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN, &tuple_length);
+				if (tuple_length < 4) {
+					proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, 2);
+					return;
+				}
 				offset += 2;
-
-				if (tvb_reported_length_remaining(tvb, offset) >= tuple_length)
+				proto_item_set_len(edp_tuples_leaf_tree, tuple_length);
+				tuple_length -= 4;
+
+				if ((guint)tvb_reported_length_remaining(tvb, offset) >= tuple_length)
 				{
 					switch (tuple_type)
 					{
 						case EDP_TUPLE_HOLD:
-							ti = proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, hf_ismp_hold_time, ENC_BIG_ENDIAN);
-                            proto_item_set_len(ti, tuple_length);
+							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, tuple_length, ENC_BIG_ENDIAN);
 							break;
 						case EDP_TUPLE_INT_NAME:
 							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_interface_name, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
@@ -227,9 +231,13 @@
 							proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_system_description, tvb, offset, tuple_length, ENC_NA|ENC_ASCII);
 							break;
 						case EDP_TUPLE_IPX_ADDR:
+							if (tuple_length != 4+6) {
+								proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, tuple_length);
+								return;
+							}
 							proto_tree_add_string(edp_tuples_leaf_tree, hf_ismp_interface_ipx_address ,tvb, offset, tuple_length,
 								ipx_addr_to_str(tvb_get_ntohl(tvb, offset),
-								tvb_get_string_enc(wmem_packet_scope(), tvb, offset+4, tuple_length-4, ENC_ASCII)));
+								tvb_get_ptr(tvb, offset+4, tuple_length-4)));
 							break;
 						case EDP_TUPLE_UNKNOWN:
 						default:","{'deleted_lines': ['\tguint16 tuple_length = 0;', '\tproto_item *edp_ti, *ti;', '\t\t\t\ttuple_length = tvb_get_ntohs(tvb, offset+2);', '\t\t\t\tedp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, tuple_length,', '\t\t\t\tproto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN);', '', '\t\t\t\tif (tvb_reported_length_remaining(tvb, offset) >= tuple_length)', '\t\t\t\t\t\t\tti = proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, hf_ismp_hold_time, ENC_BIG_ENDIAN);', '                            proto_item_set_len(ti, tuple_length);', '\t\t\t\t\t\t\t\ttvb_get_string_enc(wmem_packet_scope(), tvb, offset+4, tuple_length-4, ENC_ASCII)));'], 'added_lines': ['\tguint32 tuple_length = 0;', '\tproto_item *edp_ti;', '\t\t\t\tedp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, 4,', '\t\t\t\tproto_tree_add_item_ret_uint(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN, &tuple_length);', '\t\t\t\tif (tuple_length < 4) {', '\t\t\t\t\tproto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, 2);', '\t\t\t\t\treturn;', '\t\t\t\t}', '\t\t\t\tproto_item_set_len(edp_tuples_leaf_tree, tuple_length);', '\t\t\t\ttuple_length -= 4;', '', '\t\t\t\tif ((guint)tvb_reported_length_remaining(tvb, offset) >= tuple_length)', '\t\t\t\t\t\t\tproto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, tuple_length, ENC_BIG_ENDIAN);', '\t\t\t\t\t\t\tif (tuple_length != 4+6) {', '\t\t\t\t\t\t\t\tproto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, tuple_length);', '\t\t\t\t\t\t\t\treturn;', '\t\t\t\t\t\t\t}', '\t\t\t\t\t\t\t\ttvb_get_ptr(tvb, offset+4, tuple_length-4)));']}",True,"In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the ISMP dissector could crash. This was addressed in epan/dissectors/packet-ismp.c by validating the IPX address length to avoid a buffer over-read.",7.5,HIGH,2,test,2018-05-15T11:08:49Z,2
CVE-2018-11219,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,redis,"Security: fix Lua struct package offset handling.

After the first fix to the struct package I found another similar
problem, which is fixed by this patch. It could be reproduced easily by
running the following script:

    return struct.unpack('f', ""xxxxxxxxxxxxx"",-3)

The above will access bytes before the 'data' pointer.",e89086e09a38cc6713bcd4b9c29abf92cf393936,https://github.com/redis/redis/commit/e89086e09a38cc6713bcd4b9c29abf92cf393936,deps/lua/src/lua_struct.c,b_unpack,"static int b_unpack (lua_State *L) {
Header h;
const char *fmt = luaL_checkstring(L, 1);
size_t ld;
const char *data = luaL_checklstring(L, 2, &ld);
size_t pos = luaL_optinteger(L, 3, 1) - 1;
int n = 0;  
defaultoptions(&h);
while (*fmt) {
int opt = *fmt++;
size_t size = optsize(L, opt, &fmt);
pos += gettoalign(pos, &h, opt, size);
luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
luaL_checkstack(L, 2, ""too many results"");
switch (opt) {
case 'b': case 'B': case 'h': case 'H':
case 'l': case 'L': case 'T': case 'i':  case 'I': {  
int issigned = islower(opt);
lua_Number res = getinteger(data+pos, h.endian, issigned, size);
lua_pushnumber(L, res); n++;
break;
}
case 'x': {
break;
}
case 'f': {
float f;
memcpy(&f, data+pos, size);
correctbytes((char *)&f, sizeof(f), h.endian);
lua_pushnumber(L, f); n++;
break;
}
case 'd': {
double d;
memcpy(&d, data+pos, size);
correctbytes((char *)&d, sizeof(d), h.endian);
lua_pushnumber(L, d); n++;
break;
}
case 'c': {
if (size == 0) {
if (n == 0 || !lua_isnumber(L, -1))
luaL_error(L, ""format 'c0' needs a previous size"");
size = lua_tonumber(L, -1);
lua_pop(L, 1); n--;
luaL_argcheck(L, size <= ld && pos <= ld - size,
2, ""data string too short"");
}
lua_pushlstring(L, data+pos, size); n++;
break;
}
case 's': {
const char *e = (const char *)memchr(data+pos, '\0', ld - pos);
if (e == NULL)
luaL_error(L, ""unfinished string in data"");
size = (e - (data+pos)) + 1;
lua_pushlstring(L, data+pos, size - 1); n++;
break;
}
default: controloptions(L, opt, &fmt, &h);
}
pos += size;
}
lua_pushinteger(L, pos + 1);  
return n + 1;
}","static int b_unpack (lua_State *VAR_0) {
Header VAR_1;
const char *VAR_2 = luaL_checkstring(VAR_0, 1);
size_t VAR_3;
const char *VAR_4 = luaL_checklstring(VAR_0, 2, &VAR_3);
size_t VAR_5 = luaL_optinteger(VAR_0, 3, 1) - 1;
int VAR_6 = 0;  
defaultoptions(&VAR_1);
while (*VAR_2) {
int VAR_7 = *VAR_2++;
size_t VAR_8 = optsize(VAR_0, VAR_7, &VAR_2);
VAR_5 += gettoalign(VAR_5, &VAR_1, VAR_7, VAR_8);
luaL_argcheck(VAR_0, VAR_5+VAR_8 <= VAR_3, 2, ""data string too short"");
luaL_checkstack(VAR_0, 2, ""too many results"");
switch (VAR_7) {
case 'b': case 'B': case 'h': case 'H':
case 'l': case 'L': case 'T': case 'i':  case 'I': {  
int VAR_9 = islower(VAR_7);
lua_Number VAR_10 = getinteger(VAR_4+VAR_5, VAR_1.endian, VAR_9, VAR_8);
lua_pushnumber(VAR_0, VAR_10); VAR_6++;
break;
}
case 'x': {
break;
}
case 'f': {
float VAR_11;
memcpy(&VAR_11, VAR_4+VAR_5, VAR_8);
correctbytes((char *)&VAR_11, sizeof(VAR_11), VAR_1.endian);
lua_pushnumber(VAR_0, VAR_11); VAR_6++;
break;
}
case 'd': {
double VAR_12;
memcpy(&VAR_12, VAR_4+VAR_5, VAR_8);
correctbytes((char *)&VAR_12, sizeof(VAR_12), VAR_1.endian);
lua_pushnumber(VAR_0, VAR_12); VAR_6++;
break;
}
case 'c': {
if (VAR_8 == 0) {
if (VAR_6 == 0 || !lua_isnumber(VAR_0, -1))
luaL_error(VAR_0, ""format 'c0' needs a previous size"");
VAR_8 = lua_tonumber(VAR_0, -1);
lua_pop(VAR_0, 1); VAR_6--;
luaL_argcheck(VAR_0, VAR_8 <= VAR_3 && VAR_5 <= VAR_3 - VAR_8,
2, ""data string too short"");
}
lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_8); VAR_6++;
break;
}
case 's': {
const char *VAR_13 = (const char *)memchr(VAR_4+VAR_5, '\0', VAR_3 - VAR_5);
if (VAR_13 == NULL)
luaL_error(VAR_0, ""unfinished string in data"");
VAR_8 = (VAR_13 - (VAR_4+VAR_5)) + 1;
lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_8 - 1); VAR_6++;
break;
}
default: controloptions(VAR_0, VAR_7, &VAR_2, &VAR_1);
}
VAR_5 += VAR_8;
}
lua_pushinteger(VAR_0, VAR_5 + 1);  
return VAR_6 + 1;
}",redis/e89086e09a38cc6713bcd4b9c29abf92cf393936/lua_struct.c/vul/before/0.json,"static int b_unpack (lua_State *L) {
  Header h;
  const char *fmt = luaL_checkstring(L, 1);
  size_t ld;
  const char *data = luaL_checklstring(L, 2, &ld);
  size_t pos = luaL_optinteger(L, 3, 1);
  luaL_argcheck(L, pos > 0, 3, ""offset must be 1 or greater"");
  pos--; /* Lua indexes are 1-based, but here we want 0-based for C
          * pointer math. */
  int n = 0;  /* number of results */
  defaultoptions(&h);
  while (*fmt) {
    int opt = *fmt++;
    size_t size = optsize(L, opt, &fmt);
    pos += gettoalign(pos, &h, opt, size);
    luaL_argcheck(L, size <= ld && pos <= ld - size,
                   2, ""data string too short"");
    /* stack space for item + next position */
    luaL_checkstack(L, 2, ""too many results"");
    switch (opt) {
      case 'b': case 'B': case 'h': case 'H':
      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */
        int issigned = islower(opt);
        lua_Number res = getinteger(data+pos, h.endian, issigned, size);
        lua_pushnumber(L, res); n++;
        break;
      }
      case 'x': {
        break;
      }
      case 'f': {
        float f;
        memcpy(&f, data+pos, size);
        correctbytes((char *)&f, sizeof(f), h.endian);
        lua_pushnumber(L, f); n++;
        break;
      }
      case 'd': {
        double d;
        memcpy(&d, data+pos, size);
        correctbytes((char *)&d, sizeof(d), h.endian);
        lua_pushnumber(L, d); n++;
        break;
      }
      case 'c': {
        if (size == 0) {
          if (n == 0 || !lua_isnumber(L, -1))
            luaL_error(L, ""format 'c0' needs a previous size"");
          size = lua_tonumber(L, -1);
          lua_pop(L, 1); n--;
          luaL_argcheck(L, size <= ld && pos <= ld - size,
                           2, ""data string too short"");
        }
        lua_pushlstring(L, data+pos, size); n++;
        break;
      }
      case 's': {
        const char *e = (const char *)memchr(data+pos, '\0', ld - pos);
        if (e == NULL)
          luaL_error(L, ""unfinished string in data"");
        size = (e - (data+pos)) + 1;
        lua_pushlstring(L, data+pos, size - 1); n++;
        break;
      }
      default: controloptions(L, opt, &fmt, &h);
    }
    pos += size;
  }
  lua_pushinteger(L, pos + 1);  /* next position */
  return n + 1;
}","static int b_unpack (lua_State *VAR_0) {
  Header VAR_1;
  const char *VAR_2 = luaL_checkstring(VAR_0, 1);
  size_t VAR_3;
  const char *VAR_4 = luaL_checklstring(VAR_0, 2, &VAR_3);
  size_t VAR_5 = luaL_optinteger(VAR_0, 3, 1);
  luaL_argcheck(VAR_0, VAR_5 > 0, 3, ""offset must be 1 or greater"");
  VAR_5--; /* COMMENT_0 */
                            
  int VAR_6 = 0;  /* COMMENT_2 */
  defaultoptions(&VAR_1);
  while (*VAR_2) {
    int VAR_7 = *VAR_2++;
    size_t VAR_8 = optsize(VAR_0, VAR_7, &VAR_2);
    VAR_5 += gettoalign(VAR_5, &VAR_1, VAR_7, VAR_8);
    luaL_argcheck(VAR_0, VAR_8 <= VAR_3 && VAR_5 <= VAR_3 - VAR_8,
                   2, ""data string too short"");
    /* COMMENT_3 */
    luaL_checkstack(VAR_0, 2, ""too many results"");
    switch (VAR_7) {
      case 'b': case 'B': case 'h': case 'H':
      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* COMMENT_4 */
        int VAR_9 = islower(VAR_7);
        lua_Number VAR_10 = getinteger(VAR_4+VAR_5, VAR_1.endian, VAR_9, VAR_8);
        lua_pushnumber(VAR_0, VAR_10); VAR_6++;
        break;
      }
      case 'x': {
        break;
      }
      case 'f': {
        float VAR_11;
        memcpy(&VAR_11, VAR_4+VAR_5, VAR_8);
        correctbytes((char *)&VAR_11, sizeof(VAR_11), VAR_1.endian);
        lua_pushnumber(VAR_0, VAR_11); VAR_6++;
        break;
      }
      case 'd': {
        double VAR_12;
        memcpy(&VAR_12, VAR_4+VAR_5, VAR_8);
        correctbytes((char *)&VAR_12, sizeof(VAR_12), VAR_1.endian);
        lua_pushnumber(VAR_0, VAR_12); VAR_6++;
        break;
      }
      case 'c': {
        if (VAR_8 == 0) {
          if (VAR_6 == 0 || !lua_isnumber(VAR_0, -1))
            luaL_error(VAR_0, ""format 'c0' needs a previous size"");
          VAR_8 = lua_tonumber(VAR_0, -1);
          lua_pop(VAR_0, 1); VAR_6--;
          luaL_argcheck(VAR_0, VAR_8 <= VAR_3 && VAR_5 <= VAR_3 - VAR_8,
                           2, ""data string too short"");
        }
        lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_8); VAR_6++;
        break;
      }
      case 's': {
        const char *VAR_13 = (const char *)memchr(VAR_4+VAR_5, '\0', VAR_3 - VAR_5);
        if (VAR_13 == NULL)
          luaL_error(VAR_0, ""unfinished string in data"");
        VAR_8 = (VAR_13 - (VAR_4+VAR_5)) + 1;
        lua_pushlstring(VAR_0, VAR_4+VAR_5, VAR_8 - 1); VAR_6++;
        break;
      }
      default: controloptions(VAR_0, VAR_7, &VAR_2, &VAR_1);
    }
    VAR_5 += VAR_8;
  }
  lua_pushinteger(VAR_0, VAR_5 + 1);  /* COMMENT_5 */
  return VAR_6 + 1;
}",redis/e89086e09a38cc6713bcd4b9c29abf92cf393936/lua_struct.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,14 +3,18 @@
   const char *fmt = luaL_checkstring(L, 1);
   size_t ld;
   const char *data = luaL_checklstring(L, 2, &ld);
-  size_t pos = luaL_optinteger(L, 3, 1) - 1;
+  size_t pos = luaL_optinteger(L, 3, 1);
+  luaL_argcheck(L, pos > 0, 3, ""offset must be 1 or greater"");
+  pos--; /* Lua indexes are 1-based, but here we want 0-based for C
+          * pointer math. */
   int n = 0;  /* number of results */
   defaultoptions(&h);
   while (*fmt) {
     int opt = *fmt++;
     size_t size = optsize(L, opt, &fmt);
     pos += gettoalign(pos, &h, opt, size);
-    luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
+    luaL_argcheck(L, size <= ld && pos <= ld - size,
+                   2, ""data string too short"");
     /* stack space for item + next position */
     luaL_checkstack(L, 2, ""too many results"");
     switch (opt) {","{'deleted_lines': ['  size_t pos = luaL_optinteger(L, 3, 1) - 1;', '    luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");'], 'added_lines': ['  size_t pos = luaL_optinteger(L, 3, 1);', '  luaL_argcheck(L, pos > 0, 3, ""offset must be 1 or greater"");', '  pos--; /* Lua indexes are 1-based, but here we want 0-based for C', '          * pointer math. */', '    luaL_argcheck(L, size <= ld && pos <= ld - size,', '                   2, ""data string too short"");']}",True,"An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking.",9.8,CRITICAL,3,test,2018-05-15T11:13:49Z,2
CVE-2018-11595,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,espruino/Espruino,Fix strncat/cpy bounding issues (fix #1425),0a7619875bf79877907205f6bee08465b89ff10b,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,src/jspin.c,jshGetPinString,"void jshGetPinString(char *result, Pin pin) {
result[0] = 0; #ifdef PIN_NAMES_DIRECT
if (jshIsPinValid(pin)) {
result[0] = (char)('A'+(pinInfo[pin].port&JSH_PORT_MASK)-JSH_PORTA);
itostr(pinInfo[pin].pin-JSH_PIN0,&result[1],10);
#else
if (false) {
#if JSH_PORTA_OFFSET!=-1
} else if(
#if JSH_PORTA_OFFSET!=0
pin>=JSH_PORTA_OFFSET &&
#endif
pin<JSH_PORTA_OFFSET+JSH_PORTA_COUNT) {
result[0]='A';
itostr(pin-JSH_PORTA_OFFSET,&result[1],10);
#endif
#if JSH_PORTB_OFFSET!=-1
} else if (pin>=JSH_PORTB_OFFSET && pin<JSH_PORTB_OFFSET+JSH_PORTB_COUNT) {
result[0]='B';
itostr(pin-JSH_PORTB_OFFSET,&result[1],10);
#endif
#if JSH_PORTC_OFFSET!=-1
} else if (pin>=JSH_PORTC_OFFSET && pin<JSH_PORTC_OFFSET+JSH_PORTC_COUNT) {
result[0]='C';
itostr(pin-JSH_PORTC_OFFSET,&result[1],10);
#endif
#if JSH_PORTD_OFFSET!=-1
} else if (
#if JSH_PORTD_OFFSET!=0
pin>=JSH_PORTD_OFFSET &&
#endif
pin<JSH_PORTD_OFFSET+JSH_PORTD_COUNT) {
result[0]='D';
itostr(pin-JSH_PORTD_OFFSET,&result[1],10);
#endif
#if JSH_PORTE_OFFSET!=-1
} else if (pin>=JSH_PORTE_OFFSET && pin<JSH_PORTE_OFFSET+JSH_PORTE_COUNT) {
result[0]='E';
itostr(pin-JSH_PORTE_OFFSET,&result[1],10);
#endif
#if JSH_PORTF_OFFSET!=-1
} else if (pin>=JSH_PORTF_OFFSET && pin<JSH_PORTF_OFFSET+JSH_PORTF_COUNT) {
result[0]='F';
itostr(pin-JSH_PORTF_OFFSET,&result[1],10);
#endif
#if JSH_PORTG_OFFSET!=-1
} else if (pin>=JSH_PORTG_OFFSET && pin<JSH_PORTG_OFFSET+JSH_PORTG_COUNT) {
result[0]='G';
itostr(pin-JSH_PORTG_OFFSET,&result[1],10);
#endif
#if JSH_PORTH_OFFSET!=-1
} else if (pin>=JSH_PORTH_OFFSET && pin<JSH_PORTH_OFFSET+JSH_PORTH_COUNT) {
result[0]='H';
itostr(pin-JSH_PORTH_OFFSET,&result[1],10);
#endif
#if JSH_PORTI_OFFSET!=-1
} else if (pin>=JSH_PORTI_OFFSET && pin<JSH_PORTI_OFFSET+JSH_PORTI_COUNT) {
result[0]='I';
itostr(pin-JSH_PORTI_OFFSET,&result[1],10);
#endif
#if JSH_PORTV_OFFSET!=-1
} else if (pin>=JSH_PORTV_OFFSET && pin<JSH_PORTV_OFFSET+JSH_PORTV_COUNT) {
result[0]='V';
itostr(pin-JSH_PORTV_OFFSET,&result[1],10);
#endif
#endif
} else {
strncpy(result, ""undefined"", 10);
}
}","void jshGetPinString(char *VAR_0, Pin VAR_1) {
VAR_0[0] = 0; 
#ifdef VAR_2
if (jshIsPinValid(VAR_1)) {
VAR_0[0] = (char)('A'+(VAR_3[VAR_1].port&VAR_4)-VAR_5);
itostr(VAR_3[VAR_1].pin-VAR_6,&VAR_0[1],10);
#else
if (false) {
#if VAR_7!=-1
} else if(
#if VAR_7!=0
VAR_1>=VAR_7 &&
#endif
VAR_1<VAR_7+VAR_8) {
VAR_0[0]='A';
itostr(VAR_1-VAR_7,&VAR_0[1],10);
#endif
#if VAR_9!=-1
} else if (pin>=VAR_9 && pin<VAR_9+VAR_10) {
VAR_0[0]='B';
itostr(pin-VAR_9,&VAR_0[1],10);
#endif
#if VAR_11!=-1
} else if (pin>=VAR_11 && pin<VAR_11+VAR_12) {
VAR_0[0]='C';
itostr(pin-VAR_11,&VAR_0[1],10);
#endif
#if VAR_13!=-1
} else if (
#if VAR_13!=0
pin>=VAR_13 &&
#endif
pin<VAR_13+VAR_14) {
VAR_0[0]='D';
itostr(pin-VAR_13,&VAR_0[1],10);
#endif
#if VAR_15!=-1
} else if (pin>=VAR_15 && pin<VAR_15+VAR_16) {
VAR_0[0]='E';
itostr(pin-VAR_15,&VAR_0[1],10);
#endif
#if VAR_17!=-1
} else if (pin>=VAR_17 && pin<VAR_17+VAR_18) {
VAR_0[0]='F';
itostr(pin-VAR_17,&VAR_0[1],10);
#endif
#if VAR_19!=-1
} else if (pin>=VAR_19 && pin<VAR_19+VAR_20) {
VAR_0[0]='G';
itostr(pin-VAR_19,&VAR_0[1],10);
#endif
#if VAR_21!=-1
} else if (pin>=VAR_21 && pin<VAR_21+VAR_22) {
VAR_0[0]='H';
itostr(pin-VAR_21,&VAR_0[1],10);
#endif
#if VAR_23!=-1
} else if (pin>=VAR_23 && pin<VAR_23+VAR_24) {
VAR_0[0]='I';
itostr(pin-VAR_23,&VAR_0[1],10);
#endif
#if VAR_25!=-1
} else if (pin>=VAR_25 && pin<VAR_25+VAR_26) {
VAR_0[0]='V';
itostr(pin-VAR_25,&VAR_0[1],10);
#endif
#endif
} else {
strncpy(VAR_0, ""undefined"", 10);
}
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jspin.c/vul/before/1.json,"void jshGetPinString(char *result, Pin pin) {
  result[0] = 0; // just in case
#ifdef PIN_NAMES_DIRECT
  if (jshIsPinValid(pin)) {
    result[0] = (char)('A'+(pinInfo[pin].port&JSH_PORT_MASK)-JSH_PORTA);
    itostr(pinInfo[pin].pin-JSH_PIN0,&result[1],10);
#else
    if (false) {
#if JSH_PORTA_OFFSET!=-1
    } else if(
#if JSH_PORTA_OFFSET!=0
        pin>=JSH_PORTA_OFFSET &&
#endif
        pin<JSH_PORTA_OFFSET+JSH_PORTA_COUNT) {
      result[0]='A';
      itostr(pin-JSH_PORTA_OFFSET,&result[1],10);
#endif
#if JSH_PORTB_OFFSET!=-1
    } else if (pin>=JSH_PORTB_OFFSET && pin<JSH_PORTB_OFFSET+JSH_PORTB_COUNT) {
      result[0]='B';
      itostr(pin-JSH_PORTB_OFFSET,&result[1],10);
#endif
#if JSH_PORTC_OFFSET!=-1
    } else if (pin>=JSH_PORTC_OFFSET && pin<JSH_PORTC_OFFSET+JSH_PORTC_COUNT) {
      result[0]='C';
      itostr(pin-JSH_PORTC_OFFSET,&result[1],10);
#endif
#if JSH_PORTD_OFFSET!=-1
    } else if (
#if JSH_PORTD_OFFSET!=0
        pin>=JSH_PORTD_OFFSET &&
#endif
        pin<JSH_PORTD_OFFSET+JSH_PORTD_COUNT) {
      result[0]='D';
      itostr(pin-JSH_PORTD_OFFSET,&result[1],10);
#endif
#if JSH_PORTE_OFFSET!=-1
    } else if (pin>=JSH_PORTE_OFFSET && pin<JSH_PORTE_OFFSET+JSH_PORTE_COUNT) {
      result[0]='E';
      itostr(pin-JSH_PORTE_OFFSET,&result[1],10);
#endif
#if JSH_PORTF_OFFSET!=-1
    } else if (pin>=JSH_PORTF_OFFSET && pin<JSH_PORTF_OFFSET+JSH_PORTF_COUNT) {
      result[0]='F';
      itostr(pin-JSH_PORTF_OFFSET,&result[1],10);
#endif
#if JSH_PORTG_OFFSET!=-1
    } else if (pin>=JSH_PORTG_OFFSET && pin<JSH_PORTG_OFFSET+JSH_PORTG_COUNT) {
      result[0]='G';
      itostr(pin-JSH_PORTG_OFFSET,&result[1],10);
#endif
#if JSH_PORTH_OFFSET!=-1
    } else if (pin>=JSH_PORTH_OFFSET && pin<JSH_PORTH_OFFSET+JSH_PORTH_COUNT) {
      result[0]='H';
      itostr(pin-JSH_PORTH_OFFSET,&result[1],10);
#endif
#if JSH_PORTI_OFFSET!=-1
    } else if (pin>=JSH_PORTI_OFFSET && pin<JSH_PORTI_OFFSET+JSH_PORTI_COUNT) {
      result[0]='I';
      itostr(pin-JSH_PORTI_OFFSET,&result[1],10);
#endif
#if JSH_PORTV_OFFSET!=-1
    } else if (pin>=JSH_PORTV_OFFSET && pin<JSH_PORTV_OFFSET+JSH_PORTV_COUNT) {
      result[0]='V';
      itostr(pin-JSH_PORTV_OFFSET,&result[1],10);
#endif
#endif
    } else {
      strcpy(result, ""undefined"");
    }
  }","void jshGetPinString(char *VAR_0, Pin VAR_1) {
  VAR_0[0] = 0; /* COMMENT_0 */
#ifdef VAR_2
  if (jshIsPinValid(VAR_1)) {
    VAR_0[0] = (char)('A'+(VAR_3[VAR_1].port&VAR_4)-VAR_5);
    itostr(VAR_3[VAR_1].pin-VAR_6,&VAR_0[1],10);
#else
    if (false) {
#if VAR_7!=-1
    } else if(
#if VAR_7!=0
        VAR_1>=VAR_7 &&
#endif
        VAR_1<VAR_7+VAR_8) {
      VAR_0[0]='A';
      itostr(VAR_1-VAR_7,&VAR_0[1],10);
#endif
#if VAR_9!=-1
    } else if (pin>=VAR_9 && pin<VAR_9+VAR_10) {
      VAR_0[0]='B';
      itostr(pin-VAR_9,&VAR_0[1],10);
#endif
#if VAR_11!=-1
    } else if (pin>=VAR_11 && pin<VAR_11+VAR_12) {
      VAR_0[0]='C';
      itostr(pin-VAR_11,&VAR_0[1],10);
#endif
#if VAR_13!=-1
    } else if (
#if VAR_13!=0
        pin>=VAR_13 &&
#endif
        pin<VAR_13+VAR_14) {
      VAR_0[0]='D';
      itostr(pin-VAR_13,&VAR_0[1],10);
#endif
#if VAR_15!=-1
    } else if (pin>=VAR_15 && pin<VAR_15+VAR_16) {
      VAR_0[0]='E';
      itostr(pin-VAR_15,&VAR_0[1],10);
#endif
#if VAR_17!=-1
    } else if (pin>=VAR_17 && pin<VAR_17+VAR_18) {
      VAR_0[0]='F';
      itostr(pin-VAR_17,&VAR_0[1],10);
#endif
#if VAR_19!=-1
    } else if (pin>=VAR_19 && pin<VAR_19+VAR_20) {
      VAR_0[0]='G';
      itostr(pin-VAR_19,&VAR_0[1],10);
#endif
#if VAR_21!=-1
    } else if (pin>=VAR_21 && pin<VAR_21+VAR_22) {
      VAR_0[0]='H';
      itostr(pin-VAR_21,&VAR_0[1],10);
#endif
#if VAR_23!=-1
    } else if (pin>=VAR_23 && pin<VAR_23+VAR_24) {
      VAR_0[0]='I';
      itostr(pin-VAR_23,&VAR_0[1],10);
#endif
#if VAR_25!=-1
    } else if (pin>=VAR_25 && pin<VAR_25+VAR_26) {
      VAR_0[0]='V';
      itostr(pin-VAR_25,&VAR_0[1],10);
#endif
#endif
    } else {
      strcpy(VAR_0, ""undefined"");
    }
  }",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jspin.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -66,6 +66,6 @@
 #endif
 #endif
     } else {
-      strncpy(result, ""undefined"", 10);
+      strcpy(result, ""undefined"");
     }
   }","{'deleted_lines': ['      strncpy(result, ""undefined"", 10);'], 'added_lines': ['      strcpy(result, ""undefined"");']}",True,"Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",7.8,HIGH,2,test,2018-05-21T09:35:49Z,2
CVE-2018-11595,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,espruino/Espruino,Fix strncat/cpy bounding issues (fix #1425),0a7619875bf79877907205f6bee08465b89ff10b,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,src/jsutils.c,ftoa_bounded_extra,"void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {
const JsVarFloat stopAtError = 0.0000001;
if (isnan(val)) strncpy(str,""NaN"",len);
else if (!isfinite(val)) {
if (val<0) strncpy(str,""-Infinity"",len);
else strncpy(str,""Infinity"",len);
} else {
if (val<0) {
if (--len <= 0) { *str=0; return; }       *(str++) = '-';
val = -val;
}
if (((JsVarInt)(val+stopAtError)) == (1+(JsVarInt)val))
val = (JsVarFloat)(1+(JsVarInt)val);
JsVarFloat d = 1;
while (d*radix <= val) d*=radix;
while (d >= 1) {
int v = (int)(val / d);
val -= v*d;
if (--len <= 0) { *str=0; return; }       *(str++) = itoch(v);
d /= radix;
}
#ifndef USE_NO_FLOATS
if (((fractionalDigits<0) && val>0) || fractionalDigits>0) {
bool hasPt = false;
val*=radix;
while (((fractionalDigits<0) && (fractionalDigits>-12) && (val > stopAtError)) || (fractionalDigits > 0)) {
int v = (int)(val+((fractionalDigits==1) ? 0.4 : 0.00000001) );
val = (val-v)*radix;
if (v==radix) v=radix-1;
if (!hasPt) {
hasPt = true;
if (--len <= 0) { *str=0; return; }           *(str++)='.';
}
if (--len <= 0) { *str=0; return; }         *(str++)=itoch(v);
fractionalDigits--;
}
}
#endif
*(str++)=0;
}
}","void ftoa_bounded_extra(JsVarFloat VAR_0,char *VAR_1, size_t VAR_2, int VAR_3, int VAR_4) {
const JsVarFloat VAR_5 = 0.0000001;
if (isnan(VAR_0)) strncpy(VAR_1,""NaN"",VAR_2);
else if (!isfinite(VAR_0)) {
if (VAR_0<0) strncpy(VAR_1,""-Infinity"",VAR_2);
else strncpy(VAR_1,""Infinity"",VAR_2);
} else {
if (VAR_0<0) {
if (--VAR_2 <= 0) { *VAR_1=0; return; } 
*(VAR_1++) = '-';
VAR_0 = -VAR_0;
}
if (((VAR_6)(VAR_0+VAR_5)) == (1+(JsVarInt)VAR_0))
VAR_0 = (JsVarFloat)(1+(JsVarInt)VAR_0);
JsVarFloat VAR_7 = 1;
while (VAR_7*VAR_3 <= VAR_0) VAR_7*=VAR_3;
while (VAR_7 >= 1) {
int VAR_8 = (int)(VAR_0 / VAR_7);
VAR_0 -= VAR_8*VAR_7;
if (--VAR_2 <= 0) { *VAR_1=0; return; } 
*(VAR_1++) = itoch(VAR_8);
VAR_7 /= VAR_3;
}
#ifndef VAR_9
if (((VAR_4<0) && VAR_0>0) || VAR_4>0) {
bool VAR_10 = false;
VAR_0*=VAR_3;
while (((VAR_4<0) && (VAR_4>-12) && (VAR_0 > VAR_5)) || (VAR_4 > 0)) {
int VAR_8 = (int)(VAR_0+((VAR_4==1) ? 0.4 : 0.00000001) );
VAR_0 = (VAR_0-VAR_8)*VAR_3;
if (VAR_8==VAR_3) VAR_8=VAR_3-1;
if (!VAR_10) {
VAR_10 = true;
if (--VAR_2 <= 0) { *VAR_1=0; return; } 
*(VAR_1++)='.';
}
if (--VAR_2 <= 0) { *VAR_1=0; return; } 
*(VAR_1++)=itoch(VAR_8);
VAR_4--;
}
}
#endif
*(VAR_1++)=0;
}
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jsutils.c/vul/before/0.json,"void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {
  assert(len>9); // in case if strcpy
  const JsVarFloat stopAtError = 0.0000001;
  if (isnan(val)) strcpy(str,""NaN"");
  else if (!isfinite(val)) {
    if (val<0) strcpy(str,""-Infinity"");
    else strcpy(str,""Infinity"");
  } else {
    if (val<0) {
      if (--len <= 0) { *str=0; return; } // bounds check
      *(str++) = '-';
      val = -val;
    }

    // what if we're really close to an integer? Just use that...
    if (((JsVarInt)(val+stopAtError)) == (1+(JsVarInt)val))
      val = (JsVarFloat)(1+(JsVarInt)val);

    JsVarFloat d = 1;
    while (d*radix <= val) d*=radix;
    while (d >= 1) {
      int v = (int)(val / d);
      val -= v*d;
      if (--len <= 0) { *str=0; return; } // bounds check
      *(str++) = itoch(v);
      d /= radix;
    }
#ifndef USE_NO_FLOATS
    if (((fractionalDigits<0) && val>0) || fractionalDigits>0) {
      bool hasPt = false;
      val*=radix;
      while (((fractionalDigits<0) && (fractionalDigits>-12) && (val > stopAtError)) || (fractionalDigits > 0)) {
        int v = (int)(val+((fractionalDigits==1) ? 0.4 : 0.00000001) );
        val = (val-v)*radix;
	if (v==radix) v=radix-1;
        if (!hasPt) {	
	  hasPt = true;
          if (--len <= 0) { *str=0; return; } // bounds check
          *(str++)='.';
        }
        if (--len <= 0) { *str=0; return; } // bounds check
        *(str++)=itoch(v);
        fractionalDigits--;
      }
    }
#endif

    *(str++)=0;
  }
}","void ftoa_bounded_extra(JsVarFloat VAR_0,char *VAR_1, size_t VAR_2, int VAR_3, int VAR_4) {
  assert(VAR_2>9); /* COMMENT_0 */
  const JsVarFloat VAR_5 = 0.0000001;
  if (isnan(VAR_0)) strcpy(VAR_1,""NaN"");
  else if (!isfinite(VAR_0)) {
    if (VAR_0<0) strcpy(VAR_1,""-Infinity"");
    else strcpy(VAR_1,""Infinity"");
  } else {
    if (VAR_0<0) {
      if (--VAR_2 <= 0) { *VAR_1=0; return; } /* COMMENT_1 */
      *(VAR_1++) = '-';
      VAR_0 = -VAR_0;
    }

    /* COMMENT_2 */
    if (((VAR_6)(VAR_0+VAR_5)) == (1+(JsVarInt)VAR_0))
      VAR_0 = (JsVarFloat)(1+(JsVarInt)VAR_0);

    JsVarFloat VAR_7 = 1;
    while (VAR_7*VAR_3 <= VAR_0) VAR_7*=VAR_3;
    while (VAR_7 >= 1) {
      int VAR_8 = (int)(VAR_0 / VAR_7);
      VAR_0 -= VAR_8*VAR_7;
      if (--VAR_2 <= 0) { *VAR_1=0; return; } /* COMMENT_1 */
      *(VAR_1++) = itoch(VAR_8);
      VAR_7 /= VAR_3;
    }
#ifndef VAR_9
    if (((VAR_4<0) && VAR_0>0) || VAR_4>0) {
      bool VAR_10 = false;
      VAR_0*=VAR_3;
      while (((VAR_4<0) && (VAR_4>-12) && (VAR_0 > VAR_5)) || (VAR_4 > 0)) {
        int VAR_8 = (int)(VAR_0+((VAR_4==1) ? 0.4 : 0.00000001) );
        VAR_0 = (VAR_0-VAR_8)*VAR_3;
	if (VAR_8==VAR_3) VAR_8=VAR_3-1;
        if (!VAR_10) {	
	  VAR_10 = true;
          if (--VAR_2 <= 0) { *VAR_1=0; return; } /* COMMENT_1 */
          *(VAR_1++)='.';
        }
        if (--VAR_2 <= 0) { *VAR_1=0; return; } /* COMMENT_1 */
        *(VAR_1++)=itoch(VAR_8);
        VAR_4--;
      }
    }
#endif

    *(VAR_1++)=0;
  }
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jsutils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,9 +1,10 @@
 void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {
+  assert(len>9); // in case if strcpy
   const JsVarFloat stopAtError = 0.0000001;
-  if (isnan(val)) strncpy(str,""NaN"",len);
+  if (isnan(val)) strcpy(str,""NaN"");
   else if (!isfinite(val)) {
-    if (val<0) strncpy(str,""-Infinity"",len);
-    else strncpy(str,""Infinity"",len);
+    if (val<0) strcpy(str,""-Infinity"");
+    else strcpy(str,""Infinity"");
   } else {
     if (val<0) {
       if (--len <= 0) { *str=0; return; } // bounds check","{'deleted_lines': ['  if (isnan(val)) strncpy(str,""NaN"",len);', '    if (val<0) strncpy(str,""-Infinity"",len);', '    else strncpy(str,""Infinity"",len);'], 'added_lines': ['  assert(len>9); // in case if strcpy', '  if (isnan(val)) strcpy(str,""NaN"");', '    if (val<0) strcpy(str,""-Infinity"");', '    else strcpy(str,""Infinity"");']}",True,"Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",7.8,HIGH,2,test,2018-05-21T09:35:49Z,2
CVE-2018-11595,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,espruino/Espruino,Fix strncat/cpy bounding issues (fix #1425),0a7619875bf79877907205f6bee08465b89ff10b,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,src/jsvar.c,jsvGetString,"size_t jsvGetString(const JsVar *v, char *str, size_t len) {
const char *s = jsvGetConstString(v);
if (s) {
strncpy(str, s, len);
return strlen(s);
} else if (jsvIsInt(v)) {
itostr(v->varData.integer, str, 10);
return strlen(str);
} else if (jsvIsFloat(v)) {
ftoa_bounded(v->varData.floating, str, len);
return strlen(str);
} else if (jsvHasCharacterData(v)) {
assert(!jsvIsStringExt(v));
size_t l = len;
JsvStringIterator it;
jsvStringIteratorNewConst(&it, v, 0);
while (jsvStringIteratorHasChar(&it)) {
if (l--<=1) {
*str = 0;
jsvStringIteratorFree(&it);
return len;
}
*(str++) = jsvStringIteratorGetChar(&it);
jsvStringIteratorNext(&it);
}
jsvStringIteratorFree(&it);
*str = 0;
return len-l;
} else {
JsVar *stringVar = jsvAsString((JsVar*)v, false);     if (stringVar) {
size_t l = jsvGetString(stringVar, str, len);       jsvUnLock(stringVar);
return l;
} else {
strncpy(str, """", len);
jsExceptionHere(JSET_INTERNALERROR, ""Variable type cannot be converted to string"");
return 0;
}
}
}","size_t jsvGetString(const JsVar *VAR_0, char *VAR_1, size_t VAR_2) {
const char *VAR_3 = jsvGetConstString(VAR_0);
if (VAR_3) {
strncpy(VAR_1, VAR_3, VAR_2);
return strlen(VAR_3);
} else if (jsvIsInt(VAR_0)) {
itostr(VAR_0->varData.integer, VAR_1, 10);
return strlen(VAR_1);
} else if (jsvIsFloat(VAR_0)) {
ftoa_bounded(VAR_0->varData.floating, VAR_1, VAR_2);
return strlen(VAR_1);
} else if (jsvHasCharacterData(VAR_0)) {
assert(!jsvIsStringExt(VAR_0));
size_t VAR_4 = VAR_2;
JsvStringIterator VAR_5;
jsvStringIteratorNewConst(&VAR_5, VAR_0, 0);
while (jsvStringIteratorHasChar(&VAR_5)) {
if (VAR_4--<=1) {
*VAR_1 = 0;
jsvStringIteratorFree(&VAR_5);
return VAR_2;
}
*(VAR_1++) = jsvStringIteratorGetChar(&VAR_5);
jsvStringIteratorNext(&VAR_5);
}
jsvStringIteratorFree(&VAR_5);
*VAR_1 = 0;
return VAR_2-VAR_4;
} else {
JsVar *VAR_6 = jsvAsString((JsVar*)VAR_0, false); 
if (VAR_6) {
size_t VAR_4 = jsvGetString(VAR_6, VAR_1, VAR_2); 
jsvUnLock(VAR_6);
return VAR_4;
} else {
strncpy(VAR_1, """", VAR_2);
jsExceptionHere(VAR_7, ""Variable type cannot be converted to string"");
return 0;
}
}
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jsvar.c/vul/before/0.json,"size_t jsvGetString(const JsVar *v, char *str, size_t len) {
  const char *s = jsvGetConstString(v);
  if (s) {
    strncpy(str, s, len);
    str[len-1] = 0;
    return strlen(s);
  } else if (jsvIsInt(v)) {
    itostr(v->varData.integer, str, 10);
    return strlen(str);
  } else if (jsvIsFloat(v)) {
    ftoa_bounded(v->varData.floating, str, len);
    return strlen(str);
  } else if (jsvHasCharacterData(v)) {
    assert(!jsvIsStringExt(v));
    size_t l = len;
    JsvStringIterator it;
    jsvStringIteratorNewConst(&it, v, 0);
    while (jsvStringIteratorHasChar(&it)) {
      if (l--<=1) {
        *str = 0;
        jsvStringIteratorFree(&it);
        return len;
      }
      *(str++) = jsvStringIteratorGetChar(&it);
      jsvStringIteratorNext(&it);
    }
    jsvStringIteratorFree(&it);
    *str = 0;
    return len-l;
  } else {
    // Try and get as a JsVar string, and try again
    JsVar *stringVar = jsvAsString((JsVar*)v, false); // we know we're casting to non-const here
    if (stringVar) {
      size_t l = jsvGetString(stringVar, str, len); // call again - but this time with converted var
      jsvUnLock(stringVar);
      return l;
    } else {
      str[0] = 0;
      jsExceptionHere(JSET_INTERNALERROR, ""Variable type cannot be converted to string"");
      return 0;
    }
  }
}","size_t jsvGetString(const JsVar *VAR_0, char *VAR_1, size_t VAR_2) {
  const char *VAR_3 = jsvGetConstString(VAR_0);
  if (VAR_3) {
    strncpy(VAR_1, VAR_3, VAR_2);
    VAR_1[VAR_2-1] = 0;
    return strlen(VAR_3);
  } else if (jsvIsInt(VAR_0)) {
    itostr(VAR_0->varData.integer, VAR_1, 10);
    return strlen(VAR_1);
  } else if (jsvIsFloat(VAR_0)) {
    ftoa_bounded(VAR_0->varData.floating, VAR_1, VAR_2);
    return strlen(VAR_1);
  } else if (jsvHasCharacterData(VAR_0)) {
    assert(!jsvIsStringExt(VAR_0));
    size_t VAR_4 = VAR_2;
    JsvStringIterator VAR_5;
    jsvStringIteratorNewConst(&VAR_5, VAR_0, 0);
    while (jsvStringIteratorHasChar(&VAR_5)) {
      if (VAR_4--<=1) {
        *VAR_1 = 0;
        jsvStringIteratorFree(&VAR_5);
        return VAR_2;
      }
      *(VAR_1++) = jsvStringIteratorGetChar(&VAR_5);
      jsvStringIteratorNext(&VAR_5);
    }
    jsvStringIteratorFree(&VAR_5);
    *VAR_1 = 0;
    return VAR_2-VAR_4;
  } else {
    /* COMMENT_0 */
    JsVar *VAR_6 = jsvAsString((JsVar*)VAR_0, false); /* COMMENT_1 */
    if (VAR_6) {
      size_t VAR_4 = jsvGetString(VAR_6, VAR_1, VAR_2); /* COMMENT_2 */
      jsvUnLock(VAR_6);
      return VAR_4;
    } else {
      VAR_1[0] = 0;
      jsExceptionHere(VAR_7, ""Variable type cannot be converted to string"");
      return 0;
    }
  }
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jsvar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
   const char *s = jsvGetConstString(v);
   if (s) {
     strncpy(str, s, len);
+    str[len-1] = 0;
     return strlen(s);
   } else if (jsvIsInt(v)) {
     itostr(v->varData.integer, str, 10);
@@ -34,7 +35,7 @@
       jsvUnLock(stringVar);
       return l;
     } else {
-      strncpy(str, """", len);
+      str[0] = 0;
       jsExceptionHere(JSET_INTERNALERROR, ""Variable type cannot be converted to string"");
       return 0;
     }","{'deleted_lines': ['      strncpy(str, """", len);'], 'added_lines': ['    str[len-1] = 0;', '      str[0] = 0;']}",True,"Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",7.8,HIGH,2,test,2018-05-21T09:35:49Z,2
CVE-2018-11595,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,espruino/Espruino,Fix strncat/cpy bounding issues (fix #1425),0a7619875bf79877907205f6bee08465b89ff10b,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,src/jslex.c,jslTokenAsString,"void jslTokenAsString(int token, char *str, size_t len) {
if (token>32 && token<128) {
assert(len>=4);
str[0] = '\'';
str[1] = (char)token;
str[2] = '\'';
str[3] = 0;
return;
}
switch (token) {
case LEX_EOF : strncpy(str, ""EOF"", len); return;
case LEX_ID : strncpy(str, ""ID"", len); return;
case LEX_INT : strncpy(str, ""INT"", len); return;
case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
case LEX_STR : strncpy(str, ""STRING"", len); return;
case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
}
if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
const char tokenNames[] =
""==\0""
""===\0""
""!=\0""
""!==\0""
""<=\0""
""<<\0""
""<<=\0""
"">=\0""
"">>\0""
"">>>\0""
"">>=\0""
"">>>=\0""
""+=\0""
""-=\0""
""++\0""
""--\0""
""*=\0""
""/=\0""
""%=\0""
""&=\0""
""&&\0""
""|=\0""
""||\0""
""^=\0""
""=>\0""
""if\0""
""else\0""
""do\0""
""while\0""
""for\0""
""return\0""
""continue\0""
""function\0""
""return\0""
""var\0""
""let\0""
""const\0""
""this\0""
""throw\0""
""try\0""
""catch\0""
""finally\0""
""true\0""
""false\0""
""null\0""
""undefined\0""
""new\0""
""in\0""
""instanceof\0""
""switch\0""
""case\0""
""default\0""
""delete\0""
""typeof\0""
""void\0""
""debugger\0""
""class\0""
""extends\0""
""super\0""
""static\0""
;
unsigned int p = 0;
int n = token-_LEX_OPERATOR_START;
while (n>0 && p<sizeof(tokenNames)) {
while (tokenNames[p] && p<sizeof(tokenNames)) p++;
p++;       n--;     }
assert(n==0);
strncpy(str, &tokenNames[p], len);
return;
}
assert(len>=10);
strncpy(str, ""?["",len);
itostr(token, &str[2], 10);
strncat(str, ""]"",len);
}","void jslTokenAsString(int VAR_0, char *VAR_1, size_t VAR_2) {
if (VAR_0>32 && VAR_0<128) {
assert(VAR_2>=4);
VAR_1[0] = '\'';
VAR_1[1] = (char)VAR_0;
VAR_1[2] = '\'';
VAR_1[3] = 0;
return;
}
switch (VAR_0) {
case VAR_3 : strncpy(VAR_1, ""EOF"", VAR_2); return;
case VAR_4 : strncpy(VAR_1, ""ID"", VAR_2); return;
case VAR_5 : strncpy(VAR_1, ""INT"", VAR_2); return;
case VAR_6 : strncpy(VAR_1, ""FLOAT"", VAR_2); return;
case VAR_7 : strncpy(VAR_1, ""STRING"", VAR_2); return;
case VAR_8 : strncpy(VAR_1, ""UNFINISHED STRING"", VAR_2); return;
case VAR_9 : strncpy(VAR_1, ""TEMPLATE LITERAL"", VAR_2); return;
case VAR_10 : strncpy(VAR_1, ""UNFINISHED TEMPLATE LITERAL"", VAR_2); return;
case VAR_11 : strncpy(VAR_1, ""REGEX"", VAR_2); return;
case VAR_12 : strncpy(VAR_1, ""UNFINISHED REGEX"", VAR_2); return;
case VAR_13 : strncpy(VAR_1, ""UNFINISHED COMMENT"", VAR_2); return;
}
if (VAR_0>=VAR_14 && VAR_0<VAR_15) {
const char VAR_16[] =
""==\0""
""===\0""
""!=\0""
""!==\0""
""<=\0""
""<<\0""
""<<=\0""
"">=\0""
"">>\0""
"">>>\0""
"">>=\0""
"">>>=\0""
""+=\0""
""-=\0""
""++\0""
""--\0""
""*=\0""
""/=\0""
""%=\0""
""&=\0""
""&&\0""
""|=\0""
""||\0""
""^=\0""
""=>\0""
""if\0""
""else\0""
""do\0""
""while\0""
""for\0""
""return\0""
""continue\0""
""function\0""
""return\0""
""var\0""
""let\0""
""const\0""
""this\0""
""throw\0""
""try\0""
""catch\0""
""finally\0""
""true\0""
""false\0""
""null\0""
""undefined\0""
""new\0""
""in\0""
""instanceof\0""
""switch\0""
""case\0""
""default\0""
""delete\0""
""typeof\0""
""void\0""
""debugger\0""
""class\0""
""extends\0""
""super\0""
""static\0""
;
unsigned int VAR_17 = 0;
int VAR_18 = VAR_0-VAR_14;
while (VAR_18>0 && VAR_17<sizeof(VAR_16)) {
while (VAR_16[VAR_17] && VAR_17<sizeof(VAR_16)) VAR_17++;
VAR_17++; 
VAR_18--; 
}
assert(VAR_18==0);
strncpy(VAR_1, &VAR_16[VAR_17], VAR_2);
return;
}
assert(VAR_2>=10);
strncpy(VAR_1, ""?["",VAR_2);
itostr(VAR_0, &VAR_1[2], 10);
strncat(VAR_1, ""]"",VAR_2);
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jslex.c/vul/before/1.json,"void jslTokenAsString(int token, char *str, size_t len) {
  // see JS_ERROR_TOKEN_BUF_SIZE
  if (token>32 && token<128) {
    assert(len>=4);
    str[0] = '\'';
    str[1] = (char)token;
    str[2] = '\'';
    str[3] = 0;
    return;
  }

  switch (token) {
  case LEX_EOF : strncpy(str, ""EOF"", len); return;
  case LEX_ID : strncpy(str, ""ID"", len); return;
  case LEX_INT : strncpy(str, ""INT"", len); return;
  case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return;
  case LEX_STR : strncpy(str, ""STRING"", len); return;
  case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return;
  case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return;
  case LEX_REGEX : strncpy(str, ""REGEX"", len); return;
  case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return;
  case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return;
  }
  if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
    const char tokenNames[] =
        /* LEX_EQUAL      :   */ ""==\0""
        /* LEX_TYPEEQUAL  :   */ ""===\0""
        /* LEX_NEQUAL     :   */ ""!=\0""
        /* LEX_NTYPEEQUAL :   */ ""!==\0""
        /* LEX_LEQUAL    :    */ ""<=\0""
        /* LEX_LSHIFT     :   */ ""<<\0""
        /* LEX_LSHIFTEQUAL :  */ ""<<=\0""
        /* LEX_GEQUAL      :  */ "">=\0""
        /* LEX_RSHIFT      :  */ "">>\0""
        /* LEX_RSHIFTUNSIGNED */ "">>>\0""
        /* LEX_RSHIFTEQUAL :  */ "">>=\0""
        /* LEX_RSHIFTUNSIGNEDEQUAL */ "">>>=\0""
        /* LEX_PLUSEQUAL   :  */ ""+=\0""
        /* LEX_MINUSEQUAL  :  */ ""-=\0""
        /* LEX_PLUSPLUS :     */ ""++\0""
        /* LEX_MINUSMINUS     */ ""--\0""
        /* LEX_MULEQUAL :     */ ""*=\0""
        /* LEX_DIVEQUAL :     */ ""/=\0""
        /* LEX_MODEQUAL :     */ ""%=\0""
        /* LEX_ANDEQUAL :     */ ""&=\0""
        /* LEX_ANDAND :       */ ""&&\0""
        /* LEX_OREQUAL :      */ ""|=\0""
        /* LEX_OROR :         */ ""||\0""
        /* LEX_XOREQUAL :     */ ""^=\0""
        /* LEX_ARROW_FUNCTION */ ""=>\0""

        // reserved words
        /*LEX_R_IF :       */ ""if\0""
        /*LEX_R_ELSE :     */ ""else\0""
        /*LEX_R_DO :       */ ""do\0""
        /*LEX_R_WHILE :    */ ""while\0""
        /*LEX_R_FOR :      */ ""for\0""
        /*LEX_R_BREAK :    */ ""return\0""
        /*LEX_R_CONTINUE   */ ""continue\0""
        /*LEX_R_FUNCTION   */ ""function\0""
        /*LEX_R_RETURN     */ ""return\0""
        /*LEX_R_VAR :      */ ""var\0""
        /*LEX_R_LET :      */ ""let\0""
        /*LEX_R_CONST :    */ ""const\0""
        /*LEX_R_THIS :     */ ""this\0""
        /*LEX_R_THROW :    */ ""throw\0""
        /*LEX_R_TRY :      */ ""try\0""
        /*LEX_R_CATCH :    */ ""catch\0""
        /*LEX_R_FINALLY :  */ ""finally\0""
        /*LEX_R_TRUE :     */ ""true\0""
        /*LEX_R_FALSE :    */ ""false\0""
        /*LEX_R_NULL :     */ ""null\0""
        /*LEX_R_UNDEFINED  */ ""undefined\0""
        /*LEX_R_NEW :      */ ""new\0""
        /*LEX_R_IN :       */ ""in\0""
        /*LEX_R_INSTANCEOF */ ""instanceof\0""
        /*LEX_R_SWITCH     */ ""switch\0""
        /*LEX_R_CASE       */ ""case\0""
        /*LEX_R_DEFAULT    */ ""default\0""
        /*LEX_R_DELETE     */ ""delete\0""
        /*LEX_R_TYPEOF :   */ ""typeof\0""
        /*LEX_R_VOID :     */ ""void\0""
        /*LEX_R_DEBUGGER : */ ""debugger\0""
        /*LEX_R_CLASS :    */ ""class\0""
        /*LEX_R_EXTENDS :  */ ""extends\0""
        /*LEX_R_SUPER :  */   ""super\0""
        /*LEX_R_STATIC :   */ ""static\0""
        ;
    unsigned int p = 0;
    int n = token-_LEX_OPERATOR_START;
    while (n>0 && p<sizeof(tokenNames)) {
      while (tokenNames[p] && p<sizeof(tokenNames)) p++;
      p++; // skip the zero
      n--; // next token
    }
    assert(n==0);
    strncpy(str, &tokenNames[p], len);
    return;
  }

  assert(len>=10);
  espruino_snprintf(str, len, ""?[%d]"", token);
}","void jslTokenAsString(int VAR_0, char *VAR_1, size_t VAR_2) {
  /* COMMENT_0 */
  if (VAR_0>32 && VAR_0<128) {
    assert(VAR_2>=4);
    VAR_1[0] = '\'';
    VAR_1[1] = (char)VAR_0;
    VAR_1[2] = '\'';
    VAR_1[3] = 0;
    return;
  }

  switch (VAR_0) {
  case VAR_3 : strncpy(VAR_1, ""EOF"", VAR_2); return;
  case VAR_4 : strncpy(VAR_1, ""ID"", VAR_2); return;
  case VAR_5 : strncpy(VAR_1, ""INT"", VAR_2); return;
  case VAR_6 : strncpy(VAR_1, ""FLOAT"", VAR_2); return;
  case VAR_7 : strncpy(VAR_1, ""STRING"", VAR_2); return;
  case VAR_8 : strncpy(VAR_1, ""UNFINISHED STRING"", VAR_2); return;
  case VAR_9 : strncpy(VAR_1, ""TEMPLATE LITERAL"", VAR_2); return;
  case VAR_10 : strncpy(VAR_1, ""UNFINISHED TEMPLATE LITERAL"", VAR_2); return;
  case VAR_11 : strncpy(VAR_1, ""REGEX"", VAR_2); return;
  case VAR_12 : strncpy(VAR_1, ""UNFINISHED REGEX"", VAR_2); return;
  case VAR_13 : strncpy(VAR_1, ""UNFINISHED COMMENT"", VAR_2); return;
  }
  if (VAR_0>=VAR_14 && VAR_0<VAR_15) {
    const char VAR_16[] =
        /* COMMENT_1 */ ""==\0""
        /* COMMENT_2 */ ""===\0""
        /* COMMENT_3 */ ""!=\0""
        /* COMMENT_4 */ ""!==\0""
        /* COMMENT_5 */ ""<=\0""
        /* COMMENT_6 */ ""<<\0""
        /* COMMENT_7 */ ""<<=\0""
        /* COMMENT_8 */ "">=\0""
        /* COMMENT_9 */ "">>\0""
        /* COMMENT_10 */ "">>>\0""
        /* COMMENT_11 */ "">>=\0""
        /* COMMENT_12 */ "">>>=\0""
        /* COMMENT_13 */ ""+=\0""
        /* COMMENT_14 */ ""-=\0""
        /* COMMENT_15 */ ""++\0""
        /* COMMENT_16 */ ""--\0""
        /* COMMENT_17 */ ""*=\0""
        /* COMMENT_18 */ ""/=\0""
        /* COMMENT_19 */ ""%=\0""
        /* COMMENT_20 */ ""&=\0""
        /* COMMENT_21 */ ""&&\0""
        /* COMMENT_22 */ ""|=\0""
        /* COMMENT_23 */ ""||\0""
        /* COMMENT_24 */ ""^=\0""
        /* COMMENT_25 */ ""=>\0""

        /* COMMENT_26 */
        /* COMMENT_27 */ ""if\0""
        /* COMMENT_28 */ ""else\0""
        /* COMMENT_29 */ ""do\0""
        /* COMMENT_30 */ ""while\0""
        /* COMMENT_31 */ ""for\0""
        /* COMMENT_32 */ ""return\0""
        /* COMMENT_33 */ ""continue\0""
        /* COMMENT_34 */ ""function\0""
        /* COMMENT_35 */ ""return\0""
        /* COMMENT_36 */ ""var\0""
        /* COMMENT_37 */ ""let\0""
        /* COMMENT_38 */ ""const\0""
        /* COMMENT_39 */ ""this\0""
        /* COMMENT_40 */ ""throw\0""
        /* COMMENT_41 */ ""try\0""
        /* COMMENT_42 */ ""catch\0""
        /* COMMENT_43 */ ""finally\0""
        /* COMMENT_44 */ ""true\0""
        /* COMMENT_45 */ ""false\0""
        /* COMMENT_46 */ ""null\0""
        /* COMMENT_47 */ ""undefined\0""
        /* COMMENT_48 */ ""new\0""
        /* COMMENT_49 */ ""in\0""
        /* COMMENT_50 */ ""instanceof\0""
        /* COMMENT_51 */ ""switch\0""
        /* COMMENT_52 */ ""case\0""
        /* COMMENT_53 */ ""default\0""
        /* COMMENT_54 */ ""delete\0""
        /* COMMENT_55 */ ""typeof\0""
        /* COMMENT_56 */ ""void\0""
        /* COMMENT_57 */ ""debugger\0""
        /* COMMENT_58 */ ""class\0""
        /* COMMENT_59 */ ""extends\0""
        /* COMMENT_60 */   ""super\0""
        /* COMMENT_61 */ ""static\0""
        ;
    unsigned int VAR_17 = 0;
    int VAR_18 = VAR_0-VAR_14;
    while (VAR_18>0 && VAR_17<sizeof(VAR_16)) {
      while (VAR_16[VAR_17] && VAR_17<sizeof(VAR_16)) VAR_17++;
      VAR_17++; /* COMMENT_62 */
      VAR_18--; /* COMMENT_63 */
    }
    assert(VAR_18==0);
    strncpy(VAR_1, &VAR_16[VAR_17], VAR_2);
    return;
  }

  assert(VAR_2>=10);
  espruino_snprintf(VAR_1, VAR_2, ""?[%d]"", VAR_0);
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jslex.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -100,7 +100,5 @@
   }
 
   assert(len>=10);
-  strncpy(str, ""?["",len);
-  itostr(token, &str[2], 10);
-  strncat(str, ""]"",len);
+  espruino_snprintf(str, len, ""?[%d]"", token);
 }","{'deleted_lines': ['  strncpy(str, ""?["",len);', '  itostr(token, &str[2], 10);', '  strncat(str, ""]"",len);'], 'added_lines': ['  espruino_snprintf(str, len, ""?[%d]"", token);']}",True,"Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",7.8,HIGH,2,test,2018-05-21T09:35:49Z,2
CVE-2018-11595,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,espruino/Espruino,Fix strncat/cpy bounding issues (fix #1425),0a7619875bf79877907205f6bee08465b89ff10b,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,src/jslex.c,jslGetTokenString,"void jslGetTokenString(char *str, size_t len) {
if (lex->tk == LEX_ID) {
strncpy(str, ""ID:"", len);
strncat(str, jslGetTokenValueAsString(), len);
} else if (lex->tk == LEX_STR) {
strncpy(str, ""String:'"", len);
strncat(str, jslGetTokenValueAsString(), len);
strncat(str, ""'"", len);
} else
jslTokenAsString(lex->tk, str, len);
}","void jslGetTokenString(char *VAR_0, size_t VAR_1) {
if (VAR_2->tk == VAR_3) {
strncpy(VAR_0, ""ID:"", VAR_1);
strncat(VAR_0, jslGetTokenValueAsString(), VAR_1);
} else if (VAR_2->tk == VAR_4) {
strncpy(VAR_0, ""String:'"", VAR_1);
strncat(VAR_0, jslGetTokenValueAsString(), VAR_1);
strncat(VAR_0, ""'"", VAR_1);
} else
jslTokenAsString(VAR_2->tk, VAR_0, VAR_1);
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jslex.c/vul/before/0.json,"void jslGetTokenString(char *str, size_t len) {
  if (lex->tk == LEX_ID) {
    espruino_snprintf(str, len, ""ID:%s"", jslGetTokenValueAsString());
  } else if (lex->tk == LEX_STR) {
    espruino_snprintf(str, len, ""String:'%s'"", jslGetTokenValueAsString());
  } else
    jslTokenAsString(lex->tk, str, len);
}","void jslGetTokenString(char *VAR_0, size_t VAR_1) {
  if (VAR_2->tk == VAR_3) {
    espruino_snprintf(VAR_0, VAR_1, ""ID:%s"", jslGetTokenValueAsString());
  } else if (VAR_2->tk == VAR_4) {
    espruino_snprintf(VAR_0, VAR_1, ""String:'%s'"", jslGetTokenValueAsString());
  } else
    jslTokenAsString(VAR_2->tk, VAR_0, VAR_1);
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jslex.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,8 @@
 void jslGetTokenString(char *str, size_t len) {
   if (lex->tk == LEX_ID) {
-    strncpy(str, ""ID:"", len);
-    strncat(str, jslGetTokenValueAsString(), len);
+    espruino_snprintf(str, len, ""ID:%s"", jslGetTokenValueAsString());
   } else if (lex->tk == LEX_STR) {
-    strncpy(str, ""String:'"", len);
-    strncat(str, jslGetTokenValueAsString(), len);
-    strncat(str, ""'"", len);
+    espruino_snprintf(str, len, ""String:'%s'"", jslGetTokenValueAsString());
   } else
     jslTokenAsString(lex->tk, str, len);
 }","{'deleted_lines': ['    strncpy(str, ""ID:"", len);', '    strncat(str, jslGetTokenValueAsString(), len);', '    strncpy(str, ""String:\'"", len);', '    strncat(str, jslGetTokenValueAsString(), len);', '    strncat(str, ""\'"", len);'], 'added_lines': ['    espruino_snprintf(str, len, ""ID:%s"", jslGetTokenValueAsString());', '    espruino_snprintf(str, len, ""String:\'%s\'"", jslGetTokenValueAsString());']}",True,"Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",7.8,HIGH,2,test,2018-05-21T09:35:49Z,2
CVE-2018-11595,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,espruino/Espruino,Fix strncat/cpy bounding issues (fix #1425),0a7619875bf79877907205f6bee08465b89ff10b,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,src/jspin.c,jshPinFunctionToString,"void jshPinFunctionToString(JshPinFunction pinFunc, JshPinFunctionToStringFlags flags, char *buf, size_t bufSize) {
const char *devStr = """";
JshPinFunction info = JSH_MASK_INFO & pinFunc;
JshPinFunction firstDevice = 0;
const char *infoStr = 0;
char infoStrBuf[5];
buf[0]=0;
if (JSH_PINFUNCTION_IS_USART(pinFunc)) {
devStr=(flags&JSPFTS_JS_NAMES)?""Serial"":""USART"";
firstDevice=JSH_USART1;
if (info==JSH_USART_RX) infoStr=""RX"";
else if (info==JSH_USART_TX) infoStr=""TX"";
else if (info==JSH_USART_CK) infoStr=""CK"";
} else if (JSH_PINFUNCTION_IS_SPI(pinFunc)) {
devStr=""SPI"";
firstDevice=JSH_SPI1;
if (info==JSH_SPI_MISO) infoStr=""MISO"";
else if (info==JSH_SPI_MOSI) infoStr=""MOSI"";
else if (info==JSH_SPI_SCK) infoStr=""SCK"";
} else if (JSH_PINFUNCTION_IS_I2C(pinFunc)) {
devStr=""I2C"";
firstDevice=JSH_I2C1;
if (info==JSH_I2C_SCL) infoStr=""SCL"";
else if (info==JSH_I2C_SDA) infoStr=""SDA"";
} else if (JSH_PINFUNCTION_IS_DAC(pinFunc)) {
devStr=""DAC"";
firstDevice=JSH_DAC;
if (info==JSH_DAC_CH1) infoStr=""CH1"";
else if (info==JSH_DAC_CH2) infoStr=""CH2"";
} else if (JSH_PINFUNCTION_IS_TIMER(pinFunc)) {
devStr=""TIM"";
firstDevice=JSH_TIMER1;
infoStr = &infoStrBuf[0];
infoStrBuf[0] = 'C';
infoStrBuf[1] = 'H';
infoStrBuf[2] = (char)('1' + ((info&JSH_MASK_TIMER_CH)>>JSH_SHIFT_INFO));
if (info & JSH_TIMER_NEGATED) {
infoStrBuf[3]='N';
infoStrBuf[4] = 0;
} else {
infoStrBuf[3] = 0;
}
}
int devIdx = 1 + ((((pinFunc&JSH_MASK_TYPE) - firstDevice) >> JSH_SHIFT_TYPE));
if (!devStr) {
jsiConsolePrintf(""Couldn't convert pin function %d\n"", pinFunc);
return;
}
if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize);
if (flags & JSPFTS_DEVICE_NUMBER) itostr(devIdx, &buf[strlen(buf)], 10);
if (flags & JSPFTS_SPACE) strncat(buf, "" "", bufSize);
if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize);
}","void jshPinFunctionToString(JshPinFunction VAR_0, JshPinFunctionToStringFlags VAR_1, char *VAR_2, size_t VAR_3) {
const char *VAR_4 = """";
JshPinFunction VAR_5 = VAR_6 & VAR_0;
JshPinFunction VAR_7 = 0;
const char *VAR_8 = 0;
char VAR_9[5];
VAR_2[0]=0;
if (JSH_PINFUNCTION_IS_USART(VAR_0)) {
VAR_4=(VAR_1&VAR_10)?""Serial"":""USART"";
VAR_7=VAR_11;
if (VAR_5==VAR_12) VAR_8=""RX"";
else if (VAR_5==VAR_13) VAR_8=""TX"";
else if (VAR_5==VAR_14) VAR_8=""CK"";
} else if (JSH_PINFUNCTION_IS_SPI(VAR_0)) {
VAR_4=""SPI"";
VAR_7=VAR_15;
if (VAR_5==VAR_16) VAR_8=""MISO"";
else if (VAR_5==VAR_17) VAR_8=""MOSI"";
else if (VAR_5==VAR_18) VAR_8=""SCK"";
} else if (JSH_PINFUNCTION_IS_I2C(VAR_0)) {
VAR_4=""I2C"";
VAR_7=VAR_19;
if (VAR_5==VAR_20) VAR_8=""SCL"";
else if (VAR_5==VAR_21) VAR_8=""SDA"";
} else if (JSH_PINFUNCTION_IS_DAC(VAR_0)) {
VAR_4=""DAC"";
VAR_7=VAR_22;
if (VAR_5==VAR_23) VAR_8=""CH1"";
else if (VAR_5==VAR_24) VAR_8=""CH2"";
} else if (JSH_PINFUNCTION_IS_TIMER(VAR_0)) {
VAR_4=""TIM"";
VAR_7=VAR_25;
VAR_8 = &VAR_9[0];
VAR_9[0] = 'C';
VAR_9[1] = 'H';
VAR_9[2] = (char)('1' + ((VAR_5&VAR_26)>>VAR_27));
if (VAR_5 & VAR_28) {
VAR_9[3]='N';
VAR_9[4] = 0;
} else {
VAR_9[3] = 0;
}
}
int VAR_29 = 1 + ((((VAR_0&VAR_30) - VAR_7) >> VAR_31));
if (!VAR_4) {
jsiConsolePrintf(""Couldn't convert pin function %d\n"", VAR_0);
return;
}
if (VAR_1 & VAR_32) strncat(VAR_2, VAR_4, VAR_3);
if (VAR_1 & VAR_33) itostr(VAR_29, &VAR_2[strlen(VAR_2)], 10);
if (VAR_1 & VAR_34) strncat(VAR_2, "" "", VAR_3);
if (VAR_8 && (VAR_1 & VAR_35)) strncat(VAR_2, VAR_8, VAR_3);
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jspin.c/vul/before/0.json,"void jshPinFunctionToString(JshPinFunction pinFunc, JshPinFunctionToStringFlags flags, char *buf, size_t bufSize) {
  const char *devStr = """";
  JshPinFunction info = JSH_MASK_INFO & pinFunc;
  JshPinFunction firstDevice = 0;
  const char *infoStr = 0;
  char infoStrBuf[5];
  buf[0]=0;
  if (JSH_PINFUNCTION_IS_USART(pinFunc)) {
    devStr=(flags&JSPFTS_JS_NAMES)?""Serial"":""USART"";
    firstDevice=JSH_USART1;
    if (info==JSH_USART_RX) infoStr=""RX"";
    else if (info==JSH_USART_TX) infoStr=""TX"";
    else if (info==JSH_USART_CK) infoStr=""CK"";
  } else if (JSH_PINFUNCTION_IS_SPI(pinFunc)) {
    devStr=""SPI"";
    firstDevice=JSH_SPI1;
    if (info==JSH_SPI_MISO) infoStr=""MISO"";
    else if (info==JSH_SPI_MOSI) infoStr=""MOSI"";
    else if (info==JSH_SPI_SCK) infoStr=""SCK"";
  } else if (JSH_PINFUNCTION_IS_I2C(pinFunc)) {
    devStr=""I2C"";
    firstDevice=JSH_I2C1;
    if (info==JSH_I2C_SCL) infoStr=""SCL"";
    else if (info==JSH_I2C_SDA) infoStr=""SDA"";
  } else if (JSH_PINFUNCTION_IS_DAC(pinFunc)) {
     devStr=""DAC"";
     firstDevice=JSH_DAC;
     if (info==JSH_DAC_CH1) infoStr=""CH1"";
     else if (info==JSH_DAC_CH2) infoStr=""CH2"";
  } else if (JSH_PINFUNCTION_IS_TIMER(pinFunc)) {
     devStr=""TIM"";
     firstDevice=JSH_TIMER1;
     infoStr = &infoStrBuf[0];
     infoStrBuf[0] = 'C';
     infoStrBuf[1] = 'H';
     infoStrBuf[2] = (char)('1' + ((info&JSH_MASK_TIMER_CH)>>JSH_SHIFT_INFO));
     if (info & JSH_TIMER_NEGATED) {
       infoStrBuf[3]='N';
       infoStrBuf[4] = 0;
     } else {
       infoStrBuf[3] = 0;
     }
   }
  int devIdx = 1 + ((((pinFunc&JSH_MASK_TYPE) - firstDevice) >> JSH_SHIFT_TYPE));

  if (!devStr) {
    jsiConsolePrintf(""Couldn't convert pin function %d\n"", pinFunc);
    return;
  }
  if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize-1);
  if (flags & JSPFTS_DEVICE_NUMBER) itostr(devIdx, &buf[strlen(buf)], 10);
  if (flags & JSPFTS_SPACE) strncat(buf, "" "", bufSize-(strlen(buf)+1));
  if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize-(strlen(buf)+1));
}","void jshPinFunctionToString(JshPinFunction VAR_0, JshPinFunctionToStringFlags VAR_1, char *VAR_2, size_t VAR_3) {
  const char *VAR_4 = """";
  JshPinFunction VAR_5 = VAR_6 & VAR_0;
  JshPinFunction VAR_7 = 0;
  const char *VAR_8 = 0;
  char VAR_9[5];
  VAR_2[0]=0;
  if (JSH_PINFUNCTION_IS_USART(VAR_0)) {
    VAR_4=(VAR_1&VAR_10)?""Serial"":""USART"";
    VAR_7=VAR_11;
    if (VAR_5==VAR_12) VAR_8=""RX"";
    else if (VAR_5==VAR_13) VAR_8=""TX"";
    else if (VAR_5==VAR_14) VAR_8=""CK"";
  } else if (JSH_PINFUNCTION_IS_SPI(VAR_0)) {
    VAR_4=""SPI"";
    VAR_7=VAR_15;
    if (VAR_5==VAR_16) VAR_8=""MISO"";
    else if (VAR_5==VAR_17) VAR_8=""MOSI"";
    else if (VAR_5==VAR_18) VAR_8=""SCK"";
  } else if (JSH_PINFUNCTION_IS_I2C(VAR_0)) {
    VAR_4=""I2C"";
    VAR_7=VAR_19;
    if (VAR_5==VAR_20) VAR_8=""SCL"";
    else if (VAR_5==VAR_21) VAR_8=""SDA"";
  } else if (JSH_PINFUNCTION_IS_DAC(VAR_0)) {
     VAR_4=""DAC"";
     VAR_7=VAR_22;
     if (VAR_5==VAR_23) VAR_8=""CH1"";
     else if (VAR_5==VAR_24) VAR_8=""CH2"";
  } else if (JSH_PINFUNCTION_IS_TIMER(VAR_0)) {
     VAR_4=""TIM"";
     VAR_7=VAR_25;
     VAR_8 = &VAR_9[0];
     VAR_9[0] = 'C';
     VAR_9[1] = 'H';
     VAR_9[2] = (char)('1' + ((VAR_5&VAR_26)>>VAR_27));
     if (VAR_5 & VAR_28) {
       VAR_9[3]='N';
       VAR_9[4] = 0;
     } else {
       VAR_9[3] = 0;
     }
   }
  int VAR_29 = 1 + ((((VAR_0&VAR_30) - VAR_7) >> VAR_31));

  if (!VAR_4) {
    jsiConsolePrintf(""Couldn't convert pin function %d\n"", VAR_0);
    return;
  }
  if (VAR_1 & VAR_32) strncat(VAR_2, VAR_4, VAR_3-1);
  if (VAR_1 & VAR_33) itostr(VAR_29, &VAR_2[strlen(VAR_2)], 10);
  if (VAR_1 & VAR_34) strncat(VAR_2, "" "", VAR_3-(strlen(VAR_2)+1));
  if (VAR_8 && (VAR_1 & VAR_35)) strncat(VAR_2, VAR_8, VAR_3-(strlen(VAR_2)+1));
}",espruino/Espruino/0a7619875bf79877907205f6bee08465b89ff10b/jspin.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,8 +47,8 @@
     jsiConsolePrintf(""Couldn't convert pin function %d\n"", pinFunc);
     return;
   }
-  if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize);
+  if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize-1);
   if (flags & JSPFTS_DEVICE_NUMBER) itostr(devIdx, &buf[strlen(buf)], 10);
-  if (flags & JSPFTS_SPACE) strncat(buf, "" "", bufSize);
-  if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize);
+  if (flags & JSPFTS_SPACE) strncat(buf, "" "", bufSize-(strlen(buf)+1));
+  if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize-(strlen(buf)+1));
 }","{'deleted_lines': ['  if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize);', '  if (flags & JSPFTS_SPACE) strncat(buf, "" "", bufSize);', '  if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize);'], 'added_lines': ['  if (flags & JSPFTS_DEVICE) strncat(buf, devStr, bufSize-1);', '  if (flags & JSPFTS_SPACE) strncat(buf, "" "", bufSize-(strlen(buf)+1));', '  if (infoStr && (flags & JSPFTS_TYPE)) strncat(buf, infoStr, bufSize-(strlen(buf)+1));']}",True,"Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Escalation of Privileges with a user crafted input file via a Buffer Overflow during syntax parsing, because strncat is misused.",7.8,HIGH,2,test,2018-05-21T09:35:49Z,2
CVE-2018-11594,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,espruino/Espruino,Fix stack overflow if void void void... is repeated many times (fix #1434),c36d30529118aa049797db43f111ddad468aad29,https://github.com/espruino/Espruino/commit/c36d30529118aa049797db43f111ddad468aad29,src/jsparse.c,jspeFactor,"NO_INLINE JsVar *jspeFactor() {
if (lex->tk==LEX_ID) {
JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));
JSP_ASSERT_MATCH(LEX_ID);
#ifndef SAVE_ON_FLASH
if (lex->tk==LEX_TEMPLATE_LITERAL)
jsExceptionHere(JSET_SYNTAXERROR, ""Tagged template literals not supported"");
else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {
JsVar *funcVar = jspeArrowFunction(0,a);
jsvUnLock(a);
a=funcVar;
}
#endif
return a;
} else if (lex->tk==LEX_INT) {
JsVar *v = 0;
if (JSP_SHOULD_EXECUTE) {
v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));
}
JSP_ASSERT_MATCH(LEX_INT);
return v;
} else if (lex->tk==LEX_FLOAT) {
JsVar *v = 0;
if (JSP_SHOULD_EXECUTE) {
v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));
}
JSP_ASSERT_MATCH(LEX_FLOAT);
return v;
} else if (lex->tk=='(') {
JSP_ASSERT_MATCH('(');
if (!jspCheckStackPosition()) return 0;
#ifdef SAVE_ON_FLASH
JsVar *a = jspeExpression();
if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);
return a;
#else
return jspeExpressionOrArrowFunction();
#endif
} else if (lex->tk==LEX_R_TRUE) {
JSP_ASSERT_MATCH(LEX_R_TRUE);
return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;
} else if (lex->tk==LEX_R_FALSE) {
JSP_ASSERT_MATCH(LEX_R_FALSE);
return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;
} else if (lex->tk==LEX_R_NULL) {
JSP_ASSERT_MATCH(LEX_R_NULL);
return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;
} else if (lex->tk==LEX_R_UNDEFINED) {
JSP_ASSERT_MATCH(LEX_R_UNDEFINED);
return 0;
} else if (lex->tk==LEX_STR) {
JsVar *a = 0;
if (JSP_SHOULD_EXECUTE)
a = jslGetTokenValueAsVar(lex);
JSP_ASSERT_MATCH(LEX_STR);
return a;
#ifndef SAVE_ON_FLASH
} else if (lex->tk==LEX_TEMPLATE_LITERAL) {
return jspeTemplateLiteral();
#endif
} else if (lex->tk==LEX_REGEX) {
JsVar *a = 0;
#ifdef SAVE_ON_FLASH
jsExceptionHere(JSET_SYNTAXERROR, ""RegEx are not supported in this version of Espruino\n"");
#else
JsVar *regex = jslGetTokenValueAsVar(lex);
size_t regexEnd = 0, regexLen = 0;
JsvStringIterator it;
jsvStringIteratorNew(&it, regex, 0);
while (jsvStringIteratorHasChar(&it)) {
regexLen++;
if (jsvStringIteratorGetChar(&it)=='/')
regexEnd = regexLen;
jsvStringIteratorNext(&it);
}
jsvStringIteratorFree(&it);
JsVar *flags = 0;
if (regexEnd < regexLen)
flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);
JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);
a = jswrap_regexp_constructor(regexSource, flags);
jsvUnLock3(regex, flags, regexSource);
#endif
JSP_ASSERT_MATCH(LEX_REGEX);
return a;
} else if (lex->tk=='{') {
if (!jspCheckStackPosition()) return 0;
return jspeFactorObject();
} else if (lex->tk=='[') {
if (!jspCheckStackPosition()) return 0;
return jspeFactorArray();
} else if (lex->tk==LEX_R_FUNCTION) {
if (!jspCheckStackPosition()) return 0;
JSP_ASSERT_MATCH(LEX_R_FUNCTION);
return jspeFunctionDefinition(true);
#ifndef SAVE_ON_FLASH
} else if (lex->tk==LEX_R_CLASS) {
if (!jspCheckStackPosition()) return 0;
JSP_ASSERT_MATCH(LEX_R_CLASS);
return jspeClassDefinition(true);
} else if (lex->tk==LEX_R_SUPER) {
JSP_ASSERT_MATCH(LEX_R_SUPER);
if (jsvIsObject(execInfo.thisVar)) {
JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0);       JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;       jsvUnLock(proto1);
if (!proto2) {
jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
return 0;
}
if (lex->tk=='(') return proto2;             JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;
jsvUnLock(proto2);
return proto3;
} else if (jsvIsFunction(execInfo.thisVar)) {
JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);
JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;
jsvUnLock(proto1);
if (!proto2) {
jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
return 0;
}
return proto2;
}
jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
return 0;
#endif
} else if (lex->tk==LEX_R_THIS) {
JSP_ASSERT_MATCH(LEX_R_THIS);
return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );
} else if (lex->tk==LEX_R_DELETE) {
if (!jspCheckStackPosition()) return 0;
return jspeFactorDelete();
} else if (lex->tk==LEX_R_TYPEOF) {
if (!jspCheckStackPosition()) return 0;
return jspeFactorTypeOf();
} else if (lex->tk==LEX_R_VOID) {
JSP_ASSERT_MATCH(LEX_R_VOID);
jsvUnLock(jspeUnaryExpression());
return 0;
}
JSP_MATCH(LEX_EOF);
jsExceptionHere(JSET_SYNTAXERROR, ""Unexpected end of Input\n"");
return 0;
}","NO_INLINE VAR_0 *jspeFactor() {
if (VAR_1->tk==VAR_2) {
JsVar *VAR_3 = jspGetNamedVariable(jslGetTokenValueAsString(VAR_1));
JSP_ASSERT_MATCH(VAR_2);
#ifndef VAR_4
if (VAR_1->tk==VAR_5)
jsExceptionHere(VAR_6, ""Tagged template literals not supported"");
else if (VAR_1->tk==VAR_7 && jsvIsName(VAR_3)) {
JsVar *VAR_8 = jspeArrowFunction(0,VAR_3);
jsvUnLock(VAR_3);
VAR_3=VAR_8;
}
#endif
return VAR_3;
} else if (VAR_1->tk==VAR_9) {
JsVar *VAR_10 = 0;
if (VAR_11) {
VAR_10 = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(VAR_1)));
}
JSP_ASSERT_MATCH(VAR_9);
return VAR_10;
} else if (VAR_1->tk==VAR_12) {
JsVar *VAR_10 = 0;
if (VAR_11) {
VAR_10 = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(VAR_1)));
}
JSP_ASSERT_MATCH(VAR_12);
return VAR_10;
} else if (VAR_1->tk=='(') {
JSP_ASSERT_MATCH('(');
if (!jspCheckStackPosition()) return 0;
#ifdef VAR_4
JsVar *VAR_3 = jspeExpression();
if (!VAR_13) JSP_MATCH_WITH_RETURN(')',VAR_3);
return VAR_3;
#else
return jspeExpressionOrArrowFunction();
#endif
} else if (VAR_1->tk==VAR_14) {
JSP_ASSERT_MATCH(VAR_14);
return VAR_11 ? jsvNewFromBool(true) : 0;
} else if (VAR_1->tk==VAR_15) {
JSP_ASSERT_MATCH(VAR_15);
return VAR_11 ? jsvNewFromBool(false) : 0;
} else if (VAR_1->tk==VAR_16) {
JSP_ASSERT_MATCH(VAR_16);
return VAR_11 ? jsvNewWithFlags(VAR_17) : 0;
} else if (VAR_1->tk==VAR_18) {
JSP_ASSERT_MATCH(VAR_18);
return 0;
} else if (VAR_1->tk==VAR_19) {
JsVar *VAR_3 = 0;
if (VAR_11)
VAR_3 = jslGetTokenValueAsVar(VAR_1);
JSP_ASSERT_MATCH(VAR_19);
return VAR_3;
#ifndef VAR_4
} else if (VAR_1->tk==VAR_5) {
return jspeTemplateLiteral();
#endif
} else if (lex->tk==LEX_REGEX) {
JsVar *VAR_3 = 0;
#ifdef VAR_4
jsExceptionHere(VAR_6, ""RegEx are not supported in this version of Espruino\n"");
#else
JsVar *VAR_20 = jslGetTokenValueAsVar(VAR_1);
size_t VAR_21 = 0, VAR_22 = 0;
JsvStringIterator VAR_23;
jsvStringIteratorNew(&VAR_23, VAR_20, 0);
while (jsvStringIteratorHasChar(&VAR_23)) {
VAR_22++;
if (jsvStringIteratorGetChar(&VAR_23)=='/')
VAR_21 = VAR_22;
jsvStringIteratorNext(&VAR_23);
}
jsvStringIteratorFree(&VAR_23);
JsVar *VAR_24 = 0;
if (VAR_21 < VAR_22)
VAR_24 = jsvNewFromStringVar(VAR_20, VAR_21, VAR_25);
JsVar *VAR_26 = jsvNewFromStringVar(VAR_20, 1, VAR_21-2);
VAR_3 = jswrap_regexp_constructor(VAR_26, VAR_24);
jsvUnLock3(VAR_20, VAR_24, VAR_26);
#endif
JSP_ASSERT_MATCH(VAR_27);
return VAR_3;
} else if (VAR_1->tk=='{') {
if (!jspCheckStackPosition()) return 0;
return jspeFactorObject();
} else if (VAR_1->tk=='[') {
if (!jspCheckStackPosition()) return 0;
return jspeFactorArray();
} else if (VAR_1->tk==VAR_28) {
if (!jspCheckStackPosition()) return 0;
JSP_ASSERT_MATCH(VAR_28);
return jspeFunctionDefinition(true);
#ifndef VAR_4
} else if (VAR_1->tk==VAR_29) {
if (!jspCheckStackPosition()) return 0;
JSP_ASSERT_MATCH(VAR_29);
return jspeClassDefinition(true);
} else if (VAR_1->tk==VAR_30) {
JSP_ASSERT_MATCH(VAR_30);
if (jsvIsObject(VAR_31.thisVar)) {
JsVar *VAR_32 = jsvObjectGetChild(VAR_31.thisVar, VAR_33, 0); 
JsVar *VAR_34 = jsvIsObject(VAR_32) ? jsvObjectGetChild(VAR_32, VAR_33, 0) : 0; 
jsvUnLock(VAR_32);
if (!VAR_34) {
jsExceptionHere(VAR_6, ""Calling 'super' outside of class"");
return 0;
}
if (VAR_1->tk=='(') return VAR_34; 
JsVar *VAR_35 = jsvIsFunction(VAR_34) ? jsvObjectGetChild(VAR_34, VAR_36, 0) : 0;
jsvUnLock(VAR_34);
return VAR_35;
} else if (jsvIsFunction(VAR_31.thisVar)) {
JsVar *VAR_32 = jsvObjectGetChild(VAR_31.thisVar, VAR_36, 0);
JsVar *VAR_34 = jsvIsObject(VAR_32) ? jsvObjectGetChild(VAR_32, VAR_33, 0) : 0;
jsvUnLock(VAR_32);
if (!VAR_34) {
jsExceptionHere(VAR_6, ""Calling 'super' outside of class"");
return 0;
}
return VAR_34;
}
jsExceptionHere(VAR_6, ""Calling 'super' outside of class"");
return 0;
#endif
} else if (lex->tk==LEX_R_THIS) {
JSP_ASSERT_MATCH(VAR_37);
return jsvLockAgain( VAR_31.thisVar ? VAR_31.thisVar : VAR_31.root );
} else if (VAR_1->tk==VAR_38) {
if (!jspCheckStackPosition()) return 0;
return jspeFactorDelete();
} else if (VAR_1->tk==VAR_39) {
if (!jspCheckStackPosition()) return 0;
return jspeFactorTypeOf();
} else if (VAR_1->tk==VAR_40) {
JSP_ASSERT_MATCH(VAR_40);
jsvUnLock(jspeUnaryExpression());
return 0;
}
JSP_MATCH(VAR_41);
jsExceptionHere(VAR_6, ""Unexpected end of Input\n"");
return 0;
}",,"NO_INLINE JsVar *jspeFactor() {
  if (lex->tk==LEX_ID) {
    JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));
    JSP_ASSERT_MATCH(LEX_ID);
#ifndef SAVE_ON_FLASH
    if (lex->tk==LEX_TEMPLATE_LITERAL)
      jsExceptionHere(JSET_SYNTAXERROR, ""Tagged template literals not supported"");
    else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {
      JsVar *funcVar = jspeArrowFunction(0,a);
      jsvUnLock(a);
      a=funcVar;
    }
#endif
    return a;
  } else if (lex->tk==LEX_INT) {
    JsVar *v = 0;
    if (JSP_SHOULD_EXECUTE) {
      v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));
    }
    JSP_ASSERT_MATCH(LEX_INT);
    return v;
  } else if (lex->tk==LEX_FLOAT) {
    JsVar *v = 0;
    if (JSP_SHOULD_EXECUTE) {
      v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));
    }
    JSP_ASSERT_MATCH(LEX_FLOAT);
    return v;
  } else if (lex->tk=='(') {
    JSP_ASSERT_MATCH('(');
    if (!jspCheckStackPosition()) return 0;
#ifdef SAVE_ON_FLASH
    // Just parse a normal expression (which can include commas)
    JsVar *a = jspeExpression();
    if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);
    return a;
#else
    return jspeExpressionOrArrowFunction();
#endif

  } else if (lex->tk==LEX_R_TRUE) {
    JSP_ASSERT_MATCH(LEX_R_TRUE);
    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;
  } else if (lex->tk==LEX_R_FALSE) {
    JSP_ASSERT_MATCH(LEX_R_FALSE);
    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;
  } else if (lex->tk==LEX_R_NULL) {
    JSP_ASSERT_MATCH(LEX_R_NULL);
    return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;
  } else if (lex->tk==LEX_R_UNDEFINED) {
    JSP_ASSERT_MATCH(LEX_R_UNDEFINED);
    return 0;
  } else if (lex->tk==LEX_STR) {
    JsVar *a = 0;
    if (JSP_SHOULD_EXECUTE)
      a = jslGetTokenValueAsVar(lex);
    JSP_ASSERT_MATCH(LEX_STR);
    return a;
#ifndef SAVE_ON_FLASH
  } else if (lex->tk==LEX_TEMPLATE_LITERAL) {
    return jspeTemplateLiteral();
#endif
  } else if (lex->tk==LEX_REGEX) {
    JsVar *a = 0;
#ifdef SAVE_ON_FLASH
    jsExceptionHere(JSET_SYNTAXERROR, ""RegEx are not supported in this version of Espruino\n"");
#else
    JsVar *regex = jslGetTokenValueAsVar(lex);
    size_t regexEnd = 0, regexLen = 0;
    JsvStringIterator it;
    jsvStringIteratorNew(&it, regex, 0);
    while (jsvStringIteratorHasChar(&it)) {
      regexLen++;
      if (jsvStringIteratorGetChar(&it)=='/')
        regexEnd = regexLen;
      jsvStringIteratorNext(&it);
    }
    jsvStringIteratorFree(&it);
    JsVar *flags = 0;
    if (regexEnd < regexLen)
      flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);
    JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);
    a = jswrap_regexp_constructor(regexSource, flags);
    jsvUnLock3(regex, flags, regexSource);
#endif
    JSP_ASSERT_MATCH(LEX_REGEX);
    return a;
  } else if (lex->tk=='{') {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorObject();
  } else if (lex->tk=='[') {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorArray();
  } else if (lex->tk==LEX_R_FUNCTION) {
    if (!jspCheckStackPosition()) return 0;
    JSP_ASSERT_MATCH(LEX_R_FUNCTION);
    return jspeFunctionDefinition(true);
#ifndef SAVE_ON_FLASH
  } else if (lex->tk==LEX_R_CLASS) {
    if (!jspCheckStackPosition()) return 0;
    JSP_ASSERT_MATCH(LEX_R_CLASS);
    return jspeClassDefinition(true);
  } else if (lex->tk==LEX_R_SUPER) {
    JSP_ASSERT_MATCH(LEX_R_SUPER);
    /* This is kind of nasty, since super appears to do
      three different things.

      * In the constructor it references the extended class's constructor
      * in a method it references the constructor's prototype.
      * in a static method it references the extended class's constructor (but this is different)
     */

    if (jsvIsObject(execInfo.thisVar)) {
      // 'this' is an object - must be calling a normal method
      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0); // if we're in a method, get __proto__ first
      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0; // still in method, get __proto__.__proto__
      jsvUnLock(proto1);
      if (!proto2) {
        jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
        return 0;
      }
      if (lex->tk=='(') return proto2; // eg. used in a constructor
      // But if we're doing something else - eg '.' or '[' then it needs to reference the prototype
      JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;
      jsvUnLock(proto2);
      return proto3;
    } else if (jsvIsFunction(execInfo.thisVar)) {
      // 'this' is a function - must be calling a static method
      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);
      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;
      jsvUnLock(proto1);
      if (!proto2) {
        jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
        return 0;
      }
      return proto2;
    }
    jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
    return 0;
#endif
  } else if (lex->tk==LEX_R_THIS) {
    JSP_ASSERT_MATCH(LEX_R_THIS);
    return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );
  } else if (lex->tk==LEX_R_DELETE) {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorDelete();
  } else if (lex->tk==LEX_R_TYPEOF) {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorTypeOf();
  } else if (lex->tk==LEX_R_VOID) {
    if (!jspCheckStackPosition()) return 0;
    JSP_ASSERT_MATCH(LEX_R_VOID);
    jsvUnLock(jspeUnaryExpression());
    return 0;
  }
  JSP_MATCH(LEX_EOF);
  jsExceptionHere(JSET_SYNTAXERROR, ""Unexpected end of Input\n"");
  return 0;
}","NO_INLINE VAR_0 *jspeFactor() {
  if (VAR_1->tk==VAR_2) {
    JsVar *VAR_3 = jspGetNamedVariable(jslGetTokenValueAsString(VAR_1));
    JSP_ASSERT_MATCH(VAR_2);
#ifndef VAR_4
    if (VAR_1->tk==VAR_5)
      jsExceptionHere(VAR_6, ""Tagged template literals not supported"");
    else if (VAR_1->tk==VAR_7 && jsvIsName(VAR_3)) {
      JsVar *VAR_8 = jspeArrowFunction(0,VAR_3);
      jsvUnLock(VAR_3);
      VAR_3=VAR_8;
    }
#endif
    return VAR_3;
  } else if (VAR_1->tk==VAR_9) {
    JsVar *VAR_10 = 0;
    if (VAR_11) {
      VAR_10 = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(VAR_1)));
    }
    JSP_ASSERT_MATCH(VAR_9);
    return VAR_10;
  } else if (VAR_1->tk==VAR_12) {
    JsVar *VAR_10 = 0;
    if (VAR_11) {
      VAR_10 = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(VAR_1)));
    }
    JSP_ASSERT_MATCH(VAR_12);
    return VAR_10;
  } else if (VAR_1->tk=='(') {
    JSP_ASSERT_MATCH('(');
    if (!jspCheckStackPosition()) return 0;
#ifdef VAR_4
    /* COMMENT_0 */
    JsVar *VAR_3 = jspeExpression();
    if (!VAR_13) JSP_MATCH_WITH_RETURN(')',VAR_3);
    return VAR_3;
#else
    return jspeExpressionOrArrowFunction();
#endif

  } else if (VAR_1->tk==VAR_14) {
    JSP_ASSERT_MATCH(VAR_14);
    return VAR_11 ? jsvNewFromBool(true) : 0;
  } else if (VAR_1->tk==VAR_15) {
    JSP_ASSERT_MATCH(VAR_15);
    return VAR_11 ? jsvNewFromBool(false) : 0;
  } else if (VAR_1->tk==VAR_16) {
    JSP_ASSERT_MATCH(VAR_16);
    return VAR_11 ? jsvNewWithFlags(VAR_17) : 0;
  } else if (VAR_1->tk==VAR_18) {
    JSP_ASSERT_MATCH(VAR_18);
    return 0;
  } else if (VAR_1->tk==VAR_19) {
    JsVar *VAR_3 = 0;
    if (VAR_11)
      VAR_3 = jslGetTokenValueAsVar(VAR_1);
    JSP_ASSERT_MATCH(VAR_19);
    return VAR_3;
#ifndef VAR_4
  } else if (VAR_1->tk==VAR_5) {
    return jspeTemplateLiteral();
#endif
  } else if (lex->tk==LEX_REGEX) {
    JsVar *VAR_3 = 0;
#ifdef VAR_4
    jsExceptionHere(VAR_6, ""RegEx are not supported in this version of Espruino\n"");
#else
    JsVar *VAR_20 = jslGetTokenValueAsVar(VAR_1);
    size_t VAR_21 = 0, VAR_22 = 0;
    JsvStringIterator VAR_23;
    jsvStringIteratorNew(&VAR_23, VAR_20, 0);
    while (jsvStringIteratorHasChar(&VAR_23)) {
      VAR_22++;
      if (jsvStringIteratorGetChar(&VAR_23)=='/')
        VAR_21 = VAR_22;
      jsvStringIteratorNext(&VAR_23);
    }
    jsvStringIteratorFree(&VAR_23);
    JsVar *VAR_24 = 0;
    if (VAR_21 < VAR_22)
      VAR_24 = jsvNewFromStringVar(VAR_20, VAR_21, VAR_25);
    JsVar *VAR_26 = jsvNewFromStringVar(VAR_20, 1, VAR_21-2);
    VAR_3 = jswrap_regexp_constructor(VAR_26, VAR_24);
    jsvUnLock3(VAR_20, VAR_24, VAR_26);
#endif
    JSP_ASSERT_MATCH(VAR_27);
    return VAR_3;
  } else if (VAR_1->tk=='{') {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorObject();
  } else if (VAR_1->tk=='[') {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorArray();
  } else if (VAR_1->tk==VAR_28) {
    if (!jspCheckStackPosition()) return 0;
    JSP_ASSERT_MATCH(VAR_28);
    return jspeFunctionDefinition(true);
#ifndef VAR_4
  } else if (VAR_1->tk==VAR_29) {
    if (!jspCheckStackPosition()) return 0;
    JSP_ASSERT_MATCH(VAR_29);
    return jspeClassDefinition(true);
  } else if (VAR_1->tk==VAR_30) {
    JSP_ASSERT_MATCH(VAR_30);
    /* COMMENT_1 */
                             

                                                                         
                                                              
                                                                                                 
       

    if (jsvIsObject(VAR_31.thisVar)) {
      /* COMMENT_8 */
      JsVar *VAR_32 = jsvObjectGetChild(VAR_31.thisVar, VAR_33, 0); /* COMMENT_9 */
      JsVar *VAR_34 = jsvIsObject(VAR_32) ? jsvObjectGetChild(VAR_32, VAR_33, 0) : 0; /* COMMENT_10 */
      jsvUnLock(VAR_32);
      if (!VAR_34) {
        jsExceptionHere(VAR_6, ""Calling 'super' outside of class"");
        return 0;
      }
      if (VAR_1->tk=='(') return VAR_34; /* COMMENT_11 */
      /* COMMENT_12 */
      JsVar *VAR_35 = jsvIsFunction(VAR_34) ? jsvObjectGetChild(VAR_34, VAR_36, 0) : 0;
      jsvUnLock(VAR_34);
      return VAR_35;
    } else if (jsvIsFunction(VAR_31.thisVar)) {
      /* COMMENT_13 */
      JsVar *VAR_32 = jsvObjectGetChild(VAR_31.thisVar, VAR_36, 0);
      JsVar *VAR_34 = jsvIsObject(VAR_32) ? jsvObjectGetChild(VAR_32, VAR_33, 0) : 0;
      jsvUnLock(VAR_32);
      if (!VAR_34) {
        jsExceptionHere(VAR_6, ""Calling 'super' outside of class"");
        return 0;
      }
      return VAR_34;
    }
    jsExceptionHere(VAR_6, ""Calling 'super' outside of class"");
    return 0;
#endif
  } else if (lex->tk==LEX_R_THIS) {
    JSP_ASSERT_MATCH(VAR_37);
    return jsvLockAgain( VAR_31.thisVar ? VAR_31.thisVar : VAR_31.root );
  } else if (VAR_1->tk==VAR_38) {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorDelete();
  } else if (VAR_1->tk==VAR_39) {
    if (!jspCheckStackPosition()) return 0;
    return jspeFactorTypeOf();
  } else if (VAR_1->tk==VAR_40) {
    if (!jspCheckStackPosition()) return 0;
    JSP_ASSERT_MATCH(VAR_40);
    jsvUnLock(jspeUnaryExpression());
    return 0;
  }
  JSP_MATCH(VAR_41);
  jsExceptionHere(VAR_6, ""Unexpected end of Input\n"");
  return 0;
}",,"--- func_before
+++ func_after
@@ -148,6 +148,7 @@
     if (!jspCheckStackPosition()) return 0;
     return jspeFactorTypeOf();
   } else if (lex->tk==LEX_R_VOID) {
+    if (!jspCheckStackPosition()) return 0;
     JSP_ASSERT_MATCH(LEX_R_VOID);
     jsvUnLock(jspeUnaryExpression());
     return 0;","{'deleted_lines': [], 'added_lines': ['    if (!jspCheckStackPosition()) return 0;']}",True,"Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing of ""VOID"" tokens in jsparse.c.",5.5,MEDIUM,1,test,2018-05-21T13:30:19Z,2
CVE-2018-9132,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,libming,"decompile: Fix null pointer dereference in getInt

When getInt is passed a PUSH_REGISTER parameter, it retrieves the
content of this register and returns the value contained by this
register as an int. When this register is empty, we call getInt with
a NULL pointer and a null pointer dereference occurs.

In this patch we first make sure that regs[act->p.RegisterNumber] is
not NULL before doing anything with it.

Fixes #133 (CVE-2018-9132).",dc65ba0497f4c5ca58be2018e2816e72baf63634,https://github.com/libming/libming/commit/dc65ba0497f4c5ca58be2018e2816e72baf63634,util/decompile.c,getInt,"static int
getInt(struct SWF_ACTIONPUSHPARAM *act)
{
switch( act->Type ) 
{
case PUSH_FLOAT: 
return ((int)act->p.Float);
case PUSH_NULL: 
return 0;
case PUSH_REGISTER: 
return getInt(regs[act->p.RegisterNumber]);
case PUSH_DOUBLE: 
return (int)act->p.Double;
case PUSH_INT: 
return act->p.Integer;
default: 
fprintf (stderr,""  Can't get int for type: %d\n"", act->Type);
}
return 0;
}","static int
getInt(struct SWF_ACTIONPUSHPARAM *VAR_0)
{
switch( VAR_0->Type ) 
{
case VAR_1: 
return ((int)VAR_0->p.Float);
case VAR_2: 
return 0;
case VAR_3: 
return getInt(VAR_4[VAR_0->p.RegisterNumber]);
case VAR_5: 
return (int)VAR_0->p.Double;
case VAR_6: 
return VAR_0->p.Integer;
default: 
fprintf (VAR_7,""  Can't get int for type: %d\n"", VAR_0->Type);
}
return 0;
}",libming/dc65ba0497f4c5ca58be2018e2816e72baf63634/decompile.c/vul/before/0.json,"static int
getInt(struct SWF_ACTIONPUSHPARAM *act)
{
	switch( act->Type ) 
	{
	case PUSH_FLOAT: /* FLOAT -- also used for PROPERTY storing */
		return ((int)act->p.Float);
	case PUSH_NULL: /* NULL */
		return 0;
	case PUSH_REGISTER: /* REGISTER */
		if (regs[act->p.RegisterNumber])
		{
			return getInt(regs[act->p.RegisterNumber]);
		}
		else
		{
			SWF_warn(""WARNING: retrieving undefined register values.\n"");
			break;
		}
	case PUSH_DOUBLE: /* DOUBLE */
		return (int)act->p.Double;
	case PUSH_INT: /* INTEGER */
		return act->p.Integer;
	default: 
		fprintf (stderr,""  Can't get int for type: %d\n"", act->Type);
	}
	return 0;
}","static int
getInt(struct SWF_ACTIONPUSHPARAM *VAR_0)
{
	switch( VAR_0->Type ) 
	{
	case VAR_1: /* COMMENT_0 */
		return ((int)VAR_0->p.Float);
	case VAR_2: /* COMMENT_1 */
		return 0;
	case VAR_3: /* COMMENT_2 */
		if (VAR_4[VAR_0->p.RegisterNumber])
		{
			return getInt(VAR_4[VAR_0->p.RegisterNumber]);
		}
		else
		{
			SWF_warn(""WARNING: retrieving undefined register values.\n"");
			break;
		}
	case VAR_5: /* COMMENT_3 */
		return (int)VAR_0->p.Double;
	case VAR_6: /* COMMENT_4 */
		return VAR_0->p.Integer;
	default: 
		fprintf (VAR_7,""  Can't get int for type: %d\n"", VAR_0->Type);
	}
	return 0;
}",libming/dc65ba0497f4c5ca58be2018e2816e72baf63634/decompile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,15 @@
 	case PUSH_NULL: /* NULL */
 		return 0;
 	case PUSH_REGISTER: /* REGISTER */
-		return getInt(regs[act->p.RegisterNumber]);
+		if (regs[act->p.RegisterNumber])
+		{
+			return getInt(regs[act->p.RegisterNumber]);
+		}
+		else
+		{
+			SWF_warn(""WARNING: retrieving undefined register values.\n"");
+			break;
+		}
 	case PUSH_DOUBLE: /* DOUBLE */
 		return (int)act->p.Double;
 	case PUSH_INT: /* INTEGER */","{'deleted_lines': ['\t\treturn getInt(regs[act->p.RegisterNumber]);'], 'added_lines': ['\t\tif (regs[act->p.RegisterNumber])', '\t\t{', '\t\t\treturn getInt(regs[act->p.RegisterNumber]);', '\t\t}', '\t\telse', '\t\t{', '\t\t\tSWF_warn(""WARNING: retrieving undefined register values.\\n"");', '\t\t\tbreak;', '\t\t}']}",True,libming 0.4.8 has a NULL pointer dereference in the getInt function of the decompile.c file. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted swf file.,6.5,MEDIUM,1,test,2018-05-26T02:11:51Z,2
CVE-2018-9009,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,libming,"decompile: fix use-after-free in decompileJUMP

Same issue as f42fdb4 (functions accessing actions array without
checking the validity of n, the user entered index), same fix.

In this patch we also fix other source code places which might be
affected by the same bug.

Fixes #131 (CVE-2018-9009).",1d698a4b1f03d6136bbf2b0171b86985be553454,https://github.com/libming/libming/commit/1d698a4b1f03d6136bbf2b0171b86985be553454,util/decompile.c,decompileJUMP,"static int
decompileJUMP(int n, SWF_ACTION *actions, int maxn)
{
int i=0,j=0;
int offSave;
struct SWF_ACTIONIF *sactif;
OUT_BEGIN2(SWF_ACTIONJUMP);
sactif=NULL;
if(isLogicalOp(n+1, actions, maxn) ||
(OpCode(actions, n+1, maxn) == SWFACTION_PUSH && isLogicalOp(n+2, actions, maxn)))
{
return 0;
}
if (OpCode(actions, n+1, maxn) == SWFACTION_POP)
return 1;
if (OpCode(actions, n+1, maxn) == SWFACTION_JUMP) 
{
if (actions[n+1].SWF_ACTIONJUMP.BranchOffset==0)
return 1;
}
for(i=0; n + 1 + i < maxn && (actions[(n+1)+i].SWF_ACTIONRECORD.Offset < (actions[n+1].SWF_ACTIONRECORD.Offset+actions[n ].SWF_ACTIONJUMP.BranchOffset)); i++)
{
#if 0
printf(""\n"",actions[n+1+i].SWF_ACTIONRECORD.ActionCode);
#endif
; }
if (i)
{
for (j=0; n+j+i<maxn; j++)
{
#if 0
printf(""\n"",actions[n+i+j].SWF_ACTIONRECORD.ActionCode)
#endif
if (OpCode(actions, n+i+j, maxn) == SWFACTION_IF)
{
sactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);
if (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP
&& sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+
sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==
actions[n].SWF_ACTIONRECORD.Offset )
{
break;
}
else
sactif=NULL;
}
}
}
if (sactif)
{
INDENT
puts(""while("");
decompileActions(j-1, &actions[n+1+i], gIndent);
puts(getName(pop()));
println(""){         "");
offSave=offseoloop;
if (n+i+j+1<maxn)offseoloop=actions[n+i+j+1].SWF_ACTIONRECORD.Offset;
else
offseoloop=actions[n+i+j].SWF_ACTIONRECORD.Offset+5;
decompileActions(sactif->numActions-1, sactif->Actions,gIndent+1);
decompileActions(i, &actions[n+1], gIndent+1);
offseoloop=offSave;
INDENT
println(""};"");
return i+j; 
}
if (sact->BranchOffset>0)
{
if ( stackVal(n,actions) == 1 && n+1==maxn)
{return decompileRETURN(n, actions,maxn);
}
if (n+2 < maxn && OpCode(actions, n+1, maxn) == SWFACTION_PUSH && 
actions[n+2].SWF_ACTIONRECORD.Offset == actions[n+1].SWF_ACTIONRECORD.Offset+sact->BranchOffset)
{
return 1; }
INDENT
if (offseoloop==actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5)
puts(""break;"" );
else
puts(""return;"" );
println(""\t\t\t        offseoloop, actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5);
}
else
{
if (sact->BranchOffset<0)
{
INDENT
println(""continue;     "");
}
}
return 0;
}","static int
decompileJUMP(int VAR_0, SWF_ACTION *VAR_1, int VAR_2)
{
int VAR_3=0,VAR_4=0;
int VAR_5;
struct SWF_ACTIONIF *VAR_6;
OUT_BEGIN2(VAR_7);
VAR_6=NULL;
if(isLogicalOp(VAR_0+1, VAR_1, VAR_2) ||
(OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && isLogicalOp(VAR_0+2, VAR_1, VAR_2)))
{
return 0;
}
if (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_9)
return 1;
if (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_10) 
{
if (VAR_1[VAR_0+1].SWF_ACTIONJUMP.BranchOffset==0)
return 1;
}
for(VAR_3=0; VAR_0 + 1 + VAR_3 < VAR_2 && (VAR_1[(VAR_0+1)+VAR_3].SWF_ACTIONRECORD.Offset < (VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_1[VAR_0 ].SWF_ACTIONJUMP.BranchOffset)); VAR_3++)
{
#if 0
printf(""\n"",VAR_1[VAR_0+1+VAR_3].SWF_ACTIONRECORD.ActionCode);
#endif
; 
}
if (VAR_3)
{
for (VAR_4=0; VAR_0+VAR_4+VAR_3<VAR_2; VAR_4++)
{
#if 0
printf(""\n"",VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.ActionCode)
#endif
if (OpCode(VAR_1, VAR_0+VAR_3+VAR_4, VAR_2) == VAR_11)
{
VAR_6 = (struct SWF_ACTIONIF *)&(VAR_1[VAR_0+VAR_3+VAR_4]);
if (VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONRECORD.ActionCode==VAR_10
&& VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.BranchOffset+
VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.Offset==
VAR_1[VAR_0].SWF_ACTIONRECORD.Offset )
{
break;
}
else
VAR_6=NULL;
}
}
}
if (VAR_6)
{
INDENT
VAR_12(""while("");
decompileActions(VAR_4-1, &VAR_1[VAR_0+1+VAR_3], VAR_13);
VAR_12(getName(pop()));
println(""){         "");
VAR_5=VAR_14;
if (VAR_0+VAR_3+VAR_4+1<VAR_2)
VAR_14=VAR_1[VAR_0+VAR_3+VAR_4+1].SWF_ACTIONRECORD.Offset;
else
VAR_14=VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.Offset+5;
decompileActions(VAR_6->numActions-1, VAR_6->Actions,VAR_13+1);
decompileActions(VAR_3, &VAR_1[VAR_0+1], VAR_13+1);
VAR_14=VAR_5;
INDENT
VAR_15(""};"");
return VAR_3+VAR_4; 
}
if (VAR_16->BranchOffset>0)
{
if ( stackVal(VAR_0,VAR_1) == 1 && VAR_0+1==VAR_2)
{
return decompileRETURN(VAR_0, VAR_1,VAR_2);
}
if (VAR_0+2 < VAR_2 && OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && 
VAR_1[VAR_0+2].SWF_ACTIONRECORD.Offset == VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset)
{
return 1; 
}
INDENT
if (offseoloop==VAR_1[VAR_0].VAR_17.VAR_18+VAR_16->VAR_19+5)
VAR_12(""break;"" );
else
VAR_12(""return;"" );
VAR_15(""\t\t\t// offs_end_of_loop=%d  offs_jmp_dest=%d"",
offseoloop, VAR_1[VAR_0].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset+5);
}
else
{
if (VAR_16->BranchOffset<0)
{
INDENT
VAR_15(""continue;     "");
}
}
return 0;
}",libming/1d698a4b1f03d6136bbf2b0171b86985be553454/decompile.c/vul/before/0.json,"static int
decompileJUMP(int n, SWF_ACTION *actions, int maxn)
{
	int i=0,j=0;
	int offSave;
	struct SWF_ACTIONIF *sactif;
	OUT_BEGIN2(SWF_ACTIONJUMP);
	sactif=NULL;

	if(isLogicalOp(n+1, actions, maxn) ||
	   (OpCode(actions, n+1, maxn) == SWFACTION_PUSH && isLogicalOp(n+2, actions, maxn)))
	{
		/* Probably the start of a do {} while(), so skip it */
		return 0;
	}

	/* Probably the end of a switch{}, so skip it */
	if (OpCode(actions, n+1, maxn) == SWFACTION_POP)
		return 1;

	if (OpCode(actions, n+1, maxn) == SWFACTION_JUMP) 
	{
		if (actions[n+1].SWF_ACTIONJUMP.BranchOffset==0)
			return 1;
	}

	for(i=0; n + 1 + i < maxn && (actions[(n+1)+i].SWF_ACTIONRECORD.Offset < (actions[n+1].SWF_ACTIONRECORD.Offset+actions[n ].SWF_ACTIONJUMP.BranchOffset)); i++)
	{
#if 0
		printf(""/* for PART3 OP 0x%x */\n"",actions[n+1+i].SWF_ACTIONRECORD.ActionCode);
#endif
		; // NOOP
	}

	if (i)
	{
		for (j=0; n+j+i<maxn; j++)
		{
#if 0
			 printf(""/* FOR part2 OP 0x%x */\n"",actions[n+i+j].SWF_ACTIONRECORD.ActionCode)
			// at least one should push on stack
#endif
	 
			if (OpCode(actions, n+i+j, maxn) == SWFACTION_IF)
			{
				sactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);
				/* chk whether last jump does lead us back to start of loop */
				if (OpCode(sactif->Actions, sactif->numActions-1, maxn) == SWFACTION_JUMP
				    && sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+
				    sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==
				    actions[n].SWF_ACTIONRECORD.Offset )
				{
					break;
				}
				else
					sactif=NULL;
			}
		}
	}

	if (sactif)
	{
		INDENT
		puts(""while("");
		decompileActions(j-1, &actions[n+1+i], gIndent);
		puts(getName(pop()));
		println(""){         /* original FOR loop rewritten to WHILE */"");
		offSave=offseoloop;
		if (n+i+j+1<maxn)						// see part2 above
			offseoloop=actions[n+i+j+1].SWF_ACTIONRECORD.Offset;
		else
			offseoloop=actions[n+i+j].SWF_ACTIONRECORD.Offset+5;
		decompileActions(sactif->numActions-1, sactif->Actions,gIndent+1);
		decompileActions(i, &actions[n+1], gIndent+1);
		offseoloop=offSave;
		INDENT
		println(""};"");
		return i+j; 
	}
	
	if (sact->BranchOffset>0)
	{
		if ( stackVal(n,actions) == 1 && n+1==maxn)
		{	// leaving block @last op with value on stack: a return x;
			return decompileRETURN(n, actions,maxn);
		}
		if (n+2 < maxn && OpCode(actions, n+1, maxn) == SWFACTION_PUSH && 
			actions[n+2].SWF_ACTIONRECORD.Offset == actions[n+1].SWF_ACTIONRECORD.Offset+sact->BranchOffset)
		{
			return 1; 	// jump to short to be a 'break': but an internal jump over a push
		}			// to do: add some control flow analysis
		
		INDENT
		
		if (offseoloop==actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5)
			puts(""break;"" );
		else
			puts(""return;"" );
		
		println(""\t\t\t// offs_end_of_loop=%d  offs_jmp_dest=%d"",
		        offseoloop, actions[n].SWF_ACTIONRECORD.Offset+sact->BranchOffset+5);
	}
	else
	{
		if (sact->BranchOffset<0)
		{
			INDENT
			println(""continue;     /*------*/"");
		}
	}
	/* error(""Unhandled JUMP""); */
	return 0;
}","static int
decompileJUMP(int VAR_0, SWF_ACTION *VAR_1, int VAR_2)
{
	int VAR_3=0,VAR_4=0;
	int VAR_5;
	struct SWF_ACTIONIF *VAR_6;
	OUT_BEGIN2(VAR_7);
	VAR_6=NULL;

	if(isLogicalOp(VAR_0+1, VAR_1, VAR_2) ||
	   (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && isLogicalOp(VAR_0+2, VAR_1, VAR_2)))
	{
		/* COMMENT_0 */
		return 0;
	}

	/* COMMENT_1 */
	if (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_9)
		return 1;

	if (OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_10) 
	{
		if (VAR_1[VAR_0+1].SWF_ACTIONJUMP.BranchOffset==0)
			return 1;
	}

	for(VAR_3=0; VAR_0 + 1 + VAR_3 < VAR_2 && (VAR_1[(VAR_0+1)+VAR_3].SWF_ACTIONRECORD.Offset < (VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_1[VAR_0 ].SWF_ACTIONJUMP.BranchOffset)); VAR_3++)
	{
#if 0
		printf(""/* for PART3 OP 0x%x */\n"",VAR_1[VAR_0+1+VAR_3].SWF_ACTIONRECORD.ActionCode);
#endif
		; /* COMMENT_2 */
	}

	if (VAR_3)
	{
		for (VAR_4=0; VAR_0+VAR_4+VAR_3<VAR_2; VAR_4++)
		{
#if 0
			 printf(""/* FOR part2 OP 0x%x */\n"",VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.ActionCode)
			/* COMMENT_3 */
#endif
	 
			if (OpCode(VAR_1, VAR_0+VAR_3+VAR_4, VAR_2) == VAR_11)
			{
				VAR_6 = (struct SWF_ACTIONIF *)&(VAR_1[VAR_0+VAR_3+VAR_4]);
				/* COMMENT_4 */
				if (OpCode(VAR_6->Actions, VAR_6->numActions-1, VAR_2) == VAR_10
				    && VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.BranchOffset+
				    VAR_6->Actions[VAR_6->numActions-1].SWF_ACTIONJUMP.Offset==
				    VAR_1[VAR_0].SWF_ACTIONRECORD.Offset )
				{
					break;
				}
				else
					VAR_6=NULL;
			}
		}
	}

	if (VAR_6)
	{
		INDENT
		VAR_12(""while("");
		decompileActions(VAR_4-1, &VAR_1[VAR_0+1+VAR_3], VAR_13);
		VAR_12(getName(pop()));
		println(""){         /* original FOR loop rewritten to WHILE */"");
		VAR_5=VAR_14;
		if (VAR_0+VAR_3+VAR_4+1<VAR_2)						/* COMMENT_5 */
			VAR_14=VAR_1[VAR_0+VAR_3+VAR_4+1].SWF_ACTIONRECORD.Offset;
		else
			VAR_14=VAR_1[VAR_0+VAR_3+VAR_4].SWF_ACTIONRECORD.Offset+5;
		decompileActions(VAR_6->numActions-1, VAR_6->Actions,VAR_13+1);
		decompileActions(VAR_3, &VAR_1[VAR_0+1], VAR_13+1);
		VAR_14=VAR_5;
		INDENT
		VAR_15(""};"");
		return VAR_3+VAR_4; 
	}
	
	if (VAR_16->BranchOffset>0)
	{
		if ( stackVal(VAR_0,VAR_1) == 1 && VAR_0+1==VAR_2)
		{	/* COMMENT_6 */
			return decompileRETURN(VAR_0, VAR_1,VAR_2);
		}
		if (VAR_0+2 < VAR_2 && OpCode(VAR_1, VAR_0+1, VAR_2) == VAR_8 && 
			VAR_1[VAR_0+2].SWF_ACTIONRECORD.Offset == VAR_1[VAR_0+1].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset)
		{
			return 1; 	/* COMMENT_7 */
		}			/* COMMENT_8 */
		
		INDENT
		
		if (offseoloop==VAR_1[VAR_0].VAR_17.VAR_18+VAR_16->VAR_19+5)
			VAR_12(""break;"" );
		else
			VAR_12(""return;"" );
		
		VAR_15(""\t\t\t// offs_end_of_loop=%d  offs_jmp_dest=%d"",
		        offseoloop, VAR_1[VAR_0].SWF_ACTIONRECORD.Offset+VAR_16->BranchOffset+5);
	}
	else
	{
		if (VAR_16->BranchOffset<0)
		{
			INDENT
			VAR_15(""continue;     /* COMMENT_9 */"");
		}
	}
	/* COMMENT_10 */
	return 0;
}",libming/1d698a4b1f03d6136bbf2b0171b86985be553454/decompile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,7 @@
 			{
 				sactif = (struct SWF_ACTIONIF *)&(actions[n+i+j]);
 				/* chk whether last jump does lead us back to start of loop */
-				if (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP
+				if (OpCode(sactif->Actions, sactif->numActions-1, maxn) == SWFACTION_JUMP
 				    && sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.BranchOffset+
 				    sactif->Actions[sactif->numActions-1].SWF_ACTIONJUMP.Offset==
 				    actions[n].SWF_ACTIONRECORD.Offset )","{'deleted_lines': ['\t\t\t\tif (sactif->Actions[sactif->numActions-1].SWF_ACTIONRECORD.ActionCode==SWFACTION_JUMP'], 'added_lines': ['\t\t\t\tif (OpCode(sactif->Actions, sactif->numActions-1, maxn) == SWFACTION_JUMP']}",True,"In libming 0.4.8, there is a use-after-free in the decompileJUMP function of the decompile.c file.",8.8,HIGH,2,test,2018-05-26T02:22:33Z,2
CVE-2018-12085,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,liblouis,"Check index before writing to result->chars

Fixes #595",dbfa58bb128cae86729578ac596056b3385817ef,https://github.com/liblouis/liblouis/commit/dbfa58bb128cae86729578ac596056b3385817ef,liblouis/compileTranslationTable.c,parseChars,"static int
parseChars(FileInfo *nested, CharsString *result, CharsString *token) {
int in = 0;
int out = 0;
int lastOutSize = 0;
int lastIn;
unsigned int ch = 0;
int numBytes = 0;
unsigned int utf32 = 0;
int k;
while (in < token->length) {
ch = token->chars[in++] & 0xff;
if (ch < 128) {
if (ch == '\\') { 
switch (ch = token->chars[in]) {
case '\\':
break;
case 'e':
ch = 0x1b;
break;
case 'f':
ch = 12;
break;
case 'n':
ch = 10;
break;
case 'r':
ch = 13;
break;
case 's':
ch = ' ';
break;
case 't':
ch = 9;
break;
case 'v':
ch = 11;
break;
case 'w':
ch = ENDSEGMENT;
break;
case 34:
ch = QUOTESUB;
break;
case 'X':
case 'x':
if (token->length - in > 4) {
ch = hexValue(nested, &token->chars[in + 1], 4);
in += 4;
}
break;
case 'y':
case 'Y':
if (CHARSIZE == 2) {
not32:
compileError(nested,
""liblouis has not been compiled for 32-bit Unicode"");
break;
}
if (token->length - in > 5) {
ch = hexValue(nested, &token->chars[in + 1], 5);
in += 5;
}
break;
case 'z':
case 'Z':
if (CHARSIZE == 2) goto not32;
if (token->length - in > 8) {
ch = hexValue(nested, &token->chars[in + 1], 8);
in += 8;
}
break;
default:
compileError(nested, ""invalid escape sequence '\\%c'"", ch);
break;
}
in++;
}
result->chars[out++] = (widechar)ch;
if (out >= MAXSTRING) {
result->length = out;
return 1;
}
continue;
}
lastOutSize = out;
lastIn = in;
for (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--)
if (ch >= first0Bit[numBytes]) break;
utf32 = ch & (0XFF - first0Bit[numBytes]);
for (k = 0; k < numBytes; k++) {
if (in >= MAXSTRING) break;
if (out >= MAXSTRING) {
result->length = lastOutSize;
return 1;
}
if (token->chars[in] < 128 || (token->chars[in] & 0x0040)) {
compileWarning(nested, ""invalid UTF-8. Assuming Latin-1."");
result->chars[out++] = token->chars[lastIn];
in = lastIn + 1;
continue;
}
utf32 = (utf32 << 6) + (token->chars[in++] & 0x3f);
}
if (out >= MAXSTRING) {
result->length = lastOutSize;
return 1;
}
if (CHARSIZE == 2 && utf32 > 0xffff) utf32 = 0xffff;
result->chars[out++] = (widechar)utf32;
}
result->length = out;
return 1;
}","static int
parseChars(FileInfo *VAR_0, CharsString *VAR_1, CharsString *VAR_2) {
int VAR_3 = 0;
int VAR_4 = 0;
int VAR_5 = 0;
int VAR_6;
unsigned int VAR_7 = 0;
int VAR_8 = 0;
unsigned int VAR_9 = 0;
int VAR_10;
while (VAR_3 < VAR_2->length) {
VAR_7 = VAR_2->chars[VAR_3++] & 0xff;
if (VAR_7 < 128) {
if (VAR_7 == '\\') { 
switch (VAR_7 = VAR_2->chars[VAR_3]) {
case '\\':
break;
case 'e':
VAR_7 = 0x1b;
break;
case 'f':
VAR_7 = 12;
break;
case 'n':
VAR_7 = 10;
break;
case 'r':
VAR_7 = 13;
break;
case 's':
VAR_7 = ' ';
break;
case 't':
VAR_7 = 9;
break;
case 'v':
VAR_7 = 11;
break;
case 'w':
VAR_7 = VAR_11;
break;
case 34:
VAR_7 = VAR_12;
break;
case 'X':
case 'x':
if (VAR_2->length - VAR_3 > 4) {
VAR_7 = hexValue(VAR_0, &VAR_2->chars[VAR_3 + 1], 4);
VAR_3 += 4;
}
break;
case 'y':
case 'Y':
if (VAR_13 == 2) {
not32:
compileError(VAR_0,
""liblouis has not been compiled for 32-bit Unicode"");
break;
}
if (VAR_2->length - VAR_3 > 5) {
VAR_7 = hexValue(VAR_0, &VAR_2->chars[VAR_3 + 1], 5);
VAR_3 += 5;
}
break;
case 'z':
case 'Z':
if (VAR_13 == 2) goto not32;
if (VAR_2->length - VAR_3 > 8) {
VAR_7 = hexValue(VAR_0, &VAR_2->chars[VAR_3 + 1], 8);
VAR_3 += 8;
}
break;
default:
compileError(VAR_0, ""invalid escape sequence '\\%c'"", VAR_7);
break;
}
VAR_3++;
}
VAR_1->chars[VAR_4++] = (widechar)VAR_7;
if (VAR_4 >= VAR_14) {
VAR_1->length = VAR_4;
return 1;
}
continue;
}
VAR_5 = VAR_4;
VAR_6 = VAR_3;
for (VAR_8 = VAR_15 - 1; VAR_8 > 0; VAR_8--)
if (VAR_7 >= VAR_16[VAR_8]) break;
VAR_9 = VAR_7 & (0VAR_17 - VAR_16[VAR_8]);
for (VAR_10 = 0; VAR_10 < VAR_8; VAR_10++) {
if (VAR_3 >= VAR_14) break;
if (VAR_4 >= VAR_14) {
VAR_1->length = VAR_5;
return 1;
}
if (VAR_2->chars[VAR_3] < 128 || (VAR_2->chars[VAR_3] & 0x0040)) {
compileWarning(VAR_0, ""invalid UTF-8. Assuming Latin-1."");
VAR_1->chars[VAR_4++] = VAR_2->chars[VAR_6];
VAR_3 = VAR_6 + 1;
continue;
}
VAR_9 = (VAR_9 << 6) + (VAR_2->chars[VAR_3++] & 0x3f);
}
if (VAR_4 >= VAR_14) {
VAR_1->length = VAR_5;
return 1;
}
if (VAR_13 == 2 && VAR_9 > 0xffff) VAR_9 = 0xffff;
VAR_1->chars[VAR_4++] = (widechar)VAR_9;
}
VAR_1->length = VAR_4;
return 1;
}",liblouis/dbfa58bb128cae86729578ac596056b3385817ef/compileTranslationTable.c/vul/before/0.json,"static int
parseChars(FileInfo *nested, CharsString *result, CharsString *token) {
	int in = 0;
	int out = 0;
	int lastOutSize = 0;
	int lastIn;
	unsigned int ch = 0;
	int numBytes = 0;
	unsigned int utf32 = 0;
	int k;
	while (in < token->length) {
		ch = token->chars[in++] & 0xff;
		if (ch < 128) {
			if (ch == '\\') { /* escape sequence */
				switch (ch = token->chars[in]) {
				case '\\':
					break;
				case 'e':
					ch = 0x1b;
					break;
				case 'f':
					ch = 12;
					break;
				case 'n':
					ch = 10;
					break;
				case 'r':
					ch = 13;
					break;
				case 's':
					ch = ' ';
					break;
				case 't':
					ch = 9;
					break;
				case 'v':
					ch = 11;
					break;
				case 'w':
					ch = ENDSEGMENT;
					break;
				case 34:
					ch = QUOTESUB;
					break;
				case 'X':
				case 'x':
					if (token->length - in > 4) {
						ch = hexValue(nested, &token->chars[in + 1], 4);
						in += 4;
					}
					break;
				case 'y':
				case 'Y':
					if (CHARSIZE == 2) {
					not32:
						compileError(nested,
								""liblouis has not been compiled for 32-bit Unicode"");
						break;
					}
					if (token->length - in > 5) {
						ch = hexValue(nested, &token->chars[in + 1], 5);
						in += 5;
					}
					break;
				case 'z':
				case 'Z':
					if (CHARSIZE == 2) goto not32;
					if (token->length - in > 8) {
						ch = hexValue(nested, &token->chars[in + 1], 8);
						in += 8;
					}
					break;
				default:
					compileError(nested, ""invalid escape sequence '\\%c'"", ch);
					break;
				}
				in++;
			}
			if (out >= MAXSTRING) {
				result->length = out;
				return 1;
			}
			result->chars[out++] = (widechar)ch;
			continue;
		}
		lastOutSize = out;
		lastIn = in;
		for (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--)
			if (ch >= first0Bit[numBytes]) break;
		utf32 = ch & (0XFF - first0Bit[numBytes]);
		for (k = 0; k < numBytes; k++) {
			if (in >= MAXSTRING) break;
			if (out >= MAXSTRING) {
				result->length = lastOutSize;
				return 1;
			}
			if (token->chars[in] < 128 || (token->chars[in] & 0x0040)) {
				compileWarning(nested, ""invalid UTF-8. Assuming Latin-1."");
				result->chars[out++] = token->chars[lastIn];
				in = lastIn + 1;
				continue;
			}
			utf32 = (utf32 << 6) + (token->chars[in++] & 0x3f);
		}
		if (out >= MAXSTRING) {
			result->length = lastOutSize;
			return 1;
		}
		if (CHARSIZE == 2 && utf32 > 0xffff) utf32 = 0xffff;
		result->chars[out++] = (widechar)utf32;
	}
	result->length = out;
	return 1;
}","static int
parseChars(FileInfo *VAR_0, CharsString *VAR_1, CharsString *VAR_2) {
	int VAR_3 = 0;
	int VAR_4 = 0;
	int VAR_5 = 0;
	int VAR_6;
	unsigned int VAR_7 = 0;
	int VAR_8 = 0;
	unsigned int VAR_9 = 0;
	int VAR_10;
	while (VAR_3 < VAR_2->length) {
		VAR_7 = VAR_2->chars[VAR_3++] & 0xff;
		if (VAR_7 < 128) {
			if (VAR_7 == '\\') { /* COMMENT_0 */
				switch (VAR_7 = VAR_2->chars[VAR_3]) {
				case '\\':
					break;
				case 'e':
					VAR_7 = 0x1b;
					break;
				case 'f':
					VAR_7 = 12;
					break;
				case 'n':
					VAR_7 = 10;
					break;
				case 'r':
					VAR_7 = 13;
					break;
				case 's':
					VAR_7 = ' ';
					break;
				case 't':
					VAR_7 = 9;
					break;
				case 'v':
					VAR_7 = 11;
					break;
				case 'w':
					VAR_7 = VAR_11;
					break;
				case 34:
					VAR_7 = VAR_12;
					break;
				case 'X':
				case 'x':
					if (VAR_2->length - VAR_3 > 4) {
						VAR_7 = hexValue(VAR_0, &VAR_2->chars[VAR_3 + 1], 4);
						VAR_3 += 4;
					}
					break;
				case 'y':
				case 'Y':
					if (VAR_13 == 2) {
					not32:
						compileError(VAR_0,
								""liblouis has not been compiled for 32-bit Unicode"");
						break;
					}
					if (VAR_2->length - VAR_3 > 5) {
						VAR_7 = hexValue(VAR_0, &VAR_2->chars[VAR_3 + 1], 5);
						VAR_3 += 5;
					}
					break;
				case 'z':
				case 'Z':
					if (VAR_13 == 2) goto not32;
					if (VAR_2->length - VAR_3 > 8) {
						VAR_7 = hexValue(VAR_0, &VAR_2->chars[VAR_3 + 1], 8);
						VAR_3 += 8;
					}
					break;
				default:
					compileError(VAR_0, ""invalid escape sequence '\\%c'"", VAR_7);
					break;
				}
				VAR_3++;
			}
			if (VAR_4 >= VAR_14) {
				VAR_1->length = VAR_4;
				return 1;
			}
			VAR_1->chars[VAR_4++] = (widechar)VAR_7;
			continue;
		}
		VAR_5 = VAR_4;
		VAR_6 = VAR_3;
		for (VAR_8 = VAR_15 - 1; VAR_8 > 0; VAR_8--)
			if (VAR_7 >= VAR_16[VAR_8]) break;
		VAR_9 = VAR_7 & (0VAR_17 - VAR_16[VAR_8]);
		for (VAR_10 = 0; VAR_10 < VAR_8; VAR_10++) {
			if (VAR_3 >= VAR_14) break;
			if (VAR_4 >= VAR_14) {
				VAR_1->length = VAR_5;
				return 1;
			}
			if (VAR_2->chars[VAR_3] < 128 || (VAR_2->chars[VAR_3] & 0x0040)) {
				compileWarning(VAR_0, ""invalid UTF-8. Assuming Latin-1."");
				VAR_1->chars[VAR_4++] = VAR_2->chars[VAR_6];
				VAR_3 = VAR_6 + 1;
				continue;
			}
			VAR_9 = (VAR_9 << 6) + (VAR_2->chars[VAR_3++] & 0x3f);
		}
		if (VAR_4 >= VAR_14) {
			VAR_1->length = VAR_5;
			return 1;
		}
		if (VAR_13 == 2 && VAR_9 > 0xffff) VAR_9 = 0xffff;
		VAR_1->chars[VAR_4++] = (widechar)VAR_9;
	}
	VAR_1->length = VAR_4;
	return 1;
}",liblouis/dbfa58bb128cae86729578ac596056b3385817ef/compileTranslationTable.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -76,11 +76,11 @@
 				}
 				in++;
 			}
-			result->chars[out++] = (widechar)ch;
 			if (out >= MAXSTRING) {
 				result->length = out;
 				return 1;
 			}
+			result->chars[out++] = (widechar)ch;
 			continue;
 		}
 		lastOutSize = out;","{'deleted_lines': ['\t\t\tresult->chars[out++] = (widechar)ch;'], 'added_lines': ['\t\t\tresult->chars[out++] = (widechar)ch;']}",True,"Liblouis 3.6.0 has a stack-based Buffer Overflow in the function parseChars in compileTranslationTable.c, a different vulnerability than CVE-2018-11440.",8.8,HIGH,2,test,2018-06-06T14:41:53Z,2
CVE-2018-12599,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1177,ae04fa4be910255e5d363edebd77adeee99a525d,https://github.com/ImageMagick/ImageMagick/commit/ae04fa4be910255e5d363edebd77adeee99a525d,coders/bmp.c,WriteBMPImage,"static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
BMPInfo
bmp_info;
BMPSubtype
bmp_subtype;
const char
*option;
const StringInfo
*profile;
MagickBooleanType
have_color_info,
status;
MagickOffsetType
scene;
MemoryInfo
*pixel_info;
register const Quantum
*p;
register ssize_t
i,
x;
register unsigned char
*q;
size_t
bytes_per_line,
imageListLength,
type;
ssize_t
y;
unsigned char
*bmp_data,
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
type=4;
if (LocaleCompare(image_info->magick,""BMP2"") == 0)
type=2;
else
if (LocaleCompare(image_info->magick,""BMP3"") == 0)
type=3;
option=GetImageOption(image_info,""bmp:format"");
if (option != (char *) NULL)
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  Format=%s"",option);
if (LocaleCompare(option,""bmp2"") == 0)
type=2;
if (LocaleCompare(option,""bmp3"") == 0)
type=3;
if (LocaleCompare(option,""bmp4"") == 0)
type=4;
}
scene=0;
imageListLength=GetImageListLength(image);
do
{
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
(void) TransformImageColorspace(image,sRGBColorspace,exception);
(void) memset(&bmp_info,0,sizeof(bmp_info));
bmp_info.file_size=14+12;
if (type > 2)
bmp_info.file_size+=28;
bmp_info.offset_bits=bmp_info.file_size;
bmp_info.compression=BI_RGB;
bmp_info.red_mask=0x00ff0000U;
bmp_info.green_mask=0x0000ff00U;
bmp_info.blue_mask=0x000000ffU;
bmp_info.alpha_mask=0xff000000U;
bmp_subtype=UndefinedSubtype;
if ((image->storage_class == PseudoClass) && (image->colors > 256))
(void) SetImageStorageClass(image,DirectClass,exception);
if (image->storage_class != DirectClass)
{
bmp_info.bits_per_pixel=8;
if (image->colors <= 2)
bmp_info.bits_per_pixel=1;
else
if (image->colors <= 16)
bmp_info.bits_per_pixel=4;
else
if (image->colors <= 256)
bmp_info.bits_per_pixel=8;
if (image_info->compression == RLECompression)
bmp_info.bits_per_pixel=8;
bmp_info.number_colors=1U << bmp_info.bits_per_pixel;
if (image->alpha_trait != UndefinedPixelTrait)
(void) SetImageStorageClass(image,DirectClass,exception);
else
if ((size_t) bmp_info.number_colors < image->colors)
(void) SetImageStorageClass(image,DirectClass,exception);
else
{
bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);
bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);
if (type > 2)
{
bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);
bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);
}
}
}
if (image->storage_class == DirectClass)
{
bmp_info.number_colors=0;
option=GetImageOption(image_info,""bmp:subtype"");
if (option != (const char *) NULL)
{
if (image->alpha_trait != UndefinedPixelTrait)
{
if (LocaleNCompare(option,""ARGB4444"",8) == 0)
{
bmp_subtype=ARGB4444;
bmp_info.red_mask=0x00000f00U;
bmp_info.green_mask=0x000000f0U;
bmp_info.blue_mask=0x0000000fU;
bmp_info.alpha_mask=0x0000f000U;
}
else if (LocaleNCompare(option,""ARGB1555"",8) == 0)
{
bmp_subtype=ARGB1555;
bmp_info.red_mask=0x00007c00U;
bmp_info.green_mask=0x000003e0U;
bmp_info.blue_mask=0x0000001fU;
bmp_info.alpha_mask=0x00008000U;
}
}
else
{
if (LocaleNCompare(option,""RGB555"",6) == 0)
{
bmp_subtype=RGB555;
bmp_info.red_mask=0x00007c00U;
bmp_info.green_mask=0x000003e0U;
bmp_info.blue_mask=0x0000001fU;
bmp_info.alpha_mask=0U;
}
else if (LocaleNCompare(option,""RGB565"",6) == 0)
{
bmp_subtype=RGB565;
bmp_info.red_mask=0x0000f800U;
bmp_info.green_mask=0x000007e0U;
bmp_info.blue_mask=0x0000001fU;
bmp_info.alpha_mask=0U;
}
}
}
if (bmp_subtype != UndefinedSubtype)
{
bmp_info.bits_per_pixel=16;
bmp_info.compression=BI_BITFIELDS;
}
else
{
bmp_info.bits_per_pixel=(unsigned short) ((type > 3) &&
(image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);
bmp_info.compression=(unsigned int) ((type > 3) &&
(image->alpha_trait != UndefinedPixelTrait) ? BI_BITFIELDS : BI_RGB);
if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))
{
option=GetImageOption(image_info,""bmp3:alpha"");
if (IsStringTrue(option))
bmp_info.bits_per_pixel=32;
}
}
}
bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);
bmp_info.ba_offset=0;
profile=GetImageProfile(image,""icc"");
have_color_info=(image->rendering_intent != UndefinedIntent) ||
(profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :
MagickFalse;
if (type == 2)
bmp_info.size=12;
else
if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&
(have_color_info == MagickFalse)))
{
type=3;
bmp_info.size=40;
}
else
{
int
extra_size;
bmp_info.size=108;
extra_size=68;
if ((image->rendering_intent != UndefinedIntent) ||
(profile != (StringInfo *) NULL))
{
bmp_info.size=124;
extra_size+=16;
}
bmp_info.file_size+=extra_size;
bmp_info.offset_bits+=extra_size;
}
if (((ssize_t) image->columns != (ssize_t) ((signed int) image->columns)) ||
((ssize_t) image->rows != (ssize_t) ((signed int) image->rows)))
ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
bmp_info.width=(ssize_t) image->columns;
bmp_info.height=(ssize_t) image->rows;
bmp_info.planes=1;
bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);
bmp_info.file_size+=bmp_info.image_size;
bmp_info.x_pixels=75*39;
bmp_info.y_pixels=75*39;
switch (image->units)
{
case UndefinedResolution:
case PixelsPerInchResolution:
{
bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);
bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);
break;
}
case PixelsPerCentimeterResolution:
{
bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);
bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);
break;
}
}
bmp_info.colors_important=bmp_info.number_colors;
pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,
sizeof(*pixels));
if (pixel_info == (MemoryInfo *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
(void) memset(pixels,0,(size_t) bmp_info.image_size);
switch (bmp_info.bits_per_pixel)
{
case 1:
{
size_t
bit,
byte;
for (y=0; y < (ssize_t) image->rows; y++)
{
ssize_t
offset;
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
bit=0;
byte=0;
for (x=0; x < (ssize_t) image->columns; x++)
{
byte<<=1;
byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;
bit++;
if (bit == 8)
{
*q++=(unsigned char) byte;
bit=0;
byte=0;
}
p+=GetPixelChannels(image);
}
if (bit != 0)
{
*q++=(unsigned char) (byte << (8-bit));
x++;
}
offset=(ssize_t) (image->columns+7)/8;
for (x=offset; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 4:
{
unsigned int
byte,
nibble;
ssize_t
offset;
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
nibble=0;
byte=0;
for (x=0; x < (ssize_t) image->columns; x++)
{
byte<<=4;
byte|=((unsigned int) GetPixelIndex(image,p) & 0x0f);
nibble++;
if (nibble == 2)
{
*q++=(unsigned char) byte;
nibble=0;
byte=0;
}
p+=GetPixelChannels(image);
}
if (nibble != 0)
{
*q++=(unsigned char) (byte << 4);
x++;
}
offset=(ssize_t) (image->columns+1)/2;
for (x=offset; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 8:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=(unsigned char) GetPixelIndex(image,p);
p+=GetPixelChannels(image);
}
for ( ; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 16:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
unsigned short
pixel;
pixel=0;
if (bmp_subtype == ARGB4444)
{
pixel=(unsigned short) (ScaleQuantumToAny(
GetPixelAlpha(image,p),15) << 12);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelRed(image,p),15) << 8);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelGreen(image,p),15) << 4);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelBlue(image,p),15));
}
else if (bmp_subtype == RGB565)
{
pixel=(unsigned short) (ScaleQuantumToAny(
GetPixelRed(image,p),31) << 11);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelGreen(image,p),63) << 5);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelBlue(image,p),31));
}
else
{
if (bmp_subtype == ARGB1555)
pixel=(unsigned short) (ScaleQuantumToAny(
GetPixelAlpha(image,p),1) << 15);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelRed(image,p),31) << 10);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelGreen(image,p),31) << 5);
pixel|=(unsigned short) (ScaleQuantumToAny(
GetPixelBlue(image,p),31));
}
*((unsigned short *) q)=pixel;
q+=2;
p+=GetPixelChannels(image);
}
for (x=2L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 24:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=ScaleQuantumToChar(GetPixelBlue(image,p));
*q++=ScaleQuantumToChar(GetPixelGreen(image,p));
*q++=ScaleQuantumToChar(GetPixelRed(image,p));
p+=GetPixelChannels(image);
}
for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 32:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=ScaleQuantumToChar(GetPixelBlue(image,p));
*q++=ScaleQuantumToChar(GetPixelGreen(image,p));
*q++=ScaleQuantumToChar(GetPixelRed(image,p));
*q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
p+=GetPixelChannels(image);
}
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
}
if ((type > 2) && (bmp_info.bits_per_pixel == 8))
if (image_info->compression != NoCompression)
{
MemoryInfo
*rle_info;
rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),
(image->rows+2)*sizeof(*pixels));
if (rle_info == (MemoryInfo *) NULL)
{
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
}
bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);
bmp_info.file_size-=bmp_info.image_size;
bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,
pixels,bmp_data);
bmp_info.file_size+=bmp_info.image_size;
pixel_info=RelinquishVirtualMemory(pixel_info);
pixel_info=rle_info;
pixels=bmp_data;
bmp_info.compression=BI_RLE8;
}
if (image->debug != MagickFalse)
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Writing BMP version %.20g datastream"",(double) type);
if (image->storage_class == DirectClass)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Storage class=DirectClass"");
else
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Storage class=PseudoClass"");
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Image depth=%.20g"",(double) image->depth);
if (image->alpha_trait != UndefinedPixelTrait)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Matte=True"");
else
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Matte=MagickFalse"");
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   BMP bits_per_pixel=%.20g"",(double) bmp_info.bits_per_pixel);
switch ((int) bmp_info.compression)
{
case BI_RGB:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=BI_RGB"");
break;
}
case BI_RLE8:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=BI_RLE8"");
break;
}
case BI_BITFIELDS:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=BI_BITFIELDS"");
break;
}
default:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=UNKNOWN (%u)"",bmp_info.compression);
break;
}
}
if (bmp_info.number_colors == 0)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Number_colors=unspecified"");
else
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Number_colors=%u"",bmp_info.number_colors);
}
(void) WriteBlob(image,2,(unsigned char *) ""BM"");
(void) WriteBlobLSBLong(image,bmp_info.file_size);
(void) WriteBlobLSBLong(image,bmp_info.ba_offset);  
(void) WriteBlobLSBLong(image,bmp_info.offset_bits);
if (type == 2)
{
(void) WriteBlobLSBLong(image,bmp_info.size);
(void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);
(void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);
(void) WriteBlobLSBShort(image,bmp_info.planes);
(void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
}
else
{
(void) WriteBlobLSBLong(image,bmp_info.size);
(void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);
(void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);
(void) WriteBlobLSBShort(image,bmp_info.planes);
(void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
(void) WriteBlobLSBLong(image,bmp_info.compression);
(void) WriteBlobLSBLong(image,bmp_info.image_size);
(void) WriteBlobLSBLong(image,bmp_info.x_pixels);
(void) WriteBlobLSBLong(image,bmp_info.y_pixels);
(void) WriteBlobLSBLong(image,bmp_info.number_colors);
(void) WriteBlobLSBLong(image,bmp_info.colors_important);
}
if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||
(have_color_info != MagickFalse)))
{
(void) WriteBlobLSBLong(image,bmp_info.red_mask);
(void) WriteBlobLSBLong(image,bmp_info.green_mask);
(void) WriteBlobLSBLong(image,bmp_info.blue_mask);
(void) WriteBlobLSBLong(image,bmp_info.alpha_mask);
(void) WriteBlobLSBLong(image,0x73524742U);  
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.red_primary.x*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.red_primary.y*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
((1.000f-(image->chromaticity.red_primary.x+
image->chromaticity.red_primary.y))*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.green_primary.x*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.green_primary.y*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
((1.000f-(image->chromaticity.green_primary.x+
image->chromaticity.green_primary.y))*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.blue_primary.x*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.blue_primary.y*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
((1.000f-(image->chromaticity.blue_primary.x+
image->chromaticity.blue_primary.y))*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(bmp_info.gamma_scale.x*0x10000));
(void) WriteBlobLSBLong(image,(unsigned int)
(bmp_info.gamma_scale.y*0x10000));
(void) WriteBlobLSBLong(image,(unsigned int)
(bmp_info.gamma_scale.z*0x10000));
if ((image->rendering_intent != UndefinedIntent) ||
(profile != (StringInfo *) NULL))
{
ssize_t
intent;
switch ((int) image->rendering_intent)
{
case SaturationIntent:
{
intent=LCS_GM_BUSINESS;
break;
}
case RelativeIntent:
{
intent=LCS_GM_GRAPHICS;
break;
}
case PerceptualIntent:
{
intent=LCS_GM_IMAGES;
break;
}
case AbsoluteIntent:
{
intent=LCS_GM_ABS_COLORIMETRIC;
break;
}
default:
{
intent=0;
break;
}
}
(void) WriteBlobLSBLong(image,(unsigned int) intent);
(void) WriteBlobLSBLong(image,0x00);  
(void) WriteBlobLSBLong(image,0x00);  
(void) WriteBlobLSBLong(image,0x00);  
}
}
if (image->storage_class == PseudoClass)
{
unsigned char
*bmp_colormap;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  Colormap: %.20g entries"",(double) image->colors);
bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));
if (bmp_colormap == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
q=bmp_colormap;
for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)
{
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));
if (type > 2)
*q++=(unsigned char) 0x0;
}
for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)
{
*q++=(unsigned char) 0x00;
*q++=(unsigned char) 0x00;
*q++=(unsigned char) 0x00;
if (type > 2)
*q++=(unsigned char) 0x00;
}
if (type <= 2)
(void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),
bmp_colormap);
else
(void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),
bmp_colormap);
bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  Pixels:  %u bytes"",bmp_info.image_size);
(void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);
pixel_info=RelinquishVirtualMemory(pixel_info);
if (GetNextImageInList(image) == (Image *) NULL)
break;
image=SyncNextImageInList(image);
status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);
if (status == MagickFalse)
break;
} while (image_info->adjoin != MagickFalse);
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WriteBMPImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
BMPInfo
VAR_3;
BMPSubtype
VAR_4;
const char
*VAR_5;
const StringInfo
*VAR_6;
MagickBooleanType
VAR_7,
VAR_8;
MagickOffsetType
VAR_9;
MemoryInfo
*VAR_10;
register const Quantum
*VAR_11;
register ssize_t
VAR_12,
VAR_13;
register unsigned char
*VAR_14;
size_t
VAR_15,
VAR_16,
VAR_17;
ssize_t
VAR_18;
unsigned char
*VAR_19,
*VAR_20;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_21);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_21);
if (VAR_1->debug != VAR_22)
(void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_21);
VAR_8=OpenBlob(VAR_0,VAR_1,VAR_24,VAR_2);
if (VAR_8 == VAR_22)
return(VAR_8);
VAR_17=4;
if (LocaleCompare(VAR_0->magick,""BMP2"") == 0)
VAR_17=2;
else
if (LocaleCompare(VAR_0->magick,""BMP3"") == 0)
VAR_17=3;
VAR_5=GetImageOption(VAR_0,""bmp:format"");
if (VAR_5 != (char *) NULL)
{
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""  Format=%s"",VAR_5);
if (LocaleCompare(VAR_5,""bmp2"") == 0)
VAR_17=2;
if (LocaleCompare(VAR_5,""bmp3"") == 0)
VAR_17=3;
if (LocaleCompare(VAR_5,""bmp4"") == 0)
VAR_17=4;
}
VAR_9=0;
VAR_16=GetImageListLength(VAR_1);
do
{
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_22)
(void) TransformImageColorspace(VAR_1,VAR_26,VAR_2);
(void) memset(&VAR_3,0,sizeof(VAR_3));
VAR_3.file_size=14+12;
if (VAR_17 > 2)
VAR_3.file_size+=28;
VAR_3.offset_bits=VAR_3.file_size;
VAR_3.compression=VAR_27;
VAR_3.red_mask=0x00ff0000U;
VAR_3.green_mask=0x0000ff00U;
VAR_3.blue_mask=0x000000ffU;
VAR_3.alpha_mask=0xff000000U;
VAR_4=VAR_28;
if ((VAR_1->storage_class == VAR_29) && (VAR_1->colors > 256))
(void) SetImageStorageClass(VAR_1,VAR_30,VAR_2);
if (VAR_1->storage_class != VAR_30)
{
VAR_3.bits_per_pixel=8;
if (VAR_1->colors <= 2)
VAR_3.bits_per_pixel=1;
else
if (VAR_1->colors <= 16)
VAR_3.bits_per_pixel=4;
else
if (VAR_1->colors <= 256)
VAR_3.bits_per_pixel=8;
if (VAR_0->compression == VAR_31)
VAR_3.bits_per_pixel=8;
VAR_3.number_colors=1U << VAR_3.bits_per_pixel;
if (VAR_1->alpha_trait != VAR_32)
(void) SetImageStorageClass(VAR_1,VAR_30,VAR_2);
else
if ((size_t) VAR_3.number_colors < VAR_1->colors)
(void) SetImageStorageClass(VAR_1,VAR_30,VAR_2);
else
{
VAR_3.file_size+=3*(1UL << VAR_3.bits_per_pixel);
VAR_3.offset_bits+=3*(1UL << VAR_3.bits_per_pixel);
if (VAR_17 > 2)
{
VAR_3.file_size+=(1UL << VAR_3.bits_per_pixel);
VAR_3.offset_bits+=(1UL << VAR_3.bits_per_pixel);
}
}
}
if (VAR_1->storage_class == VAR_30)
{
VAR_3.number_colors=0;
VAR_5=GetImageOption(VAR_0,""bmp:subtype"");
if (VAR_5 != (const char *) NULL)
{
if (VAR_1->alpha_trait != VAR_32)
{
if (LocaleNCompare(VAR_5,""ARGB4444"",8) == 0)
{
VAR_4=VAR_33;
VAR_3.red_mask=0x00000f00U;
VAR_3.green_mask=0x000000f0U;
VAR_3.blue_mask=0x0000000fU;
VAR_3.alpha_mask=0x0000f000U;
}
else if (LocaleNCompare(VAR_5,""ARGB1555"",8) == 0)
{
VAR_4=VAR_34;
VAR_3.red_mask=0x00007c00U;
VAR_3.green_mask=0x000003e0U;
VAR_3.blue_mask=0x0000001fU;
VAR_3.alpha_mask=0x00008000U;
}
}
else
{
if (LocaleNCompare(VAR_5,""RGB555"",6) == 0)
{
VAR_4=VAR_35;
VAR_3.red_mask=0x00007c00U;
VAR_3.green_mask=0x000003e0U;
VAR_3.blue_mask=0x0000001fU;
VAR_3.alpha_mask=0U;
}
else if (LocaleNCompare(VAR_5,""RGB565"",6) == 0)
{
VAR_4=VAR_36;
VAR_3.red_mask=0x0000f800U;
VAR_3.green_mask=0x000007e0U;
VAR_3.blue_mask=0x0000001fU;
VAR_3.alpha_mask=0U;
}
}
}
if (VAR_4 != VAR_28)
{
VAR_3.bits_per_pixel=16;
VAR_3.compression=VAR_37;
}
else
{
VAR_3.bits_per_pixel=(unsigned short) ((VAR_17 > 3) &&
(VAR_1->alpha_trait != VAR_32) ? 32 : 24);
VAR_3.compression=(unsigned int) ((VAR_17 > 3) &&
(VAR_1->alpha_trait != VAR_32) ? VAR_37 : VAR_27);
if ((VAR_17 == 3) && (VAR_1->alpha_trait != VAR_32))
{
VAR_5=GetImageOption(VAR_0,""bmp3:alpha"");
if (IsStringTrue(VAR_5))
VAR_3.bits_per_pixel=32;
}
}
}
VAR_15=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);
VAR_3.ba_offset=0;
VAR_6=GetImageProfile(VAR_1,""icc"");
VAR_7=(VAR_1->rendering_intent != VAR_38) ||
(VAR_6 != (StringInfo *) NULL) || (VAR_1->gamma != 0.0) ?  VAR_39 :
VAR_22;
if (VAR_17 == 2)
VAR_3.size=12;
else
if ((VAR_17 == 3) || ((VAR_1->alpha_trait == VAR_32) &&
(VAR_7 == VAR_22)))
{
VAR_17=3;
VAR_3.size=40;
}
else
{
int
VAR_40;
VAR_3.size=108;
VAR_40=68;
if ((VAR_1->rendering_intent != VAR_38) ||
(VAR_6 != (StringInfo *) NULL))
{
VAR_3.size=124;
VAR_40+=16;
}
VAR_3.file_size+=VAR_40;
VAR_3.offset_bits+=VAR_40;
}
if (((ssize_t) VAR_1->columns != (ssize_t) ((signed int) VAR_1->columns)) ||
((ssize_t) VAR_1->rows != (ssize_t) ((signed int) VAR_1->rows)))
ThrowWriterException(VAR_41,""WidthOrHeightExceedsLimit"");
VAR_3.width=(ssize_t) VAR_1->columns;
VAR_3.height=(ssize_t) VAR_1->rows;
VAR_3.planes=1;
VAR_3.image_size=(unsigned int) (VAR_15*VAR_1->rows);
VAR_3.file_size+=VAR_3.image_size;
VAR_3.x_pixels=75*39;
VAR_3.y_pixels=75*39;
switch (VAR_1->units)
{
case VAR_42:
case VAR_43:
{
VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);
VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);
break;
}
case VAR_44:
{
VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);
VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);
break;
}
}
VAR_3.colors_important=VAR_3.number_colors;
VAR_10=AcquireVirtualMemory((size_t) VAR_3.image_size,
sizeof(*VAR_20));
if (VAR_10 == (MemoryInfo *) NULL)
ThrowWriterException(VAR_45,""MemoryAllocationFailed"");
VAR_20=(unsigned char *) GetVirtualMemoryBlob(VAR_10);
(void) memset(VAR_20,0,(size_t) VAR_3.image_size);
switch (VAR_3.bits_per_pixel)
{
case 1:
{
size_t
VAR_46,
VAR_47;
for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
{
ssize_t
VAR_48;
VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
if (VAR_11 == (const Quantum *) NULL)
break;
VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
VAR_46=0;
VAR_47=0;
for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
{
VAR_47<<=1;
VAR_47|=GetPixelIndex(VAR_1,VAR_11) != 0 ? 0x01 : 0x00;
VAR_46++;
if (VAR_46 == 8)
{
*VAR_14++=(unsigned char) VAR_47;
VAR_46=0;
VAR_47=0;
}
VAR_11+=GetPixelChannels(VAR_1);
}
if (VAR_46 != 0)
{
*VAR_14++=(unsigned char) (VAR_47 << (8-VAR_46));
VAR_13++;
}
VAR_48=(ssize_t) (VAR_1->columns+7)/8;
for (VAR_13=VAR_48; VAR_13 < (ssize_t) VAR_15; VAR_13++)
*VAR_14++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
VAR_1->rows);
if (VAR_8 == VAR_22)
break;
}
}
break;
}
case 4:
{
unsigned int
VAR_47,
VAR_50;
ssize_t
VAR_48;
for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
{
VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
if (VAR_11 == (const Quantum *) NULL)
break;
VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
VAR_50=0;
VAR_47=0;
for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
{
VAR_47<<=4;
VAR_47|=((unsigned int) GetPixelIndex(VAR_1,VAR_11) & 0x0f);
VAR_50++;
if (VAR_50 == 2)
{
*VAR_14++=(unsigned char) VAR_47;
VAR_50=0;
VAR_47=0;
}
VAR_11+=GetPixelChannels(VAR_1);
}
if (VAR_50 != 0)
{
*VAR_14++=(unsigned char) (VAR_47 << 4);
VAR_13++;
}
VAR_48=(ssize_t) (VAR_1->columns+1)/2;
for (VAR_13=VAR_48; VAR_13 < (ssize_t) VAR_15; VAR_13++)
*VAR_14++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
VAR_1->rows);
if (VAR_8 == VAR_22)
break;
}
}
break;
}
case 8:
{
for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
{
VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
if (VAR_11 == (const Quantum *) NULL)
break;
VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
{
*VAR_14++=(unsigned char) GetPixelIndex(VAR_1,VAR_11);
VAR_11+=GetPixelChannels(VAR_1);
}
for ( ; VAR_13 < (ssize_t) VAR_15; VAR_13++)
*VAR_14++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
VAR_1->rows);
if (VAR_8 == VAR_22)
break;
}
}
break;
}
case 16:
{
for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
{
VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
if (VAR_11 == (const Quantum *) NULL)
break;
VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
{
unsigned short
VAR_51;
VAR_51=0;
if (VAR_4 == VAR_33)
{
VAR_51=(unsigned short) (ScaleQuantumToAny(
GetPixelAlpha(VAR_1,VAR_11),15) << 12);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelRed(VAR_1,VAR_11),15) << 8);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelGreen(VAR_1,VAR_11),15) << 4);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelBlue(VAR_1,VAR_11),15));
}
else if (VAR_4 == VAR_36)
{
VAR_51=(unsigned short) (ScaleQuantumToAny(
GetPixelRed(VAR_1,VAR_11),31) << 11);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelGreen(VAR_1,VAR_11),63) << 5);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelBlue(VAR_1,VAR_11),31));
}
else
{
if (VAR_4 == VAR_34)
VAR_51=(unsigned short) (ScaleQuantumToAny(
GetPixelAlpha(VAR_1,VAR_11),1) << 15);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelRed(VAR_1,VAR_11),31) << 10);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelGreen(VAR_1,VAR_11),31) << 5);
VAR_51|=(unsigned short) (ScaleQuantumToAny(
GetPixelBlue(VAR_1,VAR_11),31));
}
*((unsigned short *) VAR_14)=VAR_51;
VAR_14+=2;
VAR_11+=GetPixelChannels(VAR_1);
}
for (VAR_13=2L*(ssize_t) VAR_1->columns; VAR_13 < (ssize_t) VAR_15; VAR_13++)
*VAR_14++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
VAR_1->rows);
if (VAR_8 == VAR_22)
break;
}
}
break;
}
case 24:
{
for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
{
VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
if (VAR_11 == (const Quantum *) NULL)
break;
VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
{
*VAR_14++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_11));
*VAR_14++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_11));
*VAR_14++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_11));
VAR_11+=GetPixelChannels(VAR_1);
}
for (VAR_13=3L*(ssize_t) VAR_1->columns; VAR_13 < (ssize_t) VAR_15; VAR_13++)
*VAR_14++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
VAR_1->rows);
if (VAR_8 == VAR_22)
break;
}
}
break;
}
case 32:
{
for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
{
VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
if (VAR_11 == (const Quantum *) NULL)
break;
VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
{
*VAR_14++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_11));
*VAR_14++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_11));
*VAR_14++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_11));
*VAR_14++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_11));
VAR_11+=GetPixelChannels(VAR_1);
}
if (VAR_1->previous == (Image *) NULL)
{
VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
VAR_1->rows);
if (VAR_8 == VAR_22)
break;
}
}
break;
}
}
if ((VAR_17 > 2) && (VAR_3.bits_per_pixel == 8))
if (VAR_0->compression != VAR_52)
{
MemoryInfo
*VAR_53;
VAR_53=AcquireVirtualMemory((size_t) (2*(VAR_15+2)+2),
(VAR_1->rows+2)*sizeof(*VAR_20));
if (VAR_53 == (MemoryInfo *) NULL)
{
VAR_10=RelinquishVirtualMemory(VAR_10);
ThrowWriterException(VAR_45,""MemoryAllocationFailed"");
}
VAR_19=(unsigned char *) GetVirtualMemoryBlob(VAR_53);
VAR_3.file_size-=VAR_3.image_size;
VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_15,
VAR_20,VAR_19);
VAR_3.file_size+=VAR_3.image_size;
VAR_10=RelinquishVirtualMemory(VAR_10);
VAR_10=VAR_53;
VAR_20=VAR_19;
VAR_3.compression=VAR_54;
}
if (VAR_1->debug != VAR_22)
{
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Writing BMP version %.20g datastream"",(double) VAR_17);
if (VAR_1->storage_class == VAR_30)
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Storage class=DirectClass"");
else
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Storage class=PseudoClass"");
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Image depth=%.20g"",(double) VAR_1->depth);
if (VAR_1->alpha_trait != VAR_32)
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Matte=True"");
else
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Matte=MagickFalse"");
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   BMP bits_per_pixel=%.20g"",(double) VAR_3.bits_per_pixel);
switch ((int) VAR_3.compression)
{
case VAR_27:
{
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Compression=BI_RGB"");
break;
}
case VAR_54:
{
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Compression=BI_RLE8"");
break;
}
case VAR_37:
{
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Compression=BI_BITFIELDS"");
break;
}
default:
{
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Compression=UNKNOWN (%u)"",VAR_3.compression);
break;
}
}
if (VAR_3.number_colors == 0)
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Number_colors=unspecified"");
else
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""   Number_colors=%u"",VAR_3.number_colors);
}
(void) WriteBlob(VAR_1,2,(unsigned char *) ""BM"");
(void) WriteBlobLSBLong(VAR_1,VAR_3.file_size);
(void) WriteBlobLSBLong(VAR_1,VAR_3.ba_offset);  
(void) WriteBlobLSBLong(VAR_1,VAR_3.offset_bits);
if (VAR_17 == 2)
{
(void) WriteBlobLSBLong(VAR_1,VAR_3.size);
(void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.width);
(void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.height);
(void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
(void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
}
else
{
(void) WriteBlobLSBLong(VAR_1,VAR_3.size);
(void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.width);
(void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.height);
(void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
(void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
(void) WriteBlobLSBLong(VAR_1,VAR_3.compression);
(void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);
(void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);
(void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);
(void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);
(void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);
}
if ((VAR_17 > 3) && ((VAR_1->alpha_trait != VAR_32) ||
(VAR_7 != VAR_22)))
{
(void) WriteBlobLSBLong(VAR_1,VAR_3.red_mask);
(void) WriteBlobLSBLong(VAR_1,VAR_3.green_mask);
(void) WriteBlobLSBLong(VAR_1,VAR_3.blue_mask);
(void) WriteBlobLSBLong(VAR_1,VAR_3.alpha_mask);
(void) WriteBlobLSBLong(VAR_1,0x73524742U);  
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.red_primary.x*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.red_primary.y*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
((1.000f-(VAR_1->chromaticity.red_primary.x+
VAR_1->chromaticity.red_primary.y))*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.green_primary.x*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.green_primary.y*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
((1.000f-(VAR_1->chromaticity.green_primary.x+
VAR_1->chromaticity.green_primary.y))*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.blue_primary.x*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.blue_primary.y*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
((1.000f-(VAR_1->chromaticity.blue_primary.x+
VAR_1->chromaticity.blue_primary.y))*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_3.gamma_scale.x*0x10000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_3.gamma_scale.y*0x10000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_3.gamma_scale.z*0x10000));
if ((VAR_1->rendering_intent != VAR_38) ||
(VAR_6 != (StringInfo *) NULL))
{
ssize_t
VAR_55;
switch ((int) VAR_1->rendering_intent)
{
case VAR_56:
{
VAR_55=VAR_57;
break;
}
case VAR_58:
{
VAR_55=VAR_59;
break;
}
case VAR_60:
{
VAR_55=VAR_61;
break;
}
case VAR_62:
{
VAR_55=VAR_63;
break;
}
default:
{
VAR_55=0;
break;
}
}
(void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_55);
(void) WriteBlobLSBLong(VAR_1,0x00);  
(void) WriteBlobLSBLong(VAR_1,0x00);  
(void) WriteBlobLSBLong(VAR_1,0x00);  
}
}
if (VAR_1->storage_class == VAR_29)
{
unsigned char
*VAR_64;
if (VAR_1->debug != VAR_22)
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""  Colormap: %.20g entries"",(double) VAR_1->colors);
VAR_64=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
VAR_3.bits_per_pixel),4*sizeof(*VAR_64));
if (VAR_64 == (unsigned char *) NULL)
ThrowWriterException(VAR_45,""MemoryAllocationFailed"");
VAR_14=VAR_64;
for (VAR_12=0; VAR_12 < (ssize_t) MagickMin((ssize_t) VAR_1->colors,(ssize_t) VAR_3.number_colors); VAR_12++)
{
*VAR_14++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_12].blue));
*VAR_14++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_12].green));
*VAR_14++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_12].red));
if (VAR_17 > 2)
*VAR_14++=(unsigned char) 0x0;
}
for ( ; VAR_12 < (ssize_t) (1UL << VAR_3.bits_per_pixel); VAR_12++)
{
*VAR_14++=(unsigned char) 0x00;
*VAR_14++=(unsigned char) 0x00;
*VAR_14++=(unsigned char) 0x00;
if (VAR_17 > 2)
*VAR_14++=(unsigned char) 0x00;
}
if (VAR_17 <= 2)
(void) WriteBlob(VAR_1,(size_t) (3*(1L << VAR_3.bits_per_pixel)),
VAR_64);
else
(void) WriteBlob(VAR_1,(size_t) (4*(1L << VAR_3.bits_per_pixel)),
VAR_64);
VAR_64=(unsigned char *) RelinquishMagickMemory(VAR_64);
}
if (VAR_1->debug != VAR_22)
(void) LogMagickEvent(VAR_25,GetMagickModule(),
""  Pixels:  %u bytes"",VAR_3.image_size);
(void) WriteBlob(VAR_1,(size_t) VAR_3.image_size,VAR_20);
VAR_10=RelinquishVirtualMemory(VAR_10);
if (GetNextImageInList(VAR_1) == (Image *) NULL)
break;
VAR_1=SyncNextImageInList(VAR_1);
VAR_8=SetImageProgress(VAR_1,VAR_65,VAR_9++,VAR_16);
if (VAR_8 == VAR_22)
break;
} while (VAR_0->adjoin != VAR_22);
(void) CloseBlob(VAR_1);
return(VAR_39);
}",ImageMagick/ae04fa4be910255e5d363edebd77adeee99a525d/bmp.c/vul/before/0.json,"static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  BMPInfo
    bmp_info;

  BMPSubtype
    bmp_subtype;

  const char
    *option;

  const StringInfo
    *profile;

  MagickBooleanType
    have_color_info,
    status;

  MagickOffsetType
    scene;

  MemoryInfo
    *pixel_info;

  register const Quantum
    *p;

  register ssize_t
    i,
    x;

  register unsigned char
    *q;

  size_t
    bytes_per_line,
    imageListLength,
    type;

  ssize_t
    y;

  unsigned char
    *bmp_data,
    *pixels;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  type=4;
  if (LocaleCompare(image_info->magick,""BMP2"") == 0)
    type=2;
  else
    if (LocaleCompare(image_info->magick,""BMP3"") == 0)
      type=3;
  option=GetImageOption(image_info,""bmp:format"");
  if (option != (char *) NULL)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Format=%s"",option);
      if (LocaleCompare(option,""bmp2"") == 0)
        type=2;
      if (LocaleCompare(option,""bmp3"") == 0)
        type=3;
      if (LocaleCompare(option,""bmp4"") == 0)
        type=4;
    }
  scene=0;
  imageListLength=GetImageListLength(image);
  do
  {
    /*
      Initialize BMP raster file header.
    */
    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
      (void) TransformImageColorspace(image,sRGBColorspace,exception);
    (void) memset(&bmp_info,0,sizeof(bmp_info));
    bmp_info.file_size=14+12;
    if (type > 2)
      bmp_info.file_size+=28;
    bmp_info.offset_bits=bmp_info.file_size;
    bmp_info.compression=BI_RGB;
    bmp_info.red_mask=0x00ff0000U;
    bmp_info.green_mask=0x0000ff00U;
    bmp_info.blue_mask=0x000000ffU;
    bmp_info.alpha_mask=0xff000000U;
    bmp_subtype=UndefinedSubtype;
    if ((image->storage_class == PseudoClass) && (image->colors > 256))
      (void) SetImageStorageClass(image,DirectClass,exception);
    if (image->storage_class != DirectClass)
      {
        /*
          Colormapped BMP raster.
        */
        bmp_info.bits_per_pixel=8;
        if (image->colors <= 2)
          bmp_info.bits_per_pixel=1;
        else
          if (image->colors <= 16)
            bmp_info.bits_per_pixel=4;
          else
            if (image->colors <= 256)
              bmp_info.bits_per_pixel=8;
        if (image_info->compression == RLECompression)
          bmp_info.bits_per_pixel=8;
        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;
        if (image->alpha_trait != UndefinedPixelTrait)
          (void) SetImageStorageClass(image,DirectClass,exception);
        else
          if ((size_t) bmp_info.number_colors < image->colors)
            (void) SetImageStorageClass(image,DirectClass,exception);
          else
            {
              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);
              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);
              if (type > 2)
                {
                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);
                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);
                }
            }
      }
    if (image->storage_class == DirectClass)
      {
        /*
          Full color BMP raster.
        */
        bmp_info.number_colors=0;
        option=GetImageOption(image_info,""bmp:subtype"");
        if (option != (const char *) NULL)
        {
          if (image->alpha_trait != UndefinedPixelTrait)
            {
              if (LocaleNCompare(option,""ARGB4444"",8) == 0)
                {
                  bmp_subtype=ARGB4444;
                  bmp_info.red_mask=0x00000f00U;
                  bmp_info.green_mask=0x000000f0U;
                  bmp_info.blue_mask=0x0000000fU;
                  bmp_info.alpha_mask=0x0000f000U;
                }
              else if (LocaleNCompare(option,""ARGB1555"",8) == 0)
                {
                  bmp_subtype=ARGB1555;
                  bmp_info.red_mask=0x00007c00U;
                  bmp_info.green_mask=0x000003e0U;
                  bmp_info.blue_mask=0x0000001fU;
                  bmp_info.alpha_mask=0x00008000U;
                }
            }
          else
          {
            if (LocaleNCompare(option,""RGB555"",6) == 0)
              {
                bmp_subtype=RGB555;
                bmp_info.red_mask=0x00007c00U;
                bmp_info.green_mask=0x000003e0U;
                bmp_info.blue_mask=0x0000001fU;
                bmp_info.alpha_mask=0U;
              }
            else if (LocaleNCompare(option,""RGB565"",6) == 0)
              {
                bmp_subtype=RGB565;
                bmp_info.red_mask=0x0000f800U;
                bmp_info.green_mask=0x000007e0U;
                bmp_info.blue_mask=0x0000001fU;
                bmp_info.alpha_mask=0U;
              }
          }
        }
        if (bmp_subtype != UndefinedSubtype)
          {
            bmp_info.bits_per_pixel=16;
            bmp_info.compression=BI_BITFIELDS;
          }
        else
          {
            bmp_info.bits_per_pixel=(unsigned short) ((type > 3) &&
               (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);
            bmp_info.compression=(unsigned int) ((type > 3) &&
              (image->alpha_trait != UndefinedPixelTrait) ? BI_BITFIELDS : BI_RGB);
            if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))
              {
                option=GetImageOption(image_info,""bmp3:alpha"");
                if (IsStringTrue(option))
                  bmp_info.bits_per_pixel=32;
              }
          }
      }
    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);
    bmp_info.ba_offset=0;
    profile=GetImageProfile(image,""icc"");
    have_color_info=(image->rendering_intent != UndefinedIntent) ||
      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :
      MagickFalse;
    if (type == 2)
      bmp_info.size=12;
    else
      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&
          (have_color_info == MagickFalse)))
        {
          type=3;
          bmp_info.size=40;
        }
      else
        {
          int
            extra_size;

          bmp_info.size=108;
          extra_size=68;
          if ((image->rendering_intent != UndefinedIntent) ||
              (profile != (StringInfo *) NULL))
            {
              bmp_info.size=124;
              extra_size+=16;
            }
          bmp_info.file_size+=extra_size;
          bmp_info.offset_bits+=extra_size;
        }
    if (((ssize_t) image->columns != (ssize_t) ((signed int) image->columns)) ||
        ((ssize_t) image->rows != (ssize_t) ((signed int) image->rows)))
      ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
    bmp_info.width=(ssize_t) image->columns;
    bmp_info.height=(ssize_t) image->rows;
    bmp_info.planes=1;
    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);
    bmp_info.file_size+=bmp_info.image_size;
    bmp_info.x_pixels=75*39;
    bmp_info.y_pixels=75*39;
    switch (image->units)
    {
      case UndefinedResolution:
      case PixelsPerInchResolution:
      {
        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);
        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);
        break;
      }
      case PixelsPerCentimeterResolution:
      {
        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);
        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);
        break;
      }
    }
    bmp_info.colors_important=bmp_info.number_colors;
    /*
      Convert MIFF to BMP raster pixels.
    */
    pixel_info=AcquireVirtualMemory(image->rows,
      MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) memset(pixels,0,(size_t) bmp_info.image_size);
    switch (bmp_info.bits_per_pixel)
    {
      case 1:
      {
        size_t
          bit,
          byte;

        /*
          Convert PseudoClass image to a BMP monochrome image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          ssize_t
            offset;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          bit=0;
          byte=0;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            byte<<=1;
            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;
            bit++;
            if (bit == 8)
              {
                *q++=(unsigned char) byte;
                bit=0;
                byte=0;
              }
             p+=GetPixelChannels(image);
           }
           if (bit != 0)
             {
               *q++=(unsigned char) (byte << (8-bit));
               x++;
             }
          offset=(ssize_t) (image->columns+7)/8;
          for (x=offset; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 4:
      {
        unsigned int
          byte,
          nibble;

        ssize_t
          offset;

        /*
          Convert PseudoClass image to a BMP monochrome image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          nibble=0;
          byte=0;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            byte<<=4;
            byte|=((unsigned int) GetPixelIndex(image,p) & 0x0f);
            nibble++;
            if (nibble == 2)
              {
                *q++=(unsigned char) byte;
                nibble=0;
                byte=0;
              }
            p+=GetPixelChannels(image);
          }
          if (nibble != 0)
            {
              *q++=(unsigned char) (byte << 4);
              x++;
            }
          offset=(ssize_t) (image->columns+1)/2;
          for (x=offset; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 8:
      {
        /*
          Convert PseudoClass packet to BMP pixel.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            *q++=(unsigned char) GetPixelIndex(image,p);
            p+=GetPixelChannels(image);
          }
          for ( ; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 16:
      {
        /*
          Convert DirectClass packet to BMP BGR888.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            unsigned short
              pixel;

            pixel=0;
            if (bmp_subtype == ARGB4444)
              {
                pixel=(unsigned short) (ScaleQuantumToAny(
                  GetPixelAlpha(image,p),15) << 12);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelRed(image,p),15) << 8);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelGreen(image,p),15) << 4);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelBlue(image,p),15));
              }
            else if (bmp_subtype == RGB565)
              {
                pixel=(unsigned short) (ScaleQuantumToAny(
                  GetPixelRed(image,p),31) << 11);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelGreen(image,p),63) << 5);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelBlue(image,p),31));
              }
            else
              {
                if (bmp_subtype == ARGB1555)
                  pixel=(unsigned short) (ScaleQuantumToAny(
                    GetPixelAlpha(image,p),1) << 15);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelRed(image,p),31) << 10);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelGreen(image,p),31) << 5);
                pixel|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelBlue(image,p),31));
              }
            *((unsigned short *) q)=pixel;
            q+=2;
            p+=GetPixelChannels(image);
          }
          for (x=2L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 24:
      {
        /*
          Convert DirectClass packet to BMP BGR888.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
            *q++=ScaleQuantumToChar(GetPixelRed(image,p));
            p+=GetPixelChannels(image);
          }
          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 32:
      {
        /*
          Convert DirectClass packet to ARGB8888 pixel.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
            *q++=ScaleQuantumToChar(GetPixelRed(image,p));
            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
            p+=GetPixelChannels(image);
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
    }
    if ((type > 2) && (bmp_info.bits_per_pixel == 8))
      if (image_info->compression != NoCompression)
        {
          MemoryInfo
            *rle_info;

          /*
            Convert run-length encoded raster pixels.
          */
          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),
            (image->rows+2)*sizeof(*pixels));
          if (rle_info == (MemoryInfo *) NULL)
            {
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
            }
          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);
          bmp_info.file_size-=bmp_info.image_size;
          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,
            pixels,bmp_data);
          bmp_info.file_size+=bmp_info.image_size;
          pixel_info=RelinquishVirtualMemory(pixel_info);
          pixel_info=rle_info;
          pixels=bmp_data;
          bmp_info.compression=BI_RLE8;
        }
    /*
      Write BMP for Windows, all versions, 14-byte header.
    */
    if (image->debug != MagickFalse)
      {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""   Writing BMP version %.20g datastream"",(double) type);
        if (image->storage_class == DirectClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Storage class=DirectClass"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Storage class=PseudoClass"");
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""   Image depth=%.20g"",(double) image->depth);
        if (image->alpha_trait != UndefinedPixelTrait)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Matte=True"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Matte=MagickFalse"");
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""   BMP bits_per_pixel=%.20g"",(double) bmp_info.bits_per_pixel);
        switch ((int) bmp_info.compression)
        {
           case BI_RGB:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=BI_RGB"");
             break;
           }
           case BI_RLE8:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=BI_RLE8"");
             break;
           }
           case BI_BITFIELDS:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=BI_BITFIELDS"");
             break;
           }
           default:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=UNKNOWN (%u)"",bmp_info.compression);
             break;
           }
        }
        if (bmp_info.number_colors == 0)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Number_colors=unspecified"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Number_colors=%u"",bmp_info.number_colors);
      }
    (void) WriteBlob(image,2,(unsigned char *) ""BM"");
    (void) WriteBlobLSBLong(image,bmp_info.file_size);
    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */
    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);
    if (type == 2)
      {
        /*
          Write 12-byte version 2 bitmap header.
        */
        (void) WriteBlobLSBLong(image,bmp_info.size);
        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);
        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);
        (void) WriteBlobLSBShort(image,bmp_info.planes);
        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
      }
    else
      {
        /*
          Write 40-byte version 3+ bitmap header.
        */
        (void) WriteBlobLSBLong(image,bmp_info.size);
        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);
        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);
        (void) WriteBlobLSBShort(image,bmp_info.planes);
        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
        (void) WriteBlobLSBLong(image,bmp_info.compression);
        (void) WriteBlobLSBLong(image,bmp_info.image_size);
        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);
        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);
        (void) WriteBlobLSBLong(image,bmp_info.number_colors);
        (void) WriteBlobLSBLong(image,bmp_info.colors_important);
      }
    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||
        (have_color_info != MagickFalse)))
      {
        /*
          Write the rest of the 108-byte BMP Version 4 header.
        */
        (void) WriteBlobLSBLong(image,bmp_info.red_mask);
        (void) WriteBlobLSBLong(image,bmp_info.green_mask);
        (void) WriteBlobLSBLong(image,bmp_info.blue_mask);
        (void) WriteBlobLSBLong(image,bmp_info.alpha_mask);
        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.red_primary.x*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.red_primary.y*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          ((1.000f-(image->chromaticity.red_primary.x+
          image->chromaticity.red_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.green_primary.x*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.green_primary.y*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          ((1.000f-(image->chromaticity.green_primary.x+
          image->chromaticity.green_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.blue_primary.x*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.blue_primary.y*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          ((1.000f-(image->chromaticity.blue_primary.x+
          image->chromaticity.blue_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (bmp_info.gamma_scale.x*0x10000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (bmp_info.gamma_scale.y*0x10000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (bmp_info.gamma_scale.z*0x10000));
        if ((image->rendering_intent != UndefinedIntent) ||
            (profile != (StringInfo *) NULL))
          {
            ssize_t
              intent;

            switch ((int) image->rendering_intent)
            {
              case SaturationIntent:
              {
                intent=LCS_GM_BUSINESS;
                break;
              }
              case RelativeIntent:
              {
                intent=LCS_GM_GRAPHICS;
                break;
              }
              case PerceptualIntent:
              {
                intent=LCS_GM_IMAGES;
                break;
              }
              case AbsoluteIntent:
              {
                intent=LCS_GM_ABS_COLORIMETRIC;
                break;
              }
              default:
              {
                intent=0;
                break;
              }
            }
            (void) WriteBlobLSBLong(image,(unsigned int) intent);
            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */
            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */
            (void) WriteBlobLSBLong(image,0x00);  /* reserved */
          }
      }
    if (image->storage_class == PseudoClass)
      {
        unsigned char
          *bmp_colormap;

        /*
          Dump colormap to file.
        */
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Colormap: %.20g entries"",(double) image->colors);
        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));
        if (bmp_colormap == (unsigned char *) NULL)
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
        q=bmp_colormap;
        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)
        {
          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));
          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));
          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));
          if (type > 2)
            *q++=(unsigned char) 0x0;
        }
        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)
        {
          *q++=(unsigned char) 0x00;
          *q++=(unsigned char) 0x00;
          *q++=(unsigned char) 0x00;
          if (type > 2)
            *q++=(unsigned char) 0x00;
        }
        if (type <= 2)
          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),
            bmp_colormap);
        else
          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),
            bmp_colormap);
        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
      }
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Pixels:  %u bytes"",bmp_info.image_size);
    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WriteBMPImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  BMPInfo
    VAR_3;

  BMPSubtype
    VAR_4;

  const char
    *VAR_5;

  const StringInfo
    *VAR_6;

  MagickBooleanType
    VAR_7,
    VAR_8;

  MagickOffsetType
    VAR_9;

  MemoryInfo
    *VAR_10;

  register const Quantum
    *VAR_11;

  register ssize_t
    VAR_12,
    VAR_13;

  register unsigned char
    *VAR_14;

  size_t
    VAR_15,
    VAR_16,
    VAR_17;

  ssize_t
    VAR_18;

  unsigned char
    *VAR_19,
    *VAR_20;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_21);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_21);
  if (VAR_1->debug != VAR_22)
    (void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_21);
  VAR_8=OpenBlob(VAR_0,VAR_1,VAR_24,VAR_2);
  if (VAR_8 == VAR_22)
    return(VAR_8);
  VAR_17=4;
  if (LocaleCompare(VAR_0->magick,""BMP2"") == 0)
    VAR_17=2;
  else
    if (LocaleCompare(VAR_0->magick,""BMP3"") == 0)
      VAR_17=3;
  VAR_5=GetImageOption(VAR_0,""bmp:format"");
  if (VAR_5 != (char *) NULL)
    {
      (void) LogMagickEvent(VAR_25,GetMagickModule(),
          ""  Format=%s"",VAR_5);
      if (LocaleCompare(VAR_5,""bmp2"") == 0)
        VAR_17=2;
      if (LocaleCompare(VAR_5,""bmp3"") == 0)
        VAR_17=3;
      if (LocaleCompare(VAR_5,""bmp4"") == 0)
        VAR_17=4;
    }
  VAR_9=0;
  VAR_16=GetImageListLength(VAR_1);
  do
  {
    /* COMMENT_3 */
                                        
      
    if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_22)
      (void) TransformImageColorspace(VAR_1,VAR_26,VAR_2);
    (void) memset(&VAR_3,0,sizeof(VAR_3));
    VAR_3.file_size=14+12;
    if (VAR_17 > 2)
      VAR_3.file_size+=28;
    VAR_3.offset_bits=VAR_3.file_size;
    VAR_3.compression=VAR_27;
    VAR_3.red_mask=0x00ff0000U;
    VAR_3.green_mask=0x0000ff00U;
    VAR_3.blue_mask=0x000000ffU;
    VAR_3.alpha_mask=0xff000000U;
    VAR_4=VAR_28;
    if ((VAR_1->storage_class == VAR_29) && (VAR_1->colors > 256))
      (void) SetImageStorageClass(VAR_1,VAR_30,VAR_2);
    if (VAR_1->storage_class != VAR_30)
      {
        /* COMMENT_6 */
                                 
          
        VAR_3.bits_per_pixel=8;
        if (VAR_1->colors <= 2)
          VAR_3.bits_per_pixel=1;
        else
          if (VAR_1->colors <= 16)
            VAR_3.bits_per_pixel=4;
          else
            if (VAR_1->colors <= 256)
              VAR_3.bits_per_pixel=8;
        if (VAR_0->compression == VAR_31)
          VAR_3.bits_per_pixel=8;
        VAR_3.number_colors=1U << VAR_3.bits_per_pixel;
        if (VAR_1->alpha_trait != VAR_32)
          (void) SetImageStorageClass(VAR_1,VAR_30,VAR_2);
        else
          if ((size_t) VAR_3.number_colors < VAR_1->colors)
            (void) SetImageStorageClass(VAR_1,VAR_30,VAR_2);
          else
            {
              VAR_3.file_size+=3*(1UL << VAR_3.bits_per_pixel);
              VAR_3.offset_bits+=3*(1UL << VAR_3.bits_per_pixel);
              if (VAR_17 > 2)
                {
                  VAR_3.file_size+=(1UL << VAR_3.bits_per_pixel);
                  VAR_3.offset_bits+=(1UL << VAR_3.bits_per_pixel);
                }
            }
      }
    if (VAR_1->storage_class == VAR_30)
      {
        /* COMMENT_9 */
                                
          
        VAR_3.number_colors=0;
        VAR_5=GetImageOption(VAR_0,""bmp:subtype"");
        if (VAR_5 != (const char *) NULL)
        {
          if (VAR_1->alpha_trait != VAR_32)
            {
              if (LocaleNCompare(VAR_5,""ARGB4444"",8) == 0)
                {
                  VAR_4=VAR_33;
                  VAR_3.red_mask=0x00000f00U;
                  VAR_3.green_mask=0x000000f0U;
                  VAR_3.blue_mask=0x0000000fU;
                  VAR_3.alpha_mask=0x0000f000U;
                }
              else if (LocaleNCompare(VAR_5,""ARGB1555"",8) == 0)
                {
                  VAR_4=VAR_34;
                  VAR_3.red_mask=0x00007c00U;
                  VAR_3.green_mask=0x000003e0U;
                  VAR_3.blue_mask=0x0000001fU;
                  VAR_3.alpha_mask=0x00008000U;
                }
            }
          else
          {
            if (LocaleNCompare(VAR_5,""RGB555"",6) == 0)
              {
                VAR_4=VAR_35;
                VAR_3.red_mask=0x00007c00U;
                VAR_3.green_mask=0x000003e0U;
                VAR_3.blue_mask=0x0000001fU;
                VAR_3.alpha_mask=0U;
              }
            else if (LocaleNCompare(VAR_5,""RGB565"",6) == 0)
              {
                VAR_4=VAR_36;
                VAR_3.red_mask=0x0000f800U;
                VAR_3.green_mask=0x000007e0U;
                VAR_3.blue_mask=0x0000001fU;
                VAR_3.alpha_mask=0U;
              }
          }
        }
        if (VAR_4 != VAR_28)
          {
            VAR_3.bits_per_pixel=16;
            VAR_3.compression=VAR_37;
          }
        else
          {
            VAR_3.bits_per_pixel=(unsigned short) ((VAR_17 > 3) &&
               (VAR_1->alpha_trait != VAR_32) ? 32 : 24);
            VAR_3.compression=(unsigned int) ((VAR_17 > 3) &&
              (VAR_1->alpha_trait != VAR_32) ? VAR_37 : VAR_27);
            if ((VAR_17 == 3) && (VAR_1->alpha_trait != VAR_32))
              {
                VAR_5=GetImageOption(VAR_0,""bmp3:alpha"");
                if (IsStringTrue(VAR_5))
                  VAR_3.bits_per_pixel=32;
              }
          }
      }
    VAR_15=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);
    VAR_3.ba_offset=0;
    VAR_6=GetImageProfile(VAR_1,""icc"");
    VAR_7=(VAR_1->rendering_intent != VAR_38) ||
      (VAR_6 != (StringInfo *) NULL) || (VAR_1->gamma != 0.0) ?  VAR_39 :
      VAR_22;
    if (VAR_17 == 2)
      VAR_3.size=12;
    else
      if ((VAR_17 == 3) || ((VAR_1->alpha_trait == VAR_32) &&
          (VAR_7 == VAR_22)))
        {
          VAR_17=3;
          VAR_3.size=40;
        }
      else
        {
          int
            VAR_40;

          VAR_3.size=108;
          VAR_40=68;
          if ((VAR_1->rendering_intent != VAR_38) ||
              (VAR_6 != (StringInfo *) NULL))
            {
              VAR_3.size=124;
              VAR_40+=16;
            }
          VAR_3.file_size+=VAR_40;
          VAR_3.offset_bits+=VAR_40;
        }
    if (((ssize_t) VAR_1->columns != (ssize_t) ((signed int) VAR_1->columns)) ||
        ((ssize_t) VAR_1->rows != (ssize_t) ((signed int) VAR_1->rows)))
      ThrowWriterException(VAR_41,""WidthOrHeightExceedsLimit"");
    VAR_3.width=(ssize_t) VAR_1->columns;
    VAR_3.height=(ssize_t) VAR_1->rows;
    VAR_3.planes=1;
    VAR_3.image_size=(unsigned int) (VAR_15*VAR_1->rows);
    VAR_3.file_size+=VAR_3.image_size;
    VAR_3.x_pixels=75*39;
    VAR_3.y_pixels=75*39;
    switch (VAR_1->units)
    {
      case VAR_42:
      case VAR_43:
      {
        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);
        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);
        break;
      }
      case VAR_44:
      {
        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);
        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);
        break;
      }
    }
    VAR_3.colors_important=VAR_3.number_colors;
    /* COMMENT_12 */
                                        
      
    VAR_10=AcquireVirtualMemory(VAR_1->rows,
      MagickMax(VAR_15,VAR_1->columns+256UL)*sizeof(*VAR_20));
    if (VAR_10 == (MemoryInfo *) NULL)
      ThrowWriterException(VAR_45,""MemoryAllocationFailed"");
    VAR_20=(unsigned char *) GetVirtualMemoryBlob(VAR_10);
    (void) memset(VAR_20,0,(size_t) VAR_3.image_size);
    switch (VAR_3.bits_per_pixel)
    {
      case 1:
      {
        size_t
          VAR_46,
          VAR_47;

        /* COMMENT_15 */
                                                              
          
        for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
        {
          ssize_t
            VAR_48;

          VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
          if (VAR_11 == (const Quantum *) NULL)
            break;
          VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
          VAR_46=0;
          VAR_47=0;
          for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
          {
            VAR_47<<=1;
            VAR_47|=GetPixelIndex(VAR_1,VAR_11) != 0 ? 0x01 : 0x00;
            VAR_46++;
            if (VAR_46 == 8)
              {
                *VAR_14++=(unsigned char) VAR_47;
                VAR_46=0;
                VAR_47=0;
              }
             VAR_11+=GetPixelChannels(VAR_1);
           }
           if (VAR_46 != 0)
             {
               *VAR_14++=(unsigned char) (VAR_47 << (8-VAR_46));
               VAR_13++;
             }
          VAR_48=(ssize_t) (VAR_1->columns+7)/8;
          for (VAR_13=VAR_48; VAR_13 < (ssize_t) VAR_15; VAR_13++)
            *VAR_14++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
                VAR_1->rows);
              if (VAR_8 == VAR_22)
                break;
            }
        }
        break;
      }
      case 4:
      {
        unsigned int
          VAR_47,
          VAR_50;

        ssize_t
          VAR_48;

        /* COMMENT_18 */
                                                              
          
        for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
        {
          VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
          if (VAR_11 == (const Quantum *) NULL)
            break;
          VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
          VAR_50=0;
          VAR_47=0;
          for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
          {
            VAR_47<<=4;
            VAR_47|=((unsigned int) GetPixelIndex(VAR_1,VAR_11) & 0x0f);
            VAR_50++;
            if (VAR_50 == 2)
              {
                *VAR_14++=(unsigned char) VAR_47;
                VAR_50=0;
                VAR_47=0;
              }
            VAR_11+=GetPixelChannels(VAR_1);
          }
          if (VAR_50 != 0)
            {
              *VAR_14++=(unsigned char) (VAR_47 << 4);
              VAR_13++;
            }
          VAR_48=(ssize_t) (VAR_1->columns+1)/2;
          for (VAR_13=VAR_48; VAR_13 < (ssize_t) VAR_15; VAR_13++)
            *VAR_14++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
                VAR_1->rows);
              if (VAR_8 == VAR_22)
                break;
            }
        }
        break;
      }
      case 8:
      {
        /* COMMENT_21 */
                                                  
          
        for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
        {
          VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
          if (VAR_11 == (const Quantum *) NULL)
            break;
          VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
          for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
          {
            *VAR_14++=(unsigned char) GetPixelIndex(VAR_1,VAR_11);
            VAR_11+=GetPixelChannels(VAR_1);
          }
          for ( ; VAR_13 < (ssize_t) VAR_15; VAR_13++)
            *VAR_14++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
                VAR_1->rows);
              if (VAR_8 == VAR_22)
                break;
            }
        }
        break;
      }
      case 16:
      {
        /* COMMENT_24 */
                                                   
          
        for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
        {
          VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
          if (VAR_11 == (const Quantum *) NULL)
            break;
          VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
          for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
          {
            unsigned short
              VAR_51;

            VAR_51=0;
            if (VAR_4 == VAR_33)
              {
                VAR_51=(unsigned short) (ScaleQuantumToAny(
                  GetPixelAlpha(VAR_1,VAR_11),15) << 12);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelRed(VAR_1,VAR_11),15) << 8);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelGreen(VAR_1,VAR_11),15) << 4);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelBlue(VAR_1,VAR_11),15));
              }
            else if (VAR_4 == VAR_36)
              {
                VAR_51=(unsigned short) (ScaleQuantumToAny(
                  GetPixelRed(VAR_1,VAR_11),31) << 11);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelGreen(VAR_1,VAR_11),63) << 5);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelBlue(VAR_1,VAR_11),31));
              }
            else
              {
                if (VAR_4 == VAR_34)
                  VAR_51=(unsigned short) (ScaleQuantumToAny(
                    GetPixelAlpha(VAR_1,VAR_11),1) << 15);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelRed(VAR_1,VAR_11),31) << 10);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelGreen(VAR_1,VAR_11),31) << 5);
                VAR_51|=(unsigned short) (ScaleQuantumToAny(
                  GetPixelBlue(VAR_1,VAR_11),31));
              }
            *((unsigned short *) VAR_14)=VAR_51;
            VAR_14+=2;
            VAR_11+=GetPixelChannels(VAR_1);
          }
          for (VAR_13=2L*(ssize_t) VAR_1->columns; VAR_13 < (ssize_t) VAR_15; VAR_13++)
            *VAR_14++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
                VAR_1->rows);
              if (VAR_8 == VAR_22)
                break;
            }
        }
        break;
      }
      case 24:
      {
        /* COMMENT_27 */
                                                   
          
        for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
        {
          VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
          if (VAR_11 == (const Quantum *) NULL)
            break;
          VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
          for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
          {
            *VAR_14++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_11));
            *VAR_14++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_11));
            *VAR_14++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_11));
            VAR_11+=GetPixelChannels(VAR_1);
          }
          for (VAR_13=3L*(ssize_t) VAR_1->columns; VAR_13 < (ssize_t) VAR_15; VAR_13++)
            *VAR_14++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
                VAR_1->rows);
              if (VAR_8 == VAR_22)
                break;
            }
        }
        break;
      }
      case 32:
      {
        /* COMMENT_30 */
                                                       
          
        for (VAR_18=0; VAR_18 < (ssize_t) VAR_1->rows; VAR_18++)
        {
          VAR_11=GetVirtualPixels(VAR_1,0,VAR_18,VAR_1->columns,1,VAR_2);
          if (VAR_11 == (const Quantum *) NULL)
            break;
          VAR_14=VAR_20+(VAR_1->rows-VAR_18-1)*VAR_15;
          for (VAR_13=0; VAR_13 < (ssize_t) VAR_1->columns; VAR_13++)
          {
            *VAR_14++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_11));
            *VAR_14++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_11));
            *VAR_14++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_11));
            *VAR_14++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_11));
            VAR_11+=GetPixelChannels(VAR_1);
          }
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_8=SetImageProgress(VAR_1,VAR_49,(MagickOffsetType) VAR_18,
                VAR_1->rows);
              if (VAR_8 == VAR_22)
                break;
            }
        }
        break;
      }
    }
    if ((VAR_17 > 2) && (VAR_3.bits_per_pixel == 8))
      if (VAR_0->compression != VAR_52)
        {
          MemoryInfo
            *VAR_53;

          /* COMMENT_33 */
                                                     
            
          VAR_53=AcquireVirtualMemory((size_t) (2*(VAR_15+2)+2),
            (VAR_1->rows+2)*sizeof(*VAR_20));
          if (VAR_53 == (MemoryInfo *) NULL)
            {
              VAR_10=RelinquishVirtualMemory(VAR_10);
              ThrowWriterException(VAR_45,""MemoryAllocationFailed"");
            }
          VAR_19=(unsigned char *) GetVirtualMemoryBlob(VAR_53);
          VAR_3.file_size-=VAR_3.image_size;
          VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_15,
            VAR_20,VAR_19);
          VAR_3.file_size+=VAR_3.image_size;
          VAR_10=RelinquishVirtualMemory(VAR_10);
          VAR_10=VAR_53;
          VAR_20=VAR_19;
          VAR_3.compression=VAR_54;
        }
    /* COMMENT_36 */
                                                          
      
    if (VAR_1->debug != VAR_22)
      {
        (void) LogMagickEvent(VAR_25,GetMagickModule(),
          ""   Writing BMP version %.20g datastream"",(double) VAR_17);
        if (VAR_1->storage_class == VAR_30)
          (void) LogMagickEvent(VAR_25,GetMagickModule(),
            ""   Storage class=DirectClass"");
        else
          (void) LogMagickEvent(VAR_25,GetMagickModule(),
            ""   Storage class=PseudoClass"");
        (void) LogMagickEvent(VAR_25,GetMagickModule(),
          ""   Image depth=%.20g"",(double) VAR_1->depth);
        if (VAR_1->alpha_trait != VAR_32)
          (void) LogMagickEvent(VAR_25,GetMagickModule(),
            ""   Matte=True"");
        else
          (void) LogMagickEvent(VAR_25,GetMagickModule(),
            ""   Matte=MagickFalse"");
        (void) LogMagickEvent(VAR_25,GetMagickModule(),
          ""   BMP bits_per_pixel=%.20g"",(double) VAR_3.bits_per_pixel);
        switch ((int) VAR_3.compression)
        {
           case VAR_27:
           {
             (void) LogMagickEvent(VAR_25,GetMagickModule(),
               ""   Compression=BI_RGB"");
             break;
           }
           case VAR_54:
           {
             (void) LogMagickEvent(VAR_25,GetMagickModule(),
               ""   Compression=BI_RLE8"");
             break;
           }
           case VAR_37:
           {
             (void) LogMagickEvent(VAR_25,GetMagickModule(),
               ""   Compression=BI_BITFIELDS"");
             break;
           }
           default:
           {
             (void) LogMagickEvent(VAR_25,GetMagickModule(),
               ""   Compression=UNKNOWN (%u)"",VAR_3.compression);
             break;
           }
        }
        if (VAR_3.number_colors == 0)
          (void) LogMagickEvent(VAR_25,GetMagickModule(),
            ""   Number_colors=unspecified"");
        else
          (void) LogMagickEvent(VAR_25,GetMagickModule(),
            ""   Number_colors=%u"",VAR_3.number_colors);
      }
    (void) WriteBlob(VAR_1,2,(unsigned char *) ""BM"");
    (void) WriteBlobLSBLong(VAR_1,VAR_3.file_size);
    (void) WriteBlobLSBLong(VAR_1,VAR_3.ba_offset);  /* COMMENT_39 */
    (void) WriteBlobLSBLong(VAR_1,VAR_3.offset_bits);
    if (VAR_17 == 2)
      {
        /* COMMENT_40 */
                                                
          
        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);
        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.width);
        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.height);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
      }
    else
      {
        /* COMMENT_43 */
                                                 
          
        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);
        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.width);
        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.height);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.compression);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);
      }
    if ((VAR_17 > 3) && ((VAR_1->alpha_trait != VAR_32) ||
        (VAR_7 != VAR_22)))
      {
        /* COMMENT_46 */
                                                              
          
        (void) WriteBlobLSBLong(VAR_1,VAR_3.red_mask);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.green_mask);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.blue_mask);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.alpha_mask);
        (void) WriteBlobLSBLong(VAR_1,0x73524742U);  /* COMMENT_49 */
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.red_primary.x*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.red_primary.y*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          ((1.000f-(VAR_1->chromaticity.red_primary.x+
          VAR_1->chromaticity.red_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.green_primary.x*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.green_primary.y*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          ((1.000f-(VAR_1->chromaticity.green_primary.x+
          VAR_1->chromaticity.green_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.blue_primary.x*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.blue_primary.y*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          ((1.000f-(VAR_1->chromaticity.blue_primary.x+
          VAR_1->chromaticity.blue_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_3.gamma_scale.x*0x10000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_3.gamma_scale.y*0x10000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_3.gamma_scale.z*0x10000));
        if ((VAR_1->rendering_intent != VAR_38) ||
            (VAR_6 != (StringInfo *) NULL))
          {
            ssize_t
              VAR_55;

            switch ((int) VAR_1->rendering_intent)
            {
              case VAR_56:
              {
                VAR_55=VAR_57;
                break;
              }
              case VAR_58:
              {
                VAR_55=VAR_59;
                break;
              }
              case VAR_60:
              {
                VAR_55=VAR_61;
                break;
              }
              case VAR_62:
              {
                VAR_55=VAR_63;
                break;
              }
              default:
              {
                VAR_55=0;
                break;
              }
            }
            (void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_55);
            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_50 */
            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_51 */
            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_52 */
          }
      }
    if (VAR_1->storage_class == VAR_29)
      {
        unsigned char
          *VAR_64;

        /* COMMENT_53 */
                                
          
        if (VAR_1->debug != VAR_22)
          (void) LogMagickEvent(VAR_25,GetMagickModule(),
            ""  Colormap: %.20g entries"",(double) VAR_1->colors);
        VAR_64=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
          VAR_3.bits_per_pixel),4*sizeof(*VAR_64));
        if (VAR_64 == (unsigned char *) NULL)
          ThrowWriterException(VAR_45,""MemoryAllocationFailed"");
        VAR_14=VAR_64;
        for (VAR_12=0; VAR_12 < (ssize_t) MagickMin((ssize_t) VAR_1->colors,(ssize_t) VAR_3.number_colors); VAR_12++)
        {
          *VAR_14++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_12].blue));
          *VAR_14++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_12].green));
          *VAR_14++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_12].red));
          if (VAR_17 > 2)
            *VAR_14++=(unsigned char) 0x0;
        }
        for ( ; VAR_12 < (ssize_t) (1UL << VAR_3.bits_per_pixel); VAR_12++)
        {
          *VAR_14++=(unsigned char) 0x00;
          *VAR_14++=(unsigned char) 0x00;
          *VAR_14++=(unsigned char) 0x00;
          if (VAR_17 > 2)
            *VAR_14++=(unsigned char) 0x00;
        }
        if (VAR_17 <= 2)
          (void) WriteBlob(VAR_1,(size_t) (3*(1L << VAR_3.bits_per_pixel)),
            VAR_64);
        else
          (void) WriteBlob(VAR_1,(size_t) (4*(1L << VAR_3.bits_per_pixel)),
            VAR_64);
        VAR_64=(unsigned char *) RelinquishMagickMemory(VAR_64);
      }
    if (VAR_1->debug != VAR_22)
      (void) LogMagickEvent(VAR_25,GetMagickModule(),
        ""  Pixels:  %u bytes"",VAR_3.image_size);
    (void) WriteBlob(VAR_1,(size_t) VAR_3.image_size,VAR_20);
    VAR_10=RelinquishVirtualMemory(VAR_10);
    if (GetNextImageInList(VAR_1) == (Image *) NULL)
      break;
    VAR_1=SyncNextImageInList(VAR_1);
    VAR_8=SetImageProgress(VAR_1,VAR_65,VAR_9++,VAR_16);
    if (VAR_8 == VAR_22)
      break;
  } while (VAR_0->adjoin != VAR_22);
  (void) CloseBlob(VAR_1);
  return(VAR_39);
}",ImageMagick/ae04fa4be910255e5d363edebd77adeee99a525d/bmp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -260,8 +260,8 @@
     /*
       Convert MIFF to BMP raster pixels.
     */
-    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,
-      sizeof(*pixels));
+    pixel_info=AcquireVirtualMemory(image->rows,
+      MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);","{'deleted_lines': ['    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,', '      sizeof(*pixels));'], 'added_lines': ['    pixel_info=AcquireVirtualMemory(image->rows,', '      MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));']}",True,"In ImageMagick 7.0.8-3 Q16, ReadBMPImage and WriteBMPImage in coders/bmp.c allow attackers to cause an out of bounds write via a crafted file.",8.8,HIGH,2,test,2018-06-20T00:27:19Z,2
CVE-2018-10932,['CWE-117'],AV:A/AC:L/Au:N/C:N/I:P/A:N,0.0,intel/openlldp,"basman_clif: print the OID properly

When invoking the lldp tool to view the management information, the display
for the OID is printed as the actual binary bits, rather than the
OID dotted-notation form.

This change will display the OID as expected.

Signed-off-by: Aaron Conole <aconole@redhat.com>",cf3f54d1883e5bc23e4c4006a63e1dde88684013,https://github.com/intel/openlldp/commit/cf3f54d1883e5bc23e4c4006a63e1dde88684013,lldp_basman_clif.c,print_mng_addr,"void print_mng_addr(u16 len, char *info)
{
u8 addrlen;
u8 addrnum;
u8 iftype;
u8 oidlen;
u32 ifnum;
u32 offset;
int i;
char buf[132];
if (len < 9 || len > 167) {
printf(""Bad Management Address TLV: %*.*s\n"",
2*len, 2*len, info);
return;
}
hexstr2bin(info, (u8 *)&addrlen, sizeof(addrlen));
hexstr2bin(info+2, (u8 *)&addrnum, sizeof(addrnum));
switch(addrnum) {
case MANADDR_ALL802:
if (addrlen != 1 + 6)
return;
printf(""MAC: "");
for (i = 0; i < 12; i+=2) {
printf(""%2.2s"", info + 4 + i);
if (i < 10)
printf("":"");
else
printf(""\n"");
}
break;
case MANADDR_IPV4:
if (addrlen == 5) {
struct in_addr addr;
hexstr2bin(info+4, (u8 *)&addr, sizeof(addr));
inet_ntop(AF_INET, (void *)&addr, buf,
sizeof(buf));
printf(""IPv4: %s\n"", buf);
} else {
printf(""Bad IPv4: %*.*s\n"",
2*(addrlen-2), 2*(addrlen-2), info+4);
}
break;
case MANADDR_IPV6:
if (addrlen == 17) {
struct in6_addr addr;
hexstr2bin(info+4, (u8 *)&addr, sizeof(addr));
memset(buf, 0, sizeof(buf));
inet_ntop(AF_INET6, (void *)&addr, buf,
sizeof(buf));
printf(""IPv6: %s\n"", buf);
} else {
printf(""Bad IPv6: %*.*s\n"",
2*(addrlen-2), 2*(addrlen-2), info+4);
}
break;
default:
printf(""Network Address Type %d: %*.*s\n"", addrnum,
2*(addrlen-1), 2*(addrlen-1), info+4);
break;
}
offset = 2*(1+addrlen);
hexstr2bin(info+offset, (u8 *)&iftype, sizeof(iftype));
offset += 2;
hexstr2bin(info+offset, (u8 *)&ifnum, sizeof(ifnum));
offset += 2*sizeof(u32);
ifnum = ntohl(ifnum);
switch (iftype) {
case IFNUM_UNKNOWN:
printf(""\tUnknown interface subtype: "");
break;
case IFNUM_IFINDEX:
printf(""\tIfindex: "");
break;
case IFNUM_SYS_PORT_NUM:
printf(""\tSystem port number: "");
break;
default:
printf(""\tBad interface numbering subtype: "");
break;
}
printf(""%d\n"", ifnum);
hexstr2bin(info+offset, (u8 *)&oidlen, sizeof(oidlen));
offset += 2;
if (oidlen && oidlen <= 128) {
memset(buf, 0, sizeof(buf));
if (hexstr2bin(info+offset, (u8 *)&buf, oidlen))
printf(""\tOID: Error parsing OID\n"");
else
printf(""\tOID: %s\n"", buf);
} else if (oidlen > 128) {
printf(""\tOID: Invalid length = %d\n"", oidlen);
}
}","void print_mng_addr(u16 VAR_0, char *VAR_1)
{
u8 VAR_2;
u8 VAR_3;
u8 VAR_4;
u8 VAR_5;
u32 VAR_6;
u32 VAR_7;
int VAR_8;
char VAR_9[132];
if (VAR_0 < 9 || VAR_0 > 167) {
printf(""Bad Management Address TLV: %*.*s\n"",
2*VAR_0, 2*VAR_0, VAR_1);
return;
}
hexstr2bin(VAR_1, (u8 *)&VAR_2, sizeof(VAR_2));
hexstr2bin(VAR_1+2, (u8 *)&VAR_3, sizeof(VAR_3));
switch(VAR_3) {
case VAR_10:
if (VAR_2 != 1 + 6)
return;
printf(""MAC: "");
for (VAR_8 = 0; VAR_8 < 12; VAR_8+=2) {
printf(""%2.2s"", VAR_1 + 4 + VAR_8);
if (VAR_8 < 10)
printf("":"");
else
printf(""\n"");
}
break;
case VAR_11:
if (VAR_2 == 5) {
struct in_addr VAR_12;
hexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));
inet_ntop(VAR_13, (void *)&VAR_12, VAR_9,
sizeof(VAR_9));
printf(""IPv4: %s\n"", VAR_9);
} else {
printf(""Bad IPv4: %*.*s\n"",
2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);
}
break;
case VAR_14:
if (VAR_2 == 17) {
struct in6_addr VAR_12;
hexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));
memset(VAR_9, 0, sizeof(VAR_9));
inet_ntop(VAR_15, (void *)&VAR_12, VAR_9,
sizeof(VAR_9));
printf(""IPv6: %s\n"", VAR_9);
} else {
printf(""Bad IPv6: %*.*s\n"",
2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);
}
break;
default:
printf(""Network Address Type %d: %*.*s\n"", VAR_3,
2*(VAR_2-1), 2*(VAR_2-1), VAR_1+4);
break;
}
VAR_7 = 2*(1+VAR_2);
hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_4, sizeof(VAR_4));
VAR_7 += 2;
hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_6, sizeof(VAR_6));
VAR_7 += 2*sizeof(u32);
VAR_6 = ntohl(VAR_6);
switch (VAR_4) {
case VAR_16:
printf(""\tUnknown interface subtype: "");
break;
case VAR_17:
printf(""\tIfindex: "");
break;
case VAR_18:
printf(""\tSystem port number: "");
break;
default:
printf(""\tBad interface numbering subtype: "");
break;
}
printf(""%d\n"", VAR_6);
hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_5, sizeof(VAR_5));
VAR_7 += 2;
if (VAR_5 && VAR_5 <= 128) {
memset(VAR_9, 0, sizeof(VAR_9));
if (hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_9, VAR_5))
printf(""\tOID: Error parsing OID\n"");
else
printf(""\tOID: %s\n"", VAR_9);
} else if (VAR_5 > 128) {
printf(""\tOID: Invalid length = %d\n"", VAR_5);
}
}",intel/openlldp/cf3f54d1883e5bc23e4c4006a63e1dde88684013/lldp_basman_clif.c/vul/before/0.json,"void print_mng_addr(u16 len, char *info)
{
	u8 addrlen;
	u8 addrnum;
	u8 iftype;
	u8 oidlen;
	u32 ifnum;
	u32 offset;
	int i;
	char buf[132];

	if (len < 9 || len > 167) {
		printf(""Bad Management Address TLV: %*.*s\n"",
			2*len, 2*len, info);
		return;
	}

	hexstr2bin(info, (u8 *)&addrlen, sizeof(addrlen));
	hexstr2bin(info+2, (u8 *)&addrnum, sizeof(addrnum));

	switch(addrnum) {
	case MANADDR_ALL802:
		if (addrlen != 1 + 6)
			return;
		printf(""MAC: "");
		for (i = 0; i < 12; i+=2) {
			printf(""%2.2s"", info + 4 + i);
			if (i < 10)
				printf("":"");
			else
				printf(""\n"");
		}
		break;
	case MANADDR_IPV4:
		if (addrlen == 5) {
			struct in_addr addr;
			hexstr2bin(info+4, (u8 *)&addr, sizeof(addr));
			inet_ntop(AF_INET, (void *)&addr, buf,
				  sizeof(buf));
			printf(""IPv4: %s\n"", buf);
		} else {
			printf(""Bad IPv4: %*.*s\n"",
			       2*(addrlen-2), 2*(addrlen-2), info+4);
		}
		break;
	case MANADDR_IPV6:
		if (addrlen == 17) {
			struct in6_addr addr;
			hexstr2bin(info+4, (u8 *)&addr, sizeof(addr));
			memset(buf, 0, sizeof(buf));
			inet_ntop(AF_INET6, (void *)&addr, buf,
				  sizeof(buf));
			printf(""IPv6: %s\n"", buf);
		} else {
			printf(""Bad IPv6: %*.*s\n"",
			       2*(addrlen-2), 2*(addrlen-2), info+4);
		}
		break;
	default:
		printf(""Network Address Type %d: %*.*s\n"", addrnum,
		       2*(addrlen-1), 2*(addrlen-1), info+4);
		break;
	}

	offset = 2*(1+addrlen);
	hexstr2bin(info+offset, (u8 *)&iftype, sizeof(iftype));
	offset += 2;
	hexstr2bin(info+offset, (u8 *)&ifnum, sizeof(ifnum));
	offset += 2*sizeof(u32);
	ifnum = ntohl(ifnum);

	switch (iftype) {
	case IFNUM_UNKNOWN:
		printf(""\tUnknown interface subtype: "");
		break;
	case IFNUM_IFINDEX:
		printf(""\tIfindex: "");
		break;
	case IFNUM_SYS_PORT_NUM:
		printf(""\tSystem port number: "");
		break;
	default:
		printf(""\tBad interface numbering subtype: "");
		break;
	}
	printf(""%d\n"", ifnum);

	hexstr2bin(info+offset, (u8 *)&oidlen, sizeof(oidlen));
	offset += 2;

	if (oidlen && oidlen <= 128) {
		memset(buf, 0, sizeof(buf));
		if (hexstr2bin(info+offset, (u8 *)&buf, oidlen))
			printf(""\tOID: Error parsing OID\n"");
		else {
			printf(""\tOID: 0."");
			for (i = 0; i < oidlen; ++i) {
				printf(""%d"", buf[i]);
				if (i != (oidlen - 1))
					printf(""."");
			}
			printf(""\n"");
		}
	} else if (oidlen > 128) {
		printf(""\tOID: Invalid length = %d\n"", oidlen);
	}
}","void print_mng_addr(u16 VAR_0, char *VAR_1)
{
	u8 VAR_2;
	u8 VAR_3;
	u8 VAR_4;
	u8 VAR_5;
	u32 VAR_6;
	u32 VAR_7;
	int VAR_8;
	char VAR_9[132];

	if (VAR_0 < 9 || VAR_0 > 167) {
		printf(""Bad Management Address TLV: %*.*s\n"",
			2*VAR_0, 2*VAR_0, VAR_1);
		return;
	}

	hexstr2bin(VAR_1, (u8 *)&VAR_2, sizeof(VAR_2));
	hexstr2bin(VAR_1+2, (u8 *)&VAR_3, sizeof(VAR_3));

	switch(VAR_3) {
	case VAR_10:
		if (VAR_2 != 1 + 6)
			return;
		printf(""MAC: "");
		for (VAR_8 = 0; VAR_8 < 12; VAR_8+=2) {
			printf(""%2.2s"", VAR_1 + 4 + VAR_8);
			if (VAR_8 < 10)
				printf("":"");
			else
				printf(""\n"");
		}
		break;
	case VAR_11:
		if (VAR_2 == 5) {
			struct in_addr VAR_12;
			hexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));
			inet_ntop(VAR_13, (void *)&VAR_12, VAR_9,
				  sizeof(VAR_9));
			printf(""IPv4: %s\n"", VAR_9);
		} else {
			printf(""Bad IPv4: %*.*s\n"",
			       2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);
		}
		break;
	case VAR_14:
		if (VAR_2 == 17) {
			struct in6_addr VAR_12;
			hexstr2bin(VAR_1+4, (u8 *)&VAR_12, sizeof(VAR_12));
			memset(VAR_9, 0, sizeof(VAR_9));
			inet_ntop(VAR_15, (void *)&VAR_12, VAR_9,
				  sizeof(VAR_9));
			printf(""IPv6: %s\n"", VAR_9);
		} else {
			printf(""Bad IPv6: %*.*s\n"",
			       2*(VAR_2-2), 2*(VAR_2-2), VAR_1+4);
		}
		break;
	default:
		printf(""Network Address Type %d: %*.*s\n"", VAR_3,
		       2*(VAR_2-1), 2*(VAR_2-1), VAR_1+4);
		break;
	}

	VAR_7 = 2*(1+VAR_2);
	hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_4, sizeof(VAR_4));
	VAR_7 += 2;
	hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_6, sizeof(VAR_6));
	VAR_7 += 2*sizeof(u32);
	VAR_6 = ntohl(VAR_6);

	switch (VAR_4) {
	case VAR_16:
		printf(""\tUnknown interface subtype: "");
		break;
	case VAR_17:
		printf(""\tIfindex: "");
		break;
	case VAR_18:
		printf(""\tSystem port number: "");
		break;
	default:
		printf(""\tBad interface numbering subtype: "");
		break;
	}
	printf(""%d\n"", VAR_6);

	hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_5, sizeof(VAR_5));
	VAR_7 += 2;

	if (VAR_5 && VAR_5 <= 128) {
		memset(VAR_9, 0, sizeof(VAR_9));
		if (hexstr2bin(VAR_1+VAR_7, (u8 *)&VAR_9, VAR_5))
			printf(""\tOID: Error parsing OID\n"");
		else {
			printf(""\tOID: 0."");
			for (VAR_8 = 0; VAR_8 < VAR_5; ++VAR_8) {
				printf(""%d"", VAR_9[VAR_8]);
				if (VAR_8 != (VAR_5 - 1))
					printf(""."");
			}
			printf(""\n"");
		}
	} else if (VAR_5 > 128) {
		printf(""\tOID: Invalid length = %d\n"", VAR_5);
	}
}",intel/openlldp/cf3f54d1883e5bc23e4c4006a63e1dde88684013/lldp_basman_clif.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -92,8 +92,15 @@
 		memset(buf, 0, sizeof(buf));
 		if (hexstr2bin(info+offset, (u8 *)&buf, oidlen))
 			printf(""\tOID: Error parsing OID\n"");
-		else
-			printf(""\tOID: %s\n"", buf);
+		else {
+			printf(""\tOID: 0."");
+			for (i = 0; i < oidlen; ++i) {
+				printf(""%d"", buf[i]);
+				if (i != (oidlen - 1))
+					printf(""."");
+			}
+			printf(""\n"");
+		}
 	} else if (oidlen > 128) {
 		printf(""\tOID: Invalid length = %d\n"", oidlen);
 	}","{'deleted_lines': ['\t\telse', '\t\t\tprintf(""\\tOID: %s\\n"", buf);'], 'added_lines': ['\t\telse {', '\t\t\tprintf(""\\tOID: 0."");', '\t\t\tfor (i = 0; i < oidlen; ++i) {', '\t\t\t\tprintf(""%d"", buf[i]);', '\t\t\t\tif (i != (oidlen - 1))', '\t\t\t\t\tprintf(""."");', '\t\t\t}', '\t\t\tprintf(""\\n"");', '\t\t}']}",True,"lldptool version 1.0.1 and older can print a raw, unsanitized attacker controlled buffer when mngAddr information is displayed. This may allow an attacker to inject shell control characters into the buffer and impact the behavior of the terminal.",4.3,MEDIUM,1,test,2018-06-21T17:28:48Z,2
CVE-2018-12910,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,GNOME/libsoup,"cookie-jar: bail if hostname is an empty string

There are several other ways to fix the problem with this function, but
skipping over all of the code is probably the simplest.

Fixes #3",db2b0d5809d5f8226d47312b40992cadbcde439f,https://github.com/GNOME/libsoup/commit/db2b0d5809d5f8226d47312b40992cadbcde439f,libsoup/soup-cookie-jar.c,get_cookies,"static GSList *
get_cookies (SoupCookieJar *jar, SoupURI *uri, gboolean for_http, gboolean copy_cookies)
{
SoupCookieJarPrivate *priv;
GSList *cookies, *domain_cookies;
char *domain, *cur, *next_domain;
GSList *new_head, *cookies_to_remove = NULL, *p;
priv = soup_cookie_jar_get_instance_private (jar);
if (!uri->host)
return NULL;
cookies = NULL;
domain = cur = g_strdup_printf ("".%s"", uri->host);
next_domain = domain + 1;
do {
new_head = domain_cookies = g_hash_table_lookup (priv->domains, cur);
while (domain_cookies) {
GSList *next = domain_cookies->next;
SoupCookie *cookie = domain_cookies->data;
if (cookie->expires && soup_date_is_past (cookie->expires)) {
cookies_to_remove = g_slist_append (cookies_to_remove,
cookie);
new_head = g_slist_delete_link (new_head, domain_cookies);
g_hash_table_insert (priv->domains,
g_strdup (cur),
new_head);
} else if (soup_cookie_applies_to_uri (cookie, uri) &&
(for_http || !cookie->http_only))
cookies = g_slist_append (cookies, copy_cookies ? soup_cookie_copy (cookie) : cookie);
domain_cookies = next;
}
cur = next_domain;
if (cur)
next_domain = strchr (cur + 1, '.');
} while (cur);
g_free (domain);
for (p = cookies_to_remove; p; p = p->next) {
SoupCookie *cookie = p->data;
soup_cookie_jar_changed (jar, cookie, NULL);
soup_cookie_free (cookie);
}
g_slist_free (cookies_to_remove);
return g_slist_sort_with_data (cookies, compare_cookies, jar);
}","static GSList *
get_cookies (SoupCookieJar *VAR_0, SoupURI *VAR_1, gboolean VAR_2, gboolean VAR_3)
{
SoupCookieJarPrivate *VAR_4;
GSList *VAR_5, *VAR_6;
char *VAR_7, *VAR_8, *VAR_9;
GSList *VAR_10, *VAR_11 = NULL, *VAR_12;
VAR_4 = soup_cookie_jar_get_instance_private (VAR_0);
if (!VAR_1->host)
return NULL;
VAR_5 = NULL;
VAR_7 = VAR_8 = g_strdup_printf ("".%s"", VAR_1->host);
VAR_9 = VAR_7 + 1;
do {
VAR_10 = VAR_6 = g_hash_table_lookup (VAR_4->domains, VAR_8);
while (VAR_6) {
GSList *VAR_13 = VAR_6->next;
SoupCookie *VAR_14 = VAR_6->data;
if (VAR_14->expires && soup_date_is_past (VAR_14->expires)) {
VAR_11 = g_slist_append (VAR_11,
VAR_14);
VAR_10 = g_slist_delete_link (VAR_10, VAR_6);
g_hash_table_insert (VAR_4->domains,
g_strdup (VAR_8),
VAR_10);
} else if (soup_cookie_applies_to_uri (VAR_14, VAR_1) &&
(VAR_2 || !VAR_14->http_only))
VAR_5 = g_slist_append (VAR_5, VAR_3 ? soup_cookie_copy (VAR_14) : VAR_14);
VAR_6 = VAR_13;
}
VAR_8 = VAR_9;
if (VAR_8)
VAR_9 = strchr (VAR_8 + 1, '.');
} while (VAR_8);
g_free (VAR_7);
for (VAR_12 = VAR_11; VAR_12; VAR_12 = VAR_12->next) {
SoupCookie *VAR_14 = VAR_12->data;
soup_cookie_jar_changed (VAR_0, VAR_14, NULL);
soup_cookie_free (VAR_14);
}
g_slist_free (VAR_11);
return g_slist_sort_with_data (VAR_5, VAR_15, VAR_0);
}",GNOME/libsoup/db2b0d5809d5f8226d47312b40992cadbcde439f/soup-cookie-jar.c/vul/before/0.json,"static GSList *
get_cookies (SoupCookieJar *jar, SoupURI *uri, gboolean for_http, gboolean copy_cookies)
{
	SoupCookieJarPrivate *priv;
	GSList *cookies, *domain_cookies;
	char *domain, *cur, *next_domain;
	GSList *new_head, *cookies_to_remove = NULL, *p;

	priv = soup_cookie_jar_get_instance_private (jar);

	if (!uri->host || !uri->host[0])
		return NULL;

	/* The logic here is a little weird, but the plan is that if
	 * uri->host is ""www.foo.com"", we will end up looking up
	 * cookies for "".www.foo.com"", ""www.foo.com"", "".foo.com"", and
	 * "".com"", in that order. (Logic stolen from Mozilla.)
	 */
	cookies = NULL;
	domain = cur = g_strdup_printf ("".%s"", uri->host);
	next_domain = domain + 1;
	do {
		new_head = domain_cookies = g_hash_table_lookup (priv->domains, cur);
		while (domain_cookies) {
			GSList *next = domain_cookies->next;
			SoupCookie *cookie = domain_cookies->data;

			if (cookie->expires && soup_date_is_past (cookie->expires)) {
				cookies_to_remove = g_slist_append (cookies_to_remove,
								    cookie);
				new_head = g_slist_delete_link (new_head, domain_cookies);
				g_hash_table_insert (priv->domains,
						     g_strdup (cur),
						     new_head);
			} else if (soup_cookie_applies_to_uri (cookie, uri) &&
				   (for_http || !cookie->http_only))
				cookies = g_slist_append (cookies, copy_cookies ? soup_cookie_copy (cookie) : cookie);

			domain_cookies = next;
		}
		cur = next_domain;
		if (cur)
			next_domain = strchr (cur + 1, '.');
	} while (cur);
	g_free (domain);

	for (p = cookies_to_remove; p; p = p->next) {
		SoupCookie *cookie = p->data;

		soup_cookie_jar_changed (jar, cookie, NULL);
		soup_cookie_free (cookie);
	}
	g_slist_free (cookies_to_remove);

	return g_slist_sort_with_data (cookies, compare_cookies, jar);
}","static GSList *
get_cookies (SoupCookieJar *VAR_0, SoupURI *VAR_1, gboolean VAR_2, gboolean VAR_3)
{
	SoupCookieJarPrivate *VAR_4;
	GSList *VAR_5, *VAR_6;
	char *VAR_7, *VAR_8, *VAR_9;
	GSList *VAR_10, *VAR_11 = NULL, *VAR_12;

	VAR_4 = soup_cookie_jar_get_instance_private (VAR_0);

	if (!VAR_1->host || !VAR_1->host[0])
		return NULL;

	/* COMMENT_0 */
                                                         
                                                              
                                                       
    
	VAR_5 = NULL;
	VAR_7 = VAR_8 = g_strdup_printf ("".%s"", VAR_1->host);
	VAR_9 = VAR_7 + 1;
	do {
		VAR_10 = VAR_6 = g_hash_table_lookup (VAR_4->domains, VAR_8);
		while (VAR_6) {
			GSList *VAR_13 = VAR_6->next;
			SoupCookie *VAR_14 = VAR_6->data;

			if (VAR_14->expires && soup_date_is_past (VAR_14->expires)) {
				VAR_11 = g_slist_append (VAR_11,
								    VAR_14);
				VAR_10 = g_slist_delete_link (VAR_10, VAR_6);
				g_hash_table_insert (VAR_4->domains,
						     g_strdup (VAR_8),
						     VAR_10);
			} else if (soup_cookie_applies_to_uri (VAR_14, VAR_1) &&
				   (VAR_2 || !VAR_14->http_only))
				VAR_5 = g_slist_append (VAR_5, VAR_3 ? soup_cookie_copy (VAR_14) : VAR_14);

			VAR_6 = VAR_13;
		}
		VAR_8 = VAR_9;
		if (VAR_8)
			VAR_9 = strchr (VAR_8 + 1, '.');
	} while (VAR_8);
	g_free (VAR_7);

	for (VAR_12 = VAR_11; VAR_12; VAR_12 = VAR_12->next) {
		SoupCookie *VAR_14 = VAR_12->data;

		soup_cookie_jar_changed (VAR_0, VAR_14, NULL);
		soup_cookie_free (VAR_14);
	}
	g_slist_free (VAR_11);

	return g_slist_sort_with_data (VAR_5, VAR_15, VAR_0);
}",GNOME/libsoup/db2b0d5809d5f8226d47312b40992cadbcde439f/soup-cookie-jar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 
 	priv = soup_cookie_jar_get_instance_private (jar);
 
-	if (!uri->host)
+	if (!uri->host || !uri->host[0])
 		return NULL;
 
 	/* The logic here is a little weird, but the plan is that if","{'deleted_lines': ['\tif (!uri->host)'], 'added_lines': ['\tif (!uri->host || !uri->host[0])']}",True,The get_cookies function in soup-cookie-jar.c in libsoup 2.63.2 allows attackers to have unspecified impact via an empty hostname.,9.8,CRITICAL,3,test,2018-06-25T00:46:19Z,2
CVE-2018-12893,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0.0,xen-project/xen,"x86: Refine checks in #DB handler for faulting conditions

One of the fix for XSA-260 (c/s 75d6828bc2 ""x86/traps: Fix handling of #DB
exceptions in hypervisor context"") added some safety checks to help avoid
livelocks of #DB faults.

While a General Detect #DB exception does have fault semantics, hardware
clears %dr7.gd on entry to the handler, meaning that it is actually safe to
return to.  Furthermore, %dr6.gd is guest controlled and sticky (never cleared
by hardware).  A malicious PV guest can therefore trigger the fatal_trap() and
crash Xen.

Instruction breakpoints are more tricky.  The breakpoint match bits in %dr6
are not sticky, but the Intel manual warns that they may be set for
non-enabled breakpoints, so add a breakpoint enabled check.

Beyond that, because of the restriction on the linear addresses PV guests can
set, and the fault (rather than trap) nature of instruction breakpoints
(i.e. can't be deferred by a MovSS shadow), there should be no way to
encounter an instruction breakpoint in Xen context.  However, for extra
robustness, deal with this situation by clearing the breakpoint configuration,
rather than crashing.

This is XSA-265

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",17bf51297220dcd74da29de99320b6b1c72d1fa5,https://github.com/xen-project/xen/commit/17bf51297220dcd74da29de99320b6b1c72d1fa5,xen/arch/x86/traps.c,do_debug,"void do_debug(struct cpu_user_regs *regs)
{
unsigned long dr6;
struct vcpu *v = current;
dr6 = read_debugreg(6);
if ( debugger_trap_entry(TRAP_debug, regs) )
return;
write_debugreg(6, X86_DR6_DEFAULT);
if ( !guest_mode(regs) )
{
if ( regs->eflags & X86_EFLAGS_TF )
{
if ( (regs->rip >= (unsigned long)sysenter_entry) &&
(regs->rip <= (unsigned long)sysenter_eflags_saved) )
{
if ( regs->rip == (unsigned long)sysenter_eflags_saved )
regs->eflags &= ~X86_EFLAGS_TF;
goto out;
}
if ( !debugger_trap_fatal(TRAP_debug, regs) )
{
WARN();
regs->eflags &= ~X86_EFLAGS_TF;
}
}
if ( dr6 & DR_GENERAL_DETECT )
{
printk(XENLOG_ERR ""Hit General Detect in Xen context\n"");
fatal_trap(regs, 0);
}
if ( dr6 & (DR_TRAP3 | DR_TRAP2 | DR_TRAP1 | DR_TRAP0) )
{
unsigned int bp, dr7 = read_debugreg(7) >> DR_CONTROL_SHIFT;
for ( bp = 0; bp < 4; ++bp )
{
if ( (dr6 & (1u << bp)) && 
((dr7 & (3u << (bp * DR_CONTROL_SIZE))) == 0)  )
{
printk(XENLOG_ERR
""Hit instruction breakpoint in Xen context\n"");
fatal_trap(regs, 0);
}
}
}
gprintk(XENLOG_WARNING,
""Hit #DB in Xen context: %04x:%p [%ps], stk %04x:%p, dr6 %lx\n"",
regs->cs, _p(regs->rip), _p(regs->rip),
regs->ss, _p(regs->rsp), dr6);
goto out;
}
v->arch.debugreg[6] |= (dr6 & ~X86_DR6_DEFAULT);
v->arch.debugreg[6] &= (dr6 | ~X86_DR6_DEFAULT);
ler_enable();
pv_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);
return;
out:
ler_enable();
return;
}","void do_debug(struct cpu_user_regs *VAR_0)
{
unsigned long VAR_1;
struct vcpu *VAR_2 = VAR_3;
VAR_1 = read_debugreg(6);
if ( debugger_trap_entry(VAR_4, VAR_0) )
return;
write_debugreg(6, VAR_5);
if ( !guest_mode(VAR_0) )
{
if ( VAR_0->eflags & VAR_6 )
{
if ( (VAR_0->rip >= (unsigned long)VAR_7) &&
(VAR_0->rip <= (unsigned long)VAR_8) )
{
if ( VAR_0->rip == (unsigned long)VAR_8 )
VAR_0->eflags &= ~VAR_6;
goto out;
}
if ( !debugger_trap_fatal(VAR_4, VAR_0) )
{
WARN();
VAR_0->eflags &= ~VAR_6;
}
}
if ( VAR_1 & VAR_9 )
{
printk(XENLOG_ERR ""Hit General Detect in Xen context\n"");
fatal_trap(VAR_0, 0);
}
if ( VAR_1 & (VAR_10 | VAR_11 | VAR_12 | VAR_13) )
{
unsigned int VAR_14, VAR_15 = read_debugreg(7) >> VAR_16;
for ( VAR_14 = 0; VAR_14 < 4; ++VAR_14 )
{
if ( (VAR_1 & (1u << VAR_14)) && 
((VAR_15 & (3u << (VAR_14 * VAR_17))) == 0)  )
{
printk(XENLOG_ERR
""Hit instruction breakpoint in Xen context\n"");
fatal_trap(VAR_0, 0);
}
}
}
gprintk(VAR_18,
""Hit #DB in Xen context: %04x:%p [%ps], stk %04x:%p, dr6 %lx\n"",
VAR_0->cs, _p(VAR_0->rip), _p(VAR_0->rip),
VAR_0->ss, _p(VAR_0->rsp), VAR_1);
goto out;
}
VAR_2->arch.debugreg[6] |= (VAR_1 & ~VAR_5);
VAR_2->arch.debugreg[6] &= (VAR_1 | ~VAR_5);
ler_enable();
pv_inject_hw_exception(VAR_4, VAR_19);
return;
out:
ler_enable();
return;
}",xen-project/xen/17bf51297220dcd74da29de99320b6b1c72d1fa5/traps.c/vul/before/0.json,"void do_debug(struct cpu_user_regs *regs)
{
    unsigned long dr6;
    struct vcpu *v = current;

    /* Stash dr6 as early as possible. */
    dr6 = read_debugreg(6);

    if ( debugger_trap_entry(TRAP_debug, regs) )
        return;

    /*
     * At the time of writing (March 2018), on the subject of %dr6:
     *
     * The Intel manual says:
     *   Certain debug exceptions may clear bits 0-3. The remaining contents
     *   of the DR6 register are never cleared by the processor. To avoid
     *   confusion in identifying debug exceptions, debug handlers should
     *   clear the register (except bit 16, which they should set) before
     *   returning to the interrupted task.
     *
     * The AMD manual says:
     *   Bits 15:13 of the DR6 register are not cleared by the processor and
     *   must be cleared by software after the contents have been read.
     *
     * Some bits are reserved set, some are reserved clear, and some bits
     * which were previously reserved set are reused and cleared by hardware.
     * For future compatibility, reset to the default value, which will allow
     * us to spot any bit being changed by hardware to its non-default value.
     */
    write_debugreg(6, X86_DR6_DEFAULT);

    if ( !guest_mode(regs) )
    {
        /*
         * !!! WARNING !!!
         *
         * %dr6 is mostly guest controlled at this point.  Any decsions base
         * on its value must be crosschecked with non-guest controlled state.
         */

        if ( regs->eflags & X86_EFLAGS_TF )
        {
            /* In SYSENTER entry path we can't zap TF until EFLAGS is saved. */
            if ( (regs->rip >= (unsigned long)sysenter_entry) &&
                 (regs->rip <= (unsigned long)sysenter_eflags_saved) )
            {
                if ( regs->rip == (unsigned long)sysenter_eflags_saved )
                    regs->eflags &= ~X86_EFLAGS_TF;
                goto out;
            }
            if ( !debugger_trap_fatal(TRAP_debug, regs) )
            {
                WARN();
                regs->eflags &= ~X86_EFLAGS_TF;
            }
        }

        /*
         * Check for fault conditions.  General Detect, and instruction
         * breakpoints are faults rather than traps, at which point attempting
         * to ignore and continue will result in a livelock.
         *
         * However, on entering the #DB handler, hardware clears %dr7.gd for
         * us (as confirmed by the earlier %dr6 accesses succeeding), meaning
         * that a real General Detect exception is restartable.
         *
         * PV guests are not permitted to point %dr{0..3} at Xen linear
         * addresses, and Instruction Breakpoints (being faults) don't get
         * delayed by a MovSS shadow, so we should never encounter one in
         * hypervisor context.
         *
         * If however we do, safety measures need to be enacted.  Use a big
         * hammer and clear all debug settings.
         */
        if ( dr6 & (DR_TRAP3 | DR_TRAP2 | DR_TRAP1 | DR_TRAP0) )
        {
            unsigned int bp, dr7 = read_debugreg(7);

            for ( bp = 0; bp < 4; ++bp )
            {
                if ( (dr6 & (1u << bp)) && /* Breakpoint triggered? */
                     (dr7 & (3u << (bp * DR_ENABLE_SIZE))) && /* Enabled? */
                     ((dr7 & (3u << ((bp * DR_CONTROL_SIZE) + /* Insn? */
                                     DR_CONTROL_SHIFT))) == DR_RW_EXECUTE) )
                {
                    ASSERT_UNREACHABLE();

                    printk(XENLOG_ERR
                           ""Hit instruction breakpoint in Xen context\n"");
                    write_debugreg(7, 0);
                    break;
                }
            }
        }

        /*
         * Whatever caused this #DB should be restartable by this point.  Note
         * it and continue.  Guests can trigger this in certain corner cases,
         * so ensure the message is ratelimited.
         */
        gprintk(XENLOG_WARNING,
                ""Hit #DB in Xen context: %04x:%p [%ps], stk %04x:%p, dr6 %lx\n"",
                regs->cs, _p(regs->rip), _p(regs->rip),
                regs->ss, _p(regs->rsp), dr6);

        goto out;
    }

    /* Save debug status register where guest OS can peek at it */
    v->arch.debugreg[6] |= (dr6 & ~X86_DR6_DEFAULT);
    v->arch.debugreg[6] &= (dr6 | ~X86_DR6_DEFAULT);

    ler_enable();
    pv_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);
    return;

 out:
    ler_enable();
    return;
}","void do_debug(struct cpu_user_regs *VAR_0)
{
    unsigned long VAR_1;
    struct vcpu *VAR_2 = VAR_3;

    /* COMMENT_0 */
    VAR_1 = read_debugreg(6);

    if ( debugger_trap_entry(VAR_4, VAR_0) )
        return;

    /* COMMENT_1 */
                                                                   
      
                             
                                                                            
                                                                         
                                                                         
                                                                         
                                           
      
                           
                                                                            
                                                                       
      
                                                                         
                                                                             
                                                                             
                                                                             
       
    write_debugreg(6, VAR_5);

    if ( !guest_mode(VAR_0) )
    {
        /* COMMENT_18 */
                          
          
                                                                            
                                                                             
           

        if ( VAR_0->eflags & VAR_6 )
        {
            /* COMMENT_24 */
            if ( (VAR_0->rip >= (unsigned long)VAR_7) &&
                 (VAR_0->rip <= (unsigned long)VAR_8) )
            {
                if ( VAR_0->rip == (unsigned long)VAR_8 )
                    VAR_0->eflags &= ~VAR_6;
                goto out;
            }
            if ( !debugger_trap_fatal(VAR_4, VAR_0) )
            {
                WARN();
                VAR_0->eflags &= ~VAR_6;
            }
        }

        /* COMMENT_25 */
                                                                       
                                                                              
                                                            
          
                                                                            
                                                                             
                                                               
          
                                                                       
                                                                          
                                                                         
                              
          
                                                                           
                                               
           
        if ( VAR_1 & (VAR_9 | VAR_10 | VAR_11 | VAR_12) )
        {
            unsigned int VAR_13, VAR_14 = read_debugreg(7);

            for ( VAR_13 = 0; VAR_13 < 4; ++VAR_13 )
            {
                if ( (VAR_1 & (1u << VAR_13)) && /* COMMENT_40 */
                     (VAR_14 & (3u << (VAR_13 * VAR_15))) && /* COMMENT_41 */
                     ((VAR_14 & (3u << ((VAR_13 * VAR_16) + /* COMMENT_42 */
                                     VAR_17))) == VAR_18) )
                {
                    ASSERT_UNREACHABLE();

                    printk(XENLOG_ERR
                           ""Hit instruction breakpoint in Xen context\n"");
                    write_debugreg(7, 0);
                    break;
                }
            }
        }

        /* COMMENT_43 */
                                                                              
                                                                             
                                                
           
        gprintk(VAR_19,
                ""Hit #DB in Xen context: %04x:%p [%ps], stk %04x:%p, dr6 %lx\n"",
                VAR_0->cs, _p(VAR_0->rip), _p(VAR_0->rip),
                VAR_0->ss, _p(VAR_0->rsp), VAR_1);

        goto out;
    }

    /* COMMENT_48 */
    VAR_2->arch.debugreg[6] |= (VAR_1 & ~VAR_5);
    VAR_2->arch.debugreg[6] &= (VAR_1 | ~VAR_5);

    ler_enable();
    pv_inject_hw_exception(VAR_4, VAR_20);
    return;

 out:
    ler_enable();
    return;
}",xen-project/xen/17bf51297220dcd74da29de99320b6b1c72d1fa5/traps.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,6 +32,13 @@
 
     if ( !guest_mode(regs) )
     {
+        /*
+         * !!! WARNING !!!
+         *
+         * %dr6 is mostly guest controlled at this point.  Any decsions base
+         * on its value must be crosschecked with non-guest controlled state.
+         */
+
         if ( regs->eflags & X86_EFLAGS_TF )
         {
             /* In SYSENTER entry path we can't zap TF until EFLAGS is saved. */
@@ -53,33 +60,44 @@
          * Check for fault conditions.  General Detect, and instruction
          * breakpoints are faults rather than traps, at which point attempting
          * to ignore and continue will result in a livelock.
+         *
+         * However, on entering the #DB handler, hardware clears %dr7.gd for
+         * us (as confirmed by the earlier %dr6 accesses succeeding), meaning
+         * that a real General Detect exception is restartable.
+         *
+         * PV guests are not permitted to point %dr{0..3} at Xen linear
+         * addresses, and Instruction Breakpoints (being faults) don't get
+         * delayed by a MovSS shadow, so we should never encounter one in
+         * hypervisor context.
+         *
+         * If however we do, safety measures need to be enacted.  Use a big
+         * hammer and clear all debug settings.
          */
-        if ( dr6 & DR_GENERAL_DETECT )
-        {
-            printk(XENLOG_ERR ""Hit General Detect in Xen context\n"");
-            fatal_trap(regs, 0);
-        }
-
         if ( dr6 & (DR_TRAP3 | DR_TRAP2 | DR_TRAP1 | DR_TRAP0) )
         {
-            unsigned int bp, dr7 = read_debugreg(7) >> DR_CONTROL_SHIFT;
+            unsigned int bp, dr7 = read_debugreg(7);
 
             for ( bp = 0; bp < 4; ++bp )
             {
                 if ( (dr6 & (1u << bp)) && /* Breakpoint triggered? */
-                     ((dr7 & (3u << (bp * DR_CONTROL_SIZE))) == 0) /* Insn? */ )
+                     (dr7 & (3u << (bp * DR_ENABLE_SIZE))) && /* Enabled? */
+                     ((dr7 & (3u << ((bp * DR_CONTROL_SIZE) + /* Insn? */
+                                     DR_CONTROL_SHIFT))) == DR_RW_EXECUTE) )
                 {
+                    ASSERT_UNREACHABLE();
+
                     printk(XENLOG_ERR
                            ""Hit instruction breakpoint in Xen context\n"");
-                    fatal_trap(regs, 0);
+                    write_debugreg(7, 0);
+                    break;
                 }
             }
         }
 
         /*
-         * Whatever caused this #DB should be a trap.  Note it and continue.
-         * Guests can trigger this in certain corner cases, so ensure the
-         * message is ratelimited.
+         * Whatever caused this #DB should be restartable by this point.  Note
+         * it and continue.  Guests can trigger this in certain corner cases,
+         * so ensure the message is ratelimited.
          */
         gprintk(XENLOG_WARNING,
                 ""Hit #DB in Xen context: %04x:%p [%ps], stk %04x:%p, dr6 %lx\n"",","{'deleted_lines': ['        if ( dr6 & DR_GENERAL_DETECT )', '        {', '            printk(XENLOG_ERR ""Hit General Detect in Xen context\\n"");', '            fatal_trap(regs, 0);', '        }', '', '            unsigned int bp, dr7 = read_debugreg(7) >> DR_CONTROL_SHIFT;', '                     ((dr7 & (3u << (bp * DR_CONTROL_SIZE))) == 0) /* Insn? */ )', '                    fatal_trap(regs, 0);', '         * Whatever caused this #DB should be a trap.  Note it and continue.', '         * Guests can trigger this in certain corner cases, so ensure the', '         * message is ratelimited.'], 'added_lines': ['        /*', '         * !!! WARNING !!!', '         *', '         * %dr6 is mostly guest controlled at this point.  Any decsions base', '         * on its value must be crosschecked with non-guest controlled state.', '         */', '', '         *', '         * However, on entering the #DB handler, hardware clears %dr7.gd for', '         * us (as confirmed by the earlier %dr6 accesses succeeding), meaning', '         * that a real General Detect exception is restartable.', '         *', '         * PV guests are not permitted to point %dr{0..3} at Xen linear', ""         * addresses, and Instruction Breakpoints (being faults) don't get"", '         * delayed by a MovSS shadow, so we should never encounter one in', '         * hypervisor context.', '         *', '         * If however we do, safety measures need to be enacted.  Use a big', '         * hammer and clear all debug settings.', '            unsigned int bp, dr7 = read_debugreg(7);', '                     (dr7 & (3u << (bp * DR_ENABLE_SIZE))) && /* Enabled? */', '                     ((dr7 & (3u << ((bp * DR_CONTROL_SIZE) + /* Insn? */', '                                     DR_CONTROL_SHIFT))) == DR_RW_EXECUTE) )', '                    ASSERT_UNREACHABLE();', '', '                    write_debugreg(7, 0);', '                    break;', '         * Whatever caused this #DB should be restartable by this point.  Note', '         * it and continue.  Guests can trigger this in certain corner cases,', '         * so ensure the message is ratelimited.']}",True,"An issue was discovered in Xen through 4.10.x. One of the fixes in XSA-260 added some safety checks to help prevent Xen livelocking with debug exceptions. Unfortunately, due to an oversight, at least one of these safety checks can be triggered by a guest. A malicious PV guest can crash Xen, leading to a Denial of Service. All Xen systems which have applied the XSA-260 fix are vulnerable. Only x86 systems are vulnerable. ARM systems are not vulnerable. Only x86 PV guests can exploit the vulnerability. x86 HVM and PVH guests cannot exploit the vulnerability. An attacker needs to be able to control hardware debugging facilities to exploit the vulnerability, but such permissions are typically available to unprivileged users.",6.5,MEDIUM,1,test,2018-06-28T07:04:20Z,2
CVE-2018-14851,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,php/php-src,"Fix bug #76557: heap-buffer-overflow (READ of size 48) while reading exif data

Use MAKERNOTE length as data size.",3462efa386f26d343062094514af604c29e3edce,https://github.com/php/php-src/commit/3462efa386f26d343062094514af604c29e3edce,ext/exif/exif.c,exif_process_IFD_in_MAKERNOTE,"static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement TSRMLS_DC)
{
int de, i=0, section_index = SECTION_MAKERNOTE;
int NumDirEntries, old_motorola_intel, offset_diff;
const maker_note_type *maker_note;
char *dir_start;
for (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) {
if (i==sizeof(maker_note_array)/sizeof(maker_note_type)) {
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""No maker note data found. Detected maker: %s (length = %d)"", ImageInfo->make, strlen(ImageInfo->make));
#endif
return TRUE;
}
maker_note = maker_note_array+i;
if (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make)))
continue;
if (maker_note->model && (!ImageInfo->model || strcmp(maker_note->model, ImageInfo->model)))
continue;
if (maker_note->id_string && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len))
continue;
break;
}
if (maker_note->offset >= value_len) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X offset 0x%04X"", value_len, maker_note->offset);
return FALSE;
}
dir_start = value_ptr + maker_note->offset;
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement));
#endif
ImageInfo->sections_found |= FOUND_MAKERNOTE;
old_motorola_intel = ImageInfo->motorola_intel;
switch (maker_note->byte_order) {
case MN_ORDER_INTEL:
ImageInfo->motorola_intel = 0;
break;
case MN_ORDER_MOTOROLA:
ImageInfo->motorola_intel = 1;
break;
default:
case MN_ORDER_NORMAL:
break;
}
NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel);
switch (maker_note->offset_mode) {
case MN_OFFSET_MAKER:
offset_base = value_ptr;
break;
case MN_OFFSET_GUESS:
if (maker_note->offset + 10 + 4 >= value_len) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X"", value_len);
return FALSE;
}
offset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel);
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Using automatic offset correction: 0x%04X"", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff);
#endif
if (offset_diff < 0 || offset_diff >= value_len ) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data bad offset: 0x%04X length 0x%04X"", offset_diff, value_len);
return FALSE;
}
offset_base = value_ptr + offset_diff;
break;
default:
case MN_OFFSET_NORMAL:
break;
}
if ((2+NumDirEntries*12) > value_len) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X"", NumDirEntries, 2+NumDirEntries*12, value_len);
return FALSE;
}
for (de=0;de<NumDirEntries;de++) {
if (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,
offset_base, IFDlength, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {
return FALSE;
}
}
ImageInfo->motorola_intel = old_motorola_intel;
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(SECTION_MAKERNOTE));
#endif
return TRUE;
}","static int exif_process_IFD_in_MAKERNOTE(image_info_type *VAR_0, char * VAR_1, int VAR_2, char *VAR_3, size_t VAR_4, size_t VAR_5 TSRMLS_DC)
{
int VAR_6, VAR_7=0, VAR_8 = VAR_9;
int VAR_10, VAR_11, VAR_12;
const maker_note_type *VAR_13;
char *VAR_14;
for (VAR_7=0; VAR_7<=sizeof(maker_note_array)/sizeof(maker_note_type); VAR_7++) {
if (VAR_7==sizeof(maker_note_array)/sizeof(maker_note_type)) {
#ifdef VAR_15
VAR_16(NULL VAR_17, VAR_0, VAR_18, ""No maker note data found. Detected maker: %s (length = %d)"", VAR_0->make, strlen(VAR_0->make));
#endif
return TRUE;
}
VAR_13 = maker_note_array+VAR_7;
if (VAR_13->make && (!VAR_0->make || strcmp(VAR_13->make, VAR_0->make)))
continue;
if (VAR_13->model && (!VAR_0->model || strcmp(VAR_13->model, VAR_0->model)))
continue;
if (VAR_13->id_string && strncmp(VAR_13->id_string, VAR_1, VAR_13->id_string_len))
continue;
break;
}
if (VAR_13->offset >= VAR_2) {
VAR_16(""exif_read_data#error_ifd"" VAR_17, VAR_0, VAR_19, ""IFD data too short: 0x%04X offset 0x%04X"", VAR_2, VAR_13->offset);
return FALSE;
}
VAR_14 = VAR_1 + VAR_13->offset;
#ifdef VAR_15
VAR_16(NULL VAR_17, VAR_0, VAR_18, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(VAR_8), (int)VAR_14-(int)VAR_3+VAR_13->offset+VAR_5, VAR_2, VAR_2, exif_char_dump(VAR_1, VAR_2, (int)VAR_14-(int)VAR_3+VAR_13->offset+VAR_5));
#endif
VAR_0->sections_found |= VAR_20;
VAR_11 = VAR_0->motorola_intel;
switch (VAR_13->byte_order) {
case VAR_21:
VAR_0->motorola_intel = 0;
break;
case VAR_22:
VAR_0->motorola_intel = 1;
break;
default:
case VAR_23:
break;
}
VAR_10 = php_ifd_get16u(VAR_14, VAR_0->motorola_intel);
switch (VAR_13->offset_mode) {
case VAR_24:
VAR_3 = VAR_1;
break;
case VAR_25:
if (VAR_13->offset + 10 + 4 >= VAR_2) {
VAR_16(""exif_read_data#error_ifd"" VAR_17, VAR_0, VAR_19, ""IFD data too short: 0x%04X"", VAR_2);
return FALSE;
}
VAR_12 = 2 + VAR_10*12 + 4 - php_ifd_get32u(VAR_14+10, VAR_0->motorola_intel);
#ifdef VAR_15
VAR_16(NULL VAR_17, VAR_0, VAR_18, ""Using automatic offset correction: 0x%04X"", ((int)VAR_14-(int)VAR_3+VAR_13->offset+VAR_5) + VAR_12);
#endif
if (VAR_12 < 0 || VAR_12 >= VAR_2 ) {
VAR_16(""exif_read_data#error_ifd"" VAR_17, VAR_0, VAR_19, ""IFD data bad offset: 0x%04X length 0x%04X"", VAR_12, VAR_2);
return FALSE;
}
VAR_3 = VAR_1 + VAR_12;
break;
default:
case VAR_26:
break;
}
if ((2+VAR_10*12) > VAR_2) {
VAR_16(""exif_read_data#error_ifd"" VAR_17, VAR_0, VAR_19, ""Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X"", VAR_10, 2+VAR_10*12, VAR_2);
return FALSE;
}
for (VAR_6=0;VAR_6<VAR_10;VAR_6++) {
if (!exif_process_IFD_TAG(VAR_0, VAR_14 + 2 + 12 * VAR_6,
VAR_3, VAR_4, VAR_5, VAR_8, 0, VAR_13->tag_table VAR_27)) {
return FALSE;
}
}
VAR_0->motorola_intel = VAR_11;
#ifdef VAR_15
VAR_16(NULL VAR_17, VAR_0, VAR_18, ""VAR_28 %VAR_29 VAR_30"", exif_get_sectionname(SECTION_MAKERNOTE));
#endif
return TRUE;
}",,"static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement TSRMLS_DC)
{
	int de, i=0, section_index = SECTION_MAKERNOTE;
	int NumDirEntries, old_motorola_intel, offset_diff;
	const maker_note_type *maker_note;
	char *dir_start;
	int data_len;

	for (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) {
		if (i==sizeof(maker_note_array)/sizeof(maker_note_type)) {
#ifdef EXIF_DEBUG
			exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""No maker note data found. Detected maker: %s (length = %d)"", ImageInfo->make, strlen(ImageInfo->make));
#endif
			/* unknown manufacturer, not an error, use it as a string */
			return TRUE;
		}

		maker_note = maker_note_array+i;

		/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""check (%s,%s)"", maker_note->make?maker_note->make:"""", maker_note->model?maker_note->model:"""");*/
		if (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make)))
			continue;
		if (maker_note->model && (!ImageInfo->model || strcmp(maker_note->model, ImageInfo->model)))
			continue;
		if (maker_note->id_string && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len))
			continue;
		break;
	}

	if (maker_note->offset >= value_len) {
		/* Do not go past the value end */
		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X offset 0x%04X"", value_len, maker_note->offset);
		return FALSE;
	}

	dir_start = value_ptr + maker_note->offset;

#ifdef EXIF_DEBUG
	exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement));
#endif

	ImageInfo->sections_found |= FOUND_MAKERNOTE;

	old_motorola_intel = ImageInfo->motorola_intel;
	switch (maker_note->byte_order) {
		case MN_ORDER_INTEL:
			ImageInfo->motorola_intel = 0;
			break;
		case MN_ORDER_MOTOROLA:
			ImageInfo->motorola_intel = 1;
			break;
		default:
		case MN_ORDER_NORMAL:
			break;
	}

	NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel);

	switch (maker_note->offset_mode) {
		case MN_OFFSET_MAKER:
			offset_base = value_ptr;
			data_len = value_len;
			break;
		case MN_OFFSET_GUESS:
			if (maker_note->offset + 10 + 4 >= value_len) {
				/* Can not read dir_start+10 since it's beyond value end */
				exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X"", value_len);
				return FALSE;
			}
			offset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel);
#ifdef EXIF_DEBUG
			exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Using automatic offset correction: 0x%04X"", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff);
#endif
			if (offset_diff < 0 || offset_diff >= value_len ) {
				exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data bad offset: 0x%04X length 0x%04X"", offset_diff, value_len);
				return FALSE;
			}
			offset_base = value_ptr + offset_diff;
			data_len = value_len - offset_diff;
			break;
		default:
		case MN_OFFSET_NORMAL:
			break;
	}

	if ((2+NumDirEntries*12) > value_len) {
		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X"", NumDirEntries, 2+NumDirEntries*12, value_len);
		return FALSE;
	}

	for (de=0;de<NumDirEntries;de++) {
		if (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,
								  offset_base, data_len, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {
			return FALSE;
		}
	}
	ImageInfo->motorola_intel = old_motorola_intel;
/*	NextDirOffset (must be NULL) = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);*/
#ifdef EXIF_DEBUG
	exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(SECTION_MAKERNOTE));
#endif
	return TRUE;
}","static int exif_process_IFD_in_MAKERNOTE(image_info_type *VAR_0, char * VAR_1, int VAR_2, char *VAR_3, size_t VAR_4, size_t VAR_5 TSRMLS_DC)
{
	int VAR_6, VAR_7=0, VAR_8 = VAR_9;
	int VAR_10, VAR_11, VAR_12;
	const maker_note_type *VAR_13;
	char *VAR_14;
	int VAR_15;

	for (VAR_7=0; VAR_7<=sizeof(maker_note_array)/sizeof(maker_note_type); VAR_7++) {
		if (VAR_7==sizeof(maker_note_array)/sizeof(maker_note_type)) {
#ifdef VAR_16
			VAR_17(NULL VAR_18, VAR_0, VAR_19, ""No maker note data found. Detected maker: %s (length = %d)"", VAR_0->make, strlen(VAR_0->make));
#endif
			/* COMMENT_0 */
			return TRUE;
		}

		VAR_13 = maker_note_array+VAR_7;

		/* COMMENT_1 */
		if (VAR_13->make && (!VAR_0->make || strcmp(VAR_13->make, VAR_0->make)))
			continue;
		if (VAR_13->model && (!VAR_0->model || strcmp(VAR_13->model, VAR_0->model)))
			continue;
		if (VAR_13->id_string && strncmp(VAR_13->id_string, VAR_1, VAR_13->id_string_len))
			continue;
		break;
	}

	if (VAR_13->offset >= VAR_2) {
		/* COMMENT_2 */
		VAR_17(""exif_read_data#error_ifd"" VAR_18, VAR_0, VAR_20, ""IFD data too short: 0x%04X offset 0x%04X"", VAR_2, VAR_13->offset);
		return FALSE;
	}

	VAR_14 = VAR_1 + VAR_13->offset;

#ifdef VAR_16
	VAR_17(NULL VAR_18, VAR_0, VAR_19, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(VAR_8), (int)VAR_14-(int)VAR_3+VAR_13->offset+VAR_5, VAR_2, VAR_2, exif_char_dump(VAR_1, VAR_2, (int)VAR_14-(int)VAR_3+VAR_13->offset+VAR_5));
#endif

	VAR_0->sections_found |= VAR_21;

	VAR_11 = VAR_0->motorola_intel;
	switch (VAR_13->byte_order) {
		case VAR_22:
			VAR_0->motorola_intel = 0;
			break;
		case VAR_23:
			VAR_0->motorola_intel = 1;
			break;
		default:
		case VAR_24:
			break;
	}

	VAR_10 = php_ifd_get16u(VAR_14, VAR_0->motorola_intel);

	switch (VAR_13->offset_mode) {
		case VAR_25:
			VAR_3 = VAR_1;
			VAR_15 = VAR_2;
			break;
		case VAR_26:
			if (VAR_13->offset + 10 + 4 >= VAR_2) {
				/* COMMENT_3 */
				VAR_17(""exif_read_data#error_ifd"" VAR_18, VAR_0, VAR_20, ""IFD data too short: 0x%04X"", VAR_2);
				return FALSE;
			}
			VAR_12 = 2 + VAR_10*12 + 4 - php_ifd_get32u(VAR_14+10, VAR_0->motorola_intel);
#ifdef VAR_16
			VAR_17(NULL VAR_18, VAR_0, VAR_19, ""Using automatic offset correction: 0x%04X"", ((int)VAR_14-(int)VAR_3+VAR_13->offset+VAR_5) + VAR_12);
#endif
			if (VAR_12 < 0 || VAR_12 >= VAR_2 ) {
				VAR_17(""exif_read_data#error_ifd"" VAR_18, VAR_0, VAR_20, ""IFD data bad offset: 0x%04X length 0x%04X"", VAR_12, VAR_2);
				return FALSE;
			}
			VAR_3 = VAR_1 + VAR_12;
			VAR_15 = VAR_2 - VAR_12;
			break;
		default:
		case VAR_27:
			break;
	}

	if ((2+VAR_10*12) > VAR_2) {
		VAR_17(""exif_read_data#error_ifd"" VAR_18, VAR_0, VAR_20, ""Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X"", VAR_10, 2+VAR_10*12, VAR_2);
		return FALSE;
	}

	for (VAR_6=0;VAR_6<VAR_10;VAR_6++) {
		if (!exif_process_IFD_TAG(VAR_0, VAR_14 + 2 + 12 * VAR_6,
								  VAR_3, VAR_15, VAR_5, VAR_8, 0, VAR_13->tag_table VAR_28)) {
			return FALSE;
		}
	}
	VAR_0->motorola_intel = VAR_11;
/* COMMENT_4 */
#ifdef VAR_16
	VAR_17(NULL VAR_18, VAR_0, VAR_19, ""VAR_29 %VAR_30 VAR_31"", exif_get_sectionname(SECTION_MAKERNOTE));
#endif
	return TRUE;
}",,"--- func_before
+++ func_after
@@ -4,6 +4,7 @@
 	int NumDirEntries, old_motorola_intel, offset_diff;
 	const maker_note_type *maker_note;
 	char *dir_start;
+	int data_len;
 
 	for (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) {
 		if (i==sizeof(maker_note_array)/sizeof(maker_note_type)) {
@@ -58,6 +59,7 @@
 	switch (maker_note->offset_mode) {
 		case MN_OFFSET_MAKER:
 			offset_base = value_ptr;
+			data_len = value_len;
 			break;
 		case MN_OFFSET_GUESS:
 			if (maker_note->offset + 10 + 4 >= value_len) {
@@ -74,6 +76,7 @@
 				return FALSE;
 			}
 			offset_base = value_ptr + offset_diff;
+			data_len = value_len - offset_diff;
 			break;
 		default:
 		case MN_OFFSET_NORMAL:
@@ -87,7 +90,7 @@
 
 	for (de=0;de<NumDirEntries;de++) {
 		if (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,
-								  offset_base, IFDlength, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {
+								  offset_base, data_len, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {
 			return FALSE;
 		}
 	}","{'deleted_lines': ['\t\t\t\t\t\t\t\t  offset_base, IFDlength, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {'], 'added_lines': ['\tint data_len;', '\t\t\tdata_len = value_len;', '\t\t\tdata_len = value_len - offset_diff;', '\t\t\t\t\t\t\t\t  offset_base, data_len, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {']}",True,"exif_process_IFD_in_MAKERNOTE in ext/exif/exif.c in PHP before 5.6.37, 7.0.x before 7.0.31, 7.1.x before 7.1.20, and 7.2.x before 7.2.8 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted JPEG file.",5.5,MEDIUM,1,test,2018-07-02T05:20:19Z,2
CVE-2018-1999015,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0.0,ffmpeg,"avcodec/mpeg4videodec: Check for bitstream end in read_quant_matrix_ext()

Fixes: out of array read
Fixes: asff-crash-0e53d0dc491dfdd507530b66562812fbd4c36678

Found-by: Paul Ch <paulcher@icloud.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",5aba5b89d0b1d73164d3b81764828bb8b20ff32a,https://github.com/FFmpeg/FFmpeg/commit/5aba5b89d0b1d73164d3b81764828bb8b20ff32a,libavcodec/mpeg4videodec.c,read_quant_matrix_ext,"static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
{
int i, j, v;
if (get_bits1(gb)) {
for (i = 0; i < 64; i++) {
v = get_bits(gb, 8);
j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
s->intra_matrix[j]        = v;
s->chroma_intra_matrix[j] = v;
}
}
if (get_bits1(gb)) {
for (i = 0; i < 64; i++) {
get_bits(gb, 8);
}
}
if (get_bits1(gb)) {
for (i = 0; i < 64; i++) {
v = get_bits(gb, 8);
j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
s->chroma_intra_matrix[j] = v;
}
}
if (get_bits1(gb)) {
for (i = 0; i < 64; i++) {
get_bits(gb, 8);
}
}
next_start_code_studio(gb);
}","static void read_quant_matrix_ext(MpegEncContext *VAR_0, GetBitContext *VAR_1)
{
int VAR_2, VAR_3, VAR_4;
if (get_bits1(VAR_1)) {
for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
VAR_4 = get_bits(VAR_1, 8);
VAR_3 = VAR_0->idsp.idct_permutation[VAR_5[VAR_2]];
VAR_0->intra_matrix[VAR_3]        = VAR_4;
VAR_0->chroma_intra_matrix[VAR_3] = VAR_4;
}
}
if (get_bits1(VAR_1)) {
for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
get_bits(VAR_1, 8);
}
}
if (get_bits1(VAR_1)) {
for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
VAR_4 = get_bits(VAR_1, 8);
VAR_3 = VAR_0->idsp.idct_permutation[VAR_5[VAR_2]];
VAR_0->chroma_intra_matrix[VAR_3] = VAR_4;
}
}
if (get_bits1(VAR_1)) {
for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
get_bits(VAR_1, 8);
}
}
next_start_code_studio(VAR_1);
}",ffmpeg/5aba5b89d0b1d73164d3b81764828bb8b20ff32a/mpeg4videodec.c/vul/before/0.json,"static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
{
    int i, j, v;

    if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        /* intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            v = get_bits(gb, 8);
            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
            s->intra_matrix[j]        = v;
            s->chroma_intra_matrix[j] = v;
        }
    }

    if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        /* non_intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            get_bits(gb, 8);
        }
    }

    if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        /* chroma_intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            v = get_bits(gb, 8);
            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];
            s->chroma_intra_matrix[j] = v;
        }
    }

    if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        /* chroma_non_intra_quantiser_matrix */
        for (i = 0; i < 64; i++) {
            get_bits(gb, 8);
        }
    }

    next_start_code_studio(gb);
    return 0;
}","static int read_quant_matrix_ext(MpegEncContext *VAR_0, GetBitContext *VAR_1)
{
    int VAR_2, VAR_3, VAR_4;

    if (get_bits1(VAR_1)) {
        if (get_bits_left(VAR_1) < 64*8)
            return VAR_5;
        /* COMMENT_0 */
        for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
            VAR_4 = get_bits(VAR_1, 8);
            VAR_3 = VAR_0->idsp.idct_permutation[VAR_6[VAR_2]];
            VAR_0->intra_matrix[VAR_3]        = VAR_4;
            VAR_0->chroma_intra_matrix[VAR_3] = VAR_4;
        }
    }

    if (get_bits1(VAR_1)) {
        if (get_bits_left(VAR_1) < 64*8)
            return VAR_5;
        /* COMMENT_1 */
        for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
            get_bits(VAR_1, 8);
        }
    }

    if (get_bits1(VAR_1)) {
        if (get_bits_left(VAR_1) < 64*8)
            return VAR_5;
        /* COMMENT_2 */
        for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
            VAR_4 = get_bits(VAR_1, 8);
            VAR_3 = VAR_0->idsp.idct_permutation[VAR_6[VAR_2]];
            VAR_0->chroma_intra_matrix[VAR_3] = VAR_4;
        }
    }

    if (get_bits1(VAR_1)) {
        if (get_bits_left(VAR_1) < 64*8)
            return VAR_5;
        /* COMMENT_3 */
        for (VAR_2 = 0; VAR_2 < 64; VAR_2++) {
            get_bits(VAR_1, 8);
        }
    }

    next_start_code_studio(VAR_1);
    return 0;
}",ffmpeg/5aba5b89d0b1d73164d3b81764828bb8b20ff32a/mpeg4videodec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,10 @@
-static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
+static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
 {
     int i, j, v;
 
     if (get_bits1(gb)) {
+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;
         /* intra_quantiser_matrix */
         for (i = 0; i < 64; i++) {
             v = get_bits(gb, 8);
@@ -13,6 +15,8 @@
     }
 
     if (get_bits1(gb)) {
+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;
         /* non_intra_quantiser_matrix */
         for (i = 0; i < 64; i++) {
             get_bits(gb, 8);
@@ -20,6 +24,8 @@
     }
 
     if (get_bits1(gb)) {
+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;
         /* chroma_intra_quantiser_matrix */
         for (i = 0; i < 64; i++) {
             v = get_bits(gb, 8);
@@ -29,6 +35,8 @@
     }
 
     if (get_bits1(gb)) {
+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;
         /* chroma_non_intra_quantiser_matrix */
         for (i = 0; i < 64; i++) {
             get_bits(gb, 8);
@@ -36,4 +44,5 @@
     }
 
     next_start_code_studio(gb);
+    return 0;
 }","{'deleted_lines': ['static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)'], 'added_lines': ['static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)', '        if (get_bits_left(gb) < 64*8)', '            return AVERROR_INVALIDDATA;', '        if (get_bits_left(gb) < 64*8)', '            return AVERROR_INVALIDDATA;', '        if (get_bits_left(gb) < 64*8)', '            return AVERROR_INVALIDDATA;', '        if (get_bits_left(gb) < 64*8)', '            return AVERROR_INVALIDDATA;', '    return 0;']}",True,FFmpeg before commit 5aba5b89d0b1d73164d3b81764828bb8b20ff32a contains an out of array read vulnerability in ASF_F format demuxer that can result in heap memory reading. This attack appear to be exploitable via specially crafted ASF file that has to provided as input. This vulnerability appears to have been fixed in 5aba5b89d0b1d73164d3b81764828bb8b20ff32a and later.,6.5,MEDIUM,1,test,2018-07-03T20:48:32Z,2
CVE-2018-14434,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1192,98a2cceae0dceccbfe54051167c2c80be1f13c3f,https://github.com/ImageMagick/ImageMagick/commit/98a2cceae0dceccbfe54051167c2c80be1f13c3f,coders/mpc.c,WriteMPCImage,"static MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
char
buffer[MagickPathExtent],
cache_filename[MagickPathExtent];
const char
*property,
*value;
MagickBooleanType
status;
MagickOffsetType
offset,
scene;
register ssize_t
i;
size_t
depth,
imageListLength;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
(void) CopyMagickString(cache_filename,image->filename,MagickPathExtent-6);
AppendImageFormat(""cache"",cache_filename);
scene=0;
offset=0;
imageListLength=GetImageListLength(image);
do
{
depth=GetImageQuantumDepth(image,MagickTrue);
if ((image->storage_class == PseudoClass) &&
(image->colors > (size_t) (GetQuantumRange(image->depth)+1)))
(void) SetImageStorageClass(image,DirectClass,exception);
(void) WriteBlobString(image,""id=MagickCache\n"");
(void) FormatLocaleString(buffer,MagickPathExtent,""magick-signature=%u\n"",
GetMagickSignature((const StringInfo *) NULL));
(void) WriteBlobString(image,buffer);
(void) FormatLocaleString(buffer,MagickPathExtent,
""class=%s  colors=%.20g  alpha-trait=%s\n"",CommandOptionToMnemonic(
MagickClassOptions,image->storage_class),(double) image->colors,
CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)
image->alpha_trait));
(void) WriteBlobString(image,buffer);
(void) FormatLocaleString(buffer,MagickPathExtent,
""number-channels=%.20g  number-meta-channels=%.20g\n"",
(double) image->number_channels,(double) image->number_meta_channels);
(void) WriteBlobString(image,buffer);
(void) FormatLocaleString(buffer,MagickPathExtent,
""columns=%.20g  rows=%.20g depth=%.20g\n"",(double) image->columns,
(double) image->rows,(double) image->depth);
(void) WriteBlobString(image,buffer);
if (image->type != UndefinedType)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""type=%s\n"",
CommandOptionToMnemonic(MagickTypeOptions,image->type));
(void) WriteBlobString(image,buffer);
}
(void) FormatLocaleString(buffer,MagickPathExtent,""colorspace=%s\n"",
CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));
(void) WriteBlobString(image,buffer);
if (image->intensity != UndefinedPixelIntensityMethod)
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""pixel-intensity=%s\n"",CommandOptionToMnemonic(
MagickPixelIntensityOptions,image->intensity));
(void) WriteBlobString(image,buffer);
}
if (image->endian != UndefinedEndian)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""endian=%s\n"",
CommandOptionToMnemonic(MagickEndianOptions,image->endian));
(void) WriteBlobString(image,buffer);
}
if (image->compression != UndefinedCompression)
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""compression=%s  quality=%.20g\n"",CommandOptionToMnemonic(
MagickCompressOptions,image->compression),(double) image->quality);
(void) WriteBlobString(image,buffer);
}
if (image->units != UndefinedResolution)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""units=%s\n"",
CommandOptionToMnemonic(MagickResolutionOptions,image->units));
(void) WriteBlobString(image,buffer);
}
if ((image->resolution.x != 0) || (image->resolution.y != 0))
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""resolution=%gx%g\n"",image->resolution.x,image->resolution.y);
(void) WriteBlobString(image,buffer);
}
if ((image->page.width != 0) || (image->page.height != 0))
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""page=%.20gx%.20g%+.20g%+.20g\n"",(double) image->page.width,(double)
image->page.height,(double) image->page.x,(double) image->page.y);
(void) WriteBlobString(image,buffer);
}
else
if ((image->page.x != 0) || (image->page.y != 0))
{
(void) FormatLocaleString(buffer,MagickPathExtent,""page=%+ld%+ld\n"",
(long) image->page.x,(long) image->page.y);
(void) WriteBlobString(image,buffer);
}
if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""tile-offset=%+ld%+ld\n"",(long) image->tile_offset.x,(long)
image->tile_offset.y);
(void) WriteBlobString(image,buffer);
}
if ((GetNextImageInList(image) != (Image *) NULL) ||
(GetPreviousImageInList(image) != (Image *) NULL))
{
if (image->scene == 0)
(void) FormatLocaleString(buffer,MagickPathExtent,
""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",(double)
image->iterations,(double) image->delay,(double)
image->ticks_per_second);
else
(void) FormatLocaleString(buffer,MagickPathExtent,""scene=%.20g  ""
""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",
(double) image->scene,(double) image->iterations,(double)
image->delay,(double) image->ticks_per_second);
(void) WriteBlobString(image,buffer);
}
else
{
if (image->scene != 0)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""scene=%.20g\n"",
(double) image->scene);
(void) WriteBlobString(image,buffer);
}
if (image->iterations != 0)
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""iterations=%.20g\n"",(double) image->iterations);
(void) WriteBlobString(image,buffer);
}
if (image->delay != 0)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""delay=%.20g\n"",
(double) image->delay);
(void) WriteBlobString(image,buffer);
}
if (image->ticks_per_second != UndefinedTicksPerSecond)
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""ticks-per-second=%.20g\n"",(double) image->ticks_per_second);
(void) WriteBlobString(image,buffer);
}
}
if (image->gravity != UndefinedGravity)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""gravity=%s\n"",
CommandOptionToMnemonic(MagickGravityOptions,image->gravity));
(void) WriteBlobString(image,buffer);
}
if (image->dispose != UndefinedDispose)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""dispose=%s\n"",
CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));
(void) WriteBlobString(image,buffer);
}
if (image->rendering_intent != UndefinedIntent)
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""rendering-intent=%s\n"",CommandOptionToMnemonic(MagickIntentOptions,
image->rendering_intent));
(void) WriteBlobString(image,buffer);
}
if (image->gamma != 0.0)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""gamma=%g\n"",
image->gamma);
(void) WriteBlobString(image,buffer);
}
if (image->chromaticity.white_point.x != 0.0)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""red-primary=""
""%g,%g  green-primary=%g,%g  blue-primary=%g,%g\n"",
image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,
image->chromaticity.green_primary.x,
image->chromaticity.green_primary.y,
image->chromaticity.blue_primary.x,
image->chromaticity.blue_primary.y);
(void) WriteBlobString(image,buffer);
(void) FormatLocaleString(buffer,MagickPathExtent,
""white-point=%g,%g\n"",image->chromaticity.white_point.x,
image->chromaticity.white_point.y);
(void) WriteBlobString(image,buffer);
}
if (image->orientation != UndefinedOrientation)
{
(void) FormatLocaleString(buffer,MagickPathExtent,
""orientation=%s\n"",CommandOptionToMnemonic(MagickOrientationOptions,
image->orientation));
(void) WriteBlobString(image,buffer);
}
if (image->profiles != (void *) NULL)
{
const char
*name;
const StringInfo
*profile;
ResetImageProfileIterator(image);
for (name=GetNextImageProfile(image); name != (const char *) NULL; )
{
profile=GetImageProfile(image,name);
if (profile != (StringInfo *) NULL)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""profile=%s\n"",
name);
(void) WriteBlobString(image,buffer);
}
name=GetNextImageProfile(image);
}
}
if (image->montage != (char *) NULL)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""montage=%s\n"",
image->montage);
(void) WriteBlobString(image,buffer);
}
ResetImagePropertyIterator(image);
property=GetNextImageProperty(image);
while (property != (const char *) NULL)
{
(void) FormatLocaleString(buffer,MagickPathExtent,""%s="",property);
(void) WriteBlobString(image,buffer);
value=GetImageProperty(image,property,exception);
if (value != (const char *) NULL)
{
size_t
length;
length=strlen(value);
for (i=0; i < (ssize_t) length; i++)
if (isspace((int) ((unsigned char) value[i])) != 0)
break;
if ((i == (ssize_t) length) && (i != 0))
(void) WriteBlob(image,length,(const unsigned char *) value);
else
{
(void) WriteBlobByte(image,'{');
if (strchr(value,'}') == (char *) NULL)
(void) WriteBlob(image,length,(const unsigned char *) value);
else
for (i=0; i < (ssize_t) length; i++)
{
if (value[i] == (int) '}')
(void) WriteBlobByte(image,'\\');
(void) WriteBlobByte(image,(unsigned char) value[i]);
}
(void) WriteBlobByte(image,'}');
}
}
(void) WriteBlobByte(image,'\n');
property=GetNextImageProperty(image);
}
(void) WriteBlobString(image,""\f\n:\032"");
if (image->montage != (char *) NULL)
{
if (image->directory != (char *) NULL)
(void) WriteBlobString(image,image->directory);
(void) WriteBlobByte(image,'\0');
}
if (image->profiles != 0)
{
const char
*name;
const StringInfo
*profile;
ResetImageProfileIterator(image);
name=GetNextImageProfile(image);
while (name != (const char *) NULL)
{
profile=GetImageProfile(image,name);
(void) WriteBlobMSBLong(image,(unsigned int)
GetStringInfoLength(profile));
(void) WriteBlob(image,GetStringInfoLength(profile),
GetStringInfoDatum(profile));
name=GetNextImageProfile(image);
}
}
if (image->storage_class == PseudoClass)
{
size_t
packet_size;
unsigned char
*colormap,
*q;
packet_size=(size_t) (3UL*depth/8UL);
colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
packet_size*sizeof(*colormap));
if (colormap == (unsigned char *) NULL)
return(MagickFalse);
q=colormap;
for (i=0; i < (ssize_t) image->colors; i++)
{
switch (depth)
{
default:
ThrowWriterException(CorruptImageError,""ImageDepthNotSupported"");
case 32:
{
unsigned int
pixel;
pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].red));
q=PopLongPixel(MSBEndian,pixel,q);
pixel=ScaleQuantumToLong(ClampToQuantum(
image->colormap[i].green));
q=PopLongPixel(MSBEndian,pixel,q);
pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].blue));
q=PopLongPixel(MSBEndian,pixel,q);
break;
}
case 16:
{
unsigned short
pixel;
pixel=ScaleQuantumToShort(ClampToQuantum(image->colormap[i].red));
q=PopShortPixel(MSBEndian,pixel,q);
pixel=ScaleQuantumToShort(ClampToQuantum(
image->colormap[i].green));
q=PopShortPixel(MSBEndian,pixel,q);
pixel=ScaleQuantumToShort(ClampToQuantum(
image->colormap[i].blue));
q=PopShortPixel(MSBEndian,pixel,q);
break;
}
case 8:
{
unsigned char
pixel;
pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
image->colormap[i].red));
q=PopCharPixel(pixel,q);
pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
image->colormap[i].green));
q=PopCharPixel(pixel,q);
pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
image->colormap[i].blue));
q=PopCharPixel(pixel,q);
break;
}
}
}
(void) WriteBlob(image,packet_size*image->colors,colormap);
colormap=(unsigned char *) RelinquishMagickMemory(colormap);
}
status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,
exception);
if (status == MagickFalse)
ThrowWriterException(CacheError,""UnableToPersistPixelCache"");
if (GetNextImageInList(image) == (Image *) NULL)
break;
image=SyncNextImageInList(image);
if (image->progress_monitor != (MagickProgressMonitor) NULL)
{
status=image->progress_monitor(SaveImagesTag,scene,
imageListLength,image->client_data);
if (status == MagickFalse)
break;
}
scene++;
} while (image_info->adjoin != MagickFalse);
(void) CloseBlob(image);
return(status);
}","static MagickBooleanType WriteMPCImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
char
VAR_3[VAR_4],
VAR_5[VAR_4];
const char
*VAR_6,
*VAR_7;
MagickBooleanType
VAR_8;
MagickOffsetType
VAR_9,
VAR_10;
register ssize_t
VAR_11;
size_t
VAR_12,
VAR_13;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_14);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_14);
if (VAR_1->debug != VAR_15)
(void) LogMagickEvent(VAR_16,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_14);
VAR_8=OpenBlob(VAR_0,VAR_1,VAR_17,VAR_2);
if (VAR_8 == VAR_15)
return(VAR_8);
(void) CopyMagickString(VAR_5,VAR_1->filename,VAR_4-6);
AppendImageFormat(""cache"",VAR_5);
VAR_10=0;
VAR_9=0;
VAR_13=GetImageListLength(VAR_1);
do
{
VAR_12=GetImageQuantumDepth(VAR_1,VAR_18);
if ((VAR_1->storage_class == VAR_19) &&
(VAR_1->colors > (size_t) (GetQuantumRange(VAR_1->depth)+1)))
(void) SetImageStorageClass(VAR_1,VAR_20,VAR_2);
(void) WriteBlobString(VAR_1,""id=MagickCache\n"");
(void) FormatLocaleString(VAR_3,VAR_4,""magick-signature=%u\n"",
GetMagickSignature((const StringInfo *) NULL));
(void) WriteBlobString(VAR_1,VAR_3);
(void) FormatLocaleString(VAR_3,VAR_4,
""class=%s  colors=%.20g  alpha-trait=%s\n"",CommandOptionToMnemonic(
VAR_21,VAR_1->storage_class),(double) VAR_1->colors,
CommandOptionToMnemonic(VAR_22,(ssize_t)
VAR_1->alpha_trait));
(void) WriteBlobString(VAR_1,VAR_3);
(void) FormatLocaleString(VAR_3,VAR_4,
""number-channels=%.20g  number-meta-channels=%.20g\n"",
(double) VAR_1->number_channels,(double) VAR_1->number_meta_channels);
(void) WriteBlobString(VAR_1,VAR_3);
(void) FormatLocaleString(VAR_3,VAR_4,
""columns=%.20g  rows=%.20g depth=%.20g\n"",(double) VAR_1->columns,
(double) VAR_1->rows,(double) VAR_1->depth);
(void) WriteBlobString(VAR_1,VAR_3);
if (VAR_1->type != VAR_23)
{
(void) FormatLocaleString(VAR_3,VAR_4,""type=%s\n"",
CommandOptionToMnemonic(VAR_24,VAR_1->type));
(void) WriteBlobString(VAR_1,VAR_3);
}
(void) FormatLocaleString(VAR_3,VAR_4,""colorspace=%s\n"",
CommandOptionToMnemonic(VAR_25,VAR_1->colorspace));
(void) WriteBlobString(VAR_1,VAR_3);
if (VAR_1->intensity != VAR_26)
{
(void) FormatLocaleString(VAR_3,VAR_4,
""pixel-intensity=%s\n"",CommandOptionToMnemonic(
VAR_27,VAR_1->intensity));
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->endian != VAR_28)
{
(void) FormatLocaleString(VAR_3,VAR_4,""endian=%s\n"",
CommandOptionToMnemonic(VAR_29,VAR_1->endian));
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->compression != VAR_30)
{
(void) FormatLocaleString(VAR_3,VAR_4,
""compression=%s  quality=%.20g\n"",CommandOptionToMnemonic(
VAR_31,VAR_1->compression),(double) VAR_1->quality);
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->units != VAR_32)
{
(void) FormatLocaleString(VAR_3,VAR_4,""units=%s\n"",
CommandOptionToMnemonic(VAR_33,VAR_1->units));
(void) WriteBlobString(VAR_1,VAR_3);
}
if ((VAR_1->resolution.x != 0) || (VAR_1->resolution.y != 0))
{
(void) FormatLocaleString(VAR_3,VAR_4,
""resolution=%gx%g\n"",VAR_1->resolution.x,VAR_1->resolution.y);
(void) WriteBlobString(VAR_1,VAR_3);
}
if ((VAR_1->page.width != 0) || (VAR_1->page.height != 0))
{
(void) FormatLocaleString(VAR_3,VAR_4,
""page=%.20gx%.20g%+.20g%+.20g\n"",(double) VAR_1->page.width,(double)
VAR_1->page.height,(double) VAR_1->page.x,(double) VAR_1->page.y);
(void) WriteBlobString(VAR_1,VAR_3);
}
else
if ((VAR_1->page.x != 0) || (VAR_1->page.y != 0))
{
(void) FormatLocaleString(VAR_3,VAR_4,""page=%+ld%+ld\n"",
(long) VAR_1->page.x,(long) VAR_1->page.y);
(void) WriteBlobString(VAR_1,VAR_3);
}
if ((VAR_1->tile_offset.x != 0) || (VAR_1->tile_offset.y != 0))
{
(void) FormatLocaleString(VAR_3,VAR_4,
""tile-offset=%+ld%+ld\n"",(long) VAR_1->tile_offset.x,(long)
VAR_1->tile_offset.y);
(void) WriteBlobString(VAR_1,VAR_3);
}
if ((GetNextImageInList(VAR_1) != (Image *) NULL) ||
(GetPreviousImageInList(VAR_1) != (Image *) NULL))
{
if (VAR_1->scene == 0)
(void) FormatLocaleString(VAR_3,VAR_4,
""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",(double)
VAR_1->iterations,(double) VAR_1->delay,(double)
VAR_1->ticks_per_second);
else
(void) FormatLocaleString(VAR_3,VAR_4,""scene=%.20g  ""
""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",
(double) VAR_1->scene,(double) VAR_1->iterations,(double)
VAR_1->delay,(double) VAR_1->ticks_per_second);
(void) WriteBlobString(VAR_1,VAR_3);
}
else
{
if (VAR_1->scene != 0)
{
(void) FormatLocaleString(VAR_3,VAR_4,""scene=%.20g\n"",
(double) VAR_1->scene);
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->iterations != 0)
{
(void) FormatLocaleString(VAR_3,VAR_4,
""iterations=%.20g\n"",(double) VAR_1->iterations);
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->delay != 0)
{
(void) FormatLocaleString(VAR_3,VAR_4,""delay=%.20g\n"",
(double) VAR_1->delay);
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->ticks_per_second != VAR_34)
{
(void) FormatLocaleString(VAR_3,VAR_4,
""ticks-per-second=%.20g\n"",(double) VAR_1->ticks_per_second);
(void) WriteBlobString(VAR_1,VAR_3);
}
}
if (VAR_1->gravity != VAR_35)
{
(void) FormatLocaleString(VAR_3,VAR_4,""gravity=%s\n"",
CommandOptionToMnemonic(VAR_36,VAR_1->gravity));
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->dispose != VAR_37)
{
(void) FormatLocaleString(VAR_3,VAR_4,""dispose=%s\n"",
CommandOptionToMnemonic(VAR_38,VAR_1->dispose));
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->rendering_intent != VAR_39)
{
(void) FormatLocaleString(VAR_3,VAR_4,
""rendering-intent=%s\n"",CommandOptionToMnemonic(VAR_40,
VAR_1->rendering_intent));
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->gamma != 0.0)
{
(void) FormatLocaleString(VAR_3,VAR_4,""gamma=%g\n"",
VAR_1->gamma);
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->chromaticity.white_point.x != 0.0)
{
(void) FormatLocaleString(VAR_3,VAR_4,""red-primary=""
""%g,%g  green-primary=%g,%g  blue-primary=%g,%g\n"",
VAR_1->chromaticity.red_primary.x,VAR_1->chromaticity.red_primary.y,
VAR_1->chromaticity.green_primary.x,
VAR_1->chromaticity.green_primary.y,
VAR_1->chromaticity.blue_primary.x,
VAR_1->chromaticity.blue_primary.y);
(void) WriteBlobString(VAR_1,VAR_3);
(void) FormatLocaleString(VAR_3,VAR_4,
""white-point=%g,%g\n"",VAR_1->chromaticity.white_point.x,
VAR_1->chromaticity.white_point.y);
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->orientation != VAR_41)
{
(void) FormatLocaleString(VAR_3,VAR_4,
""orientation=%s\n"",CommandOptionToMnemonic(VAR_42,
VAR_1->orientation));
(void) WriteBlobString(VAR_1,VAR_3);
}
if (VAR_1->profiles != (void *) NULL)
{
const char
*VAR_43;
const StringInfo
*VAR_44;
ResetImageProfileIterator(VAR_1);
for (VAR_43=GetNextImageProfile(VAR_1); VAR_43 != (const char *) NULL; )
{
VAR_44=GetImageProfile(VAR_1,VAR_43);
if (VAR_44 != (StringInfo *) NULL)
{
(void) FormatLocaleString(VAR_3,VAR_4,""profile=%s\n"",
VAR_43);
(void) WriteBlobString(VAR_1,VAR_3);
}
VAR_43=GetNextImageProfile(VAR_1);
}
}
if (VAR_1->montage != (char *) NULL)
{
(void) FormatLocaleString(VAR_3,VAR_4,""montage=%s\n"",
VAR_1->montage);
(void) WriteBlobString(VAR_1,VAR_3);
}
ResetImagePropertyIterator(VAR_1);
VAR_6=GetNextImageProperty(VAR_1);
while (VAR_6 != (const char *) NULL)
{
(void) FormatLocaleString(VAR_3,VAR_4,""%s="",VAR_6);
(void) WriteBlobString(VAR_1,VAR_3);
VAR_7=GetImageProperty(VAR_1,VAR_6,VAR_2);
if (VAR_7 != (const char *) NULL)
{
size_t
VAR_45;
VAR_45=strlen(VAR_7);
for (VAR_11=0; VAR_11 < (ssize_t) VAR_45; VAR_11++)
if (isspace((int) ((unsigned char) VAR_7[VAR_11])) != 0)
break;
if ((VAR_11 == (ssize_t) VAR_45) && (VAR_11 != 0))
(void) WriteBlob(VAR_1,VAR_45,(const unsigned char *) VAR_7);
else
{
(void) WriteBlobByte(VAR_1,'{');
if (strchr(VAR_7,'}') == (char *) NULL)
(void) WriteBlob(VAR_1,VAR_45,(const unsigned char *) VAR_7);
else
for (VAR_11=0; VAR_11 < (ssize_t) VAR_45; VAR_11++)
{
if (VAR_7[VAR_11] == (int) '}')
(void) WriteBlobByte(VAR_1,'\\');
(void) WriteBlobByte(VAR_1,(unsigned char) VAR_7[VAR_11]);
}
(void) WriteBlobByte(VAR_1,'}');
}
}
(void) WriteBlobByte(VAR_1,'\n');
VAR_6=GetNextImageProperty(VAR_1);
}
(void) WriteBlobString(VAR_1,""\f\n:\032"");
if (VAR_1->montage != (char *) NULL)
{
if (VAR_1->directory != (char *) NULL)
(void) WriteBlobString(VAR_1,VAR_1->directory);
(void) WriteBlobByte(VAR_1,'\0');
}
if (VAR_1->profiles != 0)
{
const char
*VAR_43;
const StringInfo
*VAR_44;
ResetImageProfileIterator(VAR_1);
VAR_43=GetNextImageProfile(VAR_1);
while (VAR_43 != (const char *) NULL)
{
VAR_44=GetImageProfile(VAR_1,VAR_43);
(void) WriteBlobMSBLong(VAR_1,(unsigned int)
GetStringInfoLength(VAR_44));
(void) WriteBlob(VAR_1,GetStringInfoLength(VAR_44),
GetStringInfoDatum(VAR_44));
VAR_43=GetNextImageProfile(VAR_1);
}
}
if (VAR_1->storage_class == VAR_19)
{
size_t
VAR_46;
unsigned char
*VAR_47,
*VAR_48;
VAR_46=(size_t) (3UL*VAR_12/8UL);
VAR_47=(unsigned char *) AcquireQuantumMemory(VAR_1->colors,
VAR_46*sizeof(*VAR_47));
if (VAR_47 == (unsigned char *) NULL)
return(VAR_15);
VAR_48=VAR_47;
for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->colors; VAR_11++)
{
switch (VAR_12)
{
default:
ThrowWriterException(VAR_49,""ImageDepthNotSupported"");
case 32:
{
unsigned int
VAR_50;
VAR_50=ScaleQuantumToLong(ClampToQuantum(VAR_1->colormap[VAR_11].red));
VAR_48=PopLongPixel(VAR_51,VAR_50,VAR_48);
VAR_50=ScaleQuantumToLong(ClampToQuantum(
VAR_1->colormap[VAR_11].green));
VAR_48=PopLongPixel(VAR_51,VAR_50,VAR_48);
VAR_50=ScaleQuantumToLong(ClampToQuantum(VAR_1->colormap[VAR_11].blue));
VAR_48=PopLongPixel(VAR_51,VAR_50,VAR_48);
break;
}
case 16:
{
unsigned short
VAR_50;
VAR_50=ScaleQuantumToShort(ClampToQuantum(VAR_1->colormap[VAR_11].red));
VAR_48=PopShortPixel(VAR_51,VAR_50,VAR_48);
VAR_50=ScaleQuantumToShort(ClampToQuantum(
VAR_1->colormap[VAR_11].green));
VAR_48=PopShortPixel(VAR_51,VAR_50,VAR_48);
VAR_50=ScaleQuantumToShort(ClampToQuantum(
VAR_1->colormap[VAR_11].blue));
VAR_48=PopShortPixel(VAR_51,VAR_50,VAR_48);
break;
}
case 8:
{
unsigned char
VAR_50;
VAR_50=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
VAR_1->colormap[VAR_11].red));
VAR_48=PopCharPixel(VAR_50,VAR_48);
VAR_50=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
VAR_1->colormap[VAR_11].green));
VAR_48=PopCharPixel(VAR_50,VAR_48);
VAR_50=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
VAR_1->colormap[VAR_11].blue));
VAR_48=PopCharPixel(VAR_50,VAR_48);
break;
}
}
}
(void) WriteBlob(VAR_1,VAR_46*VAR_1->colors,VAR_47);
VAR_47=(unsigned char *) RelinquishMagickMemory(VAR_47);
}
VAR_8=PersistPixelCache(VAR_1,VAR_5,VAR_15,&VAR_9,
VAR_2);
if (VAR_8 == VAR_15)
ThrowWriterException(VAR_52,""UnableToPersistPixelCache"");
if (GetNextImageInList(VAR_1) == (Image *) NULL)
break;
VAR_1=SyncNextImageInList(VAR_1);
if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
{
VAR_8=VAR_1->progress_monitor(VAR_53,VAR_10,
VAR_13,VAR_1->client_data);
if (VAR_8 == VAR_15)
break;
}
VAR_10++;
} while (VAR_0->adjoin != VAR_15);
(void) CloseBlob(VAR_1);
return(VAR_8);
}",ImageMagick/98a2cceae0dceccbfe54051167c2c80be1f13c3f/mpc.c/vul/before/0.json,"static MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  char
    buffer[MagickPathExtent],
    cache_filename[MagickPathExtent];

  const char
    *property,
    *value;

  MagickBooleanType
    status;

  MagickOffsetType
    offset,
    scene;

  register ssize_t
    i;

  size_t
    depth,
    imageListLength;

  /*
    Open persistent cache.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent-6);
  AppendImageFormat(""cache"",cache_filename);
  scene=0;
  offset=0;
  imageListLength=GetImageListLength(image);
  do
  {
    /*
      Write persistent cache meta-information.
    */
    depth=GetImageQuantumDepth(image,MagickTrue);
    if ((image->storage_class == PseudoClass) &&
        (image->colors > (size_t) (GetQuantumRange(image->depth)+1)))
      (void) SetImageStorageClass(image,DirectClass,exception);
    (void) WriteBlobString(image,""id=MagickCache\n"");
    (void) FormatLocaleString(buffer,MagickPathExtent,""magick-signature=%u\n"",
      GetMagickSignature((const StringInfo *) NULL));
    (void) WriteBlobString(image,buffer);
    (void) FormatLocaleString(buffer,MagickPathExtent,
      ""class=%s  colors=%.20g  alpha-trait=%s\n"",CommandOptionToMnemonic(
      MagickClassOptions,image->storage_class),(double) image->colors,
      CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)
      image->alpha_trait));
    (void) WriteBlobString(image,buffer);
    (void) FormatLocaleString(buffer,MagickPathExtent,
      ""number-channels=%.20g  number-meta-channels=%.20g\n"",
      (double) image->number_channels,(double) image->number_meta_channels);
    (void) WriteBlobString(image,buffer);
    (void) FormatLocaleString(buffer,MagickPathExtent,
      ""columns=%.20g  rows=%.20g depth=%.20g\n"",(double) image->columns,
      (double) image->rows,(double) image->depth);
    (void) WriteBlobString(image,buffer);
    if (image->type != UndefinedType)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,""type=%s\n"",
          CommandOptionToMnemonic(MagickTypeOptions,image->type));
        (void) WriteBlobString(image,buffer);
      }
    (void) FormatLocaleString(buffer,MagickPathExtent,""colorspace=%s\n"",
      CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));
    (void) WriteBlobString(image,buffer);
    if (image->intensity != UndefinedPixelIntensityMethod)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""pixel-intensity=%s\n"",CommandOptionToMnemonic(
          MagickPixelIntensityOptions,image->intensity));
        (void) WriteBlobString(image,buffer);
      }
    if (image->endian != UndefinedEndian)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,""endian=%s\n"",
          CommandOptionToMnemonic(MagickEndianOptions,image->endian));
        (void) WriteBlobString(image,buffer);
      }
    if (image->compression != UndefinedCompression)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""compression=%s  quality=%.20g\n"",CommandOptionToMnemonic(
          MagickCompressOptions,image->compression),(double) image->quality);
        (void) WriteBlobString(image,buffer);
      }
    if (image->units != UndefinedResolution)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,""units=%s\n"",
          CommandOptionToMnemonic(MagickResolutionOptions,image->units));
        (void) WriteBlobString(image,buffer);
      }
    if ((image->resolution.x != 0) || (image->resolution.y != 0))
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""resolution=%gx%g\n"",image->resolution.x,image->resolution.y);
        (void) WriteBlobString(image,buffer);
      }
    if ((image->page.width != 0) || (image->page.height != 0))
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""page=%.20gx%.20g%+.20g%+.20g\n"",(double) image->page.width,(double)
          image->page.height,(double) image->page.x,(double) image->page.y);
        (void) WriteBlobString(image,buffer);
      }
    else
      if ((image->page.x != 0) || (image->page.y != 0))
        {
          (void) FormatLocaleString(buffer,MagickPathExtent,""page=%+ld%+ld\n"",
            (long) image->page.x,(long) image->page.y);
          (void) WriteBlobString(image,buffer);
        }
    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""tile-offset=%+ld%+ld\n"",(long) image->tile_offset.x,(long)
           image->tile_offset.y);
        (void) WriteBlobString(image,buffer);
      }
    if ((GetNextImageInList(image) != (Image *) NULL) ||
        (GetPreviousImageInList(image) != (Image *) NULL))
      {
        if (image->scene == 0)
          (void) FormatLocaleString(buffer,MagickPathExtent,
            ""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",(double)
            image->iterations,(double) image->delay,(double)
            image->ticks_per_second);
        else
          (void) FormatLocaleString(buffer,MagickPathExtent,""scene=%.20g  ""
            ""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",
            (double) image->scene,(double) image->iterations,(double)
            image->delay,(double) image->ticks_per_second);
        (void) WriteBlobString(image,buffer);
      }
    else
      {
        if (image->scene != 0)
          {
            (void) FormatLocaleString(buffer,MagickPathExtent,""scene=%.20g\n"",
              (double) image->scene);
            (void) WriteBlobString(image,buffer);
          }
        if (image->iterations != 0)
          {
            (void) FormatLocaleString(buffer,MagickPathExtent,
              ""iterations=%.20g\n"",(double) image->iterations);
            (void) WriteBlobString(image,buffer);
          }
        if (image->delay != 0)
          {
            (void) FormatLocaleString(buffer,MagickPathExtent,""delay=%.20g\n"",
              (double) image->delay);
            (void) WriteBlobString(image,buffer);
          }
        if (image->ticks_per_second != UndefinedTicksPerSecond)
          {
            (void) FormatLocaleString(buffer,MagickPathExtent,
              ""ticks-per-second=%.20g\n"",(double) image->ticks_per_second);
            (void) WriteBlobString(image,buffer);
          }
      }
    if (image->gravity != UndefinedGravity)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,""gravity=%s\n"",
          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));
        (void) WriteBlobString(image,buffer);
      }
    if (image->dispose != UndefinedDispose)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,""dispose=%s\n"",
          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));
        (void) WriteBlobString(image,buffer);
      }
    if (image->rendering_intent != UndefinedIntent)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""rendering-intent=%s\n"",CommandOptionToMnemonic(MagickIntentOptions,
          image->rendering_intent));
        (void) WriteBlobString(image,buffer);
      }
    if (image->gamma != 0.0)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,""gamma=%g\n"",
          image->gamma);
        (void) WriteBlobString(image,buffer);
      }
    if (image->chromaticity.white_point.x != 0.0)
      {
        /*
          Note chomaticity points.
        */
        (void) FormatLocaleString(buffer,MagickPathExtent,""red-primary=""
          ""%g,%g  green-primary=%g,%g  blue-primary=%g,%g\n"",
          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,
          image->chromaticity.green_primary.x,
          image->chromaticity.green_primary.y,
          image->chromaticity.blue_primary.x,
          image->chromaticity.blue_primary.y);
        (void) WriteBlobString(image,buffer);
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""white-point=%g,%g\n"",image->chromaticity.white_point.x,
          image->chromaticity.white_point.y);
        (void) WriteBlobString(image,buffer);
      }
    if (image->orientation != UndefinedOrientation)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,
          ""orientation=%s\n"",CommandOptionToMnemonic(MagickOrientationOptions,
          image->orientation));
        (void) WriteBlobString(image,buffer);
      }
    if (image->profiles != (void *) NULL)
      {
        const char
          *name;

        const StringInfo
          *profile;

        /*
          Write image profile names.
        */
        ResetImageProfileIterator(image);
        for (name=GetNextImageProfile(image); name != (const char *) NULL; )
        {
          profile=GetImageProfile(image,name);
          if (profile != (StringInfo *) NULL)
            {
              (void) FormatLocaleString(buffer,MagickPathExtent,""profile=%s\n"",
                name);
              (void) WriteBlobString(image,buffer);
            }
          name=GetNextImageProfile(image);
        }
      }
    if (image->montage != (char *) NULL)
      {
        (void) FormatLocaleString(buffer,MagickPathExtent,""montage=%s\n"",
          image->montage);
        (void) WriteBlobString(image,buffer);
      }
    ResetImagePropertyIterator(image);
    property=GetNextImageProperty(image);
    while (property != (const char *) NULL)
    {
      (void) FormatLocaleString(buffer,MagickPathExtent,""%s="",property);
      (void) WriteBlobString(image,buffer);
      value=GetImageProperty(image,property,exception);
      if (value != (const char *) NULL)
        {
          size_t
            length;

          length=strlen(value);
          for (i=0; i < (ssize_t) length; i++)
            if (isspace((int) ((unsigned char) value[i])) != 0)
              break;
          if ((i == (ssize_t) length) && (i != 0))
            (void) WriteBlob(image,length,(const unsigned char *) value);
          else
            {
              (void) WriteBlobByte(image,'{');
              if (strchr(value,'}') == (char *) NULL)
                (void) WriteBlob(image,length,(const unsigned char *) value);
              else
                for (i=0; i < (ssize_t) length; i++)
                {
                  if (value[i] == (int) '}')
                    (void) WriteBlobByte(image,'\\');
                  (void) WriteBlobByte(image,(unsigned char) value[i]);
                }
              (void) WriteBlobByte(image,'}');
            }
        }
      (void) WriteBlobByte(image,'\n');
      property=GetNextImageProperty(image);
    }
    (void) WriteBlobString(image,""\f\n:\032"");
    if (image->montage != (char *) NULL)
      {
        /*
          Write montage tile directory.
        */
        if (image->directory != (char *) NULL)
          (void) WriteBlobString(image,image->directory);
        (void) WriteBlobByte(image,'\0');
      }
    if (image->profiles != 0)
      {
        const char
          *name;

        const StringInfo
          *profile;

        /*
          Write image profile blobs.
        */
        ResetImageProfileIterator(image);
        name=GetNextImageProfile(image);
        while (name != (const char *) NULL)
        {
          profile=GetImageProfile(image,name);
          (void) WriteBlobMSBLong(image,(unsigned int)
            GetStringInfoLength(profile));
          (void) WriteBlob(image,GetStringInfoLength(profile),
            GetStringInfoDatum(profile));
          name=GetNextImageProfile(image);
        }
      }
    if (image->storage_class == PseudoClass)
      {
        size_t
          packet_size;

        unsigned char
          *colormap,
          *q;

        /*
          Allocate colormap.
        */
        packet_size=(size_t) (3UL*depth/8UL);
        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          packet_size*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          return(MagickFalse);
        /*
          Write colormap to file.
        */
        q=colormap;
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          switch (depth)
          {
            default:
            {
              colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              ThrowWriterException(CorruptImageError,""ImageDepthNotSupported"");
              break;
            }
            case 32:
            {
              unsigned int
                pixel;

              pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].red));
              q=PopLongPixel(MSBEndian,pixel,q);
              pixel=ScaleQuantumToLong(ClampToQuantum(
                image->colormap[i].green));
              q=PopLongPixel(MSBEndian,pixel,q);
              pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].blue));
              q=PopLongPixel(MSBEndian,pixel,q);
              break;
            }
            case 16:
            {
              unsigned short
                pixel;

              pixel=ScaleQuantumToShort(ClampToQuantum(image->colormap[i].red));
              q=PopShortPixel(MSBEndian,pixel,q);
              pixel=ScaleQuantumToShort(ClampToQuantum(
                image->colormap[i].green));
              q=PopShortPixel(MSBEndian,pixel,q);
              pixel=ScaleQuantumToShort(ClampToQuantum(
                image->colormap[i].blue));
              q=PopShortPixel(MSBEndian,pixel,q);
              break;
            }
            case 8:
            {
              unsigned char
                pixel;

              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
                image->colormap[i].red));
              q=PopCharPixel(pixel,q);
              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
                image->colormap[i].green));
              q=PopCharPixel(pixel,q);
              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
                image->colormap[i].blue));
              q=PopCharPixel(pixel,q);
              break;
            }
          }
        }
        (void) WriteBlob(image,packet_size*image->colors,colormap);
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      }
    /*
      Initialize persistent pixel cache.
    */
    status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,
      exception);
    if (status == MagickFalse)
      ThrowWriterException(CacheError,""UnableToPersistPixelCache"");
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    if (image->progress_monitor != (MagickProgressMonitor) NULL)
      {
        status=image->progress_monitor(SaveImagesTag,scene,
          imageListLength,image->client_data);
        if (status == MagickFalse)
          break;
      }
    scene++;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(status);
}","static MagickBooleanType WriteMPCImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  char
    VAR_3[VAR_4],
    VAR_5[VAR_4];

  const char
    *VAR_6,
    *VAR_7;

  MagickBooleanType
    VAR_8;

  MagickOffsetType
    VAR_9,
    VAR_10;

  register ssize_t
    VAR_11;

  size_t
    VAR_12,
    VAR_13;

  /* COMMENT_0 */
                          
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_14);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_14);
  if (VAR_1->debug != VAR_15)
    (void) LogMagickEvent(VAR_16,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_14);
  VAR_8=OpenBlob(VAR_0,VAR_1,VAR_17,VAR_2);
  if (VAR_8 == VAR_15)
    return(VAR_8);
  (void) CopyMagickString(VAR_5,VAR_1->filename,VAR_4-6);
  AppendImageFormat(""cache"",VAR_5);
  VAR_10=0;
  VAR_9=0;
  VAR_13=GetImageListLength(VAR_1);
  do
  {
    /* COMMENT_3 */
                                              
      
    VAR_12=GetImageQuantumDepth(VAR_1,VAR_18);
    if ((VAR_1->storage_class == VAR_19) &&
        (VAR_1->colors > (size_t) (GetQuantumRange(VAR_1->depth)+1)))
      (void) SetImageStorageClass(VAR_1,VAR_20,VAR_2);
    (void) WriteBlobString(VAR_1,""id=MagickCache\n"");
    (void) FormatLocaleString(VAR_3,VAR_4,""magick-signature=%u\n"",
      GetMagickSignature((const StringInfo *) NULL));
    (void) WriteBlobString(VAR_1,VAR_3);
    (void) FormatLocaleString(VAR_3,VAR_4,
      ""class=%s  colors=%.20g  alpha-trait=%s\n"",CommandOptionToMnemonic(
      VAR_21,VAR_1->storage_class),(double) VAR_1->colors,
      CommandOptionToMnemonic(VAR_22,(ssize_t)
      VAR_1->alpha_trait));
    (void) WriteBlobString(VAR_1,VAR_3);
    (void) FormatLocaleString(VAR_3,VAR_4,
      ""number-channels=%.20g  number-meta-channels=%.20g\n"",
      (double) VAR_1->number_channels,(double) VAR_1->number_meta_channels);
    (void) WriteBlobString(VAR_1,VAR_3);
    (void) FormatLocaleString(VAR_3,VAR_4,
      ""columns=%.20g  rows=%.20g depth=%.20g\n"",(double) VAR_1->columns,
      (double) VAR_1->rows,(double) VAR_1->depth);
    (void) WriteBlobString(VAR_1,VAR_3);
    if (VAR_1->type != VAR_23)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,""type=%s\n"",
          CommandOptionToMnemonic(VAR_24,VAR_1->type));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    (void) FormatLocaleString(VAR_3,VAR_4,""colorspace=%s\n"",
      CommandOptionToMnemonic(VAR_25,VAR_1->colorspace));
    (void) WriteBlobString(VAR_1,VAR_3);
    if (VAR_1->intensity != VAR_26)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""pixel-intensity=%s\n"",CommandOptionToMnemonic(
          VAR_27,VAR_1->intensity));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->endian != VAR_28)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,""endian=%s\n"",
          CommandOptionToMnemonic(VAR_29,VAR_1->endian));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->compression != VAR_30)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""compression=%s  quality=%.20g\n"",CommandOptionToMnemonic(
          VAR_31,VAR_1->compression),(double) VAR_1->quality);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->units != VAR_32)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,""units=%s\n"",
          CommandOptionToMnemonic(VAR_33,VAR_1->units));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if ((VAR_1->resolution.x != 0) || (VAR_1->resolution.y != 0))
      {
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""resolution=%gx%g\n"",VAR_1->resolution.x,VAR_1->resolution.y);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if ((VAR_1->page.width != 0) || (VAR_1->page.height != 0))
      {
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""page=%.20gx%.20g%+.20g%+.20g\n"",(double) VAR_1->page.width,(double)
          VAR_1->page.height,(double) VAR_1->page.x,(double) VAR_1->page.y);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    else
      if ((VAR_1->page.x != 0) || (VAR_1->page.y != 0))
        {
          (void) FormatLocaleString(VAR_3,VAR_4,""page=%+ld%+ld\n"",
            (long) VAR_1->page.x,(long) VAR_1->page.y);
          (void) WriteBlobString(VAR_1,VAR_3);
        }
    if ((VAR_1->tile_offset.x != 0) || (VAR_1->tile_offset.y != 0))
      {
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""tile-offset=%+ld%+ld\n"",(long) VAR_1->tile_offset.x,(long)
           VAR_1->tile_offset.y);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if ((GetNextImageInList(VAR_1) != (Image *) NULL) ||
        (GetPreviousImageInList(VAR_1) != (Image *) NULL))
      {
        if (VAR_1->scene == 0)
          (void) FormatLocaleString(VAR_3,VAR_4,
            ""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",(double)
            VAR_1->iterations,(double) VAR_1->delay,(double)
            VAR_1->ticks_per_second);
        else
          (void) FormatLocaleString(VAR_3,VAR_4,""scene=%.20g  ""
            ""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",
            (double) VAR_1->scene,(double) VAR_1->iterations,(double)
            VAR_1->delay,(double) VAR_1->ticks_per_second);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    else
      {
        if (VAR_1->scene != 0)
          {
            (void) FormatLocaleString(VAR_3,VAR_4,""scene=%.20g\n"",
              (double) VAR_1->scene);
            (void) WriteBlobString(VAR_1,VAR_3);
          }
        if (VAR_1->iterations != 0)
          {
            (void) FormatLocaleString(VAR_3,VAR_4,
              ""iterations=%.20g\n"",(double) VAR_1->iterations);
            (void) WriteBlobString(VAR_1,VAR_3);
          }
        if (VAR_1->delay != 0)
          {
            (void) FormatLocaleString(VAR_3,VAR_4,""delay=%.20g\n"",
              (double) VAR_1->delay);
            (void) WriteBlobString(VAR_1,VAR_3);
          }
        if (VAR_1->ticks_per_second != VAR_34)
          {
            (void) FormatLocaleString(VAR_3,VAR_4,
              ""ticks-per-second=%.20g\n"",(double) VAR_1->ticks_per_second);
            (void) WriteBlobString(VAR_1,VAR_3);
          }
      }
    if (VAR_1->gravity != VAR_35)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,""gravity=%s\n"",
          CommandOptionToMnemonic(VAR_36,VAR_1->gravity));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->dispose != VAR_37)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,""dispose=%s\n"",
          CommandOptionToMnemonic(VAR_38,VAR_1->dispose));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->rendering_intent != VAR_39)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""rendering-intent=%s\n"",CommandOptionToMnemonic(VAR_40,
          VAR_1->rendering_intent));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->gamma != 0.0)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,""gamma=%g\n"",
          VAR_1->gamma);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->chromaticity.white_point.x != 0.0)
      {
        /* COMMENT_6 */
                                  
          
        (void) FormatLocaleString(VAR_3,VAR_4,""red-primary=""
          ""%g,%g  green-primary=%g,%g  blue-primary=%g,%g\n"",
          VAR_1->chromaticity.red_primary.x,VAR_1->chromaticity.red_primary.y,
          VAR_1->chromaticity.green_primary.x,
          VAR_1->chromaticity.green_primary.y,
          VAR_1->chromaticity.blue_primary.x,
          VAR_1->chromaticity.blue_primary.y);
        (void) WriteBlobString(VAR_1,VAR_3);
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""white-point=%g,%g\n"",VAR_1->chromaticity.white_point.x,
          VAR_1->chromaticity.white_point.y);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->orientation != VAR_41)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,
          ""orientation=%s\n"",CommandOptionToMnemonic(VAR_42,
          VAR_1->orientation));
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    if (VAR_1->profiles != (void *) NULL)
      {
        const char
          *VAR_43;

        const StringInfo
          *VAR_44;

        /* COMMENT_9 */
                                    
          
        ResetImageProfileIterator(VAR_1);
        for (VAR_43=GetNextImageProfile(VAR_1); VAR_43 != (const char *) NULL; )
        {
          VAR_44=GetImageProfile(VAR_1,VAR_43);
          if (VAR_44 != (StringInfo *) NULL)
            {
              (void) FormatLocaleString(VAR_3,VAR_4,""profile=%s\n"",
                VAR_43);
              (void) WriteBlobString(VAR_1,VAR_3);
            }
          VAR_43=GetNextImageProfile(VAR_1);
        }
      }
    if (VAR_1->montage != (char *) NULL)
      {
        (void) FormatLocaleString(VAR_3,VAR_4,""montage=%s\n"",
          VAR_1->montage);
        (void) WriteBlobString(VAR_1,VAR_3);
      }
    ResetImagePropertyIterator(VAR_1);
    VAR_6=GetNextImageProperty(VAR_1);
    while (VAR_6 != (const char *) NULL)
    {
      (void) FormatLocaleString(VAR_3,VAR_4,""%s="",VAR_6);
      (void) WriteBlobString(VAR_1,VAR_3);
      VAR_7=GetImageProperty(VAR_1,VAR_6,VAR_2);
      if (VAR_7 != (const char *) NULL)
        {
          size_t
            VAR_45;

          VAR_45=strlen(VAR_7);
          for (VAR_11=0; VAR_11 < (ssize_t) VAR_45; VAR_11++)
            if (isspace((int) ((unsigned char) VAR_7[VAR_11])) != 0)
              break;
          if ((VAR_11 == (ssize_t) VAR_45) && (VAR_11 != 0))
            (void) WriteBlob(VAR_1,VAR_45,(const unsigned char *) VAR_7);
          else
            {
              (void) WriteBlobByte(VAR_1,'{');
              if (strchr(VAR_7,'}') == (char *) NULL)
                (void) WriteBlob(VAR_1,VAR_45,(const unsigned char *) VAR_7);
              else
                for (VAR_11=0; VAR_11 < (ssize_t) VAR_45; VAR_11++)
                {
                  if (VAR_7[VAR_11] == (int) '}')
                    (void) WriteBlobByte(VAR_1,'\\');
                  (void) WriteBlobByte(VAR_1,(unsigned char) VAR_7[VAR_11]);
                }
              (void) WriteBlobByte(VAR_1,'}');
            }
        }
      (void) WriteBlobByte(VAR_1,'\n');
      VAR_6=GetNextImageProperty(VAR_1);
    }
    (void) WriteBlobString(VAR_1,""\f\n:\032"");
    if (VAR_1->montage != (char *) NULL)
      {
        /* COMMENT_12 */
                                       
          
        if (VAR_1->directory != (char *) NULL)
          (void) WriteBlobString(VAR_1,VAR_1->directory);
        (void) WriteBlobByte(VAR_1,'\0');
      }
    if (VAR_1->profiles != 0)
      {
        const char
          *VAR_43;

        const StringInfo
          *VAR_44;

        /* COMMENT_15 */
                                    
          
        ResetImageProfileIterator(VAR_1);
        VAR_43=GetNextImageProfile(VAR_1);
        while (VAR_43 != (const char *) NULL)
        {
          VAR_44=GetImageProfile(VAR_1,VAR_43);
          (void) WriteBlobMSBLong(VAR_1,(unsigned int)
            GetStringInfoLength(VAR_44));
          (void) WriteBlob(VAR_1,GetStringInfoLength(VAR_44),
            GetStringInfoDatum(VAR_44));
          VAR_43=GetNextImageProfile(VAR_1);
        }
      }
    if (VAR_1->storage_class == VAR_19)
      {
        size_t
          VAR_46;

        unsigned char
          *VAR_47,
          *VAR_48;

        /* COMMENT_18 */
                            
          
        VAR_46=(size_t) (3UL*VAR_12/8UL);
        VAR_47=(unsigned char *) AcquireQuantumMemory(VAR_1->colors,
          VAR_46*sizeof(*VAR_47));
        if (VAR_47 == (unsigned char *) NULL)
          return(VAR_15);
        /* COMMENT_21 */
                                 
          
        VAR_48=VAR_47;
        for (VAR_11=0; VAR_11 < (ssize_t) VAR_1->colors; VAR_11++)
        {
          switch (VAR_12)
          {
            default:
            {
              VAR_47=(unsigned char *) RelinquishMagickMemory(VAR_47);
              ThrowWriterException(VAR_49,""ImageDepthNotSupported"");
              break;
            }
            case 32:
            {
              unsigned int
                VAR_50;

              VAR_50=ScaleQuantumToLong(ClampToQuantum(VAR_1->colormap[VAR_11].red));
              VAR_48=PopLongPixel(VAR_51,VAR_50,VAR_48);
              VAR_50=ScaleQuantumToLong(ClampToQuantum(
                VAR_1->colormap[VAR_11].green));
              VAR_48=PopLongPixel(VAR_51,VAR_50,VAR_48);
              VAR_50=ScaleQuantumToLong(ClampToQuantum(VAR_1->colormap[VAR_11].blue));
              VAR_48=PopLongPixel(VAR_51,VAR_50,VAR_48);
              break;
            }
            case 16:
            {
              unsigned short
                VAR_50;

              VAR_50=ScaleQuantumToShort(ClampToQuantum(VAR_1->colormap[VAR_11].red));
              VAR_48=PopShortPixel(VAR_51,VAR_50,VAR_48);
              VAR_50=ScaleQuantumToShort(ClampToQuantum(
                VAR_1->colormap[VAR_11].green));
              VAR_48=PopShortPixel(VAR_51,VAR_50,VAR_48);
              VAR_50=ScaleQuantumToShort(ClampToQuantum(
                VAR_1->colormap[VAR_11].blue));
              VAR_48=PopShortPixel(VAR_51,VAR_50,VAR_48);
              break;
            }
            case 8:
            {
              unsigned char
                VAR_50;

              VAR_50=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
                VAR_1->colormap[VAR_11].red));
              VAR_48=PopCharPixel(VAR_50,VAR_48);
              VAR_50=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
                VAR_1->colormap[VAR_11].green));
              VAR_48=PopCharPixel(VAR_50,VAR_48);
              VAR_50=(unsigned char) ScaleQuantumToChar(ClampToQuantum(
                VAR_1->colormap[VAR_11].blue));
              VAR_48=PopCharPixel(VAR_50,VAR_48);
              break;
            }
          }
        }
        (void) WriteBlob(VAR_1,VAR_46*VAR_1->colors,VAR_47);
        VAR_47=(unsigned char *) RelinquishMagickMemory(VAR_47);
      }
    /* COMMENT_24 */
                                        
      
    VAR_8=PersistPixelCache(VAR_1,VAR_5,VAR_15,&VAR_9,
      VAR_2);
    if (VAR_8 == VAR_15)
      ThrowWriterException(VAR_52,""UnableToPersistPixelCache"");
    if (GetNextImageInList(VAR_1) == (Image *) NULL)
      break;
    VAR_1=SyncNextImageInList(VAR_1);
    if (VAR_1->progress_monitor != (MagickProgressMonitor) NULL)
      {
        VAR_8=VAR_1->progress_monitor(VAR_53,VAR_10,
          VAR_13,VAR_1->client_data);
        if (VAR_8 == VAR_15)
          break;
      }
    VAR_10++;
  } while (VAR_0->adjoin != VAR_15);
  (void) CloseBlob(VAR_1);
  return(VAR_8);
}",ImageMagick/98a2cceae0dceccbfe54051167c2c80be1f13c3f/mpc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -348,7 +348,11 @@
           switch (depth)
           {
             default:
+            {
+              colormap=(unsigned char *) RelinquishMagickMemory(colormap);
               ThrowWriterException(CorruptImageError,""ImageDepthNotSupported"");
+              break;
+            }
             case 32:
             {
               unsigned int","{'deleted_lines': [], 'added_lines': ['            {', '              colormap=(unsigned char *) RelinquishMagickMemory(colormap);', '              break;', '            }']}",True,ImageMagick 7.0.8-4 has a memory leak for a colormap in WriteMPCImage in coders/mpc.c.,6.5,MEDIUM,1,test,2018-07-04T18:17:07Z,2
CVE-2018-14437,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1190,082223fb992448dbb574747deac9a30f986c116e,https://github.com/ImageMagick/ImageMagick/commit/082223fb992448dbb574747deac9a30f986c116e,coders/meta.c,parse8BIM,"static ssize_t parse8BIM(Image *ifile, Image *ofile)
{
char
brkused,
quoted,
*line,
*token,
*newstr,
*name;
int
state,
next;
unsigned char
dataset;
unsigned int
recnum;
int
inputlen = MagickPathExtent;
MagickOffsetType
savedpos,
currentpos;
ssize_t
savedolen = 0L,
outputlen = 0L;
TokenInfo
*token_info;
dataset = 0;
recnum = 0;
line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));
if (line == (char *) NULL)
return(-1);
newstr = name = token = (char *) NULL;
savedpos = 0;
token_info=AcquireTokenInfo();
while (super_fgets(&line,&inputlen,ifile)!=NULL)
{
state=0;
next=0;
token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));
if (token == (char *) NULL)
break;
newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));
if (newstr == (char *) NULL)
break;
while (Tokenizer(token_info,0,token,(size_t) inputlen,line,"""",""="",""\"""",0,
&brkused,&next,&quoted)==0)
{
if (state == 0)
{
int
state,
next;
char
brkused,
quoted;
state=0;
next=0;
while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""#"",
"""", 0,&brkused,&next,&quoted)==0)
{
switch (state)
{
case 0:
if (strcmp(newstr,""8BIM"")==0)
dataset = 255;
else
dataset = (unsigned char) StringToLong(newstr);
break;
case 1:
recnum = (unsigned int) StringToUnsignedLong(newstr);
break;
case 2:
name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,
sizeof(*name));
if (name)
(void) strcpy(name,newstr);
break;
}
state++;
}
}
else
if (state == 1)
{
int
next;
ssize_t
len;
char
brkused,
quoted;
next=0;
len = (ssize_t) strlen(token);
while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""&"",
"""",0,&brkused,&next,&quoted)==0)
{
if (brkused && next > 0)
{
size_t
codes_length;
char
*s = &token[next-1];
codes_length=convertHTMLcodes(s, strlen(s));
if ((ssize_t) codes_length > len)
len=0;
else
len-=codes_length;
}
}
if (dataset == 255)
{
unsigned char
nlen = 0;
int
i;
if (savedolen > 0)
{
MagickOffsetType
offset;
ssize_t diff = outputlen - savedolen;
currentpos = TellBlob(ofile);
if (currentpos < 0)
return(-1);
offset=SeekBlob(ofile,savedpos,SEEK_SET);
if (offset < 0)
return(-1);
(void) WriteBlobMSBLong(ofile,(unsigned int) diff);
offset=SeekBlob(ofile,currentpos,SEEK_SET);
if (offset < 0)
return(-1);
savedolen = 0L;
}
if (outputlen & 1)
{
(void) WriteBlobByte(ofile,0x00);
outputlen++;
}
(void) WriteBlobString(ofile,""8BIM"");
(void) WriteBlobMSBShort(ofile,(unsigned short) recnum);
outputlen += 6;
if (name)
nlen = (unsigned char) strlen(name);
(void) WriteBlobByte(ofile,nlen);
outputlen++;
for (i=0; i<nlen; i++)
(void) WriteBlobByte(ofile,(unsigned char) name[i]);
outputlen += nlen;
if ((nlen & 0x01) == 0)
{
(void) WriteBlobByte(ofile,0x00);
outputlen++;
}
if (recnum != IPTC_ID)
{
(void) WriteBlobMSBLong(ofile, (unsigned int) len);
outputlen += 4;
next=0;
outputlen += len;
while (len-- > 0)
(void) WriteBlobByte(ofile,(unsigned char) token[next++]);
if (outputlen & 1)
{
(void) WriteBlobByte(ofile,0x00);
outputlen++;
}
}
else
{
savedpos = TellBlob(ofile);
if (savedpos < 0)
return(-1);
(void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);
outputlen += 4;
savedolen = outputlen;
}
}
else
{
if (len <= 0x7FFF)
{
(void) WriteBlobByte(ofile,0x1c);
(void) WriteBlobByte(ofile,(unsigned char) dataset);
(void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));
(void) WriteBlobMSBShort(ofile,(unsigned short) len);
outputlen += 5;
next=0;
outputlen += len;
while (len-- > 0)
(void) WriteBlobByte(ofile,(unsigned char) token[next++]);
}
}
}
state++;
}
if (token != (char *) NULL)
token=DestroyString(token);
if (newstr != (char *) NULL)
newstr=DestroyString(newstr);
if (name != (char *) NULL)
name=DestroyString(name);
}
token_info=DestroyTokenInfo(token_info);
if (token != (char *) NULL)
token=DestroyString(token);
if (newstr != (char *) NULL)
newstr=DestroyString(newstr);
if (name != (char *) NULL)
name=DestroyString(name);
line=DestroyString(line);
if (savedolen > 0)
{
MagickOffsetType
offset;
ssize_t diff = outputlen - savedolen;
currentpos = TellBlob(ofile);
if (currentpos < 0)
return(-1);
offset=SeekBlob(ofile,savedpos,SEEK_SET);
if (offset < 0)
return(-1);
(void) WriteBlobMSBLong(ofile,(unsigned int) diff);
offset=SeekBlob(ofile,currentpos,SEEK_SET);
if (offset < 0)
return(-1);
savedolen = 0L;
}
return outputlen;
}","static ssize_t parse8BIM(Image *VAR_0, Image *VAR_1)
{
char
VAR_2,
VAR_3,
*VAR_4,
*VAR_5,
*VAR_6,
*VAR_7;
int
VAR_8,
VAR_9;
unsigned char
VAR_10;
unsigned int
VAR_11;
int
VAR_12 = VAR_13;
MagickOffsetType
VAR_14,
VAR_15;
ssize_t
VAR_16 = 0L,
VAR_17 = 0L;
TokenInfo
*VAR_18;
VAR_10 = 0;
VAR_11 = 0;
VAR_4 = (char *) AcquireQuantumMemory((size_t) VAR_12,sizeof(*VAR_4));
if (VAR_4 == (char *) NULL)
return(-1);
VAR_6 = VAR_7 = VAR_5 = (char *) NULL;
VAR_14 = 0;
VAR_18=AcquireTokenInfo();
while (super_fgets(&VAR_4,&VAR_12,VAR_0)!=NULL)
{
VAR_8=0;
VAR_9=0;
VAR_5=(char *) AcquireQuantumMemory((size_t) VAR_12,sizeof(*VAR_5));
if (VAR_5 == (char *) NULL)
break;
VAR_6=(char *) AcquireQuantumMemory((size_t) VAR_12,sizeof(*VAR_6));
if (VAR_6 == (char *) NULL)
break;
while (Tokenizer(VAR_18,0,VAR_5,(size_t) VAR_12,VAR_4,"""",""="",""\"""",0,
&VAR_2,&VAR_9,&VAR_3)==0)
{
if (VAR_8 == 0)
{
int
VAR_8,
VAR_9;
char
VAR_2,
VAR_3;
VAR_8=0;
VAR_9=0;
while (Tokenizer(VAR_18,0,VAR_6,(size_t) VAR_12,VAR_5,"""",""#"",
"""", 0,&VAR_2,&VAR_9,&VAR_3)==0)
{
switch (VAR_8)
{
case 0:
if (strcmp(VAR_6,""8BIM"")==0)
VAR_10 = 255;
else
VAR_10 = (unsigned char) StringToLong(VAR_6);
break;
case 1:
VAR_11 = (unsigned int) StringToUnsignedLong(VAR_6);
break;
case 2:
VAR_7=(char *) AcquireQuantumMemory(strlen(VAR_6)+VAR_13,
sizeof(*VAR_7));
if (VAR_7)
(void) strcpy(VAR_7,VAR_6);
break;
}
VAR_8++;
}
}
else
if (VAR_8 == 1)
{
int
VAR_9;
ssize_t
VAR_19;
char
VAR_2,
VAR_3;
VAR_9=0;
VAR_19 = (ssize_t) strlen(VAR_5);
while (Tokenizer(VAR_18,0,VAR_6,(size_t) VAR_12,VAR_5,"""",""&"",
"""",0,&VAR_2,&VAR_9,&VAR_3)==0)
{
if (VAR_2 && VAR_9 > 0)
{
size_t
VAR_20;
char
*VAR_21 = &VAR_5[VAR_9-1];
VAR_20=convertHTMLcodes(VAR_21, strlen(VAR_21));
if ((ssize_t) VAR_20 > VAR_19)
VAR_19=0;
else
VAR_19-=VAR_20;
}
}
if (VAR_10 == 255)
{
unsigned char
VAR_22 = 0;
int
VAR_23;
if (VAR_16 > 0)
{
MagickOffsetType
VAR_24;
ssize_t VAR_25 = VAR_17 - VAR_16;
VAR_15 = TellBlob(VAR_1);
if (VAR_15 < 0)
return(-1);
VAR_24=SeekBlob(VAR_1,VAR_14,VAR_26);
if (VAR_24 < 0)
return(-1);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_25);
VAR_24=SeekBlob(VAR_1,VAR_15,VAR_26);
if (VAR_24 < 0)
return(-1);
VAR_16 = 0L;
}
if (VAR_17 & 1)
{
(void) WriteBlobByte(VAR_1,0x00);
VAR_17++;
}
(void) WriteBlobString(VAR_1,""8BIM"");
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_11);
VAR_17 += 6;
if (VAR_7)
VAR_22 = (unsigned char) strlen(VAR_7);
(void) WriteBlobByte(VAR_1,VAR_22);
VAR_17++;
for (VAR_23=0; VAR_23<VAR_22; VAR_23++)
(void) WriteBlobByte(VAR_1,(unsigned char) VAR_7[VAR_23]);
VAR_17 += VAR_22;
if ((VAR_22 & 0x01) == 0)
{
(void) WriteBlobByte(VAR_1,0x00);
VAR_17++;
}
if (VAR_11 != VAR_27)
{
(void) WriteBlobMSBLong(VAR_1, (unsigned int) VAR_19);
VAR_17 += 4;
VAR_9=0;
VAR_17 += VAR_19;
while (VAR_19-- > 0)
(void) WriteBlobByte(VAR_1,(unsigned char) VAR_5[VAR_9++]);
if (VAR_17 & 1)
{
(void) WriteBlobByte(VAR_1,0x00);
VAR_17++;
}
}
else
{
VAR_14 = TellBlob(VAR_1);
if (VAR_14 < 0)
return(-1);
(void) WriteBlobMSBLong(VAR_1,0xFFFFFFFFU);
VAR_17 += 4;
VAR_16 = VAR_17;
}
}
else
{
if (VAR_19 <= 0x7FFF)
{
(void) WriteBlobByte(VAR_1,0x1c);
(void) WriteBlobByte(VAR_1,(unsigned char) VAR_10);
(void) WriteBlobByte(VAR_1,(unsigned char) (VAR_11 & 0xff));
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_19);
VAR_17 += 5;
VAR_9=0;
VAR_17 += VAR_19;
while (VAR_19-- > 0)
(void) WriteBlobByte(VAR_1,(unsigned char) VAR_5[VAR_9++]);
}
}
}
VAR_8++;
}
if (VAR_5 != (char *) NULL)
VAR_5=DestroyString(VAR_5);
if (VAR_6 != (char *) NULL)
VAR_6=DestroyString(VAR_6);
if (VAR_7 != (char *) NULL)
VAR_7=DestroyString(VAR_7);
}
VAR_18=DestroyTokenInfo(VAR_18);
if (VAR_5 != (char *) NULL)
VAR_5=DestroyString(VAR_5);
if (VAR_6 != (char *) NULL)
VAR_6=DestroyString(VAR_6);
if (VAR_7 != (char *) NULL)
VAR_7=DestroyString(VAR_7);
VAR_4=DestroyString(VAR_4);
if (VAR_16 > 0)
{
MagickOffsetType
VAR_24;
ssize_t VAR_25 = VAR_17 - VAR_16;
VAR_15 = TellBlob(VAR_1);
if (VAR_15 < 0)
return(-1);
VAR_24=SeekBlob(VAR_1,VAR_14,VAR_26);
if (VAR_24 < 0)
return(-1);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_25);
VAR_24=SeekBlob(VAR_1,VAR_15,VAR_26);
if (VAR_24 < 0)
return(-1);
VAR_16 = 0L;
}
return VAR_17;
}",ImageMagick/082223fb992448dbb574747deac9a30f986c116e/meta.c/vul/before/0.json,"static ssize_t parse8BIM(Image *ifile, Image *ofile)
{
  char
    brkused,
    quoted,
    *line,
    *token,
    *newstr,
    *name;

  int
    state,
    next;

  unsigned char
    dataset;

  unsigned int
    recnum;

  int
    inputlen = MagickPathExtent;

  MagickOffsetType
    savedpos,
    currentpos;

  ssize_t
    savedolen = 0L,
    outputlen = 0L;

  TokenInfo
    *token_info;

  dataset = 0;
  recnum = 0;
  line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));
  if (line == (char *) NULL)
    return(-1);
  newstr = name = token = (char *) NULL;
  savedpos = 0;
  token_info=AcquireTokenInfo();
  while (super_fgets(&line,&inputlen,ifile)!=NULL)
  {
    state=0;
    next=0;

    token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));
    if (token == (char *) NULL)
      break;
    newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));
    if (newstr == (char *) NULL)
      break;
    while (Tokenizer(token_info,0,token,(size_t) inputlen,line,"""",""="",""\"""",0,
           &brkused,&next,&quoted)==0)
    {
      if (state == 0)
        {
          int
            state,
            next;

          char
            brkused,
            quoted;

          state=0;
          next=0;
          while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""#"",
            """", 0,&brkused,&next,&quoted)==0)
          {
            switch (state)
            {
              case 0:
                if (strcmp(newstr,""8BIM"")==0)
                  dataset = 255;
                else
                  dataset = (unsigned char) StringToLong(newstr);
                break;
              case 1:
                recnum = (unsigned int) StringToUnsignedLong(newstr);
                break;
              case 2:
                name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,
                  sizeof(*name));
                if (name)
                  (void) strcpy(name,newstr);
                break;
            }
            state++;
          }
        }
      else
        if (state == 1)
          {
            int
              next;

            ssize_t
              len;

            char
              brkused,
              quoted;

            next=0;
            len = (ssize_t) strlen(token);
            while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""&"",
              """",0,&brkused,&next,&quoted)==0)
            {
              if (brkused && next > 0)
                {
                  size_t
                    codes_length;

                  char
                    *s = &token[next-1];

                  codes_length=convertHTMLcodes(s, strlen(s));
                  if ((ssize_t) codes_length > len)
                    len=0;
                  else
                    len-=codes_length;
                }
            }

            if (dataset == 255)
              {
                unsigned char
                  nlen = 0;

                int
                  i;

                if (savedolen > 0)
                  {
                    MagickOffsetType
                      offset;

                    ssize_t diff = outputlen - savedolen;
                    currentpos = TellBlob(ofile);
                    if (currentpos < 0)
                      {
                        line=DestroyString(line);
                        return(-1);
                      }
                    offset=SeekBlob(ofile,savedpos,SEEK_SET);
                    if (offset < 0)
                      {
                        line=DestroyString(line);
                        return(-1);
                      }
                    (void) WriteBlobMSBLong(ofile,(unsigned int) diff);
                    offset=SeekBlob(ofile,currentpos,SEEK_SET);
                    if (offset < 0)
                      {
                        line=DestroyString(line);
                        return(-1);
                      }
                    savedolen = 0L;
                  }
                if (outputlen & 1)
                  {
                    (void) WriteBlobByte(ofile,0x00);
                    outputlen++;
                  }
                (void) WriteBlobString(ofile,""8BIM"");
                (void) WriteBlobMSBShort(ofile,(unsigned short) recnum);
                outputlen += 6;
                if (name)
                  nlen = (unsigned char) strlen(name);
                (void) WriteBlobByte(ofile,nlen);
                outputlen++;
                for (i=0; i<nlen; i++)
                  (void) WriteBlobByte(ofile,(unsigned char) name[i]);
                outputlen += nlen;
                if ((nlen & 0x01) == 0)
                  {
                    (void) WriteBlobByte(ofile,0x00);
                    outputlen++;
                  }
                if (recnum != IPTC_ID)
                  {
                    (void) WriteBlobMSBLong(ofile, (unsigned int) len);
                    outputlen += 4;

                    next=0;
                    outputlen += len;
                    while (len-- > 0)
                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);

                    if (outputlen & 1)
                      {
                        (void) WriteBlobByte(ofile,0x00);
                        outputlen++;
                      }
                  }
                else
                  {
                    /* patch in a fake length for now and fix it later */
                    savedpos = TellBlob(ofile);
                    if (savedpos < 0)
                      return(-1);
                    (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);
                    outputlen += 4;
                    savedolen = outputlen;
                  }
              }
            else
              {
                if (len <= 0x7FFF)
                  {
                    (void) WriteBlobByte(ofile,0x1c);
                    (void) WriteBlobByte(ofile,(unsigned char) dataset);
                    (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));
                    (void) WriteBlobMSBShort(ofile,(unsigned short) len);
                    outputlen += 5;
                    next=0;
                    outputlen += len;
                    while (len-- > 0)
                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);
                  }
              }
          }
      state++;
    }
    if (token != (char *) NULL)
      token=DestroyString(token);
    if (newstr != (char *) NULL)
      newstr=DestroyString(newstr);
    if (name != (char *) NULL)
      name=DestroyString(name);
  }
  token_info=DestroyTokenInfo(token_info);
  if (token != (char *) NULL)
    token=DestroyString(token);
  if (newstr != (char *) NULL)
    newstr=DestroyString(newstr);
  if (name != (char *) NULL)
    name=DestroyString(name);
  line=DestroyString(line);
  if (savedolen > 0)
    {
      MagickOffsetType
        offset;

      ssize_t diff = outputlen - savedolen;

      currentpos = TellBlob(ofile);
      if (currentpos < 0)
        return(-1);
      offset=SeekBlob(ofile,savedpos,SEEK_SET);
      if (offset < 0)
        return(-1);
      (void) WriteBlobMSBLong(ofile,(unsigned int) diff);
      offset=SeekBlob(ofile,currentpos,SEEK_SET);
      if (offset < 0)
        return(-1);
      savedolen = 0L;
    }
  return outputlen;
}","static ssize_t parse8BIM(Image *VAR_0, Image *VAR_1)
{
  char
    VAR_2,
    VAR_3,
    *VAR_4,
    *VAR_5,
    *VAR_6,
    *VAR_7;

  int
    VAR_8,
    VAR_9;

  unsigned char
    VAR_10;

  unsigned int
    VAR_11;

  int
    VAR_12 = VAR_13;

  MagickOffsetType
    VAR_14,
    VAR_15;

  ssize_t
    VAR_16 = 0L,
    VAR_17 = 0L;

  TokenInfo
    *VAR_18;

  VAR_10 = 0;
  VAR_11 = 0;
  VAR_4 = (char *) AcquireQuantumMemory((size_t) VAR_12,sizeof(*VAR_4));
  if (VAR_4 == (char *) NULL)
    return(-1);
  VAR_6 = VAR_7 = VAR_5 = (char *) NULL;
  VAR_14 = 0;
  VAR_18=AcquireTokenInfo();
  while (super_fgets(&VAR_4,&VAR_12,VAR_0)!=NULL)
  {
    VAR_8=0;
    VAR_9=0;

    VAR_5=(char *) AcquireQuantumMemory((size_t) VAR_12,sizeof(*VAR_5));
    if (VAR_5 == (char *) NULL)
      break;
    VAR_6=(char *) AcquireQuantumMemory((size_t) VAR_12,sizeof(*VAR_6));
    if (VAR_6 == (char *) NULL)
      break;
    while (Tokenizer(VAR_18,0,VAR_5,(size_t) VAR_12,VAR_4,"""",""="",""\"""",0,
           &VAR_2,&VAR_9,&VAR_3)==0)
    {
      if (VAR_8 == 0)
        {
          int
            VAR_8,
            VAR_9;

          char
            VAR_2,
            VAR_3;

          VAR_8=0;
          VAR_9=0;
          while (Tokenizer(VAR_18,0,VAR_6,(size_t) VAR_12,VAR_5,"""",""#"",
            """", 0,&VAR_2,&VAR_9,&VAR_3)==0)
          {
            switch (VAR_8)
            {
              case 0:
                if (strcmp(VAR_6,""8BIM"")==0)
                  VAR_10 = 255;
                else
                  VAR_10 = (unsigned char) StringToLong(VAR_6);
                break;
              case 1:
                VAR_11 = (unsigned int) StringToUnsignedLong(VAR_6);
                break;
              case 2:
                VAR_7=(char *) AcquireQuantumMemory(strlen(VAR_6)+VAR_13,
                  sizeof(*VAR_7));
                if (VAR_7)
                  (void) strcpy(VAR_7,VAR_6);
                break;
            }
            VAR_8++;
          }
        }
      else
        if (VAR_8 == 1)
          {
            int
              VAR_9;

            ssize_t
              VAR_19;

            char
              VAR_2,
              VAR_3;

            VAR_9=0;
            VAR_19 = (ssize_t) strlen(VAR_5);
            while (Tokenizer(VAR_18,0,VAR_6,(size_t) VAR_12,VAR_5,"""",""&"",
              """",0,&VAR_2,&VAR_9,&VAR_3)==0)
            {
              if (VAR_2 && VAR_9 > 0)
                {
                  size_t
                    VAR_20;

                  char
                    *VAR_21 = &VAR_5[VAR_9-1];

                  VAR_20=convertHTMLcodes(VAR_21, strlen(VAR_21));
                  if ((ssize_t) VAR_20 > VAR_19)
                    VAR_19=0;
                  else
                    VAR_19-=VAR_20;
                }
            }

            if (VAR_10 == 255)
              {
                unsigned char
                  VAR_22 = 0;

                int
                  VAR_23;

                if (VAR_16 > 0)
                  {
                    MagickOffsetType
                      VAR_24;

                    ssize_t VAR_25 = VAR_17 - VAR_16;
                    VAR_15 = TellBlob(VAR_1);
                    if (VAR_15 < 0)
                      {
                        VAR_4=DestroyString(VAR_4);
                        return(-1);
                      }
                    VAR_24=SeekBlob(VAR_1,VAR_14,VAR_26);
                    if (VAR_24 < 0)
                      {
                        VAR_4=DestroyString(VAR_4);
                        return(-1);
                      }
                    (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_25);
                    VAR_24=SeekBlob(VAR_1,VAR_15,VAR_26);
                    if (VAR_24 < 0)
                      {
                        VAR_4=DestroyString(VAR_4);
                        return(-1);
                      }
                    VAR_16 = 0L;
                  }
                if (VAR_17 & 1)
                  {
                    (void) WriteBlobByte(VAR_1,0x00);
                    VAR_17++;
                  }
                (void) WriteBlobString(VAR_1,""8BIM"");
                (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_11);
                VAR_17 += 6;
                if (VAR_7)
                  VAR_22 = (unsigned char) strlen(VAR_7);
                (void) WriteBlobByte(VAR_1,VAR_22);
                VAR_17++;
                for (VAR_23=0; VAR_23<VAR_22; VAR_23++)
                  (void) WriteBlobByte(VAR_1,(unsigned char) VAR_7[VAR_23]);
                VAR_17 += VAR_22;
                if ((VAR_22 & 0x01) == 0)
                  {
                    (void) WriteBlobByte(VAR_1,0x00);
                    VAR_17++;
                  }
                if (VAR_11 != VAR_27)
                  {
                    (void) WriteBlobMSBLong(VAR_1, (unsigned int) VAR_19);
                    VAR_17 += 4;

                    VAR_9=0;
                    VAR_17 += VAR_19;
                    while (VAR_19-- > 0)
                      (void) WriteBlobByte(VAR_1,(unsigned char) VAR_5[VAR_9++]);

                    if (VAR_17 & 1)
                      {
                        (void) WriteBlobByte(VAR_1,0x00);
                        VAR_17++;
                      }
                  }
                else
                  {
                    /* COMMENT_0 */
                    VAR_14 = TellBlob(VAR_1);
                    if (VAR_14 < 0)
                      return(-1);
                    (void) WriteBlobMSBLong(VAR_1,0xFFFFFFFFU);
                    VAR_17 += 4;
                    VAR_16 = VAR_17;
                  }
              }
            else
              {
                if (VAR_19 <= 0x7FFF)
                  {
                    (void) WriteBlobByte(VAR_1,0x1c);
                    (void) WriteBlobByte(VAR_1,(unsigned char) VAR_10);
                    (void) WriteBlobByte(VAR_1,(unsigned char) (VAR_11 & 0xff));
                    (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_19);
                    VAR_17 += 5;
                    VAR_9=0;
                    VAR_17 += VAR_19;
                    while (VAR_19-- > 0)
                      (void) WriteBlobByte(VAR_1,(unsigned char) VAR_5[VAR_9++]);
                  }
              }
          }
      VAR_8++;
    }
    if (VAR_5 != (char *) NULL)
      VAR_5=DestroyString(VAR_5);
    if (VAR_6 != (char *) NULL)
      VAR_6=DestroyString(VAR_6);
    if (VAR_7 != (char *) NULL)
      VAR_7=DestroyString(VAR_7);
  }
  VAR_18=DestroyTokenInfo(VAR_18);
  if (VAR_5 != (char *) NULL)
    VAR_5=DestroyString(VAR_5);
  if (VAR_6 != (char *) NULL)
    VAR_6=DestroyString(VAR_6);
  if (VAR_7 != (char *) NULL)
    VAR_7=DestroyString(VAR_7);
  VAR_4=DestroyString(VAR_4);
  if (VAR_16 > 0)
    {
      MagickOffsetType
        VAR_24;

      ssize_t VAR_25 = VAR_17 - VAR_16;

      VAR_15 = TellBlob(VAR_1);
      if (VAR_15 < 0)
        return(-1);
      VAR_24=SeekBlob(VAR_1,VAR_14,VAR_26);
      if (VAR_24 < 0)
        return(-1);
      (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_25);
      VAR_24=SeekBlob(VAR_1,VAR_15,VAR_26);
      if (VAR_24 < 0)
        return(-1);
      VAR_16 = 0L;
    }
  return VAR_17;
}",ImageMagick/082223fb992448dbb574747deac9a30f986c116e/meta.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -140,14 +140,23 @@
                     ssize_t diff = outputlen - savedolen;
                     currentpos = TellBlob(ofile);
                     if (currentpos < 0)
-                      return(-1);
+                      {
+                        line=DestroyString(line);
+                        return(-1);
+                      }
                     offset=SeekBlob(ofile,savedpos,SEEK_SET);
                     if (offset < 0)
-                      return(-1);
+                      {
+                        line=DestroyString(line);
+                        return(-1);
+                      }
                     (void) WriteBlobMSBLong(ofile,(unsigned int) diff);
                     offset=SeekBlob(ofile,currentpos,SEEK_SET);
                     if (offset < 0)
-                      return(-1);
+                      {
+                        line=DestroyString(line);
+                        return(-1);
+                      }
                     savedolen = 0L;
                   }
                 if (outputlen & 1)","{'deleted_lines': ['                      return(-1);', '                      return(-1);', '                      return(-1);'], 'added_lines': ['                      {', '                        line=DestroyString(line);', '                        return(-1);', '                      }', '                      {', '                        line=DestroyString(line);', '                        return(-1);', '                      }', '                      {', '                        line=DestroyString(line);', '                        return(-1);', '                      }']}",True,ImageMagick 7.0.8-4 has a memory leak in parse8BIM in coders/meta.c.,6.5,MEDIUM,1,test,2018-07-04T18:24:47Z,2
CVE-2018-14356,['CWE-824'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,neomutt,Ensure UID in fetch_uidl,93b8ac558752d09e1c56d4f1bc82631316fa9c82,https://github.com/neomutt/neomutt/commit/93b8ac558752d09e1c56d4f1bc82631316fa9c82,pop.c,fetch_uidl,"static int fetch_uidl(char *line, void *data)
{
int i, index;
struct Context *ctx = (struct Context *) data;
struct PopData *pop_data = (struct PopData *) ctx->data;
char *endp = NULL;
errno = 0;
index = strtol(line, &endp, 10);
if (errno)
return -1;
while (*endp == ' ')
endp++;
memmove(line, endp, strlen(endp) + 1);
for (i = 0; i < ctx->msgcount; i++)
if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)
break;
if (i == ctx->msgcount)
{
mutt_debug(1, ""new header %d %s\n"", index, line);
if (i >= ctx->hdrmax)
mx_alloc_memory(ctx);
ctx->msgcount++;
ctx->hdrs[i] = mutt_header_new();
ctx->hdrs[i]->data = mutt_str_strdup(line);
}
else if (ctx->hdrs[i]->index != index - 1)
pop_data->clear_cache = true;
ctx->hdrs[i]->refno = index;
ctx->hdrs[i]->index = index - 1;
return 0;
}","static int fetch_uidl(char *VAR_0, void *VAR_1)
{
int VAR_2, VAR_3;
struct Context *VAR_4 = (struct Context *) VAR_1;
struct PopData *VAR_5 = (struct PopData *) VAR_4->data;
char *VAR_6 = NULL;
VAR_7 = 0;
VAR_3 = strtol(VAR_0, &VAR_6, 10);
if (VAR_7)
return -1;
while (*VAR_6 == ' ')
VAR_6++;
memmove(VAR_0, VAR_6, strlen(VAR_6) + 1);
for (VAR_2 = 0; VAR_2 < VAR_4->msgcount; VAR_2++)
if (mutt_str_strcmp(VAR_0, VAR_4->hdrs[VAR_2]->data) == 0)
break;
if (VAR_2 == VAR_4->msgcount)
{
mutt_debug(1, ""new header %d %s\n"", VAR_3, VAR_0);
if (VAR_2 >= VAR_4->hdrmax)
mx_alloc_memory(VAR_4);
VAR_4->msgcount++;
VAR_4->hdrs[VAR_2] = mutt_header_new();
VAR_4->hdrs[VAR_2]->data = mutt_str_strdup(VAR_0);
}
else if (VAR_4->hdrs[VAR_2]->index != VAR_3 - 1)
VAR_5->clear_cache = true;
VAR_4->hdrs[VAR_2]->refno = VAR_3;
VAR_4->hdrs[VAR_2]->index = VAR_3 - 1;
return 0;
}",neomutt/93b8ac558752d09e1c56d4f1bc82631316fa9c82/pop.c/vul/before/0.json,"static int fetch_uidl(char *line, void *data)
{
  int i, index;
  struct Context *ctx = (struct Context *) data;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  char *endp = NULL;

  errno = 0;
  index = strtol(line, &endp, 10);
  if (errno)
    return -1;
  while (*endp == ' ')
    endp++;
  memmove(line, endp, strlen(endp) + 1);

  /* uid must be at least be 1 byte */
  if (strlen(line) == 0)
    return -1;

  for (i = 0; i < ctx->msgcount; i++)
    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)
      break;

  if (i == ctx->msgcount)
  {
    mutt_debug(1, ""new header %d %s\n"", index, line);

    if (i >= ctx->hdrmax)
      mx_alloc_memory(ctx);

    ctx->msgcount++;
    ctx->hdrs[i] = mutt_header_new();
    ctx->hdrs[i]->data = mutt_str_strdup(line);
  }
  else if (ctx->hdrs[i]->index != index - 1)
    pop_data->clear_cache = true;

  ctx->hdrs[i]->refno = index;
  ctx->hdrs[i]->index = index - 1;

  return 0;
}","static int fetch_uidl(char *VAR_0, void *VAR_1)
{
  int VAR_2, VAR_3;
  struct Context *VAR_4 = (struct Context *) VAR_1;
  struct PopData *VAR_5 = (struct PopData *) VAR_4->data;
  char *VAR_6 = NULL;

  VAR_7 = 0;
  VAR_3 = strtol(VAR_0, &VAR_6, 10);
  if (VAR_7)
    return -1;
  while (*VAR_6 == ' ')
    VAR_6++;
  memmove(VAR_0, VAR_6, strlen(VAR_6) + 1);

  /* COMMENT_0 */
  if (strlen(VAR_0) == 0)
    return -1;

  for (VAR_2 = 0; VAR_2 < VAR_4->msgcount; VAR_2++)
    if (mutt_str_strcmp(VAR_0, VAR_4->hdrs[VAR_2]->data) == 0)
      break;

  if (VAR_2 == VAR_4->msgcount)
  {
    mutt_debug(1, ""new header %d %s\n"", VAR_3, VAR_0);

    if (VAR_2 >= VAR_4->hdrmax)
      mx_alloc_memory(VAR_4);

    VAR_4->msgcount++;
    VAR_4->hdrs[VAR_2] = mutt_header_new();
    VAR_4->hdrs[VAR_2]->data = mutt_str_strdup(VAR_0);
  }
  else if (VAR_4->hdrs[VAR_2]->index != VAR_3 - 1)
    VAR_5->clear_cache = true;

  VAR_4->hdrs[VAR_2]->refno = VAR_3;
  VAR_4->hdrs[VAR_2]->index = VAR_3 - 1;

  return 0;
}",neomutt/93b8ac558752d09e1c56d4f1bc82631316fa9c82/pop.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,10 @@
   while (*endp == ' ')
     endp++;
   memmove(line, endp, strlen(endp) + 1);
+
+  /* uid must be at least be 1 byte */
+  if (strlen(line) == 0)
+    return -1;
 
   for (i = 0; i < ctx->msgcount; i++)
     if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)","{'deleted_lines': [], 'added_lines': ['', '  /* uid must be at least be 1 byte */', '  if (strlen(line) == 0)', '    return -1;']}",True,An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c mishandles a zero-length UID.,9.8,CRITICAL,3,test,2018-07-07T20:55:34Z,2
CVE-2018-14395,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ffmpeg,"avformat/movenc: Write version 2 of audio atom if channels is not known

The version 1 needs the channel count and would divide by 0
Fixes: division by 0
Fixes: fpe_movenc.c_1108_1.ogg
Fixes: fpe_movenc.c_1108_2.ogg
Fixes: fpe_movenc.c_1108_3.wav

Found-by: #CHEN HONGXU# <HCHEN017@e.ntu.edu.sg>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
(cherry picked from commit fa19fbcf712a6a6cc5a5cfdc3254a97b9bce6582)
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",2c0e98a0b478284bdff6d7a4062522605a8beae5,https://github.com/FFmpeg/FFmpeg/commit/2c0e98a0b478284bdff6d7a4062522605a8beae5,libavformat/movenc.c,mov_write_audio_tag,"static int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)
{
int64_t pos = avio_tell(pb);
int version = 0;
uint32_t tag = track->tag;
if (track->mode == MODE_MOV) {
if (track->timescale > UINT16_MAX) {
if (mov_get_lpcm_flags(track->par->codec_id))
tag = AV_RL32(""lpcm"");
version = 2;
} else if (track->audio_vbr || mov_pcm_le_gt16(track->par->codec_id) ||
mov_pcm_be_gt16(track->par->codec_id) ||
track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||
track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
track->par->codec_id == AV_CODEC_ID_QDM2) {
version = 1;
}
}
avio_wb32(pb, 0); 
if (mov->encryption_scheme != MOV_ENC_NONE) {
ffio_wfourcc(pb, ""enca"");
} else {
avio_wl32(pb, tag);     }
avio_wb32(pb, 0); 
avio_wb16(pb, 0); 
avio_wb16(pb, 1); 
avio_wb16(pb, version); 
avio_wb16(pb, 0); 
avio_wb32(pb, 0); 
if (version == 2) {
avio_wb16(pb, 3);
avio_wb16(pb, 16);
avio_wb16(pb, 0xfffe);
avio_wb16(pb, 0);
avio_wb32(pb, 0x00010000);
avio_wb32(pb, 72);
avio_wb64(pb, av_double2int(track->par->sample_rate));
avio_wb32(pb, track->par->channels);
avio_wb32(pb, 0x7F000000);
avio_wb32(pb, av_get_bits_per_sample(track->par->codec_id));
avio_wb32(pb, mov_get_lpcm_flags(track->par->codec_id));
avio_wb32(pb, track->sample_size);
avio_wb32(pb, get_samples_per_packet(track));
} else {
if (track->mode == MODE_MOV) {
avio_wb16(pb, track->par->channels);
if (track->par->codec_id == AV_CODEC_ID_PCM_U8 ||
track->par->codec_id == AV_CODEC_ID_PCM_S8)
avio_wb16(pb, 8); 
else if (track->par->codec_id == AV_CODEC_ID_ADPCM_G726)
avio_wb16(pb, track->par->bits_per_coded_sample);
else
avio_wb16(pb, 16);
avio_wb16(pb, track->audio_vbr ? -2 : 0); 
} else { 
avio_wb16(pb, 2);
avio_wb16(pb, 16);
avio_wb16(pb, 0);
}
avio_wb16(pb, 0); 
avio_wb16(pb, track->par->sample_rate <= UINT16_MAX ?
track->par->sample_rate : 0);
avio_wb16(pb, 0); 
}
if (version == 1) { 
if (mov_pcm_le_gt16(track->par->codec_id) ||
mov_pcm_be_gt16(track->par->codec_id))
avio_wb32(pb, 1); 
else
avio_wb32(pb, track->par->frame_size); 
avio_wb32(pb, track->sample_size / track->par->channels); 
avio_wb32(pb, track->sample_size); 
avio_wb32(pb, 2); 
}
if (track->mode == MODE_MOV &&
(track->par->codec_id == AV_CODEC_ID_AAC           ||
track->par->codec_id == AV_CODEC_ID_AC3           ||
track->par->codec_id == AV_CODEC_ID_EAC3          ||
track->par->codec_id == AV_CODEC_ID_AMR_NB        ||
track->par->codec_id == AV_CODEC_ID_ALAC          ||
track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||
track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
track->par->codec_id == AV_CODEC_ID_QDM2          ||
(mov_pcm_le_gt16(track->par->codec_id) && version==1) ||
(mov_pcm_be_gt16(track->par->codec_id) && version==1)))
mov_write_wave_tag(s, pb, track);
else if (track->tag == MKTAG('m','p','4','a'))
mov_write_esds_tag(pb, track);
else if (track->par->codec_id == AV_CODEC_ID_AMR_NB)
mov_write_amr_tag(pb, track);
else if (track->par->codec_id == AV_CODEC_ID_AC3)
mov_write_ac3_tag(pb, track);
else if (track->par->codec_id == AV_CODEC_ID_EAC3)
mov_write_eac3_tag(pb, track);
else if (track->par->codec_id == AV_CODEC_ID_ALAC)
mov_write_extradata_tag(pb, track);
else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)
mov_write_wfex_tag(s, pb, track);
else if (track->vos_len > 0)
mov_write_glbl_tag(pb, track);
if (track->mode == MODE_MOV && track->par->codec_type == AVMEDIA_TYPE_AUDIO)
mov_write_chan_tag(s, pb, track);
if (mov->encryption_scheme != MOV_ENC_NONE) {
ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);
}
return update_size(pb, pos);
}","static int mov_write_audio_tag(AVFormatContext *VAR_0, AVIOContext *VAR_1, MOVMuxContext *VAR_2, MOVTrack *VAR_3)
{
int64_t VAR_4 = avio_tell(VAR_1);
int VAR_5 = 0;
uint32_t VAR_6 = VAR_3->tag;
if (VAR_3->mode == VAR_7) {
if (VAR_3->timescale > VAR_8) {
if (mov_get_lpcm_flags(VAR_3->par->codec_id))
VAR_6 = AV_RL32(""lpcm"");
VAR_5 = 2;
} else if (VAR_3->audio_vbr || mov_pcm_le_gt16(VAR_3->par->codec_id) ||
mov_pcm_be_gt16(VAR_3->par->codec_id) ||
VAR_3->par->codec_id == VAR_9 ||
VAR_3->par->codec_id == VAR_10 ||
VAR_3->par->codec_id == VAR_11) {
VAR_5 = 1;
}
}
avio_wb32(VAR_1, 0); 
if (VAR_2->encryption_scheme != VAR_12) {
ffio_wfourcc(VAR_1, ""enca"");
} else {
avio_wl32(VAR_1, VAR_6); 
}
avio_wb32(VAR_1, 0); 
avio_wb16(VAR_1, 0); 
avio_wb16(VAR_1, 1); 
avio_wb16(VAR_1, VAR_5); 
avio_wb16(VAR_1, 0); 
avio_wb32(VAR_1, 0); 
if (VAR_5 == 2) {
avio_wb16(VAR_1, 3);
avio_wb16(VAR_1, 16);
avio_wb16(VAR_1, 0xfffe);
avio_wb16(VAR_1, 0);
avio_wb32(VAR_1, 0x00010000);
avio_wb32(VAR_1, 72);
avio_wb64(VAR_1, av_double2int(VAR_3->par->sample_rate));
avio_wb32(VAR_1, VAR_3->par->channels);
avio_wb32(VAR_1, 0x7F000000);
avio_wb32(VAR_1, av_get_bits_per_sample(VAR_3->par->codec_id));
avio_wb32(VAR_1, mov_get_lpcm_flags(VAR_3->par->codec_id));
avio_wb32(VAR_1, VAR_3->sample_size);
avio_wb32(VAR_1, get_samples_per_packet(VAR_3));
} else {
if (VAR_3->mode == VAR_7) {
avio_wb16(VAR_1, VAR_3->par->channels);
if (VAR_3->par->codec_id == VAR_13 ||
VAR_3->par->codec_id == VAR_14)
avio_wb16(VAR_1, 8); 
else if (VAR_3->par->codec_id == VAR_15)
avio_wb16(VAR_1, VAR_3->par->bits_per_coded_sample);
else
avio_wb16(VAR_1, 16);
avio_wb16(VAR_1, VAR_3->audio_vbr ? -2 : 0); 
} else { 
avio_wb16(VAR_1, 2);
avio_wb16(VAR_1, 16);
avio_wb16(VAR_1, 0);
}
avio_wb16(VAR_1, 0); 
avio_wb16(VAR_1, VAR_3->par->sample_rate <= VAR_8 ?
VAR_3->par->sample_rate : 0);
avio_wb16(VAR_1, 0); 
}
if (VAR_5 == 1) { 
if (mov_pcm_le_gt16(VAR_3->par->codec_id) ||
mov_pcm_be_gt16(VAR_3->par->codec_id))
avio_wb32(VAR_1, 1); 
else
avio_wb32(VAR_1, VAR_3->par->frame_size); 
avio_wb32(VAR_1, VAR_3->sample_size / VAR_3->par->channels); 
avio_wb32(VAR_1, VAR_3->sample_size); 
avio_wb32(VAR_1, 2); 
}
if (VAR_3->mode == VAR_7 &&
(VAR_3->par->codec_id == VAR_16           ||
VAR_3->par->codec_id == VAR_17           ||
VAR_3->par->codec_id == VAR_18          ||
VAR_3->par->codec_id == VAR_19        ||
VAR_3->par->codec_id == VAR_20          ||
VAR_3->par->codec_id == VAR_9      ||
VAR_3->par->codec_id == VAR_10 ||
VAR_3->par->codec_id == VAR_11          ||
(mov_pcm_le_gt16(VAR_3->par->codec_id) && VAR_5==1) ||
(mov_pcm_be_gt16(VAR_3->par->codec_id) && VAR_5==1)))
mov_write_wave_tag(VAR_0, VAR_1, VAR_3);
else if (VAR_3->tag == MKTAG('m','p','4','a'))
mov_write_esds_tag(VAR_1, VAR_3);
else if (VAR_3->par->codec_id == VAR_19)
mov_write_amr_tag(VAR_1, VAR_3);
else if (VAR_3->par->codec_id == VAR_17)
mov_write_ac3_tag(VAR_1, VAR_3);
else if (VAR_3->par->codec_id == VAR_18)
mov_write_eac3_tag(VAR_1, VAR_3);
else if (VAR_3->par->codec_id == VAR_20)
mov_write_extradata_tag(VAR_1, VAR_3);
else if (VAR_3->par->codec_id == VAR_21)
mov_write_wfex_tag(VAR_0, VAR_1, VAR_3);
else if (VAR_3->vos_len > 0)
mov_write_glbl_tag(VAR_1, VAR_3);
if (VAR_3->mode == VAR_7 && VAR_3->par->codec_type == VAR_22)
mov_write_chan_tag(VAR_0, VAR_1, VAR_3);
if (VAR_2->encryption_scheme != VAR_12) {
ff_mov_cenc_write_sinf_tag(VAR_3, VAR_1, VAR_2->encryption_kid);
}
return update_size(VAR_1, VAR_4);
}",ffmpeg/2c0e98a0b478284bdff6d7a4062522605a8beae5/movenc.c/vul/before/0.json,"static int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)
{
    int64_t pos = avio_tell(pb);
    int version = 0;
    uint32_t tag = track->tag;

    if (track->mode == MODE_MOV) {
        if (track->timescale > UINT16_MAX || !track->par->channels) {
            if (mov_get_lpcm_flags(track->par->codec_id))
                tag = AV_RL32(""lpcm"");
            version = 2;
        } else if (track->audio_vbr || mov_pcm_le_gt16(track->par->codec_id) ||
                   mov_pcm_be_gt16(track->par->codec_id) ||
                   track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||
                   track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
                   track->par->codec_id == AV_CODEC_ID_QDM2) {
            version = 1;
        }
    }

    avio_wb32(pb, 0); /* size */
    if (mov->encryption_scheme != MOV_ENC_NONE) {
        ffio_wfourcc(pb, ""enca"");
    } else {
        avio_wl32(pb, tag); // store it byteswapped
    }
    avio_wb32(pb, 0); /* Reserved */
    avio_wb16(pb, 0); /* Reserved */
    avio_wb16(pb, 1); /* Data-reference index, XXX  == 1 */

    /* SoundDescription */
    avio_wb16(pb, version); /* Version */
    avio_wb16(pb, 0); /* Revision level */
    avio_wb32(pb, 0); /* Reserved */

    if (version == 2) {
        avio_wb16(pb, 3);
        avio_wb16(pb, 16);
        avio_wb16(pb, 0xfffe);
        avio_wb16(pb, 0);
        avio_wb32(pb, 0x00010000);
        avio_wb32(pb, 72);
        avio_wb64(pb, av_double2int(track->par->sample_rate));
        avio_wb32(pb, track->par->channels);
        avio_wb32(pb, 0x7F000000);
        avio_wb32(pb, av_get_bits_per_sample(track->par->codec_id));
        avio_wb32(pb, mov_get_lpcm_flags(track->par->codec_id));
        avio_wb32(pb, track->sample_size);
        avio_wb32(pb, get_samples_per_packet(track));
    } else {
        if (track->mode == MODE_MOV) {
            avio_wb16(pb, track->par->channels);
            if (track->par->codec_id == AV_CODEC_ID_PCM_U8 ||
                track->par->codec_id == AV_CODEC_ID_PCM_S8)
                avio_wb16(pb, 8); /* bits per sample */
            else if (track->par->codec_id == AV_CODEC_ID_ADPCM_G726)
                avio_wb16(pb, track->par->bits_per_coded_sample);
            else
                avio_wb16(pb, 16);
            avio_wb16(pb, track->audio_vbr ? -2 : 0); /* compression ID */
        } else { /* reserved for mp4/3gp */
            avio_wb16(pb, 2);
            avio_wb16(pb, 16);
            avio_wb16(pb, 0);
        }

        avio_wb16(pb, 0); /* packet size (= 0) */
        avio_wb16(pb, track->par->sample_rate <= UINT16_MAX ?
                      track->par->sample_rate : 0);
        avio_wb16(pb, 0); /* Reserved */
    }

    if (version == 1) { /* SoundDescription V1 extended info */
        if (mov_pcm_le_gt16(track->par->codec_id) ||
            mov_pcm_be_gt16(track->par->codec_id))
            avio_wb32(pb, 1); /*  must be 1 for  uncompressed formats */
        else
            avio_wb32(pb, track->par->frame_size); /* Samples per packet */
        avio_wb32(pb, track->sample_size / track->par->channels); /* Bytes per packet */
        avio_wb32(pb, track->sample_size); /* Bytes per frame */
        avio_wb32(pb, 2); /* Bytes per sample */
    }

    if (track->mode == MODE_MOV &&
        (track->par->codec_id == AV_CODEC_ID_AAC           ||
         track->par->codec_id == AV_CODEC_ID_AC3           ||
         track->par->codec_id == AV_CODEC_ID_EAC3          ||
         track->par->codec_id == AV_CODEC_ID_AMR_NB        ||
         track->par->codec_id == AV_CODEC_ID_ALAC          ||
         track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||
         track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
         track->par->codec_id == AV_CODEC_ID_QDM2          ||
         (mov_pcm_le_gt16(track->par->codec_id) && version==1) ||
         (mov_pcm_be_gt16(track->par->codec_id) && version==1)))
        mov_write_wave_tag(s, pb, track);
    else if (track->tag == MKTAG('m','p','4','a'))
        mov_write_esds_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_AMR_NB)
        mov_write_amr_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_AC3)
        mov_write_ac3_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_EAC3)
        mov_write_eac3_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_ALAC)
        mov_write_extradata_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)
        mov_write_wfex_tag(s, pb, track);
    else if (track->vos_len > 0)
        mov_write_glbl_tag(pb, track);

    if (track->mode == MODE_MOV && track->par->codec_type == AVMEDIA_TYPE_AUDIO)
        mov_write_chan_tag(s, pb, track);

    if (mov->encryption_scheme != MOV_ENC_NONE) {
        ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);
    }

    return update_size(pb, pos);
}","static int mov_write_audio_tag(AVFormatContext *VAR_0, AVIOContext *VAR_1, MOVMuxContext *VAR_2, MOVTrack *VAR_3)
{
    int64_t VAR_4 = avio_tell(VAR_1);
    int VAR_5 = 0;
    uint32_t VAR_6 = VAR_3->tag;

    if (VAR_3->mode == VAR_7) {
        if (VAR_3->timescale > VAR_8 || !VAR_3->par->channels) {
            if (mov_get_lpcm_flags(VAR_3->par->codec_id))
                VAR_6 = AV_RL32(""lpcm"");
            VAR_5 = 2;
        } else if (VAR_3->audio_vbr || mov_pcm_le_gt16(VAR_3->par->codec_id) ||
                   mov_pcm_be_gt16(VAR_3->par->codec_id) ||
                   VAR_3->par->codec_id == VAR_9 ||
                   VAR_3->par->codec_id == VAR_10 ||
                   VAR_3->par->codec_id == VAR_11) {
            VAR_5 = 1;
        }
    }

    avio_wb32(VAR_1, 0); /* COMMENT_0 */
    if (VAR_2->encryption_scheme != VAR_12) {
        ffio_wfourcc(VAR_1, ""enca"");
    } else {
        avio_wl32(VAR_1, VAR_6); /* COMMENT_1 */
    }
    avio_wb32(VAR_1, 0); /* COMMENT_2 */
    avio_wb16(VAR_1, 0); /* COMMENT_2 */
    avio_wb16(VAR_1, 1); /* COMMENT_3 */

    /* COMMENT_4 */
    avio_wb16(VAR_1, VAR_5); /* COMMENT_5 */
    avio_wb16(VAR_1, 0); /* COMMENT_6 */
    avio_wb32(VAR_1, 0); /* COMMENT_2 */

    if (VAR_5 == 2) {
        avio_wb16(VAR_1, 3);
        avio_wb16(VAR_1, 16);
        avio_wb16(VAR_1, 0xfffe);
        avio_wb16(VAR_1, 0);
        avio_wb32(VAR_1, 0x00010000);
        avio_wb32(VAR_1, 72);
        avio_wb64(VAR_1, av_double2int(VAR_3->par->sample_rate));
        avio_wb32(VAR_1, VAR_3->par->channels);
        avio_wb32(VAR_1, 0x7F000000);
        avio_wb32(VAR_1, av_get_bits_per_sample(VAR_3->par->codec_id));
        avio_wb32(VAR_1, mov_get_lpcm_flags(VAR_3->par->codec_id));
        avio_wb32(VAR_1, VAR_3->sample_size);
        avio_wb32(VAR_1, get_samples_per_packet(VAR_3));
    } else {
        if (VAR_3->mode == VAR_7) {
            avio_wb16(VAR_1, VAR_3->par->channels);
            if (VAR_3->par->codec_id == VAR_13 ||
                VAR_3->par->codec_id == VAR_14)
                avio_wb16(VAR_1, 8); /* COMMENT_7 */
            else if (VAR_3->par->codec_id == VAR_15)
                avio_wb16(VAR_1, VAR_3->par->bits_per_coded_sample);
            else
                avio_wb16(VAR_1, 16);
            avio_wb16(VAR_1, VAR_3->audio_vbr ? -2 : 0); /* COMMENT_8 */
        } else { /* COMMENT_9 */
            avio_wb16(VAR_1, 2);
            avio_wb16(VAR_1, 16);
            avio_wb16(VAR_1, 0);
        }

        avio_wb16(VAR_1, 0); /* COMMENT_10 */
        avio_wb16(VAR_1, VAR_3->par->sample_rate <= VAR_8 ?
                      VAR_3->par->sample_rate : 0);
        avio_wb16(VAR_1, 0); /* COMMENT_2 */
    }

    if (VAR_5 == 1) { /* COMMENT_11 */
        if (mov_pcm_le_gt16(VAR_3->par->codec_id) ||
            mov_pcm_be_gt16(VAR_3->par->codec_id))
            avio_wb32(VAR_1, 1); /* COMMENT_12 */
        else
            avio_wb32(VAR_1, VAR_3->par->frame_size); /* COMMENT_13 */
        avio_wb32(VAR_1, VAR_3->sample_size / VAR_3->par->channels); /* COMMENT_14 */
        avio_wb32(VAR_1, VAR_3->sample_size); /* COMMENT_15 */
        avio_wb32(VAR_1, 2); /* COMMENT_16 */
    }

    if (VAR_3->mode == VAR_7 &&
        (VAR_3->par->codec_id == VAR_16           ||
         VAR_3->par->codec_id == VAR_17           ||
         VAR_3->par->codec_id == VAR_18          ||
         VAR_3->par->codec_id == VAR_19        ||
         VAR_3->par->codec_id == VAR_20          ||
         VAR_3->par->codec_id == VAR_9      ||
         VAR_3->par->codec_id == VAR_10 ||
         VAR_3->par->codec_id == VAR_11          ||
         (mov_pcm_le_gt16(VAR_3->par->codec_id) && VAR_5==1) ||
         (mov_pcm_be_gt16(VAR_3->par->codec_id) && VAR_5==1)))
        mov_write_wave_tag(VAR_0, VAR_1, VAR_3);
    else if (VAR_3->tag == MKTAG('m','p','4','a'))
        mov_write_esds_tag(VAR_1, VAR_3);
    else if (VAR_3->par->codec_id == VAR_19)
        mov_write_amr_tag(VAR_1, VAR_3);
    else if (VAR_3->par->codec_id == VAR_17)
        mov_write_ac3_tag(VAR_1, VAR_3);
    else if (VAR_3->par->codec_id == VAR_18)
        mov_write_eac3_tag(VAR_1, VAR_3);
    else if (VAR_3->par->codec_id == VAR_20)
        mov_write_extradata_tag(VAR_1, VAR_3);
    else if (VAR_3->par->codec_id == VAR_21)
        mov_write_wfex_tag(VAR_0, VAR_1, VAR_3);
    else if (VAR_3->vos_len > 0)
        mov_write_glbl_tag(VAR_1, VAR_3);

    if (VAR_3->mode == VAR_7 && VAR_3->par->codec_type == VAR_22)
        mov_write_chan_tag(VAR_0, VAR_1, VAR_3);

    if (VAR_2->encryption_scheme != VAR_12) {
        ff_mov_cenc_write_sinf_tag(VAR_3, VAR_1, VAR_2->encryption_kid);
    }

    return update_size(VAR_1, VAR_4);
}",ffmpeg/2c0e98a0b478284bdff6d7a4062522605a8beae5/movenc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
     uint32_t tag = track->tag;
 
     if (track->mode == MODE_MOV) {
-        if (track->timescale > UINT16_MAX) {
+        if (track->timescale > UINT16_MAX || !track->par->channels) {
             if (mov_get_lpcm_flags(track->par->codec_id))
                 tag = AV_RL32(""lpcm"");
             version = 2;","{'deleted_lines': ['        if (track->timescale > UINT16_MAX) {'], 'added_lines': ['        if (track->timescale > UINT16_MAX || !track->par->channels) {']}",True,libavformat/movenc.c in FFmpeg 3.2 and 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.,6.5,MEDIUM,1,test,2018-07-07T22:16:42Z,2
CVE-2018-14544,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,axiomatic-systems/Bento4,fix #291,0de27979fb2f70cb7c9f302946c2b199964ee6aa,https://github.com/axiomatic-systems/Bento4/commit/0de27979fb2f70cb7c9f302946c2b199964ee6aa,Source/C++/Core/Ap4Mpeg2Ts.cpp,AP4_Mpeg2TsAudioSampleStream::WriteSample,"AP4_Result
AP4_Mpeg2TsAudioSampleStream::WriteSample(AP4_Sample&            sample,
AP4_DataBuffer&        sample_data,
AP4_SampleDescription* sample_description,
bool                   with_pcr, 
AP4_ByteStream&        output)
{
if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {
AP4_MpegAudioSampleDescription* audio_desc = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, sample_description);
if (audio_desc == NULL) return AP4_ERROR_NOT_SUPPORTED;
if (audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_LC   &&
audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_MAIN &&
audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_SBR      &&
audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_PS) {
return AP4_ERROR_NOT_SUPPORTED;
}
unsigned int sample_rate   = audio_desc->GetSampleRate();
unsigned int channel_count = audio_desc->GetChannelCount();
const AP4_DataBuffer& dsi  = audio_desc->GetDecoderInfo();
if (dsi.GetDataSize()) {
AP4_Mp4AudioDecoderConfig dec_config;
AP4_Result result = dec_config.Parse(dsi.GetData(), dsi.GetDataSize());
if (AP4_SUCCEEDED(result)) {
sample_rate = dec_config.m_SamplingFrequency;
channel_count = dec_config.m_ChannelCount;
}
}
unsigned int sampling_frequency_index = GetSamplingFrequencyIndex(sample_rate);
unsigned int channel_configuration    = channel_count;
unsigned char* buffer = new unsigned char[7+sample_data.GetDataSize()];
MakeAdtsHeader(buffer, sample_data.GetDataSize(), sampling_frequency_index, channel_configuration);
AP4_CopyMemory(buffer+7, sample_data.GetData(), sample_data.GetDataSize());
AP4_UI64 ts = AP4_ConvertTime(sample.GetDts(), m_TimeScale, 90000);
WritePES(buffer, 7+sample.GetSize(), ts, false, ts, with_pcr, output);
delete[] buffer;
} else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3 ||
sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {
AP4_UI64 ts = AP4_ConvertTime(sample.GetDts(), m_TimeScale, 90000);
WritePES(sample_data.GetData(), sample_data.GetDataSize(), ts, false, ts, with_pcr, output);
} else {
return AP4_ERROR_NOT_SUPPORTED;
}
return AP4_SUCCESS;
}","AP4_Result
AP4_Mpeg2TsAudioSampleStream::WriteSample(AP4_Sample&            VAR_0,
AP4_DataBuffer&        VAR_1,
AP4_SampleDescription* VAR_2,
bool                   VAR_3, 
AP4_ByteStream&        VAR_4)
{
if (VAR_2->GetFormat() == VAR_5) {
AP4_MpegAudioSampleDescription* VAR_6 = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, VAR_2);
if (VAR_6 == NULL) return VAR_7;
if (VAR_6->GetMpeg4AudioObjectType() != VAR_8   &&
VAR_6->GetMpeg4AudioObjectType() != VAR_9 &&
VAR_6->GetMpeg4AudioObjectType() != VAR_10      &&
VAR_6->GetMpeg4AudioObjectType() != VAR_11) {
return VAR_7;
}
unsigned int VAR_12   = VAR_6->GetSampleRate();
unsigned int VAR_13 = VAR_6->GetChannelCount();
const AP4_DataBuffer& VAR_14  = VAR_6->GetDecoderInfo();
if (VAR_14.GetDataSize()) {
AP4_Mp4AudioDecoderConfig VAR_15;
AP4_Result VAR_16 = VAR_15.Parse(VAR_14.GetData(), VAR_14.GetDataSize());
if (AP4_SUCCEEDED(VAR_16)) {
VAR_12 = VAR_15.m_SamplingFrequency;
VAR_13 = VAR_15.m_ChannelCount;
}
}
unsigned int VAR_17 = GetSamplingFrequencyIndex(VAR_12);
unsigned int VAR_18    = VAR_13;
unsigned char* VAR_19 = new unsigned char[7+VAR_1.GetDataSize()];
MakeAdtsHeader(VAR_19, VAR_1.GetDataSize(), VAR_17, VAR_18);
AP4_CopyMemory(VAR_19+7, VAR_1.GetData(), VAR_1.GetDataSize());
AP4_UI64 VAR_20 = AP4_ConvertTime(VAR_0.GetDts(), VAR_21, 90000);
WritePES(VAR_19, 7+VAR_0.GetSize(), VAR_20, false, VAR_20, VAR_3, VAR_4);
delete[] VAR_19;
} else if (VAR_2->GetFormat() == VAR_22 ||
VAR_2->GetFormat() == VAR_23) {
AP4_UI64 VAR_20 = AP4_ConvertTime(VAR_0.GetDts(), VAR_21, 90000);
WritePES(VAR_1.GetData(), VAR_1.GetDataSize(), VAR_20, false, VAR_20, VAR_3, VAR_4);
} else {
return VAR_7;
}
return VAR_24;
}",axiomatic-systems/Bento4/0de27979fb2f70cb7c9f302946c2b199964ee6aa/Ap4Mpeg2Ts.cpp/vul/before/1.json,"AP4_Result
AP4_Mpeg2TsAudioSampleStream::WriteSample(AP4_Sample&            sample,
                                          AP4_DataBuffer&        sample_data,
                                          AP4_SampleDescription* sample_description,
                                          bool                   with_pcr, 
                                          AP4_ByteStream&        output)
{
    if (!sample_description) {
        return AP4_ERROR_INVALID_PARAMETERS;
    }

    // check the sample description
    if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {
        AP4_MpegAudioSampleDescription* audio_desc = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, sample_description);
        
        if (audio_desc == NULL) return AP4_ERROR_NOT_SUPPORTED;
        if (audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_LC   &&
            audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_AAC_MAIN &&
            audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_SBR      &&
            audio_desc->GetMpeg4AudioObjectType() != AP4_MPEG4_AUDIO_OBJECT_TYPE_PS) {
            return AP4_ERROR_NOT_SUPPORTED;
        }
        
        unsigned int sample_rate   = audio_desc->GetSampleRate();
        unsigned int channel_count = audio_desc->GetChannelCount();
        const AP4_DataBuffer& dsi  = audio_desc->GetDecoderInfo();
        if (dsi.GetDataSize()) {
            AP4_Mp4AudioDecoderConfig dec_config;
            AP4_Result result = dec_config.Parse(dsi.GetData(), dsi.GetDataSize());
            if (AP4_SUCCEEDED(result)) {
                sample_rate = dec_config.m_SamplingFrequency;
                channel_count = dec_config.m_ChannelCount;
            }
        }
        unsigned int sampling_frequency_index = GetSamplingFrequencyIndex(sample_rate);
        unsigned int channel_configuration    = channel_count;

        unsigned char* buffer = new unsigned char[7+sample_data.GetDataSize()];
        MakeAdtsHeader(buffer, sample_data.GetDataSize(), sampling_frequency_index, channel_configuration);
        AP4_CopyMemory(buffer+7, sample_data.GetData(), sample_data.GetDataSize());
        AP4_UI64 ts = AP4_ConvertTime(sample.GetDts(), m_TimeScale, 90000);
        WritePES(buffer, 7+sample.GetSize(), ts, false, ts, with_pcr, output);
        delete[] buffer;
    } else if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_AC_3 ||
               sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {
        AP4_UI64 ts = AP4_ConvertTime(sample.GetDts(), m_TimeScale, 90000);
        WritePES(sample_data.GetData(), sample_data.GetDataSize(), ts, false, ts, with_pcr, output);
    } else {
        return AP4_ERROR_NOT_SUPPORTED;
    }

    
    return AP4_SUCCESS;
}","AP4_Result
AP4_Mpeg2TsAudioSampleStream::WriteSample(AP4_Sample&            VAR_0,
                                          AP4_DataBuffer&        VAR_1,
                                          AP4_SampleDescription* VAR_2,
                                          bool                   VAR_3, 
                                          AP4_ByteStream&        VAR_4)
{
    if (!VAR_2) {
        return VAR_5;
    }

    /* COMMENT_0 */
    if (VAR_2->GetFormat() == VAR_6) {
        AP4_MpegAudioSampleDescription* VAR_7 = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, VAR_2);
        
        if (VAR_7 == NULL) return VAR_8;
        if (VAR_7->GetMpeg4AudioObjectType() != VAR_9   &&
            VAR_7->GetMpeg4AudioObjectType() != VAR_10 &&
            VAR_7->GetMpeg4AudioObjectType() != VAR_11      &&
            VAR_7->GetMpeg4AudioObjectType() != VAR_12) {
            return VAR_8;
        }
        
        unsigned int VAR_13   = VAR_7->GetSampleRate();
        unsigned int VAR_14 = VAR_7->GetChannelCount();
        const AP4_DataBuffer& VAR_15  = VAR_7->GetDecoderInfo();
        if (VAR_15.GetDataSize()) {
            AP4_Mp4AudioDecoderConfig VAR_16;
            AP4_Result VAR_17 = VAR_16.Parse(VAR_15.GetData(), VAR_15.GetDataSize());
            if (AP4_SUCCEEDED(VAR_17)) {
                VAR_13 = VAR_16.m_SamplingFrequency;
                VAR_14 = VAR_16.m_ChannelCount;
            }
        }
        unsigned int VAR_18 = GetSamplingFrequencyIndex(VAR_13);
        unsigned int VAR_19    = VAR_14;

        unsigned char* VAR_20 = new unsigned char[7+VAR_1.GetDataSize()];
        MakeAdtsHeader(VAR_20, VAR_1.GetDataSize(), VAR_18, VAR_19);
        AP4_CopyMemory(VAR_20+7, VAR_1.GetData(), VAR_1.GetDataSize());
        AP4_UI64 VAR_21 = AP4_ConvertTime(VAR_0.GetDts(), VAR_22, 90000);
        WritePES(VAR_20, 7+VAR_0.GetSize(), VAR_21, false, VAR_21, VAR_3, VAR_4);
        delete[] VAR_20;
    } else if (VAR_2->GetFormat() == VAR_23 ||
               VAR_2->GetFormat() == VAR_24) {
        AP4_UI64 VAR_21 = AP4_ConvertTime(VAR_0.GetDts(), VAR_22, 90000);
        WritePES(VAR_1.GetData(), VAR_1.GetDataSize(), VAR_21, false, VAR_21, VAR_3, VAR_4);
    } else {
        return VAR_8;
    }

    
    return VAR_25;
}",axiomatic-systems/Bento4/0de27979fb2f70cb7c9f302946c2b199964ee6aa/Ap4Mpeg2Ts.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -5,6 +5,10 @@
                                           bool                   with_pcr, 
                                           AP4_ByteStream&        output)
 {
+    if (!sample_description) {
+        return AP4_ERROR_INVALID_PARAMETERS;
+    }
+
     // check the sample description
     if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_MP4A) {
         AP4_MpegAudioSampleDescription* audio_desc = AP4_DYNAMIC_CAST(AP4_MpegAudioSampleDescription, sample_description);","{'deleted_lines': [], 'added_lines': ['    if (!sample_description) {', '        return AP4_ERROR_INVALID_PARAMETERS;', '    }', '']}",True,"There exists one invalid memory read bug in AP4_SampleDescription::GetFormat() in Ap4SampleDescription.h in Bento4 1.5.1-624, which can allow attackers to cause a denial-of-service via a crafted mp4 file. This vulnerability can be triggered by the executable mp42ts.",5.5,MEDIUM,1,test,2018-07-21T18:30:08Z,2
CVE-2018-14544,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,axiomatic-systems/Bento4,fix #291,0de27979fb2f70cb7c9f302946c2b199964ee6aa,https://github.com/axiomatic-systems/Bento4/commit/0de27979fb2f70cb7c9f302946c2b199964ee6aa,Source/C++/Core/Ap4Mpeg2Ts.cpp,AP4_Mpeg2TsVideoSampleStream::WriteSample,"AP4_Result
AP4_Mpeg2TsVideoSampleStream::WriteSample(AP4_Sample&            sample,
AP4_DataBuffer&        sample_data, 
AP4_SampleDescription* sample_description,
bool                   with_pcr, 
AP4_ByteStream&        output)
{
if (sample_description->GetType() == AP4_SampleDescription::TYPE_AVC) {
AP4_AvcSampleDescription* avc_desc = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, sample_description);
if (avc_desc == NULL) return AP4_ERROR_NOT_SUPPORTED;
if ((int)sample.GetDescriptionIndex() != m_SampleDescriptionIndex) {
m_SampleDescriptionIndex = (int)sample.GetDescriptionIndex();
m_NaluLengthSize = avc_desc->GetNaluLengthSize();
m_Prefix.SetDataSize(0);
for (unsigned int i=0; i<avc_desc->GetSequenceParameters().ItemCount(); i++) {
AP4_DataBuffer& buffer = avc_desc->GetSequenceParameters()[i];
unsigned int prefix_size = m_Prefix.GetDataSize();
m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
unsigned char* p = m_Prefix.UseData()+prefix_size;
*p++ = 0;
*p++ = 0;
*p++ = 0;
*p++ = 1;
AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
}
for (unsigned int i=0; i<avc_desc->GetPictureParameters().ItemCount(); i++) {
AP4_DataBuffer& buffer = avc_desc->GetPictureParameters()[i];
unsigned int prefix_size = m_Prefix.GetDataSize();
m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
unsigned char* p = m_Prefix.UseData()+prefix_size;
*p++ = 0;
*p++ = 0;
*p++ = 0;
*p++ = 1;
AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
}
}
} else if (sample_description->GetType() == AP4_SampleDescription::TYPE_HEVC) {
AP4_HevcSampleDescription* hevc_desc = AP4_DYNAMIC_CAST(AP4_HevcSampleDescription, sample_description);
if (hevc_desc == NULL) return AP4_ERROR_NOT_SUPPORTED;
if ((int)sample.GetDescriptionIndex() != m_SampleDescriptionIndex) {
m_SampleDescriptionIndex = (int)sample.GetDescriptionIndex();
m_NaluLengthSize = hevc_desc->GetNaluLengthSize();
m_Prefix.SetDataSize(0);
for (unsigned int i=0; i<hevc_desc->GetSequences().ItemCount(); i++) {
const AP4_HvccAtom::Sequence& seq = hevc_desc->GetSequences()[i];
if (seq.m_NaluType == AP4_HEVC_NALU_TYPE_VPS_NUT) {
for (unsigned int j=0; j<seq.m_Nalus.ItemCount(); j++) {
const AP4_DataBuffer& buffer = seq.m_Nalus[j];
unsigned int prefix_size = m_Prefix.GetDataSize();
m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
unsigned char* p = m_Prefix.UseData()+prefix_size;
*p++ = 0;
*p++ = 0;
*p++ = 0;
*p++ = 1;
AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
}
}
}
for (unsigned int i=0; i<hevc_desc->GetSequences().ItemCount(); i++) {
const AP4_HvccAtom::Sequence& seq = hevc_desc->GetSequences()[i];
if (seq.m_NaluType == AP4_HEVC_NALU_TYPE_SPS_NUT) {
for (unsigned int j=0; j<seq.m_Nalus.ItemCount(); j++) {
const AP4_DataBuffer& buffer = seq.m_Nalus[j];
unsigned int prefix_size = m_Prefix.GetDataSize();
m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
unsigned char* p = m_Prefix.UseData()+prefix_size;
*p++ = 0;
*p++ = 0;
*p++ = 0;
*p++ = 1;
AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
}
}
}
for (unsigned int i=0; i<hevc_desc->GetSequences().ItemCount(); i++) {
const AP4_HvccAtom::Sequence& seq = hevc_desc->GetSequences()[i];
if (seq.m_NaluType == AP4_HEVC_NALU_TYPE_PPS_NUT) {
for (unsigned int j=0; j<seq.m_Nalus.ItemCount(); j++) {
const AP4_DataBuffer& buffer = seq.m_Nalus[j];
unsigned int prefix_size = m_Prefix.GetDataSize();
m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
unsigned char* p = m_Prefix.UseData()+prefix_size;
*p++ = 0;
*p++ = 0;
*p++ = 0;
*p++ = 1;
AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
}
}
}
}
} else {
return AP4_ERROR_NOT_SUPPORTED;
}
bool emit_prefix = false;
if (sample.IsSync() || m_SamplesWritten == 0) {
emit_prefix = true;
}
const unsigned char* data      = sample_data.GetData();
unsigned int         data_size = sample_data.GetDataSize();
AP4_DataBuffer pes_data;
for (unsigned int nalu_count = 0; data_size; nalu_count++) {
if (data_size < m_NaluLengthSize) break;
AP4_UI32 nalu_size;
if (m_NaluLengthSize == 1) {
nalu_size = *data++;
data_size--;
} else if (m_NaluLengthSize == 2) {
nalu_size = AP4_BytesToInt16BE(data);
data      += 2;
data_size -= 2;
} else if (m_NaluLengthSize == 4) {
nalu_size = AP4_BytesToInt32BE(data);
data      += 4;
data_size -= 4;
} else {
break;
}
if (nalu_size > data_size) break;
if (nalu_count == 0 && sample_description->GetType() == AP4_SampleDescription::TYPE_AVC) {
if ( (data[0] & 0x1F) != AP4_AVC_NAL_UNIT_TYPE_ACCESS_UNIT_DELIMITER) {
unsigned char delimiter[6];
delimiter[0] = 0;
delimiter[1] = 0;
delimiter[2] = 0;
delimiter[3] = 1;
delimiter[4] = 9;                    delimiter[5] = 0xF0;                 pes_data.AppendData(delimiter, 6);
if (emit_prefix) {
pes_data.AppendData(m_Prefix.GetData(), m_Prefix.GetDataSize());
emit_prefix = false;
}
}
} else {
if (emit_prefix) {
pes_data.AppendData(m_Prefix.GetData(), m_Prefix.GetDataSize());
emit_prefix = false;
}
}
unsigned char start_code[3];
start_code[0] = 0;
start_code[1] = 0;
start_code[2] = 1;
pes_data.AppendData(start_code, 3);
pes_data.AppendData(data, nalu_size);
if (emit_prefix) {
pes_data.AppendData(m_Prefix.GetData(), m_Prefix.GetDataSize());
emit_prefix = false;
}
data      += nalu_size;
data_size -= nalu_size;
} 
AP4_UI64 dts = AP4_ConvertTime(sample.GetDts(), m_TimeScale, 90000);
AP4_UI64 pts = AP4_ConvertTime(sample.GetCts(), m_TimeScale, 90000);
++m_SamplesWritten;
return WritePES(pes_data.GetData(), pes_data.GetDataSize(), dts, true, pts, with_pcr, output);
}","AP4_Result
AP4_Mpeg2TsVideoSampleStream::WriteSample(AP4_Sample&            VAR_0,
AP4_DataBuffer&        VAR_1, 
AP4_SampleDescription* VAR_2,
bool                   VAR_3, 
AP4_ByteStream&        VAR_4)
{
if (VAR_2->GetType() == AP4_SampleDescription::TYPE_AVC) {
AP4_AvcSampleDescription* VAR_5 = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, VAR_2);
if (VAR_5 == NULL) return VAR_6;
if ((int)VAR_0.GetDescriptionIndex() != VAR_7) {
VAR_7 = (int)VAR_0.GetDescriptionIndex();
VAR_8 = VAR_5->GetNaluLengthSize();
VAR_9.SetDataSize(0);
for (unsigned int VAR_10=0; VAR_10<VAR_5->GetSequenceParameters().ItemCount(); VAR_10++) {
AP4_DataBuffer& VAR_11 = VAR_5->GetSequenceParameters()[VAR_10];
unsigned int VAR_12 = VAR_9.GetDataSize();
VAR_9.SetDataSize(VAR_12+4+VAR_11.GetDataSize());
unsigned char* VAR_13 = VAR_9.UseData()+VAR_12;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 1;
AP4_CopyMemory(VAR_13, VAR_11.GetData(), VAR_11.GetDataSize());
}
for (unsigned int VAR_10=0; VAR_10<VAR_5->GetPictureParameters().ItemCount(); VAR_10++) {
AP4_DataBuffer& VAR_11 = VAR_5->GetPictureParameters()[VAR_10];
unsigned int VAR_12 = VAR_9.GetDataSize();
VAR_9.SetDataSize(VAR_12+4+VAR_11.GetDataSize());
unsigned char* VAR_13 = VAR_9.UseData()+VAR_12;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 1;
AP4_CopyMemory(VAR_13, VAR_11.GetData(), VAR_11.GetDataSize());
}
}
} else if (VAR_2->GetType() == AP4_SampleDescription::TYPE_HEVC) {
AP4_HevcSampleDescription* VAR_14 = AP4_DYNAMIC_CAST(AP4_HevcSampleDescription, VAR_2);
if (VAR_14 == NULL) return VAR_6;
if ((int)VAR_0.GetDescriptionIndex() != VAR_7) {
VAR_7 = (int)VAR_0.GetDescriptionIndex();
VAR_8 = VAR_14->GetNaluLengthSize();
VAR_9.SetDataSize(0);
for (unsigned int VAR_10=0; VAR_10<VAR_14->GetSequences().ItemCount(); VAR_10++) {
const AP4_HvccAtom::Sequence& VAR_15 = VAR_14->GetSequences()[VAR_10];
if (VAR_15.m_NaluType == VAR_16) {
for (unsigned int VAR_17=0; VAR_17<VAR_15.m_Nalus.ItemCount(); VAR_17++) {
const AP4_DataBuffer& VAR_11 = VAR_15.m_Nalus[VAR_17];
unsigned int VAR_12 = VAR_9.GetDataSize();
VAR_9.SetDataSize(VAR_12+4+VAR_11.GetDataSize());
unsigned char* VAR_13 = VAR_9.UseData()+VAR_12;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 1;
AP4_CopyMemory(VAR_13, VAR_11.GetData(), VAR_11.GetDataSize());
}
}
}
for (unsigned int VAR_10=0; VAR_10<VAR_14->GetSequences().ItemCount(); VAR_10++) {
const AP4_HvccAtom::Sequence& VAR_15 = VAR_14->GetSequences()[VAR_10];
if (VAR_15.m_NaluType == VAR_18) {
for (unsigned int VAR_17=0; VAR_17<VAR_15.m_Nalus.ItemCount(); VAR_17++) {
const AP4_DataBuffer& VAR_11 = VAR_15.m_Nalus[VAR_17];
unsigned int VAR_12 = VAR_9.GetDataSize();
VAR_9.SetDataSize(VAR_12+4+VAR_11.GetDataSize());
unsigned char* VAR_13 = VAR_9.UseData()+VAR_12;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 1;
AP4_CopyMemory(VAR_13, VAR_11.GetData(), VAR_11.GetDataSize());
}
}
}
for (unsigned int VAR_10=0; VAR_10<VAR_14->GetSequences().ItemCount(); VAR_10++) {
const AP4_HvccAtom::Sequence& VAR_15 = VAR_14->GetSequences()[VAR_10];
if (VAR_15.m_NaluType == VAR_19) {
for (unsigned int VAR_17=0; VAR_17<VAR_15.m_Nalus.ItemCount(); VAR_17++) {
const AP4_DataBuffer& VAR_11 = VAR_15.m_Nalus[VAR_17];
unsigned int VAR_12 = VAR_9.GetDataSize();
VAR_9.SetDataSize(VAR_12+4+VAR_11.GetDataSize());
unsigned char* VAR_13 = VAR_9.UseData()+VAR_12;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 0;
*VAR_13++ = 1;
AP4_CopyMemory(VAR_13, VAR_11.GetData(), VAR_11.GetDataSize());
}
}
}
}
} else {
return VAR_6;
}
bool VAR_20 = false;
if (VAR_0.IsSync() || VAR_21 == 0) {
VAR_20 = true;
}
const unsigned char* VAR_22      = VAR_1.GetData();
unsigned int         VAR_23 = VAR_1.GetDataSize();
AP4_DataBuffer VAR_24;
for (unsigned int VAR_25 = 0; VAR_23; VAR_25++) {
if (VAR_23 < VAR_8) break;
AP4_UI32 VAR_26;
if (VAR_8 == 1) {
VAR_26 = *VAR_22++;
VAR_23--;
} else if (VAR_8 == 2) {
VAR_26 = AP4_BytesToInt16BE(VAR_22);
VAR_22      += 2;
VAR_23 -= 2;
} else if (VAR_8 == 4) {
VAR_26 = AP4_BytesToInt32BE(VAR_22);
VAR_22      += 4;
VAR_23 -= 4;
} else {
break;
}
if (VAR_26 > VAR_23) break;
if (VAR_25 == 0 && VAR_2->GetType() == AP4_SampleDescription::TYPE_AVC) {
if ( (VAR_22[0] & 0x1F) != VAR_27) {
unsigned char VAR_28[6];
VAR_28[0] = 0;
VAR_28[1] = 0;
VAR_28[2] = 0;
VAR_28[3] = 1;
VAR_28[4] = 9;    
VAR_28[5] = 0xF0; 
VAR_24.AppendData(VAR_28, 6);
if (VAR_20) {
VAR_24.AppendData(VAR_9.GetData(), VAR_9.GetDataSize());
VAR_20 = false;
}
}
} else {
if (VAR_20) {
VAR_24.AppendData(VAR_9.GetData(), VAR_9.GetDataSize());
VAR_20 = false;
}
}
unsigned char VAR_29[3];
VAR_29[0] = 0;
VAR_29[1] = 0;
VAR_29[2] = 1;
VAR_24.AppendData(VAR_29, 3);
VAR_24.AppendData(VAR_22, VAR_26);
if (VAR_20) {
VAR_24.AppendData(VAR_9.GetData(), VAR_9.GetDataSize());
VAR_20 = false;
}
VAR_22      += VAR_26;
VAR_23 -= VAR_26;
} 
AP4_UI64 VAR_30 = AP4_ConvertTime(VAR_0.GetDts(), VAR_31, 90000);
AP4_UI64 VAR_32 = AP4_ConvertTime(VAR_0.GetCts(), VAR_31, 90000);
++VAR_21;
return WritePES(VAR_24.GetData(), VAR_24.GetDataSize(), VAR_30, true, VAR_32, VAR_3, VAR_4);
}",axiomatic-systems/Bento4/0de27979fb2f70cb7c9f302946c2b199964ee6aa/Ap4Mpeg2Ts.cpp/vul/before/0.json,"AP4_Result
AP4_Mpeg2TsVideoSampleStream::WriteSample(AP4_Sample&            sample,
                                          AP4_DataBuffer&        sample_data, 
                                          AP4_SampleDescription* sample_description,
                                          bool                   with_pcr, 
                                          AP4_ByteStream&        output)
{
    if (!sample_description) {
        return AP4_ERROR_INVALID_PARAMETERS;
    }
    
    if (sample_description->GetType() == AP4_SampleDescription::TYPE_AVC) {
        // check the sample description
        AP4_AvcSampleDescription* avc_desc = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, sample_description);
        if (avc_desc == NULL) return AP4_ERROR_NOT_SUPPORTED;
        
        if ((int)sample.GetDescriptionIndex() != m_SampleDescriptionIndex) {
            m_SampleDescriptionIndex = (int)sample.GetDescriptionIndex();
            m_NaluLengthSize = avc_desc->GetNaluLengthSize();

            // make the SPS/PPS prefix
            m_Prefix.SetDataSize(0);
            for (unsigned int i=0; i<avc_desc->GetSequenceParameters().ItemCount(); i++) {
                AP4_DataBuffer& buffer = avc_desc->GetSequenceParameters()[i];
                unsigned int prefix_size = m_Prefix.GetDataSize();
                m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
                unsigned char* p = m_Prefix.UseData()+prefix_size;
                *p++ = 0;
                *p++ = 0;
                *p++ = 0;
                *p++ = 1;
                AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
            }
            for (unsigned int i=0; i<avc_desc->GetPictureParameters().ItemCount(); i++) {
                AP4_DataBuffer& buffer = avc_desc->GetPictureParameters()[i];
                unsigned int prefix_size = m_Prefix.GetDataSize();
                m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
                unsigned char* p = m_Prefix.UseData()+prefix_size;
                *p++ = 0;
                *p++ = 0;
                *p++ = 0;
                *p++ = 1;
                AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
            }
        }
    } else if (sample_description->GetType() == AP4_SampleDescription::TYPE_HEVC) {
        // check the sample description
        AP4_HevcSampleDescription* hevc_desc = AP4_DYNAMIC_CAST(AP4_HevcSampleDescription, sample_description);
        if (hevc_desc == NULL) return AP4_ERROR_NOT_SUPPORTED;

        if ((int)sample.GetDescriptionIndex() != m_SampleDescriptionIndex) {
            m_SampleDescriptionIndex = (int)sample.GetDescriptionIndex();
            m_NaluLengthSize = hevc_desc->GetNaluLengthSize();

            // make the VPS/SPS/PPS prefix
            m_Prefix.SetDataSize(0);
            for (unsigned int i=0; i<hevc_desc->GetSequences().ItemCount(); i++) {
                const AP4_HvccAtom::Sequence& seq = hevc_desc->GetSequences()[i];
                if (seq.m_NaluType == AP4_HEVC_NALU_TYPE_VPS_NUT) {
                    for (unsigned int j=0; j<seq.m_Nalus.ItemCount(); j++) {
                        const AP4_DataBuffer& buffer = seq.m_Nalus[j];
                        unsigned int prefix_size = m_Prefix.GetDataSize();
                        m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
                        unsigned char* p = m_Prefix.UseData()+prefix_size;
                        *p++ = 0;
                        *p++ = 0;
                        *p++ = 0;
                        *p++ = 1;
                        AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
                    }
                }
            }

            for (unsigned int i=0; i<hevc_desc->GetSequences().ItemCount(); i++) {
                const AP4_HvccAtom::Sequence& seq = hevc_desc->GetSequences()[i];
                if (seq.m_NaluType == AP4_HEVC_NALU_TYPE_SPS_NUT) {
                    for (unsigned int j=0; j<seq.m_Nalus.ItemCount(); j++) {
                        const AP4_DataBuffer& buffer = seq.m_Nalus[j];
                        unsigned int prefix_size = m_Prefix.GetDataSize();
                        m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
                        unsigned char* p = m_Prefix.UseData()+prefix_size;
                        *p++ = 0;
                        *p++ = 0;
                        *p++ = 0;
                        *p++ = 1;
                        AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
                    }
                }
            }

            for (unsigned int i=0; i<hevc_desc->GetSequences().ItemCount(); i++) {
                const AP4_HvccAtom::Sequence& seq = hevc_desc->GetSequences()[i];
                if (seq.m_NaluType == AP4_HEVC_NALU_TYPE_PPS_NUT) {
                    for (unsigned int j=0; j<seq.m_Nalus.ItemCount(); j++) {
                        const AP4_DataBuffer& buffer = seq.m_Nalus[j];
                        unsigned int prefix_size = m_Prefix.GetDataSize();
                        m_Prefix.SetDataSize(prefix_size+4+buffer.GetDataSize());
                        unsigned char* p = m_Prefix.UseData()+prefix_size;
                        *p++ = 0;
                        *p++ = 0;
                        *p++ = 0;
                        *p++ = 1;
                        AP4_CopyMemory(p, buffer.GetData(), buffer.GetDataSize());
                    }
                }
            }
            
        }
    } else {
        return AP4_ERROR_NOT_SUPPORTED;
    }
    
    // decide if we need to emit the prefix
    bool emit_prefix = false;
    if (sample.IsSync() || m_SamplesWritten == 0) {
        emit_prefix = true;
    }
    
    // write the NAL units
    const unsigned char* data      = sample_data.GetData();
    unsigned int         data_size = sample_data.GetDataSize();
    
    // allocate a buffer for the PES packet
    AP4_DataBuffer pes_data;

    // output all NALUs
    for (unsigned int nalu_count = 0; data_size; nalu_count++) {
        // sanity check
        if (data_size < m_NaluLengthSize) break;
        
        // get the next NAL unit
        AP4_UI32 nalu_size;
        if (m_NaluLengthSize == 1) {
            nalu_size = *data++;
            data_size--;
        } else if (m_NaluLengthSize == 2) {
            nalu_size = AP4_BytesToInt16BE(data);
            data      += 2;
            data_size -= 2;
        } else if (m_NaluLengthSize == 4) {
            nalu_size = AP4_BytesToInt32BE(data);
            data      += 4;
            data_size -= 4;
        } else {
            break;
        }
        if (nalu_size > data_size) break;
        
        // check if we need to add a delimiter before the NALU
        if (nalu_count == 0 && sample_description->GetType() == AP4_SampleDescription::TYPE_AVC) {
            if (/* nalu_size != 2 || */ (data[0] & 0x1F) != AP4_AVC_NAL_UNIT_TYPE_ACCESS_UNIT_DELIMITER) {
                // the first NAL unit is not an Access Unit Delimiter, we need to add one
                unsigned char delimiter[6];
                delimiter[0] = 0;
                delimiter[1] = 0;
                delimiter[2] = 0;
                delimiter[3] = 1;
                delimiter[4] = 9;    // NAL type = Access Unit Delimiter;
                delimiter[5] = 0xF0; // Slice types = ANY
                pes_data.AppendData(delimiter, 6);

                if (emit_prefix) {
                    pes_data.AppendData(m_Prefix.GetData(), m_Prefix.GetDataSize());
                    emit_prefix = false;
                }
            }
        } else {
            if (emit_prefix) {
                pes_data.AppendData(m_Prefix.GetData(), m_Prefix.GetDataSize());
                emit_prefix = false;
            }
        }
        
        // add a start code before the NAL unit
        unsigned char start_code[3];
        start_code[0] = 0;
        start_code[1] = 0;
        start_code[2] = 1;
        pes_data.AppendData(start_code, 3);
        
        // add the NALU
        pes_data.AppendData(data, nalu_size);
        
        // for AVC streams that do start with a NAL unit delimiter, we need to add the prefix now
        if (emit_prefix) {
            pes_data.AppendData(m_Prefix.GetData(), m_Prefix.GetDataSize());
            emit_prefix = false;
        }

        // move to the next NAL unit
        data      += nalu_size;
        data_size -= nalu_size;
    } 
    
    // compute the timestamp
    AP4_UI64 dts = AP4_ConvertTime(sample.GetDts(), m_TimeScale, 90000);
    AP4_UI64 pts = AP4_ConvertTime(sample.GetCts(), m_TimeScale, 90000);
    
    // update counters
    ++m_SamplesWritten;
    
    // write the packet
    return WritePES(pes_data.GetData(), pes_data.GetDataSize(), dts, true, pts, with_pcr, output);
}","AP4_Result
AP4_Mpeg2TsVideoSampleStream::WriteSample(AP4_Sample&            VAR_0,
                                          AP4_DataBuffer&        VAR_1, 
                                          AP4_SampleDescription* VAR_2,
                                          bool                   VAR_3, 
                                          AP4_ByteStream&        VAR_4)
{
    if (!VAR_2) {
        return VAR_5;
    }
    
    if (VAR_2->GetType() == AP4_SampleDescription::TYPE_AVC) {
        /* COMMENT_0 */
        AP4_AvcSampleDescription* VAR_6 = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, VAR_2);
        if (VAR_6 == NULL) return VAR_7;
        
        if ((int)VAR_0.GetDescriptionIndex() != VAR_8) {
            VAR_8 = (int)VAR_0.GetDescriptionIndex();
            VAR_9 = VAR_6->GetNaluLengthSize();

            /* COMMENT_1 */
            VAR_10.SetDataSize(0);
            for (unsigned int VAR_11=0; VAR_11<VAR_6->GetSequenceParameters().ItemCount(); VAR_11++) {
                AP4_DataBuffer& VAR_12 = VAR_6->GetSequenceParameters()[VAR_11];
                unsigned int VAR_13 = VAR_10.GetDataSize();
                VAR_10.SetDataSize(VAR_13+4+VAR_12.GetDataSize());
                unsigned char* VAR_14 = VAR_10.UseData()+VAR_13;
                *VAR_14++ = 0;
                *VAR_14++ = 0;
                *VAR_14++ = 0;
                *VAR_14++ = 1;
                AP4_CopyMemory(VAR_14, VAR_12.GetData(), VAR_12.GetDataSize());
            }
            for (unsigned int VAR_11=0; VAR_11<VAR_6->GetPictureParameters().ItemCount(); VAR_11++) {
                AP4_DataBuffer& VAR_12 = VAR_6->GetPictureParameters()[VAR_11];
                unsigned int VAR_13 = VAR_10.GetDataSize();
                VAR_10.SetDataSize(VAR_13+4+VAR_12.GetDataSize());
                unsigned char* VAR_14 = VAR_10.UseData()+VAR_13;
                *VAR_14++ = 0;
                *VAR_14++ = 0;
                *VAR_14++ = 0;
                *VAR_14++ = 1;
                AP4_CopyMemory(VAR_14, VAR_12.GetData(), VAR_12.GetDataSize());
            }
        }
    } else if (VAR_2->GetType() == AP4_SampleDescription::TYPE_HEVC) {
        /* COMMENT_0 */
        AP4_HevcSampleDescription* VAR_15 = AP4_DYNAMIC_CAST(AP4_HevcSampleDescription, VAR_2);
        if (VAR_15 == NULL) return VAR_7;

        if ((int)VAR_0.GetDescriptionIndex() != VAR_8) {
            VAR_8 = (int)VAR_0.GetDescriptionIndex();
            VAR_9 = VAR_15->GetNaluLengthSize();

            /* COMMENT_2 */
            VAR_10.SetDataSize(0);
            for (unsigned int VAR_11=0; VAR_11<VAR_15->GetSequences().ItemCount(); VAR_11++) {
                const AP4_HvccAtom::Sequence& VAR_16 = VAR_15->GetSequences()[VAR_11];
                if (VAR_16.m_NaluType == VAR_17) {
                    for (unsigned int VAR_18=0; VAR_18<VAR_16.m_Nalus.ItemCount(); VAR_18++) {
                        const AP4_DataBuffer& VAR_12 = VAR_16.m_Nalus[VAR_18];
                        unsigned int VAR_13 = VAR_10.GetDataSize();
                        VAR_10.SetDataSize(VAR_13+4+VAR_12.GetDataSize());
                        unsigned char* VAR_14 = VAR_10.UseData()+VAR_13;
                        *VAR_14++ = 0;
                        *VAR_14++ = 0;
                        *VAR_14++ = 0;
                        *VAR_14++ = 1;
                        AP4_CopyMemory(VAR_14, VAR_12.GetData(), VAR_12.GetDataSize());
                    }
                }
            }

            for (unsigned int VAR_11=0; VAR_11<VAR_15->GetSequences().ItemCount(); VAR_11++) {
                const AP4_HvccAtom::Sequence& VAR_16 = VAR_15->GetSequences()[VAR_11];
                if (VAR_16.m_NaluType == VAR_19) {
                    for (unsigned int VAR_18=0; VAR_18<VAR_16.m_Nalus.ItemCount(); VAR_18++) {
                        const AP4_DataBuffer& VAR_12 = VAR_16.m_Nalus[VAR_18];
                        unsigned int VAR_13 = VAR_10.GetDataSize();
                        VAR_10.SetDataSize(VAR_13+4+VAR_12.GetDataSize());
                        unsigned char* VAR_14 = VAR_10.UseData()+VAR_13;
                        *VAR_14++ = 0;
                        *VAR_14++ = 0;
                        *VAR_14++ = 0;
                        *VAR_14++ = 1;
                        AP4_CopyMemory(VAR_14, VAR_12.GetData(), VAR_12.GetDataSize());
                    }
                }
            }

            for (unsigned int VAR_11=0; VAR_11<VAR_15->GetSequences().ItemCount(); VAR_11++) {
                const AP4_HvccAtom::Sequence& VAR_16 = VAR_15->GetSequences()[VAR_11];
                if (VAR_16.m_NaluType == VAR_20) {
                    for (unsigned int VAR_18=0; VAR_18<VAR_16.m_Nalus.ItemCount(); VAR_18++) {
                        const AP4_DataBuffer& VAR_12 = VAR_16.m_Nalus[VAR_18];
                        unsigned int VAR_13 = VAR_10.GetDataSize();
                        VAR_10.SetDataSize(VAR_13+4+VAR_12.GetDataSize());
                        unsigned char* VAR_14 = VAR_10.UseData()+VAR_13;
                        *VAR_14++ = 0;
                        *VAR_14++ = 0;
                        *VAR_14++ = 0;
                        *VAR_14++ = 1;
                        AP4_CopyMemory(VAR_14, VAR_12.GetData(), VAR_12.GetDataSize());
                    }
                }
            }
            
        }
    } else {
        return VAR_7;
    }
    
    /* COMMENT_3 */
    bool VAR_21 = false;
    if (VAR_0.IsSync() || VAR_22 == 0) {
        VAR_21 = true;
    }
    
    /* COMMENT_4 */
    const unsigned char* VAR_23      = VAR_1.GetData();
    unsigned int         VAR_24 = VAR_1.GetDataSize();
    
    /* COMMENT_5 */
    AP4_DataBuffer VAR_25;

    /* COMMENT_6 */
    for (unsigned int VAR_26 = 0; VAR_24; VAR_26++) {
        /* COMMENT_7 */
        if (VAR_24 < VAR_9) break;
        
        /* COMMENT_8 */
        AP4_UI32 VAR_27;
        if (VAR_9 == 1) {
            VAR_27 = *VAR_23++;
            VAR_24--;
        } else if (VAR_9 == 2) {
            VAR_27 = AP4_BytesToInt16BE(VAR_23);
            VAR_23      += 2;
            VAR_24 -= 2;
        } else if (VAR_9 == 4) {
            VAR_27 = AP4_BytesToInt32BE(VAR_23);
            VAR_23      += 4;
            VAR_24 -= 4;
        } else {
            break;
        }
        if (VAR_27 > VAR_24) break;
        
        /* COMMENT_9 */
        if (VAR_26 == 0 && VAR_2->GetType() == AP4_SampleDescription::TYPE_AVC) {
            if (/* COMMENT_10 */ (VAR_23[0] & 0x1F) != VAR_28) {
                /* COMMENT_11 */
                unsigned char VAR_29[6];
                VAR_29[0] = 0;
                VAR_29[1] = 0;
                VAR_29[2] = 0;
                VAR_29[3] = 1;
                VAR_29[4] = 9;    /* COMMENT_12 */
                VAR_29[5] = 0xF0; /* COMMENT_13 */
                VAR_25.AppendData(VAR_29, 6);

                if (VAR_21) {
                    VAR_25.AppendData(VAR_10.GetData(), VAR_10.GetDataSize());
                    VAR_21 = false;
                }
            }
        } else {
            if (VAR_21) {
                VAR_25.AppendData(VAR_10.GetData(), VAR_10.GetDataSize());
                VAR_21 = false;
            }
        }
        
        /* COMMENT_14 */
        unsigned char VAR_30[3];
        VAR_30[0] = 0;
        VAR_30[1] = 0;
        VAR_30[2] = 1;
        VAR_25.AppendData(VAR_30, 3);
        
        /* COMMENT_15 */
        VAR_25.AppendData(VAR_23, VAR_27);
        
        /* COMMENT_16 */
        if (VAR_21) {
            VAR_25.AppendData(VAR_10.GetData(), VAR_10.GetDataSize());
            VAR_21 = false;
        }

        /* COMMENT_17 */
        VAR_23      += VAR_27;
        VAR_24 -= VAR_27;
    } 
    
    /* COMMENT_18 */
    AP4_UI64 VAR_31 = AP4_ConvertTime(VAR_0.GetDts(), VAR_32, 90000);
    AP4_UI64 VAR_33 = AP4_ConvertTime(VAR_0.GetCts(), VAR_32, 90000);
    
    /* COMMENT_19 */
    ++VAR_22;
    
    /* COMMENT_20 */
    return WritePES(VAR_25.GetData(), VAR_25.GetDataSize(), VAR_31, true, VAR_33, VAR_3, VAR_4);
}",axiomatic-systems/Bento4/0de27979fb2f70cb7c9f302946c2b199964ee6aa/Ap4Mpeg2Ts.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,10 @@
                                           bool                   with_pcr, 
                                           AP4_ByteStream&        output)
 {
+    if (!sample_description) {
+        return AP4_ERROR_INVALID_PARAMETERS;
+    }
+    
     if (sample_description->GetType() == AP4_SampleDescription::TYPE_AVC) {
         // check the sample description
         AP4_AvcSampleDescription* avc_desc = AP4_DYNAMIC_CAST(AP4_AvcSampleDescription, sample_description);","{'deleted_lines': [], 'added_lines': ['    if (!sample_description) {', '        return AP4_ERROR_INVALID_PARAMETERS;', '    }', '    ']}",True,"There exists one invalid memory read bug in AP4_SampleDescription::GetFormat() in Ap4SampleDescription.h in Bento4 1.5.1-624, which can allow attackers to cause a denial-of-service via a crafted mp4 file. This vulnerability can be triggered by the executable mp42ts.",5.5,MEDIUM,1,test,2018-07-21T18:30:08Z,2
CVE-2018-14072,['CWE-772'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,saitoha/libsixel,"Fix memory leak problems reported in #67
https://github.com/saitoha/libsixel/issues/67",f94bc6fec696abd77be275226f28409602bd1f27,https://github.com/saitoha/libsixel/commit/f94bc6fec696abd77be275226f28409602bd1f27,src/decoder.c,sixel_decoder_decode,"SIXELAPI SIXELSTATUS
sixel_decoder_decode(
sixel_decoder_t  *decoder)
{
SIXELSTATUS status = SIXEL_FALSE;
unsigned char *raw_data;
int sx;
int sy;
int raw_len;
int max;
int n;
FILE *input_fp = NULL;
unsigned char *indexed_pixels;
unsigned char *palette;
int ncolors;
unsigned char *pixels = NULL;
sixel_decoder_ref(decoder);
if (strcmp(decoder->input, ""-"") == 0) {
#if defined(O_BINARY)
# if HAVE__SETMODE
_setmode(fileno(stdin), O_BINARY);
# elif HAVE_SETMODE
setmode(fileno(stdin), O_BINARY);
# endif  
#endif  
input_fp = stdin;
} else {
input_fp = fopen(decoder->input, ""rb"");
if (!input_fp) {
sixel_helper_set_additional_message(
""sixel_decoder_decode: fopen() failed."");
status = (SIXEL_LIBC_ERROR | (errno & 0xff));
goto end;
}
}
raw_len = 0;
max = 64 * 1024;
raw_data = (unsigned char *)sixel_allocator_malloc(decoder->allocator, (size_t)max);
if (raw_data == NULL) {
sixel_helper_set_additional_message(
""sixel_decoder_decode: sixel_allocator_malloc() failed."");
status = SIXEL_BAD_ALLOCATION;
goto end;
}
for (;;) {
if ((max - raw_len) < 4096) {
max *= 2;
raw_data = (unsigned char *)sixel_allocator_realloc(decoder->allocator, raw_data, (size_t)max);
if (raw_data == NULL) {
sixel_helper_set_additional_message(
""sixel_decoder_decode: sixel_allocator_realloc() failed."");
status = SIXEL_BAD_ALLOCATION;
goto end;
}
}
if ((n = (int)fread(raw_data + raw_len, 1, 4096, input_fp)) <= 0) {
break;
}
raw_len += n;
}
if (input_fp != stdout) {
fclose(input_fp);
}
status = sixel_decode_raw(
raw_data,
raw_len,
&indexed_pixels,
&sx,
&sy,
&palette,
&ncolors,
decoder->allocator);
if (SIXEL_FAILED(status)) {
goto end;
}
status = sixel_helper_write_image_file(indexed_pixels, sx, sy, palette,
SIXEL_PIXELFORMAT_PAL8,
decoder->output,
SIXEL_FORMAT_PNG,
decoder->allocator);
if (SIXEL_FAILED(status)) {
goto end;
}
end:
sixel_allocator_free(decoder->allocator, pixels);
sixel_decoder_unref(decoder);
return status;
}","SIXELAPI VAR_0
sixel_decoder_decode(
sixel_decoder_t  *VAR_1)
{
SIXELSTATUS VAR_2 = VAR_3;
unsigned char *VAR_4;
int VAR_5;
int VAR_6;
int VAR_7;
int VAR_8;
int VAR_9;
FILE *VAR_10 = NULL;
unsigned char *VAR_11;
unsigned char *VAR_12;
int VAR_13;
unsigned char *VAR_14 = NULL;
sixel_decoder_ref(VAR_1);
if (strcmp(VAR_1->input, ""-"") == 0) {
#if defined(VAR_15)
# if VAR_16
_setmode(fileno(VAR_17), VAR_15);
# elif VAR_18
setmode(fileno(VAR_17), VAR_15);
# endif  
#endif  
VAR_10 = VAR_17;
} else {
VAR_10 = fopen(VAR_1->input, ""rb"");
if (!VAR_10) {
sixel_helper_set_additional_message(
""sixel_decoder_decode: fopen() failed."");
VAR_2 = (VAR_19 | (VAR_20 & 0xff));
goto end;
}
}
VAR_7 = 0;
VAR_8 = 64 * 1024;
VAR_4 = (unsigned char *)sixel_allocator_malloc(VAR_1->allocator, (size_t)VAR_8);
if (VAR_4 == NULL) {
sixel_helper_set_additional_message(
""sixel_decoder_decode: sixel_allocator_malloc() failed."");
VAR_2 = VAR_21;
goto end;
}
for (;;) {
if ((VAR_8 - VAR_7) < 4096) {
VAR_8 *= 2;
VAR_4 = (unsigned char *)sixel_allocator_realloc(VAR_1->allocator, VAR_4, (size_t)VAR_8);
if (VAR_4 == NULL) {
sixel_helper_set_additional_message(
""sixel_decoder_decode: sixel_allocator_realloc() failed."");
VAR_2 = VAR_21;
goto end;
}
}
if ((VAR_9 = (int)fread(VAR_4 + VAR_7, 1, 4096, VAR_10)) <= 0) {
break;
}
VAR_7 += VAR_9;
}
if (VAR_10 != VAR_22) {
fclose(VAR_10);
}
VAR_2 = sixel_decode_raw(
VAR_4,
VAR_7,
&VAR_11,
&VAR_5,
&VAR_6,
&VAR_12,
&VAR_13,
VAR_1->allocator);
if (SIXEL_FAILED(VAR_2)) {
goto end;
}
VAR_2 = sixel_helper_write_image_file(VAR_11, VAR_5, VAR_6, VAR_12,
VAR_23,
VAR_1->output,
VAR_24,
VAR_1->allocator);
if (SIXEL_FAILED(VAR_2)) {
goto end;
}
end:
sixel_allocator_free(VAR_1->allocator, VAR_14);
sixel_decoder_unref(VAR_1);
return VAR_2;
}",,"SIXELAPI SIXELSTATUS
sixel_decoder_decode(
    sixel_decoder_t /* in */ *decoder)
{
    SIXELSTATUS status = SIXEL_FALSE;
    unsigned char *raw_data = NULL;
    int sx;
    int sy;
    int raw_len;
    int max;
    int n;
    FILE *input_fp = NULL;
    unsigned char *indexed_pixels = NULL;
    unsigned char *palette = NULL;
    int ncolors;

    sixel_decoder_ref(decoder);

    if (strcmp(decoder->input, ""-"") == 0) {
        /* for windows */
#if defined(O_BINARY)
# if HAVE__SETMODE
        _setmode(fileno(stdin), O_BINARY);
# elif HAVE_SETMODE
        setmode(fileno(stdin), O_BINARY);
# endif  /* HAVE_SETMODE */
#endif  /* defined(O_BINARY) */
        input_fp = stdin;
    } else {
        input_fp = fopen(decoder->input, ""rb"");
        if (!input_fp) {
            sixel_helper_set_additional_message(
                ""sixel_decoder_decode: fopen() failed."");
            status = (SIXEL_LIBC_ERROR | (errno & 0xff));
            goto end;
        }
    }

    raw_len = 0;
    max = 64 * 1024;

    raw_data = (unsigned char *)sixel_allocator_malloc(decoder->allocator, (size_t)max);
    if (raw_data == NULL) {
        sixel_helper_set_additional_message(
            ""sixel_decoder_decode: sixel_allocator_malloc() failed."");
        status = SIXEL_BAD_ALLOCATION;
        goto end;
    }

    for (;;) {
        if ((max - raw_len) < 4096) {
            max *= 2;
            raw_data = (unsigned char *)sixel_allocator_realloc(decoder->allocator, raw_data, (size_t)max);
            if (raw_data == NULL) {
                sixel_helper_set_additional_message(
                    ""sixel_decoder_decode: sixel_allocator_realloc() failed."");
                status = SIXEL_BAD_ALLOCATION;
                goto end;
            }
        }
        if ((n = (int)fread(raw_data + raw_len, 1, 4096, input_fp)) <= 0) {
            break;
        }
        raw_len += n;
    }

    if (input_fp != stdout) {
        fclose(input_fp);
    }

    status = sixel_decode_raw(
        raw_data,
        raw_len,
        &indexed_pixels,
        &sx,
        &sy,
        &palette,
        &ncolors,
        decoder->allocator);
    if (SIXEL_FAILED(status)) {
        goto end;
    }

    status = sixel_helper_write_image_file(indexed_pixels, sx, sy, palette,
                                           SIXEL_PIXELFORMAT_PAL8,
                                           decoder->output,
                                           SIXEL_FORMAT_PNG,
                                           decoder->allocator);

    if (SIXEL_FAILED(status)) {
        goto end;
    }

end:
    sixel_allocator_free(decoder->allocator, raw_data);
    sixel_allocator_free(decoder->allocator, indexed_pixels);
    sixel_allocator_free(decoder->allocator, palette);
    sixel_decoder_unref(decoder);

    return status;
}","SIXELAPI VAR_0
sixel_decoder_decode(
    sixel_decoder_t /* COMMENT_0 */ *VAR_1)
{
    SIXELSTATUS VAR_2 = VAR_3;
    unsigned char *VAR_4 = NULL;
    int VAR_5;
    int VAR_6;
    int VAR_7;
    int VAR_8;
    int VAR_9;
    FILE *VAR_10 = NULL;
    unsigned char *VAR_11 = NULL;
    unsigned char *VAR_12 = NULL;
    int VAR_13;

    sixel_decoder_ref(VAR_1);

    if (strcmp(VAR_1->input, ""-"") == 0) {
        /* COMMENT_1 */
#if defined(VAR_14)
# if VAR_15
        _setmode(fileno(VAR_16), VAR_14);
# elif VAR_17
        setmode(fileno(VAR_16), VAR_14);
# endif  /* COMMENT_2 */
#endif  /* COMMENT_3 */
        VAR_10 = VAR_16;
    } else {
        VAR_10 = fopen(VAR_1->input, ""rb"");
        if (!VAR_10) {
            sixel_helper_set_additional_message(
                ""sixel_decoder_decode: fopen() failed."");
            VAR_2 = (VAR_18 | (VAR_19 & 0xff));
            goto end;
        }
    }

    VAR_7 = 0;
    VAR_8 = 64 * 1024;

    VAR_4 = (unsigned char *)sixel_allocator_malloc(VAR_1->allocator, (size_t)VAR_8);
    if (VAR_4 == NULL) {
        sixel_helper_set_additional_message(
            ""sixel_decoder_decode: sixel_allocator_malloc() failed."");
        VAR_2 = VAR_20;
        goto end;
    }

    for (;;) {
        if ((VAR_8 - VAR_7) < 4096) {
            VAR_8 *= 2;
            VAR_4 = (unsigned char *)sixel_allocator_realloc(VAR_1->allocator, VAR_4, (size_t)VAR_8);
            if (VAR_4 == NULL) {
                sixel_helper_set_additional_message(
                    ""sixel_decoder_decode: sixel_allocator_realloc() failed."");
                VAR_2 = VAR_20;
                goto end;
            }
        }
        if ((VAR_9 = (int)fread(VAR_4 + VAR_7, 1, 4096, VAR_10)) <= 0) {
            break;
        }
        VAR_7 += VAR_9;
    }

    if (VAR_10 != VAR_21) {
        fclose(VAR_10);
    }

    VAR_2 = sixel_decode_raw(
        VAR_4,
        VAR_7,
        &VAR_11,
        &VAR_5,
        &VAR_6,
        &VAR_12,
        &VAR_13,
        VAR_1->allocator);
    if (SIXEL_FAILED(VAR_2)) {
        goto end;
    }

    VAR_2 = sixel_helper_write_image_file(VAR_11, VAR_5, VAR_6, VAR_12,
                                           VAR_22,
                                           VAR_1->output,
                                           VAR_23,
                                           VAR_1->allocator);

    if (SIXEL_FAILED(VAR_2)) {
        goto end;
    }

end:
    sixel_allocator_free(VAR_1->allocator, VAR_4);
    sixel_allocator_free(VAR_1->allocator, VAR_11);
    sixel_allocator_free(VAR_1->allocator, VAR_12);
    sixel_decoder_unref(VAR_1);

    return VAR_2;
}",,"--- func_before
+++ func_after
@@ -3,17 +3,16 @@
     sixel_decoder_t /* in */ *decoder)
 {
     SIXELSTATUS status = SIXEL_FALSE;
-    unsigned char *raw_data;
+    unsigned char *raw_data = NULL;
     int sx;
     int sy;
     int raw_len;
     int max;
     int n;
     FILE *input_fp = NULL;
-    unsigned char *indexed_pixels;
-    unsigned char *palette;
+    unsigned char *indexed_pixels = NULL;
+    unsigned char *palette = NULL;
     int ncolors;
-    unsigned char *pixels = NULL;
 
     sixel_decoder_ref(decoder);
 
@@ -93,7 +92,9 @@
     }
 
 end:
-    sixel_allocator_free(decoder->allocator, pixels);
+    sixel_allocator_free(decoder->allocator, raw_data);
+    sixel_allocator_free(decoder->allocator, indexed_pixels);
+    sixel_allocator_free(decoder->allocator, palette);
     sixel_decoder_unref(decoder);
 
     return status;","{'deleted_lines': ['    unsigned char *raw_data;', '    unsigned char *indexed_pixels;', '    unsigned char *palette;', '    unsigned char *pixels = NULL;', '    sixel_allocator_free(decoder->allocator, pixels);'], 'added_lines': ['    unsigned char *raw_data = NULL;', '    unsigned char *indexed_pixels = NULL;', '    unsigned char *palette = NULL;', '    sixel_allocator_free(decoder->allocator, raw_data);', '    sixel_allocator_free(decoder->allocator, indexed_pixels);', '    sixel_allocator_free(decoder->allocator, palette);']}",True,"libsixel 1.8.1 has a memory leak in sixel_decoder_decode in decoder.c, image_buffer_resize in fromsixel.c, and sixel_decode_raw in fromsixel.c.",7.5,HIGH,2,test,2018-07-22T05:14:28Z,2
CVE-2018-16328,['CWE-476'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1224,107ce8577e818cf4801e5a59641cb769d645cc95,https://github.com/ImageMagick/ImageMagick/commit/107ce8577e818cf4801e5a59641cb769d645cc95,MagickCore/log.c,CheckEventLogging,"static inline void CheckEventLogging()
{
if (IsLinkedListEmpty(log_cache) != MagickFalse)
event_logging=MagickFalse;
else
{
LogInfo
*p;
ResetLinkedListIterator(log_cache);
p=(LogInfo *) GetNextValueInLinkedList(log_cache);
event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;
}
}","static inline void CheckEventLogging()
{
if (IsLinkedListEmpty(VAR_0) != VAR_1)
VAR_2=VAR_1;
else
{
LogInfo
*VAR_3;
ResetLinkedListIterator(VAR_0);
VAR_3=(LogInfo *) GetNextValueInLinkedList(VAR_0);
VAR_2=VAR_3->event_mask != VAR_4 ? VAR_5: VAR_1;
}
}",ImageMagick/107ce8577e818cf4801e5a59641cb769d645cc95/log.c/vul/before/0.json,"static inline void CheckEventLogging()
{
  /*
    Are we logging events?
  */
  if (IsLinkedListEmpty(log_cache) != MagickFalse)
    event_logging=MagickFalse;
  else
    {
      LogInfo
        *p;

      ResetLinkedListIterator(log_cache);
      p=(LogInfo *) GetNextValueInLinkedList(log_cache);
      event_logging=(p != (LogInfo *) NULL) && (p->event_mask != NoEvents) ?
        MagickTrue: MagickFalse;
    }
}","static inline void CheckEventLogging()
{
  /* COMMENT_0 */
                          
    
  if (IsLinkedListEmpty(VAR_0) != VAR_1)
    VAR_2=VAR_1;
  else
    {
      LogInfo
        *VAR_3;

      ResetLinkedListIterator(VAR_0);
      VAR_3=(LogInfo *) GetNextValueInLinkedList(VAR_0);
      VAR_2=(VAR_3 != (LogInfo *) NULL) && (VAR_3->event_mask != VAR_4) ?
        VAR_5: VAR_1;
    }
}",ImageMagick/107ce8577e818cf4801e5a59641cb769d645cc95/log.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
 
       ResetLinkedListIterator(log_cache);
       p=(LogInfo *) GetNextValueInLinkedList(log_cache);
-      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;
+      event_logging=(p != (LogInfo *) NULL) && (p->event_mask != NoEvents) ?
+        MagickTrue: MagickFalse;
     }
 }","{'deleted_lines': ['      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;'], 'added_lines': ['      event_logging=(p != (LogInfo *) NULL) && (p->event_mask != NoEvents) ?', '        MagickTrue: MagickFalse;']}",True,"In ImageMagick before 7.0.8-8, a NULL pointer dereference exists in the CheckEventLogging function in MagickCore/log.c.",9.8,CRITICAL,3,test,2018-07-23T18:37:48Z,2
CVE-2018-15857,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0.0,xkbcommon/libxkbcommon,"xkbcomp: fix pointer value for FreeStmt

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>",c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,https://github.com/xkbcommon/libxkbcommon/commit/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb,src/xkbcomp/ast-build.c,ExprAppendMultiKeysymList,"ExprDef *
ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
unsigned nSyms = darray_size(expr->keysym_list.syms);
unsigned numEntries = darray_size(append->keysym_list.syms);
darray_append(expr->keysym_list.symsMapIndex, nSyms);
darray_append(expr->keysym_list.symsNumEntries, numEntries);
darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
FreeStmt((ParseCommon *) &append);
return expr;
}","ExprDef *
ExprAppendMultiKeysymList(ExprDef *VAR_0, ExprDef *VAR_1)
{
unsigned VAR_2 = darray_size(VAR_0->keysym_list.syms);
unsigned VAR_3 = darray_size(VAR_1->keysym_list.syms);
darray_append(VAR_0->keysym_list.symsMapIndex, VAR_2);
darray_append(VAR_0->keysym_list.symsNumEntries, VAR_3);
darray_concat(VAR_0->keysym_list.syms, VAR_1->keysym_list.syms);
FreeStmt((ParseCommon *) &VAR_1);
return VAR_0;
}",xkbcommon/libxkbcommon/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb/ast-build.c/vul/before/0.json,"ExprDef *
ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
{
    unsigned nSyms = darray_size(expr->keysym_list.syms);
    unsigned numEntries = darray_size(append->keysym_list.syms);

    darray_append(expr->keysym_list.symsMapIndex, nSyms);
    darray_append(expr->keysym_list.symsNumEntries, numEntries);
    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);

    FreeStmt((ParseCommon *) append);

    return expr;
}","ExprDef *
ExprAppendMultiKeysymList(ExprDef *VAR_0, ExprDef *VAR_1)
{
    unsigned VAR_2 = darray_size(VAR_0->keysym_list.syms);
    unsigned VAR_3 = darray_size(VAR_1->keysym_list.syms);

    darray_append(VAR_0->keysym_list.symsMapIndex, VAR_2);
    darray_append(VAR_0->keysym_list.symsNumEntries, VAR_3);
    darray_concat(VAR_0->keysym_list.syms, VAR_1->keysym_list.syms);

    FreeStmt((ParseCommon *) VAR_1);

    return VAR_0;
}",xkbcommon/libxkbcommon/c1e5ac16e77a21f87bdf3bc4dea61b037a17dddb/ast-build.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
-    FreeStmt((ParseCommon *) &append);
+    FreeStmt((ParseCommon *) append);
 
     return expr;
 }","{'deleted_lines': ['    FreeStmt((ParseCommon *) &append);'], 'added_lines': ['    FreeStmt((ParseCommon *) append);']}",True,An invalid free in ExprAppendMultiKeysymList in xkbcomp/ast-build.c in xkbcommon before 0.8.1 could be used by local attackers to crash xkbcommon keymap parsers or possibly have unspecified other impact by supplying a crafted keymap file.,7.8,HIGH,2,test,2018-07-30T04:11:46Z,2
CVE-2018-20856,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0.0,torvalds/linux,"block: blk_init_allocated_queue() set q->fq as NULL in the fail case

We find the memory use-after-free issue in __blk_drain_queue()
on the kernel 4.14. After read the latest kernel 4.18-rc6 we
think it has the same problem.

Memory is allocated for q->fq in the blk_init_allocated_queue().
If the elevator init function called with error return, it will
run into the fail case to free the q->fq.

Then the __blk_drain_queue() uses the same memory after the free
of the q->fq, it will lead to the unpredictable event.

The patch is to set q->fq as NULL in the fail case of
blk_init_allocated_queue().

Fixes: commit 7c94e1c157a2 (""block: introduce blk_flush_queue to drive flush machinery"")
Cc: <stable@vger.kernel.org>
Reviewed-by: Ming Lei <ming.lei@redhat.com>
Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
Signed-off-by: xiao jin <jin.xiao@intel.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>",54648cf1ec2d7f4b6a71767799c45676a138ca24,https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24,block/blk-core.c,blk_init_allocated_queue,"int blk_init_allocated_queue(struct request_queue *q)
{
WARN_ON_ONCE(q->mq_ops);
q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
if (!q->fq)
return -ENOMEM;
if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
goto out_free_flush_queue;
if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
goto out_exit_flush_rq;
INIT_WORK(&q->timeout_work, blk_timeout_work);
q->queue_flags|= QUEUE_FLAG_DEFAULT;
blk_queue_make_request(q, blk_queue_bio);
q->sg_reserved_size = INT_MAX;
if (elevator_init(q))
goto out_exit_flush_rq;
return 0;
out_exit_flush_rq:
if (q->exit_rq_fn)
q->exit_rq_fn(q, q->fq->flush_rq);
out_free_flush_queue:
blk_free_flush_queue(q->fq);
return -ENOMEM;
}","int blk_init_allocated_queue(struct request_queue *VAR_0)
{
WARN_ON_ONCE(VAR_0->mq_ops);
VAR_0->fq = blk_alloc_flush_queue(VAR_0, VAR_1, VAR_0->cmd_size);
if (!VAR_0->fq)
return -VAR_2;
if (VAR_0->init_rq_fn && VAR_0->init_rq_fn(VAR_0, VAR_0->fq->flush_rq, VAR_3))
goto out_free_flush_queue;
if (blk_init_rl(&VAR_0->root_rl, VAR_0, VAR_3))
goto out_exit_flush_rq;
INIT_WORK(&VAR_0->timeout_work, VAR_4);
VAR_0->queue_flags|= VAR_5;
blk_queue_make_request(VAR_0, VAR_6);
VAR_0->sg_reserved_size = VAR_7;
if (elevator_init(VAR_0))
goto out_exit_flush_rq;
return 0;
out_exit_flush_rq:
if (VAR_0->exit_rq_fn)
VAR_0->exit_rq_fn(VAR_0, VAR_0->fq->flush_rq);
out_free_flush_queue:
blk_free_flush_queue(VAR_0->fq);
return -VAR_2;
}",torvalds/linux/54648cf1ec2d7f4b6a71767799c45676a138ca24/blk-core.c/vul/before/0.json,"int blk_init_allocated_queue(struct request_queue *q)
{
	WARN_ON_ONCE(q->mq_ops);

	q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);
	if (!q->fq)
		return -ENOMEM;

	if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))
		goto out_free_flush_queue;

	if (blk_init_rl(&q->root_rl, q, GFP_KERNEL))
		goto out_exit_flush_rq;

	INIT_WORK(&q->timeout_work, blk_timeout_work);
	q->queue_flags		|= QUEUE_FLAG_DEFAULT;

	/*
	 * This also sets hw/phys segments, boundary and size
	 */
	blk_queue_make_request(q, blk_queue_bio);

	q->sg_reserved_size = INT_MAX;

	if (elevator_init(q))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (q->exit_rq_fn)
		q->exit_rq_fn(q, q->fq->flush_rq);
out_free_flush_queue:
	blk_free_flush_queue(q->fq);
	q->fq = NULL;
	return -ENOMEM;
}","int blk_init_allocated_queue(struct request_queue *VAR_0)
{
	WARN_ON_ONCE(VAR_0->mq_ops);

	VAR_0->fq = blk_alloc_flush_queue(VAR_0, VAR_1, VAR_0->cmd_size);
	if (!VAR_0->fq)
		return -VAR_2;

	if (VAR_0->init_rq_fn && VAR_0->init_rq_fn(VAR_0, VAR_0->fq->flush_rq, VAR_3))
		goto out_free_flush_queue;

	if (blk_init_rl(&VAR_0->root_rl, VAR_0, VAR_3))
		goto out_exit_flush_rq;

	INIT_WORK(&VAR_0->timeout_work, VAR_4);
	VAR_0->queue_flags		|= VAR_5;

	/* COMMENT_0 */
                                                      
    
	blk_queue_make_request(VAR_0, VAR_6);

	VAR_0->sg_reserved_size = VAR_7;

	if (elevator_init(VAR_0))
		goto out_exit_flush_rq;
	return 0;

out_exit_flush_rq:
	if (VAR_0->exit_rq_fn)
		VAR_0->exit_rq_fn(VAR_0, VAR_0->fq->flush_rq);
out_free_flush_queue:
	blk_free_flush_queue(VAR_0->fq);
	VAR_0->fq = NULL;
	return -VAR_2;
}",torvalds/linux/54648cf1ec2d7f4b6a71767799c45676a138ca24/blk-core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,5 +31,6 @@
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
+	q->fq = NULL;
 	return -ENOMEM;
 }","{'deleted_lines': [], 'added_lines': ['\tq->fq = NULL;']}",True,"An issue was discovered in the Linux kernel before 4.18.7. In block/blk-core.c, there is an __blk_drain_queue() use-after-free because a certain error case is mishandled.",7.8,HIGH,2,test,2018-07-30T06:11:12Z,2
CVE-2019-15163,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,the-tcpdump-group/libpcap,"Don't crash if crypt() fails.

It can fail, so make sure it doesn't before comparing its result with
the password.

This addresses Include Security issue F12: [libpcap] Remote Packet
Capture Daemon Null Pointer Dereference Denial of Service.",437b273761adedcbd880f714bfa44afeec186a31,https://github.com/the-tcpdump-group/libpcap/commit/437b273761adedcbd880f714bfa44afeec186a31,rpcapd/daemon.c,daemon_AuthUserPwd,"static int
daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
HANDLE Token;
if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
{
pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
GetLastError(), ""LogonUser() failed"");
return -1;
}
if (ImpersonateLoggedOnUser(Token) == 0)
{
pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
GetLastError(), ""ImpersonateLoggedOnUser() failed"");
CloseHandle(Token);
return -1;
}
CloseHandle(Token);
return 0;
#else
struct passwd *user;
char *user_password;
#ifdef HAVE_GETSPNAM
struct spwd *usersp;
#endif
if ((user = getpwnam(username)) == NULL)
{
pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
return -1;
}
#ifdef HAVE_GETSPNAM
if ((usersp = getspnam(username)) == NULL)
{
pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
return -1;
}
user_password = usersp->sp_pwdp;
#else
user_password = user->pw_passwd;
#endif
if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)
{
pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
return -1;
}
if (setuid(user->pw_uid))
{
pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
errno, ""setuid"");
return -1;
}
return 0;
#endif
}","static int
daemon_AuthUserPwd(char *VAR_0, char *VAR_1, char *VAR_2)
{
#ifdef VAR_3
HANDLE VAR_4;
if (LogonUser(VAR_0, ""."", VAR_1, VAR_5, VAR_6, &VAR_4) == 0)
{
pcap_fmt_errmsg_for_win32_err(VAR_2, VAR_7,
GetLastError(), ""LogonUser() failed"");
return -1;
}
if (ImpersonateLoggedOnUser(VAR_4) == 0)
{
pcap_fmt_errmsg_for_win32_err(VAR_2, VAR_7,
GetLastError(), ""ImpersonateLoggedOnUser() failed"");
CloseHandle(VAR_4);
return -1;
}
CloseHandle(VAR_4);
return 0;
#else
struct passwd *VAR_8;
char *VAR_9;
#ifdef VAR_10
struct spwd *VAR_11;
#endif
if ((VAR_8 = getpwnam(VAR_0)) == NULL)
{
pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
return -1;
}
#ifdef VAR_10
if ((VAR_11 = getspnam(VAR_0)) == NULL)
{
pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
return -1;
}
VAR_9 = VAR_11->sp_pwdp;
#else
VAR_9 = VAR_8->pw_passwd;
#endif
if (strcmp(VAR_9, (char *) crypt(VAR_1, VAR_9)) != 0)
{
pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
return -1;
}
if (setuid(VAR_8->pw_uid))
{
pcap_fmt_errmsg_for_errno(VAR_2, VAR_7,
VAR_12, ""setuid"");
return -1;
}
return 0;
#endif
}",the-tcpdump-group/libpcap/437b273761adedcbd880f714bfa44afeec186a31/daemon.c/vul/before/0.json,"static int
daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
	/*
	 * Warning: the user which launches the process must have the
	 * SE_TCB_NAME right.
	 * This corresponds to have the ""Act as part of the Operating System""
	 * turned on (administrative tools, local security settings, local
	 * policies, user right assignment)
	 * However, it seems to me that if you run it as a service, this
	 * right should be provided by default.
	 *
	 * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,
	 * which merely indicates that the user name or password is
	 * incorrect, not whether it's the user name or the password
	 * that's incorrect, so a client that's trying to brute-force
	 * accounts doesn't know whether it's the user name or the
	 * password that's incorrect, so it doesn't know whether to
	 * stop trying to log in with a given user name and move on
	 * to another user name.
	 */
	HANDLE Token;
	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""LogonUser() failed"");
		return -1;
	}

	// This call should change the current thread to the selected user.
	// I didn't test it.
	if (ImpersonateLoggedOnUser(Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		CloseHandle(Token);
		return -1;
	}

	CloseHandle(Token);
	return 0;

#else
	/*
	 * See
	 *
	 *	http://www.unixpapa.com/incnote/passwd.html
	 *
	 * We use the Solaris/Linux shadow password authentication if
	 * we have getspnam(), otherwise we just do traditional
	 * authentication, which, on some platforms, might work, even
	 * with shadow passwords, if we're running as root.  Traditional
	 * authenticaion won't work if we're not running as root, as
	 * I think these days all UN*Xes either won't return the password
	 * at all with getpwnam() or will only do so if you're root.
	 *
	 * XXX - perhaps what we *should* be using is PAM, if we have
	 * it.  That might hide all the details of username/password
	 * authentication, whether it's done with a visible-to-root-
	 * only password database or some other authentication mechanism,
	 * behind its API.
	 */
	struct passwd *user;
	char *user_password;
#ifdef HAVE_GETSPNAM
	struct spwd *usersp;
#endif
	char *crypt_password;

	// This call is needed to get the uid
	if ((user = getpwnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

#ifdef HAVE_GETSPNAM
	// This call is needed to get the password; otherwise 'x' is returned
	if ((usersp = getspnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}
	user_password = usersp->sp_pwdp;
#else
	/*
	 * XXX - what about other platforms?
	 * The unixpapa.com page claims this Just Works on *BSD if you're
	 * running as root - it's from 2000, so it doesn't indicate whether
	 * macOS (which didn't come out until 2001, under the name Mac OS
	 * X) behaves like the *BSDs or not, and might also work on AIX.
	 * HP-UX does something else.
	 *
	 * Again, hopefully PAM hides all that.
	 */
	user_password = user->pw_passwd;
#endif

	crypt_password = crypt(password, user_password);
	if (crypt_password == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}
	if (strcmp(user_password, crypt_password) != 0)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

	if (setuid(user->pw_uid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setuid"");
		return -1;
	}

/*	if (setgid(user->pw_gid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setgid"");
		return -1;
	}
*/
	return 0;

#endif

}","static int
daemon_AuthUserPwd(char *VAR_0, char *VAR_1, char *VAR_2)
{
#ifdef VAR_3
	/* COMMENT_0 */
                                                              
                      
                                                                      
                                                                   
                                    
                                                                 
                                        
   
                                                                     
                                                            
                                                             
                                                              
                                                           
                                                            
                                                            
                         
    
	HANDLE VAR_4;
	if (LogonUser(VAR_0, ""."", VAR_1, VAR_5, VAR_6, &VAR_4) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(VAR_2, VAR_7,
		    GetLastError(), ""LogonUser() failed"");
		return -1;
	}

	/* COMMENT_18 */
	/* COMMENT_19 */
	if (ImpersonateLoggedOnUser(VAR_4) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(VAR_2, VAR_7,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		CloseHandle(VAR_4);
		return -1;
	}

	CloseHandle(VAR_4);
	return 0;

#else
	/* COMMENT_20 */
       
   
                                               
   
                                                              
                                                        
                                                              
                                                                 
                                                             
                                                                  
                                                             
   
                                                              
                                                             
                                                             
                                                                  
                   
    
	struct passwd *VAR_8;
	char *VAR_9;
#ifdef VAR_10
	struct spwd *VAR_11;
#endif
	char *VAR_12;

	/* COMMENT_37 */
	if ((VAR_8 = getpwnam(VAR_0)) == NULL)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

#ifdef VAR_10
	/* COMMENT_38 */
	if ((VAR_11 = getspnam(VAR_0)) == NULL)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
		return -1;
	}
	VAR_9 = VAR_11->sp_pwdp;
#else
	/* COMMENT_39 */
                                     
                                                                  
                                                                    
                                                                  
                                                                 
                              
   
                                        
    
	VAR_9 = VAR_8->pw_passwd;
#endif

	VAR_12 = crypt(VAR_1, VAR_9);
	if (VAR_12 == NULL)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
		return -1;
	}
	if (strcmp(VAR_9, VAR_12) != 0)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

	if (setuid(VAR_8->pw_uid))
	{
		pcap_fmt_errmsg_for_errno(VAR_2, VAR_7,
		    VAR_13, ""setuid"");
		return -1;
	}

/* COMMENT_49 */
  
                                                     
                       
            
  
  
	return 0;

#endif

}",the-tcpdump-group/libpcap/437b273761adedcbd880f714bfa44afeec186a31/daemon.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -66,6 +66,7 @@
 #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
+	char *crypt_password;
 
 	// This call is needed to get the uid
 	if ((user = getpwnam(username)) == NULL)
@@ -96,7 +97,13 @@
 	user_password = user->pw_passwd;
 #endif
 
-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)
+	crypt_password = crypt(password, user_password);
+	if (crypt_password == NULL)
+	{
+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
+		return -1;
+	}
+	if (strcmp(user_password, crypt_password) != 0)
 	{
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		return -1;","{'deleted_lines': ['\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)'], 'added_lines': ['\tchar *crypt_password;', '\tcrypt_password = crypt(password, user_password);', '\tif (crypt_password == NULL)', '\t{', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");', '\t\treturn -1;', '\t}', '\tif (strcmp(user_password, crypt_password) != 0)']}",True,rpcapd/daemon.c in libpcap before 1.9.1 allows attackers to cause a denial of service (NULL pointer dereference and daemon crash) if a crypt() call fails.,7.5,HIGH,2,test,2018-08-06T02:04:38Z,2
CVE-2019-15162,['CWE-345'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,the-tcpdump-group/libpcap,"On UN*X, don't tell the client why authentication failed.

""no such user"" tells the client that the user ID isn't valid and,
therefore, that it needn't bother trying to do password cracking for
that user ID; just saying that the authentication failed dosn't give
them that hint.

This resolves the third problem in Include Security issue F11: [libpcap]
Remote Packet Capture Daemon Multiple Authentication Improvements.

The Windows LogonUser() API returns ERROR_LOGON_FAILURE for both cases,
so the Windows code doesn't have this issue.  Just return the same
""Authentication failed"" message on Windows to the user.

For various authentication failures *other* than ""no such user"" and
""password not valid"", log a message, as there's a problem that may need
debugging.  We don't need to tell the end user what the problem is, as
they may not bother reporting it and, even if they do, they may not give
the full error message.",484d60cbf7ca4ec758c3cbb8a82d68b244a78d58,https://github.com/the-tcpdump-group/libpcap/commit/484d60cbf7ca4ec758c3cbb8a82d68b244a78d58,rpcapd/daemon.c,daemon_AuthUserPwd,"static int
daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
HANDLE Token;
if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
{
pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
GetLastError(), ""LogonUser() failed"");
return -1;
}
if (ImpersonateLoggedOnUser(Token) == 0)
{
pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
GetLastError(), ""ImpersonateLoggedOnUser() failed"");
CloseHandle(Token);
return -1;
}
CloseHandle(Token);
return 0;
#else
struct passwd *user;
char *user_password;
#ifdef HAVE_GETSPNAM
struct spwd *usersp;
#endif
char *crypt_password;
if ((user = getpwnam(username)) == NULL)
{
pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
return -1;
}
#ifdef HAVE_GETSPNAM
if ((usersp = getspnam(username)) == NULL)
{
pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
return -1;
}
user_password = usersp->sp_pwdp;
#else
user_password = user->pw_passwd;
#endif
crypt_password = crypt(password, user_password);
if (crypt_password == NULL)
{
pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
return -1;
}
if (strcmp(user_password, crypt_password) != 0)
{
pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
return -1;
}
if (setuid(user->pw_uid))
{
pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
errno, ""setuid"");
return -1;
}
return 0;
#endif
}","static int
daemon_AuthUserPwd(char *VAR_0, char *VAR_1, char *VAR_2)
{
#ifdef VAR_3
HANDLE VAR_4;
if (LogonUser(VAR_0, ""."", VAR_1, VAR_5, VAR_6, &VAR_4) == 0)
{
pcap_fmt_errmsg_for_win32_err(VAR_2, VAR_7,
GetLastError(), ""LogonUser() failed"");
return -1;
}
if (ImpersonateLoggedOnUser(VAR_4) == 0)
{
pcap_fmt_errmsg_for_win32_err(VAR_2, VAR_7,
GetLastError(), ""ImpersonateLoggedOnUser() failed"");
CloseHandle(VAR_4);
return -1;
}
CloseHandle(VAR_4);
return 0;
#else
struct passwd *VAR_8;
char *VAR_9;
#ifdef VAR_10
struct spwd *VAR_11;
#endif
char *VAR_12;
if ((VAR_8 = getpwnam(VAR_0)) == NULL)
{
pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
return -1;
}
#ifdef VAR_10
if ((VAR_11 = getspnam(VAR_0)) == NULL)
{
pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
return -1;
}
VAR_9 = VAR_11->sp_pwdp;
#else
VAR_9 = VAR_8->pw_passwd;
#endif
VAR_12 = crypt(VAR_1, VAR_9);
if (VAR_12 == NULL)
{
pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
return -1;
}
if (strcmp(VAR_9, VAR_12) != 0)
{
pcap_snprintf(VAR_2, VAR_7, ""Authentication failed: user name or password incorrect"");
return -1;
}
if (setuid(VAR_8->pw_uid))
{
pcap_fmt_errmsg_for_errno(VAR_2, VAR_7,
VAR_13, ""setuid"");
return -1;
}
return 0;
#endif
}",the-tcpdump-group/libpcap/484d60cbf7ca4ec758c3cbb8a82d68b244a78d58/daemon.c/vul/before/0.json,"static int
daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
	/*
	 * Warning: the user which launches the process must have the
	 * SE_TCB_NAME right.
	 * This corresponds to have the ""Act as part of the Operating System""
	 * turned on (administrative tools, local security settings, local
	 * policies, user right assignment)
	 * However, it seems to me that if you run it as a service, this
	 * right should be provided by default.
	 *
	 * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,
	 * which merely indicates that the user name or password is
	 * incorrect, not whether it's the user name or the password
	 * that's incorrect, so a client that's trying to brute-force
	 * accounts doesn't know whether it's the user name or the
	 * password that's incorrect, so it doesn't know whether to
	 * stop trying to log in with a given user name and move on
	 * to another user name.
	 */
	DWORD error;
	HANDLE Token;
	char errmsgbuf[PCAP_ERRBUF_SIZE];	// buffer for errors to log

	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		error = GetLastError();
		if (error != ERROR_LOGON_FAILURE)
		{
			// Some error other than an authentication error;
			// log it.
			pcap_fmt_errmsg_for_win32_err(errmsgbuf,
			    PCAP_ERRBUF_SIZE, error, ""LogonUser() failed"");
			rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
		}			    
		return -1;
	}

	// This call should change the current thread to the selected user.
	// I didn't test it.
	if (ImpersonateLoggedOnUser(Token) == 0)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		pcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
		CloseHandle(Token);
		return -1;
	}

	CloseHandle(Token);
	return 0;

#else
	/*
	 * See
	 *
	 *	http://www.unixpapa.com/incnote/passwd.html
	 *
	 * We use the Solaris/Linux shadow password authentication if
	 * we have getspnam(), otherwise we just do traditional
	 * authentication, which, on some platforms, might work, even
	 * with shadow passwords, if we're running as root.  Traditional
	 * authenticaion won't work if we're not running as root, as
	 * I think these days all UN*Xes either won't return the password
	 * at all with getpwnam() or will only do so if you're root.
	 *
	 * XXX - perhaps what we *should* be using is PAM, if we have
	 * it.  That might hide all the details of username/password
	 * authentication, whether it's done with a visible-to-root-
	 * only password database or some other authentication mechanism,
	 * behind its API.
	 */
	int error;
	struct passwd *user;
	char *user_password;
#ifdef HAVE_GETSPNAM
	struct spwd *usersp;
#endif
	char *crypt_password;

	// This call is needed to get the uid
	if ((user = getpwnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}

#ifdef HAVE_GETSPNAM
	// This call is needed to get the password; otherwise 'x' is returned
	if ((usersp = getspnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}
	user_password = usersp->sp_pwdp;
#else
	/*
	 * XXX - what about other platforms?
	 * The unixpapa.com page claims this Just Works on *BSD if you're
	 * running as root - it's from 2000, so it doesn't indicate whether
	 * macOS (which didn't come out until 2001, under the name Mac OS
	 * X) behaves like the *BSDs or not, and might also work on AIX.
	 * HP-UX does something else.
	 *
	 * Again, hopefully PAM hides all that.
	 */
	user_password = user->pw_passwd;
#endif

	//
	// The Single UNIX Specification says that if crypt() fails it
	// sets errno, but some implementatons that haven't been run
	// through the SUS test suite might not do so.
	//
	errno = 0;
	crypt_password = crypt(password, user_password);
	if (crypt_password == NULL)
	{
		error = errno;
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		if (error == 0)
		{
			// It didn't set errno.
			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed"");
		}
		else
		{
			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed: %s"",
			    strerror(error));
		}
		return -1;
	}
	if (strcmp(user_password, crypt_password) != 0)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}

	if (setuid(user->pw_uid))
	{
		error = errno;
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    error, ""setuid"");
		rpcapd_log(LOGPRIO_ERROR, ""setuid() failed: %s"",
		    strerror(error));
		return -1;
	}

/*	if (setgid(user->pw_gid))
	{
		error = errno;
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setgid"");
		rpcapd_log(LOGPRIO_ERROR, ""setgid() failed: %s"",
		    strerror(error));
		return -1;
	}
*/
	return 0;

#endif

}","static int
daemon_AuthUserPwd(char *VAR_0, char *VAR_1, char *VAR_2)
{
#ifdef VAR_3
	/* COMMENT_0 */
                                                              
                      
                                                                      
                                                                   
                                    
                                                                 
                                        
   
                                                                     
                                                            
                                                             
                                                              
                                                           
                                                            
                                                            
                         
    
	DWORD VAR_4;
	HANDLE VAR_5;
	char VAR_6[VAR_7];	/* COMMENT_18 */

	if (LogonUser(VAR_0, ""."", VAR_1, VAR_8, VAR_9, &VAR_5) == 0)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
		VAR_4 = GetLastError();
		if (VAR_4 != VAR_10)
		{
			/* COMMENT_19 */
			/* COMMENT_20 */
			pcap_fmt_errmsg_for_win32_err(VAR_6,
			    VAR_7, VAR_4, ""LogonUser() failed"");
			rpcapd_log(VAR_11, ""%s"", VAR_6);
		}			    
		return -1;
	}

	/* COMMENT_21 */
	/* COMMENT_22 */
	if (ImpersonateLoggedOnUser(VAR_5) == 0)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
		pcap_fmt_errmsg_for_win32_err(VAR_6, VAR_7,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		rpcapd_log(VAR_11, ""%s"", VAR_6);
		CloseHandle(VAR_5);
		return -1;
	}

	CloseHandle(VAR_5);
	return 0;

#else
	/* COMMENT_23 */
       
   
                                               
   
                                                              
                                                        
                                                              
                                                                 
                                                             
                                                                  
                                                             
   
                                                              
                                                             
                                                             
                                                                  
                   
    
	int VAR_4;
	struct passwd *VAR_12;
	char *VAR_13;
#ifdef VAR_14
	struct spwd *VAR_15;
#endif
	char *VAR_16;

	/* COMMENT_40 */
	if ((VAR_12 = getpwnam(VAR_0)) == NULL)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
		return -1;
	}

#ifdef VAR_14
	/* COMMENT_41 */
	if ((VAR_15 = getspnam(VAR_0)) == NULL)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
		return -1;
	}
	VAR_13 = VAR_15->sp_pwdp;
#else
	/* COMMENT_42 */
                                     
                                                                  
                                                                    
                                                                  
                                                                 
                              
   
                                        
    
	VAR_13 = VAR_12->pw_passwd;
#endif

	/* COMMENT_52 */
	/* COMMENT_53 */
	/* COMMENT_54 */
	/* COMMENT_55 */
	/* COMMENT_52 */
	VAR_17 = 0;
	VAR_16 = crypt(VAR_1, VAR_13);
	if (VAR_16 == NULL)
	{
		VAR_4 = VAR_17;
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
		if (VAR_4 == 0)
		{
			/* COMMENT_56 */
			rpcapd_log(VAR_11, ""crypt() failed"");
		}
		else
		{
			rpcapd_log(VAR_11, ""crypt() failed: %s"",
			    strerror(VAR_4));
		}
		return -1;
	}
	if (strcmp(VAR_13, VAR_16) != 0)
	{
		pcap_snprintf(VAR_2, VAR_7, ""Authentication failed"");
		return -1;
	}

	if (setuid(VAR_12->pw_uid))
	{
		VAR_4 = VAR_17;
		pcap_fmt_errmsg_for_errno(VAR_2, VAR_7,
		    VAR_4, ""setuid"");
		rpcapd_log(VAR_11, ""setuid() failed: %s"",
		    strerror(VAR_4));
		return -1;
	}

/* COMMENT_57 */
  
                
                                                     
                       
                                                  
                       
            
  
  
	return 0;

#endif

}",the-tcpdump-group/libpcap/484d60cbf7ca4ec758c3cbb8a82d68b244a78d58/daemon.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,11 +20,22 @@
 	 * stop trying to log in with a given user name and move on
 	 * to another user name.
 	 */
+	DWORD error;
 	HANDLE Token;
+	char errmsgbuf[PCAP_ERRBUF_SIZE];	// buffer for errors to log
+
 	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
 	{
-		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
-		    GetLastError(), ""LogonUser() failed"");
+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
+		error = GetLastError();
+		if (error != ERROR_LOGON_FAILURE)
+		{
+			// Some error other than an authentication error;
+			// log it.
+			pcap_fmt_errmsg_for_win32_err(errmsgbuf,
+			    PCAP_ERRBUF_SIZE, error, ""LogonUser() failed"");
+			rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
+		}			    
 		return -1;
 	}
 
@@ -32,8 +43,10 @@
 	// I didn't test it.
 	if (ImpersonateLoggedOnUser(Token) == 0)
 	{
-		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
+		pcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
+		rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
 		CloseHandle(Token);
 		return -1;
 	}
@@ -61,6 +74,7 @@
 	 * only password database or some other authentication mechanism,
 	 * behind its API.
 	 */
+	int error;
 	struct passwd *user;
 	char *user_password;
 #ifdef HAVE_GETSPNAM
@@ -71,7 +85,7 @@
 	// This call is needed to get the uid
 	if ((user = getpwnam(username)) == NULL)
 	{
-		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		return -1;
 	}
 
@@ -79,7 +93,7 @@
 	// This call is needed to get the password; otherwise 'x' is returned
 	if ((usersp = getspnam(username)) == NULL)
 	{
-		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		return -1;
 	}
 	user_password = usersp->sp_pwdp;
@@ -97,29 +111,52 @@
 	user_password = user->pw_passwd;
 #endif
 
+	//
+	// The Single UNIX Specification says that if crypt() fails it
+	// sets errno, but some implementatons that haven't been run
+	// through the SUS test suite might not do so.
+	//
+	errno = 0;
 	crypt_password = crypt(password, user_password);
 	if (crypt_password == NULL)
 	{
+		error = errno;
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
+		if (error == 0)
+		{
+			// It didn't set errno.
+			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed"");
+		}
+		else
+		{
+			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed: %s"",
+			    strerror(error));
+		}
 		return -1;
 	}
 	if (strcmp(user_password, crypt_password) != 0)
 	{
-		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		return -1;
 	}
 
 	if (setuid(user->pw_uid))
 	{
+		error = errno;
 		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
-		    errno, ""setuid"");
+		    error, ""setuid"");
+		rpcapd_log(LOGPRIO_ERROR, ""setuid() failed: %s"",
+		    strerror(error));
 		return -1;
 	}
 
 /*	if (setgid(user->pw_gid))
 	{
+		error = errno;
 		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 		    errno, ""setgid"");
+		rpcapd_log(LOGPRIO_ERROR, ""setgid() failed: %s"",
+		    strerror(error));
 		return -1;
 	}
 */","{'deleted_lines': ['\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,', '\t\t    GetLastError(), ""LogonUser() failed"");', '\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");', '\t\t    errno, ""setuid"");'], 'added_lines': ['\tDWORD error;', '\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to log', '', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");', '\t\terror = GetLastError();', '\t\tif (error != ERROR_LOGON_FAILURE)', '\t\t{', '\t\t\t// Some error other than an authentication error;', '\t\t\t// log it.', '\t\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf,', '\t\t\t    PCAP_ERRBUF_SIZE, error, ""LogonUser() failed"");', '\t\t\trpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);', '\t\t}\t\t\t    ', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");', '\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,', '\t\trpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);', '\tint error;', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");', '\t//', '\t// The Single UNIX Specification says that if crypt() fails it', ""\t// sets errno, but some implementatons that haven't been run"", '\t// through the SUS test suite might not do so.', '\t//', '\terrno = 0;', '\t\terror = errno;', '\t\tif (error == 0)', '\t\t{', ""\t\t\t// It didn't set errno."", '\t\t\trpcapd_log(LOGPRIO_ERROR, ""crypt() failed"");', '\t\t}', '\t\telse', '\t\t{', '\t\t\trpcapd_log(LOGPRIO_ERROR, ""crypt() failed: %s"",', '\t\t\t    strerror(error));', '\t\t}', '\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");', '\t\terror = errno;', '\t\t    error, ""setuid"");', '\t\trpcapd_log(LOGPRIO_ERROR, ""setuid() failed: %s"",', '\t\t    strerror(error));', '\t\terror = errno;', '\t\trpcapd_log(LOGPRIO_ERROR, ""setgid() failed: %s"",', '\t\t    strerror(error));']}",True,"rpcapd/daemon.c in libpcap before 1.9.1 on non-Windows platforms provides details about why authentication failed, which might make it easier for attackers to enumerate valid usernames.",5.3,MEDIUM,1,test,2018-08-06T02:42:34Z,2
CVE-2018-14522,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,aubio,src/io/source_wavread.c: also exit if samplerate is negative (closes #188),99c7aa2e3efec988a5f81018b48d9388ff24bba1,https://github.com/aubio/aubio/commit/99c7aa2e3efec988a5f81018b48d9388ff24bba1,src/io/source_wavread.c,new_aubio_source_wavread,"aubio_source_wavread_t * new_aubio_source_wavread(const char_t * path, uint_t samplerate, uint_t hop_size) {
aubio_source_wavread_t * s = AUBIO_NEW(aubio_source_wavread_t);
size_t bytes_read = 0, bytes_junk = 0, bytes_expected = 44;
unsigned char buf[5] = ""\0"";
unsigned int format, channels, sr, byterate, blockalign, duration, bitspersample;
if (path == NULL) {
AUBIO_ERR(""source_wavread: Aborted opening null path\n"");
goto beach;
}
if ((sint_t)samplerate < 0) {
AUBIO_ERR(""source_wavread: Can not open %s with samplerate %d\n"", path, samplerate);
goto beach;
}
if ((sint_t)hop_size <= 0) {
AUBIO_ERR(""source_wavread: Can not open %s with hop_size %d\n"", path, hop_size);
goto beach;
}
if (s->path) AUBIO_FREE(s->path);
s->path = AUBIO_ARRAY(char_t, strnlen(path, PATH_MAX) + 1);
strncpy(s->path, path, strnlen(path, PATH_MAX) + 1);
s->samplerate = samplerate;
s->hop_size = hop_size;
s->fid = fopen((const char *)path, ""rb"");
if (!s->fid) {
AUBIO_ERR(""source_wavread: Failed opening %s (System error: %s)\n"", s->path, strerror(errno));
goto beach;
}
bytes_read += fread(buf, 1, 4, s->fid);
buf[4] = '\0';
if ( strcmp((const char *)buf, ""RIFF"") != 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (could not find RIFF header)\n"", s->path);
goto beach;
}
bytes_read += fread(buf, 1, 4, s->fid);
bytes_read += fread(buf, 1, 4, s->fid);
buf[4] = '\0';
if ( strcmp((const char *)buf, ""WAVE"") != 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (wrong format in RIFF header)\n"", s->path);
goto beach;
}
bytes_read += fread(buf, 1, 4, s->fid);
buf[4] = '\0';
if ( strcmp((const char *)buf, ""JUNK"") == 0 ) {
bytes_junk = fread(buf, 1, 4, s->fid);
buf[4] = '\0';
bytes_junk += read_little_endian(buf, 4);
if (fseek(s->fid, bytes_read + bytes_junk, SEEK_SET) != 0) {
AUBIO_ERR(""source_wavread: Failed opening %s (could not seek past JUNK Chunk: %s)\n"",
s->path, strerror(errno));
goto beach;
}
bytes_read += bytes_junk;
bytes_expected += bytes_junk + 4;
bytes_read += fread(buf, 1, 4, s->fid);
buf[4] = '\0';
}
if ( strcmp((const char *)buf, ""fmt "") != 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (could not find 'fmt ' in RIFF header)\n"", s->path);
goto beach;
}
bytes_read += fread(buf, 1, 4, s->fid);
format = read_little_endian(buf, 4);
if ( format != 16 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (not encoded with PCM)\n"", s->path);
goto beach;
}
if ( buf[1] || buf[2] | buf[3] ) {
AUBIO_ERR(""source_wavread: Failed opening %s (Subchunk1Size should be 0)\n"", s->path);
goto beach;
}
bytes_read += fread(buf, 1, 2, s->fid);
if ( buf[0] != 1 || buf[1] != 0) {
AUBIO_ERR(""source_wavread: Failed opening %s (AudioFormat should be PCM)\n"", s->path);
goto beach;
}
bytes_read += fread(buf, 1, 2, s->fid);
channels = read_little_endian(buf, 2);
bytes_read += fread(buf, 1, 4, s->fid);
sr = read_little_endian(buf, 4);
bytes_read += fread(buf, 1, 4, s->fid);
byterate = read_little_endian(buf, 4);
bytes_read += fread(buf, 1, 2, s->fid);
blockalign = read_little_endian(buf, 2);
bytes_read += fread(buf, 1, 2, s->fid);
bitspersample = read_little_endian(buf, 2);
if ( channels == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (number of channels can not be 0)\n"", s->path);
goto beach;
}
if ( sr == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be 0)\n"", s->path);
goto beach;
}
if ( byterate == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (byterate can not be 0)\n"", s->path);
goto beach;
}
if ( bitspersample == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (bitspersample can not be 0)\n"", s->path);
goto beach;
}
#if 0
if ( bitspersample != 16 ) {
AUBIO_ERR(""source_wavread: can not process %dbit file %s\n"",
bitspersample, s->path);
goto beach;
}
#endif
if ( byterate * 8 != sr * channels * bitspersample ) {
AUBIO_ERR(""source_wavread: Failed opening %s (wrong byterate)\n"", s->path);
goto beach;
}
if ( blockalign * 8 != channels * bitspersample ) {
AUBIO_ERR(""source_wavread: Failed opening %s (wrong blockalign)\n"", s->path);
goto beach;
}
s->input_samplerate = sr;
s->input_channels = channels;
#if 0
AUBIO_DBG(""channels %d\n"", channels);
AUBIO_DBG(""sr %d\n"", sr);
AUBIO_DBG(""byterate %d\n"", byterate);
AUBIO_DBG(""blockalign %d\n"", blockalign);
AUBIO_DBG(""bitspersample %d\n"", bitspersample);
AUBIO_DBG(""found %d channels in %s\n"", s->input_channels, s->path);
AUBIO_DBG(""found %d samplerate in %s\n"", s->input_samplerate, s->path);
#endif
if (samplerate == 0) {
s->samplerate = s->input_samplerate;
} else if (samplerate != s->input_samplerate) {
AUBIO_ERR(""source_wavread: can not resample %s from %d to %dHz\n"",
s->path, s->input_samplerate, samplerate);
goto beach;
}
bytes_read += fread(buf, 1, 4, s->fid);
buf[4] = '\0';
while ( strcmp((const char *)buf, ""data"") != 0 ) {
if (feof(s->fid) || ferror(s->fid)) {
AUBIO_ERR(""source_wavread: no data RIFF header found in %s\n"", s->path);
goto beach;
}
bytes_junk = fread(buf, 1, 4, s->fid);
buf[4] = '\0';
bytes_junk += read_little_endian(buf, 4);
if (fseek(s->fid, bytes_read + bytes_junk, SEEK_SET) != 0) {
AUBIO_ERR(""source_wavread: could not seek past unknown chunk in %s (%s)\n"",
s->path, strerror(errno));
goto beach;
}
bytes_read += bytes_junk;
bytes_expected += bytes_junk+ 4;
bytes_read += fread(buf, 1, 4, s->fid);
buf[4] = '\0';
}
bytes_read += fread(buf, 1, 4, s->fid);
duration = read_little_endian(buf, 4) / blockalign;
if ( bytes_read != bytes_expected ) {
#ifndef HAVE_WIN_HACKS
AUBIO_ERR(""source_wavread: short read (%zd instead of %zd) in %s\n"",
bytes_read, bytes_expected, s->path);
#else     AUBIO_ERR(""source_wavread: short read (%d instead of %d) in %s\n"",
(int)bytes_read, (int)bytes_expected, s->path);
#endif
goto beach;
}
s->seek_start = bytes_read;
s->output = new_fmat(s->input_channels, AUBIO_WAVREAD_BUFSIZE);
s->blockalign= blockalign;
s->bitspersample = bitspersample;
s->duration = duration;
s->short_output = (unsigned char *)calloc(s->blockalign, AUBIO_WAVREAD_BUFSIZE);
s->read_index = 0;
s->read_samples = 0;
s->eof = 0;
return s;
beach:
del_aubio_source_wavread(s);
return NULL;
}","aubio_source_wavread_t * new_aubio_source_wavread(const char_t * VAR_0, uint_t VAR_1, uint_t VAR_2) {
aubio_source_wavread_t * VAR_3 = AUBIO_NEW(aubio_source_wavread_t);
size_t VAR_4 = 0, VAR_5 = 0, VAR_6 = 44;
unsigned char VAR_7[5] = ""\0"";
unsigned int VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
if (VAR_0 == NULL) {
AUBIO_ERR(""source_wavread: Aborted opening null path\n"");
goto beach;
}
if ((sint_t)VAR_1 < 0) {
AUBIO_ERR(""source_wavread: Can not open %s with samplerate %d\n"", VAR_0, VAR_1);
goto beach;
}
if ((sint_t)VAR_2 <= 0) {
AUBIO_ERR(""source_wavread: Can not open %s with hop_size %d\n"", VAR_0, VAR_2);
goto beach;
}
if (VAR_3->path) AUBIO_FREE(VAR_3->path);
VAR_3->path = AUBIO_ARRAY(char_t, strnlen(VAR_0, VAR_15) + 1);
strncpy(VAR_3->path, VAR_0, strnlen(VAR_0, VAR_15) + 1);
VAR_3->samplerate = VAR_1;
VAR_3->hop_size = VAR_2;
VAR_3->fid = fopen((const char *)VAR_0, ""rb"");
if (!VAR_3->fid) {
AUBIO_ERR(""source_wavread: Failed opening %s (System error: %s)\n"", VAR_3->path, strerror(VAR_16));
goto beach;
}
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
if ( strcmp((const char *)VAR_7, ""RIFF"") != 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (could not find RIFF header)\n"", VAR_3->path);
goto beach;
}
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
if ( strcmp((const char *)VAR_7, ""WAVE"") != 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (wrong format in RIFF header)\n"", VAR_3->path);
goto beach;
}
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
if ( strcmp((const char *)VAR_7, ""JUNK"") == 0 ) {
VAR_5 = fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
VAR_5 += read_little_endian(VAR_7, 4);
if (fseek(VAR_3->fid, VAR_4 + VAR_5, VAR_17) != 0) {
AUBIO_ERR(""source_wavread: Failed opening %s (could not seek past JUNK Chunk: %s)\n"",
VAR_3->path, strerror(VAR_16));
goto beach;
}
VAR_4 += VAR_5;
VAR_6 += VAR_5 + 4;
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
}
if ( strcmp((const char *)VAR_7, ""fmt "") != 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (could not find 'fmt ' in RIFF header)\n"", VAR_3->path);
goto beach;
}
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_8 = read_little_endian(VAR_7, 4);
if ( VAR_8 != 16 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (not encoded with PCM)\n"", VAR_3->path);
goto beach;
}
if ( VAR_7[1] || VAR_7[2] | VAR_7[3] ) {
AUBIO_ERR(""source_wavread: Failed opening %s (Subchunk1Size should be 0)\n"", VAR_3->path);
goto beach;
}
VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
if ( VAR_7[0] != 1 || VAR_7[1] != 0) {
AUBIO_ERR(""source_wavread: Failed opening %s (AudioFormat should be PCM)\n"", VAR_3->path);
goto beach;
}
VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
VAR_9 = read_little_endian(VAR_7, 2);
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_10 = read_little_endian(VAR_7, 4);
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_11 = read_little_endian(VAR_7, 4);
VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
VAR_12 = read_little_endian(VAR_7, 2);
VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
VAR_14 = read_little_endian(VAR_7, 2);
if ( VAR_9 == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (number of channels can not be 0)\n"", VAR_3->path);
goto beach;
}
if ( VAR_10 == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be 0)\n"", VAR_3->path);
goto beach;
}
if ( VAR_11 == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (byterate can not be 0)\n"", VAR_3->path);
goto beach;
}
if ( VAR_14 == 0 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (bitspersample can not be 0)\n"", VAR_3->path);
goto beach;
}
#if 0
if ( VAR_14 != 16 ) {
AUBIO_ERR(""source_wavread: can not process %dbit file %s\n"",
VAR_14, VAR_3->path);
goto beach;
}
#endif
if ( VAR_11 * 8 != VAR_10 * VAR_9 * VAR_14 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (wrong byterate)\n"", VAR_3->path);
goto beach;
}
if ( VAR_12 * 8 != VAR_9 * VAR_14 ) {
AUBIO_ERR(""source_wavread: Failed opening %s (wrong blockalign)\n"", VAR_3->path);
goto beach;
}
VAR_3->input_samplerate = VAR_10;
VAR_3->input_channels = VAR_9;
#if 0
AUBIO_DBG(""channels %d\n"", VAR_9);
AUBIO_DBG(""sr %d\n"", VAR_10);
AUBIO_DBG(""byterate %d\n"", VAR_11);
AUBIO_DBG(""blockalign %d\n"", VAR_12);
AUBIO_DBG(""bitspersample %d\n"", VAR_14);
AUBIO_DBG(""found %d channels in %s\n"", VAR_3->input_channels, VAR_3->path);
AUBIO_DBG(""found %d samplerate in %s\n"", VAR_3->input_samplerate, VAR_3->path);
#endif
if (VAR_1 == 0) {
VAR_3->samplerate = VAR_3->input_samplerate;
} else if (VAR_1 != VAR_3->input_samplerate) {
AUBIO_ERR(""source_wavread: can not resample %s from %d to %dHz\n"",
VAR_3->path, VAR_3->input_samplerate, VAR_1);
goto beach;
}
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
while ( strcmp((const char *)VAR_7, ""data"") != 0 ) {
if (feof(VAR_3->fid) || ferror(VAR_3->fid)) {
AUBIO_ERR(""source_wavread: no data RIFF header found in %s\n"", VAR_3->path);
goto beach;
}
VAR_5 = fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
VAR_5 += read_little_endian(VAR_7, 4);
if (fseek(VAR_3->fid, VAR_4 + VAR_5, VAR_17) != 0) {
AUBIO_ERR(""source_wavread: could not seek past unknown chunk in %s (%s)\n"",
VAR_3->path, strerror(VAR_16));
goto beach;
}
VAR_4 += VAR_5;
VAR_6 += VAR_5+ 4;
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_7[4] = '\0';
}
VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
VAR_13 = read_little_endian(VAR_7, 4) / VAR_12;
if ( VAR_4 != VAR_6 ) {
#ifndef VAR_18
AUBIO_ERR(""source_wavread: short read (%zd instead of %zd) in %s\n"",
VAR_4, VAR_6, VAR_3->path);
#else 
AUBIO_ERR(""source_wavread: short read (%d instead of %d) in %s\n"",
(int)VAR_4, (int)VAR_6, VAR_3->path);
#endif
goto beach;
}
VAR_3->seek_start = VAR_4;
VAR_3->output = new_fmat(VAR_3->input_channels, VAR_19);
VAR_3->blockalign= VAR_12;
VAR_3->bitspersample = VAR_14;
VAR_3->duration = VAR_13;
VAR_3->short_output = (unsigned char *)calloc(VAR_3->blockalign, VAR_19);
VAR_3->read_index = 0;
VAR_3->read_samples = 0;
VAR_3->eof = 0;
return VAR_3;
beach:
del_aubio_source_wavread(VAR_3);
return NULL;
}",aubio/99c7aa2e3efec988a5f81018b48d9388ff24bba1/source_wavread.c/vul/before/0.json,"aubio_source_wavread_t * new_aubio_source_wavread(const char_t * path, uint_t samplerate, uint_t hop_size) {
  aubio_source_wavread_t * s = AUBIO_NEW(aubio_source_wavread_t);
  size_t bytes_read = 0, bytes_junk = 0, bytes_expected = 44;
  unsigned char buf[5] = ""\0"";
  unsigned int format, channels, sr, byterate, blockalign, duration, bitspersample;//, data_size;

  if (path == NULL) {
    AUBIO_ERR(""source_wavread: Aborted opening null path\n"");
    goto beach;
  }
  if ((sint_t)samplerate < 0) {
    AUBIO_ERR(""source_wavread: Can not open %s with samplerate %d\n"", path, samplerate);
    goto beach;
  }
  if ((sint_t)hop_size <= 0) {
    AUBIO_ERR(""source_wavread: Can not open %s with hop_size %d\n"", path, hop_size);
    goto beach;
  }

  if (s->path) AUBIO_FREE(s->path);
  s->path = AUBIO_ARRAY(char_t, strnlen(path, PATH_MAX) + 1);
  strncpy(s->path, path, strnlen(path, PATH_MAX) + 1);

  s->samplerate = samplerate;
  s->hop_size = hop_size;

  s->fid = fopen((const char *)path, ""rb"");
  if (!s->fid) {
    AUBIO_ERR(""source_wavread: Failed opening %s (System error: %s)\n"", s->path, strerror(errno));
    goto beach;
  }

  // ChunkID
  bytes_read += fread(buf, 1, 4, s->fid);
  buf[4] = '\0';
  if ( strcmp((const char *)buf, ""RIFF"") != 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (could not find RIFF header)\n"", s->path);
    goto beach;
  }

  // ChunkSize
  bytes_read += fread(buf, 1, 4, s->fid);

  // Format
  bytes_read += fread(buf, 1, 4, s->fid);
  buf[4] = '\0';
  if ( strcmp((const char *)buf, ""WAVE"") != 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (wrong format in RIFF header)\n"", s->path);
    goto beach;
  }

  // Subchunk1ID
  bytes_read += fread(buf, 1, 4, s->fid);
  buf[4] = '\0';

  // check if we have a JUNK Chunk
  if ( strcmp((const char *)buf, ""JUNK"") == 0 ) {
    bytes_junk = fread(buf, 1, 4, s->fid);
    buf[4] = '\0';
    bytes_junk += read_little_endian(buf, 4);
    if (fseek(s->fid, bytes_read + bytes_junk, SEEK_SET) != 0) {
      AUBIO_ERR(""source_wavread: Failed opening %s (could not seek past JUNK Chunk: %s)\n"",
          s->path, strerror(errno));
      goto beach;
    }
    bytes_read += bytes_junk;
    bytes_expected += bytes_junk + 4;
    // now really read the fmt chunk
    bytes_read += fread(buf, 1, 4, s->fid);
    buf[4] = '\0';
  }

  // get the fmt chunk
  if ( strcmp((const char *)buf, ""fmt "") != 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (could not find 'fmt ' in RIFF header)\n"", s->path);
    goto beach;
  }

  // Subchunk1Size
  bytes_read += fread(buf, 1, 4, s->fid);
  format = read_little_endian(buf, 4);
  if ( format != 16 ) {
    // TODO accept format 18
    AUBIO_ERR(""source_wavread: Failed opening %s (not encoded with PCM)\n"", s->path);
    goto beach;
  }
  if ( buf[1] || buf[2] | buf[3] ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (Subchunk1Size should be 0)\n"", s->path);
    goto beach;
  }

  // AudioFormat
  bytes_read += fread(buf, 1, 2, s->fid);
  if ( buf[0] != 1 || buf[1] != 0) {
    AUBIO_ERR(""source_wavread: Failed opening %s (AudioFormat should be PCM)\n"", s->path);
    goto beach;
  }

  // NumChannels
  bytes_read += fread(buf, 1, 2, s->fid);
  channels = read_little_endian(buf, 2);

  // SampleRate
  bytes_read += fread(buf, 1, 4, s->fid);
  sr = read_little_endian(buf, 4);

  // ByteRate
  bytes_read += fread(buf, 1, 4, s->fid);
  byterate = read_little_endian(buf, 4);

  // BlockAlign
  bytes_read += fread(buf, 1, 2, s->fid);
  blockalign = read_little_endian(buf, 2);

  // BitsPerSample
  bytes_read += fread(buf, 1, 2, s->fid);
  bitspersample = read_little_endian(buf, 2);

  if ( channels == 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (number of channels can not be 0)\n"", s->path);
    goto beach;
  }

  if ( (sint_t)sr <= 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be <= 0)\n"", s->path);
    goto beach;
  }

  if ( byterate == 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (byterate can not be 0)\n"", s->path);
    goto beach;
  }

  if ( bitspersample == 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (bitspersample can not be 0)\n"", s->path);
    goto beach;
  }
#if 0
  if ( bitspersample != 16 ) {
    AUBIO_ERR(""source_wavread: can not process %dbit file %s\n"",
        bitspersample, s->path);
    goto beach;
  }
#endif

  if ( byterate * 8 != sr * channels * bitspersample ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (wrong byterate)\n"", s->path);
    goto beach;
  }

  if ( blockalign * 8 != channels * bitspersample ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (wrong blockalign)\n"", s->path);
    goto beach;
  }

  s->input_samplerate = sr;
  s->input_channels = channels;

#if 0
  AUBIO_DBG(""channels %d\n"", channels);
  AUBIO_DBG(""sr %d\n"", sr);
  AUBIO_DBG(""byterate %d\n"", byterate);
  AUBIO_DBG(""blockalign %d\n"", blockalign);
  AUBIO_DBG(""bitspersample %d\n"", bitspersample);

  AUBIO_DBG(""found %d channels in %s\n"", s->input_channels, s->path);
  AUBIO_DBG(""found %d samplerate in %s\n"", s->input_samplerate, s->path);
#endif

  if (samplerate == 0) {
    s->samplerate = s->input_samplerate;
  } else if (samplerate != s->input_samplerate) {
    AUBIO_ERR(""source_wavread: can not resample %s from %d to %dHz\n"",
        s->path, s->input_samplerate, samplerate);
    goto beach;
  }

  // Subchunk2ID
  bytes_read += fread(buf, 1, 4, s->fid);
  buf[4] = '\0';
  while ( strcmp((const char *)buf, ""data"") != 0 ) {
    if (feof(s->fid) || ferror(s->fid)) {
      AUBIO_ERR(""source_wavread: no data RIFF header found in %s\n"", s->path);
      goto beach;
    }
    bytes_junk = fread(buf, 1, 4, s->fid);
    buf[4] = '\0';
    bytes_junk += read_little_endian(buf, 4);
    if (fseek(s->fid, bytes_read + bytes_junk, SEEK_SET) != 0) {
      AUBIO_ERR(""source_wavread: could not seek past unknown chunk in %s (%s)\n"",
          s->path, strerror(errno));
      goto beach;
    }
    bytes_read += bytes_junk;
    bytes_expected += bytes_junk+ 4;
    bytes_read += fread(buf, 1, 4, s->fid);
    buf[4] = '\0';
  }

  // Subchunk2Size
  bytes_read += fread(buf, 1, 4, s->fid);
  duration = read_little_endian(buf, 4) / blockalign;

  //data_size = buf[0] + (buf[1] << 8) + (buf[2] << 16) + (buf[3] << 24);
  //AUBIO_MSG(""found %d frames in %s\n"", 8 * data_size / bitspersample / channels, s->path);

  // check the total number of bytes read is correct
  if ( bytes_read != bytes_expected ) {
#ifndef HAVE_WIN_HACKS
    AUBIO_ERR(""source_wavread: short read (%zd instead of %zd) in %s\n"",
        bytes_read, bytes_expected, s->path);
#else // mingw does not know about %zd...
    AUBIO_ERR(""source_wavread: short read (%d instead of %d) in %s\n"",
        (int)bytes_read, (int)bytes_expected, s->path);
#endif
    goto beach;
  }
  s->seek_start = bytes_read;

  s->output = new_fmat(s->input_channels, AUBIO_WAVREAD_BUFSIZE);
  s->blockalign= blockalign;
  s->bitspersample = bitspersample;

  s->duration = duration;

  s->short_output = (unsigned char *)calloc(s->blockalign, AUBIO_WAVREAD_BUFSIZE);
  s->read_index = 0;
  s->read_samples = 0;
  s->eof = 0;

  return s;

beach:
  //AUBIO_ERR(""source_wavread: can not read %s at samplerate %dHz with a hop_size of %d\n"",
  //    s->path, s->samplerate, s->hop_size);
  del_aubio_source_wavread(s);
  return NULL;
}","aubio_source_wavread_t * new_aubio_source_wavread(const char_t * VAR_0, uint_t VAR_1, uint_t VAR_2) {
  aubio_source_wavread_t * VAR_3 = AUBIO_NEW(aubio_source_wavread_t);
  size_t VAR_4 = 0, VAR_5 = 0, VAR_6 = 44;
  unsigned char VAR_7[5] = ""\0"";
  unsigned int VAR_8, VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;/* COMMENT_0 */

  if (VAR_0 == NULL) {
    AUBIO_ERR(""source_wavread: Aborted opening null path\n"");
    goto beach;
  }
  if ((sint_t)VAR_1 < 0) {
    AUBIO_ERR(""source_wavread: Can not open %s with samplerate %d\n"", VAR_0, VAR_1);
    goto beach;
  }
  if ((sint_t)VAR_2 <= 0) {
    AUBIO_ERR(""source_wavread: Can not open %s with hop_size %d\n"", VAR_0, VAR_2);
    goto beach;
  }

  if (VAR_3->path) AUBIO_FREE(VAR_3->path);
  VAR_3->path = AUBIO_ARRAY(char_t, strnlen(VAR_0, VAR_15) + 1);
  strncpy(VAR_3->path, VAR_0, strnlen(VAR_0, VAR_15) + 1);

  VAR_3->samplerate = VAR_1;
  VAR_3->hop_size = VAR_2;

  VAR_3->fid = fopen((const char *)VAR_0, ""rb"");
  if (!VAR_3->fid) {
    AUBIO_ERR(""source_wavread: Failed opening %s (System error: %s)\n"", VAR_3->path, strerror(VAR_16));
    goto beach;
  }

  /* COMMENT_1 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_7[4] = '\0';
  if ( strcmp((const char *)VAR_7, ""RIFF"") != 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (could not find RIFF header)\n"", VAR_3->path);
    goto beach;
  }

  /* COMMENT_2 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);

  /* COMMENT_3 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_7[4] = '\0';
  if ( strcmp((const char *)VAR_7, ""WAVE"") != 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (wrong format in RIFF header)\n"", VAR_3->path);
    goto beach;
  }

  /* COMMENT_4 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_7[4] = '\0';

  /* COMMENT_5 */
  if ( strcmp((const char *)VAR_7, ""JUNK"") == 0 ) {
    VAR_5 = fread(VAR_7, 1, 4, VAR_3->fid);
    VAR_7[4] = '\0';
    VAR_5 += read_little_endian(VAR_7, 4);
    if (fseek(VAR_3->fid, VAR_4 + VAR_5, VAR_17) != 0) {
      AUBIO_ERR(""source_wavread: Failed opening %s (could not seek past JUNK Chunk: %s)\n"",
          VAR_3->path, strerror(VAR_16));
      goto beach;
    }
    VAR_4 += VAR_5;
    VAR_6 += VAR_5 + 4;
    /* COMMENT_6 */
    VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
    VAR_7[4] = '\0';
  }

  /* COMMENT_7 */
  if ( strcmp((const char *)VAR_7, ""fmt "") != 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (could not find 'fmt ' in RIFF header)\n"", VAR_3->path);
    goto beach;
  }

  /* COMMENT_8 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_8 = read_little_endian(VAR_7, 4);
  if ( VAR_8 != 16 ) {
    /* COMMENT_9 */
    AUBIO_ERR(""source_wavread: Failed opening %s (not encoded with PCM)\n"", VAR_3->path);
    goto beach;
  }
  if ( VAR_7[1] || VAR_7[2] | VAR_7[3] ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (Subchunk1Size should be 0)\n"", VAR_3->path);
    goto beach;
  }

  /* COMMENT_10 */
  VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
  if ( VAR_7[0] != 1 || VAR_7[1] != 0) {
    AUBIO_ERR(""source_wavread: Failed opening %s (AudioFormat should be PCM)\n"", VAR_3->path);
    goto beach;
  }

  /* COMMENT_11 */
  VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
  VAR_9 = read_little_endian(VAR_7, 2);

  /* COMMENT_12 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_10 = read_little_endian(VAR_7, 4);

  /* COMMENT_13 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_11 = read_little_endian(VAR_7, 4);

  /* COMMENT_14 */
  VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
  VAR_12 = read_little_endian(VAR_7, 2);

  /* COMMENT_15 */
  VAR_4 += fread(VAR_7, 1, 2, VAR_3->fid);
  VAR_14 = read_little_endian(VAR_7, 2);

  if ( VAR_9 == 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (number of channels can not be 0)\n"", VAR_3->path);
    goto beach;
  }

  if ( (sint_t)VAR_10 <= 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be <= 0)\n"", VAR_3->path);
    goto beach;
  }

  if ( VAR_11 == 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (byterate can not be 0)\n"", VAR_3->path);
    goto beach;
  }

  if ( VAR_14 == 0 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (bitspersample can not be 0)\n"", VAR_3->path);
    goto beach;
  }
#if 0
  if ( VAR_14 != 16 ) {
    AUBIO_ERR(""source_wavread: can not process %dbit file %s\n"",
        VAR_14, VAR_3->path);
    goto beach;
  }
#endif

  if ( VAR_11 * 8 != VAR_10 * VAR_9 * VAR_14 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (wrong byterate)\n"", VAR_3->path);
    goto beach;
  }

  if ( VAR_12 * 8 != VAR_9 * VAR_14 ) {
    AUBIO_ERR(""source_wavread: Failed opening %s (wrong blockalign)\n"", VAR_3->path);
    goto beach;
  }

  VAR_3->input_samplerate = VAR_10;
  VAR_3->input_channels = VAR_9;

#if 0
  AUBIO_DBG(""channels %d\n"", VAR_9);
  AUBIO_DBG(""sr %d\n"", VAR_10);
  AUBIO_DBG(""byterate %d\n"", VAR_11);
  AUBIO_DBG(""blockalign %d\n"", VAR_12);
  AUBIO_DBG(""bitspersample %d\n"", VAR_14);

  AUBIO_DBG(""found %d channels in %s\n"", VAR_3->input_channels, VAR_3->path);
  AUBIO_DBG(""found %d samplerate in %s\n"", VAR_3->input_samplerate, VAR_3->path);
#endif

  if (VAR_1 == 0) {
    VAR_3->samplerate = VAR_3->input_samplerate;
  } else if (VAR_1 != VAR_3->input_samplerate) {
    AUBIO_ERR(""source_wavread: can not resample %s from %d to %dHz\n"",
        VAR_3->path, VAR_3->input_samplerate, VAR_1);
    goto beach;
  }

  /* COMMENT_16 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_7[4] = '\0';
  while ( strcmp((const char *)VAR_7, ""data"") != 0 ) {
    if (feof(VAR_3->fid) || ferror(VAR_3->fid)) {
      AUBIO_ERR(""source_wavread: no data RIFF header found in %s\n"", VAR_3->path);
      goto beach;
    }
    VAR_5 = fread(VAR_7, 1, 4, VAR_3->fid);
    VAR_7[4] = '\0';
    VAR_5 += read_little_endian(VAR_7, 4);
    if (fseek(VAR_3->fid, VAR_4 + VAR_5, VAR_17) != 0) {
      AUBIO_ERR(""source_wavread: could not seek past unknown chunk in %s (%s)\n"",
          VAR_3->path, strerror(VAR_16));
      goto beach;
    }
    VAR_4 += VAR_5;
    VAR_6 += VAR_5+ 4;
    VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
    VAR_7[4] = '\0';
  }

  /* COMMENT_17 */
  VAR_4 += fread(VAR_7, 1, 4, VAR_3->fid);
  VAR_13 = read_little_endian(VAR_7, 4) / VAR_12;

  /* COMMENT_18 */
  /* COMMENT_19 */

  /* COMMENT_20 */
  if ( VAR_4 != VAR_6 ) {
#ifndef VAR_18
    AUBIO_ERR(""source_wavread: short read (%zd instead of %zd) in %s\n"",
        VAR_4, VAR_6, VAR_3->path);
#else /* COMMENT_21 */
    AUBIO_ERR(""source_wavread: short read (%d instead of %d) in %s\n"",
        (int)VAR_4, (int)VAR_6, VAR_3->path);
#endif
    goto beach;
  }
  VAR_3->seek_start = VAR_4;

  VAR_3->output = new_fmat(VAR_3->input_channels, VAR_19);
  VAR_3->blockalign= VAR_12;
  VAR_3->bitspersample = VAR_14;

  VAR_3->duration = VAR_13;

  VAR_3->short_output = (unsigned char *)calloc(VAR_3->blockalign, VAR_19);
  VAR_3->read_index = 0;
  VAR_3->read_samples = 0;
  VAR_3->eof = 0;

  return VAR_3;

beach:
  /* COMMENT_22 */
  /* COMMENT_23 */
  del_aubio_source_wavread(VAR_3);
  return NULL;
}",aubio/99c7aa2e3efec988a5f81018b48d9388ff24bba1/source_wavread.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -121,8 +121,8 @@
     goto beach;
   }
 
-  if ( sr == 0 ) {
-    AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be 0)\n"", s->path);
+  if ( (sint_t)sr <= 0 ) {
+    AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be <= 0)\n"", s->path);
     goto beach;
   }
 ","{'deleted_lines': ['  if ( sr == 0 ) {', '    AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be 0)\\n"", s->path);'], 'added_lines': ['  if ( (sint_t)sr <= 0 ) {', '    AUBIO_ERR(""source_wavread: Failed opening %s (samplerate can not be <= 0)\\n"", s->path);']}",True,"An issue was discovered in aubio 0.4.6. A SEGV signal can occur in aubio_pitch_set_unit in pitch/pitch.c, as demonstrated by aubionotes.",8.8,HIGH,2,test,2018-08-06T12:04:48Z,2
CVE-2018-20855,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0.0,torvalds/linux,"IB/mlx5: Fix leaking stack memory to userspace

mlx5_ib_create_qp_resp was never initialized and only the first 4 bytes
were written.

Fixes: 41d902cb7c32 (""RDMA/mlx5: Fix definition of mlx5_ib_create_qp_resp"")
Cc: <stable@vger.kernel.org>
Acked-by: Leon Romanovsky <leonro@mellanox.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>",0625b4ba1a5d4703c7fb01c497bd6c156908af00,https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00,drivers/infiniband/hw/mlx5/qp.c,create_qp_common,"static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,
struct ib_qp_init_attr *init_attr,
struct ib_udata *udata, struct mlx5_ib_qp *qp)
{
struct mlx5_ib_resources *devr = &dev->devr;
int inlen = MLX5_ST_SZ_BYTES(create_qp_in);
struct mlx5_core_dev *mdev = dev->mdev;
struct mlx5_ib_create_qp_resp resp;
struct mlx5_ib_cq *send_cq;
struct mlx5_ib_cq *recv_cq;
unsigned long flags;
u32 uidx = MLX5_IB_DEFAULT_UIDX;
struct mlx5_ib_create_qp ucmd;
struct mlx5_ib_qp_base *base;
int mlx5_st;
void *qpc;
u32 *in;
int err;
mutex_init(&qp->mutex);
spin_lock_init(&qp->sq.lock);
spin_lock_init(&qp->rq.lock);
mlx5_st = to_mlx5_st(init_attr->qp_type);
if (mlx5_st < 0)
return -EINVAL;
if (init_attr->rwq_ind_tbl) {
if (!udata)
return -ENOSYS;
err = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);
return err;
}
if (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {
if (!MLX5_CAP_GEN(mdev, block_lb_mc)) {
mlx5_ib_dbg(dev, ""block multicast loopback isn't supported\n"");
return -EINVAL;
} else {
qp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;
}
}
if (init_attr->create_flags &
(IB_QP_CREATE_CROSS_CHANNEL |
IB_QP_CREATE_MANAGED_SEND |
IB_QP_CREATE_MANAGED_RECV)) {
if (!MLX5_CAP_GEN(mdev, cd)) {
mlx5_ib_dbg(dev, ""cross-channel isn't supported\n"");
return -EINVAL;
}
if (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)
qp->flags |= MLX5_IB_QP_CROSS_CHANNEL;
if (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)
qp->flags |= MLX5_IB_QP_MANAGED_SEND;
if (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)
qp->flags |= MLX5_IB_QP_MANAGED_RECV;
}
if (init_attr->qp_type == IB_QPT_UD &&
(init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))
if (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {
mlx5_ib_dbg(dev, ""ipoib UD lso qp isn't supported\n"");
return -EOPNOTSUPP;
}
if (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {
if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
mlx5_ib_dbg(dev, ""Scatter FCS is supported only for Raw Packet QPs"");
return -EOPNOTSUPP;
}
if (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||
!MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {
mlx5_ib_dbg(dev, ""Scatter FCS isn't supported\n"");
return -EOPNOTSUPP;
}
qp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;
}
if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)
qp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;
if (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {
if (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&
MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||
(init_attr->qp_type != IB_QPT_RAW_PACKET))
return -EOPNOTSUPP;
qp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;
}
if (pd && pd->uobject) {
if (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {
mlx5_ib_dbg(dev, ""copy failed\n"");
return -EFAULT;
}
err = get_qp_user_index(to_mucontext(pd->uobject->context),
&ucmd, udata->inlen, &uidx);
if (err)
return err;
qp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);
qp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);
if (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {
if (init_attr->qp_type != IB_QPT_RAW_PACKET ||
!tunnel_offload_supported(mdev)) {
mlx5_ib_dbg(dev, ""Tunnel offload isn't supported\n"");
return -EOPNOTSUPP;
}
qp->tunnel_offload_en = true;
}
if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {
if (init_attr->qp_type != IB_QPT_UD ||
(MLX5_CAP_GEN(dev->mdev, port_type) !=
MLX5_CAP_PORT_TYPE_IB) ||
!mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {
mlx5_ib_dbg(dev, ""Source QP option isn't supported\n"");
return -EOPNOTSUPP;
}
qp->flags |= MLX5_IB_QP_UNDERLAY;
qp->underlay_qpn = init_attr->source_qpn;
}
} else {
qp->wq_sig = !!wq_signature;
}
base = (init_attr->qp_type == IB_QPT_RAW_PACKET ||
qp->flags & MLX5_IB_QP_UNDERLAY) ?
&qp->raw_packet_qp.rq.base :
&qp->trans_qp.base;
qp->has_rq = qp_has_rq(init_attr);
err = set_rq_size(dev, &init_attr->cap, qp->has_rq,
qp, (pd && pd->uobject) ? &ucmd : NULL);
if (err) {
mlx5_ib_dbg(dev, ""err %d\n"", err);
return err;
}
if (pd) {
if (pd->uobject) {
__u32 max_wqes =
1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);
mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d)\n"", ucmd.sq_wqe_count);
if (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||
ucmd.rq_wqe_count != qp->rq.wqe_cnt) {
mlx5_ib_dbg(dev, ""invalid rq params\n"");
return -EINVAL;
}
if (ucmd.sq_wqe_count > max_wqes) {
mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d) > max allowed (%d)\n"",
ucmd.sq_wqe_count, max_wqes);
return -EINVAL;
}
if (init_attr->create_flags &
mlx5_ib_create_qp_sqpn_qp1()) {
mlx5_ib_dbg(dev, ""user-space is not allowed to create UD QPs spoofing as QP1\n"");
return -EINVAL;
}
err = create_user_qp(dev, pd, qp, udata, init_attr, &in,
&resp, &inlen, base);
if (err)
mlx5_ib_dbg(dev, ""err %d\n"", err);
} else {
err = create_kernel_qp(dev, init_attr, qp, &in, &inlen,
base);
if (err)
mlx5_ib_dbg(dev, ""err %d\n"", err);
}
if (err)
return err;
} else {
in = kvzalloc(inlen, GFP_KERNEL);
if (!in)
return -ENOMEM;
qp->create_type = MLX5_QP_EMPTY;
}
if (is_sqp(init_attr->qp_type))
qp->port = init_attr->port_num;
qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);
MLX5_SET(qpc, qpc, st, mlx5_st);
MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);
if (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)
MLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);
else
MLX5_SET(qpc, qpc, latency_sensitive, 1);
if (qp->wq_sig)
MLX5_SET(qpc, qpc, wq_signature, 1);
if (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)
MLX5_SET(qpc, qpc, block_lb_mc, 1);
if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)
MLX5_SET(qpc, qpc, cd_master, 1);
if (qp->flags & MLX5_IB_QP_MANAGED_SEND)
MLX5_SET(qpc, qpc, cd_slave_send, 1);
if (qp->flags & MLX5_IB_QP_MANAGED_RECV)
MLX5_SET(qpc, qpc, cd_slave_receive, 1);
if (qp->scat_cqe && is_connected(init_attr->qp_type)) {
int rcqe_sz;
int scqe_sz;
rcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);
scqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);
if (rcqe_sz == 128)
MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);
else
MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);
if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {
if (scqe_sz == 128)
MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);
else
MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);
}
}
if (qp->rq.wqe_cnt) {
MLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);
MLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));
}
MLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));
if (qp->sq.wqe_cnt) {
MLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));
} else {
MLX5_SET(qpc, qpc, no_sq, 1);
if (init_attr->srq &&
init_attr->srq->srq_type == IB_SRQT_TM)
MLX5_SET(qpc, qpc, offload_type,
MLX5_QPC_OFFLOAD_TYPE_RNDV);
}
switch (init_attr->qp_type) {
case IB_QPT_XRC_TGT:
MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);
MLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);
MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);
MLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);
break;
case IB_QPT_XRC_INI:
MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);
MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);
MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);
break;
default:
if (init_attr->srq) {
MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);
MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);
} else {
MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);
MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);
}
}
if (init_attr->send_cq)
MLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);
if (init_attr->recv_cq)
MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);
MLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);
if (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)
MLX5_SET(qpc, qpc, user_index, uidx);
if (init_attr->qp_type == IB_QPT_UD &&
(init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {
MLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);
qp->flags |= MLX5_IB_QP_LSO;
}
if (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {
if (!MLX5_CAP_GEN(dev->mdev, end_pad)) {
mlx5_ib_dbg(dev, ""scatter end padding is not supported\n"");
err = -EOPNOTSUPP;
goto err;
} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
MLX5_SET(qpc, qpc, end_padding_mode,
MLX5_WQ_END_PAD_MODE_ALIGN);
} else {
qp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;
}
}
if (inlen < 0) {
err = -EINVAL;
goto err;
}
if (init_attr->qp_type == IB_QPT_RAW_PACKET ||
qp->flags & MLX5_IB_QP_UNDERLAY) {
qp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;
raw_packet_qp_copy_info(qp, &qp->raw_packet_qp);
err = create_raw_packet_qp(dev, qp, in, inlen, pd);
} else {
err = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);
}
if (err) {
mlx5_ib_dbg(dev, ""create qp failed\n"");
goto err_create;
}
kvfree(in);
base->container_mibqp = qp;
base->mqp.event = mlx5_ib_qp_event;
get_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,
&send_cq, &recv_cq);
spin_lock_irqsave(&dev->reset_flow_resource_lock, flags);
mlx5_ib_lock_cqs(send_cq, recv_cq);
list_add_tail(&qp->qps_list, &dev->qp_list);
if (send_cq)
list_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);
if (recv_cq)
list_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);
mlx5_ib_unlock_cqs(send_cq, recv_cq);
spin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);
return 0;
err_create:
if (qp->create_type == MLX5_QP_USER)
destroy_qp_user(dev, pd, qp, base);
else if (qp->create_type == MLX5_QP_KERNEL)
destroy_qp_kernel(dev, qp);
err:
kvfree(in);
return err;
}","static int create_qp_common(struct mlx5_ib_dev *VAR_0, struct ib_pd *VAR_1,
struct ib_qp_init_attr *VAR_2,
struct ib_udata *VAR_3, struct mlx5_ib_qp *VAR_4)
{
struct mlx5_ib_resources *VAR_5 = &VAR_0->devr;
int VAR_6 = MLX5_ST_SZ_BYTES(VAR_7);
struct mlx5_core_dev *VAR_8 = VAR_0->mdev;
struct mlx5_ib_create_qp_resp VAR_9;
struct mlx5_ib_cq *VAR_10;
struct mlx5_ib_cq *VAR_11;
unsigned long VAR_12;
u32 VAR_13 = VAR_14;
struct mlx5_ib_create_qp VAR_15;
struct mlx5_ib_qp_base *VAR_16;
int VAR_17;
void *VAR_18;
u32 *VAR_19;
int VAR_20;
mutex_init(&VAR_4->mutex);
spin_lock_init(&VAR_4->sq.lock);
spin_lock_init(&VAR_4->rq.lock);
VAR_17 = to_mlx5_st(VAR_2->qp_type);
if (VAR_17 < 0)
return -VAR_21;
if (VAR_2->rwq_ind_tbl) {
if (!VAR_3)
return -VAR_22;
VAR_20 = create_rss_raw_qp_tir(VAR_0, VAR_4, VAR_1, VAR_2, VAR_3);
return VAR_20;
}
if (VAR_2->create_flags & VAR_23) {
if (!MLX5_CAP_GEN(VAR_8, VAR_24)) {
mlx5_ib_dbg(VAR_0, ""block multicast loopback isn't supported\n"");
return -VAR_21;
} else {
VAR_4->flags |= VAR_25;
}
}
if (VAR_2->create_flags &
(VAR_26 |
VAR_27 |
VAR_28)) {
if (!MLX5_CAP_GEN(VAR_8, VAR_29)) {
mlx5_ib_dbg(VAR_0, ""cross-channel isn't supported\n"");
return -VAR_21;
}
if (VAR_2->create_flags & VAR_26)
VAR_4->flags |= VAR_30;
if (VAR_2->create_flags & VAR_27)
VAR_4->flags |= VAR_31;
if (VAR_2->create_flags & VAR_28)
VAR_4->flags |= VAR_32;
}
if (VAR_2->qp_type == VAR_33 &&
(VAR_2->create_flags & VAR_34))
if (!MLX5_CAP_GEN(VAR_8, VAR_35)) {
mlx5_ib_dbg(VAR_0, ""ipoib UD lso qp isn't supported\n"");
return -VAR_36;
}
if (VAR_2->create_flags & VAR_37) {
if (VAR_2->qp_type != VAR_38) {
mlx5_ib_dbg(VAR_0, ""Scatter FCS is supported only for Raw Packet QPs"");
return -VAR_36;
}
if (!MLX5_CAP_GEN(VAR_0->mdev, VAR_39) ||
!MLX5_CAP_ETH(VAR_0->mdev, VAR_40)) {
mlx5_ib_dbg(VAR_0, ""Scatter FCS isn't supported\n"");
return -VAR_36;
}
VAR_4->flags |= VAR_41;
}
if (VAR_2->sq_sig_type == VAR_42)
VAR_4->sq_signal_bits = VAR_43;
if (VAR_2->create_flags & VAR_44) {
if (!(MLX5_CAP_GEN(VAR_0->mdev, VAR_39) &&
MLX5_CAP_ETH(VAR_0->mdev, VAR_45)) ||
(VAR_2->qp_type != VAR_38))
return -VAR_36;
VAR_4->flags |= VAR_46;
}
if (VAR_1 && VAR_1->uobject) {
if (ib_copy_from_udata(&VAR_15, VAR_3, sizeof(VAR_15))) {
mlx5_ib_dbg(VAR_0, ""copy failed\n"");
return -VAR_47;
}
VAR_20 = get_qp_user_index(to_mucontext(VAR_1->uobject->context),
&VAR_15, VAR_3->inlen, &VAR_13);
if (VAR_20)
return VAR_20;
VAR_4->wq_sig = !!(VAR_15.flags & VAR_48);
VAR_4->scat_cqe = !!(VAR_15.flags & VAR_49);
if (VAR_15.flags & VAR_50) {
if (VAR_2->qp_type != VAR_38 ||
!tunnel_offload_supported(VAR_8)) {
mlx5_ib_dbg(VAR_0, ""Tunnel offload isn't supported\n"");
return -VAR_36;
}
VAR_4->tunnel_offload_en = true;
}
if (VAR_2->create_flags & VAR_51) {
if (VAR_2->qp_type != VAR_33 ||
(MLX5_CAP_GEN(VAR_0->mdev, VAR_52) !=
VAR_53) ||
!mlx5_get_flow_namespace(VAR_0->mdev, VAR_54)) {
mlx5_ib_dbg(VAR_0, ""Source QP option isn't supported\n"");
return -VAR_36;
}
VAR_4->flags |= VAR_55;
VAR_4->underlay_qpn = VAR_2->source_qpn;
}
} else {
VAR_4->wq_sig = !!VAR_56;
}
VAR_16 = (VAR_2->qp_type == VAR_38 ||
VAR_4->flags & VAR_55) ?
&VAR_4->raw_packet_qp.rq.base :
&VAR_4->trans_qp.base;
VAR_4->has_rq = qp_has_rq(VAR_2);
VAR_20 = set_rq_size(VAR_0, &VAR_2->cap, VAR_4->has_rq,
VAR_4, (VAR_1 && VAR_1->uobject) ? &VAR_15 : NULL);
if (VAR_20) {
mlx5_ib_dbg(VAR_0, ""err %d\n"", VAR_20);
return VAR_20;
}
if (VAR_1) {
if (VAR_1->uobject) {
__u32 VAR_57 =
1 << MLX5_CAP_GEN(VAR_8, VAR_58);
mlx5_ib_dbg(VAR_0, ""requested sq_wqe_count (%d)\n"", VAR_15.sq_wqe_count);
if (VAR_15.rq_wqe_shift != VAR_4->rq.wqe_shift ||
VAR_15.rq_wqe_count != VAR_4->rq.wqe_cnt) {
mlx5_ib_dbg(VAR_0, ""invalid rq params\n"");
return -VAR_21;
}
if (VAR_15.sq_wqe_count > VAR_57) {
mlx5_ib_dbg(VAR_0, ""requested sq_wqe_count (%d) > max allowed (%d)\n"",
VAR_15.sq_wqe_count, VAR_57);
return -VAR_21;
}
if (VAR_2->create_flags &
mlx5_ib_create_qp_sqpn_qp1()) {
mlx5_ib_dbg(VAR_0, ""user-space is not allowed to create UD QPs spoofing as QP1\n"");
return -VAR_21;
}
VAR_20 = create_user_qp(VAR_0, VAR_1, VAR_4, VAR_3, VAR_2, &VAR_19,
&VAR_9, &VAR_6, VAR_16);
if (VAR_20)
mlx5_ib_dbg(VAR_0, ""err %d\n"", VAR_20);
} else {
VAR_20 = create_kernel_qp(VAR_0, VAR_2, VAR_4, &VAR_19, &VAR_6,
VAR_16);
if (VAR_20)
mlx5_ib_dbg(VAR_0, ""err %d\n"", VAR_20);
}
if (VAR_20)
return VAR_20;
} else {
VAR_19 = kvzalloc(VAR_6, VAR_59);
if (!VAR_19)
return -VAR_60;
VAR_4->create_type = VAR_61;
}
if (is_sqp(VAR_2->qp_type))
VAR_4->port = VAR_2->port_num;
VAR_18 = MLX5_ADDR_OF(VAR_7, VAR_19, VAR_18);
MLX5_SET(VAR_18, VAR_18, VAR_62, VAR_17);
MLX5_SET(VAR_18, VAR_18, VAR_63, VAR_64);
if (VAR_2->qp_type != VAR_65)
MLX5_SET(VAR_18, VAR_18, VAR_1, to_mpd(VAR_1 ? VAR_1 : VAR_5->p0)->pdn);
else
MLX5_SET(VAR_18, VAR_18, VAR_66, 1);
if (VAR_4->wq_sig)
MLX5_SET(VAR_18, VAR_18, VAR_56, 1);
if (VAR_4->flags & VAR_25)
MLX5_SET(VAR_18, VAR_18, VAR_24, 1);
if (VAR_4->flags & VAR_30)
MLX5_SET(VAR_18, VAR_18, VAR_67, 1);
if (VAR_4->flags & VAR_31)
MLX5_SET(VAR_18, VAR_18, VAR_68, 1);
if (VAR_4->flags & VAR_32)
MLX5_SET(VAR_18, VAR_18, VAR_69, 1);
if (VAR_4->scat_cqe && is_connected(VAR_2->qp_type)) {
int VAR_70;
int VAR_71;
VAR_70 = mlx5_ib_get_cqe_size(VAR_0, VAR_2->recv_cq);
VAR_71 = mlx5_ib_get_cqe_size(VAR_0, VAR_2->send_cq);
if (VAR_70 == 128)
MLX5_SET(VAR_18, VAR_18, VAR_72, VAR_73);
else
MLX5_SET(VAR_18, VAR_18, VAR_72, VAR_74);
if (VAR_2->sq_sig_type == VAR_42) {
if (VAR_71 == 128)
MLX5_SET(VAR_18, VAR_18, VAR_75, VAR_76);
else
MLX5_SET(VAR_18, VAR_18, VAR_75, VAR_77);
}
}
if (VAR_4->rq.wqe_cnt) {
MLX5_SET(VAR_18, VAR_18, VAR_78, VAR_4->rq.wqe_shift - 4);
MLX5_SET(VAR_18, VAR_18, VAR_79, ilog2(VAR_4->rq.wqe_cnt));
}
MLX5_SET(VAR_18, VAR_18, VAR_80, get_rx_type(VAR_4, VAR_2));
if (VAR_4->sq.wqe_cnt) {
MLX5_SET(VAR_18, VAR_18, VAR_81, ilog2(VAR_4->sq.wqe_cnt));
} else {
MLX5_SET(VAR_18, VAR_18, VAR_82, 1);
if (VAR_2->srq &&
VAR_2->srq->srq_type == VAR_83)
MLX5_SET(VAR_18, VAR_18, VAR_84,
VAR_85);
}
switch (VAR_2->qp_type) {
case VAR_86:
MLX5_SET(VAR_18, VAR_18, VAR_87, to_mcq(VAR_5->c0)->mcq.cqn);
MLX5_SET(VAR_18, VAR_18, VAR_88, to_mcq(VAR_5->c0)->mcq.cqn);
MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_5->s0)->msrq.srqn);
MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_2->xrcd)->xrcdn);
break;
case VAR_91:
MLX5_SET(VAR_18, VAR_18, VAR_87, to_mcq(VAR_5->c0)->mcq.cqn);
MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_5->x1)->xrcdn);
MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_5->s0)->msrq.srqn);
break;
default:
if (VAR_2->srq) {
MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_5->x0)->xrcdn);
MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_2->srq)->msrq.srqn);
} else {
MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_5->x1)->xrcdn);
MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_5->s1)->msrq.srqn);
}
}
if (VAR_2->send_cq)
MLX5_SET(VAR_18, VAR_18, VAR_88, to_mcq(VAR_2->send_cq)->mcq.cqn);
if (VAR_2->recv_cq)
MLX5_SET(VAR_18, VAR_18, VAR_87, to_mcq(VAR_2->recv_cq)->mcq.cqn);
MLX5_SET64(VAR_18, VAR_18, VAR_92, VAR_4->db.dma);
if (MLX5_CAP_GEN(VAR_8, VAR_93) == VAR_94)
MLX5_SET(VAR_18, VAR_18, VAR_95, VAR_13);
if (VAR_2->qp_type == VAR_33 &&
(VAR_2->create_flags & VAR_34)) {
MLX5_SET(VAR_18, VAR_18, VAR_96, 1);
VAR_4->flags |= VAR_97;
}
if (VAR_2->create_flags & VAR_98) {
if (!MLX5_CAP_GEN(VAR_0->mdev, VAR_99)) {
mlx5_ib_dbg(VAR_0, ""scatter end padding is not supported\n"");
VAR_20 = -VAR_36;
goto err;
} else if (VAR_2->qp_type != VAR_38) {
MLX5_SET(VAR_18, VAR_18, VAR_100,
VAR_101);
} else {
VAR_4->flags |= VAR_102;
}
}
if (VAR_6 < 0) {
VAR_20 = -VAR_21;
goto err;
}
if (VAR_2->qp_type == VAR_38 ||
VAR_4->flags & VAR_55) {
VAR_4->raw_packet_qp.sq.ubuffer.buf_addr = VAR_15.sq_buf_addr;
raw_packet_qp_copy_info(VAR_4, &VAR_4->raw_packet_qp);
VAR_20 = create_raw_packet_qp(VAR_0, VAR_4, VAR_19, VAR_6, VAR_1);
} else {
VAR_20 = mlx5_core_create_qp(VAR_0->mdev, &VAR_16->mqp, VAR_19, VAR_6);
}
if (VAR_20) {
mlx5_ib_dbg(VAR_0, ""create qp failed\n"");
goto err_create;
}
kvfree(VAR_19);
VAR_16->container_mibqp = VAR_4;
VAR_16->mqp.event = VAR_103;
get_cqs(VAR_2->qp_type, VAR_2->send_cq, VAR_2->recv_cq,
&VAR_10, &VAR_11);
spin_lock_irqsave(&VAR_0->reset_flow_resource_lock, VAR_12);
mlx5_ib_lock_cqs(VAR_10, VAR_11);
list_add_tail(&VAR_4->qps_list, &VAR_0->qp_list);
if (VAR_10)
list_add_tail(&VAR_4->cq_send_list, &VAR_10->list_send_qp);
if (VAR_11)
list_add_tail(&VAR_4->cq_recv_list, &VAR_11->list_recv_qp);
mlx5_ib_unlock_cqs(VAR_10, VAR_11);
spin_unlock_irqrestore(&VAR_0->reset_flow_resource_lock, VAR_12);
return 0;
err_create:
if (VAR_4->create_type == VAR_104)
destroy_qp_user(VAR_0, VAR_1, VAR_4, VAR_16);
else if (VAR_4->create_type == VAR_105)
destroy_qp_kernel(VAR_0, VAR_4);
err:
kvfree(VAR_19);
return VAR_20;
}",torvalds/linux/0625b4ba1a5d4703c7fb01c497bd6c156908af00/qp.c/vul/before/0.json,"static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,
			    struct ib_qp_init_attr *init_attr,
			    struct ib_udata *udata, struct mlx5_ib_qp *qp)
{
	struct mlx5_ib_resources *devr = &dev->devr;
	int inlen = MLX5_ST_SZ_BYTES(create_qp_in);
	struct mlx5_core_dev *mdev = dev->mdev;
	struct mlx5_ib_create_qp_resp resp = {};
	struct mlx5_ib_cq *send_cq;
	struct mlx5_ib_cq *recv_cq;
	unsigned long flags;
	u32 uidx = MLX5_IB_DEFAULT_UIDX;
	struct mlx5_ib_create_qp ucmd;
	struct mlx5_ib_qp_base *base;
	int mlx5_st;
	void *qpc;
	u32 *in;
	int err;

	mutex_init(&qp->mutex);
	spin_lock_init(&qp->sq.lock);
	spin_lock_init(&qp->rq.lock);

	mlx5_st = to_mlx5_st(init_attr->qp_type);
	if (mlx5_st < 0)
		return -EINVAL;

	if (init_attr->rwq_ind_tbl) {
		if (!udata)
			return -ENOSYS;

		err = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);
		return err;
	}

	if (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {
		if (!MLX5_CAP_GEN(mdev, block_lb_mc)) {
			mlx5_ib_dbg(dev, ""block multicast loopback isn't supported\n"");
			return -EINVAL;
		} else {
			qp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;
		}
	}

	if (init_attr->create_flags &
			(IB_QP_CREATE_CROSS_CHANNEL |
			 IB_QP_CREATE_MANAGED_SEND |
			 IB_QP_CREATE_MANAGED_RECV)) {
		if (!MLX5_CAP_GEN(mdev, cd)) {
			mlx5_ib_dbg(dev, ""cross-channel isn't supported\n"");
			return -EINVAL;
		}
		if (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)
			qp->flags |= MLX5_IB_QP_CROSS_CHANNEL;
		if (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)
			qp->flags |= MLX5_IB_QP_MANAGED_SEND;
		if (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)
			qp->flags |= MLX5_IB_QP_MANAGED_RECV;
	}

	if (init_attr->qp_type == IB_QPT_UD &&
	    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))
		if (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {
			mlx5_ib_dbg(dev, ""ipoib UD lso qp isn't supported\n"");
			return -EOPNOTSUPP;
		}

	if (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {
		if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
			mlx5_ib_dbg(dev, ""Scatter FCS is supported only for Raw Packet QPs"");
			return -EOPNOTSUPP;
		}
		if (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||
		    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {
			mlx5_ib_dbg(dev, ""Scatter FCS isn't supported\n"");
			return -EOPNOTSUPP;
		}
		qp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;
	}

	if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)
		qp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;

	if (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {
		if (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&
		      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||
		    (init_attr->qp_type != IB_QPT_RAW_PACKET))
			return -EOPNOTSUPP;
		qp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;
	}

	if (pd && pd->uobject) {
		if (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {
			mlx5_ib_dbg(dev, ""copy failed\n"");
			return -EFAULT;
		}

		err = get_qp_user_index(to_mucontext(pd->uobject->context),
					&ucmd, udata->inlen, &uidx);
		if (err)
			return err;

		qp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);
		qp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);
		if (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {
			if (init_attr->qp_type != IB_QPT_RAW_PACKET ||
			    !tunnel_offload_supported(mdev)) {
				mlx5_ib_dbg(dev, ""Tunnel offload isn't supported\n"");
				return -EOPNOTSUPP;
			}
			qp->tunnel_offload_en = true;
		}

		if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {
			if (init_attr->qp_type != IB_QPT_UD ||
			    (MLX5_CAP_GEN(dev->mdev, port_type) !=
			     MLX5_CAP_PORT_TYPE_IB) ||
			    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {
				mlx5_ib_dbg(dev, ""Source QP option isn't supported\n"");
				return -EOPNOTSUPP;
			}

			qp->flags |= MLX5_IB_QP_UNDERLAY;
			qp->underlay_qpn = init_attr->source_qpn;
		}
	} else {
		qp->wq_sig = !!wq_signature;
	}

	base = (init_attr->qp_type == IB_QPT_RAW_PACKET ||
		qp->flags & MLX5_IB_QP_UNDERLAY) ?
	       &qp->raw_packet_qp.rq.base :
	       &qp->trans_qp.base;

	qp->has_rq = qp_has_rq(init_attr);
	err = set_rq_size(dev, &init_attr->cap, qp->has_rq,
			  qp, (pd && pd->uobject) ? &ucmd : NULL);
	if (err) {
		mlx5_ib_dbg(dev, ""err %d\n"", err);
		return err;
	}

	if (pd) {
		if (pd->uobject) {
			__u32 max_wqes =
				1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);
			mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d)\n"", ucmd.sq_wqe_count);
			if (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||
			    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {
				mlx5_ib_dbg(dev, ""invalid rq params\n"");
				return -EINVAL;
			}
			if (ucmd.sq_wqe_count > max_wqes) {
				mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d) > max allowed (%d)\n"",
					    ucmd.sq_wqe_count, max_wqes);
				return -EINVAL;
			}
			if (init_attr->create_flags &
			    mlx5_ib_create_qp_sqpn_qp1()) {
				mlx5_ib_dbg(dev, ""user-space is not allowed to create UD QPs spoofing as QP1\n"");
				return -EINVAL;
			}
			err = create_user_qp(dev, pd, qp, udata, init_attr, &in,
					     &resp, &inlen, base);
			if (err)
				mlx5_ib_dbg(dev, ""err %d\n"", err);
		} else {
			err = create_kernel_qp(dev, init_attr, qp, &in, &inlen,
					       base);
			if (err)
				mlx5_ib_dbg(dev, ""err %d\n"", err);
		}

		if (err)
			return err;
	} else {
		in = kvzalloc(inlen, GFP_KERNEL);
		if (!in)
			return -ENOMEM;

		qp->create_type = MLX5_QP_EMPTY;
	}

	if (is_sqp(init_attr->qp_type))
		qp->port = init_attr->port_num;

	qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);

	MLX5_SET(qpc, qpc, st, mlx5_st);
	MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);

	if (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)
		MLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);
	else
		MLX5_SET(qpc, qpc, latency_sensitive, 1);


	if (qp->wq_sig)
		MLX5_SET(qpc, qpc, wq_signature, 1);

	if (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)
		MLX5_SET(qpc, qpc, block_lb_mc, 1);

	if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)
		MLX5_SET(qpc, qpc, cd_master, 1);
	if (qp->flags & MLX5_IB_QP_MANAGED_SEND)
		MLX5_SET(qpc, qpc, cd_slave_send, 1);
	if (qp->flags & MLX5_IB_QP_MANAGED_RECV)
		MLX5_SET(qpc, qpc, cd_slave_receive, 1);

	if (qp->scat_cqe && is_connected(init_attr->qp_type)) {
		int rcqe_sz;
		int scqe_sz;

		rcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);
		scqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);

		if (rcqe_sz == 128)
			MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);
		else
			MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);

		if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {
			if (scqe_sz == 128)
				MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);
			else
				MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);
		}
	}

	if (qp->rq.wqe_cnt) {
		MLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);
		MLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));
	}

	MLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));

	if (qp->sq.wqe_cnt) {
		MLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));
	} else {
		MLX5_SET(qpc, qpc, no_sq, 1);
		if (init_attr->srq &&
		    init_attr->srq->srq_type == IB_SRQT_TM)
			MLX5_SET(qpc, qpc, offload_type,
				 MLX5_QPC_OFFLOAD_TYPE_RNDV);
	}

	/* Set default resources */
	switch (init_attr->qp_type) {
	case IB_QPT_XRC_TGT:
		MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);
		MLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);
		MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);
		MLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);
		break;
	case IB_QPT_XRC_INI:
		MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);
		MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);
		MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);
		break;
	default:
		if (init_attr->srq) {
			MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);
			MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);
		} else {
			MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);
			MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);
		}
	}

	if (init_attr->send_cq)
		MLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);

	if (init_attr->recv_cq)
		MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);

	MLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);

	/* 0xffffff means we ask to work with cqe version 0 */
	if (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)
		MLX5_SET(qpc, qpc, user_index, uidx);

	/* we use IB_QP_CREATE_IPOIB_UD_LSO to indicates ipoib qp */
	if (init_attr->qp_type == IB_QPT_UD &&
	    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {
		MLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);
		qp->flags |= MLX5_IB_QP_LSO;
	}

	if (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {
		if (!MLX5_CAP_GEN(dev->mdev, end_pad)) {
			mlx5_ib_dbg(dev, ""scatter end padding is not supported\n"");
			err = -EOPNOTSUPP;
			goto err;
		} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
			MLX5_SET(qpc, qpc, end_padding_mode,
				 MLX5_WQ_END_PAD_MODE_ALIGN);
		} else {
			qp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;
		}
	}

	if (inlen < 0) {
		err = -EINVAL;
		goto err;
	}

	if (init_attr->qp_type == IB_QPT_RAW_PACKET ||
	    qp->flags & MLX5_IB_QP_UNDERLAY) {
		qp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;
		raw_packet_qp_copy_info(qp, &qp->raw_packet_qp);
		err = create_raw_packet_qp(dev, qp, in, inlen, pd);
	} else {
		err = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);
	}

	if (err) {
		mlx5_ib_dbg(dev, ""create qp failed\n"");
		goto err_create;
	}

	kvfree(in);

	base->container_mibqp = qp;
	base->mqp.event = mlx5_ib_qp_event;

	get_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,
		&send_cq, &recv_cq);
	spin_lock_irqsave(&dev->reset_flow_resource_lock, flags);
	mlx5_ib_lock_cqs(send_cq, recv_cq);
	/* Maintain device to QPs access, needed for further handling via reset
	 * flow
	 */
	list_add_tail(&qp->qps_list, &dev->qp_list);
	/* Maintain CQ to QPs access, needed for further handling via reset flow
	 */
	if (send_cq)
		list_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);
	if (recv_cq)
		list_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);
	mlx5_ib_unlock_cqs(send_cq, recv_cq);
	spin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);

	return 0;

err_create:
	if (qp->create_type == MLX5_QP_USER)
		destroy_qp_user(dev, pd, qp, base);
	else if (qp->create_type == MLX5_QP_KERNEL)
		destroy_qp_kernel(dev, qp);

err:
	kvfree(in);
	return err;
}","static int create_qp_common(struct mlx5_ib_dev *VAR_0, struct ib_pd *VAR_1,
			    struct ib_qp_init_attr *VAR_2,
			    struct ib_udata *VAR_3, struct mlx5_ib_qp *VAR_4)
{
	struct mlx5_ib_resources *VAR_5 = &VAR_0->devr;
	int VAR_6 = MLX5_ST_SZ_BYTES(VAR_7);
	struct mlx5_core_dev *VAR_8 = VAR_0->mdev;
	struct mlx5_ib_create_qp_resp VAR_9 = {};
	struct mlx5_ib_cq *VAR_10;
	struct mlx5_ib_cq *VAR_11;
	unsigned long VAR_12;
	u32 VAR_13 = VAR_14;
	struct mlx5_ib_create_qp VAR_15;
	struct mlx5_ib_qp_base *VAR_16;
	int VAR_17;
	void *VAR_18;
	u32 *VAR_19;
	int VAR_20;

	mutex_init(&VAR_4->mutex);
	spin_lock_init(&VAR_4->sq.lock);
	spin_lock_init(&VAR_4->rq.lock);

	VAR_17 = to_mlx5_st(VAR_2->qp_type);
	if (VAR_17 < 0)
		return -VAR_21;

	if (VAR_2->rwq_ind_tbl) {
		if (!VAR_3)
			return -VAR_22;

		VAR_20 = create_rss_raw_qp_tir(VAR_0, VAR_4, VAR_1, VAR_2, VAR_3);
		return VAR_20;
	}

	if (VAR_2->create_flags & VAR_23) {
		if (!MLX5_CAP_GEN(VAR_8, VAR_24)) {
			mlx5_ib_dbg(VAR_0, ""block multicast loopback isn't supported\n"");
			return -VAR_21;
		} else {
			VAR_4->flags |= VAR_25;
		}
	}

	if (VAR_2->create_flags &
			(VAR_26 |
			 VAR_27 |
			 VAR_28)) {
		if (!MLX5_CAP_GEN(VAR_8, VAR_29)) {
			mlx5_ib_dbg(VAR_0, ""cross-channel isn't supported\n"");
			return -VAR_21;
		}
		if (VAR_2->create_flags & VAR_26)
			VAR_4->flags |= VAR_30;
		if (VAR_2->create_flags & VAR_27)
			VAR_4->flags |= VAR_31;
		if (VAR_2->create_flags & VAR_28)
			VAR_4->flags |= VAR_32;
	}

	if (VAR_2->qp_type == VAR_33 &&
	    (VAR_2->create_flags & VAR_34))
		if (!MLX5_CAP_GEN(VAR_8, VAR_35)) {
			mlx5_ib_dbg(VAR_0, ""ipoib UD lso qp isn't supported\n"");
			return -VAR_36;
		}

	if (VAR_2->create_flags & VAR_37) {
		if (VAR_2->qp_type != VAR_38) {
			mlx5_ib_dbg(VAR_0, ""Scatter FCS is supported only for Raw Packet QPs"");
			return -VAR_36;
		}
		if (!MLX5_CAP_GEN(VAR_0->mdev, VAR_39) ||
		    !MLX5_CAP_ETH(VAR_0->mdev, VAR_40)) {
			mlx5_ib_dbg(VAR_0, ""Scatter FCS isn't supported\n"");
			return -VAR_36;
		}
		VAR_4->flags |= VAR_41;
	}

	if (VAR_2->sq_sig_type == VAR_42)
		VAR_4->sq_signal_bits = VAR_43;

	if (VAR_2->create_flags & VAR_44) {
		if (!(MLX5_CAP_GEN(VAR_0->mdev, VAR_39) &&
		      MLX5_CAP_ETH(VAR_0->mdev, VAR_45)) ||
		    (VAR_2->qp_type != VAR_38))
			return -VAR_36;
		VAR_4->flags |= VAR_46;
	}

	if (VAR_1 && VAR_1->uobject) {
		if (ib_copy_from_udata(&VAR_15, VAR_3, sizeof(VAR_15))) {
			mlx5_ib_dbg(VAR_0, ""copy failed\n"");
			return -VAR_47;
		}

		VAR_20 = get_qp_user_index(to_mucontext(VAR_1->uobject->context),
					&VAR_15, VAR_3->inlen, &VAR_13);
		if (VAR_20)
			return VAR_20;

		VAR_4->wq_sig = !!(VAR_15.flags & VAR_48);
		VAR_4->scat_cqe = !!(VAR_15.flags & VAR_49);
		if (VAR_15.flags & VAR_50) {
			if (VAR_2->qp_type != VAR_38 ||
			    !tunnel_offload_supported(VAR_8)) {
				mlx5_ib_dbg(VAR_0, ""Tunnel offload isn't supported\n"");
				return -VAR_36;
			}
			VAR_4->tunnel_offload_en = true;
		}

		if (VAR_2->create_flags & VAR_51) {
			if (VAR_2->qp_type != VAR_33 ||
			    (MLX5_CAP_GEN(VAR_0->mdev, VAR_52) !=
			     VAR_53) ||
			    !mlx5_get_flow_namespace(VAR_0->mdev, VAR_54)) {
				mlx5_ib_dbg(VAR_0, ""Source QP option isn't supported\n"");
				return -VAR_36;
			}

			VAR_4->flags |= VAR_55;
			VAR_4->underlay_qpn = VAR_2->source_qpn;
		}
	} else {
		VAR_4->wq_sig = !!VAR_56;
	}

	VAR_16 = (VAR_2->qp_type == VAR_38 ||
		VAR_4->flags & VAR_55) ?
	       &VAR_4->raw_packet_qp.rq.base :
	       &VAR_4->trans_qp.base;

	VAR_4->has_rq = qp_has_rq(VAR_2);
	VAR_20 = set_rq_size(VAR_0, &VAR_2->cap, VAR_4->has_rq,
			  VAR_4, (VAR_1 && VAR_1->uobject) ? &VAR_15 : NULL);
	if (VAR_20) {
		mlx5_ib_dbg(VAR_0, ""err %d\n"", VAR_20);
		return VAR_20;
	}

	if (VAR_1) {
		if (VAR_1->uobject) {
			__u32 VAR_57 =
				1 << MLX5_CAP_GEN(VAR_8, VAR_58);
			mlx5_ib_dbg(VAR_0, ""requested sq_wqe_count (%d)\n"", VAR_15.sq_wqe_count);
			if (VAR_15.rq_wqe_shift != VAR_4->rq.wqe_shift ||
			    VAR_15.rq_wqe_count != VAR_4->rq.wqe_cnt) {
				mlx5_ib_dbg(VAR_0, ""invalid rq params\n"");
				return -VAR_21;
			}
			if (VAR_15.sq_wqe_count > VAR_57) {
				mlx5_ib_dbg(VAR_0, ""requested sq_wqe_count (%d) > max allowed (%d)\n"",
					    VAR_15.sq_wqe_count, VAR_57);
				return -VAR_21;
			}
			if (VAR_2->create_flags &
			    mlx5_ib_create_qp_sqpn_qp1()) {
				mlx5_ib_dbg(VAR_0, ""user-space is not allowed to create UD QPs spoofing as QP1\n"");
				return -VAR_21;
			}
			VAR_20 = create_user_qp(VAR_0, VAR_1, VAR_4, VAR_3, VAR_2, &VAR_19,
					     &VAR_9, &VAR_6, VAR_16);
			if (VAR_20)
				mlx5_ib_dbg(VAR_0, ""err %d\n"", VAR_20);
		} else {
			VAR_20 = create_kernel_qp(VAR_0, VAR_2, VAR_4, &VAR_19, &VAR_6,
					       VAR_16);
			if (VAR_20)
				mlx5_ib_dbg(VAR_0, ""err %d\n"", VAR_20);
		}

		if (VAR_20)
			return VAR_20;
	} else {
		VAR_19 = kvzalloc(VAR_6, VAR_59);
		if (!VAR_19)
			return -VAR_60;

		VAR_4->create_type = VAR_61;
	}

	if (is_sqp(VAR_2->qp_type))
		VAR_4->port = VAR_2->port_num;

	VAR_18 = MLX5_ADDR_OF(VAR_7, VAR_19, VAR_18);

	MLX5_SET(VAR_18, VAR_18, VAR_62, VAR_17);
	MLX5_SET(VAR_18, VAR_18, VAR_63, VAR_64);

	if (VAR_2->qp_type != VAR_65)
		MLX5_SET(VAR_18, VAR_18, VAR_1, to_mpd(VAR_1 ? VAR_1 : VAR_5->p0)->pdn);
	else
		MLX5_SET(VAR_18, VAR_18, VAR_66, 1);


	if (VAR_4->wq_sig)
		MLX5_SET(VAR_18, VAR_18, VAR_56, 1);

	if (VAR_4->flags & VAR_25)
		MLX5_SET(VAR_18, VAR_18, VAR_24, 1);

	if (VAR_4->flags & VAR_30)
		MLX5_SET(VAR_18, VAR_18, VAR_67, 1);
	if (VAR_4->flags & VAR_31)
		MLX5_SET(VAR_18, VAR_18, VAR_68, 1);
	if (VAR_4->flags & VAR_32)
		MLX5_SET(VAR_18, VAR_18, VAR_69, 1);

	if (VAR_4->scat_cqe && is_connected(VAR_2->qp_type)) {
		int VAR_70;
		int VAR_71;

		VAR_70 = mlx5_ib_get_cqe_size(VAR_0, VAR_2->recv_cq);
		VAR_71 = mlx5_ib_get_cqe_size(VAR_0, VAR_2->send_cq);

		if (VAR_70 == 128)
			MLX5_SET(VAR_18, VAR_18, VAR_72, VAR_73);
		else
			MLX5_SET(VAR_18, VAR_18, VAR_72, VAR_74);

		if (VAR_2->sq_sig_type == VAR_42) {
			if (VAR_71 == 128)
				MLX5_SET(VAR_18, VAR_18, VAR_75, VAR_76);
			else
				MLX5_SET(VAR_18, VAR_18, VAR_75, VAR_77);
		}
	}

	if (VAR_4->rq.wqe_cnt) {
		MLX5_SET(VAR_18, VAR_18, VAR_78, VAR_4->rq.wqe_shift - 4);
		MLX5_SET(VAR_18, VAR_18, VAR_79, ilog2(VAR_4->rq.wqe_cnt));
	}

	MLX5_SET(VAR_18, VAR_18, VAR_80, get_rx_type(VAR_4, VAR_2));

	if (VAR_4->sq.wqe_cnt) {
		MLX5_SET(VAR_18, VAR_18, VAR_81, ilog2(VAR_4->sq.wqe_cnt));
	} else {
		MLX5_SET(VAR_18, VAR_18, VAR_82, 1);
		if (VAR_2->srq &&
		    VAR_2->srq->srq_type == VAR_83)
			MLX5_SET(VAR_18, VAR_18, VAR_84,
				 VAR_85);
	}

	/* COMMENT_0 */
	switch (VAR_2->qp_type) {
	case VAR_86:
		MLX5_SET(VAR_18, VAR_18, VAR_87, to_mcq(VAR_5->c0)->mcq.cqn);
		MLX5_SET(VAR_18, VAR_18, VAR_88, to_mcq(VAR_5->c0)->mcq.cqn);
		MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_5->s0)->msrq.srqn);
		MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_2->xrcd)->xrcdn);
		break;
	case VAR_91:
		MLX5_SET(VAR_18, VAR_18, VAR_87, to_mcq(VAR_5->c0)->mcq.cqn);
		MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_5->x1)->xrcdn);
		MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_5->s0)->msrq.srqn);
		break;
	default:
		if (VAR_2->srq) {
			MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_5->x0)->xrcdn);
			MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_2->srq)->msrq.srqn);
		} else {
			MLX5_SET(VAR_18, VAR_18, VAR_90, to_mxrcd(VAR_5->x1)->xrcdn);
			MLX5_SET(VAR_18, VAR_18, VAR_89, to_msrq(VAR_5->s1)->msrq.srqn);
		}
	}

	if (VAR_2->send_cq)
		MLX5_SET(VAR_18, VAR_18, VAR_88, to_mcq(VAR_2->send_cq)->mcq.cqn);

	if (VAR_2->recv_cq)
		MLX5_SET(VAR_18, VAR_18, VAR_87, to_mcq(VAR_2->recv_cq)->mcq.cqn);

	MLX5_SET64(VAR_18, VAR_18, VAR_92, VAR_4->db.dma);

	/* COMMENT_1 */
	if (MLX5_CAP_GEN(VAR_8, VAR_93) == VAR_94)
		MLX5_SET(VAR_18, VAR_18, VAR_95, VAR_13);

	/* COMMENT_2 */
	if (VAR_2->qp_type == VAR_33 &&
	    (VAR_2->create_flags & VAR_34)) {
		MLX5_SET(VAR_18, VAR_18, VAR_96, 1);
		VAR_4->flags |= VAR_97;
	}

	if (VAR_2->create_flags & VAR_98) {
		if (!MLX5_CAP_GEN(VAR_0->mdev, VAR_99)) {
			mlx5_ib_dbg(VAR_0, ""scatter end padding is not supported\n"");
			VAR_20 = -VAR_36;
			goto err;
		} else if (VAR_2->qp_type != VAR_38) {
			MLX5_SET(VAR_18, VAR_18, VAR_100,
				 VAR_101);
		} else {
			VAR_4->flags |= VAR_102;
		}
	}

	if (VAR_6 < 0) {
		VAR_20 = -VAR_21;
		goto err;
	}

	if (VAR_2->qp_type == VAR_38 ||
	    VAR_4->flags & VAR_55) {
		VAR_4->raw_packet_qp.sq.ubuffer.buf_addr = VAR_15.sq_buf_addr;
		raw_packet_qp_copy_info(VAR_4, &VAR_4->raw_packet_qp);
		VAR_20 = create_raw_packet_qp(VAR_0, VAR_4, VAR_19, VAR_6, VAR_1);
	} else {
		VAR_20 = mlx5_core_create_qp(VAR_0->mdev, &VAR_16->mqp, VAR_19, VAR_6);
	}

	if (VAR_20) {
		mlx5_ib_dbg(VAR_0, ""create qp failed\n"");
		goto err_create;
	}

	kvfree(VAR_19);

	VAR_16->container_mibqp = VAR_4;
	VAR_16->mqp.event = VAR_103;

	get_cqs(VAR_2->qp_type, VAR_2->send_cq, VAR_2->recv_cq,
		&VAR_10, &VAR_11);
	spin_lock_irqsave(&VAR_0->reset_flow_resource_lock, VAR_12);
	mlx5_ib_lock_cqs(VAR_10, VAR_11);
	/* COMMENT_3 */
        
    
	list_add_tail(&VAR_4->qps_list, &VAR_0->qp_list);
	/* COMMENT_6 */
    
	if (VAR_10)
		list_add_tail(&VAR_4->cq_send_list, &VAR_10->list_send_qp);
	if (VAR_11)
		list_add_tail(&VAR_4->cq_recv_list, &VAR_11->list_recv_qp);
	mlx5_ib_unlock_cqs(VAR_10, VAR_11);
	spin_unlock_irqrestore(&VAR_0->reset_flow_resource_lock, VAR_12);

	return 0;

err_create:
	if (VAR_4->create_type == VAR_104)
		destroy_qp_user(VAR_0, VAR_1, VAR_4, VAR_16);
	else if (VAR_4->create_type == VAR_105)
		destroy_qp_kernel(VAR_0, VAR_4);

err:
	kvfree(VAR_19);
	return VAR_20;
}",torvalds/linux/0625b4ba1a5d4703c7fb01c497bd6c156908af00/qp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	struct mlx5_ib_resources *devr = &dev->devr;
 	int inlen = MLX5_ST_SZ_BYTES(create_qp_in);
 	struct mlx5_core_dev *mdev = dev->mdev;
-	struct mlx5_ib_create_qp_resp resp;
+	struct mlx5_ib_create_qp_resp resp = {};
 	struct mlx5_ib_cq *send_cq;
 	struct mlx5_ib_cq *recv_cq;
 	unsigned long flags;","{'deleted_lines': ['\tstruct mlx5_ib_create_qp_resp resp;'], 'added_lines': ['\tstruct mlx5_ib_create_qp_resp resp = {};']}",True,"An issue was discovered in the Linux kernel before 4.18.7. In create_qp_common in drivers/infiniband/hw/mlx5/qp.c, mlx5_ib_create_qp_resp was never initialized, resulting in a leak of stack memory to userspace.",3.3,LOW,0,test,2018-08-14T21:33:52Z,2
CVE-2018-16863,['CWE-184'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0.0,ArtifexSoftware/ghostpdl,"Bug 699654: Check the restore operand type

The primary function that implements restore correctly checked its parameter,
but a function that does some preliminary work for the restore (gstate and
device handling) did not check.

So, even though the restore correctly errored out, it left things partially done
and, in particular, the device in partially restored state. Meaning the
LockSafetyParams was not correctly set.",78911a01b67d,https://github.com/ArtifexSoftware/ghostpdl/commit/78911a01b67d590b4a91afac2e8417360b934156,psi/zdevice2.c,z2restore,"static int
z2restore(i_ctx_t *i_ctx_p)
{
while (gs_gstate_saved(gs_gstate_saved(igs))) {
if (restore_page_device(igs, gs_gstate_saved(igs)))
return push_callout(i_ctx_p, ""%restore1pagedevice"");
gs_grestore(igs);
}
if (restore_page_device(igs, gs_gstate_saved(igs)))
return push_callout(i_ctx_p, ""%restorepagedevice"");
return zrestore(i_ctx_p);
}","static int
z2restore(i_ctx_t *VAR_0)
{
while (gs_gstate_saved(gs_gstate_saved(VAR_1))) {
if (restore_page_device(VAR_1, gs_gstate_saved(VAR_1)))
return push_callout(VAR_0, ""%restore1pagedevice"");
gs_grestore(VAR_1);
}
if (restore_page_device(VAR_1, gs_gstate_saved(VAR_1)))
return push_callout(VAR_0, ""%restorepagedevice"");
return zrestore(VAR_0);
}",ArtifexSoftware/ghostpdl/78911a01b67d/zdevice2.c/vul/before/0.json,"static int
z2restore(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    check_type(*op, t_save);

    while (gs_gstate_saved(gs_gstate_saved(igs))) {
        if (restore_page_device(igs, gs_gstate_saved(igs)))
            return push_callout(i_ctx_p, ""%restore1pagedevice"");
        gs_grestore(igs);
    }
    if (restore_page_device(igs, gs_gstate_saved(igs)))
        return push_callout(i_ctx_p, ""%restorepagedevice"");
    return zrestore(i_ctx_p);
}","static int
z2restore(i_ctx_t *VAR_0)
{
    os_ptr VAR_1 = VAR_2;
    check_type(*VAR_1, VAR_3);

    while (gs_gstate_saved(gs_gstate_saved(VAR_4))) {
        if (restore_page_device(VAR_4, gs_gstate_saved(VAR_4)))
            return push_callout(VAR_0, ""%restore1pagedevice"");
        gs_grestore(VAR_4);
    }
    if (restore_page_device(VAR_4, gs_gstate_saved(VAR_4)))
        return push_callout(VAR_0, ""%restorepagedevice"");
    return zrestore(VAR_0);
}",ArtifexSoftware/ghostpdl/78911a01b67d/zdevice2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,9 @@
 static int
 z2restore(i_ctx_t *i_ctx_p)
 {
+    os_ptr op = osp;
+    check_type(*op, t_save);
+
     while (gs_gstate_saved(gs_gstate_saved(igs))) {
         if (restore_page_device(igs, gs_gstate_saved(igs)))
             return push_callout(i_ctx_p, ""%restore1pagedevice"");","{'deleted_lines': [], 'added_lines': ['    os_ptr op = osp;', '    check_type(*op, t_save);', '']}",True,"It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",7.3,HIGH,2,test,2018-08-23T08:54:59Z,2
CVE-2018-16863,['CWE-184'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0.0,ArtifexSoftware/ghostpdl,"Improve restore robustness

Prompted by looking at Bug 699654:

There are two variants of the restore operator in Ghostscript: one is Level 1
(restoring VM), the other is Level 2+ (adding page device restoring to the
Level operator).

This was implemented by the Level 2+ version restoring the device in the
graphics state, then calling the Level 1 implementation to handle actually
restoring the VM state.

The problem was that the operand checking, and sanity of the save object was
only done by the Level 1 variant, thus meaning an invalid save object could
leave a (Level 2+) restore partially complete - with the page device part
restored, but not VM, and the page device not configured.

To solve that, this commit splits the operand and sanity checking, and the
core of the restore operation into separate functions, so the relevant
operators can validate the operand *before* taking any further action. That
reduces the chances of an invalid restore leaving the interpreter in an
unknown state.

If an error occurs during the actual VM restore it is essentially fatal, and the
interpreter cannot continue, but as an extra surety for security, in the event
of such an error, we'll explicitly preserve the LockSafetyParams of the device,
rather than rely on the post-restore device configuration (which won't happen
in the event of an error).",5516c614dc33,https://github.com/ArtifexSoftware/ghostpdl/commit/5516c614dc33662a2afdc377159f70218e67bde5,psi/zvmem.c,zrestore,"int
zrestore(i_ctx_t *i_ctx_p)
{
os_ptr op = osp;
alloc_save_t *asave;
bool last;
vm_save_t *vmsave;
int code = restore_check_operand(op, &asave, idmemory);
if (code < 0)
return code;
if_debug2m('u', imemory, ""[u]vmrestore 0x%lx, id = %lu\n"",
(ulong) alloc_save_client_data(asave),
(ulong) op->value.saveid);
if (I_VALIDATE_BEFORE_RESTORE)
ivalidate_clean_spaces(i_ctx_p);
osp--;
{
int code;
if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||
(code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||
(code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0
) {
osp++;
return code;
}
}
restore_fix_stack(i_ctx_p, &o_stack, asave, false);
restore_fix_stack(i_ctx_p, &e_stack, asave, true);
restore_fix_stack(i_ctx_p, &d_stack, asave, false);
do {
vmsave = alloc_save_client_data(alloc_save_current(idmemory));
gs_grestoreall_for_restore(igs, vmsave->gsave);
vmsave->gsave = 0;
code = alloc_restore_step_in(idmemory, asave);
if (code < 0)
return code;
last = code;
}
while (!last);
{
uint space = icurrent_space;
ialloc_set_space(idmemory, avm_local);
ifree_object(vmsave, ""zrestore"");
ialloc_set_space(idmemory, space);
}
dict_set_top();
if (I_VALIDATE_AFTER_RESTORE)
ivalidate_clean_spaces(i_ctx_p);
i_ctx_p->LockFilePermissions = false;
return 0;
}","int
zrestore(i_ctx_t *VAR_0)
{
os_ptr VAR_1 = VAR_2;
alloc_save_t *VAR_3;
bool VAR_4;
vm_save_t *VAR_5;
int VAR_6 = restore_check_operand(VAR_1, &VAR_3, VAR_7);
if (VAR_6 < 0)
return VAR_6;
if_debug2m('u', VAR_8, ""[u]vmrestore 0x%lx, id = %lu\n"",
(ulong) alloc_save_client_data(VAR_3),
(ulong) VAR_1->value.saveid);
if (VAR_9)
ivalidate_clean_spaces(VAR_0);
VAR_2--;
{
int VAR_6;
if ((VAR_6 = restore_check_stack(VAR_0, &VAR_10, VAR_3, false)) < 0 ||
(VAR_6 = restore_check_stack(VAR_0, &VAR_11, VAR_3, true)) < 0 ||
(VAR_6 = restore_check_stack(VAR_0, &VAR_12, VAR_3, false)) < 0
) {
VAR_2++;
return VAR_6;
}
}
restore_fix_stack(VAR_0, &VAR_10, VAR_3, false);
restore_fix_stack(VAR_0, &VAR_11, VAR_3, true);
restore_fix_stack(VAR_0, &VAR_12, VAR_3, false);
do {
VAR_5 = alloc_save_client_data(alloc_save_current(VAR_7));
gs_grestoreall_for_restore(VAR_13, VAR_5->gsave);
VAR_5->gsave = 0;
VAR_6 = alloc_restore_step_in(VAR_7, VAR_3);
if (VAR_6 < 0)
return VAR_6;
VAR_4 = VAR_6;
}
while (!VAR_4);
{
uint VAR_14 = VAR_15;
ialloc_set_space(VAR_7, VAR_16);
ifree_object(VAR_5, ""zrestore"");
ialloc_set_space(VAR_7, VAR_14);
}
dict_set_top();
if (VAR_17)
ivalidate_clean_spaces(VAR_0);
VAR_0->LockFilePermissions = false;
return 0;
}",ArtifexSoftware/ghostpdl/5516c614dc33/zvmem.c/vul/before/0.json,"int
zrestore(i_ctx_t *i_ctx_p)
{
    alloc_save_t *asave;
    int code = restore_check_save(i_ctx_p, &asave);
    if (code < 0)
        return code;

    return dorestore(i_ctx_p, asave);
}","int
zrestore(i_ctx_t *VAR_0)
{
    alloc_save_t *VAR_1;
    int VAR_2 = restore_check_save(VAR_0, &VAR_1);
    if (VAR_2 < 0)
        return VAR_2;

    return dorestore(VAR_0, VAR_1);
}",ArtifexSoftware/ghostpdl/5516c614dc33/zvmem.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,74 +1,10 @@
 int
 zrestore(i_ctx_t *i_ctx_p)
 {
-    os_ptr op = osp;
     alloc_save_t *asave;
-    bool last;
-    vm_save_t *vmsave;
-    int code = restore_check_operand(op, &asave, idmemory);
-
+    int code = restore_check_save(i_ctx_p, &asave);
     if (code < 0)
         return code;
-    if_debug2m('u', imemory, ""[u]vmrestore 0x%lx, id = %lu\n"",
-               (ulong) alloc_save_client_data(asave),
-               (ulong) op->value.saveid);
-    if (I_VALIDATE_BEFORE_RESTORE)
-        ivalidate_clean_spaces(i_ctx_p);
-    /* Check the contents of the stacks. */
-    osp--;
-    {
-        int code;
 
-        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||
-            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||
-            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0
-            ) {
-            osp++;
-            return code;
-        }
-    }
-    /* Reset l_new in all stack entries if the new save level is zero. */
-    /* Also do some special fixing on the e-stack. */
-    restore_fix_stack(i_ctx_p, &o_stack, asave, false);
-    restore_fix_stack(i_ctx_p, &e_stack, asave, true);
-    restore_fix_stack(i_ctx_p, &d_stack, asave, false);
-    /* Iteratively restore the state of memory, */
-    /* also doing a grestoreall at each step. */
-    do {
-        vmsave = alloc_save_client_data(alloc_save_current(idmemory));
-        /* Restore the graphics state. */
-        gs_grestoreall_for_restore(igs, vmsave->gsave);
-        /*
-         * If alloc_save_space decided to do a second save, the vmsave
-         * object was allocated one save level less deep than the
-         * current level, so ifree_object won't actually free it;
-         * however, it points to a gsave object that definitely
-         * *has* been freed.  In order not to trip up the garbage
-         * collector, we clear the gsave pointer now.
-         */
-        vmsave->gsave = 0;
-        /* Now it's safe to restore the state of memory. */
-        code = alloc_restore_step_in(idmemory, asave);
-        if (code < 0)
-            return code;
-        last = code;
-    }
-    while (!last);
-    {
-        uint space = icurrent_space;
-
-        ialloc_set_space(idmemory, avm_local);
-        ifree_object(vmsave, ""zrestore"");
-        ialloc_set_space(idmemory, space);
-    }
-    dict_set_top();		/* reload dict stack cache */
-    if (I_VALIDATE_AFTER_RESTORE)
-        ivalidate_clean_spaces(i_ctx_p);
-    /* If the i_ctx_p LockFilePermissions is true, but the userparams */
-    /* we just restored is false, we need to make sure that we do not */
-    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */
-    /* LockFilePermissions false until the gs_lev2.ps can do a        */
-    /* setuserparams from the restored userparam dictionary.          */
-    i_ctx_p->LockFilePermissions = false;
-    return 0;
+    return dorestore(i_ctx_p, asave);
 }","{'deleted_lines': ['    os_ptr op = osp;', '    bool last;', '    vm_save_t *vmsave;', '    int code = restore_check_operand(op, &asave, idmemory);', '', '    if_debug2m(\'u\', imemory, ""[u]vmrestore 0x%lx, id = %lu\\n"",', '               (ulong) alloc_save_client_data(asave),', '               (ulong) op->value.saveid);', '    if (I_VALIDATE_BEFORE_RESTORE)', '        ivalidate_clean_spaces(i_ctx_p);', '    /* Check the contents of the stacks. */', '    osp--;', '    {', '        int code;', '        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||', '            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||', '            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0', '            ) {', '            osp++;', '            return code;', '        }', '    }', '    /* Reset l_new in all stack entries if the new save level is zero. */', '    /* Also do some special fixing on the e-stack. */', '    restore_fix_stack(i_ctx_p, &o_stack, asave, false);', '    restore_fix_stack(i_ctx_p, &e_stack, asave, true);', '    restore_fix_stack(i_ctx_p, &d_stack, asave, false);', '    /* Iteratively restore the state of memory, */', '    /* also doing a grestoreall at each step. */', '    do {', '        vmsave = alloc_save_client_data(alloc_save_current(idmemory));', '        /* Restore the graphics state. */', '        gs_grestoreall_for_restore(igs, vmsave->gsave);', '        /*', '         * If alloc_save_space decided to do a second save, the vmsave', '         * object was allocated one save level less deep than the', ""         * current level, so ifree_object won't actually free it;"", '         * however, it points to a gsave object that definitely', '         * *has* been freed.  In order not to trip up the garbage', '         * collector, we clear the gsave pointer now.', '         */', '        vmsave->gsave = 0;', ""        /* Now it's safe to restore the state of memory. */"", '        code = alloc_restore_step_in(idmemory, asave);', '        if (code < 0)', '            return code;', '        last = code;', '    }', '    while (!last);', '    {', '        uint space = icurrent_space;', '', '        ialloc_set_space(idmemory, avm_local);', '        ifree_object(vmsave, ""zrestore"");', '        ialloc_set_space(idmemory, space);', '    }', '    dict_set_top();\t\t/* reload dict stack cache */', '    if (I_VALIDATE_AFTER_RESTORE)', '        ivalidate_clean_spaces(i_ctx_p);', '    /* If the i_ctx_p LockFilePermissions is true, but the userparams */', '    /* we just restored is false, we need to make sure that we do not */', ""    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */"", '    /* LockFilePermissions false until the gs_lev2.ps can do a        */', '    /* setuserparams from the restored userparam dictionary.          */', '    i_ctx_p->LockFilePermissions = false;', '    return 0;'], 'added_lines': ['    int code = restore_check_save(i_ctx_p, &asave);', '    return dorestore(i_ctx_p, asave);']}",True,"It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",7.3,HIGH,2,test,2018-08-24T08:26:04Z,2
CVE-2018-16863,['CWE-184'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0.0,ArtifexSoftware/ghostpdl,"Improve restore robustness

Prompted by looking at Bug 699654:

There are two variants of the restore operator in Ghostscript: one is Level 1
(restoring VM), the other is Level 2+ (adding page device restoring to the
Level operator).

This was implemented by the Level 2+ version restoring the device in the
graphics state, then calling the Level 1 implementation to handle actually
restoring the VM state.

The problem was that the operand checking, and sanity of the save object was
only done by the Level 1 variant, thus meaning an invalid save object could
leave a (Level 2+) restore partially complete - with the page device part
restored, but not VM, and the page device not configured.

To solve that, this commit splits the operand and sanity checking, and the
core of the restore operation into separate functions, so the relevant
operators can validate the operand *before* taking any further action. That
reduces the chances of an invalid restore leaving the interpreter in an
unknown state.

If an error occurs during the actual VM restore it is essentially fatal, and the
interpreter cannot continue, but as an extra surety for security, in the event
of such an error, we'll explicitly preserve the LockSafetyParams of the device,
rather than rely on the post-restore device configuration (which won't happen
in the event of an error).",5516c614dc33,https://github.com/ArtifexSoftware/ghostpdl/commit/5516c614dc33662a2afdc377159f70218e67bde5,psi/zdevice2.c,z2restore,"static int
z2restore(i_ctx_t *i_ctx_p)
{
os_ptr op = osp;
check_type(*op, t_save);
while (gs_gstate_saved(gs_gstate_saved(igs))) {
if (restore_page_device(igs, gs_gstate_saved(igs)))
return push_callout(i_ctx_p, ""%restore1pagedevice"");
gs_grestore(igs);
}
if (restore_page_device(igs, gs_gstate_saved(igs)))
return push_callout(i_ctx_p, ""%restorepagedevice"");
return zrestore(i_ctx_p);
}","static int
z2restore(i_ctx_t *VAR_0)
{
os_ptr VAR_1 = VAR_2;
check_type(*VAR_1, VAR_3);
while (gs_gstate_saved(gs_gstate_saved(VAR_4))) {
if (restore_page_device(VAR_4, gs_gstate_saved(VAR_4)))
return push_callout(VAR_0, ""%restore1pagedevice"");
gs_grestore(VAR_4);
}
if (restore_page_device(VAR_4, gs_gstate_saved(VAR_4)))
return push_callout(VAR_0, ""%restorepagedevice"");
return zrestore(VAR_0);
}",ArtifexSoftware/ghostpdl/5516c614dc33/zdevice2.c/vul/before/0.json,"static int
z2restore(i_ctx_t *i_ctx_p)
{
    alloc_save_t *asave;
    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;
    int code = restore_check_save(i_ctx_p, &asave);

    if (code < 0) return code;

    while (gs_gstate_saved(gs_gstate_saved(igs))) {
        if (restore_page_device(igs, gs_gstate_saved(igs)))
            return push_callout(i_ctx_p, ""%restore1pagedevice"");
        gs_grestore(igs);
    }
    if (restore_page_device(igs, gs_gstate_saved(igs)))
        return push_callout(i_ctx_p, ""%restorepagedevice"");

    code = dorestore(i_ctx_p, asave);

    if (code < 0) {
        /* An error here is basically fatal, but....
           restore_page_device() has to set LockSafetyParams false so it can
           configure the restored device correctly - in normal operation, that
           gets reset by that configuration. If we hit an error, though, that
           may not happen -  at least ensure we keep the setting through the
           error.
         */
        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;
    }
    return code;
}","static int
z2restore(i_ctx_t *VAR_0)
{
    alloc_save_t *VAR_1;
    bool VAR_2 = gs_currentdevice_inline(VAR_3)->LockSafetyParams;
    int VAR_4 = restore_check_save(VAR_0, &VAR_1);

    if (VAR_4 < 0) return VAR_4;

    while (gs_gstate_saved(gs_gstate_saved(VAR_3))) {
        if (restore_page_device(VAR_3, gs_gstate_saved(VAR_3)))
            return push_callout(VAR_0, ""%restore1pagedevice"");
        gs_grestore(VAR_3);
    }
    if (restore_page_device(VAR_3, gs_gstate_saved(VAR_3)))
        return push_callout(VAR_0, ""%restorepagedevice"");

    VAR_4 = dorestore(VAR_0, VAR_1);

    if (VAR_4 < 0) {
        /* COMMENT_0 */
                                                                            
                                                                              
                                                                             
                                                                            
                 
           
        gs_currentdevice_inline(VAR_3)->LockSafetyParams = VAR_2;
    }
    return VAR_4;
}",ArtifexSoftware/ghostpdl/5516c614dc33/zdevice2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,11 @@
 static int
 z2restore(i_ctx_t *i_ctx_p)
 {
-    os_ptr op = osp;
-    check_type(*op, t_save);
+    alloc_save_t *asave;
+    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;
+    int code = restore_check_save(i_ctx_p, &asave);
+
+    if (code < 0) return code;
 
     while (gs_gstate_saved(gs_gstate_saved(igs))) {
         if (restore_page_device(igs, gs_gstate_saved(igs)))
@@ -11,5 +14,18 @@
     }
     if (restore_page_device(igs, gs_gstate_saved(igs)))
         return push_callout(i_ctx_p, ""%restorepagedevice"");
-    return zrestore(i_ctx_p);
+
+    code = dorestore(i_ctx_p, asave);
+
+    if (code < 0) {
+        /* An error here is basically fatal, but....
+           restore_page_device() has to set LockSafetyParams false so it can
+           configure the restored device correctly - in normal operation, that
+           gets reset by that configuration. If we hit an error, though, that
+           may not happen -  at least ensure we keep the setting through the
+           error.
+         */
+        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;
+    }
+    return code;
 }","{'deleted_lines': ['    os_ptr op = osp;', '    check_type(*op, t_save);', '    return zrestore(i_ctx_p);'], 'added_lines': ['    alloc_save_t *asave;', '    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;', '    int code = restore_check_save(i_ctx_p, &asave);', '', '    if (code < 0) return code;', '', '    code = dorestore(i_ctx_p, asave);', '', '    if (code < 0) {', '        /* An error here is basically fatal, but....', '           restore_page_device() has to set LockSafetyParams false so it can', '           configure the restored device correctly - in normal operation, that', '           gets reset by that configuration. If we hit an error, though, that', '           may not happen -  at least ensure we keep the setting through the', '           error.', '         */', '        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;', '    }', '    return code;']}",True,"It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",7.3,HIGH,2,test,2018-08-24T08:26:04Z,2
CVE-2019-16680,['CWE-22'],AV:N/AC:H/Au:N/C:N/I:P/A:N,0.0,GNOME/file-roller,"Path traversal vulnerability

Do not extract files with relative paths.

[bug #794337]",57268e51e59b61c9e3125eb0f65551c7084297e2,https://github.com/GNOME/file-roller/commit/57268e51e59b61c9e3125eb0f65551c7084297e2,src/glib-utils.c,sanitize_filename,"static const char *
sanitize_filename (const char *file_name)
{
size_t      prefix_len;
char const *p;
if (file_name == NULL)
return NULL;
prefix_len = 0;
for (p = file_name; *p; ) {
if (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))
prefix_len = p + 2 - file_name;
do {
char c = *p++;
if (ISSLASH (c))
break;
}
while (*p);
}
p = file_name + prefix_len;
while (ISSLASH (*p))
p++;
return p;
}","static const char *
sanitize_filename (const char *VAR_0)
{
size_t      VAR_1;
char const *VAR_2;
if (VAR_0 == NULL)
return NULL;
VAR_1 = 0;
for (VAR_2 = VAR_0; *VAR_2; ) {
if (ISDOT (VAR_2[0]) && ISDOT (VAR_2[1]) && (ISSLASH (VAR_2[2]) || !VAR_2[2]))
VAR_1 = VAR_2 + 2 - VAR_0;
do {
char VAR_3 = *VAR_2++;
if (ISSLASH (VAR_3))
break;
}
while (*VAR_2);
}
VAR_2 = VAR_0 + VAR_1;
while (ISSLASH (*VAR_2))
VAR_2++;
return VAR_2;
}",GNOME/file-roller/57268e51e59b61c9e3125eb0f65551c7084297e2/glib-utils.c/vul/before/0.json,"static const char *
sanitize_filename (const char *file_name)
{
	size_t      prefix_len;
	char const *p;

	if (file_name == NULL)
		return NULL;

	prefix_len = 0;
	for (p = file_name; *p; ) {
		if (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))
			return NULL;

		do {
			char c = *p++;
			if (ISSLASH (c))
				break;
		}
		while (*p);
	}

	p = file_name + prefix_len;
	while (ISSLASH (*p))
		p++;

	return p;
}","static const char *
sanitize_filename (const char *VAR_0)
{
	size_t      VAR_1;
	char const *VAR_2;

	if (VAR_0 == NULL)
		return NULL;

	VAR_1 = 0;
	for (VAR_2 = VAR_0; *VAR_2; ) {
		if (ISDOT (VAR_2[0]) && ISDOT (VAR_2[1]) && (ISSLASH (VAR_2[2]) || !VAR_2[2]))
			return NULL;

		do {
			char VAR_3 = *VAR_2++;
			if (ISSLASH (VAR_3))
				break;
		}
		while (*VAR_2);
	}

	VAR_2 = VAR_0 + VAR_1;
	while (ISSLASH (*VAR_2))
		VAR_2++;

	return VAR_2;
}",GNOME/file-roller/57268e51e59b61c9e3125eb0f65551c7084297e2/glib-utils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
 	prefix_len = 0;
 	for (p = file_name; *p; ) {
 		if (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))
-			prefix_len = p + 2 - file_name;
+			return NULL;
 
 		do {
 			char c = *p++;","{'deleted_lines': ['\t\t\tprefix_len = p + 2 - file_name;'], 'added_lines': ['\t\t\treturn NULL;']}",True,"An issue was discovered in GNOME file-roller before 3.29.91. It allows a single ./../ path traversal via a filename contained in a TAR archive, possibly overwriting a file during extraction.",4.3,MEDIUM,1,test,2018-08-27T13:15:42Z,2
CVE-2018-16300,['CWE-674'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,the-tcpdump-group/tcpdump,"(for 4.9.3) CVE-2018-16300/BGP: prevent stack exhaustion

Enforce a limit on how many times bgp_attr_print() can recurse.

This fixes a stack exhaustion discovered by Include Security working
under the Mozilla SOS program in 2018 by means of code audit.",af2cf04a9394c1a56227c2289ae8da262828294a,https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a,print-bgp.c,bgp_update_print,"static void
bgp_update_print(netdissect_options *ndo,
const u_char *dat, int length)
{
struct bgp bgp;
const u_char *p;
int withdrawn_routes_len;
int len;
int i;
ND_TCHECK2(dat[0], BGP_SIZE);
if (length < BGP_SIZE)
goto trunc;
memcpy(&bgp, dat, BGP_SIZE);
p = dat + BGP_SIZE;
length -= BGP_SIZE;
ND_TCHECK2(p[0], 2);
if (length < 2)
goto trunc;
withdrawn_routes_len = EXTRACT_16BITS(p);
p += 2;
length -= 2;
if (withdrawn_routes_len) {
ND_TCHECK2(p[0], withdrawn_routes_len);
if (length < withdrawn_routes_len)
goto trunc;
ND_PRINT((ndo, ""\n\t  Withdrawn routes: %d bytes"", withdrawn_routes_len));
p += withdrawn_routes_len;
length -= withdrawn_routes_len;
}
ND_TCHECK2(p[0], 2);
if (length < 2)
goto trunc;
len = EXTRACT_16BITS(p);
p += 2;
length -= 2;
if (withdrawn_routes_len == 0 && len == 0 && length == 0) {
ND_PRINT((ndo, ""\n\t  End-of-Rib Marker (empty NLRI)""));
return;
}
if (len) {
while (len) {
int aflags, atype, alenlen, alen;
ND_TCHECK2(p[0], 2);
if (len < 2)
goto trunc;
if (length < 2)
goto trunc;
aflags = *p;
atype = *(p + 1);
p += 2;
len -= 2;
length -= 2;
alenlen = bgp_attr_lenlen(aflags, p);
ND_TCHECK2(p[0], alenlen);
if (len < alenlen)
goto trunc;
if (length < alenlen)
goto trunc;
alen = bgp_attr_len(aflags, p);
p += alenlen;
len -= alenlen;
length -= alenlen;
ND_PRINT((ndo, ""\n\t  %s (%u), length: %u"",
tok2str(bgp_attr_values, ""Unknown Attribute"",
atype),
atype,
alen));
if (aflags) {
ND_PRINT((ndo, "", Flags [%s%s%s%s"",
aflags & 0x80 ? ""O"" : """",
aflags & 0x40 ? ""T"" : """",
aflags & 0x20 ? ""P"" : """",
aflags & 0x10 ? ""E"" : """"));
if (aflags & 0xf)
ND_PRINT((ndo, ""+%x"", aflags & 0xf));
ND_PRINT((ndo, ""]: ""));
}
if (len < alen)
goto trunc;
if (length < alen)
goto trunc;
if (!bgp_attr_print(ndo, atype, p, alen))
goto trunc;
p += alen;
len -= alen;
length -= alen;
}
}
if (length) {
ND_PRINT((ndo, ""\n\t  Updated routes:""));
while (length) {
char buf[MAXHOSTNAMELEN + 100];
i = decode_prefix4(ndo, p, length, buf, sizeof(buf));
if (i == -1) {
ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
break;
} else if (i == -2)
goto trunc;
else if (i == -3)
goto trunc; 
else {
ND_PRINT((ndo, ""\n\t    %s"", buf));
p += i;
length -= i;
}
}
}
return;
trunc:
ND_PRINT((ndo, ""%s"", tstr));
}","static void
bgp_update_print(netdissect_options *VAR_0,
const u_char *VAR_1, int VAR_2)
{
struct bgp bgp;
const u_char *VAR_3;
int VAR_4;
int VAR_5;
int VAR_6;
ND_TCHECK2(VAR_1[0], VAR_7);
if (VAR_2 < VAR_7)
goto trunc;
memcpy(&bgp, VAR_1, VAR_7);
VAR_3 = VAR_1 + VAR_7;
VAR_2 -= VAR_7;
ND_TCHECK2(VAR_3[0], 2);
if (VAR_2 < 2)
goto trunc;
VAR_4 = EXTRACT_16BITS(VAR_3);
VAR_3 += 2;
VAR_2 -= 2;
if (VAR_4) {
ND_TCHECK2(VAR_3[0], VAR_4);
if (VAR_2 < VAR_4)
goto trunc;
ND_PRINT((VAR_0, ""\n\t  Withdrawn routes: %d bytes"", VAR_4));
VAR_3 += VAR_4;
VAR_2 -= VAR_4;
}
ND_TCHECK2(VAR_3[0], 2);
if (VAR_2 < 2)
goto trunc;
VAR_5 = EXTRACT_16BITS(VAR_3);
VAR_3 += 2;
VAR_2 -= 2;
if (VAR_4 == 0 && VAR_5 == 0 && VAR_2 == 0) {
ND_PRINT((VAR_0, ""\n\t  End-of-Rib Marker (empty NLRI)""));
return;
}
if (VAR_5) {
while (VAR_5) {
int VAR_8, VAR_9, VAR_10, VAR_11;
ND_TCHECK2(VAR_3[0], 2);
if (VAR_5 < 2)
goto trunc;
if (VAR_2 < 2)
goto trunc;
VAR_8 = *VAR_3;
VAR_9 = *(VAR_3 + 1);
VAR_3 += 2;
VAR_5 -= 2;
VAR_2 -= 2;
VAR_10 = bgp_attr_lenlen(VAR_8, VAR_3);
ND_TCHECK2(VAR_3[0], VAR_10);
if (VAR_5 < VAR_10)
goto trunc;
if (VAR_2 < VAR_10)
goto trunc;
VAR_11 = bgp_attr_len(VAR_8, VAR_3);
VAR_3 += VAR_10;
VAR_5 -= VAR_10;
VAR_2 -= VAR_10;
ND_PRINT((VAR_0, ""\n\t  %s (%u), length: %u"",
tok2str(VAR_12, ""Unknown Attribute"",
VAR_9),
VAR_9,
VAR_11));
if (VAR_8) {
ND_PRINT((VAR_0, "", Flags [%s%s%s%s"",
VAR_8 & 0x80 ? ""O"" : """",
VAR_8 & 0x40 ? ""T"" : """",
VAR_8 & 0x20 ? ""P"" : """",
VAR_8 & 0x10 ? ""E"" : """"));
if (VAR_8 & 0xf)
ND_PRINT((VAR_0, ""+%x"", VAR_8 & 0xf));
ND_PRINT((VAR_0, ""]: ""));
}
if (VAR_5 < VAR_11)
goto trunc;
if (VAR_2 < VAR_11)
goto trunc;
if (!bgp_attr_print(VAR_0, VAR_9, VAR_3, VAR_11))
goto trunc;
VAR_3 += VAR_11;
VAR_5 -= VAR_11;
VAR_2 -= VAR_11;
}
}
if (VAR_2) {
ND_PRINT((VAR_0, ""\n\t  Updated routes:""));
while (VAR_2) {
char VAR_13[VAR_14 + 100];
VAR_6 = decode_prefix4(VAR_0, VAR_3, VAR_2, VAR_13, sizeof(VAR_13));
if (VAR_6 == -1) {
ND_PRINT((VAR_0, ""\n\t    (illegal prefix length)""));
break;
} else if (VAR_6 == -2)
goto trunc;
else if (VAR_6 == -3)
goto trunc; 
else {
ND_PRINT((VAR_0, ""\n\t    %s"", VAR_13));
VAR_3 += VAR_6;
VAR_2 -= VAR_6;
}
}
}
return;
trunc:
ND_PRINT((VAR_0, ""%s"", VAR_15));
}",the-tcpdump-group/tcpdump/af2cf04a9394c1a56227c2289ae8da262828294a/print-bgp.c/vul/before/0.json,"static void
bgp_update_print(netdissect_options *ndo,
                 const u_char *dat, int length)
{
	struct bgp bgp;
	const u_char *p;
	int withdrawn_routes_len;
	int len;
	int i;

	ND_TCHECK2(dat[0], BGP_SIZE);
	if (length < BGP_SIZE)
		goto trunc;
	memcpy(&bgp, dat, BGP_SIZE);
	p = dat + BGP_SIZE;	/*XXX*/
	length -= BGP_SIZE;

	/* Unfeasible routes */
	ND_TCHECK2(p[0], 2);
	if (length < 2)
		goto trunc;
	withdrawn_routes_len = EXTRACT_16BITS(p);
	p += 2;
	length -= 2;
	if (withdrawn_routes_len) {
		/*
		 * Without keeping state from the original NLRI message,
		 * it's not possible to tell if this a v4 or v6 route,
		 * so only try to decode it if we're not v6 enabled.
	         */
		ND_TCHECK2(p[0], withdrawn_routes_len);
		if (length < withdrawn_routes_len)
			goto trunc;
		ND_PRINT((ndo, ""\n\t  Withdrawn routes: %d bytes"", withdrawn_routes_len));
		p += withdrawn_routes_len;
		length -= withdrawn_routes_len;
	}

	ND_TCHECK2(p[0], 2);
	if (length < 2)
		goto trunc;
	len = EXTRACT_16BITS(p);
	p += 2;
	length -= 2;

        if (withdrawn_routes_len == 0 && len == 0 && length == 0) {
            /* No withdrawn routes, no path attributes, no NLRI */
            ND_PRINT((ndo, ""\n\t  End-of-Rib Marker (empty NLRI)""));
            return;
        }

	if (len) {
		/* do something more useful!*/
		while (len) {
			int aflags, atype, alenlen, alen;

			ND_TCHECK2(p[0], 2);
			if (len < 2)
			    goto trunc;
			if (length < 2)
			    goto trunc;
			aflags = *p;
			atype = *(p + 1);
			p += 2;
			len -= 2;
			length -= 2;
			alenlen = bgp_attr_lenlen(aflags, p);
			ND_TCHECK2(p[0], alenlen);
			if (len < alenlen)
			    goto trunc;
			if (length < alenlen)
			    goto trunc;
			alen = bgp_attr_len(aflags, p);
			p += alenlen;
			len -= alenlen;
			length -= alenlen;

			ND_PRINT((ndo, ""\n\t  %s (%u), length: %u"",
                              tok2str(bgp_attr_values, ""Unknown Attribute"",
					 atype),
                              atype,
                              alen));

			if (aflags) {
				ND_PRINT((ndo, "", Flags [%s%s%s%s"",
					aflags & 0x80 ? ""O"" : """",
					aflags & 0x40 ? ""T"" : """",
					aflags & 0x20 ? ""P"" : """",
					aflags & 0x10 ? ""E"" : """"));
				if (aflags & 0xf)
					ND_PRINT((ndo, ""+%x"", aflags & 0xf));
				ND_PRINT((ndo, ""]: ""));
			}
			if (len < alen)
				goto trunc;
			if (length < alen)
				goto trunc;
			if (!bgp_attr_print(ndo, atype, p, alen, 0))
				goto trunc;
			p += alen;
			len -= alen;
			length -= alen;
		}
	}

	if (length) {
		/*
		 * XXX - what if they're using the ""Advertisement of
		 * Multiple Paths in BGP"" feature:
		 *
		 * https://datatracker.ietf.org/doc/draft-ietf-idr-add-paths/
		 *
		 * http://tools.ietf.org/html/draft-ietf-idr-add-paths-06
		 */
		ND_PRINT((ndo, ""\n\t  Updated routes:""));
		while (length) {
			char buf[MAXHOSTNAMELEN + 100];
			i = decode_prefix4(ndo, p, length, buf, sizeof(buf));
			if (i == -1) {
				ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
				break;
			} else if (i == -2)
				goto trunc;
			else if (i == -3)
				goto trunc; /* bytes left, but not enough */
			else {
				ND_PRINT((ndo, ""\n\t    %s"", buf));
				p += i;
				length -= i;
			}
		}
	}
	return;
trunc:
	ND_PRINT((ndo, ""%s"", tstr));
}","static void
bgp_update_print(netdissect_options *VAR_0,
                 const u_char *VAR_1, int VAR_2)
{
	struct bgp bgp;
	const u_char *VAR_3;
	int VAR_4;
	int VAR_5;
	int VAR_6;

	ND_TCHECK2(VAR_1[0], VAR_7);
	if (VAR_2 < VAR_7)
		goto trunc;
	memcpy(&bgp, VAR_1, VAR_7);
	VAR_3 = VAR_1 + VAR_7;	/* COMMENT_0 */
	VAR_2 -= VAR_7;

	/* COMMENT_1 */
	ND_TCHECK2(VAR_3[0], 2);
	if (VAR_2 < 2)
		goto trunc;
	VAR_4 = EXTRACT_16BITS(VAR_3);
	VAR_3 += 2;
	VAR_2 -= 2;
	if (VAR_4) {
		/* COMMENT_2 */
                                                          
                                                        
                                                      
            
		ND_TCHECK2(VAR_3[0], VAR_4);
		if (VAR_2 < VAR_4)
			goto trunc;
		ND_PRINT((VAR_0, ""\n\t  Withdrawn routes: %d bytes"", VAR_4));
		VAR_3 += VAR_4;
		VAR_2 -= VAR_4;
	}

	ND_TCHECK2(VAR_3[0], 2);
	if (VAR_2 < 2)
		goto trunc;
	VAR_5 = EXTRACT_16BITS(VAR_3);
	VAR_3 += 2;
	VAR_2 -= 2;

        if (VAR_4 == 0 && VAR_5 == 0 && VAR_2 == 0) {
            /* COMMENT_7 */
            ND_PRINT((VAR_0, ""\n\t  End-of-Rib Marker (empty NLRI)""));
            return;
        }

	if (VAR_5) {
		/* COMMENT_8 */
		while (VAR_5) {
			int VAR_8, VAR_9, VAR_10, VAR_11;

			ND_TCHECK2(VAR_3[0], 2);
			if (VAR_5 < 2)
			    goto trunc;
			if (VAR_2 < 2)
			    goto trunc;
			VAR_8 = *VAR_3;
			VAR_9 = *(VAR_3 + 1);
			VAR_3 += 2;
			VAR_5 -= 2;
			VAR_2 -= 2;
			VAR_10 = bgp_attr_lenlen(VAR_8, VAR_3);
			ND_TCHECK2(VAR_3[0], VAR_10);
			if (VAR_5 < VAR_10)
			    goto trunc;
			if (VAR_2 < VAR_10)
			    goto trunc;
			VAR_11 = bgp_attr_len(VAR_8, VAR_3);
			VAR_3 += VAR_10;
			VAR_5 -= VAR_10;
			VAR_2 -= VAR_10;

			ND_PRINT((VAR_0, ""\n\t  %s (%u), length: %u"",
                              tok2str(VAR_12, ""Unknown Attribute"",
					 VAR_9),
                              VAR_9,
                              VAR_11));

			if (VAR_8) {
				ND_PRINT((VAR_0, "", Flags [%s%s%s%s"",
					VAR_8 & 0x80 ? ""O"" : """",
					VAR_8 & 0x40 ? ""T"" : """",
					VAR_8 & 0x20 ? ""P"" : """",
					VAR_8 & 0x10 ? ""E"" : """"));
				if (VAR_8 & 0xf)
					ND_PRINT((VAR_0, ""+%x"", VAR_8 & 0xf));
				ND_PRINT((VAR_0, ""]: ""));
			}
			if (VAR_5 < VAR_11)
				goto trunc;
			if (VAR_2 < VAR_11)
				goto trunc;
			if (!bgp_attr_print(VAR_0, VAR_9, VAR_3, VAR_11, 0))
				goto trunc;
			VAR_3 += VAR_11;
			VAR_5 -= VAR_11;
			VAR_2 -= VAR_11;
		}
	}

	if (VAR_2) {
		/* COMMENT_9 */
                                                      
                                    
    
                                                               
    
                                                           
     
		ND_PRINT((VAR_0, ""\n\t  Updated routes:""));
		while (VAR_2) {
			char VAR_13[VAR_14 + 100];
			VAR_6 = decode_prefix4(VAR_0, VAR_3, VAR_2, VAR_13, sizeof(VAR_13));
			if (VAR_6 == -1) {
				ND_PRINT((VAR_0, ""\n\t    (illegal prefix length)""));
				break;
			} else if (VAR_6 == -2)
				goto trunc;
			else if (VAR_6 == -3)
				goto trunc; /* COMMENT_16 */
			else {
				ND_PRINT((VAR_0, ""\n\t    %s"", VAR_13));
				VAR_3 += VAR_6;
				VAR_2 -= VAR_6;
			}
		}
	}
	return;
trunc:
	ND_PRINT((VAR_0, ""%s"", VAR_15));
}",the-tcpdump-group/tcpdump/af2cf04a9394c1a56227c2289ae8da262828294a/print-bgp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -95,7 +95,7 @@
 				goto trunc;
 			if (length < alen)
 				goto trunc;
-			if (!bgp_attr_print(ndo, atype, p, alen))
+			if (!bgp_attr_print(ndo, atype, p, alen, 0))
 				goto trunc;
 			p += alen;
 			len -= alen;","{'deleted_lines': ['\t\t\tif (!bgp_attr_print(ndo, atype, p, alen))'], 'added_lines': ['\t\t\tif (!bgp_attr_print(ndo, atype, p, alen, 0))']}",True,The BGP parser in tcpdump before 4.9.3 allows stack consumption in print-bgp.c:bgp_attr_print() because of unlimited recursion.,7.5,HIGH,2,test,2018-09-06T20:26:21Z,2
CVE-2018-17182,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"mm: get rid of vmacache_flush_all() entirely

Jann Horn points out that the vmacache_flush_all() function is not only
potentially expensive, it's buggy too.  It also happens to be entirely
unnecessary, because the sequence number overflow case can be avoided by
simply making the sequence number be 64-bit.  That doesn't even grow the
data structures in question, because the other adjacent fields are
already 64-bit.

So simplify the whole thing by just making the sequence number overflow
case go away entirely, which gets rid of all the complications and makes
the code faster too.  Win-win.

[ Oleg Nesterov points out that the VMACACHE_FULL_FLUSHES statistics
  also just goes away entirely with this ]

Reported-by: Jann Horn <jannh@google.com>
Suggested-by: Will Deacon <will.deacon@arm.com>
Acked-by: Davidlohr Bueso <dave@stgolabs.net>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",7a9cdebdcc17e426fb5287e4a82db1dfe86339b2,https://github.com/torvalds/linux/commit/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2,mm/debug.c,dump_mm,"void dump_mm(const struct mm_struct *mm)
{
pr_emerg(""mm %px mmap %px seqnum %d task_size %lu\n""
#ifdef CONFIG_MMU
""get_unmapped_area %px\n""
#endif
""mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\n""
""pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\n""
""hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\n""
""pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\n""
""start_code %lx end_code %lx start_data %lx end_data %lx\n""
""start_brk %lx brk %lx start_stack %lx\n""
""arg_start %lx arg_end %lx env_start %lx env_end %lx\n""
""binfmt %px flags %lx core_state %px\n""
#ifdef CONFIG_AIO
""ioctx_table %px\n""
#endif
#ifdef CONFIG_MEMCG
""owner %px ""
#endif
""exe_file %px\n""
#ifdef CONFIG_MMU_NOTIFIER
""mmu_notifier_mm %px\n""
#endif
#ifdef CONFIG_NUMA_BALANCING
""numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\n""
#endif
""tlb_flush_pending %d\n""
""def_flags: %#lx(%pGv)\n"",
mm, mm->mmap, mm->vmacache_seqnum, mm->task_size,
#ifdef CONFIG_MMU
mm->get_unmapped_area,
#endif
mm->mmap_base, mm->mmap_legacy_base, mm->highest_vm_end,
mm->pgd, atomic_read(&mm->mm_users),
atomic_read(&mm->mm_count),
mm_pgtables_bytes(mm),
mm->map_count,
mm->hiwater_rss, mm->hiwater_vm, mm->total_vm, mm->locked_vm,
mm->pinned_vm, mm->data_vm, mm->exec_vm, mm->stack_vm,
mm->start_code, mm->end_code, mm->start_data, mm->end_data,
mm->start_brk, mm->brk, mm->start_stack,
mm->arg_start, mm->arg_end, mm->env_start, mm->env_end,
mm->binfmt, mm->flags, mm->core_state,
#ifdef CONFIG_AIO
mm->ioctx_table,
#endif
#ifdef CONFIG_MEMCG
mm->owner,
#endif
mm->exe_file,
#ifdef CONFIG_MMU_NOTIFIER
mm->mmu_notifier_mm,
#endif
#ifdef CONFIG_NUMA_BALANCING
mm->numa_next_scan, mm->numa_scan_offset, mm->numa_scan_seq,
#endif
atomic_read(&mm->tlb_flush_pending),
mm->def_flags, &mm->def_flags
);
}","void dump_mm(const struct mm_struct *VAR_0)
{
pr_emerg(""mm %px mmap %px seqnum %d task_size %lu\n""
#ifdef VAR_1
""get_unmapped_area %px\n""
#endif
""mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\n""
""pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\n""
""hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\n""
""pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\n""
""start_code %lx end_code %lx start_data %lx end_data %lx\n""
""start_brk %lx brk %lx start_stack %lx\n""
""arg_start %lx arg_end %lx env_start %lx env_end %lx\n""
""binfmt %px flags %lx core_state %px\n""
#ifdef VAR_2
""ioctx_table %px\n""
#endif
#ifdef VAR_3
""owner %px ""
#endif
""exe_file %px\n""
#ifdef VAR_4
""mmu_notifier_mm %px\n""
#endif
#ifdef VAR_5
""numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\n""
#endif
""tlb_flush_pending %d\n""
""def_flags: %#lx(%pGv)\n"",
VAR_0, VAR_0->mmap, VAR_0->vmacache_seqnum, VAR_0->task_size,
#ifdef VAR_1
VAR_0->get_unmapped_area,
#endif
VAR_0->mmap_base, VAR_0->mmap_legacy_base, VAR_0->highest_vm_end,
VAR_0->pgd, atomic_read(&VAR_0->mm_users),
atomic_read(&VAR_0->mm_count),
mm_pgtables_bytes(VAR_0),
VAR_0->map_count,
VAR_0->hiwater_rss, VAR_0->hiwater_vm, VAR_0->total_vm, VAR_0->locked_vm,
VAR_0->pinned_vm, VAR_0->data_vm, VAR_0->exec_vm, VAR_0->stack_vm,
VAR_0->start_code, VAR_0->end_code, VAR_0->start_data, VAR_0->end_data,
VAR_0->start_brk, VAR_0->brk, VAR_0->start_stack,
VAR_0->arg_start, VAR_0->arg_end, VAR_0->env_start, VAR_0->env_end,
VAR_0->binfmt, VAR_0->flags, VAR_0->core_state,
#ifdef VAR_2
VAR_0->ioctx_table,
#endif
#ifdef VAR_3
VAR_0->owner,
#endif
VAR_0->exe_file,
#ifdef VAR_4
VAR_0->mmu_notifier_mm,
#endif
#ifdef VAR_5
VAR_0->numa_next_scan, VAR_0->numa_scan_offset, VAR_0->numa_scan_seq,
#endif
atomic_read(&VAR_0->tlb_flush_pending),
VAR_0->def_flags, &VAR_0->def_flags
);
}",torvalds/linux/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2/debug.c/vul/before/0.json,"void dump_mm(const struct mm_struct *mm)
{
	pr_emerg(""mm %px mmap %px seqnum %llu task_size %lu\n""
#ifdef CONFIG_MMU
		""get_unmapped_area %px\n""
#endif
		""mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\n""
		""pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\n""
		""hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\n""
		""pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\n""
		""start_code %lx end_code %lx start_data %lx end_data %lx\n""
		""start_brk %lx brk %lx start_stack %lx\n""
		""arg_start %lx arg_end %lx env_start %lx env_end %lx\n""
		""binfmt %px flags %lx core_state %px\n""
#ifdef CONFIG_AIO
		""ioctx_table %px\n""
#endif
#ifdef CONFIG_MEMCG
		""owner %px ""
#endif
		""exe_file %px\n""
#ifdef CONFIG_MMU_NOTIFIER
		""mmu_notifier_mm %px\n""
#endif
#ifdef CONFIG_NUMA_BALANCING
		""numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\n""
#endif
		""tlb_flush_pending %d\n""
		""def_flags: %#lx(%pGv)\n"",

		mm, mm->mmap, (long long) mm->vmacache_seqnum, mm->task_size,
#ifdef CONFIG_MMU
		mm->get_unmapped_area,
#endif
		mm->mmap_base, mm->mmap_legacy_base, mm->highest_vm_end,
		mm->pgd, atomic_read(&mm->mm_users),
		atomic_read(&mm->mm_count),
		mm_pgtables_bytes(mm),
		mm->map_count,
		mm->hiwater_rss, mm->hiwater_vm, mm->total_vm, mm->locked_vm,
		mm->pinned_vm, mm->data_vm, mm->exec_vm, mm->stack_vm,
		mm->start_code, mm->end_code, mm->start_data, mm->end_data,
		mm->start_brk, mm->brk, mm->start_stack,
		mm->arg_start, mm->arg_end, mm->env_start, mm->env_end,
		mm->binfmt, mm->flags, mm->core_state,
#ifdef CONFIG_AIO
		mm->ioctx_table,
#endif
#ifdef CONFIG_MEMCG
		mm->owner,
#endif
		mm->exe_file,
#ifdef CONFIG_MMU_NOTIFIER
		mm->mmu_notifier_mm,
#endif
#ifdef CONFIG_NUMA_BALANCING
		mm->numa_next_scan, mm->numa_scan_offset, mm->numa_scan_seq,
#endif
		atomic_read(&mm->tlb_flush_pending),
		mm->def_flags, &mm->def_flags
	);
}","void dump_mm(const struct mm_struct *VAR_0)
{
	pr_emerg(""mm %px mmap %px seqnum %llu task_size %lu\n""
#ifdef VAR_1
		""get_unmapped_area %px\n""
#endif
		""mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\n""
		""pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\n""
		""hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\n""
		""pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\n""
		""start_code %lx end_code %lx start_data %lx end_data %lx\n""
		""start_brk %lx brk %lx start_stack %lx\n""
		""arg_start %lx arg_end %lx env_start %lx env_end %lx\n""
		""binfmt %px flags %lx core_state %px\n""
#ifdef VAR_2
		""ioctx_table %px\n""
#endif
#ifdef VAR_3
		""owner %px ""
#endif
		""exe_file %px\n""
#ifdef VAR_4
		""mmu_notifier_mm %px\n""
#endif
#ifdef VAR_5
		""numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\n""
#endif
		""tlb_flush_pending %d\n""
		""def_flags: %#lx(%pGv)\n"",

		VAR_0, VAR_0->mmap, (long long) VAR_0->vmacache_seqnum, VAR_0->task_size,
#ifdef VAR_1
		VAR_0->get_unmapped_area,
#endif
		VAR_0->mmap_base, VAR_0->mmap_legacy_base, VAR_0->highest_vm_end,
		VAR_0->pgd, atomic_read(&VAR_0->mm_users),
		atomic_read(&VAR_0->mm_count),
		mm_pgtables_bytes(VAR_0),
		VAR_0->map_count,
		VAR_0->hiwater_rss, VAR_0->hiwater_vm, VAR_0->total_vm, VAR_0->locked_vm,
		VAR_0->pinned_vm, VAR_0->data_vm, VAR_0->exec_vm, VAR_0->stack_vm,
		VAR_0->start_code, VAR_0->end_code, VAR_0->start_data, VAR_0->end_data,
		VAR_0->start_brk, VAR_0->brk, VAR_0->start_stack,
		VAR_0->arg_start, VAR_0->arg_end, VAR_0->env_start, VAR_0->env_end,
		VAR_0->binfmt, VAR_0->flags, VAR_0->core_state,
#ifdef VAR_2
		VAR_0->ioctx_table,
#endif
#ifdef VAR_3
		VAR_0->owner,
#endif
		VAR_0->exe_file,
#ifdef VAR_4
		VAR_0->mmu_notifier_mm,
#endif
#ifdef VAR_5
		VAR_0->numa_next_scan, VAR_0->numa_scan_offset, VAR_0->numa_scan_seq,
#endif
		atomic_read(&VAR_0->tlb_flush_pending),
		VAR_0->def_flags, &VAR_0->def_flags
	);
}",torvalds/linux/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2/debug.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 void dump_mm(const struct mm_struct *mm)
 {
-	pr_emerg(""mm %px mmap %px seqnum %d task_size %lu\n""
+	pr_emerg(""mm %px mmap %px seqnum %llu task_size %lu\n""
 #ifdef CONFIG_MMU
 		""get_unmapped_area %px\n""
 #endif
@@ -28,7 +28,7 @@
 		""tlb_flush_pending %d\n""
 		""def_flags: %#lx(%pGv)\n"",
 
-		mm, mm->mmap, mm->vmacache_seqnum, mm->task_size,
+		mm, mm->mmap, (long long) mm->vmacache_seqnum, mm->task_size,
 #ifdef CONFIG_MMU
 		mm->get_unmapped_area,
 #endif","{'deleted_lines': ['\tpr_emerg(""mm %px mmap %px seqnum %d task_size %lu\\n""', '\t\tmm, mm->mmap, mm->vmacache_seqnum, mm->task_size,'], 'added_lines': ['\tpr_emerg(""mm %px mmap %px seqnum %llu task_size %lu\\n""', '\t\tmm, mm->mmap, (long long) mm->vmacache_seqnum, mm->task_size,']}",True,"An issue was discovered in the Linux kernel through 4.18.8. The vmacache_flush_all function in mm/vmacache.c mishandles sequence number overflows. An attacker can trigger a use-after-free (and possibly gain privileges) via certain thread creation, map, unmap, invalidation, and dereference operations.",7.8,HIGH,2,test,2018-09-13T09:57:48Z,2
CVE-2018-17182,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0.0,torvalds/linux,"mm: get rid of vmacache_flush_all() entirely

Jann Horn points out that the vmacache_flush_all() function is not only
potentially expensive, it's buggy too.  It also happens to be entirely
unnecessary, because the sequence number overflow case can be avoided by
simply making the sequence number be 64-bit.  That doesn't even grow the
data structures in question, because the other adjacent fields are
already 64-bit.

So simplify the whole thing by just making the sequence number overflow
case go away entirely, which gets rid of all the complications and makes
the code faster too.  Win-win.

[ Oleg Nesterov points out that the VMACACHE_FULL_FLUSHES statistics
  also just goes away entirely with this ]

Reported-by: Jann Horn <jannh@google.com>
Suggested-by: Will Deacon <will.deacon@arm.com>
Acked-by: Davidlohr Bueso <dave@stgolabs.net>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: stable@kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",7a9cdebdcc17e426fb5287e4a82db1dfe86339b2,https://github.com/torvalds/linux/commit/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2,include/linux/vmacache.h,vmacache_invalidate,"static inline void vmacache_invalidate(struct mm_struct *mm)
{
mm->vmacache_seqnum++;
if (unlikely(mm->vmacache_seqnum == 0))
vmacache_flush_all(mm);
}","static inline void vmacache_invalidate(struct mm_struct *VAR_0)
{
VAR_0->vmacache_seqnum++;
if (unlikely(VAR_0->vmacache_seqnum == 0))
vmacache_flush_all(VAR_0);
}",torvalds/linux/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2/vmacache.h/vul/before/0.json,"static inline void vmacache_invalidate(struct mm_struct *mm)
{
	mm->vmacache_seqnum++;
}","static inline void vmacache_invalidate(struct mm_struct *VAR_0)
{
	VAR_0->vmacache_seqnum++;
}",torvalds/linux/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2/vmacache.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,4 @@
 static inline void vmacache_invalidate(struct mm_struct *mm)
 {
 	mm->vmacache_seqnum++;
-
-	/* deal with overflows */
-	if (unlikely(mm->vmacache_seqnum == 0))
-		vmacache_flush_all(mm);
 }","{'deleted_lines': ['', '\t/* deal with overflows */', '\tif (unlikely(mm->vmacache_seqnum == 0))', '\t\tvmacache_flush_all(mm);'], 'added_lines': []}",True,"An issue was discovered in the Linux kernel through 4.18.8. The vmacache_flush_all function in mm/vmacache.c mishandles sequence number overflows. An attacker can trigger a use-after-free (and possibly gain privileges) via certain thread creation, map, unmap, invalidation, and dereference operations.",7.8,HIGH,2,test,2018-09-13T09:57:48Z,2
CVE-2018-17293,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,WAVM,Fix dereferencing null pointer when running wavm with WebAssembly main function that takes command-line arguments but no Emscripten memory to write them to,31d670b6489e6d708c3b04b911cdf14ac43d846d,https://github.com/WAVM/WAVM/commit/31d670b6489e6d708c3b04b911cdf14ac43d846d,Programs/wavm/wavm.cpp,run,"static int run(const CommandLineOptions& options)
{
IR::Module irModule;
if(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }
if(options.onlyCheck) { return EXIT_SUCCESS; }
Runtime::Module* module = nullptr;
if(!options.precompiled) { module = Runtime::compileModule(irModule); }
else
{
const UserSection* precompiledObjectSection = nullptr;
for(const UserSection& userSection : irModule.userSections)
{
if(userSection.name == ""wavm.precompiled_object"")
{
precompiledObjectSection = &userSection;
break;
}
}
if(!precompiledObjectSection)
{
Log::printf(Log::error, ""Input file did not contain 'wavm.precompiled_object' section"");
return EXIT_FAILURE;
}
else
{
module = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);
}
}
Compartment* compartment = Runtime::createCompartment();
Context* context = Runtime::createContext(compartment);
RootResolver rootResolver(compartment);
Emscripten::Instance* emscriptenInstance = nullptr;
if(options.enableEmscripten)
{
emscriptenInstance = Emscripten::instantiate(compartment, irModule);
if(emscriptenInstance)
{
rootResolver.moduleNameToInstanceMap.set(""env"", emscriptenInstance->env);
rootResolver.moduleNameToInstanceMap.set(""asm2wasm"", emscriptenInstance->asm2wasm);
rootResolver.moduleNameToInstanceMap.set(""global"", emscriptenInstance->global);
}
}
if(options.enableThreadTest)
{
ModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);
rootResolver.moduleNameToInstanceMap.set(""threadTest"", threadTestInstance);
}
LinkResult linkResult = linkModule(irModule, rootResolver);
if(!linkResult.success)
{
Log::printf(Log::error, ""Failed to link module:\n"");
for(auto& missingImport : linkResult.missingImports)
{
Log::printf(Log::error,
""Missing import: module=\""%s\"" export=\""%s\"" type=\""%s\""\n"",
missingImport.moduleName.c_str(),
missingImport.exportName.c_str(),
asString(missingImport.type).c_str());
}
return EXIT_FAILURE;
}
ModuleInstance* moduleInstance = instantiateModule(
compartment, module, std::move(linkResult.resolvedImports), options.filename);
if(!moduleInstance) { return EXIT_FAILURE; }
FunctionInstance* startFunction = getStartFunction(moduleInstance);
if(startFunction) { invokeFunctionChecked(context, startFunction, {}); }
if(options.enableEmscripten)
{
Emscripten::initializeGlobals(context, irModule, moduleInstance);
}
FunctionInstance* functionInstance;
if(!options.functionName)
{
functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, ""main""));
if(!functionInstance)
{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, ""_main"")); }
if(!functionInstance)
{
Log::printf(Log::error, ""Module does not export main function\n"");
return EXIT_FAILURE;
}
}
else
{
functionInstance
= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));
if(!functionInstance)
{
Log::printf(Log::error, ""Module does not export '%s'\n"", options.functionName);
return EXIT_FAILURE;
}
}
FunctionType functionType = getFunctionType(functionInstance);
std::vector<Value> invokeArgs;
if(!options.functionName)
{
if(functionType.params().size() == 2)
{
MemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);
if(!defaultMemory)
{
Log::printf(
Log::error,
""Module does not declare a default memory object to put arguments in.\n"");
return EXIT_FAILURE;
}
std::vector<const char*> argStrings;
argStrings.push_back(options.filename);
char** args = options.args;
while(*args) { argStrings.push_back(*args++); };
Emscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);
}
else if(functionType.params().size() > 0)
{
Log::printf(Log::error,
""WebAssembly function requires %"" PRIu64
"" argument(s), but only 0 or 2 can be passed!"",
functionType.params().size());
return EXIT_FAILURE;
}
}
else
{
for(U32 i = 0; options.args[i]; ++i)
{
Value value;
switch(functionType.params()[i])
{
case ValueType::i32: value = (U32)atoi(options.args[i]); break;
case ValueType::i64: value = (U64)atol(options.args[i]); break;
case ValueType::f32: value = (F32)atof(options.args[i]); break;
case ValueType::f64: value = atof(options.args[i]); break;
case ValueType::v128:
case ValueType::anyref:
case ValueType::anyfunc:
Errors::fatalf(""Cannot parse command-line argument for %s function parameter"",
asString(functionType.params()[i]));
default: Errors::unreachable();
}
invokeArgs.push_back(value);
}
}
Timing::Timer executionTimer;
IR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);
Timing::logTimer(""Invoked function"", executionTimer);
if(options.functionName)
{
Log::printf(Log::debug,
""%s returned: %s\n"",
options.functionName,
asString(functionResults).c_str());
return EXIT_SUCCESS;
}
else if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)
{
return functionResults[0].i32;
}
else
{
return EXIT_SUCCESS;
}
}","static int run(const CommandLineOptions& VAR_0)
{
IR::Module VAR_1;
if(!loadModule(VAR_0.filename, VAR_1)) { return VAR_2; }
if(VAR_0.onlyCheck) { return VAR_3; }
Runtime::Module* VAR_4 = nullptr;
if(!VAR_0.precompiled) { VAR_4 = Runtime::compileModule(VAR_1); }
else
{
const UserSection* VAR_5 = nullptr;
for(const UserSection& VAR_6 : VAR_1.userSections)
{
if(VAR_6.name == ""wavm.precompiled_object"")
{
VAR_5 = &VAR_6;
break;
}
}
if(!VAR_5)
{
Log::printf(Log::error, ""Input file did not contain 'wavm.precompiled_object' section"");
return VAR_2;
}
else
{
VAR_4 = Runtime::loadPrecompiledModule(VAR_1, VAR_5->data);
}
}
Compartment* VAR_7 = Runtime::createCompartment();
Context* VAR_8 = Runtime::createContext(VAR_7);
RootResolver rootResolver(compartment);
Emscripten::Instance* VAR_9 = nullptr;
if(VAR_0.enableEmscripten)
{
VAR_9 = Emscripten::instantiate(compartment, VAR_1);
if(VAR_9)
{
VAR_10.moduleNameToInstanceMap.set(""env"", VAR_9->env);
VAR_10.moduleNameToInstanceMap.set(""asm2wasm"", VAR_9->asm2wasm);
VAR_10.moduleNameToInstanceMap.set(""global"", VAR_9->global);
}
}
if(VAR_0.enableThreadTest)
{
ModuleInstance* VAR_11 = ThreadTest::instantiate(compartment);
VAR_10.moduleNameToInstanceMap.set(""threadTest"", VAR_11);
}
LinkResult VAR_12 = linkModule(VAR_1, VAR_10);
if(!VAR_12.success)
{
Log::printf(Log::error, ""Failed to link module:\n"");
for(auto& VAR_13 : VAR_12.missingImports)
{
Log::printf(Log::error,
""Missing import: module=\""%s\"" export=\""%s\"" type=\""%s\""\n"",
VAR_13.moduleName.c_str(),
VAR_13.exportName.c_str(),
asString(VAR_13.type).c_str());
}
return VAR_2;
}
ModuleInstance* VAR_14 = instantiateModule(
compartment, VAR_4, std::move(VAR_12.resolvedImports), VAR_0.filename);
if(!VAR_14) { return VAR_2; }
FunctionInstance* VAR_15 = getStartFunction(VAR_14);
if(VAR_15) { invokeFunctionChecked(VAR_8, VAR_15, {}); }
if(VAR_0.enableEmscripten)
{
Emscripten::initializeGlobals(VAR_8, VAR_1, VAR_14);
}
FunctionInstance* VAR_16;
if(!VAR_0.functionName)
{
VAR_16 = asFunctionNullable(getInstanceExport(VAR_14, ""main""));
if(!VAR_16)
{ VAR_16 = asFunctionNullable(getInstanceExport(VAR_14, ""_main"")); }
if(!VAR_16)
{
Log::printf(Log::error, ""Module does not export main function\n"");
return VAR_2;
}
}
else
{
VAR_16
= asFunctionNullable(getInstanceExport(VAR_14, VAR_0.functionName));
if(!VAR_16)
{
Log::printf(Log::error, ""Module does not export '%s'\n"", VAR_0.functionName);
return VAR_2;
}
}
FunctionType VAR_17 = getFunctionType(VAR_16);
std::vector<Value> VAR_18;
if(!VAR_0.functionName)
{
if(VAR_17.params().size() == 2)
{
MemoryInstance* VAR_19 = Runtime::getDefaultMemory(VAR_14);
if(!VAR_19)
{
Log::printf(
Log::error,
""Module does not declare a default memory object to put arguments in.\n"");
return VAR_2;
}
std::vector<const char*> VAR_20;
VAR_20.push_back(VAR_0.filename);
char** VAR_21 = VAR_0.args;
while(*VAR_21) { VAR_20.push_back(*VAR_21++); };
Emscripten::injectCommandArgs(VAR_9, VAR_20, VAR_18);
}
else if(VAR_17.params().size() > 0)
{
Log::printf(Log::error,
""WebAssembly function requires %"" VAR_22
"" argument(s), but only 0 or 2 can be passed!"",
VAR_17.params().size());
return VAR_2;
}
}
else
{
for(U32 VAR_23 = 0; VAR_0.args[VAR_23]; ++VAR_23)
{
Value VAR_24;
switch(VAR_17.params()[VAR_23])
{
case ValueType::i32: VAR_24 = (U32)atoi(VAR_0.args[VAR_23]); break;
case ValueType::i64: VAR_24 = (U64)atol(VAR_0.args[VAR_23]); break;
case ValueType::f32: VAR_24 = (F32)atof(VAR_0.args[VAR_23]); break;
case ValueType::f64: VAR_24 = atof(VAR_0.args[VAR_23]); break;
case ValueType::v128:
case ValueType::anyref:
case ValueType::anyfunc:
Errors::fatalf(""Cannot parse command-line argument for %s function parameter"",
asString(VAR_17.params()[VAR_23]));
default: Errors::unreachable();
}
VAR_18.push_back(VAR_24);
}
}
Timing::Timer VAR_25;
IR::ValueTuple VAR_26 = invokeFunctionChecked(VAR_8, VAR_16, VAR_18);
Timing::logTimer(""Invoked function"", VAR_25);
if(VAR_0.functionName)
{
Log::printf(Log::debug,
""%s returned: %s\n"",
VAR_0.functionName,
asString(VAR_26).c_str());
return VAR_3;
}
else if(VAR_26.size() == 1 && VAR_26[0].type == ValueType::i32)
{
return VAR_26[0].i32;
}
else
{
return VAR_3;
}
}",WAVM/31d670b6489e6d708c3b04b911cdf14ac43d846d/wavm.cpp/vul/before/0.json,"static int run(const CommandLineOptions& options)
{
	IR::Module irModule;

	// Load the module.
	if(!loadModule(options.filename, irModule)) { return EXIT_FAILURE; }
	if(options.onlyCheck) { return EXIT_SUCCESS; }

	// Compile the module.
	Runtime::Module* module = nullptr;
	if(!options.precompiled) { module = Runtime::compileModule(irModule); }
	else
	{
		const UserSection* precompiledObjectSection = nullptr;
		for(const UserSection& userSection : irModule.userSections)
		{
			if(userSection.name == ""wavm.precompiled_object"")
			{
				precompiledObjectSection = &userSection;
				break;
			}
		}

		if(!precompiledObjectSection)
		{
			Log::printf(Log::error, ""Input file did not contain 'wavm.precompiled_object' section"");
			return EXIT_FAILURE;
		}
		else
		{
			module = Runtime::loadPrecompiledModule(irModule, precompiledObjectSection->data);
		}
	}

	// Link the module with the intrinsic modules.
	Compartment* compartment = Runtime::createCompartment();
	Context* context = Runtime::createContext(compartment);
	RootResolver rootResolver(compartment);

	Emscripten::Instance* emscriptenInstance = nullptr;
	if(options.enableEmscripten)
	{
		emscriptenInstance = Emscripten::instantiate(compartment, irModule);
		if(emscriptenInstance)
		{
			rootResolver.moduleNameToInstanceMap.set(""env"", emscriptenInstance->env);
			rootResolver.moduleNameToInstanceMap.set(""asm2wasm"", emscriptenInstance->asm2wasm);
			rootResolver.moduleNameToInstanceMap.set(""global"", emscriptenInstance->global);
		}
	}

	if(options.enableThreadTest)
	{
		ModuleInstance* threadTestInstance = ThreadTest::instantiate(compartment);
		rootResolver.moduleNameToInstanceMap.set(""threadTest"", threadTestInstance);
	}

	LinkResult linkResult = linkModule(irModule, rootResolver);
	if(!linkResult.success)
	{
		Log::printf(Log::error, ""Failed to link module:\n"");
		for(auto& missingImport : linkResult.missingImports)
		{
			Log::printf(Log::error,
						""Missing import: module=\""%s\"" export=\""%s\"" type=\""%s\""\n"",
						missingImport.moduleName.c_str(),
						missingImport.exportName.c_str(),
						asString(missingImport.type).c_str());
		}
		return EXIT_FAILURE;
	}

	// Instantiate the module.
	ModuleInstance* moduleInstance = instantiateModule(
		compartment, module, std::move(linkResult.resolvedImports), options.filename);
	if(!moduleInstance) { return EXIT_FAILURE; }

	// Call the module start function, if it has one.
	FunctionInstance* startFunction = getStartFunction(moduleInstance);
	if(startFunction) { invokeFunctionChecked(context, startFunction, {}); }

	if(options.enableEmscripten)
	{
		// Call the Emscripten global initalizers.
		Emscripten::initializeGlobals(context, irModule, moduleInstance);
	}

	// Look up the function export to call.
	FunctionInstance* functionInstance;
	if(!options.functionName)
	{
		functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, ""main""));
		if(!functionInstance)
		{ functionInstance = asFunctionNullable(getInstanceExport(moduleInstance, ""_main"")); }
		if(!functionInstance)
		{
			Log::printf(Log::error, ""Module does not export main function\n"");
			return EXIT_FAILURE;
		}
	}
	else
	{
		functionInstance
			= asFunctionNullable(getInstanceExport(moduleInstance, options.functionName));
		if(!functionInstance)
		{
			Log::printf(Log::error, ""Module does not export '%s'\n"", options.functionName);
			return EXIT_FAILURE;
		}
	}
	FunctionType functionType = getFunctionType(functionInstance);

	// Set up the arguments for the invoke.
	std::vector<Value> invokeArgs;
	if(!options.functionName)
	{
		if(functionType.params().size() == 2)
		{
			if(!emscriptenInstance)
			{
				Log::printf(
					Log::error,
					""Module does not declare a default memory object to put arguments in.\n"");
				return EXIT_FAILURE;
			}
			else
			{
				std::vector<const char*> argStrings;
				argStrings.push_back(options.filename);
				char** args = options.args;
				while(*args) { argStrings.push_back(*args++); };

				wavmAssert(emscriptenInstance);
				Emscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);
			}
		}
		else if(functionType.params().size() > 0)
		{
			Log::printf(Log::error,
						""WebAssembly function requires %"" PRIu64
						"" argument(s), but only 0 or 2 can be passed!"",
						functionType.params().size());
			return EXIT_FAILURE;
		}
	}
	else
	{
		for(U32 i = 0; options.args[i]; ++i)
		{
			Value value;
			switch(functionType.params()[i])
			{
			case ValueType::i32: value = (U32)atoi(options.args[i]); break;
			case ValueType::i64: value = (U64)atol(options.args[i]); break;
			case ValueType::f32: value = (F32)atof(options.args[i]); break;
			case ValueType::f64: value = atof(options.args[i]); break;
			case ValueType::v128:
			case ValueType::anyref:
			case ValueType::anyfunc:
				Errors::fatalf(""Cannot parse command-line argument for %s function parameter"",
							   asString(functionType.params()[i]));
			default: Errors::unreachable();
			}
			invokeArgs.push_back(value);
		}
	}

	// Invoke the function.
	Timing::Timer executionTimer;
	IR::ValueTuple functionResults = invokeFunctionChecked(context, functionInstance, invokeArgs);
	Timing::logTimer(""Invoked function"", executionTimer);

	if(options.functionName)
	{
		Log::printf(Log::debug,
					""%s returned: %s\n"",
					options.functionName,
					asString(functionResults).c_str());
		return EXIT_SUCCESS;
	}
	else if(functionResults.size() == 1 && functionResults[0].type == ValueType::i32)
	{
		return functionResults[0].i32;
	}
	else
	{
		return EXIT_SUCCESS;
	}
}","static int run(const CommandLineOptions& VAR_0)
{
	IR::Module VAR_1;

	/* COMMENT_0 */
	if(!loadModule(VAR_0.filename, VAR_1)) { return VAR_2; }
	if(VAR_0.onlyCheck) { return VAR_3; }

	/* COMMENT_1 */
	Runtime::Module* VAR_4 = nullptr;
	if(!VAR_0.precompiled) { VAR_4 = Runtime::compileModule(VAR_1); }
	else
	{
		const UserSection* VAR_5 = nullptr;
		for(const UserSection& VAR_6 : VAR_1.userSections)
		{
			if(VAR_6.name == ""wavm.precompiled_object"")
			{
				VAR_5 = &VAR_6;
				break;
			}
		}

		if(!VAR_5)
		{
			Log::printf(Log::error, ""Input file did not contain 'wavm.precompiled_object' section"");
			return VAR_2;
		}
		else
		{
			VAR_4 = Runtime::loadPrecompiledModule(VAR_1, VAR_5->data);
		}
	}

	/* COMMENT_2 */
	Compartment* VAR_7 = Runtime::createCompartment();
	Context* VAR_8 = Runtime::createContext(VAR_7);
	RootResolver rootResolver(compartment);

	Emscripten::Instance* VAR_9 = nullptr;
	if(VAR_0.enableEmscripten)
	{
		VAR_9 = Emscripten::instantiate(compartment, VAR_1);
		if(VAR_9)
		{
			VAR_10.moduleNameToInstanceMap.set(""env"", VAR_9->env);
			VAR_10.moduleNameToInstanceMap.set(""asm2wasm"", VAR_9->asm2wasm);
			VAR_10.moduleNameToInstanceMap.set(""global"", VAR_9->global);
		}
	}

	if(VAR_0.enableThreadTest)
	{
		ModuleInstance* VAR_11 = ThreadTest::instantiate(compartment);
		VAR_10.moduleNameToInstanceMap.set(""threadTest"", VAR_11);
	}

	LinkResult VAR_12 = linkModule(VAR_1, VAR_10);
	if(!VAR_12.success)
	{
		Log::printf(Log::error, ""Failed to link module:\n"");
		for(auto& VAR_13 : VAR_12.missingImports)
		{
			Log::printf(Log::error,
						""Missing import: module=\""%s\"" export=\""%s\"" type=\""%s\""\n"",
						VAR_13.moduleName.c_str(),
						VAR_13.exportName.c_str(),
						asString(VAR_13.type).c_str());
		}
		return VAR_2;
	}

	/* COMMENT_3 */
	ModuleInstance* VAR_14 = instantiateModule(
		compartment, VAR_4, std::move(VAR_12.resolvedImports), VAR_0.filename);
	if(!VAR_14) { return VAR_2; }

	/* COMMENT_4 */
	FunctionInstance* VAR_15 = getStartFunction(VAR_14);
	if(VAR_15) { invokeFunctionChecked(VAR_8, VAR_15, {}); }

	if(VAR_0.enableEmscripten)
	{
		/* COMMENT_5 */
		Emscripten::initializeGlobals(VAR_8, VAR_1, VAR_14);
	}

	/* COMMENT_6 */
	FunctionInstance* VAR_16;
	if(!VAR_0.functionName)
	{
		VAR_16 = asFunctionNullable(getInstanceExport(VAR_14, ""main""));
		if(!VAR_16)
		{ VAR_16 = asFunctionNullable(getInstanceExport(VAR_14, ""_main"")); }
		if(!VAR_16)
		{
			Log::printf(Log::error, ""Module does not export main function\n"");
			return VAR_2;
		}
	}
	else
	{
		VAR_16
			= asFunctionNullable(getInstanceExport(VAR_14, VAR_0.functionName));
		if(!VAR_16)
		{
			Log::printf(Log::error, ""Module does not export '%s'\n"", VAR_0.functionName);
			return VAR_2;
		}
	}
	FunctionType VAR_17 = getFunctionType(VAR_16);

	/* COMMENT_7 */
	std::vector<Value> VAR_18;
	if(!VAR_0.functionName)
	{
		if(VAR_17.params().size() == 2)
		{
			if(!VAR_9)
			{
				Log::printf(
					Log::error,
					""Module does not declare a default memory object to put arguments in.\n"");
				return VAR_2;
			}
			else
			{
				std::vector<const char*> VAR_19;
				VAR_19.push_back(VAR_0.filename);
				char** VAR_20 = VAR_0.args;
				while(*VAR_20) { VAR_19.push_back(*VAR_20++); };

				wavmAssert(VAR_9);
				Emscripten::injectCommandArgs(VAR_9, VAR_19, VAR_18);
			}
		}
		else if(VAR_17.params().size() > 0)
		{
			Log::printf(Log::error,
						""WebAssembly function requires %"" VAR_21
						"" argument(s), but only 0 or 2 can be passed!"",
						VAR_17.params().size());
			return VAR_2;
		}
	}
	else
	{
		for(U32 VAR_22 = 0; VAR_0.args[VAR_22]; ++VAR_22)
		{
			Value VAR_23;
			switch(VAR_17.params()[VAR_22])
			{
			case ValueType::i32: VAR_23 = (U32)atoi(VAR_0.args[VAR_22]); break;
			case ValueType::i64: VAR_23 = (U64)atol(VAR_0.args[VAR_22]); break;
			case ValueType::f32: VAR_23 = (F32)atof(VAR_0.args[VAR_22]); break;
			case ValueType::f64: VAR_23 = atof(VAR_0.args[VAR_22]); break;
			case ValueType::v128:
			case ValueType::anyref:
			case ValueType::anyfunc:
				Errors::fatalf(""Cannot parse command-line argument for %s function parameter"",
							   asString(VAR_17.params()[VAR_22]));
			default: Errors::unreachable();
			}
			VAR_18.push_back(VAR_23);
		}
	}

	/* COMMENT_8 */
	Timing::Timer VAR_24;
	IR::ValueTuple VAR_25 = invokeFunctionChecked(VAR_8, VAR_16, VAR_18);
	Timing::logTimer(""Invoked function"", VAR_24);

	if(VAR_0.functionName)
	{
		Log::printf(Log::debug,
					""%s returned: %s\n"",
					VAR_0.functionName,
					asString(VAR_25).c_str());
		return VAR_3;
	}
	else if(VAR_25.size() == 1 && VAR_25[0].type == ValueType::i32)
	{
		return VAR_25[0].i32;
	}
	else
	{
		return VAR_3;
	}
}",WAVM/31d670b6489e6d708c3b04b911cdf14ac43d846d/wavm.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -116,21 +116,23 @@
 	{
 		if(functionType.params().size() == 2)
 		{
-			MemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);
-			if(!defaultMemory)
+			if(!emscriptenInstance)
 			{
 				Log::printf(
 					Log::error,
 					""Module does not declare a default memory object to put arguments in.\n"");
 				return EXIT_FAILURE;
 			}
+			else
+			{
+				std::vector<const char*> argStrings;
+				argStrings.push_back(options.filename);
+				char** args = options.args;
+				while(*args) { argStrings.push_back(*args++); };
 
-			std::vector<const char*> argStrings;
-			argStrings.push_back(options.filename);
-			char** args = options.args;
-			while(*args) { argStrings.push_back(*args++); };
-
-			Emscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);
+				wavmAssert(emscriptenInstance);
+				Emscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);
+			}
 		}
 		else if(functionType.params().size() > 0)
 		{","{'deleted_lines': ['\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);', '\t\t\tif(!defaultMemory)', '\t\t\tstd::vector<const char*> argStrings;', '\t\t\targStrings.push_back(options.filename);', '\t\t\tchar** args = options.args;', '\t\t\twhile(*args) { argStrings.push_back(*args++); };', '', '\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);'], 'added_lines': ['\t\t\tif(!emscriptenInstance)', '\t\t\telse', '\t\t\t{', '\t\t\t\tstd::vector<const char*> argStrings;', '\t\t\t\targStrings.push_back(options.filename);', '\t\t\t\tchar** args = options.args;', '\t\t\t\twhile(*args) { argStrings.push_back(*args++); };', '\t\t\t\twavmAssert(emscriptenInstance);', '\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);', '\t\t\t}']}",True,"An issue was discovered in WAVM before 2018-09-16. The run function in Programs/wavm/wavm.cpp does not check whether there is Emscripten memory to store the command-line arguments passed by the input WebAssembly file's main function, which allows attackers to cause a denial of service (application crash by NULL pointer dereference) or possibly have unspecified other impact by crafting certain WebAssembly files.",8.8,HIGH,2,test,2018-09-16T13:55:34Z,2
CVE-2019-1010297,"['CWE-190', 'CWE-787']",AV:N/AC:L/Au:N/C:C/I:C/A:C,0.0,OP-TEE/optee_os,"svc: check for allocation overflow in crypto calls

Without checking for overflow there is a risk of allocating a buffer
with size smaller than anticipated and as a consequence of that it might
lead to a heap based overflow with attacker controlled data written
outside the boundaries of the buffer.

Fixes: OP-TEE-2018-0010: ""Integer overflow in crypto system calls (x2)""

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Tested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>
Reported-by: Riscure <inforequest@riscure.com>
Reported-by: Alyssa Milburn <a.a.milburn@vu.nl>
Acked-by: Etienne Carriere <etienne.carriere@linaro.org>",a637243270fc1faae16de059091795c32d86e65e,https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e,core/tee/tee_svc_cryp.c,syscall_cryp_derive_key,"TEE_Result syscall_cryp_derive_key(unsigned long state,
const struct utee_attribute *usr_params,
unsigned long param_count, unsigned long derived_key)
{
TEE_Result res = TEE_ERROR_NOT_SUPPORTED;
struct tee_ta_session *sess;
struct tee_obj *ko;
struct tee_obj *so;
struct tee_cryp_state *cs;
struct tee_cryp_obj_secret *sk;
const struct tee_cryp_obj_type_props *type_props;
TEE_Attribute *params = NULL;
struct user_ta_ctx *utc;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
utc = to_user_ta_ctx(sess->ctx);
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
params = malloc(sizeof(TEE_Attribute) * param_count);
if (!params)
return TEE_ERROR_OUT_OF_MEMORY;
res = copy_in_attrs(utc, usr_params, param_count, params);
if (res != TEE_SUCCESS)
goto out;
res = tee_obj_get(utc, cs->key1, &ko);
if (res != TEE_SUCCESS)
goto out;
res = tee_obj_get(utc, tee_svc_uref_to_vaddr(derived_key), &so);
if (res != TEE_SUCCESS)
goto out;
sk = so->attr;
type_props = tee_svc_find_type_props(so->info.objectType);
if (!type_props) {
res = TEE_ERROR_NOT_SUPPORTED;
goto out;
}
if (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {
size_t alloc_size;
struct bignum *pub;
struct bignum *ss;
if (param_count != 1 ||
params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
alloc_size = params[0].content.ref.length * 8;
pub = crypto_bignum_allocate(alloc_size);
ss = crypto_bignum_allocate(alloc_size);
if (pub && ss) {
crypto_bignum_bin2bn(params[0].content.ref.buffer,
params[0].content.ref.length, pub);
res = crypto_acipher_dh_shared_secret(ko->attr,
pub, ss);
if (res == TEE_SUCCESS) {
sk->key_size = crypto_bignum_num_bytes(ss);
crypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));
so->info.handleFlags |=
TEE_HANDLE_FLAG_INITIALIZED;
set_attribute(so, type_props,
TEE_ATTR_SECRET_VALUE);
}
} else {
res = TEE_ERROR_OUT_OF_MEMORY;
}
crypto_bignum_free(pub);
crypto_bignum_free(ss);
} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {
size_t alloc_size;
struct ecc_public_key key_public;
uint8_t *pt_secret;
unsigned long pt_secret_len;
if (param_count != 2 ||
params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||
params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
switch (cs->algo) {
case TEE_ALG_ECDH_P192:
alloc_size = 192;
break;
case TEE_ALG_ECDH_P224:
alloc_size = 224;
break;
case TEE_ALG_ECDH_P256:
alloc_size = 256;
break;
case TEE_ALG_ECDH_P384:
alloc_size = 384;
break;
case TEE_ALG_ECDH_P521:
alloc_size = 521;
break;
default:
res = TEE_ERROR_NOT_IMPLEMENTED;
goto out;
}
res = crypto_acipher_alloc_ecc_public_key(&key_public,
alloc_size);
if (res != TEE_SUCCESS)
goto out;
key_public.curve = ((struct ecc_keypair *)ko->attr)->curve;
crypto_bignum_bin2bn(params[0].content.ref.buffer,
params[0].content.ref.length,
key_public.x);
crypto_bignum_bin2bn(params[1].content.ref.buffer,
params[1].content.ref.length,
key_public.y);
pt_secret = (uint8_t *)(sk + 1);
pt_secret_len = sk->alloc_size;
res = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,
pt_secret,
&pt_secret_len);
if (res == TEE_SUCCESS) {
sk->key_size = pt_secret_len;
so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
}
crypto_acipher_free_ecc_public_key(&key_public);
}
#if defined(CFG_CRYPTO_HKDF)
else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {
void *salt, *info;
size_t salt_len, info_len, okm_len;
uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);
struct tee_cryp_obj_secret *ik = ko->attr;
const uint8_t *ikm = (const uint8_t *)(ik + 1);
res = get_hkdf_params(params, param_count, &salt, &salt_len,
&info, &info_len, &okm_len);
if (res != TEE_SUCCESS)
goto out;
if (okm_len > ik->alloc_size) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
res = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,
info, info_len, (uint8_t *)(sk + 1),
okm_len);
if (res == TEE_SUCCESS) {
sk->key_size = okm_len;
so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
}
}
#endif
#if defined(CFG_CRYPTO_CONCAT_KDF)
else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {
void *info;
size_t info_len, derived_key_len;
uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);
struct tee_cryp_obj_secret *ss = ko->attr;
const uint8_t *shared_secret = (const uint8_t *)(ss + 1);
res = get_concat_kdf_params(params, param_count, &info,
&info_len, &derived_key_len);
if (res != TEE_SUCCESS)
goto out;
if (derived_key_len > ss->alloc_size) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
res = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,
info, info_len, (uint8_t *)(sk + 1),
derived_key_len);
if (res == TEE_SUCCESS) {
sk->key_size = derived_key_len;
so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
}
}
#endif
#if defined(CFG_CRYPTO_PBKDF2)
else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {
void *salt;
size_t salt_len, iteration_count, derived_key_len;
uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);
struct tee_cryp_obj_secret *ss = ko->attr;
const uint8_t *password = (const uint8_t *)(ss + 1);
res = get_pbkdf2_params(params, param_count, &salt, &salt_len,
&derived_key_len, &iteration_count);
if (res != TEE_SUCCESS)
goto out;
if (derived_key_len > ss->alloc_size) {
res = TEE_ERROR_BAD_PARAMETERS;
goto out;
}
res = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,
salt_len, iteration_count,
(uint8_t *)(sk + 1), derived_key_len);
if (res == TEE_SUCCESS) {
sk->key_size = derived_key_len;
so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
}
}
#endif
else
res = TEE_ERROR_NOT_SUPPORTED;
out:
free(params);
return res;
}","TEE_Result syscall_cryp_derive_key(unsigned long VAR_0,
const struct utee_attribute *VAR_1,
unsigned long VAR_2, unsigned long VAR_3)
{
TEE_Result VAR_4 = VAR_5;
struct tee_ta_session *VAR_6;
struct tee_obj *VAR_7;
struct tee_obj *VAR_8;
struct tee_cryp_state *VAR_9;
struct tee_cryp_obj_secret *VAR_10;
const struct tee_cryp_obj_type_props *VAR_11;
TEE_Attribute *VAR_12 = NULL;
struct user_ta_ctx *VAR_13;
VAR_4 = tee_ta_get_current_session(&VAR_6);
if (VAR_4 != VAR_14)
return VAR_4;
VAR_13 = to_user_ta_ctx(VAR_6->ctx);
VAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);
if (VAR_4 != VAR_14)
return VAR_4;
VAR_12 = malloc(sizeof(TEE_Attribute) * VAR_2);
if (!VAR_12)
return VAR_15;
VAR_4 = copy_in_attrs(VAR_13, VAR_1, VAR_2, VAR_12);
if (VAR_4 != VAR_14)
goto out;
VAR_4 = tee_obj_get(VAR_13, VAR_9->key1, &VAR_7);
if (VAR_4 != VAR_14)
goto out;
VAR_4 = tee_obj_get(VAR_13, tee_svc_uref_to_vaddr(VAR_3), &VAR_8);
if (VAR_4 != VAR_14)
goto out;
VAR_10 = VAR_8->attr;
VAR_11 = tee_svc_find_type_props(VAR_8->info.objectType);
if (!VAR_11) {
VAR_4 = VAR_5;
goto out;
}
if (VAR_9->algo == VAR_16) {
size_t VAR_17;
struct bignum *VAR_18;
struct bignum *VAR_19;
if (VAR_2 != 1 ||
VAR_12[0].attributeID != VAR_20) {
VAR_4 = VAR_21;
goto out;
}
VAR_17 = VAR_12[0].content.ref.length * 8;
VAR_18 = crypto_bignum_allocate(VAR_17);
VAR_19 = crypto_bignum_allocate(VAR_17);
if (VAR_18 && VAR_19) {
crypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,
VAR_12[0].content.ref.length, VAR_18);
VAR_4 = crypto_acipher_dh_shared_secret(VAR_7->attr,
VAR_18, VAR_19);
if (VAR_4 == VAR_14) {
VAR_10->key_size = crypto_bignum_num_bytes(VAR_19);
crypto_bignum_bn2bin(VAR_19, (uint8_t *)(VAR_10 + 1));
VAR_8->info.handleFlags |=
VAR_22;
set_attribute(VAR_8, VAR_11,
VAR_23);
}
} else {
VAR_4 = VAR_15;
}
crypto_bignum_free(VAR_18);
crypto_bignum_free(VAR_19);
} else if (TEE_ALG_GET_MAIN_ALG(VAR_9->algo) == VAR_24) {
size_t VAR_17;
struct ecc_public_key VAR_25;
uint8_t *VAR_26;
unsigned long VAR_27;
if (VAR_2 != 2 ||
VAR_12[0].attributeID != VAR_28 ||
VAR_12[1].attributeID != VAR_29) {
VAR_4 = VAR_21;
goto out;
}
switch (VAR_9->algo) {
case VAR_30:
VAR_17 = 192;
break;
case VAR_31:
VAR_17 = 224;
break;
case VAR_32:
VAR_17 = 256;
break;
case VAR_33:
VAR_17 = 384;
break;
case VAR_34:
VAR_17 = 521;
break;
default:
VAR_4 = VAR_35;
goto out;
}
VAR_4 = crypto_acipher_alloc_ecc_public_key(&VAR_25,
VAR_17);
if (VAR_4 != VAR_14)
goto out;
VAR_25.curve = ((struct ecc_keypair *)VAR_7->attr)->curve;
crypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,
VAR_12[0].content.ref.length,
VAR_25.x);
crypto_bignum_bin2bn(VAR_12[1].content.ref.buffer,
VAR_12[1].content.ref.length,
VAR_25.y);
VAR_26 = (uint8_t *)(VAR_10 + 1);
VAR_27 = VAR_10->alloc_size;
VAR_4 = crypto_acipher_ecc_shared_secret(VAR_7->attr, &VAR_25,
VAR_26,
&VAR_27);
if (VAR_4 == VAR_14) {
VAR_10->key_size = VAR_27;
VAR_8->info.handleFlags |= VAR_22;
set_attribute(VAR_8, VAR_11, VAR_23);
}
crypto_acipher_free_ecc_public_key(&VAR_25);
}
#if defined(VAR_36)
else if (VAR_37(cs->VAR_38) == VAR_39) {
void *VAR_40, *VAR_41;
size_t VAR_42, VAR_43, VAR_44;
uint32_t VAR_45 = TEE_ALG_GET_DIGEST_HASH(cs->algo);
struct tee_cryp_obj_secret *VAR_46 = VAR_7->attr;
const uint8_t *VAR_47 = (const uint8_t *)(VAR_46 + 1);
VAR_4 = get_hkdf_params(VAR_12, VAR_2, &VAR_40, &VAR_42,
&VAR_41, &VAR_43, &VAR_44);
if (VAR_4 != VAR_14)
goto out;
if (VAR_44 > VAR_46->alloc_size) {
VAR_4 = VAR_21;
goto out;
}
VAR_4 = tee_cryp_hkdf(VAR_45, VAR_47, VAR_46->key_size, VAR_40, VAR_42,
VAR_41, VAR_43, (uint8_t *)(VAR_10 + 1),
VAR_44);
if (VAR_4 == VAR_14) {
VAR_10->key_size = VAR_44;
VAR_8->info.handleFlags |= VAR_22;
set_attribute(VAR_8, VAR_11, VAR_23);
}
}
#endif
#if defined(VAR_48)
else if (VAR_37(cs->VAR_38) == VAR_49) {
void *VAR_41;
size_t VAR_43, VAR_50;
uint32_t VAR_45 = TEE_ALG_GET_DIGEST_HASH(cs->algo);
struct tee_cryp_obj_secret *VAR_19 = VAR_7->attr;
const uint8_t *VAR_51 = (const uint8_t *)(VAR_19 + 1);
VAR_4 = get_concat_kdf_params(VAR_12, VAR_2, &VAR_41,
&VAR_43, &VAR_50);
if (VAR_4 != VAR_14)
goto out;
if (VAR_50 > VAR_19->alloc_size) {
VAR_4 = VAR_21;
goto out;
}
VAR_4 = tee_cryp_concat_kdf(VAR_45, VAR_51, VAR_19->key_size,
VAR_41, VAR_43, (uint8_t *)(VAR_10 + 1),
VAR_50);
if (VAR_4 == VAR_14) {
VAR_10->key_size = VAR_50;
VAR_8->info.handleFlags |= VAR_22;
set_attribute(VAR_8, VAR_11, VAR_23);
}
}
#endif
#if defined(VAR_52)
else if (VAR_37(cs->VAR_38) == VAR_53) {
void *VAR_40;
size_t VAR_42, VAR_54, VAR_50;
uint32_t VAR_45 = TEE_ALG_GET_DIGEST_HASH(cs->algo);
struct tee_cryp_obj_secret *VAR_19 = VAR_7->attr;
const uint8_t *VAR_55 = (const uint8_t *)(VAR_19 + 1);
VAR_4 = get_pbkdf2_params(VAR_12, VAR_2, &VAR_40, &VAR_42,
&VAR_50, &VAR_54);
if (VAR_4 != VAR_14)
goto out;
if (VAR_50 > VAR_19->alloc_size) {
VAR_4 = VAR_21;
goto out;
}
VAR_4 = tee_cryp_pbkdf2(VAR_45, VAR_55, VAR_19->key_size, VAR_40,
VAR_42, VAR_54,
(uint8_t *)(VAR_10 + 1), VAR_50);
if (VAR_4 == VAR_14) {
VAR_10->key_size = VAR_50;
VAR_8->info.handleFlags |= VAR_22;
set_attribute(VAR_8, VAR_11, VAR_23);
}
}
#endif
else
VAR_4 = VAR_5;
out:
free(VAR_12);
return VAR_4;
}",OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/before/0.json,"TEE_Result syscall_cryp_derive_key(unsigned long state,
			const struct utee_attribute *usr_params,
			unsigned long param_count, unsigned long derived_key)
{
	TEE_Result res = TEE_ERROR_NOT_SUPPORTED;
	struct tee_ta_session *sess;
	struct tee_obj *ko;
	struct tee_obj *so;
	struct tee_cryp_state *cs;
	struct tee_cryp_obj_secret *sk;
	const struct tee_cryp_obj_type_props *type_props;
	TEE_Attribute *params = NULL;
	struct user_ta_ctx *utc;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	utc = to_user_ta_ctx(sess->ctx);

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
	if (!params)
		return TEE_ERROR_OUT_OF_MEMORY;
	res = copy_in_attrs(utc, usr_params, param_count, params);
	if (res != TEE_SUCCESS)
		goto out;

	/* Get key set in operation */
	res = tee_obj_get(utc, cs->key1, &ko);
	if (res != TEE_SUCCESS)
		goto out;

	res = tee_obj_get(utc, tee_svc_uref_to_vaddr(derived_key), &so);
	if (res != TEE_SUCCESS)
		goto out;

	/* Find information needed about the object to initialize */
	sk = so->attr;

	/* Find description of object */
	type_props = tee_svc_find_type_props(so->info.objectType);
	if (!type_props) {
		res = TEE_ERROR_NOT_SUPPORTED;
		goto out;
	}

	if (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {
		size_t alloc_size;
		struct bignum *pub;
		struct bignum *ss;

		if (param_count != 1 ||
		    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {
			res = TEE_ERROR_BAD_PARAMETERS;
			goto out;
		}

		alloc_size = params[0].content.ref.length * 8;
		pub = crypto_bignum_allocate(alloc_size);
		ss = crypto_bignum_allocate(alloc_size);
		if (pub && ss) {
			crypto_bignum_bin2bn(params[0].content.ref.buffer,
					     params[0].content.ref.length, pub);
			res = crypto_acipher_dh_shared_secret(ko->attr,
							      pub, ss);
			if (res == TEE_SUCCESS) {
				sk->key_size = crypto_bignum_num_bytes(ss);
				crypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));
				so->info.handleFlags |=
						TEE_HANDLE_FLAG_INITIALIZED;
				set_attribute(so, type_props,
					      TEE_ATTR_SECRET_VALUE);
			}
		} else {
			res = TEE_ERROR_OUT_OF_MEMORY;
		}
		crypto_bignum_free(pub);
		crypto_bignum_free(ss);
	} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {
		size_t alloc_size;
		struct ecc_public_key key_public;
		uint8_t *pt_secret;
		unsigned long pt_secret_len;

		if (param_count != 2 ||
		    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||
		    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {
			res = TEE_ERROR_BAD_PARAMETERS;
			goto out;
		}

		switch (cs->algo) {
		case TEE_ALG_ECDH_P192:
			alloc_size = 192;
			break;
		case TEE_ALG_ECDH_P224:
			alloc_size = 224;
			break;
		case TEE_ALG_ECDH_P256:
			alloc_size = 256;
			break;
		case TEE_ALG_ECDH_P384:
			alloc_size = 384;
			break;
		case TEE_ALG_ECDH_P521:
			alloc_size = 521;
			break;
		default:
			res = TEE_ERROR_NOT_IMPLEMENTED;
			goto out;
		}

		/* Create the public key */
		res = crypto_acipher_alloc_ecc_public_key(&key_public,
							  alloc_size);
		if (res != TEE_SUCCESS)
			goto out;
		key_public.curve = ((struct ecc_keypair *)ko->attr)->curve;
		crypto_bignum_bin2bn(params[0].content.ref.buffer,
				     params[0].content.ref.length,
				     key_public.x);
		crypto_bignum_bin2bn(params[1].content.ref.buffer,
				     params[1].content.ref.length,
				     key_public.y);

		pt_secret = (uint8_t *)(sk + 1);
		pt_secret_len = sk->alloc_size;
		res = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,
						       pt_secret,
						       &pt_secret_len);

		if (res == TEE_SUCCESS) {
			sk->key_size = pt_secret_len;
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
		}

		/* free the public key */
		crypto_acipher_free_ecc_public_key(&key_public);
	}
#if defined(CFG_CRYPTO_HKDF)
	else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {
		void *salt, *info;
		size_t salt_len, info_len, okm_len;
		uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);
		struct tee_cryp_obj_secret *ik = ko->attr;
		const uint8_t *ikm = (const uint8_t *)(ik + 1);

		res = get_hkdf_params(params, param_count, &salt, &salt_len,
				      &info, &info_len, &okm_len);
		if (res != TEE_SUCCESS)
			goto out;

		/* Requested size must fit into the output object's buffer */
		if (okm_len > ik->alloc_size) {
			res = TEE_ERROR_BAD_PARAMETERS;
			goto out;
		}

		res = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,
				    info, info_len, (uint8_t *)(sk + 1),
				    okm_len);
		if (res == TEE_SUCCESS) {
			sk->key_size = okm_len;
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
		}
	}
#endif
#if defined(CFG_CRYPTO_CONCAT_KDF)
	else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {
		void *info;
		size_t info_len, derived_key_len;
		uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);
		struct tee_cryp_obj_secret *ss = ko->attr;
		const uint8_t *shared_secret = (const uint8_t *)(ss + 1);

		res = get_concat_kdf_params(params, param_count, &info,
					    &info_len, &derived_key_len);
		if (res != TEE_SUCCESS)
			goto out;

		/* Requested size must fit into the output object's buffer */
		if (derived_key_len > ss->alloc_size) {
			res = TEE_ERROR_BAD_PARAMETERS;
			goto out;
		}

		res = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,
					  info, info_len, (uint8_t *)(sk + 1),
					  derived_key_len);
		if (res == TEE_SUCCESS) {
			sk->key_size = derived_key_len;
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
		}
	}
#endif
#if defined(CFG_CRYPTO_PBKDF2)
	else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {
		void *salt;
		size_t salt_len, iteration_count, derived_key_len;
		uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);
		struct tee_cryp_obj_secret *ss = ko->attr;
		const uint8_t *password = (const uint8_t *)(ss + 1);

		res = get_pbkdf2_params(params, param_count, &salt, &salt_len,
					&derived_key_len, &iteration_count);
		if (res != TEE_SUCCESS)
			goto out;

		/* Requested size must fit into the output object's buffer */
		if (derived_key_len > ss->alloc_size) {
			res = TEE_ERROR_BAD_PARAMETERS;
			goto out;
		}

		res = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,
				      salt_len, iteration_count,
				      (uint8_t *)(sk + 1), derived_key_len);
		if (res == TEE_SUCCESS) {
			sk->key_size = derived_key_len;
			so->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
			set_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);
		}
	}
#endif
	else
		res = TEE_ERROR_NOT_SUPPORTED;

out:
	free(params);
	return res;
}","TEE_Result syscall_cryp_derive_key(unsigned long VAR_0,
			const struct utee_attribute *VAR_1,
			unsigned long VAR_2, unsigned long VAR_3)
{
	TEE_Result VAR_4 = VAR_5;
	struct tee_ta_session *VAR_6;
	struct tee_obj *VAR_7;
	struct tee_obj *VAR_8;
	struct tee_cryp_state *VAR_9;
	struct tee_cryp_obj_secret *VAR_10;
	const struct tee_cryp_obj_type_props *VAR_11;
	TEE_Attribute *VAR_12 = NULL;
	struct user_ta_ctx *VAR_13;

	VAR_4 = tee_ta_get_current_session(&VAR_6);
	if (VAR_4 != VAR_14)
		return VAR_4;
	VAR_13 = to_user_ta_ctx(VAR_6->ctx);

	VAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);
	if (VAR_4 != VAR_14)
		return VAR_4;

	size_t VAR_15 = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), VAR_2, &VAR_15))
		return VAR_16;

	VAR_12 = malloc(VAR_15);
	if (!VAR_12)
		return VAR_17;
	VAR_4 = copy_in_attrs(VAR_13, VAR_1, VAR_2, VAR_12);
	if (VAR_4 != VAR_14)
		goto out;

	/* COMMENT_0 */
	VAR_4 = tee_obj_get(VAR_13, VAR_9->key1, &VAR_7);
	if (VAR_4 != VAR_14)
		goto out;

	VAR_4 = tee_obj_get(VAR_13, tee_svc_uref_to_vaddr(VAR_3), &VAR_8);
	if (VAR_4 != VAR_14)
		goto out;

	/* COMMENT_1 */
	VAR_10 = VAR_8->attr;

	/* COMMENT_2 */
	VAR_11 = tee_svc_find_type_props(VAR_8->info.objectType);
	if (!VAR_11) {
		VAR_4 = VAR_5;
		goto out;
	}

	if (VAR_9->algo == VAR_18) {
		size_t VAR_15;
		struct bignum *VAR_19;
		struct bignum *VAR_20;

		if (VAR_2 != 1 ||
		    VAR_12[0].attributeID != VAR_21) {
			VAR_4 = VAR_22;
			goto out;
		}

		VAR_15 = VAR_12[0].content.ref.length * 8;
		VAR_19 = crypto_bignum_allocate(VAR_15);
		VAR_20 = crypto_bignum_allocate(VAR_15);
		if (VAR_19 && VAR_20) {
			crypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,
					     VAR_12[0].content.ref.length, VAR_19);
			VAR_4 = crypto_acipher_dh_shared_secret(VAR_7->attr,
							      VAR_19, VAR_20);
			if (VAR_4 == VAR_14) {
				VAR_10->key_size = crypto_bignum_num_bytes(VAR_20);
				crypto_bignum_bn2bin(VAR_20, (uint8_t *)(VAR_10 + 1));
				VAR_8->info.handleFlags |=
						VAR_23;
				set_attribute(VAR_8, VAR_11,
					      VAR_24);
			}
		} else {
			VAR_4 = VAR_17;
		}
		crypto_bignum_free(VAR_19);
		crypto_bignum_free(VAR_20);
	} else if (TEE_ALG_GET_MAIN_ALG(VAR_9->algo) == VAR_25) {
		size_t VAR_15;
		struct ecc_public_key VAR_26;
		uint8_t *VAR_27;
		unsigned long VAR_28;

		if (VAR_2 != 2 ||
		    VAR_12[0].attributeID != VAR_29 ||
		    VAR_12[1].attributeID != VAR_30) {
			VAR_4 = VAR_22;
			goto out;
		}

		switch (VAR_9->algo) {
		case VAR_31:
			VAR_15 = 192;
			break;
		case VAR_32:
			VAR_15 = 224;
			break;
		case VAR_33:
			VAR_15 = 256;
			break;
		case VAR_34:
			VAR_15 = 384;
			break;
		case VAR_35:
			VAR_15 = 521;
			break;
		default:
			VAR_4 = VAR_36;
			goto out;
		}

		/* COMMENT_3 */
		VAR_4 = crypto_acipher_alloc_ecc_public_key(&VAR_26,
							  VAR_15);
		if (VAR_4 != VAR_14)
			goto out;
		VAR_26.curve = ((struct ecc_keypair *)VAR_7->attr)->curve;
		crypto_bignum_bin2bn(VAR_12[0].content.ref.buffer,
				     VAR_12[0].content.ref.length,
				     VAR_26.x);
		crypto_bignum_bin2bn(VAR_12[1].content.ref.buffer,
				     VAR_12[1].content.ref.length,
				     VAR_26.y);

		VAR_27 = (uint8_t *)(VAR_10 + 1);
		VAR_28 = VAR_10->alloc_size;
		VAR_4 = crypto_acipher_ecc_shared_secret(VAR_7->attr, &VAR_26,
						       VAR_27,
						       &VAR_28);

		if (VAR_4 == VAR_14) {
			VAR_10->key_size = VAR_28;
			VAR_8->info.handleFlags |= VAR_23;
			set_attribute(VAR_8, VAR_11, VAR_24);
		}

		/* COMMENT_4 */
		crypto_acipher_free_ecc_public_key(&VAR_26);
	}
#if defined(VAR_37)
	else if (VAR_38(cs->VAR_39) == VAR_40) {
		void *VAR_41, *VAR_42;
		size_t VAR_43, VAR_44, VAR_45;
		uint32_t VAR_46 = TEE_ALG_GET_DIGEST_HASH(cs->algo);
		struct tee_cryp_obj_secret *VAR_47 = VAR_7->attr;
		const uint8_t *VAR_48 = (const uint8_t *)(VAR_47 + 1);

		VAR_4 = get_hkdf_params(VAR_12, VAR_2, &VAR_41, &VAR_43,
				      &VAR_42, &VAR_44, &VAR_45);
		if (VAR_4 != VAR_14)
			goto out;

		/* COMMENT_5 */
		if (VAR_45 > VAR_47->alloc_size) {
			VAR_4 = VAR_22;
			goto out;
		}

		VAR_4 = tee_cryp_hkdf(VAR_46, VAR_48, VAR_47->key_size, VAR_41, VAR_43,
				    VAR_42, VAR_44, (uint8_t *)(VAR_10 + 1),
				    VAR_45);
		if (VAR_4 == VAR_14) {
			VAR_10->key_size = VAR_45;
			VAR_8->info.handleFlags |= VAR_23;
			set_attribute(VAR_8, VAR_11, VAR_24);
		}
	}
#endif
#if defined(VAR_49)
	else if (VAR_38(cs->VAR_39) == VAR_50) {
		void *VAR_42;
		size_t VAR_44, VAR_51;
		uint32_t VAR_46 = TEE_ALG_GET_DIGEST_HASH(cs->algo);
		struct tee_cryp_obj_secret *VAR_20 = VAR_7->attr;
		const uint8_t *VAR_52 = (const uint8_t *)(VAR_20 + 1);

		VAR_4 = get_concat_kdf_params(VAR_12, VAR_2, &VAR_42,
					    &VAR_44, &VAR_51);
		if (VAR_4 != VAR_14)
			goto out;

		/* COMMENT_5 */
		if (VAR_51 > VAR_20->alloc_size) {
			VAR_4 = VAR_22;
			goto out;
		}

		VAR_4 = tee_cryp_concat_kdf(VAR_46, VAR_52, VAR_20->key_size,
					  VAR_42, VAR_44, (uint8_t *)(VAR_10 + 1),
					  VAR_51);
		if (VAR_4 == VAR_14) {
			VAR_10->key_size = VAR_51;
			VAR_8->info.handleFlags |= VAR_23;
			set_attribute(VAR_8, VAR_11, VAR_24);
		}
	}
#endif
#if defined(VAR_53)
	else if (VAR_38(cs->VAR_39) == VAR_54) {
		void *VAR_41;
		size_t VAR_43, VAR_55, VAR_51;
		uint32_t VAR_46 = TEE_ALG_GET_DIGEST_HASH(cs->algo);
		struct tee_cryp_obj_secret *VAR_20 = VAR_7->attr;
		const uint8_t *VAR_56 = (const uint8_t *)(VAR_20 + 1);

		VAR_4 = get_pbkdf2_params(VAR_12, VAR_2, &VAR_41, &VAR_43,
					&VAR_51, &VAR_55);
		if (VAR_4 != VAR_14)
			goto out;

		/* COMMENT_5 */
		if (VAR_51 > VAR_20->alloc_size) {
			VAR_4 = VAR_22;
			goto out;
		}

		VAR_4 = tee_cryp_pbkdf2(VAR_46, VAR_56, VAR_20->key_size, VAR_41,
				      VAR_43, VAR_55,
				      (uint8_t *)(VAR_10 + 1), VAR_51);
		if (VAR_4 == VAR_14) {
			VAR_10->key_size = VAR_51;
			VAR_8->info.handleFlags |= VAR_23;
			set_attribute(VAR_8, VAR_11, VAR_24);
		}
	}
#endif
	else
		VAR_4 = VAR_5;

out:
	free(VAR_12);
	return VAR_4;
}",OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,7 +21,12 @@
 	if (res != TEE_SUCCESS)
 		return res;
 
-	params = malloc(sizeof(TEE_Attribute) * param_count);
+	size_t alloc_size = 0;
+
+	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
+		return TEE_ERROR_OVERFLOW;
+
+	params = malloc(alloc_size);
 	if (!params)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	res = copy_in_attrs(utc, usr_params, param_count, params);","{'deleted_lines': ['\tparams = malloc(sizeof(TEE_Attribute) * param_count);'], 'added_lines': ['\tsize_t alloc_size = 0;', '', '\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))', '\t\treturn TEE_ERROR_OVERFLOW;', '', '\tparams = malloc(alloc_size);']}",True,Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Execution of code in TEE core (kernel) context. The component is: optee_os. The fixed version is: 3.4.0 and later.,9.8,CRITICAL,3,test,2018-09-27T08:24:26Z,2
CVE-2019-1010297,"['CWE-190', 'CWE-787']",AV:N/AC:L/Au:N/C:C/I:C/A:C,0.0,OP-TEE/optee_os,"svc: check for allocation overflow in crypto calls

Without checking for overflow there is a risk of allocating a buffer
with size smaller than anticipated and as a consequence of that it might
lead to a heap based overflow with attacker controlled data written
outside the boundaries of the buffer.

Fixes: OP-TEE-2018-0010: ""Integer overflow in crypto system calls (x2)""

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Tested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>
Reported-by: Riscure <inforequest@riscure.com>
Reported-by: Alyssa Milburn <a.a.milburn@vu.nl>
Acked-by: Etienne Carriere <etienne.carriere@linaro.org>",a637243270fc1faae16de059091795c32d86e65e,https://github.com/OP-TEE/optee_os/commit/a637243270fc1faae16de059091795c32d86e65e,core/tee/tee_svc_cryp.c,syscall_obj_generate_key,"TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,
const struct utee_attribute *usr_params,
unsigned long param_count)
{
TEE_Result res;
struct tee_ta_session *sess;
const struct tee_cryp_obj_type_props *type_props;
struct tee_obj *o;
struct tee_cryp_obj_secret *key;
size_t byte_size;
TEE_Attribute *params = NULL;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_obj_get(to_user_ta_ctx(sess->ctx),
tee_svc_uref_to_vaddr(obj), &o);
if (res != TEE_SUCCESS)
return res;
if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)
return TEE_ERROR_BAD_STATE;
if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)
return TEE_ERROR_BAD_STATE;
type_props = tee_svc_find_type_props(o->info.objectType);
if (!type_props)
return TEE_ERROR_NOT_SUPPORTED;
if (key_size % type_props->quanta != 0)
return TEE_ERROR_NOT_SUPPORTED;
if (key_size < type_props->min_size)
return TEE_ERROR_NOT_SUPPORTED;
if (key_size > type_props->max_size)
return TEE_ERROR_NOT_SUPPORTED;
params = malloc(sizeof(TEE_Attribute) * param_count);
if (!params)
return TEE_ERROR_OUT_OF_MEMORY;
res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,
params);
if (res != TEE_SUCCESS)
goto out;
res = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,
params, param_count);
if (res != TEE_SUCCESS)
goto out;
switch (o->info.objectType) {
case TEE_TYPE_AES:
case TEE_TYPE_DES:
case TEE_TYPE_DES3:
case TEE_TYPE_HMAC_MD5:
case TEE_TYPE_HMAC_SHA1:
case TEE_TYPE_HMAC_SHA224:
case TEE_TYPE_HMAC_SHA256:
case TEE_TYPE_HMAC_SHA384:
case TEE_TYPE_HMAC_SHA512:
case TEE_TYPE_GENERIC_SECRET:
byte_size = key_size / 8;
if (o->info.objectType == TEE_TYPE_DES ||
o->info.objectType == TEE_TYPE_DES3) {
byte_size = (key_size + key_size / 7) / 8;
}
key = (struct tee_cryp_obj_secret *)o->attr;
if (byte_size > key->alloc_size) {
res = TEE_ERROR_EXCESS_DATA;
goto out;
}
res = crypto_rng_read((void *)(key + 1), byte_size);
if (res != TEE_SUCCESS)
goto out;
key->key_size = byte_size;
o->have_attrs = (1 << type_props->num_type_attrs) - 1;
break;
case TEE_TYPE_RSA_KEYPAIR:
res = tee_svc_obj_generate_key_rsa(o, type_props, key_size,
params, param_count);
if (res != TEE_SUCCESS)
goto out;
break;
case TEE_TYPE_DSA_KEYPAIR:
res = tee_svc_obj_generate_key_dsa(o, type_props, key_size);
if (res != TEE_SUCCESS)
goto out;
break;
case TEE_TYPE_DH_KEYPAIR:
res = tee_svc_obj_generate_key_dh(o, type_props, key_size,
params, param_count);
if (res != TEE_SUCCESS)
goto out;
break;
case TEE_TYPE_ECDSA_KEYPAIR:
case TEE_TYPE_ECDH_KEYPAIR:
res = tee_svc_obj_generate_key_ecc(o, type_props, key_size,
params, param_count);
if (res != TEE_SUCCESS)
goto out;
break;
default:
res = TEE_ERROR_BAD_FORMAT;
}
out:
free(params);
if (res == TEE_SUCCESS) {
o->info.keySize = key_size;
o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
}
return res;
}","TEE_Result syscall_obj_generate_key(unsigned long VAR_0, unsigned long VAR_1,
const struct utee_attribute *VAR_2,
unsigned long VAR_3)
{
TEE_Result VAR_4;
struct tee_ta_session *VAR_5;
const struct tee_cryp_obj_type_props *VAR_6;
struct tee_obj *VAR_7;
struct tee_cryp_obj_secret *VAR_8;
size_t VAR_9;
TEE_Attribute *VAR_10 = NULL;
VAR_4 = tee_ta_get_current_session(&VAR_5);
if (VAR_4 != VAR_11)
return VAR_4;
VAR_4 = tee_obj_get(to_user_ta_ctx(VAR_5->ctx),
tee_svc_uref_to_vaddr(VAR_0), &VAR_7);
if (VAR_4 != VAR_11)
return VAR_4;
if ((VAR_7->info.handleFlags & VAR_12) != 0)
return VAR_13;
if ((VAR_7->info.handleFlags & VAR_14) != 0)
return VAR_13;
VAR_6 = tee_svc_find_type_props(VAR_7->info.objectType);
if (!VAR_6)
return VAR_15;
if (VAR_1 % VAR_6->quanta != 0)
return VAR_15;
if (VAR_1 < VAR_6->min_size)
return VAR_15;
if (VAR_1 > VAR_6->max_size)
return VAR_15;
VAR_10 = malloc(sizeof(TEE_Attribute) * VAR_3);
if (!VAR_10)
return VAR_16;
VAR_4 = copy_in_attrs(to_user_ta_ctx(VAR_5->ctx), VAR_2, VAR_3,
VAR_10);
if (VAR_4 != VAR_11)
goto out;
VAR_4 = tee_svc_cryp_check_attr(VAR_17, VAR_6,
VAR_10, VAR_3);
if (VAR_4 != VAR_11)
goto out;
switch (VAR_7->info.objectType) {
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
VAR_9 = VAR_1 / 8;
if (VAR_7->info.objectType == VAR_19 ||
VAR_7->info.objectType == VAR_20) {
VAR_9 = (VAR_1 + VAR_1 / 7) / 8;
}
VAR_8 = (struct tee_cryp_obj_secret *)VAR_7->attr;
if (VAR_9 > VAR_8->alloc_size) {
VAR_4 = VAR_28;
goto out;
}
VAR_4 = crypto_rng_read((void *)(VAR_8 + 1), VAR_9);
if (VAR_4 != VAR_11)
goto out;
VAR_8->key_size = VAR_9;
VAR_7->have_attrs = (1 << VAR_6->num_type_attrs) - 1;
break;
case VAR_29:
VAR_4 = tee_svc_obj_generate_key_rsa(VAR_7, VAR_6, VAR_1,
VAR_10, VAR_3);
if (VAR_4 != VAR_11)
goto out;
break;
case VAR_30:
VAR_4 = tee_svc_obj_generate_key_dsa(VAR_7, VAR_6, VAR_1);
if (VAR_4 != VAR_11)
goto out;
break;
case VAR_31:
VAR_4 = tee_svc_obj_generate_key_dh(VAR_7, VAR_6, VAR_1,
VAR_10, VAR_3);
if (VAR_4 != VAR_11)
goto out;
break;
case VAR_32:
case VAR_33:
VAR_4 = tee_svc_obj_generate_key_ecc(VAR_7, VAR_6, VAR_1,
VAR_10, VAR_3);
if (VAR_4 != VAR_11)
goto out;
break;
default:
VAR_4 = VAR_34;
}
out:
free(VAR_10);
if (VAR_4 == VAR_11) {
VAR_7->info.keySize = VAR_1;
VAR_7->info.handleFlags |= VAR_14;
}
return VAR_4;
}",OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/before/1.json,"TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,
			const struct utee_attribute *usr_params,
			unsigned long param_count)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	const struct tee_cryp_obj_type_props *type_props;
	struct tee_obj *o;
	struct tee_cryp_obj_secret *key;
	size_t byte_size;
	TEE_Attribute *params = NULL;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/* Must be a transient object */
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)
		return TEE_ERROR_BAD_STATE;

	/* Must not be initialized already */
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)
		return TEE_ERROR_BAD_STATE;

	/* Find description of object */
	type_props = tee_svc_find_type_props(o->info.objectType);
	if (!type_props)
		return TEE_ERROR_NOT_SUPPORTED;

	/* Check that maxKeySize follows restrictions */
	if (key_size % type_props->quanta != 0)
		return TEE_ERROR_NOT_SUPPORTED;
	if (key_size < type_props->min_size)
		return TEE_ERROR_NOT_SUPPORTED;
	if (key_size > type_props->max_size)
		return TEE_ERROR_NOT_SUPPORTED;

	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
	if (!params)
		return TEE_ERROR_OUT_OF_MEMORY;
	res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,
			    params);
	if (res != TEE_SUCCESS)
		goto out;

	res = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,
				      params, param_count);
	if (res != TEE_SUCCESS)
		goto out;

	switch (o->info.objectType) {
	case TEE_TYPE_AES:
	case TEE_TYPE_DES:
	case TEE_TYPE_DES3:
	case TEE_TYPE_HMAC_MD5:
	case TEE_TYPE_HMAC_SHA1:
	case TEE_TYPE_HMAC_SHA224:
	case TEE_TYPE_HMAC_SHA256:
	case TEE_TYPE_HMAC_SHA384:
	case TEE_TYPE_HMAC_SHA512:
	case TEE_TYPE_GENERIC_SECRET:
		byte_size = key_size / 8;

		/*
		 * We have to do it like this because the parity bits aren't
		 * counted when telling the size of the key in bits.
		 */
		if (o->info.objectType == TEE_TYPE_DES ||
		    o->info.objectType == TEE_TYPE_DES3) {
			byte_size = (key_size + key_size / 7) / 8;
		}

		key = (struct tee_cryp_obj_secret *)o->attr;
		if (byte_size > key->alloc_size) {
			res = TEE_ERROR_EXCESS_DATA;
			goto out;
		}

		res = crypto_rng_read((void *)(key + 1), byte_size);
		if (res != TEE_SUCCESS)
			goto out;

		key->key_size = byte_size;

		/* Set bits for all known attributes for this object type */
		o->have_attrs = (1 << type_props->num_type_attrs) - 1;

		break;

	case TEE_TYPE_RSA_KEYPAIR:
		res = tee_svc_obj_generate_key_rsa(o, type_props, key_size,
						   params, param_count);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	case TEE_TYPE_DSA_KEYPAIR:
		res = tee_svc_obj_generate_key_dsa(o, type_props, key_size);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	case TEE_TYPE_DH_KEYPAIR:
		res = tee_svc_obj_generate_key_dh(o, type_props, key_size,
						  params, param_count);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	case TEE_TYPE_ECDSA_KEYPAIR:
	case TEE_TYPE_ECDH_KEYPAIR:
		res = tee_svc_obj_generate_key_ecc(o, type_props, key_size,
						  params, param_count);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	default:
		res = TEE_ERROR_BAD_FORMAT;
	}

out:
	free(params);
	if (res == TEE_SUCCESS) {
		o->info.keySize = key_size;
		o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
	}
	return res;
}","TEE_Result syscall_obj_generate_key(unsigned long VAR_0, unsigned long VAR_1,
			const struct utee_attribute *VAR_2,
			unsigned long VAR_3)
{
	TEE_Result VAR_4;
	struct tee_ta_session *VAR_5;
	const struct tee_cryp_obj_type_props *VAR_6;
	struct tee_obj *VAR_7;
	struct tee_cryp_obj_secret *VAR_8;
	size_t VAR_9;
	TEE_Attribute *VAR_10 = NULL;

	VAR_4 = tee_ta_get_current_session(&VAR_5);
	if (VAR_4 != VAR_11)
		return VAR_4;

	VAR_4 = tee_obj_get(to_user_ta_ctx(VAR_5->ctx),
			  tee_svc_uref_to_vaddr(VAR_0), &VAR_7);
	if (VAR_4 != VAR_11)
		return VAR_4;

	/* COMMENT_0 */
	if ((VAR_7->info.handleFlags & VAR_12) != 0)
		return VAR_13;

	/* COMMENT_1 */
	if ((VAR_7->info.handleFlags & VAR_14) != 0)
		return VAR_13;

	/* COMMENT_2 */
	VAR_6 = tee_svc_find_type_props(VAR_7->info.objectType);
	if (!VAR_6)
		return VAR_15;

	/* COMMENT_3 */
	if (VAR_1 % VAR_6->quanta != 0)
		return VAR_15;
	if (VAR_1 < VAR_6->min_size)
		return VAR_15;
	if (VAR_1 > VAR_6->max_size)
		return VAR_15;

	size_t VAR_16 = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), VAR_3, &VAR_16))
		return VAR_17;

	VAR_10 = malloc(VAR_16);
	if (!VAR_10)
		return VAR_18;
	VAR_4 = copy_in_attrs(to_user_ta_ctx(VAR_5->ctx), VAR_2, VAR_3,
			    VAR_10);
	if (VAR_4 != VAR_11)
		goto out;

	VAR_4 = tee_svc_cryp_check_attr(VAR_19, VAR_6,
				      VAR_10, VAR_3);
	if (VAR_4 != VAR_11)
		goto out;

	switch (VAR_7->info.objectType) {
	case VAR_20:
	case VAR_21:
	case VAR_22:
	case VAR_23:
	case VAR_24:
	case VAR_25:
	case VAR_26:
	case VAR_27:
	case VAR_28:
	case VAR_29:
		VAR_9 = VAR_1 / 8;

		/* COMMENT_4 */
                                                              
                                                      
     
		if (VAR_7->info.objectType == VAR_21 ||
		    VAR_7->info.objectType == VAR_22) {
			VAR_9 = (VAR_1 + VAR_1 / 7) / 8;
		}

		VAR_8 = (struct tee_cryp_obj_secret *)VAR_7->attr;
		if (VAR_9 > VAR_8->alloc_size) {
			VAR_4 = VAR_30;
			goto out;
		}

		VAR_4 = crypto_rng_read((void *)(VAR_8 + 1), VAR_9);
		if (VAR_4 != VAR_11)
			goto out;

		VAR_8->key_size = VAR_9;

		/* COMMENT_8 */
		VAR_7->have_attrs = (1 << VAR_6->num_type_attrs) - 1;

		break;

	case VAR_31:
		VAR_4 = tee_svc_obj_generate_key_rsa(VAR_7, VAR_6, VAR_1,
						   VAR_10, VAR_3);
		if (VAR_4 != VAR_11)
			goto out;
		break;

	case VAR_32:
		VAR_4 = tee_svc_obj_generate_key_dsa(VAR_7, VAR_6, VAR_1);
		if (VAR_4 != VAR_11)
			goto out;
		break;

	case VAR_33:
		VAR_4 = tee_svc_obj_generate_key_dh(VAR_7, VAR_6, VAR_1,
						  VAR_10, VAR_3);
		if (VAR_4 != VAR_11)
			goto out;
		break;

	case VAR_34:
	case VAR_35:
		VAR_4 = tee_svc_obj_generate_key_ecc(VAR_7, VAR_6, VAR_1,
						  VAR_10, VAR_3);
		if (VAR_4 != VAR_11)
			goto out;
		break;

	default:
		VAR_4 = VAR_36;
	}

out:
	free(VAR_10);
	if (VAR_4 == VAR_11) {
		VAR_7->info.keySize = VAR_1;
		VAR_7->info.handleFlags |= VAR_14;
	}
	return VAR_4;
}",OP-TEE/optee_os/a637243270fc1faae16de059091795c32d86e65e/tee_svc_cryp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -40,7 +40,12 @@
 	if (key_size > type_props->max_size)
 		return TEE_ERROR_NOT_SUPPORTED;
 
-	params = malloc(sizeof(TEE_Attribute) * param_count);
+	size_t alloc_size = 0;
+
+	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
+		return TEE_ERROR_OVERFLOW;
+
+	params = malloc(alloc_size);
 	if (!params)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,","{'deleted_lines': ['\tparams = malloc(sizeof(TEE_Attribute) * param_count);'], 'added_lines': ['\tsize_t alloc_size = 0;', '', '\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))', '\t\treturn TEE_ERROR_OVERFLOW;', '', '\tparams = malloc(alloc_size);']}",True,Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Execution of code in TEE core (kernel) context. The component is: optee_os. The fixed version is: 3.4.0 and later.,9.8,CRITICAL,3,test,2018-09-27T08:24:26Z,2
CVE-2018-1000815,['CWE-20'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0.0,brave/muon,Issue: 15232 AllowScript should use atom::ContentSettingsManager like other Allow* methods in the observer,c18663aa171c6cdf03da3e8c70df8663645b97c4,https://github.com/brave/muon/commit/c18663aa171c6cdf03da3e8c70df8663645b97c4,chromium_src/chrome/renderer/content_settings_observer.cc,ContentSettingsObserver::AllowScript,"bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {
if (!enabled_per_settings)
return false;
if (IsScriptDisabledForPreview(render_frame()))
return false;
if (is_interstitial_page_)
return true;
blink::WebLocalFrame* frame = render_frame()->GetWebFrame();
const auto it = cached_script_permissions_.find(frame);
if (it != cached_script_permissions_.end())
return it->second;
bool allow = true;
if (content_setting_rules_) {
ContentSetting setting = GetContentSettingFromRules(
content_setting_rules_->script_rules, frame,
url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());
allow = setting != CONTENT_SETTING_BLOCK;
}
allow = allow || IsWhitelistedForContentSettings();
cached_script_permissions_[frame] = allow;
return allow;
}","bool ContentSettingsObserver::AllowScript(bool VAR_0) {
if (!VAR_0)
return false;
if (IsScriptDisabledForPreview(render_frame()))
return false;
if (VAR_1)
return true;
blink::WebLocalFrame* VAR_2 = render_frame()->GetWebFrame();
const auto VAR_3 = VAR_4.find(VAR_2);
if (VAR_3 != VAR_4.end())
return VAR_3->second;
bool VAR_5 = true;
if (VAR_6) {
ContentSetting VAR_7 = GetContentSettingFromRules(
VAR_6->script_rules, VAR_2,
url::Origin(VAR_2->GetDocument().GetSecurityOrigin()).GetURL());
VAR_5 = VAR_7 != VAR_8;
}
VAR_5 = VAR_5 || IsWhitelistedForContentSettings();
VAR_4[VAR_2] = VAR_5;
return VAR_5;
}",brave/muon/c18663aa171c6cdf03da3e8c70df8663645b97c4/content_settings_observer.cc/vul/before/0.json,"bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {
  if (!enabled_per_settings)
    return false;
  if (IsScriptDisabledForPreview(render_frame()))
    return false;
  if (is_interstitial_page_)
    return true;

  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();
  const auto it = cached_script_permissions_.find(frame);
  if (it != cached_script_permissions_.end())
    return it->second;

  // Evaluate the content setting rules before
  // IsWhitelistedForContentSettings(); if there is only the default rule
  // allowing all scripts, it's quicker this way.
  bool allow = true;
  if (content_settings_manager_->content_settings()) {
    allow =
        content_settings_manager_->GetSetting(
          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),
          url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL(),
          ""javascript"",
          allow) != CONTENT_SETTING_BLOCK;
  }
  allow = allow || IsWhitelistedForContentSettings();

  cached_script_permissions_[frame] = allow;
  return allow;
}","bool ContentSettingsObserver::AllowScript(bool VAR_0) {
  if (!VAR_0)
    return false;
  if (IsScriptDisabledForPreview(render_frame()))
    return false;
  if (VAR_1)
    return true;

  blink::WebLocalFrame* VAR_2 = render_frame()->GetWebFrame();
  const auto VAR_3 = VAR_4.find(VAR_2);
  if (VAR_3 != VAR_4.end())
    return VAR_3->second;

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  bool VAR_5 = true;
  if (VAR_6->content_settings()) {
    VAR_5 =
        VAR_6->GetSetting(
          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),
          url::Origin(VAR_2->GetDocument().GetSecurityOrigin()).GetURL(),
          ""javascript"",
          VAR_5) != VAR_7;
  }
  VAR_5 = VAR_5 || IsWhitelistedForContentSettings();

  VAR_4[VAR_2] = VAR_5;
  return VAR_5;
}",brave/muon/c18663aa171c6cdf03da3e8c70df8663645b97c4/content_settings_observer.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,11 +15,13 @@
   // IsWhitelistedForContentSettings(); if there is only the default rule
   // allowing all scripts, it's quicker this way.
   bool allow = true;
-  if (content_setting_rules_) {
-    ContentSetting setting = GetContentSettingFromRules(
-        content_setting_rules_->script_rules, frame,
-        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());
-    allow = setting != CONTENT_SETTING_BLOCK;
+  if (content_settings_manager_->content_settings()) {
+    allow =
+        content_settings_manager_->GetSetting(
+          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),
+          url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL(),
+          ""javascript"",
+          allow) != CONTENT_SETTING_BLOCK;
   }
   allow = allow || IsWhitelistedForContentSettings();
 ","{'deleted_lines': ['  if (content_setting_rules_) {', '    ContentSetting setting = GetContentSettingFromRules(', '        content_setting_rules_->script_rules, frame,', '        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());', '    allow = setting != CONTENT_SETTING_BLOCK;'], 'added_lines': ['  if (content_settings_manager_->content_settings()) {', '    allow =', '        content_settings_manager_->GetSetting(', '          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),', '          url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL(),', '          ""javascript"",', '          allow) != CONTENT_SETTING_BLOCK;']}",True,"Brave Software Inc. Brave version version 0.22.810 to 0.24.0 contains a Other/Unknown vulnerability in function ContentSettingsObserver::AllowScript() in content_settings_observer.cc that can result in Websites can run inline JavaScript even if script is blocked, making attackers easier to track users. This attack appear to be exploitable via the victim must visit a specially crafted website. This vulnerability appears to have been fixed in 0.25.2.",4.3,MEDIUM,1,test,2018-10-02T01:56:46Z,2
CVE-2018-17581,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,Exiv2/exiv2,Fix #460 by adding more checks in CiffDirectory::readDirectory,b3d077dcaefb6747fff8204490f33eba5a144edb,https://github.com/Exiv2/exiv2/commit/b3d077dcaefb6747fff8204490f33eba5a144edb,src/crwimage_int.cpp,CiffDirectory::readDirectory,"void CiffDirectory::readDirectory(const byte* pData,
uint32_t    size,
ByteOrder   byteOrder)
{
uint32_t o = getULong(pData + size - 4, byteOrder);
if (size < 2 || o > size-2) throw Error(kerNotACrwImage);
uint16_t count = getUShort(pData + o, byteOrder);
#ifdef DEBUG
std::cout << ""Directory at offset "" << std::dec << o
<<"", "" << count << "" entries \n"";
#endif
o += 2;
for (uint16_t i = 0; i < count; ++i) {
if (o + 10 > size) throw Error(kerNotACrwImage);
uint16_t tag = getUShort(pData + o, byteOrder);
CiffComponent::AutoPtr m;
switch (CiffComponent::typeId(tag)) {
case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;
default: m = CiffComponent::AutoPtr(new CiffEntry); break;
}
m->setDir(this->tag());
m->read(pData, size, o, byteOrder);
add(m);
o += 10;
}
}","void CiffDirectory::readDirectory(const byte* VAR_0,
uint32_t    VAR_1,
ByteOrder   VAR_2)
{
uint32_t VAR_3 = getULong(VAR_0 + VAR_1 - 4, VAR_2);
if (VAR_1 < 2 || VAR_3 > VAR_1-2) throw Error(VAR_4);
uint16_t VAR_5 = getUShort(VAR_0 + VAR_3, VAR_2);
#ifdef VAR_6
std::cout << ""Directory at offset "" << std::dec << VAR_3
<<"", "" << VAR_5 << "" entries \n"";
#endif
VAR_3 += 2;
for (uint16_t VAR_7 = 0; VAR_7 < VAR_5; ++VAR_7) {
if (VAR_3 + 10 > VAR_1) throw Error(VAR_4);
uint16_t VAR_8 = getUShort(VAR_0 + VAR_3, VAR_2);
CiffComponent::AutoPtr VAR_9;
switch (CiffComponent::typeId(VAR_8)) {
case VAR_10: VAR_9 = CiffComponent::AutoPtr(new CiffDirectory); break;
default: VAR_9 = CiffComponent::AutoPtr(new CiffEntry); break;
}
VAR_9->setDir(this->tag());
VAR_9->read(VAR_0, VAR_1, VAR_3, VAR_2);
add(VAR_9);
VAR_3 += 10;
}
}",Exiv2/exiv2/b3d077dcaefb6747fff8204490f33eba5a144edb/crwimage_int.cpp/vul/before/0.json,"void CiffDirectory::readDirectory(const byte* pData,
                                      uint32_t    size,
                                      ByteOrder   byteOrder)
    {
        if (size < 4)
            throw Error(kerCorruptedMetadata);
        uint32_t o = getULong(pData + size - 4, byteOrder);
        if ( o+2 > size )
            throw Error(kerCorruptedMetadata);
        uint16_t count = getUShort(pData + o, byteOrder);
#ifdef DEBUG
        std::cout << ""Directory at offset "" << std::dec << o
                  <<"", "" << count << "" entries \n"";
#endif
        o += 2;
        if ( (o + (count * 10)) > size )
            throw Error(kerCorruptedMetadata);

        for (uint16_t i = 0; i < count; ++i) {
            uint16_t tag = getUShort(pData + o, byteOrder);
            CiffComponent::AutoPtr m;
            switch (CiffComponent::typeId(tag)) {
            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;
            default: m = CiffComponent::AutoPtr(new CiffEntry); break;
            }
            m->setDir(this->tag());
            m->read(pData, size, o, byteOrder);
            add(m);
            o += 10;
        }
    }","void CiffDirectory::readDirectory(const byte* VAR_0,
                                      uint32_t    VAR_1,
                                      ByteOrder   VAR_2)
    {
        if (VAR_1 < 4)
            throw Error(VAR_3);
        uint32_t VAR_4 = getULong(VAR_0 + VAR_1 - 4, VAR_2);
        if ( VAR_4+2 > VAR_1 )
            throw Error(VAR_3);
        uint16_t VAR_5 = getUShort(VAR_0 + VAR_4, VAR_2);
#ifdef VAR_6
        std::cout << ""Directory at offset "" << std::dec << VAR_4
                  <<"", "" << VAR_5 << "" entries \n"";
#endif
        VAR_4 += 2;
        if ( (VAR_4 + (VAR_5 * 10)) > VAR_1 )
            throw Error(VAR_3);

        for (uint16_t VAR_7 = 0; VAR_7 < VAR_5; ++VAR_7) {
            uint16_t VAR_8 = getUShort(VAR_0 + VAR_4, VAR_2);
            CiffComponent::AutoPtr VAR_9;
            switch (CiffComponent::typeId(VAR_8)) {
            case VAR_10: VAR_9 = CiffComponent::AutoPtr(new CiffDirectory); break;
            default: VAR_9 = CiffComponent::AutoPtr(new CiffEntry); break;
            }
            VAR_9->setDir(this->tag());
            VAR_9->read(VAR_0, VAR_1, VAR_4, VAR_2);
            add(VAR_9);
            VAR_4 += 10;
        }
    }",Exiv2/exiv2/b3d077dcaefb6747fff8204490f33eba5a144edb/crwimage_int.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,16 +2,21 @@
                                       uint32_t    size,
                                       ByteOrder   byteOrder)
     {
+        if (size < 4)
+            throw Error(kerCorruptedMetadata);
         uint32_t o = getULong(pData + size - 4, byteOrder);
-        if (size < 2 || o > size-2) throw Error(kerNotACrwImage);
+        if ( o+2 > size )
+            throw Error(kerCorruptedMetadata);
         uint16_t count = getUShort(pData + o, byteOrder);
 #ifdef DEBUG
         std::cout << ""Directory at offset "" << std::dec << o
                   <<"", "" << count << "" entries \n"";
 #endif
         o += 2;
+        if ( (o + (count * 10)) > size )
+            throw Error(kerCorruptedMetadata);
+
         for (uint16_t i = 0; i < count; ++i) {
-            if (o + 10 > size) throw Error(kerNotACrwImage);
             uint16_t tag = getUShort(pData + o, byteOrder);
             CiffComponent::AutoPtr m;
             switch (CiffComponent::typeId(tag)) {","{'deleted_lines': ['        if (size < 2 || o > size-2) throw Error(kerNotACrwImage);', '            if (o + 10 > size) throw Error(kerNotACrwImage);'], 'added_lines': ['        if (size < 4)', '            throw Error(kerCorruptedMetadata);', '        if ( o+2 > size )', '            throw Error(kerCorruptedMetadata);', '        if ( (o + (count * 10)) > size )', '            throw Error(kerCorruptedMetadata);', '']}",True,"CiffDirectory::readDirectory() at crwimage_int.cpp in Exiv2 0.26 has excessive stack consumption due to a recursive function, leading to Denial of service.",6.5,MEDIUM,1,test,2018-10-13T09:38:56Z,2
CVE-2018-17974,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,appneta/tcpreplay,"Bug #486 Enforce max snaplen rather than doing realloc

* increase MAX_SNAPLEN from 65535 to 262144
* increase MAXPACKET from 65549 to 262158
* exit on buffer overflow for adding VLAN tag (as opposed to realloc)",af0398766558a868dca232238f5df9eb151de304,https://github.com/appneta/tcpreplay/commit/af0398766558a868dca232238f5df9eb151de304,src/common/utils.c,_our_safe_pcap_next_ex,"int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,
const u_char **pktdata, const char *funcname,
const int line, const char *file)
{
int res = pcap_next_ex(pcap, pkthdr, pktdata);
if (*pktdata && *pkthdr) {
if ((*pkthdr)->len > MAX_PCAP_PACKET_LEN) {
fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
file, funcname, line, (*pkthdr)->len, MAX_PCAP_PACKET_LEN);
exit(-1);
}
if ((*pkthdr)->len < (*pkthdr)->caplen) {
fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);
exit(-1);
}
}
return res;
}","int _our_safe_pcap_next_ex(pcap_t *VAR_0, struct pcap_pkthdr **VAR_1,
const u_char **VAR_2, const char *VAR_3,
const int VAR_4, const char *VAR_5)
{
int VAR_6 = pcap_next_ex(VAR_0, VAR_1, VAR_2);
if (*VAR_2 && *VAR_1) {
if ((*VAR_1)->len > VAR_7) {
fprintf(VAR_8, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
VAR_5, VAR_3, VAR_4, (*VAR_1)->len, VAR_7);
exit(-1);
}
if ((*VAR_1)->len < (*VAR_1)->caplen) {
fprintf(VAR_8, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
VAR_5, VAR_3, VAR_4, (*VAR_1)->len, (*VAR_1)->caplen);
exit(-1);
}
}
return VAR_6;
}",appneta/tcpreplay/af0398766558a868dca232238f5df9eb151de304/utils.c/vul/before/1.json,"int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,
        const u_char **pktdata, const char *funcname,
        const int line, const char *file)
{
    int res = pcap_next_ex(pcap, pkthdr, pktdata);

    if (*pktdata && *pkthdr) {
        if ((*pkthdr)->len > MAXPACKET) {
            fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
                    file, funcname, line, (*pkthdr)->len, MAXPACKET);
            exit(-1);
        }

        if ((*pkthdr)->len < (*pkthdr)->caplen) {
            fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
                    file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);
            exit(-1);
        }
    }

    return res;
}","int _our_safe_pcap_next_ex(pcap_t *VAR_0, struct pcap_pkthdr **VAR_1,
        const u_char **VAR_2, const char *VAR_3,
        const int VAR_4, const char *VAR_5)
{
    int VAR_6 = pcap_next_ex(VAR_0, VAR_1, VAR_2);

    if (*VAR_2 && *VAR_1) {
        if ((*VAR_1)->len > VAR_7) {
            fprintf(VAR_8, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
                    VAR_5, VAR_3, VAR_4, (*VAR_1)->len, VAR_7);
            exit(-1);
        }

        if ((*VAR_1)->len < (*VAR_1)->caplen) {
            fprintf(VAR_8, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
                    VAR_5, VAR_3, VAR_4, (*VAR_1)->len, (*VAR_1)->caplen);
            exit(-1);
        }
    }

    return VAR_6;
}",appneta/tcpreplay/af0398766558a868dca232238f5df9eb151de304/utils.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -5,9 +5,9 @@
     int res = pcap_next_ex(pcap, pkthdr, pktdata);
 
     if (*pktdata && *pkthdr) {
-        if ((*pkthdr)->len > MAX_PCAP_PACKET_LEN) {
+        if ((*pkthdr)->len > MAXPACKET) {
             fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
-                    file, funcname, line, (*pkthdr)->len, MAX_PCAP_PACKET_LEN);
+                    file, funcname, line, (*pkthdr)->len, MAXPACKET);
             exit(-1);
         }
 ","{'deleted_lines': ['        if ((*pkthdr)->len > MAX_PCAP_PACKET_LEN) {', '                    file, funcname, line, (*pkthdr)->len, MAX_PCAP_PACKET_LEN);'], 'added_lines': ['        if ((*pkthdr)->len > MAXPACKET) {', '                    file, funcname, line, (*pkthdr)->len, MAXPACKET);']}",True,"An issue was discovered in Tcpreplay 4.3.0 beta1. A heap-based buffer over-read was triggered in the function dlt_en10mb_encode() of the file plugins/dlt_en10mb/en10mb.c, due to inappropriate values in the function memmove(). The length (pktlen + ctx -> l2len) can be larger than source value (packet + ctx->l2len) because the function fails to ensure the length of a packet is valid. This leads to Denial of Service.",5.5,MEDIUM,1,test,2018-10-19T16:26:37Z,2
CVE-2018-17974,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,appneta/tcpreplay,"Bug #486 Enforce max snaplen rather than doing realloc

* increase MAX_SNAPLEN from 65535 to 262144
* increase MAXPACKET from 65549 to 262158
* exit on buffer overflow for adding VLAN tag (as opposed to realloc)",af0398766558a868dca232238f5df9eb151de304,https://github.com/appneta/tcpreplay/commit/af0398766558a868dca232238f5df9eb151de304,src/common/utils.c,_our_safe_pcap_next,"u_char *_our_safe_pcap_next(pcap_t *pcap,  struct pcap_pkthdr *pkthdr,
const char *funcname, const int line, const char *file)
{
u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);
if (pktdata) {
if (pkthdr->len > MAX_PCAP_PACKET_LEN) {
fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
file, funcname, line, pkthdr->len, MAX_PCAP_PACKET_LEN);
exit(-1);
}
if (pkthdr->len < pkthdr->caplen) {
fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
file, funcname, line, pkthdr->len, pkthdr->caplen);
exit(-1);
}
}
return pktdata;
}","u_char *_our_safe_pcap_next(pcap_t *VAR_0,  struct pcap_pkthdr *VAR_1,
const char *VAR_2, const int VAR_3, const char *VAR_4)
{
u_char *VAR_5 = (u_char *)pcap_next(VAR_0, VAR_1);
if (VAR_5) {
if (VAR_1->len > VAR_6) {
fprintf(VAR_7, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
VAR_4, VAR_2, VAR_3, VAR_1->len, VAR_6);
exit(-1);
}
if (VAR_1->len < VAR_1->caplen) {
fprintf(VAR_7, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
VAR_4, VAR_2, VAR_3, VAR_1->len, VAR_1->caplen);
exit(-1);
}
}
return VAR_5;
}",appneta/tcpreplay/af0398766558a868dca232238f5df9eb151de304/utils.c/vul/before/0.json,"u_char *_our_safe_pcap_next(pcap_t *pcap,  struct pcap_pkthdr *pkthdr,
        const char *funcname, const int line, const char *file)
{
    u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);

    if (pktdata) {
        if (pkthdr->len > MAXPACKET) {
            fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
                    file, funcname, line, pkthdr->len, MAXPACKET);
            exit(-1);
        }

        if (pkthdr->len < pkthdr->caplen) {
            fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
                    file, funcname, line, pkthdr->len, pkthdr->caplen);
            exit(-1);
        }
    }

    return pktdata;
}","u_char *_our_safe_pcap_next(pcap_t *VAR_0,  struct pcap_pkthdr *VAR_1,
        const char *VAR_2, const int VAR_3, const char *VAR_4)
{
    u_char *VAR_5 = (u_char *)pcap_next(VAR_0, VAR_1);

    if (VAR_5) {
        if (VAR_1->len > VAR_6) {
            fprintf(VAR_7, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
                    VAR_4, VAR_2, VAR_3, VAR_1->len, VAR_6);
            exit(-1);
        }

        if (VAR_1->len < VAR_1->caplen) {
            fprintf(VAR_7, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
                    VAR_4, VAR_2, VAR_3, VAR_1->len, VAR_1->caplen);
            exit(-1);
        }
    }

    return VAR_5;
}",appneta/tcpreplay/af0398766558a868dca232238f5df9eb151de304/utils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,9 +4,9 @@
     u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);
 
     if (pktdata) {
-        if (pkthdr->len > MAX_PCAP_PACKET_LEN) {
+        if (pkthdr->len > MAXPACKET) {
             fprintf(stderr, ""safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
-                    file, funcname, line, pkthdr->len, MAX_PCAP_PACKET_LEN);
+                    file, funcname, line, pkthdr->len, MAXPACKET);
             exit(-1);
         }
 ","{'deleted_lines': ['        if (pkthdr->len > MAX_PCAP_PACKET_LEN) {', '                    file, funcname, line, pkthdr->len, MAX_PCAP_PACKET_LEN);'], 'added_lines': ['        if (pkthdr->len > MAXPACKET) {', '                    file, funcname, line, pkthdr->len, MAXPACKET);']}",True,"An issue was discovered in Tcpreplay 4.3.0 beta1. A heap-based buffer over-read was triggered in the function dlt_en10mb_encode() of the file plugins/dlt_en10mb/en10mb.c, due to inappropriate values in the function memmove(). The length (pktlen + ctx -> l2len) can be larger than source value (packet + ctx->l2len) because the function fails to ensure the length of a packet is valid. This leads to Denial of Service.",5.5,MEDIUM,1,test,2018-10-19T16:26:37Z,2
CVE-2018-17974,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,appneta/tcpreplay,"Bug #486 Enforce max snaplen rather than doing realloc

* increase MAX_SNAPLEN from 65535 to 262144
* increase MAXPACKET from 65549 to 262158
* exit on buffer overflow for adding VLAN tag (as opposed to realloc)",af0398766558a868dca232238f5df9eb151de304,https://github.com/appneta/tcpreplay/commit/af0398766558a868dca232238f5df9eb151de304,src/tcpedit/plugins/dlt_en10mb/en10mb.c,dlt_en10mb_encode,"int 
dlt_en10mb_encode(tcpeditdlt_t *ctx, u_char *packet, int pktlen, tcpr_dir_t dir)
{
tcpeditdlt_plugin_t *plugin = NULL;
struct tcpr_ethernet_hdr *eth = NULL;
struct tcpr_802_1q_hdr *vlan = NULL;
en10mb_config_t *config = NULL;
en10mb_extra_t *extra = NULL;
int newl2len = 0;
assert(ctx);
assert(packet);
if (pktlen < TCPR_802_1Q_H) {
tcpedit_seterr(ctx->tcpedit, 
""Unable to process packet #"" COUNTER_SPEC "" since it is less then 14 bytes."", 
ctx->tcpedit->runtime.packetnum);
return TCPEDIT_ERROR;
}
plugin = tcpedit_dlt_getplugin(ctx, dlt_value);
if (!plugin)
return TCPEDIT_ERROR;
config = plugin->config;
if (plugin->config_size < sizeof(*config))
return TCPEDIT_ERROR;
extra = (en10mb_extra_t *)ctx->decoded_extra;
if (ctx->decoded_extra_size < sizeof(*extra))
return TCPEDIT_ERROR;
if (ctx->decoder->dlt == dlt_value) {
if ((ctx->l2len == TCPR_802_1Q_H && config->vlan == TCPEDIT_VLAN_OFF) ||
(config->vlan == TCPEDIT_VLAN_ADD)) {
newl2len = TCPR_802_1Q_H;
} else if ((ctx->l2len == TCPR_802_3_H && config->vlan == TCPEDIT_VLAN_OFF) ||
(config->vlan == TCPEDIT_VLAN_DEL)) {
newl2len = TCPR_802_3_H;
}
} 
else {
newl2len = config->vlan == TCPEDIT_VLAN_ADD ? TCPR_802_1Q_H : TCPR_802_3_H;
}
if (pktlen < newl2len) {
tcpedit_seterr(ctx->tcpedit,
""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d bytes."",
ctx->tcpedit->runtime.packetnum, newl2len);
return TCPEDIT_ERROR;
}
if (pktlen < ctx->l2len) {
tcpedit_seterr(ctx->tcpedit,
""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d Layer 2 bytes."",
ctx->tcpedit->runtime.packetnum, ctx->l2len);
return TCPEDIT_ERROR;
}
if (newl2len != ctx->l2len) {
if (newl2len > ctx->l2len)
packet = safe_realloc(packet, pktlen + (newl2len - ctx->l2len));
memmove(packet + newl2len, packet + ctx->l2len, pktlen - ctx->l2len);
}
pktlen += newl2len - ctx->l2len;
eth = (struct tcpr_ethernet_hdr *)packet;
if (dir == TCPR_DIR_C2S) {
if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC1) {
if ((ctx->addr_type == ETHERNET && 
((ctx->skip_broadcast && 
is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))
|| ctx->addr_type != ETHERNET) {
memcpy(eth->ether_shost, config->intf1_smac, ETHER_ADDR_LEN);
} else {
memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);                
}
} else if (ctx->addr_type == ETHERNET) {
memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a source address"");
return TCPEDIT_ERROR;
}
if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC1) {
if ((ctx->addr_type == ETHERNET && 
((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))
|| ctx->addr_type != ETHERNET) {
memcpy(eth->ether_dhost, config->intf1_dmac, ETHER_ADDR_LEN);
} else {
memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);
}
} else if (ctx->addr_type == ETHERNET) {
memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a destination address"");
return TCPEDIT_ERROR;            
}
} else if (dir == TCPR_DIR_S2C) {
if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC2) {
if ((ctx->addr_type == ETHERNET && 
((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))
|| ctx->addr_type != ETHERNET) {
memcpy(eth->ether_shost, config->intf2_smac, ETHER_ADDR_LEN);
} else {
memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);
}
} else if (ctx->addr_type == ETHERNET) {
memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);            
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a source address"");
return TCPEDIT_ERROR;
}
if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC2) {
if ((ctx->addr_type == ETHERNET && 
((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))
|| ctx->addr_type != ETHERNET) {
memcpy(eth->ether_dhost, config->intf2_dmac, ETHER_ADDR_LEN);
} else {
memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);                
}
} else if (ctx->addr_type == ETHERNET) {
memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a destination address"");
return TCPEDIT_ERROR;
}
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Encoders only support C2S or C2S!"");
return TCPEDIT_ERROR;
}
if (config->subs.entries) {
int  entry = 0;
for (entry = 0 ; entry < config->subs.count; entry++) {
en10mb_sub_entry_t *current = &config->subs.entries[entry];
if (!memcmp(eth->ether_dhost, current->target, ETHER_ADDR_LEN)) {
memcpy(eth->ether_dhost, current->rewrite, ETHER_ADDR_LEN);
}
if (!memcmp(eth->ether_shost, current->target, ETHER_ADDR_LEN)) {
memcpy(eth->ether_shost, current->rewrite, ETHER_ADDR_LEN);
}
}
}
if (config->random.set) {
int unicast_src = is_unicast_ethernet(ctx, eth->ether_shost);
int unicast_dst = is_unicast_ethernet(ctx, eth->ether_dhost);
int i = config->random.keep;
for ( ; i < ETHER_ADDR_LEN; i++) {
eth->ether_shost[i] = MAC_MASK_APPLY(eth->ether_shost[i], config->random.mask[i], unicast_src);
eth->ether_dhost[i] = MAC_MASK_APPLY(eth->ether_dhost[i], config->random.mask[i], unicast_dst);
}
if (!config->random.keep) {
eth->ether_shost[0] &= ~(0x01 * unicast_src);
eth->ether_dhost[0] &= ~(0x01 * unicast_dst);
}
}
if (newl2len == TCPR_802_3_H) {
eth->ether_type = ctx->proto;
} else if (newl2len == TCPR_802_1Q_H) {
vlan = (struct tcpr_802_1q_hdr *)packet;
vlan->vlan_len = ctx->proto;
vlan->vlan_tpi = htons(ETHERTYPE_VLAN);
if (config->vlan_tag < 65535) {
vlan->vlan_priority_c_vid = 
htons((uint16_t)config->vlan_tag & TCPR_802_1Q_VIDMASK);
} else if (extra->vlan) {
vlan->vlan_priority_c_vid = extra->vlan_tag;
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-tag"");
return TCPEDIT_ERROR;
}
if (config->vlan_pri < 255) {
vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_pri << 13);
} else if (extra->vlan) {
vlan->vlan_priority_c_vid += extra->vlan_pri;
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-pri"");
return TCPEDIT_ERROR;
}
if (config->vlan_cfi < 255) {
vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_cfi << 12);
} else if (extra->vlan) {
vlan->vlan_priority_c_vid += extra->vlan_cfi;
} else {
tcpedit_seterr(ctx->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-cfi"");
return TCPEDIT_ERROR;            
}        
} else {
tcpedit_seterr(ctx->tcpedit, ""Unsupported new layer 2 length: %d"", newl2len);
return TCPEDIT_ERROR;
}
return pktlen;
}","int 
dlt_en10mb_encode(tcpeditdlt_t *VAR_0, u_char *VAR_1, int VAR_2, tcpr_dir_t VAR_3)
{
tcpeditdlt_plugin_t *VAR_4 = NULL;
struct tcpr_ethernet_hdr *VAR_5 = NULL;
struct tcpr_802_1q_hdr *VAR_6 = NULL;
en10mb_config_t *VAR_7 = NULL;
en10mb_extra_t *VAR_8 = NULL;
int VAR_9 = 0;
assert(VAR_0);
assert(VAR_1);
if (VAR_2 < VAR_10) {
tcpedit_seterr(VAR_0->tcpedit, 
""Unable to process packet #"" VAR_11 "" since it is less then 14 bytes."", 
VAR_0->tcpedit->runtime.packetnum);
return VAR_12;
}
VAR_4 = tcpedit_dlt_getplugin(VAR_0, VAR_13);
if (!VAR_4)
return VAR_12;
VAR_7 = VAR_4->config;
if (VAR_4->config_size < sizeof(*VAR_7))
return VAR_12;
VAR_8 = (en10mb_extra_t *)VAR_0->decoded_extra;
if (VAR_0->decoded_extra_size < sizeof(*VAR_8))
return VAR_12;
if (VAR_0->decoder->dlt == VAR_13) {
if ((VAR_0->l2len == VAR_10 && VAR_7->vlan == VAR_14) ||
(VAR_7->vlan == VAR_15)) {
VAR_9 = VAR_10;
} else if ((VAR_0->l2len == VAR_16 && VAR_7->vlan == VAR_14) ||
(VAR_7->vlan == VAR_17)) {
VAR_9 = VAR_16;
}
} 
else {
VAR_9 = VAR_7->vlan == VAR_15 ? VAR_10 : VAR_16;
}
if (VAR_2 < VAR_9) {
tcpedit_seterr(VAR_0->tcpedit,
""Unable to process packet #"" VAR_11 "" since its new length less then %d bytes."",
VAR_0->tcpedit->runtime.packetnum, VAR_9);
return VAR_12;
}
if (VAR_2 < VAR_0->l2len) {
tcpedit_seterr(VAR_0->tcpedit,
""Unable to process packet #"" VAR_11 "" since its new length less then %d Layer 2 bytes."",
VAR_0->tcpedit->runtime.packetnum, VAR_0->l2len);
return VAR_12;
}
if (VAR_9 != VAR_0->l2len) {
if (VAR_9 > VAR_0->l2len)
VAR_1 = safe_realloc(VAR_1, VAR_2 + (VAR_9 - VAR_0->l2len));
memmove(VAR_1 + VAR_9, VAR_1 + VAR_0->l2len, VAR_2 - VAR_0->l2len);
}
VAR_2 += VAR_9 - VAR_0->l2len;
VAR_5 = (struct tcpr_ethernet_hdr *)VAR_1;
if (VAR_3 == VAR_18) {
if (VAR_7->mac_mask & VAR_19) {
if ((VAR_0->addr_type == VAR_20 && 
((VAR_0->skip_broadcast && 
is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))
|| VAR_0->addr_type != VAR_20) {
memcpy(VAR_5->ether_shost, VAR_7->intf1_smac, VAR_21);
} else {
memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);                
}
} else if (VAR_0->addr_type == VAR_20) {
memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a source address"");
return VAR_12;
}
if (VAR_7->mac_mask & VAR_22) {
if ((VAR_0->addr_type == VAR_20 && 
((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))
|| VAR_0->addr_type != VAR_20) {
memcpy(VAR_5->ether_dhost, VAR_7->intf1_dmac, VAR_21);
} else {
memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);
}
} else if (VAR_0->addr_type == VAR_20) {
memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a destination address"");
return VAR_12;            
}
} else if (VAR_3 == VAR_23) {
if (VAR_7->mac_mask & VAR_24) {
if ((VAR_0->addr_type == VAR_20 && 
((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))
|| VAR_0->addr_type != VAR_20) {
memcpy(VAR_5->ether_shost, VAR_7->intf2_smac, VAR_21);
} else {
memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);
}
} else if (VAR_0->addr_type == VAR_20) {
memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_21);            
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a source address"");
return VAR_12;
}
if (VAR_7->mac_mask & VAR_25) {
if ((VAR_0->addr_type == VAR_20 && 
((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))
|| VAR_0->addr_type != VAR_20) {
memcpy(VAR_5->ether_dhost, VAR_7->intf2_dmac, VAR_21);
} else {
memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);                
}
} else if (VAR_0->addr_type == VAR_20) {
memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_21);
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a destination address"");
return VAR_12;
}
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Encoders only support C2S or C2S!"");
return VAR_12;
}
if (VAR_7->subs.entries) {
int  VAR_26 = 0;
for (VAR_26 = 0 ; VAR_26 < VAR_7->subs.count; VAR_26++) {
en10mb_sub_entry_t *VAR_27 = &VAR_7->subs.entries[VAR_26];
if (!memcmp(VAR_5->ether_dhost, VAR_27->target, VAR_21)) {
memcpy(VAR_5->ether_dhost, VAR_27->rewrite, VAR_21);
}
if (!memcmp(VAR_5->ether_shost, VAR_27->target, VAR_21)) {
memcpy(VAR_5->ether_shost, VAR_27->rewrite, VAR_21);
}
}
}
if (VAR_7->random.set) {
int VAR_28 = is_unicast_ethernet(VAR_0, VAR_5->ether_shost);
int VAR_29 = is_unicast_ethernet(VAR_0, VAR_5->ether_dhost);
int VAR_30 = VAR_7->random.keep;
for ( ; VAR_30 < VAR_21; VAR_30++) {
VAR_5->ether_shost[VAR_30] = MAC_MASK_APPLY(VAR_5->ether_shost[VAR_30], VAR_7->random.mask[VAR_30], VAR_28);
VAR_5->ether_dhost[VAR_30] = MAC_MASK_APPLY(VAR_5->ether_dhost[VAR_30], VAR_7->random.mask[VAR_30], VAR_29);
}
if (!VAR_7->random.keep) {
VAR_5->ether_shost[0] &= ~(0x01 * VAR_28);
VAR_5->ether_dhost[0] &= ~(0x01 * VAR_29);
}
}
if (VAR_9 == VAR_16) {
VAR_5->ether_type = VAR_0->proto;
} else if (VAR_9 == VAR_10) {
VAR_6 = (struct tcpr_802_1q_hdr *)VAR_1;
VAR_6->vlan_len = VAR_0->proto;
VAR_6->vlan_tpi = htons(VAR_31);
if (VAR_7->vlan_tag < 65535) {
VAR_6->vlan_priority_c_vid = 
htons((uint16_t)VAR_7->vlan_tag & VAR_32);
} else if (VAR_8->vlan) {
VAR_6->vlan_priority_c_vid = VAR_8->vlan_tag;
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-tag"");
return VAR_12;
}
if (VAR_7->vlan_pri < 255) {
VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_pri << 13);
} else if (VAR_8->vlan) {
VAR_6->vlan_priority_c_vid += VAR_8->vlan_pri;
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-pri"");
return VAR_12;
}
if (VAR_7->vlan_cfi < 255) {
VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_cfi << 12);
} else if (VAR_8->vlan) {
VAR_6->vlan_priority_c_vid += VAR_8->vlan_cfi;
} else {
tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-cfi"");
return VAR_12;            
}        
} else {
tcpedit_seterr(VAR_0->tcpedit, ""Unsupported new layer 2 length: %d"", VAR_9);
return VAR_12;
}
return VAR_2;
}",appneta/tcpreplay/af0398766558a868dca232238f5df9eb151de304/en10mb.c/vul/before/0.json,"int 
dlt_en10mb_encode(tcpeditdlt_t *ctx, u_char *packet, int pktlen, tcpr_dir_t dir)
{
    tcpeditdlt_plugin_t *plugin = NULL;
    struct tcpr_ethernet_hdr *eth = NULL;
    struct tcpr_802_1q_hdr *vlan = NULL;
    en10mb_config_t *config = NULL;
    en10mb_extra_t *extra = NULL;
    
    int newl2len = 0;

    assert(ctx);
    assert(packet);

    if (pktlen < TCPR_802_1Q_H) {
        tcpedit_seterr(ctx->tcpedit, 
                ""Unable to process packet #"" COUNTER_SPEC "" since it is less then 14 bytes."", 
                ctx->tcpedit->runtime.packetnum);
        return TCPEDIT_ERROR;
    }

    plugin = tcpedit_dlt_getplugin(ctx, dlt_value);
    if (!plugin)
        return TCPEDIT_ERROR;

    config = plugin->config;
    if (plugin->config_size < sizeof(*config))
        return TCPEDIT_ERROR;

    extra = (en10mb_extra_t *)ctx->decoded_extra;
    if (ctx->decoded_extra_size < sizeof(*extra))
        return TCPEDIT_ERROR;

    /* figure out the new layer2 length, first for the case: ethernet -> ethernet? */
    if (ctx->decoder->dlt == dlt_value) {
        if ((ctx->l2len == TCPR_802_1Q_H && config->vlan == TCPEDIT_VLAN_OFF) ||
            (config->vlan == TCPEDIT_VLAN_ADD)) {
            newl2len = TCPR_802_1Q_H;
        } else if ((ctx->l2len == TCPR_802_3_H && config->vlan == TCPEDIT_VLAN_OFF) ||
            (config->vlan == TCPEDIT_VLAN_DEL)) {
            newl2len = TCPR_802_3_H;
        }
    } 
    
    /* newl2len for some other DLT -> ethernet */
    else {
        /* if add a vlan then 18, else 14 bytes */
        newl2len = config->vlan == TCPEDIT_VLAN_ADD ? TCPR_802_1Q_H : TCPR_802_3_H;
    }

    if (pktlen < newl2len) {
        tcpedit_seterr(ctx->tcpedit,
                ""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d bytes."",
                ctx->tcpedit->runtime.packetnum, newl2len);
        return TCPEDIT_ERROR;
    }

    if (pktlen < ctx->l2len) {
        tcpedit_seterr(ctx->tcpedit,
                ""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d L2 bytes."",
                ctx->tcpedit->runtime.packetnum, ctx->l2len);
        return TCPEDIT_ERROR;
    }

    /* Make space for our new L2 header */
    if (newl2len != ctx->l2len) {
        if (pktlen + (newl2len - ctx->l2len) > MAXPACKET)
            errx(-1, ""New frame too big, new length %d exceeds %d"",
                    pktlen + (newl2len - ctx->l2len), MAXPACKET);

        memmove(packet + newl2len, packet + ctx->l2len, pktlen - ctx->l2len);
    }

    /* update the total packet length */
    pktlen += newl2len - ctx->l2len;
    
    /* always set the src & dst address as the first 12 bytes */
    eth = (struct tcpr_ethernet_hdr *)packet;
    
    if (dir == TCPR_DIR_C2S) {
        /* copy user supplied SRC MAC if provided or from original packet */
        if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC1) {
            if ((ctx->addr_type == ETHERNET && 
                    ((ctx->skip_broadcast && 
                      is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))
                || ctx->addr_type != ETHERNET) {
                memcpy(eth->ether_shost, config->intf1_smac, ETHER_ADDR_LEN);
            } else {
                memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);                
            }
        } else if (ctx->addr_type == ETHERNET) {
            memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);
        } else {
            tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a source address"");
            return TCPEDIT_ERROR;
        }

        /* copy user supplied DMAC MAC if provided or from original packet */        
        if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC1) {
            if ((ctx->addr_type == ETHERNET && 
                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))
                || ctx->addr_type != ETHERNET) {
                memcpy(eth->ether_dhost, config->intf1_dmac, ETHER_ADDR_LEN);
            } else {
                memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);
            }
        } else if (ctx->addr_type == ETHERNET) {
            memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);
        } else {
            tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a destination address"");
            return TCPEDIT_ERROR;            
        }
    
    } else if (dir == TCPR_DIR_S2C) {
        /* copy user supplied SRC MAC if provided or from original packet */
        if (config->mac_mask & TCPEDIT_MAC_MASK_SMAC2) {
            if ((ctx->addr_type == ETHERNET && 
                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->srcaddr.ethernet)) || !ctx->skip_broadcast))
                || ctx->addr_type != ETHERNET) {
                memcpy(eth->ether_shost, config->intf2_smac, ETHER_ADDR_LEN);
            } else {
                memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);
            }
        } else if (ctx->addr_type == ETHERNET) {
            memcpy(eth->ether_shost, ctx->srcaddr.ethernet, ETHER_ADDR_LEN);            
        } else {
            tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a source address"");
            return TCPEDIT_ERROR;
        }

        
        /* copy user supplied DMAC MAC if provided or from original packet */        
        if (config->mac_mask & TCPEDIT_MAC_MASK_DMAC2) {
            if ((ctx->addr_type == ETHERNET && 
                ((ctx->skip_broadcast && is_unicast_ethernet(ctx, ctx->dstaddr.ethernet)) || !ctx->skip_broadcast))
                || ctx->addr_type != ETHERNET) {
                memcpy(eth->ether_dhost, config->intf2_dmac, ETHER_ADDR_LEN);
            } else {
                memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);                
            }
        } else if (ctx->addr_type == ETHERNET) {
            memcpy(eth->ether_dhost, ctx->dstaddr.ethernet, ETHER_ADDR_LEN);
        } else {
            tcpedit_seterr(ctx->tcpedit, ""%s"", ""Please provide a destination address"");
            return TCPEDIT_ERROR;
        }

        
    } else {
        tcpedit_seterr(ctx->tcpedit, ""%s"", ""Encoders only support C2S or C2S!"");
        return TCPEDIT_ERROR;
    }

    if (config->subs.entries) {
      int  entry = 0;
      for (entry = 0 ; entry < config->subs.count; entry++) {
        en10mb_sub_entry_t *current = &config->subs.entries[entry];

        if (!memcmp(eth->ether_dhost, current->target, ETHER_ADDR_LEN)) {
          memcpy(eth->ether_dhost, current->rewrite, ETHER_ADDR_LEN);
        }

        if (!memcmp(eth->ether_shost, current->target, ETHER_ADDR_LEN)) {
          memcpy(eth->ether_shost, current->rewrite, ETHER_ADDR_LEN);
        }
      }
    }

    if (config->random.set) {
      int unicast_src = is_unicast_ethernet(ctx, eth->ether_shost);
      int unicast_dst = is_unicast_ethernet(ctx, eth->ether_dhost);

      int i = config->random.keep;
      for ( ; i < ETHER_ADDR_LEN; i++) {
        eth->ether_shost[i] = MAC_MASK_APPLY(eth->ether_shost[i], config->random.mask[i], unicast_src);
        eth->ether_dhost[i] = MAC_MASK_APPLY(eth->ether_dhost[i], config->random.mask[i], unicast_dst);
      }

      /* avoid making unicast packets multicast */
      if (!config->random.keep) {
        eth->ether_shost[0] &= ~(0x01 * unicast_src);
        eth->ether_dhost[0] &= ~(0x01 * unicast_dst);
      }
    }

    if (newl2len == TCPR_802_3_H) {
        /* all we need for 802.3 is the proto */
        eth->ether_type = ctx->proto;
        
    } else if (newl2len == TCPR_802_1Q_H) {
        /* VLAN tags need a bit more */
        vlan = (struct tcpr_802_1q_hdr *)packet;
        vlan->vlan_len = ctx->proto;
        vlan->vlan_tpi = htons(ETHERTYPE_VLAN);
        
        /* are we changing VLAN info? */
        if (config->vlan_tag < 65535) {
            vlan->vlan_priority_c_vid = 
                htons((uint16_t)config->vlan_tag & TCPR_802_1Q_VIDMASK);
        } else if (extra->vlan) {
            vlan->vlan_priority_c_vid = extra->vlan_tag;
        } else {
            tcpedit_seterr(ctx->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-tag"");
            return TCPEDIT_ERROR;
        }
        
        if (config->vlan_pri < 255) {
            vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_pri << 13);
        } else if (extra->vlan) {
            vlan->vlan_priority_c_vid += extra->vlan_pri;
        } else {
            tcpedit_seterr(ctx->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-pri"");
            return TCPEDIT_ERROR;
        }
            
        if (config->vlan_cfi < 255) {
            vlan->vlan_priority_c_vid += htons((uint16_t)config->vlan_cfi << 12);
        } else if (extra->vlan) {
            vlan->vlan_priority_c_vid += extra->vlan_cfi;
        } else {
            tcpedit_seterr(ctx->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-cfi"");
            return TCPEDIT_ERROR;            
        }        
        
    } else {
        tcpedit_seterr(ctx->tcpedit, ""Unsupported new layer 2 length: %d"", newl2len);
        return TCPEDIT_ERROR;
    }

    return pktlen;
}","int 
dlt_en10mb_encode(tcpeditdlt_t *VAR_0, u_char *VAR_1, int VAR_2, tcpr_dir_t VAR_3)
{
    tcpeditdlt_plugin_t *VAR_4 = NULL;
    struct tcpr_ethernet_hdr *VAR_5 = NULL;
    struct tcpr_802_1q_hdr *VAR_6 = NULL;
    en10mb_config_t *VAR_7 = NULL;
    en10mb_extra_t *VAR_8 = NULL;
    
    int VAR_9 = 0;

    assert(VAR_0);
    assert(VAR_1);

    if (VAR_2 < VAR_10) {
        tcpedit_seterr(VAR_0->tcpedit, 
                ""Unable to process packet #"" VAR_11 "" since it is less then 14 bytes."", 
                VAR_0->tcpedit->runtime.packetnum);
        return VAR_12;
    }

    VAR_4 = tcpedit_dlt_getplugin(VAR_0, VAR_13);
    if (!VAR_4)
        return VAR_12;

    VAR_7 = VAR_4->config;
    if (VAR_4->config_size < sizeof(*VAR_7))
        return VAR_12;

    VAR_8 = (en10mb_extra_t *)VAR_0->decoded_extra;
    if (VAR_0->decoded_extra_size < sizeof(*VAR_8))
        return VAR_12;

    /* COMMENT_0 */
    if (VAR_0->decoder->dlt == VAR_13) {
        if ((VAR_0->l2len == VAR_10 && VAR_7->vlan == VAR_14) ||
            (VAR_7->vlan == VAR_15)) {
            VAR_9 = VAR_10;
        } else if ((VAR_0->l2len == VAR_16 && VAR_7->vlan == VAR_14) ||
            (VAR_7->vlan == VAR_17)) {
            VAR_9 = VAR_16;
        }
    } 
    
    /* COMMENT_1 */
    else {
        /* COMMENT_2 */
        VAR_9 = VAR_7->vlan == VAR_15 ? VAR_10 : VAR_16;
    }

    if (VAR_2 < VAR_9) {
        tcpedit_seterr(VAR_0->tcpedit,
                ""Unable to process packet #"" VAR_11 "" since its new length less then %d bytes."",
                VAR_0->tcpedit->runtime.packetnum, VAR_9);
        return VAR_12;
    }

    if (VAR_2 < VAR_0->l2len) {
        tcpedit_seterr(VAR_0->tcpedit,
                ""Unable to process packet #"" VAR_11 "" since its new length less then %d L2 bytes."",
                VAR_0->tcpedit->runtime.packetnum, VAR_0->l2len);
        return VAR_12;
    }

    /* COMMENT_3 */
    if (VAR_9 != VAR_0->l2len) {
        if (VAR_2 + (VAR_9 - VAR_0->l2len) > VAR_18)
            errx(-1, ""New frame too big, new length %d exceeds %d"",
                    VAR_2 + (VAR_9 - VAR_0->l2len), VAR_18);

        memmove(VAR_1 + VAR_9, VAR_1 + VAR_0->l2len, VAR_2 - VAR_0->l2len);
    }

    /* COMMENT_4 */
    VAR_2 += VAR_9 - VAR_0->l2len;
    
    /* COMMENT_5 */
    VAR_5 = (struct tcpr_ethernet_hdr *)VAR_1;
    
    if (VAR_3 == VAR_19) {
        /* COMMENT_6 */
        if (VAR_7->mac_mask & VAR_20) {
            if ((VAR_0->addr_type == VAR_21 && 
                    ((VAR_0->skip_broadcast && 
                      is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))
                || VAR_0->addr_type != VAR_21) {
                memcpy(VAR_5->ether_shost, VAR_7->intf1_smac, VAR_22);
            } else {
                memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_22);                
            }
        } else if (VAR_0->addr_type == VAR_21) {
            memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_22);
        } else {
            tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a source address"");
            return VAR_12;
        }

        /* COMMENT_7 */        
        if (VAR_7->mac_mask & VAR_23) {
            if ((VAR_0->addr_type == VAR_21 && 
                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))
                || VAR_0->addr_type != VAR_21) {
                memcpy(VAR_5->ether_dhost, VAR_7->intf1_dmac, VAR_22);
            } else {
                memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_22);
            }
        } else if (VAR_0->addr_type == VAR_21) {
            memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_22);
        } else {
            tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a destination address"");
            return VAR_12;            
        }
    
    } else if (VAR_3 == VAR_24) {
        /* COMMENT_6 */
        if (VAR_7->mac_mask & VAR_25) {
            if ((VAR_0->addr_type == VAR_21 && 
                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->srcaddr.ethernet)) || !VAR_0->skip_broadcast))
                || VAR_0->addr_type != VAR_21) {
                memcpy(VAR_5->ether_shost, VAR_7->intf2_smac, VAR_22);
            } else {
                memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_22);
            }
        } else if (VAR_0->addr_type == VAR_21) {
            memcpy(VAR_5->ether_shost, VAR_0->srcaddr.ethernet, VAR_22);            
        } else {
            tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a source address"");
            return VAR_12;
        }

        
        /* COMMENT_7 */        
        if (VAR_7->mac_mask & VAR_26) {
            if ((VAR_0->addr_type == VAR_21 && 
                ((VAR_0->skip_broadcast && is_unicast_ethernet(VAR_0, VAR_0->dstaddr.ethernet)) || !VAR_0->skip_broadcast))
                || VAR_0->addr_type != VAR_21) {
                memcpy(VAR_5->ether_dhost, VAR_7->intf2_dmac, VAR_22);
            } else {
                memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_22);                
            }
        } else if (VAR_0->addr_type == VAR_21) {
            memcpy(VAR_5->ether_dhost, VAR_0->dstaddr.ethernet, VAR_22);
        } else {
            tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Please provide a destination address"");
            return VAR_12;
        }

        
    } else {
        tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Encoders only support C2S or C2S!"");
        return VAR_12;
    }

    if (VAR_7->subs.entries) {
      int  VAR_27 = 0;
      for (VAR_27 = 0 ; VAR_27 < VAR_7->subs.count; VAR_27++) {
        en10mb_sub_entry_t *VAR_28 = &VAR_7->subs.entries[VAR_27];

        if (!memcmp(VAR_5->ether_dhost, VAR_28->target, VAR_22)) {
          memcpy(VAR_5->ether_dhost, VAR_28->rewrite, VAR_22);
        }

        if (!memcmp(VAR_5->ether_shost, VAR_28->target, VAR_22)) {
          memcpy(VAR_5->ether_shost, VAR_28->rewrite, VAR_22);
        }
      }
    }

    if (VAR_7->random.set) {
      int VAR_29 = is_unicast_ethernet(VAR_0, VAR_5->ether_shost);
      int VAR_30 = is_unicast_ethernet(VAR_0, VAR_5->ether_dhost);

      int VAR_31 = VAR_7->random.keep;
      for ( ; VAR_31 < VAR_22; VAR_31++) {
        VAR_5->ether_shost[VAR_31] = MAC_MASK_APPLY(VAR_5->ether_shost[VAR_31], VAR_7->random.mask[VAR_31], VAR_29);
        VAR_5->ether_dhost[VAR_31] = MAC_MASK_APPLY(VAR_5->ether_dhost[VAR_31], VAR_7->random.mask[VAR_31], VAR_30);
      }

      /* COMMENT_8 */
      if (!VAR_7->random.keep) {
        VAR_5->ether_shost[0] &= ~(0x01 * VAR_29);
        VAR_5->ether_dhost[0] &= ~(0x01 * VAR_30);
      }
    }

    if (VAR_9 == VAR_16) {
        /* COMMENT_9 */
        VAR_5->ether_type = VAR_0->proto;
        
    } else if (VAR_9 == VAR_10) {
        /* COMMENT_10 */
        VAR_6 = (struct tcpr_802_1q_hdr *)VAR_1;
        VAR_6->vlan_len = VAR_0->proto;
        VAR_6->vlan_tpi = htons(VAR_32);
        
        /* COMMENT_11 */
        if (VAR_7->vlan_tag < 65535) {
            VAR_6->vlan_priority_c_vid = 
                htons((uint16_t)VAR_7->vlan_tag & VAR_33);
        } else if (VAR_8->vlan) {
            VAR_6->vlan_priority_c_vid = VAR_8->vlan_tag;
        } else {
            tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-tag"");
            return VAR_12;
        }
        
        if (VAR_7->vlan_pri < 255) {
            VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_pri << 13);
        } else if (VAR_8->vlan) {
            VAR_6->vlan_priority_c_vid += VAR_8->vlan_pri;
        } else {
            tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-pri"");
            return VAR_12;
        }
            
        if (VAR_7->vlan_cfi < 255) {
            VAR_6->vlan_priority_c_vid += htons((uint16_t)VAR_7->vlan_cfi << 12);
        } else if (VAR_8->vlan) {
            VAR_6->vlan_priority_c_vid += VAR_8->vlan_cfi;
        } else {
            tcpedit_seterr(VAR_0->tcpedit, ""%s"", ""Non-VLAN tagged packet requires --enet-vlan-cfi"");
            return VAR_12;            
        }        
        
    } else {
        tcpedit_seterr(VAR_0->tcpedit, ""Unsupported new layer 2 length: %d"", VAR_9);
        return VAR_12;
    }

    return VAR_2;
}",appneta/tcpreplay/af0398766558a868dca232238f5df9eb151de304/en10mb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -57,15 +57,16 @@
 
     if (pktlen < ctx->l2len) {
         tcpedit_seterr(ctx->tcpedit,
-                ""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d Layer 2 bytes."",
+                ""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d L2 bytes."",
                 ctx->tcpedit->runtime.packetnum, ctx->l2len);
         return TCPEDIT_ERROR;
     }
 
     /* Make space for our new L2 header */
     if (newl2len != ctx->l2len) {
-        if (newl2len > ctx->l2len)
-            packet = safe_realloc(packet, pktlen + (newl2len - ctx->l2len));
+        if (pktlen + (newl2len - ctx->l2len) > MAXPACKET)
+            errx(-1, ""New frame too big, new length %d exceeds %d"",
+                    pktlen + (newl2len - ctx->l2len), MAXPACKET);
 
         memmove(packet + newl2len, packet + ctx->l2len, pktlen - ctx->l2len);
     }","{'deleted_lines': ['                ""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d Layer 2 bytes."",', '        if (newl2len > ctx->l2len)', '            packet = safe_realloc(packet, pktlen + (newl2len - ctx->l2len));'], 'added_lines': ['                ""Unable to process packet #"" COUNTER_SPEC "" since its new length less then %d L2 bytes."",', '        if (pktlen + (newl2len - ctx->l2len) > MAXPACKET)', '            errx(-1, ""New frame too big, new length %d exceeds %d"",', '                    pktlen + (newl2len - ctx->l2len), MAXPACKET);']}",True,"An issue was discovered in Tcpreplay 4.3.0 beta1. A heap-based buffer over-read was triggered in the function dlt_en10mb_encode() of the file plugins/dlt_en10mb/en10mb.c, due to inappropriate values in the function memmove(). The length (pktlen + ctx -> l2len) can be larger than source value (packet + ctx->l2len) because the function fails to ensure the length of a packet is valid. This leads to Denial of Service.",5.5,MEDIUM,1,test,2018-10-19T16:26:37Z,2
CVE-2018-6307,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,LibVNC/libvncserver,"tightvnc-filetransfer: fix heap use-after-free

One can only guess what the intended semantics were here, but as every
other rfbCloseClient() call in this file is followed by an immediate
return, let's assume this was forgotton in this case.

Anyway, don't forget to clean up to not leak memory.

Closes #241",ca2a5ac02fbbadd0a21fabba779c1ea69173d10b,https://github.com/LibVNC/libvncserver/commit/ca2a5ac02fbbadd0a21fabba779c1ea69173d10b,libvncserver/tightvnc-filetransfer/handlefiletransferrequest.c,HandleFileDownloadCancelRequest,"void
HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
int n = 0;
char *reason = NULL;
rfbClientToServerTightMsg msg;
memset(&msg, 0, sizeof(rfbClientToServerTightMsg));
if((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {
if (n < 0)
rfbLog(""File [%s]: Method [%s]: Error while reading ""
""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
rfbCloseClient(cl);
return;
}
msg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);
if(msg.fdc.reasonLen == 0) {
rfbLog(""File [%s]: Method [%s]: reason length received is Zero\n"",
__FILE__, __FUNCTION__);
return;
}
reason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));
if(reason == NULL) {
rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n"", 
__FILE__, __FUNCTION__);
return;
}
if((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {
if (n < 0)
rfbLog(""File [%s]: Method [%s]: Error while reading ""
""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
rfbCloseClient(cl);
}
rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
"" reason <%s>\n"", __FILE__, __FUNCTION__, reason);
pthread_mutex_lock(&fileDownloadMutex);
CloseUndoneFileTransfer(cl, rtcp);
pthread_mutex_unlock(&fileDownloadMutex);
if(reason != NULL) {
free(reason);
reason = NULL;
}
}","void
HandleFileDownloadCancelRequest(rfbClientPtr VAR_0, rfbTightClientPtr VAR_1)
{
int VAR_2 = 0;
char *VAR_3 = NULL;
rfbClientToServerTightMsg VAR_4;
memset(&VAR_4, 0, sizeof(rfbClientToServerTightMsg));
if((VAR_2 = rfbReadExact(VAR_0, ((char *)&VAR_4)+1, VAR_5-1)) <= 0) {
if (VAR_2 < 0)
rfbLog(""File [%s]: Method [%s]: Error while reading ""
""FileDownloadCancelMsg\n"", VAR_6, VAR_7);
rfbCloseClient(VAR_0);
return;
}
VAR_4.fdc.reasonLen = Swap16IfLE(VAR_4.fdc.reasonLen);
if(VAR_4.fdc.reasonLen == 0) {
rfbLog(""File [%s]: Method [%s]: reason length received is Zero\n"",
VAR_6, VAR_7);
return;
}
VAR_3 = (char*) calloc(VAR_4.fdc.reasonLen + 1, sizeof(char));
if(VAR_3 == NULL) {
rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n"", 
VAR_6, VAR_7);
return;
}
if((VAR_2 = rfbReadExact(VAR_0, VAR_3, VAR_4.fdc.reasonLen)) <= 0) {
if (VAR_2 < 0)
rfbLog(""File [%s]: Method [%s]: Error while reading ""
""FileDownloadCancelMsg\n"", VAR_6, VAR_7);
rfbCloseClient(VAR_0);
}
rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
"" reason <%s>\n"", VAR_6, VAR_7, VAR_3);
pthread_mutex_lock(&VAR_8);
CloseUndoneFileTransfer(VAR_0, VAR_1);
pthread_mutex_unlock(&VAR_8);
if(VAR_3 != NULL) {
free(VAR_3);
VAR_3 = NULL;
}
}",LibVNC/libvncserver/ca2a5ac02fbbadd0a21fabba779c1ea69173d10b/handlefiletransferrequest.c/vul/before/0.json,"void
HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
	int n = 0;
	char *reason = NULL;
	rfbClientToServerTightMsg msg;

	memset(&msg, 0, sizeof(rfbClientToServerTightMsg));
	
	if((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {
		
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
		
	    rfbCloseClient(cl);
	    return;
	}

	msg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);

	if(msg.fdc.reasonLen == 0) {
		rfbLog(""File [%s]: Method [%s]: reason length received is Zero\n"",
				__FILE__, __FUNCTION__);
		return;
	}
	
	reason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));
	if(reason == NULL) {
		rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n"", 
				__FILE__, __FUNCTION__);
		return;
	}

	if((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {
		
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
		
	    rfbCloseClient(cl);
	    free(reason);
	    return;
	}

	rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
					"" reason <%s>\n"", __FILE__, __FUNCTION__, reason);
	
	pthread_mutex_lock(&fileDownloadMutex);
	CloseUndoneFileTransfer(cl, rtcp);
	pthread_mutex_unlock(&fileDownloadMutex);
	
	if(reason != NULL) {
		free(reason);
		reason = NULL;
	}

}","void
HandleFileDownloadCancelRequest(rfbClientPtr VAR_0, rfbTightClientPtr VAR_1)
{
	int VAR_2 = 0;
	char *VAR_3 = NULL;
	rfbClientToServerTightMsg VAR_4;

	memset(&VAR_4, 0, sizeof(rfbClientToServerTightMsg));
	
	if((VAR_2 = rfbReadExact(VAR_0, ((char *)&VAR_4)+1, VAR_5-1)) <= 0) {
		
		if (VAR_2 < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", VAR_6, VAR_7);
		
	    rfbCloseClient(VAR_0);
	    return;
	}

	VAR_4.fdc.reasonLen = Swap16IfLE(VAR_4.fdc.reasonLen);

	if(VAR_4.fdc.reasonLen == 0) {
		rfbLog(""File [%s]: Method [%s]: reason length received is Zero\n"",
				VAR_6, VAR_7);
		return;
	}
	
	VAR_3 = (char*) calloc(VAR_4.fdc.reasonLen + 1, sizeof(char));
	if(VAR_3 == NULL) {
		rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n"", 
				VAR_6, VAR_7);
		return;
	}

	if((VAR_2 = rfbReadExact(VAR_0, VAR_3, VAR_4.fdc.reasonLen)) <= 0) {
		
		if (VAR_2 < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", VAR_6, VAR_7);
		
	    rfbCloseClient(VAR_0);
	    free(VAR_3);
	    return;
	}

	rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
					"" reason <%s>\n"", VAR_6, VAR_7, VAR_3);
	
	pthread_mutex_lock(&VAR_8);
	CloseUndoneFileTransfer(VAR_0, VAR_1);
	pthread_mutex_unlock(&VAR_8);
	
	if(VAR_3 != NULL) {
		free(VAR_3);
		VAR_3 = NULL;
	}

}",LibVNC/libvncserver/ca2a5ac02fbbadd0a21fabba779c1ea69173d10b/handlefiletransferrequest.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,6 +39,8 @@
 					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
 		
 	    rfbCloseClient(cl);
+	    free(reason);
+	    return;
 	}
 
 	rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""","{'deleted_lines': [], 'added_lines': ['\t    free(reason);', '\t    return;']}",True,LibVNC before commit ca2a5ac02fbbadd0a21fabba779c1ea69173d10b contains heap use-after-free vulnerability in server code of file transfer extension that can result remote code execution.,8.1,HIGH,2,test,2018-10-21T18:52:04Z,2
CVE-2018-16149,['CWE-347'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,igrr/axtls-8266,"Apply CVE fixes for X509 parsing

Apply patches developed by Sze Yiu which correct a vulnerability in
X509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",5efe2947ab45e81d84b5f707c51d1c64be52f36c,https://github.com/igrr/axtls-8266/commit/5efe2947ab45e81d84b5f707c51d1c64be52f36c,ssl/x509.c,sig_verify,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
bigint *modulus, bigint *pub_exp)
{
int i, size;
bigint *decrypted_bi, *dat_bi;
bigint *bir = NULL;
uint8_t *block = (uint8_t *)malloc(sig_len);
dat_bi = bi_import(ctx, sig, sig_len);
ctx->mod_offset = BIGINT_M_OFFSET;
decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);
bi_export(ctx, decrypted_bi, block, sig_len);
ctx->mod_offset = BIGINT_M_OFFSET;
i = 10; 
while (block[i++] && i < sig_len);
size = sig_len - i;
if (size > 0)
{
int len;
const uint8_t *sig_ptr = get_signature(&block[i], &len);
if (sig_ptr)
{
bir = bi_import(ctx, sig_ptr, len);
}
}
free(block);
bi_clear_cache(ctx);
return bir;
}","static bigint *sig_verify(BI_CTX *VAR_0, const uint8_t *VAR_1, int VAR_2,
bigint *VAR_3, bigint *VAR_4)
{
int VAR_5, VAR_6;
bigint *VAR_7, *VAR_8;
bigint *VAR_9 = NULL;
uint8_t *VAR_10 = (uint8_t *)malloc(VAR_2);
VAR_8 = bi_import(VAR_0, VAR_1, VAR_2);
VAR_0->mod_offset = VAR_11;
VAR_7 = bi_mod_power2(VAR_0, VAR_8, VAR_3, VAR_4);
bi_export(VAR_0, VAR_7, VAR_10, VAR_2);
VAR_0->mod_offset = VAR_11;
VAR_5 = 10; 
while (VAR_10[VAR_5++] && VAR_5 < VAR_2);
VAR_6 = VAR_2 - VAR_5;
if (VAR_6 > 0)
{
int VAR_12;
const uint8_t *VAR_13 = get_signature(&VAR_10[VAR_5], &VAR_12);
if (VAR_13)
{
VAR_9 = bi_import(VAR_0, VAR_13, VAR_12);
}
}
free(VAR_10);
bi_clear_cache(VAR_0);
return VAR_9;
}",igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/before/1.json,"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,
        bigint *modulus, bigint *pub_exp)
{
    int i;
    bigint *decrypted_bi, *dat_bi;
    bigint *bir = NULL;
    uint8_t *block = (uint8_t *)malloc(sig_len);

    const uint8_t *sig_prefix = NULL;
    uint8_t sig_prefix_size = 0, hash_len = 0;
    /* adjust our expections */
    switch (sig_type)
    {
        case SIG_TYPE_MD5:
            sig_prefix = sig_prefix_md5;
            sig_prefix_size = sizeof(sig_prefix_md5);
        break;
        case SIG_TYPE_SHA1:
            sig_prefix = sig_prefix_sha1;
            sig_prefix_size = sizeof(sig_prefix_sha1);
        break;
        case SIG_TYPE_SHA256:
            sig_prefix = sig_prefix_sha256;
            sig_prefix_size = sizeof(sig_prefix_sha256);
        break;
        case SIG_TYPE_SHA384:
            sig_prefix = sig_prefix_sha384;
            sig_prefix_size = sizeof(sig_prefix_sha384);
        break;
        case SIG_TYPE_SHA512:
            sig_prefix = sig_prefix_sha512;
            sig_prefix_size = sizeof(sig_prefix_sha512);
        break;
    }
    if (sig_prefix)
        hash_len = sig_prefix[sig_prefix_size - 1];

    /* check length (#A) */
    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)
        goto err;

    /* decrypt */
    dat_bi = bi_import(ctx, sig, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* convert to a normal block */
    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);

    bi_export(ctx, decrypted_bi, block, sig_len);
    ctx->mod_offset = BIGINT_M_OFFSET;

    /* check the first 2 bytes */
    if (block[0] != 0 || block[1] != 1)
        goto err;

    /* check the padding */
    i = 2; /* start at the first padding byte */
    while (i < sig_len - 1 - sig_prefix_size - hash_len)
    { /* together with (#A), we require at least 8 bytes of padding */
        if (block[i++] != 0xFF)
            goto err;
    }

    /* check end of padding */
    if (block[i++] != 0)
        goto err;

    /* check the ASN.1 metadata */
    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))
        goto err;

    /* now we can get the hash we need */
    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);

err:
    free(block);
    /* save a few bytes of memory */
    bi_clear_cache(ctx);
    return bir;
}","static bigint *sig_verify(BI_CTX *VAR_0, const uint8_t *VAR_1, int VAR_2, uint8_t VAR_3,
        bigint *VAR_4, bigint *VAR_5)
{
    int VAR_6;
    bigint *VAR_7, *VAR_8;
    bigint *VAR_9 = NULL;
    uint8_t *VAR_10 = (uint8_t *)malloc(VAR_2);

    const uint8_t *VAR_11 = NULL;
    uint8_t VAR_12 = 0, VAR_13 = 0;
    /* COMMENT_0 */
    switch (VAR_3)
    {
        case VAR_14:
            VAR_11 = VAR_15;
            VAR_12 = sizeof(VAR_15);
        break;
        case VAR_16:
            VAR_11 = VAR_17;
            VAR_12 = sizeof(VAR_17);
        break;
        case VAR_18:
            VAR_11 = VAR_19;
            VAR_12 = sizeof(VAR_19);
        break;
        case VAR_20:
            VAR_11 = VAR_21;
            VAR_12 = sizeof(VAR_21);
        break;
        case VAR_22:
            VAR_11 = VAR_23;
            VAR_12 = sizeof(VAR_23);
        break;
    }
    if (VAR_11)
        VAR_13 = VAR_11[VAR_12 - 1];

    /* COMMENT_1 */
    if (VAR_2 < 2 + 8 + 1 + VAR_12 + VAR_13)
        goto err;

    /* COMMENT_2 */
    VAR_8 = bi_import(VAR_0, VAR_1, VAR_2);
    VAR_0->mod_offset = VAR_24;

    /* COMMENT_3 */
    VAR_7 = bi_mod_power2(VAR_0, VAR_8, VAR_4, VAR_5);

    bi_export(VAR_0, VAR_7, VAR_10, VAR_2);
    VAR_0->mod_offset = VAR_24;

    /* COMMENT_4 */
    if (VAR_10[0] != 0 || VAR_10[1] != 1)
        goto err;

    /* COMMENT_5 */
    VAR_6 = 2; /* COMMENT_6 */
    while (VAR_6 < VAR_2 - 1 - VAR_12 - VAR_13)
    { /* COMMENT_7 */
        if (VAR_10[VAR_6++] != 0xFF)
            goto err;
    }

    /* COMMENT_8 */
    if (VAR_10[VAR_6++] != 0)
        goto err;

    /* COMMENT_9 */
    if (memcmp_P(VAR_10+VAR_6, VAR_11, VAR_12))
        goto err;

    /* COMMENT_10 */
    VAR_9 = bi_import(VAR_0, VAR_10 + VAR_6 + VAR_12, VAR_13);

err:
    free(VAR_10);
    /* COMMENT_11 */
    bi_clear_cache(VAR_0);
    return VAR_9;
}",igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,10 +1,43 @@
-static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,
+static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,
         bigint *modulus, bigint *pub_exp)
 {
-    int i, size;
+    int i;
     bigint *decrypted_bi, *dat_bi;
     bigint *bir = NULL;
     uint8_t *block = (uint8_t *)malloc(sig_len);
+
+    const uint8_t *sig_prefix = NULL;
+    uint8_t sig_prefix_size = 0, hash_len = 0;
+    /* adjust our expections */
+    switch (sig_type)
+    {
+        case SIG_TYPE_MD5:
+            sig_prefix = sig_prefix_md5;
+            sig_prefix_size = sizeof(sig_prefix_md5);
+        break;
+        case SIG_TYPE_SHA1:
+            sig_prefix = sig_prefix_sha1;
+            sig_prefix_size = sizeof(sig_prefix_sha1);
+        break;
+        case SIG_TYPE_SHA256:
+            sig_prefix = sig_prefix_sha256;
+            sig_prefix_size = sizeof(sig_prefix_sha256);
+        break;
+        case SIG_TYPE_SHA384:
+            sig_prefix = sig_prefix_sha384;
+            sig_prefix_size = sizeof(sig_prefix_sha384);
+        break;
+        case SIG_TYPE_SHA512:
+            sig_prefix = sig_prefix_sha512;
+            sig_prefix_size = sizeof(sig_prefix_sha512);
+        break;
+    }
+    if (sig_prefix)
+        hash_len = sig_prefix[sig_prefix_size - 1];
+
+    /* check length (#A) */
+    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)
+        goto err;
 
     /* decrypt */
     dat_bi = bi_import(ctx, sig, sig_len);
@@ -16,21 +49,30 @@
     bi_export(ctx, decrypted_bi, block, sig_len);
     ctx->mod_offset = BIGINT_M_OFFSET;
 
-    i = 10; /* start at the first possible non-padded byte */
-    while (block[i++] && i < sig_len);
-    size = sig_len - i;
+    /* check the first 2 bytes */
+    if (block[0] != 0 || block[1] != 1)
+        goto err;
 
-    /* get only the bit we want */
-    if (size > 0)
-    {
-        int len;
-        const uint8_t *sig_ptr = get_signature(&block[i], &len);
+    /* check the padding */
+    i = 2; /* start at the first padding byte */
+    while (i < sig_len - 1 - sig_prefix_size - hash_len)
+    { /* together with (#A), we require at least 8 bytes of padding */
+        if (block[i++] != 0xFF)
+            goto err;
+    }
 
-        if (sig_ptr)
-        {
-            bir = bi_import(ctx, sig_ptr, len);
-        }
-    }
+    /* check end of padding */
+    if (block[i++] != 0)
+        goto err;
+
+    /* check the ASN.1 metadata */
+    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))
+        goto err;
+
+    /* now we can get the hash we need */
+    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);
+
+err:
     free(block);
     /* save a few bytes of memory */
     bi_clear_cache(ctx);","{'deleted_lines': ['static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,', '    int i, size;', '    i = 10; /* start at the first possible non-padded byte */', '    while (block[i++] && i < sig_len);', '    size = sig_len - i;', '    /* get only the bit we want */', '    if (size > 0)', '    {', '        int len;', '        const uint8_t *sig_ptr = get_signature(&block[i], &len);', '        if (sig_ptr)', '        {', '            bir = bi_import(ctx, sig_ptr, len);', '        }', '    }'], 'added_lines': ['static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,', '    int i;', '', '    const uint8_t *sig_prefix = NULL;', '    uint8_t sig_prefix_size = 0, hash_len = 0;', '    /* adjust our expections */', '    switch (sig_type)', '    {', '        case SIG_TYPE_MD5:', '            sig_prefix = sig_prefix_md5;', '            sig_prefix_size = sizeof(sig_prefix_md5);', '        break;', '        case SIG_TYPE_SHA1:', '            sig_prefix = sig_prefix_sha1;', '            sig_prefix_size = sizeof(sig_prefix_sha1);', '        break;', '        case SIG_TYPE_SHA256:', '            sig_prefix = sig_prefix_sha256;', '            sig_prefix_size = sizeof(sig_prefix_sha256);', '        break;', '        case SIG_TYPE_SHA384:', '            sig_prefix = sig_prefix_sha384;', '            sig_prefix_size = sizeof(sig_prefix_sha384);', '        break;', '        case SIG_TYPE_SHA512:', '            sig_prefix = sig_prefix_sha512;', '            sig_prefix_size = sizeof(sig_prefix_sha512);', '        break;', '    }', '    if (sig_prefix)', '        hash_len = sig_prefix[sig_prefix_size - 1];', '', '    /* check length (#A) */', '    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)', '        goto err;', '    /* check the first 2 bytes */', '    if (block[0] != 0 || block[1] != 1)', '        goto err;', '    /* check the padding */', '    i = 2; /* start at the first padding byte */', '    while (i < sig_len - 1 - sig_prefix_size - hash_len)', '    { /* together with (#A), we require at least 8 bytes of padding */', '        if (block[i++] != 0xFF)', '            goto err;', '    }', '    /* check end of padding */', '    if (block[i++] != 0)', '        goto err;', '', '    /* check the ASN.1 metadata */', '    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))', '        goto err;', '', '    /* now we can get the hash we need */', '    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);', '', 'err:']}",True,"In sig_verify() in x509.c in axTLS version 2.1.3 and before, the PKCS#1 v1.5 signature verification blindly trusts the declared lengths in the ASN.1 structure. Consequently, when small public exponents are being used, a remote attacker can generate purposefully crafted signatures (and put them on X.509 certificates) to induce illegal memory access and crash the verifier.",5.9,MEDIUM,1,test,2018-10-22T20:37:13Z,2
CVE-2018-16149,['CWE-347'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,igrr/axtls-8266,"Apply CVE fixes for X509 parsing

Apply patches developed by Sze Yiu which correct a vulnerability in
X509 parsing.  See CVE-2018-16150 and CVE-2018-16149 for more info.",5efe2947ab45e81d84b5f707c51d1c64be52f36c,https://github.com/igrr/axtls-8266/commit/5efe2947ab45e81d84b5f707c51d1c64be52f36c,ssl/x509.c,x509_verify,"int x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert, 
int *pathLenConstraint) 
{
int ret = X509_OK, i = 0;
bigint *cert_sig;
X509_CTX *next_cert = NULL;
BI_CTX *ctx = NULL;
bigint *mod = NULL, *expn = NULL;
int match_ca_cert = 0;
struct timeval tv;
uint8_t is_self_signed = 0;
if (cert == NULL)
{
ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       
goto end_verify;
}
if (asn1_compare_dn(cert->ca_cert_dn, cert->cert_dn) == 0)
{
is_self_signed = 1;
ctx = cert->rsa_ctx->bi_ctx;
mod = cert->rsa_ctx->m;
expn = cert->rsa_ctx->e;
}
gettimeofday(&tv, NULL);
if (tv.tv_sec < cert->not_before)
{
ret = X509_VFY_ERROR_NOT_YET_VALID;
goto end_verify;
}
if (tv.tv_sec > cert->not_after)
{
ret = X509_VFY_ERROR_EXPIRED;
goto end_verify;
}
if (cert->basic_constraint_present)
{
if (!cert->basic_constraint_cA &&
IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))
{
ret = X509_VFY_ERROR_BASIC_CONSTRAINT;
goto end_verify;
}
if (cert->basic_constraint_cA &&
(!cert->key_usage_present || 
IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN)) &&
(cert->basic_constraint_pathLenConstraint+1) < *pathLenConstraint)
{
ret = X509_VFY_ERROR_BASIC_CONSTRAINT;
goto end_verify;
}
}
next_cert = cert->next;
if (next_cert == NULL)
{
if (ca_cert_ctx != NULL) 
{
while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])
{
if (cert->basic_constraint_present && 
!ca_cert_ctx->cert[i]->basic_constraint_cA)
continue;
if (asn1_compare_dn(cert->ca_cert_dn,
ca_cert_ctx->cert[i]->cert_dn) == 0)
{
match_ca_cert = true;
ctx = ca_cert_ctx->cert[i]->rsa_ctx->bi_ctx;
mod = ca_cert_ctx->cert[i]->rsa_ctx->m;
expn = ca_cert_ctx->cert[i]->rsa_ctx->e;
break;
}
i++;
}
}
if (!match_ca_cert && !is_self_signed)
{
ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       
goto end_verify;
}
}
else if (asn1_compare_dn(cert->ca_cert_dn, next_cert->cert_dn) != 0)
{
ret = X509_VFY_ERROR_INVALID_CHAIN;
goto end_verify;
}
else 
{
ctx = next_cert->rsa_ctx->bi_ctx;
mod = next_cert->rsa_ctx->m;
expn = next_cert->rsa_ctx->e;
}
if (!match_ca_cert && is_self_signed)
{
ret = X509_VFY_ERROR_SELF_SIGNED;
goto end_verify;
}
cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, 
bi_clone(ctx, mod), bi_clone(ctx, expn));
if (cert_sig && cert->digest)
{
if (bi_compare(cert_sig, cert->digest) != 0)
ret = X509_VFY_ERROR_BAD_SIGNATURE;
bi_free(ctx, cert_sig);
}
else
{
ret = X509_VFY_ERROR_BAD_SIGNATURE;
}
bi_clear_cache(ctx);
if (ret)
goto end_verify;
if (next_cert != NULL)
{
(*pathLenConstraint)++; 
ret = x509_verify(ca_cert_ctx, next_cert, pathLenConstraint);
}
end_verify:
return ret;
}","int x509_verify(const CA_CERT_CTX *VAR_0, const X509_CTX *VAR_1, 
int *VAR_2) 
{
int VAR_3 = VAR_4, VAR_5 = 0;
bigint *VAR_6;
X509_CTX *VAR_7 = NULL;
BI_CTX *VAR_8 = NULL;
bigint *VAR_9 = NULL, *VAR_10 = NULL;
int VAR_11 = 0;
struct timeval VAR_12;
uint8_t VAR_13 = 0;
if (VAR_1 == NULL)
{
VAR_3 = VAR_14;       
goto end_verify;
}
if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_1->cert_dn) == 0)
{
VAR_13 = 1;
VAR_8 = VAR_1->rsa_ctx->bi_ctx;
VAR_9 = VAR_1->rsa_ctx->m;
VAR_10 = VAR_1->rsa_ctx->e;
}
gettimeofday(&VAR_12, NULL);
if (VAR_12.tv_sec < VAR_1->not_before)
{
VAR_3 = VAR_15;
goto end_verify;
}
if (VAR_12.tv_sec > VAR_1->not_after)
{
VAR_3 = VAR_16;
goto end_verify;
}
if (VAR_1->basic_constraint_present)
{
if (!VAR_1->basic_constraint_cA &&
IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17))
{
VAR_3 = VAR_18;
goto end_verify;
}
if (VAR_1->basic_constraint_cA &&
(!VAR_1->key_usage_present || 
IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17)) &&
(VAR_1->basic_constraint_pathLenConstraint+1) < *VAR_2)
{
VAR_3 = VAR_18;
goto end_verify;
}
}
VAR_7 = VAR_1->next;
if (VAR_7 == NULL)
{
if (VAR_0 != NULL) 
{
while (VAR_5 < VAR_19 && VAR_0->cert[VAR_5])
{
if (VAR_1->basic_constraint_present && 
!VAR_0->cert[VAR_5]->basic_constraint_cA)
continue;
if (asn1_compare_dn(VAR_1->ca_cert_dn,
VAR_0->cert[VAR_5]->cert_dn) == 0)
{
VAR_11 = true;
VAR_8 = VAR_0->cert[VAR_5]->rsa_ctx->bi_ctx;
VAR_9 = VAR_0->cert[VAR_5]->rsa_ctx->m;
VAR_10 = VAR_0->cert[VAR_5]->rsa_ctx->e;
break;
}
VAR_5++;
}
}
if (!VAR_11 && !VAR_13)
{
VAR_3 = VAR_14;       
goto end_verify;
}
}
else if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_7->cert_dn) != 0)
{
VAR_3 = VAR_20;
goto end_verify;
}
else 
{
VAR_8 = VAR_7->rsa_ctx->bi_ctx;
VAR_9 = VAR_7->rsa_ctx->m;
VAR_10 = VAR_7->rsa_ctx->e;
}
if (!VAR_11 && VAR_13)
{
VAR_3 = VAR_21;
goto end_verify;
}
VAR_6 = sig_verify(VAR_8, VAR_1->signature, VAR_1->sig_len, 
bi_clone(VAR_8, VAR_9), bi_clone(VAR_8, VAR_10));
if (VAR_6 && VAR_1->digest)
{
if (bi_compare(VAR_6, VAR_1->digest) != 0)
VAR_3 = VAR_22;
bi_free(VAR_8, VAR_6);
}
else
{
VAR_3 = VAR_22;
}
bi_clear_cache(VAR_8);
if (VAR_3)
goto end_verify;
if (VAR_7 != NULL)
{
(*VAR_2)++; 
VAR_3 = x509_verify(VAR_0, VAR_7, VAR_2);
}
end_verify:
return VAR_3;
}",igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/before/0.json,"int x509_verify(const CA_CERT_CTX *ca_cert_ctx, const X509_CTX *cert, 
        int *pathLenConstraint) 
{
    int ret = X509_OK, i = 0;
    bigint *cert_sig;
    X509_CTX *next_cert = NULL;
    BI_CTX *ctx = NULL;
    bigint *mod = NULL, *expn = NULL;
    int match_ca_cert = 0;
    struct timeval tv;
    uint8_t is_self_signed = 0;

    if (cert == NULL)
    {
        ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       
        goto end_verify;
    }

    /* a self-signed certificate that is not in the CA store - use this 
       to check the signature */
    if (asn1_compare_dn(cert->ca_cert_dn, cert->cert_dn) == 0)
    {
        is_self_signed = 1;
        ctx = cert->rsa_ctx->bi_ctx;
        mod = cert->rsa_ctx->m;
        expn = cert->rsa_ctx->e;
    }

    gettimeofday(&tv, NULL);

    /* check the not before date */
    if (tv.tv_sec < cert->not_before)
    {
        ret = X509_VFY_ERROR_NOT_YET_VALID;
        goto end_verify;
    }

    /* check the not after date */
    if (tv.tv_sec > cert->not_after)
    {
        ret = X509_VFY_ERROR_EXPIRED;
        goto end_verify;
    }

    if (cert->basic_constraint_present)
    {
        /* If the cA boolean is not asserted,
           then the keyCertSign bit in the key usage extension MUST NOT be
           asserted. */
        if (!cert->basic_constraint_cA &&
                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN))
        {
            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;
            goto end_verify;
        }

        /* The pathLenConstraint field is meaningful only if the cA boolean is
           asserted and the key usage extension, if present, asserts the
           keyCertSign bit.  In this case, it gives the maximum number of 
           non-self-issued intermediate certificates that may follow this 
           certificate in a valid certification path. */
        if (cert->basic_constraint_cA &&
            (!cert->key_usage_present || 
                IS_SET_KEY_USAGE_FLAG(cert, KEY_USAGE_KEY_CERT_SIGN)) &&
            (cert->basic_constraint_pathLenConstraint+1) < *pathLenConstraint)
        {
            ret = X509_VFY_ERROR_BASIC_CONSTRAINT;
            goto end_verify;
        }
    }

    next_cert = cert->next;

    /* last cert in the chain - look for a trusted cert */
    if (next_cert == NULL)
    {
       if (ca_cert_ctx != NULL) 
       {
            /* go thru the CA store */
            while (i < CONFIG_X509_MAX_CA_CERTS && ca_cert_ctx->cert[i])
            {
                /* the extension is present but the cA boolean is not 
                   asserted, then the certified public key MUST NOT be used 
                   to verify certificate signatures. */
                if (cert->basic_constraint_present && 
                        !ca_cert_ctx->cert[i]->basic_constraint_cA)
                    continue;
                        
                if (asn1_compare_dn(cert->ca_cert_dn,
                                            ca_cert_ctx->cert[i]->cert_dn) == 0)
                {
                    /* use this CA certificate for signature verification */
                    match_ca_cert = true;
                    ctx = ca_cert_ctx->cert[i]->rsa_ctx->bi_ctx;
                    mod = ca_cert_ctx->cert[i]->rsa_ctx->m;
                    expn = ca_cert_ctx->cert[i]->rsa_ctx->e;


                    break;
                }

                i++;
            }
        }

        /* couldn't find a trusted cert (& let self-signed errors 
           be returned) */
        if (!match_ca_cert && !is_self_signed)
        {
            ret = X509_VFY_ERROR_NO_TRUSTED_CERT;       
            goto end_verify;
        }
    }
    else if (asn1_compare_dn(cert->ca_cert_dn, next_cert->cert_dn) != 0)
    {
        /* check the chain */
        ret = X509_VFY_ERROR_INVALID_CHAIN;
        goto end_verify;
    }
    else /* use the next certificate in the chain for signature verify */
    {
        ctx = next_cert->rsa_ctx->bi_ctx;
        mod = next_cert->rsa_ctx->m;
        expn = next_cert->rsa_ctx->e;
    }

    /* cert is self signed */
    if (!match_ca_cert && is_self_signed)
    {
        ret = X509_VFY_ERROR_SELF_SIGNED;
        goto end_verify;
    }

    /* check the signature */
    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,
                        bi_clone(ctx, mod), bi_clone(ctx, expn));

    if (cert_sig && cert->digest)
    {
        if (bi_compare(cert_sig, cert->digest) != 0)
            ret = X509_VFY_ERROR_BAD_SIGNATURE;


        bi_free(ctx, cert_sig);
    }
    else
    {
        ret = X509_VFY_ERROR_BAD_SIGNATURE;
    }

    bi_clear_cache(ctx);

    if (ret)
        goto end_verify;

    /* go down the certificate chain using recursion. */
    if (next_cert != NULL)
    {
        (*pathLenConstraint)++; /* don't include last certificate */
        ret = x509_verify(ca_cert_ctx, next_cert, pathLenConstraint);
    }

end_verify:
    return ret;
}","int x509_verify(const CA_CERT_CTX *VAR_0, const X509_CTX *VAR_1, 
        int *VAR_2) 
{
    int VAR_3 = VAR_4, VAR_5 = 0;
    bigint *VAR_6;
    X509_CTX *VAR_7 = NULL;
    BI_CTX *VAR_8 = NULL;
    bigint *VAR_9 = NULL, *VAR_10 = NULL;
    int VAR_11 = 0;
    struct timeval VAR_12;
    uint8_t VAR_13 = 0;

    if (VAR_1 == NULL)
    {
        VAR_3 = VAR_14;       
        goto end_verify;
    }

    /* COMMENT_0 */
                                
    if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_1->cert_dn) == 0)
    {
        VAR_13 = 1;
        VAR_8 = VAR_1->rsa_ctx->bi_ctx;
        VAR_9 = VAR_1->rsa_ctx->m;
        VAR_10 = VAR_1->rsa_ctx->e;
    }

    gettimeofday(&VAR_12, NULL);

    /* COMMENT_2 */
    if (VAR_12.tv_sec < VAR_1->not_before)
    {
        VAR_3 = VAR_15;
        goto end_verify;
    }

    /* COMMENT_3 */
    if (VAR_12.tv_sec > VAR_1->not_after)
    {
        VAR_3 = VAR_16;
        goto end_verify;
    }

    if (VAR_1->basic_constraint_present)
    {
        /* COMMENT_4 */
                                                                          
                       
        if (!VAR_1->basic_constraint_cA &&
                IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17))
        {
            VAR_3 = VAR_18;
            goto end_verify;
        }

        /* COMMENT_7 */
                                                                        
                                                                          
                                                                          
                                                        
        if (VAR_1->basic_constraint_cA &&
            (!VAR_1->key_usage_present || 
                IS_SET_KEY_USAGE_FLAG(VAR_1, VAR_17)) &&
            (VAR_1->basic_constraint_pathLenConstraint+1) < *VAR_2)
        {
            VAR_3 = VAR_18;
            goto end_verify;
        }
    }

    VAR_7 = VAR_1->next;

    /* COMMENT_12 */
    if (VAR_7 == NULL)
    {
       if (VAR_0 != NULL) 
       {
            /* COMMENT_13 */
            while (VAR_5 < VAR_19 && VAR_0->cert[VAR_5])
            {
                /* COMMENT_14 */
                                                                            
                                                       
                if (VAR_1->basic_constraint_present && 
                        !VAR_0->cert[VAR_5]->basic_constraint_cA)
                    continue;
                        
                if (asn1_compare_dn(VAR_1->ca_cert_dn,
                                            VAR_0->cert[VAR_5]->cert_dn) == 0)
                {
                    /* COMMENT_17 */
                    VAR_11 = true;
                    VAR_8 = VAR_0->cert[VAR_5]->rsa_ctx->bi_ctx;
                    VAR_9 = VAR_0->cert[VAR_5]->rsa_ctx->m;
                    VAR_10 = VAR_0->cert[VAR_5]->rsa_ctx->e;


                    break;
                }

                VAR_5++;
            }
        }

        /* COMMENT_18 */
                          
        if (!VAR_11 && !VAR_13)
        {
            VAR_3 = VAR_14;       
            goto end_verify;
        }
    }
    else if (asn1_compare_dn(VAR_1->ca_cert_dn, VAR_7->cert_dn) != 0)
    {
        /* COMMENT_20 */
        VAR_3 = VAR_20;
        goto end_verify;
    }
    else /* COMMENT_21 */
    {
        VAR_8 = VAR_7->rsa_ctx->bi_ctx;
        VAR_9 = VAR_7->rsa_ctx->m;
        VAR_10 = VAR_7->rsa_ctx->e;
    }

    /* COMMENT_22 */
    if (!VAR_11 && VAR_13)
    {
        VAR_3 = VAR_21;
        goto end_verify;
    }

    /* COMMENT_23 */
    VAR_6 = sig_verify(VAR_8, VAR_1->signature, VAR_1->sig_len, VAR_1->sig_type,
                        bi_clone(VAR_8, VAR_9), bi_clone(VAR_8, VAR_10));

    if (VAR_6 && VAR_1->digest)
    {
        if (bi_compare(VAR_6, VAR_1->digest) != 0)
            VAR_3 = VAR_22;


        bi_free(VAR_8, VAR_6);
    }
    else
    {
        VAR_3 = VAR_22;
    }

    bi_clear_cache(VAR_8);

    if (VAR_3)
        goto end_verify;

    /* COMMENT_24 */
    if (VAR_7 != NULL)
    {
        (*VAR_2)++; /* COMMENT_25 */
        VAR_3 = x509_verify(VAR_0, VAR_7, VAR_2);
    }

end_verify:
    return VAR_3;
}",igrr/axtls-8266/5efe2947ab45e81d84b5f707c51d1c64be52f36c/x509.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -132,7 +132,7 @@
     }
 
     /* check the signature */
-    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, 
+    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,
                         bi_clone(ctx, mod), bi_clone(ctx, expn));
 
     if (cert_sig && cert->digest)","{'deleted_lines': ['    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, '], 'added_lines': ['    cert_sig = sig_verify(ctx, cert->signature, cert->sig_len, cert->sig_type,']}",True,"In sig_verify() in x509.c in axTLS version 2.1.3 and before, the PKCS#1 v1.5 signature verification blindly trusts the declared lengths in the ASN.1 structure. Consequently, when small public exponents are being used, a remote attacker can generate purposefully crafted signatures (and put them on X.509 certificates) to induce illegal memory access and crash the verifier.",5.9,MEDIUM,1,test,2018-10-22T20:37:13Z,2
CVE-2018-19045,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,acassen/keepalived,"Add command line and configuration option to set umask

Issue #1048 identified that files created by keepalived are created
with mode 0666. This commit changes the default to 0644, and also
allows the umask to be specified in the configuration or as a command
line option.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,keepalived/core/main.c,keepalived_main,"int
keepalived_main(int argc, char **argv)
{
bool report_stopped = true;
struct utsname uname_buf;
char *end;
set_time_now();
save_cmd_line_options(argc, argv);
debug = 0;
#ifndef _DEBUG_
prog_type = PROG_TYPE_PARENT;
#endif
#ifdef _WITH_VRRP_
__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
__set_bit(DAEMON_BFD, &daemon_mode);
#endif
openlog(PACKAGE_NAME, LOG_PID, log_facility);
#ifdef _MEM_CHECK_
mem_log_init(PACKAGE_NAME, ""Parent process"");
#endif
if (uname(&uname_buf))
log_message(LOG_INFO, ""Unable to get uname() information - error %d"", errno);
else {
os_major = (unsigned)strtoul(uname_buf.release, &end, 10);
if (*end != '.')
os_major = 0;
else {
os_minor = (unsigned)strtoul(end + 1, &end, 10);
if (*end != '.')
os_major = 0;
else {
if (!isdigit(end[1]))
os_major = 0;
else
os_release = (unsigned)strtoul(end + 1, &end, 10);
}
}
if (!os_major)
log_message(LOG_INFO, ""Unable to parse kernel version %s"", uname_buf.release);
if (!config_id) {
end = strchrnul(uname_buf.nodename, '.');
config_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);
strncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));
config_id[end - uname_buf.nodename] = '\0';
}
}
if (parse_cmdline(argc, argv)) {
closelog();
if (!__test_bit(NO_SYSLOG_BIT, &debug))
openlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);
}
if (__test_bit(LOG_CONSOLE_BIT, &debug))
enable_console_log();
#ifdef GIT_COMMIT
log_message(LOG_INFO, ""Starting %s, git commit %s"", version_string, GIT_COMMIT);
#else
log_message(LOG_INFO, ""Starting %s"", version_string);
#endif
core_dump_init();
if (os_major) {
if (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {
log_message(LOG_INFO, ""WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s"",
(LINUX_VERSION_CODE >> 16) & 0xff,
(LINUX_VERSION_CODE >>  8) & 0xff,
(LINUX_VERSION_CODE      ) & 0xff,
uname_buf.sysname, uname_buf.release, uname_buf.version);
} else {
log_message(LOG_INFO, ""Running on %s %s %s (built for Linux %d.%d.%d)"",
uname_buf.sysname, uname_buf.release, uname_buf.version,
(LINUX_VERSION_CODE >> 16) & 0xff,
(LINUX_VERSION_CODE >>  8) & 0xff,
(LINUX_VERSION_CODE      ) & 0xff);
}
}
#ifndef _DEBUG_
log_command_line(0);
#endif
if (!check_conf_file(conf_file)) {
if (__test_bit(CONFIG_TEST_BIT, &debug))
config_test_exit();
goto end;
}
global_data = alloc_global_data();
read_config_file();
init_global_data(global_data, NULL);
#if HAVE_DECL_CLONE_NEWNET
if (override_namespace) {
if (global_data->network_namespace) {
log_message(LOG_INFO, ""Overriding config net_namespace '%s' with command line namespace '%s'"", global_data->network_namespace, override_namespace);
FREE(global_data->network_namespace);
}
global_data->network_namespace = override_namespace;
override_namespace = NULL;
}
#endif
if (!__test_bit(CONFIG_TEST_BIT, &debug) &&
(global_data->instance_name
#if HAVE_DECL_CLONE_NEWNET
|| global_data->network_namespace
#endif
)) {
if ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {
log_message(LOG_INFO, ""Changing syslog ident to %s"", syslog_ident);
closelog();
openlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);
}
else
log_message(LOG_INFO, ""Unable to change syslog ident"");
use_pid_dir = true;
open_log_file(log_file_name,
NULL,
#if HAVE_DECL_CLONE_NEWNET
global_data->network_namespace,
#else
NULL,
#endif
global_data->instance_name);
}
set_child_finder_name(find_keepalived_child_name);
if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
if (use_pid_dir) {
create_pid_dir();
}
}
#if HAVE_DECL_CLONE_NEWNET
if (global_data->network_namespace) {
if (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {
log_message(LOG_ERR, ""Unable to set network namespace %s - exiting"", global_data->network_namespace);
goto end;
}
}
#endif
if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
if (global_data->instance_name) {
if (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))
free_main_pidfile = true;
#ifdef _WITH_LVS_
if (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))
free_checkers_pidfile = true;
#endif
#ifdef _WITH_VRRP_
if (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))
free_vrrp_pidfile = true;
#endif
#ifdef _WITH_BFD_
if (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))
free_bfd_pidfile = true;
#endif
}
if (use_pid_dir) {
if (!main_pidfile)
main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;
#ifdef _WITH_LVS_
if (!checkers_pidfile)
checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_VRRP_
if (!vrrp_pidfile)
vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_BFD_
if (!bfd_pidfile)
bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;
#endif
}
else
{
if (!main_pidfile)
main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;
#ifdef _WITH_LVS_
if (!checkers_pidfile)
checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_VRRP_
if (!vrrp_pidfile)
vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_BFD_
if (!bfd_pidfile)
bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;
#endif
}
if (keepalived_running(daemon_mode)) {
log_message(LOG_INFO, ""daemon is already running"");
report_stopped = false;
goto end;
}
}
if (!__test_bit(DONT_FORK_BIT, &debug) &&
xdaemon(false, false, true) > 0) {
closelog();
FREE_PTR(config_id);
FREE_PTR(orig_core_dump_pattern);
close_std_fd();
exit(0);
}
umask(0);
#ifdef _MEM_CHECK_
enable_mem_log_termination();
#endif
if (__test_bit(CONFIG_TEST_BIT, &debug)) {
validate_config();
config_test_exit();
}
if (!pidfile_write(main_pidfile, getpid()))
goto end;
master = thread_make_master();
signal_init();
if (!start_keepalived())
log_message(LOG_INFO, ""Warning - keepalived has no configuration to run"");
initialise_debug_options();
#ifdef THREAD_DUMP
register_parent_thread_addresses();
#endif
launch_thread_scheduler(master);
stop_keepalived();
#ifdef THREAD_DUMP
deregister_thread_addresses();
#endif
end:
if (report_stopped) {
#ifdef GIT_COMMIT
log_message(LOG_INFO, ""Stopped %s, git commit %s"", version_string, GIT_COMMIT);
#else
log_message(LOG_INFO, ""Stopped %s"", version_string);
#endif
}
#if HAVE_DECL_CLONE_NEWNET
if (global_data && global_data->network_namespace)
clear_namespaces();
#endif
if (use_pid_dir)
remove_pid_dir();
if (orig_core_dump_pattern)
update_core_dump_pattern(orig_core_dump_pattern);
free_parent_mallocs_startup(false);
free_parent_mallocs_exit();
free_global_data(global_data);
closelog();
#ifndef _MEM_CHECK_LOG_
FREE_PTR(syslog_ident);
#else
if (syslog_ident)
free(syslog_ident);
#endif
close_std_fd();
exit(KEEPALIVED_EXIT_OK);
}","int
keepalived_main(int VAR_0, char **VAR_1)
{
bool VAR_2 = true;
struct utsname VAR_3;
char *VAR_4;
set_time_now();
save_cmd_line_options(VAR_0, VAR_1);
VAR_5 = 0;
#ifndef VAR_6
VAR_7 = VAR_8;
#endif
#ifdef VAR_9
__set_bit(VAR_10, &VAR_11);
#endif
#ifdef VAR_12
__set_bit(VAR_13, &VAR_11);
#endif
#ifdef VAR_14
__set_bit(VAR_15, &VAR_11);
#endif
openlog(VAR_16, VAR_17, VAR_18);
#ifdef VAR_19
mem_log_init(VAR_16, ""Parent process"");
#endif
if (uname(&VAR_3))
log_message(VAR_20, ""Unable to get uname() information - error %d"", VAR_21);
else {
VAR_22 = (unsigned)strtoul(VAR_3.release, &VAR_4, 10);
if (*VAR_4 != '.')
VAR_22 = 0;
else {
VAR_23 = (unsigned)strtoul(VAR_4 + 1, &VAR_4, 10);
if (*VAR_4 != '.')
VAR_22 = 0;
else {
if (!isdigit(VAR_4[1]))
VAR_22 = 0;
else
VAR_24 = (unsigned)strtoul(VAR_4 + 1, &VAR_4, 10);
}
}
if (!VAR_22)
log_message(VAR_20, ""Unable to parse kernel version %s"", VAR_3.release);
if (!VAR_25) {
VAR_4 = strchrnul(VAR_3.nodename, '.');
VAR_25 = MALLOC((size_t)(VAR_4 - VAR_3.nodename) + 1);
strncpy(VAR_25, VAR_3.nodename, (size_t)(VAR_4 - VAR_3.nodename));
VAR_25[VAR_4 - VAR_3.nodename] = '\0';
}
}
if (parse_cmdline(VAR_0, VAR_1)) {
closelog();
if (!__test_bit(VAR_26, &VAR_5))
openlog(VAR_16, VAR_17 | ((__test_bit(VAR_27, &VAR_5)) ? VAR_28 : 0) , VAR_18);
}
if (__test_bit(VAR_27, &VAR_5))
enable_console_log();
#ifdef VAR_29
log_message(VAR_20, ""Starting %s, git commit %s"", VAR_30, VAR_29);
#else
log_message(VAR_20, ""Starting %s"", VAR_30);
#endif
core_dump_init();
if (VAR_22) {
if (KERNEL_VERSION(VAR_22, VAR_23, VAR_24) < VAR_31) {
log_message(VAR_20, ""WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s"",
(VAR_31 >> 16) & 0xff,
(VAR_31 >>  8) & 0xff,
(VAR_31      ) & 0xff,
VAR_3.sysname, VAR_3.release, VAR_3.version);
} else {
log_message(VAR_20, ""Running on %s %s %s (built for Linux %d.%d.%d)"",
VAR_3.sysname, VAR_3.release, VAR_3.version,
(VAR_31 >> 16) & 0xff,
(VAR_31 >>  8) & 0xff,
(VAR_31      ) & 0xff);
}
}
#ifndef VAR_6
log_command_line(0);
#endif
if (!check_conf_file(VAR_32)) {
if (__test_bit(VAR_33, &VAR_5))
config_test_exit();
goto end;
}
VAR_34 = alloc_global_data();
read_config_file();
init_global_data(VAR_34, NULL);
#if VAR_35
if (VAR_36) {
if (VAR_34->network_namespace) {
log_message(VAR_20, ""Overriding config net_namespace '%s' with command line namespace '%s'"", VAR_34->network_namespace, VAR_36);
FREE(VAR_34->network_namespace);
}
VAR_34->network_namespace = VAR_36;
VAR_36 = NULL;
}
#endif
if (!__test_bit(VAR_33, &VAR_5) &&
(VAR_34->instance_name
#if VAR_35
|| VAR_34->network_namespace
#endif
)) {
if ((VAR_37 = make_syslog_ident(VAR_16))) {
log_message(VAR_20, ""Changing syslog ident to %s"", VAR_37);
closelog();
openlog(VAR_37, VAR_17 | ((__test_bit(VAR_27, &VAR_5)) ? VAR_28 : 0), VAR_18);
}
else
log_message(VAR_20, ""Unable to change syslog ident"");
VAR_38 = true;
open_log_file(VAR_39,
NULL,
#if VAR_35
VAR_34->network_namespace,
#else
NULL,
#endif
VAR_34->instance_name);
}
set_child_finder_name(VAR_40);
if (!__test_bit(VAR_33, &VAR_5)) {
if (VAR_38) {
create_pid_dir();
}
}
#if VAR_35
if (VAR_34->network_namespace) {
if (VAR_34->network_namespace && !set_namespaces(VAR_34->network_namespace)) {
log_message(VAR_41, ""Unable to set network namespace %s - exiting"", VAR_34->network_namespace);
goto end;
}
}
#endif
if (!__test_bit(VAR_33, &VAR_5)) {
if (VAR_34->instance_name) {
if (!VAR_42 && (VAR_42 = make_pidfile_name(VAR_43 VAR_44, VAR_34->instance_name, VAR_45)))
VAR_46 = true;
#ifdef VAR_12
if (!VAR_47 && (VAR_47 = make_pidfile_name(VAR_43 VAR_48, VAR_34->instance_name, VAR_45)))
VAR_49 = true;
#endif
#ifdef VAR_9
if (!VAR_50 && (VAR_50 = make_pidfile_name(VAR_43 VAR_51, VAR_34->instance_name, VAR_45)))
VAR_52 = true;
#endif
#ifdef VAR_14
if (!VAR_53 && (VAR_53 = make_pidfile_name(VAR_43 VAR_51, VAR_34->instance_name, VAR_45)))
VAR_54 = true;
#endif
}
if (VAR_38) {
if (!VAR_42)
VAR_42 = VAR_43 KEEPALIVED_PID_FILE VAR_45;
#ifdef VAR_12
if (!VAR_47)
VAR_47 = VAR_43 CHECKERS_PID_FILE VAR_45;
#endif
#ifdef VAR_9
if (!VAR_50)
VAR_50 = VAR_43 VRRP_PID_FILE VAR_45;
#endif
#ifdef VAR_14
if (!VAR_53)
VAR_53 = VAR_43 BFD_PID_FILE VAR_45;
#endif
}
else
{
if (!VAR_42)
VAR_42 = VAR_55 KEEPALIVED_PID_FILE VAR_45;
#ifdef VAR_12
if (!VAR_47)
VAR_47 = VAR_55 CHECKERS_PID_FILE VAR_45;
#endif
#ifdef VAR_9
if (!VAR_50)
VAR_50 = VAR_55 VRRP_PID_FILE VAR_45;
#endif
#ifdef VAR_14
if (!VAR_53)
VAR_53 = VAR_55 BFD_PID_FILE VAR_45;
#endif
}
if (keepalived_running(VAR_11)) {
log_message(VAR_20, ""daemon is already running"");
VAR_2 = false;
goto end;
}
}
if (!__test_bit(VAR_56, &VAR_5) &&
xdaemon(false, false, true) > 0) {
closelog();
FREE_PTR(VAR_25);
FREE_PTR(VAR_57);
close_std_fd();
exit(0);
}
umask(0);
#ifdef VAR_19
enable_mem_log_termination();
#endif
if (__test_bit(VAR_33, &VAR_5)) {
validate_config();
config_test_exit();
}
if (!pidfile_write(VAR_42, getpid()))
goto end;
VAR_58 = thread_make_master();
signal_init();
if (!start_keepalived())
log_message(VAR_20, ""Warning - keepalived has no configuration to run"");
initialise_debug_options();
#ifdef VAR_59
register_parent_thread_addresses();
#endif
launch_thread_scheduler(VAR_58);
stop_keepalived();
#ifdef VAR_59
deregister_thread_addresses();
#endif
end:
if (VAR_2) {
#ifdef VAR_29
log_message(VAR_20, ""Stopped %s, git commit %s"", VAR_30, VAR_29);
#else
log_message(VAR_20, ""Stopped %s"", VAR_30);
#endif
}
#if VAR_35
if (VAR_34 && VAR_34->network_namespace)
clear_namespaces();
#endif
if (VAR_38)
remove_pid_dir();
if (VAR_57)
update_core_dump_pattern(VAR_57);
free_parent_mallocs_startup(false);
free_parent_mallocs_exit();
free_global_data(VAR_34);
closelog();
#ifndef VAR_60
FREE_PTR(VAR_37);
#else
if (VAR_37)
free(VAR_37);
#endif
close_std_fd();
exit(VAR_61);
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/main.c/vul/before/1.json,"int
keepalived_main(int argc, char **argv)
{
	bool report_stopped = true;
	struct utsname uname_buf;
	char *end;

	/* Ensure time_now is set. We then don't have to check anywhere
	 * else if it is set. */
	set_time_now();

	/* Save command line options in case need to log them later */
	save_cmd_line_options(argc, argv);

	/* Init debugging level */
	debug = 0;

	/* We are the parent process */
#ifndef _DEBUG_
	prog_type = PROG_TYPE_PARENT;
#endif

	/* Initialise daemon_mode */
#ifdef _WITH_VRRP_
	__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
	__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
	__set_bit(DAEMON_BFD, &daemon_mode);
#endif

	/* Set default file creation mask */
	umask(022);

	/* Open log with default settings so we can log initially */
	openlog(PACKAGE_NAME, LOG_PID, log_facility);

#ifdef _MEM_CHECK_
	mem_log_init(PACKAGE_NAME, ""Parent process"");
#endif

	/* Some functionality depends on kernel version, so get the version here */
	if (uname(&uname_buf))
		log_message(LOG_INFO, ""Unable to get uname() information - error %d"", errno);
	else {
		os_major = (unsigned)strtoul(uname_buf.release, &end, 10);
		if (*end != '.')
			os_major = 0;
		else {
			os_minor = (unsigned)strtoul(end + 1, &end, 10);
			if (*end != '.')
				os_major = 0;
			else {
				if (!isdigit(end[1]))
					os_major = 0;
				else
					os_release = (unsigned)strtoul(end + 1, &end, 10);
			}
		}
		if (!os_major)
			log_message(LOG_INFO, ""Unable to parse kernel version %s"", uname_buf.release);

		/* config_id defaults to hostname */
		if (!config_id) {
			end = strchrnul(uname_buf.nodename, '.');
			config_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);
			strncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));
			config_id[end - uname_buf.nodename] = '\0';
		}
	}

	/*
	 * Parse command line and set debug level.
	 * bits 0..7 reserved by main.c
	 */
	if (parse_cmdline(argc, argv)) {
		closelog();
		if (!__test_bit(NO_SYSLOG_BIT, &debug))
			openlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);
	}

	if (__test_bit(LOG_CONSOLE_BIT, &debug))
		enable_console_log();

#ifdef GIT_COMMIT
	log_message(LOG_INFO, ""Starting %s, git commit %s"", version_string, GIT_COMMIT);
#else
	log_message(LOG_INFO, ""Starting %s"", version_string);
#endif

	/* Handle any core file requirements */
	core_dump_init();

	if (os_major) {
		if (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {
			/* keepalived was build for a later kernel version */
			log_message(LOG_INFO, ""WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s"",
					(LINUX_VERSION_CODE >> 16) & 0xff,
					(LINUX_VERSION_CODE >>  8) & 0xff,
					(LINUX_VERSION_CODE      ) & 0xff,
					uname_buf.sysname, uname_buf.release, uname_buf.version);
		} else {
			/* keepalived was build for a later kernel version */
			log_message(LOG_INFO, ""Running on %s %s %s (built for Linux %d.%d.%d)"",
					uname_buf.sysname, uname_buf.release, uname_buf.version,
					(LINUX_VERSION_CODE >> 16) & 0xff,
					(LINUX_VERSION_CODE >>  8) & 0xff,
					(LINUX_VERSION_CODE      ) & 0xff);
		}
	}

#ifndef _DEBUG_
	log_command_line(0);
#endif

	/* Check we can read the configuration file(s).
	   NOTE: the working directory will be / if we
	   forked, but will be the current working directory
	   when keepalived was run if we haven't forked.
	   This means that if any config file names are not
	   absolute file names, the behaviour will be different
	   depending on whether we forked or not. */
	if (!check_conf_file(conf_file)) {
		if (__test_bit(CONFIG_TEST_BIT, &debug))
			config_test_exit();

		goto end;
	}

	global_data = alloc_global_data();
	global_data->umask = umask_val;

	read_config_file();

	init_global_data(global_data, NULL);

#if HAVE_DECL_CLONE_NEWNET
	if (override_namespace) {
		if (global_data->network_namespace) {
			log_message(LOG_INFO, ""Overriding config net_namespace '%s' with command line namespace '%s'"", global_data->network_namespace, override_namespace);
			FREE(global_data->network_namespace);
		}
		global_data->network_namespace = override_namespace;
		override_namespace = NULL;
	}
#endif

	if (!__test_bit(CONFIG_TEST_BIT, &debug) &&
	    (global_data->instance_name
#if HAVE_DECL_CLONE_NEWNET
	     || global_data->network_namespace
#endif
					      )) {
		if ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {
			log_message(LOG_INFO, ""Changing syslog ident to %s"", syslog_ident);
			closelog();
			openlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);
		}
		else
			log_message(LOG_INFO, ""Unable to change syslog ident"");

		use_pid_dir = true;

		open_log_file(log_file_name,
				NULL,
#if HAVE_DECL_CLONE_NEWNET
				global_data->network_namespace,
#else
				NULL,
#endif
				global_data->instance_name);
	}

	/* Initialise pointer to child finding function */
	set_child_finder_name(find_keepalived_child_name);

	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
		if (use_pid_dir) {
			/* Create the directory for pid files */
			create_pid_dir();
		}
	}

#if HAVE_DECL_CLONE_NEWNET
	if (global_data->network_namespace) {
		if (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {
			log_message(LOG_ERR, ""Unable to set network namespace %s - exiting"", global_data->network_namespace);
			goto end;
		}
	}
#endif

	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
		if (global_data->instance_name) {
			if (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_main_pidfile = true;
#ifdef _WITH_LVS_
			if (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_checkers_pidfile = true;
#endif
#ifdef _WITH_VRRP_
			if (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_vrrp_pidfile = true;
#endif
#ifdef _WITH_BFD_
			if (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_bfd_pidfile = true;
#endif
		}

		if (use_pid_dir) {
			if (!main_pidfile)
				main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;
#ifdef _WITH_LVS_
			if (!checkers_pidfile)
				checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_VRRP_
			if (!vrrp_pidfile)
				vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_BFD_
			if (!bfd_pidfile)
				bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;
#endif
		}
		else
		{
			if (!main_pidfile)
				main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;
#ifdef _WITH_LVS_
			if (!checkers_pidfile)
				checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_VRRP_
			if (!vrrp_pidfile)
				vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_BFD_
			if (!bfd_pidfile)
				bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;
#endif
		}

		/* Check if keepalived is already running */
		if (keepalived_running(daemon_mode)) {
			log_message(LOG_INFO, ""daemon is already running"");
			report_stopped = false;
			goto end;
		}
	}

	/* daemonize process */
	if (!__test_bit(DONT_FORK_BIT, &debug) &&
	    xdaemon(false, false, true) > 0) {
		closelog();
		FREE_PTR(config_id);
		FREE_PTR(orig_core_dump_pattern);
		close_std_fd();
		exit(0);
	}

#ifdef _MEM_CHECK_
	enable_mem_log_termination();
#endif

	if (__test_bit(CONFIG_TEST_BIT, &debug)) {
		validate_config();

		config_test_exit();
	}

	/* write the father's pidfile */
	if (!pidfile_write(main_pidfile, getpid()))
		goto end;

	/* Create the master thread */
	master = thread_make_master();

	/* Signal handling initialization  */
	signal_init();

	/* Init daemon */
	if (!start_keepalived())
		log_message(LOG_INFO, ""Warning - keepalived has no configuration to run"");

	initialise_debug_options();

#ifdef THREAD_DUMP
	register_parent_thread_addresses();
#endif

	/* Launch the scheduling I/O multiplexer */
	launch_thread_scheduler(master);

	/* Finish daemon process */
	stop_keepalived();

#ifdef THREAD_DUMP
	deregister_thread_addresses();
#endif

	/*
	 * Reached when terminate signal catched.
	 * finally return from system
	 */
end:
	if (report_stopped) {
#ifdef GIT_COMMIT
		log_message(LOG_INFO, ""Stopped %s, git commit %s"", version_string, GIT_COMMIT);
#else
		log_message(LOG_INFO, ""Stopped %s"", version_string);
#endif
	}

#if HAVE_DECL_CLONE_NEWNET
	if (global_data && global_data->network_namespace)
		clear_namespaces();
#endif

	if (use_pid_dir)
		remove_pid_dir();

	/* Restore original core_pattern if necessary */
	if (orig_core_dump_pattern)
		update_core_dump_pattern(orig_core_dump_pattern);

	free_parent_mallocs_startup(false);
	free_parent_mallocs_exit();
	free_global_data(global_data);

	closelog();

#ifndef _MEM_CHECK_LOG_
	FREE_PTR(syslog_ident);
#else
	if (syslog_ident)
		free(syslog_ident);
#endif
	close_std_fd();

	exit(KEEPALIVED_EXIT_OK);
}","int
keepalived_main(int VAR_0, char **VAR_1)
{
	bool VAR_2 = true;
	struct utsname VAR_3;
	char *VAR_4;

	/* COMMENT_0 */
                         
	set_time_now();

	/* COMMENT_2 */
	save_cmd_line_options(VAR_0, VAR_1);

	/* COMMENT_3 */
	VAR_5 = 0;

	/* COMMENT_4 */
#ifndef VAR_6
	VAR_7 = VAR_8;
#endif

	/* COMMENT_5 */
#ifdef VAR_9
	__set_bit(VAR_10, &VAR_11);
#endif
#ifdef VAR_12
	__set_bit(VAR_13, &VAR_11);
#endif
#ifdef VAR_14
	__set_bit(VAR_15, &VAR_11);
#endif

	/* COMMENT_6 */
	umask(022);

	/* COMMENT_7 */
	openlog(VAR_16, VAR_17, VAR_18);

#ifdef VAR_19
	mem_log_init(VAR_16, ""Parent process"");
#endif

	/* COMMENT_8 */
	if (uname(&VAR_3))
		log_message(VAR_20, ""Unable to get uname() information - error %d"", VAR_21);
	else {
		VAR_22 = (unsigned)strtoul(VAR_3.release, &VAR_4, 10);
		if (*VAR_4 != '.')
			VAR_22 = 0;
		else {
			VAR_23 = (unsigned)strtoul(VAR_4 + 1, &VAR_4, 10);
			if (*VAR_4 != '.')
				VAR_22 = 0;
			else {
				if (!isdigit(VAR_4[1]))
					VAR_22 = 0;
				else
					VAR_24 = (unsigned)strtoul(VAR_4 + 1, &VAR_4, 10);
			}
		}
		if (!VAR_22)
			log_message(VAR_20, ""Unable to parse kernel version %s"", VAR_3.release);

		/* COMMENT_9 */
		if (!VAR_25) {
			VAR_4 = strchrnul(VAR_3.nodename, '.');
			VAR_25 = MALLOC((size_t)(VAR_4 - VAR_3.nodename) + 1);
			strncpy(VAR_25, VAR_3.nodename, (size_t)(VAR_4 - VAR_3.nodename));
			VAR_25[VAR_4 - VAR_3.nodename] = '\0';
		}
	}

	/* COMMENT_10 */
                                           
                                
    
	if (parse_cmdline(VAR_0, VAR_1)) {
		closelog();
		if (!__test_bit(VAR_26, &VAR_5))
			openlog(VAR_16, VAR_17 | ((__test_bit(VAR_27, &VAR_5)) ? VAR_28 : 0) , VAR_18);
	}

	if (__test_bit(VAR_27, &VAR_5))
		enable_console_log();

#ifdef VAR_29
	log_message(VAR_20, ""Starting %s, git commit %s"", VAR_30, VAR_29);
#else
	log_message(VAR_20, ""Starting %s"", VAR_30);
#endif

	/* COMMENT_14 */
	core_dump_init();

	if (VAR_22) {
		if (KERNEL_VERSION(VAR_22, VAR_23, VAR_24) < VAR_31) {
			/* COMMENT_15 */
			log_message(VAR_20, ""WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s"",
					(VAR_31 >> 16) & 0xff,
					(VAR_31 >>  8) & 0xff,
					(VAR_31      ) & 0xff,
					VAR_3.sysname, VAR_3.release, VAR_3.version);
		} else {
			/* COMMENT_15 */
			log_message(VAR_20, ""Running on %s %s %s (built for Linux %d.%d.%d)"",
					VAR_3.sysname, VAR_3.release, VAR_3.version,
					(VAR_31 >> 16) & 0xff,
					(VAR_31 >>  8) & 0xff,
					(VAR_31      ) & 0xff);
		}
	}

#ifndef VAR_6
	log_command_line(0);
#endif

	/* COMMENT_16 */
                                               
                                                     
                                                 
                                                    
                                                        
                                             
	if (!check_conf_file(VAR_32)) {
		if (__test_bit(VAR_33, &VAR_5))
			config_test_exit();

		goto end;
	}

	VAR_34 = alloc_global_data();
	VAR_34->umask = VAR_35;

	read_config_file();

	init_global_data(VAR_34, NULL);

#if VAR_36
	if (VAR_37) {
		if (VAR_34->network_namespace) {
			log_message(VAR_20, ""Overriding config net_namespace '%s' with command line namespace '%s'"", VAR_34->network_namespace, VAR_37);
			FREE(VAR_34->network_namespace);
		}
		VAR_34->network_namespace = VAR_37;
		VAR_37 = NULL;
	}
#endif

	if (!__test_bit(VAR_33, &VAR_5) &&
	    (VAR_34->instance_name
#if VAR_36
	     || VAR_34->network_namespace
#endif
					      )) {
		if ((VAR_38 = make_syslog_ident(VAR_16))) {
			log_message(VAR_20, ""Changing syslog ident to %s"", VAR_38);
			closelog();
			openlog(VAR_38, VAR_17 | ((__test_bit(VAR_27, &VAR_5)) ? VAR_28 : 0), VAR_18);
		}
		else
			log_message(VAR_20, ""Unable to change syslog ident"");

		VAR_39 = true;

		open_log_file(VAR_40,
				NULL,
#if VAR_36
				VAR_34->network_namespace,
#else
				NULL,
#endif
				VAR_34->instance_name);
	}

	/* COMMENT_23 */
	set_child_finder_name(VAR_41);

	if (!__test_bit(VAR_33, &VAR_5)) {
		if (VAR_39) {
			/* COMMENT_24 */
			create_pid_dir();
		}
	}

#if VAR_36
	if (VAR_34->network_namespace) {
		if (VAR_34->network_namespace && !set_namespaces(VAR_34->network_namespace)) {
			log_message(VAR_42, ""Unable to set network namespace %s - exiting"", VAR_34->network_namespace);
			goto end;
		}
	}
#endif

	if (!__test_bit(VAR_33, &VAR_5)) {
		if (VAR_34->instance_name) {
			if (!VAR_43 && (VAR_43 = make_pidfile_name(VAR_44 VAR_45, VAR_34->instance_name, VAR_46)))
				VAR_47 = true;
#ifdef VAR_12
			if (!VAR_48 && (VAR_48 = make_pidfile_name(VAR_44 VAR_49, VAR_34->instance_name, VAR_46)))
				VAR_50 = true;
#endif
#ifdef VAR_9
			if (!VAR_51 && (VAR_51 = make_pidfile_name(VAR_44 VAR_52, VAR_34->instance_name, VAR_46)))
				VAR_53 = true;
#endif
#ifdef VAR_14
			if (!VAR_54 && (VAR_54 = make_pidfile_name(VAR_44 VAR_52, VAR_34->instance_name, VAR_46)))
				VAR_55 = true;
#endif
		}

		if (VAR_39) {
			if (!VAR_43)
				VAR_43 = VAR_44 KEEPALIVED_PID_FILE VAR_46;
#ifdef VAR_12
			if (!VAR_48)
				VAR_48 = VAR_44 CHECKERS_PID_FILE VAR_46;
#endif
#ifdef VAR_9
			if (!VAR_51)
				VAR_51 = VAR_44 VRRP_PID_FILE VAR_46;
#endif
#ifdef VAR_14
			if (!VAR_54)
				VAR_54 = VAR_44 BFD_PID_FILE VAR_46;
#endif
		}
		else
		{
			if (!VAR_43)
				VAR_43 = VAR_56 KEEPALIVED_PID_FILE VAR_46;
#ifdef VAR_12
			if (!VAR_48)
				VAR_48 = VAR_56 CHECKERS_PID_FILE VAR_46;
#endif
#ifdef VAR_9
			if (!VAR_51)
				VAR_51 = VAR_56 VRRP_PID_FILE VAR_46;
#endif
#ifdef VAR_14
			if (!VAR_54)
				VAR_54 = VAR_56 BFD_PID_FILE VAR_46;
#endif
		}

		/* COMMENT_25 */
		if (keepalived_running(VAR_11)) {
			log_message(VAR_20, ""daemon is already running"");
			VAR_2 = false;
			goto end;
		}
	}

	/* COMMENT_26 */
	if (!__test_bit(VAR_57, &VAR_5) &&
	    xdaemon(false, false, true) > 0) {
		closelog();
		FREE_PTR(VAR_25);
		FREE_PTR(VAR_58);
		close_std_fd();
		exit(0);
	}

#ifdef VAR_19
	enable_mem_log_termination();
#endif

	if (__test_bit(VAR_33, &VAR_5)) {
		validate_config();

		config_test_exit();
	}

	/* COMMENT_27 */
	if (!pidfile_write(VAR_43, getpid()))
		goto end;

	/* COMMENT_28 */
	VAR_59 = thread_make_master();

	/* COMMENT_29 */
	signal_init();

	/* COMMENT_30 */
	if (!start_keepalived())
		log_message(VAR_20, ""Warning - keepalived has no configuration to run"");

	initialise_debug_options();

#ifdef VAR_60
	register_parent_thread_addresses();
#endif

	/* COMMENT_31 */
	launch_thread_scheduler(VAR_59);

	/* COMMENT_32 */
	stop_keepalived();

#ifdef VAR_60
	deregister_thread_addresses();
#endif

	/* COMMENT_33 */
                                          
                              
    
end:
	if (VAR_2) {
#ifdef VAR_29
		log_message(VAR_20, ""Stopped %s, git commit %s"", VAR_30, VAR_29);
#else
		log_message(VAR_20, ""Stopped %s"", VAR_30);
#endif
	}

#if VAR_36
	if (VAR_34 && VAR_34->network_namespace)
		clear_namespaces();
#endif

	if (VAR_39)
		remove_pid_dir();

	/* COMMENT_37 */
	if (VAR_58)
		update_core_dump_pattern(VAR_58);

	free_parent_mallocs_startup(false);
	free_parent_mallocs_exit();
	free_global_data(VAR_34);

	closelog();

#ifndef VAR_61
	FREE_PTR(VAR_38);
#else
	if (VAR_38)
		free(VAR_38);
#endif
	close_std_fd();

	exit(VAR_62);
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/main.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -30,6 +30,9 @@
 #ifdef _WITH_BFD_
 	__set_bit(DAEMON_BFD, &daemon_mode);
 #endif
+
+	/* Set default file creation mask */
+	umask(022);
 
 	/* Open log with default settings so we can log initially */
 	openlog(PACKAGE_NAME, LOG_PID, log_facility);
@@ -127,6 +130,7 @@
 	}
 
 	global_data = alloc_global_data();
+	global_data->umask = umask_val;
 
 	read_config_file();
 
@@ -257,9 +261,6 @@
 		close_std_fd();
 		exit(0);
 	}
-
-	/* Set file creation mask */
-	umask(0);
 
 #ifdef _MEM_CHECK_
 	enable_mem_log_termination();","{'deleted_lines': ['', '\t/* Set file creation mask */', '\tumask(0);'], 'added_lines': ['', '\t/* Set default file creation mask */', '\tumask(022);', '\tglobal_data->umask = umask_val;']}",True,"keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information.",7.5,HIGH,2,test,2018-10-31T17:08:51Z,2
CVE-2018-19045,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,acassen/keepalived,"Add command line and configuration option to set umask

Issue #1048 identified that files created by keepalived are created
with mode 0666. This commit changes the default to 0644, and also
allows the umask to be specified in the configuration or as a command
line option.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,keepalived/core/global_data.c,dump_global_data,"void
dump_global_data(FILE *fp, data_t * data)
{
#ifdef _WITH_VRRP_
char buf[64];
#endif
if (!data)
return;
conf_write(fp, ""------< Global definitions >------"");
#if HAVE_DECL_CLONE_NEWNET
conf_write(fp, "" Network namespace = %s"", data->network_namespace ? data->network_namespace : ""(default)"");
#endif
if (data->instance_name)
conf_write(fp, "" Instance name = %s"", data->instance_name);
if (data->router_id)
conf_write(fp, "" Router ID = %s"", data->router_id);
if (data->smtp_server.ss_family) {
conf_write(fp, "" Smtp server = %s"", inet_sockaddrtos(&data->smtp_server));
conf_write(fp, "" Smtp server port = %u"", ntohs(inet_sockaddrport(&data->smtp_server)));
}
if (data->smtp_helo_name)
conf_write(fp, "" Smtp HELO name = %s"" , data->smtp_helo_name);
if (data->smtp_connection_to)
conf_write(fp, "" Smtp server connection timeout = %lu""
, data->smtp_connection_to / TIMER_HZ);
if (data->email_from) {
conf_write(fp, "" Email notification from = %s""
, data->email_from);
dump_list(fp, data->email);
}
conf_write(fp, "" Default smtp_alert = %s"",
data->smtp_alert == -1 ? ""unset"" : data->smtp_alert ? ""on"" : ""off"");
#ifdef _WITH_VRRP_
conf_write(fp, "" Default smtp_alert_vrrp = %s"",
data->smtp_alert_vrrp == -1 ? ""unset"" : data->smtp_alert_vrrp ? ""on"" : ""off"");
#endif
#ifdef _WITH_LVS_
conf_write(fp, "" Default smtp_alert_checker = %s"",
data->smtp_alert_checker == -1 ? ""unset"" : data->smtp_alert_checker ? ""on"" : ""off"");
#endif
#ifdef _WITH_VRRP_
conf_write(fp, "" Dynamic interfaces = %s"", data->dynamic_interfaces ? ""true"" : ""false"");
if (data->dynamic_interfaces)
conf_write(fp, "" Allow interface changes = %s"", data->allow_if_changes ? ""true"" : ""false"");
if (data->no_email_faults)
conf_write(fp, "" Send emails for fault transitions = off"");
#endif
#ifdef _WITH_LVS_
if (data->lvs_tcp_timeout)
conf_write(fp, "" LVS TCP timeout = %d"", data->lvs_tcp_timeout);
if (data->lvs_tcpfin_timeout)
conf_write(fp, "" LVS TCP FIN timeout = %d"", data->lvs_tcpfin_timeout);
if (data->lvs_udp_timeout)
conf_write(fp, "" LVS TCP timeout = %d"", data->lvs_udp_timeout);
#ifdef _WITH_VRRP_
#ifndef _DEBUG_
if (prog_type == PROG_TYPE_VRRP)
#endif
conf_write(fp, "" Default interface = %s"", data->default_ifp ? data->default_ifp->ifname : DFLT_INT);
if (data->lvs_syncd.vrrp) {
conf_write(fp, "" LVS syncd vrrp instance = %s""
, data->lvs_syncd.vrrp->iname);
if (data->lvs_syncd.ifname)
conf_write(fp, "" LVS syncd interface = %s""
, data->lvs_syncd.ifname);
conf_write(fp, "" LVS syncd syncid = %u""
, data->lvs_syncd.syncid);
#ifdef _HAVE_IPVS_SYNCD_ATTRIBUTES_
if (data->lvs_syncd.sync_maxlen)
conf_write(fp, "" LVS syncd maxlen = %u"", data->lvs_syncd.sync_maxlen);
if (data->lvs_syncd.mcast_group.ss_family != AF_UNSPEC)
conf_write(fp, "" LVS mcast group %s"", inet_sockaddrtos(&data->lvs_syncd.mcast_group));
if (data->lvs_syncd.mcast_port)
conf_write(fp, "" LVS syncd mcast port = %d"", data->lvs_syncd.mcast_port);
if (data->lvs_syncd.mcast_ttl)
conf_write(fp, "" LVS syncd mcast ttl = %u"", data->lvs_syncd.mcast_ttl);
#endif
}
#endif
conf_write(fp, "" LVS flush = %s"", data->lvs_flush ? ""true"" : ""false"");
#endif
if (data->notify_fifo.name) {
conf_write(fp, "" Global notify fifo = %s"", data->notify_fifo.name);
if (data->notify_fifo.script)
conf_write(fp, "" Global notify fifo script = %s, uid:gid %d:%d"",
cmd_str(data->notify_fifo.script),
data->notify_fifo.script->uid,
data->notify_fifo.script->gid);
}
#ifdef _WITH_VRRP_
if (data->vrrp_notify_fifo.name) {
conf_write(fp, "" VRRP notify fifo = %s"", data->vrrp_notify_fifo.name);
if (data->vrrp_notify_fifo.script)
conf_write(fp, "" VRRP notify fifo script = %s, uid:gid %d:%d"",
cmd_str(data->vrrp_notify_fifo.script),
data->vrrp_notify_fifo.script->uid,
data->vrrp_notify_fifo.script->gid);
}
#endif
#ifdef _WITH_LVS_
if (data->lvs_notify_fifo.name) {
conf_write(fp, "" LVS notify fifo = %s"", data->lvs_notify_fifo.name);
if (data->lvs_notify_fifo.script)
conf_write(fp, "" LVS notify fifo script = %s, uid:gid %d:%d"",
cmd_str(data->lvs_notify_fifo.script),
data->lvs_notify_fifo.script->uid,
data->lvs_notify_fifo.script->gid);
}
#endif
#ifdef _WITH_VRRP_
if (data->vrrp_mcast_group4.sin_family) {
conf_write(fp, "" VRRP IPv4 mcast group = %s""
, inet_sockaddrtos((struct sockaddr_storage *)&data->vrrp_mcast_group4));
}
if (data->vrrp_mcast_group6.sin6_family) {
conf_write(fp, "" VRRP IPv6 mcast group = %s""
, inet_sockaddrtos((struct sockaddr_storage *)&data->vrrp_mcast_group6));
}
conf_write(fp, "" Gratuitous ARP delay = %u"",
data->vrrp_garp_delay/TIMER_HZ);
conf_write(fp, "" Gratuitous ARP repeat = %u"", data->vrrp_garp_rep);
conf_write(fp, "" Gratuitous ARP refresh timer = %lu"",
data->vrrp_garp_refresh.tv_sec);
conf_write(fp, "" Gratuitous ARP refresh repeat = %d"", data->vrrp_garp_refresh_rep);
conf_write(fp, "" Gratuitous ARP lower priority delay = %d"", data->vrrp_garp_lower_prio_delay == PARAMETER_UNSET ? PARAMETER_UNSET : data->vrrp_garp_lower_prio_delay / TIMER_HZ);
conf_write(fp, "" Gratuitous ARP lower priority repeat = %d"", data->vrrp_garp_lower_prio_rep);
conf_write(fp, "" Send advert after receive lower priority advert = %s"", data->vrrp_lower_prio_no_advert ? ""false"" : ""true"");
conf_write(fp, "" Send advert after receive higher priority advert = %s"", data->vrrp_higher_prio_send_advert ? ""true"" : ""false"");
conf_write(fp, "" Gratuitous ARP interval = %d"", data->vrrp_garp_interval);
conf_write(fp, "" Gratuitous NA interval = %d"", data->vrrp_gna_interval);
conf_write(fp, "" VRRP default protocol version = %d"", data->vrrp_version);
if (data->vrrp_iptables_inchain[0])
conf_write(fp,"" Iptables input chain = %s"", data->vrrp_iptables_inchain);
if (data->vrrp_iptables_outchain[0])
conf_write(fp,"" Iptables output chain = %s"", data->vrrp_iptables_outchain);
#ifdef _HAVE_LIBIPSET_
conf_write(fp, "" Using ipsets = %s"", data->using_ipsets ? ""true"" : ""false"");
if (data->vrrp_ipset_address[0])
conf_write(fp,"" ipset IPv4 address set = %s"", data->vrrp_ipset_address);
if (data->vrrp_ipset_address6[0])
conf_write(fp,"" ipset IPv6 address set = %s"", data->vrrp_ipset_address6);
if (data->vrrp_ipset_address_iface6[0])
conf_write(fp,"" ipset IPv6 address,iface set = %s"", data->vrrp_ipset_address_iface6);
#endif
conf_write(fp, "" VRRP check unicast_src = %s"", data->vrrp_check_unicast_src ? ""true"" : ""false"");
conf_write(fp, "" VRRP skip check advert addresses = %s"", data->vrrp_skip_check_adv_addr ? ""true"" : ""false"");
conf_write(fp, "" VRRP strict mode = %s"", data->vrrp_strict ? ""true"" : ""false"");
conf_write(fp, "" VRRP process priority = %d"", data->vrrp_process_priority);
conf_write(fp, "" VRRP don't swap = %s"", data->vrrp_no_swap ? ""true"" : ""false"");
#ifdef _HAVE_SCHED_RT_
conf_write(fp, "" VRRP realtime priority = %u"", data->vrrp_realtime_priority);
#if HAVE_DECL_RLIMIT_RTTIME
conf_write(fp, "" VRRP realtime limit = %lu"", data->vrrp_rlimit_rt);
#endif
#endif
#endif
#ifdef _WITH_LVS_
conf_write(fp, "" Checker process priority = %d"", data->checker_process_priority);
conf_write(fp, "" Checker don't swap = %s"", data->checker_no_swap ? ""true"" : ""false"");
#ifdef _HAVE_SCHED_RT_
conf_write(fp, "" Checker realtime priority = %u"", data->checker_realtime_priority);
#if HAVE_DECL_RLIMIT_RTTIME
conf_write(fp, "" Checker realtime limit = %lu"", data->checker_rlimit_rt);
#endif
#endif
#endif
#ifdef _WITH_BFD_
conf_write(fp, "" BFD process priority = %d"", data->bfd_process_priority);
conf_write(fp, "" BFD don't swap = %s"", data->bfd_no_swap ? ""true"" : ""false"");
#ifdef _HAVE_SCHED_RT_
conf_write(fp, "" BFD realtime priority = %u"", data->bfd_realtime_priority);
#if HAVE_DECL_RLIMIT_RTTIME
conf_write(fp, "" BFD realtime limit = %lu"", data->bfd_rlimit_rt);
#endif
#endif
#endif
#ifdef _WITH_SNMP_VRRP_
conf_write(fp, "" SNMP vrrp %s"", data->enable_snmp_vrrp ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_CHECKER_
conf_write(fp, "" SNMP checker %s"", data->enable_snmp_checker ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_RFCV2_
conf_write(fp, "" SNMP RFCv2 %s"", data->enable_snmp_rfcv2 ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_RFCV3_
conf_write(fp, "" SNMP RFCv3 %s"", data->enable_snmp_rfcv3 ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_
conf_write(fp, "" SNMP traps %s"", data->enable_traps ? ""enabled"" : ""disabled"");
conf_write(fp, "" SNMP socket = %s"", data->snmp_socket ? data->snmp_socket : ""default (unix:/var/agentx/master)"");
#endif
#ifdef _WITH_DBUS_
conf_write(fp, "" DBus %s"", data->enable_dbus ? ""enabled"" : ""disabled"");
conf_write(fp, "" DBus service name = %s"", data->dbus_service_name ? data->dbus_service_name : """");
#endif
conf_write(fp, "" Script security %s"", script_security ? ""enabled"" : ""disabled"");
conf_write(fp, "" Default script uid:gid %d:%d"", default_script_uid, default_script_gid);
#ifdef _WITH_VRRP_
conf_write(fp, "" vrrp_netlink_cmd_rcv_bufs = %u"", global_data->vrrp_netlink_cmd_rcv_bufs);
conf_write(fp, "" vrrp_netlink_cmd_rcv_bufs_force = %u"", global_data->vrrp_netlink_cmd_rcv_bufs_force);
conf_write(fp, "" vrrp_netlink_monitor_rcv_bufs = %u"", global_data->vrrp_netlink_monitor_rcv_bufs);
conf_write(fp, "" vrrp_netlink_monitor_rcv_bufs_force = %u"", global_data->vrrp_netlink_monitor_rcv_bufs_force);
#endif
#ifdef _WITH_LVS_
conf_write(fp, "" lvs_netlink_cmd_rcv_bufs = %u"", global_data->lvs_netlink_cmd_rcv_bufs);
conf_write(fp, "" lvs_netlink_cmd_rcv_bufs_force = %u"", global_data->lvs_netlink_cmd_rcv_bufs_force);
conf_write(fp, "" lvs_netlink_monitor_rcv_bufs = %u"", global_data->lvs_netlink_monitor_rcv_bufs);
conf_write(fp, "" lvs_netlink_monitor_rcv_bufs_force = %u"", global_data->lvs_netlink_monitor_rcv_bufs_force);
conf_write(fp, "" rs_init_notifies = %u"", global_data->rs_init_notifies);
conf_write(fp, "" no_checker_emails = %u"", global_data->no_checker_emails);
#endif
#ifdef _WITH_VRRP_
buf[0] = '\0';
if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU)
strcpy(buf, "" rx_bufs_policy = MTU"");
else if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT)
strcpy(buf, "" rx_bufs_policy = ADVERT"");
else if (global_data->vrrp_rx_bufs_policy & RX_BUFS_SIZE)
sprintf(buf, "" rx_bufs_size = %lu"", global_data->vrrp_rx_bufs_size);
if (buf[0])
conf_write(fp, ""%s"", buf);
conf_write(fp, "" rx_bufs_multiples = %u"", global_data->vrrp_rx_bufs_multiples);
#endif
}","void
dump_global_data(FILE *VAR_0, data_t * VAR_1)
{
#ifdef VAR_2
char VAR_3[64];
#endif
if (!VAR_1)
return;
conf_write(VAR_0, ""------< Global definitions >------"");
#if VAR_4
conf_write(VAR_0, "" Network namespace = %s"", VAR_1->network_namespace ? VAR_1->network_namespace : ""(default)"");
#endif
if (VAR_1->instance_name)
conf_write(VAR_0, "" Instance name = %s"", VAR_1->instance_name);
if (VAR_1->router_id)
conf_write(VAR_0, "" Router ID = %s"", VAR_1->router_id);
if (VAR_1->smtp_server.ss_family) {
conf_write(VAR_0, "" Smtp server = %s"", inet_sockaddrtos(&VAR_1->smtp_server));
conf_write(VAR_0, "" Smtp server port = %u"", ntohs(inet_sockaddrport(&VAR_1->smtp_server)));
}
if (VAR_1->smtp_helo_name)
conf_write(VAR_0, "" Smtp HELO name = %s"" , VAR_1->smtp_helo_name);
if (VAR_1->smtp_connection_to)
conf_write(VAR_0, "" Smtp server connection timeout = %lu""
, VAR_1->smtp_connection_to / VAR_5);
if (VAR_1->email_from) {
conf_write(VAR_0, "" Email notification from = %s""
, VAR_1->email_from);
dump_list(VAR_0, VAR_1->email);
}
conf_write(VAR_0, "" Default smtp_alert = %s"",
VAR_1->smtp_alert == -1 ? ""unset"" : VAR_1->smtp_alert ? ""on"" : ""off"");
#ifdef VAR_2
conf_write(VAR_0, "" Default smtp_alert_vrrp = %s"",
VAR_1->smtp_alert_vrrp == -1 ? ""unset"" : VAR_1->smtp_alert_vrrp ? ""on"" : ""off"");
#endif
#ifdef VAR_6
conf_write(VAR_0, "" Default smtp_alert_checker = %s"",
VAR_1->smtp_alert_checker == -1 ? ""unset"" : VAR_1->smtp_alert_checker ? ""on"" : ""off"");
#endif
#ifdef VAR_2
conf_write(VAR_0, "" Dynamic interfaces = %s"", VAR_1->dynamic_interfaces ? ""true"" : ""false"");
if (VAR_1->dynamic_interfaces)
conf_write(VAR_0, "" Allow interface changes = %s"", VAR_1->allow_if_changes ? ""true"" : ""false"");
if (VAR_1->no_email_faults)
conf_write(VAR_0, "" Send emails for fault transitions = off"");
#endif
#ifdef VAR_6
if (VAR_1->lvs_tcp_timeout)
conf_write(VAR_0, "" LVS TCP timeout = %d"", VAR_1->lvs_tcp_timeout);
if (VAR_1->lvs_tcpfin_timeout)
conf_write(VAR_0, "" LVS TCP FIN timeout = %d"", VAR_1->lvs_tcpfin_timeout);
if (VAR_1->lvs_udp_timeout)
conf_write(VAR_0, "" LVS TCP timeout = %d"", VAR_1->lvs_udp_timeout);
#ifdef VAR_2
#ifndef VAR_7
if (VAR_8 == VAR_9)
#endif
conf_write(VAR_0, "" Default interface = %s"", VAR_1->default_ifp ? VAR_1->default_ifp->ifname : VAR_10);
if (VAR_1->lvs_syncd.vrrp) {
conf_write(VAR_0, "" LVS syncd vrrp instance = %s""
, VAR_1->lvs_syncd.vrrp->iname);
if (VAR_1->lvs_syncd.ifname)
conf_write(VAR_0, "" LVS syncd interface = %s""
, VAR_1->lvs_syncd.ifname);
conf_write(VAR_0, "" LVS syncd syncid = %u""
, VAR_1->lvs_syncd.syncid);
#ifdef VAR_11
if (VAR_1->lvs_syncd.sync_maxlen)
conf_write(VAR_0, "" LVS syncd maxlen = %u"", VAR_1->lvs_syncd.sync_maxlen);
if (VAR_1->lvs_syncd.mcast_group.ss_family != VAR_12)
conf_write(VAR_0, "" LVS mcast group %s"", inet_sockaddrtos(&VAR_1->lvs_syncd.mcast_group));
if (VAR_1->lvs_syncd.mcast_port)
conf_write(VAR_0, "" LVS syncd mcast port = %d"", VAR_1->lvs_syncd.mcast_port);
if (VAR_1->lvs_syncd.mcast_ttl)
conf_write(VAR_0, "" LVS syncd mcast ttl = %u"", VAR_1->lvs_syncd.mcast_ttl);
#endif
}
#endif
conf_write(VAR_0, "" LVS flush = %s"", VAR_1->lvs_flush ? ""true"" : ""false"");
#endif
if (VAR_1->notify_fifo.name) {
conf_write(VAR_0, "" Global notify fifo = %s"", VAR_1->notify_fifo.name);
if (VAR_1->notify_fifo.script)
conf_write(VAR_0, "" Global notify fifo script = %s, uid:gid %d:%d"",
cmd_str(VAR_1->notify_fifo.script),
VAR_1->notify_fifo.script->uid,
VAR_1->notify_fifo.script->gid);
}
#ifdef VAR_2
if (VAR_1->vrrp_notify_fifo.name) {
conf_write(VAR_0, "" VRRP notify fifo = %s"", VAR_1->vrrp_notify_fifo.name);
if (VAR_1->vrrp_notify_fifo.script)
conf_write(VAR_0, "" VRRP notify fifo script = %s, uid:gid %d:%d"",
cmd_str(VAR_1->vrrp_notify_fifo.script),
VAR_1->vrrp_notify_fifo.script->uid,
VAR_1->vrrp_notify_fifo.script->gid);
}
#endif
#ifdef VAR_6
if (VAR_1->lvs_notify_fifo.name) {
conf_write(VAR_0, "" LVS notify fifo = %s"", VAR_1->lvs_notify_fifo.name);
if (VAR_1->lvs_notify_fifo.script)
conf_write(VAR_0, "" LVS notify fifo script = %s, uid:gid %d:%d"",
cmd_str(VAR_1->lvs_notify_fifo.script),
VAR_1->lvs_notify_fifo.script->uid,
VAR_1->lvs_notify_fifo.script->gid);
}
#endif
#ifdef VAR_2
if (VAR_1->vrrp_mcast_group4.sin_family) {
conf_write(VAR_0, "" VRRP IPv4 mcast group = %s""
, inet_sockaddrtos((struct sockaddr_storage *)&VAR_1->vrrp_mcast_group4));
}
if (VAR_1->vrrp_mcast_group6.sin6_family) {
conf_write(VAR_0, "" VRRP IPv6 mcast group = %s""
, inet_sockaddrtos((struct sockaddr_storage *)&VAR_1->vrrp_mcast_group6));
}
conf_write(VAR_0, "" Gratuitous ARP delay = %u"",
VAR_1->vrrp_garp_delay/VAR_5);
conf_write(VAR_0, "" Gratuitous ARP repeat = %u"", VAR_1->vrrp_garp_rep);
conf_write(VAR_0, "" Gratuitous ARP refresh timer = %lu"",
VAR_1->vrrp_garp_refresh.tv_sec);
conf_write(VAR_0, "" Gratuitous ARP refresh repeat = %d"", VAR_1->vrrp_garp_refresh_rep);
conf_write(VAR_0, "" Gratuitous ARP lower priority delay = %d"", VAR_1->vrrp_garp_lower_prio_delay == VAR_13 ? VAR_13 : VAR_1->vrrp_garp_lower_prio_delay / VAR_5);
conf_write(VAR_0, "" Gratuitous ARP lower priority repeat = %d"", VAR_1->vrrp_garp_lower_prio_rep);
conf_write(VAR_0, "" Send advert after receive lower priority advert = %s"", VAR_1->vrrp_lower_prio_no_advert ? ""false"" : ""true"");
conf_write(VAR_0, "" Send advert after receive higher priority advert = %s"", VAR_1->vrrp_higher_prio_send_advert ? ""true"" : ""false"");
conf_write(VAR_0, "" Gratuitous ARP interval = %d"", VAR_1->vrrp_garp_interval);
conf_write(VAR_0, "" Gratuitous NA interval = %d"", VAR_1->vrrp_gna_interval);
conf_write(VAR_0, "" VRRP default protocol version = %d"", VAR_1->vrrp_version);
if (VAR_1->vrrp_iptables_inchain[0])
conf_write(VAR_0,"" Iptables input chain = %s"", VAR_1->vrrp_iptables_inchain);
if (VAR_1->vrrp_iptables_outchain[0])
conf_write(VAR_0,"" Iptables output chain = %s"", VAR_1->vrrp_iptables_outchain);
#ifdef VAR_14
conf_write(VAR_0, "" Using ipsets = %s"", VAR_1->using_ipsets ? ""true"" : ""false"");
if (VAR_1->vrrp_ipset_address[0])
conf_write(VAR_0,"" ipset IPv4 address set = %s"", VAR_1->vrrp_ipset_address);
if (VAR_1->vrrp_ipset_address6[0])
conf_write(VAR_0,"" ipset IPv6 address set = %s"", VAR_1->vrrp_ipset_address6);
if (VAR_1->vrrp_ipset_address_iface6[0])
conf_write(VAR_0,"" ipset IPv6 address,iface set = %s"", VAR_1->vrrp_ipset_address_iface6);
#endif
conf_write(VAR_0, "" VRRP check unicast_src = %s"", VAR_1->vrrp_check_unicast_src ? ""true"" : ""false"");
conf_write(VAR_0, "" VRRP skip check advert addresses = %s"", VAR_1->vrrp_skip_check_adv_addr ? ""true"" : ""false"");
conf_write(VAR_0, "" VRRP strict mode = %s"", VAR_1->vrrp_strict ? ""true"" : ""false"");
conf_write(VAR_0, "" VRRP process priority = %d"", VAR_1->vrrp_process_priority);
conf_write(VAR_0, "" VRRP don't swap = %s"", VAR_1->vrrp_no_swap ? ""true"" : ""false"");
#ifdef VAR_15
conf_write(VAR_0, "" VRRP realtime priority = %u"", VAR_1->vrrp_realtime_priority);
#if VAR_16
conf_write(VAR_0, "" VRRP realtime limit = %lu"", VAR_1->vrrp_rlimit_rt);
#endif
#endif
#endif
#ifdef VAR_6
conf_write(VAR_0, "" Checker process priority = %d"", VAR_1->checker_process_priority);
conf_write(VAR_0, "" Checker don't swap = %s"", VAR_1->checker_no_swap ? ""true"" : ""false"");
#ifdef VAR_15
conf_write(VAR_0, "" Checker realtime priority = %u"", VAR_1->checker_realtime_priority);
#if VAR_16
conf_write(VAR_0, "" Checker realtime limit = %lu"", VAR_1->checker_rlimit_rt);
#endif
#endif
#endif
#ifdef VAR_17
conf_write(VAR_0, "" BFD process priority = %d"", VAR_1->bfd_process_priority);
conf_write(VAR_0, "" BFD don't swap = %s"", VAR_1->bfd_no_swap ? ""true"" : ""false"");
#ifdef VAR_15
conf_write(VAR_0, "" BFD realtime priority = %u"", VAR_1->bfd_realtime_priority);
#if VAR_16
conf_write(VAR_0, "" BFD realtime limit = %lu"", VAR_1->bfd_rlimit_rt);
#endif
#endif
#endif
#ifdef VAR_18
conf_write(VAR_0, "" SNMP vrrp %s"", VAR_1->enable_snmp_vrrp ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_19
conf_write(VAR_0, "" SNMP checker %s"", VAR_1->enable_snmp_checker ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_20
conf_write(VAR_0, "" SNMP RFCv2 %s"", VAR_1->enable_snmp_rfcv2 ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_21
conf_write(VAR_0, "" SNMP RFCv3 %s"", VAR_1->enable_snmp_rfcv3 ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_22
conf_write(VAR_0, "" SNMP traps %s"", VAR_1->enable_traps ? ""enabled"" : ""disabled"");
conf_write(VAR_0, "" SNMP socket = %s"", VAR_1->snmp_socket ? VAR_1->snmp_socket : ""default (unix:/var/agentx/master)"");
#endif
#ifdef VAR_23
conf_write(VAR_0, "" DBus %s"", VAR_1->enable_dbus ? ""enabled"" : ""disabled"");
conf_write(VAR_0, "" DBus service name = %s"", VAR_1->dbus_service_name ? VAR_1->dbus_service_name : """");
#endif
conf_write(VAR_0, "" Script security %s"", VAR_24 ? ""enabled"" : ""disabled"");
conf_write(VAR_0, "" Default script uid:gid %d:%d"", VAR_25, VAR_26);
#ifdef VAR_2
conf_write(VAR_0, "" vrrp_netlink_cmd_rcv_bufs = %u"", VAR_27->vrrp_netlink_cmd_rcv_bufs);
conf_write(VAR_0, "" vrrp_netlink_cmd_rcv_bufs_force = %u"", VAR_27->vrrp_netlink_cmd_rcv_bufs_force);
conf_write(VAR_0, "" vrrp_netlink_monitor_rcv_bufs = %u"", VAR_27->vrrp_netlink_monitor_rcv_bufs);
conf_write(VAR_0, "" vrrp_netlink_monitor_rcv_bufs_force = %u"", VAR_27->vrrp_netlink_monitor_rcv_bufs_force);
#endif
#ifdef VAR_6
conf_write(VAR_0, "" lvs_netlink_cmd_rcv_bufs = %u"", VAR_27->lvs_netlink_cmd_rcv_bufs);
conf_write(VAR_0, "" lvs_netlink_cmd_rcv_bufs_force = %u"", VAR_27->lvs_netlink_cmd_rcv_bufs_force);
conf_write(VAR_0, "" lvs_netlink_monitor_rcv_bufs = %u"", VAR_27->lvs_netlink_monitor_rcv_bufs);
conf_write(VAR_0, "" lvs_netlink_monitor_rcv_bufs_force = %u"", VAR_27->lvs_netlink_monitor_rcv_bufs_force);
conf_write(VAR_0, "" rs_init_notifies = %u"", VAR_27->rs_init_notifies);
conf_write(VAR_0, "" no_checker_emails = %u"", VAR_27->no_checker_emails);
#endif
#ifdef VAR_2
VAR_3[0] = '\0';
if (VAR_27->vrrp_rx_bufs_policy & VAR_28)
strcpy(VAR_3, "" rx_bufs_policy = MTU"");
else if (VAR_27->vrrp_rx_bufs_policy & VAR_29)
strcpy(VAR_3, "" rx_bufs_policy = ADVERT"");
else if (VAR_27->vrrp_rx_bufs_policy & VAR_30)
sprintf(VAR_3, "" rx_bufs_size = %lu"", VAR_27->vrrp_rx_bufs_size);
if (VAR_3[0])
conf_write(VAR_0, ""%s"", VAR_3);
conf_write(VAR_0, "" rx_bufs_multiples = %u"", VAR_27->vrrp_rx_bufs_multiples);
#endif
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/global_data.c/vul/before/0.json,"void
dump_global_data(FILE *fp, data_t * data)
{
#ifdef _WITH_VRRP_
	char buf[64];
#endif

	if (!data)
		return;

	conf_write(fp, ""------< Global definitions >------"");

#if HAVE_DECL_CLONE_NEWNET
	conf_write(fp, "" Network namespace = %s"", data->network_namespace ? data->network_namespace : ""(default)"");
#endif
	if (data->instance_name)
		conf_write(fp, "" Instance name = %s"", data->instance_name);
	if (data->router_id)
		conf_write(fp, "" Router ID = %s"", data->router_id);
	if (data->smtp_server.ss_family) {
		conf_write(fp, "" Smtp server = %s"", inet_sockaddrtos(&data->smtp_server));
		conf_write(fp, "" Smtp server port = %u"", ntohs(inet_sockaddrport(&data->smtp_server)));
	}
	if (data->smtp_helo_name)
		conf_write(fp, "" Smtp HELO name = %s"" , data->smtp_helo_name);
	if (data->smtp_connection_to)
		conf_write(fp, "" Smtp server connection timeout = %lu""
				    , data->smtp_connection_to / TIMER_HZ);
	if (data->email_from) {
		conf_write(fp, "" Email notification from = %s""
				    , data->email_from);
		dump_list(fp, data->email);
	}
	conf_write(fp, "" Default smtp_alert = %s"",
			data->smtp_alert == -1 ? ""unset"" : data->smtp_alert ? ""on"" : ""off"");
#ifdef _WITH_VRRP_
	conf_write(fp, "" Default smtp_alert_vrrp = %s"",
			data->smtp_alert_vrrp == -1 ? ""unset"" : data->smtp_alert_vrrp ? ""on"" : ""off"");
#endif
#ifdef _WITH_LVS_
	conf_write(fp, "" Default smtp_alert_checker = %s"",
			data->smtp_alert_checker == -1 ? ""unset"" : data->smtp_alert_checker ? ""on"" : ""off"");
#endif
#ifdef _WITH_VRRP_
	conf_write(fp, "" Dynamic interfaces = %s"", data->dynamic_interfaces ? ""true"" : ""false"");
	if (data->dynamic_interfaces)
		conf_write(fp, "" Allow interface changes = %s"", data->allow_if_changes ? ""true"" : ""false"");
	if (data->no_email_faults)
		conf_write(fp, "" Send emails for fault transitions = off"");
#endif
#ifdef _WITH_LVS_
	if (data->lvs_tcp_timeout)
		conf_write(fp, "" LVS TCP timeout = %d"", data->lvs_tcp_timeout);
	if (data->lvs_tcpfin_timeout)
		conf_write(fp, "" LVS TCP FIN timeout = %d"", data->lvs_tcpfin_timeout);
	if (data->lvs_udp_timeout)
		conf_write(fp, "" LVS TCP timeout = %d"", data->lvs_udp_timeout);
#ifdef _WITH_VRRP_
#ifndef _DEBUG_
	if (prog_type == PROG_TYPE_VRRP)
#endif
		conf_write(fp, "" Default interface = %s"", data->default_ifp ? data->default_ifp->ifname : DFLT_INT);
	if (data->lvs_syncd.vrrp) {
		conf_write(fp, "" LVS syncd vrrp instance = %s""
				    , data->lvs_syncd.vrrp->iname);
		if (data->lvs_syncd.ifname)
			conf_write(fp, "" LVS syncd interface = %s""
				    , data->lvs_syncd.ifname);
		conf_write(fp, "" LVS syncd syncid = %u""
				    , data->lvs_syncd.syncid);
#ifdef _HAVE_IPVS_SYNCD_ATTRIBUTES_
		if (data->lvs_syncd.sync_maxlen)
			conf_write(fp, "" LVS syncd maxlen = %u"", data->lvs_syncd.sync_maxlen);
		if (data->lvs_syncd.mcast_group.ss_family != AF_UNSPEC)
			conf_write(fp, "" LVS mcast group %s"", inet_sockaddrtos(&data->lvs_syncd.mcast_group));
		if (data->lvs_syncd.mcast_port)
			conf_write(fp, "" LVS syncd mcast port = %d"", data->lvs_syncd.mcast_port);
		if (data->lvs_syncd.mcast_ttl)
			conf_write(fp, "" LVS syncd mcast ttl = %u"", data->lvs_syncd.mcast_ttl);
#endif
	}
#endif
	conf_write(fp, "" LVS flush = %s"", data->lvs_flush ? ""true"" : ""false"");
#endif
	if (data->notify_fifo.name) {
		conf_write(fp, "" Global notify fifo = %s"", data->notify_fifo.name);
		if (data->notify_fifo.script)
			conf_write(fp, "" Global notify fifo script = %s, uid:gid %d:%d"",
				    cmd_str(data->notify_fifo.script),
				    data->notify_fifo.script->uid,
				    data->notify_fifo.script->gid);
	}
#ifdef _WITH_VRRP_
	if (data->vrrp_notify_fifo.name) {
		conf_write(fp, "" VRRP notify fifo = %s"", data->vrrp_notify_fifo.name);
		if (data->vrrp_notify_fifo.script)
			conf_write(fp, "" VRRP notify fifo script = %s, uid:gid %d:%d"",
				    cmd_str(data->vrrp_notify_fifo.script),
				    data->vrrp_notify_fifo.script->uid,
				    data->vrrp_notify_fifo.script->gid);
	}
#endif
#ifdef _WITH_LVS_
	if (data->lvs_notify_fifo.name) {
		conf_write(fp, "" LVS notify fifo = %s"", data->lvs_notify_fifo.name);
		if (data->lvs_notify_fifo.script)
			conf_write(fp, "" LVS notify fifo script = %s, uid:gid %d:%d"",
				    cmd_str(data->lvs_notify_fifo.script),
				    data->lvs_notify_fifo.script->uid,
				    data->lvs_notify_fifo.script->gid);
	}
#endif
#ifdef _WITH_VRRP_
	if (data->vrrp_mcast_group4.sin_family) {
		conf_write(fp, "" VRRP IPv4 mcast group = %s""
				    , inet_sockaddrtos((struct sockaddr_storage *)&data->vrrp_mcast_group4));
	}
	if (data->vrrp_mcast_group6.sin6_family) {
		conf_write(fp, "" VRRP IPv6 mcast group = %s""
				    , inet_sockaddrtos((struct sockaddr_storage *)&data->vrrp_mcast_group6));
	}
	conf_write(fp, "" Gratuitous ARP delay = %u"",
		       data->vrrp_garp_delay/TIMER_HZ);
	conf_write(fp, "" Gratuitous ARP repeat = %u"", data->vrrp_garp_rep);
	conf_write(fp, "" Gratuitous ARP refresh timer = %lu"",
		       data->vrrp_garp_refresh.tv_sec);
	conf_write(fp, "" Gratuitous ARP refresh repeat = %d"", data->vrrp_garp_refresh_rep);
	conf_write(fp, "" Gratuitous ARP lower priority delay = %d"", data->vrrp_garp_lower_prio_delay == PARAMETER_UNSET ? PARAMETER_UNSET : data->vrrp_garp_lower_prio_delay / TIMER_HZ);
	conf_write(fp, "" Gratuitous ARP lower priority repeat = %d"", data->vrrp_garp_lower_prio_rep);
	conf_write(fp, "" Send advert after receive lower priority advert = %s"", data->vrrp_lower_prio_no_advert ? ""false"" : ""true"");
	conf_write(fp, "" Send advert after receive higher priority advert = %s"", data->vrrp_higher_prio_send_advert ? ""true"" : ""false"");
	conf_write(fp, "" Gratuitous ARP interval = %d"", data->vrrp_garp_interval);
	conf_write(fp, "" Gratuitous NA interval = %d"", data->vrrp_gna_interval);
	conf_write(fp, "" VRRP default protocol version = %d"", data->vrrp_version);
	if (data->vrrp_iptables_inchain[0])
		conf_write(fp,"" Iptables input chain = %s"", data->vrrp_iptables_inchain);
	if (data->vrrp_iptables_outchain[0])
		conf_write(fp,"" Iptables output chain = %s"", data->vrrp_iptables_outchain);
#ifdef _HAVE_LIBIPSET_
	conf_write(fp, "" Using ipsets = %s"", data->using_ipsets ? ""true"" : ""false"");
	if (data->vrrp_ipset_address[0])
		conf_write(fp,"" ipset IPv4 address set = %s"", data->vrrp_ipset_address);
	if (data->vrrp_ipset_address6[0])
		conf_write(fp,"" ipset IPv6 address set = %s"", data->vrrp_ipset_address6);
	if (data->vrrp_ipset_address_iface6[0])
		conf_write(fp,"" ipset IPv6 address,iface set = %s"", data->vrrp_ipset_address_iface6);
#endif

	conf_write(fp, "" VRRP check unicast_src = %s"", data->vrrp_check_unicast_src ? ""true"" : ""false"");
	conf_write(fp, "" VRRP skip check advert addresses = %s"", data->vrrp_skip_check_adv_addr ? ""true"" : ""false"");
	conf_write(fp, "" VRRP strict mode = %s"", data->vrrp_strict ? ""true"" : ""false"");
	conf_write(fp, "" VRRP process priority = %d"", data->vrrp_process_priority);
	conf_write(fp, "" VRRP don't swap = %s"", data->vrrp_no_swap ? ""true"" : ""false"");
#ifdef _HAVE_SCHED_RT_
	conf_write(fp, "" VRRP realtime priority = %u"", data->vrrp_realtime_priority);
#if HAVE_DECL_RLIMIT_RTTIME
	conf_write(fp, "" VRRP realtime limit = %lu"", data->vrrp_rlimit_rt);
#endif
#endif
#endif
#ifdef _WITH_LVS_
	conf_write(fp, "" Checker process priority = %d"", data->checker_process_priority);
	conf_write(fp, "" Checker don't swap = %s"", data->checker_no_swap ? ""true"" : ""false"");
#ifdef _HAVE_SCHED_RT_
	conf_write(fp, "" Checker realtime priority = %u"", data->checker_realtime_priority);
#if HAVE_DECL_RLIMIT_RTTIME
	conf_write(fp, "" Checker realtime limit = %lu"", data->checker_rlimit_rt);
#endif
#endif
#endif
#ifdef _WITH_BFD_
	conf_write(fp, "" BFD process priority = %d"", data->bfd_process_priority);
	conf_write(fp, "" BFD don't swap = %s"", data->bfd_no_swap ? ""true"" : ""false"");
#ifdef _HAVE_SCHED_RT_
	conf_write(fp, "" BFD realtime priority = %u"", data->bfd_realtime_priority);
#if HAVE_DECL_RLIMIT_RTTIME
	conf_write(fp, "" BFD realtime limit = %lu"", data->bfd_rlimit_rt);
#endif
#endif
#endif
#ifdef _WITH_SNMP_VRRP_
	conf_write(fp, "" SNMP vrrp %s"", data->enable_snmp_vrrp ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_CHECKER_
	conf_write(fp, "" SNMP checker %s"", data->enable_snmp_checker ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_RFCV2_
	conf_write(fp, "" SNMP RFCv2 %s"", data->enable_snmp_rfcv2 ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_RFCV3_
	conf_write(fp, "" SNMP RFCv3 %s"", data->enable_snmp_rfcv3 ? ""enabled"" : ""disabled"");
#endif
#ifdef _WITH_SNMP_
	conf_write(fp, "" SNMP traps %s"", data->enable_traps ? ""enabled"" : ""disabled"");
	conf_write(fp, "" SNMP socket = %s"", data->snmp_socket ? data->snmp_socket : ""default (unix:/var/agentx/master)"");
#endif
#ifdef _WITH_DBUS_
	conf_write(fp, "" DBus %s"", data->enable_dbus ? ""enabled"" : ""disabled"");
	conf_write(fp, "" DBus service name = %s"", data->dbus_service_name ? data->dbus_service_name : """");
#endif
	conf_write(fp, "" Script security %s"", script_security ? ""enabled"" : ""disabled"");
	conf_write(fp, "" Default script uid:gid %d:%d"", default_script_uid, default_script_gid);
#ifdef _WITH_VRRP_
	conf_write(fp, "" vrrp_netlink_cmd_rcv_bufs = %u"", global_data->vrrp_netlink_cmd_rcv_bufs);
	conf_write(fp, "" vrrp_netlink_cmd_rcv_bufs_force = %u"", global_data->vrrp_netlink_cmd_rcv_bufs_force);
	conf_write(fp, "" vrrp_netlink_monitor_rcv_bufs = %u"", global_data->vrrp_netlink_monitor_rcv_bufs);
	conf_write(fp, "" vrrp_netlink_monitor_rcv_bufs_force = %u"", global_data->vrrp_netlink_monitor_rcv_bufs_force);
#endif
#ifdef _WITH_LVS_
	conf_write(fp, "" lvs_netlink_cmd_rcv_bufs = %u"", global_data->lvs_netlink_cmd_rcv_bufs);
	conf_write(fp, "" lvs_netlink_cmd_rcv_bufs_force = %u"", global_data->lvs_netlink_cmd_rcv_bufs_force);
	conf_write(fp, "" lvs_netlink_monitor_rcv_bufs = %u"", global_data->lvs_netlink_monitor_rcv_bufs);
	conf_write(fp, "" lvs_netlink_monitor_rcv_bufs_force = %u"", global_data->lvs_netlink_monitor_rcv_bufs_force);
	conf_write(fp, "" rs_init_notifies = %u"", global_data->rs_init_notifies);
	conf_write(fp, "" no_checker_emails = %u"", global_data->no_checker_emails);
#endif
#ifdef _WITH_VRRP_
	buf[0] = '\0';
	if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU)
		strcpy(buf, "" rx_bufs_policy = MTU"");
	else if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT)
		strcpy(buf, "" rx_bufs_policy = ADVERT"");
	else if (global_data->vrrp_rx_bufs_policy & RX_BUFS_SIZE)
		sprintf(buf, "" rx_bufs_size = %lu"", global_data->vrrp_rx_bufs_size);
	if (buf[0])
		conf_write(fp, ""%s"", buf);
	conf_write(fp, "" rx_bufs_multiples = %u"", global_data->vrrp_rx_bufs_multiples);
	conf_write(fp, "" umask = 0%o"", global_data->umask);
#endif
}","void
dump_global_data(FILE *VAR_0, data_t * VAR_1)
{
#ifdef VAR_2
	char VAR_3[64];
#endif

	if (!VAR_1)
		return;

	conf_write(VAR_0, ""------< Global definitions >------"");

#if VAR_4
	conf_write(VAR_0, "" Network namespace = %s"", VAR_1->network_namespace ? VAR_1->network_namespace : ""(default)"");
#endif
	if (VAR_1->instance_name)
		conf_write(VAR_0, "" Instance name = %s"", VAR_1->instance_name);
	if (VAR_1->router_id)
		conf_write(VAR_0, "" Router ID = %s"", VAR_1->router_id);
	if (VAR_1->smtp_server.ss_family) {
		conf_write(VAR_0, "" Smtp server = %s"", inet_sockaddrtos(&VAR_1->smtp_server));
		conf_write(VAR_0, "" Smtp server port = %u"", ntohs(inet_sockaddrport(&VAR_1->smtp_server)));
	}
	if (VAR_1->smtp_helo_name)
		conf_write(VAR_0, "" Smtp HELO name = %s"" , VAR_1->smtp_helo_name);
	if (VAR_1->smtp_connection_to)
		conf_write(VAR_0, "" Smtp server connection timeout = %lu""
				    , VAR_1->smtp_connection_to / VAR_5);
	if (VAR_1->email_from) {
		conf_write(VAR_0, "" Email notification from = %s""
				    , VAR_1->email_from);
		dump_list(VAR_0, VAR_1->email);
	}
	conf_write(VAR_0, "" Default smtp_alert = %s"",
			VAR_1->smtp_alert == -1 ? ""unset"" : VAR_1->smtp_alert ? ""on"" : ""off"");
#ifdef VAR_2
	conf_write(VAR_0, "" Default smtp_alert_vrrp = %s"",
			VAR_1->smtp_alert_vrrp == -1 ? ""unset"" : VAR_1->smtp_alert_vrrp ? ""on"" : ""off"");
#endif
#ifdef VAR_6
	conf_write(VAR_0, "" Default smtp_alert_checker = %s"",
			VAR_1->smtp_alert_checker == -1 ? ""unset"" : VAR_1->smtp_alert_checker ? ""on"" : ""off"");
#endif
#ifdef VAR_2
	conf_write(VAR_0, "" Dynamic interfaces = %s"", VAR_1->dynamic_interfaces ? ""true"" : ""false"");
	if (VAR_1->dynamic_interfaces)
		conf_write(VAR_0, "" Allow interface changes = %s"", VAR_1->allow_if_changes ? ""true"" : ""false"");
	if (VAR_1->no_email_faults)
		conf_write(VAR_0, "" Send emails for fault transitions = off"");
#endif
#ifdef VAR_6
	if (VAR_1->lvs_tcp_timeout)
		conf_write(VAR_0, "" LVS TCP timeout = %d"", VAR_1->lvs_tcp_timeout);
	if (VAR_1->lvs_tcpfin_timeout)
		conf_write(VAR_0, "" LVS TCP FIN timeout = %d"", VAR_1->lvs_tcpfin_timeout);
	if (VAR_1->lvs_udp_timeout)
		conf_write(VAR_0, "" LVS TCP timeout = %d"", VAR_1->lvs_udp_timeout);
#ifdef VAR_2
#ifndef VAR_7
	if (VAR_8 == VAR_9)
#endif
		conf_write(VAR_0, "" Default interface = %s"", VAR_1->default_ifp ? VAR_1->default_ifp->ifname : VAR_10);
	if (VAR_1->lvs_syncd.vrrp) {
		conf_write(VAR_0, "" LVS syncd vrrp instance = %s""
				    , VAR_1->lvs_syncd.vrrp->iname);
		if (VAR_1->lvs_syncd.ifname)
			conf_write(VAR_0, "" LVS syncd interface = %s""
				    , VAR_1->lvs_syncd.ifname);
		conf_write(VAR_0, "" LVS syncd syncid = %u""
				    , VAR_1->lvs_syncd.syncid);
#ifdef VAR_11
		if (VAR_1->lvs_syncd.sync_maxlen)
			conf_write(VAR_0, "" LVS syncd maxlen = %u"", VAR_1->lvs_syncd.sync_maxlen);
		if (VAR_1->lvs_syncd.mcast_group.ss_family != VAR_12)
			conf_write(VAR_0, "" LVS mcast group %s"", inet_sockaddrtos(&VAR_1->lvs_syncd.mcast_group));
		if (VAR_1->lvs_syncd.mcast_port)
			conf_write(VAR_0, "" LVS syncd mcast port = %d"", VAR_1->lvs_syncd.mcast_port);
		if (VAR_1->lvs_syncd.mcast_ttl)
			conf_write(VAR_0, "" LVS syncd mcast ttl = %u"", VAR_1->lvs_syncd.mcast_ttl);
#endif
	}
#endif
	conf_write(VAR_0, "" LVS flush = %s"", VAR_1->lvs_flush ? ""true"" : ""false"");
#endif
	if (VAR_1->notify_fifo.name) {
		conf_write(VAR_0, "" Global notify fifo = %s"", VAR_1->notify_fifo.name);
		if (VAR_1->notify_fifo.script)
			conf_write(VAR_0, "" Global notify fifo script = %s, uid:gid %d:%d"",
				    cmd_str(VAR_1->notify_fifo.script),
				    VAR_1->notify_fifo.script->uid,
				    VAR_1->notify_fifo.script->gid);
	}
#ifdef VAR_2
	if (VAR_1->vrrp_notify_fifo.name) {
		conf_write(VAR_0, "" VRRP notify fifo = %s"", VAR_1->vrrp_notify_fifo.name);
		if (VAR_1->vrrp_notify_fifo.script)
			conf_write(VAR_0, "" VRRP notify fifo script = %s, uid:gid %d:%d"",
				    cmd_str(VAR_1->vrrp_notify_fifo.script),
				    VAR_1->vrrp_notify_fifo.script->uid,
				    VAR_1->vrrp_notify_fifo.script->gid);
	}
#endif
#ifdef VAR_6
	if (VAR_1->lvs_notify_fifo.name) {
		conf_write(VAR_0, "" LVS notify fifo = %s"", VAR_1->lvs_notify_fifo.name);
		if (VAR_1->lvs_notify_fifo.script)
			conf_write(VAR_0, "" LVS notify fifo script = %s, uid:gid %d:%d"",
				    cmd_str(VAR_1->lvs_notify_fifo.script),
				    VAR_1->lvs_notify_fifo.script->uid,
				    VAR_1->lvs_notify_fifo.script->gid);
	}
#endif
#ifdef VAR_2
	if (VAR_1->vrrp_mcast_group4.sin_family) {
		conf_write(VAR_0, "" VRRP IPv4 mcast group = %s""
				    , inet_sockaddrtos((struct sockaddr_storage *)&VAR_1->vrrp_mcast_group4));
	}
	if (VAR_1->vrrp_mcast_group6.sin6_family) {
		conf_write(VAR_0, "" VRRP IPv6 mcast group = %s""
				    , inet_sockaddrtos((struct sockaddr_storage *)&VAR_1->vrrp_mcast_group6));
	}
	conf_write(VAR_0, "" Gratuitous ARP delay = %u"",
		       VAR_1->vrrp_garp_delay/VAR_5);
	conf_write(VAR_0, "" Gratuitous ARP repeat = %u"", VAR_1->vrrp_garp_rep);
	conf_write(VAR_0, "" Gratuitous ARP refresh timer = %lu"",
		       VAR_1->vrrp_garp_refresh.tv_sec);
	conf_write(VAR_0, "" Gratuitous ARP refresh repeat = %d"", VAR_1->vrrp_garp_refresh_rep);
	conf_write(VAR_0, "" Gratuitous ARP lower priority delay = %d"", VAR_1->vrrp_garp_lower_prio_delay == VAR_13 ? VAR_13 : VAR_1->vrrp_garp_lower_prio_delay / VAR_5);
	conf_write(VAR_0, "" Gratuitous ARP lower priority repeat = %d"", VAR_1->vrrp_garp_lower_prio_rep);
	conf_write(VAR_0, "" Send advert after receive lower priority advert = %s"", VAR_1->vrrp_lower_prio_no_advert ? ""false"" : ""true"");
	conf_write(VAR_0, "" Send advert after receive higher priority advert = %s"", VAR_1->vrrp_higher_prio_send_advert ? ""true"" : ""false"");
	conf_write(VAR_0, "" Gratuitous ARP interval = %d"", VAR_1->vrrp_garp_interval);
	conf_write(VAR_0, "" Gratuitous NA interval = %d"", VAR_1->vrrp_gna_interval);
	conf_write(VAR_0, "" VRRP default protocol version = %d"", VAR_1->vrrp_version);
	if (VAR_1->vrrp_iptables_inchain[0])
		conf_write(VAR_0,"" Iptables input chain = %s"", VAR_1->vrrp_iptables_inchain);
	if (VAR_1->vrrp_iptables_outchain[0])
		conf_write(VAR_0,"" Iptables output chain = %s"", VAR_1->vrrp_iptables_outchain);
#ifdef VAR_14
	conf_write(VAR_0, "" Using ipsets = %s"", VAR_1->using_ipsets ? ""true"" : ""false"");
	if (VAR_1->vrrp_ipset_address[0])
		conf_write(VAR_0,"" ipset IPv4 address set = %s"", VAR_1->vrrp_ipset_address);
	if (VAR_1->vrrp_ipset_address6[0])
		conf_write(VAR_0,"" ipset IPv6 address set = %s"", VAR_1->vrrp_ipset_address6);
	if (VAR_1->vrrp_ipset_address_iface6[0])
		conf_write(VAR_0,"" ipset IPv6 address,iface set = %s"", VAR_1->vrrp_ipset_address_iface6);
#endif

	conf_write(VAR_0, "" VRRP check unicast_src = %s"", VAR_1->vrrp_check_unicast_src ? ""true"" : ""false"");
	conf_write(VAR_0, "" VRRP skip check advert addresses = %s"", VAR_1->vrrp_skip_check_adv_addr ? ""true"" : ""false"");
	conf_write(VAR_0, "" VRRP strict mode = %s"", VAR_1->vrrp_strict ? ""true"" : ""false"");
	conf_write(VAR_0, "" VRRP process priority = %d"", VAR_1->vrrp_process_priority);
	conf_write(VAR_0, "" VRRP don't swap = %s"", VAR_1->vrrp_no_swap ? ""true"" : ""false"");
#ifdef VAR_15
	conf_write(VAR_0, "" VRRP realtime priority = %u"", VAR_1->vrrp_realtime_priority);
#if VAR_16
	conf_write(VAR_0, "" VRRP realtime limit = %lu"", VAR_1->vrrp_rlimit_rt);
#endif
#endif
#endif
#ifdef VAR_6
	conf_write(VAR_0, "" Checker process priority = %d"", VAR_1->checker_process_priority);
	conf_write(VAR_0, "" Checker don't swap = %s"", VAR_1->checker_no_swap ? ""true"" : ""false"");
#ifdef VAR_15
	conf_write(VAR_0, "" Checker realtime priority = %u"", VAR_1->checker_realtime_priority);
#if VAR_16
	conf_write(VAR_0, "" Checker realtime limit = %lu"", VAR_1->checker_rlimit_rt);
#endif
#endif
#endif
#ifdef VAR_17
	conf_write(VAR_0, "" BFD process priority = %d"", VAR_1->bfd_process_priority);
	conf_write(VAR_0, "" BFD don't swap = %s"", VAR_1->bfd_no_swap ? ""true"" : ""false"");
#ifdef VAR_15
	conf_write(VAR_0, "" BFD realtime priority = %u"", VAR_1->bfd_realtime_priority);
#if VAR_16
	conf_write(VAR_0, "" BFD realtime limit = %lu"", VAR_1->bfd_rlimit_rt);
#endif
#endif
#endif
#ifdef VAR_18
	conf_write(VAR_0, "" SNMP vrrp %s"", VAR_1->enable_snmp_vrrp ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_19
	conf_write(VAR_0, "" SNMP checker %s"", VAR_1->enable_snmp_checker ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_20
	conf_write(VAR_0, "" SNMP RFCv2 %s"", VAR_1->enable_snmp_rfcv2 ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_21
	conf_write(VAR_0, "" SNMP RFCv3 %s"", VAR_1->enable_snmp_rfcv3 ? ""enabled"" : ""disabled"");
#endif
#ifdef VAR_22
	conf_write(VAR_0, "" SNMP traps %s"", VAR_1->enable_traps ? ""enabled"" : ""disabled"");
	conf_write(VAR_0, "" SNMP socket = %s"", VAR_1->snmp_socket ? VAR_1->snmp_socket : ""default (unix:/var/agentx/master)"");
#endif
#ifdef VAR_23
	conf_write(VAR_0, "" DBus %s"", VAR_1->enable_dbus ? ""enabled"" : ""disabled"");
	conf_write(VAR_0, "" DBus service name = %s"", VAR_1->dbus_service_name ? VAR_1->dbus_service_name : """");
#endif
	conf_write(VAR_0, "" Script security %s"", VAR_24 ? ""enabled"" : ""disabled"");
	conf_write(VAR_0, "" Default script uid:gid %d:%d"", VAR_25, VAR_26);
#ifdef VAR_2
	conf_write(VAR_0, "" vrrp_netlink_cmd_rcv_bufs = %u"", VAR_27->vrrp_netlink_cmd_rcv_bufs);
	conf_write(VAR_0, "" vrrp_netlink_cmd_rcv_bufs_force = %u"", VAR_27->vrrp_netlink_cmd_rcv_bufs_force);
	conf_write(VAR_0, "" vrrp_netlink_monitor_rcv_bufs = %u"", VAR_27->vrrp_netlink_monitor_rcv_bufs);
	conf_write(VAR_0, "" vrrp_netlink_monitor_rcv_bufs_force = %u"", VAR_27->vrrp_netlink_monitor_rcv_bufs_force);
#endif
#ifdef VAR_6
	conf_write(VAR_0, "" lvs_netlink_cmd_rcv_bufs = %u"", VAR_27->lvs_netlink_cmd_rcv_bufs);
	conf_write(VAR_0, "" lvs_netlink_cmd_rcv_bufs_force = %u"", VAR_27->lvs_netlink_cmd_rcv_bufs_force);
	conf_write(VAR_0, "" lvs_netlink_monitor_rcv_bufs = %u"", VAR_27->lvs_netlink_monitor_rcv_bufs);
	conf_write(VAR_0, "" lvs_netlink_monitor_rcv_bufs_force = %u"", VAR_27->lvs_netlink_monitor_rcv_bufs_force);
	conf_write(VAR_0, "" rs_init_notifies = %u"", VAR_27->rs_init_notifies);
	conf_write(VAR_0, "" no_checker_emails = %u"", VAR_27->no_checker_emails);
#endif
#ifdef VAR_2
	VAR_3[0] = '\0';
	if (VAR_27->vrrp_rx_bufs_policy & VAR_28)
		strcpy(VAR_3, "" rx_bufs_policy = MTU"");
	else if (VAR_27->vrrp_rx_bufs_policy & VAR_29)
		strcpy(VAR_3, "" rx_bufs_policy = ADVERT"");
	else if (VAR_27->vrrp_rx_bufs_policy & VAR_30)
		sprintf(VAR_3, "" rx_bufs_size = %lu"", VAR_27->vrrp_rx_bufs_size);
	if (VAR_3[0])
		conf_write(VAR_0, ""%s"", VAR_3);
	conf_write(VAR_0, "" rx_bufs_multiples = %u"", VAR_27->vrrp_rx_bufs_multiples);
	conf_write(VAR_0, "" umask = 0%o"", VAR_27->umask);
#endif
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/global_data.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -225,5 +225,6 @@
 	if (buf[0])
 		conf_write(fp, ""%s"", buf);
 	conf_write(fp, "" rx_bufs_multiples = %u"", global_data->vrrp_rx_bufs_multiples);
+	conf_write(fp, "" umask = 0%o"", global_data->umask);
 #endif
 }","{'deleted_lines': [], 'added_lines': ['\tconf_write(fp, "" umask = 0%o"", global_data->umask);']}",True,"keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information.",7.5,HIGH,2,test,2018-10-31T17:08:51Z,2
CVE-2018-19045,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,acassen/keepalived,"Add command line and configuration option to set umask

Issue #1048 identified that files created by keepalived are created
with mode 0666. This commit changes the default to 0644, and also
allows the umask to be specified in the configuration or as a command
line option.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,keepalived/core/global_parser.c,init_global_keywords,"void
init_global_keywords(bool global_active)
{
install_keyword_root(""linkbeat_use_polling"", use_polling_handler, global_active);
#if HAVE_DECL_CLONE_NEWNET
install_keyword_root(""net_namespace"", &net_namespace_handler, global_active);
install_keyword_root(""namespace_with_ipsets"", &namespace_ipsets_handler, global_active);
#endif
install_keyword_root(""use_pid_dir"", &use_pid_dir_handler, global_active);
install_keyword_root(""instance"", &instance_handler, global_active);
install_keyword_root(""child_wait_time"", &child_wait_handler, global_active);
install_keyword_root(""global_defs"", NULL, global_active);
install_keyword(""router_id"", &routerid_handler);
install_keyword(""notification_email_from"", &emailfrom_handler);
install_keyword(""smtp_server"", &smtpserver_handler);
install_keyword(""smtp_helo_name"", &smtphelo_handler);
install_keyword(""smtp_connect_timeout"", &smtpto_handler);
install_keyword(""notification_email"", &email_handler);
install_keyword(""smtp_alert"", &smtp_alert_handler);
#ifdef _WITH_VRRP_
install_keyword(""smtp_alert_vrrp"", &smtp_alert_vrrp_handler);
#endif
#ifdef _WITH_LVS_
install_keyword(""smtp_alert_checker"", &smtp_alert_checker_handler);
#endif
#ifdef _WITH_VRRP_
install_keyword(""dynamic_interfaces"", &dynamic_interfaces_handler);
install_keyword(""no_email_faults"", &no_email_faults_handler);
install_keyword(""default_interface"", &default_interface_handler);
#endif
#ifdef _WITH_LVS_
install_keyword(""lvs_timeouts"", &lvs_timeouts);
install_keyword(""lvs_flush"", &lvs_flush_handler);
#ifdef _WITH_VRRP_
install_keyword(""lvs_sync_daemon"", &lvs_syncd_handler);
#endif
#endif
#ifdef _WITH_VRRP_
install_keyword(""vrrp_mcast_group4"", &vrrp_mcast_group4_handler);
install_keyword(""vrrp_mcast_group6"", &vrrp_mcast_group6_handler);
install_keyword(""vrrp_garp_master_delay"", &vrrp_garp_delay_handler);
install_keyword(""vrrp_garp_master_repeat"", &vrrp_garp_rep_handler);
install_keyword(""vrrp_garp_master_refresh"", &vrrp_garp_refresh_handler);
install_keyword(""vrrp_garp_master_refresh_repeat"", &vrrp_garp_refresh_rep_handler);
install_keyword(""vrrp_garp_lower_prio_delay"", &vrrp_garp_lower_prio_delay_handler);
install_keyword(""vrrp_garp_lower_prio_repeat"", &vrrp_garp_lower_prio_rep_handler);
install_keyword(""vrrp_garp_interval"", &vrrp_garp_interval_handler);
install_keyword(""vrrp_gna_interval"", &vrrp_gna_interval_handler);
install_keyword(""vrrp_lower_prio_no_advert"", &vrrp_lower_prio_no_advert_handler);
install_keyword(""vrrp_higher_prio_send_advert"", &vrrp_higher_prio_send_advert_handler);
install_keyword(""vrrp_version"", &vrrp_version_handler);
install_keyword(""vrrp_iptables"", &vrrp_iptables_handler);
#ifdef _HAVE_LIBIPSET_
install_keyword(""vrrp_ipsets"", &vrrp_ipsets_handler);
#endif
install_keyword(""vrrp_check_unicast_src"", &vrrp_check_unicast_src_handler);
install_keyword(""vrrp_skip_check_adv_addr"", &vrrp_check_adv_addr_handler);
install_keyword(""vrrp_strict"", &vrrp_strict_handler);
install_keyword(""vrrp_priority"", &vrrp_prio_handler);
install_keyword(""vrrp_no_swap"", &vrrp_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
install_keyword(""vrrp_rt_priority"", &vrrp_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
install_keyword(""vrrp_rlimit_rtime"", &vrrp_rt_rlimit_handler);
#endif
#endif
#endif
install_keyword(""notify_fifo"", &global_notify_fifo);
install_keyword(""notify_fifo_script"", &global_notify_fifo_script);
#ifdef _WITH_VRRP_
install_keyword(""vrrp_notify_fifo"", &vrrp_notify_fifo);
install_keyword(""vrrp_notify_fifo_script"", &vrrp_notify_fifo_script);
#endif
#ifdef _WITH_LVS_
install_keyword(""lvs_notify_fifo"", &lvs_notify_fifo);
install_keyword(""lvs_notify_fifo_script"", &lvs_notify_fifo_script);
install_keyword(""checker_priority"", &checker_prio_handler);
install_keyword(""checker_no_swap"", &checker_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
install_keyword(""checker_rt_priority"", &checker_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
install_keyword(""checker_rlimit_rtime"", &checker_rt_rlimit_handler);
#endif
#endif
#endif
#ifdef _WITH_BFD_
install_keyword(""bfd_priority"", &bfd_prio_handler);
install_keyword(""bfd_no_swap"", &bfd_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
install_keyword(""bfd_rt_priority"", &bfd_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
install_keyword(""bfd_rlimit_rtime"", &bfd_rt_rlimit_handler);
#endif
#endif
#endif
#ifdef _WITH_SNMP_
install_keyword(""snmp_socket"", &snmp_socket_handler);
install_keyword(""enable_traps"", &trap_handler);
#ifdef _WITH_SNMP_VRRP_
install_keyword(""enable_snmp_vrrp"", &snmp_vrrp_handler);
install_keyword(""enable_snmp_keepalived"", &snmp_vrrp_handler);
#endif
#ifdef _WITH_SNMP_RFC_
install_keyword(""enable_snmp_rfc"", &snmp_rfc_handler);
#endif
#ifdef _WITH_SNMP_RFCV2_
install_keyword(""enable_snmp_rfcv2"", &snmp_rfcv2_handler);
#endif
#ifdef _WITH_SNMP_RFCV3_
install_keyword(""enable_snmp_rfcv3"", &snmp_rfcv3_handler);
#endif
#ifdef _WITH_SNMP_CHECKER_
install_keyword(""enable_snmp_checker"", &snmp_checker_handler);
#endif
#endif
#ifdef _WITH_DBUS_
install_keyword(""enable_dbus"", &enable_dbus_handler);
install_keyword(""dbus_service_name"", &dbus_service_name_handler);
#endif
install_keyword(""script_user"", &script_user_handler);
install_keyword(""enable_script_security"", &script_security_handler);
#ifdef _WITH_VRRP_
install_keyword(""vrrp_netlink_cmd_rcv_bufs"", &vrrp_netlink_cmd_rcv_bufs_handler);
install_keyword(""vrrp_netlink_cmd_rcv_bufs_force"", &vrrp_netlink_cmd_rcv_bufs_force_handler);
install_keyword(""vrrp_netlink_monitor_rcv_bufs"", &vrrp_netlink_monitor_rcv_bufs_handler);
install_keyword(""vrrp_netlink_monitor_rcv_bufs_force"", &vrrp_netlink_monitor_rcv_bufs_force_handler);
#endif
#ifdef _WITH_LVS_
install_keyword(""lvs_netlink_cmd_rcv_bufs"", &lvs_netlink_cmd_rcv_bufs_handler);
install_keyword(""lvs_netlink_cmd_rcv_bufs_force"", &lvs_netlink_cmd_rcv_bufs_force_handler);
install_keyword(""lvs_netlink_monitor_rcv_bufs"", &lvs_netlink_monitor_rcv_bufs_handler);
install_keyword(""lvs_netlink_monitor_rcv_bufs_force"", &lvs_netlink_monitor_rcv_bufs_force_handler);
#endif
#ifdef _WITH_LVS_
install_keyword(""rs_init_notifies"", &rs_init_notifies_handler);
install_keyword(""no_checker_emails"", &no_checker_emails_handler);
#endif
#ifdef _WITH_VRRP_
install_keyword(""vrrp_rx_bufs_policy"", &vrrp_rx_bufs_policy_handler);
install_keyword(""vrrp_rx_bufs_multiplier"", &vrrp_rx_bufs_multiplier_handler);
#endif
}","void
init_global_keywords(bool VAR_0)
{
install_keyword_root(""linkbeat_use_polling"", VAR_1, VAR_0);
#if VAR_2
install_keyword_root(""net_namespace"", &VAR_3, VAR_0);
install_keyword_root(""namespace_with_ipsets"", &VAR_4, VAR_0);
#endif
install_keyword_root(""use_pid_dir"", &VAR_5, VAR_0);
install_keyword_root(""instance"", &VAR_6, VAR_0);
install_keyword_root(""child_wait_time"", &VAR_7, VAR_0);
install_keyword_root(""global_defs"", NULL, VAR_0);
install_keyword(""router_id"", &VAR_8);
install_keyword(""notification_email_from"", &VAR_9);
install_keyword(""smtp_server"", &VAR_10);
install_keyword(""smtp_helo_name"", &VAR_11);
install_keyword(""smtp_connect_timeout"", &VAR_12);
install_keyword(""notification_email"", &VAR_13);
install_keyword(""smtp_alert"", &VAR_14);
#ifdef VAR_15
install_keyword(""smtp_alert_vrrp"", &VAR_16);
#endif
#ifdef VAR_17
install_keyword(""smtp_alert_checker"", &VAR_18);
#endif
#ifdef VAR_15
install_keyword(""dynamic_interfaces"", &VAR_19);
install_keyword(""no_email_faults"", &VAR_20);
install_keyword(""default_interface"", &VAR_21);
#endif
#ifdef VAR_17
install_keyword(""lvs_timeouts"", &VAR_22);
install_keyword(""lvs_flush"", &VAR_23);
#ifdef VAR_15
install_keyword(""lvs_sync_daemon"", &VAR_24);
#endif
#endif
#ifdef VAR_15
install_keyword(""vrrp_mcast_group4"", &VAR_25);
install_keyword(""vrrp_mcast_group6"", &VAR_26);
install_keyword(""vrrp_garp_master_delay"", &VAR_27);
install_keyword(""vrrp_garp_master_repeat"", &VAR_28);
install_keyword(""vrrp_garp_master_refresh"", &VAR_29);
install_keyword(""vrrp_garp_master_refresh_repeat"", &VAR_30);
install_keyword(""vrrp_garp_lower_prio_delay"", &VAR_31);
install_keyword(""vrrp_garp_lower_prio_repeat"", &VAR_32);
install_keyword(""vrrp_garp_interval"", &VAR_33);
install_keyword(""vrrp_gna_interval"", &VAR_34);
install_keyword(""vrrp_lower_prio_no_advert"", &VAR_35);
install_keyword(""vrrp_higher_prio_send_advert"", &VAR_36);
install_keyword(""vrrp_version"", &VAR_37);
install_keyword(""vrrp_iptables"", &VAR_38);
#ifdef VAR_39
install_keyword(""vrrp_ipsets"", &VAR_40);
#endif
install_keyword(""vrrp_check_unicast_src"", &VAR_41);
install_keyword(""vrrp_skip_check_adv_addr"", &VAR_42);
install_keyword(""vrrp_strict"", &VAR_43);
install_keyword(""vrrp_priority"", &VAR_44);
install_keyword(""vrrp_no_swap"", &VAR_45);
#ifdef VAR_46
install_keyword(""vrrp_rt_priority"", &VAR_47);
#if VAR_48 == 1
install_keyword(""vrrp_rlimit_rtime"", &VAR_49);
#endif
#endif
#endif
install_keyword(""notify_fifo"", &VAR_50);
install_keyword(""notify_fifo_script"", &VAR_51);
#ifdef VAR_15
install_keyword(""vrrp_notify_fifo"", &VAR_52);
install_keyword(""vrrp_notify_fifo_script"", &VAR_53);
#endif
#ifdef VAR_17
install_keyword(""lvs_notify_fifo"", &VAR_54);
install_keyword(""lvs_notify_fifo_script"", &VAR_55);
install_keyword(""checker_priority"", &VAR_56);
install_keyword(""checker_no_swap"", &VAR_57);
#ifdef VAR_46
install_keyword(""checker_rt_priority"", &VAR_58);
#if VAR_48 == 1
install_keyword(""checker_rlimit_rtime"", &VAR_59);
#endif
#endif
#endif
#ifdef VAR_60
install_keyword(""bfd_priority"", &VAR_61);
install_keyword(""bfd_no_swap"", &VAR_62);
#ifdef VAR_46
install_keyword(""bfd_rt_priority"", &VAR_63);
#if VAR_48 == 1
install_keyword(""bfd_rlimit_rtime"", &VAR_64);
#endif
#endif
#endif
#ifdef VAR_65
install_keyword(""snmp_socket"", &VAR_66);
install_keyword(""enable_traps"", &VAR_67);
#ifdef VAR_68
install_keyword(""enable_snmp_vrrp"", &VAR_69);
install_keyword(""enable_snmp_keepalived"", &VAR_69);
#endif
#ifdef VAR_70
install_keyword(""enable_snmp_rfc"", &VAR_71);
#endif
#ifdef VAR_72
install_keyword(""enable_snmp_rfcv2"", &VAR_73);
#endif
#ifdef VAR_74
install_keyword(""enable_snmp_rfcv3"", &VAR_75);
#endif
#ifdef VAR_76
install_keyword(""enable_snmp_checker"", &VAR_77);
#endif
#endif
#ifdef VAR_78
install_keyword(""enable_dbus"", &VAR_79);
install_keyword(""dbus_service_name"", &VAR_80);
#endif
install_keyword(""script_user"", &VAR_81);
install_keyword(""enable_script_security"", &VAR_82);
#ifdef VAR_15
install_keyword(""vrrp_netlink_cmd_rcv_bufs"", &VAR_83);
install_keyword(""vrrp_netlink_cmd_rcv_bufs_force"", &VAR_84);
install_keyword(""vrrp_netlink_monitor_rcv_bufs"", &VAR_85);
install_keyword(""vrrp_netlink_monitor_rcv_bufs_force"", &VAR_86);
#endif
#ifdef VAR_17
install_keyword(""lvs_netlink_cmd_rcv_bufs"", &VAR_87);
install_keyword(""lvs_netlink_cmd_rcv_bufs_force"", &VAR_88);
install_keyword(""lvs_netlink_monitor_rcv_bufs"", &VAR_89);
install_keyword(""lvs_netlink_monitor_rcv_bufs_force"", &VAR_90);
#endif
#ifdef VAR_17
install_keyword(""rs_init_notifies"", &VAR_91);
install_keyword(""no_checker_emails"", &VAR_92);
#endif
#ifdef VAR_15
install_keyword(""vrrp_rx_bufs_policy"", &VAR_93);
install_keyword(""vrrp_rx_bufs_multiplier"", &VAR_94);
#endif
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/global_parser.c/vul/before/0.json,"void
init_global_keywords(bool global_active)
{
	/* global definitions mapping */
	install_keyword_root(""linkbeat_use_polling"", use_polling_handler, global_active);
#if HAVE_DECL_CLONE_NEWNET
	install_keyword_root(""net_namespace"", &net_namespace_handler, global_active);
	install_keyword_root(""namespace_with_ipsets"", &namespace_ipsets_handler, global_active);
#endif
	install_keyword_root(""use_pid_dir"", &use_pid_dir_handler, global_active);
	install_keyword_root(""instance"", &instance_handler, global_active);
	install_keyword_root(""child_wait_time"", &child_wait_handler, global_active);
	install_keyword_root(""global_defs"", NULL, global_active);
	install_keyword(""router_id"", &routerid_handler);
	install_keyword(""notification_email_from"", &emailfrom_handler);
	install_keyword(""smtp_server"", &smtpserver_handler);
	install_keyword(""smtp_helo_name"", &smtphelo_handler);
	install_keyword(""smtp_connect_timeout"", &smtpto_handler);
	install_keyword(""notification_email"", &email_handler);
	install_keyword(""smtp_alert"", &smtp_alert_handler);
#ifdef _WITH_VRRP_
	install_keyword(""smtp_alert_vrrp"", &smtp_alert_vrrp_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""smtp_alert_checker"", &smtp_alert_checker_handler);
#endif
#ifdef _WITH_VRRP_
	install_keyword(""dynamic_interfaces"", &dynamic_interfaces_handler);
	install_keyword(""no_email_faults"", &no_email_faults_handler);
	install_keyword(""default_interface"", &default_interface_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""lvs_timeouts"", &lvs_timeouts);
	install_keyword(""lvs_flush"", &lvs_flush_handler);
#ifdef _WITH_VRRP_
	install_keyword(""lvs_sync_daemon"", &lvs_syncd_handler);
#endif
#endif
#ifdef _WITH_VRRP_
	install_keyword(""vrrp_mcast_group4"", &vrrp_mcast_group4_handler);
	install_keyword(""vrrp_mcast_group6"", &vrrp_mcast_group6_handler);
	install_keyword(""vrrp_garp_master_delay"", &vrrp_garp_delay_handler);
	install_keyword(""vrrp_garp_master_repeat"", &vrrp_garp_rep_handler);
	install_keyword(""vrrp_garp_master_refresh"", &vrrp_garp_refresh_handler);
	install_keyword(""vrrp_garp_master_refresh_repeat"", &vrrp_garp_refresh_rep_handler);
	install_keyword(""vrrp_garp_lower_prio_delay"", &vrrp_garp_lower_prio_delay_handler);
	install_keyword(""vrrp_garp_lower_prio_repeat"", &vrrp_garp_lower_prio_rep_handler);
	install_keyword(""vrrp_garp_interval"", &vrrp_garp_interval_handler);
	install_keyword(""vrrp_gna_interval"", &vrrp_gna_interval_handler);
	install_keyword(""vrrp_lower_prio_no_advert"", &vrrp_lower_prio_no_advert_handler);
	install_keyword(""vrrp_higher_prio_send_advert"", &vrrp_higher_prio_send_advert_handler);
	install_keyword(""vrrp_version"", &vrrp_version_handler);
	install_keyword(""vrrp_iptables"", &vrrp_iptables_handler);
#ifdef _HAVE_LIBIPSET_
	install_keyword(""vrrp_ipsets"", &vrrp_ipsets_handler);
#endif
	install_keyword(""vrrp_check_unicast_src"", &vrrp_check_unicast_src_handler);
	install_keyword(""vrrp_skip_check_adv_addr"", &vrrp_check_adv_addr_handler);
	install_keyword(""vrrp_strict"", &vrrp_strict_handler);
	install_keyword(""vrrp_priority"", &vrrp_prio_handler);
	install_keyword(""vrrp_no_swap"", &vrrp_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
	install_keyword(""vrrp_rt_priority"", &vrrp_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
	install_keyword(""vrrp_rlimit_rtime"", &vrrp_rt_rlimit_handler);
#endif
#endif
#endif
	install_keyword(""notify_fifo"", &global_notify_fifo);
	install_keyword(""notify_fifo_script"", &global_notify_fifo_script);
#ifdef _WITH_VRRP_
	install_keyword(""vrrp_notify_fifo"", &vrrp_notify_fifo);
	install_keyword(""vrrp_notify_fifo_script"", &vrrp_notify_fifo_script);
#endif
#ifdef _WITH_LVS_
	install_keyword(""lvs_notify_fifo"", &lvs_notify_fifo);
	install_keyword(""lvs_notify_fifo_script"", &lvs_notify_fifo_script);
	install_keyword(""checker_priority"", &checker_prio_handler);
	install_keyword(""checker_no_swap"", &checker_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
	install_keyword(""checker_rt_priority"", &checker_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
	install_keyword(""checker_rlimit_rtime"", &checker_rt_rlimit_handler);
#endif
#endif
#endif
#ifdef _WITH_BFD_
	install_keyword(""bfd_priority"", &bfd_prio_handler);
	install_keyword(""bfd_no_swap"", &bfd_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
	install_keyword(""bfd_rt_priority"", &bfd_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
	install_keyword(""bfd_rlimit_rtime"", &bfd_rt_rlimit_handler);
#endif
#endif
#endif
#ifdef _WITH_SNMP_
	install_keyword(""snmp_socket"", &snmp_socket_handler);
	install_keyword(""enable_traps"", &trap_handler);
#ifdef _WITH_SNMP_VRRP_
	install_keyword(""enable_snmp_vrrp"", &snmp_vrrp_handler);
	install_keyword(""enable_snmp_keepalived"", &snmp_vrrp_handler);	/* Deprecated v2.0.0 */
#endif
#ifdef _WITH_SNMP_RFC_
	install_keyword(""enable_snmp_rfc"", &snmp_rfc_handler);
#endif
#ifdef _WITH_SNMP_RFCV2_
	install_keyword(""enable_snmp_rfcv2"", &snmp_rfcv2_handler);
#endif
#ifdef _WITH_SNMP_RFCV3_
	install_keyword(""enable_snmp_rfcv3"", &snmp_rfcv3_handler);
#endif
#ifdef _WITH_SNMP_CHECKER_
	install_keyword(""enable_snmp_checker"", &snmp_checker_handler);
#endif
#endif
#ifdef _WITH_DBUS_
	install_keyword(""enable_dbus"", &enable_dbus_handler);
	install_keyword(""dbus_service_name"", &dbus_service_name_handler);
#endif
	install_keyword(""script_user"", &script_user_handler);
	install_keyword(""enable_script_security"", &script_security_handler);
#ifdef _WITH_VRRP_
	install_keyword(""vrrp_netlink_cmd_rcv_bufs"", &vrrp_netlink_cmd_rcv_bufs_handler);
	install_keyword(""vrrp_netlink_cmd_rcv_bufs_force"", &vrrp_netlink_cmd_rcv_bufs_force_handler);
	install_keyword(""vrrp_netlink_monitor_rcv_bufs"", &vrrp_netlink_monitor_rcv_bufs_handler);
	install_keyword(""vrrp_netlink_monitor_rcv_bufs_force"", &vrrp_netlink_monitor_rcv_bufs_force_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""lvs_netlink_cmd_rcv_bufs"", &lvs_netlink_cmd_rcv_bufs_handler);
	install_keyword(""lvs_netlink_cmd_rcv_bufs_force"", &lvs_netlink_cmd_rcv_bufs_force_handler);
	install_keyword(""lvs_netlink_monitor_rcv_bufs"", &lvs_netlink_monitor_rcv_bufs_handler);
	install_keyword(""lvs_netlink_monitor_rcv_bufs_force"", &lvs_netlink_monitor_rcv_bufs_force_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""rs_init_notifies"", &rs_init_notifies_handler);
	install_keyword(""no_checker_emails"", &no_checker_emails_handler);
#endif
#ifdef _WITH_VRRP_
	install_keyword(""vrrp_rx_bufs_policy"", &vrrp_rx_bufs_policy_handler);
	install_keyword(""vrrp_rx_bufs_multiplier"", &vrrp_rx_bufs_multiplier_handler);
#endif
	install_keyword(""umask"", &umask_handler);
}","void
init_global_keywords(bool VAR_0)
{
	/* COMMENT_0 */
	install_keyword_root(""linkbeat_use_polling"", VAR_1, VAR_0);
#if VAR_2
	install_keyword_root(""net_namespace"", &VAR_3, VAR_0);
	install_keyword_root(""namespace_with_ipsets"", &VAR_4, VAR_0);
#endif
	install_keyword_root(""use_pid_dir"", &VAR_5, VAR_0);
	install_keyword_root(""instance"", &VAR_6, VAR_0);
	install_keyword_root(""child_wait_time"", &VAR_7, VAR_0);
	install_keyword_root(""global_defs"", NULL, VAR_0);
	install_keyword(""router_id"", &VAR_8);
	install_keyword(""notification_email_from"", &VAR_9);
	install_keyword(""smtp_server"", &VAR_10);
	install_keyword(""smtp_helo_name"", &VAR_11);
	install_keyword(""smtp_connect_timeout"", &VAR_12);
	install_keyword(""notification_email"", &VAR_13);
	install_keyword(""smtp_alert"", &VAR_14);
#ifdef VAR_15
	install_keyword(""smtp_alert_vrrp"", &VAR_16);
#endif
#ifdef VAR_17
	install_keyword(""smtp_alert_checker"", &VAR_18);
#endif
#ifdef VAR_15
	install_keyword(""dynamic_interfaces"", &VAR_19);
	install_keyword(""no_email_faults"", &VAR_20);
	install_keyword(""default_interface"", &VAR_21);
#endif
#ifdef VAR_17
	install_keyword(""lvs_timeouts"", &VAR_22);
	install_keyword(""lvs_flush"", &VAR_23);
#ifdef VAR_15
	install_keyword(""lvs_sync_daemon"", &VAR_24);
#endif
#endif
#ifdef VAR_15
	install_keyword(""vrrp_mcast_group4"", &VAR_25);
	install_keyword(""vrrp_mcast_group6"", &VAR_26);
	install_keyword(""vrrp_garp_master_delay"", &VAR_27);
	install_keyword(""vrrp_garp_master_repeat"", &VAR_28);
	install_keyword(""vrrp_garp_master_refresh"", &VAR_29);
	install_keyword(""vrrp_garp_master_refresh_repeat"", &VAR_30);
	install_keyword(""vrrp_garp_lower_prio_delay"", &VAR_31);
	install_keyword(""vrrp_garp_lower_prio_repeat"", &VAR_32);
	install_keyword(""vrrp_garp_interval"", &VAR_33);
	install_keyword(""vrrp_gna_interval"", &VAR_34);
	install_keyword(""vrrp_lower_prio_no_advert"", &VAR_35);
	install_keyword(""vrrp_higher_prio_send_advert"", &VAR_36);
	install_keyword(""vrrp_version"", &VAR_37);
	install_keyword(""vrrp_iptables"", &VAR_38);
#ifdef VAR_39
	install_keyword(""vrrp_ipsets"", &VAR_40);
#endif
	install_keyword(""vrrp_check_unicast_src"", &VAR_41);
	install_keyword(""vrrp_skip_check_adv_addr"", &VAR_42);
	install_keyword(""vrrp_strict"", &VAR_43);
	install_keyword(""vrrp_priority"", &VAR_44);
	install_keyword(""vrrp_no_swap"", &VAR_45);
#ifdef VAR_46
	install_keyword(""vrrp_rt_priority"", &VAR_47);
#if VAR_48 == 1
	install_keyword(""vrrp_rlimit_rtime"", &VAR_49);
#endif
#endif
#endif
	install_keyword(""notify_fifo"", &VAR_50);
	install_keyword(""notify_fifo_script"", &VAR_51);
#ifdef VAR_15
	install_keyword(""vrrp_notify_fifo"", &VAR_52);
	install_keyword(""vrrp_notify_fifo_script"", &VAR_53);
#endif
#ifdef VAR_17
	install_keyword(""lvs_notify_fifo"", &VAR_54);
	install_keyword(""lvs_notify_fifo_script"", &VAR_55);
	install_keyword(""checker_priority"", &VAR_56);
	install_keyword(""checker_no_swap"", &VAR_57);
#ifdef VAR_46
	install_keyword(""checker_rt_priority"", &VAR_58);
#if VAR_48 == 1
	install_keyword(""checker_rlimit_rtime"", &VAR_59);
#endif
#endif
#endif
#ifdef VAR_60
	install_keyword(""bfd_priority"", &VAR_61);
	install_keyword(""bfd_no_swap"", &VAR_62);
#ifdef VAR_46
	install_keyword(""bfd_rt_priority"", &VAR_63);
#if VAR_48 == 1
	install_keyword(""bfd_rlimit_rtime"", &VAR_64);
#endif
#endif
#endif
#ifdef VAR_65
	install_keyword(""snmp_socket"", &VAR_66);
	install_keyword(""enable_traps"", &VAR_67);
#ifdef VAR_68
	install_keyword(""enable_snmp_vrrp"", &VAR_69);
	install_keyword(""enable_snmp_keepalived"", &VAR_69);	/* COMMENT_1 */
#endif
#ifdef VAR_70
	install_keyword(""enable_snmp_rfc"", &VAR_71);
#endif
#ifdef VAR_72
	install_keyword(""enable_snmp_rfcv2"", &VAR_73);
#endif
#ifdef VAR_74
	install_keyword(""enable_snmp_rfcv3"", &VAR_75);
#endif
#ifdef VAR_76
	install_keyword(""enable_snmp_checker"", &VAR_77);
#endif
#endif
#ifdef VAR_78
	install_keyword(""enable_dbus"", &VAR_79);
	install_keyword(""dbus_service_name"", &VAR_80);
#endif
	install_keyword(""script_user"", &VAR_81);
	install_keyword(""enable_script_security"", &VAR_82);
#ifdef VAR_15
	install_keyword(""vrrp_netlink_cmd_rcv_bufs"", &VAR_83);
	install_keyword(""vrrp_netlink_cmd_rcv_bufs_force"", &VAR_84);
	install_keyword(""vrrp_netlink_monitor_rcv_bufs"", &VAR_85);
	install_keyword(""vrrp_netlink_monitor_rcv_bufs_force"", &VAR_86);
#endif
#ifdef VAR_17
	install_keyword(""lvs_netlink_cmd_rcv_bufs"", &VAR_87);
	install_keyword(""lvs_netlink_cmd_rcv_bufs_force"", &VAR_88);
	install_keyword(""lvs_netlink_monitor_rcv_bufs"", &VAR_89);
	install_keyword(""lvs_netlink_monitor_rcv_bufs_force"", &VAR_90);
#endif
#ifdef VAR_17
	install_keyword(""rs_init_notifies"", &VAR_91);
	install_keyword(""no_checker_emails"", &VAR_92);
#endif
#ifdef VAR_15
	install_keyword(""vrrp_rx_bufs_policy"", &VAR_93);
	install_keyword(""vrrp_rx_bufs_multiplier"", &VAR_94);
#endif
	install_keyword(""umask"", &VAR_95);
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/global_parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -140,4 +140,5 @@
 	install_keyword(""vrrp_rx_bufs_policy"", &vrrp_rx_bufs_policy_handler);
 	install_keyword(""vrrp_rx_bufs_multiplier"", &vrrp_rx_bufs_multiplier_handler);
 #endif
+	install_keyword(""umask"", &umask_handler);
 }","{'deleted_lines': [], 'added_lines': ['\tinstall_keyword(""umask"", &umask_handler);']}",True,"keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information.",7.5,HIGH,2,test,2018-10-31T17:08:51Z,2
CVE-2018-19045,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,acassen/keepalived,"Add command line and configuration option to set umask

Issue #1048 identified that files created by keepalived are created
with mode 0666. This commit changes the default to 0644, and also
allows the umask to be specified in the configuration or as a command
line option.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,keepalived/core/main.c,parse_cmdline,"static bool
parse_cmdline(int argc, char **argv)
{
int c;
bool reopen_log = false;
int signum;
struct utsname uname_buf;
int longindex;
int curind;
bool bad_option = false;
unsigned facility;
struct option long_options[] = {
{""use-file"",required_argument,NULL, 'f'},
#if defined _WITH_VRRP_ && defined _WITH_LVS_
{""vrrp"",no_argument,NULL, 'P'},
{""check"",no_argument,NULL, 'C'},
#endif
#ifdef _WITH_BFD_
{""no_bfd"",no_argument,NULL, 'B'},
#endif
{""all"",no_argument,NULL,  3 },
{""log-console"",no_argument,NULL, 'l'},
{""log-detail"",no_argument,NULL, 'D'},
{""log-facility"",required_argument,NULL, 'S'},
{""log-file"",optional_argument,NULL, 'g'},
{""flush-log-file"",no_argument,NULL,  2 },
{""no-syslog"",no_argument,NULL, 'G'},
#ifdef _WITH_VRRP_
{""release-vips"",no_argument,NULL, 'X'},
{""dont-release-vrrp"",no_argument,NULL, 'V'},
#endif
#ifdef _WITH_LVS_
{""dont-release-ipvs"",no_argument,NULL, 'I'},
#endif
{""dont-respawn"",no_argument,NULL, 'R'},
{""dont-fork"",no_argument,NULL, 'n'},
{""dump-conf"",no_argument,NULL, 'd'},
{""pid"",required_argument,NULL, 'p'},
#ifdef _WITH_VRRP_
{""vrrp_pid"",required_argument,NULL, 'r'},
#endif
#ifdef _WITH_LVS_
{""checkers_pid"",required_argument,NULL, 'c'},
{""address-monitoring"",no_argument,NULL, 'a'},
#endif
#ifdef _WITH_BFD_
{""bfd_pid"",required_argument,NULL, 'b'},
#endif
#ifdef _WITH_SNMP_
{""snmp"",no_argument,NULL, 'x'},
{""snmp-agent-socket"",required_argument,NULL, 'A'},
#endif
{""core-dump"",no_argument,NULL, 'm'},
{""core-dump-pattern"",optional_argument,NULL, 'M'},
#ifdef _MEM_CHECK_LOG_
{""mem-check-log"",no_argument,NULL, 'L'},
#endif
#if HAVE_DECL_CLONE_NEWNET
{""namespace"",required_argument,NULL, 's'},
#endif
{""config-id"",required_argument,NULL, 'i'},
{""signum"",required_argument,NULL,  4 },
{""config-test"",optional_argument,NULL, 't'},
#ifdef _WITH_PERF_
{""perf"",optional_argument,NULL,  5 },
#endif
#ifdef WITH_DEBUG_OPTIONS
{""debug"",optional_argument,NULL,  6 },
#endif
{""version"",no_argument,NULL, 'v'},
{""help"",no_argument,NULL, 'h'},
{NULL,0,NULL,  0 }
};
curind = optind;
while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndDRS:f:p:i:mM::g::Gt::""
#if defined _WITH_VRRP_ && defined _WITH_LVS_
""PC""
#endif
#ifdef _WITH_VRRP_
""r:VX""
#endif
#ifdef _WITH_LVS_
""ac:I""
#endif
#ifdef _WITH_BFD_
""Bb:""
#endif
#ifdef _WITH_SNMP_
""xA:""
#endif
#ifdef _MEM_CHECK_LOG_
""L""
#endif
#if HAVE_DECL_CLONE_NEWNET
""s:""
#endif
, long_options, &longindex)) != -1) {
if (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {
c = ':';
optarg = NULL;
}
switch (c) {
case 'v':
fprintf(stderr, ""%s"", version_string);
#ifdef GIT_COMMIT
fprintf(stderr, "", git commit %s"", GIT_COMMIT);
#endif
fprintf(stderr, ""\n\n%s\n\n"", COPYRIGHT_STRING);
fprintf(stderr, ""Built with kernel headers for Linux %d.%d.%d\n"",
(LINUX_VERSION_CODE >> 16) & 0xff,
(LINUX_VERSION_CODE >>  8) & 0xff,
(LINUX_VERSION_CODE      ) & 0xff);
uname(&uname_buf);
fprintf(stderr, ""Running on %s %s %s\n\n"", uname_buf.sysname, uname_buf.release, uname_buf.version);
fprintf(stderr, ""configure options: %s\n\n"", KEEPALIVED_CONFIGURE_OPTIONS);
fprintf(stderr, ""Config options: %s\n\n"", CONFIGURATION_OPTIONS);
fprintf(stderr, ""System options: %s\n"", SYSTEM_OPTIONS);
exit(0);
break;
case 'h':
usage(argv[0]);
exit(0);
break;
case 'l':
__set_bit(LOG_CONSOLE_BIT, &debug);
reopen_log = true;
break;
case 'n':
__set_bit(DONT_FORK_BIT, &debug);
break;
case 'd':
__set_bit(DUMP_CONF_BIT, &debug);
break;
#ifdef _WITH_VRRP_
case 'V':
__set_bit(DONT_RELEASE_VRRP_BIT, &debug);
break;
#endif
#ifdef _WITH_LVS_
case 'I':
__set_bit(DONT_RELEASE_IPVS_BIT, &debug);
break;
#endif
case 'D':
if (__test_bit(LOG_DETAIL_BIT, &debug))
__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);
else
__set_bit(LOG_DETAIL_BIT, &debug);
break;
case 'R':
__set_bit(DONT_RESPAWN_BIT, &debug);
break;
#ifdef _WITH_VRRP_
case 'X':
__set_bit(RELEASE_VIPS_BIT, &debug);
break;
#endif
case 'S':
if (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))
fprintf(stderr, ""Invalid log facility '%s'\n"", optarg);
else {
log_facility = LOG_FACILITY[facility].facility;
reopen_log = true;
}
break;
case 'g':
if (optarg && optarg[0])
log_file_name = optarg;
else
log_file_name = ""/tmp/keepalived.log"";
open_log_file(log_file_name, NULL, NULL, NULL);
break;
case 'G':
__set_bit(NO_SYSLOG_BIT, &debug);
reopen_log = true;
break;
case 't':
__set_bit(CONFIG_TEST_BIT, &debug);
__set_bit(DONT_RESPAWN_BIT, &debug);
__set_bit(DONT_FORK_BIT, &debug);
__set_bit(NO_SYSLOG_BIT, &debug);
if (optarg && optarg[0]) {
int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
if (fd == -1) {
fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
exit(EXIT_FAILURE);
}
dup2(fd, STDERR_FILENO);
close(fd);
}
break;
case 'f':
conf_file = optarg;
break;
case 2:
set_flush_log_file();
break;
#if defined _WITH_VRRP_ && defined _WITH_LVS_
case 'P':
__clear_bit(DAEMON_CHECKERS, &daemon_mode);
break;
case 'C':
__clear_bit(DAEMON_VRRP, &daemon_mode);
break;
#endif
#ifdef _WITH_BFD_
case 'B':
__clear_bit(DAEMON_BFD, &daemon_mode);
break;
#endif
case 'p':
main_pidfile = optarg;
break;
#ifdef _WITH_LVS_
case 'c':
checkers_pidfile = optarg;
break;
case 'a':
__set_bit(LOG_ADDRESS_CHANGES, &debug);
break;
#endif
#ifdef _WITH_VRRP_
case 'r':
vrrp_pidfile = optarg;
break;
#endif
#ifdef _WITH_BFD_
case 'b':
bfd_pidfile = optarg;
break;
#endif
#ifdef _WITH_SNMP_
case 'x':
snmp = 1;
break;
case 'A':
snmp_socket = optarg;
break;
#endif
case 'M':
set_core_dump_pattern = true;
if (optarg && optarg[0])
core_dump_pattern = optarg;
case 'm':
create_core_dump = true;
break;
#ifdef _MEM_CHECK_LOG_
case 'L':
__set_bit(MEM_CHECK_LOG_BIT, &debug);
break;
#endif
#if HAVE_DECL_CLONE_NEWNET
case 's':
override_namespace = MALLOC(strlen(optarg) + 1);
strcpy(override_namespace, optarg);
break;
#endif
case 'i':
FREE_PTR(config_id);
config_id = MALLOC(strlen(optarg) + 1);
strcpy(config_id, optarg);
break;
case 4:
signum = get_signum(optarg);
if (signum == -1) {
fprintf(stderr, ""Unknown sigfunc %s\n"", optarg);
exit(1);
}
printf(""%d\n"", signum);
exit(0);
break;
case 3:
__set_bit(RUN_ALL_CHILDREN, &daemon_mode);
#ifdef _WITH_VRRP_
__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
__set_bit(DAEMON_BFD, &daemon_mode);
#endif
break;
#ifdef _WITH_PERF_
case 5:
if (optarg && optarg[0]) {
if (!strcmp(optarg, ""run""))
perf_run = PERF_RUN;
else if (!strcmp(optarg, ""all""))
perf_run = PERF_ALL;
else if (!strcmp(optarg, ""end""))
perf_run = PERF_END;
else
log_message(LOG_INFO, ""Unknown perf start point %s"", optarg);
}
else
perf_run = PERF_RUN;
break;
#endif
#ifdef WITH_DEBUG_OPTIONS
case 6:
set_debug_options(optarg && optarg[0] ? optarg : NULL);
break;
#endif
case '?':
if (optopt && argv[curind][1] != '-')
fprintf(stderr, ""Unknown option -%c\n"", optopt);
else
fprintf(stderr, ""Unknown option %s\n"", argv[curind]);
bad_option = true;
break;
case ':':
if (optopt && argv[curind][1] != '-')
fprintf(stderr, ""Missing parameter for option -%c\n"", optopt);
else
fprintf(stderr, ""Missing parameter for option --%s\n"", long_options[longindex].name);
bad_option = true;
break;
default:
exit(1);
break;
}
curind = optind;
}
if (optind < argc) {
printf(""Unexpected argument(s): "");
while (optind < argc)
printf(""%s "", argv[optind++]);
printf(""\n"");
}
if (bad_option)
exit(1);
return reopen_log;
}","static bool
parse_cmdline(int VAR_0, char **VAR_1)
{
int VAR_2;
bool VAR_3 = false;
int VAR_4;
struct utsname VAR_5;
int VAR_6;
int VAR_7;
bool VAR_8 = false;
unsigned VAR_9;
struct option VAR_10[] = {
{""use-file"",VAR_11,NULL, 'f'},
#if defined VAR_12 && VAR_13 VAR_14
{""vrrp"",VAR_15,NULL, 'P'},
{""check"",VAR_15,NULL, 'C'},
#endif
#ifdef VAR_16
{""no_bfd"",VAR_15,NULL, 'B'},
#endif
{""all"",VAR_15,NULL,  3 },
{""log-console"",VAR_15,NULL, 'l'},
{""log-detail"",VAR_15,NULL, 'D'},
{""log-facility"",VAR_11,NULL, 'S'},
{""log-file"",VAR_17,NULL, 'g'},
{""flush-log-file"",VAR_15,NULL,  2 },
{""no-syslog"",VAR_15,NULL, 'G'},
#ifdef VAR_12
{""release-vips"",VAR_15,NULL, 'X'},
{""dont-release-vrrp"",VAR_15,NULL, 'V'},
#endif
#ifdef VAR_14
{""dont-release-ipvs"",VAR_15,NULL, 'I'},
#endif
{""dont-respawn"",VAR_15,NULL, 'R'},
{""dont-fork"",VAR_15,NULL, 'n'},
{""dump-conf"",VAR_15,NULL, 'd'},
{""pid"",VAR_11,NULL, 'p'},
#ifdef VAR_12
{""vrrp_pid"",VAR_11,NULL, 'r'},
#endif
#ifdef VAR_14
{""checkers_pid"",VAR_11,NULL, 'c'},
{""address-monitoring"",VAR_15,NULL, 'a'},
#endif
#ifdef VAR_16
{""bfd_pid"",VAR_11,NULL, 'b'},
#endif
#ifdef VAR_18
{""snmp"",VAR_15,NULL, 'x'},
{""snmp-agent-socket"",VAR_11,NULL, 'A'},
#endif
{""core-dump"",VAR_15,NULL, 'm'},
{""core-dump-pattern"",VAR_17,NULL, 'M'},
#ifdef VAR_19
{""mem-check-log"",VAR_15,NULL, 'L'},
#endif
#if VAR_20
{""namespace"",VAR_11,NULL, 's'},
#endif
{""config-id"",VAR_11,NULL, 'i'},
{""signum"",VAR_11,NULL,  4 },
{""config-test"",VAR_17,NULL, 't'},
#ifdef VAR_21
{""perf"",VAR_17,NULL,  5 },
#endif
#ifdef VAR_22
{""debug"",VAR_17,NULL,  6 },
#endif
{""version"",VAR_15,NULL, 'v'},
{""help"",VAR_15,NULL, 'h'},
{NULL,0,NULL,  0 }
};
VAR_7 = VAR_23;
while (VAR_6 = -1, (VAR_2 = getopt_long(VAR_0, VAR_1, "":vhlndDRS:f:p:i:mM::g::Gt::""
#if defined VAR_12 && VAR_13 VAR_14
""PC""
#endif
#ifdef VAR_12
""r:VX""
#endif
#ifdef VAR_14
""ac:I""
#endif
#ifdef VAR_16
""Bb:""
#endif
#ifdef VAR_18
""xA:""
#endif
#ifdef VAR_19
""L""
#endif
#if VAR_20
""s:""
#endif
, VAR_10, &VAR_6)) != -1) {
if (VAR_6 >= 0 && VAR_10[VAR_6].has_arg == VAR_11 && VAR_24 && !VAR_24[0]) {
VAR_2 = ':';
VAR_24 = NULL;
}
switch (VAR_2) {
case 'v':
fprintf(VAR_25, ""%s"", VAR_26);
#ifdef VAR_27
fprintf(VAR_25, "", git commit %s"", VAR_27);
#endif
fprintf(VAR_25, ""\n\n%s\n\n"", VAR_28);
fprintf(VAR_25, ""Built with kernel headers for Linux %d.%d.%d\n"",
(VAR_29 >> 16) & 0xff,
(VAR_29 >>  8) & 0xff,
(VAR_29      ) & 0xff);
uname(&VAR_5);
fprintf(VAR_25, ""Running on %s %s %s\n\n"", VAR_5.sysname, VAR_5.release, VAR_5.version);
fprintf(VAR_25, ""configure options: %s\n\n"", VAR_30);
fprintf(VAR_25, ""Config options: %s\n\n"", VAR_31);
fprintf(VAR_25, ""System options: %s\n"", VAR_32);
exit(0);
break;
case 'h':
usage(VAR_1[0]);
exit(0);
break;
case 'l':
__set_bit(VAR_33, &VAR_34);
VAR_3 = true;
break;
case 'n':
__set_bit(VAR_35, &VAR_34);
break;
case 'd':
__set_bit(VAR_36, &VAR_34);
break;
#ifdef VAR_12
case 'V':
__set_bit(VAR_37, &VAR_34);
break;
#endif
#ifdef VAR_14
case 'I':
__set_bit(VAR_38, &VAR_34);
break;
#endif
case 'D':
if (__test_bit(VAR_39, &VAR_34))
__set_bit(VAR_40, &VAR_34);
else
__set_bit(VAR_39, &VAR_34);
break;
case 'R':
__set_bit(VAR_41, &VAR_34);
break;
#ifdef VAR_12
case 'X':
__set_bit(VAR_42, &VAR_34);
break;
#endif
case 'S':
if (!read_unsigned(VAR_24, &VAR_9, 0, VAR_43, false))
fprintf(VAR_25, ""Invalid log facility '%s'\n"", VAR_24);
else {
VAR_44 = VAR_45[VAR_9].facility;
VAR_3 = true;
}
break;
case 'g':
if (VAR_24 && VAR_24[0])
VAR_46 = VAR_24;
else
VAR_46 = ""/tmp/keepalived.log"";
open_log_file(VAR_46, NULL, NULL, NULL);
break;
case 'G':
__set_bit(VAR_47, &VAR_34);
VAR_3 = true;
break;
case 't':
__set_bit(VAR_48, &VAR_34);
__set_bit(VAR_41, &VAR_34);
__set_bit(VAR_35, &VAR_34);
__set_bit(VAR_47, &VAR_34);
if (VAR_24 && VAR_24[0]) {
int VAR_49 = open(VAR_24, VAR_50 | VAR_51 | VAR_52, VAR_53 | VAR_54 | VAR_55 | VAR_56);
if (VAR_49 == -1) {
fprintf(VAR_25, ""Unable to open config-test log file %s\n"", VAR_24);
exit(VAR_57);
}
dup2(VAR_49, VAR_58);
close(VAR_49);
}
break;
case 'f':
VAR_59 = VAR_24;
break;
case 2:
set_flush_log_file();
break;
#if defined VAR_12 && defined VAR_14
case 'P':
__clear_bit(VAR_60, &VAR_61);
break;
case 'C':
__clear_bit(VAR_62, &VAR_61);
break;
#endif
#ifdef VAR_16
case 'B':
__clear_bit(VAR_63, &VAR_61);
break;
#endif
case 'p':
VAR_64 = VAR_24;
break;
#ifdef VAR_14
case 'c':
VAR_65 = VAR_24;
break;
case 'a':
__set_bit(VAR_66, &VAR_34);
break;
#endif
#ifdef VAR_12
case 'r':
VAR_67 = VAR_24;
break;
#endif
#ifdef VAR_16
case 'b':
VAR_68 = VAR_24;
break;
#endif
#ifdef VAR_18
case 'x':
VAR_69 = 1;
break;
case 'A':
VAR_70 = VAR_24;
break;
#endif
case 'M':
VAR_71 = true;
if (VAR_24 && VAR_24[0])
VAR_72 = VAR_24;
case 'm':
VAR_73 = true;
break;
#ifdef VAR_19
case 'L':
__set_bit(VAR_74, &VAR_34);
break;
#endif
#if VAR_20
case 's':
VAR_75 = MALLOC(strlen(VAR_24) + 1);
strcpy(VAR_75, VAR_24);
break;
#endif
case 'i':
FREE_PTR(VAR_76);
VAR_76 = MALLOC(strlen(VAR_24) + 1);
strcpy(VAR_76, VAR_24);
break;
case 4:
VAR_4 = get_signum(VAR_24);
if (VAR_4 == -1) {
fprintf(VAR_25, ""Unknown sigfunc %s\n"", VAR_24);
exit(1);
}
printf(""%d\n"", VAR_4);
exit(0);
break;
case 3:
__set_bit(VAR_77, &VAR_61);
#ifdef VAR_12
__set_bit(VAR_62, &VAR_61);
#endif
#ifdef VAR_14
__set_bit(VAR_60, &VAR_61);
#endif
#ifdef VAR_16
__set_bit(VAR_63, &VAR_61);
#endif
break;
#ifdef VAR_21
case 5:
if (VAR_24 && VAR_24[0]) {
if (!strcmp(VAR_24, ""run""))
VAR_78 = VAR_79;
else if (!strcmp(VAR_24, ""all""))
VAR_78 = VAR_80;
else if (!strcmp(VAR_24, ""end""))
VAR_78 = VAR_81;
else
log_message(VAR_82, ""Unknown perf start point %s"", VAR_24);
}
else
VAR_78 = VAR_79;
break;
#endif
#ifdef VAR_22
case 6:
set_debug_options(VAR_24 && VAR_24[0] ? VAR_24 : NULL);
break;
#endif
case '?':
if (VAR_83 && VAR_1[VAR_7][1] != '-')
fprintf(VAR_25, ""Unknown option -%c\n"", VAR_83);
else
fprintf(VAR_25, ""Unknown option %s\n"", VAR_1[VAR_7]);
VAR_8 = true;
break;
case ':':
if (VAR_83 && VAR_1[VAR_7][1] != '-')
fprintf(VAR_25, ""Missing parameter for option -%c\n"", VAR_83);
else
fprintf(VAR_25, ""Missing parameter for option --%s\n"", VAR_10[VAR_6].name);
VAR_8 = true;
break;
default:
exit(1);
break;
}
VAR_7 = VAR_23;
}
if (VAR_23 < VAR_0) {
printf(""Unexpected argument(s): "");
while (VAR_23 < VAR_0)
printf(""%s "", VAR_1[VAR_23++]);
printf(""\n"");
}
if (VAR_8)
exit(1);
return VAR_3;
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/main.c/vul/before/0.json,"static bool
parse_cmdline(int argc, char **argv)
{
	int c;
	bool reopen_log = false;
	int signum;
	struct utsname uname_buf;
	int longindex;
	int curind;
	bool bad_option = false;
	unsigned facility;
	mode_t new_umask_val;

	struct option long_options[] = {
		{""use-file"",		required_argument,	NULL, 'f'},
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		{""vrrp"",		no_argument,		NULL, 'P'},
		{""check"",		no_argument,		NULL, 'C'},
#endif
#ifdef _WITH_BFD_
		{""no_bfd"",		no_argument,		NULL, 'B'},
#endif
		{""all"",			no_argument,		NULL,  3 },
		{""log-console"",		no_argument,		NULL, 'l'},
		{""log-detail"",		no_argument,		NULL, 'D'},
		{""log-facility"",	required_argument,	NULL, 'S'},
		{""log-file"",		optional_argument,	NULL, 'g'},
		{""flush-log-file"",	no_argument,		NULL,  2 },
		{""no-syslog"",		no_argument,		NULL, 'G'},
		{""umask"",		required_argument,	NULL, 'u'},
#ifdef _WITH_VRRP_
		{""release-vips"",	no_argument,		NULL, 'X'},
		{""dont-release-vrrp"",	no_argument,		NULL, 'V'},
#endif
#ifdef _WITH_LVS_
		{""dont-release-ipvs"",	no_argument,		NULL, 'I'},
#endif
		{""dont-respawn"",	no_argument,		NULL, 'R'},
		{""dont-fork"",		no_argument,		NULL, 'n'},
		{""dump-conf"",		no_argument,		NULL, 'd'},
		{""pid"",			required_argument,	NULL, 'p'},
#ifdef _WITH_VRRP_
		{""vrrp_pid"",		required_argument,	NULL, 'r'},
#endif
#ifdef _WITH_LVS_
		{""checkers_pid"",	required_argument,	NULL, 'c'},
		{""address-monitoring"",	no_argument,		NULL, 'a'},
#endif
#ifdef _WITH_BFD_
		{""bfd_pid"",		required_argument,	NULL, 'b'},
#endif
#ifdef _WITH_SNMP_
		{""snmp"",		no_argument,		NULL, 'x'},
		{""snmp-agent-socket"",	required_argument,	NULL, 'A'},
#endif
		{""core-dump"",		no_argument,		NULL, 'm'},
		{""core-dump-pattern"",	optional_argument,	NULL, 'M'},
#ifdef _MEM_CHECK_LOG_
		{""mem-check-log"",	no_argument,		NULL, 'L'},
#endif
#if HAVE_DECL_CLONE_NEWNET
		{""namespace"",		required_argument,	NULL, 's'},
#endif
		{""config-id"",		required_argument,	NULL, 'i'},
		{""signum"",		required_argument,	NULL,  4 },
		{""config-test"",		optional_argument,	NULL, 't'},
#ifdef _WITH_PERF_
		{""perf"",		optional_argument,	NULL,  5 },
#endif
#ifdef WITH_DEBUG_OPTIONS
		{""debug"",		optional_argument,	NULL,  6 },
#endif
		{""version"",		no_argument,		NULL, 'v'},
		{""help"",		no_argument,		NULL, 'h'},

		{NULL,			0,			NULL,  0 }
	};

	/* Unfortunately, if a short option is used, getopt_long() doesn't change the value
	 * of longindex, so we need to ensure that before calling getopt_long(), longindex
	 * is set to a known invalid value */
	curind = optind;
	while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndu:DRS:f:p:i:mM::g::Gt::""
#if defined _WITH_VRRP_ && defined _WITH_LVS_
					    ""PC""
#endif
#ifdef _WITH_VRRP_
					    ""r:VX""
#endif
#ifdef _WITH_LVS_
					    ""ac:I""
#endif
#ifdef _WITH_BFD_
					    ""Bb:""
#endif
#ifdef _WITH_SNMP_
					    ""xA:""
#endif
#ifdef _MEM_CHECK_LOG_
					    ""L""
#endif
#if HAVE_DECL_CLONE_NEWNET
					    ""s:""
#endif
				, long_options, &longindex)) != -1) {

		/* Check for an empty option argument. For example --use-file= returns
		 * a 0 length option, which we don't want */
		if (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {
			c = ':';
			optarg = NULL;
		}

		switch (c) {
		case 'v':
			fprintf(stderr, ""%s"", version_string);
#ifdef GIT_COMMIT
			fprintf(stderr, "", git commit %s"", GIT_COMMIT);
#endif
			fprintf(stderr, ""\n\n%s\n\n"", COPYRIGHT_STRING);
			fprintf(stderr, ""Built with kernel headers for Linux %d.%d.%d\n"",
						(LINUX_VERSION_CODE >> 16) & 0xff,
						(LINUX_VERSION_CODE >>  8) & 0xff,
						(LINUX_VERSION_CODE      ) & 0xff);
			uname(&uname_buf);
			fprintf(stderr, ""Running on %s %s %s\n\n"", uname_buf.sysname, uname_buf.release, uname_buf.version);
			fprintf(stderr, ""configure options: %s\n\n"", KEEPALIVED_CONFIGURE_OPTIONS);
			fprintf(stderr, ""Config options: %s\n\n"", CONFIGURATION_OPTIONS);
			fprintf(stderr, ""System options: %s\n"", SYSTEM_OPTIONS);
			exit(0);
			break;
		case 'h':
			usage(argv[0]);
			exit(0);
			break;
		case 'l':
			__set_bit(LOG_CONSOLE_BIT, &debug);
			reopen_log = true;
			break;
		case 'n':
			__set_bit(DONT_FORK_BIT, &debug);
			break;
		case 'd':
			__set_bit(DUMP_CONF_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'V':
			__set_bit(DONT_RELEASE_VRRP_BIT, &debug);
			break;
#endif
#ifdef _WITH_LVS_
		case 'I':
			__set_bit(DONT_RELEASE_IPVS_BIT, &debug);
			break;
#endif
		case 'D':
			if (__test_bit(LOG_DETAIL_BIT, &debug))
				__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);
			else
				__set_bit(LOG_DETAIL_BIT, &debug);
			break;
		case 'R':
			__set_bit(DONT_RESPAWN_BIT, &debug);
			break;
#ifdef _WITH_VRRP_
		case 'X':
			__set_bit(RELEASE_VIPS_BIT, &debug);
			break;
#endif
		case 'S':
			if (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))
				fprintf(stderr, ""Invalid log facility '%s'\n"", optarg);
			else {
				log_facility = LOG_FACILITY[facility].facility;
				reopen_log = true;
			}
			break;
		case 'g':
			if (optarg && optarg[0])
				log_file_name = optarg;
			else
				log_file_name = ""/tmp/keepalived.log"";
			open_log_file(log_file_name, NULL, NULL, NULL);
			break;
		case 'G':
			__set_bit(NO_SYSLOG_BIT, &debug);
			reopen_log = true;
			break;
		case 'u':
			new_umask_val = set_umask(optarg);
			if (umask_cmdline)
				umask_val = new_umask_val;
			break;
		case 't':
			__set_bit(CONFIG_TEST_BIT, &debug);
			__set_bit(DONT_RESPAWN_BIT, &debug);
			__set_bit(DONT_FORK_BIT, &debug);
			__set_bit(NO_SYSLOG_BIT, &debug);
			if (optarg && optarg[0]) {
				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
				if (fd == -1) {
					fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
					exit(EXIT_FAILURE);
				}
				dup2(fd, STDERR_FILENO);
				close(fd);
			}
			break;
		case 'f':
			conf_file = optarg;
			break;
		case 2:		/* --flush-log-file */
			set_flush_log_file();
			break;
#if defined _WITH_VRRP_ && defined _WITH_LVS_
		case 'P':
			__clear_bit(DAEMON_CHECKERS, &daemon_mode);
			break;
		case 'C':
			__clear_bit(DAEMON_VRRP, &daemon_mode);
			break;
#endif
#ifdef _WITH_BFD_
		case 'B':
			__clear_bit(DAEMON_BFD, &daemon_mode);
			break;
#endif
		case 'p':
			main_pidfile = optarg;
			break;
#ifdef _WITH_LVS_
		case 'c':
			checkers_pidfile = optarg;
			break;
		case 'a':
			__set_bit(LOG_ADDRESS_CHANGES, &debug);
			break;
#endif
#ifdef _WITH_VRRP_
		case 'r':
			vrrp_pidfile = optarg;
			break;
#endif
#ifdef _WITH_BFD_
		case 'b':
			bfd_pidfile = optarg;
			break;
#endif
#ifdef _WITH_SNMP_
		case 'x':
			snmp = 1;
			break;
		case 'A':
			snmp_socket = optarg;
			break;
#endif
		case 'M':
			set_core_dump_pattern = true;
			if (optarg && optarg[0])
				core_dump_pattern = optarg;
			/* ... falls through ... */
		case 'm':
			create_core_dump = true;
			break;
#ifdef _MEM_CHECK_LOG_
		case 'L':
			__set_bit(MEM_CHECK_LOG_BIT, &debug);
			break;
#endif
#if HAVE_DECL_CLONE_NEWNET
		case 's':
			override_namespace = MALLOC(strlen(optarg) + 1);
			strcpy(override_namespace, optarg);
			break;
#endif
		case 'i':
			FREE_PTR(config_id);
			config_id = MALLOC(strlen(optarg) + 1);
			strcpy(config_id, optarg);
			break;
		case 4:			/* --signum */
			signum = get_signum(optarg);
			if (signum == -1) {
				fprintf(stderr, ""Unknown sigfunc %s\n"", optarg);
				exit(1);
			}

			printf(""%d\n"", signum);
			exit(0);
			break;
		case 3:			/* --all */
			__set_bit(RUN_ALL_CHILDREN, &daemon_mode);
#ifdef _WITH_VRRP_
			__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
			__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
			__set_bit(DAEMON_BFD, &daemon_mode);
#endif
			break;
#ifdef _WITH_PERF_
		case 5:
			if (optarg && optarg[0]) {
				if (!strcmp(optarg, ""run""))
					perf_run = PERF_RUN;
				else if (!strcmp(optarg, ""all""))
					perf_run = PERF_ALL;
				else if (!strcmp(optarg, ""end""))
					perf_run = PERF_END;
				else
					log_message(LOG_INFO, ""Unknown perf start point %s"", optarg);
			}
			else
				perf_run = PERF_RUN;

			break;
#endif
#ifdef WITH_DEBUG_OPTIONS
		case 6:
			set_debug_options(optarg && optarg[0] ? optarg : NULL);
			break;
#endif
		case '?':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Unknown option -%c\n"", optopt);
			else
				fprintf(stderr, ""Unknown option %s\n"", argv[curind]);
			bad_option = true;
			break;
		case ':':
			if (optopt && argv[curind][1] != '-')
				fprintf(stderr, ""Missing parameter for option -%c\n"", optopt);
			else
				fprintf(stderr, ""Missing parameter for option --%s\n"", long_options[longindex].name);
			bad_option = true;
			break;
		default:
			exit(1);
			break;
		}
		curind = optind;
	}

	if (optind < argc) {
		printf(""Unexpected argument(s): "");
		while (optind < argc)
			printf(""%s "", argv[optind++]);
		printf(""\n"");
	}

	if (bad_option)
		exit(1);

	return reopen_log;
}","static bool
parse_cmdline(int VAR_0, char **VAR_1)
{
	int VAR_2;
	bool VAR_3 = false;
	int VAR_4;
	struct utsname VAR_5;
	int VAR_6;
	int VAR_7;
	bool VAR_8 = false;
	unsigned VAR_9;
	mode_t VAR_10;

	struct option VAR_11[] = {
		{""use-file"",		VAR_12,	NULL, 'f'},
#if defined VAR_13 && VAR_14 VAR_15
		{""vrrp"",		VAR_16,		NULL, 'P'},
		{""check"",		VAR_16,		NULL, 'C'},
#endif
#ifdef VAR_17
		{""no_bfd"",		VAR_16,		NULL, 'B'},
#endif
		{""all"",			VAR_16,		NULL,  3 },
		{""log-console"",		VAR_16,		NULL, 'l'},
		{""log-detail"",		VAR_16,		NULL, 'D'},
		{""log-facility"",	VAR_12,	NULL, 'S'},
		{""log-file"",		VAR_18,	NULL, 'g'},
		{""flush-log-file"",	VAR_16,		NULL,  2 },
		{""no-syslog"",		VAR_16,		NULL, 'G'},
		{""umask"",		VAR_12,	NULL, 'u'},
#ifdef VAR_13
		{""release-vips"",	VAR_16,		NULL, 'X'},
		{""dont-release-vrrp"",	VAR_16,		NULL, 'V'},
#endif
#ifdef VAR_15
		{""dont-release-ipvs"",	VAR_16,		NULL, 'I'},
#endif
		{""dont-respawn"",	VAR_16,		NULL, 'R'},
		{""dont-fork"",		VAR_16,		NULL, 'n'},
		{""dump-conf"",		VAR_16,		NULL, 'd'},
		{""pid"",			VAR_12,	NULL, 'p'},
#ifdef VAR_13
		{""vrrp_pid"",		VAR_12,	NULL, 'r'},
#endif
#ifdef VAR_15
		{""checkers_pid"",	VAR_12,	NULL, 'c'},
		{""address-monitoring"",	VAR_16,		NULL, 'a'},
#endif
#ifdef VAR_17
		{""bfd_pid"",		VAR_12,	NULL, 'b'},
#endif
#ifdef VAR_19
		{""snmp"",		VAR_16,		NULL, 'x'},
		{""snmp-agent-socket"",	VAR_12,	NULL, 'A'},
#endif
		{""core-dump"",		VAR_16,		NULL, 'm'},
		{""core-dump-pattern"",	VAR_18,	NULL, 'M'},
#ifdef VAR_20
		{""mem-check-log"",	VAR_16,		NULL, 'L'},
#endif
#if VAR_21
		{""namespace"",		VAR_12,	NULL, 's'},
#endif
		{""config-id"",		VAR_12,	NULL, 'i'},
		{""signum"",		VAR_12,	NULL,  4 },
		{""config-test"",		VAR_18,	NULL, 't'},
#ifdef VAR_22
		{""perf"",		VAR_18,	NULL,  5 },
#endif
#ifdef VAR_23
		{""debug"",		VAR_18,	NULL,  6 },
#endif
		{""version"",		VAR_16,		NULL, 'v'},
		{""help"",		VAR_16,		NULL, 'h'},

		{NULL,			0,			NULL,  0 }
	};

	/* COMMENT_0 */
                                                                                   
                                      
	VAR_7 = VAR_24;
	while (VAR_6 = -1, (VAR_2 = getopt_long(VAR_0, VAR_1, "":vhlndu:DRS:f:p:i:mM::g::Gt::""
#if defined VAR_13 && VAR_14 VAR_15
					    ""PC""
#endif
#ifdef VAR_13
					    ""r:VX""
#endif
#ifdef VAR_15
					    ""ac:I""
#endif
#ifdef VAR_17
					    ""Bb:""
#endif
#ifdef VAR_19
					    ""xA:""
#endif
#ifdef VAR_20
					    ""L""
#endif
#if VAR_21
					    ""s:""
#endif
				, VAR_11, &VAR_6)) != -1) {

		/* COMMENT_3 */
                                              
		if (VAR_6 >= 0 && VAR_11[VAR_6].has_arg == VAR_12 && VAR_25 && !VAR_25[0]) {
			VAR_2 = ':';
			VAR_25 = NULL;
		}

		switch (VAR_2) {
		case 'v':
			fprintf(VAR_26, ""%s"", VAR_27);
#ifdef VAR_28
			fprintf(VAR_26, "", git commit %s"", VAR_28);
#endif
			fprintf(VAR_26, ""\n\n%s\n\n"", VAR_29);
			fprintf(VAR_26, ""Built with kernel headers for Linux %d.%d.%d\n"",
						(VAR_30 >> 16) & 0xff,
						(VAR_30 >>  8) & 0xff,
						(VAR_30      ) & 0xff);
			uname(&VAR_5);
			fprintf(VAR_26, ""Running on %s %s %s\n\n"", VAR_5.sysname, VAR_5.release, VAR_5.version);
			fprintf(VAR_26, ""configure options: %s\n\n"", VAR_31);
			fprintf(VAR_26, ""Config options: %s\n\n"", VAR_32);
			fprintf(VAR_26, ""System options: %s\n"", VAR_33);
			exit(0);
			break;
		case 'h':
			usage(VAR_1[0]);
			exit(0);
			break;
		case 'l':
			__set_bit(VAR_34, &VAR_35);
			VAR_3 = true;
			break;
		case 'n':
			__set_bit(VAR_36, &VAR_35);
			break;
		case 'd':
			__set_bit(VAR_37, &VAR_35);
			break;
#ifdef VAR_13
		case 'V':
			__set_bit(VAR_38, &VAR_35);
			break;
#endif
#ifdef VAR_15
		case 'I':
			__set_bit(VAR_39, &VAR_35);
			break;
#endif
		case 'D':
			if (__test_bit(VAR_40, &VAR_35))
				__set_bit(VAR_41, &VAR_35);
			else
				__set_bit(VAR_40, &VAR_35);
			break;
		case 'R':
			__set_bit(VAR_42, &VAR_35);
			break;
#ifdef VAR_13
		case 'X':
			__set_bit(VAR_43, &VAR_35);
			break;
#endif
		case 'S':
			if (!read_unsigned(VAR_25, &VAR_9, 0, VAR_44, false))
				fprintf(VAR_26, ""Invalid log facility '%s'\n"", VAR_25);
			else {
				VAR_45 = VAR_46[VAR_9].facility;
				VAR_3 = true;
			}
			break;
		case 'g':
			if (VAR_25 && VAR_25[0])
				VAR_47 = VAR_25;
			else
				VAR_47 = ""/tmp/keepalived.log"";
			open_log_file(VAR_47, NULL, NULL, NULL);
			break;
		case 'G':
			__set_bit(VAR_48, &VAR_35);
			VAR_3 = true;
			break;
		case 'u':
			VAR_10 = set_umask(VAR_25);
			if (VAR_49)
				VAR_50 = VAR_10;
			break;
		case 't':
			__set_bit(VAR_51, &VAR_35);
			__set_bit(VAR_42, &VAR_35);
			__set_bit(VAR_36, &VAR_35);
			__set_bit(VAR_48, &VAR_35);
			if (VAR_25 && VAR_25[0]) {
				int VAR_52 = open(VAR_25, VAR_53 | VAR_54 | VAR_55, VAR_56 | VAR_57 | VAR_58 | VAR_59);
				if (VAR_52 == -1) {
					fprintf(VAR_26, ""Unable to open config-test log file %s\n"", VAR_25);
					exit(VAR_60);
				}
				dup2(VAR_52, VAR_61);
				close(VAR_52);
			}
			break;
		case 'f':
			VAR_62 = VAR_25;
			break;
		case 2:		/* COMMENT_5 */
			set_flush_log_file();
			break;
#if defined VAR_13 && defined VAR_15
		case 'P':
			__clear_bit(VAR_63, &VAR_64);
			break;
		case 'C':
			__clear_bit(VAR_65, &VAR_64);
			break;
#endif
#ifdef VAR_17
		case 'B':
			__clear_bit(VAR_66, &VAR_64);
			break;
#endif
		case 'p':
			VAR_67 = VAR_25;
			break;
#ifdef VAR_15
		case 'c':
			VAR_68 = VAR_25;
			break;
		case 'a':
			__set_bit(VAR_69, &VAR_35);
			break;
#endif
#ifdef VAR_13
		case 'r':
			VAR_70 = VAR_25;
			break;
#endif
#ifdef VAR_17
		case 'b':
			VAR_71 = VAR_25;
			break;
#endif
#ifdef VAR_19
		case 'x':
			VAR_72 = 1;
			break;
		case 'A':
			VAR_73 = VAR_25;
			break;
#endif
		case 'M':
			VAR_74 = true;
			if (VAR_25 && VAR_25[0])
				VAR_75 = VAR_25;
			/* COMMENT_6 */
		case 'm':
			VAR_76 = true;
			break;
#ifdef VAR_20
		case 'L':
			__set_bit(VAR_77, &VAR_35);
			break;
#endif
#if VAR_21
		case 's':
			VAR_78 = MALLOC(strlen(VAR_25) + 1);
			strcpy(VAR_78, VAR_25);
			break;
#endif
		case 'i':
			FREE_PTR(VAR_79);
			VAR_79 = MALLOC(strlen(VAR_25) + 1);
			strcpy(VAR_79, VAR_25);
			break;
		case 4:			/* COMMENT_7 */
			VAR_4 = get_signum(VAR_25);
			if (VAR_4 == -1) {
				fprintf(VAR_26, ""Unknown sigfunc %s\n"", VAR_25);
				exit(1);
			}

			printf(""%d\n"", VAR_4);
			exit(0);
			break;
		case 3:			/* COMMENT_8 */
			__set_bit(VAR_80, &VAR_64);
#ifdef VAR_13
			__set_bit(VAR_65, &VAR_64);
#endif
#ifdef VAR_15
			__set_bit(VAR_63, &VAR_64);
#endif
#ifdef VAR_17
			__set_bit(VAR_66, &VAR_64);
#endif
			break;
#ifdef VAR_22
		case 5:
			if (VAR_25 && VAR_25[0]) {
				if (!strcmp(VAR_25, ""run""))
					VAR_81 = VAR_82;
				else if (!strcmp(VAR_25, ""all""))
					VAR_81 = VAR_83;
				else if (!strcmp(VAR_25, ""end""))
					VAR_81 = VAR_84;
				else
					log_message(VAR_85, ""Unknown perf start point %s"", VAR_25);
			}
			else
				VAR_81 = VAR_82;

			break;
#endif
#ifdef VAR_23
		case 6:
			set_debug_options(VAR_25 && VAR_25[0] ? VAR_25 : NULL);
			break;
#endif
		case '?':
			if (VAR_86 && VAR_1[VAR_7][1] != '-')
				fprintf(VAR_26, ""Unknown option -%c\n"", VAR_86);
			else
				fprintf(VAR_26, ""Unknown option %s\n"", VAR_1[VAR_7]);
			VAR_8 = true;
			break;
		case ':':
			if (VAR_86 && VAR_1[VAR_7][1] != '-')
				fprintf(VAR_26, ""Missing parameter for option -%c\n"", VAR_86);
			else
				fprintf(VAR_26, ""Missing parameter for option --%s\n"", VAR_11[VAR_6].name);
			VAR_8 = true;
			break;
		default:
			exit(1);
			break;
		}
		VAR_7 = VAR_24;
	}

	if (VAR_24 < VAR_0) {
		printf(""Unexpected argument(s): "");
		while (VAR_24 < VAR_0)
			printf(""%s "", VAR_1[VAR_24++]);
		printf(""\n"");
	}

	if (VAR_8)
		exit(1);

	return VAR_3;
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,7 @@
 	int curind;
 	bool bad_option = false;
 	unsigned facility;
+	mode_t new_umask_val;
 
 	struct option long_options[] = {
 		{""use-file"",		required_argument,	NULL, 'f'},
@@ -26,6 +27,7 @@
 		{""log-file"",		optional_argument,	NULL, 'g'},
 		{""flush-log-file"",	no_argument,		NULL,  2 },
 		{""no-syslog"",		no_argument,		NULL, 'G'},
+		{""umask"",		required_argument,	NULL, 'u'},
 #ifdef _WITH_VRRP_
 		{""release-vips"",	no_argument,		NULL, 'X'},
 		{""dont-release-vrrp"",	no_argument,		NULL, 'V'},
@@ -78,7 +80,7 @@
 	 * of longindex, so we need to ensure that before calling getopt_long(), longindex
 	 * is set to a known invalid value */
 	curind = optind;
-	while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndDRS:f:p:i:mM::g::Gt::""
+	while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndu:DRS:f:p:i:mM::g::Gt::""
 #if defined _WITH_VRRP_ && defined _WITH_LVS_
 					    ""PC""
 #endif
@@ -183,6 +185,11 @@
 		case 'G':
 			__set_bit(NO_SYSLOG_BIT, &debug);
 			reopen_log = true;
+			break;
+		case 'u':
+			new_umask_val = set_umask(optarg);
+			if (umask_cmdline)
+				umask_val = new_umask_val;
 			break;
 		case 't':
 			__set_bit(CONFIG_TEST_BIT, &debug);","{'deleted_lines': ['\twhile (longindex = -1, (c = getopt_long(argc, argv, "":vhlndDRS:f:p:i:mM::g::Gt::""'], 'added_lines': ['\tmode_t new_umask_val;', '\t\t{""umask"",\t\trequired_argument,\tNULL, \'u\'},', '\twhile (longindex = -1, (c = getopt_long(argc, argv, "":vhlndu:DRS:f:p:i:mM::g::Gt::""', '\t\t\tbreak;', ""\t\tcase 'u':"", '\t\t\tnew_umask_val = set_umask(optarg);', '\t\t\tif (umask_cmdline)', '\t\t\t\tumask_val = new_umask_val;']}",True,"keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information.",7.5,HIGH,2,test,2018-10-31T17:08:51Z,2
CVE-2018-19045,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,acassen/keepalived,"Add command line and configuration option to set umask

Issue #1048 identified that files created by keepalived are created
with mode 0666. This commit changes the default to 0644, and also
allows the umask to be specified in the configuration or as a command
line option.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,keepalived/core/main.c,usage,"static void
usage(const char *prog)
{
fprintf(stderr, ""Usage: %s [OPTION...]\n"", prog);
fprintf(stderr, ""  -f, --use-file=FILE          Use the specified configuration file\n"");
#if defined _WITH_VRRP_ && defined _WITH_LVS_
fprintf(stderr, ""  -P, --vrrp                   Only run with VRRP subsystem\n"");
fprintf(stderr, ""  -C, --check                  Only run with Health-checker subsystem\n"");
#endif
#ifdef _WITH_BFD_
fprintf(stderr, ""  -B, --no_bfd                 Don't run BFD subsystem\n"");
#endif
fprintf(stderr, ""      --all                    Force all child processes to run, even if have no configuration\n"");
fprintf(stderr, ""  -l, --log-console            Log messages to local console\n"");
fprintf(stderr, ""  -D, --log-detail             Detailed log messages\n"");
fprintf(stderr, ""  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\n"");
fprintf(stderr, ""  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\n"");
fprintf(stderr, ""      --flush-log-file         Flush log file on write\n"");
fprintf(stderr, ""  -G, --no-syslog              Don't log via syslog\n"");
#ifdef _WITH_VRRP_
fprintf(stderr, ""  -X, --release-vips           Drop VIP on transition from signal.\n"");
fprintf(stderr, ""  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\n"");
#endif
#ifdef _WITH_LVS_
fprintf(stderr, ""  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\n"");
#endif
fprintf(stderr, ""  -R, --dont-respawn           Don't respawn child processes\n"");
fprintf(stderr, ""  -n, --dont-fork              Don't fork the daemon process\n"");
fprintf(stderr, ""  -d, --dump-conf              Dump the configuration data\n"");
fprintf(stderr, ""  -p, --pid=FILE               Use specified pidfile for parent process\n"");
#ifdef _WITH_VRRP_
fprintf(stderr, ""  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\n"");
#endif
#ifdef _WITH_LVS_
fprintf(stderr, ""  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\n"");
fprintf(stderr, ""  -a, --address-monitoring     Report all address additions/deletions notified via netlink\n"");
#endif
#ifdef _WITH_BFD_
fprintf(stderr, ""  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\n"");
#endif
#ifdef _WITH_SNMP_
fprintf(stderr, ""  -x, --snmp                   Enable SNMP subsystem\n"");
fprintf(stderr, ""  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\n"");
#endif
#if HAVE_DECL_CLONE_NEWNET
fprintf(stderr, ""  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\n"");
#endif
fprintf(stderr, ""  -m, --core-dump              Produce core dump if terminate abnormally\n"");
fprintf(stderr, ""  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\n"");
#ifdef _MEM_CHECK_LOG_
fprintf(stderr, ""  -L, --mem-check-log          Log malloc/frees to syslog\n"");
#endif
fprintf(stderr, ""  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\n""
""                                or any lines beginning @^ that do match.\n""
""                                The config-id defaults to the node name if option not used\n"");
fprintf(stderr, ""      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS""
#ifdef _WITH_JSON_
"", JSON""
#endif
""\n"");
fprintf(stderr, ""  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\n""
""                                stderr by default\n"");
#ifdef _WITH_PERF_
fprintf(stderr, ""      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\n"");
#endif
#ifdef WITH_DEBUG_OPTIONS
fprintf(stderr, ""      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\n"");
#ifdef _TIMER_CHECK_
fprintf(stderr, ""                                   T - timer debug\n"");
#endif
#ifdef _SMTP_ALERT_DEBUG_
fprintf(stderr, ""                                   M - email alert debug\n"");
#endif
#ifdef _EPOLL_DEBUG_
fprintf(stderr, ""                                   E - epoll debug\n"");
#endif
#ifdef _EPOLL_THREAD_DUMP_
fprintf(stderr, ""                                   D - epoll thread dump debug\n"");
#endif
#ifdef _VRRP_FD_DEBUG
fprintf(stderr, ""                                   F - vrrp fd dump debug\n"");
#endif
#ifdef _REGEX_DEBUG_
fprintf(stderr, ""                                   R - regex debug\n"");
#endif
#ifdef _WITH_REGEX_TIMERS_
fprintf(stderr, ""                                   X - regex timers\n"");
#endif
#ifdef _TSM_DEBUG_
fprintf(stderr, ""                                   S - TSM debug\n"");
#endif
#ifdef _NETLINK_TIMERS_
fprintf(stderr, ""                                   N - netlink timer debug\n"");
#endif
fprintf(stderr, ""                                 Example --debug=TpMEvcp\n"");
#endif
fprintf(stderr, ""  -v, --version                Display the version number\n"");
fprintf(stderr, ""  -h, --help                   Display this help message\n"");
}","static void
usage(const char *VAR_0)
{
fprintf(VAR_1, ""Usage: %s [OPTION...]\n"", VAR_0);
fprintf(VAR_1, ""  -f, --use-file=FILE          Use the specified configuration file\n"");
#if defined VAR_2 && defined VAR_3
fprintf(VAR_1, ""  -P, --vrrp                   Only run with VRRP subsystem\n"");
fprintf(VAR_1, ""  -C, --check                  Only run with Health-checker subsystem\n"");
#endif
#ifdef VAR_4
fprintf(VAR_1, ""  -B, --no_bfd                 Don't run BFD subsystem\n"");
#endif
fprintf(VAR_1, ""      --all                    Force all child processes to run, even if have no configuration\n"");
fprintf(VAR_1, ""  -l, --log-console            Log messages to local console\n"");
fprintf(VAR_1, ""  -D, --log-detail             Detailed log messages\n"");
fprintf(VAR_1, ""  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\n"");
fprintf(VAR_1, ""  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\n"");
fprintf(VAR_1, ""      --flush-log-file         Flush log file on write\n"");
fprintf(VAR_1, ""  -G, --no-syslog              Don't log via syslog\n"");
#ifdef VAR_2
fprintf(VAR_1, ""  -X, --release-vips           Drop VIP on transition from signal.\n"");
fprintf(VAR_1, ""  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\n"");
#endif
#ifdef VAR_3
fprintf(VAR_1, ""  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\n"");
#endif
fprintf(VAR_1, ""  -R, --dont-respawn           Don't respawn child processes\n"");
fprintf(VAR_1, ""  -n, --dont-fork              Don't fork the daemon process\n"");
fprintf(VAR_1, ""  -d, --dump-conf              Dump the configuration data\n"");
fprintf(VAR_1, ""  -p, --pid=FILE               Use specified pidfile for parent process\n"");
#ifdef VAR_2
fprintf(VAR_1, ""  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\n"");
#endif
#ifdef VAR_3
fprintf(VAR_1, ""  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\n"");
fprintf(VAR_1, ""  -a, --address-monitoring     Report all address additions/deletions notified via netlink\n"");
#endif
#ifdef VAR_4
fprintf(VAR_1, ""  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\n"");
#endif
#ifdef VAR_5
fprintf(VAR_1, ""  -x, --snmp                   Enable SNMP subsystem\n"");
fprintf(VAR_1, ""  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\n"");
#endif
#if VAR_6
fprintf(VAR_1, ""  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\n"");
#endif
fprintf(VAR_1, ""  -m, --core-dump              Produce core dump if terminate abnormally\n"");
fprintf(VAR_1, ""  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\n"");
#ifdef VAR_7
fprintf(VAR_1, ""  -L, --mem-check-log          Log malloc/frees to syslog\n"");
#endif
fprintf(VAR_1, ""  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\n""
""                                or any lines beginning @^ that do match.\n""
""                                The config-id defaults to the node name if option not used\n"");
fprintf(VAR_1, ""      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS""
#ifdef VAR_8
"", JSON""
#endif
""\n"");
fprintf(VAR_1, ""  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\n""
""                                stderr by default\n"");
#ifdef VAR_9
fprintf(VAR_1, ""      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\n"");
#endif
#ifdef VAR_10
fprintf(VAR_1, ""      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\n"");
#ifdef VAR_11
fprintf(VAR_1, ""                                   T - timer debug\n"");
#endif
#ifdef VAR_12
fprintf(VAR_1, ""                                   M - email alert debug\n"");
#endif
#ifdef VAR_13
fprintf(VAR_1, ""                                   E - epoll debug\n"");
#endif
#ifdef VAR_14
fprintf(VAR_1, ""                                   D - epoll thread dump debug\n"");
#endif
#ifdef VAR_15
fprintf(VAR_1, ""                                   F - vrrp fd dump debug\n"");
#endif
#ifdef VAR_16
fprintf(VAR_1, ""                                   R - regex debug\n"");
#endif
#ifdef VAR_17
fprintf(VAR_1, ""                                   X - regex timers\n"");
#endif
#ifdef VAR_18
fprintf(VAR_1, ""                                   S - TSM debug\n"");
#endif
#ifdef VAR_19
fprintf(VAR_1, ""                                   N - netlink timer debug\n"");
#endif
fprintf(VAR_1, ""                                 Example --debug=TpMEvcp\n"");
#endif
fprintf(VAR_1, ""  -v, --version                Display the version number\n"");
fprintf(VAR_1, ""  -h, --help                   Display this help message\n"");
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/main.c/vul/before/2.json,"static void
usage(const char *prog)
{
	fprintf(stderr, ""Usage: %s [OPTION...]\n"", prog);
	fprintf(stderr, ""  -f, --use-file=FILE          Use the specified configuration file\n"");
#if defined _WITH_VRRP_ && defined _WITH_LVS_
	fprintf(stderr, ""  -P, --vrrp                   Only run with VRRP subsystem\n"");
	fprintf(stderr, ""  -C, --check                  Only run with Health-checker subsystem\n"");
#endif
#ifdef _WITH_BFD_
	fprintf(stderr, ""  -B, --no_bfd                 Don't run BFD subsystem\n"");
#endif
	fprintf(stderr, ""      --all                    Force all child processes to run, even if have no configuration\n"");
	fprintf(stderr, ""  -l, --log-console            Log messages to local console\n"");
	fprintf(stderr, ""  -D, --log-detail             Detailed log messages\n"");
	fprintf(stderr, ""  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\n"");
	fprintf(stderr, ""  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\n"");
	fprintf(stderr, ""      --flush-log-file         Flush log file on write\n"");
	fprintf(stderr, ""  -G, --no-syslog              Don't log via syslog\n"");
	fprintf(stderr, ""  -u, --umask=MASK             umask for file creation (in numeric form)\n"");
#ifdef _WITH_VRRP_
	fprintf(stderr, ""  -X, --release-vips           Drop VIP on transition from signal.\n"");
	fprintf(stderr, ""  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\n"");
#endif
#ifdef _WITH_LVS_
	fprintf(stderr, ""  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\n"");
#endif
	fprintf(stderr, ""  -R, --dont-respawn           Don't respawn child processes\n"");
	fprintf(stderr, ""  -n, --dont-fork              Don't fork the daemon process\n"");
	fprintf(stderr, ""  -d, --dump-conf              Dump the configuration data\n"");
	fprintf(stderr, ""  -p, --pid=FILE               Use specified pidfile for parent process\n"");
#ifdef _WITH_VRRP_
	fprintf(stderr, ""  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\n"");
#endif
#ifdef _WITH_LVS_
	fprintf(stderr, ""  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\n"");
	fprintf(stderr, ""  -a, --address-monitoring     Report all address additions/deletions notified via netlink\n"");
#endif
#ifdef _WITH_BFD_
	fprintf(stderr, ""  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\n"");
#endif
#ifdef _WITH_SNMP_
	fprintf(stderr, ""  -x, --snmp                   Enable SNMP subsystem\n"");
	fprintf(stderr, ""  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\n"");
#endif
#if HAVE_DECL_CLONE_NEWNET
	fprintf(stderr, ""  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\n"");
#endif
	fprintf(stderr, ""  -m, --core-dump              Produce core dump if terminate abnormally\n"");
	fprintf(stderr, ""  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\n"");
#ifdef _MEM_CHECK_LOG_
	fprintf(stderr, ""  -L, --mem-check-log          Log malloc/frees to syslog\n"");
#endif
	fprintf(stderr, ""  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\n""
			""                                or any lines beginning @^ that do match.\n""
			""                                The config-id defaults to the node name if option not used\n"");
	fprintf(stderr, ""      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS""
#ifdef _WITH_JSON_
								"", JSON""
#endif
								""\n"");
	fprintf(stderr, ""  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\n""
			""                                stderr by default\n"");
#ifdef _WITH_PERF_
	fprintf(stderr, ""      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\n"");
#endif
#ifdef WITH_DEBUG_OPTIONS
	fprintf(stderr, ""      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\n"");
#ifdef _TIMER_CHECK_
	fprintf(stderr, ""                                   T - timer debug\n"");
#endif
#ifdef _SMTP_ALERT_DEBUG_
	fprintf(stderr, ""                                   M - email alert debug\n"");
#endif
#ifdef _EPOLL_DEBUG_
	fprintf(stderr, ""                                   E - epoll debug\n"");
#endif
#ifdef _EPOLL_THREAD_DUMP_
	fprintf(stderr, ""                                   D - epoll thread dump debug\n"");
#endif
#ifdef _VRRP_FD_DEBUG
	fprintf(stderr, ""                                   F - vrrp fd dump debug\n"");
#endif
#ifdef _REGEX_DEBUG_
	fprintf(stderr, ""                                   R - regex debug\n"");
#endif
#ifdef _WITH_REGEX_TIMERS_
	fprintf(stderr, ""                                   X - regex timers\n"");
#endif
#ifdef _TSM_DEBUG_
	fprintf(stderr, ""                                   S - TSM debug\n"");
#endif
#ifdef _NETLINK_TIMERS_
	fprintf(stderr, ""                                   N - netlink timer debug\n"");
#endif
	fprintf(stderr, ""                                 Example --debug=TpMEvcp\n"");
#endif
	fprintf(stderr, ""  -v, --version                Display the version number\n"");
	fprintf(stderr, ""  -h, --help                   Display this help message\n"");
}","static void
usage(const char *VAR_0)
{
	fprintf(VAR_1, ""Usage: %s [OPTION...]\n"", VAR_0);
	fprintf(VAR_1, ""  -f, --use-file=FILE          Use the specified configuration file\n"");
#if defined VAR_2 && defined VAR_3
	fprintf(VAR_1, ""  -P, --vrrp                   Only run with VRRP subsystem\n"");
	fprintf(VAR_1, ""  -C, --check                  Only run with Health-checker subsystem\n"");
#endif
#ifdef VAR_4
	fprintf(VAR_1, ""  -B, --no_bfd                 Don't run BFD subsystem\n"");
#endif
	fprintf(VAR_1, ""      --all                    Force all child processes to run, even if have no configuration\n"");
	fprintf(VAR_1, ""  -l, --log-console            Log messages to local console\n"");
	fprintf(VAR_1, ""  -D, --log-detail             Detailed log messages\n"");
	fprintf(VAR_1, ""  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\n"");
	fprintf(VAR_1, ""  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\n"");
	fprintf(VAR_1, ""      --flush-log-file         Flush log file on write\n"");
	fprintf(VAR_1, ""  -G, --no-syslog              Don't log via syslog\n"");
	fprintf(VAR_1, ""  -u, --umask=MASK             umask for file creation (in numeric form)\n"");
#ifdef VAR_2
	fprintf(VAR_1, ""  -X, --release-vips           Drop VIP on transition from signal.\n"");
	fprintf(VAR_1, ""  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\n"");
#endif
#ifdef VAR_3
	fprintf(VAR_1, ""  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\n"");
#endif
	fprintf(VAR_1, ""  -R, --dont-respawn           Don't respawn child processes\n"");
	fprintf(VAR_1, ""  -n, --dont-fork              Don't fork the daemon process\n"");
	fprintf(VAR_1, ""  -d, --dump-conf              Dump the configuration data\n"");
	fprintf(VAR_1, ""  -p, --pid=FILE               Use specified pidfile for parent process\n"");
#ifdef VAR_2
	fprintf(VAR_1, ""  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\n"");
#endif
#ifdef VAR_3
	fprintf(VAR_1, ""  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\n"");
	fprintf(VAR_1, ""  -a, --address-monitoring     Report all address additions/deletions notified via netlink\n"");
#endif
#ifdef VAR_4
	fprintf(VAR_1, ""  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\n"");
#endif
#ifdef VAR_5
	fprintf(VAR_1, ""  -x, --snmp                   Enable SNMP subsystem\n"");
	fprintf(VAR_1, ""  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\n"");
#endif
#if VAR_6
	fprintf(VAR_1, ""  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\n"");
#endif
	fprintf(VAR_1, ""  -m, --core-dump              Produce core dump if terminate abnormally\n"");
	fprintf(VAR_1, ""  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\n"");
#ifdef VAR_7
	fprintf(VAR_1, ""  -L, --mem-check-log          Log malloc/frees to syslog\n"");
#endif
	fprintf(VAR_1, ""  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\n""
			""                                or any lines beginning @^ that do match.\n""
			""                                The config-id defaults to the node name if option not used\n"");
	fprintf(VAR_1, ""      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS""
#ifdef VAR_8
								"", JSON""
#endif
								""\n"");
	fprintf(VAR_1, ""  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\n""
			""                                stderr by default\n"");
#ifdef VAR_9
	fprintf(VAR_1, ""      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\n"");
#endif
#ifdef VAR_10
	fprintf(VAR_1, ""      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\n"");
#ifdef VAR_11
	fprintf(VAR_1, ""                                   T - timer debug\n"");
#endif
#ifdef VAR_12
	fprintf(VAR_1, ""                                   M - email alert debug\n"");
#endif
#ifdef VAR_13
	fprintf(VAR_1, ""                                   E - epoll debug\n"");
#endif
#ifdef VAR_14
	fprintf(VAR_1, ""                                   D - epoll thread dump debug\n"");
#endif
#ifdef VAR_15
	fprintf(VAR_1, ""                                   F - vrrp fd dump debug\n"");
#endif
#ifdef VAR_16
	fprintf(VAR_1, ""                                   R - regex debug\n"");
#endif
#ifdef VAR_17
	fprintf(VAR_1, ""                                   X - regex timers\n"");
#endif
#ifdef VAR_18
	fprintf(VAR_1, ""                                   S - TSM debug\n"");
#endif
#ifdef VAR_19
	fprintf(VAR_1, ""                                   N - netlink timer debug\n"");
#endif
	fprintf(VAR_1, ""                                 Example --debug=TpMEvcp\n"");
#endif
	fprintf(VAR_1, ""  -v, --version                Display the version number\n"");
	fprintf(VAR_1, ""  -h, --help                   Display this help message\n"");
}",acassen/keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067/main.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -17,6 +17,7 @@
 	fprintf(stderr, ""  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\n"");
 	fprintf(stderr, ""      --flush-log-file         Flush log file on write\n"");
 	fprintf(stderr, ""  -G, --no-syslog              Don't log via syslog\n"");
+	fprintf(stderr, ""  -u, --umask=MASK             umask for file creation (in numeric form)\n"");
 #ifdef _WITH_VRRP_
 	fprintf(stderr, ""  -X, --release-vips           Drop VIP on transition from signal.\n"");
 	fprintf(stderr, ""  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\n"");","{'deleted_lines': [], 'added_lines': ['\tfprintf(stderr, ""  -u, --umask=MASK             umask for file creation (in numeric form)\\n"");']}",True,"keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information.",7.5,HIGH,2,test,2018-10-31T17:08:51Z,2
CVE-2018-19045,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,acassen/keepalived,"Fix compile warning introduced in commit c6247a9

Commit c6247a9 - ""Add command line and configuration option to set umask""
introduced a compile warning, although the code would have worked OK.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,https://github.com/acassen/keepalived/commit/5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,keepalived/core/main.c,set_umask,"static mode_t
set_umask(const char *optarg)
{
long umask_long;
mode_t umask_val;
char *endptr;
umask_long = strtoll(optarg, &endptr, 0);
if (*endptr || umask_long < 0 || umask_long & ~0777L) {
fprintf(stderr, ""Invalid --umask option %s"", optarg);
return;
}
umask_val = umask_long & 0777;
umask(umask_val);
umask_cmdline = true;
return umask_val;
}","static mode_t
set_umask(const char *VAR_0)
{
long VAR_1;
mode_t VAR_2;
char *VAR_3;
VAR_1 = strtoll(VAR_0, &VAR_3, 0);
if (*VAR_3 || VAR_1 < 0 || VAR_1 & ~0777L) {
fprintf(VAR_4, ""Invalid --umask option %s"", VAR_0);
return;
}
VAR_2 = VAR_1 & 0777;
umask(VAR_2);
VAR_5 = true;
return VAR_2;
}",acassen/keepalived/5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6/main.c/vul/before/0.json,"static mode_t
set_umask(const char *optarg)
{
	long umask_long;
	mode_t umask_val;
	char *endptr;

	umask_long = strtoll(optarg, &endptr, 0);

	if (*endptr || umask_long < 0 || umask_long & ~0777L) {
		fprintf(stderr, ""Invalid --umask option %s"", optarg);
		return 0;
	}

	umask_val = umask_long & 0777;
	umask(umask_val);

	umask_cmdline = true;

	return umask_val;
}","static mode_t
set_umask(const char *VAR_0)
{
	long VAR_1;
	mode_t VAR_2;
	char *VAR_3;

	VAR_1 = strtoll(VAR_0, &VAR_3, 0);

	if (*VAR_3 || VAR_1 < 0 || VAR_1 & ~0777L) {
		fprintf(VAR_4, ""Invalid --umask option %s"", VAR_0);
		return 0;
	}

	VAR_2 = VAR_1 & 0777;
	umask(VAR_2);

	VAR_5 = true;

	return VAR_2;
}",acassen/keepalived/5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 
 	if (*endptr || umask_long < 0 || umask_long & ~0777L) {
 		fprintf(stderr, ""Invalid --umask option %s"", optarg);
-		return;
+		return 0;
 	}
 
 	umask_val = umask_long & 0777;","{'deleted_lines': ['\t\treturn;'], 'added_lines': ['\t\treturn 0;']}",True,"keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information.",7.5,HIGH,2,test,2018-10-31T21:57:02Z,2
CVE-2018-19477,['CWE-704'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ArtifexSoftware/ghostpdl,"Bug #700168 - add a type check

Bug #700168 ""Type confusion in JBIG2Decode""

The code was assuming that .jbig2globalctx was a structure allocated
by the graphics library, without checking.

Add a check to see that it is a structure and that its the correct
type of structure.",606a22e77e7f081781e99e44644cd0119f559e03,https://github.com/ArtifexSoftware/ghostpdl/commit/606a22e77e7f081781e99e44644cd0119f559e03,psi/zfjbig2.c,z_jbig2decode,"static int
z_jbig2decode(i_ctx_t * i_ctx_p)
{
os_ptr op = osp;
ref *sop = NULL;
s_jbig2_global_data_t *gref;
stream_jbig2decode_state state;
s_jbig2decode_set_global_data((stream_state*)&state, NULL);
if (r_has_type(op, t_dictionary)) {
check_dict_read(*op);
if ( dict_find_string(op, "".jbig2globalctx"", &sop) > 0) {
gref = r_ptr(sop, s_jbig2_global_data_t);
s_jbig2decode_set_global_data((stream_state*)&state, gref);
}
}
return filter_read(i_ctx_p, 0, &s_jbig2decode_template,
(stream_state *) & state, (sop ? r_space(sop) : 0));
}","static int
z_jbig2decode(i_ctx_t * VAR_0)
{
os_ptr VAR_1 = VAR_2;
ref *VAR_3 = NULL;
s_jbig2_global_data_t *VAR_4;
stream_jbig2decode_state VAR_5;
s_jbig2decode_set_global_data((stream_state*)&VAR_5, NULL);
if (r_has_type(VAR_1, VAR_6)) {
check_dict_read(*VAR_1);
if ( dict_find_string(VAR_1, "".jbig2globalctx"", &VAR_3) > 0) {
VAR_4 = r_ptr(VAR_3, s_jbig2_global_data_t);
s_jbig2decode_set_global_data((stream_state*)&VAR_5, VAR_4);
}
}
return filter_read(VAR_0, 0, &VAR_7,
(stream_state *) & VAR_5, (VAR_3 ? r_space(VAR_3) : 0));
}",ArtifexSoftware/ghostpdl/606a22e77e7f081781e99e44644cd0119f559e03/zfjbig2.c/vul/before/0.json,"static int
z_jbig2decode(i_ctx_t * i_ctx_p)
{
    os_ptr op = osp;
    ref *sop = NULL;
    s_jbig2_global_data_t *gref;
    stream_jbig2decode_state state;

    /* Extract the global context reference, if any, from the parameter
       dictionary and embed it in our stream state. The original object
       ref is under the JBIG2Globals key.
       We expect the postscript code to resolve this and call
       z_jbig2makeglobalctx() below to create an astruct wrapping the
       global decoder data and store it under the .jbig2globalctx key
     */
    s_jbig2decode_set_global_data((stream_state*)&state, NULL);
    if (r_has_type(op, t_dictionary)) {
        check_dict_read(*op);
        if ( dict_find_string(op, "".jbig2globalctx"", &sop) > 0) {
            if (!r_is_struct(sop) || !r_has_stype(sop, imemory, st_jbig2_global_data_t))
                return_error(gs_error_typecheck);
            gref = r_ptr(sop, s_jbig2_global_data_t);
            s_jbig2decode_set_global_data((stream_state*)&state, gref);
        }
    }

    /* we pass npop=0, since we've no arguments left to consume */
    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,
                       (stream_state *) & state, (sop ? r_space(sop) : 0));
}","static int
z_jbig2decode(i_ctx_t * VAR_0)
{
    os_ptr VAR_1 = VAR_2;
    ref *VAR_3 = NULL;
    s_jbig2_global_data_t *VAR_4;
    stream_jbig2decode_state VAR_5;

    /* COMMENT_0 */
                                                                       
                                         
                                                             
                                                                     
                                                                     
       
    s_jbig2decode_set_global_data((stream_state*)&VAR_5, NULL);
    if (r_has_type(VAR_1, VAR_6)) {
        check_dict_read(*VAR_1);
        if ( dict_find_string(VAR_1, "".jbig2globalctx"", &VAR_3) > 0) {
            if (!r_is_struct(VAR_3) || !r_has_stype(VAR_3, VAR_7, VAR_8))
                return_error(VAR_9);
            VAR_4 = r_ptr(VAR_3, s_jbig2_global_data_t);
            s_jbig2decode_set_global_data((stream_state*)&VAR_5, VAR_4);
        }
    }

    /* COMMENT_7 */
    return filter_read(VAR_0, 0, &VAR_10,
                       (stream_state *) & VAR_5, (VAR_3 ? r_space(VAR_3) : 0));
}",ArtifexSoftware/ghostpdl/606a22e77e7f081781e99e44644cd0119f559e03/zfjbig2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,8 @@
     if (r_has_type(op, t_dictionary)) {
         check_dict_read(*op);
         if ( dict_find_string(op, "".jbig2globalctx"", &sop) > 0) {
+            if (!r_is_struct(sop) || !r_has_stype(sop, imemory, st_jbig2_global_data_t))
+                return_error(gs_error_typecheck);
             gref = r_ptr(sop, s_jbig2_global_data_t);
             s_jbig2decode_set_global_data((stream_state*)&state, gref);
         }","{'deleted_lines': [], 'added_lines': ['            if (!r_is_struct(sop) || !r_has_stype(sop, imemory, st_jbig2_global_data_t))', '                return_error(gs_error_typecheck);']}",True,psi/zfjbig2.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a JBIG2Decode type confusion.,7.8,HIGH,2,test,2018-11-14T09:27:00Z,2
CVE-2018-1000877,['CWE-415'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,libarchive,"Avoid a double-free when a window size of 0 is specified

new_size can be 0 with a malicious or corrupted RAR archive.

realloc(area, 0) is equivalent to free(area), so the region would
be free()d here and the free()d again in the cleanup function.

Found with a setup running AFL, afl-rb, and qsym.",021efa522ad729ff0f5806c4ce53e4a6cc1daa31,https://github.com/libarchive/libarchive/commit/021efa522ad729ff0f5806c4ce53e4a6cc1daa31,libarchive/archive_read_support_format_rar.c,parse_codes,"static int
parse_codes(struct archive_read *a)
{
int i, j, val, n, r;
unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
unsigned int maxorder;
struct huffman_code precode;
struct rar *rar = (struct rar *)(a->format->data);
struct rar_br *br = &(rar->br);
free_codes(a);
rar_br_consume_unalined_bits(br);
if (!rar_br_read_ahead(a, br, 1))
goto truncated_data;
if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
{
rar_br_consume(br, 1);
if (!rar_br_read_ahead(a, br, 7))
goto truncated_data;
ppmd_flags = rar_br_bits(br, 7);
rar_br_consume(br, 7);
if (ppmd_flags & 0x20)
{
if (!rar_br_read_ahead(a, br, 8))
goto truncated_data;
rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
rar_br_consume(br, 8);
}
if (ppmd_flags & 0x40)
{
if (!rar_br_read_ahead(a, br, 8))
goto truncated_data;
rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
rar_br_consume(br, 8);
}
else
rar->ppmd_escape = 2;
if (ppmd_flags & 0x20)
{
maxorder = (ppmd_flags & 0x1F) + 1;
if(maxorder > 16)
maxorder = 16 + (maxorder - 16) * 3;
if (maxorder == 1)
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Truncated RAR file data"");
return (ARCHIVE_FATAL);
}
__archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);
rar->bytein.a = a;
rar->bytein.Read = &ppmd_read;
__archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
rar->range_dec.Stream = &rar->bytein;
__archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);
if (rar->dictionary_size == 0) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid zero dictionary size"");
return (ARCHIVE_FATAL);
}
if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
rar->dictionary_size))
{
archive_set_error(&a->archive, ENOMEM,
""Out of memory"");
return (ARCHIVE_FATAL);
}
if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unable to initialize PPMd range decoder"");
return (ARCHIVE_FATAL);
}
__archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
rar->ppmd_valid = 1;
}
else
{
if (!rar->ppmd_valid) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid PPMd sequence"");
return (ARCHIVE_FATAL);
}
if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unable to initialize PPMd range decoder"");
return (ARCHIVE_FATAL);
}
}
}
else
{
rar_br_consume(br, 1);
if (!rar_br_read_ahead(a, br, 1))
goto truncated_data;
if (!rar_br_bits(br, 1))
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
rar_br_consume(br, 1);
memset(&bitlengths, 0, sizeof(bitlengths));
for (i = 0; i < MAX_SYMBOLS;)
{
if (!rar_br_read_ahead(a, br, 4))
goto truncated_data;
bitlengths[i++] = rar_br_bits(br, 4);
rar_br_consume(br, 4);
if (bitlengths[i-1] == 0xF)
{
if (!rar_br_read_ahead(a, br, 4))
goto truncated_data;
zerocount = rar_br_bits(br, 4);
rar_br_consume(br, 4);
if (zerocount)
{
i--;
for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
bitlengths[i++] = 0;
}
}
}
memset(&precode, 0, sizeof(precode));
r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK) {
free(precode.tree);
free(precode.table);
return (r);
}
for (i = 0; i < HUFFMAN_TABLE_SIZE;)
{
if ((val = read_next_symbol(a, &precode)) < 0) {
free(precode.tree);
free(precode.table);
return (ARCHIVE_FATAL);
}
if (val < 16)
{
rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
i++;
}
else if (val < 18)
{
if (i == 0)
{
free(precode.tree);
free(precode.table);
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Internal error extracting RAR file."");
return (ARCHIVE_FATAL);
}
if(val == 16) {
if (!rar_br_read_ahead(a, br, 3)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 3) + 3;
rar_br_consume(br, 3);
} else {
if (!rar_br_read_ahead(a, br, 7)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 7) + 11;
rar_br_consume(br, 7);
}
for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
{
rar->lengthtable[i] = rar->lengthtable[i-1];
i++;
}
}
else
{
if(val == 18) {
if (!rar_br_read_ahead(a, br, 3)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 3) + 3;
rar_br_consume(br, 3);
} else {
if (!rar_br_read_ahead(a, br, 7)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 7) + 11;
rar_br_consume(br, 7);
}
for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
rar->lengthtable[i++] = 0;
}
}
free(precode.tree);
free(precode.table);
r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
r = create_code(a, &rar->lowoffsetcode,
&rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
r = create_code(a, &rar->lengthcode,
&rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
}
if (!rar->dictionary_size || !rar->lzss.window)
{
void *new_window;
unsigned int new_size;
if (rar->unp_size >= DICTIONARY_MAX_SIZE)
new_size = DICTIONARY_MAX_SIZE;
else
new_size = rar_fls((unsigned int)rar->unp_size) << 1;
new_window = realloc(rar->lzss.window, new_size);
if (new_window == NULL) {
archive_set_error(&a->archive, ENOMEM,
""Unable to allocate memory for uncompressed data."");
return (ARCHIVE_FATAL);
}
rar->lzss.window = (unsigned char *)new_window;
rar->dictionary_size = new_size;
memset(rar->lzss.window, 0, rar->dictionary_size);
rar->lzss.mask = rar->dictionary_size - 1;
}
rar->start_new_table = 0;
return (ARCHIVE_OK);
truncated_data:
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Truncated RAR file data"");
rar->valid = 0;
return (ARCHIVE_FATAL);
}","static int
parse_codes(struct archive_read *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;
unsigned char VAR_6[VAR_7], VAR_8, VAR_9;
unsigned int VAR_10;
struct huffman_code VAR_11;
struct rar *rar = (struct rar *)(VAR_0->format->data);
struct rar_br *VAR_12 = &(rar->br);
free_codes(VAR_0);
rar_br_consume_unalined_bits(VAR_12);
if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
goto truncated_data;
if ((rar->is_ppmd_block = rar_br_bits(VAR_12, 1)) != 0)
{
rar_br_consume(VAR_12, 1);
if (!rar_br_read_ahead(VAR_0, VAR_12, 7))
goto truncated_data;
VAR_9 = rar_br_bits(VAR_12, 7);
rar_br_consume(VAR_12, 7);
if (VAR_9 & 0x20)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
goto truncated_data;
rar->dictionary_size = (rar_br_bits(VAR_12, 8) + 1) << 20;
rar_br_consume(VAR_12, 8);
}
if (VAR_9 & 0x40)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
goto truncated_data;
rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(VAR_12, 8);
rar_br_consume(VAR_12, 8);
}
else
rar->ppmd_escape = 2;
if (VAR_9 & 0x20)
{
VAR_10 = (VAR_9 & 0x1F) + 1;
if(VAR_10 > 16)
VAR_10 = 16 + (VAR_10 - 16) * 3;
if (VAR_10 == 1)
{
archive_set_error(&VAR_0->archive, VAR_13,
""Truncated RAR file data"");
return (VAR_14);
}
VAR_15.Ppmd7_Free(&rar->ppmd7_context);
rar->bytein.a = VAR_0;
rar->bytein.Read = &VAR_16;
VAR_15.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
rar->range_dec.Stream = &rar->bytein;
VAR_15.Ppmd7_Construct(&rar->ppmd7_context);
if (rar->dictionary_size == 0) {
archive_set_error(&VAR_0->archive, VAR_13,
""Invalid zero dictionary size"");
return (VAR_14);
}
if (!VAR_15.Ppmd7_Alloc(&rar->ppmd7_context,
rar->dictionary_size))
{
archive_set_error(&VAR_0->archive, VAR_17,
""Out of memory"");
return (VAR_14);
}
if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&VAR_0->archive, VAR_13,
""Unable to initialize PPMd range decoder"");
return (VAR_14);
}
VAR_15.Ppmd7_Init(&rar->ppmd7_context, VAR_10);
rar->ppmd_valid = 1;
}
else
{
if (!rar->ppmd_valid) {
archive_set_error(&VAR_0->archive, VAR_13,
""Invalid PPMd sequence"");
return (VAR_14);
}
if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&VAR_0->archive, VAR_13,
""Unable to initialize PPMd range decoder"");
return (VAR_14);
}
}
}
else
{
rar_br_consume(VAR_12, 1);
if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
goto truncated_data;
if (!rar_br_bits(VAR_12, 1))
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
rar_br_consume(VAR_12, 1);
memset(&VAR_6, 0, sizeof(VAR_6));
for (VAR_1 = 0; VAR_1 < VAR_7;)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
goto truncated_data;
VAR_6[VAR_1++] = rar_br_bits(VAR_12, 4);
rar_br_consume(VAR_12, 4);
if (VAR_6[VAR_1-1] == 0xF)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
goto truncated_data;
VAR_8 = rar_br_bits(VAR_12, 4);
rar_br_consume(VAR_12, 4);
if (VAR_8)
{
VAR_1--;
for (VAR_2 = 0; VAR_2 < VAR_8 + 2 && VAR_1 < VAR_7; VAR_2++)
VAR_6[VAR_1++] = 0;
}
}
}
memset(&VAR_11, 0, sizeof(VAR_11));
VAR_5 = create_code(VAR_0, &VAR_11, VAR_6, VAR_7, VAR_18);
if (VAR_5 != VAR_19) {
free(VAR_11.tree);
free(VAR_11.table);
return (VAR_5);
}
for (VAR_1 = 0; VAR_1 < VAR_20;)
{
if ((VAR_3 = read_next_symbol(VAR_0, &VAR_11)) < 0) {
free(VAR_11.tree);
free(VAR_11.table);
return (VAR_14);
}
if (VAR_3 < 16)
{
rar->lengthtable[VAR_1] = (rar->lengthtable[VAR_1] + VAR_3) & 0xF;
VAR_1++;
}
else if (VAR_3 < 18)
{
if (VAR_1 == 0)
{
free(VAR_11.tree);
free(VAR_11.table);
archive_set_error(&VAR_0->archive, VAR_13,
""Internal error extracting RAR file."");
return (VAR_14);
}
if(VAR_3 == 16) {
if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 3) + 3;
rar_br_consume(VAR_12, 3);
} else {
if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 7) + 11;
rar_br_consume(VAR_12, 7);
}
for (VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)
{
rar->lengthtable[VAR_1] = rar->lengthtable[VAR_1-1];
VAR_1++;
}
}
else
{
if(VAR_3 == 18) {
if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 3) + 3;
rar_br_consume(VAR_12, 3);
} else {
if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 7) + 11;
rar_br_consume(VAR_12, 7);
}
for(VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)
rar->lengthtable[VAR_1++] = 0;
}
}
free(VAR_11.tree);
free(VAR_11.table);
VAR_5 = create_code(VAR_0, &rar->maincode, &rar->lengthtable[0], VAR_21,
VAR_18);
if (VAR_5 != VAR_19)
return (VAR_5);
VAR_5 = create_code(VAR_0, &rar->offsetcode, &rar->lengthtable[VAR_21],
VAR_22, VAR_18);
if (VAR_5 != VAR_19)
return (VAR_5);
VAR_5 = create_code(VAR_0, &rar->lowoffsetcode,
&rar->lengthtable[VAR_21 + VAR_22],
VAR_23, VAR_18);
if (VAR_5 != VAR_19)
return (VAR_5);
VAR_5 = create_code(VAR_0, &rar->lengthcode,
&rar->lengthtable[VAR_21 + VAR_22 +
VAR_23], VAR_24, VAR_18);
if (VAR_5 != VAR_19)
return (VAR_5);
}
if (!rar->dictionary_size || !rar->lzss.window)
{
void *VAR_25;
unsigned int VAR_26;
if (rar->unp_size >= VAR_27)
VAR_26 = VAR_27;
else
VAR_26 = rar_fls((unsigned int)rar->unp_size) << 1;
VAR_25 = realloc(rar->lzss.window, VAR_26);
if (VAR_25 == NULL) {
archive_set_error(&VAR_0->archive, VAR_17,
""Unable to allocate memory for uncompressed data."");
return (VAR_14);
}
rar->lzss.window = (unsigned char *)VAR_25;
rar->dictionary_size = VAR_26;
memset(rar->lzss.window, 0, rar->dictionary_size);
rar->lzss.mask = rar->dictionary_size - 1;
}
rar->start_new_table = 0;
return (VAR_19);
truncated_data:
archive_set_error(&VAR_0->archive, VAR_13,
""Truncated RAR file data"");
rar->valid = 0;
return (VAR_14);
}",libarchive/021efa522ad729ff0f5806c4ce53e4a6cc1daa31/archive_read_support_format_rar.c/vul/before/0.json,"static int
parse_codes(struct archive_read *a)
{
  int i, j, val, n, r;
  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
  unsigned int maxorder;
  struct huffman_code precode;
  struct rar *rar = (struct rar *)(a->format->data);
  struct rar_br *br = &(rar->br);

  free_codes(a);

  /* Skip to the next byte */
  rar_br_consume_unalined_bits(br);

  /* PPMd block flag */
  if (!rar_br_read_ahead(a, br, 1))
    goto truncated_data;
  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
  {
    rar_br_consume(br, 1);
    if (!rar_br_read_ahead(a, br, 7))
      goto truncated_data;
    ppmd_flags = rar_br_bits(br, 7);
    rar_br_consume(br, 7);

    /* Memory is allocated in MB */
    if (ppmd_flags & 0x20)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
      rar_br_consume(br, 8);
    }

    if (ppmd_flags & 0x40)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
      rar_br_consume(br, 8);
    }
    else
      rar->ppmd_escape = 2;

    if (ppmd_flags & 0x20)
    {
      maxorder = (ppmd_flags & 0x1F) + 1;
      if(maxorder > 16)
        maxorder = 16 + (maxorder - 16) * 3;

      if (maxorder == 1)
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Truncated RAR file data"");
        return (ARCHIVE_FATAL);
      }

      /* Make sure ppmd7_contest is freed before Ppmd7_Construct
       * because reading a broken file cause this abnormal sequence. */
      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);

      rar->bytein.a = a;
      rar->bytein.Read = &ppmd_read;
      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
      rar->range_dec.Stream = &rar->bytein;
      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);

      if (rar->dictionary_size == 0) {
	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid zero dictionary size"");
	      return (ARCHIVE_FATAL);
      }

      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size))
      {
        archive_set_error(&a->archive, ENOMEM,
                          ""Out of memory"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
      rar->ppmd_valid = 1;
    }
    else
    {
      if (!rar->ppmd_valid) {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid PPMd sequence"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
    }
  }
  else
  {
    rar_br_consume(br, 1);

    /* Keep existing table flag */
    if (!rar_br_read_ahead(a, br, 1))
      goto truncated_data;
    if (!rar_br_bits(br, 1))
      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
    rar_br_consume(br, 1);

    memset(&bitlengths, 0, sizeof(bitlengths));
    for (i = 0; i < MAX_SYMBOLS;)
    {
      if (!rar_br_read_ahead(a, br, 4))
        goto truncated_data;
      bitlengths[i++] = rar_br_bits(br, 4);
      rar_br_consume(br, 4);
      if (bitlengths[i-1] == 0xF)
      {
        if (!rar_br_read_ahead(a, br, 4))
          goto truncated_data;
        zerocount = rar_br_bits(br, 4);
        rar_br_consume(br, 4);
        if (zerocount)
        {
          i--;
          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
            bitlengths[i++] = 0;
        }
      }
    }

    memset(&precode, 0, sizeof(precode));
    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK) {
      free(precode.tree);
      free(precode.table);
      return (r);
    }

    for (i = 0; i < HUFFMAN_TABLE_SIZE;)
    {
      if ((val = read_next_symbol(a, &precode)) < 0) {
        free(precode.tree);
        free(precode.table);
        return (ARCHIVE_FATAL);
      }
      if (val < 16)
      {
        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
        i++;
      }
      else if (val < 18)
      {
        if (i == 0)
        {
          free(precode.tree);
          free(precode.table);
          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                            ""Internal error extracting RAR file."");
          return (ARCHIVE_FATAL);
        }

        if(val == 16) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
        {
          rar->lengthtable[i] = rar->lengthtable[i-1];
          i++;
        }
      }
      else
      {
        if(val == 18) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
          rar->lengthtable[i++] = 0;
      }
    }
    free(precode.tree);
    free(precode.table);

    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
                MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lowoffsetcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lengthcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
  }

  if (!rar->dictionary_size || !rar->lzss.window)
  {
    /* Seems as though dictionary sizes are not used. Even so, minimize
     * memory usage as much as possible.
     */
    void *new_window;
    unsigned int new_size;

    if (rar->unp_size >= DICTIONARY_MAX_SIZE)
      new_size = DICTIONARY_MAX_SIZE;
    else
      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
    if (new_size == 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                        ""Zero window size is invalid."");
      return (ARCHIVE_FATAL);
    }
    new_window = realloc(rar->lzss.window, new_size);
    if (new_window == NULL) {
      archive_set_error(&a->archive, ENOMEM,
                        ""Unable to allocate memory for uncompressed data."");
      return (ARCHIVE_FATAL);
    }
    rar->lzss.window = (unsigned char *)new_window;
    rar->dictionary_size = new_size;
    memset(rar->lzss.window, 0, rar->dictionary_size);
    rar->lzss.mask = rar->dictionary_size - 1;
  }

  rar->start_new_table = 0;
  return (ARCHIVE_OK);
truncated_data:
  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                    ""Truncated RAR file data"");
  rar->valid = 0;
  return (ARCHIVE_FATAL);
}","static int
parse_codes(struct archive_read *VAR_0)
{
  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;
  unsigned char VAR_6[VAR_7], VAR_8, VAR_9;
  unsigned int VAR_10;
  struct huffman_code VAR_11;
  struct rar *rar = (struct rar *)(VAR_0->format->data);
  struct rar_br *VAR_12 = &(rar->br);

  free_codes(VAR_0);

  /* COMMENT_0 */
  rar_br_consume_unalined_bits(VAR_12);

  /* COMMENT_1 */
  if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
    goto truncated_data;
  if ((rar->is_ppmd_block = rar_br_bits(VAR_12, 1)) != 0)
  {
    rar_br_consume(VAR_12, 1);
    if (!rar_br_read_ahead(VAR_0, VAR_12, 7))
      goto truncated_data;
    VAR_9 = rar_br_bits(VAR_12, 7);
    rar_br_consume(VAR_12, 7);

    /* COMMENT_2 */
    if (VAR_9 & 0x20)
    {
      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
        goto truncated_data;
      rar->dictionary_size = (rar_br_bits(VAR_12, 8) + 1) << 20;
      rar_br_consume(VAR_12, 8);
    }

    if (VAR_9 & 0x40)
    {
      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
        goto truncated_data;
      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(VAR_12, 8);
      rar_br_consume(VAR_12, 8);
    }
    else
      rar->ppmd_escape = 2;

    if (VAR_9 & 0x20)
    {
      VAR_10 = (VAR_9 & 0x1F) + 1;
      if(VAR_10 > 16)
        VAR_10 = 16 + (VAR_10 - 16) * 3;

      if (VAR_10 == 1)
      {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Truncated RAR file data"");
        return (VAR_14);
      }

      /* COMMENT_3 */
                                                                       
      VAR_15.Ppmd7_Free(&rar->ppmd7_context);

      rar->bytein.a = VAR_0;
      rar->bytein.Read = &VAR_16;
      VAR_15.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
      rar->range_dec.Stream = &rar->bytein;
      VAR_15.Ppmd7_Construct(&rar->ppmd7_context);

      if (rar->dictionary_size == 0) {
	      archive_set_error(&VAR_0->archive, VAR_13,
                          ""Invalid zero dictionary size"");
	      return (VAR_14);
      }

      if (!VAR_15.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size))
      {
        archive_set_error(&VAR_0->archive, VAR_17,
                          ""Out of memory"");
        return (VAR_14);
      }
      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Unable to initialize PPMd range decoder"");
        return (VAR_14);
      }
      VAR_15.Ppmd7_Init(&rar->ppmd7_context, VAR_10);
      rar->ppmd_valid = 1;
    }
    else
    {
      if (!rar->ppmd_valid) {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Invalid PPMd sequence"");
        return (VAR_14);
      }
      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Unable to initialize PPMd range decoder"");
        return (VAR_14);
      }
    }
  }
  else
  {
    rar_br_consume(VAR_12, 1);

    /* COMMENT_5 */
    if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
      goto truncated_data;
    if (!rar_br_bits(VAR_12, 1))
      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
    rar_br_consume(VAR_12, 1);

    memset(&VAR_6, 0, sizeof(VAR_6));
    for (VAR_1 = 0; VAR_1 < VAR_7;)
    {
      if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
        goto truncated_data;
      VAR_6[VAR_1++] = rar_br_bits(VAR_12, 4);
      rar_br_consume(VAR_12, 4);
      if (VAR_6[VAR_1-1] == 0xF)
      {
        if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
          goto truncated_data;
        VAR_8 = rar_br_bits(VAR_12, 4);
        rar_br_consume(VAR_12, 4);
        if (VAR_8)
        {
          VAR_1--;
          for (VAR_2 = 0; VAR_2 < VAR_8 + 2 && VAR_1 < VAR_7; VAR_2++)
            VAR_6[VAR_1++] = 0;
        }
      }
    }

    memset(&VAR_11, 0, sizeof(VAR_11));
    VAR_5 = create_code(VAR_0, &VAR_11, VAR_6, VAR_7, VAR_18);
    if (VAR_5 != VAR_19) {
      free(VAR_11.tree);
      free(VAR_11.table);
      return (VAR_5);
    }

    for (VAR_1 = 0; VAR_1 < VAR_20;)
    {
      if ((VAR_3 = read_next_symbol(VAR_0, &VAR_11)) < 0) {
        free(VAR_11.tree);
        free(VAR_11.table);
        return (VAR_14);
      }
      if (VAR_3 < 16)
      {
        rar->lengthtable[VAR_1] = (rar->lengthtable[VAR_1] + VAR_3) & 0xF;
        VAR_1++;
      }
      else if (VAR_3 < 18)
      {
        if (VAR_1 == 0)
        {
          free(VAR_11.tree);
          free(VAR_11.table);
          archive_set_error(&VAR_0->archive, VAR_13,
                            ""Internal error extracting RAR file."");
          return (VAR_14);
        }

        if(VAR_3 == 16) {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 3) + 3;
          rar_br_consume(VAR_12, 3);
        } else {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 7) + 11;
          rar_br_consume(VAR_12, 7);
        }

        for (VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)
        {
          rar->lengthtable[VAR_1] = rar->lengthtable[VAR_1-1];
          VAR_1++;
        }
      }
      else
      {
        if(VAR_3 == 18) {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 3) + 3;
          rar_br_consume(VAR_12, 3);
        } else {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 7) + 11;
          rar_br_consume(VAR_12, 7);
        }

        for(VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_20; VAR_2++)
          rar->lengthtable[VAR_1++] = 0;
      }
    }
    free(VAR_11.tree);
    free(VAR_11.table);

    VAR_5 = create_code(VAR_0, &rar->maincode, &rar->lengthtable[0], VAR_21,
                VAR_18);
    if (VAR_5 != VAR_19)
      return (VAR_5);
    VAR_5 = create_code(VAR_0, &rar->offsetcode, &rar->lengthtable[VAR_21],
                VAR_22, VAR_18);
    if (VAR_5 != VAR_19)
      return (VAR_5);
    VAR_5 = create_code(VAR_0, &rar->lowoffsetcode,
                &rar->lengthtable[VAR_21 + VAR_22],
                VAR_23, VAR_18);
    if (VAR_5 != VAR_19)
      return (VAR_5);
    VAR_5 = create_code(VAR_0, &rar->lengthcode,
                &rar->lengthtable[VAR_21 + VAR_22 +
                VAR_23], VAR_24, VAR_18);
    if (VAR_5 != VAR_19)
      return (VAR_5);
  }

  if (!rar->dictionary_size || !rar->lzss.window)
  {
    /* COMMENT_6 */
                                        
       
    void *VAR_25;
    unsigned int VAR_26;

    if (rar->unp_size >= VAR_27)
      VAR_26 = VAR_27;
    else
      VAR_26 = rar_fls((unsigned int)rar->unp_size) << 1;
    if (VAR_26 == 0) {
      archive_set_error(&VAR_0->archive, VAR_13,
                        ""Zero window size is invalid."");
      return (VAR_14);
    }
    VAR_25 = realloc(rar->lzss.window, VAR_26);
    if (VAR_25 == NULL) {
      archive_set_error(&VAR_0->archive, VAR_17,
                        ""Unable to allocate memory for uncompressed data."");
      return (VAR_14);
    }
    rar->lzss.window = (unsigned char *)VAR_25;
    rar->dictionary_size = VAR_26;
    memset(rar->lzss.window, 0, rar->dictionary_size);
    rar->lzss.mask = rar->dictionary_size - 1;
  }

  rar->start_new_table = 0;
  return (VAR_19);
truncated_data:
  archive_set_error(&VAR_0->archive, VAR_13,
                    ""Truncated RAR file data"");
  rar->valid = 0;
  return (VAR_14);
}",libarchive/021efa522ad729ff0f5806c4ce53e4a6cc1daa31/archive_read_support_format_rar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -250,6 +250,11 @@
       new_size = DICTIONARY_MAX_SIZE;
     else
       new_size = rar_fls((unsigned int)rar->unp_size) << 1;
+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }
     new_window = realloc(rar->lzss.window, new_size);
     if (new_window == NULL) {
       archive_set_error(&a->archive, ENOMEM,","{'deleted_lines': [], 'added_lines': ['    if (new_size == 0) {', '      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,', '                        ""Zero window size is invalid."");', '      return (ARCHIVE_FATAL);', '    }']}",True,"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.",8.8,HIGH,2,test,2018-11-20T06:56:29Z,2
CVE-2018-19841,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,dbry/WavPack,issue #54: fix potential out-of-bounds heap read,bba5389dc598a92bdf2b297c3ea34620b6679b5b,https://github.com/dbry/WavPack/commit/bba5389dc598a92bdf2b297c3ea34620b6679b5b,src/open_utils.c,WavpackVerifySingleBlock,"int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)
{
WavpackHeader *wphdr = (WavpackHeader *) buffer;
uint32_t checksum_passed = 0, bcount, meta_bc;
unsigned char *dp, meta_id, c1, c2;
if (strncmp (wphdr->ckID, ""wvpk"", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))
return FALSE;
bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;
dp = (unsigned char *)(wphdr + 1);
while (bcount >= 2) {
meta_id = *dp++;
c1 = *dp++;
meta_bc = c1 << 1;
bcount -= 2;
if (meta_id & ID_LARGE) {
if (bcount < 2)
return FALSE;
c1 = *dp++;
c2 = *dp++;
meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);
bcount -= 2;
}
if (bcount < meta_bc)
return FALSE;
if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {
#ifdef BITSTREAM_SHORTS
uint16_t *csptr = (uint16_t*) buffer;
#else
unsigned char *csptr = buffer;
#endif
int wcount = (int)(dp - 2 - buffer) >> 1;
uint32_t csum = (uint32_t) -1;
if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)
return FALSE;
#ifdef BITSTREAM_SHORTS
while (wcount--)
csum = (csum * 3) + *csptr++;
#else
WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);
while (wcount--) {
csum = (csum * 3) + csptr [0] + (csptr [1] << 8);
csptr += 2;
}
WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);
#endif
if (meta_bc == 4) {
if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))
return FALSE;
}
else {
csum ^= csum >> 16;
if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))
return FALSE;
}
checksum_passed++;
}
bcount -= meta_bc;
dp += meta_bc;
}
return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);
}","int WavpackVerifySingleBlock (unsigned char *VAR_0, int VAR_1)
{
WavpackHeader *VAR_2 = (WavpackHeader *) VAR_0;
uint32_t VAR_3 = 0, VAR_4, VAR_5;
unsigned char *VAR_6, VAR_7, VAR_8, VAR_9;
if (strncmp (VAR_2->ckID, ""wvpk"", 4) || VAR_2->ckSize + 8 < sizeof (WavpackHeader))
return FALSE;
VAR_4 = VAR_2->ckSize - sizeof (WavpackHeader) + 8;
VAR_6 = (unsigned char *)(VAR_2 + 1);
while (VAR_4 >= 2) {
VAR_7 = *VAR_6++;
VAR_8 = *VAR_6++;
VAR_5 = VAR_8 << 1;
VAR_4 -= 2;
if (VAR_7 & VAR_10) {
if (VAR_4 < 2)
return FALSE;
VAR_8 = *VAR_6++;
VAR_9 = *VAR_6++;
VAR_5 += ((uint32_t) VAR_8 << 9) + ((uint32_t) VAR_9 << 17);
VAR_4 -= 2;
}
if (VAR_4 < VAR_5)
return FALSE;
if (VAR_1 && (VAR_7 & VAR_11) == VAR_12) {
#ifdef VAR_13
uint16_t *VAR_14 = (uint16_t*) VAR_0;
#else
unsigned char *VAR_14 = VAR_0;
#endif
int VAR_15 = (int)(VAR_6 - 2 - VAR_0) >> 1;
uint32_t VAR_16 = (uint32_t) -1;
if ((VAR_7 & VAR_17) || VAR_5 < 2 || VAR_5 > 4)
return FALSE;
#ifdef VAR_13
while (VAR_15--)
VAR_16 = (VAR_16 * 3) + *VAR_14++;
#else
WavpackNativeToLittleEndian ((WavpackHeader *) VAR_0, VAR_18);
while (VAR_15--) {
VAR_16 = (VAR_16 * 3) + VAR_14 [0] + (VAR_14 [1] << 8);
VAR_14 += 2;
}
WavpackLittleEndianToNative ((WavpackHeader *) VAR_0, VAR_18);
#endif
if (VAR_5 == 4) {
if (*VAR_6++ != (VAR_16 & 0xff) || *VAR_6++ != ((VAR_16 >> 8) & 0xff) || *VAR_6++ != ((VAR_16 >> 16) & 0xff) || *VAR_6++ != ((VAR_16 >> 24) & 0xff))
return FALSE;
}
else {
VAR_16 ^= VAR_16 >> 16;
if (*VAR_6++ != (VAR_16 & 0xff) || *VAR_6++ != ((VAR_16 >> 8) & 0xff))
return FALSE;
}
VAR_3++;
}
VAR_4 -= VAR_5;
VAR_6 += VAR_5;
}
return (VAR_4 == 0) && (!VAR_1 || !(VAR_2->flags & VAR_19) || VAR_3);
}",dbry/WavPack/bba5389dc598a92bdf2b297c3ea34620b6679b5b/open_utils.c/vul/before/0.json,"int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)
{
    WavpackHeader *wphdr = (WavpackHeader *) buffer;
    uint32_t checksum_passed = 0, bcount, meta_bc;
    unsigned char *dp, meta_id, c1, c2;

    if (strncmp (wphdr->ckID, ""wvpk"", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader))
        return FALSE;

    bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8;
    dp = (unsigned char *)(wphdr + 1);

    while (bcount >= 2) {
        meta_id = *dp++;
        c1 = *dp++;

        meta_bc = c1 << 1;
        bcount -= 2;

        if (meta_id & ID_LARGE) {
            if (bcount < 2)
                return FALSE;

            c1 = *dp++;
            c2 = *dp++;
            meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17);
            bcount -= 2;
        }

        if (bcount < meta_bc)
            return FALSE;

        if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) {
#ifdef BITSTREAM_SHORTS
            uint16_t *csptr = (uint16_t*) buffer;
#else
            unsigned char *csptr = buffer;
#endif
            int wcount = (int)(dp - 2 - buffer) >> 1;
            uint32_t csum = (uint32_t) -1;

            if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4)
                return FALSE;

#ifdef BITSTREAM_SHORTS
            while (wcount--)
                csum = (csum * 3) + *csptr++;
#else
            WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat);

            while (wcount--) {
                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);
                csptr += 2;
            }

            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);
#endif

            if (meta_bc == 4) {
                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))
                    return FALSE;
            }
            else {
                csum ^= csum >> 16;

                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))
                    return FALSE;
            }

            checksum_passed++;
        }

        bcount -= meta_bc;
        dp += meta_bc;
    }

    return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed);
}","int WavpackVerifySingleBlock (unsigned char *VAR_0, int VAR_1)
{
    WavpackHeader *VAR_2 = (WavpackHeader *) VAR_0;
    uint32_t VAR_3 = 0, VAR_4, VAR_5;
    unsigned char *VAR_6, VAR_7, VAR_8, VAR_9;

    if (strncmp (VAR_2->ckID, ""wvpk"", 4) || VAR_2->ckSize + 8 < sizeof (WavpackHeader))
        return FALSE;

    VAR_4 = VAR_2->ckSize - sizeof (WavpackHeader) + 8;
    VAR_6 = (unsigned char *)(VAR_2 + 1);

    while (VAR_4 >= 2) {
        VAR_7 = *VAR_6++;
        VAR_8 = *VAR_6++;

        VAR_5 = VAR_8 << 1;
        VAR_4 -= 2;

        if (VAR_7 & VAR_10) {
            if (VAR_4 < 2)
                return FALSE;

            VAR_8 = *VAR_6++;
            VAR_9 = *VAR_6++;
            VAR_5 += ((uint32_t) VAR_8 << 9) + ((uint32_t) VAR_9 << 17);
            VAR_4 -= 2;
        }

        if (VAR_4 < VAR_5)
            return FALSE;

        if (VAR_1 && (VAR_7 & VAR_11) == VAR_12) {
#ifdef VAR_13
            uint16_t *VAR_14 = (uint16_t*) VAR_0;
#else
            unsigned char *VAR_14 = VAR_0;
#endif
            int VAR_15 = (int)(VAR_6 - 2 - VAR_0) >> 1;
            uint32_t VAR_16 = (uint32_t) -1;

            if ((VAR_7 & VAR_17) || VAR_5 < 2 || VAR_5 > 4)
                return FALSE;

#ifdef VAR_13
            while (VAR_15--)
                VAR_16 = (VAR_16 * 3) + *VAR_14++;
#else
            WavpackNativeToLittleEndian ((WavpackHeader *) VAR_0, VAR_18);

            while (VAR_15--) {
                VAR_16 = (VAR_16 * 3) + VAR_14 [0] + (VAR_14 [1] << 8);
                VAR_14 += 2;
            }

            WavpackLittleEndianToNative ((WavpackHeader *) VAR_0, VAR_18);
#endif

            if (VAR_5 == 4) {
                if (*VAR_6 != (VAR_16 & 0xff) || VAR_6[1] != ((VAR_16 >> 8) & 0xff) || VAR_6[2] != ((VAR_16 >> 16) & 0xff) || VAR_6[3] != ((VAR_16 >> 24) & 0xff))
                    return FALSE;
            }
            else {
                VAR_16 ^= VAR_16 >> 16;

                if (*VAR_6 != (VAR_16 & 0xff) || VAR_6[1] != ((VAR_16 >> 8) & 0xff))
                    return FALSE;
            }

            VAR_3++;
        }

        VAR_4 -= VAR_5;
        VAR_6 += VAR_5;
    }

    return (VAR_4 == 0) && (!VAR_1 || !(VAR_2->flags & VAR_19) || VAR_3);
}",dbry/WavPack/bba5389dc598a92bdf2b297c3ea34620b6679b5b/open_utils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -57,13 +57,13 @@
 #endif
 
             if (meta_bc == 4) {
-                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))
+                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))
                     return FALSE;
             }
             else {
                 csum ^= csum >> 16;
 
-                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))
+                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))
                     return FALSE;
             }
 ","{'deleted_lines': ['                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))', '                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))'], 'added_lines': ['                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))', '                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))']}",True,"The function WavpackVerifySingleBlock in open_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (out-of-bounds read and application crash) via a crafted WavPack Lossless Audio file, as demonstrated by wvunpack.",5.5,MEDIUM,1,test,2018-11-30T05:53:51Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_scan_collect_last_primary,"void ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,
uint8_t *input_rows, size_t input_rows_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
scan_collect_last_primary(join_expr, join_expr_length,
input_rows, input_rows_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_scan_collect_last_primary(uint8_t *VAR_0, size_t VAR_1,
uint8_t *VAR_2, size_t VAR_3,
uint8_t **VAR_4, size_t *VAR_5) {
try {
scan_collect_last_primary(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5);
} catch (const std::runtime_error &VAR_6) {
ocall_throw(VAR_6.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/4.json,"void ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,
                                     uint8_t *input_rows, size_t input_rows_length,
                                     uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  sgx_lfence();

  try {
    scan_collect_last_primary(join_expr, join_expr_length,
                              input_rows, input_rows_length,
                              output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_scan_collect_last_primary(uint8_t *VAR_0, size_t VAR_1,
                                     uint8_t *VAR_2, size_t VAR_3,
                                     uint8_t **VAR_4, size_t *VAR_5) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  sgx_lfence();

  try {
    scan_collect_last_primary(VAR_0, VAR_1,
                              VAR_2, VAR_3,
                              VAR_4, VAR_5);
  } catch (const std::runtime_error &VAR_6) {
    ocall_throw(VAR_6.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,6 +1,10 @@
 void ecall_scan_collect_last_primary(uint8_t *join_expr, size_t join_expr_length,
                                      uint8_t *input_rows, size_t input_rows_length,
                                      uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  sgx_lfence();
+
   try {
     scan_collect_last_primary(join_expr, join_expr_length,
                               input_rows, input_rows_length,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_project,"void ecall_project(uint8_t *condition, size_t condition_length,
uint8_t *input_rows, size_t input_rows_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
project(condition, condition_length,
input_rows, input_rows_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_project(uint8_t *VAR_0, size_t VAR_1,
uint8_t *VAR_2, size_t VAR_3,
uint8_t **VAR_4, size_t *VAR_5) {
try {
project(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5);
} catch (const std::runtime_error &VAR_6) {
ocall_throw(VAR_6.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/2.json,"void ecall_project(uint8_t *condition, size_t condition_length,
                   uint8_t *input_rows, size_t input_rows_length,
                   uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  sgx_lfence();

  try {
    project(condition, condition_length,
            input_rows, input_rows_length,
            output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_project(uint8_t *VAR_0, size_t VAR_1,
                   uint8_t *VAR_2, size_t VAR_3,
                   uint8_t **VAR_4, size_t *VAR_5) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  sgx_lfence();

  try {
    project(VAR_0, VAR_1,
            VAR_2, VAR_3,
            VAR_4, VAR_5);
  } catch (const std::runtime_error &VAR_6) {
    ocall_throw(VAR_6.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,10 @@
 void ecall_project(uint8_t *condition, size_t condition_length,
                    uint8_t *input_rows, size_t input_rows_length,
                    uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  sgx_lfence();
+
   try {
     project(condition, condition_length,
             input_rows, input_rows_length,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_non_oblivious_aggregate_step1,"void ecall_non_oblivious_aggregate_step1(
uint8_t *agg_op, size_t agg_op_length,
uint8_t *input_rows, size_t input_rows_length,
uint8_t **first_row, size_t *first_row_length,
uint8_t **last_group, size_t *last_group_length,
uint8_t **last_row, size_t *last_row_length) {
try {
non_oblivious_aggregate_step1(
agg_op, agg_op_length,
input_rows, input_rows_length,
first_row, first_row_length,
last_group, last_group_length,
last_row, last_row_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_non_oblivious_aggregate_step1(
uint8_t *VAR_0, size_t VAR_1,
uint8_t *VAR_2, size_t VAR_3,
uint8_t **VAR_4, size_t *VAR_5,
uint8_t **VAR_6, size_t *VAR_7,
uint8_t **VAR_8, size_t *VAR_9) {
try {
non_oblivious_aggregate_step1(
VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5,
VAR_6, VAR_7,
VAR_8, VAR_9);
} catch (const std::runtime_error &VAR_10) {
ocall_throw(VAR_10.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/3.json,"void ecall_non_oblivious_aggregate_step1(
  uint8_t *agg_op, size_t agg_op_length,
  uint8_t *input_rows, size_t input_rows_length,
  uint8_t **first_row, size_t *first_row_length,
  uint8_t **last_group, size_t *last_group_length,
  uint8_t **last_row, size_t *last_row_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  sgx_lfence();

  try {
    non_oblivious_aggregate_step1(
      agg_op, agg_op_length,
      input_rows, input_rows_length,
      first_row, first_row_length,
      last_group, last_group_length,
      last_row, last_row_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_non_oblivious_aggregate_step1(
  uint8_t *VAR_0, size_t VAR_1,
  uint8_t *VAR_2, size_t VAR_3,
  uint8_t **VAR_4, size_t *VAR_5,
  uint8_t **VAR_6, size_t *VAR_7,
  uint8_t **VAR_8, size_t *VAR_9) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  sgx_lfence();

  try {
    non_oblivious_aggregate_step1(
      VAR_0, VAR_1,
      VAR_2, VAR_3,
      VAR_4, VAR_5,
      VAR_6, VAR_7,
      VAR_8, VAR_9);
  } catch (const std::runtime_error &VAR_10) {
    ocall_throw(VAR_10.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -4,6 +4,10 @@
   uint8_t **first_row, size_t *first_row_length,
   uint8_t **last_group, size_t *last_group_length,
   uint8_t **last_row, size_t *last_row_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  sgx_lfence();
+
   try {
     non_oblivious_aggregate_step1(
       agg_op, agg_op_length,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_non_oblivious_aggregate_step2,"void ecall_non_oblivious_aggregate_step2(
uint8_t *agg_op, size_t agg_op_length,
uint8_t *input_rows, size_t input_rows_length,
uint8_t *next_partition_first_row, size_t next_partition_first_row_length,
uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,
uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
non_oblivious_aggregate_step2(
agg_op, agg_op_length,
input_rows, input_rows_length,
next_partition_first_row, next_partition_first_row_length,
prev_partition_last_group, prev_partition_last_group_length,
prev_partition_last_row, prev_partition_last_row_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_non_oblivious_aggregate_step2(
uint8_t *VAR_0, size_t VAR_1,
uint8_t *VAR_2, size_t VAR_3,
uint8_t *VAR_4, size_t VAR_5,
uint8_t *VAR_6, size_t VAR_7,
uint8_t *VAR_8, size_t VAR_9,
uint8_t **VAR_10, size_t *VAR_11) {
try {
non_oblivious_aggregate_step2(
VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5,
VAR_6, VAR_7,
VAR_8, VAR_9,
VAR_10, VAR_11);
} catch (const std::runtime_error &VAR_12) {
ocall_throw(VAR_12.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/0.json,"void ecall_non_oblivious_aggregate_step2(
  uint8_t *agg_op, size_t agg_op_length,
  uint8_t *input_rows, size_t input_rows_length,
  uint8_t *next_partition_first_row, size_t next_partition_first_row_length,
  uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,
  uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,
  uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  assert(sgx_is_outside_enclave(next_partition_first_row, next_partition_first_row_length) == 1);
  assert(sgx_is_outside_enclave(prev_partition_last_group, prev_partition_last_group_length) == 1);
  assert(sgx_is_outside_enclave(prev_partition_last_row, prev_partition_last_row_length) == 1);
  sgx_lfence();

  try {
    non_oblivious_aggregate_step2(
      agg_op, agg_op_length,
      input_rows, input_rows_length,
      next_partition_first_row, next_partition_first_row_length,
      prev_partition_last_group, prev_partition_last_group_length,
      prev_partition_last_row, prev_partition_last_row_length,
      output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_non_oblivious_aggregate_step2(
  uint8_t *VAR_0, size_t VAR_1,
  uint8_t *VAR_2, size_t VAR_3,
  uint8_t *VAR_4, size_t VAR_5,
  uint8_t *VAR_6, size_t VAR_7,
  uint8_t *VAR_8, size_t VAR_9,
  uint8_t **VAR_10, size_t *VAR_11) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  assert(sgx_is_outside_enclave(VAR_4, VAR_5) == 1);
  assert(sgx_is_outside_enclave(VAR_6, VAR_7) == 1);
  assert(sgx_is_outside_enclave(VAR_8, VAR_9) == 1);
  sgx_lfence();

  try {
    non_oblivious_aggregate_step2(
      VAR_0, VAR_1,
      VAR_2, VAR_3,
      VAR_4, VAR_5,
      VAR_6, VAR_7,
      VAR_8, VAR_9,
      VAR_10, VAR_11);
  } catch (const std::runtime_error &VAR_12) {
    ocall_throw(VAR_12.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,13 @@
   uint8_t *prev_partition_last_group, size_t prev_partition_last_group_length,
   uint8_t *prev_partition_last_row, size_t prev_partition_last_row_length,
   uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  assert(sgx_is_outside_enclave(next_partition_first_row, next_partition_first_row_length) == 1);
+  assert(sgx_is_outside_enclave(prev_partition_last_group, prev_partition_last_group_length) == 1);
+  assert(sgx_is_outside_enclave(prev_partition_last_row, prev_partition_last_row_length) == 1);
+  sgx_lfence();
+
   try {
     non_oblivious_aggregate_step2(
       agg_op, agg_op_length,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  assert(sgx_is_outside_enclave(next_partition_first_row, next_partition_first_row_length) == 1);', '  assert(sgx_is_outside_enclave(prev_partition_last_group, prev_partition_last_group_length) == 1);', '  assert(sgx_is_outside_enclave(prev_partition_last_row, prev_partition_last_row_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_partition_for_sort,"void ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,
uint32_t num_partitions,
uint8_t *input_rows, size_t input_rows_length,
uint8_t *boundary_rows, size_t boundary_rows_length,
uint8_t **output_partitions, size_t *output_partition_lengths) {
try {
partition_for_sort(sort_order, sort_order_length,
num_partitions,
input_rows, input_rows_length,
boundary_rows, boundary_rows_length,
output_partitions, output_partition_lengths);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_partition_for_sort(uint8_t *VAR_0, size_t VAR_1,
uint32_t VAR_2,
uint8_t *VAR_3, size_t VAR_4,
uint8_t *VAR_5, size_t VAR_6,
uint8_t **VAR_7, size_t *VAR_8) {
try {
partition_for_sort(VAR_0, VAR_1,
VAR_2,
VAR_3, VAR_4,
VAR_5, VAR_6,
VAR_7, VAR_8);
} catch (const std::runtime_error &VAR_9) {
ocall_throw(VAR_9.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/1.json,"void ecall_partition_for_sort(uint8_t *sort_order, size_t sort_order_length,
                              uint32_t num_partitions,
                              uint8_t *input_rows, size_t input_rows_length,
                              uint8_t *boundary_rows, size_t boundary_rows_length,
                              uint8_t **output_partitions, size_t *output_partition_lengths) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  assert(sgx_is_outside_enclave(boundary_rows, boundary_rows_length) == 1);
  sgx_lfence();

  try {
    partition_for_sort(sort_order, sort_order_length,
                       num_partitions,
                       input_rows, input_rows_length,
                       boundary_rows, boundary_rows_length,
                       output_partitions, output_partition_lengths);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_partition_for_sort(uint8_t *VAR_0, size_t VAR_1,
                              uint32_t VAR_2,
                              uint8_t *VAR_3, size_t VAR_4,
                              uint8_t *VAR_5, size_t VAR_6,
                              uint8_t **VAR_7, size_t *VAR_8) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_3, VAR_4) == 1);
  assert(sgx_is_outside_enclave(VAR_5, VAR_6) == 1);
  sgx_lfence();

  try {
    partition_for_sort(VAR_0, VAR_1,
                       VAR_2,
                       VAR_3, VAR_4,
                       VAR_5, VAR_6,
                       VAR_7, VAR_8);
  } catch (const std::runtime_error &VAR_9) {
    ocall_throw(VAR_9.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,6 +3,11 @@
                               uint8_t *input_rows, size_t input_rows_length,
                               uint8_t *boundary_rows, size_t boundary_rows_length,
                               uint8_t **output_partitions, size_t *output_partition_lengths) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  assert(sgx_is_outside_enclave(boundary_rows, boundary_rows_length) == 1);
+  sgx_lfence();
+
   try {
     partition_for_sort(sort_order, sort_order_length,
                        num_partitions,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  assert(sgx_is_outside_enclave(boundary_rows, boundary_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_filter,"void ecall_filter(uint8_t *condition, size_t condition_length,
uint8_t *input_rows, size_t input_rows_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
filter(condition, condition_length,
input_rows, input_rows_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_filter(uint8_t *VAR_0, size_t VAR_1,
uint8_t *VAR_2, size_t VAR_3,
uint8_t **VAR_4, size_t *VAR_5) {
try {
filter(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5);
} catch (const std::runtime_error &VAR_6) {
ocall_throw(VAR_6.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/5.json,"void ecall_filter(uint8_t *condition, size_t condition_length,
                  uint8_t *input_rows, size_t input_rows_length,
                  uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  sgx_lfence();

  try {
    filter(condition, condition_length,
           input_rows, input_rows_length,
           output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_filter(uint8_t *VAR_0, size_t VAR_1,
                  uint8_t *VAR_2, size_t VAR_3,
                  uint8_t **VAR_4, size_t *VAR_5) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  sgx_lfence();

  try {
    filter(VAR_0, VAR_1,
           VAR_2, VAR_3,
           VAR_4, VAR_5);
  } catch (const std::runtime_error &VAR_6) {
    ocall_throw(VAR_6.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,6 +1,10 @@
 void ecall_filter(uint8_t *condition, size_t condition_length,
                   uint8_t *input_rows, size_t input_rows_length,
                   uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  sgx_lfence();
+
   try {
     filter(condition, condition_length,
            input_rows, input_rows_length,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_external_sort,"void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,
uint8_t *input_rows, size_t input_rows_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
external_sort(sort_order, sort_order_length,
input_rows, input_rows_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_external_sort(uint8_t *VAR_0, size_t VAR_1,
uint8_t *VAR_2, size_t VAR_3,
uint8_t **VAR_4, size_t *VAR_5) {
try {
external_sort(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5);
} catch (const std::runtime_error &VAR_6) {
ocall_throw(VAR_6.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/9.json,"void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,
                         uint8_t *input_rows, size_t input_rows_length,
                         uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  sgx_lfence();

  try {
    external_sort(sort_order, sort_order_length,
                  input_rows, input_rows_length,
                  output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_external_sort(uint8_t *VAR_0, size_t VAR_1,
                         uint8_t *VAR_2, size_t VAR_3,
                         uint8_t **VAR_4, size_t *VAR_5) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  sgx_lfence();

  try {
    external_sort(VAR_0, VAR_1,
                  VAR_2, VAR_3,
                  VAR_4, VAR_5);
  } catch (const std::runtime_error &VAR_6) {
    ocall_throw(VAR_6.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/9.json,"--- func_before
+++ func_after
@@ -1,6 +1,10 @@
 void ecall_external_sort(uint8_t *sort_order, size_t sort_order_length,
                          uint8_t *input_rows, size_t input_rows_length,
                          uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  sgx_lfence();
+
   try {
     external_sort(sort_order, sort_order_length,
                   input_rows, input_rows_length,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_sample,"void ecall_sample(uint8_t *input_rows, size_t input_rows_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
sample(input_rows, input_rows_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_sample(uint8_t *VAR_0, size_t VAR_1,
uint8_t **VAR_2, size_t *VAR_3) {
try {
sample(VAR_0, VAR_1,
VAR_2, VAR_3);
} catch (const std::runtime_error &VAR_4) {
ocall_throw(VAR_4.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/8.json,"void ecall_sample(uint8_t *input_rows, size_t input_rows_length,
                  uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  sgx_lfence();

  try {
    sample(input_rows, input_rows_length,
           output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_sample(uint8_t *VAR_0, size_t VAR_1,
                  uint8_t **VAR_2, size_t *VAR_3) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_0, VAR_1) == 1);
  sgx_lfence();

  try {
    sample(VAR_0, VAR_1,
           VAR_2, VAR_3);
  } catch (const std::runtime_error &VAR_4) {
    ocall_throw(VAR_4.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/8.json,"--- func_before
+++ func_after
@@ -1,5 +1,9 @@
 void ecall_sample(uint8_t *input_rows, size_t input_rows_length,
                   uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  sgx_lfence();
+
   try {
     sample(input_rows, input_rows_length,
            output_rows, output_rows_length);","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_non_oblivious_sort_merge_join,"void ecall_non_oblivious_sort_merge_join(uint8_t *join_expr, size_t join_expr_length,
uint8_t *input_rows, size_t input_rows_length,
uint8_t *join_row, size_t join_row_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
non_oblivious_sort_merge_join(join_expr, join_expr_length,
input_rows, input_rows_length,
join_row, join_row_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_non_oblivious_sort_merge_join(uint8_t *VAR_0, size_t VAR_1,
uint8_t *VAR_2, size_t VAR_3,
uint8_t *VAR_4, size_t VAR_5,
uint8_t **VAR_6, size_t *VAR_7) {
try {
non_oblivious_sort_merge_join(VAR_0, VAR_1,
VAR_2, VAR_3,
VAR_4, VAR_5,
VAR_6, VAR_7);
} catch (const std::runtime_error &VAR_8) {
ocall_throw(VAR_8.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/6.json,"void ecall_non_oblivious_sort_merge_join(uint8_t *join_expr, size_t join_expr_length,
                                         uint8_t *input_rows, size_t input_rows_length,
                                         uint8_t *join_row, size_t join_row_length,
                                         uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  assert(sgx_is_outside_enclave(join_row, join_row_length) == 1);
  sgx_lfence();

  try {
    non_oblivious_sort_merge_join(join_expr, join_expr_length,
                                  input_rows, input_rows_length,
                                  join_row, join_row_length,
                                  output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_non_oblivious_sort_merge_join(uint8_t *VAR_0, size_t VAR_1,
                                         uint8_t *VAR_2, size_t VAR_3,
                                         uint8_t *VAR_4, size_t VAR_5,
                                         uint8_t **VAR_6, size_t *VAR_7) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  assert(sgx_is_outside_enclave(VAR_4, VAR_5) == 1);
  sgx_lfence();

  try {
    non_oblivious_sort_merge_join(VAR_0, VAR_1,
                                  VAR_2, VAR_3,
                                  VAR_4, VAR_5,
                                  VAR_6, VAR_7);
  } catch (const std::runtime_error &VAR_8) {
    ocall_throw(VAR_8.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/6.json,"--- func_before
+++ func_after
@@ -2,6 +2,11 @@
                                          uint8_t *input_rows, size_t input_rows_length,
                                          uint8_t *join_row, size_t join_row_length,
                                          uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  assert(sgx_is_outside_enclave(join_row, join_row_length) == 1);
+  sgx_lfence();
+
   try {
     non_oblivious_sort_merge_join(join_expr, join_expr_length,
                                   input_rows, input_rows_length,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  assert(sgx_is_outside_enclave(join_row, join_row_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_find_range_bounds,"void ecall_find_range_bounds(uint8_t *sort_order, size_t sort_order_length,
uint32_t num_partitions,
uint8_t *input_rows, size_t input_rows_length,
uint8_t **output_rows, size_t *output_rows_length) {
try {
find_range_bounds(sort_order, sort_order_length,
num_partitions,
input_rows, input_rows_length,
output_rows, output_rows_length);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_find_range_bounds(uint8_t *VAR_0, size_t VAR_1,
uint32_t VAR_2,
uint8_t *VAR_3, size_t VAR_4,
uint8_t **VAR_5, size_t *VAR_6) {
try {
find_range_bounds(VAR_0, VAR_1,
VAR_2,
VAR_3, VAR_4,
VAR_5, VAR_6);
} catch (const std::runtime_error &VAR_7) {
ocall_throw(VAR_7.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/7.json,"void ecall_find_range_bounds(uint8_t *sort_order, size_t sort_order_length,
                             uint32_t num_partitions,
                             uint8_t *input_rows, size_t input_rows_length,
                             uint8_t **output_rows, size_t *output_rows_length) {
  // Guard against operating on arbitrary enclave memory
  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
  sgx_lfence();

  try {
    find_range_bounds(sort_order, sort_order_length,
                      num_partitions,
                      input_rows, input_rows_length,
                      output_rows, output_rows_length);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_find_range_bounds(uint8_t *VAR_0, size_t VAR_1,
                             uint32_t VAR_2,
                             uint8_t *VAR_3, size_t VAR_4,
                             uint8_t **VAR_5, size_t *VAR_6) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_3, VAR_4) == 1);
  sgx_lfence();

  try {
    find_range_bounds(VAR_0, VAR_1,
                      VAR_2,
                      VAR_3, VAR_4,
                      VAR_5, VAR_6);
  } catch (const std::runtime_error &VAR_7) {
    ocall_throw(VAR_7.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/7.json,"--- func_before
+++ func_after
@@ -2,6 +2,10 @@
                              uint32_t num_partitions,
                              uint8_t *input_rows, size_t input_rows_length,
                              uint8_t **output_rows, size_t *output_rows_length) {
+  // Guard against operating on arbitrary enclave memory
+  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);
+  sgx_lfence();
+
   try {
     find_range_bounds(sort_order, sort_order_length,
                       num_partitions,","{'deleted_lines': [], 'added_lines': ['  // Guard against operating on arbitrary enclave memory', '  assert(sgx_is_outside_enclave(input_rows, input_rows_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-20742,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0.0,mc2-project/opaque-sql,"Check that ecall [user_check] pointers and ocall_malloc result pointer are outside enclave (#67)

This should reduce the enclave's attack surface by preventing an attacker from invoking ecalls on or triggering unexpected writes to arbitrary enclave memory, which could potentially leak information about that memory or lead to incorrect results.

Fixes #36. Fixes #66.",5ddda15d89f5ac82f4416208c5319ace4aecdc36,https://github.com/mc2-project/opaque-sql/commit/5ddda15d89f5ac82f4416208c5319ace4aecdc36,src/enclave/Enclave/Enclave.cpp,ecall_encrypt,"void ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,
uint8_t *ciphertext, uint32_t cipher_length) {
try {
assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);
(void)cipher_length;
(void)plaintext_length;
encrypt(plaintext, plaintext_length, ciphertext);
} catch (const std::runtime_error &e) {
ocall_throw(e.what());
}
}","void ecall_encrypt(uint8_t *VAR_0, uint32_t VAR_1,
uint8_t *VAR_2, uint32_t VAR_3) {
try {
assert(VAR_3 >= VAR_1 + VAR_4 + VAR_5);
(void)VAR_3;
(void)VAR_1;
encrypt(VAR_0, VAR_1, VAR_2);
} catch (const std::runtime_error &VAR_6) {
ocall_throw(VAR_6.what());
}
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/before/10.json,"void ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,
                   uint8_t *ciphertext, uint32_t cipher_length) {
  // Guard against encrypting or overwriting enclave memory
  assert(sgx_is_outside_enclave(plaintext, plaintext_length) == 1);
  assert(sgx_is_outside_enclave(ciphertext, cipher_length) == 1);
  sgx_lfence();

  try {
    // IV (12 bytes) + ciphertext + mac (16 bytes)
    assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);
    (void)cipher_length;
    (void)plaintext_length;
    encrypt(plaintext, plaintext_length, ciphertext);
  } catch (const std::runtime_error &e) {
    ocall_throw(e.what());
  }
}","void ecall_encrypt(uint8_t *VAR_0, uint32_t VAR_1,
                   uint8_t *VAR_2, uint32_t VAR_3) {
  /* COMMENT_0 */
  assert(sgx_is_outside_enclave(VAR_0, VAR_1) == 1);
  assert(sgx_is_outside_enclave(VAR_2, VAR_3) == 1);
  sgx_lfence();

  try {
    /* COMMENT_1 */
    assert(VAR_3 >= VAR_1 + VAR_4 + VAR_5);
    (void)VAR_3;
    (void)VAR_1;
    encrypt(VAR_0, VAR_1, VAR_2);
  } catch (const std::runtime_error &VAR_6) {
    ocall_throw(VAR_6.what());
  }
}",mc2-project/opaque-sql/5ddda15d89f5ac82f4416208c5319ace4aecdc36/Enclave.cpp/vul/after/10.json,"--- func_before
+++ func_after
@@ -1,5 +1,10 @@
 void ecall_encrypt(uint8_t *plaintext, uint32_t plaintext_length,
                    uint8_t *ciphertext, uint32_t cipher_length) {
+  // Guard against encrypting or overwriting enclave memory
+  assert(sgx_is_outside_enclave(plaintext, plaintext_length) == 1);
+  assert(sgx_is_outside_enclave(ciphertext, cipher_length) == 1);
+  sgx_lfence();
+
   try {
     // IV (12 bytes) + ciphertext + mac (16 bytes)
     assert(cipher_length >= plaintext_length + SGX_AESGCM_IV_SIZE + SGX_AESGCM_MAC_SIZE);","{'deleted_lines': [], 'added_lines': ['  // Guard against encrypting or overwriting enclave memory', '  assert(sgx_is_outside_enclave(plaintext, plaintext_length) == 1);', '  assert(sgx_is_outside_enclave(ciphertext, cipher_length) == 1);', '  sgx_lfence();', '']}",True,An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.,7.5,HIGH,2,test,2018-12-01T09:11:22Z,2
CVE-2018-19797,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sass/libsass,"Disallow parent selector in selector_fns arguments

Fixes #2779

sass-spec: https://github.com/sass/sass-spec/pull/1320",75ddbb90468c4bbc21140fe0d37291314bc26ff8,https://github.com/sass/libsass/commit/75ddbb90468c4bbc21140fe0d37291314bc26ff8,src/fn_utils.cpp,get_arg_sels,"Selector_List_Obj get_arg_sels(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) {
Expression_Obj exp = ARG(argname, Expression);
if (exp->concrete_type() == Expression::NULL_VAL) {
std::stringstream msg;
msg << argname << "": null is not a valid selector: it must be a string,\n"";
msg << ""a list of strings, or a list of lists of strings for `"" << function_name(sig) << ""'"";
error(msg.str(), exp->pstate(), traces);
}
if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
str->quote_mark(0);
}
std::string exp_src = exp->to_string(ctx.c_options);
return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
}","Selector_List_Obj get_arg_sels(const std::string& VAR_0, Env& VAR_1, Signature VAR_2, ParserState VAR_3, Backtraces VAR_4, Context& VAR_5) {
Expression_Obj VAR_6 = ARG(VAR_0, VAR_7);
if (VAR_6->concrete_type() == Expression::NULL_VAL) {
std::stringstream VAR_8;
VAR_8 << VAR_0 << "": null is not a valid selector: it must be a string,\n"";
VAR_8 << ""a list of strings, or a list of lists of strings for `"" << function_name(VAR_2) << ""'"";
error(VAR_8.str(), VAR_6->pstate(), VAR_4);
}
if (String_Constant_Ptr VAR_9 = VAR_10<String_Constant>(VAR_6)) {
VAR_9->quote_mark(0);
}
std::string VAR_11 = VAR_6->to_string(VAR_5.c_options);
return Parser::parse_selector(VAR_11.c_str(), VAR_5, VAR_4, VAR_6->pstate(), VAR_3.src);
}",sass/libsass/75ddbb90468c4bbc21140fe0d37291314bc26ff8/fn_utils.cpp/vul/before/0.json,"Selector_List_Obj get_arg_sels(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) {
      Expression_Obj exp = ARG(argname, Expression);
      if (exp->concrete_type() == Expression::NULL_VAL) {
        std::stringstream msg;
        msg << argname << "": null is not a valid selector: it must be a string,\n"";
        msg << ""a list of strings, or a list of lists of strings for `"" << function_name(sig) << ""'"";
        error(msg.str(), exp->pstate(), traces);
      }
      if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
        str->quote_mark(0);
      }
      std::string exp_src = exp->to_string(ctx.c_options);
      return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, /*allow_parent=*/false);
    }","Selector_List_Obj get_arg_sels(const std::string& VAR_0, Env& VAR_1, Signature VAR_2, ParserState VAR_3, Backtraces VAR_4, Context& VAR_5) {
      Expression_Obj VAR_6 = ARG(VAR_0, VAR_7);
      if (VAR_6->concrete_type() == Expression::NULL_VAL) {
        std::stringstream VAR_8;
        VAR_8 << VAR_0 << "": null is not a valid selector: it must be a string,\n"";
        VAR_8 << ""a list of strings, or a list of lists of strings for `"" << function_name(VAR_2) << ""'"";
        error(VAR_8.str(), VAR_6->pstate(), VAR_4);
      }
      if (String_Constant_Ptr VAR_9 = VAR_10<String_Constant>(VAR_6)) {
        VAR_9->quote_mark(0);
      }
      std::string VAR_11 = VAR_6->to_string(VAR_5.c_options);
      return Parser::parse_selector(VAR_11.c_str(), VAR_5, VAR_4, VAR_6->pstate(), VAR_3.src, /* COMMENT_0 */false);
    }",sass/libsass/75ddbb90468c4bbc21140fe0d37291314bc26ff8/fn_utils.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,5 +10,5 @@
         str->quote_mark(0);
       }
       std::string exp_src = exp->to_string(ctx.c_options);
-      return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
+      return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, /*allow_parent=*/false);
     }","{'deleted_lines': ['      return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);'], 'added_lines': ['      return Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, /*allow_parent=*/false);']}",True,"In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Selector_List::populate_extends in SharedPtr.hpp (used by ast.cpp and ast_selectors.cpp) may cause a Denial of Service (application crash) via a crafted sass input file.",6.5,MEDIUM,1,test,2018-12-02T15:22:36Z,2
CVE-2018-19797,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sass/libsass,"Disallow parent selector in selector_fns arguments

Fixes #2779

sass-spec: https://github.com/sass/sass-spec/pull/1320",75ddbb90468c4bbc21140fe0d37291314bc26ff8,https://github.com/sass/libsass/commit/75ddbb90468c4bbc21140fe0d37291314bc26ff8,src/fn_utils.cpp,get_arg_sel,"Compound_Selector_Obj get_arg_sel(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) {
Expression_Obj exp = ARG(argname, Expression);
if (exp->concrete_type() == Expression::NULL_VAL) {
std::stringstream msg;
msg << argname << "": null is not a string for `"" << function_name(sig) << ""'"";
error(msg.str(), exp->pstate(), traces);
}
if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
str->quote_mark(0);
}
std::string exp_src = exp->to_string(ctx.c_options);
Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
if (sel_list->length() == 0) return {};
Complex_Selector_Obj first = sel_list->first();
if (!first->tail()) return first->head();
return first->tail()->head();
}","Compound_Selector_Obj get_arg_sel(const std::string& VAR_0, Env& VAR_1, Signature VAR_2, ParserState VAR_3, Backtraces VAR_4, Context& VAR_5) {
Expression_Obj VAR_6 = ARG(VAR_0, VAR_7);
if (VAR_6->concrete_type() == Expression::NULL_VAL) {
std::stringstream VAR_8;
VAR_8 << VAR_0 << "": null is not a string for `"" << function_name(VAR_2) << ""'"";
error(VAR_8.str(), VAR_6->pstate(), VAR_4);
}
if (String_Constant_Ptr VAR_9 = VAR_10<String_Constant>(VAR_6)) {
VAR_9->quote_mark(0);
}
std::string VAR_11 = VAR_6->to_string(VAR_5.c_options);
Selector_List_Obj VAR_12 = Parser::parse_selector(VAR_11.c_str(), VAR_5, VAR_4, VAR_6->pstate(), VAR_3.src);
if (VAR_12->length() == 0) return {};
Complex_Selector_Obj VAR_13 = VAR_12->first();
if (!VAR_13->tail()) return VAR_13->head();
return VAR_13->tail()->head();
}",sass/libsass/75ddbb90468c4bbc21140fe0d37291314bc26ff8/fn_utils.cpp/vul/before/1.json,"Compound_Selector_Obj get_arg_sel(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) {
      Expression_Obj exp = ARG(argname, Expression);
      if (exp->concrete_type() == Expression::NULL_VAL) {
        std::stringstream msg;
        msg << argname << "": null is not a string for `"" << function_name(sig) << ""'"";
        error(msg.str(), exp->pstate(), traces);
      }
      if (String_Constant_Ptr str = Cast<String_Constant>(exp)) {
        str->quote_mark(0);
      }
      std::string exp_src = exp->to_string(ctx.c_options);
      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, /*allow_parent=*/false);
      if (sel_list->length() == 0) return {};
      Complex_Selector_Obj first = sel_list->first();
      if (!first->tail()) return first->head();
      return first->tail()->head();
    }","Compound_Selector_Obj get_arg_sel(const std::string& VAR_0, Env& VAR_1, Signature VAR_2, ParserState VAR_3, Backtraces VAR_4, Context& VAR_5) {
      Expression_Obj VAR_6 = ARG(VAR_0, VAR_7);
      if (VAR_6->concrete_type() == Expression::NULL_VAL) {
        std::stringstream VAR_8;
        VAR_8 << VAR_0 << "": null is not a string for `"" << function_name(VAR_2) << ""'"";
        error(VAR_8.str(), VAR_6->pstate(), VAR_4);
      }
      if (String_Constant_Ptr VAR_9 = VAR_10<String_Constant>(VAR_6)) {
        VAR_9->quote_mark(0);
      }
      std::string VAR_11 = VAR_6->to_string(VAR_5.c_options);
      Selector_List_Obj VAR_12 = Parser::parse_selector(VAR_11.c_str(), VAR_5, VAR_4, VAR_6->pstate(), VAR_3.src, /* COMMENT_0 */false);
      if (VAR_12->length() == 0) return {};
      Complex_Selector_Obj VAR_13 = VAR_12->first();
      if (!VAR_13->tail()) return VAR_13->head();
      return VAR_13->tail()->head();
    }",sass/libsass/75ddbb90468c4bbc21140fe0d37291314bc26ff8/fn_utils.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
         str->quote_mark(0);
       }
       std::string exp_src = exp->to_string(ctx.c_options);
-      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);
+      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, /*allow_parent=*/false);
       if (sel_list->length() == 0) return {};
       Complex_Selector_Obj first = sel_list->first();
       if (!first->tail()) return first->head();","{'deleted_lines': ['      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src);'], 'added_lines': ['      Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, /*allow_parent=*/false);']}",True,"In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Selector_List::populate_extends in SharedPtr.hpp (used by ast.cpp and ast_selectors.cpp) may cause a Denial of Service (application crash) via a crafted sass input file.",6.5,MEDIUM,1,test,2018-12-02T15:22:36Z,2
CVE-2018-20760,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,gpac,check error code on call to gf_utf8_wcstombs (#1177),4c1360818fc8948e9307059fba4dc47ba8ad255d,https://github.com/gpac/gpac/commit/4c1360818fc8948e9307059fba4dc47ba8ad255d,src/media_tools/text_import.c,gf_text_get_utf8_line,"char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)
{
u32 i, j, len;
char *sOK;
char szLineConv[1024];
unsigned short *sptr;
memset(szLine, 0, sizeof(char)*lineSize);
sOK = fgets(szLine, lineSize, txt_in);
if (!sOK) return NULL;
if (unicode_type<=1) {
j=0;
len = (u32) strlen(szLine);
for (i=0; i<len; i++) {
if (!unicode_type && (szLine[i] & 0x80)) {
if ((szLine[i+1] & 0xc0) != 0x80) {
szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
j++;
szLine[i] &= 0xbf;
}
else if ( (szLine[i] & 0xe0) == 0xc0) {
szLineConv[j] = szLine[i];
i++;
j++;
}
else if ( (szLine[i] & 0xf0) == 0xe0) {
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
}
else if ( (szLine[i] & 0xf8) == 0xf0) {
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
szLineConv[j] = szLine[i];
i++;
j++;
} else {
i+=1;
continue;
}
}
szLineConv[j] = szLine[i];
j++;
}
szLineConv[j] = 0;
strcpy(szLine, szLineConv);
return sOK;
}
#ifdef GPAC_BIG_ENDIAN
if (unicode_type==3) {
#else
if (unicode_type==2) {
#endif
i=0;
while (1) {
char c;
if (!szLine[i] && !szLine[i+1]) break;
c = szLine[i+1];
szLine[i+1] = szLine[i];
szLine[i] = c;
i+=2;
}
}
sptr = (u16 *)szLine;
i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
szLineConv[i] = 0;
strcpy(szLine, szLineConv);
if (unicode_type==3) fgetc(txt_in);
return sOK;
}","char *gf_text_get_utf8_line(char *VAR_0, u32 VAR_1, FILE *VAR_2, s32 VAR_3)
{
u32 VAR_4, VAR_5, VAR_6;
char *VAR_7;
char VAR_8[1024];
unsigned short *VAR_9;
memset(VAR_0, 0, sizeof(char)*VAR_1);
VAR_7 = fgets(VAR_0, VAR_1, VAR_2);
if (!VAR_7) return NULL;
if (VAR_3<=1) {
VAR_5=0;
VAR_6 = (u32) strlen(VAR_0);
for (VAR_4=0; VAR_4<VAR_6; VAR_4++) {
if (!VAR_3 && (VAR_0[VAR_4] & 0x80)) {
if ((VAR_0[VAR_4+1] & 0xc0) != 0x80) {
VAR_8[VAR_5] = 0xc0 | ( (VAR_0[VAR_4] >> 6) & 0x3 );
VAR_5++;
VAR_0[VAR_4] &= 0xbf;
}
else if ( (VAR_0[VAR_4] & 0xe0) == 0xc0) {
VAR_8[VAR_5] = VAR_0[VAR_4];
VAR_4++;
VAR_5++;
}
else if ( (VAR_0[VAR_4] & 0xf0) == 0xe0) {
VAR_8[VAR_5] = VAR_0[VAR_4];
VAR_4++;
VAR_5++;
VAR_8[VAR_5] = VAR_0[VAR_4];
VAR_4++;
VAR_5++;
}
else if ( (VAR_0[VAR_4] & 0xf8) == 0xf0) {
VAR_8[VAR_5] = VAR_0[VAR_4];
VAR_4++;
VAR_5++;
VAR_8[VAR_5] = VAR_0[VAR_4];
VAR_4++;
VAR_5++;
VAR_8[VAR_5] = VAR_0[VAR_4];
VAR_4++;
VAR_5++;
} else {
VAR_4+=1;
continue;
}
}
VAR_8[VAR_5] = VAR_0[VAR_4];
VAR_5++;
}
VAR_8[VAR_5] = 0;
strcpy(VAR_0, VAR_8);
return VAR_7;
}
#ifdef VAR_10
if (VAR_3==3) {
#else
if (unicode_type==2) {
#endif
i=0;
while (1) {
char VAR_11;
if (!VAR_0[VAR_4] && !VAR_0[VAR_4+1]) break;
VAR_11 = VAR_0[VAR_4+1];
VAR_0[VAR_4+1] = VAR_0[VAR_4];
VAR_0[VAR_4] = VAR_11;
VAR_4+=2;
}
}
VAR_9 = (u16 *)VAR_0;
VAR_4 = (u32) gf_utf8_wcstombs(VAR_8, 1024, (const unsigned short **) &VAR_9);
VAR_8[VAR_4] = 0;
strcpy(VAR_0, VAR_8);
if (VAR_3==3) fgetc(VAR_2);
return VAR_7;
}",gpac/4c1360818fc8948e9307059fba4dc47ba8ad255d/text_import.c/vul/before/0.json,"char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)
{
	u32 i, j, len;
	char *sOK;
	char szLineConv[1024];
	unsigned short *sptr;

	memset(szLine, 0, sizeof(char)*lineSize);
	sOK = fgets(szLine, lineSize, txt_in);
	if (!sOK) return NULL;
	if (unicode_type<=1) {
		j=0;
		len = (u32) strlen(szLine);
		for (i=0; i<len; i++) {
			if (!unicode_type && (szLine[i] & 0x80)) {
				/*non UTF8 (likely some win-CP)*/
				if ((szLine[i+1] & 0xc0) != 0x80) {
					szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
					j++;
					szLine[i] &= 0xbf;
				}
				/*UTF8 2 bytes char*/
				else if ( (szLine[i] & 0xe0) == 0xc0) {
					szLineConv[j] = szLine[i];
					i++;
					j++;
				}
				/*UTF8 3 bytes char*/
				else if ( (szLine[i] & 0xf0) == 0xe0) {
					szLineConv[j] = szLine[i];
					i++;
					j++;
					szLineConv[j] = szLine[i];
					i++;
					j++;
				}
				/*UTF8 4 bytes char*/
				else if ( (szLine[i] & 0xf8) == 0xf0) {
					szLineConv[j] = szLine[i];
					i++;
					j++;
					szLineConv[j] = szLine[i];
					i++;
					j++;
					szLineConv[j] = szLine[i];
					i++;
					j++;
				} else {
					i+=1;
					continue;
				}
			}
			szLineConv[j] = szLine[i];
			j++;
		}
		szLineConv[j] = 0;
		strcpy(szLine, szLineConv);
		return sOK;
	}

#ifdef GPAC_BIG_ENDIAN
	if (unicode_type==3) {
#else
	if (unicode_type==2) {
#endif
		i=0;
		while (1) {
			char c;
			if (!szLine[i] && !szLine[i+1]) break;
			c = szLine[i+1];
			szLine[i+1] = szLine[i];
			szLine[i] = c;
			i+=2;
		}
	}
	sptr = (u16 *)szLine;
	i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
	if (i >= (u32)ARRAY_LENGTH(szLineConv))
		return NULL;
	szLineConv[i] = 0;
	strcpy(szLine, szLineConv);
	/*this is ugly indeed: since input is UTF16-LE, there are many chances the fgets never reads the \0 after a \n*/
	if (unicode_type==3) fgetc(txt_in);
	return sOK;
}","char *gf_text_get_utf8_line(char *VAR_0, u32 VAR_1, FILE *VAR_2, s32 VAR_3)
{
	u32 VAR_4, VAR_5, VAR_6;
	char *VAR_7;
	char VAR_8[1024];
	unsigned short *VAR_9;

	memset(VAR_0, 0, sizeof(char)*VAR_1);
	VAR_7 = fgets(VAR_0, VAR_1, VAR_2);
	if (!VAR_7) return NULL;
	if (VAR_3<=1) {
		VAR_5=0;
		VAR_6 = (u32) strlen(VAR_0);
		for (VAR_4=0; VAR_4<VAR_6; VAR_4++) {
			if (!VAR_3 && (VAR_0[VAR_4] & 0x80)) {
				/* COMMENT_0 */
				if ((VAR_0[VAR_4+1] & 0xc0) != 0x80) {
					VAR_8[VAR_5] = 0xc0 | ( (VAR_0[VAR_4] >> 6) & 0x3 );
					VAR_5++;
					VAR_0[VAR_4] &= 0xbf;
				}
				/* COMMENT_1 */
				else if ( (VAR_0[VAR_4] & 0xe0) == 0xc0) {
					VAR_8[VAR_5] = VAR_0[VAR_4];
					VAR_4++;
					VAR_5++;
				}
				/* COMMENT_2 */
				else if ( (VAR_0[VAR_4] & 0xf0) == 0xe0) {
					VAR_8[VAR_5] = VAR_0[VAR_4];
					VAR_4++;
					VAR_5++;
					VAR_8[VAR_5] = VAR_0[VAR_4];
					VAR_4++;
					VAR_5++;
				}
				/* COMMENT_3 */
				else if ( (VAR_0[VAR_4] & 0xf8) == 0xf0) {
					VAR_8[VAR_5] = VAR_0[VAR_4];
					VAR_4++;
					VAR_5++;
					VAR_8[VAR_5] = VAR_0[VAR_4];
					VAR_4++;
					VAR_5++;
					VAR_8[VAR_5] = VAR_0[VAR_4];
					VAR_4++;
					VAR_5++;
				} else {
					VAR_4+=1;
					continue;
				}
			}
			VAR_8[VAR_5] = VAR_0[VAR_4];
			VAR_5++;
		}
		VAR_8[VAR_5] = 0;
		strcpy(VAR_0, VAR_8);
		return VAR_7;
	}

#ifdef VAR_10
	if (VAR_3==3) {
#else
	if (unicode_type==2) {
#endif
		i=0;
		while (1) {
			char VAR_11;
			if (!VAR_0[VAR_4] && !VAR_0[VAR_4+1]) break;
			VAR_11 = VAR_0[VAR_4+1];
			VAR_0[VAR_4+1] = VAR_0[VAR_4];
			VAR_0[VAR_4] = VAR_11;
			VAR_4+=2;
		}
	}
	VAR_9 = (u16 *)VAR_0;
	VAR_4 = (u32) gf_utf8_wcstombs(VAR_8, 1024, (const unsigned short **) &VAR_9);
	if (VAR_4 >= (u32)ARRAY_LENGTH(VAR_8))
		return NULL;
	VAR_8[VAR_4] = 0;
	strcpy(VAR_0, VAR_8);
	/* COMMENT_4 */
	if (VAR_3==3) fgetc(VAR_2);
	return VAR_7;
}",gpac/4c1360818fc8948e9307059fba4dc47ba8ad255d/text_import.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -75,6 +75,8 @@
 	}
 	sptr = (u16 *)szLine;
 	i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
+	if (i >= (u32)ARRAY_LENGTH(szLineConv))
+		return NULL;
 	szLineConv[i] = 0;
 	strcpy(szLine, szLineConv);
 	/*this is ugly indeed: since input is UTF16-LE, there are many chances the fgets never reads the \0 after a \n*/","{'deleted_lines': [], 'added_lines': ['\tif (i >= (u32)ARRAY_LENGTH(szLineConv))', '\t\treturn NULL;']}",True,"In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because a certain -1 return value is mishandled.",7.8,HIGH,2,test,2018-12-13T13:39:21Z,2
CVE-2019-3804,['CWE-909'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,cockpit-project/cockpit,"ws: Fix bug parsing invalid base64 headers

The len parameter to g_base64_decode_inplace() is a inout
parameter, and needs to be initialized. Lets just use
the simpler g_base64_decode() function. This fixes a segfault.

Closes #10819",c51f6177576d7e12,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,src/ws/cockpitauth.c,base64_decode_string,"static char *
base64_decode_string (const char *enc)
{
if (enc == NULL)
return NULL;
char *dec = g_strdup (enc);
gsize len;
g_base64_decode_inplace (dec, &len);
dec[len] = '\0';
return dec;
}","static char *
base64_decode_string (const char *VAR_0)
{
if (VAR_0 == NULL)
return NULL;
char *VAR_1 = g_strdup (VAR_0);
gsize VAR_2;
g_base64_decode_inplace (VAR_1, &VAR_2);
VAR_1[VAR_2] = '\0';
return VAR_1;
}",cockpit-project/cockpit/c51f6177576d7e12/cockpitauth.c/vul/before/0.json,"static gchar *
base64_decode_string (const char *enc)
{
  gchar *dec;
  gsize len;

  if (enc == NULL)
    return NULL;

  dec = (gchar *)g_base64_decode (enc, &len);
  if (dec)
    dec[len] = '\0';

  return dec;
}","static gchar *
base64_decode_string (const char *VAR_0)
{
  gchar *VAR_1;
  gsize VAR_2;

  if (VAR_0 == NULL)
    return NULL;

  VAR_1 = (gchar *)g_base64_decode (VAR_0, &VAR_2);
  if (VAR_1)
    VAR_1[VAR_2] = '\0';

  return VAR_1;
}",cockpit-project/cockpit/c51f6177576d7e12/cockpitauth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,12 +1,15 @@
-static char *
+static gchar *
 base64_decode_string (const char *enc)
 {
+  gchar *dec;
+  gsize len;
+
   if (enc == NULL)
     return NULL;
 
-  char *dec = g_strdup (enc);
-  gsize len;
-  g_base64_decode_inplace (dec, &len);
-  dec[len] = '\0';
+  dec = (gchar *)g_base64_decode (enc, &len);
+  if (dec)
+    dec[len] = '\0';
+
   return dec;
 }","{'deleted_lines': ['static char *', '  char *dec = g_strdup (enc);', '  gsize len;', '  g_base64_decode_inplace (dec, &len);', ""  dec[len] = '\\0';""], 'added_lines': ['static gchar *', '  gchar *dec;', '  gsize len;', '', '  dec = (gchar *)g_base64_decode (enc, &len);', '  if (dec)', ""    dec[len] = '\\0';"", '']}",True,It was found that cockpit before version 184 used glib's base64 decode functionality incorrectly resulting in a denial of service attack. An unauthenticated attacker could send a specially crafted request with an invalid base64-encoded cookie which could cause the web service to crash.,7.5,HIGH,2,test,2018-12-13T14:12:44Z,2
CVE-2018-19661,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,libsndfile,"a/ulaw: fix multiple buffer overflows

i2ulaw_array() and i2alaw_array() fail to handle ptr [count] = INT_MIN
properly, leading to buffer underflow. INT_MIN is a special value
since - INT_MIN cannot be represented as int.

In this case round - INT_MIN to INT_MAX and proceed as usual.

f2ulaw_array() and f2alaw_array() fail to handle ptr [count] = NaN
properly, leading to null pointer dereference.

In this case, arbitrarily set the buffer value to 0.

This commit fixes #429 (CVE-2018-19661 and CVE-2018-19662) and
fixes #344 (CVE-2017-17456 and CVE-2017-17457).",c4dd30d69b070a3cb32b4bf74c47a8163b1916da,https://github.com/libsndfile/libsndfile/commit/c4dd30d69b070a3cb32b4bf74c47a8163b1916da,src/ulaw.c,i2ulaw_array,"static inline void
i2ulaw_array (const int *ptr, int count, unsigned char *buffer)
{while (--count >= 0)
{if (ptr [count] >= 0)
buffer [count] = ulaw_encode [ptr [count] >> (16 + 2)] ;
else
buffer [count] = 0x7F & ulaw_encode [-ptr [count] >> (16 + 2)] ;
} ;
}","static inline void
i2ulaw_array (const int *VAR_0, int VAR_1, unsigned char *VAR_2)
{while (--VAR_1 >= 0)
{if (VAR_0 [VAR_1] >= 0)
VAR_2 [VAR_1] = VAR_3 [VAR_0 [VAR_1] >> (16 + 2)] ;
else
VAR_2 [VAR_1] = 0x7F & VAR_3 [-VAR_0 [VAR_1] >> (16 + 2)] ;
} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/ulaw.c/vul/before/1.json,"static inline void
i2ulaw_array (const int *ptr, int count, unsigned char *buffer)
{	while (--count >= 0)
	{	if (ptr [count] == INT_MIN)
			buffer [count] = ulaw_encode [INT_MAX >> (16 + 2)] ;
		else if (ptr [count] >= 0)
			buffer [count] = ulaw_encode [ptr [count] >> (16 + 2)] ;
		else
			buffer [count] = 0x7F & ulaw_encode [-ptr [count] >> (16 + 2)] ;
		} ;
}","static inline void
i2ulaw_array (const int *VAR_0, int VAR_1, unsigned char *VAR_2)
{	while (--VAR_1 >= 0)
	{	if (VAR_0 [VAR_1] == VAR_3)
			VAR_2 [VAR_1] = VAR_4 [VAR_5 >> (16 + 2)] ;
		else if (VAR_0 [VAR_1] >= 0)
			VAR_2 [VAR_1] = VAR_4 [VAR_0 [VAR_1] >> (16 + 2)] ;
		else
			VAR_2 [VAR_1] = 0x7F & VAR_4 [-VAR_0 [VAR_1] >> (16 + 2)] ;
		} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/ulaw.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,9 @@
 static inline void
 i2ulaw_array (const int *ptr, int count, unsigned char *buffer)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
+	{	if (ptr [count] == INT_MIN)
+			buffer [count] = ulaw_encode [INT_MAX >> (16 + 2)] ;
+		else if (ptr [count] >= 0)
 			buffer [count] = ulaw_encode [ptr [count] >> (16 + 2)] ;
 		else
 			buffer [count] = 0x7F & ulaw_encode [-ptr [count] >> (16 + 2)] ;","{'deleted_lines': ['\t{\tif (ptr [count] >= 0)'], 'added_lines': ['\t{\tif (ptr [count] == INT_MIN)', '\t\t\tbuffer [count] = ulaw_encode [INT_MAX >> (16 + 2)] ;', '\t\telse if (ptr [count] >= 0)']}",True,An issue was discovered in libsndfile 1.0.28. There is a buffer over-read in the function i2ulaw_array in ulaw.c that will lead to a denial of service.,6.5,MEDIUM,1,test,2018-12-14T06:36:57Z,2
CVE-2018-19661,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,libsndfile,"a/ulaw: fix multiple buffer overflows

i2ulaw_array() and i2alaw_array() fail to handle ptr [count] = INT_MIN
properly, leading to buffer underflow. INT_MIN is a special value
since - INT_MIN cannot be represented as int.

In this case round - INT_MIN to INT_MAX and proceed as usual.

f2ulaw_array() and f2alaw_array() fail to handle ptr [count] = NaN
properly, leading to null pointer dereference.

In this case, arbitrarily set the buffer value to 0.

This commit fixes #429 (CVE-2018-19661 and CVE-2018-19662) and
fixes #344 (CVE-2017-17456 and CVE-2017-17457).",c4dd30d69b070a3cb32b4bf74c47a8163b1916da,https://github.com/libsndfile/libsndfile/commit/c4dd30d69b070a3cb32b4bf74c47a8163b1916da,src/ulaw.c,d2ulaw_array,"static inline void
d2ulaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
{while (--count >= 0)
{if (ptr [count] >= 0)
buffer [count] = ulaw_encode [lrint (normfact * ptr [count])] ;
else
buffer [count] = 0x7F & ulaw_encode [- lrint (normfact * ptr [count])] ;
} ;
}","static inline void
d2ulaw_array (const double *VAR_0, int VAR_1, unsigned char *VAR_2, double VAR_3)
{while (--VAR_1 >= 0)
{if (VAR_0 [VAR_1] >= 0)
VAR_2 [VAR_1] = VAR_4 [lrint (VAR_3 * VAR_0 [VAR_1])] ;
else
VAR_2 [VAR_1] = 0x7F & VAR_4 [- lrint (VAR_3 * VAR_0 [VAR_1])] ;
} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/ulaw.c/vul/before/0.json,"static inline void
d2ulaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
{	while (--count >= 0)
	{	if (!isfinite (ptr [count]))
			buffer [count] = 0 ;
		else if (ptr [count] >= 0)
			buffer [count] = ulaw_encode [lrint (normfact * ptr [count])] ;
		else
			buffer [count] = 0x7F & ulaw_encode [- lrint (normfact * ptr [count])] ;
		} ;
}","static inline void
d2ulaw_array (const double *VAR_0, int VAR_1, unsigned char *VAR_2, double VAR_3)
{	while (--VAR_1 >= 0)
	{	if (!isfinite (VAR_0 [VAR_1]))
			VAR_2 [VAR_1] = 0 ;
		else if (VAR_0 [VAR_1] >= 0)
			VAR_2 [VAR_1] = VAR_4 [lrint (VAR_3 * VAR_0 [VAR_1])] ;
		else
			VAR_2 [VAR_1] = 0x7F & VAR_4 [- lrint (VAR_3 * VAR_0 [VAR_1])] ;
		} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/ulaw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,9 @@
 static inline void
 d2ulaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
+	{	if (!isfinite (ptr [count]))
+			buffer [count] = 0 ;
+		else if (ptr [count] >= 0)
 			buffer [count] = ulaw_encode [lrint (normfact * ptr [count])] ;
 		else
 			buffer [count] = 0x7F & ulaw_encode [- lrint (normfact * ptr [count])] ;","{'deleted_lines': ['\t{\tif (ptr [count] >= 0)'], 'added_lines': ['\t{\tif (!isfinite (ptr [count]))', '\t\t\tbuffer [count] = 0 ;', '\t\telse if (ptr [count] >= 0)']}",True,An issue was discovered in libsndfile 1.0.28. There is a buffer over-read in the function i2ulaw_array in ulaw.c that will lead to a denial of service.,6.5,MEDIUM,1,test,2018-12-14T06:36:57Z,2
CVE-2018-19661,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,libsndfile,"a/ulaw: fix multiple buffer overflows

i2ulaw_array() and i2alaw_array() fail to handle ptr [count] = INT_MIN
properly, leading to buffer underflow. INT_MIN is a special value
since - INT_MIN cannot be represented as int.

In this case round - INT_MIN to INT_MAX and proceed as usual.

f2ulaw_array() and f2alaw_array() fail to handle ptr [count] = NaN
properly, leading to null pointer dereference.

In this case, arbitrarily set the buffer value to 0.

This commit fixes #429 (CVE-2018-19661 and CVE-2018-19662) and
fixes #344 (CVE-2017-17456 and CVE-2017-17457).",c4dd30d69b070a3cb32b4bf74c47a8163b1916da,https://github.com/libsndfile/libsndfile/commit/c4dd30d69b070a3cb32b4bf74c47a8163b1916da,src/alaw.c,d2alaw_array,"static inline void
d2alaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
{while (--count >= 0)
{if (ptr [count] >= 0)
buffer [count] = alaw_encode [lrint (normfact * ptr [count])] ;
else
buffer [count] = 0x7F & alaw_encode [- lrint (normfact * ptr [count])] ;
} ;
}","static inline void
d2alaw_array (const double *VAR_0, int VAR_1, unsigned char *VAR_2, double VAR_3)
{while (--VAR_1 >= 0)
{if (VAR_0 [VAR_1] >= 0)
VAR_2 [VAR_1] = VAR_4 [lrint (VAR_3 * VAR_0 [VAR_1])] ;
else
VAR_2 [VAR_1] = 0x7F & VAR_4 [- lrint (VAR_3 * VAR_0 [VAR_1])] ;
} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/alaw.c/vul/before/0.json,"static inline void
d2alaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
{	while (--count >= 0)
	{	if (!isfinite (ptr [count]))
			buffer [count] = 0 ;
		else if (ptr [count] >= 0)
			buffer [count] = alaw_encode [lrint (normfact * ptr [count])] ;
		else
			buffer [count] = 0x7F & alaw_encode [- lrint (normfact * ptr [count])] ;
		} ;
}","static inline void
d2alaw_array (const double *VAR_0, int VAR_1, unsigned char *VAR_2, double VAR_3)
{	while (--VAR_1 >= 0)
	{	if (!isfinite (VAR_0 [VAR_1]))
			VAR_2 [VAR_1] = 0 ;
		else if (VAR_0 [VAR_1] >= 0)
			VAR_2 [VAR_1] = VAR_4 [lrint (VAR_3 * VAR_0 [VAR_1])] ;
		else
			VAR_2 [VAR_1] = 0x7F & VAR_4 [- lrint (VAR_3 * VAR_0 [VAR_1])] ;
		} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/alaw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,9 @@
 static inline void
 d2alaw_array (const double *ptr, int count, unsigned char *buffer, double normfact)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
+	{	if (!isfinite (ptr [count]))
+			buffer [count] = 0 ;
+		else if (ptr [count] >= 0)
 			buffer [count] = alaw_encode [lrint (normfact * ptr [count])] ;
 		else
 			buffer [count] = 0x7F & alaw_encode [- lrint (normfact * ptr [count])] ;","{'deleted_lines': ['\t{\tif (ptr [count] >= 0)'], 'added_lines': ['\t{\tif (!isfinite (ptr [count]))', '\t\t\tbuffer [count] = 0 ;', '\t\telse if (ptr [count] >= 0)']}",True,An issue was discovered in libsndfile 1.0.28. There is a buffer over-read in the function i2ulaw_array in ulaw.c that will lead to a denial of service.,6.5,MEDIUM,1,test,2018-12-14T06:36:57Z,2
CVE-2018-19661,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,libsndfile,"a/ulaw: fix multiple buffer overflows

i2ulaw_array() and i2alaw_array() fail to handle ptr [count] = INT_MIN
properly, leading to buffer underflow. INT_MIN is a special value
since - INT_MIN cannot be represented as int.

In this case round - INT_MIN to INT_MAX and proceed as usual.

f2ulaw_array() and f2alaw_array() fail to handle ptr [count] = NaN
properly, leading to null pointer dereference.

In this case, arbitrarily set the buffer value to 0.

This commit fixes #429 (CVE-2018-19661 and CVE-2018-19662) and
fixes #344 (CVE-2017-17456 and CVE-2017-17457).",c4dd30d69b070a3cb32b4bf74c47a8163b1916da,https://github.com/libsndfile/libsndfile/commit/c4dd30d69b070a3cb32b4bf74c47a8163b1916da,src/alaw.c,i2alaw_array,"static inline void
i2alaw_array (const int *ptr, int count, unsigned char *buffer)
{while (--count >= 0)
{if (ptr [count] >= 0)
buffer [count] = alaw_encode [ptr [count] >> (16 + 4)] ;
else
buffer [count] = 0x7F & alaw_encode [- ptr [count] >> (16 + 4)] ;
} ;
}","static inline void
i2alaw_array (const int *VAR_0, int VAR_1, unsigned char *VAR_2)
{while (--VAR_1 >= 0)
{if (VAR_0 [VAR_1] >= 0)
VAR_2 [VAR_1] = VAR_3 [VAR_0 [VAR_1] >> (16 + 4)] ;
else
VAR_2 [VAR_1] = 0x7F & VAR_3 [- VAR_0 [VAR_1] >> (16 + 4)] ;
} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/alaw.c/vul/before/1.json,"static inline void
i2alaw_array (const int *ptr, int count, unsigned char *buffer)
{	while (--count >= 0)
	{	if (ptr [count] == INT_MIN)
			buffer [count] = alaw_encode [INT_MAX >> (16 + 4)] ;
		else if (ptr [count] >= 0)
			buffer [count] = alaw_encode [ptr [count] >> (16 + 4)] ;
		else
			buffer [count] = 0x7F & alaw_encode [- ptr [count] >> (16 + 4)] ;
		} ;
}","static inline void
i2alaw_array (const int *VAR_0, int VAR_1, unsigned char *VAR_2)
{	while (--VAR_1 >= 0)
	{	if (VAR_0 [VAR_1] == VAR_3)
			VAR_2 [VAR_1] = VAR_4 [VAR_5 >> (16 + 4)] ;
		else if (VAR_0 [VAR_1] >= 0)
			VAR_2 [VAR_1] = VAR_4 [VAR_0 [VAR_1] >> (16 + 4)] ;
		else
			VAR_2 [VAR_1] = 0x7F & VAR_4 [- VAR_0 [VAR_1] >> (16 + 4)] ;
		} ;
}",libsndfile/c4dd30d69b070a3cb32b4bf74c47a8163b1916da/alaw.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,9 @@
 static inline void
 i2alaw_array (const int *ptr, int count, unsigned char *buffer)
 {	while (--count >= 0)
-	{	if (ptr [count] >= 0)
+	{	if (ptr [count] == INT_MIN)
+			buffer [count] = alaw_encode [INT_MAX >> (16 + 4)] ;
+		else if (ptr [count] >= 0)
 			buffer [count] = alaw_encode [ptr [count] >> (16 + 4)] ;
 		else
 			buffer [count] = 0x7F & alaw_encode [- ptr [count] >> (16 + 4)] ;","{'deleted_lines': ['\t{\tif (ptr [count] >= 0)'], 'added_lines': ['\t{\tif (ptr [count] == INT_MIN)', '\t\t\tbuffer [count] = alaw_encode [INT_MAX >> (16 + 4)] ;', '\t\telse if (ptr [count] >= 0)']}",True,An issue was discovered in libsndfile 1.0.28. There is a buffer over-read in the function i2ulaw_array in ulaw.c that will lead to a denial of service.,6.5,MEDIUM,1,test,2018-12-14T06:36:57Z,2
CVE-2018-6345,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,facebook/hhvm,"Fix a bug in number_format()

Summary: In case of error while calling snprintf, return empty string instead of malformed string.

Reviewed By: binliu19

Differential Revision: D13379372

fbshipit-source-id: 1e5611598464daccc674d5a96558c9f2aee08fc8",190ffdf6c8b1ec443be202c7d69e63a7e3da25e3,https://github.com/facebook/hhvm/commit/190ffdf6c8b1ec443be202c7d69e63a7e3da25e3,hphp/runtime/base/zend-string.cpp,string_number_format,"String string_number_format(double d, int dec,
const String& dec_point,
const String& thousand_sep) {
char *tmpbuf = nullptr, *resbuf;
char *s, *t;  
char *dp;
int integral;
int tmplen, reslen=0;
int count=0;
int is_negative=0;
if (d < 0) {
is_negative = 1;
d = -d;
}
if (dec < 0) dec = 0;
d = php_math_round(d, dec);
String tmpstr(63, ReserveString);
tmpbuf = tmpstr.mutableData();
tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d);
if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
tmpstr.setSize(tmplen);
return tmpstr;
}
if (tmplen >= 64) {
tmpstr = String(tmplen, ReserveString);
tmpbuf = tmpstr.mutableData();
tmplen = snprintf(tmpbuf, tmplen + 1, ""%.*F"", dec, d);
if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
tmpstr.setSize(tmplen);
return tmpstr;
}
}
if (dec) {
dp = strpbrk(tmpbuf, "".,"");
} else {
dp = nullptr;
}
if (dp) {
integral = dp - tmpbuf;
} else {
integral = tmplen;
}
if (!thousand_sep.empty()) {
if (integral + thousand_sep.size() * ((integral-1) / 3) < integral) {
raise_error(""String overflow"");
}
integral += ((integral-1) / 3) * thousand_sep.size();
}
reslen = integral;
if (dec) {
reslen += dec;
if (!dec_point.empty()) {
if (reslen + dec_point.size() < dec_point.size()) {
raise_error(""String overflow"");
}
reslen += dec_point.size();
}
}
if (is_negative) {
reslen++;
}
String resstr(reslen, ReserveString);
resbuf = resstr.mutableData();
s = tmpbuf+tmplen-1;
t = resbuf+reslen-1;
if (dec) {
int declen = dp ? s - dp : 0;
int topad = dec > declen ? dec - declen : 0;
while (topad--) {
*t-- = '0';
}
if (dp) {
s -= declen + 1; 
t -= declen;
memcpy(t + 1, dp + 1, declen);
}
if (!dec_point.empty()) {
memcpy(t + (1 - dec_point.size()), dec_point.data(), dec_point.size());
t -= dec_point.size();
}
}
while(s >= tmpbuf) {
*t-- = *s--;
if (thousand_sep && (++count%3)==0 && s>=tmpbuf) {
memcpy(t + (1 - thousand_sep.size()),
thousand_sep.data(),
thousand_sep.size());
t -= thousand_sep.size();
}
}
if (is_negative) {
*t-- = '-';
}
resstr.setSize(reslen);
return resstr;
}","String string_number_format(double VAR_0, int VAR_1,
const String& VAR_2,
const String& VAR_3) {
char *VAR_4 = nullptr, *VAR_5;
char *VAR_6, *VAR_7;  
char *VAR_8;
int VAR_9;
int VAR_10, VAR_11=0;
int VAR_12=0;
int VAR_13=0;
if (VAR_0 < 0) {
VAR_13 = 1;
VAR_0 = -VAR_0;
}
if (VAR_1 < 0) VAR_1 = 0;
VAR_0 = php_math_round(VAR_0, VAR_1);
String VAR_14(63, VAR_15);
VAR_4 = VAR_14.mutableData();
VAR_10 = snprintf(VAR_4, 64, ""%.*F"", VAR_1, VAR_0);
if (VAR_4 == nullptr || !isdigit((int)VAR_4[0])) {
VAR_14.setSize(VAR_10);
return VAR_14;
}
if (VAR_10 >= 64) {
VAR_14 = String(VAR_10, VAR_15);
VAR_4 = VAR_14.mutableData();
VAR_10 = snprintf(VAR_4, VAR_10 + 1, ""%.*F"", VAR_1, VAR_0);
if (VAR_4 == nullptr || !isdigit((int)VAR_4[0])) {
VAR_14.setSize(VAR_10);
return VAR_14;
}
}
if (VAR_1) {
VAR_8 = strpbrk(VAR_4, "".,"");
} else {
VAR_8 = nullptr;
}
if (VAR_8) {
VAR_9 = VAR_8 - VAR_4;
} else {
VAR_9 = VAR_10;
}
if (!VAR_3.empty()) {
if (VAR_9 + VAR_3.size() * ((VAR_9-1) / 3) < VAR_9) {
raise_error(""String overflow"");
}
VAR_9 += ((VAR_9-1) / 3) * VAR_3.size();
}
VAR_11 = VAR_9;
if (VAR_1) {
VAR_11 += VAR_1;
if (!VAR_2.empty()) {
if (VAR_11 + VAR_2.size() < VAR_2.size()) {
raise_error(""String overflow"");
}
VAR_11 += VAR_2.size();
}
}
if (VAR_13) {
VAR_11++;
}
String resstr(reslen, ReserveString);
VAR_5 = VAR_16.mutableData();
VAR_6 = VAR_4+VAR_10-1;
VAR_7 = VAR_5+reslen-1;
if (VAR_1) {
int VAR_17 = VAR_8 ? VAR_6 - VAR_8 : 0;
int VAR_18 = VAR_1 > VAR_17 ? VAR_1 - VAR_17 : 0;
while (VAR_18--) {
*VAR_7-- = '0';
}
if (VAR_8) {
VAR_6 -= VAR_17 + 1; 
VAR_7 -= VAR_17;
memcpy(VAR_7 + 1, VAR_8 + 1, VAR_17);
}
if (!VAR_2.empty()) {
memcpy(VAR_7 + (1 - VAR_2.size()), VAR_2.data(), VAR_2.size());
VAR_7 -= VAR_2.size();
}
}
while(VAR_6 >= VAR_4) {
*VAR_7-- = *VAR_6--;
if (VAR_3 && (++VAR_12%3)==0 && VAR_6>=VAR_4) {
memcpy(VAR_7 + (1 - VAR_3.size()),
VAR_3.data(),
VAR_3.size());
VAR_7 -= VAR_3.size();
}
}
if (VAR_13) {
*VAR_7-- = '-';
}
VAR_16.setSize(reslen);
return VAR_16;
}",facebook/hhvm/190ffdf6c8b1ec443be202c7d69e63a7e3da25e3/zend-string.cpp/vul/before/0.json,"String string_number_format(double d, int dec,
                            const String& dec_point,
                            const String& thousand_sep) {
  char *tmpbuf = nullptr, *resbuf;
  char *s, *t;  /* source, target */
  char *dp;
  int integral;
  int tmplen, reslen=0;
  int count=0;
  int is_negative=0;

  if (d < 0) {
    is_negative = 1;
    d = -d;
  }

  if (dec < 0) dec = 0;
  d = php_math_round(d, dec);

  // departure from PHP: we got rid of dependencies on spprintf() here.
  String tmpstr(63, ReserveString);
  tmpbuf = tmpstr.mutableData();
  tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d);
  if (tmplen < 0) return empty_string();
  if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
    tmpstr.setSize(tmplen);
    return tmpstr;
  }
  if (tmplen >= 64) {
    // Uncommon, asked for more than 64 chars worth of precision
    tmpstr = String(tmplen, ReserveString);
    tmpbuf = tmpstr.mutableData();
    tmplen = snprintf(tmpbuf, tmplen + 1, ""%.*F"", dec, d);
    if (tmplen < 0) return empty_string();
    if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
      tmpstr.setSize(tmplen);
      return tmpstr;
    }
  }

  /* find decimal point, if expected */
  if (dec) {
    dp = strpbrk(tmpbuf, "".,"");
  } else {
    dp = nullptr;
  }

  /* calculate the length of the return buffer */
  if (dp) {
    integral = dp - tmpbuf;
  } else {
    /* no decimal point was found */
    integral = tmplen;
  }

  /* allow for thousand separators */
  if (!thousand_sep.empty()) {
    if (integral + thousand_sep.size() * ((integral-1) / 3) < integral) {
      /* overflow */
      raise_error(""String overflow"");
    }

    integral += ((integral-1) / 3) * thousand_sep.size();
  }

  reslen = integral;

  if (dec) {
    reslen += dec;

    if (!dec_point.empty()) {
      if (reslen + dec_point.size() < dec_point.size()) {
        /* overflow */
        raise_error(""String overflow"");
      }
      reslen += dec_point.size();
    }
  }

  /* add a byte for minus sign */
  if (is_negative) {
    reslen++;
  }
  String resstr(reslen, ReserveString);
  resbuf = resstr.mutableData();

  s = tmpbuf+tmplen-1;
  t = resbuf+reslen-1;

  /* copy the decimal places.
   * Take care, as the sprintf implementation may return less places than
   * we requested due to internal buffer limitations */
  if (dec) {
    int declen = dp ? s - dp : 0;
    int topad = dec > declen ? dec - declen : 0;

    /* pad with '0's */
    while (topad--) {
      *t-- = '0';
    }

    if (dp) {
      s -= declen + 1; /* +1 to skip the point */
      t -= declen;

      /* now copy the chars after the point */
      memcpy(t + 1, dp + 1, declen);
    }

    /* add decimal point */
    if (!dec_point.empty()) {
      memcpy(t + (1 - dec_point.size()), dec_point.data(), dec_point.size());
      t -= dec_point.size();
    }
  }

  /* copy the numbers before the decimal point, adding thousand
   * separator every three digits */
  while(s >= tmpbuf) {
    *t-- = *s--;
    if (thousand_sep && (++count%3)==0 && s>=tmpbuf) {
      memcpy(t + (1 - thousand_sep.size()),
             thousand_sep.data(),
             thousand_sep.size());
      t -= thousand_sep.size();
    }
  }

  /* and a minus sign, if needed */
  if (is_negative) {
    *t-- = '-';
  }

  resstr.setSize(reslen);
  return resstr;
}","String string_number_format(double VAR_0, int VAR_1,
                            const String& VAR_2,
                            const String& VAR_3) {
  char *VAR_4 = nullptr, *VAR_5;
  char *VAR_6, *VAR_7;  /* COMMENT_0 */
  char *VAR_8;
  int VAR_9;
  int VAR_10, VAR_11=0;
  int VAR_12=0;
  int VAR_13=0;

  if (VAR_0 < 0) {
    VAR_13 = 1;
    VAR_0 = -VAR_0;
  }

  if (VAR_1 < 0) VAR_1 = 0;
  VAR_0 = php_math_round(VAR_0, VAR_1);

  /* COMMENT_1 */
  String VAR_14(63, VAR_15);
  VAR_4 = VAR_14.mutableData();
  VAR_10 = snprintf(VAR_4, 64, ""%.*F"", VAR_1, VAR_0);
  if (VAR_10 < 0) return empty_string();
  if (VAR_4 == nullptr || !isdigit((int)VAR_4[0])) {
    VAR_14.setSize(VAR_10);
    return VAR_14;
  }
  if (VAR_10 >= 64) {
    /* COMMENT_2 */
    VAR_14 = String(VAR_10, VAR_15);
    VAR_4 = VAR_14.mutableData();
    VAR_10 = snprintf(VAR_4, VAR_10 + 1, ""%.*F"", VAR_1, VAR_0);
    if (VAR_10 < 0) return empty_string();
    if (VAR_4 == nullptr || !isdigit((int)VAR_4[0])) {
      VAR_14.setSize(VAR_10);
      return VAR_14;
    }
  }

  /* COMMENT_3 */
  if (VAR_1) {
    VAR_8 = strpbrk(VAR_4, "".,"");
  } else {
    VAR_8 = nullptr;
  }

  /* COMMENT_4 */
  if (VAR_8) {
    VAR_9 = VAR_8 - VAR_4;
  } else {
    /* COMMENT_5 */
    VAR_9 = VAR_10;
  }

  /* COMMENT_6 */
  if (!VAR_3.empty()) {
    if (VAR_9 + VAR_3.size() * ((VAR_9-1) / 3) < VAR_9) {
      /* COMMENT_7 */
      raise_error(""String overflow"");
    }

    VAR_9 += ((VAR_9-1) / 3) * VAR_3.size();
  }

  VAR_11 = VAR_9;

  if (VAR_1) {
    VAR_11 += VAR_1;

    if (!VAR_2.empty()) {
      if (VAR_11 + VAR_2.size() < VAR_2.size()) {
        /* COMMENT_7 */
        raise_error(""String overflow"");
      }
      VAR_11 += VAR_2.size();
    }
  }

  /* COMMENT_8 */
  if (VAR_13) {
    VAR_11++;
  }
  String resstr(reslen, ReserveString);
  VAR_5 = VAR_16.mutableData();

  VAR_6 = VAR_4+VAR_10-1;
  VAR_7 = VAR_5+reslen-1;

  /* COMMENT_9 */
                                                                         
                                                       
  if (VAR_1) {
    int VAR_17 = VAR_8 ? VAR_6 - VAR_8 : 0;
    int VAR_18 = VAR_1 > VAR_17 ? VAR_1 - VAR_17 : 0;

    /* COMMENT_12 */
    while (VAR_18--) {
      *VAR_7-- = '0';
    }

    if (VAR_8) {
      VAR_6 -= VAR_17 + 1; /* COMMENT_13 */
      VAR_7 -= VAR_17;

      /* COMMENT_14 */
      memcpy(VAR_7 + 1, VAR_8 + 1, VAR_17);
    }

    /* COMMENT_15 */
    if (!VAR_2.empty()) {
      memcpy(VAR_7 + (1 - VAR_2.size()), VAR_2.data(), VAR_2.size());
      VAR_7 -= VAR_2.size();
    }
  }

  /* COMMENT_16 */
                                    
  while(VAR_6 >= VAR_4) {
    *VAR_7-- = *VAR_6--;
    if (VAR_3 && (++VAR_12%3)==0 && VAR_6>=VAR_4) {
      memcpy(VAR_7 + (1 - VAR_3.size()),
             VAR_3.data(),
             VAR_3.size());
      VAR_7 -= VAR_3.size();
    }
  }

  /* COMMENT_18 */
  if (VAR_13) {
    *VAR_7-- = '-';
  }

  VAR_16.setSize(reslen);
  return VAR_16;
}",facebook/hhvm/190ffdf6c8b1ec443be202c7d69e63a7e3da25e3/zend-string.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,7 @@
   String tmpstr(63, ReserveString);
   tmpbuf = tmpstr.mutableData();
   tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d);
+  if (tmplen < 0) return empty_string();
   if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
     tmpstr.setSize(tmplen);
     return tmpstr;
@@ -30,6 +31,7 @@
     tmpstr = String(tmplen, ReserveString);
     tmpbuf = tmpstr.mutableData();
     tmplen = snprintf(tmpbuf, tmplen + 1, ""%.*F"", dec, d);
+    if (tmplen < 0) return empty_string();
     if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
       tmpstr.setSize(tmplen);
       return tmpstr;","{'deleted_lines': [], 'added_lines': ['  if (tmplen < 0) return empty_string();', '    if (tmplen < 0) return empty_string();']}",True,"The function number_format is vulnerable to a heap overflow issue when its second argument ($dec_points) is excessively large. The internal implementation of the function will cause a string to be created with an invalid length, which can then interact poorly with other functions. This affects all supported versions of HHVM (3.30.1 and 3.27.5 and below).",9.8,CRITICAL,3,test,2018-12-14T16:42:02Z,2
CVE-2019-5719,['CWE-327'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,wireshark,"ISAKMP: Fix a crash when no decryption data block is there

Don't try to (re)set parameters in a struct when its pointer
points to NULL.

Bug: 15374
Change-Id: I953e82795990fde5fce2ad6d955781b372a9e405
Signed-off-by: Jaap Keuter <jaap.keuter@xs4all.nl>
Reviewed-on: https://code.wireshark.org/review/31189
Tested-by: Petri Dish Buildbot
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit c9cfae7fecd4bc21b8b4f48328d08e104d47dd52)
Reviewed-on: https://code.wireshark.org/review/31220
Petri-Dish: Michael Mann <mmann78@netscape.net>",b5b02f2a9b8772d8814096f86c60a32889d61f2c,https://github.com/wireshark/wireshark/commit/b5b02f2a9b8772d8814096f86c60a32889d61f2c,epan/dissectors/packet-isakmp.c,dissect_ike_attribute,"static int
dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr
)
{
guint headerlen, value_len, attr_type;
proto_item *attr_item;
proto_tree *attr_tree;
dissect_attribute_header(tvb, tree, offset,
hf_isakmp_ike_attr, ike_attr_type,
&headerlen, &value_len, &attr_type,
&attr_item, &attr_tree);
offset += headerlen;
if (value_len == 0)
{
expert_add_info(pinfo, attr_item, &ei_isakmp_attribute_value_empty);
return headerlen;
}
switch(attr_type) {
case IKE_ATTR_ENCRYPTION_ALGORITHM:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_encryption_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);
proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_enc_algo, ""Unknown %d""));
decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);
break;
case IKE_ATTR_HASH_ALGORITHM:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_hash_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);
proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_hash_algo, ""Unknown %d""));
decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);
break;
case IKE_ATTR_AUTHENTICATION_METHOD:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_authentication_method, tvb, offset, value_len, ENC_BIG_ENDIAN);
proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_authmeth, ""Unknown %d""));
decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;
break;
case IKE_ATTR_GROUP_DESCRIPTION:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_description, tvb, offset, value_len, ENC_BIG_ENDIAN);
proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), dh_group, ""Unknown %d""));
decr->group = tvb_get_ntohs(tvb, offset);
break;
case IKE_ATTR_GROUP_TYPE:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_type, tvb, offset, value_len, ENC_BIG_ENDIAN);
proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_grp_type, ""Unknown %d""));
break;
case IKE_ATTR_GROUP_PRIME:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_prime, tvb, offset, value_len, ENC_NA);
break;
case IKE_ATTR_GROUP_GENERATOR_ONE:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_one, tvb, offset, value_len, ENC_NA);
break;
case IKE_ATTR_GROUP_GENERATOR_TWO:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_two, tvb, offset, value_len, ENC_NA);
break;
case IKE_ATTR_GROUP_CURVE_A:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_a, tvb, offset, value_len, ENC_NA);
break;
case IKE_ATTR_GROUP_CURVE_B:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_b, tvb, offset, value_len, ENC_NA);
break;
case IKE_ATTR_LIFE_TYPE:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_life_type, tvb, offset, value_len, ENC_BIG_ENDIAN);
proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), attr_life_type, ""Unknown %d""));
break;
case IKE_ATTR_LIFE_DURATION:
dissect_life_duration(tvb, attr_tree, attr_item, hf_isakmp_ike_attr_life_duration_uint32, hf_isakmp_ike_attr_life_duration_uint64, hf_isakmp_ike_attr_life_duration_bytes, offset, value_len);
break;
case IKE_ATTR_PRF:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_prf, tvb, offset, value_len, ENC_NA);
break;
case IKE_ATTR_KEY_LENGTH:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_key_length, tvb, offset, value_len, ENC_BIG_ENDIAN);
proto_item_append_text(attr_item, "": %d"", tvb_get_ntohs(tvb, offset));
decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);
break;
case IKE_ATTR_FIELD_SIZE:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_field_size, tvb, offset, value_len, ENC_NA);
break;
case IKE_ATTR_GROUP_ORDER:
proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_order, tvb, offset, value_len, ENC_NA);
break;
default:
break;
}
return headerlen + value_len;
}","static int
dissect_ike_attribute(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, int VAR_3, decrypt_data_t *VAR_4
)
{
guint VAR_5, VAR_6, VAR_7;
proto_item *VAR_8;
proto_tree *VAR_9;
dissect_attribute_header(VAR_0, VAR_2, VAR_3,
VAR_10, VAR_11,
&VAR_5, &VAR_6, &VAR_7,
&VAR_8, &VAR_9);
VAR_3 += VAR_5;
if (VAR_6 == 0)
{
expert_add_info(VAR_1, VAR_8, &VAR_12);
return VAR_5;
}
switch(VAR_7) {
case VAR_13:
proto_tree_add_item(VAR_9, VAR_14, VAR_0, VAR_3, VAR_6, VAR_15);
proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_16, ""Unknown %d""));
VAR_4->ike_encr_alg = tvb_get_ntohs(VAR_0, VAR_3);
break;
case VAR_17:
proto_tree_add_item(VAR_9, VAR_18, VAR_0, VAR_3, VAR_6, VAR_15);
proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_19, ""Unknown %d""));
VAR_4->ike_hash_alg = tvb_get_ntohs(VAR_0, VAR_3);
break;
case VAR_20:
proto_tree_add_item(VAR_9, VAR_21, VAR_0, VAR_3, VAR_6, VAR_15);
proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_22, ""Unknown %d""));
VAR_4->is_psk = tvb_get_ntohs(VAR_0, VAR_3) == 0x01 ? TRUE : FALSE;
break;
case VAR_23:
proto_tree_add_item(VAR_9, VAR_24, VAR_0, VAR_3, VAR_6, VAR_15);
proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_25, ""Unknown %d""));
VAR_4->group = tvb_get_ntohs(VAR_0, VAR_3);
break;
case VAR_26:
proto_tree_add_item(VAR_9, VAR_27, VAR_0, VAR_3, VAR_6, VAR_15);
proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_28, ""Unknown %d""));
break;
case VAR_29:
proto_tree_add_item(VAR_9, VAR_30, VAR_0, VAR_3, VAR_6, VAR_31);
break;
case VAR_32:
proto_tree_add_item(VAR_9, VAR_33, VAR_0, VAR_3, VAR_6, VAR_31);
break;
case VAR_34:
proto_tree_add_item(VAR_9, VAR_35, VAR_0, VAR_3, VAR_6, VAR_31);
break;
case VAR_36:
proto_tree_add_item(VAR_9, VAR_37, VAR_0, VAR_3, VAR_6, VAR_31);
break;
case VAR_38:
proto_tree_add_item(VAR_9, VAR_39, VAR_0, VAR_3, VAR_6, VAR_31);
break;
case VAR_40:
proto_tree_add_item(VAR_9, VAR_41, VAR_0, VAR_3, VAR_6, VAR_15);
proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_42, ""Unknown %d""));
break;
case VAR_43:
dissect_life_duration(VAR_0, VAR_9, VAR_8, VAR_44, VAR_45, VAR_46, VAR_3, VAR_6);
break;
case VAR_47:
proto_tree_add_item(VAR_9, VAR_48, VAR_0, VAR_3, VAR_6, VAR_31);
break;
case VAR_49:
proto_tree_add_item(VAR_9, VAR_50, VAR_0, VAR_3, VAR_6, VAR_15);
proto_item_append_text(VAR_8, "": %d"", tvb_get_ntohs(VAR_0, VAR_3));
VAR_4->ike_encr_keylen = tvb_get_ntohs(VAR_0, VAR_3);
break;
case VAR_51:
proto_tree_add_item(VAR_9, VAR_52, VAR_0, VAR_3, VAR_6, VAR_31);
break;
case VAR_53:
proto_tree_add_item(VAR_9, VAR_54, VAR_0, VAR_3, VAR_6, VAR_31);
break;
default:
break;
}
return VAR_5 + VAR_6;
}",wireshark/b5b02f2a9b8772d8814096f86c60a32889d61f2c/packet-isakmp.c/vul/before/1.json,"static int
dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr)
{
  guint headerlen, value_len, attr_type;
  proto_item *attr_item;
  proto_tree *attr_tree;

  dissect_attribute_header(tvb, tree, offset,
                           hf_isakmp_ike_attr, ike_attr_type,
                           &headerlen, &value_len, &attr_type,
                           &attr_item, &attr_tree);

  offset += headerlen;

  if (value_len == 0)
  {
    expert_add_info(pinfo, attr_item, &ei_isakmp_attribute_value_empty);
    return headerlen;
  }

  switch(attr_type) {
    case IKE_ATTR_ENCRYPTION_ALGORITHM:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_encryption_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);
      proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_enc_algo, ""Unknown %d""));
      if (decr) decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);
      break;
    case IKE_ATTR_HASH_ALGORITHM:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_hash_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);
      proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_hash_algo, ""Unknown %d""));
      if (decr) decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);
      break;
    case IKE_ATTR_AUTHENTICATION_METHOD:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_authentication_method, tvb, offset, value_len, ENC_BIG_ENDIAN);
      proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_authmeth, ""Unknown %d""));
      if (decr) decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;
      break;
    case IKE_ATTR_GROUP_DESCRIPTION:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_description, tvb, offset, value_len, ENC_BIG_ENDIAN);
      proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), dh_group, ""Unknown %d""));
      if (decr) decr->group = tvb_get_ntohs(tvb, offset);
      break;
    case IKE_ATTR_GROUP_TYPE:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_type, tvb, offset, value_len, ENC_BIG_ENDIAN);
      proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_grp_type, ""Unknown %d""));
      break;
    case IKE_ATTR_GROUP_PRIME:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_prime, tvb, offset, value_len, ENC_NA);
      break;
    case IKE_ATTR_GROUP_GENERATOR_ONE:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_one, tvb, offset, value_len, ENC_NA);
      break;
    case IKE_ATTR_GROUP_GENERATOR_TWO:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_two, tvb, offset, value_len, ENC_NA);
      break;
    case IKE_ATTR_GROUP_CURVE_A:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_a, tvb, offset, value_len, ENC_NA);
      break;
    case IKE_ATTR_GROUP_CURVE_B:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_b, tvb, offset, value_len, ENC_NA);
      break;
    case IKE_ATTR_LIFE_TYPE:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_life_type, tvb, offset, value_len, ENC_BIG_ENDIAN);
      proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), attr_life_type, ""Unknown %d""));
      break;
    case IKE_ATTR_LIFE_DURATION:
      dissect_life_duration(tvb, attr_tree, attr_item, hf_isakmp_ike_attr_life_duration_uint32, hf_isakmp_ike_attr_life_duration_uint64, hf_isakmp_ike_attr_life_duration_bytes, offset, value_len);
      break;
    case IKE_ATTR_PRF:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_prf, tvb, offset, value_len, ENC_NA);
      break;
    case IKE_ATTR_KEY_LENGTH:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_key_length, tvb, offset, value_len, ENC_BIG_ENDIAN);
      proto_item_append_text(attr_item, "": %d"", tvb_get_ntohs(tvb, offset));
      if (decr) decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);
      break;
    case IKE_ATTR_FIELD_SIZE:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_field_size, tvb, offset, value_len, ENC_NA);
      break;
    case IKE_ATTR_GROUP_ORDER:
      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_order, tvb, offset, value_len, ENC_NA);
      break;
    default:
      /* No Default Action */
      break;
  }

  return headerlen + value_len;
}","static int
dissect_ike_attribute(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, int VAR_3, decrypt_data_t *VAR_4)
{
  guint VAR_5, VAR_6, VAR_7;
  proto_item *VAR_8;
  proto_tree *VAR_9;

  dissect_attribute_header(VAR_0, VAR_2, VAR_3,
                           VAR_10, VAR_11,
                           &VAR_5, &VAR_6, &VAR_7,
                           &VAR_8, &VAR_9);

  VAR_3 += VAR_5;

  if (VAR_6 == 0)
  {
    expert_add_info(VAR_1, VAR_8, &VAR_12);
    return VAR_5;
  }

  switch(VAR_7) {
    case VAR_13:
      proto_tree_add_item(VAR_9, VAR_14, VAR_0, VAR_3, VAR_6, VAR_15);
      proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_16, ""Unknown %d""));
      if (VAR_4) VAR_4->ike_encr_alg = tvb_get_ntohs(VAR_0, VAR_3);
      break;
    case VAR_17:
      proto_tree_add_item(VAR_9, VAR_18, VAR_0, VAR_3, VAR_6, VAR_15);
      proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_19, ""Unknown %d""));
      if (VAR_4) VAR_4->ike_hash_alg = tvb_get_ntohs(VAR_0, VAR_3);
      break;
    case VAR_20:
      proto_tree_add_item(VAR_9, VAR_21, VAR_0, VAR_3, VAR_6, VAR_15);
      proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_22, ""Unknown %d""));
      if (VAR_4) VAR_4->is_psk = tvb_get_ntohs(VAR_0, VAR_3) == 0x01 ? TRUE : FALSE;
      break;
    case VAR_23:
      proto_tree_add_item(VAR_9, VAR_24, VAR_0, VAR_3, VAR_6, VAR_15);
      proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_25, ""Unknown %d""));
      if (VAR_4) VAR_4->group = tvb_get_ntohs(VAR_0, VAR_3);
      break;
    case VAR_26:
      proto_tree_add_item(VAR_9, VAR_27, VAR_0, VAR_3, VAR_6, VAR_15);
      proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_28, ""Unknown %d""));
      break;
    case VAR_29:
      proto_tree_add_item(VAR_9, VAR_30, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    case VAR_32:
      proto_tree_add_item(VAR_9, VAR_33, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    case VAR_34:
      proto_tree_add_item(VAR_9, VAR_35, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    case VAR_36:
      proto_tree_add_item(VAR_9, VAR_37, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    case VAR_38:
      proto_tree_add_item(VAR_9, VAR_39, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    case VAR_40:
      proto_tree_add_item(VAR_9, VAR_41, VAR_0, VAR_3, VAR_6, VAR_15);
      proto_item_append_text(VAR_8, "": %s"", val_to_str(tvb_get_ntohs(VAR_0, VAR_3), VAR_42, ""Unknown %d""));
      break;
    case VAR_43:
      dissect_life_duration(VAR_0, VAR_9, VAR_8, VAR_44, VAR_45, VAR_46, VAR_3, VAR_6);
      break;
    case VAR_47:
      proto_tree_add_item(VAR_9, VAR_48, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    case VAR_49:
      proto_tree_add_item(VAR_9, VAR_50, VAR_0, VAR_3, VAR_6, VAR_15);
      proto_item_append_text(VAR_8, "": %d"", tvb_get_ntohs(VAR_0, VAR_3));
      if (VAR_4) VAR_4->ike_encr_keylen = tvb_get_ntohs(VAR_0, VAR_3);
      break;
    case VAR_51:
      proto_tree_add_item(VAR_9, VAR_52, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    case VAR_53:
      proto_tree_add_item(VAR_9, VAR_54, VAR_0, VAR_3, VAR_6, VAR_31);
      break;
    default:
      /* COMMENT_0 */
      break;
  }

  return VAR_5 + VAR_6;
}",wireshark/b5b02f2a9b8772d8814096f86c60a32889d61f2c/packet-isakmp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,5 @@
 static int
-dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr
-)
+dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr)
 {
   guint headerlen, value_len, attr_type;
   proto_item *attr_item;
@@ -23,22 +22,22 @@
     case IKE_ATTR_ENCRYPTION_ALGORITHM:
       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_encryption_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);
       proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_enc_algo, ""Unknown %d""));
-      decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);
+      if (decr) decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);
       break;
     case IKE_ATTR_HASH_ALGORITHM:
       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_hash_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);
       proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_hash_algo, ""Unknown %d""));
-      decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);
+      if (decr) decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);
       break;
     case IKE_ATTR_AUTHENTICATION_METHOD:
       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_authentication_method, tvb, offset, value_len, ENC_BIG_ENDIAN);
       proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_authmeth, ""Unknown %d""));
-      decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;
+      if (decr) decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;
       break;
     case IKE_ATTR_GROUP_DESCRIPTION:
       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_description, tvb, offset, value_len, ENC_BIG_ENDIAN);
       proto_item_append_text(attr_item, "": %s"", val_to_str(tvb_get_ntohs(tvb, offset), dh_group, ""Unknown %d""));
-      decr->group = tvb_get_ntohs(tvb, offset);
+      if (decr) decr->group = tvb_get_ntohs(tvb, offset);
       break;
     case IKE_ATTR_GROUP_TYPE:
       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_type, tvb, offset, value_len, ENC_BIG_ENDIAN);
@@ -72,7 +71,7 @@
     case IKE_ATTR_KEY_LENGTH:
       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_key_length, tvb, offset, value_len, ENC_BIG_ENDIAN);
       proto_item_append_text(attr_item, "": %d"", tvb_get_ntohs(tvb, offset));
-      decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);
+      if (decr) decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);
       break;
     case IKE_ATTR_FIELD_SIZE:
       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_field_size, tvb, offset, value_len, ENC_NA);","{'deleted_lines': ['dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr', ')', '      decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);', '      decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);', '      decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;', '      decr->group = tvb_get_ntohs(tvb, offset);', '      decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);'], 'added_lines': ['dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr)', '      if (decr) decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);', '      if (decr) decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);', '      if (decr) decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;', '      if (decr) decr->group = tvb_get_ntohs(tvb, offset);', '      if (decr) decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);']}",True,"In Wireshark 2.6.0 to 2.6.5 and 2.4.0 to 2.4.11, the ISAKMP dissector could crash. This was addressed in epan/dissectors/packet-isakmp.c by properly handling the case of a missing decryption data block.",5.5,MEDIUM,1,test,2018-12-24T22:15:26Z,2
CVE-2019-5719,['CWE-327'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,wireshark,"ISAKMP: Fix a crash when no decryption data block is there

Don't try to (re)set parameters in a struct when its pointer
points to NULL.

Bug: 15374
Change-Id: I953e82795990fde5fce2ad6d955781b372a9e405
Signed-off-by: Jaap Keuter <jaap.keuter@xs4all.nl>
Reviewed-on: https://code.wireshark.org/review/31189
Tested-by: Petri Dish Buildbot
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit c9cfae7fecd4bc21b8b4f48328d08e104d47dd52)
Reviewed-on: https://code.wireshark.org/review/31220
Petri-Dish: Michael Mann <mmann78@netscape.net>",b5b02f2a9b8772d8814096f86c60a32889d61f2c,https://github.com/wireshark/wireshark/commit/b5b02f2a9b8772d8814096f86c60a32889d61f2c,epan/dissectors/packet-isakmp.c,dissect_transform,"static void
dissect_transform(tvbuff_t *tvb, packet_info *pinfo, int offset, int length, proto_tree *tree, int isakmp_version, int protocol_id, void* decr_data)
{
if (isakmp_version == 1)
{
guint8              transform_id;
guint8              transform_num;
decrypt_data_t *decr = (decrypt_data_t *)decr_data;
int offset_end = 0;
offset_end = offset + length;
transform_num = tvb_get_guint8(tvb, offset);
proto_item_append_text(tree,"" # %d"",transform_num);
proto_tree_add_item(tree, hf_isakmp_trans_number, tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
transform_id = tvb_get_guint8(tvb, offset);
switch (protocol_id) {
case 1:     
proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
transform_id, ""%s (%u)"",
val_to_str_const(transform_id, vs_v1_trans_isakmp, ""UNKNOWN-TRANS-TYPE""), transform_id);
break;
case 2:     
proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
transform_id, ""%s (%u)"",
val_to_str_const(transform_id, vs_v1_trans_ah, ""UNKNOWN-AH-TRANS-TYPE""), transform_id);
break;
case 3:     
proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
transform_id, ""%s (%u)"",
val_to_str_const(transform_id, vs_v1_trans_esp, ""UNKNOWN-ESP-TRANS-TYPE""), transform_id);
break;
case 4:     
proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
transform_id, ""%s (%u)"",
val_to_str_const(transform_id, transform_id_ipcomp, ""UNKNOWN-IPCOMP-TRANS-TYPE""), transform_id);
break;
default:
proto_tree_add_item(tree, hf_isakmp_trans_id, tvb, offset, 1, ENC_BIG_ENDIAN);
break;
}
offset += 1;
proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 2, ENC_NA);
offset += 2;
if (protocol_id == 1 && transform_id == 1) {
decr->ike_encr_alg = 0;
decr->ike_encr_keylen = 0;
decr->ike_hash_alg = 0;
while (offset < offset_end) {
offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr);
}
}
else {
while (offset < offset_end) {
offset += dissect_ipsec_attribute(tvb, pinfo, tree, offset);
}
}
}
else if(isakmp_version == 2)
{
guint8 transform_type;
int offset_end = 0;
offset_end = offset + length;
transform_type = tvb_get_guint8(tvb, offset);
proto_tree_add_item(tree, hf_isakmp_trans_type, tvb, offset, 1, ENC_BIG_ENDIAN);
offset += 1;
proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 1, ENC_NA);
offset += 1;
switch(transform_type){
case TF_IKE2_ENCR:
proto_tree_add_item(tree, hf_isakmp_trans_encr, tvb, offset, 2, ENC_BIG_ENDIAN);
break;
case TF_IKE2_PRF:
proto_tree_add_item(tree, hf_isakmp_trans_prf, tvb, offset, 2, ENC_BIG_ENDIAN);
break;
case TF_IKE2_INTEG:
proto_tree_add_item(tree, hf_isakmp_trans_integ, tvb, offset, 2, ENC_BIG_ENDIAN);
break;
case TF_IKE2_DH:
proto_tree_add_item(tree, hf_isakmp_trans_dh, tvb, offset, 2, ENC_BIG_ENDIAN);
break;
case TF_IKE2_ESN:
proto_tree_add_item(tree, hf_isakmp_trans_esn, tvb, offset, 2, ENC_BIG_ENDIAN);
break;
default:
proto_tree_add_item(tree, hf_isakmp_trans_id_v2, tvb, offset, 2, ENC_BIG_ENDIAN);
break;
}
offset += 2;
while (offset < offset_end) {
offset += dissect_ike2_transform_attribute(tvb, pinfo, tree, offset);
}
}
}","static void
dissect_transform(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, int VAR_3, proto_tree *VAR_4, int VAR_5, int VAR_6, void* VAR_7)
{
if (VAR_5 == 1)
{
guint8              VAR_8;
guint8              VAR_9;
decrypt_data_t *VAR_10 = (decrypt_data_t *)VAR_7;
int VAR_11 = 0;
VAR_11 = VAR_2 + VAR_3;
VAR_9 = tvb_get_guint8(VAR_0, VAR_2);
proto_item_append_text(VAR_4,"" # %d"",VAR_9);
proto_tree_add_item(VAR_4, VAR_12, VAR_0, VAR_2, 1, VAR_13);
VAR_2 += 1;
VAR_8 = tvb_get_guint8(VAR_0, VAR_2);
switch (VAR_6) {
case 1:     
proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
VAR_8, ""%s (%u)"",
val_to_str_const(VAR_8, VAR_15, ""UNKNOWN-TRANS-TYPE""), VAR_8);
break;
case 2:     
proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
VAR_8, ""%s (%u)"",
val_to_str_const(VAR_8, VAR_16, ""UNKNOWN-AH-TRANS-TYPE""), VAR_8);
break;
case 3:     
proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
VAR_8, ""%s (%u)"",
val_to_str_const(VAR_8, VAR_17, ""UNKNOWN-ESP-TRANS-TYPE""), VAR_8);
break;
case 4:     
proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
VAR_8, ""%s (%u)"",
val_to_str_const(VAR_8, VAR_18, ""UNKNOWN-IPCOMP-TRANS-TYPE""), VAR_8);
break;
default:
proto_tree_add_item(VAR_4, VAR_14, VAR_0, VAR_2, 1, VAR_13);
break;
}
VAR_2 += 1;
proto_tree_add_item(VAR_4, VAR_19, VAR_0, VAR_2, 2, VAR_20);
VAR_2 += 2;
if (VAR_6 == 1 && VAR_8 == 1) {
VAR_10->ike_encr_alg = 0;
VAR_10->ike_encr_keylen = 0;
VAR_10->ike_hash_alg = 0;
while (VAR_2 < VAR_11) {
VAR_2 += dissect_ike_attribute(VAR_0, VAR_1, VAR_4, VAR_2, VAR_10);
}
}
else {
while (VAR_2 < VAR_11) {
VAR_2 += dissect_ipsec_attribute(VAR_0, VAR_1, VAR_4, VAR_2);
}
}
}
else if(VAR_5 == 2)
{
guint8 VAR_21;
int VAR_11 = 0;
VAR_11 = VAR_2 + VAR_3;
VAR_21 = tvb_get_guint8(VAR_0, VAR_2);
proto_tree_add_item(VAR_4, VAR_22, VAR_0, VAR_2, 1, VAR_13);
VAR_2 += 1;
proto_tree_add_item(VAR_4, VAR_19, VAR_0, VAR_2, 1, VAR_20);
VAR_2 += 1;
switch(VAR_21){
case VAR_23:
proto_tree_add_item(VAR_4, VAR_24, VAR_0, VAR_2, 2, VAR_13);
break;
case VAR_25:
proto_tree_add_item(VAR_4, VAR_26, VAR_0, VAR_2, 2, VAR_13);
break;
case VAR_27:
proto_tree_add_item(VAR_4, VAR_28, VAR_0, VAR_2, 2, VAR_13);
break;
case VAR_29:
proto_tree_add_item(VAR_4, VAR_30, VAR_0, VAR_2, 2, VAR_13);
break;
case VAR_31:
proto_tree_add_item(VAR_4, VAR_32, VAR_0, VAR_2, 2, VAR_13);
break;
default:
proto_tree_add_item(VAR_4, VAR_33, VAR_0, VAR_2, 2, VAR_13);
break;
}
VAR_2 += 2;
while (VAR_2 < VAR_11) {
VAR_2 += dissect_ike2_transform_attribute(VAR_0, VAR_1, VAR_4, VAR_2);
}
}
}",wireshark/b5b02f2a9b8772d8814096f86c60a32889d61f2c/packet-isakmp.c/vul/before/0.json,"static void
dissect_transform(tvbuff_t *tvb, packet_info *pinfo, int offset, int length, proto_tree *tree, int isakmp_version, int protocol_id, void* decr_data)
{
  if (isakmp_version == 1)
  {
    guint8              transform_id;
    guint8              transform_num;
    decrypt_data_t *decr = (decrypt_data_t *)decr_data;
    int offset_end = 0;
    offset_end = offset + length;

    transform_num = tvb_get_guint8(tvb, offset);
    proto_item_append_text(tree,"" # %d"",transform_num);

    proto_tree_add_item(tree, hf_isakmp_trans_number, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;

    transform_id = tvb_get_guint8(tvb, offset);
    switch (protocol_id) {
    case 1:     /* ISAKMP */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, ""%s (%u)"",
                                 val_to_str_const(transform_id, vs_v1_trans_isakmp, ""UNKNOWN-TRANS-TYPE""), transform_id);
      break;
    case 2:     /* AH */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, ""%s (%u)"",
                                 val_to_str_const(transform_id, vs_v1_trans_ah, ""UNKNOWN-AH-TRANS-TYPE""), transform_id);
      break;
    case 3:     /* ESP */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, ""%s (%u)"",
                                 val_to_str_const(transform_id, vs_v1_trans_esp, ""UNKNOWN-ESP-TRANS-TYPE""), transform_id);
      break;
    case 4:     /* IPCOMP */
      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,
                                 transform_id, ""%s (%u)"",
                                 val_to_str_const(transform_id, transform_id_ipcomp, ""UNKNOWN-IPCOMP-TRANS-TYPE""), transform_id);
      break;
    default:
      proto_tree_add_item(tree, hf_isakmp_trans_id, tvb, offset, 1, ENC_BIG_ENDIAN);
      break;
    }
    offset += 1;

    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 2, ENC_NA);
    offset += 2;

    if (protocol_id == 1 && transform_id == 1) {
      if (decr) {
        /* Allow detection of missing IKE transform attributes:
         * Make sure their values are not carried over from another transform
         * dissected previously. */
        decr->ike_encr_alg = 0;
        decr->ike_encr_keylen = 0;
        decr->ike_hash_alg = 0;
      }
      while (offset < offset_end) {
        offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr);
      }
    }
    else {
       while (offset < offset_end) {
         offset += dissect_ipsec_attribute(tvb, pinfo, tree, offset);
       }
    }
  }
  else if(isakmp_version == 2)
  {
    guint8 transform_type;
    int offset_end = 0;
    offset_end = offset + length;

    transform_type = tvb_get_guint8(tvb, offset);
    proto_tree_add_item(tree, hf_isakmp_trans_type, tvb, offset, 1, ENC_BIG_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 1, ENC_NA);
    offset += 1;

    switch(transform_type){
    case TF_IKE2_ENCR:
      proto_tree_add_item(tree, hf_isakmp_trans_encr, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_PRF:
      proto_tree_add_item(tree, hf_isakmp_trans_prf, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_INTEG:
      proto_tree_add_item(tree, hf_isakmp_trans_integ, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_DH:
      proto_tree_add_item(tree, hf_isakmp_trans_dh, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    case TF_IKE2_ESN:
      proto_tree_add_item(tree, hf_isakmp_trans_esn, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    default:
      proto_tree_add_item(tree, hf_isakmp_trans_id_v2, tvb, offset, 2, ENC_BIG_ENDIAN);
      break;
    }
    offset += 2;

    while (offset < offset_end) {
      offset += dissect_ike2_transform_attribute(tvb, pinfo, tree, offset);
    }
  }
}","static void
dissect_transform(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, int VAR_3, proto_tree *VAR_4, int VAR_5, int VAR_6, void* VAR_7)
{
  if (VAR_5 == 1)
  {
    guint8              VAR_8;
    guint8              VAR_9;
    decrypt_data_t *VAR_10 = (decrypt_data_t *)VAR_7;
    int VAR_11 = 0;
    VAR_11 = VAR_2 + VAR_3;

    VAR_9 = tvb_get_guint8(VAR_0, VAR_2);
    proto_item_append_text(VAR_4,"" # %d"",VAR_9);

    proto_tree_add_item(VAR_4, VAR_12, VAR_0, VAR_2, 1, VAR_13);
    VAR_2 += 1;

    VAR_8 = tvb_get_guint8(VAR_0, VAR_2);
    switch (VAR_6) {
    case 1:     /* COMMENT_0 */
      proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
                                 VAR_8, ""%s (%u)"",
                                 val_to_str_const(VAR_8, VAR_15, ""UNKNOWN-TRANS-TYPE""), VAR_8);
      break;
    case 2:     /* COMMENT_1 */
      proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
                                 VAR_8, ""%s (%u)"",
                                 val_to_str_const(VAR_8, VAR_16, ""UNKNOWN-AH-TRANS-TYPE""), VAR_8);
      break;
    case 3:     /* COMMENT_2 */
      proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
                                 VAR_8, ""%s (%u)"",
                                 val_to_str_const(VAR_8, VAR_17, ""UNKNOWN-ESP-TRANS-TYPE""), VAR_8);
      break;
    case 4:     /* COMMENT_3 */
      proto_tree_add_uint_format_value(VAR_4, VAR_14, VAR_0, VAR_2, 1,
                                 VAR_8, ""%s (%u)"",
                                 val_to_str_const(VAR_8, VAR_18, ""UNKNOWN-IPCOMP-TRANS-TYPE""), VAR_8);
      break;
    default:
      proto_tree_add_item(VAR_4, VAR_14, VAR_0, VAR_2, 1, VAR_13);
      break;
    }
    VAR_2 += 1;

    proto_tree_add_item(VAR_4, VAR_19, VAR_0, VAR_2, 2, VAR_20);
    VAR_2 += 2;

    if (VAR_6 == 1 && VAR_8 == 1) {
      if (VAR_10) {
        /* COMMENT_4 */
                                                                             
                                   
        VAR_10->ike_encr_alg = 0;
        VAR_10->ike_encr_keylen = 0;
        VAR_10->ike_hash_alg = 0;
      }
      while (VAR_2 < VAR_11) {
        VAR_2 += dissect_ike_attribute(VAR_0, VAR_1, VAR_4, VAR_2, VAR_10);
      }
    }
    else {
       while (VAR_2 < VAR_11) {
         VAR_2 += dissect_ipsec_attribute(VAR_0, VAR_1, VAR_4, VAR_2);
       }
    }
  }
  else if(VAR_5 == 2)
  {
    guint8 VAR_21;
    int VAR_11 = 0;
    VAR_11 = VAR_2 + VAR_3;

    VAR_21 = tvb_get_guint8(VAR_0, VAR_2);
    proto_tree_add_item(VAR_4, VAR_22, VAR_0, VAR_2, 1, VAR_13);
    VAR_2 += 1;

    proto_tree_add_item(VAR_4, VAR_19, VAR_0, VAR_2, 1, VAR_20);
    VAR_2 += 1;

    switch(VAR_21){
    case VAR_23:
      proto_tree_add_item(VAR_4, VAR_24, VAR_0, VAR_2, 2, VAR_13);
      break;
    case VAR_25:
      proto_tree_add_item(VAR_4, VAR_26, VAR_0, VAR_2, 2, VAR_13);
      break;
    case VAR_27:
      proto_tree_add_item(VAR_4, VAR_28, VAR_0, VAR_2, 2, VAR_13);
      break;
    case VAR_29:
      proto_tree_add_item(VAR_4, VAR_30, VAR_0, VAR_2, 2, VAR_13);
      break;
    case VAR_31:
      proto_tree_add_item(VAR_4, VAR_32, VAR_0, VAR_2, 2, VAR_13);
      break;
    default:
      proto_tree_add_item(VAR_4, VAR_33, VAR_0, VAR_2, 2, VAR_13);
      break;
    }
    VAR_2 += 2;

    while (VAR_2 < VAR_11) {
      VAR_2 += dissect_ike2_transform_attribute(VAR_0, VAR_1, VAR_4, VAR_2);
    }
  }
}",wireshark/b5b02f2a9b8772d8814096f86c60a32889d61f2c/packet-isakmp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,12 +47,14 @@
     offset += 2;
 
     if (protocol_id == 1 && transform_id == 1) {
-      /* Allow detection of missing IKE transform attributes:
-       * Make sure their values are not carried over from another transform
-       * dissected previously. */
-      decr->ike_encr_alg = 0;
-      decr->ike_encr_keylen = 0;
-      decr->ike_hash_alg = 0;
+      if (decr) {
+        /* Allow detection of missing IKE transform attributes:
+         * Make sure their values are not carried over from another transform
+         * dissected previously. */
+        decr->ike_encr_alg = 0;
+        decr->ike_encr_keylen = 0;
+        decr->ike_hash_alg = 0;
+      }
       while (offset < offset_end) {
         offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr);
       }","{'deleted_lines': ['      /* Allow detection of missing IKE transform attributes:', '       * Make sure their values are not carried over from another transform', '       * dissected previously. */', '      decr->ike_encr_alg = 0;', '      decr->ike_encr_keylen = 0;', '      decr->ike_hash_alg = 0;'], 'added_lines': ['      if (decr) {', '        /* Allow detection of missing IKE transform attributes:', '         * Make sure their values are not carried over from another transform', '         * dissected previously. */', '        decr->ike_encr_alg = 0;', '        decr->ike_encr_keylen = 0;', '        decr->ike_hash_alg = 0;', '      }']}",True,"In Wireshark 2.6.0 to 2.6.5 and 2.4.0 to 2.4.11, the ISAKMP dissector could crash. This was addressed in epan/dissectors/packet-isakmp.c by properly handling the case of a missing decryption data block.",5.5,MEDIUM,1,test,2018-12-24T22:15:26Z,2
CVE-2019-5489,['CWE-319'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0.0,torvalds/linux,"Change mincore() to count ""mapped"" pages rather than ""cached"" pages

The semantics of what ""in core"" means for the mincore() system call are
somewhat unclear, but Linux has always (since 2.3.52, which is when
mincore() was initially done) treated it as ""page is available in page
cache"" rather than ""page is mapped in the mapping"".

The problem with that traditional semantic is that it exposes a lot of
system cache state that it really probably shouldn't, and that users
shouldn't really even care about.

So let's try to avoid that information leak by simply changing the
semantics to be that mincore() counts actual mapped pages, not pages
that might be cheaply mapped if they were faulted (note the ""might be""
part of the old semantics: being in the cache doesn't actually guarantee
that you can access them without IO anyway, since things like network
filesystems may have to revalidate the cache before use).

In many ways the old semantics were somewhat insane even aside from the
information leak issue.  From the very beginning (and that beginning is
a long time ago: 2.3.52 was released in March 2000, I think), the code
had a comment saying

  Later we can get more picky about what ""in core"" means precisely.

and this is that ""later"".  Admittedly it is much later than is really
comfortable.

NOTE! This is a real semantic change, and it is for example known to
change the output of ""fincore"", since that program literally does a
mmmap without populating it, and then doing ""mincore()"" on that mapping
that doesn't actually have any pages in it.

I'm hoping that nobody actually has any workflow that cares, and the
info leak is real.

We may have to do something different if it turns out that people have
valid reasons to want the old semantics, and if we can limit the
information leak sanely.

Cc: Kevin Easton <kevin@guarana.org>
Cc: Jiri Kosina <jikos@kernel.org>
Cc: Masatake YAMATO <yamato@redhat.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Greg KH <gregkh@linuxfoundation.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Michal Hocko <mhocko@suse.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",574823bfab82d9d8fa47f422778043fbb4b4f50e,https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e,mm/mincore.c,mincore_pte_range,"static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
struct mm_walk *walk)
{
spinlock_t *ptl;
struct vm_area_struct *vma = walk->vma;
pte_t *ptep;
unsigned char *vec = walk->private;
int nr = (end - addr) >> PAGE_SHIFT;
ptl = pmd_trans_huge_lock(pmd, vma);
if (ptl) {
memset(vec, 1, nr);
spin_unlock(ptl);
goto out;
}
if (pmd_trans_unstable(pmd)) {
__mincore_unmapped_range(addr, end, vma, vec);
goto out;
}
ptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);
for (; addr != end; ptep++, addr += PAGE_SIZE) {
pte_t pte = *ptep;
if (pte_none(pte))
__mincore_unmapped_range(addr, addr + PAGE_SIZE,
vma, vec);
else if (pte_present(pte))
*vec = 1;
else { 
swp_entry_t entry = pte_to_swp_entry(pte);
if (non_swap_entry(entry)) {
*vec = 1;
} else {
#ifdef CONFIG_SWAP
*vec = mincore_page(swap_address_space(entry),
swp_offset(entry));
#else
WARN_ON(1);
*vec = 1;
#endif
}
}
vec++;
}
pte_unmap_unlock(ptep - 1, ptl);
out:
walk->private += nr;
cond_resched();
return 0;
}","static int mincore_pte_range(pmd_t *VAR_0, unsigned long VAR_1, unsigned long VAR_2,
struct mm_walk *VAR_3)
{
spinlock_t *VAR_4;
struct vm_area_struct *VAR_5 = VAR_3->vma;
pte_t *VAR_6;
unsigned char *VAR_7 = VAR_3->private;
int VAR_8 = (VAR_2 - VAR_1) >> VAR_9;
VAR_4 = pmd_trans_huge_lock(VAR_0, VAR_5);
if (VAR_4) {
memset(VAR_7, 1, VAR_8);
spin_unlock(VAR_4);
goto out;
}
if (pmd_trans_unstable(VAR_0)) {
__mincore_unmapped_range(VAR_1, VAR_2, VAR_5, VAR_7);
goto out;
}
VAR_6 = pte_offset_map_lock(VAR_3->mm, VAR_0, VAR_1, &VAR_4);
for (; VAR_1 != VAR_2; VAR_6++, VAR_1 += VAR_10) {
pte_t VAR_11 = *VAR_6;
if (pte_none(VAR_11))
__mincore_unmapped_range(VAR_1, VAR_1 + VAR_10,
VAR_5, VAR_7);
else if (pte_present(VAR_11))
*VAR_7 = 1;
else { 
swp_entry_t VAR_12 = pte_to_swp_entry(VAR_11);
if (non_swap_entry(VAR_12)) {
*VAR_7 = 1;
} else {
#ifdef VAR_13
*VAR_7 = mincore_page(swap_address_space(VAR_12),
swp_offset(VAR_12));
#else
WARN_ON(1);
*VAR_7 = 1;
#endif
}
}
VAR_7++;
}
pte_unmap_unlock(VAR_6 - 1, VAR_4);
out:
VAR_3->private += VAR_8;
cond_resched();
return 0;
}",torvalds/linux/574823bfab82d9d8fa47f422778043fbb4b4f50e/mincore.c/vul/before/0.json,"static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
			struct mm_walk *walk)
{
	spinlock_t *ptl;
	struct vm_area_struct *vma = walk->vma;
	pte_t *ptep;
	unsigned char *vec = walk->private;
	int nr = (end - addr) >> PAGE_SHIFT;

	ptl = pmd_trans_huge_lock(pmd, vma);
	if (ptl) {
		memset(vec, 1, nr);
		spin_unlock(ptl);
		goto out;
	}

	/* We'll consider a THP page under construction to be there */
	if (pmd_trans_unstable(pmd)) {
		memset(vec, 1, nr);
		goto out;
	}

	ptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);
	for (; addr != end; ptep++, addr += PAGE_SIZE) {
		pte_t pte = *ptep;

		if (pte_none(pte))
			*vec = 0;
		else if (pte_present(pte))
			*vec = 1;
		else { /* pte is a swap entry */
			swp_entry_t entry = pte_to_swp_entry(pte);

			/*
			 * migration or hwpoison entries are always
			 * uptodate
			 */
			*vec = !!non_swap_entry(entry);
		}
		vec++;
	}
	pte_unmap_unlock(ptep - 1, ptl);
out:
	walk->private += nr;
	cond_resched();
	return 0;
}","static int mincore_pte_range(pmd_t *VAR_0, unsigned long VAR_1, unsigned long VAR_2,
			struct mm_walk *VAR_3)
{
	spinlock_t *VAR_4;
	struct vm_area_struct *VAR_5 = VAR_3->vma;
	pte_t *VAR_6;
	unsigned char *VAR_7 = VAR_3->private;
	int VAR_8 = (VAR_2 - VAR_1) >> VAR_9;

	VAR_4 = pmd_trans_huge_lock(VAR_0, VAR_5);
	if (VAR_4) {
		memset(VAR_7, 1, VAR_8);
		spin_unlock(VAR_4);
		goto out;
	}

	/* COMMENT_0 */
	if (pmd_trans_unstable(VAR_0)) {
		memset(VAR_7, 1, VAR_8);
		goto out;
	}

	VAR_6 = pte_offset_map_lock(VAR_3->mm, VAR_0, VAR_1, &VAR_4);
	for (; VAR_1 != VAR_2; VAR_6++, VAR_1 += VAR_10) {
		pte_t VAR_11 = *VAR_6;

		if (pte_none(VAR_11))
			*VAR_7 = 0;
		else if (pte_present(VAR_11))
			*VAR_7 = 1;
		else { /* COMMENT_1 */
			swp_entry_t VAR_12 = pte_to_swp_entry(VAR_11);

			/* COMMENT_2 */
                                              
              
      
			*VAR_7 = !!non_swap_entry(VAR_12);
		}
		VAR_7++;
	}
	pte_unmap_unlock(VAR_6 - 1, VAR_4);
out:
	VAR_3->private += VAR_8;
	cond_resched();
	return 0;
}",torvalds/linux/574823bfab82d9d8fa47f422778043fbb4b4f50e/mincore.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,8 +14,9 @@
 		goto out;
 	}
 
+	/* We'll consider a THP page under construction to be there */
 	if (pmd_trans_unstable(pmd)) {
-		__mincore_unmapped_range(addr, end, vma, vec);
+		memset(vec, 1, nr);
 		goto out;
 	}
 
@@ -24,28 +25,17 @@
 		pte_t pte = *ptep;
 
 		if (pte_none(pte))
-			__mincore_unmapped_range(addr, addr + PAGE_SIZE,
-						 vma, vec);
+			*vec = 0;
 		else if (pte_present(pte))
 			*vec = 1;
 		else { /* pte is a swap entry */
 			swp_entry_t entry = pte_to_swp_entry(pte);
 
-			if (non_swap_entry(entry)) {
-				/*
-				 * migration or hwpoison entries are always
-				 * uptodate
-				 */
-				*vec = 1;
-			} else {
-#ifdef CONFIG_SWAP
-				*vec = mincore_page(swap_address_space(entry),
-						    swp_offset(entry));
-#else
-				WARN_ON(1);
-				*vec = 1;
-#endif
-			}
+			/*
+			 * migration or hwpoison entries are always
+			 * uptodate
+			 */
+			*vec = !!non_swap_entry(entry);
 		}
 		vec++;
 	}","{'deleted_lines': ['\t\t__mincore_unmapped_range(addr, end, vma, vec);', '\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,', '\t\t\t\t\t\t vma, vec);', '\t\t\tif (non_swap_entry(entry)) {', '\t\t\t\t/*', '\t\t\t\t * migration or hwpoison entries are always', '\t\t\t\t * uptodate', '\t\t\t\t */', '\t\t\t\t*vec = 1;', '\t\t\t} else {', '#ifdef CONFIG_SWAP', '\t\t\t\t*vec = mincore_page(swap_address_space(entry),', '\t\t\t\t\t\t    swp_offset(entry));', '#else', '\t\t\t\tWARN_ON(1);', '\t\t\t\t*vec = 1;', '#endif', '\t\t\t}'], 'added_lines': [""\t/* We'll consider a THP page under construction to be there */"", '\t\tmemset(vec, 1, nr);', '\t\t\t*vec = 0;', '\t\t\t/*', '\t\t\t * migration or hwpoison entries are always', '\t\t\t * uptodate', '\t\t\t */', '\t\t\t*vec = !!non_swap_entry(entry);']}",True,"The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server.",5.5,MEDIUM,1,test,2019-01-06T01:50:59Z,2
CVE-2019-5489,['CWE-319'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0.0,torvalds/linux,"Change mincore() to count ""mapped"" pages rather than ""cached"" pages

The semantics of what ""in core"" means for the mincore() system call are
somewhat unclear, but Linux has always (since 2.3.52, which is when
mincore() was initially done) treated it as ""page is available in page
cache"" rather than ""page is mapped in the mapping"".

The problem with that traditional semantic is that it exposes a lot of
system cache state that it really probably shouldn't, and that users
shouldn't really even care about.

So let's try to avoid that information leak by simply changing the
semantics to be that mincore() counts actual mapped pages, not pages
that might be cheaply mapped if they were faulted (note the ""might be""
part of the old semantics: being in the cache doesn't actually guarantee
that you can access them without IO anyway, since things like network
filesystems may have to revalidate the cache before use).

In many ways the old semantics were somewhat insane even aside from the
information leak issue.  From the very beginning (and that beginning is
a long time ago: 2.3.52 was released in March 2000, I think), the code
had a comment saying

  Later we can get more picky about what ""in core"" means precisely.

and this is that ""later"".  Admittedly it is much later than is really
comfortable.

NOTE! This is a real semantic change, and it is for example known to
change the output of ""fincore"", since that program literally does a
mmmap without populating it, and then doing ""mincore()"" on that mapping
that doesn't actually have any pages in it.

I'm hoping that nobody actually has any workflow that cares, and the
info leak is real.

We may have to do something different if it turns out that people have
valid reasons to want the old semantics, and if we can limit the
information leak sanely.

Cc: Kevin Easton <kevin@guarana.org>
Cc: Jiri Kosina <jikos@kernel.org>
Cc: Masatake YAMATO <yamato@redhat.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Greg KH <gregkh@linuxfoundation.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Michal Hocko <mhocko@suse.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",574823bfab82d9d8fa47f422778043fbb4b4f50e,https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e,mm/mincore.c,mincore_unmapped_range,"static int mincore_unmapped_range(unsigned long addr, unsigned long end,
struct mm_walk *walk)
{
walk->private += __mincore_unmapped_range(addr, end,
walk->vma, walk->private);
return 0;
}","static int mincore_unmapped_range(unsigned long VAR_0, unsigned long VAR_1,
struct mm_walk *VAR_2)
{
VAR_2->private += __mincore_unmapped_range(VAR_0, VAR_1,
VAR_2->vma, VAR_2->private);
return 0;
}",torvalds/linux/574823bfab82d9d8fa47f422778043fbb4b4f50e/mincore.c/vul/before/1.json,"static int mincore_unmapped_range(unsigned long addr, unsigned long end,
				   struct mm_walk *walk)
{
	unsigned char *vec = walk->private;
	unsigned long nr = (end - addr) >> PAGE_SHIFT;

	memset(vec, 0, nr);
	walk->private += nr;
	return 0;
}","static int mincore_unmapped_range(unsigned long VAR_0, unsigned long VAR_1,
				   struct mm_walk *VAR_2)
{
	unsigned char *VAR_3 = VAR_2->private;
	unsigned long VAR_4 = (VAR_1 - VAR_0) >> VAR_5;

	memset(VAR_3, 0, VAR_4);
	VAR_2->private += VAR_4;
	return 0;
}",torvalds/linux/574823bfab82d9d8fa47f422778043fbb4b4f50e/mincore.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,10 @@
 static int mincore_unmapped_range(unsigned long addr, unsigned long end,
 				   struct mm_walk *walk)
 {
-	walk->private += __mincore_unmapped_range(addr, end,
-						  walk->vma, walk->private);
+	unsigned char *vec = walk->private;
+	unsigned long nr = (end - addr) >> PAGE_SHIFT;
+
+	memset(vec, 0, nr);
+	walk->private += nr;
 	return 0;
 }","{'deleted_lines': ['\twalk->private += __mincore_unmapped_range(addr, end,', '\t\t\t\t\t\t  walk->vma, walk->private);'], 'added_lines': ['\tunsigned char *vec = walk->private;', '\tunsigned long nr = (end - addr) >> PAGE_SHIFT;', '', '\tmemset(vec, 0, nr);', '\twalk->private += nr;']}",True,"The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server.",5.5,MEDIUM,1,test,2019-01-06T01:50:59Z,2
CVE-2018-20749,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,LibVNC/libvncserver,"Error out in rfbProcessFileTransferReadBuffer if length can not be allocated

re #273",15bb719c03cc70f14c36a843dcb16ed69b405707,https://github.com/LibVNC/libvncserver/commit/15bb719c03cc70f14c36a843dcb16ed69b405707,libvncserver/rfbserver.c,rfbProcessFileTransferReadBuffer,"char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)
{
char *buffer=NULL;
int   n=0;
FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("""", cl, NULL);
if (length>0) {
buffer=malloc((uint64_t)length+1);
if (buffer!=NULL) {
if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {
if (n != 0)
rfbLogPerror(""rfbProcessFileTransferReadBuffer: read"");
rfbCloseClient(cl);
if (buffer!=NULL) free(buffer);
return NULL;
}
buffer[length]=0;
}
}
return buffer;
}","char *rfbProcessFileTransferReadBuffer(rfbClientPtr VAR_0, uint32_t VAR_1)
{
char *VAR_2=NULL;
int   VAR_3=0;
FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("""", VAR_0, NULL);
if (VAR_1>0) {
VAR_2=malloc((uint64_t)VAR_1+1);
if (VAR_2!=NULL) {
if ((VAR_3 = rfbReadExact(VAR_0, (char *)VAR_2, VAR_1)) <= 0) {
if (VAR_3 != 0)
rfbLogPerror(""rfbProcessFileTransferReadBuffer: read"");
rfbCloseClient(VAR_0);
if (VAR_2!=NULL) free(VAR_2);
return NULL;
}
VAR_2[VAR_1]=0;
}
}
return VAR_2;
}",LibVNC/libvncserver/15bb719c03cc70f14c36a843dcb16ed69b405707/rfbserver.c/vul/before/0.json,"char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)
{
    char *buffer=NULL;
    int   n=0;

    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("""", cl, NULL);

    /*
       We later alloc length+1, which might wrap around on 32-bit systems if length equals
       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF
       will safely be allocated since this check will never trigger and malloc() can digest length+1
       without problems as length is a uint32_t.
    */
    if(length == SIZE_MAX) {
	rfbErr(""rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u"", (unsigned int)length);
	rfbCloseClient(cl);
	return NULL;
    }

    if (length>0) {
        buffer=malloc((size_t)length+1);
        if (buffer!=NULL) {
            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {
                if (n != 0)
                    rfbLogPerror(""rfbProcessFileTransferReadBuffer: read"");
                rfbCloseClient(cl);
                /* NOTE: don't forget to free(buffer) if you return early! */
                if (buffer!=NULL) free(buffer);
                return NULL;
            }
            /* Null Terminate */
            buffer[length]=0;
        }
    }
    return buffer;
}","char *rfbProcessFileTransferReadBuffer(rfbClientPtr VAR_0, uint32_t VAR_1)
{
    char *VAR_2=NULL;
    int   VAR_3=0;

    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("""", VAR_0, NULL);

    /* COMMENT_0 */
                                                                                          
                                                                                              
                                                                                                    
                                                
      
    if(VAR_1 == VAR_4) {
	rfbErr(""rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u"", (unsigned int)VAR_1);
	rfbCloseClient(VAR_0);
	return NULL;
    }

    if (VAR_1>0) {
        VAR_2=malloc((size_t)VAR_1+1);
        if (VAR_2!=NULL) {
            if ((VAR_3 = rfbReadExact(VAR_0, (char *)VAR_2, VAR_1)) <= 0) {
                if (VAR_3 != 0)
                    rfbLogPerror(""rfbProcessFileTransferReadBuffer: read"");
                rfbCloseClient(VAR_0);
                /* COMMENT_6 */
                if (VAR_2!=NULL) free(VAR_2);
                return NULL;
            }
            /* COMMENT_7 */
            VAR_2[VAR_1]=0;
        }
    }
    return VAR_2;
}",LibVNC/libvncserver/15bb719c03cc70f14c36a843dcb16ed69b405707/rfbserver.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,11 +4,21 @@
     int   n=0;
 
     FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("""", cl, NULL);
+
     /*
-    rfbLog(""rfbProcessFileTransferReadBuffer(%dlen)\n"", length);
+       We later alloc length+1, which might wrap around on 32-bit systems if length equals
+       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF
+       will safely be allocated since this check will never trigger and malloc() can digest length+1
+       without problems as length is a uint32_t.
     */
+    if(length == SIZE_MAX) {
+	rfbErr(""rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u"", (unsigned int)length);
+	rfbCloseClient(cl);
+	return NULL;
+    }
+
     if (length>0) {
-        buffer=malloc((uint64_t)length+1);
+        buffer=malloc((size_t)length+1);
         if (buffer!=NULL) {
             if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {
                 if (n != 0)","{'deleted_lines': ['    rfbLog(""rfbProcessFileTransferReadBuffer(%dlen)\\n"", length);', '        buffer=malloc((uint64_t)length+1);'], 'added_lines': ['', '       We later alloc length+1, which might wrap around on 32-bit systems if length equals', '       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF', '       will safely be allocated since this check will never trigger and malloc() can digest length+1', '       without problems as length is a uint32_t.', '    if(length == SIZE_MAX) {', '\trfbErr(""rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u"", (unsigned int)length);', '\trfbCloseClient(cl);', '\treturn NULL;', '    }', '', '        buffer=malloc((size_t)length+1);']}",True,LibVNC before 0.9.12 contains a heap out-of-bounds write vulnerability in libvncserver/rfbserver.c. The fix for CVE-2018-15127 was incomplete.,9.8,CRITICAL,3,test,2019-01-06T14:13:56Z,2
CVE-2019-5736,['CWE-78'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0.0,opencontainers/runc,"nsenter: clone /proc/self/exe to avoid exposing host binary to container

There are quite a few circumstances where /proc/self/exe pointing to a
pretty important container binary is a _bad_ thing, so to avoid this we
have to make a copy (preferably doing self-clean-up and not being
writeable).

We require memfd_create(2) -- though there is an O_TMPFILE fallback --
but we can always extend this to use a scratch MNT_DETACH overlayfs or
tmpfs. The main downside to this approach is no page-cache sharing for
the runc binary (which overlayfs would give us) but this is far less
complicated.

This is only done during nsenter so that it happens transparently to the
Go code, and any libcontainer users benefit from it. This also makes
ExtraFiles and --preserve-fds handling trivial (because we don't need to
worry about it).

Fixes: CVE-2019-5736
Co-developed-by: Christian Brauner <christian.brauner@ubuntu.com>
Signed-off-by: Aleksa Sarai <asarai@suse.de>",0a8e4117e7f715d5fbeef398405813ce8e88558b,https://github.com/opencontainers/runc/commit/0a8e4117e7f715d5fbeef398405813ce8e88558b,libcontainer/nsenter/nsexec.c,nsexec,"void nsexec(void)
{
int pipenum;
jmp_buf env;
int sync_child_pipe[2], sync_grandchild_pipe[2];
struct nlconfig_t config = { 0 };
pipenum = initpipe();
if (pipenum == -1)
return;
nl_parse(pipenum, &config);
update_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);
if (config.namespaces) {
if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)
bail(""failed to set process as non-dumpable"");
}
if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)
bail(""failed to setup sync pipe between parent and child"");
if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)
bail(""failed to setup sync pipe between parent and grandchild"");
switch (setjmp(env)) {
case JUMP_PARENT:{
int len;
pid_t child, first_child = -1;
bool ready = false;
prctl(PR_SET_NAME, (unsigned long)""runc:[0:PARENT]"", 0, 0, 0);
child = clone_parent(&env, JUMP_CHILD);
if (child < 0)
bail(""unable to fork: child_func"");
while (!ready) {
enum sync_t s;
int ret;
syncfd = sync_child_pipe[1];
close(sync_child_pipe[0]);
if (read(syncfd, &s, sizeof(s)) != sizeof(s))
bail(""failed to sync with child: next state"");
switch (s) {
case SYNC_ERR:
if (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))
bail(""failed to sync with child: read(error code)"");
exit(ret);
case SYNC_USERMAP_PLS:
if (config.is_rootless_euid && !config.is_setgroup)
update_setgroups(child, SETGROUPS_DENY);
update_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len);
update_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len);
s = SYNC_USERMAP_ACK;
if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
kill(child, SIGKILL);
bail(""failed to sync with child: write(SYNC_USERMAP_ACK)"");
}
break;
case SYNC_RECVPID_PLS:{
first_child = child;
if (read(syncfd, &child, sizeof(child)) != sizeof(child)) {
kill(first_child, SIGKILL);
bail(""failed to sync with child: read(childpid)"");
}
s = SYNC_RECVPID_ACK;
if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
kill(first_child, SIGKILL);
kill(child, SIGKILL);
bail(""failed to sync with child: write(SYNC_RECVPID_ACK)"");
}
len = dprintf(pipenum, ""{\""pid\"": %d, \""pid_first\"": %d}\n"", child, first_child);
if (len < 0) {
kill(child, SIGKILL);
bail(""unable to generate JSON for child pid"");
}
}
break;
case SYNC_CHILD_READY:
ready = true;
break;
default:
bail(""unexpected sync value: %u"", s);
}
}
ready = false;
while (!ready) {
enum sync_t s;
int ret;
syncfd = sync_grandchild_pipe[1];
close(sync_grandchild_pipe[0]);
s = SYNC_GRANDCHILD;
if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
kill(child, SIGKILL);
bail(""failed to sync with child: write(SYNC_GRANDCHILD)"");
}
if (read(syncfd, &s, sizeof(s)) != sizeof(s))
bail(""failed to sync with child: next state"");
switch (s) {
case SYNC_ERR:
if (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))
bail(""failed to sync with child: read(error code)"");
exit(ret);
case SYNC_CHILD_READY:
ready = true;
break;
default:
bail(""unexpected sync value: %u"", s);
}
}
exit(0);
}
case JUMP_CHILD:{
pid_t child;
enum sync_t s;
syncfd = sync_child_pipe[0];
close(sync_child_pipe[1]);
prctl(PR_SET_NAME, (unsigned long)""runc:[1:CHILD]"", 0, 0, 0);
if (config.namespaces)
join_namespaces(config.namespaces);
if (config.cloneflags & CLONE_NEWUSER) {
if (unshare(CLONE_NEWUSER) < 0)
bail(""failed to unshare user namespace"");
config.cloneflags &= ~CLONE_NEWUSER;
if (config.namespaces) {
if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)
bail(""failed to set process as dumpable"");
}
s = SYNC_USERMAP_PLS;
if (write(syncfd, &s, sizeof(s)) != sizeof(s))
bail(""failed to sync with parent: write(SYNC_USERMAP_PLS)"");
if (read(syncfd, &s, sizeof(s)) != sizeof(s))
bail(""failed to sync with parent: read(SYNC_USERMAP_ACK)"");
if (s != SYNC_USERMAP_ACK)
bail(""failed to sync with parent: SYNC_USERMAP_ACK: got %u"", s);
if (config.namespaces) {
if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)
bail(""failed to set process as dumpable"");
}
if (setresuid(0, 0, 0) < 0)
bail(""failed to become root in user namespace"");
}
if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)
bail(""failed to unshare namespaces"");
child = clone_parent(&env, JUMP_INIT);
if (child < 0)
bail(""unable to fork: init_func"");
s = SYNC_RECVPID_PLS;
if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
kill(child, SIGKILL);
bail(""failed to sync with parent: write(SYNC_RECVPID_PLS)"");
}
if (write(syncfd, &child, sizeof(child)) != sizeof(child)) {
kill(child, SIGKILL);
bail(""failed to sync with parent: write(childpid)"");
}
if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {
kill(child, SIGKILL);
bail(""failed to sync with parent: read(SYNC_RECVPID_ACK)"");
}
if (s != SYNC_RECVPID_ACK) {
kill(child, SIGKILL);
bail(""failed to sync with parent: SYNC_RECVPID_ACK: got %u"", s);
}
s = SYNC_CHILD_READY;
if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
kill(child, SIGKILL);
bail(""failed to sync with parent: write(SYNC_CHILD_READY)"");
}
exit(0);
}
case JUMP_INIT:{
enum sync_t s;
syncfd = sync_grandchild_pipe[0];
close(sync_grandchild_pipe[1]);
close(sync_child_pipe[0]);
close(sync_child_pipe[1]);
prctl(PR_SET_NAME, (unsigned long)""runc:[2:INIT]"", 0, 0, 0);
if (read(syncfd, &s, sizeof(s)) != sizeof(s))
bail(""failed to sync with parent: read(SYNC_GRANDCHILD)"");
if (s != SYNC_GRANDCHILD)
bail(""failed to sync with parent: SYNC_GRANDCHILD: got %u"", s);
if (setsid() < 0)
bail(""setsid failed"");
if (setuid(0) < 0)
bail(""setuid failed"");
if (setgid(0) < 0)
bail(""setgid failed"");
if (!config.is_rootless_euid && config.is_setgroup) {
if (setgroups(0, NULL) < 0)
bail(""setgroups failed"");
}
if (config.cloneflags & CLONE_NEWCGROUP) {
uint8_t value;
if (read(pipenum, &value, sizeof(value)) != sizeof(value))
bail(""read synchronisation value failed"");
if (value == CREATECGROUPNS) {
if (unshare(CLONE_NEWCGROUP) < 0)
bail(""failed to unshare cgroup namespace"");
} else
bail(""received unknown synchronisation value"");
}
s = SYNC_CHILD_READY;
if (write(syncfd, &s, sizeof(s)) != sizeof(s))
bail(""failed to sync with patent: write(SYNC_CHILD_READY)"");
close(sync_grandchild_pipe[0]);
nl_free(&config);
return;
}
default:
bail(""unexpected jump value"");
}
bail(""should never be reached"");
}","void nsexec(void)
{
int VAR_0;
jmp_buf VAR_1;
int VAR_2[2], VAR_3[2];
struct nlconfig_t VAR_4 = { 0 };
VAR_0 = initpipe();
if (VAR_0 == -1)
return;
nl_parse(VAR_0, &VAR_4);
update_oom_score_adj(VAR_4.oom_score_adj, VAR_4.oom_score_adj_len);
if (VAR_4.namespaces) {
if (prctl(VAR_5, 0, 0, 0, 0) < 0)
bail(""failed to set process as non-dumpable"");
}
if (socketpair(VAR_6, VAR_7, 0, VAR_2) < 0)
bail(""failed to setup sync pipe between parent and child"");
if (socketpair(VAR_6, VAR_7, 0, VAR_3) < 0)
bail(""failed to setup sync pipe between parent and grandchild"");
switch (setjmp(VAR_1)) {
case VAR_8:{
int VAR_9;
pid_t VAR_10, VAR_11 = -1;
bool VAR_12 = false;
prctl(VAR_13, (unsigned long)""runc:[0:PARENT]"", 0, 0, 0);
VAR_10 = clone_parent(&VAR_1, VAR_14);
if (VAR_10 < 0)
bail(""unable to fork: child_func"");
while (!VAR_12) {
enum sync_t VAR_15;
int VAR_16;
VAR_17 = VAR_2[1];
close(VAR_2[0]);
if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
bail(""failed to sync with child: next state"");
switch (VAR_15) {
case VAR_18:
if (read(VAR_17, &VAR_16, sizeof(VAR_16)) != sizeof(VAR_16))
bail(""failed to sync with child: read(error code)"");
exit(VAR_16);
case VAR_19:
if (VAR_4.is_rootless_euid && !VAR_4.is_setgroup)
update_setgroups(VAR_10, VAR_20);
update_uidmap(VAR_4.uidmappath, VAR_10, VAR_4.uidmap, VAR_4.uidmap_len);
update_gidmap(VAR_4.gidmappath, VAR_10, VAR_4.gidmap, VAR_4.gidmap_len);
VAR_15 = VAR_21;
if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
kill(VAR_10, VAR_22);
bail(""failed to sync with child: write(SYNC_USERMAP_ACK)"");
}
break;
case VAR_23:{
VAR_11 = VAR_10;
if (read(VAR_17, &VAR_10, sizeof(VAR_10)) != sizeof(VAR_10)) {
kill(VAR_11, VAR_22);
bail(""failed to sync with child: read(childpid)"");
}
VAR_15 = VAR_24;
if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
kill(VAR_11, VAR_22);
kill(VAR_10, VAR_22);
bail(""failed to sync with child: write(SYNC_RECVPID_ACK)"");
}
VAR_9 = dprintf(VAR_0, ""{\""pid\"": %d, \""pid_first\"": %d}\n"", VAR_10, VAR_11);
if (VAR_9 < 0) {
kill(VAR_10, VAR_22);
bail(""unable to generate JSON for child pid"");
}
}
break;
case VAR_25:
VAR_12 = true;
break;
default:
bail(""unexpected sync value: %u"", VAR_15);
}
}
VAR_12 = false;
while (!VAR_12) {
enum sync_t VAR_15;
int VAR_16;
VAR_17 = VAR_3[1];
close(VAR_3[0]);
VAR_15 = VAR_26;
if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
kill(VAR_10, VAR_22);
bail(""failed to sync with child: write(SYNC_GRANDCHILD)"");
}
if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
bail(""failed to sync with child: next state"");
switch (VAR_15) {
case VAR_18:
if (read(VAR_17, &VAR_16, sizeof(VAR_16)) != sizeof(VAR_16))
bail(""failed to sync with child: read(error code)"");
exit(VAR_16);
case VAR_25:
VAR_12 = true;
break;
default:
bail(""unexpected sync value: %u"", VAR_15);
}
}
exit(0);
}
case VAR_14:{
pid_t VAR_10;
enum sync_t VAR_15;
VAR_17 = VAR_2[0];
close(VAR_2[1]);
prctl(VAR_13, (unsigned long)""runc:[1:CHILD]"", 0, 0, 0);
if (VAR_4.namespaces)
join_namespaces(VAR_4.namespaces);
if (VAR_4.cloneflags & VAR_27) {
if (unshare(VAR_27) < 0)
bail(""failed to unshare user namespace"");
VAR_4.cloneflags &= ~VAR_27;
if (VAR_4.namespaces) {
if (prctl(VAR_5, 1, 0, 0, 0) < 0)
bail(""failed to set process as dumpable"");
}
VAR_15 = VAR_19;
if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
bail(""failed to sync with parent: write(SYNC_USERMAP_PLS)"");
if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
bail(""failed to sync with parent: read(SYNC_USERMAP_ACK)"");
if (VAR_15 != VAR_21)
bail(""failed to sync with parent: SYNC_USERMAP_ACK: got %u"", VAR_15);
if (VAR_4.namespaces) {
if (prctl(VAR_5, 0, 0, 0, 0) < 0)
bail(""failed to set process as dumpable"");
}
if (setresuid(0, 0, 0) < 0)
bail(""failed to become root in user namespace"");
}
if (unshare(VAR_4.cloneflags & ~VAR_28) < 0)
bail(""failed to unshare namespaces"");
VAR_10 = clone_parent(&VAR_1, VAR_29);
if (VAR_10 < 0)
bail(""unable to fork: init_func"");
VAR_15 = VAR_23;
if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
kill(VAR_10, VAR_22);
bail(""failed to sync with parent: write(SYNC_RECVPID_PLS)"");
}
if (write(VAR_17, &VAR_10, sizeof(VAR_10)) != sizeof(VAR_10)) {
kill(VAR_10, VAR_22);
bail(""failed to sync with parent: write(childpid)"");
}
if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
kill(VAR_10, VAR_22);
bail(""failed to sync with parent: read(SYNC_RECVPID_ACK)"");
}
if (VAR_15 != VAR_24) {
kill(VAR_10, VAR_22);
bail(""failed to sync with parent: SYNC_RECVPID_ACK: got %u"", VAR_15);
}
VAR_15 = VAR_25;
if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
kill(VAR_10, VAR_22);
bail(""failed to sync with parent: write(SYNC_CHILD_READY)"");
}
exit(0);
}
case VAR_29:{
enum sync_t VAR_15;
VAR_17 = VAR_3[0];
close(VAR_3[1]);
close(VAR_2[0]);
close(VAR_2[1]);
prctl(VAR_13, (unsigned long)""runc:[2:INIT]"", 0, 0, 0);
if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
bail(""failed to sync with parent: read(SYNC_GRANDCHILD)"");
if (VAR_15 != VAR_26)
bail(""failed to sync with parent: SYNC_GRANDCHILD: got %u"", VAR_15);
if (setsid() < 0)
bail(""setsid failed"");
if (setuid(0) < 0)
bail(""setuid failed"");
if (setgid(0) < 0)
bail(""setgid failed"");
if (!VAR_4.is_rootless_euid && VAR_4.is_setgroup) {
if (setgroups(0, NULL) < 0)
bail(""setgroups failed"");
}
if (VAR_4.cloneflags & VAR_28) {
uint8_t VAR_30;
if (read(VAR_0, &VAR_30, sizeof(VAR_30)) != sizeof(VAR_30))
bail(""read synchronisation value failed"");
if (VAR_30 == VAR_31) {
if (unshare(VAR_28) < 0)
bail(""failed to unshare cgroup namespace"");
} else
bail(""received unknown synchronisation value"");
}
VAR_15 = VAR_25;
if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
bail(""failed to sync with patent: write(SYNC_CHILD_READY)"");
close(VAR_3[0]);
nl_free(&VAR_4);
return;
}
default:
bail(""unexpected jump value"");
}
bail(""should never be reached"");
}",opencontainers/runc/0a8e4117e7f715d5fbeef398405813ce8e88558b/nsexec.c/vul/before/0.json,"void nsexec(void)
{
	int pipenum;
	jmp_buf env;
	int sync_child_pipe[2], sync_grandchild_pipe[2];
	struct nlconfig_t config = { 0 };

	/*
	 * If we don't have an init pipe, just return to the go routine.
	 * We'll only get an init pipe for start or exec.
	 */
	pipenum = initpipe();
	if (pipenum == -1)
		return;

	/*
	 * We need to re-exec if we are not in a cloned binary. This is necessary
	 * to ensure that containers won't be able to access the host binary
	 * through /proc/self/exe. See CVE-2019-5736.
	 */
	if (ensure_cloned_binary() < 0)
		bail(""could not ensure we are a cloned binary"");

	/* Parse all of the netlink configuration. */
	nl_parse(pipenum, &config);

	/* Set oom_score_adj. This has to be done before !dumpable because
	 * /proc/self/oom_score_adj is not writeable unless you're an privileged
	 * user (if !dumpable is set). All children inherit their parent's
	 * oom_score_adj value on fork(2) so this will always be propagated
	 * properly.
	 */
	update_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);

	/*
	 * Make the process non-dumpable, to avoid various race conditions that
	 * could cause processes in namespaces we're joining to access host
	 * resources (or potentially execute code).
	 *
	 * However, if the number of namespaces we are joining is 0, we are not
	 * going to be switching to a different security context. Thus setting
	 * ourselves to be non-dumpable only breaks things (like rootless
	 * containers), which is the recommendation from the kernel folks.
	 */
	if (config.namespaces) {
		if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)
			bail(""failed to set process as non-dumpable"");
	}

	/* Pipe so we can tell the child when we've finished setting up. */
	if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)
		bail(""failed to setup sync pipe between parent and child"");

	/*
	 * We need a new socketpair to sync with grandchild so we don't have
	 * race condition with child.
	 */
	if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)
		bail(""failed to setup sync pipe between parent and grandchild"");

	/* TODO: Currently we aren't dealing with child deaths properly. */

	/*
	 * Okay, so this is quite annoying.
	 *
	 * In order for this unsharing code to be more extensible we need to split
	 * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case
	 * would be if we did clone(CLONE_NEWUSER) and the other namespaces
	 * separately, but because of SELinux issues we cannot really do that. But
	 * we cannot just dump the namespace flags into clone(...) because several
	 * usecases (such as rootless containers) require more granularity around
	 * the namespace setup. In addition, some older kernels had issues where
	 * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot
	 * handle this while also dealing with SELinux so we choose SELinux support
	 * over broken kernel support).
	 *
	 * However, if we unshare(2) the user namespace *before* we clone(2), then
	 * all hell breaks loose.
	 *
	 * The parent no longer has permissions to do many things (unshare(2) drops
	 * all capabilities in your old namespace), and the container cannot be set
	 * up to have more than one {uid,gid} mapping. This is obviously less than
	 * ideal. In order to fix this, we have to first clone(2) and then unshare.
	 *
	 * Unfortunately, it's not as simple as that. We have to fork to enter the
	 * PID namespace (the PID namespace only applies to children). Since we'll
	 * have to double-fork, this clone_parent() call won't be able to get the
	 * PID of the _actual_ init process (without doing more synchronisation than
	 * I can deal with at the moment). So we'll just get the parent to send it
	 * for us, the only job of this process is to update
	 * /proc/pid/{setgroups,uid_map,gid_map}.
	 *
	 * And as a result of the above, we also need to setns(2) in the first child
	 * because if we join a PID namespace in the topmost parent then our child
	 * will be in that namespace (and it will not be able to give us a PID value
	 * that makes sense without resorting to sending things with cmsg).
	 *
	 * This also deals with an older issue caused by dumping cloneflags into
	 * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so
	 * we have to unshare(2) before clone(2) in order to do this. This was fixed
	 * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was
	 * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're
	 * aware, the last mainline kernel which had this bug was Linux 3.12.
	 * However, we cannot comment on which kernels the broken patch was
	 * backported to.
	 *
	 * -- Aleksa ""what has my life come to?"" Sarai
	 */

	switch (setjmp(env)) {
		/*
		 * Stage 0: We're in the parent. Our job is just to create a new child
		 *          (stage 1: JUMP_CHILD) process and write its uid_map and
		 *          gid_map. That process will go on to create a new process, then
		 *          it will send us its PID which we will send to the bootstrap
		 *          process.
		 */
	case JUMP_PARENT:{
			int len;
			pid_t child, first_child = -1;
			bool ready = false;

			/* For debugging. */
			prctl(PR_SET_NAME, (unsigned long)""runc:[0:PARENT]"", 0, 0, 0);

			/* Start the process of getting a container. */
			child = clone_parent(&env, JUMP_CHILD);
			if (child < 0)
				bail(""unable to fork: child_func"");

			/*
			 * State machine for synchronisation with the children.
			 *
			 * Father only return when both child and grandchild are
			 * ready, so we can receive all possible error codes
			 * generated by children.
			 */
			while (!ready) {
				enum sync_t s;
				int ret;

				syncfd = sync_child_pipe[1];
				close(sync_child_pipe[0]);

				if (read(syncfd, &s, sizeof(s)) != sizeof(s))
					bail(""failed to sync with child: next state"");

				switch (s) {
				case SYNC_ERR:
					/* We have to mirror the error code of the child. */
					if (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))
						bail(""failed to sync with child: read(error code)"");

					exit(ret);
				case SYNC_USERMAP_PLS:
					/*
					 * Enable setgroups(2) if we've been asked to. But we also
					 * have to explicitly disable setgroups(2) if we're
					 * creating a rootless container for single-entry mapping.
					 * i.e. config.is_setgroup == false.
					 * (this is required since Linux 3.19).
					 *
					 * For rootless multi-entry mapping, config.is_setgroup shall be true and
					 * newuidmap/newgidmap shall be used.
					 */

					if (config.is_rootless_euid && !config.is_setgroup)
						update_setgroups(child, SETGROUPS_DENY);

					/* Set up mappings. */
					update_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len);
					update_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len);

					s = SYNC_USERMAP_ACK;
					if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
						kill(child, SIGKILL);
						bail(""failed to sync with child: write(SYNC_USERMAP_ACK)"");
					}
					break;
				case SYNC_RECVPID_PLS:{
						first_child = child;

						/* Get the init_func pid. */
						if (read(syncfd, &child, sizeof(child)) != sizeof(child)) {
							kill(first_child, SIGKILL);
							bail(""failed to sync with child: read(childpid)"");
						}

						/* Send ACK. */
						s = SYNC_RECVPID_ACK;
						if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
							kill(first_child, SIGKILL);
							kill(child, SIGKILL);
							bail(""failed to sync with child: write(SYNC_RECVPID_ACK)"");
						}

						/* Send the init_func pid back to our parent.
						 *
						 * Send the init_func pid and the pid of the first child back to our parent.
						 * We need to send both back because we can't reap the first child we created (CLONE_PARENT).
						 * It becomes the responsibility of our parent to reap the first child.
						 */
						len = dprintf(pipenum, ""{\""pid\"": %d, \""pid_first\"": %d}\n"", child, first_child);
						if (len < 0) {
							kill(child, SIGKILL);
							bail(""unable to generate JSON for child pid"");
						}
					}
					break;
				case SYNC_CHILD_READY:
					ready = true;
					break;
				default:
					bail(""unexpected sync value: %u"", s);
				}
			}

			/* Now sync with grandchild. */

			ready = false;
			while (!ready) {
				enum sync_t s;
				int ret;

				syncfd = sync_grandchild_pipe[1];
				close(sync_grandchild_pipe[0]);

				s = SYNC_GRANDCHILD;
				if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
					kill(child, SIGKILL);
					bail(""failed to sync with child: write(SYNC_GRANDCHILD)"");
				}

				if (read(syncfd, &s, sizeof(s)) != sizeof(s))
					bail(""failed to sync with child: next state"");

				switch (s) {
				case SYNC_ERR:
					/* We have to mirror the error code of the child. */
					if (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))
						bail(""failed to sync with child: read(error code)"");

					exit(ret);
				case SYNC_CHILD_READY:
					ready = true;
					break;
				default:
					bail(""unexpected sync value: %u"", s);
				}
			}
			exit(0);
		}

		/*
		 * Stage 1: We're in the first child process. Our job is to join any
		 *          provided namespaces in the netlink payload and unshare all
		 *          of the requested namespaces. If we've been asked to
		 *          CLONE_NEWUSER, we will ask our parent (stage 0) to set up
		 *          our user mappings for us. Then, we create a new child
		 *          (stage 2: JUMP_INIT) for PID namespace. We then send the
		 *          child's PID to our parent (stage 0).
		 */
	case JUMP_CHILD:{
			pid_t child;
			enum sync_t s;

			/* We're in a child and thus need to tell the parent if we die. */
			syncfd = sync_child_pipe[0];
			close(sync_child_pipe[1]);

			/* For debugging. */
			prctl(PR_SET_NAME, (unsigned long)""runc:[1:CHILD]"", 0, 0, 0);

			/*
			 * We need to setns first. We cannot do this earlier (in stage 0)
			 * because of the fact that we forked to get here (the PID of
			 * [stage 2: JUMP_INIT]) would be meaningless). We could send it
			 * using cmsg(3) but that's just annoying.
			 */
			if (config.namespaces)
				join_namespaces(config.namespaces);

			/*
			 * Deal with user namespaces first. They are quite special, as they
			 * affect our ability to unshare other namespaces and are used as
			 * context for privilege checks.
			 *
			 * We don't unshare all namespaces in one go. The reason for this
			 * is that, while the kernel documentation may claim otherwise,
			 * there are certain cases where unsharing all namespaces at once
			 * will result in namespace objects being owned incorrectly.
			 * Ideally we should just fix these kernel bugs, but it's better to
			 * be safe than sorry, and fix them separately.
			 *
			 * A specific case of this is that the SELinux label of the
			 * internal kern-mount that mqueue uses will be incorrect if the
			 * UTS namespace is cloned before the USER namespace is mapped.
			 * I've also heard of similar problems with the network namespace
			 * in some scenarios. This also mirrors how LXC deals with this
			 * problem.
			 */
			if (config.cloneflags & CLONE_NEWUSER) {
				if (unshare(CLONE_NEWUSER) < 0)
					bail(""failed to unshare user namespace"");
				config.cloneflags &= ~CLONE_NEWUSER;

				/*
				 * We don't have the privileges to do any mapping here (see the
				 * clone_parent rant). So signal our parent to hook us up.
				 */

				/* Switching is only necessary if we joined namespaces. */
				if (config.namespaces) {
					if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)
						bail(""failed to set process as dumpable"");
				}
				s = SYNC_USERMAP_PLS;
				if (write(syncfd, &s, sizeof(s)) != sizeof(s))
					bail(""failed to sync with parent: write(SYNC_USERMAP_PLS)"");

				/* ... wait for mapping ... */

				if (read(syncfd, &s, sizeof(s)) != sizeof(s))
					bail(""failed to sync with parent: read(SYNC_USERMAP_ACK)"");
				if (s != SYNC_USERMAP_ACK)
					bail(""failed to sync with parent: SYNC_USERMAP_ACK: got %u"", s);
				/* Switching is only necessary if we joined namespaces. */
				if (config.namespaces) {
					if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)
						bail(""failed to set process as dumpable"");
				}

				/* Become root in the namespace proper. */
				if (setresuid(0, 0, 0) < 0)
					bail(""failed to become root in user namespace"");
			}
			/*
			 * Unshare all of the namespaces. Now, it should be noted that this
			 * ordering might break in the future (especially with rootless
			 * containers). But for now, it's not possible to split this into
			 * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.
			 *
			 * Note that we don't merge this with clone() because there were
			 * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)
			 * was broken, so we'll just do it the long way anyway.
			 */
			if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)
				bail(""failed to unshare namespaces"");

			/*
			 * TODO: What about non-namespace clone flags that we're dropping here?
			 *
			 * We fork again because of PID namespace, setns(2) or unshare(2) don't
			 * change the PID namespace of the calling process, because doing so
			 * would change the caller's idea of its own PID (as reported by getpid()),
			 * which would break many applications and libraries, so we must fork
			 * to actually enter the new PID namespace.
			 */
			child = clone_parent(&env, JUMP_INIT);
			if (child < 0)
				bail(""unable to fork: init_func"");

			/* Send the child to our parent, which knows what it's doing. */
			s = SYNC_RECVPID_PLS;
			if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
				kill(child, SIGKILL);
				bail(""failed to sync with parent: write(SYNC_RECVPID_PLS)"");
			}
			if (write(syncfd, &child, sizeof(child)) != sizeof(child)) {
				kill(child, SIGKILL);
				bail(""failed to sync with parent: write(childpid)"");
			}

			/* ... wait for parent to get the pid ... */

			if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {
				kill(child, SIGKILL);
				bail(""failed to sync with parent: read(SYNC_RECVPID_ACK)"");
			}
			if (s != SYNC_RECVPID_ACK) {
				kill(child, SIGKILL);
				bail(""failed to sync with parent: SYNC_RECVPID_ACK: got %u"", s);
			}

			s = SYNC_CHILD_READY;
			if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {
				kill(child, SIGKILL);
				bail(""failed to sync with parent: write(SYNC_CHILD_READY)"");
			}

			/* Our work is done. [Stage 2: JUMP_INIT] is doing the rest of the work. */
			exit(0);
		}

		/*
		 * Stage 2: We're the final child process, and the only process that will
		 *          actually return to the Go runtime. Our job is to just do the
		 *          final cleanup steps and then return to the Go runtime to allow
		 *          init_linux.go to run.
		 */
	case JUMP_INIT:{
			/*
			 * We're inside the child now, having jumped from the
			 * start_child() code after forking in the parent.
			 */
			enum sync_t s;

			/* We're in a child and thus need to tell the parent if we die. */
			syncfd = sync_grandchild_pipe[0];
			close(sync_grandchild_pipe[1]);
			close(sync_child_pipe[0]);
			close(sync_child_pipe[1]);

			/* For debugging. */
			prctl(PR_SET_NAME, (unsigned long)""runc:[2:INIT]"", 0, 0, 0);

			if (read(syncfd, &s, sizeof(s)) != sizeof(s))
				bail(""failed to sync with parent: read(SYNC_GRANDCHILD)"");
			if (s != SYNC_GRANDCHILD)
				bail(""failed to sync with parent: SYNC_GRANDCHILD: got %u"", s);

			if (setsid() < 0)
				bail(""setsid failed"");

			if (setuid(0) < 0)
				bail(""setuid failed"");

			if (setgid(0) < 0)
				bail(""setgid failed"");

			if (!config.is_rootless_euid && config.is_setgroup) {
				if (setgroups(0, NULL) < 0)
					bail(""setgroups failed"");
			}

			/* ... wait until our topmost parent has finished cgroup setup in p.manager.Apply() ... */
			if (config.cloneflags & CLONE_NEWCGROUP) {
				uint8_t value;
				if (read(pipenum, &value, sizeof(value)) != sizeof(value))
					bail(""read synchronisation value failed"");
				if (value == CREATECGROUPNS) {
					if (unshare(CLONE_NEWCGROUP) < 0)
						bail(""failed to unshare cgroup namespace"");
				} else
					bail(""received unknown synchronisation value"");
			}

			s = SYNC_CHILD_READY;
			if (write(syncfd, &s, sizeof(s)) != sizeof(s))
				bail(""failed to sync with patent: write(SYNC_CHILD_READY)"");

			/* Close sync pipes. */
			close(sync_grandchild_pipe[0]);

			/* Free netlink data. */
			nl_free(&config);

			/* Finish executing, let the Go runtime take over. */
			return;
		}
	default:
		bail(""unexpected jump value"");
	}

	/* Should never be reached. */
	bail(""should never be reached"");
}","void nsexec(void)
{
	int VAR_0;
	jmp_buf VAR_1;
	int VAR_2[2], VAR_3[2];
	struct nlconfig_t VAR_4 = { 0 };

	/* COMMENT_0 */
                                                                 
                                                  
    
	VAR_0 = initpipe();
	if (VAR_0 == -1)
		return;

	/* COMMENT_4 */
                                                                          
                                                                     
                                              
    
	if (ensure_cloned_binary() < 0)
		bail(""could not ensure we are a cloned binary"");

	/* COMMENT_9 */
	nl_parse(VAR_0, &VAR_4);

	/* COMMENT_10 */
                                                                         
                                                                   
                                                                    
             
    
	update_oom_score_adj(VAR_4.oom_score_adj, VAR_4.oom_score_adj_len);

	/* COMMENT_16 */
                                                                        
                                                                    
                                            
   
                                                                        
                                                                       
                                                                  
                                                                   
    
	if (VAR_4.namespaces) {
		if (prctl(VAR_5, 0, 0, 0, 0) < 0)
			bail(""failed to set process as non-dumpable"");
	}

	/* COMMENT_26 */
	if (socketpair(VAR_6, VAR_7, 0, VAR_2) < 0)
		bail(""failed to setup sync pipe between parent and child"");

	/* COMMENT_27 */
                                                                     
                              
    
	if (socketpair(VAR_6, VAR_7, 0, VAR_3) < 0)
		bail(""failed to setup sync pipe between parent and grandchild"");

	/* COMMENT_31 */

	/* COMMENT_32 */
                                    
   
                                                                           
                                                                         
                                                                    
                                                                           
                                                                           
                                                                          
                                                                         
                                                                       
                                                                            
                                
   
                                                                           
                          
   
                                                                            
                                                                            
                                                                           
                                                                            
   
                                                                           
                                                                           
                                                                          
                                                                             
                                                                           
                                                     
                                          
   
                                                                             
                                                                           
                                                                             
                                                                    
   
                                                                         
                                                                            
                                                                             
                                                                        
                                                                           
                                                                      
                                                                    
                  
   
                                               
    

	switch (setjmp(VAR_1)) {
		/* COMMENT_72 */
                                                                        
                                                                     
                                                                            
                                                                         
                      
     
	case VAR_8:{
			int VAR_9;
			pid_t VAR_10, VAR_11 = -1;
			bool VAR_12 = false;

			/* COMMENT_79 */
			prctl(VAR_13, (unsigned long)""runc:[0:PARENT]"", 0, 0, 0);

			/* COMMENT_80 */
			VAR_10 = clone_parent(&VAR_1, VAR_14);
			if (VAR_10 < 0)
				bail(""unable to fork: child_func"");

			/* COMMENT_81 */
                                                          
     
                                                           
                                                       
                            
      
			while (!VAR_12) {
				enum sync_t VAR_15;
				int VAR_16;

				VAR_17 = VAR_2[1];
				close(VAR_2[0]);

				if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
					bail(""failed to sync with child: next state"");

				switch (VAR_15) {
				case VAR_18:
					/* COMMENT_88 */
					if (read(VAR_17, &VAR_16, sizeof(VAR_16)) != sizeof(VAR_16))
						bail(""failed to sync with child: read(error code)"");

					exit(VAR_16);
				case VAR_19:
					/* COMMENT_89 */
                                                               
                                                        
                                                               
                                         
                                            
       
                                                                              
                                          
        

					if (VAR_4.is_rootless_euid && !VAR_4.is_setgroup)
						update_setgroups(VAR_10, VAR_20);

					/* COMMENT_99 */
					update_uidmap(VAR_4.uidmappath, VAR_10, VAR_4.uidmap, VAR_4.uidmap_len);
					update_gidmap(VAR_4.gidmappath, VAR_10, VAR_4.gidmap, VAR_4.gidmap_len);

					VAR_15 = VAR_21;
					if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
						kill(VAR_10, VAR_22);
						bail(""failed to sync with child: write(SYNC_USERMAP_ACK)"");
					}
					break;
				case VAR_23:{
						VAR_11 = VAR_10;

						/* COMMENT_100 */
						if (read(VAR_17, &VAR_10, sizeof(VAR_10)) != sizeof(VAR_10)) {
							kill(VAR_11, VAR_22);
							bail(""failed to sync with child: read(childpid)"");
						}

						/* COMMENT_101 */
						VAR_15 = VAR_24;
						if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
							kill(VAR_11, VAR_22);
							kill(VAR_10, VAR_22);
							bail(""failed to sync with child: write(SYNC_RECVPID_ACK)"");
						}

						/* COMMENT_102 */
        
                                                                                  
                                                                                                   
                                                                             
         
						VAR_9 = dprintf(VAR_0, ""{\""pid\"": %d, \""pid_first\"": %d}\n"", VAR_10, VAR_11);
						if (VAR_9 < 0) {
							kill(VAR_10, VAR_22);
							bail(""unable to generate JSON for child pid"");
						}
					}
					break;
				case VAR_25:
					VAR_12 = true;
					break;
				default:
					bail(""unexpected sync value: %u"", VAR_15);
				}
			}

			/* COMMENT_108 */

			VAR_12 = false;
			while (!VAR_12) {
				enum sync_t VAR_15;
				int VAR_16;

				VAR_17 = VAR_3[1];
				close(VAR_3[0]);

				VAR_15 = VAR_26;
				if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
					kill(VAR_10, VAR_22);
					bail(""failed to sync with child: write(SYNC_GRANDCHILD)"");
				}

				if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
					bail(""failed to sync with child: next state"");

				switch (VAR_15) {
				case VAR_18:
					/* COMMENT_88 */
					if (read(VAR_17, &VAR_16, sizeof(VAR_16)) != sizeof(VAR_16))
						bail(""failed to sync with child: read(error code)"");

					exit(VAR_16);
				case VAR_25:
					VAR_12 = true;
					break;
				default:
					bail(""unexpected sync value: %u"", VAR_15);
				}
			}
			exit(0);
		}

		/* COMMENT_109 */
                                                                      
                                                                        
                                                                 
                                                                       
                                                                   
                                                                      
                                                  
     
	case VAR_14:{
			pid_t VAR_10;
			enum sync_t VAR_15;

			/* COMMENT_118 */
			VAR_17 = VAR_2[0];
			close(VAR_2[1]);

			/* COMMENT_79 */
			prctl(VAR_13, (unsigned long)""runc:[1:CHILD]"", 0, 0, 0);

			/* COMMENT_119 */
                                                                    
                                                                
                                                                   
                                             
      
			if (VAR_4.namespaces)
				join_namespaces(VAR_4.namespaces);

			/* COMMENT_125 */
                                                                      
                                                                    
                                   
     
                                                                    
                                                                  
                                                                    
                                                               
                                                                      
                                                  
     
                                                              
                                                                   
                                                                  
                                                                    
                                                                  
              
      
			if (VAR_4.cloneflags & VAR_27) {
				if (unshare(VAR_27) < 0)
					bail(""failed to unshare user namespace"");
				VAR_4.cloneflags &= ~VAR_27;

				/* COMMENT_143 */
                                                                   
                                                              
       

				/* COMMENT_147 */
				if (VAR_4.namespaces) {
					if (prctl(VAR_5, 1, 0, 0, 0) < 0)
						bail(""failed to set process as dumpable"");
				}
				VAR_15 = VAR_19;
				if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
					bail(""failed to sync with parent: write(SYNC_USERMAP_PLS)"");

				/* COMMENT_148 */

				if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
					bail(""failed to sync with parent: read(SYNC_USERMAP_ACK)"");
				if (VAR_15 != VAR_21)
					bail(""failed to sync with parent: SYNC_USERMAP_ACK: got %u"", VAR_15);
				/* COMMENT_147 */
				if (VAR_4.namespaces) {
					if (prctl(VAR_5, 0, 0, 0, 0) < 0)
						bail(""failed to set process as dumpable"");
				}

				/* COMMENT_149 */
				if (setresuid(0, 0, 0) < 0)
					bail(""failed to become root in user namespace"");
			}
			/* COMMENT_150 */
                                                                      
                                                                  
                                                                    
                                                                     
     
                                                                   
                                                                       
                                                          
      
			if (unshare(VAR_4.cloneflags & ~VAR_28) < 0)
				bail(""failed to unshare namespaces"");

			/* COMMENT_160 */
                                                                          
     
                                                                          
                                                                       
                                                                              
                                                                        
                                              
      
			VAR_10 = clone_parent(&VAR_1, VAR_29);
			if (VAR_10 < 0)
				bail(""unable to fork: init_func"");

			/* COMMENT_169 */
			VAR_15 = VAR_23;
			if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
				kill(VAR_10, VAR_22);
				bail(""failed to sync with parent: write(SYNC_RECVPID_PLS)"");
			}
			if (write(VAR_17, &VAR_10, sizeof(VAR_10)) != sizeof(VAR_10)) {
				kill(VAR_10, VAR_22);
				bail(""failed to sync with parent: write(childpid)"");
			}

			/* COMMENT_170 */

			if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
				kill(VAR_10, VAR_22);
				bail(""failed to sync with parent: read(SYNC_RECVPID_ACK)"");
			}
			if (VAR_15 != VAR_24) {
				kill(VAR_10, VAR_22);
				bail(""failed to sync with parent: SYNC_RECVPID_ACK: got %u"", VAR_15);
			}

			VAR_15 = VAR_25;
			if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15)) {
				kill(VAR_10, VAR_22);
				bail(""failed to sync with parent: write(SYNC_CHILD_READY)"");
			}

			/* COMMENT_171 */
			exit(0);
		}

		/* COMMENT_172 */
                                                                           
                                                                          
                                                                            
                                   
     
	case VAR_29:{
			/* COMMENT_178 */
                                                        
                                                     
      
			enum sync_t VAR_15;

			/* COMMENT_118 */
			VAR_17 = VAR_3[0];
			close(VAR_3[1]);
			close(VAR_2[0]);
			close(VAR_2[1]);

			/* COMMENT_79 */
			prctl(VAR_13, (unsigned long)""runc:[2:INIT]"", 0, 0, 0);

			if (read(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
				bail(""failed to sync with parent: read(SYNC_GRANDCHILD)"");
			if (VAR_15 != VAR_26)
				bail(""failed to sync with parent: SYNC_GRANDCHILD: got %u"", VAR_15);

			if (setsid() < 0)
				bail(""setsid failed"");

			if (setuid(0) < 0)
				bail(""setuid failed"");

			if (setgid(0) < 0)
				bail(""setgid failed"");

			if (!VAR_4.is_rootless_euid && VAR_4.is_setgroup) {
				if (setgroups(0, NULL) < 0)
					bail(""setgroups failed"");
			}

			/* COMMENT_182 */
			if (VAR_4.cloneflags & VAR_28) {
				uint8_t VAR_30;
				if (read(VAR_0, &VAR_30, sizeof(VAR_30)) != sizeof(VAR_30))
					bail(""read synchronisation value failed"");
				if (VAR_30 == VAR_31) {
					if (unshare(VAR_28) < 0)
						bail(""failed to unshare cgroup namespace"");
				} else
					bail(""received unknown synchronisation value"");
			}

			VAR_15 = VAR_25;
			if (write(VAR_17, &VAR_15, sizeof(VAR_15)) != sizeof(VAR_15))
				bail(""failed to sync with patent: write(SYNC_CHILD_READY)"");

			/* COMMENT_183 */
			close(VAR_3[0]);

			/* COMMENT_184 */
			nl_free(&VAR_4);

			/* COMMENT_185 */
			return;
		}
	default:
		bail(""unexpected jump value"");
	}

	/* COMMENT_186 */
	bail(""should never be reached"");
}",opencontainers/runc/0a8e4117e7f715d5fbeef398405813ce8e88558b/nsexec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,14 @@
 	pipenum = initpipe();
 	if (pipenum == -1)
 		return;
+
+	/*
+	 * We need to re-exec if we are not in a cloned binary. This is necessary
+	 * to ensure that containers won't be able to access the host binary
+	 * through /proc/self/exe. See CVE-2019-5736.
+	 */
+	if (ensure_cloned_binary() < 0)
+		bail(""could not ensure we are a cloned binary"");
 
 	/* Parse all of the netlink configuration. */
 	nl_parse(pipenum, &config);","{'deleted_lines': [], 'added_lines': ['', '\t/*', '\t * We need to re-exec if we are not in a cloned binary. This is necessary', ""\t * to ensure that containers won't be able to access the host binary"", '\t * through /proc/self/exe. See CVE-2019-5736.', '\t */', '\tif (ensure_cloned_binary() < 0)', '\t\tbail(""could not ensure we are a cloned binary"");']}",True,"runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers: (1) a new container with an attacker-controlled image, or (2) an existing container, to which the attacker previously had write access, that can be attached with docker exec. This occurs because of file-descriptor mishandling, related to /proc/self/exe.",8.6,HIGH,2,test,2019-01-09T02:40:01Z,2
CVE-2019-15518,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,swoole/swoole-src,fix directory traversal bug,32791110749d7b57ee3007af58411823bf6f5789,https://github.com/swoole/swoole-src/commit/32791110749d7b57ee3007af58411823bf6f5789,src/network/port.c,swPort_http_static_handler,"static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)
{
char *url = request->buffer->str + request->url_offset;
char *params = memchr(url, '?', request->url_length);
struct
{
off_t offset;
size_t length;
char filename[PATH_MAX];
} buffer;
char *p = buffer.filename;
memcpy(p, serv->document_root, serv->document_root_len);
p += serv->document_root_len;
uint32_t n = params ? params - url : request->url_length;
memcpy(p, url, n);
p += n;
*p = 0;
struct stat file_stat;
if (lstat(buffer.filename, &file_stat) < 0)
{
return SW_FALSE;
}
if (file_stat.st_size == 0)
{
return SW_FALSE;
}
if ((file_stat.st_mode & S_IFMT) != S_IFREG)
{
return SW_FALSE;
}
char header_buffer[1024];
swSendData response;
response.info.fd = conn->session_id;
response.info.type = SW_EVENT_TCP;
p = request->buffer->str + request->url_offset + request->url_length + 10;
char *pe = request->buffer->str + request->header_length;
char *date_if_modified_since = NULL;
int length_if_modified_since = 0;
int state = 0;
for (; p < pe; p++)
{
switch(state)
{
case 0:
if (strncasecmp(p, SW_STRL(""If-Modified-Since"")) == 0)
{
p += sizeof(""If-Modified-Since"");
state = 1;
}
break;
case 1:
if (!isspace(*p))
{
date_if_modified_since = p;
state = 2;
}
break;
case 2:
if (strncasecmp(p, SW_STRL(""\r\n"")) == 0)
{
length_if_modified_since = p - date_if_modified_since;
goto check_modify_date;
}
break;
default:
break;
}
}
char date_[64];
struct tm *tm1;
check_modify_date: tm1 = gmtime(&serv->gs->now);
strftime(date_, sizeof(date_), ""%a, %d %b %Y %H:%M:%S %Z"", tm1);
char date_last_modified[64];
#ifdef __MACH__
time_t file_mtime = file_stat.st_mtimespec.tv_sec;
#elif defined(_WIN32)
time_t file_mtime = file_stat.st_mtime;
#else
time_t file_mtime = file_stat.st_mtim.tv_sec;
#endif
struct tm *tm2 = gmtime(&file_mtime);
strftime(date_last_modified, sizeof(date_last_modified), ""%a, %d %b %Y %H:%M:%S %Z"", tm2);
if (state == 2)
{
struct tm tm3;
char date_tmp[64];
memcpy(date_tmp, date_if_modified_since, length_if_modified_since);
date_tmp[length_if_modified_since] = 0;
char *date_format = NULL;
if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)
{
date_format = SW_HTTP_RFC1123_DATE_GMT;
}
else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)
{
date_format = SW_HTTP_RFC1123_DATE_UTC;
}
else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)
{
date_format = SW_HTTP_RFC850_DATE;
}
else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)
{
date_format = SW_HTTP_ASCTIME_DATE;
}
if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)
{
response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
""HTTP/1.1 304 Not Modified\r\n""
""%s""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
date_,
date_last_modified,
SW_HTTP_SERVER_SOFTWARE
);
response.data = header_buffer;
swServer_master_send(serv, &response);
goto _finish;
}
}
response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
""HTTP/1.1 200 OK\r\n""
""%s""
""Content-Length: %ld\r\n""
""Content-Type: %s\r\n""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
(long) file_stat.st_size,
swoole_get_mime_type(buffer.filename),
date_,
date_last_modified,
SW_HTTP_SERVER_SOFTWARE);
response.data = header_buffer;
#ifdef HAVE_TCP_NOPUSH
if (conn->tcp_nopush == 0)
{
if (swSocket_tcp_nopush(conn->fd, 1) == -1)
{
swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(errno), errno);
}
conn->tcp_nopush = 1;
}
#endif
swServer_master_send(serv, &response);
buffer.offset = 0;
buffer.length = file_stat.st_size;
response.info.type = SW_EVENT_SENDFILE;
response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;
response.data = (void*) &buffer;
swServer_master_send(serv, &response);
_finish:
if (!request->keep_alive)
{
response.info.type = SW_EVENT_CLOSE;
response.length = 0;
response.data = NULL;
swServer_master_send(serv, &response);
}
return SW_TRUE;
}","static int swPort_http_static_handler(swServer *VAR_0, swHttpRequest *VAR_1, swConnection *VAR_2)
{
char *VAR_3 = VAR_1->buffer->str + VAR_1->url_offset;
char *VAR_4 = memchr(VAR_3, '?', VAR_1->url_length);
struct
{
off_t offset;
size_t length;
char filename[VAR_5];
} VAR_6;
char *VAR_7 = VAR_6.filename;
memcpy(VAR_7, VAR_0->document_root, VAR_0->document_root_len);
VAR_7 += VAR_0->document_root_len;
uint32_t VAR_8 = VAR_4 ? VAR_4 - VAR_3 : VAR_1->url_length;
memcpy(VAR_7, VAR_3, VAR_8);
VAR_7 += VAR_8;
*VAR_7 = 0;
struct stat VAR_9;
if (lstat(VAR_6.filename, &VAR_9) < 0)
{
return VAR_10;
}
if (VAR_9.st_size == 0)
{
return VAR_10;
}
if ((VAR_9.st_mode & VAR_11) != VAR_12)
{
return VAR_10;
}
char VAR_13[1024];
swSendData VAR_14;
VAR_14.info.fd = VAR_2->session_id;
VAR_14.info.type = VAR_15;
VAR_7 = VAR_1->buffer->str + VAR_1->url_offset + VAR_1->url_length + 10;
char *VAR_16 = VAR_1->buffer->str + VAR_1->header_length;
char *VAR_17 = NULL;
int VAR_18 = 0;
int VAR_19 = 0;
for (; VAR_7 < VAR_16; VAR_7++)
{
switch(VAR_19)
{
case 0:
if (strncasecmp(VAR_7, SW_STRL(""If-Modified-Since"")) == 0)
{
VAR_7 += sizeof(""If-Modified-Since"");
VAR_19 = 1;
}
break;
case 1:
if (!isspace(*VAR_7))
{
VAR_17 = VAR_7;
VAR_19 = 2;
}
break;
case 2:
if (strncasecmp(VAR_7, SW_STRL(""\r\n"")) == 0)
{
VAR_18 = VAR_7 - VAR_17;
goto check_modify_date;
}
break;
default:
break;
}
}
char VAR_20[64];
struct tm *VAR_21;
check_modify_date: VAR_21 = gmtime(&VAR_0->gs->now);
strftime(VAR_20, sizeof(VAR_20), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_21);
char VAR_22[64];
#ifdef VAR_23
time_t VAR_24 = VAR_9.st_mtimespec.tv_sec;
#elif defined(VAR_25)
time_t VAR_24 = VAR_9.st_mtime;
#else
time_t VAR_24 = VAR_9.st_mtim.tv_sec;
#endif
struct tm *VAR_26 = gmtime(&VAR_24);
strftime(VAR_22, sizeof(VAR_22), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_26);
if (VAR_19 == 2)
{
struct tm VAR_27;
char VAR_28[64];
memcpy(VAR_28, VAR_17, VAR_18);
VAR_28[VAR_18] = 0;
char *VAR_29 = NULL;
if (strptime(VAR_28, VAR_30, &VAR_27) != NULL)
{
VAR_29 = VAR_30;
}
else if (strptime(VAR_28, VAR_31, &VAR_27) != NULL)
{
VAR_29 = VAR_31;
}
else if (strptime(VAR_28, VAR_32, &VAR_27) != NULL)
{
VAR_29 = VAR_32;
}
else if (strptime(VAR_28, VAR_33, &VAR_27) != NULL)
{
VAR_29 = VAR_33;
}
if (VAR_29 && mktime(&VAR_27) - (int) VAR_34 >= VAR_24)
{
VAR_14.length = VAR_14.info.len = sw_snprintf(VAR_13, sizeof(VAR_13),
""HTTP/1.1 304 Not Modified\r\n""
""%s""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
VAR_20,
VAR_22,
VAR_35
);
VAR_14.data = VAR_13;
swServer_master_send(VAR_0, &VAR_14);
goto _finish;
}
}
VAR_14.length = VAR_14.info.len = sw_snprintf(VAR_13, sizeof(VAR_13),
""HTTP/1.1 200 OK\r\n""
""%s""
""Content-Length: %ld\r\n""
""Content-Type: %s\r\n""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
(long) VAR_9.st_size,
swoole_get_mime_type(VAR_6.filename),
VAR_20,
VAR_22,
VAR_35);
VAR_14.data = VAR_13;
#ifdef VAR_36
if (VAR_2->tcp_nopush == 0)
{
if (swSocket_tcp_nopush(VAR_2->fd, 1) == -1)
{
swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(VAR_37), VAR_37);
}
VAR_2->tcp_nopush = 1;
}
#endif
swServer_master_send(VAR_0, &VAR_14);
VAR_6.offset = 0;
VAR_6.length = VAR_9.st_size;
VAR_14.info.type = VAR_38;
VAR_14.length = VAR_14.info.len = sizeof(VAR_39) + VAR_6.length + 1;
VAR_14.data = (void*) &VAR_6;
swServer_master_send(VAR_0, &VAR_14);
_finish:
if (!VAR_1->keep_alive)
{
VAR_14.info.type = VAR_40;
VAR_14.length = 0;
VAR_14.data = NULL;
swServer_master_send(VAR_0, &VAR_14);
}
return VAR_41;
}",swoole/swoole-src/32791110749d7b57ee3007af58411823bf6f5789/port.c/vul/before/0.json,"static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)
{
    char *url = request->buffer->str + request->url_offset;
    char *params = memchr(url, '?', request->url_length);

    struct
    {
        off_t offset;
        size_t length;
        char filename[PATH_MAX];
    } buffer;

    char *p = buffer.filename;

    memcpy(p, serv->document_root, serv->document_root_len);
    p += serv->document_root_len;
    uint32_t n = params ? params - url : request->url_length;
    memcpy(p, url, n);
    p += n;
    *p = 0;

    char real_path[PATH_MAX];
    if (!realpath(buffer.filename, real_path))
    {
        return SW_FALSE;
    }

    if (real_path[serv->document_root_len] != '/')
    {
        return SW_FALSE;
    }

    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)
    {
        return SW_FALSE;
    }

    struct stat file_stat;
    if (lstat(buffer.filename, &file_stat) < 0)
    {
        return SW_FALSE;
    }
    if (file_stat.st_size == 0)
    {
        return SW_FALSE;
    }
    if ((file_stat.st_mode & S_IFMT) != S_IFREG)
    {
        return SW_FALSE;
    }

    char header_buffer[1024];
    swSendData response;
    response.info.fd = conn->session_id;

    response.info.type = SW_EVENT_TCP;

    p = request->buffer->str + request->url_offset + request->url_length + 10;
    char *pe = request->buffer->str + request->header_length;

    char *date_if_modified_since = NULL;
    int length_if_modified_since = 0;

    int state = 0;
    for (; p < pe; p++)
    {
        switch(state)
        {
        case 0:
            if (strncasecmp(p, SW_STRL(""If-Modified-Since"")) == 0)
            {
                p += sizeof(""If-Modified-Since"");
                state = 1;
            }
            break;
        case 1:
            if (!isspace(*p))
            {
                date_if_modified_since = p;
                state = 2;
            }
            break;
        case 2:
            if (strncasecmp(p, SW_STRL(""\r\n"")) == 0)
            {
                length_if_modified_since = p - date_if_modified_since;
                goto check_modify_date;
            }
            break;
        default:
            break;
        }
    }

    char date_[64];
    struct tm *tm1;

    check_modify_date: tm1 = gmtime(&serv->gs->now);
    strftime(date_, sizeof(date_), ""%a, %d %b %Y %H:%M:%S %Z"", tm1);

    char date_last_modified[64];
#ifdef __MACH__
    time_t file_mtime = file_stat.st_mtimespec.tv_sec;
#elif defined(_WIN32)
	time_t file_mtime = file_stat.st_mtime;
#else
    time_t file_mtime = file_stat.st_mtim.tv_sec;
#endif

    struct tm *tm2 = gmtime(&file_mtime);
    strftime(date_last_modified, sizeof(date_last_modified), ""%a, %d %b %Y %H:%M:%S %Z"", tm2);

    if (state == 2)
    {
        struct tm tm3;
        char date_tmp[64];
        memcpy(date_tmp, date_if_modified_since, length_if_modified_since);
        date_tmp[length_if_modified_since] = 0;

        char *date_format = NULL;

        if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)
        {
            date_format = SW_HTTP_RFC1123_DATE_GMT;
        }
        else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)
        {
            date_format = SW_HTTP_RFC1123_DATE_UTC;
        }
        else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)
        {
            date_format = SW_HTTP_RFC850_DATE;
        }
        else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)
        {
            date_format = SW_HTTP_ASCTIME_DATE;
        }
        if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)
        {
            response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
                    ""HTTP/1.1 304 Not Modified\r\n""
                    ""%s""
                    ""Date: %s\r\n""
                    ""Last-Modified: %s\r\n""
                    ""Server: %s\r\n\r\n"",
                    request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
                    date_,
                    date_last_modified,
                    SW_HTTP_SERVER_SOFTWARE
            );
            response.data = header_buffer;
            swServer_master_send(serv, &response);
            goto _finish;
        }
    }

    response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
            ""HTTP/1.1 200 OK\r\n""
            ""%s""
            ""Content-Length: %ld\r\n""
            ""Content-Type: %s\r\n""
            ""Date: %s\r\n""
            ""Last-Modified: %s\r\n""
            ""Server: %s\r\n\r\n"",
            request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
            (long) file_stat.st_size,
            swoole_get_mime_type(buffer.filename),
            date_,
            date_last_modified,
            SW_HTTP_SERVER_SOFTWARE);

    response.data = header_buffer;

#ifdef HAVE_TCP_NOPUSH
    if (conn->tcp_nopush == 0)
    {
        if (swSocket_tcp_nopush(conn->fd, 1) == -1)
        {
            swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(errno), errno);
        }
        conn->tcp_nopush = 1;
    }
#endif
    swServer_master_send(serv, &response);

    buffer.offset = 0;
    buffer.length = file_stat.st_size;

    response.info.type = SW_EVENT_SENDFILE;
    response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;
    response.data = (void*) &buffer;

    swServer_master_send(serv, &response);

    _finish:
    if (!request->keep_alive)
    {
        response.info.type = SW_EVENT_CLOSE;
        response.length = 0;
        response.data = NULL;
        swServer_master_send(serv, &response);
    }

    return SW_TRUE;
}","static int swPort_http_static_handler(swServer *VAR_0, swHttpRequest *VAR_1, swConnection *VAR_2)
{
    char *VAR_3 = VAR_1->buffer->str + VAR_1->url_offset;
    char *VAR_4 = memchr(VAR_3, '?', VAR_1->url_length);

    struct
    {
        off_t offset;
        size_t length;
        char filename[VAR_5];
    } VAR_6;

    char *VAR_7 = VAR_6.filename;

    memcpy(VAR_7, VAR_0->document_root, VAR_0->document_root_len);
    VAR_7 += VAR_0->document_root_len;
    uint32_t VAR_8 = VAR_4 ? VAR_4 - VAR_3 : VAR_1->url_length;
    memcpy(VAR_7, VAR_3, VAR_8);
    VAR_7 += VAR_8;
    *VAR_7 = 0;

    char VAR_9[VAR_5];
    if (!realpath(VAR_6.filename, VAR_9))
    {
        return VAR_10;
    }

    if (VAR_9[VAR_0->document_root_len] != '/')
    {
        return VAR_10;
    }

    if (strncmp(VAR_9, VAR_0->document_root, VAR_0->document_root_len) != 0)
    {
        return VAR_10;
    }

    struct stat VAR_11;
    if (lstat(VAR_6.filename, &VAR_11) < 0)
    {
        return VAR_10;
    }
    if (VAR_11.st_size == 0)
    {
        return VAR_10;
    }
    if ((VAR_11.st_mode & VAR_12) != VAR_13)
    {
        return VAR_10;
    }

    char VAR_14[1024];
    swSendData VAR_15;
    VAR_15.info.fd = VAR_2->session_id;

    VAR_15.info.type = VAR_16;

    VAR_7 = VAR_1->buffer->str + VAR_1->url_offset + VAR_1->url_length + 10;
    char *VAR_17 = VAR_1->buffer->str + VAR_1->header_length;

    char *VAR_18 = NULL;
    int VAR_19 = 0;

    int VAR_20 = 0;
    for (; VAR_7 < VAR_17; VAR_7++)
    {
        switch(VAR_20)
        {
        case 0:
            if (strncasecmp(VAR_7, SW_STRL(""If-Modified-Since"")) == 0)
            {
                VAR_7 += sizeof(""If-Modified-Since"");
                VAR_20 = 1;
            }
            break;
        case 1:
            if (!isspace(*VAR_7))
            {
                VAR_18 = VAR_7;
                VAR_20 = 2;
            }
            break;
        case 2:
            if (strncasecmp(VAR_7, SW_STRL(""\r\n"")) == 0)
            {
                VAR_19 = VAR_7 - VAR_18;
                goto check_modify_date;
            }
            break;
        default:
            break;
        }
    }

    char VAR_21[64];
    struct tm *VAR_22;

    check_modify_date: VAR_22 = gmtime(&VAR_0->gs->now);
    strftime(VAR_21, sizeof(VAR_21), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_22);

    char VAR_23[64];
#ifdef VAR_24
    time_t VAR_25 = VAR_11.st_mtimespec.tv_sec;
#elif defined(VAR_26)
	time_t VAR_25 = VAR_11.st_mtime;
#else
    time_t VAR_25 = VAR_11.st_mtim.tv_sec;
#endif

    struct tm *VAR_27 = gmtime(&VAR_25);
    strftime(VAR_23, sizeof(VAR_23), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_27);

    if (VAR_20 == 2)
    {
        struct tm VAR_28;
        char VAR_29[64];
        memcpy(VAR_29, VAR_18, VAR_19);
        VAR_29[VAR_19] = 0;

        char *VAR_30 = NULL;

        if (strptime(VAR_29, VAR_31, &VAR_28) != NULL)
        {
            VAR_30 = VAR_31;
        }
        else if (strptime(VAR_29, VAR_32, &VAR_28) != NULL)
        {
            VAR_30 = VAR_32;
        }
        else if (strptime(VAR_29, VAR_33, &VAR_28) != NULL)
        {
            VAR_30 = VAR_33;
        }
        else if (strptime(VAR_29, VAR_34, &VAR_28) != NULL)
        {
            VAR_30 = VAR_34;
        }
        if (VAR_30 && mktime(&VAR_28) - (int) VAR_35 >= VAR_25)
        {
            VAR_15.length = VAR_15.info.len = sw_snprintf(VAR_14, sizeof(VAR_14),
                    ""HTTP/1.1 304 Not Modified\r\n""
                    ""%s""
                    ""Date: %s\r\n""
                    ""Last-Modified: %s\r\n""
                    ""Server: %s\r\n\r\n"",
                    VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
                    VAR_21,
                    VAR_23,
                    VAR_36
            );
            VAR_15.data = VAR_14;
            swServer_master_send(VAR_0, &VAR_15);
            goto _finish;
        }
    }

    VAR_15.length = VAR_15.info.len = sw_snprintf(VAR_14, sizeof(VAR_14),
            ""HTTP/1.1 200 OK\r\n""
            ""%s""
            ""Content-Length: %ld\r\n""
            ""Content-Type: %s\r\n""
            ""Date: %s\r\n""
            ""Last-Modified: %s\r\n""
            ""Server: %s\r\n\r\n"",
            VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
            (long) VAR_11.st_size,
            swoole_get_mime_type(VAR_6.filename),
            VAR_21,
            VAR_23,
            VAR_36);

    VAR_15.data = VAR_14;

#ifdef VAR_37
    if (VAR_2->tcp_nopush == 0)
    {
        if (swSocket_tcp_nopush(VAR_2->fd, 1) == -1)
        {
            swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(VAR_38), VAR_38);
        }
        VAR_2->tcp_nopush = 1;
    }
#endif
    swServer_master_send(VAR_0, &VAR_15);

    VAR_6.offset = 0;
    VAR_6.length = VAR_11.st_size;

    VAR_15.info.type = VAR_39;
    VAR_15.length = VAR_15.info.len = sizeof(VAR_40) + VAR_6.length + 1;
    VAR_15.data = (void*) &VAR_6;

    swServer_master_send(VAR_0, &VAR_15);

    _finish:
    if (!VAR_1->keep_alive)
    {
        VAR_15.info.type = VAR_41;
        VAR_15.length = 0;
        VAR_15.data = NULL;
        swServer_master_send(VAR_0, &VAR_15);
    }

    return VAR_42;
}",swoole/swoole-src/32791110749d7b57ee3007af58411823bf6f5789/port.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,6 +18,22 @@
     memcpy(p, url, n);
     p += n;
     *p = 0;
+
+    char real_path[PATH_MAX];
+    if (!realpath(buffer.filename, real_path))
+    {
+        return SW_FALSE;
+    }
+
+    if (real_path[serv->document_root_len] != '/')
+    {
+        return SW_FALSE;
+    }
+
+    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)
+    {
+        return SW_FALSE;
+    }
 
     struct stat file_stat;
     if (lstat(buffer.filename, &file_stat) < 0)","{'deleted_lines': [], 'added_lines': ['', '    char real_path[PATH_MAX];', '    if (!realpath(buffer.filename, real_path))', '    {', '        return SW_FALSE;', '    }', '', ""    if (real_path[serv->document_root_len] != '/')"", '    {', '        return SW_FALSE;', '    }', '', '    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)', '    {', '        return SW_FALSE;', '    }']}",True,Swoole before 4.2.13 allows directory traversal in swPort_http_static_handler.,5.3,MEDIUM,1,test,2019-01-16T12:06:52Z,2
CVE-2019-15518,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,swoole/swoole-src,fix directory traversal bug,32791110749d7b57ee3007af58411823bf6f5789,https://github.com/swoole/swoole-src/commit/32791110749d7b57ee3007af58411823bf6f5789,swoole_server.cc,PHP_METHOD,"static PHP_METHOD(swoole_server, set)
{
zval *zset = NULL;
zval *zobject = getThis();
HashTable *vht;
zval *v;
swServer *serv = (swServer *) swoole_get_object(zobject);
if (serv->gs->start > 0)
{
swoole_php_fatal_error(E_WARNING, ""server is running. unable to execute function 'swoole_server_set'."");
RETURN_FALSE;
}
ZEND_PARSE_PARAMETERS_START(1, 1)
Z_PARAM_ARRAY(zset)
ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);
php_swoole_array_separate(zset);
vht = Z_ARRVAL_P(zset);
if (php_swoole_array_get_value(vht, ""chroot"", v))
{
convert_to_string(v);
if (SwooleG.chroot)
{
sw_free(SwooleG.chroot);
}
SwooleG.chroot = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
}
if (php_swoole_array_get_value(vht, ""user"", v))
{
convert_to_string(v);
if (SwooleG.user)
{
sw_free(SwooleG.user);
}
SwooleG.user = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
}
if (php_swoole_array_get_value(vht, ""group"", v))
{
convert_to_string(v);
if (SwooleG.group)
{
sw_free(SwooleG.group);
}
SwooleG.group = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
}
if (php_swoole_array_get_value(vht, ""daemonize"", v))
{
convert_to_boolean(v);
serv->daemonize = Z_BVAL_P(v);
}
#ifdef SW_DEBUG
if (php_swoole_array_get_value(vht, ""debug_mode"", v))
{
convert_to_boolean(v);
if (Z_BVAL_P(v))
{
SwooleG.log_level = 0;
}
}
#endif
if (php_swoole_array_get_value(vht, ""trace_flags"", v))
{
convert_to_long(v);
SwooleG.trace_flags = (uint32_t) MAX(0, Z_LVAL_P(v));
}
if (php_swoole_array_get_value(vht, ""pid_file"", v))
{
convert_to_string(v);
if (serv->pid_file)
{
sw_free(serv->pid_file);
}
serv->pid_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
}
if (php_swoole_array_get_value(vht, ""reactor_num"", v))
{
convert_to_long(v);
serv->reactor_num = (uint16_t) Z_LVAL_P(v);
if (serv->reactor_num <= 0)
{
serv->reactor_num = SwooleG.cpu_num;
}
}
if (php_swoole_array_get_value(vht, ""worker_num"", v))
{
convert_to_long(v);
serv->worker_num = (uint16_t) Z_LVAL_P(v);
if (serv->worker_num <= 0)
{
serv->worker_num = SwooleG.cpu_num;
}
}
if (php_swoole_array_get_value(vht, ""max_wait_time"", v))
{
convert_to_long(v);
serv->max_wait_time = (uint32_t) Z_LVAL_P(v);
}
#ifdef SW_COROUTINE
if (php_swoole_array_get_value(vht, ""enable_coroutine"", v))
{
convert_to_boolean(v);
serv->enable_coroutine = SwooleG.enable_coroutine = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""max_coro_num"", v) || php_swoole_array_get_value(vht, ""max_coroutine"", v))
{
zend_long max_num;
convert_to_long(v);
max_num = Z_LVAL_P(v);
PHPCoroutine::set_max_num(max_num <= 0 ? SW_DEFAULT_MAX_CORO_NUM : max_num);
}
if (php_swoole_array_get_value(vht, ""send_yield"", v))
{
convert_to_boolean(v);
serv->send_yield = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""send_timeout"", v))
{
convert_to_double(v);
serv->send_timeout = Z_DVAL_P(v);
}
#endif
if (php_swoole_array_get_value(vht, ""dispatch_mode"", v))
{
convert_to_long(v);
serv->dispatch_mode = (uint8_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""dispatch_func"", v))
{
swServer_dispatch_function c_dispatch_func = NULL;
while(1)
{
if (Z_TYPE_P(v) == IS_STRING)
{
c_dispatch_func = (swServer_dispatch_function) swoole_get_function(Z_STRVAL_P(v), Z_STRLEN_P(v));
if (c_dispatch_func)
{
break;
}
}
char *func_name = NULL;
zend_fcall_info_cache *fci_cache = (zend_fcall_info_cache *) emalloc(sizeof(zend_fcall_info_cache));
if (!sw_zend_is_callable_ex(v, NULL, 0, &func_name, NULL, fci_cache, NULL))
{
swoole_php_fatal_error(E_ERROR, ""function '%s' is not callable"", func_name);
return;
}
efree(func_name);
sw_fci_cache_persist(fci_cache);
serv->private_data_3 = (void *) fci_cache;
c_dispatch_func = php_swoole_dispatch_func;
break;
}
if (c_dispatch_func)
{
serv->dispatch_mode = SW_DISPATCH_USERFUNC;
serv->dispatch_func = c_dispatch_func;
}
}
if (php_swoole_array_get_value(vht, ""log_file"", v))
{
convert_to_string(v);
if (SwooleG.log_file)
{
sw_free(SwooleG.log_file);
}
SwooleG.log_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
}
if (php_swoole_array_get_value(vht, ""log_level"", v))
{
zend_long level;
convert_to_long(v);
level = Z_LVAL_P(v);
SwooleG.log_level = (uint32_t) (level < 0 ? UINT32_MAX : level);
}
if (php_swoole_array_get_value(vht, ""discard_timeout_request"", v))
{
convert_to_boolean(v);
serv->discard_timeout_request = (uint32_t) Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""enable_unsafe_event"", v))
{
convert_to_boolean(v);
serv->enable_unsafe_event = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""enable_delay_receive"", v))
{
convert_to_boolean(v);
serv->enable_delay_receive = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""task_enable_coroutine"", v))
{
convert_to_boolean(v);
if (Z_BVAL_P(v))
{
if (!SwooleG.enable_coroutine)
{
swoole_php_fatal_error(E_ERROR, ""server->enable_coroutine must be true."");
return;
}
serv->task_enable_coroutine = 1;
}
else
{
serv->task_enable_coroutine = 0;
}
}
if (php_swoole_array_get_value(vht, ""task_worker_num"", v))
{
convert_to_long(v);
serv->task_worker_num = (uint16_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""trace_event_worker"", v))
{
convert_to_boolean(v);
serv->trace_event_worker = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""request_slowlog_timeout"", v))
{
convert_to_long(v);
serv->request_slowlog_timeout = (uint8_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""request_slowlog_file"", v))
{
convert_to_string(v);
serv->request_slowlog_file = fopen(Z_STRVAL_P(v), ""a+"");
if (serv->request_slowlog_file == NULL)
{
swoole_php_fatal_error(E_ERROR, ""Unable to open request_slowlog_file[%s]."", Z_STRVAL_P(v));
return;
}
if (serv->request_slowlog_timeout == 0)
{
serv->request_slowlog_timeout = 1;
}
}
if (php_swoole_array_get_value(vht, ""task_ipc_mode"", v))
{
convert_to_long(v);
serv->task_ipc_mode = (uint8_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""task_tmpdir"", v))
{
convert_to_string(v);
if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)
{
swoole_php_fatal_error(E_ERROR, ""Unable to create task_tmpdir[%s]."", Z_STRVAL_P(v));
return;
}
if (SwooleG.task_tmpdir)
{
sw_free(SwooleG.task_tmpdir);
}
SwooleG.task_tmpdir = (char*) sw_malloc(Z_STRLEN_P(v) + sizeof(SW_TASK_TMP_FILE) + 1);
SwooleG.task_tmpdir_len = sw_snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, ""%s/swoole.task.XXXXXX"", Z_STRVAL_P(v)) + 1;
}
if (php_swoole_array_get_value(vht, ""task_max_request"", v))
{
convert_to_long(v);
serv->task_max_request = (uint16_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""max_connection"", v) || php_swoole_array_get_value(vht, ""max_conn"", v))
{
convert_to_long(v);
serv->max_connection = (uint32_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""heartbeat_check_interval"", v))
{
convert_to_long(v);
serv->heartbeat_check_interval = (uint16_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""heartbeat_idle_time"", v))
{
convert_to_long(v);
serv->heartbeat_idle_time = (uint16_t) Z_LVAL_P(v);
if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)
{
swoole_php_fatal_error(E_WARNING, ""heartbeat_idle_time must be greater than heartbeat_check_interval."");
serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;
}
}
else if (serv->heartbeat_check_interval > 0)
{
serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;
}
if (php_swoole_array_get_value(vht, ""max_request"", v))
{
convert_to_long(v);
serv->max_request = (uint32_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""reload_async"", v))
{
convert_to_boolean(v);
serv->reload_async = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""open_cpu_affinity"", v))
{
convert_to_boolean(v);
serv->open_cpu_affinity = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""cpu_affinity_ignore"", v))
{
int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));
if (ignore_num >= SW_CPU_NUM)
{
swoole_php_fatal_error(E_ERROR, ""cpu_affinity_ignore num must be less than cpu num (%d)"", SW_CPU_NUM);
RETURN_FALSE;
}
int available_num = SW_CPU_NUM - ignore_num;
int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);
int flag, i, available_i = 0;
zval *zval_core = NULL;
for (i = 0; i < SW_CPU_NUM; i++)
{
flag = 1;
SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)
int core = (int) Z_LVAL_P(zval_core);
if (i == core)
{
flag = 0;
break;
}
SW_HASHTABLE_FOREACH_END();
if (flag)
{
available_cpu[available_i] = i;
available_i++;
}
}
serv->cpu_affinity_available_num = available_num;
serv->cpu_affinity_available = available_cpu;
}
if (php_swoole_array_get_value(vht, ""http_parse_post"", v))
{
convert_to_boolean(v);
serv->http_parse_post = Z_BVAL_P(v);
}
#ifdef SW_HAVE_ZLIB
if (php_swoole_array_get_value(vht, ""http_compression"", v))
{
convert_to_boolean(v);
serv->http_compression = Z_BVAL_P(v);
serv->http_compression_level = Z_BEST_SPEED;
}
if (php_swoole_array_get_value(vht, ""http_gzip_level"", v) || php_swoole_array_get_value(vht, ""http_compression_level"", v))
{
convert_to_long(v);
zend_long level = Z_LVAL_P(v);
if (level > UINT8_MAX)
{
level = UINT8_MAX;
}
else if (level < 0)
{
level = 0;
}
serv->http_compression_level = level;
}
#endif
if (php_swoole_array_get_value(vht, ""upload_tmp_dir"", v))
{
convert_to_string(v);
if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)
{
swoole_php_fatal_error(E_ERROR, ""Unable to create upload_tmp_dir[%s]."", Z_STRVAL_P(v));
return;
}
if (serv->upload_tmp_dir)
{
sw_free(serv->upload_tmp_dir);
}
serv->upload_tmp_dir = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
}
if (php_swoole_array_get_value(vht, ""enable_static_handler"", v))
{
convert_to_boolean(v);
serv->enable_static_handler = Z_BVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""document_root"", v))
{
convert_to_string(v);
if (serv->document_root)
{
sw_free(serv->document_root);
}
serv->document_root = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
if (serv->document_root[Z_STRLEN_P(v) - 1] == '/')
{
serv->document_root[Z_STRLEN_P(v) - 1] = 0;
serv->document_root_len = Z_STRLEN_P(v) - 1;
}
else
{
serv->document_root_len = Z_STRLEN_P(v);
}
}
if (php_swoole_array_get_value(vht, ""buffer_input_size"", v))
{
convert_to_long(v);
serv->buffer_input_size = (uint32_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""buffer_output_size"", v))
{
convert_to_long(v);
serv->buffer_output_size = (uint32_t) Z_LVAL_P(v);
}
if (php_swoole_array_get_value(vht, ""message_queue_key"", v))
{
convert_to_long(v);
serv->message_queue_key = (uint64_t) Z_LVAL_P(v);
}
zval *retval = NULL;
zval *port_object = server_port_list.zobjects[0];
Z_TRY_ADDREF_P(port_object);
Z_TRY_ADDREF_P(zset);
sw_zend_call_method_with_1_params(&port_object, swoole_server_port_ce_ptr, NULL, ""set"", &retval, zset);
zval *zsetting = sw_zend_read_property_array(swoole_server_ce_ptr, getThis(), ZEND_STRL(""setting""), 1);
php_array_merge(Z_ARRVAL_P(zsetting), Z_ARRVAL_P(zset));
zval_ptr_dtor(zset);
RETURN_TRUE;
}","static PHP_METHOD(swoole_server, set)
{
zval *VAR_0 = NULL;
zval *VAR_1 = getThis();
HashTable *VAR_2;
zval *VAR_3;
swServer *VAR_4 = (swServer *) swoole_get_object(VAR_1);
if (VAR_4->gs->start > 0)
{
swoole_php_fatal_error(VAR_5, ""server is running. unable to execute function 'swoole_server_set'."");
VAR_6;
}
ZEND_PARSE_PARAMETERS_START(1, 1)
Z_PARAM_ARRAY(VAR_0)
ZEND_PARSE_PARAMETERS_END_EX(VAR_6);
php_swoole_array_separate(VAR_0);
VAR_2 = Z_ARRVAL_P(VAR_0);
if (php_swoole_array_get_value(VAR_2, ""chroot"", VAR_3))
{
convert_to_string(VAR_3);
if (VAR_7.chroot)
{
sw_free(VAR_7.chroot);
}
VAR_7.chroot = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
}
if (php_swoole_array_get_value(VAR_2, ""user"", VAR_3))
{
convert_to_string(VAR_3);
if (VAR_7.user)
{
sw_free(VAR_7.user);
}
VAR_7.user = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
}
if (php_swoole_array_get_value(VAR_2, ""group"", VAR_3))
{
convert_to_string(VAR_3);
if (VAR_7.group)
{
sw_free(VAR_7.group);
}
VAR_7.group = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
}
if (php_swoole_array_get_value(VAR_2, ""daemonize"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->daemonize = Z_BVAL_P(VAR_3);
}
#ifdef VAR_8
if (php_swoole_array_get_value(VAR_2, ""debug_mode"", VAR_3))
{
convert_to_boolean(VAR_3);
if (Z_BVAL_P(VAR_3))
{
VAR_7.log_level = 0;
}
}
#endif
if (php_swoole_array_get_value(VAR_2, ""trace_flags"", VAR_3))
{
convert_to_long(VAR_3);
VAR_7.trace_flags = (uint32_t) MAX(0, Z_LVAL_P(VAR_3));
}
if (php_swoole_array_get_value(VAR_2, ""pid_file"", VAR_3))
{
convert_to_string(VAR_3);
if (VAR_4->pid_file)
{
sw_free(VAR_4->pid_file);
}
VAR_4->pid_file = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
}
if (php_swoole_array_get_value(VAR_2, ""reactor_num"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->reactor_num = (uint16_t) Z_LVAL_P(VAR_3);
if (VAR_4->reactor_num <= 0)
{
VAR_4->reactor_num = VAR_7.cpu_num;
}
}
if (php_swoole_array_get_value(VAR_2, ""worker_num"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->worker_num = (uint16_t) Z_LVAL_P(VAR_3);
if (VAR_4->worker_num <= 0)
{
VAR_4->worker_num = VAR_7.cpu_num;
}
}
if (php_swoole_array_get_value(VAR_2, ""max_wait_time"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->max_wait_time = (uint32_t) Z_LVAL_P(VAR_3);
}
#ifdef VAR_9
if (php_swoole_array_get_value(VAR_2, ""enable_coroutine"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->enable_coroutine = VAR_7.enable_coroutine = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""max_coro_num"", VAR_3) || php_swoole_array_get_value(VAR_2, ""max_coroutine"", VAR_3))
{
zend_long VAR_10;
convert_to_long(VAR_3);
VAR_10 = Z_LVAL_P(VAR_3);
PHPCoroutine::set_max_num(VAR_10 <= 0 ? VAR_11 : VAR_10);
}
if (php_swoole_array_get_value(VAR_2, ""send_yield"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->send_yield = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""send_timeout"", VAR_3))
{
convert_to_double(VAR_3);
VAR_4->send_timeout = Z_DVAL_P(VAR_3);
}
#endif
if (php_swoole_array_get_value(VAR_2, ""dispatch_mode"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->dispatch_mode = (uint8_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""dispatch_func"", VAR_3))
{
swServer_dispatch_function VAR_12 = NULL;
while(1)
{
if (Z_TYPE_P(VAR_3) == VAR_13)
{
VAR_12 = (swServer_dispatch_function) swoole_get_function(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
if (VAR_12)
{
break;
}
}
char *VAR_14 = NULL;
zend_fcall_info_cache *VAR_15 = (zend_fcall_info_cache *) emalloc(sizeof(zend_fcall_info_cache));
if (!sw_zend_is_callable_ex(VAR_3, NULL, 0, &VAR_14, NULL, VAR_15, NULL))
{
swoole_php_fatal_error(VAR_16, ""function '%s' is not callable"", VAR_14);
return;
}
efree(VAR_14);
sw_fci_cache_persist(VAR_15);
VAR_4->private_data_3 = (void *) VAR_15;
VAR_12 = VAR_17;
break;
}
if (VAR_12)
{
VAR_4->dispatch_mode = VAR_18;
VAR_4->dispatch_func = VAR_12;
}
}
if (php_swoole_array_get_value(VAR_2, ""log_file"", VAR_3))
{
convert_to_string(VAR_3);
if (VAR_7.log_file)
{
sw_free(VAR_7.log_file);
}
VAR_7.log_file = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
}
if (php_swoole_array_get_value(VAR_2, ""log_level"", VAR_3))
{
zend_long VAR_19;
convert_to_long(VAR_3);
VAR_19 = Z_LVAL_P(VAR_3);
VAR_7.log_level = (uint32_t) (VAR_19 < 0 ? VAR_20 : VAR_19);
}
if (php_swoole_array_get_value(VAR_2, ""discard_timeout_request"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->discard_timeout_request = (uint32_t) Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""enable_unsafe_event"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->enable_unsafe_event = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""enable_delay_receive"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->enable_delay_receive = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""task_enable_coroutine"", VAR_3))
{
convert_to_boolean(VAR_3);
if (Z_BVAL_P(VAR_3))
{
if (!VAR_7.enable_coroutine)
{
swoole_php_fatal_error(VAR_16, ""server->enable_coroutine must be true."");
return;
}
VAR_4->task_enable_coroutine = 1;
}
else
{
VAR_4->task_enable_coroutine = 0;
}
}
if (php_swoole_array_get_value(VAR_2, ""task_worker_num"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->task_worker_num = (uint16_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""trace_event_worker"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->trace_event_worker = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""request_slowlog_timeout"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->request_slowlog_timeout = (uint8_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""request_slowlog_file"", VAR_3))
{
convert_to_string(VAR_3);
VAR_4->request_slowlog_file = fopen(Z_STRVAL_P(VAR_3), ""a+"");
if (VAR_4->request_slowlog_file == NULL)
{
swoole_php_fatal_error(VAR_16, ""Unable to open request_slowlog_file[%s]."", Z_STRVAL_P(VAR_3));
return;
}
if (VAR_4->request_slowlog_timeout == 0)
{
VAR_4->request_slowlog_timeout = 1;
}
}
if (php_swoole_array_get_value(VAR_2, ""task_ipc_mode"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->task_ipc_mode = (uint8_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""task_tmpdir"", VAR_3))
{
convert_to_string(VAR_3);
if (php_swoole_create_dir(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3)) < 0)
{
swoole_php_fatal_error(VAR_16, ""Unable to create task_tmpdir[%s]."", Z_STRVAL_P(VAR_3));
return;
}
if (VAR_7.task_tmpdir)
{
sw_free(VAR_7.task_tmpdir);
}
VAR_7.task_tmpdir = (char*) sw_malloc(Z_STRLEN_P(VAR_3) + sizeof(VAR_21) + 1);
VAR_7.task_tmpdir_len = sw_snprintf(VAR_7.task_tmpdir, VAR_22, ""%s/swoole.task.XXXXXX"", Z_STRVAL_P(VAR_3)) + 1;
}
if (php_swoole_array_get_value(VAR_2, ""task_max_request"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->task_max_request = (uint16_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""max_connection"", VAR_3) || php_swoole_array_get_value(VAR_2, ""max_conn"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->max_connection = (uint32_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""heartbeat_check_interval"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->heartbeat_check_interval = (uint16_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""heartbeat_idle_time"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->heartbeat_idle_time = (uint16_t) Z_LVAL_P(VAR_3);
if (VAR_4->heartbeat_check_interval > VAR_4->heartbeat_idle_time)
{
swoole_php_fatal_error(VAR_5, ""heartbeat_idle_time must be greater than heartbeat_check_interval."");
VAR_4->heartbeat_check_interval = VAR_4->heartbeat_idle_time / 2;
}
}
else if (VAR_4->heartbeat_check_interval > 0)
{
VAR_4->heartbeat_idle_time = VAR_4->heartbeat_check_interval * 2;
}
if (php_swoole_array_get_value(VAR_2, ""max_request"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->max_request = (uint32_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""reload_async"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->reload_async = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""open_cpu_affinity"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->open_cpu_affinity = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""cpu_affinity_ignore"", VAR_3))
{
int VAR_23 = zend_hash_num_elements(Z_ARRVAL_P(VAR_3));
if (VAR_23 >= VAR_24)
{
swoole_php_fatal_error(VAR_16, ""cpu_affinity_ignore num must be less than cpu num (%d)"", VAR_24);
VAR_6;
}
int VAR_25 = VAR_24 - VAR_23;
int *VAR_26 = (int *) sw_malloc(sizeof(int) * VAR_25);
int VAR_27, VAR_28, VAR_29 = 0;
zval *VAR_30 = NULL;
for (VAR_28 = 0; VAR_28 < VAR_24; VAR_28++)
{
VAR_27 = 1;
SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(VAR_3), VAR_30)
int VAR_31 = (int) Z_LVAL_P(VAR_30);
if (VAR_28 == VAR_31)
{
VAR_27 = 0;
break;
}
SW_HASHTABLE_FOREACH_END();
if (VAR_27)
{
VAR_26[VAR_29] = VAR_28;
VAR_29++;
}
}
VAR_4->cpu_affinity_available_num = VAR_25;
VAR_4->cpu_affinity_available = VAR_26;
}
if (php_swoole_array_get_value(VAR_2, ""http_parse_post"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->http_parse_post = Z_BVAL_P(VAR_3);
}
#ifdef VAR_32
if (php_swoole_array_get_value(VAR_2, ""http_compression"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->http_compression = Z_BVAL_P(VAR_3);
VAR_4->http_compression_level = VAR_33;
}
if (php_swoole_array_get_value(VAR_2, ""http_gzip_level"", VAR_3) || php_swoole_array_get_value(VAR_2, ""http_compression_level"", VAR_3))
{
convert_to_long(VAR_3);
zend_long VAR_19 = Z_LVAL_P(VAR_3);
if (VAR_19 > VAR_34)
{
VAR_19 = VAR_34;
}
else if (VAR_19 < 0)
{
VAR_19 = 0;
}
VAR_4->http_compression_level = VAR_19;
}
#endif
if (php_swoole_array_get_value(VAR_2, ""upload_tmp_dir"", VAR_3))
{
convert_to_string(VAR_3);
if (php_swoole_create_dir(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3)) < 0)
{
swoole_php_fatal_error(VAR_16, ""Unable to create upload_tmp_dir[%s]."", Z_STRVAL_P(VAR_3));
return;
}
if (VAR_4->upload_tmp_dir)
{
sw_free(VAR_4->upload_tmp_dir);
}
VAR_4->upload_tmp_dir = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
}
if (php_swoole_array_get_value(VAR_2, ""enable_static_handler"", VAR_3))
{
convert_to_boolean(VAR_3);
VAR_4->enable_static_handler = Z_BVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""document_root"", VAR_3))
{
convert_to_string(VAR_3);
if (VAR_4->document_root)
{
sw_free(VAR_4->document_root);
}
VAR_4->document_root = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
if (VAR_4->document_root[Z_STRLEN_P(VAR_3) - 1] == '/')
{
VAR_4->document_root[Z_STRLEN_P(VAR_3) - 1] = 0;
VAR_4->document_root_len = Z_STRLEN_P(VAR_3) - 1;
}
else
{
VAR_4->document_root_len = Z_STRLEN_P(VAR_3);
}
}
if (php_swoole_array_get_value(VAR_2, ""buffer_input_size"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->buffer_input_size = (uint32_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""buffer_output_size"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->buffer_output_size = (uint32_t) Z_LVAL_P(VAR_3);
}
if (php_swoole_array_get_value(VAR_2, ""message_queue_key"", VAR_3))
{
convert_to_long(VAR_3);
VAR_4->message_queue_key = (uint64_t) Z_LVAL_P(VAR_3);
}
zval *VAR_35 = NULL;
zval *VAR_36 = VAR_37.zobjects[0];
Z_TRY_ADDREF_P(VAR_36);
Z_TRY_ADDREF_P(VAR_0);
sw_zend_call_method_with_1_params(&VAR_36, VAR_38, NULL, ""set"", &VAR_35, VAR_0);
zval *VAR_39 = sw_zend_read_property_array(VAR_40, getThis(), ZEND_STRL(""setting""), 1);
php_array_merge(Z_ARRVAL_P(VAR_39), Z_ARRVAL_P(VAR_0));
zval_ptr_dtor(VAR_0);
VAR_41;
}",,"static PHP_METHOD(swoole_server, set)
{
    zval *zset = NULL;
    zval *zobject = getThis();
    HashTable *vht;

    zval *v;

    swServer *serv = (swServer *) swoole_get_object(zobject);
    if (serv->gs->start > 0)
    {
        swoole_php_fatal_error(E_WARNING, ""server is running. unable to execute function 'swoole_server_set'."");
        RETURN_FALSE;
    }

    ZEND_PARSE_PARAMETERS_START(1, 1)
        Z_PARAM_ARRAY(zset)
    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);

    php_swoole_array_separate(zset);
    vht = Z_ARRVAL_P(zset);

    //chroot
    if (php_swoole_array_get_value(vht, ""chroot"", v))
    {
        convert_to_string(v);
        if (SwooleG.chroot)
        {
            sw_free(SwooleG.chroot);
        }
        SwooleG.chroot = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
    }
    //user
    if (php_swoole_array_get_value(vht, ""user"", v))
    {
        convert_to_string(v);
        if (SwooleG.user)
        {
            sw_free(SwooleG.user);
        }
        SwooleG.user = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
    }
    //group
    if (php_swoole_array_get_value(vht, ""group"", v))
    {
        convert_to_string(v);
        if (SwooleG.group)
        {
            sw_free(SwooleG.group);
        }
        SwooleG.group = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
    }
    //daemonize
    if (php_swoole_array_get_value(vht, ""daemonize"", v))
    {
        convert_to_boolean(v);
        serv->daemonize = Z_BVAL_P(v);
    }
#ifdef SW_DEBUG
    //debug
    if (php_swoole_array_get_value(vht, ""debug_mode"", v))
    {
        convert_to_boolean(v);
        if (Z_BVAL_P(v))
        {
            SwooleG.log_level = 0;
        }
    }
#endif
    if (php_swoole_array_get_value(vht, ""trace_flags"", v))
    {
        convert_to_long(v);
        SwooleG.trace_flags = (uint32_t) MAX(0, Z_LVAL_P(v));
    }
    //pid file
    if (php_swoole_array_get_value(vht, ""pid_file"", v))
    {
        convert_to_string(v);
        if (serv->pid_file)
        {
            sw_free(serv->pid_file);
        }
        serv->pid_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
    }
    //reactor thread num
    if (php_swoole_array_get_value(vht, ""reactor_num"", v))
    {
        convert_to_long(v);
        serv->reactor_num = (uint16_t) Z_LVAL_P(v);
        if (serv->reactor_num <= 0)
        {
            serv->reactor_num = SwooleG.cpu_num;
        }
    }
    //worker_num
    if (php_swoole_array_get_value(vht, ""worker_num"", v))
    {
        convert_to_long(v);
        serv->worker_num = (uint16_t) Z_LVAL_P(v);
        if (serv->worker_num <= 0)
        {
            serv->worker_num = SwooleG.cpu_num;
        }
    }
    //max wait time
    if (php_swoole_array_get_value(vht, ""max_wait_time"", v))
    {
        convert_to_long(v);
        serv->max_wait_time = (uint32_t) Z_LVAL_P(v);
    }
#ifdef SW_COROUTINE
    if (php_swoole_array_get_value(vht, ""enable_coroutine"", v))
    {
        convert_to_boolean(v);
        serv->enable_coroutine = SwooleG.enable_coroutine = Z_BVAL_P(v);
    }
    if (php_swoole_array_get_value(vht, ""max_coro_num"", v) || php_swoole_array_get_value(vht, ""max_coroutine"", v))
    {
        zend_long max_num;
        convert_to_long(v);
        max_num = Z_LVAL_P(v);
        PHPCoroutine::set_max_num(max_num <= 0 ? SW_DEFAULT_MAX_CORO_NUM : max_num);
    }
    if (php_swoole_array_get_value(vht, ""send_yield"", v))
    {
        convert_to_boolean(v);
        serv->send_yield = Z_BVAL_P(v);
    }
    if (php_swoole_array_get_value(vht, ""send_timeout"", v))
    {
        convert_to_double(v);
        serv->send_timeout = Z_DVAL_P(v);
    }
#endif
    //dispatch_mode
    if (php_swoole_array_get_value(vht, ""dispatch_mode"", v))
    {
        convert_to_long(v);
        serv->dispatch_mode = (uint8_t) Z_LVAL_P(v);
    }
    //dispatch function
    if (php_swoole_array_get_value(vht, ""dispatch_func"", v))
    {
        swServer_dispatch_function c_dispatch_func = NULL;
        while(1)
        {
            if (Z_TYPE_P(v) == IS_STRING)
            {
                c_dispatch_func = (swServer_dispatch_function) swoole_get_function(Z_STRVAL_P(v), Z_STRLEN_P(v));
                if (c_dispatch_func)
                {
                    break;
                }
            }
            char *func_name = NULL;
            zend_fcall_info_cache *fci_cache = (zend_fcall_info_cache *) emalloc(sizeof(zend_fcall_info_cache));
            if (!sw_zend_is_callable_ex(v, NULL, 0, &func_name, NULL, fci_cache, NULL))
            {
                swoole_php_fatal_error(E_ERROR, ""function '%s' is not callable"", func_name);
                return;
            }
            efree(func_name);
            sw_fci_cache_persist(fci_cache);
            serv->private_data_3 = (void *) fci_cache;
            c_dispatch_func = php_swoole_dispatch_func;
            break;
        }
        if (c_dispatch_func)
        {
            serv->dispatch_mode = SW_DISPATCH_USERFUNC;
            serv->dispatch_func = c_dispatch_func;
        }
    }
    //log_file
    if (php_swoole_array_get_value(vht, ""log_file"", v))
    {
        convert_to_string(v);
        if (SwooleG.log_file)
        {
            sw_free(SwooleG.log_file);
        }
        SwooleG.log_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
    }
    //log_level
    if (php_swoole_array_get_value(vht, ""log_level"", v))
    {
        zend_long level;
        convert_to_long(v);
        level = Z_LVAL_P(v);
        SwooleG.log_level = (uint32_t) (level < 0 ? UINT32_MAX : level);
    }
    /**
     * for dispatch_mode = 1/3
     */
    if (php_swoole_array_get_value(vht, ""discard_timeout_request"", v))
    {
        convert_to_boolean(v);
        serv->discard_timeout_request = (uint32_t) Z_BVAL_P(v);
    }
    //onConnect/onClose event
    if (php_swoole_array_get_value(vht, ""enable_unsafe_event"", v))
    {
        convert_to_boolean(v);
        serv->enable_unsafe_event = Z_BVAL_P(v);
    }
    //delay receive
    if (php_swoole_array_get_value(vht, ""enable_delay_receive"", v))
    {
        convert_to_boolean(v);
        serv->enable_delay_receive = Z_BVAL_P(v);
    }
    //task coroutine
    if (php_swoole_array_get_value(vht, ""task_enable_coroutine"", v))
    {
        convert_to_boolean(v);
        if (Z_BVAL_P(v))
        {
            if (!SwooleG.enable_coroutine)
            {
                swoole_php_fatal_error(E_ERROR, ""server->enable_coroutine must be true."");
                return;
            }
            serv->task_enable_coroutine = 1;
        }
        else
        {
            serv->task_enable_coroutine = 0;
        }
    }
    //task_worker_num
    if (php_swoole_array_get_value(vht, ""task_worker_num"", v))
    {
        convert_to_long(v);
        serv->task_worker_num = (uint16_t) Z_LVAL_P(v);
    }
    //slowlog
    if (php_swoole_array_get_value(vht, ""trace_event_worker"", v))
    {
        convert_to_boolean(v);
        serv->trace_event_worker = Z_BVAL_P(v);
    }
    if (php_swoole_array_get_value(vht, ""request_slowlog_timeout"", v))
    {
        convert_to_long(v);
        serv->request_slowlog_timeout = (uint8_t) Z_LVAL_P(v);
    }
    if (php_swoole_array_get_value(vht, ""request_slowlog_file"", v))
    {
        convert_to_string(v);
        serv->request_slowlog_file = fopen(Z_STRVAL_P(v), ""a+"");
        if (serv->request_slowlog_file == NULL)
        {
            swoole_php_fatal_error(E_ERROR, ""Unable to open request_slowlog_file[%s]."", Z_STRVAL_P(v));
            return;
        }
        if (serv->request_slowlog_timeout == 0)
        {
            serv->request_slowlog_timeout = 1;
        }
    }
    //task ipc mode, 1,2,3
    if (php_swoole_array_get_value(vht, ""task_ipc_mode"", v))
    {
        convert_to_long(v);
        serv->task_ipc_mode = (uint8_t) Z_LVAL_P(v);
    }
    /**
     * Temporary file directory for task_worker
     */
    if (php_swoole_array_get_value(vht, ""task_tmpdir"", v))
    {
        convert_to_string(v);
        if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)
        {
            swoole_php_fatal_error(E_ERROR, ""Unable to create task_tmpdir[%s]."", Z_STRVAL_P(v));
            return;
        }
        if (SwooleG.task_tmpdir)
        {
            sw_free(SwooleG.task_tmpdir);
        }
        SwooleG.task_tmpdir = (char*) sw_malloc(Z_STRLEN_P(v) + sizeof(SW_TASK_TMP_FILE) + 1);
        SwooleG.task_tmpdir_len = sw_snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, ""%s/swoole.task.XXXXXX"", Z_STRVAL_P(v)) + 1;
    }
    //task_max_request
    if (php_swoole_array_get_value(vht, ""task_max_request"", v))
    {
        convert_to_long(v);
        serv->task_max_request = (uint16_t) Z_LVAL_P(v);
    }
    //max_connection
    if (php_swoole_array_get_value(vht, ""max_connection"", v) || php_swoole_array_get_value(vht, ""max_conn"", v))
    {
        convert_to_long(v);
        serv->max_connection = (uint32_t) Z_LVAL_P(v);
    }
    //heartbeat_check_interval
    if (php_swoole_array_get_value(vht, ""heartbeat_check_interval"", v))
    {
        convert_to_long(v);
        serv->heartbeat_check_interval = (uint16_t) Z_LVAL_P(v);
    }
    //heartbeat idle time
    if (php_swoole_array_get_value(vht, ""heartbeat_idle_time"", v))
    {
        convert_to_long(v);
        serv->heartbeat_idle_time = (uint16_t) Z_LVAL_P(v);

        if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)
        {
            swoole_php_fatal_error(E_WARNING, ""heartbeat_idle_time must be greater than heartbeat_check_interval."");
            serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;
        }
    }
    else if (serv->heartbeat_check_interval > 0)
    {
        serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;
    }
    //max_request
    if (php_swoole_array_get_value(vht, ""max_request"", v))
    {
        convert_to_long(v);
        serv->max_request = (uint32_t) Z_LVAL_P(v);
    }
    //reload async
    if (php_swoole_array_get_value(vht, ""reload_async"", v))
    {
        convert_to_boolean(v);
        serv->reload_async = Z_BVAL_P(v);
    }
    //cpu affinity
    if (php_swoole_array_get_value(vht, ""open_cpu_affinity"", v))
    {
        convert_to_boolean(v);
        serv->open_cpu_affinity = Z_BVAL_P(v);
    }
    //cpu affinity set
    if (php_swoole_array_get_value(vht, ""cpu_affinity_ignore"", v))
    {
        int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));
        if (ignore_num >= SW_CPU_NUM)
        {
            swoole_php_fatal_error(E_ERROR, ""cpu_affinity_ignore num must be less than cpu num (%d)"", SW_CPU_NUM);
            RETURN_FALSE;
        }
        int available_num = SW_CPU_NUM - ignore_num;
        int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);
        int flag, i, available_i = 0;

        zval *zval_core = NULL;
        for (i = 0; i < SW_CPU_NUM; i++)
        {
            flag = 1;
            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)
                int core = (int) Z_LVAL_P(zval_core);
                if (i == core)
                {
                    flag = 0;
                    break;
                }
            SW_HASHTABLE_FOREACH_END();
            if (flag)
            {
                available_cpu[available_i] = i;
                available_i++;
            }
        }
        serv->cpu_affinity_available_num = available_num;
        serv->cpu_affinity_available = available_cpu;
    }
    //paser x-www-form-urlencoded form data
    if (php_swoole_array_get_value(vht, ""http_parse_post"", v))
    {
        convert_to_boolean(v);
        serv->http_parse_post = Z_BVAL_P(v);
    }
#ifdef SW_HAVE_ZLIB
    //http content compression
    if (php_swoole_array_get_value(vht, ""http_compression"", v))
    {
        convert_to_boolean(v);
        serv->http_compression = Z_BVAL_P(v);
        serv->http_compression_level = Z_BEST_SPEED;
    }
    if (php_swoole_array_get_value(vht, ""http_gzip_level"", v) || php_swoole_array_get_value(vht, ""http_compression_level"", v))
    {
        convert_to_long(v);
        zend_long level = Z_LVAL_P(v);
        if (level > UINT8_MAX)
        {
            level = UINT8_MAX;
        }
        else if (level < 0)
        {
            level = 0;
        }
        serv->http_compression_level = level;
    }
#endif
    //temporary directory for HTTP uploaded file.
    if (php_swoole_array_get_value(vht, ""upload_tmp_dir"", v))
    {
        convert_to_string(v);
        if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)
        {
            swoole_php_fatal_error(E_ERROR, ""Unable to create upload_tmp_dir[%s]."", Z_STRVAL_P(v));
            return;
        }
        if (serv->upload_tmp_dir)
        {
            sw_free(serv->upload_tmp_dir);
        }
        serv->upload_tmp_dir = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
    }
    /**
     * http static file handler
     */
    if (php_swoole_array_get_value(vht, ""enable_static_handler"", v))
    {
        convert_to_boolean(v);
        serv->enable_static_handler = Z_BVAL_P(v);
    }
    if (php_swoole_array_get_value(vht, ""document_root"", v))
    {
        convert_to_string(v);

        if (Z_STRLEN_P(v) >= PATH_MAX)
        {
            swoole_php_fatal_error(E_ERROR, ""The length of document_root must be less than %d."", PATH_MAX);
            return;
        }

        if (serv->document_root)
        {
            sw_free(serv->document_root);
        }

        serv->document_root = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
        if (serv->document_root[Z_STRLEN_P(v) - 1] == '/')
        {
            serv->document_root[Z_STRLEN_P(v) - 1] = 0;
            serv->document_root_len = Z_STRLEN_P(v) - 1;
        }
        else
        {
            serv->document_root_len = Z_STRLEN_P(v);
        }
    }
    /**
     * buffer input size
     */
    if (php_swoole_array_get_value(vht, ""buffer_input_size"", v))
    {
        convert_to_long(v);
        serv->buffer_input_size = (uint32_t) Z_LVAL_P(v);
    }
    /**
     * buffer output size
     */
    if (php_swoole_array_get_value(vht, ""buffer_output_size"", v))
    {
        convert_to_long(v);
        serv->buffer_output_size = (uint32_t) Z_LVAL_P(v);
    }
    //message queue key
    if (php_swoole_array_get_value(vht, ""message_queue_key"", v))
    {
        convert_to_long(v);
        serv->message_queue_key = (uint64_t) Z_LVAL_P(v);
    }

    zval *retval = NULL;
    zval *port_object = server_port_list.zobjects[0];

    Z_TRY_ADDREF_P(port_object);
    Z_TRY_ADDREF_P(zset);

    sw_zend_call_method_with_1_params(&port_object, swoole_server_port_ce_ptr, NULL, ""set"", &retval, zset);

    zval *zsetting = sw_zend_read_property_array(swoole_server_ce_ptr, getThis(), ZEND_STRL(""setting""), 1);
    php_array_merge(Z_ARRVAL_P(zsetting), Z_ARRVAL_P(zset));
    zval_ptr_dtor(zset);

    RETURN_TRUE;
}","static PHP_METHOD(swoole_server, set)
{
    zval *VAR_0 = NULL;
    zval *VAR_1 = getThis();
    HashTable *VAR_2;

    zval *VAR_3;

    swServer *VAR_4 = (swServer *) swoole_get_object(VAR_1);
    if (VAR_4->gs->start > 0)
    {
        swoole_php_fatal_error(VAR_5, ""server is running. unable to execute function 'swoole_server_set'."");
        VAR_6;
    }

    ZEND_PARSE_PARAMETERS_START(1, 1)
        Z_PARAM_ARRAY(VAR_0)
    ZEND_PARSE_PARAMETERS_END_EX(VAR_6);

    php_swoole_array_separate(VAR_0);
    VAR_2 = Z_ARRVAL_P(VAR_0);

    /* COMMENT_0 */
    if (php_swoole_array_get_value(VAR_2, ""chroot"", VAR_3))
    {
        convert_to_string(VAR_3);
        if (VAR_7.chroot)
        {
            sw_free(VAR_7.chroot);
        }
        VAR_7.chroot = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
    }
    /* COMMENT_1 */
    if (php_swoole_array_get_value(VAR_2, ""user"", VAR_3))
    {
        convert_to_string(VAR_3);
        if (VAR_7.user)
        {
            sw_free(VAR_7.user);
        }
        VAR_7.user = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
    }
    /* COMMENT_2 */
    if (php_swoole_array_get_value(VAR_2, ""group"", VAR_3))
    {
        convert_to_string(VAR_3);
        if (VAR_7.group)
        {
            sw_free(VAR_7.group);
        }
        VAR_7.group = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
    }
    /* COMMENT_3 */
    if (php_swoole_array_get_value(VAR_2, ""daemonize"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->daemonize = Z_BVAL_P(VAR_3);
    }
#ifdef VAR_8
    /* COMMENT_4 */
    if (php_swoole_array_get_value(VAR_2, ""debug_mode"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        if (Z_BVAL_P(VAR_3))
        {
            VAR_7.log_level = 0;
        }
    }
#endif
    if (php_swoole_array_get_value(VAR_2, ""trace_flags"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_7.trace_flags = (uint32_t) MAX(0, Z_LVAL_P(VAR_3));
    }
    /* COMMENT_5 */
    if (php_swoole_array_get_value(VAR_2, ""pid_file"", VAR_3))
    {
        convert_to_string(VAR_3);
        if (VAR_4->pid_file)
        {
            sw_free(VAR_4->pid_file);
        }
        VAR_4->pid_file = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
    }
    /* COMMENT_6 */
    if (php_swoole_array_get_value(VAR_2, ""reactor_num"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->reactor_num = (uint16_t) Z_LVAL_P(VAR_3);
        if (VAR_4->reactor_num <= 0)
        {
            VAR_4->reactor_num = VAR_7.cpu_num;
        }
    }
    /* COMMENT_7 */
    if (php_swoole_array_get_value(VAR_2, ""worker_num"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->worker_num = (uint16_t) Z_LVAL_P(VAR_3);
        if (VAR_4->worker_num <= 0)
        {
            VAR_4->worker_num = VAR_7.cpu_num;
        }
    }
    /* COMMENT_8 */
    if (php_swoole_array_get_value(VAR_2, ""max_wait_time"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->max_wait_time = (uint32_t) Z_LVAL_P(VAR_3);
    }
#ifdef VAR_9
    if (php_swoole_array_get_value(VAR_2, ""enable_coroutine"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->enable_coroutine = VAR_7.enable_coroutine = Z_BVAL_P(VAR_3);
    }
    if (php_swoole_array_get_value(VAR_2, ""max_coro_num"", VAR_3) || php_swoole_array_get_value(VAR_2, ""max_coroutine"", VAR_3))
    {
        zend_long VAR_10;
        convert_to_long(VAR_3);
        VAR_10 = Z_LVAL_P(VAR_3);
        PHPCoroutine::set_max_num(VAR_10 <= 0 ? VAR_11 : VAR_10);
    }
    if (php_swoole_array_get_value(VAR_2, ""send_yield"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->send_yield = Z_BVAL_P(VAR_3);
    }
    if (php_swoole_array_get_value(VAR_2, ""send_timeout"", VAR_3))
    {
        convert_to_double(VAR_3);
        VAR_4->send_timeout = Z_DVAL_P(VAR_3);
    }
#endif
    /* COMMENT_9 */
    if (php_swoole_array_get_value(VAR_2, ""dispatch_mode"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->dispatch_mode = (uint8_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_10 */
    if (php_swoole_array_get_value(VAR_2, ""dispatch_func"", VAR_3))
    {
        swServer_dispatch_function VAR_12 = NULL;
        while(1)
        {
            if (Z_TYPE_P(VAR_3) == VAR_13)
            {
                VAR_12 = (swServer_dispatch_function) swoole_get_function(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
                if (VAR_12)
                {
                    break;
                }
            }
            char *VAR_14 = NULL;
            zend_fcall_info_cache *VAR_15 = (zend_fcall_info_cache *) emalloc(sizeof(zend_fcall_info_cache));
            if (!sw_zend_is_callable_ex(VAR_3, NULL, 0, &VAR_14, NULL, VAR_15, NULL))
            {
                swoole_php_fatal_error(VAR_16, ""function '%s' is not callable"", VAR_14);
                return;
            }
            efree(VAR_14);
            sw_fci_cache_persist(VAR_15);
            VAR_4->private_data_3 = (void *) VAR_15;
            VAR_12 = VAR_17;
            break;
        }
        if (VAR_12)
        {
            VAR_4->dispatch_mode = VAR_18;
            VAR_4->dispatch_func = VAR_12;
        }
    }
    /* COMMENT_11 */
    if (php_swoole_array_get_value(VAR_2, ""log_file"", VAR_3))
    {
        convert_to_string(VAR_3);
        if (VAR_7.log_file)
        {
            sw_free(VAR_7.log_file);
        }
        VAR_7.log_file = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
    }
    /* COMMENT_12 */
    if (php_swoole_array_get_value(VAR_2, ""log_level"", VAR_3))
    {
        zend_long VAR_19;
        convert_to_long(VAR_3);
        VAR_19 = Z_LVAL_P(VAR_3);
        VAR_7.log_level = (uint32_t) (VAR_19 < 0 ? VAR_20 : VAR_19);
    }
    /* COMMENT_13 */
                              
       
    if (php_swoole_array_get_value(VAR_2, ""discard_timeout_request"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->discard_timeout_request = (uint32_t) Z_BVAL_P(VAR_3);
    }
    /* COMMENT_16 */
    if (php_swoole_array_get_value(VAR_2, ""enable_unsafe_event"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->enable_unsafe_event = Z_BVAL_P(VAR_3);
    }
    /* COMMENT_17 */
    if (php_swoole_array_get_value(VAR_2, ""enable_delay_receive"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->enable_delay_receive = Z_BVAL_P(VAR_3);
    }
    /* COMMENT_18 */
    if (php_swoole_array_get_value(VAR_2, ""task_enable_coroutine"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        if (Z_BVAL_P(VAR_3))
        {
            if (!VAR_7.enable_coroutine)
            {
                swoole_php_fatal_error(VAR_16, ""server->enable_coroutine must be true."");
                return;
            }
            VAR_4->task_enable_coroutine = 1;
        }
        else
        {
            VAR_4->task_enable_coroutine = 0;
        }
    }
    /* COMMENT_19 */
    if (php_swoole_array_get_value(VAR_2, ""task_worker_num"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->task_worker_num = (uint16_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_20 */
    if (php_swoole_array_get_value(VAR_2, ""trace_event_worker"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->trace_event_worker = Z_BVAL_P(VAR_3);
    }
    if (php_swoole_array_get_value(VAR_2, ""request_slowlog_timeout"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->request_slowlog_timeout = (uint8_t) Z_LVAL_P(VAR_3);
    }
    if (php_swoole_array_get_value(VAR_2, ""request_slowlog_file"", VAR_3))
    {
        convert_to_string(VAR_3);
        VAR_4->request_slowlog_file = fopen(Z_STRVAL_P(VAR_3), ""a+"");
        if (VAR_4->request_slowlog_file == NULL)
        {
            swoole_php_fatal_error(VAR_16, ""Unable to open request_slowlog_file[%s]."", Z_STRVAL_P(VAR_3));
            return;
        }
        if (VAR_4->request_slowlog_timeout == 0)
        {
            VAR_4->request_slowlog_timeout = 1;
        }
    }
    /* COMMENT_21 */
    if (php_swoole_array_get_value(VAR_2, ""task_ipc_mode"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->task_ipc_mode = (uint8_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_22 */
                                               
       
    if (php_swoole_array_get_value(VAR_2, ""task_tmpdir"", VAR_3))
    {
        convert_to_string(VAR_3);
        if (php_swoole_create_dir(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3)) < 0)
        {
            swoole_php_fatal_error(VAR_16, ""Unable to create task_tmpdir[%s]."", Z_STRVAL_P(VAR_3));
            return;
        }
        if (VAR_7.task_tmpdir)
        {
            sw_free(VAR_7.task_tmpdir);
        }
        VAR_7.task_tmpdir = (char*) sw_malloc(Z_STRLEN_P(VAR_3) + sizeof(VAR_21) + 1);
        VAR_7.task_tmpdir_len = sw_snprintf(VAR_7.task_tmpdir, VAR_22, ""%s/swoole.task.XXXXXX"", Z_STRVAL_P(VAR_3)) + 1;
    }
    /* COMMENT_25 */
    if (php_swoole_array_get_value(VAR_2, ""task_max_request"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->task_max_request = (uint16_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_26 */
    if (php_swoole_array_get_value(VAR_2, ""max_connection"", VAR_3) || php_swoole_array_get_value(VAR_2, ""max_conn"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->max_connection = (uint32_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_27 */
    if (php_swoole_array_get_value(VAR_2, ""heartbeat_check_interval"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->heartbeat_check_interval = (uint16_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_28 */
    if (php_swoole_array_get_value(VAR_2, ""heartbeat_idle_time"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->heartbeat_idle_time = (uint16_t) Z_LVAL_P(VAR_3);

        if (VAR_4->heartbeat_check_interval > VAR_4->heartbeat_idle_time)
        {
            swoole_php_fatal_error(VAR_5, ""heartbeat_idle_time must be greater than heartbeat_check_interval."");
            VAR_4->heartbeat_check_interval = VAR_4->heartbeat_idle_time / 2;
        }
    }
    else if (VAR_4->heartbeat_check_interval > 0)
    {
        VAR_4->heartbeat_idle_time = VAR_4->heartbeat_check_interval * 2;
    }
    /* COMMENT_29 */
    if (php_swoole_array_get_value(VAR_2, ""max_request"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->max_request = (uint32_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_30 */
    if (php_swoole_array_get_value(VAR_2, ""reload_async"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->reload_async = Z_BVAL_P(VAR_3);
    }
    /* COMMENT_31 */
    if (php_swoole_array_get_value(VAR_2, ""open_cpu_affinity"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->open_cpu_affinity = Z_BVAL_P(VAR_3);
    }
    /* COMMENT_32 */
    if (php_swoole_array_get_value(VAR_2, ""cpu_affinity_ignore"", VAR_3))
    {
        int VAR_23 = zend_hash_num_elements(Z_ARRVAL_P(VAR_3));
        if (VAR_23 >= VAR_24)
        {
            swoole_php_fatal_error(VAR_16, ""cpu_affinity_ignore num must be less than cpu num (%d)"", VAR_24);
            VAR_6;
        }
        int VAR_25 = VAR_24 - VAR_23;
        int *VAR_26 = (int *) sw_malloc(sizeof(int) * VAR_25);
        int VAR_27, VAR_28, VAR_29 = 0;

        zval *VAR_30 = NULL;
        for (VAR_28 = 0; VAR_28 < VAR_24; VAR_28++)
        {
            VAR_27 = 1;
            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(VAR_3), VAR_30)
                int VAR_31 = (int) Z_LVAL_P(VAR_30);
                if (VAR_28 == VAR_31)
                {
                    VAR_27 = 0;
                    break;
                }
            SW_HASHTABLE_FOREACH_END();
            if (VAR_27)
            {
                VAR_26[VAR_29] = VAR_28;
                VAR_29++;
            }
        }
        VAR_4->cpu_affinity_available_num = VAR_25;
        VAR_4->cpu_affinity_available = VAR_26;
    }
    /* COMMENT_33 */
    if (php_swoole_array_get_value(VAR_2, ""http_parse_post"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->http_parse_post = Z_BVAL_P(VAR_3);
    }
#ifdef VAR_32
    /* COMMENT_34 */
    if (php_swoole_array_get_value(VAR_2, ""http_compression"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->http_compression = Z_BVAL_P(VAR_3);
        VAR_4->http_compression_level = VAR_33;
    }
    if (php_swoole_array_get_value(VAR_2, ""http_gzip_level"", VAR_3) || php_swoole_array_get_value(VAR_2, ""http_compression_level"", VAR_3))
    {
        convert_to_long(VAR_3);
        zend_long VAR_19 = Z_LVAL_P(VAR_3);
        if (VAR_19 > VAR_34)
        {
            VAR_19 = VAR_34;
        }
        else if (VAR_19 < 0)
        {
            VAR_19 = 0;
        }
        VAR_4->http_compression_level = VAR_19;
    }
#endif
    /* COMMENT_35 */
    if (php_swoole_array_get_value(VAR_2, ""upload_tmp_dir"", VAR_3))
    {
        convert_to_string(VAR_3);
        if (php_swoole_create_dir(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3)) < 0)
        {
            swoole_php_fatal_error(VAR_16, ""Unable to create upload_tmp_dir[%s]."", Z_STRVAL_P(VAR_3));
            return;
        }
        if (VAR_4->upload_tmp_dir)
        {
            sw_free(VAR_4->upload_tmp_dir);
        }
        VAR_4->upload_tmp_dir = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
    }
    /* COMMENT_36 */
                               
       
    if (php_swoole_array_get_value(VAR_2, ""enable_static_handler"", VAR_3))
    {
        convert_to_boolean(VAR_3);
        VAR_4->enable_static_handler = Z_BVAL_P(VAR_3);
    }
    if (php_swoole_array_get_value(VAR_2, ""document_root"", VAR_3))
    {
        convert_to_string(VAR_3);

        if (Z_STRLEN_P(VAR_3) >= VAR_35)
        {
            swoole_php_fatal_error(VAR_16, ""The length of document_root must be less than %d."", VAR_35);
            return;
        }

        if (VAR_4->document_root)
        {
            sw_free(VAR_4->document_root);
        }

        VAR_4->document_root = sw_strndup(Z_STRVAL_P(VAR_3), Z_STRLEN_P(VAR_3));
        if (VAR_4->document_root[Z_STRLEN_P(VAR_3) - 1] == '/')
        {
            VAR_4->document_root[Z_STRLEN_P(VAR_3) - 1] = 0;
            VAR_4->document_root_len = Z_STRLEN_P(VAR_3) - 1;
        }
        else
        {
            VAR_4->document_root_len = Z_STRLEN_P(VAR_3);
        }
    }
    /* COMMENT_39 */
                        
       
    if (php_swoole_array_get_value(VAR_2, ""buffer_input_size"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->buffer_input_size = (uint32_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_42 */
                         
       
    if (php_swoole_array_get_value(VAR_2, ""buffer_output_size"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->buffer_output_size = (uint32_t) Z_LVAL_P(VAR_3);
    }
    /* COMMENT_45 */
    if (php_swoole_array_get_value(VAR_2, ""message_queue_key"", VAR_3))
    {
        convert_to_long(VAR_3);
        VAR_4->message_queue_key = (uint64_t) Z_LVAL_P(VAR_3);
    }

    zval *VAR_36 = NULL;
    zval *VAR_37 = VAR_38.zobjects[0];

    Z_TRY_ADDREF_P(VAR_37);
    Z_TRY_ADDREF_P(VAR_0);

    sw_zend_call_method_with_1_params(&VAR_37, VAR_39, NULL, ""set"", &VAR_36, VAR_0);

    zval *VAR_40 = sw_zend_read_property_array(VAR_41, getThis(), ZEND_STRL(""setting""), 1);
    php_array_merge(Z_ARRVAL_P(VAR_40), Z_ARRVAL_P(VAR_0));
    zval_ptr_dtor(VAR_0);

    VAR_42;
}",,"--- func_before
+++ func_after
@@ -423,10 +423,18 @@
     if (php_swoole_array_get_value(vht, ""document_root"", v))
     {
         convert_to_string(v);
+
+        if (Z_STRLEN_P(v) >= PATH_MAX)
+        {
+            swoole_php_fatal_error(E_ERROR, ""The length of document_root must be less than %d."", PATH_MAX);
+            return;
+        }
+
         if (serv->document_root)
         {
             sw_free(serv->document_root);
         }
+
         serv->document_root = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));
         if (serv->document_root[Z_STRLEN_P(v) - 1] == '/')
         {","{'deleted_lines': [], 'added_lines': ['', '        if (Z_STRLEN_P(v) >= PATH_MAX)', '        {', '            swoole_php_fatal_error(E_ERROR, ""The length of document_root must be less than %d."", PATH_MAX);', '            return;', '        }', '', '']}",True,Swoole before 4.2.13 allows directory traversal in swPort_http_static_handler.,5.3,MEDIUM,1,test,2019-01-16T12:06:52Z,2
CVE-2019-15518,['CWE-22'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,swoole/swoole-src,fix bug,a37b20878592951f4e8e7274b38bbb6e94af7e42,https://github.com/swoole/swoole-src/commit/a37b20878592951f4e8e7274b38bbb6e94af7e42,src/network/port.c,swPort_http_static_handler,"static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)
{
char *url = request->buffer->str + request->url_offset;
char *params = memchr(url, '?', request->url_length);
struct
{
off_t offset;
size_t length;
char filename[PATH_MAX];
} buffer;
char *p = buffer.filename;
memcpy(p, serv->document_root, serv->document_root_len);
p += serv->document_root_len;
uint32_t n = params ? params - url : request->url_length;
memcpy(p, url, n);
p += n;
*p = 0;
char real_path[PATH_MAX];
if (!realpath(buffer.filename, real_path))
{
return SW_FALSE;
}
if (real_path[serv->document_root_len] != '/')
{
return SW_FALSE;
}
if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)
{
return SW_FALSE;
}
struct stat file_stat;
if (lstat(buffer.filename, &file_stat) < 0)
{
return SW_FALSE;
}
if (file_stat.st_size == 0)
{
return SW_FALSE;
}
if ((file_stat.st_mode & S_IFMT) != S_IFREG)
{
return SW_FALSE;
}
char header_buffer[1024];
swSendData response;
response.info.fd = conn->session_id;
response.info.type = SW_EVENT_TCP;
p = request->buffer->str + request->url_offset + request->url_length + 10;
char *pe = request->buffer->str + request->header_length;
char *date_if_modified_since = NULL;
int length_if_modified_since = 0;
int state = 0;
for (; p < pe; p++)
{
switch(state)
{
case 0:
if (strncasecmp(p, SW_STRL(""If-Modified-Since"")) == 0)
{
p += sizeof(""If-Modified-Since"");
state = 1;
}
break;
case 1:
if (!isspace(*p))
{
date_if_modified_since = p;
state = 2;
}
break;
case 2:
if (strncasecmp(p, SW_STRL(""\r\n"")) == 0)
{
length_if_modified_since = p - date_if_modified_since;
goto check_modify_date;
}
break;
default:
break;
}
}
char date_[64];
struct tm *tm1;
check_modify_date: tm1 = gmtime(&serv->gs->now);
strftime(date_, sizeof(date_), ""%a, %d %b %Y %H:%M:%S %Z"", tm1);
char date_last_modified[64];
#ifdef __MACH__
time_t file_mtime = file_stat.st_mtimespec.tv_sec;
#elif defined(_WIN32)
time_t file_mtime = file_stat.st_mtime;
#else
time_t file_mtime = file_stat.st_mtim.tv_sec;
#endif
struct tm *tm2 = gmtime(&file_mtime);
strftime(date_last_modified, sizeof(date_last_modified), ""%a, %d %b %Y %H:%M:%S %Z"", tm2);
if (state == 2)
{
struct tm tm3;
char date_tmp[64];
memcpy(date_tmp, date_if_modified_since, length_if_modified_since);
date_tmp[length_if_modified_since] = 0;
char *date_format = NULL;
if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)
{
date_format = SW_HTTP_RFC1123_DATE_GMT;
}
else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)
{
date_format = SW_HTTP_RFC1123_DATE_UTC;
}
else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)
{
date_format = SW_HTTP_RFC850_DATE;
}
else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)
{
date_format = SW_HTTP_ASCTIME_DATE;
}
if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)
{
response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
""HTTP/1.1 304 Not Modified\r\n""
""%s""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
date_,
date_last_modified,
SW_HTTP_SERVER_SOFTWARE
);
response.data = header_buffer;
swServer_master_send(serv, &response);
goto _finish;
}
}
response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
""HTTP/1.1 200 OK\r\n""
""%s""
""Content-Length: %ld\r\n""
""Content-Type: %s\r\n""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
(long) file_stat.st_size,
swoole_get_mime_type(buffer.filename),
date_,
date_last_modified,
SW_HTTP_SERVER_SOFTWARE);
response.data = header_buffer;
#ifdef HAVE_TCP_NOPUSH
if (conn->tcp_nopush == 0)
{
if (swSocket_tcp_nopush(conn->fd, 1) == -1)
{
swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(errno), errno);
}
conn->tcp_nopush = 1;
}
#endif
swServer_master_send(serv, &response);
buffer.offset = 0;
buffer.length = file_stat.st_size;
response.info.type = SW_EVENT_SENDFILE;
response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;
response.data = (void*) &buffer;
swServer_master_send(serv, &response);
_finish:
if (!request->keep_alive)
{
response.info.type = SW_EVENT_CLOSE;
response.length = 0;
response.data = NULL;
swServer_master_send(serv, &response);
}
return SW_TRUE;
}","static int swPort_http_static_handler(swServer *VAR_0, swHttpRequest *VAR_1, swConnection *VAR_2)
{
char *VAR_3 = VAR_1->buffer->str + VAR_1->url_offset;
char *VAR_4 = memchr(VAR_3, '?', VAR_1->url_length);
struct
{
off_t offset;
size_t length;
char filename[VAR_5];
} VAR_6;
char *VAR_7 = VAR_6.filename;
memcpy(VAR_7, VAR_0->document_root, VAR_0->document_root_len);
VAR_7 += VAR_0->document_root_len;
uint32_t VAR_8 = VAR_4 ? VAR_4 - VAR_3 : VAR_1->url_length;
memcpy(VAR_7, VAR_3, VAR_8);
VAR_7 += VAR_8;
*VAR_7 = 0;
char VAR_9[VAR_5];
if (!realpath(VAR_6.filename, VAR_9))
{
return VAR_10;
}
if (VAR_9[VAR_0->document_root_len] != '/')
{
return VAR_10;
}
if (strncmp(VAR_9, VAR_0->document_root, VAR_0->document_root_len) != 0)
{
return VAR_10;
}
struct stat VAR_11;
if (lstat(VAR_6.filename, &VAR_11) < 0)
{
return VAR_10;
}
if (VAR_11.st_size == 0)
{
return VAR_10;
}
if ((VAR_11.st_mode & VAR_12) != VAR_13)
{
return VAR_10;
}
char VAR_14[1024];
swSendData VAR_15;
VAR_15.info.fd = VAR_2->session_id;
VAR_15.info.type = VAR_16;
VAR_7 = VAR_1->buffer->str + VAR_1->url_offset + VAR_1->url_length + 10;
char *VAR_17 = VAR_1->buffer->str + VAR_1->header_length;
char *VAR_18 = NULL;
int VAR_19 = 0;
int VAR_20 = 0;
for (; VAR_7 < VAR_17; VAR_7++)
{
switch(VAR_20)
{
case 0:
if (strncasecmp(VAR_7, SW_STRL(""If-Modified-Since"")) == 0)
{
VAR_7 += sizeof(""If-Modified-Since"");
VAR_20 = 1;
}
break;
case 1:
if (!isspace(*VAR_7))
{
VAR_18 = VAR_7;
VAR_20 = 2;
}
break;
case 2:
if (strncasecmp(VAR_7, SW_STRL(""\r\n"")) == 0)
{
VAR_19 = VAR_7 - VAR_18;
goto check_modify_date;
}
break;
default:
break;
}
}
char VAR_21[64];
struct tm *VAR_22;
check_modify_date: VAR_22 = gmtime(&VAR_0->gs->now);
strftime(VAR_21, sizeof(VAR_21), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_22);
char VAR_23[64];
#ifdef VAR_24
time_t VAR_25 = VAR_11.st_mtimespec.tv_sec;
#elif defined(VAR_26)
time_t VAR_25 = VAR_11.st_mtime;
#else
time_t VAR_25 = VAR_11.st_mtim.tv_sec;
#endif
struct tm *VAR_27 = gmtime(&VAR_25);
strftime(VAR_23, sizeof(VAR_23), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_27);
if (VAR_20 == 2)
{
struct tm VAR_28;
char VAR_29[64];
memcpy(VAR_29, VAR_18, VAR_19);
VAR_29[VAR_19] = 0;
char *VAR_30 = NULL;
if (strptime(VAR_29, VAR_31, &VAR_28) != NULL)
{
VAR_30 = VAR_31;
}
else if (strptime(VAR_29, VAR_32, &VAR_28) != NULL)
{
VAR_30 = VAR_32;
}
else if (strptime(VAR_29, VAR_33, &VAR_28) != NULL)
{
VAR_30 = VAR_33;
}
else if (strptime(VAR_29, VAR_34, &VAR_28) != NULL)
{
VAR_30 = VAR_34;
}
if (VAR_30 && mktime(&VAR_28) - (int) VAR_35 >= VAR_25)
{
VAR_15.length = VAR_15.info.len = sw_snprintf(VAR_14, sizeof(VAR_14),
""HTTP/1.1 304 Not Modified\r\n""
""%s""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
VAR_21,
VAR_23,
VAR_36
);
VAR_15.data = VAR_14;
swServer_master_send(VAR_0, &VAR_15);
goto _finish;
}
}
VAR_15.length = VAR_15.info.len = sw_snprintf(VAR_14, sizeof(VAR_14),
""HTTP/1.1 200 OK\r\n""
""%s""
""Content-Length: %ld\r\n""
""Content-Type: %s\r\n""
""Date: %s\r\n""
""Last-Modified: %s\r\n""
""Server: %s\r\n\r\n"",
VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
(long) VAR_11.st_size,
swoole_get_mime_type(VAR_6.filename),
VAR_21,
VAR_23,
VAR_36);
VAR_15.data = VAR_14;
#ifdef VAR_37
if (VAR_2->tcp_nopush == 0)
{
if (swSocket_tcp_nopush(VAR_2->fd, 1) == -1)
{
swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(VAR_38), VAR_38);
}
VAR_2->tcp_nopush = 1;
}
#endif
swServer_master_send(VAR_0, &VAR_15);
VAR_6.offset = 0;
VAR_6.length = VAR_11.st_size;
VAR_15.info.type = VAR_39;
VAR_15.length = VAR_15.info.len = sizeof(VAR_40) + VAR_6.length + 1;
VAR_15.data = (void*) &VAR_6;
swServer_master_send(VAR_0, &VAR_15);
_finish:
if (!VAR_1->keep_alive)
{
VAR_15.info.type = VAR_41;
VAR_15.length = 0;
VAR_15.data = NULL;
swServer_master_send(VAR_0, &VAR_15);
}
return VAR_42;
}",swoole/swoole-src/a37b20878592951f4e8e7274b38bbb6e94af7e42/port.c/vul/before/0.json,"static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)
{
    char *url = request->buffer->str + request->url_offset;
    char *params = memchr(url, '?', request->url_length);

    struct
    {
        off_t offset;
        size_t length;
        char filename[PATH_MAX];
    } buffer;

    char *p = buffer.filename;

    memcpy(p, serv->document_root, serv->document_root_len);
    p += serv->document_root_len;
    size_t n = params ? params - url : request->url_length;

    if (serv->document_root_len + n >= PATH_MAX)
    {
        return SW_FALSE;
    }

    memcpy(p, url, n);
    p += n;
    *p = '\0';

    char real_path[PATH_MAX];
    if (!realpath(buffer.filename, real_path))
    {
        return SW_FALSE;
    }

    if (real_path[serv->document_root_len] != '/')
    {
        return SW_FALSE;
    }

    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)
    {
        return SW_FALSE;
    }

    struct stat file_stat;
    if (lstat(buffer.filename, &file_stat) < 0)
    {
        return SW_FALSE;
    }
    if (file_stat.st_size == 0)
    {
        return SW_FALSE;
    }
    if ((file_stat.st_mode & S_IFMT) != S_IFREG)
    {
        return SW_FALSE;
    }

    char header_buffer[1024];
    swSendData response;
    response.info.fd = conn->session_id;

    response.info.type = SW_EVENT_TCP;

    p = request->buffer->str + request->url_offset + request->url_length + 10;
    char *pe = request->buffer->str + request->header_length;

    char *date_if_modified_since = NULL;
    int length_if_modified_since = 0;

    int state = 0;
    for (; p < pe; p++)
    {
        switch(state)
        {
        case 0:
            if (strncasecmp(p, SW_STRL(""If-Modified-Since"")) == 0)
            {
                p += sizeof(""If-Modified-Since"");
                state = 1;
            }
            break;
        case 1:
            if (!isspace(*p))
            {
                date_if_modified_since = p;
                state = 2;
            }
            break;
        case 2:
            if (strncasecmp(p, SW_STRL(""\r\n"")) == 0)
            {
                length_if_modified_since = p - date_if_modified_since;
                goto check_modify_date;
            }
            break;
        default:
            break;
        }
    }

    char date_[64];
    struct tm *tm1;

    check_modify_date: tm1 = gmtime(&serv->gs->now);
    strftime(date_, sizeof(date_), ""%a, %d %b %Y %H:%M:%S %Z"", tm1);

    char date_last_modified[64];
#ifdef __MACH__
    time_t file_mtime = file_stat.st_mtimespec.tv_sec;
#elif defined(_WIN32)
	time_t file_mtime = file_stat.st_mtime;
#else
    time_t file_mtime = file_stat.st_mtim.tv_sec;
#endif

    struct tm *tm2 = gmtime(&file_mtime);
    strftime(date_last_modified, sizeof(date_last_modified), ""%a, %d %b %Y %H:%M:%S %Z"", tm2);

    if (state == 2)
    {
        struct tm tm3;
        char date_tmp[64];
        memcpy(date_tmp, date_if_modified_since, length_if_modified_since);
        date_tmp[length_if_modified_since] = 0;

        char *date_format = NULL;

        if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)
        {
            date_format = SW_HTTP_RFC1123_DATE_GMT;
        }
        else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)
        {
            date_format = SW_HTTP_RFC1123_DATE_UTC;
        }
        else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)
        {
            date_format = SW_HTTP_RFC850_DATE;
        }
        else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)
        {
            date_format = SW_HTTP_ASCTIME_DATE;
        }
        if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)
        {
            response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
                    ""HTTP/1.1 304 Not Modified\r\n""
                    ""%s""
                    ""Date: %s\r\n""
                    ""Last-Modified: %s\r\n""
                    ""Server: %s\r\n\r\n"",
                    request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
                    date_,
                    date_last_modified,
                    SW_HTTP_SERVER_SOFTWARE
            );
            response.data = header_buffer;
            swServer_master_send(serv, &response);
            goto _finish;
        }
    }

    response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),
            ""HTTP/1.1 200 OK\r\n""
            ""%s""
            ""Content-Length: %ld\r\n""
            ""Content-Type: %s\r\n""
            ""Date: %s\r\n""
            ""Last-Modified: %s\r\n""
            ""Server: %s\r\n\r\n"",
            request->keep_alive ? ""Connection: keep-alive\r\n"" : """",
            (long) file_stat.st_size,
            swoole_get_mime_type(buffer.filename),
            date_,
            date_last_modified,
            SW_HTTP_SERVER_SOFTWARE);

    response.data = header_buffer;

#ifdef HAVE_TCP_NOPUSH
    if (conn->tcp_nopush == 0)
    {
        if (swSocket_tcp_nopush(conn->fd, 1) == -1)
        {
            swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(errno), errno);
        }
        conn->tcp_nopush = 1;
    }
#endif
    swServer_master_send(serv, &response);

    buffer.offset = 0;
    buffer.length = file_stat.st_size;

    response.info.type = SW_EVENT_SENDFILE;
    response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;
    response.data = (void*) &buffer;

    swServer_master_send(serv, &response);

    _finish:
    if (!request->keep_alive)
    {
        response.info.type = SW_EVENT_CLOSE;
        response.length = 0;
        response.data = NULL;
        swServer_master_send(serv, &response);
    }

    return SW_TRUE;
}","static int swPort_http_static_handler(swServer *VAR_0, swHttpRequest *VAR_1, swConnection *VAR_2)
{
    char *VAR_3 = VAR_1->buffer->str + VAR_1->url_offset;
    char *VAR_4 = memchr(VAR_3, '?', VAR_1->url_length);

    struct
    {
        off_t offset;
        size_t length;
        char filename[VAR_5];
    } VAR_6;

    char *VAR_7 = VAR_6.filename;

    memcpy(VAR_7, VAR_0->document_root, VAR_0->document_root_len);
    VAR_7 += VAR_0->document_root_len;
    size_t VAR_8 = VAR_4 ? VAR_4 - VAR_3 : VAR_1->url_length;

    if (VAR_0->document_root_len + VAR_8 >= VAR_5)
    {
        return VAR_9;
    }

    memcpy(VAR_7, VAR_3, VAR_8);
    VAR_7 += VAR_8;
    *VAR_7 = '\0';

    char VAR_10[VAR_5];
    if (!realpath(VAR_6.filename, VAR_10))
    {
        return VAR_9;
    }

    if (VAR_10[VAR_0->document_root_len] != '/')
    {
        return VAR_9;
    }

    if (strncmp(VAR_10, VAR_0->document_root, VAR_0->document_root_len) != 0)
    {
        return VAR_9;
    }

    struct stat VAR_11;
    if (lstat(VAR_6.filename, &VAR_11) < 0)
    {
        return VAR_9;
    }
    if (VAR_11.st_size == 0)
    {
        return VAR_9;
    }
    if ((VAR_11.st_mode & VAR_12) != VAR_13)
    {
        return VAR_9;
    }

    char VAR_14[1024];
    swSendData VAR_15;
    VAR_15.info.fd = VAR_2->session_id;

    VAR_15.info.type = VAR_16;

    VAR_7 = VAR_1->buffer->str + VAR_1->url_offset + VAR_1->url_length + 10;
    char *VAR_17 = VAR_1->buffer->str + VAR_1->header_length;

    char *VAR_18 = NULL;
    int VAR_19 = 0;

    int VAR_20 = 0;
    for (; VAR_7 < VAR_17; VAR_7++)
    {
        switch(VAR_20)
        {
        case 0:
            if (strncasecmp(VAR_7, SW_STRL(""If-Modified-Since"")) == 0)
            {
                VAR_7 += sizeof(""If-Modified-Since"");
                VAR_20 = 1;
            }
            break;
        case 1:
            if (!isspace(*VAR_7))
            {
                VAR_18 = VAR_7;
                VAR_20 = 2;
            }
            break;
        case 2:
            if (strncasecmp(VAR_7, SW_STRL(""\r\n"")) == 0)
            {
                VAR_19 = VAR_7 - VAR_18;
                goto check_modify_date;
            }
            break;
        default:
            break;
        }
    }

    char VAR_21[64];
    struct tm *VAR_22;

    check_modify_date: VAR_22 = gmtime(&VAR_0->gs->now);
    strftime(VAR_21, sizeof(VAR_21), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_22);

    char VAR_23[64];
#ifdef VAR_24
    time_t VAR_25 = VAR_11.st_mtimespec.tv_sec;
#elif defined(VAR_26)
	time_t VAR_25 = VAR_11.st_mtime;
#else
    time_t VAR_25 = VAR_11.st_mtim.tv_sec;
#endif

    struct tm *VAR_27 = gmtime(&VAR_25);
    strftime(VAR_23, sizeof(VAR_23), ""%a, %d %b %Y %H:%M:%S %Z"", VAR_27);

    if (VAR_20 == 2)
    {
        struct tm VAR_28;
        char VAR_29[64];
        memcpy(VAR_29, VAR_18, VAR_19);
        VAR_29[VAR_19] = 0;

        char *VAR_30 = NULL;

        if (strptime(VAR_29, VAR_31, &VAR_28) != NULL)
        {
            VAR_30 = VAR_31;
        }
        else if (strptime(VAR_29, VAR_32, &VAR_28) != NULL)
        {
            VAR_30 = VAR_32;
        }
        else if (strptime(VAR_29, VAR_33, &VAR_28) != NULL)
        {
            VAR_30 = VAR_33;
        }
        else if (strptime(VAR_29, VAR_34, &VAR_28) != NULL)
        {
            VAR_30 = VAR_34;
        }
        if (VAR_30 && mktime(&VAR_28) - (int) VAR_35 >= VAR_25)
        {
            VAR_15.length = VAR_15.info.len = sw_snprintf(VAR_14, sizeof(VAR_14),
                    ""HTTP/1.1 304 Not Modified\r\n""
                    ""%s""
                    ""Date: %s\r\n""
                    ""Last-Modified: %s\r\n""
                    ""Server: %s\r\n\r\n"",
                    VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
                    VAR_21,
                    VAR_23,
                    VAR_36
            );
            VAR_15.data = VAR_14;
            swServer_master_send(VAR_0, &VAR_15);
            goto _finish;
        }
    }

    VAR_15.length = VAR_15.info.len = sw_snprintf(VAR_14, sizeof(VAR_14),
            ""HTTP/1.1 200 OK\r\n""
            ""%s""
            ""Content-Length: %ld\r\n""
            ""Content-Type: %s\r\n""
            ""Date: %s\r\n""
            ""Last-Modified: %s\r\n""
            ""Server: %s\r\n\r\n"",
            VAR_1->keep_alive ? ""Connection: keep-alive\r\n"" : """",
            (long) VAR_11.st_size,
            swoole_get_mime_type(VAR_6.filename),
            VAR_21,
            VAR_23,
            VAR_36);

    VAR_15.data = VAR_14;

#ifdef VAR_37
    if (VAR_2->tcp_nopush == 0)
    {
        if (swSocket_tcp_nopush(VAR_2->fd, 1) == -1)
        {
            swWarn(""swSocket_tcp_nopush() failed. Error: %s[%d]"", strerror(VAR_38), VAR_38);
        }
        VAR_2->tcp_nopush = 1;
    }
#endif
    swServer_master_send(VAR_0, &VAR_15);

    VAR_6.offset = 0;
    VAR_6.length = VAR_11.st_size;

    VAR_15.info.type = VAR_39;
    VAR_15.length = VAR_15.info.len = sizeof(VAR_40) + VAR_6.length + 1;
    VAR_15.data = (void*) &VAR_6;

    swServer_master_send(VAR_0, &VAR_15);

    _finish:
    if (!VAR_1->keep_alive)
    {
        VAR_15.info.type = VAR_41;
        VAR_15.length = 0;
        VAR_15.data = NULL;
        swServer_master_send(VAR_0, &VAR_15);
    }

    return VAR_42;
}",swoole/swoole-src/a37b20878592951f4e8e7274b38bbb6e94af7e42/port.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,10 +14,16 @@
 
     memcpy(p, serv->document_root, serv->document_root_len);
     p += serv->document_root_len;
-    uint32_t n = params ? params - url : request->url_length;
+    size_t n = params ? params - url : request->url_length;
+
+    if (serv->document_root_len + n >= PATH_MAX)
+    {
+        return SW_FALSE;
+    }
+
     memcpy(p, url, n);
     p += n;
-    *p = 0;
+    *p = '\0';
 
     char real_path[PATH_MAX];
     if (!realpath(buffer.filename, real_path))","{'deleted_lines': ['    uint32_t n = params ? params - url : request->url_length;', '    *p = 0;'], 'added_lines': ['    size_t n = params ? params - url : request->url_length;', '', '    if (serv->document_root_len + n >= PATH_MAX)', '    {', '        return SW_FALSE;', '    }', '', ""    *p = '\\0';""]}",True,Swoole before 4.2.13 allows directory traversal in swPort_http_static_handler.,5.3,MEDIUM,1,test,2019-01-16T12:15:45Z,2
CVE-2019-5815,"['CWE-843', 'CWE-787']",AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,GNOME/libxslt,"Always set context node before calling XPath iterators

The xmlXPathNext* iterators rely on the XPath context node being set to
the start node of the iteration. Some parts of the code base like the
xsl:key functions also leave the context node in an unspecified state.
Make sure that the context node is reset before invoking the XPath
iterators. Also backup and restore the context node in
xsltNumberFormatGetMultipleLevel for good measure.

This bug could also lead to type confusion and invalid reads in
connection with namespace nodes.

Fixes #13. Also see the Chromium bug report:

https://bugs.chromium.org/p/chromium/issues/detail?id=930663

Thanks to Nicolas Grgoire for the report.",08b62c25871b38d5d573515ca8a065b4b8f64f6b,https://github.com/GNOME/libxslt/commit/08b62c25871b38d5d573515ca8a065b4b8f64f6b,libxslt/numbers.c,xsltNumberFormatGetMultipleLevel,"static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
xmlNodePtr node,
xsltCompMatchPtr countPat,
xsltCompMatchPtr fromPat,
double *array,
int max)
{
int amount = 0;
int cnt;
xmlNodePtr ancestor;
xmlNodePtr preceding;
xmlXPathParserContextPtr parser;
context->xpathCtxt->node = node;
parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
if (parser) {
for (ancestor = node;
(ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
ancestor = xmlXPathNextAncestor(parser, ancestor)) {
if ((fromPat != NULL) &&
xsltTestCompMatchList(context, ancestor, fromPat))
break; 
if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
cnt = 1;
for (preceding =
xmlXPathNextPrecedingSibling(parser, ancestor);
preceding != NULL;
preceding =
xmlXPathNextPrecedingSibling(parser, preceding)) {
if (xsltTestCompMatchCount(context, preceding, countPat,
node))
cnt++;
}
array[amount++] = (double)cnt;
if (amount >= max)
break; 
}
}
xmlXPathFreeParserContext(parser);
}
return amount;
}","static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr VAR_0,
xmlNodePtr VAR_1,
xsltCompMatchPtr VAR_2,
xsltCompMatchPtr VAR_3,
double *VAR_4,
int VAR_5)
{
int VAR_6 = 0;
int VAR_7;
xmlNodePtr VAR_8;
xmlNodePtr VAR_9;
xmlXPathParserContextPtr VAR_10;
VAR_0->xpathCtxt->node = VAR_1;
VAR_10 = xmlXPathNewParserContext(NULL, VAR_0->xpathCtxt);
if (VAR_10) {
for (VAR_8 = VAR_1;
(VAR_8 != NULL) && (VAR_8->type != VAR_11);
VAR_8 = xmlXPathNextAncestor(VAR_10, VAR_8)) {
if ((VAR_3 != NULL) &&
xsltTestCompMatchList(VAR_0, VAR_8, VAR_3))
break; 
if (xsltTestCompMatchCount(VAR_0, VAR_8, VAR_2, VAR_1)) {
VAR_7 = 1;
for (VAR_9 =
xmlXPathNextPrecedingSibling(VAR_10, VAR_8);
VAR_9 != NULL;
VAR_9 =
xmlXPathNextPrecedingSibling(VAR_10, VAR_9)) {
if (xsltTestCompMatchCount(VAR_0, VAR_9, VAR_2,
VAR_1))
VAR_7++;
}
VAR_4[VAR_6++] = (double)VAR_7;
if (VAR_6 >= VAR_5)
break; 
}
}
xmlXPathFreeParserContext(VAR_10);
}
return VAR_6;
}",GNOME/libxslt/08b62c25871b38d5d573515ca8a065b4b8f64f6b/numbers.c/vul/before/0.json,"static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
				 xmlNodePtr node,
				 xsltCompMatchPtr countPat,
				 xsltCompMatchPtr fromPat,
				 double *array,
				 int max)
{
    int amount = 0;
    int cnt;
    xmlNodePtr oldCtxtNode;
    xmlNodePtr ancestor;
    xmlNodePtr preceding;
    xmlXPathParserContextPtr parser;

    oldCtxtNode = context->xpathCtxt->node;
    parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
    if (parser) {
	/* ancestor-or-self::*[count] */
	ancestor = node;
	while ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {
	    if ((fromPat != NULL) &&
		xsltTestCompMatchList(context, ancestor, fromPat))
		break; /* for */

            /*
             * The xmlXPathNext* iterators require that the context node is
             * set to the start node. Calls to xsltTestCompMatch* may also
             * leave the context node in an undefined state, so make sure
             * that the context node is reset before each iterator invocation.
             */

	    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
		/* count(preceding-sibling::*) */
		cnt = 1;
                context->xpathCtxt->node = ancestor;
                preceding = xmlXPathNextPrecedingSibling(parser, ancestor);
                while (preceding != NULL) {
	            if (xsltTestCompMatchCount(context, preceding, countPat,
                                               node))
			cnt++;
                    context->xpathCtxt->node = ancestor;
                    preceding =
                        xmlXPathNextPrecedingSibling(parser, preceding);
		}
		array[amount++] = (double)cnt;
		if (amount >= max)
		    break; /* for */
	    }
            context->xpathCtxt->node = node;
            ancestor = xmlXPathNextAncestor(parser, ancestor);
	}
	xmlXPathFreeParserContext(parser);
    }
    context->xpathCtxt->node = oldCtxtNode;
    return amount;
}","static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr VAR_0,
				 xmlNodePtr VAR_1,
				 xsltCompMatchPtr VAR_2,
				 xsltCompMatchPtr VAR_3,
				 double *VAR_4,
				 int VAR_5)
{
    int VAR_6 = 0;
    int VAR_7;
    xmlNodePtr VAR_8;
    xmlNodePtr VAR_9;
    xmlNodePtr VAR_10;
    xmlXPathParserContextPtr VAR_11;

    VAR_8 = VAR_0->xpathCtxt->node;
    VAR_11 = xmlXPathNewParserContext(NULL, VAR_0->xpathCtxt);
    if (VAR_11) {
	/* COMMENT_0 */
	VAR_9 = VAR_1;
	while ((VAR_9 != NULL) && (VAR_9->type != VAR_12)) {
	    if ((VAR_3 != NULL) &&
		xsltTestCompMatchList(VAR_0, VAR_9, VAR_3))
		break; /* COMMENT_1 */

            /* COMMENT_2 */
                                                                           
                                                                          
                                                                         
                                                                              
               

	    if (xsltTestCompMatchCount(VAR_0, VAR_9, VAR_2, VAR_1)) {
		/* COMMENT_8 */
		VAR_7 = 1;
                VAR_0->xpathCtxt->node = VAR_9;
                VAR_10 = xmlXPathNextPrecedingSibling(VAR_11, VAR_9);
                while (VAR_10 != NULL) {
	            if (xsltTestCompMatchCount(VAR_0, VAR_10, VAR_2,
                                               VAR_1))
			VAR_7++;
                    VAR_0->xpathCtxt->node = VAR_9;
                    VAR_10 =
                        xmlXPathNextPrecedingSibling(VAR_11, VAR_10);
		}
		VAR_4[VAR_6++] = (double)VAR_7;
		if (VAR_6 >= VAR_5)
		    break; /* COMMENT_1 */
	    }
            VAR_0->xpathCtxt->node = VAR_1;
            VAR_9 = xmlXPathNextAncestor(VAR_11, VAR_9);
	}
	xmlXPathFreeParserContext(VAR_11);
    }
    VAR_0->xpathCtxt->node = VAR_8;
    return VAR_6;
}",GNOME/libxslt/08b62c25871b38d5d573515ca8a065b4b8f64f6b/numbers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,41 +8,50 @@
 {
     int amount = 0;
     int cnt;
+    xmlNodePtr oldCtxtNode;
     xmlNodePtr ancestor;
     xmlNodePtr preceding;
     xmlXPathParserContextPtr parser;
 
-    context->xpathCtxt->node = node;
+    oldCtxtNode = context->xpathCtxt->node;
     parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
     if (parser) {
 	/* ancestor-or-self::*[count] */
-	for (ancestor = node;
-	     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
-	     ancestor = xmlXPathNextAncestor(parser, ancestor)) {
-
+	ancestor = node;
+	while ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {
 	    if ((fromPat != NULL) &&
 		xsltTestCompMatchList(context, ancestor, fromPat))
 		break; /* for */
 
+            /*
+             * The xmlXPathNext* iterators require that the context node is
+             * set to the start node. Calls to xsltTestCompMatch* may also
+             * leave the context node in an undefined state, so make sure
+             * that the context node is reset before each iterator invocation.
+             */
+
 	    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
 		/* count(preceding-sibling::*) */
 		cnt = 1;
-		for (preceding =
-                        xmlXPathNextPrecedingSibling(parser, ancestor);
-		     preceding != NULL;
-		     preceding =
-		        xmlXPathNextPrecedingSibling(parser, preceding)) {
-
+                context->xpathCtxt->node = ancestor;
+                preceding = xmlXPathNextPrecedingSibling(parser, ancestor);
+                while (preceding != NULL) {
 	            if (xsltTestCompMatchCount(context, preceding, countPat,
                                                node))
 			cnt++;
+                    context->xpathCtxt->node = ancestor;
+                    preceding =
+                        xmlXPathNextPrecedingSibling(parser, preceding);
 		}
 		array[amount++] = (double)cnt;
 		if (amount >= max)
 		    break; /* for */
 	    }
+            context->xpathCtxt->node = node;
+            ancestor = xmlXPathNextAncestor(parser, ancestor);
 	}
 	xmlXPathFreeParserContext(parser);
     }
+    context->xpathCtxt->node = oldCtxtNode;
     return amount;
 }","{'deleted_lines': ['    context->xpathCtxt->node = node;', '\tfor (ancestor = node;', '\t     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);', '\t     ancestor = xmlXPathNextAncestor(parser, ancestor)) {', '', '\t\tfor (preceding =', '                        xmlXPathNextPrecedingSibling(parser, ancestor);', '\t\t     preceding != NULL;', '\t\t     preceding =', '\t\t        xmlXPathNextPrecedingSibling(parser, preceding)) {', ''], 'added_lines': ['    xmlNodePtr oldCtxtNode;', '    oldCtxtNode = context->xpathCtxt->node;', '\tancestor = node;', '\twhile ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {', '            /*', '             * The xmlXPathNext* iterators require that the context node is', '             * set to the start node. Calls to xsltTestCompMatch* may also', '             * leave the context node in an undefined state, so make sure', '             * that the context node is reset before each iterator invocation.', '             */', '', '                context->xpathCtxt->node = ancestor;', '                preceding = xmlXPathNextPrecedingSibling(parser, ancestor);', '                while (preceding != NULL) {', '                    context->xpathCtxt->node = ancestor;', '                    preceding =', '                        xmlXPathNextPrecedingSibling(parser, preceding);', '            context->xpathCtxt->node = node;', '            ancestor = xmlXPathNextAncestor(parser, ancestor);', '    context->xpathCtxt->node = oldCtxtNode;']}",True,Type confusion in xsltNumberFormatGetMultipleLevel prior to libxslt 1.1.33 could allow attackers to potentially exploit heap corruption via crafted XML data.,7.5,HIGH,2,test,2019-02-20T12:24:37Z,2
CVE-2019-10895,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"netscaler: fix multiple out-of-bounds reads.

Multiple bugs have been found in the provided bug. Some of them have
been fixed in gefe920a, others here. The main problem is when malformed
files give wrong lenghts to the code, that casts and dereference it
without checking, causing oob reads. The fix introduces a check function
that prevents to go beyond the limits, early returning with a malformed
file message.

Other bugs have been fixed by forcing the string terminator that allows
the use of strlen() and MIN() that prevent wrong reads.

Conflicts:
	wiretap/netscaler.c

Bug: 15497
Change-Id: I8411208b5ea0f1a0720a17b882f704d03296d1c4
Reviewed-on: https://code.wireshark.org/review/32194
Petri-Dish: Gerald Combs <gerald@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Gerald Combs <gerald@wireshark.org>
(cherry picked from commit 07bb974bcd99467381dddae134f11a6f21cf6ca5)
Reviewed-on: https://code.wireshark.org/review/32200",38680c4c69f9f4e0f39e29b66fe2b02d88eb629d,https://github.com/wireshark/wireshark/commit/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d,wiretap/netscaler.c,nspm_signature_version,"static guint32
nspm_signature_version(wtap *wth, gchar *nstrace_buf, gint32 len)
{
gchar *dp = nstrace_buf;
int bytes_read;
bytes_read = file_read(dp, len, wth->fh);
if (bytes_read == len) {
for ( ; len > (gint32)(MIN(sizeof(NSPR_SIGSTR_V10), sizeof(NSPR_SIGSTR_V20))); dp++, len--)
{
#define sigv10p    ((nspr_signature_v10_t*)dp)
if ((pletoh16(&sigv10p->nsprRecordType) == NSPR_SIGNATURE_V10) &&
(pletoh16(&sigv10p->nsprRecordSize) <= len) &&
((gint32)sizeof(NSPR_SIGSTR_V10) <= len) &&
(!nspm_signature_isv10(sigv10p->sig_Signature)))
return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_1_0;
#undef    sigv10p
#define sigv20p    ((nspr_signature_v20_t*)dp)
if ((sigv20p->sig_RecordType == NSPR_SIGNATURE_V20) &&
(sigv20p->sig_RecordSize <= len) &&
((gint32)sizeof(NSPR_SIGSTR_V20) <= len))
{
if (!nspm_signature_isv20(sigv20p->sig_Signature)){
return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_2_0;
} else if (!nspm_signature_isv30(sigv20p->sig_Signature)){
return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0;
}else if (!nspm_signature_isv35(sigv20p->sig_Signature)){
return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_5;
}
}
#undef    sigv20p
}
}
return WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;    
}","static guint32
nspm_signature_version(wtap *VAR_0, gchar *VAR_1, gint32 VAR_2)
{
gchar *VAR_3 = VAR_1;
int VAR_4;
VAR_4 = file_read(VAR_3, VAR_2, VAR_0->fh);
if (VAR_4 == VAR_2) {
for ( ; VAR_2 > (gint32)(MIN(sizeof(VAR_5), sizeof(VAR_6))); VAR_3++, VAR_2--)
{
#define VAR_7    ((nspr_signature_v10_t*)dp)
if ((pletoh16(&VAR_7->nsprRecordType) == VAR_8) &&
(pletoh16(&VAR_7->nsprRecordSize) <= VAR_2) &&
((gint32)sizeof(VAR_5) <= VAR_2) &&
(!nspm_signature_isv10(VAR_7->sig_Signature)))
return VAR_9;
#undef    sigv10p
#define VAR_10    ((nspr_signature_v20_t*)dp)
if ((VAR_10->sig_RecordType == VAR_11) &&
(VAR_10->sig_RecordSize <= VAR_2) &&
((gint32)sizeof(VAR_6) <= VAR_2))
{
if (!nspm_signature_isv20(VAR_10->sig_Signature)){
return VAR_12;
} else if (!nspm_signature_isv30(VAR_10->sig_Signature)){
return VAR_13;
}else if (!nspm_signature_isv35(VAR_10->sig_Signature)){
return VAR_14;
}
}
#undef    sigv20p
}
}
return VAR_15;    
}",wireshark/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d/netscaler.c/vul/before/0.json,"static guint32
nspm_signature_version(wtap *wth, gchar *nstrace_buf, gint32 len)
{
    gchar *dp = nstrace_buf;
    int bytes_read;

    bytes_read = file_read(dp, len, wth->fh);
    if (bytes_read == len) {

        for ( ; len > (gint32)(MIN(sizeof(NSPR_SIGSTR_V10), sizeof(NSPR_SIGSTR_V20))); dp++, len--)
        {
#define sigv10p    ((nspr_signature_v10_t*)dp)
            if ((pletoh16(&sigv10p->nsprRecordType) == NSPR_SIGNATURE_V10) &&
                (pletoh16(&sigv10p->nsprRecordSize) <= len) &&
                (pletoh16(&sigv10p->nsprRecordSize) > 0) &&
                ((gint32)sizeof(NSPR_SIGSTR_V10) <= len) &&
                (!nspm_signature_isv10(sigv10p->sig_Signature)))
                return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_1_0;
#undef    sigv10p

#define sigv20p    ((nspr_signature_v20_t*)dp)
            if ((sigv20p->sig_RecordType == NSPR_SIGNATURE_V20) &&
                (sigv20p->sig_RecordSize <= len) &&
                ((gint32)sizeof(NSPR_SIGSTR_V20) <= len))
            {
                sigv20p->sig_Signature[sigv20p->sig_RecordSize] = '\0';
                if (!nspm_signature_isv20(sigv20p->sig_Signature)){
                    return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_2_0;
                } else if (!nspm_signature_isv30(sigv20p->sig_Signature)){
                    return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0;
                }else if (!nspm_signature_isv35(sigv20p->sig_Signature)){
                    return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_5;
                }
            }
#undef    sigv20p
        }
    }

    return WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;    /* no version found */
}","static guint32
nspm_signature_version(wtap *VAR_0, gchar *VAR_1, gint32 VAR_2)
{
    gchar *VAR_3 = VAR_1;
    int VAR_4;

    VAR_4 = file_read(VAR_3, VAR_2, VAR_0->fh);
    if (VAR_4 == VAR_2) {

        for ( ; VAR_2 > (gint32)(MIN(sizeof(VAR_5), sizeof(VAR_6))); VAR_3++, VAR_2--)
        {
#define VAR_7    ((nspr_signature_v10_t*)dp)
            if ((pletoh16(&VAR_7->nsprRecordType) == VAR_8) &&
                (pletoh16(&VAR_7->nsprRecordSize) <= VAR_2) &&
                (pletoh16(&VAR_7->nsprRecordSize) > 0) &&
                ((gint32)sizeof(VAR_5) <= VAR_2) &&
                (!nspm_signature_isv10(VAR_7->sig_Signature)))
                return VAR_9;
#undef    sigv10p

#define VAR_10    ((nspr_signature_v20_t*)dp)
            if ((VAR_10->sig_RecordType == VAR_11) &&
                (VAR_10->sig_RecordSize <= VAR_2) &&
                ((gint32)sizeof(VAR_6) <= VAR_2))
            {
                VAR_10->sig_Signature[VAR_10->sig_RecordSize] = '\0';
                if (!nspm_signature_isv20(VAR_10->sig_Signature)){
                    return VAR_12;
                } else if (!nspm_signature_isv30(VAR_10->sig_Signature)){
                    return VAR_13;
                }else if (!nspm_signature_isv35(VAR_10->sig_Signature)){
                    return VAR_14;
                }
            }
#undef    sigv20p
        }
    }

    return VAR_15;    /* COMMENT_0 */
}",wireshark/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d/netscaler.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
 #define sigv10p    ((nspr_signature_v10_t*)dp)
             if ((pletoh16(&sigv10p->nsprRecordType) == NSPR_SIGNATURE_V10) &&
                 (pletoh16(&sigv10p->nsprRecordSize) <= len) &&
+                (pletoh16(&sigv10p->nsprRecordSize) > 0) &&
                 ((gint32)sizeof(NSPR_SIGSTR_V10) <= len) &&
                 (!nspm_signature_isv10(sigv10p->sig_Signature)))
                 return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_1_0;
@@ -22,6 +23,7 @@
                 (sigv20p->sig_RecordSize <= len) &&
                 ((gint32)sizeof(NSPR_SIGSTR_V20) <= len))
             {
+                sigv20p->sig_Signature[sigv20p->sig_RecordSize] = '\0';
                 if (!nspm_signature_isv20(sigv20p->sig_Signature)){
                     return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_2_0;
                 } else if (!nspm_signature_isv30(sigv20p->sig_Signature)){","{'deleted_lines': [], 'added_lines': ['                (pletoh16(&sigv10p->nsprRecordSize) > 0) &&', ""                sigv20p->sig_Signature[sigv20p->sig_RecordSize] = '\\0';""]}",True,"In Wireshark 2.4.0 to 2.4.13, 2.6.0 to 2.6.7, and 3.0.0, the NetScaler file parser could crash. This was addressed in wiretap/netscaler.c by improving data validation.",7.5,HIGH,2,test,2019-02-26T14:33:32Z,2
CVE-2019-10895,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"netscaler: fix multiple out-of-bounds reads.

Multiple bugs have been found in the provided bug. Some of them have
been fixed in gefe920a, others here. The main problem is when malformed
files give wrong lenghts to the code, that casts and dereference it
without checking, causing oob reads. The fix introduces a check function
that prevents to go beyond the limits, early returning with a malformed
file message.

Other bugs have been fixed by forcing the string terminator that allows
the use of strlen() and MIN() that prevent wrong reads.

Conflicts:
	wiretap/netscaler.c

Bug: 15497
Change-Id: I8411208b5ea0f1a0720a17b882f704d03296d1c4
Reviewed-on: https://code.wireshark.org/review/32194
Petri-Dish: Gerald Combs <gerald@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Gerald Combs <gerald@wireshark.org>
(cherry picked from commit 07bb974bcd99467381dddae134f11a6f21cf6ca5)
Reviewed-on: https://code.wireshark.org/review/32200",38680c4c69f9f4e0f39e29b66fe2b02d88eb629d,https://github.com/wireshark/wireshark/commit/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d,wiretap/netscaler.c,nstrace_read_v30,"static gboolean nstrace_read_v30(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
{
nstrace_t *nstrace = (nstrace_t *)wth->priv;
guint64 nsg_creltime;
gchar *nstrace_buf = nstrace->pnstrace_buf;
guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;
guint32 nstrace_buflen = nstrace->nstrace_buflen;
guint8* nstrace_tmpbuff;
guint32 nstrace_tmpbuff_off=0,nst_dataSize=0,rec_size=0,nsg_nextPageOffset=0;
nspr_hd_v20_t *hdp;
int bytes_read = 0;
*err = 0;
*err_info = NULL;
if(nstrace_buflen == 0){
return FALSE; 
}
nstrace_tmpbuff = (guint8*)g_malloc(65536);
do
{
if (!nstrace_buf[nstrace_buf_offset] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE){
nstrace_buf_offset = NSPR_PAGESIZE_TRACE;
}
if (file_eof(wth->fh) && bytes_read > 0 && bytes_read < NSPR_PAGESIZE_TRACE){
memset(&nstrace_buf[bytes_read], 0, NSPR_PAGESIZE_TRACE-bytes_read);
}
while ((nstrace_buf_offset < NSPR_PAGESIZE_TRACE) &&
nstrace_buf[nstrace_buf_offset])
{
hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];
if (nspr_getv20recordsize(hdp) == 0) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""nstrace: zero size record found"");
g_free(nstrace_tmpbuff);
return FALSE;
}
switch (hdp->phd_RecordType)
{
#define GENERATE_CASE_FULL_V30(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
GENERATE_CASE_FULL_V30(&wth->phdr,30,300);
#undef GENERATE_CASE_FULL_V30
#define GENERATE_CASE_FULL_V35(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
GENERATE_CASE_FULL_V35(&wth->phdr,35,350);
#undef GENERATE_CASE_FULL_V35
case NSPR_ABSTIME_V20:
{
nstrace_buf_offset += nspr_getv20recordsize(hdp);
ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));
break;
}
case NSPR_RELTIME_V20:
{
ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));
nstrace_buf_offset += nspr_getv20recordsize(hdp);
break;
}
default:
{
nstrace_buf_offset += nspr_getv20recordsize(hdp);
break;
}
}
}
nstrace_buf_offset = 0;
nstrace->xxx_offset += nstrace_buflen;
nstrace_buflen = NSPR_PAGESIZE_TRACE;
} while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && (file_eof(wth->fh) || (guint32)bytes_read == nstrace_buflen));
if (bytes_read < 0)
*err = file_error(wth->fh, err_info);
else
*err = 0;
g_free(nstrace_tmpbuff);
return FALSE;
}","static gboolean nstrace_read_v30(wtap *VAR_0, int *VAR_1, gchar **VAR_2, gint64 *VAR_3)
{
nstrace_t *VAR_4 = (nstrace_t *)VAR_0->priv;
guint64 VAR_5;
gchar *VAR_6 = VAR_4->pnstrace_buf;
guint32 VAR_7 = VAR_4->nstrace_buf_offset;
guint32 VAR_8 = VAR_4->nstrace_buflen;
guint8* VAR_9;
guint32 VAR_10=0,VAR_11=0,VAR_12=0,VAR_13=0;
nspr_hd_v20_t *VAR_14;
int VAR_15 = 0;
*VAR_1 = 0;
*VAR_2 = NULL;
if(VAR_8 == 0){
return FALSE; 
}
VAR_9 = (guint8*)g_malloc(65536);
do
{
if (!VAR_6[VAR_7] && VAR_7 <= VAR_16){
VAR_7 = VAR_16;
}
if (file_eof(VAR_0->fh) && VAR_15 > 0 && VAR_15 < VAR_16){
memset(&VAR_6[VAR_15], 0, VAR_16-VAR_15);
}
while ((VAR_7 < VAR_16) &&
VAR_6[VAR_7])
{
VAR_14 = (nspr_hd_v20_t *) &VAR_6[VAR_7];
if (nspr_getv20recordsize(VAR_14) == 0) {
*VAR_1 = VAR_17;
*VAR_2 = g_strdup(""nstrace: zero size record found"");
g_free(VAR_9);
return FALSE;
}
switch (VAR_14->phd_RecordType)
{
#define GENERATE_CASE_FULL_V30(VAR_18,VAR_19,VAR_20) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
GENERATE_CASE_FULL_V30(&VAR_0->phdr,30,300);
#undef GENERATE_CASE_FULL_V30
#define GENERATE_CASE_FULL_V35(VAR_18,VAR_19,VAR_20) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
GENERATE_CASE_FULL_V35(&VAR_0->phdr,35,350);
#undef GENERATE_CASE_FULL_V35
case VAR_21:
{
VAR_7 += nspr_getv20recordsize(VAR_14);
ns_setabstime(VAR_4, pletoh32(&((nspr_abstime_v20_t *) &VAR_6[VAR_7])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &VAR_6[VAR_7])->abs_RelTime));
break;
}
case VAR_22:
{
ns_setrelativetime(VAR_4, pletoh16(&((nspr_abstime_v20_t *) &VAR_6[VAR_7])->abs_RelTime));
VAR_7 += nspr_getv20recordsize(VAR_14);
break;
}
default:
{
VAR_7 += nspr_getv20recordsize(VAR_14);
break;
}
}
}
VAR_7 = 0;
VAR_4->xxx_offset += VAR_8;
VAR_8 = VAR_16;
} while((VAR_8 > 0) && (VAR_15 = file_read(VAR_6, VAR_8, VAR_0->fh)) > 0 && (file_eof(VAR_0->fh) || (guint32)VAR_15 == VAR_8));
if (VAR_15 < 0)
*VAR_1 = file_error(VAR_0->fh, VAR_2);
else
*VAR_1 = 0;
g_free(VAR_9);
return FALSE;
}",wireshark/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d/netscaler.c/vul/before/1.json,"static gboolean nstrace_read_v30(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
{
    nstrace_t *nstrace = (nstrace_t *)wth->priv;
    guint64 nsg_creltime;
    gchar *nstrace_buf = nstrace->pnstrace_buf;
    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;
    guint32 nstrace_buflen = nstrace->nstrace_buflen;
    guint8* nstrace_tmpbuff;
    guint32 nstrace_tmpbuff_off=0,nst_dataSize=0,rec_size=0,nsg_nextPageOffset=0;
    nspr_hd_v20_t *hdp;
    int bytes_read = 0;
    *err = 0;
    *err_info = NULL;
    if(nstrace_buflen == 0){
      return FALSE; /* Reached End Of File */
    }

    nstrace_tmpbuff = (guint8*)g_malloc(65536);

    do
    {

        if (nstrace_buf_offset >= nstrace_buflen) {
            *err = WTAP_ERR_BAD_FILE;
            *err_info = g_strdup(""nstrace: malformed file"");
            g_free(nstrace_tmpbuff);
            return FALSE;
        }

        if (!nstrace_buf[nstrace_buf_offset] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE){
            nstrace_buf_offset = NSPR_PAGESIZE_TRACE;
        }
        if (file_eof(wth->fh) && bytes_read > 0 && bytes_read < NSPR_PAGESIZE_TRACE){
            memset(&nstrace_buf[bytes_read], 0, NSPR_PAGESIZE_TRACE-bytes_read);
        }
        while ((nstrace_buf_offset < NSPR_PAGESIZE_TRACE) &&
            nstrace_buf[nstrace_buf_offset])
        {
            if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info)) {
                g_free(nstrace_tmpbuff);
                return FALSE;
            }

            hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];
            if (nspr_getv20recordsize(hdp) == 0) {
                *err = WTAP_ERR_BAD_FILE;
                *err_info = g_strdup(""nstrace: zero size record found"");
                g_free(nstrace_tmpbuff);
                return FALSE;
            }
            switch (hdp->phd_RecordType)
            {

#define GENERATE_CASE_FULL_V30(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

                GENERATE_CASE_FULL_V30(&wth->phdr,30,300);

#undef GENERATE_CASE_FULL_V30

#define GENERATE_CASE_FULL_V35(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
                GENERATE_CASE_FULL_V35(&wth->phdr,35,350);

#undef GENERATE_CASE_FULL_V35

                case NSPR_ABSTIME_V20:
                {
                    nstrace_buf_offset += nspr_getv20recordsize(hdp);
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info)) {
                        g_free(nstrace_tmpbuff);
                        return FALSE;
                    }
                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));
                    break;
                }

                case NSPR_RELTIME_V20:
                {
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info)) {
                        g_free(nstrace_tmpbuff);
                        return FALSE;
                    }
                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));
                    nstrace_buf_offset += nspr_getv20recordsize(hdp);
                    break;
                }

                default:
                {
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info)) {
                        g_free(nstrace_tmpbuff);
                        return FALSE;
                    }
                    nstrace_buf_offset += nspr_getv20recordsize(hdp);
                    break;
                }
            }
        }
        nstrace_buf_offset = 0;
        nstrace->xxx_offset += nstrace_buflen;
        nstrace_buflen = NSPR_PAGESIZE_TRACE;
    } while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && (file_eof(wth->fh) || (guint32)bytes_read == nstrace_buflen));

    if (bytes_read < 0)
        *err = file_error(wth->fh, err_info);
    else
        *err = 0;
    g_free(nstrace_tmpbuff);
    return FALSE;
}","static gboolean nstrace_read_v30(wtap *VAR_0, int *VAR_1, gchar **VAR_2, gint64 *VAR_3)
{
    nstrace_t *VAR_4 = (nstrace_t *)VAR_0->priv;
    guint64 VAR_5;
    gchar *VAR_6 = VAR_4->pnstrace_buf;
    guint32 VAR_7 = VAR_4->nstrace_buf_offset;
    guint32 VAR_8 = VAR_4->nstrace_buflen;
    guint8* VAR_9;
    guint32 VAR_10=0,VAR_11=0,VAR_12=0,VAR_13=0;
    nspr_hd_v20_t *VAR_14;
    int VAR_15 = 0;
    *VAR_1 = 0;
    *VAR_2 = NULL;
    if(VAR_8 == 0){
      return FALSE; /* COMMENT_0 */
    }

    VAR_9 = (guint8*)g_malloc(65536);

    do
    {

        if (VAR_7 >= VAR_8) {
            *VAR_1 = VAR_16;
            *VAR_2 = g_strdup(""nstrace: malformed file"");
            g_free(VAR_9);
            return FALSE;
        }

        if (!VAR_6[VAR_7] && VAR_7 <= VAR_17){
            VAR_7 = VAR_17;
        }
        if (file_eof(VAR_0->fh) && VAR_15 > 0 && VAR_15 < VAR_17){
            memset(&VAR_6[VAR_15], 0, VAR_17-VAR_15);
        }
        while ((VAR_7 < VAR_17) &&
            VAR_6[VAR_7])
        {
            if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_hd_v20_t), VAR_1, VAR_2)) {
                g_free(VAR_9);
                return FALSE;
            }

            VAR_14 = (nspr_hd_v20_t *) &VAR_6[VAR_7];
            if (nspr_getv20recordsize(VAR_14) == 0) {
                *VAR_1 = VAR_16;
                *VAR_2 = g_strdup(""nstrace: zero size record found"");
                g_free(VAR_9);
                return FALSE;
            }
            switch (VAR_14->phd_RecordType)
            {

#define GENERATE_CASE_FULL_V30(VAR_18,VAR_19,VAR_20) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

                GENERATE_CASE_FULL_V30(&VAR_0->phdr,30,300);

#undef GENERATE_CASE_FULL_V30

#define GENERATE_CASE_FULL_V35(VAR_18,VAR_19,VAR_20) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
                GENERATE_CASE_FULL_V35(&VAR_0->phdr,35,350);

#undef GENERATE_CASE_FULL_V35

                case VAR_21:
                {
                    VAR_7 += nspr_getv20recordsize(VAR_14);
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(VAR_22), VAR_1, VAR_2)) {
                        g_free(VAR_9);
                        return FALSE;
                    }
                    ns_setabstime(VAR_4, pletoh32(&((nspr_abstime_v20_t *) &VAR_6[VAR_7])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &VAR_6[VAR_7])->abs_RelTime));
                    break;
                }

                case VAR_23:
                {
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_abstime_v20_t), VAR_1, VAR_2)) {
                        g_free(VAR_9);
                        return FALSE;
                    }
                    ns_setrelativetime(VAR_4, pletoh16(&((nspr_abstime_v20_t *) &VAR_6[VAR_7])->abs_RelTime));
                    VAR_7 += nspr_getv20recordsize(VAR_14);
                    break;
                }

                default:
                {
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_hd_v20_t), VAR_1, VAR_2)) {
                        g_free(VAR_9);
                        return FALSE;
                    }
                    VAR_7 += nspr_getv20recordsize(VAR_14);
                    break;
                }
            }
        }
        VAR_7 = 0;
        VAR_4->xxx_offset += VAR_8;
        VAR_8 = VAR_17;
    } while((VAR_8 > 0) && (VAR_15 = file_read(VAR_6, VAR_8, VAR_0->fh)) > 0 && (file_eof(VAR_0->fh) || (guint32)VAR_15 == VAR_8));

    if (VAR_15 < 0)
        *VAR_1 = file_error(VAR_0->fh, VAR_2);
    else
        *VAR_1 = 0;
    g_free(VAR_9);
    return FALSE;
}",wireshark/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d/netscaler.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -19,6 +19,14 @@
 
     do
     {
+
+        if (nstrace_buf_offset >= nstrace_buflen) {
+            *err = WTAP_ERR_BAD_FILE;
+            *err_info = g_strdup(""nstrace: malformed file"");
+            g_free(nstrace_tmpbuff);
+            return FALSE;
+        }
+
         if (!nstrace_buf[nstrace_buf_offset] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE){
             nstrace_buf_offset = NSPR_PAGESIZE_TRACE;
         }
@@ -28,6 +36,11 @@
         while ((nstrace_buf_offset < NSPR_PAGESIZE_TRACE) &&
             nstrace_buf[nstrace_buf_offset])
         {
+            if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info)) {
+                g_free(nstrace_tmpbuff);
+                return FALSE;
+            }
+
             hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];
             if (nspr_getv20recordsize(hdp) == 0) {
                 *err = WTAP_ERR_BAD_FILE;
@@ -62,12 +75,20 @@
                 case NSPR_ABSTIME_V20:
                 {
                     nstrace_buf_offset += nspr_getv20recordsize(hdp);
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info)) {
+                        g_free(nstrace_tmpbuff);
+                        return FALSE;
+                    }
                     ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));
                     break;
                 }
 
                 case NSPR_RELTIME_V20:
                 {
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info)) {
+                        g_free(nstrace_tmpbuff);
+                        return FALSE;
+                    }
                     ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));
                     nstrace_buf_offset += nspr_getv20recordsize(hdp);
                     break;
@@ -75,6 +96,10 @@
 
                 default:
                 {
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info)) {
+                        g_free(nstrace_tmpbuff);
+                        return FALSE;
+                    }
                     nstrace_buf_offset += nspr_getv20recordsize(hdp);
                     break;
                 }","{'deleted_lines': [], 'added_lines': ['', '        if (nstrace_buf_offset >= nstrace_buflen) {', '            *err = WTAP_ERR_BAD_FILE;', '            *err_info = g_strdup(""nstrace: malformed file"");', '            g_free(nstrace_tmpbuff);', '            return FALSE;', '        }', '', '            if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info)) {', '                g_free(nstrace_tmpbuff);', '                return FALSE;', '            }', '', '                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info)) {', '                        g_free(nstrace_tmpbuff);', '                        return FALSE;', '                    }', '                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info)) {', '                        g_free(nstrace_tmpbuff);', '                        return FALSE;', '                    }', '                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info)) {', '                        g_free(nstrace_tmpbuff);', '                        return FALSE;', '                    }']}",True,"In Wireshark 2.4.0 to 2.4.13, 2.6.0 to 2.6.7, and 3.0.0, the NetScaler file parser could crash. This was addressed in wiretap/netscaler.c by improving data validation.",7.5,HIGH,2,test,2019-02-26T14:33:32Z,2
CVE-2019-10895,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"netscaler: fix multiple out-of-bounds reads.

Multiple bugs have been found in the provided bug. Some of them have
been fixed in gefe920a, others here. The main problem is when malformed
files give wrong lenghts to the code, that casts and dereference it
without checking, causing oob reads. The fix introduces a check function
that prevents to go beyond the limits, early returning with a malformed
file message.

Other bugs have been fixed by forcing the string terminator that allows
the use of strlen() and MIN() that prevent wrong reads.

Conflicts:
	wiretap/netscaler.c

Bug: 15497
Change-Id: I8411208b5ea0f1a0720a17b882f704d03296d1c4
Reviewed-on: https://code.wireshark.org/review/32194
Petri-Dish: Gerald Combs <gerald@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Gerald Combs <gerald@wireshark.org>
(cherry picked from commit 07bb974bcd99467381dddae134f11a6f21cf6ca5)
Reviewed-on: https://code.wireshark.org/review/32200",38680c4c69f9f4e0f39e29b66fe2b02d88eb629d,https://github.com/wireshark/wireshark/commit/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d,wiretap/netscaler.c,nstrace_read_v20,"static gboolean nstrace_read_v20(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
{
nstrace_t *nstrace = (nstrace_t *)wth->priv;
guint64 nsg_creltime = nstrace->nsg_creltime;
gchar *nstrace_buf = nstrace->pnstrace_buf;
guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;
guint32 nstrace_buflen = nstrace->nstrace_buflen;
*err = 0;
*err_info = NULL;
do
{
while ((nstrace_buf_offset < nstrace_buflen) &&
((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType))))
{
switch ((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType)
{
#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_FULL_V25(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
#define GENERATE_CASE_PART_V25(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
GENERATE_CASE_FULL(&wth->phdr,20,200);
GENERATE_CASE_PART(&wth->phdr,20,200);
GENERATE_CASE_FULL(&wth->phdr,21,201);
GENERATE_CASE_PART(&wth->phdr,21,201);
GENERATE_CASE_FULL(&wth->phdr,22,202);
GENERATE_CASE_PART(&wth->phdr,22,202);
GENERATE_CASE_FULL(&wth->phdr,23,203);
GENERATE_CASE_PART(&wth->phdr,23,203);
GENERATE_CASE_FULL_V25(&wth->phdr,24,204);
GENERATE_CASE_PART_V25(&wth->phdr,24,204);
GENERATE_CASE_FULL_V25(&wth->phdr,25,205);
GENERATE_CASE_PART_V25(&wth->phdr,25,205);
GENERATE_CASE_FULL_V25(&wth->phdr,26,206);
GENERATE_CASE_PART_V25(&wth->phdr,26,206);
#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25
case NSPR_ABSTIME_V20:
{
nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
break;
}
case NSPR_RELTIME_V20:
{
nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
break;
}
case NSPR_UNUSEDSPACE_V20:
{
if (nstrace_buf_offset >= NSPR_PAGESIZE/2)
nstrace_buf_offset = nstrace_buflen;
else
nstrace_buf_offset = NSPR_PAGESIZE/2;
break;
}
default:
{
nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
break;
}
}
}
nstrace_buf_offset = 0;
nstrace->xxx_offset += nstrace_buflen;
nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));
}while((nstrace_buflen > 0) && (nstrace_read_buf(wth->fh, nstrace_buf, nstrace_buflen, err, err_info)));
return FALSE;
}","static gboolean nstrace_read_v20(wtap *VAR_0, int *VAR_1, gchar **VAR_2, gint64 *VAR_3)
{
nstrace_t *VAR_4 = (nstrace_t *)VAR_0->priv;
guint64 VAR_5 = VAR_4->nsg_creltime;
gchar *VAR_6 = VAR_4->pnstrace_buf;
guint32 VAR_7 = VAR_4->nstrace_buf_offset;
guint32 VAR_8 = VAR_4->nstrace_buflen;
*VAR_1 = 0;
*VAR_2 = NULL;
do
{
while ((VAR_7 < VAR_8) &&
((VAR_8 - VAR_7) >= ((gint32)sizeof((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType))))
{
switch ((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType)
{
#define GENERATE_CASE_FULL(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_FULL_V25(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_PART(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
#define GENERATE_CASE_PART_V25(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
GENERATE_CASE_FULL(&VAR_0->phdr,20,200);
GENERATE_CASE_PART(&VAR_0->phdr,20,200);
GENERATE_CASE_FULL(&VAR_0->phdr,21,201);
GENERATE_CASE_PART(&VAR_0->phdr,21,201);
GENERATE_CASE_FULL(&VAR_0->phdr,22,202);
GENERATE_CASE_PART(&VAR_0->phdr,22,202);
GENERATE_CASE_FULL(&VAR_0->phdr,23,203);
GENERATE_CASE_PART(&VAR_0->phdr,23,203);
GENERATE_CASE_FULL_V25(&VAR_0->phdr,24,204);
GENERATE_CASE_PART_V25(&VAR_0->phdr,24,204);
GENERATE_CASE_FULL_V25(&VAR_0->phdr,25,205);
GENERATE_CASE_PART_V25(&VAR_0->phdr,25,205);
GENERATE_CASE_FULL_V25(&VAR_0->phdr,26,206);
GENERATE_CASE_PART_V25(&VAR_0->phdr,26,206);
#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25
case VAR_12:
{
nspr_pktracefull_v20_t *VAR_13 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_13) == 0) {
*VAR_1 = VAR_14;
*VAR_2 = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_13);
ns_setabstime(VAR_4, pletoh32(&((nspr_abstime_v20_t *) VAR_13)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) VAR_13)->abs_RelTime));
break;
}
case VAR_15:
{
nspr_pktracefull_v20_t *VAR_13 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_13) == 0) {
*VAR_1 = VAR_14;
*VAR_2 = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
ns_setrelativetime(VAR_4, pletoh16(&((nspr_abstime_v20_t *) VAR_13)->abs_RelTime));
VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_13);
break;
}
case VAR_16:
{
if (VAR_7 >= VAR_17/2)
VAR_7 = VAR_8;
else
VAR_7 = VAR_17/2;
break;
}
default:
{
nspr_pktracefull_v20_t *VAR_13 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_13) == 0) {
*VAR_1 = VAR_14;
*VAR_2 = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_13);
break;
}
}
}
VAR_7 = 0;
VAR_4->xxx_offset += VAR_8;
VAR_8 = GET_READ_PAGE_SIZE((VAR_4->file_size - VAR_4->xxx_offset));
}while((VAR_8 > 0) && (nstrace_read_buf(VAR_0->fh, VAR_6, VAR_8, VAR_1, VAR_2)));
return FALSE;
}",wireshark/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d/netscaler.c/vul/before/2.json,"static gboolean nstrace_read_v20(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
{
    nstrace_t *nstrace = (nstrace_t *)wth->priv;
    guint64 nsg_creltime = nstrace->nsg_creltime;
    gchar *nstrace_buf = nstrace->pnstrace_buf;
    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;
    guint32 nstrace_buflen = nstrace->nstrace_buflen;

    *err = 0;
    *err_info = NULL;
    do
    {
        while ((nstrace_buf_offset < nstrace_buflen) &&
            ((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType))))
        {
            switch ((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType)
            {

#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_FULL_V25(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

#define GENERATE_CASE_PART_V25(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
        case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

                GENERATE_CASE_FULL(&wth->phdr,20,200);
                GENERATE_CASE_PART(&wth->phdr,20,200);
                GENERATE_CASE_FULL(&wth->phdr,21,201);
                GENERATE_CASE_PART(&wth->phdr,21,201);
                GENERATE_CASE_FULL(&wth->phdr,22,202);
                GENERATE_CASE_PART(&wth->phdr,22,202);
                GENERATE_CASE_FULL(&wth->phdr,23,203);
                GENERATE_CASE_PART(&wth->phdr,23,203);
                GENERATE_CASE_FULL_V25(&wth->phdr,24,204);
                GENERATE_CASE_PART_V25(&wth->phdr,24,204);
                GENERATE_CASE_FULL_V25(&wth->phdr,25,205);
                GENERATE_CASE_PART_V25(&wth->phdr,25,205);
                GENERATE_CASE_FULL_V25(&wth->phdr,26,206);
                GENERATE_CASE_PART_V25(&wth->phdr,26,206);

#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25

                case NSPR_ABSTIME_V20:
                {
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
                        return FALSE;
                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                        *err = WTAP_ERR_BAD_FILE;
                        *err_info = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))
                        return FALSE;
                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
                        return FALSE;
                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
                    break;
                }

                case NSPR_RELTIME_V20:
                {
                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                        *err = WTAP_ERR_BAD_FILE;
                        *err_info = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
                        return FALSE;
                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
                    break;
                  }

                case NSPR_UNUSEDSPACE_V20:
                {
                    if (nstrace_buf_offset >= NSPR_PAGESIZE/2)
                        nstrace_buf_offset = nstrace_buflen;
                    else
                        nstrace_buf_offset = NSPR_PAGESIZE/2;
                    break;
                  }

                default:
                {
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
                        return FALSE;
                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                        *err = WTAP_ERR_BAD_FILE;
                        *err_info = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
                    break;
                }
            }
        }

        nstrace_buf_offset = 0;
        nstrace->xxx_offset += nstrace_buflen;
        nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));
    }while((nstrace_buflen > 0) && (nstrace_read_buf(wth->fh, nstrace_buf, nstrace_buflen, err, err_info)));

    return FALSE;
}","static gboolean nstrace_read_v20(wtap *VAR_0, int *VAR_1, gchar **VAR_2, gint64 *VAR_3)
{
    nstrace_t *VAR_4 = (nstrace_t *)VAR_0->priv;
    guint64 VAR_5 = VAR_4->nsg_creltime;
    gchar *VAR_6 = VAR_4->pnstrace_buf;
    guint32 VAR_7 = VAR_4->nstrace_buf_offset;
    guint32 VAR_8 = VAR_4->nstrace_buflen;

    *VAR_1 = 0;
    *VAR_2 = NULL;
    do
    {
        while ((VAR_7 < VAR_8) &&
            ((VAR_8 - VAR_7) >= ((gint32)sizeof((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType))))
        {
            switch ((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType)
            {

#define GENERATE_CASE_FULL(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_FULL_V25(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_PART(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

#define GENERATE_CASE_PART_V25(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
        case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

                GENERATE_CASE_FULL(&VAR_0->phdr,20,200);
                GENERATE_CASE_PART(&VAR_0->phdr,20,200);
                GENERATE_CASE_FULL(&VAR_0->phdr,21,201);
                GENERATE_CASE_PART(&VAR_0->phdr,21,201);
                GENERATE_CASE_FULL(&VAR_0->phdr,22,202);
                GENERATE_CASE_PART(&VAR_0->phdr,22,202);
                GENERATE_CASE_FULL(&VAR_0->phdr,23,203);
                GENERATE_CASE_PART(&VAR_0->phdr,23,203);
                GENERATE_CASE_FULL_V25(&VAR_0->phdr,24,204);
                GENERATE_CASE_PART_V25(&VAR_0->phdr,24,204);
                GENERATE_CASE_FULL_V25(&VAR_0->phdr,25,205);
                GENERATE_CASE_PART_V25(&VAR_0->phdr,25,205);
                GENERATE_CASE_FULL_V25(&VAR_0->phdr,26,206);
                GENERATE_CASE_PART_V25(&VAR_0->phdr,26,206);

#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25

                case VAR_12:
                {
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(VAR_13), VAR_1, VAR_2))
                        return FALSE;
                    nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
                        *VAR_1 = VAR_15;
                        *VAR_2 = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_hd_v20_t), VAR_1, VAR_2))
                        return FALSE;
                    VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(VAR_16), VAR_1, VAR_2))
                        return FALSE;
                    ns_setabstime(VAR_4, pletoh32(&((nspr_abstime_v20_t *) VAR_14)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) VAR_14)->abs_RelTime));
                    break;
                }

                case VAR_17:
                {
                    nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
                        *VAR_1 = VAR_15;
                        *VAR_2 = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_abstime_v20_t), VAR_1, VAR_2))
                        return FALSE;
                    ns_setrelativetime(VAR_4, pletoh16(&((nspr_abstime_v20_t *) VAR_14)->abs_RelTime));
                    VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
                    break;
                  }

                case VAR_18:
                {
                    if (VAR_7 >= VAR_19/2)
                        VAR_7 = VAR_8;
                    else
                        VAR_7 = VAR_19/2;
                    break;
                  }

                default:
                {
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_pktracefull_v20_t), VAR_1, VAR_2))
                        return FALSE;
                    nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
                        *VAR_1 = VAR_15;
                        *VAR_2 = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
                    break;
                }
            }
        }

        VAR_7 = 0;
        VAR_4->xxx_offset += VAR_8;
        VAR_8 = GET_READ_PAGE_SIZE((VAR_4->file_size - VAR_4->xxx_offset));
    }while((VAR_8 > 0) && (nstrace_read_buf(VAR_0->fh, VAR_6, VAR_8, VAR_1, VAR_2)));

    return FALSE;
}",wireshark/38680c4c69f9f4e0f39e29b66fe2b02d88eb629d/netscaler.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -64,13 +64,19 @@
 
                 case NSPR_ABSTIME_V20:
                 {
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
+                        return FALSE;
                     nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                     if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                         *err = WTAP_ERR_BAD_FILE;
                         *err_info = g_strdup(""nstrace: zero size record found"");
                         return FALSE;
                     }
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))
+                        return FALSE;
                     nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
+                        return FALSE;
                     ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
                     break;
                 }
@@ -83,6 +89,8 @@
                         *err_info = g_strdup(""nstrace: zero size record found"");
                         return FALSE;
                     }
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
+                        return FALSE;
                     ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
                     nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
                     break;
@@ -99,6 +107,8 @@
 
                 default:
                 {
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
+                        return FALSE;
                     nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                     if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                         *err = WTAP_ERR_BAD_FILE;","{'deleted_lines': [], 'added_lines': ['                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))', '                        return FALSE;', '                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))', '                        return FALSE;', '                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))', '                        return FALSE;', '                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))', '                        return FALSE;', '                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))', '                        return FALSE;']}",True,"In Wireshark 2.4.0 to 2.4.13, 2.6.0 to 2.6.7, and 3.0.0, the NetScaler file parser could crash. This was addressed in wiretap/netscaler.c by improving data validation.",7.5,HIGH,2,test,2019-02-26T14:33:32Z,2
CVE-2019-10899,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"srvloc: check buffer index to prevent heap overflow.

Bug: 15546
Change-Id: I35eee1f6e1127db74339ec7218d7681bd93de59c
Reviewed-on: https://code.wireshark.org/review/32285
Petri-Dish: Alexis La Goutte <alexis.lagoutte@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 8f15ebed65ceea5c856fce055b5d83fb0c4b597b)
Reviewed-on: https://code.wireshark.org/review/32340
Petri-Dish: Dario Lombardo <lomato@gmail.com>
Reviewed-by: Dario Lombardo <lomato@gmail.com>
(cherry picked from commit f43ac1291b80bbccdd1ef3e6118f72e08dc8beac)
Reviewed-on: https://code.wireshark.org/review/32722
Reviewed-by: Gerald Combs <gerald@wireshark.org>",b16fea2f175a3297edac118c8844c7987d31c1cb,https://github.com/wireshark/wireshark/commit/b16fea2f175a3297edac118c8844c7987d31c1cb,epan/dissectors/packet-srvloc.c,unicode_to_bytes,"static const guint8*
unicode_to_bytes(tvbuff_t *tvb, int offset, int length, gboolean endianness)
{
const guint8 *ascii_text = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_ASCII);
int           i, j       = 0;
guint8        c_char, c_char1;
guint8       *byte_array;
if (length < 1)
return """";
if (endianness) {
byte_array = (guint8 *)wmem_alloc(wmem_packet_scope(), length*2 + 1);
for (i = length; i > 0; i--) {
c_char = ascii_text[i];
if (c_char != 0) {
i--;
c_char1 = ascii_text[i];
if (c_char1 == 0) {
i--;
c_char1 = ascii_text[i];
}
byte_array[j] = c_char1;
j++;
byte_array[j] = c_char;
j++;
}
}
}
else
{
byte_array = (guint8 *)wmem_alloc(wmem_packet_scope(), length + 1);
for (i = 0; i < length; i++) {
c_char = ascii_text[i];
if (c_char != 0) {
byte_array[j] = c_char;
j++;
}
}
}
byte_array[j]=0;
return byte_array;
}","static const guint8*
unicode_to_bytes(tvbuff_t *VAR_0, int VAR_1, int VAR_2, gboolean VAR_3)
{
const guint8 *VAR_4 = tvb_get_string_enc(wmem_packet_scope(), VAR_0, VAR_1, VAR_2, VAR_5);
int           VAR_6, VAR_7       = 0;
guint8        VAR_8, VAR_9;
guint8       *VAR_10;
if (VAR_2 < 1)
return """";
if (VAR_3) {
VAR_10 = (guint8 *)wmem_alloc(wmem_packet_scope(), VAR_2*2 + 1);
for (VAR_6 = VAR_2; VAR_6 > 0; VAR_6--) {
VAR_8 = VAR_4[VAR_6];
if (VAR_8 != 0) {
VAR_6--;
VAR_9 = VAR_4[VAR_6];
if (VAR_9 == 0) {
VAR_6--;
VAR_9 = VAR_4[VAR_6];
}
VAR_10[VAR_7] = VAR_9;
VAR_7++;
VAR_10[VAR_7] = VAR_8;
VAR_7++;
}
}
}
else
{
VAR_10 = (guint8 *)wmem_alloc(wmem_packet_scope(), VAR_2 + 1);
for (VAR_6 = 0; VAR_6 < VAR_2; VAR_6++) {
VAR_8 = VAR_4[VAR_6];
if (VAR_8 != 0) {
VAR_10[VAR_7] = VAR_8;
VAR_7++;
}
}
}
VAR_10[VAR_7]=0;
return VAR_10;
}",wireshark/b16fea2f175a3297edac118c8844c7987d31c1cb/packet-srvloc.c/vul/before/0.json,"static const guint8*
unicode_to_bytes(tvbuff_t *tvb, int offset, int length, gboolean endianness)
{
    const guint8 *ascii_text = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_ASCII);
    int           i, j       = 0;
    guint8        c_char, c_char1;
    guint8       *byte_array;

    /* XXX - Is this the correct behavior? */
    if (length < 1)
        return """";

    if (endianness) {
        byte_array = (guint8 *)wmem_alloc(wmem_packet_scope(), length*2 + 1);
        for (i = length; i > 0; i--) {
            c_char = ascii_text[i];
            if (c_char != 0) {
                if (i == 0)
                    break;
                i--;
                c_char1 = ascii_text[i];
                if (c_char1 == 0) {
                    if (i == 0)
                        break;
                    i--;
                    c_char1 = ascii_text[i];
                }
                byte_array[j] = c_char1;
                j++;
                byte_array[j] = c_char;
                j++;
            }
        }
    }
    else
    {
        byte_array = (guint8 *)wmem_alloc(wmem_packet_scope(), length + 1);
        for (i = 0; i < length; i++) {
            c_char = ascii_text[i];
            if (c_char != 0) {
                byte_array[j] = c_char;
                j++;
            }
        }
    }

    byte_array[j]=0;
    return byte_array;
}","static const guint8*
unicode_to_bytes(tvbuff_t *VAR_0, int VAR_1, int VAR_2, gboolean VAR_3)
{
    const guint8 *VAR_4 = tvb_get_string_enc(wmem_packet_scope(), VAR_0, VAR_1, VAR_2, VAR_5);
    int           VAR_6, VAR_7       = 0;
    guint8        VAR_8, VAR_9;
    guint8       *VAR_10;

    /* COMMENT_0 */
    if (VAR_2 < 1)
        return """";

    if (VAR_3) {
        VAR_10 = (guint8 *)wmem_alloc(wmem_packet_scope(), VAR_2*2 + 1);
        for (VAR_6 = VAR_2; VAR_6 > 0; VAR_6--) {
            VAR_8 = VAR_4[VAR_6];
            if (VAR_8 != 0) {
                if (VAR_6 == 0)
                    break;
                VAR_6--;
                VAR_9 = VAR_4[VAR_6];
                if (VAR_9 == 0) {
                    if (VAR_6 == 0)
                        break;
                    VAR_6--;
                    VAR_9 = VAR_4[VAR_6];
                }
                VAR_10[VAR_7] = VAR_9;
                VAR_7++;
                VAR_10[VAR_7] = VAR_8;
                VAR_7++;
            }
        }
    }
    else
    {
        VAR_10 = (guint8 *)wmem_alloc(wmem_packet_scope(), VAR_2 + 1);
        for (VAR_6 = 0; VAR_6 < VAR_2; VAR_6++) {
            VAR_8 = VAR_4[VAR_6];
            if (VAR_8 != 0) {
                VAR_10[VAR_7] = VAR_8;
                VAR_7++;
            }
        }
    }

    VAR_10[VAR_7]=0;
    return VAR_10;
}",wireshark/b16fea2f175a3297edac118c8844c7987d31c1cb/packet-srvloc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,9 +15,13 @@
         for (i = length; i > 0; i--) {
             c_char = ascii_text[i];
             if (c_char != 0) {
+                if (i == 0)
+                    break;
                 i--;
                 c_char1 = ascii_text[i];
                 if (c_char1 == 0) {
+                    if (i == 0)
+                        break;
                     i--;
                     c_char1 = ascii_text[i];
                 }","{'deleted_lines': [], 'added_lines': ['                if (i == 0)', '                    break;', '                    if (i == 0)', '                        break;']}",True,"In Wireshark 2.4.0 to 2.4.13, 2.6.0 to 2.6.7, and 3.0.0, the SRVLOC dissector could crash. This was addressed in epan/dissectors/packet-srvloc.c by preventing a heap-based buffer under-read.",7.5,HIGH,2,test,2019-03-01T10:18:53Z,2
CVE-2019-9640,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,php/php-src,Fix bug #77540 - Invalid Read on exif_process_SOFn,30d2b94a2e88021b77b07149e1f4438662ca8e5e,https://github.com/php/php-src/commit/30d2b94a2e88021b77b07149e1f4438662ca8e5e,ext/exif/exif.c,exif_scan_thumbnail,"static int exif_scan_thumbnail(image_info_type *ImageInfo)
{
uchar           c, *data = (uchar*)ImageInfo->Thumbnail.data;
int             n, marker;
size_t          length=2, pos=0;
jpeg_sof_info   sof_info;
if (!data) {
return FALSE; 
}
if (memcmp(data, ""\xFF\xD8\xFF"", 3)) {
if (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Thumbnail is not a JPEG image"");
}
return FALSE;
}
for (;;) {
pos += length;
if (pos>=ImageInfo->Thumbnail.size)
return FALSE;
c = data[pos++];
if (pos>=ImageInfo->Thumbnail.size)
return FALSE;
if (c != 0xFF) {
return FALSE;
}
n = 8;
while ((c = data[pos++]) == 0xFF && n--) {
if (pos+3>=ImageInfo->Thumbnail.size)
return FALSE;
}
if (c == 0xFF)
return FALSE;
marker = c;
length = php_jpg_get16(data+pos);
if (pos+length>=ImageInfo->Thumbnail.size) {
return FALSE;
}
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Thumbnail: process section(x%02X=%s) @ x%04X + x%04X"", marker, exif_get_markername(marker), pos, length);
#endif
switch (marker) {
case M_SOF0:
case M_SOF1:
case M_SOF2:
case M_SOF3:
case M_SOF5:
case M_SOF6:
case M_SOF7:
case M_SOF9:
case M_SOF10:
case M_SOF11:
case M_SOF13:
case M_SOF14:
case M_SOF15:
exif_process_SOFn(data+pos, marker, &sof_info);
ImageInfo->Thumbnail.height   = sof_info.height;
ImageInfo->Thumbnail.width    = sof_info.width;
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Thumbnail: size: %d * %d"", sof_info.width, sof_info.height);
#endif
return TRUE;
case M_SOS:
case M_EOI:
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Could not compute size of thumbnail"");
return FALSE;
break;
default:
break;
}
}
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Could not compute size of thumbnail"");
return FALSE;
}","static int exif_scan_thumbnail(image_info_type *VAR_0)
{
uchar           VAR_1, *VAR_2 = (uchar*)VAR_0->Thumbnail.data;
int             VAR_3, VAR_4;
size_t          VAR_5=2, VAR_6=0;
jpeg_sof_info   VAR_7;
if (!VAR_2) {
return FALSE; 
}
if (memcmp(VAR_2, ""\xFF\xD8\xFF"", 3)) {
if (!VAR_0->Thumbnail.width && !VAR_0->Thumbnail.height) {
VAR_8(NULL VAR_9, VAR_0, VAR_10, ""Thumbnail is not a JPEG image"");
}
return FALSE;
}
for (;;) {
VAR_6 += VAR_5;
if (VAR_6>=VAR_0->Thumbnail.size)
return FALSE;
VAR_1 = VAR_2[VAR_6++];
if (VAR_6>=VAR_0->Thumbnail.size)
return FALSE;
if (VAR_1 != 0xFF) {
return FALSE;
}
VAR_3 = 8;
while ((VAR_1 = VAR_2[VAR_6++]) == 0xFF && VAR_3--) {
if (VAR_6+3>=VAR_0->Thumbnail.size)
return FALSE;
}
if (VAR_1 == 0xFF)
return FALSE;
VAR_4 = VAR_1;
VAR_5 = php_jpg_get16(VAR_2+VAR_6);
if (VAR_6+VAR_5>=VAR_0->Thumbnail.size) {
return FALSE;
}
#ifdef VAR_11
VAR_8(NULL VAR_9, VAR_0, VAR_12, ""Thumbnail: process section(x%02X=%s) @ x%04X + x%04X"", VAR_4, exif_get_markername(VAR_4), VAR_6, VAR_5);
#endif
switch (VAR_4) {
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
exif_process_SOFn(VAR_2+VAR_6, VAR_4, &VAR_7);
VAR_0->Thumbnail.height   = VAR_7.height;
VAR_0->Thumbnail.width    = VAR_7.width;
#ifdef VAR_11
VAR_8(NULL VAR_9, VAR_0, VAR_12, ""Thumbnail: size: %d * %d"", VAR_7.width, VAR_7.height);
#endif
return TRUE;
case VAR_26:
case VAR_27:
VAR_8(NULL VAR_9, VAR_0, VAR_10, ""Could not compute size of thumbnail"");
return FALSE;
break;
default:
break;
}
}
VAR_8(NULL VAR_9, VAR_0, VAR_10, ""Could not compute size of thumbnail"");
return FALSE;
}",php/php-src/30d2b94a2e88021b77b07149e1f4438662ca8e5e/exif.c/vul/before/0.json,"static int exif_scan_thumbnail(image_info_type *ImageInfo)
{
	uchar           c, *data = (uchar*)ImageInfo->Thumbnail.data;
	int             n, marker;
	size_t          length=2, pos=0;
	jpeg_sof_info   sof_info;

	if (!data) {
		return FALSE; /* nothing to do here */
	}
	if (memcmp(data, ""\xFF\xD8\xFF"", 3)) {
		if (!ImageInfo->Thumbnail.width && !ImageInfo->Thumbnail.height) {
			exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Thumbnail is not a JPEG image"");
		}
		return FALSE;
	}
	for (;;) {
		pos += length;
		if (pos>=ImageInfo->Thumbnail.size)
			return FALSE;
		c = data[pos++];
		if (pos>=ImageInfo->Thumbnail.size)
			return FALSE;
		if (c != 0xFF) {
			return FALSE;
		}
		n = 8;
		while ((c = data[pos++]) == 0xFF && n--) {
			if (pos+3>=ImageInfo->Thumbnail.size)
				return FALSE;
			/* +3 = pos++ of next check when reaching marker + 2 bytes for length */
		}
		if (c == 0xFF)
			return FALSE;
		marker = c;
		length = php_jpg_get16(data+pos);
		if (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {
			return FALSE;
		}
#ifdef EXIF_DEBUG
		exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Thumbnail: process section(x%02X=%s) @ x%04X + x%04X"", marker, exif_get_markername(marker), pos, length);
#endif
		switch (marker) {
			case M_SOF0:
			case M_SOF1:
			case M_SOF2:
			case M_SOF3:
			case M_SOF5:
			case M_SOF6:
			case M_SOF7:
			case M_SOF9:
			case M_SOF10:
			case M_SOF11:
			case M_SOF13:
			case M_SOF14:
			case M_SOF15:
				/* handle SOFn block */
				if (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {
					/* exif_process_SOFn needs 8 bytes */
					return FALSE;
				}
				exif_process_SOFn(data+pos, marker, &sof_info);
				ImageInfo->Thumbnail.height   = sof_info.height;
				ImageInfo->Thumbnail.width    = sof_info.width;
#ifdef EXIF_DEBUG
				exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Thumbnail: size: %d * %d"", sof_info.width, sof_info.height);
#endif
				return TRUE;

			case M_SOS:
			case M_EOI:
				exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Could not compute size of thumbnail"");
				return FALSE;
				break;

			default:
				/* just skip */
				break;
		}
	}

	exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Could not compute size of thumbnail"");
	return FALSE;
}","static int exif_scan_thumbnail(image_info_type *VAR_0)
{
	uchar           VAR_1, *VAR_2 = (uchar*)VAR_0->Thumbnail.data;
	int             VAR_3, VAR_4;
	size_t          VAR_5=2, VAR_6=0;
	jpeg_sof_info   VAR_7;

	if (!VAR_2) {
		return FALSE; /* COMMENT_0 */
	}
	if (memcmp(VAR_2, ""\xFF\xD8\xFF"", 3)) {
		if (!VAR_0->Thumbnail.width && !VAR_0->Thumbnail.height) {
			VAR_8(NULL VAR_9, VAR_0, VAR_10, ""Thumbnail is not a JPEG image"");
		}
		return FALSE;
	}
	for (;;) {
		VAR_6 += VAR_5;
		if (VAR_6>=VAR_0->Thumbnail.size)
			return FALSE;
		VAR_1 = VAR_2[VAR_6++];
		if (VAR_6>=VAR_0->Thumbnail.size)
			return FALSE;
		if (VAR_1 != 0xFF) {
			return FALSE;
		}
		VAR_3 = 8;
		while ((VAR_1 = VAR_2[VAR_6++]) == 0xFF && VAR_3--) {
			if (VAR_6+3>=VAR_0->Thumbnail.size)
				return FALSE;
			/* COMMENT_1 */
		}
		if (VAR_1 == 0xFF)
			return FALSE;
		VAR_4 = VAR_1;
		VAR_5 = php_jpg_get16(VAR_2+VAR_6);
		if (VAR_5 > VAR_0->Thumbnail.size || VAR_6 >= VAR_0->Thumbnail.size - VAR_5) {
			return FALSE;
		}
#ifdef VAR_11
		VAR_8(NULL VAR_9, VAR_0, VAR_12, ""Thumbnail: process section(x%02X=%s) @ x%04X + x%04X"", VAR_4, exif_get_markername(VAR_4), VAR_6, VAR_5);
#endif
		switch (VAR_4) {
			case VAR_13:
			case VAR_14:
			case VAR_15:
			case VAR_16:
			case VAR_17:
			case VAR_18:
			case VAR_19:
			case VAR_20:
			case VAR_21:
			case VAR_22:
			case VAR_23:
			case VAR_24:
			case VAR_25:
				/* COMMENT_2 */
				if (VAR_5 < 8 || VAR_0->Thumbnail.size - 8 < VAR_6) {
					/* COMMENT_3 */
					return FALSE;
				}
				exif_process_SOFn(VAR_2+VAR_6, VAR_4, &VAR_7);
				VAR_0->Thumbnail.height   = VAR_7.height;
				VAR_0->Thumbnail.width    = VAR_7.width;
#ifdef VAR_11
				VAR_8(NULL VAR_9, VAR_0, VAR_12, ""Thumbnail: size: %d * %d"", VAR_7.width, VAR_7.height);
#endif
				return TRUE;

			case VAR_26:
			case VAR_27:
				VAR_8(NULL VAR_9, VAR_0, VAR_10, ""Could not compute size of thumbnail"");
				return FALSE;
				break;

			default:
				/* COMMENT_4 */
				break;
		}
	}

	VAR_8(NULL VAR_9, VAR_0, VAR_10, ""Could not compute size of thumbnail"");
	return FALSE;
}",php/php-src/30d2b94a2e88021b77b07149e1f4438662ca8e5e/exif.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,7 +34,7 @@
 			return FALSE;
 		marker = c;
 		length = php_jpg_get16(data+pos);
-		if (pos+length>=ImageInfo->Thumbnail.size) {
+		if (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {
 			return FALSE;
 		}
 #ifdef EXIF_DEBUG
@@ -55,6 +55,10 @@
 			case M_SOF14:
 			case M_SOF15:
 				/* handle SOFn block */
+				if (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {
+					/* exif_process_SOFn needs 8 bytes */
+					return FALSE;
+				}
 				exif_process_SOFn(data+pos, marker, &sof_info);
 				ImageInfo->Thumbnail.height   = sof_info.height;
 				ImageInfo->Thumbnail.width    = sof_info.width;","{'deleted_lines': ['\t\tif (pos+length>=ImageInfo->Thumbnail.size) {'], 'added_lines': ['\t\tif (length > ImageInfo->Thumbnail.size || pos >= ImageInfo->Thumbnail.size - length) {', '\t\t\t\tif (length < 8 || ImageInfo->Thumbnail.size - 8 < pos) {', '\t\t\t\t\t/* exif_process_SOFn needs 8 bytes */', '\t\t\t\t\treturn FALSE;', '\t\t\t\t}']}",True,"An issue was discovered in the EXIF component in PHP before 7.1.27, 7.2.x before 7.2.16, and 7.3.x before 7.3.3. There is an Invalid Read in exif_process_SOFn.",7.5,HIGH,2,test,2019-03-02T21:38:00Z,2
CVE-2019-9675,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,php/php-src,Fix bug #77586 - phar_tar_writeheaders_int() buffer overflow,e0f5d62bd6690169998474b62f92a8c5ddf0e699,https://github.com/php/php-src/commit/e0f5d62bd6690169998474b62f92a8c5ddf0e699,ext/phar/tar.c,phar_tar_writeheaders_int,"static int phar_tar_writeheaders_int(phar_entry_info *entry, void *argument) 
{
tar_header header;
size_t pos;
struct _phar_pass_tar_info *fp = (struct _phar_pass_tar_info *)argument;
char padding[512];
if (entry->is_mounted) {
return ZEND_HASH_APPLY_KEEP;
}
if (entry->is_deleted) {
if (entry->fp_refcount <= 0) {
return ZEND_HASH_APPLY_REMOVE;
} else {
return ZEND_HASH_APPLY_KEEP;
}
}
phar_add_virtual_dirs(entry->phar, entry->filename, entry->filename_len);
memset((char *) &header, 0, sizeof(header));
if (entry->filename_len > 100) {
char *boundary;
if (entry->filename_len > 256) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
boundary = entry->filename + entry->filename_len - 101;
while (*boundary && *boundary != '/') {
++boundary;
}
if (!*boundary || ((boundary - entry->filename) > 155)) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
memcpy(header.prefix, entry->filename, boundary - entry->filename);
memcpy(header.name, boundary + 1, entry->filename_len - (boundary + 1 - entry->filename));
} else {
memcpy(header.name, entry->filename, entry->filename_len);
}
phar_tar_octal(header.mode, entry->flags & PHAR_ENT_PERM_MASK, sizeof(header.mode)-1);
if (FAILURE == phar_tar_octal(header.size, entry->uncompressed_filesize, sizeof(header.size)-1)) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too large for tar file format"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
if (FAILURE == phar_tar_octal(header.mtime, entry->timestamp, sizeof(header.mtime)-1)) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, file modification time of file \""%s\"" is too large for tar file format"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
header.typeflag = entry->tar_type;
if (entry->link) {
strncpy(header.linkname, entry->link, strlen(entry->link));
}
strncpy(header.magic, ""ustar"", sizeof(""ustar"")-1);
strncpy(header.version, ""00"", sizeof(""00"")-1);
strncpy(header.checksum, ""        "", sizeof(""        "")-1);
entry->crc32 = phar_tar_checksum((char *)&header, sizeof(header));
if (FAILURE == phar_tar_octal(header.checksum, entry->crc32, sizeof(header.checksum)-1)) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, checksum of file \""%s\"" is too large for tar file format"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
entry->header_offset = php_stream_tell(fp->new);
if (sizeof(header) != php_stream_write(fp->new, (char *) &header, sizeof(header))) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, header for  file \""%s\"" could not be written"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
pos = php_stream_tell(fp->new); 
if (entry->uncompressed_filesize) {
if (FAILURE == phar_open_entry_fp(entry, fp->error, 0)) {
return ZEND_HASH_APPLY_STOP;
}
if (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0)) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written, seek failed"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
if (SUCCESS != php_stream_copy_to_stream_ex(phar_get_efp(entry, 0), fp->new, entry->uncompressed_filesize, NULL)) {
if (fp->error) {
spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written"", entry->phar->fname, entry->filename);
}
return ZEND_HASH_APPLY_STOP;
}
memset(padding, 0, 512);
php_stream_write(fp->new, padding, ((entry->uncompressed_filesize +511)&~511) - entry->uncompressed_filesize);
}
if (!entry->is_modified && entry->fp_refcount) {
switch (entry->fp_type) {
case PHAR_FP:
fp->free_fp = 0;
break;
case PHAR_UFP:
fp->free_ufp = 0;
default:
break;
}
}
entry->is_modified = 0;
if (entry->fp_type == PHAR_MOD && entry->fp != entry->phar->fp && entry->fp != entry->phar->ufp) {
if (!entry->fp_refcount) {
php_stream_close(entry->fp);
}
entry->fp = NULL;
}
entry->fp_type = PHAR_FP;
entry->offset = entry->offset_abs = pos;
return ZEND_HASH_APPLY_KEEP;
}","static int phar_tar_writeheaders_int(phar_entry_info *VAR_0, void *VAR_1) 
{
tar_header VAR_2;
size_t VAR_3;
struct _phar_pass_tar_info *VAR_4 = (struct _phar_pass_tar_info *)VAR_1;
char VAR_5[512];
if (VAR_0->is_mounted) {
return VAR_6;
}
if (VAR_0->is_deleted) {
if (VAR_0->fp_refcount <= 0) {
return VAR_7;
} else {
return VAR_6;
}
}
phar_add_virtual_dirs(VAR_0->phar, VAR_0->filename, VAR_0->filename_len);
memset((char *) &VAR_2, 0, sizeof(VAR_2));
if (VAR_0->filename_len > 100) {
char *VAR_8;
if (VAR_0->filename_len > 256) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
VAR_8 = VAR_0->filename + VAR_0->filename_len - 101;
while (*VAR_8 && *VAR_8 != '/') {
++VAR_8;
}
if (!*VAR_8 || ((VAR_8 - VAR_0->filename) > 155)) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
memcpy(VAR_2.prefix, VAR_0->filename, VAR_8 - VAR_0->filename);
memcpy(VAR_2.name, VAR_8 + 1, VAR_0->filename_len - (VAR_8 + 1 - VAR_0->filename));
} else {
memcpy(VAR_2.name, VAR_0->filename, VAR_0->filename_len);
}
phar_tar_octal(VAR_2.mode, VAR_0->flags & VAR_10, sizeof(VAR_2.mode)-1);
if (VAR_11 == phar_tar_octal(VAR_2.size, VAR_0->uncompressed_filesize, sizeof(VAR_2.size)-1)) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too large for tar file format"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
if (VAR_11 == phar_tar_octal(VAR_2.mtime, VAR_0->timestamp, sizeof(VAR_2.mtime)-1)) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, file modification time of file \""%s\"" is too large for tar file format"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
VAR_2.typeflag = VAR_0->tar_type;
if (VAR_0->link) {
strncpy(VAR_2.linkname, VAR_0->link, strlen(VAR_0->link));
}
strncpy(VAR_2.magic, ""ustar"", sizeof(""ustar"")-1);
strncpy(VAR_2.version, ""00"", sizeof(""00"")-1);
strncpy(VAR_2.checksum, ""        "", sizeof(""        "")-1);
VAR_0->crc32 = phar_tar_checksum((char *)&VAR_2, sizeof(VAR_2));
if (VAR_11 == phar_tar_octal(VAR_2.checksum, VAR_0->crc32, sizeof(VAR_2.checksum)-1)) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, checksum of file \""%s\"" is too large for tar file format"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
VAR_0->header_offset = php_stream_tell(VAR_4->new);
if (sizeof(VAR_2) != php_stream_write(VAR_4->new, (char *) &VAR_2, sizeof(VAR_2))) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, header for  file \""%s\"" could not be written"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
VAR_3 = php_stream_tell(VAR_4->new); 
if (VAR_0->uncompressed_filesize) {
if (VAR_11 == phar_open_entry_fp(VAR_0, VAR_4->error, 0)) {
return VAR_9;
}
if (-1 == phar_seek_efp(VAR_0, 0, VAR_12, 0, 0)) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written, seek failed"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
if (VAR_13 != php_stream_copy_to_stream_ex(phar_get_efp(VAR_0, 0), VAR_4->new, VAR_0->uncompressed_filesize, NULL)) {
if (VAR_4->error) {
spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written"", VAR_0->phar->fname, VAR_0->filename);
}
return VAR_9;
}
memset(VAR_5, 0, 512);
php_stream_write(VAR_4->new, VAR_5, ((VAR_0->uncompressed_filesize +511)&~511) - VAR_0->uncompressed_filesize);
}
if (!VAR_0->is_modified && VAR_0->fp_refcount) {
switch (VAR_0->fp_type) {
case VAR_14:
VAR_4->free_fp = 0;
break;
case VAR_15:
VAR_4->free_ufp = 0;
default:
break;
}
}
VAR_0->is_modified = 0;
if (VAR_0->fp_type == VAR_16 && VAR_0->fp != VAR_0->phar->fp && VAR_0->fp != VAR_0->phar->ufp) {
if (!VAR_0->fp_refcount) {
php_stream_close(VAR_0->fp);
}
VAR_0->fp = NULL;
}
VAR_0->fp_type = VAR_14;
VAR_0->offset = VAR_0->offset_abs = VAR_3;
return VAR_6;
}",php/php-src/e0f5d62bd6690169998474b62f92a8c5ddf0e699/tar.c/vul/before/0.json,"static int phar_tar_writeheaders_int(phar_entry_info *entry, void *argument) /* {{{ */
{
	tar_header header;
	size_t pos;
	struct _phar_pass_tar_info *fp = (struct _phar_pass_tar_info *)argument;
	char padding[512];

	if (entry->is_mounted) {
		return ZEND_HASH_APPLY_KEEP;
	}

	if (entry->is_deleted) {
		if (entry->fp_refcount <= 0) {
			return ZEND_HASH_APPLY_REMOVE;
		} else {
			/* we can't delete this in-memory until it is closed */
			return ZEND_HASH_APPLY_KEEP;
		}
	}

	phar_add_virtual_dirs(entry->phar, entry->filename, entry->filename_len);
	memset((char *) &header, 0, sizeof(header));

	if (entry->filename_len > 100) {
		char *boundary;
		if (entry->filename_len > 256) {
			if (fp->error) {
				spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", entry->phar->fname, entry->filename);
			}
			return ZEND_HASH_APPLY_STOP;
		}
		boundary = entry->filename + entry->filename_len - 101;
		while (*boundary && *boundary != '/') {
			++boundary;
		}
		if (!*boundary || ((boundary - entry->filename) > 155)) {
			if (fp->error) {
				spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", entry->phar->fname, entry->filename);
			}
			return ZEND_HASH_APPLY_STOP;
		}
		memcpy(header.prefix, entry->filename, boundary - entry->filename);
		memcpy(header.name, boundary + 1, entry->filename_len - (boundary + 1 - entry->filename));
	} else {
		memcpy(header.name, entry->filename, entry->filename_len);
	}

	phar_tar_octal(header.mode, entry->flags & PHAR_ENT_PERM_MASK, sizeof(header.mode)-1);

	if (FAILURE == phar_tar_octal(header.size, entry->uncompressed_filesize, sizeof(header.size)-1)) {
		if (fp->error) {
			spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too large for tar file format"", entry->phar->fname, entry->filename);
		}
		return ZEND_HASH_APPLY_STOP;
	}

	if (FAILURE == phar_tar_octal(header.mtime, entry->timestamp, sizeof(header.mtime)-1)) {
		if (fp->error) {
			spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, file modification time of file \""%s\"" is too large for tar file format"", entry->phar->fname, entry->filename);
		}
		return ZEND_HASH_APPLY_STOP;
	}

	/* calc checksum */
	header.typeflag = entry->tar_type;

	if (entry->link) {
		if (strlcpy(header.linkname, entry->link, sizeof(header.linkname)) >= sizeof(header.linkname)) {
			if (fp->error) {
				spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, link \""%s\"" is too long for format"", entry->phar->fname, entry->link);
			}
			return ZEND_HASH_APPLY_STOP;
		}
	}

	strncpy(header.magic, ""ustar"", sizeof(""ustar"")-1);
	strncpy(header.version, ""00"", sizeof(""00"")-1);
	strncpy(header.checksum, ""        "", sizeof(""        "")-1);
	entry->crc32 = phar_tar_checksum((char *)&header, sizeof(header));

	if (FAILURE == phar_tar_octal(header.checksum, entry->crc32, sizeof(header.checksum)-1)) {
		if (fp->error) {
			spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, checksum of file \""%s\"" is too large for tar file format"", entry->phar->fname, entry->filename);
		}
		return ZEND_HASH_APPLY_STOP;
	}

	/* write header */
	entry->header_offset = php_stream_tell(fp->new);

	if (sizeof(header) != php_stream_write(fp->new, (char *) &header, sizeof(header))) {
		if (fp->error) {
			spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, header for  file \""%s\"" could not be written"", entry->phar->fname, entry->filename);
		}
		return ZEND_HASH_APPLY_STOP;
	}

	pos = php_stream_tell(fp->new); /* save start of file within tar */

	/* write contents */
	if (entry->uncompressed_filesize) {
		if (FAILURE == phar_open_entry_fp(entry, fp->error, 0)) {
			return ZEND_HASH_APPLY_STOP;
		}

		if (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0)) {
			if (fp->error) {
				spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written, seek failed"", entry->phar->fname, entry->filename);
			}
			return ZEND_HASH_APPLY_STOP;
		}

		if (SUCCESS != php_stream_copy_to_stream_ex(phar_get_efp(entry, 0), fp->new, entry->uncompressed_filesize, NULL)) {
			if (fp->error) {
				spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written"", entry->phar->fname, entry->filename);
			}
			return ZEND_HASH_APPLY_STOP;
		}

		memset(padding, 0, 512);
		php_stream_write(fp->new, padding, ((entry->uncompressed_filesize +511)&~511) - entry->uncompressed_filesize);
	}

	if (!entry->is_modified && entry->fp_refcount) {
		/* open file pointers refer to this fp, do not free the stream */
		switch (entry->fp_type) {
			case PHAR_FP:
				fp->free_fp = 0;
				break;
			case PHAR_UFP:
				fp->free_ufp = 0;
			default:
				break;
		}
	}

	entry->is_modified = 0;

	if (entry->fp_type == PHAR_MOD && entry->fp != entry->phar->fp && entry->fp != entry->phar->ufp) {
		if (!entry->fp_refcount) {
			php_stream_close(entry->fp);
		}
		entry->fp = NULL;
	}

	entry->fp_type = PHAR_FP;

	/* note new location within tar */
	entry->offset = entry->offset_abs = pos;
	return ZEND_HASH_APPLY_KEEP;
}","static int phar_tar_writeheaders_int(phar_entry_info *VAR_0, void *VAR_1) /* COMMENT_0 */
{
	tar_header VAR_2;
	size_t VAR_3;
	struct _phar_pass_tar_info *VAR_4 = (struct _phar_pass_tar_info *)VAR_1;
	char VAR_5[512];

	if (VAR_0->is_mounted) {
		return VAR_6;
	}

	if (VAR_0->is_deleted) {
		if (VAR_0->fp_refcount <= 0) {
			return VAR_7;
		} else {
			/* COMMENT_1 */
			return VAR_6;
		}
	}

	phar_add_virtual_dirs(VAR_0->phar, VAR_0->filename, VAR_0->filename_len);
	memset((char *) &VAR_2, 0, sizeof(VAR_2));

	if (VAR_0->filename_len > 100) {
		char *VAR_8;
		if (VAR_0->filename_len > 256) {
			if (VAR_4->error) {
				spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", VAR_0->phar->fname, VAR_0->filename);
			}
			return VAR_9;
		}
		VAR_8 = VAR_0->filename + VAR_0->filename_len - 101;
		while (*VAR_8 && *VAR_8 != '/') {
			++VAR_8;
		}
		if (!*VAR_8 || ((VAR_8 - VAR_0->filename) > 155)) {
			if (VAR_4->error) {
				spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too long for tar file format"", VAR_0->phar->fname, VAR_0->filename);
			}
			return VAR_9;
		}
		memcpy(VAR_2.prefix, VAR_0->filename, VAR_8 - VAR_0->filename);
		memcpy(VAR_2.name, VAR_8 + 1, VAR_0->filename_len - (VAR_8 + 1 - VAR_0->filename));
	} else {
		memcpy(VAR_2.name, VAR_0->filename, VAR_0->filename_len);
	}

	phar_tar_octal(VAR_2.mode, VAR_0->flags & VAR_10, sizeof(VAR_2.mode)-1);

	if (VAR_11 == phar_tar_octal(VAR_2.size, VAR_0->uncompressed_filesize, sizeof(VAR_2.size)-1)) {
		if (VAR_4->error) {
			spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, filename \""%s\"" is too large for tar file format"", VAR_0->phar->fname, VAR_0->filename);
		}
		return VAR_9;
	}

	if (VAR_11 == phar_tar_octal(VAR_2.mtime, VAR_0->timestamp, sizeof(VAR_2.mtime)-1)) {
		if (VAR_4->error) {
			spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, file modification time of file \""%s\"" is too large for tar file format"", VAR_0->phar->fname, VAR_0->filename);
		}
		return VAR_9;
	}

	/* COMMENT_2 */
	VAR_2.typeflag = VAR_0->tar_type;

	if (VAR_0->link) {
		if (strlcpy(VAR_2.linkname, VAR_0->link, sizeof(VAR_2.linkname)) >= sizeof(VAR_2.linkname)) {
			if (VAR_4->error) {
				spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, link \""%s\"" is too long for format"", VAR_0->phar->fname, VAR_0->link);
			}
			return VAR_9;
		}
	}

	strncpy(VAR_2.magic, ""ustar"", sizeof(""ustar"")-1);
	strncpy(VAR_2.version, ""00"", sizeof(""00"")-1);
	strncpy(VAR_2.checksum, ""        "", sizeof(""        "")-1);
	VAR_0->crc32 = phar_tar_checksum((char *)&VAR_2, sizeof(VAR_2));

	if (VAR_11 == phar_tar_octal(VAR_2.checksum, VAR_0->crc32, sizeof(VAR_2.checksum)-1)) {
		if (VAR_4->error) {
			spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, checksum of file \""%s\"" is too large for tar file format"", VAR_0->phar->fname, VAR_0->filename);
		}
		return VAR_9;
	}

	/* COMMENT_3 */
	VAR_0->header_offset = php_stream_tell(VAR_4->new);

	if (sizeof(VAR_2) != php_stream_write(VAR_4->new, (char *) &VAR_2, sizeof(VAR_2))) {
		if (VAR_4->error) {
			spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, header for  file \""%s\"" could not be written"", VAR_0->phar->fname, VAR_0->filename);
		}
		return VAR_9;
	}

	VAR_3 = php_stream_tell(VAR_4->new); /* COMMENT_4 */

	/* COMMENT_5 */
	if (VAR_0->uncompressed_filesize) {
		if (VAR_11 == phar_open_entry_fp(VAR_0, VAR_4->error, 0)) {
			return VAR_9;
		}

		if (-1 == phar_seek_efp(VAR_0, 0, VAR_12, 0, 0)) {
			if (VAR_4->error) {
				spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written, seek failed"", VAR_0->phar->fname, VAR_0->filename);
			}
			return VAR_9;
		}

		if (VAR_13 != php_stream_copy_to_stream_ex(phar_get_efp(VAR_0, 0), VAR_4->new, VAR_0->uncompressed_filesize, NULL)) {
			if (VAR_4->error) {
				spprintf(VAR_4->error, 4096, ""tar-based phar \""%s\"" cannot be created, contents of file \""%s\"" could not be written"", VAR_0->phar->fname, VAR_0->filename);
			}
			return VAR_9;
		}

		memset(VAR_5, 0, 512);
		php_stream_write(VAR_4->new, VAR_5, ((VAR_0->uncompressed_filesize +511)&~511) - VAR_0->uncompressed_filesize);
	}

	if (!VAR_0->is_modified && VAR_0->fp_refcount) {
		/* COMMENT_6 */
		switch (VAR_0->fp_type) {
			case VAR_14:
				VAR_4->free_fp = 0;
				break;
			case VAR_15:
				VAR_4->free_ufp = 0;
			default:
				break;
		}
	}

	VAR_0->is_modified = 0;

	if (VAR_0->fp_type == VAR_16 && VAR_0->fp != VAR_0->phar->fp && VAR_0->fp != VAR_0->phar->ufp) {
		if (!VAR_0->fp_refcount) {
			php_stream_close(VAR_0->fp);
		}
		VAR_0->fp = NULL;
	}

	VAR_0->fp_type = VAR_14;

	/* COMMENT_7 */
	VAR_0->offset = VAR_0->offset_abs = VAR_3;
	return VAR_6;
}",php/php-src/e0f5d62bd6690169998474b62f92a8c5ddf0e699/tar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -65,7 +65,12 @@
 	header.typeflag = entry->tar_type;
 
 	if (entry->link) {
-		strncpy(header.linkname, entry->link, strlen(entry->link));
+		if (strlcpy(header.linkname, entry->link, sizeof(header.linkname)) >= sizeof(header.linkname)) {
+			if (fp->error) {
+				spprintf(fp->error, 4096, ""tar-based phar \""%s\"" cannot be created, link \""%s\"" is too long for format"", entry->phar->fname, entry->link);
+			}
+			return ZEND_HASH_APPLY_STOP;
+		}
 	}
 
 	strncpy(header.magic, ""ustar"", sizeof(""ustar"")-1);","{'deleted_lines': ['\t\tstrncpy(header.linkname, entry->link, strlen(entry->link));'], 'added_lines': ['\t\tif (strlcpy(header.linkname, entry->link, sizeof(header.linkname)) >= sizeof(header.linkname)) {', '\t\t\tif (fp->error) {', '\t\t\t\tspprintf(fp->error, 4096, ""tar-based phar \\""%s\\"" cannot be created, link \\""%s\\"" is too long for format"", entry->phar->fname, entry->link);', '\t\t\t}', '\t\t\treturn ZEND_HASH_APPLY_STOP;', '\t\t}']}",True,"An issue was discovered in PHP 7.x before 7.1.27 and 7.3.x before 7.3.3. phar_tar_writeheaders_int in ext/phar/tar.c has a buffer overflow via a long link value. NOTE: The vendor indicates that the link value is used only when an archive contains a symlink, which currently cannot happen: ""This issue allows theoretical compromise of security, but a practical attack is usually impossible.",8.1,HIGH,2,test,2019-03-04T06:33:38Z,2
CVE-2019-10895,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"netscaler: add more sanity checks.

Fix more crashes found in the provided bug report.

Bug: 15497
Change-Id: If84498fa879ad56c8677f8c1442a8dc0e5906003
Reviewed-on: https://code.wireshark.org/review/32333
Petri-Dish: Dario Lombardo <lomato@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 134a513dd59315d67866f238459fdee6347f1055)
Reviewed-on: https://code.wireshark.org/review/32422
(cherry picked from commit fc8367a50516e832be960a9001ccdb09ced9b27f)
Reviewed-on: https://code.wireshark.org/review/32430
Reviewed-by: Guy Harris <guy@alum.mit.edu>",2fbbde780e5d5d82e31dca656217daf278cf62bb,https://github.com/wireshark/wireshark/commit/2fbbde780e5d5d82e31dca656217daf278cf62bb,wiretap/netscaler.c,nstrace_read_v20,"static gboolean nstrace_read_v20(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
{
nstrace_t *nstrace = (nstrace_t *)wth->priv;
guint64 nsg_creltime = nstrace->nsg_creltime;
gchar *nstrace_buf = nstrace->pnstrace_buf;
guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;
guint32 nstrace_buflen = nstrace->nstrace_buflen;
*err = 0;
*err_info = NULL;
do
{
while ((nstrace_buf_offset < nstrace_buflen) &&
((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType))))
{
switch ((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType)
{
#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_FULL_V25(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
#define GENERATE_CASE_PART_V25(phdr,ver,HEADERVER) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
GENERATE_CASE_FULL(&wth->phdr,20,200);
GENERATE_CASE_PART(&wth->phdr,20,200);
GENERATE_CASE_FULL(&wth->phdr,21,201);
GENERATE_CASE_PART(&wth->phdr,21,201);
GENERATE_CASE_FULL(&wth->phdr,22,202);
GENERATE_CASE_PART(&wth->phdr,22,202);
GENERATE_CASE_FULL(&wth->phdr,23,203);
GENERATE_CASE_PART(&wth->phdr,23,203);
GENERATE_CASE_FULL_V25(&wth->phdr,24,204);
GENERATE_CASE_PART_V25(&wth->phdr,24,204);
GENERATE_CASE_FULL_V25(&wth->phdr,25,205);
GENERATE_CASE_PART_V25(&wth->phdr,25,205);
GENERATE_CASE_FULL_V25(&wth->phdr,26,206);
GENERATE_CASE_PART_V25(&wth->phdr,26,206);
#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25
case NSPR_ABSTIME_V20:
{
if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
return FALSE;
nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))
return FALSE;
nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
return FALSE;
ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
break;
}
case NSPR_RELTIME_V20:
{
nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
return FALSE;
ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
break;
}
case NSPR_UNUSEDSPACE_V20:
{
if (nstrace_buf_offset >= NSPR_PAGESIZE/2)
nstrace_buf_offset = nstrace_buflen;
else
nstrace_buf_offset = NSPR_PAGESIZE/2;
break;
}
default:
{
if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
return FALSE;
nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
break;
}
}
}
nstrace_buf_offset = 0;
nstrace->xxx_offset += nstrace_buflen;
nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));
}while((nstrace_buflen > 0) && (nstrace_read_buf(wth->fh, nstrace_buf, nstrace_buflen, err, err_info)));
return FALSE;
}","static gboolean nstrace_read_v20(wtap *VAR_0, int *VAR_1, gchar **VAR_2, gint64 *VAR_3)
{
nstrace_t *VAR_4 = (nstrace_t *)VAR_0->priv;
guint64 VAR_5 = VAR_4->nsg_creltime;
gchar *VAR_6 = VAR_4->pnstrace_buf;
guint32 VAR_7 = VAR_4->nstrace_buf_offset;
guint32 VAR_8 = VAR_4->nstrace_buflen;
*VAR_1 = 0;
*VAR_2 = NULL;
do
{
while ((VAR_7 < VAR_8) &&
((VAR_8 - VAR_7) >= ((gint32)sizeof((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType))))
{
switch ((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType)
{
#define GENERATE_CASE_FULL(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_FULL_V25(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEFULLTX_V##ver:\
case NSPR_PDPKTRACEFULLTXB_V##ver:\
case NSPR_PDPKTRACEFULLRX_V##ver:\
case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);
#define GENERATE_CASE_PART(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
#define GENERATE_CASE_PART_V25(VAR_9,VAR_10,VAR_11) \
case NSPR_PDPKTRACEPARTTX_V##ver:\
case NSPR_PDPKTRACEPARTTXB_V##ver:\
case NSPR_PDPKTRACEPARTRX_V##ver:\
case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);
GENERATE_CASE_FULL(&VAR_0->phdr,20,200);
GENERATE_CASE_PART(&VAR_0->phdr,20,200);
GENERATE_CASE_FULL(&VAR_0->phdr,21,201);
GENERATE_CASE_PART(&VAR_0->phdr,21,201);
GENERATE_CASE_FULL(&VAR_0->phdr,22,202);
GENERATE_CASE_PART(&VAR_0->phdr,22,202);
GENERATE_CASE_FULL(&VAR_0->phdr,23,203);
GENERATE_CASE_PART(&VAR_0->phdr,23,203);
GENERATE_CASE_FULL_V25(&VAR_0->phdr,24,204);
GENERATE_CASE_PART_V25(&VAR_0->phdr,24,204);
GENERATE_CASE_FULL_V25(&VAR_0->phdr,25,205);
GENERATE_CASE_PART_V25(&VAR_0->phdr,25,205);
GENERATE_CASE_FULL_V25(&VAR_0->phdr,26,206);
GENERATE_CASE_PART_V25(&VAR_0->phdr,26,206);
#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25
case VAR_12:
{
if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(VAR_13), VAR_1, VAR_2))
return FALSE;
nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
*VAR_1 = VAR_15;
*VAR_2 = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_hd_v20_t), VAR_1, VAR_2))
return FALSE;
VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(VAR_16), VAR_1, VAR_2))
return FALSE;
ns_setabstime(VAR_4, pletoh32(&((nspr_abstime_v20_t *) VAR_14)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) VAR_14)->abs_RelTime));
break;
}
case VAR_17:
{
nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
*VAR_1 = VAR_15;
*VAR_2 = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_abstime_v20_t), VAR_1, VAR_2))
return FALSE;
ns_setrelativetime(VAR_4, pletoh16(&((nspr_abstime_v20_t *) VAR_14)->abs_RelTime));
VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
break;
}
case VAR_18:
{
if (VAR_7 >= VAR_19/2)
VAR_7 = VAR_8;
else
VAR_7 = VAR_19/2;
break;
}
default:
{
if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_pktracefull_v20_t), VAR_1, VAR_2))
return FALSE;
nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
*VAR_1 = VAR_15;
*VAR_2 = g_strdup(""nstrace: zero size record found"");
return FALSE;
}
VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
break;
}
}
}
VAR_7 = 0;
VAR_4->xxx_offset += VAR_8;
VAR_8 = GET_READ_PAGE_SIZE((VAR_4->file_size - VAR_4->xxx_offset));
}while((VAR_8 > 0) && (nstrace_read_buf(VAR_0->fh, VAR_6, VAR_8, VAR_1, VAR_2)));
return FALSE;
}",wireshark/2fbbde780e5d5d82e31dca656217daf278cf62bb/netscaler.c/vul/before/0.json,"static gboolean nstrace_read_v20(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
{
    nstrace_t *nstrace = (nstrace_t *)wth->priv;
    guint64 nsg_creltime = nstrace->nsg_creltime;
    gchar *nstrace_buf = nstrace->pnstrace_buf;
    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;
    guint32 nstrace_buflen = nstrace->nstrace_buflen;

    *err = 0;
    *err_info = NULL;
    do
    {
        while ((nstrace_buf_offset < nstrace_buflen) &&
            ((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType))))
        {
            switch ((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType)
            {

#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_FULL_V25(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

#define GENERATE_CASE_PART_V25(phdr,ver,HEADERVER) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
        case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

                GENERATE_CASE_FULL(&wth->phdr,20,200);
                GENERATE_CASE_PART(&wth->phdr,20,200);
                GENERATE_CASE_FULL(&wth->phdr,21,201);
                GENERATE_CASE_PART(&wth->phdr,21,201);
                GENERATE_CASE_FULL(&wth->phdr,22,202);
                GENERATE_CASE_PART(&wth->phdr,22,202);
                GENERATE_CASE_FULL(&wth->phdr,23,203);
                GENERATE_CASE_PART(&wth->phdr,23,203);
                GENERATE_CASE_FULL_V25(&wth->phdr,24,204);
                GENERATE_CASE_PART_V25(&wth->phdr,24,204);
                GENERATE_CASE_FULL_V25(&wth->phdr,25,205);
                GENERATE_CASE_PART_V25(&wth->phdr,25,205);
                GENERATE_CASE_FULL_V25(&wth->phdr,26,206);
                GENERATE_CASE_PART_V25(&wth->phdr,26,206);

#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25

                case NSPR_ABSTIME_V20:
                {
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
                        return FALSE;
                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                        *err = WTAP_ERR_BAD_FILE;
                        *err_info = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))
                        return FALSE;
                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
                        return FALSE;
                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
                    break;
                }

                case NSPR_RELTIME_V20:
                {
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))
                        return FALSE;
                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                        *err = WTAP_ERR_BAD_FILE;
                        *err_info = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v20_t), err, err_info))
                        return FALSE;
                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));
                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
                    break;
                  }

                case NSPR_UNUSEDSPACE_V20:
                {
                    if (nstrace_buf_offset >= NSPR_PAGESIZE/2)
                        nstrace_buf_offset = nstrace_buflen;
                    else
                        nstrace_buf_offset = NSPR_PAGESIZE/2;
                    break;
                  }

                default:
                {
                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_pktracefull_v20_t), err, err_info))
                        return FALSE;
                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                        *err = WTAP_ERR_BAD_FILE;
                        *err_info = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);
                    break;
                }
            }
        }

        nstrace_buf_offset = 0;
        nstrace->xxx_offset += nstrace_buflen;
        nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));
    }while((nstrace_buflen > 0) && (nstrace_read_buf(wth->fh, nstrace_buf, nstrace_buflen, err, err_info)));

    return FALSE;
}","static gboolean nstrace_read_v20(wtap *VAR_0, int *VAR_1, gchar **VAR_2, gint64 *VAR_3)
{
    nstrace_t *VAR_4 = (nstrace_t *)VAR_0->priv;
    guint64 VAR_5 = VAR_4->nsg_creltime;
    gchar *VAR_6 = VAR_4->pnstrace_buf;
    guint32 VAR_7 = VAR_4->nstrace_buf_offset;
    guint32 VAR_8 = VAR_4->nstrace_buflen;

    *VAR_1 = 0;
    *VAR_2 = NULL;
    do
    {
        while ((VAR_7 < VAR_8) &&
            ((VAR_8 - VAR_7) >= ((gint32)sizeof((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType))))
        {
            switch ((( nspr_hd_v20_t*)&VAR_6[VAR_7])->phd_RecordType)
            {

#define GENERATE_CASE_FULL(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_FULL_V25(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEFULLTX_V##ver:\
        case NSPR_PDPKTRACEFULLTXB_V##ver:\
        case NSPR_PDPKTRACEFULLRX_V##ver:\
        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);

#define GENERATE_CASE_PART(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

#define GENERATE_CASE_PART_V25(VAR_9,VAR_10,VAR_11) \
        case NSPR_PDPKTRACEPARTTX_V##ver:\
        case NSPR_PDPKTRACEPARTTXB_V##ver:\
        case NSPR_PDPKTRACEPARTRX_V##ver:\
        case NSPR_PDPKTRACEPARTNEWRX_V##ver:\
            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);

                GENERATE_CASE_FULL(&VAR_0->phdr,20,200);
                GENERATE_CASE_PART(&VAR_0->phdr,20,200);
                GENERATE_CASE_FULL(&VAR_0->phdr,21,201);
                GENERATE_CASE_PART(&VAR_0->phdr,21,201);
                GENERATE_CASE_FULL(&VAR_0->phdr,22,202);
                GENERATE_CASE_PART(&VAR_0->phdr,22,202);
                GENERATE_CASE_FULL(&VAR_0->phdr,23,203);
                GENERATE_CASE_PART(&VAR_0->phdr,23,203);
                GENERATE_CASE_FULL_V25(&VAR_0->phdr,24,204);
                GENERATE_CASE_PART_V25(&VAR_0->phdr,24,204);
                GENERATE_CASE_FULL_V25(&VAR_0->phdr,25,205);
                GENERATE_CASE_PART_V25(&VAR_0->phdr,25,205);
                GENERATE_CASE_FULL_V25(&VAR_0->phdr,26,206);
                GENERATE_CASE_PART_V25(&VAR_0->phdr,26,206);

#undef GENERATE_CASE_FULL
#undef GENERATE_CASE_FULL_V25
#undef GENERATE_CASE_PART
#undef GENERATE_CASE_PART_V25

                case VAR_12:
                {
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(VAR_13), VAR_1, VAR_2))
                        return FALSE;
                    nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
                        *VAR_1 = VAR_15;
                        *VAR_2 = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_hd_v20_t), VAR_1, VAR_2))
                        return FALSE;
                    VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(VAR_16), VAR_1, VAR_2))
                        return FALSE;
                    ns_setabstime(VAR_4, pletoh32(&((nspr_abstime_v20_t *) VAR_14)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) VAR_14)->abs_RelTime));
                    break;
                }

                case VAR_17:
                {
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_hd_v20_t), VAR_1, VAR_2))
                        return FALSE;
                    nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
                        *VAR_1 = VAR_15;
                        *VAR_2 = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_abstime_v20_t), VAR_1, VAR_2))
                        return FALSE;
                    ns_setrelativetime(VAR_4, pletoh16(&((nspr_abstime_v20_t *) VAR_14)->abs_RelTime));
                    VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
                    break;
                  }

                case VAR_18:
                {
                    if (VAR_7 >= VAR_19/2)
                        VAR_7 = VAR_8;
                    else
                        VAR_7 = VAR_19/2;
                    break;
                  }

                default:
                {
                    if (!nstrace_ensure_buflen(VAR_4, VAR_7, sizeof(nspr_pktracefull_v20_t), VAR_1, VAR_2))
                        return FALSE;
                    nspr_pktracefull_v20_t *VAR_14 = (nspr_pktracefull_v20_t *) &VAR_6[VAR_7];
                    if (nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14) == 0) {
                        *VAR_1 = VAR_15;
                        *VAR_2 = g_strdup(""nstrace: zero size record found"");
                        return FALSE;
                    }
                    VAR_7 += nspr_getv20recordsize((nspr_hd_v20_t *)VAR_14);
                    break;
                }
            }
        }

        VAR_7 = 0;
        VAR_4->xxx_offset += VAR_8;
        VAR_8 = GET_READ_PAGE_SIZE((VAR_4->file_size - VAR_4->xxx_offset));
    }while((VAR_8 > 0) && (nstrace_read_buf(VAR_0->fh, VAR_6, VAR_8, VAR_1, VAR_2)));

    return FALSE;
}",wireshark/2fbbde780e5d5d82e31dca656217daf278cf62bb/netscaler.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -83,6 +83,8 @@
 
                 case NSPR_RELTIME_V20:
                 {
+                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))
+                        return FALSE;
                     nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];
                     if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {
                         *err = WTAP_ERR_BAD_FILE;","{'deleted_lines': [], 'added_lines': ['                    if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_hd_v20_t), err, err_info))', '                        return FALSE;']}",True,"In Wireshark 2.4.0 to 2.4.13, 2.6.0 to 2.6.7, and 3.0.0, the NetScaler file parser could crash. This was addressed in wiretap/netscaler.c by improving data validation.",7.5,HIGH,2,test,2019-03-05T16:25:24Z,2
CVE-2019-8381,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,appneta/tcpreplay,Bugs #538 add check for packet length in do_checksum(),dae97cbafc5c06ebbc6b34e76ba614104f1b73e1,https://github.com/appneta/tcpreplay/commit/dae97cbafc5c06ebbc6b34e76ba614104f1b73e1,src/tcpedit/checksum.c,do_checksum,"int
do_checksum(tcpedit_t *tcpedit, uint8_t *data, int proto, int len) {
ipv4_hdr_t *ipv4;
ipv6_hdr_t *ipv6;
tcp_hdr_t *tcp;
udp_hdr_t *udp;
icmpv4_hdr_t *icmp;
icmpv6_hdr_t *icmp6;
int ip_hl;
int sum;
sum = 0;
ipv4 = NULL;
ipv6 = NULL;
assert(data);
if (!data || len <= 0 || len > 65535) {
tcpedit_setwarn(tcpedit, ""%s"", ""Unable to checksum packets with no L3+ data"");
return TCPEDIT_WARN;
}
ipv4 = (ipv4_hdr_t *)data;
if (ipv4->ip_v == 6) {
ipv6 = (ipv6_hdr_t *)data;
ipv4 = NULL;
proto = get_ipv6_l4proto(ipv6, len);
dbgx(3, ""layer4 proto is 0x%hx"", (uint16_t)proto);
ip_hl = (u_char*)get_layer4_v6(ipv6, len) - (u_char*)data;
dbgx(3, ""ip_hl proto is 0x%d"", ip_hl);
len -= (ip_hl - TCPR_IPV6_H);
} else {
ip_hl = ipv4->ip_hl << 2;
}
switch (proto) {
case IPPROTO_TCP:
tcp = (tcp_hdr_t *)(data + ip_hl);
#ifdef STUPID_SOLARIS_CHECKSUM_BUG
tcp->th_sum = tcp->th_off << 2;
return (TCPEDIT_OK);
#endif
tcp->th_sum = 0;
if (ipv6 != NULL) {
sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
} else {
sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);
}
sum += ntohs(IPPROTO_TCP + len);
sum += do_checksum_math((uint16_t *)tcp, len);
tcp->th_sum = CHECKSUM_CARRY(sum);
break;
case IPPROTO_UDP:
udp = (udp_hdr_t *)(data + ip_hl);
if (udp->uh_sum == 0) 
break; 
udp->uh_sum = 0;
if (ipv6 != NULL) {
sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
} else {
sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);
}
sum += ntohs(IPPROTO_UDP + len);
sum += do_checksum_math((uint16_t *)udp, len);
udp->uh_sum = CHECKSUM_CARRY(sum);
break;
case IPPROTO_ICMP:
icmp = (icmpv4_hdr_t *)(data + ip_hl);
icmp->icmp_sum = 0;
if (ipv6 != NULL) {
sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
icmp->icmp_sum = CHECKSUM_CARRY(sum);                
}
sum += do_checksum_math((uint16_t *)icmp, len);
icmp->icmp_sum = CHECKSUM_CARRY(sum);
break;
case IPPROTO_ICMP6:
icmp6 = (icmpv6_hdr_t *)(data + ip_hl);
icmp6->icmp_sum = 0;
if (ipv6 != NULL) {
sum = do_checksum_math((u_int16_t *)&ipv6->ip_src, 32);
}
sum += ntohs(IPPROTO_ICMP6 + len);
sum += do_checksum_math((u_int16_t *)icmp6, len);
icmp6->icmp_sum = CHECKSUM_CARRY(sum);
break;
case IPPROTO_IP:
if (ipv4) {
ipv4->ip_sum = 0;
sum = do_checksum_math((uint16_t *)data, ip_hl);
ipv4->ip_sum = CHECKSUM_CARRY(sum);
}
break;
case IPPROTO_IGMP:
case IPPROTO_GRE:
case IPPROTO_OSPF:
case IPPROTO_OSPF_LSA:
case IPPROTO_VRRP:
case TCPR_PROTO_CDP: 
case TCPR_PROTO_ISL:
default:
tcpedit_setwarn(tcpedit, ""Unsupported protocol for checksum: 0x%x"", proto);
return TCPEDIT_WARN;
}
return TCPEDIT_OK;
}","int
do_checksum(tcpedit_t *VAR_0, uint8_t *VAR_1, int VAR_2, int VAR_3) {
ipv4_hdr_t *VAR_4;
ipv6_hdr_t *VAR_5;
tcp_hdr_t *VAR_6;
udp_hdr_t *VAR_7;
icmpv4_hdr_t *VAR_8;
icmpv6_hdr_t *VAR_9;
int VAR_10;
int VAR_11;
VAR_11 = 0;
VAR_4 = NULL;
VAR_5 = NULL;
assert(VAR_1);
if (!VAR_1 || VAR_3 <= 0 || VAR_3 > 65535) {
tcpedit_setwarn(VAR_0, ""%s"", ""Unable to checksum packets with no L3+ data"");
return VAR_12;
}
VAR_4 = (ipv4_hdr_t *)VAR_1;
if (VAR_4->ip_v == 6) {
VAR_5 = (ipv6_hdr_t *)VAR_1;
VAR_4 = NULL;
VAR_2 = get_ipv6_l4proto(VAR_5, VAR_3);
dbgx(3, ""layer4 proto is 0x%hx"", (uint16_t)VAR_2);
VAR_10 = (u_char*)get_layer4_v6(VAR_5, VAR_3) - (u_char*)VAR_1;
dbgx(3, ""ip_hl proto is 0x%d"", VAR_10);
VAR_3 -= (VAR_10 - VAR_13);
} else {
VAR_10 = VAR_4->ip_hl << 2;
}
switch (VAR_2) {
case VAR_14:
VAR_6 = (tcp_hdr_t *)(VAR_1 + VAR_10);
#ifdef VAR_15
VAR_6->th_sum = VAR_6->th_off << 2;
return (VAR_16);
#endif
VAR_6->th_sum = 0;
if (VAR_5 != NULL) {
VAR_11 = do_checksum_math((uint16_t *)&VAR_5->ip_src, 32);
} else {
VAR_11 = do_checksum_math((uint16_t *)&VAR_4->ip_src, 8);
}
VAR_11 += ntohs(VAR_14 + VAR_3);
VAR_11 += do_checksum_math((uint16_t *)VAR_6, VAR_3);
VAR_6->th_sum = CHECKSUM_CARRY(VAR_11);
break;
case VAR_17:
VAR_7 = (udp_hdr_t *)(VAR_1 + VAR_10);
if (VAR_7->uh_sum == 0) 
break; 
VAR_7->uh_sum = 0;
if (VAR_5 != NULL) {
VAR_11 = do_checksum_math((uint16_t *)&VAR_5->ip_src, 32);
} else {
VAR_11 = do_checksum_math((uint16_t *)&VAR_4->ip_src, 8);
}
VAR_11 += ntohs(VAR_17 + VAR_3);
VAR_11 += do_checksum_math((uint16_t *)VAR_7, VAR_3);
VAR_7->uh_sum = CHECKSUM_CARRY(VAR_11);
break;
case VAR_18:
VAR_8 = (icmpv4_hdr_t *)(VAR_1 + VAR_10);
VAR_8->icmp_sum = 0;
if (VAR_5 != NULL) {
VAR_11 = do_checksum_math((uint16_t *)&VAR_5->ip_src, 32);
VAR_8->icmp_sum = CHECKSUM_CARRY(VAR_11);                
}
VAR_11 += do_checksum_math((uint16_t *)VAR_8, VAR_3);
VAR_8->icmp_sum = CHECKSUM_CARRY(VAR_11);
break;
case VAR_19:
VAR_9 = (icmpv6_hdr_t *)(VAR_1 + VAR_10);
VAR_9->icmp_sum = 0;
if (VAR_5 != NULL) {
VAR_11 = do_checksum_math((u_int16_t *)&VAR_5->ip_src, 32);
}
VAR_11 += ntohs(VAR_19 + VAR_3);
VAR_11 += do_checksum_math((u_int16_t *)VAR_9, VAR_3);
VAR_9->icmp_sum = CHECKSUM_CARRY(VAR_11);
break;
case VAR_20:
if (VAR_4) {
VAR_4->ip_sum = 0;
VAR_11 = do_checksum_math((uint16_t *)VAR_1, VAR_10);
VAR_4->ip_sum = CHECKSUM_CARRY(VAR_11);
}
break;
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26: 
case VAR_27:
default:
tcpedit_setwarn(VAR_0, ""Unsupported protocol for checksum: 0x%x"", VAR_2);
return VAR_12;
}
return VAR_16;
}",appneta/tcpreplay/dae97cbafc5c06ebbc6b34e76ba614104f1b73e1/checksum.c/vul/before/0.json,"int
do_checksum(tcpedit_t *tcpedit, uint8_t *data, int proto, int len) {
    ipv4_hdr_t *ipv4;
    ipv6_hdr_t *ipv6;
    tcp_hdr_t *tcp;
    udp_hdr_t *udp;
    icmpv4_hdr_t *icmp;
    icmpv6_hdr_t *icmp6;
    u_char *layer;
    int ip_hl;
    int sum;

    sum = 0;
    ipv4 = NULL;
    ipv6 = NULL;
    assert(data);

    if (!data || len <= 0 || len > 65535) {
        tcpedit_setwarn(tcpedit, ""%s"", ""Unable to checksum packets with no L3+ data"");
        return TCPEDIT_WARN;
    }

    ipv4 = (ipv4_hdr_t *)data;
    if (ipv4->ip_v == 6) {
        ipv6 = (ipv6_hdr_t *)data;
        ipv4 = NULL;

        proto = get_ipv6_l4proto(ipv6, len);
        dbgx(3, ""layer4 proto is 0x%hx"", (uint16_t)proto);

        layer = (u_char*)get_layer4_v6(ipv6, len);
        if (!layer) {
            tcpedit_setwarn(tcpedit, ""%s"", ""Packet to short for checksum"");
            return TCPEDIT_WARN;
        }

        ip_hl = layer - (u_char*)data;
        dbgx(3, ""ip_hl proto is 0x%d"", ip_hl);

        len -= (ip_hl - TCPR_IPV6_H);
    } else {
        ip_hl = ipv4->ip_hl << 2;
    }

    switch (proto) {

        case IPPROTO_TCP:
            tcp = (tcp_hdr_t *)(data + ip_hl);
#ifdef STUPID_SOLARIS_CHECKSUM_BUG
            tcp->th_sum = tcp->th_off << 2;
            return (TCPEDIT_OK);
#endif
            tcp->th_sum = 0;

            /* Note, we do both src & dst IP's at the same time, that's why the
             * length is 2x a single IP
             */
            if (ipv6 != NULL) {
                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
            } else {
                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);
            }
            sum += ntohs(IPPROTO_TCP + len);
            sum += do_checksum_math((uint16_t *)tcp, len);
            tcp->th_sum = CHECKSUM_CARRY(sum);
            break;

        case IPPROTO_UDP:
            udp = (udp_hdr_t *)(data + ip_hl);
            /* No need to recalculate UDP checksums if already 0 */
            if (udp->uh_sum == 0)
                break;
            udp->uh_sum = 0;
            if (ipv6 != NULL) {
                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
            } else {
                sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8);
            }
            sum += ntohs(IPPROTO_UDP + len);
            sum += do_checksum_math((uint16_t *)udp, len);
            udp->uh_sum = CHECKSUM_CARRY(sum);
            break;

        case IPPROTO_ICMP:
            icmp = (icmpv4_hdr_t *)(data + ip_hl);
            icmp->icmp_sum = 0;
            if (ipv6 != NULL) {
                sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
                icmp->icmp_sum = CHECKSUM_CARRY(sum);
            }
            sum += do_checksum_math((uint16_t *)icmp, len);
            icmp->icmp_sum = CHECKSUM_CARRY(sum);
            break;

        case IPPROTO_ICMP6:
            icmp6 = (icmpv6_hdr_t *)(data + ip_hl);
            icmp6->icmp_sum = 0;
            if (ipv6 != NULL) {
                sum = do_checksum_math((u_int16_t *)&ipv6->ip_src, 32);
            }
            sum += ntohs(IPPROTO_ICMP6 + len);
            sum += do_checksum_math((u_int16_t *)icmp6, len);
            icmp6->icmp_sum = CHECKSUM_CARRY(sum);
            break;


        case IPPROTO_IP:
            if (ipv4) {
                ipv4->ip_sum = 0;
                sum = do_checksum_math((uint16_t *)data, ip_hl);
                ipv4->ip_sum = CHECKSUM_CARRY(sum);
            }
            break;

        case IPPROTO_IGMP:
        case IPPROTO_GRE:
        case IPPROTO_OSPF:
        case IPPROTO_OSPF_LSA:
        case IPPROTO_VRRP:
        case TCPR_PROTO_CDP:
        case TCPR_PROTO_ISL:
        default:
            tcpedit_setwarn(tcpedit, ""Unsupported protocol for checksum: 0x%x"", proto);
            return TCPEDIT_WARN;
    }

    return TCPEDIT_OK;
}","int
do_checksum(tcpedit_t *VAR_0, uint8_t *VAR_1, int VAR_2, int VAR_3) {
    ipv4_hdr_t *VAR_4;
    ipv6_hdr_t *VAR_5;
    tcp_hdr_t *VAR_6;
    udp_hdr_t *VAR_7;
    icmpv4_hdr_t *VAR_8;
    icmpv6_hdr_t *VAR_9;
    u_char *VAR_10;
    int VAR_11;
    int VAR_12;

    VAR_12 = 0;
    VAR_4 = NULL;
    VAR_5 = NULL;
    assert(VAR_1);

    if (!VAR_1 || VAR_3 <= 0 || VAR_3 > 65535) {
        tcpedit_setwarn(VAR_0, ""%s"", ""Unable to checksum packets with no L3+ data"");
        return VAR_13;
    }

    VAR_4 = (ipv4_hdr_t *)VAR_1;
    if (VAR_4->ip_v == 6) {
        VAR_5 = (ipv6_hdr_t *)VAR_1;
        VAR_4 = NULL;

        VAR_2 = get_ipv6_l4proto(VAR_5, VAR_3);
        dbgx(3, ""layer4 proto is 0x%hx"", (uint16_t)VAR_2);

        VAR_10 = (u_char*)get_layer4_v6(VAR_5, VAR_3);
        if (!VAR_10) {
            tcpedit_setwarn(VAR_0, ""%s"", ""Packet to short for checksum"");
            return VAR_13;
        }

        VAR_11 = VAR_10 - (u_char*)VAR_1;
        dbgx(3, ""ip_hl proto is 0x%d"", VAR_11);

        VAR_3 -= (VAR_11 - VAR_14);
    } else {
        VAR_11 = VAR_4->ip_hl << 2;
    }

    switch (VAR_2) {

        case VAR_15:
            VAR_6 = (tcp_hdr_t *)(VAR_1 + VAR_11);
#ifdef VAR_16
            VAR_6->th_sum = VAR_6->th_off << 2;
            return (VAR_17);
#endif
            VAR_6->th_sum = 0;

            /* COMMENT_0 */
                                       
               
            if (VAR_5 != NULL) {
                VAR_12 = do_checksum_math((uint16_t *)&VAR_5->ip_src, 32);
            } else {
                VAR_12 = do_checksum_math((uint16_t *)&VAR_4->ip_src, 8);
            }
            VAR_12 += ntohs(VAR_15 + VAR_3);
            VAR_12 += do_checksum_math((uint16_t *)VAR_6, VAR_3);
            VAR_6->th_sum = CHECKSUM_CARRY(VAR_12);
            break;

        case VAR_18:
            VAR_7 = (udp_hdr_t *)(VAR_1 + VAR_11);
            /* COMMENT_3 */
            if (VAR_7->uh_sum == 0)
                break;
            VAR_7->uh_sum = 0;
            if (VAR_5 != NULL) {
                VAR_12 = do_checksum_math((uint16_t *)&VAR_5->ip_src, 32);
            } else {
                VAR_12 = do_checksum_math((uint16_t *)&VAR_4->ip_src, 8);
            }
            VAR_12 += ntohs(VAR_18 + VAR_3);
            VAR_12 += do_checksum_math((uint16_t *)VAR_7, VAR_3);
            VAR_7->uh_sum = CHECKSUM_CARRY(VAR_12);
            break;

        case VAR_19:
            VAR_8 = (icmpv4_hdr_t *)(VAR_1 + VAR_11);
            VAR_8->icmp_sum = 0;
            if (VAR_5 != NULL) {
                VAR_12 = do_checksum_math((uint16_t *)&VAR_5->ip_src, 32);
                VAR_8->icmp_sum = CHECKSUM_CARRY(VAR_12);
            }
            VAR_12 += do_checksum_math((uint16_t *)VAR_8, VAR_3);
            VAR_8->icmp_sum = CHECKSUM_CARRY(VAR_12);
            break;

        case VAR_20:
            VAR_9 = (icmpv6_hdr_t *)(VAR_1 + VAR_11);
            VAR_9->icmp_sum = 0;
            if (VAR_5 != NULL) {
                VAR_12 = do_checksum_math((u_int16_t *)&VAR_5->ip_src, 32);
            }
            VAR_12 += ntohs(VAR_20 + VAR_3);
            VAR_12 += do_checksum_math((u_int16_t *)VAR_9, VAR_3);
            VAR_9->icmp_sum = CHECKSUM_CARRY(VAR_12);
            break;


        case VAR_21:
            if (VAR_4) {
                VAR_4->ip_sum = 0;
                VAR_12 = do_checksum_math((uint16_t *)VAR_1, VAR_11);
                VAR_4->ip_sum = CHECKSUM_CARRY(VAR_12);
            }
            break;

        case VAR_22:
        case VAR_23:
        case VAR_24:
        case VAR_25:
        case VAR_26:
        case VAR_27:
        case VAR_28:
        default:
            tcpedit_setwarn(VAR_0, ""Unsupported protocol for checksum: 0x%x"", VAR_2);
            return VAR_13;
    }

    return VAR_17;
}",appneta/tcpreplay/dae97cbafc5c06ebbc6b34e76ba614104f1b73e1/checksum.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
     udp_hdr_t *udp;
     icmpv4_hdr_t *icmp;
     icmpv6_hdr_t *icmp6;
+    u_char *layer;
     int ip_hl;
     int sum;
 
@@ -27,7 +28,13 @@
         proto = get_ipv6_l4proto(ipv6, len);
         dbgx(3, ""layer4 proto is 0x%hx"", (uint16_t)proto);
 
-        ip_hl = (u_char*)get_layer4_v6(ipv6, len) - (u_char*)data;
+        layer = (u_char*)get_layer4_v6(ipv6, len);
+        if (!layer) {
+            tcpedit_setwarn(tcpedit, ""%s"", ""Packet to short for checksum"");
+            return TCPEDIT_WARN;
+        }
+
+        ip_hl = layer - (u_char*)data;
         dbgx(3, ""ip_hl proto is 0x%d"", ip_hl);
 
         len -= (ip_hl - TCPR_IPV6_H);
@@ -61,8 +68,8 @@
         case IPPROTO_UDP:
             udp = (udp_hdr_t *)(data + ip_hl);
             /* No need to recalculate UDP checksums if already 0 */
-            if (udp->uh_sum == 0) 
-                break; 
+            if (udp->uh_sum == 0)
+                break;
             udp->uh_sum = 0;
             if (ipv6 != NULL) {
                 sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
@@ -79,7 +86,7 @@
             icmp->icmp_sum = 0;
             if (ipv6 != NULL) {
                 sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32);
-                icmp->icmp_sum = CHECKSUM_CARRY(sum);                
+                icmp->icmp_sum = CHECKSUM_CARRY(sum);
             }
             sum += do_checksum_math((uint16_t *)icmp, len);
             icmp->icmp_sum = CHECKSUM_CARRY(sum);
@@ -110,7 +117,7 @@
         case IPPROTO_OSPF:
         case IPPROTO_OSPF_LSA:
         case IPPROTO_VRRP:
-        case TCPR_PROTO_CDP: 
+        case TCPR_PROTO_CDP:
         case TCPR_PROTO_ISL:
         default:
             tcpedit_setwarn(tcpedit, ""Unsupported protocol for checksum: 0x%x"", proto);","{'deleted_lines': ['        ip_hl = (u_char*)get_layer4_v6(ipv6, len) - (u_char*)data;', '            if (udp->uh_sum == 0) ', '                break; ', '                icmp->icmp_sum = CHECKSUM_CARRY(sum);                ', '        case TCPR_PROTO_CDP: '], 'added_lines': ['    u_char *layer;', '        layer = (u_char*)get_layer4_v6(ipv6, len);', '        if (!layer) {', '            tcpedit_setwarn(tcpedit, ""%s"", ""Packet to short for checksum"");', '            return TCPEDIT_WARN;', '        }', '', '        ip_hl = layer - (u_char*)data;', '            if (udp->uh_sum == 0)', '                break;', '                icmp->icmp_sum = CHECKSUM_CARRY(sum);', '        case TCPR_PROTO_CDP:']}",True,An issue was discovered in Tcpreplay 4.3.1. An invalid memory access occurs in do_checksum in checksum.c. It can be triggered by sending a crafted pcap file to the tcpreplay-edit binary. It allows an attacker to cause a Denial of Service (Segmentation fault) or possibly have unspecified other impact.,7.8,HIGH,2,test,2019-03-12T20:29:10Z,2
CVE-2019-15921,['CWE-401'],AV:L/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"genetlink: Fix a memory leak on error path

In genl_register_family(), when idr_alloc() fails,
we forget to free the memory we possibly allocate for
family->attrbuf.

Reported-by: Hulk Robot <hulkci@huawei.com>
Fixes: 2ae0f17df1cd (""genetlink: use idr to track families"")
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Reviewed-by: Kirill Tkhai <ktkhai@virtuozzo.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2,https://github.com/torvalds/linux/commit/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2,net/netlink/genetlink.c,genl_register_family,"int genl_register_family(struct genl_family *family)
{
int err, i;
int start = GENL_START_ALLOC, end = GENL_MAX_ID;
err = genl_validate_ops(family);
if (err)
return err;
genl_lock_all();
if (genl_family_find_byname(family->name)) {
err = -EEXIST;
goto errout_locked;
}
if (family == &genl_ctrl) {
start = end = GENL_ID_CTRL;
} else if (strcmp(family->name, ""pmcraid"") == 0) {
start = end = GENL_ID_PMCRAID;
} else if (strcmp(family->name, ""VFS_DQUOT"") == 0) {
start = end = GENL_ID_VFS_DQUOT;
}
if (family->maxattr && !family->parallel_ops) {
family->attrbuf = kmalloc_array(family->maxattr + 1,
sizeof(struct nlattr *),
GFP_KERNEL);
if (family->attrbuf == NULL) {
err = -ENOMEM;
goto errout_locked;
}
} else
family->attrbuf = NULL;
family->id = idr_alloc(&genl_fam_idr, family,
start, end + 1, GFP_KERNEL);
if (family->id < 0) {
err = family->id;
goto errout_locked;
}
err = genl_validate_assign_mc_groups(family);
if (err)
goto errout_remove;
genl_unlock_all();
genl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);
for (i = 0; i < family->n_mcgrps; i++)
genl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,
&family->mcgrps[i], family->mcgrp_offset + i);
return 0;
errout_remove:
idr_remove(&genl_fam_idr, family->id);
kfree(family->attrbuf);
errout_locked:
genl_unlock_all();
return err;
}","int genl_register_family(struct genl_family *VAR_0)
{
int VAR_1, VAR_2;
int VAR_3 = VAR_4, VAR_5 = VAR_6;
VAR_1 = genl_validate_ops(VAR_0);
if (VAR_1)
return VAR_1;
genl_lock_all();
if (genl_family_find_byname(VAR_0->name)) {
VAR_1 = -VAR_7;
goto errout_locked;
}
if (VAR_0 == &VAR_8) {
VAR_3 = VAR_5 = VAR_9;
} else if (strcmp(VAR_0->name, ""pmcraid"") == 0) {
VAR_3 = VAR_5 = VAR_10;
} else if (strcmp(VAR_0->name, ""VFS_DQUOT"") == 0) {
VAR_3 = VAR_5 = VAR_11;
}
if (VAR_0->maxattr && !VAR_0->parallel_ops) {
VAR_0->attrbuf = kmalloc_array(VAR_0->maxattr + 1,
sizeof(struct nlattr *),
VAR_12);
if (VAR_0->attrbuf == NULL) {
VAR_1 = -VAR_13;
goto errout_locked;
}
} else
VAR_0->attrbuf = NULL;
VAR_0->id = idr_alloc(&VAR_14, VAR_0,
VAR_3, VAR_5 + 1, VAR_12);
if (VAR_0->id < 0) {
VAR_1 = VAR_0->id;
goto errout_locked;
}
VAR_1 = genl_validate_assign_mc_groups(VAR_0);
if (VAR_1)
goto errout_remove;
genl_unlock_all();
genl_ctrl_event(VAR_15, VAR_0, NULL, 0);
for (VAR_2 = 0; VAR_2 < VAR_0->n_mcgrps; VAR_2++)
genl_ctrl_event(VAR_16, VAR_0,
&VAR_0->mcgrps[VAR_2], VAR_0->mcgrp_offset + VAR_2);
return 0;
errout_remove:
idr_remove(&VAR_14, VAR_0->id);
kfree(VAR_0->attrbuf);
errout_locked:
genl_unlock_all();
return VAR_1;
}",torvalds/linux/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2/genetlink.c/vul/before/0.json,"int genl_register_family(struct genl_family *family)
{
	int err, i;
	int start = GENL_START_ALLOC, end = GENL_MAX_ID;

	err = genl_validate_ops(family);
	if (err)
		return err;

	genl_lock_all();

	if (genl_family_find_byname(family->name)) {
		err = -EEXIST;
		goto errout_locked;
	}

	/*
	 * Sadly, a few cases need to be special-cased
	 * due to them having previously abused the API
	 * and having used their family ID also as their
	 * multicast group ID, so we use reserved IDs
	 * for both to be sure we can do that mapping.
	 */
	if (family == &genl_ctrl) {
		/* and this needs to be special for initial family lookups */
		start = end = GENL_ID_CTRL;
	} else if (strcmp(family->name, ""pmcraid"") == 0) {
		start = end = GENL_ID_PMCRAID;
	} else if (strcmp(family->name, ""VFS_DQUOT"") == 0) {
		start = end = GENL_ID_VFS_DQUOT;
	}

	if (family->maxattr && !family->parallel_ops) {
		family->attrbuf = kmalloc_array(family->maxattr + 1,
						sizeof(struct nlattr *),
						GFP_KERNEL);
		if (family->attrbuf == NULL) {
			err = -ENOMEM;
			goto errout_locked;
		}
	} else
		family->attrbuf = NULL;

	family->id = idr_alloc(&genl_fam_idr, family,
			       start, end + 1, GFP_KERNEL);
	if (family->id < 0) {
		err = family->id;
		goto errout_free;
	}

	err = genl_validate_assign_mc_groups(family);
	if (err)
		goto errout_remove;

	genl_unlock_all();

	/* send all events */
	genl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);
	for (i = 0; i < family->n_mcgrps; i++)
		genl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,
				&family->mcgrps[i], family->mcgrp_offset + i);

	return 0;

errout_remove:
	idr_remove(&genl_fam_idr, family->id);
errout_free:
	kfree(family->attrbuf);
errout_locked:
	genl_unlock_all();
	return err;
}","int genl_register_family(struct genl_family *VAR_0)
{
	int VAR_1, VAR_2;
	int VAR_3 = VAR_4, VAR_5 = VAR_6;

	VAR_1 = genl_validate_ops(VAR_0);
	if (VAR_1)
		return VAR_1;

	genl_lock_all();

	if (genl_family_find_byname(VAR_0->name)) {
		VAR_1 = -VAR_7;
		goto errout_locked;
	}

	/* COMMENT_0 */
                                               
                                                
                                                 
                                              
                                               
    
	if (VAR_0 == &VAR_8) {
		/* COMMENT_7 */
		VAR_3 = VAR_5 = VAR_9;
	} else if (strcmp(VAR_0->name, ""pmcraid"") == 0) {
		VAR_3 = VAR_5 = VAR_10;
	} else if (strcmp(VAR_0->name, ""VFS_DQUOT"") == 0) {
		VAR_3 = VAR_5 = VAR_11;
	}

	if (VAR_0->maxattr && !VAR_0->parallel_ops) {
		VAR_0->attrbuf = kmalloc_array(VAR_0->maxattr + 1,
						sizeof(struct nlattr *),
						VAR_12);
		if (VAR_0->attrbuf == NULL) {
			VAR_1 = -VAR_13;
			goto errout_locked;
		}
	} else
		VAR_0->attrbuf = NULL;

	VAR_0->id = idr_alloc(&VAR_14, VAR_0,
			       VAR_3, VAR_5 + 1, VAR_12);
	if (VAR_0->id < 0) {
		VAR_1 = VAR_0->id;
		goto errout_free;
	}

	VAR_1 = genl_validate_assign_mc_groups(VAR_0);
	if (VAR_1)
		goto errout_remove;

	genl_unlock_all();

	/* COMMENT_8 */
	genl_ctrl_event(VAR_15, VAR_0, NULL, 0);
	for (VAR_2 = 0; VAR_2 < VAR_0->n_mcgrps; VAR_2++)
		genl_ctrl_event(VAR_16, VAR_0,
				&VAR_0->mcgrps[VAR_2], VAR_0->mcgrp_offset + VAR_2);

	return 0;

errout_remove:
	idr_remove(&VAR_14, VAR_0->id);
errout_free:
	kfree(VAR_0->attrbuf);
errout_locked:
	genl_unlock_all();
	return VAR_1;
}",torvalds/linux/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2/genetlink.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,7 @@
 			       start, end + 1, GFP_KERNEL);
 	if (family->id < 0) {
 		err = family->id;
-		goto errout_locked;
+		goto errout_free;
 	}
 
 	err = genl_validate_assign_mc_groups(family);
@@ -64,6 +64,7 @@
 
 errout_remove:
 	idr_remove(&genl_fam_idr, family->id);
+errout_free:
 	kfree(family->attrbuf);
 errout_locked:
 	genl_unlock_all();","{'deleted_lines': ['\t\tgoto errout_locked;'], 'added_lines': ['\t\tgoto errout_free;', 'errout_free:']}",True,An issue was discovered in the Linux kernel before 5.0.6. There is a memory leak issue when idr_alloc() fails in genl_register_family() in net/netlink/genetlink.c.,4.7,MEDIUM,1,test,2019-03-21T07:02:50Z,2
CVE-2019-12976,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1520,c0fe488e7052f68d4eb7768805a857ef6fef928d,https://github.com/ImageMagick/ImageMagick/commit/c0fe488e7052f68d4eb7768805a857ef6fef928d,coders/pcl.c,ReadPCLImage,"static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define CropBox  ""CropBox""
#define DeviceCMYK  ""DeviceCMYK""
#define MediaBox  ""MediaBox""
#define RenderPCLText  ""  Rendering PCL...  ""
char
command[MagickPathExtent],
*density,
filename[MagickPathExtent],
geometry[MagickPathExtent],
*options,
input_filename[MagickPathExtent];
const DelegateInfo
*delegate_info;
Image
*image,
*next_image;
ImageInfo
*read_info;
MagickBooleanType
cmyk,
status;
PointInfo
delta;
RectangleInfo
bounding_box,
page;
register char
*p;
register ssize_t
c;
SegmentInfo
bounds;
size_t
height,
width;
ssize_t
count;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);
if (status == MagickFalse)
{
ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",
image_info->filename);
image=DestroyImageList(image);
return((Image *) NULL);
}
delta.x=DefaultResolution;
delta.y=DefaultResolution;
if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))
{
GeometryInfo
geometry_info;
MagickStatusType
flags;
flags=ParseGeometry(PSDensityGeometry,&geometry_info);
image->resolution.x=geometry_info.rho;
image->resolution.y=geometry_info.sigma;
if ((flags & SigmaValue) == 0)
image->resolution.y=image->resolution.x;
}
cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
count=0;
(void) memset(&bounding_box,0,sizeof(bounding_box));
(void) memset(&bounds,0,sizeof(bounds));
(void) memset(&page,0,sizeof(page));
(void) memset(command,0,sizeof(command));
p=command;
for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
{
if (image_info->page != (char *) NULL)
continue;
*p++=(char) c;
if ((c != (int) '/') && (c != '\n') &&
((size_t) (p-command) < (MagickPathExtent-1)))
continue;
*p='\0';
p=command;
if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)
cmyk=MagickTrue;
if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)
{
count=(ssize_t) sscanf(command,""CropBox [%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
if (count != 4)
count=(ssize_t) sscanf(command,""CropBox[%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
}
if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)
{
count=(ssize_t) sscanf(command,""MediaBox [%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
if (count != 4)
count=(ssize_t) sscanf(command,""MediaBox[%lf %lf %lf %lf"",
&bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
}
if (count != 4)
continue;
width=(size_t) floor(bounds.x2-bounds.x1+0.5);
height=(size_t) floor(bounds.y2-bounds.y1+0.5);
if (width > page.width)
page.width=width;
if (height > page.height)
page.height=height;
}
(void) CloseBlob(image);
if ((page.width == 0) || (page.height == 0))
(void) ParseAbsoluteGeometry(PSPageGeometry,&page);
if (image_info->page != (char *) NULL)
(void) ParseAbsoluteGeometry(image_info->page,&page);
(void) FormatLocaleString(geometry,MagickPathExtent,""%.20gx%.20g"",(double)
page.width,(double) page.height);
if (image_info->monochrome != MagickFalse)
delegate_info=GetDelegateInfo(""pcl:mono"",(char *) NULL,exception);
else
if (cmyk != MagickFalse)
delegate_info=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,exception);
else
delegate_info=GetDelegateInfo(""pcl:color"",(char *) NULL,exception);
if (delegate_info == (const DelegateInfo *) NULL)
return((Image *) NULL);
if ((page.width == 0) || (page.height == 0))
(void) ParseAbsoluteGeometry(PSPageGeometry,&page);
if (image_info->page != (char *) NULL)
(void) ParseAbsoluteGeometry(image_info->page,&page);
density=AcquireString("""");
options=AcquireString("""");
(void) FormatLocaleString(density,MagickPathExtent,""%gx%g"",
image->resolution.x,image->resolution.y);
page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);
page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);
(void) FormatLocaleString(options,MagickPathExtent,""-g%.20gx%.20g "",(double)
page.width,(double) page.height);
image=DestroyImage(image);
read_info=CloneImageInfo(image_info);
*read_info->magick='\0';
if (read_info->number_scenes != 0)
{
if (read_info->number_scenes != 1)
(void) FormatLocaleString(options,MagickPathExtent,""-dLastPage=%.20g"",
(double) (read_info->scene+read_info->number_scenes));
else
(void) FormatLocaleString(options,MagickPathExtent,
""-dFirstPage=%.20g -dLastPage=%.20g"",(double) read_info->scene+1,
(double) (read_info->scene+read_info->number_scenes));
read_info->number_scenes=0;
if (read_info->scenes != (char *) NULL)
*read_info->scenes='\0';
}
(void) CopyMagickString(filename,read_info->filename,MagickPathExtent);
(void) AcquireUniqueFilename(read_info->filename);
(void) FormatLocaleString(command,MagickPathExtent,
GetDelegateCommands(delegate_info),
read_info->antialias != MagickFalse ? 4 : 1,
read_info->antialias != MagickFalse ? 4 : 1,density,options,
read_info->filename,input_filename);
options=DestroyString(options);
density=DestroyString(density);
status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,
(char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;
image=ReadImage(read_info,exception);
(void) RelinquishUniqueFileResource(read_info->filename);
(void) RelinquishUniqueFileResource(input_filename);
read_info=DestroyImageInfo(read_info);
if (image == (Image *) NULL)
ThrowReaderException(DelegateError,""PCLDelegateFailed"");
if (LocaleCompare(image->magick,""BMP"") == 0)
{
Image
*cmyk_image;
cmyk_image=ConsolidateCMYKImages(image,exception);
if (cmyk_image != (Image *) NULL)
{
image=DestroyImageList(image);
image=cmyk_image;
}
}
do
{
(void) CopyMagickString(image->filename,filename,MagickPathExtent);
image->page=page;
next_image=SyncNextImageInList(image);
if (next_image != (Image *) NULL)
image=next_image;
} while (next_image != (Image *) NULL);
return(GetFirstImageInList(image));
}","static Image *ReadPCLImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  ""CropBox""
#define VAR_3  ""DeviceCMYK""
#define VAR_4  ""MediaBox""
#define VAR_5  ""  Rendering PCL...  ""
char
VAR_6[VAR_7],
*VAR_8,
VAR_9[VAR_7],
VAR_10[VAR_7],
*VAR_11,
VAR_12[VAR_7];
const DelegateInfo
*VAR_13;
Image
*VAR_14,
*VAR_15;
ImageInfo
*VAR_16;
MagickBooleanType
VAR_17,
VAR_18;
PointInfo
VAR_19;
RectangleInfo
VAR_20,
VAR_21;
register char
*VAR_22;
register ssize_t
VAR_23;
SegmentInfo
VAR_24;
size_t
VAR_25,
VAR_26;
ssize_t
VAR_27;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_28);
if (VAR_0->debug != VAR_29)
(void) LogMagickEvent(VAR_30,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_28);
VAR_14=AcquireImage(VAR_0,VAR_1);
VAR_18=OpenBlob(VAR_0,VAR_14,VAR_31,VAR_1);
if (VAR_18 == VAR_29)
{
VAR_14=DestroyImageList(VAR_14);
return((Image *) NULL);
}
VAR_18=AcquireUniqueSymbolicLink(VAR_0->filename,VAR_12);
if (VAR_18 == VAR_29)
{
ThrowFileException(VAR_1,VAR_32,""UnableToCreateTemporaryFile"",
VAR_0->filename);
VAR_14=DestroyImageList(VAR_14);
return((Image *) NULL);
}
VAR_19.x=VAR_33;
VAR_19.y=VAR_33;
if ((VAR_14->resolution.x == 0.0) || (VAR_14->resolution.y == 0.0))
{
GeometryInfo
VAR_34;
MagickStatusType
VAR_35;
VAR_35=ParseGeometry(VAR_36,&VAR_34);
VAR_14->resolution.x=VAR_34.rho;
VAR_14->resolution.y=VAR_34.sigma;
if ((VAR_35 & VAR_37) == 0)
VAR_14->resolution.y=VAR_14->resolution.x;
}
VAR_17=VAR_14->colorspace == VAR_38 ? VAR_39 : VAR_29;
VAR_27=0;
(void) memset(&VAR_20,0,sizeof(VAR_20));
(void) memset(&VAR_24,0,sizeof(VAR_24));
(void) memset(&VAR_21,0,sizeof(VAR_21));
(void) memset(VAR_6,0,sizeof(VAR_6));
VAR_22=VAR_6;
for (VAR_23=ReadBlobByte(VAR_14); VAR_23 != VAR_40; VAR_23=ReadBlobByte(VAR_14))
{
if (VAR_0->page != (char *) NULL)
continue;
*VAR_22++=(char) VAR_23;
if ((VAR_23 != (int) '/') && (VAR_23 != '\n') &&
((size_t) (VAR_22-VAR_6) < (VAR_7-1)))
continue;
*VAR_22='\0';
VAR_22=VAR_6;
if (LocaleNCompare(VAR_3,VAR_6,strlen(VAR_3)) == 0)
VAR_17=VAR_39;
if (LocaleNCompare(VAR_2,VAR_6,strlen(VAR_2)) == 0)
{
VAR_27=(ssize_t) sscanf(VAR_6,""CropBox [%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
if (VAR_27 != 4)
VAR_27=(ssize_t) sscanf(VAR_6,""CropBox[%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
}
if (LocaleNCompare(VAR_4,VAR_6,strlen(VAR_4)) == 0)
{
VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox [%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
if (VAR_27 != 4)
VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox[%lf %lf %lf %lf"",
&VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
}
if (VAR_27 != 4)
continue;
VAR_26=(size_t) floor(VAR_24.x2-VAR_24.x1+0.5);
VAR_25=(size_t) floor(VAR_24.y2-VAR_24.y1+0.5);
if (VAR_26 > VAR_21.width)
VAR_21.width=VAR_26;
if (VAR_25 > VAR_21.height)
VAR_21.height=VAR_25;
}
(void) CloseBlob(VAR_14);
if ((VAR_21.width == 0) || (VAR_21.height == 0))
(void) ParseAbsoluteGeometry(VAR_41,&VAR_21);
if (VAR_0->page != (char *) NULL)
(void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
(void) FormatLocaleString(VAR_10,VAR_7,""%.20gx%.20g"",(double)
VAR_21.width,(double) VAR_21.height);
if (VAR_0->monochrome != VAR_29)
VAR_13=GetDelegateInfo(""pcl:mono"",(char *) NULL,VAR_1);
else
if (VAR_17 != VAR_29)
VAR_13=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,VAR_1);
else
VAR_13=GetDelegateInfo(""pcl:color"",(char *) NULL,VAR_1);
if (VAR_13 == (const DelegateInfo *) NULL)
return((Image *) NULL);
if ((VAR_21.width == 0) || (VAR_21.height == 0))
(void) ParseAbsoluteGeometry(VAR_41,&VAR_21);
if (VAR_0->page != (char *) NULL)
(void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
VAR_8=AcquireString("""");
VAR_11=AcquireString("""");
(void) FormatLocaleString(VAR_8,VAR_7,""%gx%g"",
VAR_14->resolution.x,VAR_14->resolution.y);
VAR_21.width=(size_t) floor(VAR_21.width*VAR_14->resolution.x/VAR_19.x+0.5);
VAR_21.height=(size_t) floor(VAR_21.height*VAR_14->resolution.y/VAR_19.y+0.5);
(void) FormatLocaleString(VAR_11,VAR_7,""-g%.20gx%.20g "",(double)
VAR_21.width,(double) VAR_21.height);
VAR_14=DestroyImage(VAR_14);
VAR_16=CloneImageInfo(VAR_0);
*VAR_16->magick='\0';
if (VAR_16->number_scenes != 0)
{
if (VAR_16->number_scenes != 1)
(void) FormatLocaleString(VAR_11,VAR_7,""-dLastPage=%.20g"",
(double) (VAR_16->scene+VAR_16->number_scenes));
else
(void) FormatLocaleString(VAR_11,VAR_7,
""-dFirstPage=%.20g -dLastPage=%.20g"",(double) VAR_16->scene+1,
(double) (VAR_16->scene+VAR_16->number_scenes));
VAR_16->number_scenes=0;
if (VAR_16->scenes != (char *) NULL)
*VAR_16->scenes='\0';
}
(void) CopyMagickString(VAR_9,VAR_16->filename,VAR_7);
(void) AcquireUniqueFilename(VAR_16->filename);
(void) FormatLocaleString(VAR_6,VAR_7,
GetDelegateCommands(VAR_13),
VAR_16->antialias != VAR_29 ? 4 : 1,
VAR_16->antialias != VAR_29 ? 4 : 1,VAR_8,VAR_11,
VAR_16->filename,VAR_12);
VAR_11=DestroyString(VAR_11);
VAR_8=DestroyString(VAR_8);
VAR_18=ExternalDelegateCommand(VAR_29,VAR_16->verbose,VAR_6,
(char *) NULL,VAR_1) != 0 ? VAR_39 : VAR_29;
VAR_14=ReadImage(VAR_16,VAR_1);
(void) RelinquishUniqueFileResource(VAR_16->filename);
(void) RelinquishUniqueFileResource(VAR_12);
VAR_16=DestroyImageInfo(VAR_16);
if (VAR_14 == (Image *) NULL)
ThrowReaderException(VAR_42,""PCLDelegateFailed"");
if (LocaleCompare(VAR_14->magick,""BMP"") == 0)
{
Image
*VAR_43;
VAR_43=ConsolidateCMYKImages(VAR_14,VAR_1);
if (VAR_43 != (Image *) NULL)
{
VAR_14=DestroyImageList(VAR_14);
VAR_14=VAR_43;
}
}
do
{
(void) CopyMagickString(VAR_14->filename,VAR_9,VAR_7);
VAR_14->page=VAR_21;
VAR_15=SyncNextImageInList(VAR_14);
if (VAR_15 != (Image *) NULL)
VAR_14=VAR_15;
} while (VAR_15 != (Image *) NULL);
return(GetFirstImageInList(VAR_14));
}",ImageMagick/c0fe488e7052f68d4eb7768805a857ef6fef928d/pcl.c/vul/before/0.json,"static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define CropBox  ""CropBox""
#define DeviceCMYK  ""DeviceCMYK""
#define MediaBox  ""MediaBox""
#define RenderPCLText  ""  Rendering PCL...  ""

  char
    command[MagickPathExtent],
    *density,
    filename[MagickPathExtent],
    geometry[MagickPathExtent],
    *options,
    input_filename[MagickPathExtent];

  const DelegateInfo
    *delegate_info;

  Image
    *image,
    *next_image;

  ImageInfo
    *read_info;

  MagickBooleanType
    cmyk,
    status;

  PointInfo
    delta;

  RectangleInfo
    bounding_box,
    page;

  register char
    *p;

  register ssize_t
    c;

  SegmentInfo
    bounds;

  size_t
    height,
    width;

  ssize_t
    count;

  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  /*
    Open image file.
  */
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);
  if (status == MagickFalse)
    {
      ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",
        image_info->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Set the page density.
  */
  delta.x=DefaultResolution;
  delta.y=DefaultResolution;
  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(PSDensityGeometry,&geometry_info);
      image->resolution.x=geometry_info.rho;
      image->resolution.y=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        image->resolution.y=image->resolution.x;
    }
  /*
    Determine page geometry from the PCL media box.
  */
  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
  count=0;
  (void) memset(&bounding_box,0,sizeof(bounding_box));
  (void) memset(&bounds,0,sizeof(bounds));
  (void) memset(&page,0,sizeof(page));
  (void) memset(command,0,sizeof(command));
  p=command;
  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
  {
    if (image_info->page != (char *) NULL)
      continue;
    /*
      Note PCL elements.
    */
    *p++=(char) c;
    if ((c != (int) '/') && (c != '\n') &&
        ((size_t) (p-command) < (MagickPathExtent-1)))
      continue;
    *p='\0';
    p=command;
    /*
      Is this a CMYK document?
    */
    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)
      cmyk=MagickTrue;
    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)
      {
        /*
          Note region defined by crop box.
        */
        count=(ssize_t) sscanf(command,""CropBox [%lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        if (count != 4)
          count=(ssize_t) sscanf(command,""CropBox[%lf %lf %lf %lf"",
            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
      }
    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)
      {
        /*
          Note region defined by media box.
        */
        count=(ssize_t) sscanf(command,""MediaBox [%lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        if (count != 4)
          count=(ssize_t) sscanf(command,""MediaBox[%lf %lf %lf %lf"",
            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
      }
    if (count != 4)
      continue;
    /*
      Set PCL render geometry.
    */
    width=(size_t) floor(bounds.x2-bounds.x1+0.5);
    height=(size_t) floor(bounds.y2-bounds.y1+0.5);
    if (width > page.width)
      page.width=width;
    if (height > page.height)
      page.height=height;
  }
  (void) CloseBlob(image);
  /*
    Render PCL with the GhostPCL delegate.
  */
  if ((page.width == 0) || (page.height == 0))
    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  (void) FormatLocaleString(geometry,MagickPathExtent,""%.20gx%.20g"",(double)
    page.width,(double) page.height);
  if (image_info->monochrome != MagickFalse)
    delegate_info=GetDelegateInfo(""pcl:mono"",(char *) NULL,exception);
  else
     if (cmyk != MagickFalse)
       delegate_info=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,exception);
     else
       delegate_info=GetDelegateInfo(""pcl:color"",(char *) NULL,exception);
  if (delegate_info == (const DelegateInfo *) NULL)
    {
      image=DestroyImage(image);
      return((Image *) NULL);
    }
  if ((page.width == 0) || (page.height == 0))
    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  density=AcquireString("""");
  options=AcquireString("""");
  (void) FormatLocaleString(density,MagickPathExtent,""%gx%g"",
    image->resolution.x,image->resolution.y);
  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);
  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);
  (void) FormatLocaleString(options,MagickPathExtent,""-g%.20gx%.20g "",(double)
    page.width,(double) page.height);
  image=DestroyImage(image);
  read_info=CloneImageInfo(image_info);
  *read_info->magick='\0';
  if (read_info->number_scenes != 0)
    {
      if (read_info->number_scenes != 1)
        (void) FormatLocaleString(options,MagickPathExtent,""-dLastPage=%.20g"",
          (double) (read_info->scene+read_info->number_scenes));
      else
        (void) FormatLocaleString(options,MagickPathExtent,
          ""-dFirstPage=%.20g -dLastPage=%.20g"",(double) read_info->scene+1,
          (double) (read_info->scene+read_info->number_scenes));
      read_info->number_scenes=0;
      if (read_info->scenes != (char *) NULL)
        *read_info->scenes='\0';
    }
  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);
  (void) AcquireUniqueFilename(read_info->filename);
  (void) FormatLocaleString(command,MagickPathExtent,
    GetDelegateCommands(delegate_info),
    read_info->antialias != MagickFalse ? 4 : 1,
    read_info->antialias != MagickFalse ? 4 : 1,density,options,
    read_info->filename,input_filename);
  options=DestroyString(options);
  density=DestroyString(density);
  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,
    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;
  image=ReadImage(read_info,exception);
  (void) RelinquishUniqueFileResource(read_info->filename);
  (void) RelinquishUniqueFileResource(input_filename);
  read_info=DestroyImageInfo(read_info);
  if (image == (Image *) NULL)
    ThrowReaderException(DelegateError,""PCLDelegateFailed"");
  if (LocaleCompare(image->magick,""BMP"") == 0)
    {
      Image
        *cmyk_image;

      cmyk_image=ConsolidateCMYKImages(image,exception);
      if (cmyk_image != (Image *) NULL)
        {
          image=DestroyImageList(image);
          image=cmyk_image;
        }
    }
  do
  {
    (void) CopyMagickString(image->filename,filename,MagickPathExtent);
    image->page=page;
    next_image=SyncNextImageInList(image);
    if (next_image != (Image *) NULL)
      image=next_image;
  } while (next_image != (Image *) NULL);
  return(GetFirstImageInList(image));
}","static Image *ReadPCLImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  ""CropBox""
#define VAR_3  ""DeviceCMYK""
#define VAR_4  ""MediaBox""
#define VAR_5  ""  Rendering PCL...  ""

  char
    VAR_6[VAR_7],
    *VAR_8,
    VAR_9[VAR_7],
    VAR_10[VAR_7],
    *VAR_11,
    VAR_12[VAR_7];

  const DelegateInfo
    *VAR_13;

  Image
    *VAR_14,
    *VAR_15;

  ImageInfo
    *VAR_16;

  MagickBooleanType
    VAR_17,
    VAR_18;

  PointInfo
    VAR_19;

  RectangleInfo
    VAR_20,
    VAR_21;

  register char
    *VAR_22;

  register ssize_t
    VAR_23;

  SegmentInfo
    VAR_24;

  size_t
    VAR_25,
    VAR_26;

  ssize_t
    VAR_27;

  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_28);
  if (VAR_0->debug != VAR_29)
    (void) LogMagickEvent(VAR_30,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_28);
  /* COMMENT_0 */
                    
    
  VAR_14=AcquireImage(VAR_0,VAR_1);
  VAR_18=OpenBlob(VAR_0,VAR_14,VAR_31,VAR_1);
  if (VAR_18 == VAR_29)
    {
      VAR_14=DestroyImageList(VAR_14);
      return((Image *) NULL);
    }
  VAR_18=AcquireUniqueSymbolicLink(VAR_0->filename,VAR_12);
  if (VAR_18 == VAR_29)
    {
      ThrowFileException(VAR_1,VAR_32,""UnableToCreateTemporaryFile"",
        VAR_0->filename);
      VAR_14=DestroyImageList(VAR_14);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                         
    
  VAR_19.x=VAR_33;
  VAR_19.y=VAR_33;
  if ((VAR_14->resolution.x == 0.0) || (VAR_14->resolution.y == 0.0))
    {
      GeometryInfo
        VAR_34;

      MagickStatusType
        VAR_35;

      VAR_35=ParseGeometry(VAR_36,&VAR_34);
      VAR_14->resolution.x=VAR_34.rho;
      VAR_14->resolution.y=VAR_34.sigma;
      if ((VAR_35 & VAR_37) == 0)
        VAR_14->resolution.y=VAR_14->resolution.x;
    }
  /* COMMENT_6 */
                                                   
    
  VAR_17=VAR_14->colorspace == VAR_38 ? VAR_39 : VAR_29;
  VAR_27=0;
  (void) memset(&VAR_20,0,sizeof(VAR_20));
  (void) memset(&VAR_24,0,sizeof(VAR_24));
  (void) memset(&VAR_21,0,sizeof(VAR_21));
  (void) memset(VAR_6,0,sizeof(VAR_6));
  VAR_22=VAR_6;
  for (VAR_23=ReadBlobByte(VAR_14); VAR_23 != VAR_40; VAR_23=ReadBlobByte(VAR_14))
  {
    if (VAR_0->page != (char *) NULL)
      continue;
    /* COMMENT_9 */
                        
      
    *VAR_22++=(char) VAR_23;
    if ((VAR_23 != (int) '/') && (VAR_23 != '\n') &&
        ((size_t) (VAR_22-VAR_6) < (VAR_7-1)))
      continue;
    *VAR_22='\0';
    VAR_22=VAR_6;
    /* COMMENT_12 */
                              
      
    if (LocaleNCompare(VAR_3,VAR_6,strlen(VAR_3)) == 0)
      VAR_17=VAR_39;
    if (LocaleNCompare(VAR_2,VAR_6,strlen(VAR_2)) == 0)
      {
        /* COMMENT_15 */
                                          
          
        VAR_27=(ssize_t) sscanf(VAR_6,""CropBox [%lf %lf %lf %lf"",
          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
        if (VAR_27 != 4)
          VAR_27=(ssize_t) sscanf(VAR_6,""CropBox[%lf %lf %lf %lf"",
            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
      }
    if (LocaleNCompare(VAR_4,VAR_6,strlen(VAR_4)) == 0)
      {
        /* COMMENT_18 */
                                           
          
        VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox [%lf %lf %lf %lf"",
          &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
        if (VAR_27 != 4)
          VAR_27=(ssize_t) sscanf(VAR_6,""MediaBox[%lf %lf %lf %lf"",
            &VAR_24.x1,&VAR_24.y1,&VAR_24.x2,&VAR_24.y2);
      }
    if (VAR_27 != 4)
      continue;
    /* COMMENT_21 */
                              
      
    VAR_26=(size_t) floor(VAR_24.x2-VAR_24.x1+0.5);
    VAR_25=(size_t) floor(VAR_24.y2-VAR_24.y1+0.5);
    if (VAR_26 > VAR_21.width)
      VAR_21.width=VAR_26;
    if (VAR_25 > VAR_21.height)
      VAR_21.height=VAR_25;
  }
  (void) CloseBlob(VAR_14);
  /* COMMENT_24 */
                                          
    
  if ((VAR_21.width == 0) || (VAR_21.height == 0))
    (void) ParseAbsoluteGeometry(VAR_41,&VAR_21);
  if (VAR_0->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
  (void) FormatLocaleString(VAR_10,VAR_7,""%.20gx%.20g"",(double)
    VAR_21.width,(double) VAR_21.height);
  if (VAR_0->monochrome != VAR_29)
    VAR_13=GetDelegateInfo(""pcl:mono"",(char *) NULL,VAR_1);
  else
     if (VAR_17 != VAR_29)
       VAR_13=GetDelegateInfo(""pcl:cmyk"",(char *) NULL,VAR_1);
     else
       VAR_13=GetDelegateInfo(""pcl:color"",(char *) NULL,VAR_1);
  if (VAR_13 == (const DelegateInfo *) NULL)
    {
      VAR_14=DestroyImage(VAR_14);
      return((Image *) NULL);
    }
  if ((VAR_21.width == 0) || (VAR_21.height == 0))
    (void) ParseAbsoluteGeometry(VAR_41,&VAR_21);
  if (VAR_0->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(VAR_0->page,&VAR_21);
  VAR_8=AcquireString("""");
  VAR_11=AcquireString("""");
  (void) FormatLocaleString(VAR_8,VAR_7,""%gx%g"",
    VAR_14->resolution.x,VAR_14->resolution.y);
  VAR_21.width=(size_t) floor(VAR_21.width*VAR_14->resolution.x/VAR_19.x+0.5);
  VAR_21.height=(size_t) floor(VAR_21.height*VAR_14->resolution.y/VAR_19.y+0.5);
  (void) FormatLocaleString(VAR_11,VAR_7,""-g%.20gx%.20g "",(double)
    VAR_21.width,(double) VAR_21.height);
  VAR_14=DestroyImage(VAR_14);
  VAR_16=CloneImageInfo(VAR_0);
  *VAR_16->magick='\0';
  if (VAR_16->number_scenes != 0)
    {
      if (VAR_16->number_scenes != 1)
        (void) FormatLocaleString(VAR_11,VAR_7,""-dLastPage=%.20g"",
          (double) (VAR_16->scene+VAR_16->number_scenes));
      else
        (void) FormatLocaleString(VAR_11,VAR_7,
          ""-dFirstPage=%.20g -dLastPage=%.20g"",(double) VAR_16->scene+1,
          (double) (VAR_16->scene+VAR_16->number_scenes));
      VAR_16->number_scenes=0;
      if (VAR_16->scenes != (char *) NULL)
        *VAR_16->scenes='\0';
    }
  (void) CopyMagickString(VAR_9,VAR_16->filename,VAR_7);
  (void) AcquireUniqueFilename(VAR_16->filename);
  (void) FormatLocaleString(VAR_6,VAR_7,
    GetDelegateCommands(VAR_13),
    VAR_16->antialias != VAR_29 ? 4 : 1,
    VAR_16->antialias != VAR_29 ? 4 : 1,VAR_8,VAR_11,
    VAR_16->filename,VAR_12);
  VAR_11=DestroyString(VAR_11);
  VAR_8=DestroyString(VAR_8);
  VAR_18=ExternalDelegateCommand(VAR_29,VAR_16->verbose,VAR_6,
    (char *) NULL,VAR_1) != 0 ? VAR_39 : VAR_29;
  VAR_14=ReadImage(VAR_16,VAR_1);
  (void) RelinquishUniqueFileResource(VAR_16->filename);
  (void) RelinquishUniqueFileResource(VAR_12);
  VAR_16=DestroyImageInfo(VAR_16);
  if (VAR_14 == (Image *) NULL)
    ThrowReaderException(VAR_42,""PCLDelegateFailed"");
  if (LocaleCompare(VAR_14->magick,""BMP"") == 0)
    {
      Image
        *VAR_43;

      VAR_43=ConsolidateCMYKImages(VAR_14,VAR_1);
      if (VAR_43 != (Image *) NULL)
        {
          VAR_14=DestroyImageList(VAR_14);
          VAR_14=VAR_43;
        }
    }
  do
  {
    (void) CopyMagickString(VAR_14->filename,VAR_9,VAR_7);
    VAR_14->page=VAR_21;
    VAR_15=SyncNextImageInList(VAR_14);
    if (VAR_15 != (Image *) NULL)
      VAR_14=VAR_15;
  } while (VAR_15 != (Image *) NULL);
  return(GetFirstImageInList(VAR_14));
}",ImageMagick/c0fe488e7052f68d4eb7768805a857ef6fef928d/pcl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -174,7 +174,10 @@
      else
        delegate_info=GetDelegateInfo(""pcl:color"",(char *) NULL,exception);
   if (delegate_info == (const DelegateInfo *) NULL)
-    return((Image *) NULL);
+    {
+      image=DestroyImage(image);
+      return((Image *) NULL);
+    }
   if ((page.width == 0) || (page.height == 0))
     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
   if (image_info->page != (char *) NULL)
@@ -186,7 +189,7 @@
   page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);
   page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);
   (void) FormatLocaleString(options,MagickPathExtent,""-g%.20gx%.20g "",(double)
-     page.width,(double) page.height);
+    page.width,(double) page.height);
   image=DestroyImage(image);
   read_info=CloneImageInfo(image_info);
   *read_info->magick='\0';","{'deleted_lines': ['    return((Image *) NULL);', '     page.width,(double) page.height);'], 'added_lines': ['    {', '      image=DestroyImage(image);', '      return((Image *) NULL);', '    }', '    page.width,(double) page.height);']}",True,ImageMagick 7.0.8-34 has a memory leak in the ReadPCLImage function in coders/pcl.c.,5.5,MEDIUM,1,test,2019-03-23T18:36:09Z,2
CVE-2019-11338,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ffmpeg,"avcodec/hevcdec: Avoid only partly skiping duplicate first slices

Fixes: NULL pointer dereference and out of array access
Fixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432
Fixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304

This also fixes the return code for explode mode

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Reviewed-by: James Almer <jamrial@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
(cherry picked from commit 54655623a82632e7624714d7b2a3e039dc5faa7e)
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",9ccc633068c6fe76989f487c8932bd11886ad65b,https://github.com/FFmpeg/FFmpeg/commit/9ccc633068c6fe76989f487c8932bd11886ad65b,libavcodec/hevcdec.c,hls_slice_header,"static int hls_slice_header(HEVCContext *s)
{
GetBitContext *gb = &s->HEVClc->gb;
SliceHeader *sh   = &s->sh;
int i, ret;
sh->first_slice_in_pic_flag = get_bits1(gb);
if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
s->seq_decode = (s->seq_decode + 1) & 0xff;
s->max_ra     = INT_MAX;
if (IS_IDR(s))
ff_hevc_clear_refs(s);
}
sh->no_output_of_prior_pics_flag = 0;
if (IS_IRAP(s))
sh->no_output_of_prior_pics_flag = get_bits1(gb);
sh->pps_id = get_ue_golomb_long(gb);
if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {
av_log(s->avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id);
return AVERROR_INVALIDDATA;
}
if (!sh->first_slice_in_pic_flag &&
s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {
av_log(s->avctx, AV_LOG_ERROR, ""PPS changed between slices.\n"");
return AVERROR_INVALIDDATA;
}
s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;
if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)
sh->no_output_of_prior_pics_flag = 1;
if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {
const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;
const HEVCSPS *last_sps = s->ps.sps;
enum AVPixelFormat pix_fmt;
if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {
if (sps->width != last_sps->width || sps->height != last_sps->height ||
sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=
last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)
sh->no_output_of_prior_pics_flag = 0;
}
ff_hevc_clear_refs(s);
pix_fmt = get_format(s, sps);
if (pix_fmt < 0)
return pix_fmt;
ret = set_sps(s, sps, pix_fmt);
if (ret < 0)
return ret;
s->seq_decode = (s->seq_decode + 1) & 0xff;
s->max_ra     = INT_MAX;
}
sh->dependent_slice_segment_flag = 0;
if (!sh->first_slice_in_pic_flag) {
int slice_address_length;
if (s->ps.pps->dependent_slice_segments_enabled_flag)
sh->dependent_slice_segment_flag = get_bits1(gb);
slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *
s->ps.sps->ctb_height);
sh->slice_segment_addr = get_bitsz(gb, slice_address_length);
if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {
av_log(s->avctx, AV_LOG_ERROR,
""Invalid slice segment address: %u.\n"",
sh->slice_segment_addr);
return AVERROR_INVALIDDATA;
}
if (!sh->dependent_slice_segment_flag) {
sh->slice_addr = sh->slice_segment_addr;
s->slice_idx++;
}
} else {
sh->slice_segment_addr = sh->slice_addr = 0;
s->slice_idx           = 0;
s->slice_initialized   = 0;
}
if (!sh->dependent_slice_segment_flag) {
s->slice_initialized = 0;
for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)
skip_bits(gb, 1);  
sh->slice_type = get_ue_golomb_long(gb);
if (!(sh->slice_type == HEVC_SLICE_I ||
sh->slice_type == HEVC_SLICE_P ||
sh->slice_type == HEVC_SLICE_B)) {
av_log(s->avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"",
sh->slice_type);
return AVERROR_INVALIDDATA;
}
if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {
av_log(s->avctx, AV_LOG_ERROR, ""Inter slices in an IRAP frame.\n"");
return AVERROR_INVALIDDATA;
}
sh->pic_output_flag = 1;
if (s->ps.pps->output_flag_present_flag)
sh->pic_output_flag = get_bits1(gb);
if (s->ps.sps->separate_colour_plane_flag)
sh->colour_plane_id = get_bits(gb, 2);
if (!IS_IDR(s)) {
int poc, pos;
sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);
poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);
if (!sh->first_slice_in_pic_flag && poc != s->poc) {
av_log(s->avctx, AV_LOG_WARNING,
""Ignoring POC change between slices: %d -> %d\n"", s->poc, poc);
if (s->avctx->err_recognition & AV_EF_EXPLODE)
return AVERROR_INVALIDDATA;
poc = s->poc;
}
s->poc = poc;
sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);
pos = get_bits_left(gb);
if (!sh->short_term_ref_pic_set_sps_flag) {
ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);
if (ret < 0)
return ret;
sh->short_term_rps = &sh->slice_rps;
} else {
int numbits, rps_idx;
if (!s->ps.sps->nb_st_rps) {
av_log(s->avctx, AV_LOG_ERROR, ""No ref lists in the SPS.\n"");
return AVERROR_INVALIDDATA;
}
numbits = av_ceil_log2(s->ps.sps->nb_st_rps);
rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;
sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];
}
sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);
pos = get_bits_left(gb);
ret = decode_lt_rps(s, &sh->long_term_rps, gb);
if (ret < 0) {
av_log(s->avctx, AV_LOG_WARNING, ""Invalid long term RPS.\n"");
if (s->avctx->err_recognition & AV_EF_EXPLODE)
return AVERROR_INVALIDDATA;
}
sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);
if (s->ps.sps->sps_temporal_mvp_enabled_flag)
sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);
else
sh->slice_temporal_mvp_enabled_flag = 0;
} else {
s->sh.short_term_rps = NULL;
s->poc               = 0;
}
if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&
s->nal_unit_type != HEVC_NAL_TRAIL_N &&
s->nal_unit_type != HEVC_NAL_TSA_N   &&
s->nal_unit_type != HEVC_NAL_STSA_N  &&
s->nal_unit_type != HEVC_NAL_RADL_N  &&
s->nal_unit_type != HEVC_NAL_RADL_R  &&
s->nal_unit_type != HEVC_NAL_RASL_N  &&
s->nal_unit_type != HEVC_NAL_RASL_R)
s->pocTid0 = s->poc;
if (s->ps.sps->sao_enabled) {
sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);
if (s->ps.sps->chroma_format_idc) {
sh->slice_sample_adaptive_offset_flag[1] =
sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);
}
} else {
sh->slice_sample_adaptive_offset_flag[0] = 0;
sh->slice_sample_adaptive_offset_flag[1] = 0;
sh->slice_sample_adaptive_offset_flag[2] = 0;
}
sh->nb_refs[L0] = sh->nb_refs[L1] = 0;
if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {
int nb_refs;
sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;
if (sh->slice_type == HEVC_SLICE_B)
sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;
if (get_bits1(gb)) {                 sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;
if (sh->slice_type == HEVC_SLICE_B)
sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;
}
if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {
av_log(s->avctx, AV_LOG_ERROR, ""Too many refs: %d/%d.\n"",
sh->nb_refs[L0], sh->nb_refs[L1]);
return AVERROR_INVALIDDATA;
}
sh->rpl_modification_flag[0] = 0;
sh->rpl_modification_flag[1] = 0;
nb_refs = ff_hevc_frame_nb_refs(s);
if (!nb_refs) {
av_log(s->avctx, AV_LOG_ERROR, ""Zero refs for a frame with P or B slices.\n"");
return AVERROR_INVALIDDATA;
}
if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {
sh->rpl_modification_flag[0] = get_bits1(gb);
if (sh->rpl_modification_flag[0]) {
for (i = 0; i < sh->nb_refs[L0]; i++)
sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));
}
if (sh->slice_type == HEVC_SLICE_B) {
sh->rpl_modification_flag[1] = get_bits1(gb);
if (sh->rpl_modification_flag[1] == 1)
for (i = 0; i < sh->nb_refs[L1]; i++)
sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));
}
}
if (sh->slice_type == HEVC_SLICE_B)
sh->mvd_l1_zero_flag = get_bits1(gb);
if (s->ps.pps->cabac_init_present_flag)
sh->cabac_init_flag = get_bits1(gb);
else
sh->cabac_init_flag = 0;
sh->collocated_ref_idx = 0;
if (sh->slice_temporal_mvp_enabled_flag) {
sh->collocated_list = L0;
if (sh->slice_type == HEVC_SLICE_B)
sh->collocated_list = !get_bits1(gb);
if (sh->nb_refs[sh->collocated_list] > 1) {
sh->collocated_ref_idx = get_ue_golomb_long(gb);
if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {
av_log(s->avctx, AV_LOG_ERROR,
""Invalid collocated_ref_idx: %d.\n"",
sh->collocated_ref_idx);
return AVERROR_INVALIDDATA;
}
}
}
if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||
(s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {
int ret = pred_weight_table(s, gb);
if (ret < 0)
return ret;
}
sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);
if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {
av_log(s->avctx, AV_LOG_ERROR,
""Invalid number of merging MVP candidates: %d.\n"",
sh->max_num_merge_cand);
return AVERROR_INVALIDDATA;
}
}
sh->slice_qp_delta = get_se_golomb(gb);
if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
sh->slice_cb_qp_offset = get_se_golomb(gb);
sh->slice_cr_qp_offset = get_se_golomb(gb);
} else {
sh->slice_cb_qp_offset = 0;
sh->slice_cr_qp_offset = 0;
}
if (s->ps.pps->chroma_qp_offset_list_enabled_flag)
sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);
else
sh->cu_chroma_qp_offset_enabled_flag = 0;
if (s->ps.pps->deblocking_filter_control_present_flag) {
int deblocking_filter_override_flag = 0;
if (s->ps.pps->deblocking_filter_override_enabled_flag)
deblocking_filter_override_flag = get_bits1(gb);
if (deblocking_filter_override_flag) {
sh->disable_deblocking_filter_flag = get_bits1(gb);
if (!sh->disable_deblocking_filter_flag) {
int beta_offset_div2 = get_se_golomb(gb);
int tc_offset_div2   = get_se_golomb(gb) ;
if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||
tc_offset_div2   < -6 || tc_offset_div2   > 6) {
av_log(s->avctx, AV_LOG_ERROR,
""Invalid deblock filter offsets: %d, %d\n"",
beta_offset_div2, tc_offset_div2);
return AVERROR_INVALIDDATA;
}
sh->beta_offset = beta_offset_div2 * 2;
sh->tc_offset   =   tc_offset_div2 * 2;
}
} else {
sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;
sh->beta_offset                    = s->ps.pps->beta_offset;
sh->tc_offset                      = s->ps.pps->tc_offset;
}
} else {
sh->disable_deblocking_filter_flag = 0;
sh->beta_offset                    = 0;
sh->tc_offset                      = 0;
}
if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
(sh->slice_sample_adaptive_offset_flag[0] ||
sh->slice_sample_adaptive_offset_flag[1] ||
!sh->disable_deblocking_filter_flag)) {
sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);
} else {
sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;
}
} else if (!s->slice_initialized) {
av_log(s->avctx, AV_LOG_ERROR, ""Independent slice segment missing.\n"");
return AVERROR_INVALIDDATA;
}
sh->num_entry_point_offsets = 0;
if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {
unsigned num_entry_point_offsets = get_ue_golomb_long(gb);
if (num_entry_point_offsets > get_bits_left(gb)) {
av_log(s->avctx, AV_LOG_ERROR, ""num_entry_point_offsets %d is invalid\n"", num_entry_point_offsets);
return AVERROR_INVALIDDATA;
}
sh->num_entry_point_offsets = num_entry_point_offsets;
if (sh->num_entry_point_offsets > 0) {
int offset_len = get_ue_golomb_long(gb) + 1;
if (offset_len < 1 || offset_len > 32) {
sh->num_entry_point_offsets = 0;
av_log(s->avctx, AV_LOG_ERROR, ""offset_len %d is invalid\n"", offset_len);
return AVERROR_INVALIDDATA;
}
av_freep(&sh->entry_point_offset);
av_freep(&sh->offset);
av_freep(&sh->size);
sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));
sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
if (!sh->entry_point_offset || !sh->offset || !sh->size) {
sh->num_entry_point_offsets = 0;
av_log(s->avctx, AV_LOG_ERROR, ""Failed to allocate memory\n"");
return AVERROR(ENOMEM);
}
for (i = 0; i < sh->num_entry_point_offsets; i++) {
unsigned val = get_bits_long(gb, offset_len);
sh->entry_point_offset[i] = val + 1;             }
if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {
s->enable_parallel_tiles = 0;                 s->threads_number = 1;
} else
s->enable_parallel_tiles = 0;
} else
s->enable_parallel_tiles = 0;
}
if (s->ps.pps->slice_header_extension_present_flag) {
unsigned int length = get_ue_golomb_long(gb);
if (length*8LL > get_bits_left(gb)) {
av_log(s->avctx, AV_LOG_ERROR, ""too many slice_header_extension_data_bytes\n"");
return AVERROR_INVALIDDATA;
}
for (i = 0; i < length; i++)
skip_bits(gb, 8);      }
sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;
if (sh->slice_qp > 51 ||
sh->slice_qp < -s->ps.sps->qp_bd_offset) {
av_log(s->avctx, AV_LOG_ERROR,
""The slice_qp %d is outside the valid range ""
""[%d, 51].\n"",
sh->slice_qp,
-s->ps.sps->qp_bd_offset);
return AVERROR_INVALIDDATA;
}
sh->slice_ctb_addr_rs = sh->slice_segment_addr;
if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {
av_log(s->avctx, AV_LOG_ERROR, ""Impossible slice segment.\n"");
return AVERROR_INVALIDDATA;
}
if (get_bits_left(gb) < 0) {
av_log(s->avctx, AV_LOG_ERROR,
""Overread slice header by %d bits\n"", -get_bits_left(gb));
return AVERROR_INVALIDDATA;
}
s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;
if (!s->ps.pps->cu_qp_delta_enabled_flag)
s->HEVClc->qp_y = s->sh.slice_qp;
s->slice_initialized = 1;
s->HEVClc->tu.cu_qp_offset_cb = 0;
s->HEVClc->tu.cu_qp_offset_cr = 0;
return 0;
}","static int hls_slice_header(HEVCContext *VAR_0)
{
GetBitContext *VAR_1 = &VAR_0->HEVClc->gb;
SliceHeader *VAR_2   = &VAR_0->sh;
int VAR_3, VAR_4;
VAR_2->first_slice_in_pic_flag = get_bits1(VAR_1);
if ((IS_IDR(VAR_0) || IS_BLA(VAR_0)) && VAR_2->first_slice_in_pic_flag) {
VAR_0->seq_decode = (VAR_0->seq_decode + 1) & 0xff;
VAR_0->max_ra     = VAR_5;
if (IS_IDR(VAR_0))
ff_hevc_clear_refs(VAR_0);
}
VAR_2->no_output_of_prior_pics_flag = 0;
if (IS_IRAP(VAR_0))
VAR_2->no_output_of_prior_pics_flag = get_bits1(VAR_1);
VAR_2->pps_id = get_ue_golomb_long(VAR_1);
if (VAR_2->pps_id >= VAR_6 || !VAR_0->ps.pps_list[VAR_2->pps_id]) {
av_log(VAR_0->avctx, VAR_7, ""PPS id out of range: %d\n"", VAR_2->pps_id);
return VAR_8;
}
if (!VAR_2->first_slice_in_pic_flag &&
VAR_0->ps.pps != (HEVCPPS*)VAR_0->ps.pps_list[VAR_2->pps_id]->data) {
av_log(VAR_0->avctx, VAR_7, ""PPS changed between slices.\n"");
return VAR_8;
}
VAR_0->ps.pps = (HEVCPPS*)VAR_0->ps.pps_list[VAR_2->pps_id]->data;
if (VAR_0->nal_unit_type == VAR_9 && VAR_0->last_eos == 1)
VAR_2->no_output_of_prior_pics_flag = 1;
if (VAR_0->ps.sps != (HEVCSPS*)VAR_0->ps.sps_list[VAR_0->ps.pps->sps_id]->data) {
const HEVCSPS *VAR_10 = (HEVCSPS*)VAR_0->ps.sps_list[VAR_0->ps.pps->sps_id]->data;
const HEVCSPS *VAR_11 = VAR_0->ps.sps;
enum AVPixelFormat VAR_12;
if (VAR_11 && IS_IRAP(VAR_0) && VAR_0->nal_unit_type != VAR_9) {
if (VAR_10->width != VAR_11->width || VAR_10->height != VAR_11->height ||
VAR_10->temporal_layer[VAR_10->max_sub_layers - 1].max_dec_pic_buffering !=
VAR_11->temporal_layer[VAR_11->max_sub_layers - 1].max_dec_pic_buffering)
VAR_2->no_output_of_prior_pics_flag = 0;
}
ff_hevc_clear_refs(VAR_0);
VAR_12 = get_format(VAR_0, VAR_10);
if (VAR_12 < 0)
return VAR_12;
VAR_4 = set_sps(VAR_0, VAR_10, VAR_12);
if (VAR_4 < 0)
return VAR_4;
VAR_0->seq_decode = (VAR_0->seq_decode + 1) & 0xff;
VAR_0->max_ra     = VAR_5;
}
VAR_2->dependent_slice_segment_flag = 0;
if (!VAR_2->first_slice_in_pic_flag) {
int VAR_13;
if (VAR_0->ps.pps->dependent_slice_segments_enabled_flag)
VAR_2->dependent_slice_segment_flag = get_bits1(VAR_1);
VAR_13 = av_ceil_log2(VAR_0->ps.sps->ctb_width *
VAR_0->ps.sps->ctb_height);
VAR_2->slice_segment_addr = get_bitsz(VAR_1, VAR_13);
if (VAR_2->slice_segment_addr >= VAR_0->ps.sps->ctb_width * VAR_0->ps.sps->ctb_height) {
av_log(VAR_0->avctx, VAR_7,
""Invalid slice segment address: %u.\n"",
VAR_2->slice_segment_addr);
return VAR_8;
}
if (!VAR_2->dependent_slice_segment_flag) {
VAR_2->slice_addr = VAR_2->slice_segment_addr;
VAR_0->slice_idx++;
}
} else {
VAR_2->slice_segment_addr = VAR_2->slice_addr = 0;
VAR_0->slice_idx           = 0;
VAR_0->slice_initialized   = 0;
}
if (!VAR_2->dependent_slice_segment_flag) {
VAR_0->slice_initialized = 0;
for (VAR_3 = 0; VAR_3 < VAR_0->ps.pps->num_extra_slice_header_bits; VAR_3++)
skip_bits(VAR_1, 1);  
VAR_2->slice_type = get_ue_golomb_long(VAR_1);
if (!(VAR_2->slice_type == VAR_14 ||
VAR_2->slice_type == VAR_15 ||
VAR_2->slice_type == VAR_16)) {
av_log(VAR_0->avctx, VAR_7, ""Unknown slice type: %d.\n"",
VAR_2->slice_type);
return VAR_8;
}
if (IS_IRAP(VAR_0) && VAR_2->slice_type != VAR_14) {
av_log(VAR_0->avctx, VAR_7, ""Inter slices in an IRAP frame.\n"");
return VAR_8;
}
VAR_2->pic_output_flag = 1;
if (VAR_0->ps.pps->output_flag_present_flag)
VAR_2->pic_output_flag = get_bits1(VAR_1);
if (VAR_0->ps.sps->separate_colour_plane_flag)
VAR_2->colour_plane_id = get_bits(VAR_1, 2);
if (!IS_IDR(VAR_0)) {
int VAR_17, VAR_18;
VAR_2->pic_order_cnt_lsb = get_bits(VAR_1, VAR_0->ps.sps->log2_max_poc_lsb);
VAR_17 = ff_hevc_compute_poc(VAR_0->ps.sps, VAR_0->pocTid0, VAR_2->pic_order_cnt_lsb, VAR_0->nal_unit_type);
if (!VAR_2->first_slice_in_pic_flag && VAR_17 != VAR_0->poc) {
av_log(VAR_0->avctx, VAR_19,
""Ignoring POC change between slices: %d -> %d\n"", VAR_0->poc, VAR_17);
if (VAR_0->avctx->err_recognition & VAR_20)
return VAR_8;
VAR_17 = VAR_0->poc;
}
VAR_0->poc = VAR_17;
VAR_2->short_term_ref_pic_set_sps_flag = get_bits1(VAR_1);
VAR_18 = get_bits_left(VAR_1);
if (!VAR_2->short_term_ref_pic_set_sps_flag) {
VAR_4 = ff_hevc_decode_short_term_rps(VAR_1, VAR_0->avctx, &VAR_2->slice_rps, VAR_0->ps.sps, 1);
if (VAR_4 < 0)
return VAR_4;
VAR_2->short_term_rps = &VAR_2->slice_rps;
} else {
int VAR_21, VAR_22;
if (!VAR_0->ps.sps->nb_st_rps) {
av_log(VAR_0->avctx, VAR_7, ""No ref lists in the SPS.\n"");
return VAR_8;
}
VAR_21 = av_ceil_log2(VAR_0->ps.sps->nb_st_rps);
VAR_22 = VAR_21 > 0 ? get_bits(VAR_1, VAR_21) : 0;
VAR_2->short_term_rps = &VAR_0->ps.sps->st_rps[VAR_22];
}
VAR_2->short_term_ref_pic_set_size = VAR_18 - get_bits_left(VAR_1);
VAR_18 = get_bits_left(VAR_1);
VAR_4 = decode_lt_rps(VAR_0, &VAR_2->long_term_rps, VAR_1);
if (VAR_4 < 0) {
av_log(VAR_0->avctx, VAR_19, ""Invalid long term RPS.\n"");
if (VAR_0->avctx->err_recognition & VAR_20)
return VAR_8;
}
VAR_2->long_term_ref_pic_set_size = VAR_18 - get_bits_left(VAR_1);
if (VAR_0->ps.sps->sps_temporal_mvp_enabled_flag)
VAR_2->slice_temporal_mvp_enabled_flag = get_bits1(VAR_1);
else
VAR_2->slice_temporal_mvp_enabled_flag = 0;
} else {
VAR_0->sh.short_term_rps = NULL;
VAR_0->poc               = 0;
}
if (VAR_2->first_slice_in_pic_flag && VAR_0->temporal_id == 0 &&
VAR_0->nal_unit_type != VAR_23 &&
VAR_0->nal_unit_type != VAR_24   &&
VAR_0->nal_unit_type != VAR_25  &&
VAR_0->nal_unit_type != VAR_26  &&
VAR_0->nal_unit_type != VAR_27  &&
VAR_0->nal_unit_type != VAR_28  &&
VAR_0->nal_unit_type != VAR_29)
VAR_0->pocTid0 = VAR_0->poc;
if (VAR_0->ps.sps->sao_enabled) {
VAR_2->slice_sample_adaptive_offset_flag[0] = get_bits1(VAR_1);
if (VAR_0->ps.sps->chroma_format_idc) {
VAR_2->slice_sample_adaptive_offset_flag[1] =
VAR_2->slice_sample_adaptive_offset_flag[2] = get_bits1(VAR_1);
}
} else {
VAR_2->slice_sample_adaptive_offset_flag[0] = 0;
VAR_2->slice_sample_adaptive_offset_flag[1] = 0;
VAR_2->slice_sample_adaptive_offset_flag[2] = 0;
}
VAR_2->nb_refs[VAR_30] = VAR_2->nb_refs[VAR_31] = 0;
if (VAR_2->slice_type == VAR_15 || VAR_2->slice_type == VAR_16) {
int VAR_32;
VAR_2->nb_refs[VAR_30] = VAR_0->ps.pps->num_ref_idx_l0_default_active;
if (VAR_2->slice_type == VAR_16)
VAR_2->nb_refs[VAR_31] = VAR_0->ps.pps->num_ref_idx_l1_default_active;
if (get_bits1(VAR_1)) { 
VAR_2->nb_refs[VAR_30] = get_ue_golomb_long(VAR_1) + 1;
if (VAR_2->slice_type == VAR_16)
VAR_2->nb_refs[VAR_31] = get_ue_golomb_long(VAR_1) + 1;
}
if (VAR_2->nb_refs[VAR_30] > VAR_33 || VAR_2->nb_refs[VAR_31] > VAR_33) {
av_log(VAR_0->avctx, VAR_7, ""Too many refs: %d/%d.\n"",
VAR_2->nb_refs[VAR_30], VAR_2->nb_refs[VAR_31]);
return VAR_8;
}
VAR_2->rpl_modification_flag[0] = 0;
VAR_2->rpl_modification_flag[1] = 0;
VAR_32 = ff_hevc_frame_nb_refs(VAR_0);
if (!VAR_32) {
av_log(VAR_0->avctx, VAR_7, ""Zero refs for a frame with P or B slices.\n"");
return VAR_8;
}
if (VAR_0->ps.pps->lists_modification_present_flag && VAR_32 > 1) {
VAR_2->rpl_modification_flag[0] = get_bits1(VAR_1);
if (VAR_2->rpl_modification_flag[0]) {
for (VAR_3 = 0; VAR_3 < VAR_2->nb_refs[VAR_30]; VAR_3++)
VAR_2->list_entry_lx[0][VAR_3] = get_bits(VAR_1, av_ceil_log2(VAR_32));
}
if (VAR_2->slice_type == VAR_16) {
VAR_2->rpl_modification_flag[1] = get_bits1(VAR_1);
if (VAR_2->rpl_modification_flag[1] == 1)
for (VAR_3 = 0; VAR_3 < VAR_2->nb_refs[VAR_31]; VAR_3++)
VAR_2->list_entry_lx[1][VAR_3] = get_bits(VAR_1, av_ceil_log2(VAR_32));
}
}
if (VAR_2->slice_type == VAR_16)
VAR_2->mvd_l1_zero_flag = get_bits1(VAR_1);
if (VAR_0->ps.pps->cabac_init_present_flag)
VAR_2->cabac_init_flag = get_bits1(VAR_1);
else
VAR_2->cabac_init_flag = 0;
VAR_2->collocated_ref_idx = 0;
if (VAR_2->slice_temporal_mvp_enabled_flag) {
VAR_2->collocated_list = VAR_30;
if (VAR_2->slice_type == VAR_16)
VAR_2->collocated_list = !get_bits1(VAR_1);
if (VAR_2->nb_refs[VAR_2->collocated_list] > 1) {
VAR_2->collocated_ref_idx = get_ue_golomb_long(VAR_1);
if (VAR_2->collocated_ref_idx >= VAR_2->nb_refs[VAR_2->collocated_list]) {
av_log(VAR_0->avctx, VAR_7,
""Invalid collocated_ref_idx: %d.\n"",
VAR_2->collocated_ref_idx);
return VAR_8;
}
}
}
if ((VAR_0->ps.pps->weighted_pred_flag   && VAR_2->slice_type == VAR_15) ||
(VAR_0->ps.pps->weighted_bipred_flag && VAR_2->slice_type == VAR_16)) {
int VAR_4 = pred_weight_table(VAR_0, VAR_1);
if (VAR_4 < 0)
return VAR_4;
}
VAR_2->max_num_merge_cand = 5 - get_ue_golomb_long(VAR_1);
if (VAR_2->max_num_merge_cand < 1 || VAR_2->max_num_merge_cand > 5) {
av_log(VAR_0->avctx, VAR_7,
""Invalid number of merging MVP candidates: %d.\n"",
VAR_2->max_num_merge_cand);
return VAR_8;
}
}
VAR_2->slice_qp_delta = get_se_golomb(VAR_1);
if (VAR_0->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
VAR_2->slice_cb_qp_offset = get_se_golomb(VAR_1);
VAR_2->slice_cr_qp_offset = get_se_golomb(VAR_1);
} else {
VAR_2->slice_cb_qp_offset = 0;
VAR_2->slice_cr_qp_offset = 0;
}
if (VAR_0->ps.pps->chroma_qp_offset_list_enabled_flag)
VAR_2->cu_chroma_qp_offset_enabled_flag = get_bits1(VAR_1);
else
VAR_2->cu_chroma_qp_offset_enabled_flag = 0;
if (VAR_0->ps.pps->deblocking_filter_control_present_flag) {
int VAR_34 = 0;
if (VAR_0->ps.pps->deblocking_filter_override_enabled_flag)
VAR_34 = get_bits1(VAR_1);
if (VAR_34) {
VAR_2->disable_deblocking_filter_flag = get_bits1(VAR_1);
if (!VAR_2->disable_deblocking_filter_flag) {
int VAR_35 = get_se_golomb(VAR_1);
int VAR_36   = get_se_golomb(VAR_1) ;
if (VAR_35 < -6 || VAR_35 > 6 ||
VAR_36   < -6 || VAR_36   > 6) {
av_log(VAR_0->avctx, VAR_7,
""Invalid deblock filter offsets: %d, %d\n"",
VAR_35, VAR_36);
return VAR_8;
}
VAR_2->beta_offset = VAR_35 * 2;
VAR_2->tc_offset   =   VAR_36 * 2;
}
} else {
VAR_2->disable_deblocking_filter_flag = VAR_0->ps.pps->disable_dbf;
VAR_2->beta_offset                    = VAR_0->ps.pps->beta_offset;
VAR_2->tc_offset                      = VAR_0->ps.pps->tc_offset;
}
} else {
VAR_2->disable_deblocking_filter_flag = 0;
VAR_2->beta_offset                    = 0;
VAR_2->tc_offset                      = 0;
}
if (VAR_0->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
(VAR_2->slice_sample_adaptive_offset_flag[0] ||
VAR_2->slice_sample_adaptive_offset_flag[1] ||
!VAR_2->disable_deblocking_filter_flag)) {
VAR_2->slice_loop_filter_across_slices_enabled_flag = get_bits1(VAR_1);
} else {
VAR_2->slice_loop_filter_across_slices_enabled_flag = VAR_0->ps.pps->seq_loop_filter_across_slices_enabled_flag;
}
} else if (!VAR_0->slice_initialized) {
av_log(VAR_0->avctx, VAR_7, ""Independent slice segment missing.\n"");
return VAR_8;
}
VAR_2->num_entry_point_offsets = 0;
if (VAR_0->ps.pps->tiles_enabled_flag || VAR_0->ps.pps->entropy_coding_sync_enabled_flag) {
unsigned VAR_37 = get_ue_golomb_long(VAR_1);
if (VAR_37 > get_bits_left(VAR_1)) {
av_log(VAR_0->avctx, VAR_7, ""num_entry_point_offsets %d is invalid\n"", VAR_37);
return VAR_8;
}
VAR_2->num_entry_point_offsets = VAR_37;
if (VAR_2->num_entry_point_offsets > 0) {
int VAR_38 = get_ue_golomb_long(VAR_1) + 1;
if (VAR_38 < 1 || VAR_38 > 32) {
VAR_2->num_entry_point_offsets = 0;
av_log(VAR_0->avctx, VAR_7, ""offset_len %d is invalid\n"", VAR_38);
return VAR_8;
}
av_freep(&VAR_2->entry_point_offset);
av_freep(&VAR_2->offset);
av_freep(&VAR_2->size);
VAR_2->entry_point_offset = av_malloc_array(VAR_2->num_entry_point_offsets, sizeof(unsigned));
VAR_2->offset = av_malloc_array(VAR_2->num_entry_point_offsets, sizeof(int));
VAR_2->size = av_malloc_array(VAR_2->num_entry_point_offsets, sizeof(int));
if (!VAR_2->entry_point_offset || !VAR_2->offset || !VAR_2->size) {
VAR_2->num_entry_point_offsets = 0;
av_log(VAR_0->avctx, VAR_7, ""Failed to allocate memory\n"");
return AVERROR(VAR_39);
}
for (VAR_3 = 0; VAR_3 < VAR_2->num_entry_point_offsets; VAR_3++) {
unsigned VAR_40 = get_bits_long(VAR_1, VAR_38);
VAR_2->entry_point_offset[VAR_3] = VAR_40 + 1; 
}
if (VAR_0->threads_number > 1 && (VAR_0->ps.pps->num_tile_rows > 1 || VAR_0->ps.pps->num_tile_columns > 1)) {
VAR_0->enable_parallel_tiles = 0; 
VAR_0->threads_number = 1;
} else
VAR_0->enable_parallel_tiles = 0;
} else
VAR_0->enable_parallel_tiles = 0;
}
if (VAR_0->ps.pps->slice_header_extension_present_flag) {
unsigned int VAR_41 = get_ue_golomb_long(VAR_1);
if (VAR_41*8LL > get_bits_left(VAR_1)) {
av_log(VAR_0->avctx, VAR_7, ""too many slice_header_extension_data_bytes\n"");
return VAR_8;
}
for (VAR_3 = 0; VAR_3 < VAR_41; VAR_3++)
skip_bits(VAR_1, 8);  
}
VAR_2->slice_qp = 26U + VAR_0->ps.pps->pic_init_qp_minus26 + VAR_2->slice_qp_delta;
if (VAR_2->slice_qp > 51 ||
VAR_2->slice_qp < -VAR_0->ps.sps->qp_bd_offset) {
av_log(VAR_0->avctx, VAR_7,
""The slice_qp %d is outside the valid range ""
""[%d, 51].\n"",
VAR_2->slice_qp,
-VAR_0->ps.sps->qp_bd_offset);
return VAR_8;
}
VAR_2->slice_ctb_addr_rs = VAR_2->slice_segment_addr;
if (!VAR_0->sh.slice_ctb_addr_rs && VAR_0->sh.dependent_slice_segment_flag) {
av_log(VAR_0->avctx, VAR_7, ""Impossible slice segment.\n"");
return VAR_8;
}
if (get_bits_left(VAR_1) < 0) {
av_log(VAR_0->avctx, VAR_7,
""Overread slice header by %d bits\n"", -get_bits_left(VAR_1));
return VAR_8;
}
VAR_0->HEVClc->first_qp_group = !VAR_0->sh.dependent_slice_segment_flag;
if (!VAR_0->ps.pps->cu_qp_delta_enabled_flag)
VAR_0->HEVClc->qp_y = VAR_0->sh.slice_qp;
VAR_0->slice_initialized = 1;
VAR_0->HEVClc->tu.cu_qp_offset_cb = 0;
VAR_0->HEVClc->tu.cu_qp_offset_cr = 0;
return 0;
}",ffmpeg/9ccc633068c6fe76989f487c8932bd11886ad65b/hevcdec.c/vul/before/1.json,"static int hls_slice_header(HEVCContext *s)
{
    GetBitContext *gb = &s->HEVClc->gb;
    SliceHeader *sh   = &s->sh;
    int i, ret;

    // Coded parameters
    sh->first_slice_in_pic_flag = get_bits1(gb);
    if (s->ref && sh->first_slice_in_pic_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
        return 1; // This slice will be skiped later, do not corrupt state
    }

    if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
        if (IS_IDR(s))
            ff_hevc_clear_refs(s);
    }
    sh->no_output_of_prior_pics_flag = 0;
    if (IS_IRAP(s))
        sh->no_output_of_prior_pics_flag = get_bits1(gb);

    sh->pps_id = get_ue_golomb_long(gb);
    if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id);
        return AVERROR_INVALIDDATA;
    }
    if (!sh->first_slice_in_pic_flag &&
        s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) {
        av_log(s->avctx, AV_LOG_ERROR, ""PPS changed between slices.\n"");
        return AVERROR_INVALIDDATA;
    }
    s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data;
    if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1)
        sh->no_output_of_prior_pics_flag = 1;

    if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {
        const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;
        const HEVCSPS *last_sps = s->ps.sps;
        enum AVPixelFormat pix_fmt;

        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {
            if (sps->width != last_sps->width || sps->height != last_sps->height ||
                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=
                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)
                sh->no_output_of_prior_pics_flag = 0;
        }
        ff_hevc_clear_refs(s);

        pix_fmt = get_format(s, sps);
        if (pix_fmt < 0)
            return pix_fmt;

        ret = set_sps(s, sps, pix_fmt);
        if (ret < 0)
            return ret;

        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
    }

    sh->dependent_slice_segment_flag = 0;
    if (!sh->first_slice_in_pic_flag) {
        int slice_address_length;

        if (s->ps.pps->dependent_slice_segments_enabled_flag)
            sh->dependent_slice_segment_flag = get_bits1(gb);

        slice_address_length = av_ceil_log2(s->ps.sps->ctb_width *
                                            s->ps.sps->ctb_height);
        sh->slice_segment_addr = get_bitsz(gb, slice_address_length);
        if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Invalid slice segment address: %u.\n"",
                   sh->slice_segment_addr);
            return AVERROR_INVALIDDATA;
        }

        if (!sh->dependent_slice_segment_flag) {
            sh->slice_addr = sh->slice_segment_addr;
            s->slice_idx++;
        }
    } else {
        sh->slice_segment_addr = sh->slice_addr = 0;
        s->slice_idx           = 0;
        s->slice_initialized   = 0;
    }

    if (!sh->dependent_slice_segment_flag) {
        s->slice_initialized = 0;

        for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++)
            skip_bits(gb, 1);  // slice_reserved_undetermined_flag[]

        sh->slice_type = get_ue_golomb_long(gb);
        if (!(sh->slice_type == HEVC_SLICE_I ||
              sh->slice_type == HEVC_SLICE_P ||
              sh->slice_type == HEVC_SLICE_B)) {
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"",
                   sh->slice_type);
            return AVERROR_INVALIDDATA;
        }
        if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) {
            av_log(s->avctx, AV_LOG_ERROR, ""Inter slices in an IRAP frame.\n"");
            return AVERROR_INVALIDDATA;
        }

        // when flag is not present, picture is inferred to be output
        sh->pic_output_flag = 1;
        if (s->ps.pps->output_flag_present_flag)
            sh->pic_output_flag = get_bits1(gb);

        if (s->ps.sps->separate_colour_plane_flag)
            sh->colour_plane_id = get_bits(gb, 2);

        if (!IS_IDR(s)) {
            int poc, pos;

            sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb);
            poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type);
            if (!sh->first_slice_in_pic_flag && poc != s->poc) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Ignoring POC change between slices: %d -> %d\n"", s->poc, poc);
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
                poc = s->poc;
            }
            s->poc = poc;

            sh->short_term_ref_pic_set_sps_flag = get_bits1(gb);
            pos = get_bits_left(gb);
            if (!sh->short_term_ref_pic_set_sps_flag) {
                ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1);
                if (ret < 0)
                    return ret;

                sh->short_term_rps = &sh->slice_rps;
            } else {
                int numbits, rps_idx;

                if (!s->ps.sps->nb_st_rps) {
                    av_log(s->avctx, AV_LOG_ERROR, ""No ref lists in the SPS.\n"");
                    return AVERROR_INVALIDDATA;
                }

                numbits = av_ceil_log2(s->ps.sps->nb_st_rps);
                rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0;
                sh->short_term_rps = &s->ps.sps->st_rps[rps_idx];
            }
            sh->short_term_ref_pic_set_size = pos - get_bits_left(gb);

            pos = get_bits_left(gb);
            ret = decode_lt_rps(s, &sh->long_term_rps, gb);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING, ""Invalid long term RPS.\n"");
                if (s->avctx->err_recognition & AV_EF_EXPLODE)
                    return AVERROR_INVALIDDATA;
            }
            sh->long_term_ref_pic_set_size = pos - get_bits_left(gb);

            if (s->ps.sps->sps_temporal_mvp_enabled_flag)
                sh->slice_temporal_mvp_enabled_flag = get_bits1(gb);
            else
                sh->slice_temporal_mvp_enabled_flag = 0;
        } else {
            s->sh.short_term_rps = NULL;
            s->poc               = 0;
        }

        /* 8.3.1 */
        if (sh->first_slice_in_pic_flag && s->temporal_id == 0 &&
            s->nal_unit_type != HEVC_NAL_TRAIL_N &&
            s->nal_unit_type != HEVC_NAL_TSA_N   &&
            s->nal_unit_type != HEVC_NAL_STSA_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_N  &&
            s->nal_unit_type != HEVC_NAL_RADL_R  &&
            s->nal_unit_type != HEVC_NAL_RASL_N  &&
            s->nal_unit_type != HEVC_NAL_RASL_R)
            s->pocTid0 = s->poc;

        if (s->ps.sps->sao_enabled) {
            sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb);
            if (s->ps.sps->chroma_format_idc) {
                sh->slice_sample_adaptive_offset_flag[1] =
                sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb);
            }
        } else {
            sh->slice_sample_adaptive_offset_flag[0] = 0;
            sh->slice_sample_adaptive_offset_flag[1] = 0;
            sh->slice_sample_adaptive_offset_flag[2] = 0;
        }

        sh->nb_refs[L0] = sh->nb_refs[L1] = 0;
        if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) {
            int nb_refs;

            sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active;
            if (sh->slice_type == HEVC_SLICE_B)
                sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active;

            if (get_bits1(gb)) { // num_ref_idx_active_override_flag
                sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1;
            }
            if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) {
                av_log(s->avctx, AV_LOG_ERROR, ""Too many refs: %d/%d.\n"",
                       sh->nb_refs[L0], sh->nb_refs[L1]);
                return AVERROR_INVALIDDATA;
            }

            sh->rpl_modification_flag[0] = 0;
            sh->rpl_modification_flag[1] = 0;
            nb_refs = ff_hevc_frame_nb_refs(s);
            if (!nb_refs) {
                av_log(s->avctx, AV_LOG_ERROR, ""Zero refs for a frame with P or B slices.\n"");
                return AVERROR_INVALIDDATA;
            }

            if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) {
                sh->rpl_modification_flag[0] = get_bits1(gb);
                if (sh->rpl_modification_flag[0]) {
                    for (i = 0; i < sh->nb_refs[L0]; i++)
                        sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }

                if (sh->slice_type == HEVC_SLICE_B) {
                    sh->rpl_modification_flag[1] = get_bits1(gb);
                    if (sh->rpl_modification_flag[1] == 1)
                        for (i = 0; i < sh->nb_refs[L1]; i++)
                            sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs));
                }
            }

            if (sh->slice_type == HEVC_SLICE_B)
                sh->mvd_l1_zero_flag = get_bits1(gb);

            if (s->ps.pps->cabac_init_present_flag)
                sh->cabac_init_flag = get_bits1(gb);
            else
                sh->cabac_init_flag = 0;

            sh->collocated_ref_idx = 0;
            if (sh->slice_temporal_mvp_enabled_flag) {
                sh->collocated_list = L0;
                if (sh->slice_type == HEVC_SLICE_B)
                    sh->collocated_list = !get_bits1(gb);

                if (sh->nb_refs[sh->collocated_list] > 1) {
                    sh->collocated_ref_idx = get_ue_golomb_long(gb);
                    if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) {
                        av_log(s->avctx, AV_LOG_ERROR,
                               ""Invalid collocated_ref_idx: %d.\n"",
                               sh->collocated_ref_idx);
                        return AVERROR_INVALIDDATA;
                    }
                }
            }

            if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) ||
                (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) {
                int ret = pred_weight_table(s, gb);
                if (ret < 0)
                    return ret;
            }

            sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb);
            if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) {
                av_log(s->avctx, AV_LOG_ERROR,
                       ""Invalid number of merging MVP candidates: %d.\n"",
                       sh->max_num_merge_cand);
                return AVERROR_INVALIDDATA;
            }
        }

        sh->slice_qp_delta = get_se_golomb(gb);

        if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
            sh->slice_cb_qp_offset = get_se_golomb(gb);
            sh->slice_cr_qp_offset = get_se_golomb(gb);
        } else {
            sh->slice_cb_qp_offset = 0;
            sh->slice_cr_qp_offset = 0;
        }

        if (s->ps.pps->chroma_qp_offset_list_enabled_flag)
            sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb);
        else
            sh->cu_chroma_qp_offset_enabled_flag = 0;

        if (s->ps.pps->deblocking_filter_control_present_flag) {
            int deblocking_filter_override_flag = 0;

            if (s->ps.pps->deblocking_filter_override_enabled_flag)
                deblocking_filter_override_flag = get_bits1(gb);

            if (deblocking_filter_override_flag) {
                sh->disable_deblocking_filter_flag = get_bits1(gb);
                if (!sh->disable_deblocking_filter_flag) {
                    int beta_offset_div2 = get_se_golomb(gb);
                    int tc_offset_div2   = get_se_golomb(gb) ;
                    if (beta_offset_div2 < -6 || beta_offset_div2 > 6 ||
                        tc_offset_div2   < -6 || tc_offset_div2   > 6) {
                        av_log(s->avctx, AV_LOG_ERROR,
                            ""Invalid deblock filter offsets: %d, %d\n"",
                            beta_offset_div2, tc_offset_div2);
                        return AVERROR_INVALIDDATA;
                    }
                    sh->beta_offset = beta_offset_div2 * 2;
                    sh->tc_offset   =   tc_offset_div2 * 2;
                }
            } else {
                sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf;
                sh->beta_offset                    = s->ps.pps->beta_offset;
                sh->tc_offset                      = s->ps.pps->tc_offset;
            }
        } else {
            sh->disable_deblocking_filter_flag = 0;
            sh->beta_offset                    = 0;
            sh->tc_offset                      = 0;
        }

        if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
            (sh->slice_sample_adaptive_offset_flag[0] ||
             sh->slice_sample_adaptive_offset_flag[1] ||
             !sh->disable_deblocking_filter_flag)) {
            sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb);
        } else {
            sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag;
        }
    } else if (!s->slice_initialized) {
        av_log(s->avctx, AV_LOG_ERROR, ""Independent slice segment missing.\n"");
        return AVERROR_INVALIDDATA;
    }

    sh->num_entry_point_offsets = 0;
    if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) {
        unsigned num_entry_point_offsets = get_ue_golomb_long(gb);
        // It would be possible to bound this tighter but this here is simpler
        if (num_entry_point_offsets > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""num_entry_point_offsets %d is invalid\n"", num_entry_point_offsets);
            return AVERROR_INVALIDDATA;
        }

        sh->num_entry_point_offsets = num_entry_point_offsets;
        if (sh->num_entry_point_offsets > 0) {
            int offset_len = get_ue_golomb_long(gb) + 1;

            if (offset_len < 1 || offset_len > 32) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""offset_len %d is invalid\n"", offset_len);
                return AVERROR_INVALIDDATA;
            }

            av_freep(&sh->entry_point_offset);
            av_freep(&sh->offset);
            av_freep(&sh->size);
            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned));
            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
            if (!sh->entry_point_offset || !sh->offset || !sh->size) {
                sh->num_entry_point_offsets = 0;
                av_log(s->avctx, AV_LOG_ERROR, ""Failed to allocate memory\n"");
                return AVERROR(ENOMEM);
            }
            for (i = 0; i < sh->num_entry_point_offsets; i++) {
                unsigned val = get_bits_long(gb, offset_len);
                sh->entry_point_offset[i] = val + 1; // +1; // +1 to get the size
            }
            if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) {
                s->enable_parallel_tiles = 0; // TODO: you can enable tiles in parallel here
                s->threads_number = 1;
            } else
                s->enable_parallel_tiles = 0;
        } else
            s->enable_parallel_tiles = 0;
    }

    if (s->ps.pps->slice_header_extension_present_flag) {
        unsigned int length = get_ue_golomb_long(gb);
        if (length*8LL > get_bits_left(gb)) {
            av_log(s->avctx, AV_LOG_ERROR, ""too many slice_header_extension_data_bytes\n"");
            return AVERROR_INVALIDDATA;
        }
        for (i = 0; i < length; i++)
            skip_bits(gb, 8);  // slice_header_extension_data_byte
    }

    // Inferred parameters
    sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta;
    if (sh->slice_qp > 51 ||
        sh->slice_qp < -s->ps.sps->qp_bd_offset) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""The slice_qp %d is outside the valid range ""
               ""[%d, 51].\n"",
               sh->slice_qp,
               -s->ps.sps->qp_bd_offset);
        return AVERROR_INVALIDDATA;
    }

    sh->slice_ctb_addr_rs = sh->slice_segment_addr;

    if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Impossible slice segment.\n"");
        return AVERROR_INVALIDDATA;
    }

    if (get_bits_left(gb) < 0) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Overread slice header by %d bits\n"", -get_bits_left(gb));
        return AVERROR_INVALIDDATA;
    }

    s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag;

    if (!s->ps.pps->cu_qp_delta_enabled_flag)
        s->HEVClc->qp_y = s->sh.slice_qp;

    s->slice_initialized = 1;
    s->HEVClc->tu.cu_qp_offset_cb = 0;
    s->HEVClc->tu.cu_qp_offset_cr = 0;

    return 0;
}","static int hls_slice_header(HEVCContext *VAR_0)
{
    GetBitContext *VAR_1 = &VAR_0->HEVClc->gb;
    SliceHeader *VAR_2   = &VAR_0->sh;
    int VAR_3, VAR_4;

    /* COMMENT_0 */
    VAR_2->first_slice_in_pic_flag = get_bits1(VAR_1);
    if (VAR_0->ref && VAR_2->first_slice_in_pic_flag) {
        av_log(VAR_0->avctx, VAR_5, ""Two slices reporting being the first in the same frame.\n"");
        return 1; /* COMMENT_1 */
    }

    if ((IS_IDR(VAR_0) || IS_BLA(VAR_0)) && VAR_2->first_slice_in_pic_flag) {
        VAR_0->seq_decode = (VAR_0->seq_decode + 1) & 0xff;
        VAR_0->max_ra     = VAR_6;
        if (IS_IDR(VAR_0))
            ff_hevc_clear_refs(VAR_0);
    }
    VAR_2->no_output_of_prior_pics_flag = 0;
    if (IS_IRAP(VAR_0))
        VAR_2->no_output_of_prior_pics_flag = get_bits1(VAR_1);

    VAR_2->pps_id = get_ue_golomb_long(VAR_1);
    if (VAR_2->pps_id >= VAR_7 || !VAR_0->ps.pps_list[VAR_2->pps_id]) {
        av_log(VAR_0->avctx, VAR_5, ""PPS id out of range: %d\n"", VAR_2->pps_id);
        return VAR_8;
    }
    if (!VAR_2->first_slice_in_pic_flag &&
        VAR_0->ps.pps != (HEVCPPS*)VAR_0->ps.pps_list[VAR_2->pps_id]->data) {
        av_log(VAR_0->avctx, VAR_5, ""PPS changed between slices.\n"");
        return VAR_8;
    }
    VAR_0->ps.pps = (HEVCPPS*)VAR_0->ps.pps_list[VAR_2->pps_id]->data;
    if (VAR_0->nal_unit_type == VAR_9 && VAR_0->last_eos == 1)
        VAR_2->no_output_of_prior_pics_flag = 1;

    if (VAR_0->ps.sps != (HEVCSPS*)VAR_0->ps.sps_list[VAR_0->ps.pps->sps_id]->data) {
        const HEVCSPS *VAR_10 = (HEVCSPS*)VAR_0->ps.sps_list[VAR_0->ps.pps->sps_id]->data;
        const HEVCSPS *VAR_11 = VAR_0->ps.sps;
        enum AVPixelFormat VAR_12;

        if (VAR_11 && IS_IRAP(VAR_0) && VAR_0->nal_unit_type != VAR_9) {
            if (VAR_10->width != VAR_11->width || VAR_10->height != VAR_11->height ||
                VAR_10->temporal_layer[VAR_10->max_sub_layers - 1].max_dec_pic_buffering !=
                VAR_11->temporal_layer[VAR_11->max_sub_layers - 1].max_dec_pic_buffering)
                VAR_2->no_output_of_prior_pics_flag = 0;
        }
        ff_hevc_clear_refs(VAR_0);

        VAR_12 = get_format(VAR_0, VAR_10);
        if (VAR_12 < 0)
            return VAR_12;

        VAR_4 = set_sps(VAR_0, VAR_10, VAR_12);
        if (VAR_4 < 0)
            return VAR_4;

        VAR_0->seq_decode = (VAR_0->seq_decode + 1) & 0xff;
        VAR_0->max_ra     = VAR_6;
    }

    VAR_2->dependent_slice_segment_flag = 0;
    if (!VAR_2->first_slice_in_pic_flag) {
        int VAR_13;

        if (VAR_0->ps.pps->dependent_slice_segments_enabled_flag)
            VAR_2->dependent_slice_segment_flag = get_bits1(VAR_1);

        VAR_13 = av_ceil_log2(VAR_0->ps.sps->ctb_width *
                                            VAR_0->ps.sps->ctb_height);
        VAR_2->slice_segment_addr = get_bitsz(VAR_1, VAR_13);
        if (VAR_2->slice_segment_addr >= VAR_0->ps.sps->ctb_width * VAR_0->ps.sps->ctb_height) {
            av_log(VAR_0->avctx, VAR_5,
                   ""Invalid slice segment address: %u.\n"",
                   VAR_2->slice_segment_addr);
            return VAR_8;
        }

        if (!VAR_2->dependent_slice_segment_flag) {
            VAR_2->slice_addr = VAR_2->slice_segment_addr;
            VAR_0->slice_idx++;
        }
    } else {
        VAR_2->slice_segment_addr = VAR_2->slice_addr = 0;
        VAR_0->slice_idx           = 0;
        VAR_0->slice_initialized   = 0;
    }

    if (!VAR_2->dependent_slice_segment_flag) {
        VAR_0->slice_initialized = 0;

        for (VAR_3 = 0; VAR_3 < VAR_0->ps.pps->num_extra_slice_header_bits; VAR_3++)
            skip_bits(VAR_1, 1);  /* COMMENT_2 */

        VAR_2->slice_type = get_ue_golomb_long(VAR_1);
        if (!(VAR_2->slice_type == VAR_14 ||
              VAR_2->slice_type == VAR_15 ||
              VAR_2->slice_type == VAR_16)) {
            av_log(VAR_0->avctx, VAR_5, ""Unknown slice type: %d.\n"",
                   VAR_2->slice_type);
            return VAR_8;
        }
        if (IS_IRAP(VAR_0) && VAR_2->slice_type != VAR_14) {
            av_log(VAR_0->avctx, VAR_5, ""Inter slices in an IRAP frame.\n"");
            return VAR_8;
        }

        /* COMMENT_3 */
        VAR_2->pic_output_flag = 1;
        if (VAR_0->ps.pps->output_flag_present_flag)
            VAR_2->pic_output_flag = get_bits1(VAR_1);

        if (VAR_0->ps.sps->separate_colour_plane_flag)
            VAR_2->colour_plane_id = get_bits(VAR_1, 2);

        if (!IS_IDR(VAR_0)) {
            int VAR_17, VAR_18;

            VAR_2->pic_order_cnt_lsb = get_bits(VAR_1, VAR_0->ps.sps->log2_max_poc_lsb);
            VAR_17 = ff_hevc_compute_poc(VAR_0->ps.sps, VAR_0->pocTid0, VAR_2->pic_order_cnt_lsb, VAR_0->nal_unit_type);
            if (!VAR_2->first_slice_in_pic_flag && VAR_17 != VAR_0->poc) {
                av_log(VAR_0->avctx, VAR_19,
                       ""Ignoring POC change between slices: %d -> %d\n"", VAR_0->poc, VAR_17);
                if (VAR_0->avctx->err_recognition & VAR_20)
                    return VAR_8;
                VAR_17 = VAR_0->poc;
            }
            VAR_0->poc = VAR_17;

            VAR_2->short_term_ref_pic_set_sps_flag = get_bits1(VAR_1);
            VAR_18 = get_bits_left(VAR_1);
            if (!VAR_2->short_term_ref_pic_set_sps_flag) {
                VAR_4 = ff_hevc_decode_short_term_rps(VAR_1, VAR_0->avctx, &VAR_2->slice_rps, VAR_0->ps.sps, 1);
                if (VAR_4 < 0)
                    return VAR_4;

                VAR_2->short_term_rps = &VAR_2->slice_rps;
            } else {
                int VAR_21, VAR_22;

                if (!VAR_0->ps.sps->nb_st_rps) {
                    av_log(VAR_0->avctx, VAR_5, ""No ref lists in the SPS.\n"");
                    return VAR_8;
                }

                VAR_21 = av_ceil_log2(VAR_0->ps.sps->nb_st_rps);
                VAR_22 = VAR_21 > 0 ? get_bits(VAR_1, VAR_21) : 0;
                VAR_2->short_term_rps = &VAR_0->ps.sps->st_rps[VAR_22];
            }
            VAR_2->short_term_ref_pic_set_size = VAR_18 - get_bits_left(VAR_1);

            VAR_18 = get_bits_left(VAR_1);
            VAR_4 = decode_lt_rps(VAR_0, &VAR_2->long_term_rps, VAR_1);
            if (VAR_4 < 0) {
                av_log(VAR_0->avctx, VAR_19, ""Invalid long term RPS.\n"");
                if (VAR_0->avctx->err_recognition & VAR_20)
                    return VAR_8;
            }
            VAR_2->long_term_ref_pic_set_size = VAR_18 - get_bits_left(VAR_1);

            if (VAR_0->ps.sps->sps_temporal_mvp_enabled_flag)
                VAR_2->slice_temporal_mvp_enabled_flag = get_bits1(VAR_1);
            else
                VAR_2->slice_temporal_mvp_enabled_flag = 0;
        } else {
            VAR_0->sh.short_term_rps = NULL;
            VAR_0->poc               = 0;
        }

        /* COMMENT_4 */
        if (VAR_2->first_slice_in_pic_flag && VAR_0->temporal_id == 0 &&
            VAR_0->nal_unit_type != VAR_23 &&
            VAR_0->nal_unit_type != VAR_24   &&
            VAR_0->nal_unit_type != VAR_25  &&
            VAR_0->nal_unit_type != VAR_26  &&
            VAR_0->nal_unit_type != VAR_27  &&
            VAR_0->nal_unit_type != VAR_28  &&
            VAR_0->nal_unit_type != VAR_29)
            VAR_0->pocTid0 = VAR_0->poc;

        if (VAR_0->ps.sps->sao_enabled) {
            VAR_2->slice_sample_adaptive_offset_flag[0] = get_bits1(VAR_1);
            if (VAR_0->ps.sps->chroma_format_idc) {
                VAR_2->slice_sample_adaptive_offset_flag[1] =
                VAR_2->slice_sample_adaptive_offset_flag[2] = get_bits1(VAR_1);
            }
        } else {
            VAR_2->slice_sample_adaptive_offset_flag[0] = 0;
            VAR_2->slice_sample_adaptive_offset_flag[1] = 0;
            VAR_2->slice_sample_adaptive_offset_flag[2] = 0;
        }

        VAR_2->nb_refs[VAR_30] = VAR_2->nb_refs[VAR_31] = 0;
        if (VAR_2->slice_type == VAR_15 || VAR_2->slice_type == VAR_16) {
            int VAR_32;

            VAR_2->nb_refs[VAR_30] = VAR_0->ps.pps->num_ref_idx_l0_default_active;
            if (VAR_2->slice_type == VAR_16)
                VAR_2->nb_refs[VAR_31] = VAR_0->ps.pps->num_ref_idx_l1_default_active;

            if (get_bits1(VAR_1)) { /* COMMENT_5 */
                VAR_2->nb_refs[VAR_30] = get_ue_golomb_long(VAR_1) + 1;
                if (VAR_2->slice_type == VAR_16)
                    VAR_2->nb_refs[VAR_31] = get_ue_golomb_long(VAR_1) + 1;
            }
            if (VAR_2->nb_refs[VAR_30] > VAR_33 || VAR_2->nb_refs[VAR_31] > VAR_33) {
                av_log(VAR_0->avctx, VAR_5, ""Too many refs: %d/%d.\n"",
                       VAR_2->nb_refs[VAR_30], VAR_2->nb_refs[VAR_31]);
                return VAR_8;
            }

            VAR_2->rpl_modification_flag[0] = 0;
            VAR_2->rpl_modification_flag[1] = 0;
            VAR_32 = ff_hevc_frame_nb_refs(VAR_0);
            if (!VAR_32) {
                av_log(VAR_0->avctx, VAR_5, ""Zero refs for a frame with P or B slices.\n"");
                return VAR_8;
            }

            if (VAR_0->ps.pps->lists_modification_present_flag && VAR_32 > 1) {
                VAR_2->rpl_modification_flag[0] = get_bits1(VAR_1);
                if (VAR_2->rpl_modification_flag[0]) {
                    for (VAR_3 = 0; VAR_3 < VAR_2->nb_refs[VAR_30]; VAR_3++)
                        VAR_2->list_entry_lx[0][VAR_3] = get_bits(VAR_1, av_ceil_log2(VAR_32));
                }

                if (VAR_2->slice_type == VAR_16) {
                    VAR_2->rpl_modification_flag[1] = get_bits1(VAR_1);
                    if (VAR_2->rpl_modification_flag[1] == 1)
                        for (VAR_3 = 0; VAR_3 < VAR_2->nb_refs[VAR_31]; VAR_3++)
                            VAR_2->list_entry_lx[1][VAR_3] = get_bits(VAR_1, av_ceil_log2(VAR_32));
                }
            }

            if (VAR_2->slice_type == VAR_16)
                VAR_2->mvd_l1_zero_flag = get_bits1(VAR_1);

            if (VAR_0->ps.pps->cabac_init_present_flag)
                VAR_2->cabac_init_flag = get_bits1(VAR_1);
            else
                VAR_2->cabac_init_flag = 0;

            VAR_2->collocated_ref_idx = 0;
            if (VAR_2->slice_temporal_mvp_enabled_flag) {
                VAR_2->collocated_list = VAR_30;
                if (VAR_2->slice_type == VAR_16)
                    VAR_2->collocated_list = !get_bits1(VAR_1);

                if (VAR_2->nb_refs[VAR_2->collocated_list] > 1) {
                    VAR_2->collocated_ref_idx = get_ue_golomb_long(VAR_1);
                    if (VAR_2->collocated_ref_idx >= VAR_2->nb_refs[VAR_2->collocated_list]) {
                        av_log(VAR_0->avctx, VAR_5,
                               ""Invalid collocated_ref_idx: %d.\n"",
                               VAR_2->collocated_ref_idx);
                        return VAR_8;
                    }
                }
            }

            if ((VAR_0->ps.pps->weighted_pred_flag   && VAR_2->slice_type == VAR_15) ||
                (VAR_0->ps.pps->weighted_bipred_flag && VAR_2->slice_type == VAR_16)) {
                int VAR_4 = pred_weight_table(VAR_0, VAR_1);
                if (VAR_4 < 0)
                    return VAR_4;
            }

            VAR_2->max_num_merge_cand = 5 - get_ue_golomb_long(VAR_1);
            if (VAR_2->max_num_merge_cand < 1 || VAR_2->max_num_merge_cand > 5) {
                av_log(VAR_0->avctx, VAR_5,
                       ""Invalid number of merging MVP candidates: %d.\n"",
                       VAR_2->max_num_merge_cand);
                return VAR_8;
            }
        }

        VAR_2->slice_qp_delta = get_se_golomb(VAR_1);

        if (VAR_0->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) {
            VAR_2->slice_cb_qp_offset = get_se_golomb(VAR_1);
            VAR_2->slice_cr_qp_offset = get_se_golomb(VAR_1);
        } else {
            VAR_2->slice_cb_qp_offset = 0;
            VAR_2->slice_cr_qp_offset = 0;
        }

        if (VAR_0->ps.pps->chroma_qp_offset_list_enabled_flag)
            VAR_2->cu_chroma_qp_offset_enabled_flag = get_bits1(VAR_1);
        else
            VAR_2->cu_chroma_qp_offset_enabled_flag = 0;

        if (VAR_0->ps.pps->deblocking_filter_control_present_flag) {
            int VAR_34 = 0;

            if (VAR_0->ps.pps->deblocking_filter_override_enabled_flag)
                VAR_34 = get_bits1(VAR_1);

            if (VAR_34) {
                VAR_2->disable_deblocking_filter_flag = get_bits1(VAR_1);
                if (!VAR_2->disable_deblocking_filter_flag) {
                    int VAR_35 = get_se_golomb(VAR_1);
                    int VAR_36   = get_se_golomb(VAR_1) ;
                    if (VAR_35 < -6 || VAR_35 > 6 ||
                        VAR_36   < -6 || VAR_36   > 6) {
                        av_log(VAR_0->avctx, VAR_5,
                            ""Invalid deblock filter offsets: %d, %d\n"",
                            VAR_35, VAR_36);
                        return VAR_8;
                    }
                    VAR_2->beta_offset = VAR_35 * 2;
                    VAR_2->tc_offset   =   VAR_36 * 2;
                }
            } else {
                VAR_2->disable_deblocking_filter_flag = VAR_0->ps.pps->disable_dbf;
                VAR_2->beta_offset                    = VAR_0->ps.pps->beta_offset;
                VAR_2->tc_offset                      = VAR_0->ps.pps->tc_offset;
            }
        } else {
            VAR_2->disable_deblocking_filter_flag = 0;
            VAR_2->beta_offset                    = 0;
            VAR_2->tc_offset                      = 0;
        }

        if (VAR_0->ps.pps->seq_loop_filter_across_slices_enabled_flag &&
            (VAR_2->slice_sample_adaptive_offset_flag[0] ||
             VAR_2->slice_sample_adaptive_offset_flag[1] ||
             !VAR_2->disable_deblocking_filter_flag)) {
            VAR_2->slice_loop_filter_across_slices_enabled_flag = get_bits1(VAR_1);
        } else {
            VAR_2->slice_loop_filter_across_slices_enabled_flag = VAR_0->ps.pps->seq_loop_filter_across_slices_enabled_flag;
        }
    } else if (!VAR_0->slice_initialized) {
        av_log(VAR_0->avctx, VAR_5, ""Independent slice segment missing.\n"");
        return VAR_8;
    }

    VAR_2->num_entry_point_offsets = 0;
    if (VAR_0->ps.pps->tiles_enabled_flag || VAR_0->ps.pps->entropy_coding_sync_enabled_flag) {
        unsigned VAR_37 = get_ue_golomb_long(VAR_1);
        /* COMMENT_6 */
        if (VAR_37 > get_bits_left(VAR_1)) {
            av_log(VAR_0->avctx, VAR_5, ""num_entry_point_offsets %d is invalid\n"", VAR_37);
            return VAR_8;
        }

        VAR_2->num_entry_point_offsets = VAR_37;
        if (VAR_2->num_entry_point_offsets > 0) {
            int VAR_38 = get_ue_golomb_long(VAR_1) + 1;

            if (VAR_38 < 1 || VAR_38 > 32) {
                VAR_2->num_entry_point_offsets = 0;
                av_log(VAR_0->avctx, VAR_5, ""offset_len %d is invalid\n"", VAR_38);
                return VAR_8;
            }

            av_freep(&VAR_2->entry_point_offset);
            av_freep(&VAR_2->offset);
            av_freep(&VAR_2->size);
            VAR_2->entry_point_offset = av_malloc_array(VAR_2->num_entry_point_offsets, sizeof(unsigned));
            VAR_2->offset = av_malloc_array(VAR_2->num_entry_point_offsets, sizeof(int));
            VAR_2->size = av_malloc_array(VAR_2->num_entry_point_offsets, sizeof(int));
            if (!VAR_2->entry_point_offset || !VAR_2->offset || !VAR_2->size) {
                VAR_2->num_entry_point_offsets = 0;
                av_log(VAR_0->avctx, VAR_5, ""Failed to allocate memory\n"");
                return AVERROR(VAR_39);
            }
            for (VAR_3 = 0; VAR_3 < VAR_2->num_entry_point_offsets; VAR_3++) {
                unsigned VAR_40 = get_bits_long(VAR_1, VAR_38);
                VAR_2->entry_point_offset[VAR_3] = VAR_40 + 1; /* COMMENT_7 */
            }
            if (VAR_0->threads_number > 1 && (VAR_0->ps.pps->num_tile_rows > 1 || VAR_0->ps.pps->num_tile_columns > 1)) {
                VAR_0->enable_parallel_tiles = 0; /* COMMENT_8 */
                VAR_0->threads_number = 1;
            } else
                VAR_0->enable_parallel_tiles = 0;
        } else
            VAR_0->enable_parallel_tiles = 0;
    }

    if (VAR_0->ps.pps->slice_header_extension_present_flag) {
        unsigned int VAR_41 = get_ue_golomb_long(VAR_1);
        if (VAR_41*8LL > get_bits_left(VAR_1)) {
            av_log(VAR_0->avctx, VAR_5, ""too many slice_header_extension_data_bytes\n"");
            return VAR_8;
        }
        for (VAR_3 = 0; VAR_3 < VAR_41; VAR_3++)
            skip_bits(VAR_1, 8);  /* COMMENT_9 */
    }

    /* COMMENT_10 */
    VAR_2->slice_qp = 26U + VAR_0->ps.pps->pic_init_qp_minus26 + VAR_2->slice_qp_delta;
    if (VAR_2->slice_qp > 51 ||
        VAR_2->slice_qp < -VAR_0->ps.sps->qp_bd_offset) {
        av_log(VAR_0->avctx, VAR_5,
               ""The slice_qp %d is outside the valid range ""
               ""[%d, 51].\n"",
               VAR_2->slice_qp,
               -VAR_0->ps.sps->qp_bd_offset);
        return VAR_8;
    }

    VAR_2->slice_ctb_addr_rs = VAR_2->slice_segment_addr;

    if (!VAR_0->sh.slice_ctb_addr_rs && VAR_0->sh.dependent_slice_segment_flag) {
        av_log(VAR_0->avctx, VAR_5, ""Impossible slice segment.\n"");
        return VAR_8;
    }

    if (get_bits_left(VAR_1) < 0) {
        av_log(VAR_0->avctx, VAR_5,
               ""Overread slice header by %d bits\n"", -get_bits_left(VAR_1));
        return VAR_8;
    }

    VAR_0->HEVClc->first_qp_group = !VAR_0->sh.dependent_slice_segment_flag;

    if (!VAR_0->ps.pps->cu_qp_delta_enabled_flag)
        VAR_0->HEVClc->qp_y = VAR_0->sh.slice_qp;

    VAR_0->slice_initialized = 1;
    VAR_0->HEVClc->tu.cu_qp_offset_cb = 0;
    VAR_0->HEVClc->tu.cu_qp_offset_cr = 0;

    return 0;
}",ffmpeg/9ccc633068c6fe76989f487c8932bd11886ad65b/hevcdec.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,11 @@
 
     // Coded parameters
     sh->first_slice_in_pic_flag = get_bits1(gb);
+    if (s->ref && sh->first_slice_in_pic_flag) {
+        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
+        return 1; // This slice will be skiped later, do not corrupt state
+    }
+
     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;","{'deleted_lines': [], 'added_lines': ['    if (s->ref && sh->first_slice_in_pic_flag) {', '        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\\n"");', '        return 1; // This slice will be skiped later, do not corrupt state', '    }', '']}",True,"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",8.8,HIGH,2,test,2019-03-23T19:55:08Z,2
CVE-2019-11338,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ffmpeg,"avcodec/hevcdec: Avoid only partly skiping duplicate first slices

Fixes: NULL pointer dereference and out of array access
Fixes: 13871/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432
Fixes: 13845/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304

This also fixes the return code for explode mode

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Reviewed-by: James Almer <jamrial@gmail.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
(cherry picked from commit 54655623a82632e7624714d7b2a3e039dc5faa7e)
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",9ccc633068c6fe76989f487c8932bd11886ad65b,https://github.com/FFmpeg/FFmpeg/commit/9ccc633068c6fe76989f487c8932bd11886ad65b,libavcodec/hevcdec.c,decode_nal_unit,"static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
{
HEVCLocalContext *lc = s->HEVClc;
GetBitContext *gb    = &lc->gb;
int ctb_addr_ts, ret;
*gb              = nal->gb;
s->nal_unit_type = nal->type;
s->temporal_id   = nal->temporal_id;
switch (s->nal_unit_type) {
case HEVC_NAL_VPS:
ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_SPS:
ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
s->apply_defdispwin);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_PPS:
ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_SEI_PREFIX:
case HEVC_NAL_SEI_SUFFIX:
ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_TRAIL_R:
case HEVC_NAL_TRAIL_N:
case HEVC_NAL_TSA_N:
case HEVC_NAL_TSA_R:
case HEVC_NAL_STSA_N:
case HEVC_NAL_STSA_R:
case HEVC_NAL_BLA_W_LP:
case HEVC_NAL_BLA_W_RADL:
case HEVC_NAL_BLA_N_LP:
case HEVC_NAL_IDR_W_RADL:
case HEVC_NAL_IDR_N_LP:
case HEVC_NAL_CRA_NUT:
case HEVC_NAL_RADL_N:
case HEVC_NAL_RADL_R:
case HEVC_NAL_RASL_N:
case HEVC_NAL_RASL_R:
ret = hls_slice_header(s);
if (ret < 0)
return ret;
if (s->sh.first_slice_in_pic_flag) {
if (s->ref) {
av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
goto fail;
}
if (s->max_ra == INT_MAX) {
if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
s->max_ra = s->poc;
} else {
if (IS_IDR(s))
s->max_ra = INT_MIN;
}
}
if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
s->poc <= s->max_ra) {
s->is_decoded = 0;
break;
} else {
if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
s->max_ra = INT_MIN;
}
ret = hevc_frame_start(s);
if (ret < 0)
return ret;
} else if (!s->ref) {
av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
goto fail;
}
if (s->nal_unit_type != s->first_nal_type) {
av_log(s->avctx, AV_LOG_ERROR,
""Non-matching NAL types of the VCL NALUs: %d %d\n"",
s->first_nal_type, s->nal_unit_type);
return AVERROR_INVALIDDATA;
}
if (!s->sh.dependent_slice_segment_flag &&
s->sh.slice_type != HEVC_SLICE_I) {
ret = ff_hevc_slice_rpl(s);
if (ret < 0) {
av_log(s->avctx, AV_LOG_WARNING,
""Error constructing the reference lists for the current slice.\n"");
goto fail;
}
}
if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
if (ret < 0)
goto fail;
}
if (s->avctx->hwaccel) {
ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
if (ret < 0)
goto fail;
} else {
if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
ctb_addr_ts = hls_slice_data_wpp(s, nal);
else
ctb_addr_ts = hls_slice_data(s);
if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
s->is_decoded = 1;
}
if (ctb_addr_ts < 0) {
ret = ctb_addr_ts;
goto fail;
}
}
break;
case HEVC_NAL_EOS_NUT:
case HEVC_NAL_EOB_NUT:
s->seq_decode = (s->seq_decode + 1) & 0xff;
s->max_ra     = INT_MAX;
break;
case HEVC_NAL_AUD:
case HEVC_NAL_FD_NUT:
break;
default:
av_log(s->avctx, AV_LOG_INFO,
""Skipping NAL unit %d\n"", s->nal_unit_type);
}
return 0;
fail:
if (s->avctx->err_recognition & AV_EF_EXPLODE)
return ret;
return 0;
}","static int decode_nal_unit(HEVCContext *VAR_0, const H2645NAL *VAR_1)
{
HEVCLocalContext *VAR_2 = VAR_0->HEVClc;
GetBitContext *VAR_3    = &VAR_2->gb;
int VAR_4, VAR_5;
*VAR_3              = VAR_1->gb;
VAR_0->nal_unit_type = VAR_1->type;
VAR_0->temporal_id   = VAR_1->temporal_id;
switch (VAR_0->nal_unit_type) {
case VAR_6:
VAR_5 = ff_hevc_decode_nal_vps(VAR_3, VAR_0->avctx, &VAR_0->ps);
if (VAR_5 < 0)
goto fail;
break;
case VAR_7:
VAR_5 = ff_hevc_decode_nal_sps(VAR_3, VAR_0->avctx, &VAR_0->ps,
VAR_0->apply_defdispwin);
if (VAR_5 < 0)
goto fail;
break;
case VAR_8:
VAR_5 = ff_hevc_decode_nal_pps(VAR_3, VAR_0->avctx, &VAR_0->ps);
if (VAR_5 < 0)
goto fail;
break;
case VAR_9:
case VAR_10:
VAR_5 = ff_hevc_decode_nal_sei(VAR_3, VAR_0->avctx, &VAR_0->sei, &VAR_0->ps, VAR_0->nal_unit_type);
if (VAR_5 < 0)
goto fail;
break;
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26:
VAR_5 = hls_slice_header(VAR_0);
if (VAR_5 < 0)
return VAR_5;
if (VAR_0->sh.first_slice_in_pic_flag) {
if (VAR_0->ref) {
av_log(VAR_0->avctx, VAR_27, ""Two slices reporting being the first in the same frame.\n"");
goto fail;
}
if (VAR_0->max_ra == VAR_28) {
if (VAR_0->nal_unit_type == VAR_22 || IS_BLA(VAR_0)) {
VAR_0->max_ra = VAR_0->poc;
} else {
if (IS_IDR(VAR_0))
VAR_0->max_ra = VAR_29;
}
}
if ((VAR_0->nal_unit_type == VAR_26 || VAR_0->nal_unit_type == VAR_25) &&
VAR_0->poc <= VAR_0->max_ra) {
VAR_0->is_decoded = 0;
break;
} else {
if (VAR_0->nal_unit_type == VAR_26 && VAR_0->poc > VAR_0->max_ra)
VAR_0->max_ra = VAR_29;
}
VAR_5 = hevc_frame_start(VAR_0);
if (VAR_5 < 0)
return VAR_5;
} else if (!VAR_0->ref) {
av_log(VAR_0->avctx, VAR_27, ""First slice in a frame missing.\n"");
goto fail;
}
if (VAR_0->nal_unit_type != VAR_0->first_nal_type) {
av_log(VAR_0->avctx, VAR_27,
""Non-matching NAL types of the VCL NALUs: %d %d\n"",
VAR_0->first_nal_type, VAR_0->nal_unit_type);
return VAR_30;
}
if (!VAR_0->sh.dependent_slice_segment_flag &&
VAR_0->sh.slice_type != VAR_31) {
VAR_5 = ff_hevc_slice_rpl(VAR_0);
if (VAR_5 < 0) {
av_log(VAR_0->avctx, VAR_32,
""Error constructing the reference lists for the current slice.\n"");
goto fail;
}
}
if (VAR_0->sh.first_slice_in_pic_flag && VAR_0->avctx->hwaccel) {
VAR_5 = VAR_0->avctx->hwaccel->start_frame(VAR_0->avctx, NULL, 0);
if (VAR_5 < 0)
goto fail;
}
if (VAR_0->avctx->hwaccel) {
VAR_5 = VAR_0->avctx->hwaccel->decode_slice(VAR_0->avctx, VAR_1->raw_data, VAR_1->raw_size);
if (VAR_5 < 0)
goto fail;
} else {
if (VAR_0->threads_number > 1 && VAR_0->sh.num_entry_point_offsets > 0)
VAR_4 = hls_slice_data_wpp(VAR_0, VAR_1);
else
VAR_4 = hls_slice_data(VAR_0);
if (VAR_4 >= (VAR_0->ps.sps->ctb_width * VAR_0->ps.sps->ctb_height)) {
VAR_0->is_decoded = 1;
}
if (VAR_4 < 0) {
VAR_5 = VAR_4;
goto fail;
}
}
break;
case VAR_33:
case VAR_34:
VAR_0->seq_decode = (VAR_0->seq_decode + 1) & 0xff;
VAR_0->max_ra     = VAR_28;
break;
case VAR_35:
case VAR_36:
break;
default:
av_log(VAR_0->avctx, VAR_37,
""Skipping NAL unit %d\n"", VAR_0->nal_unit_type);
}
return 0;
fail:
if (VAR_0->avctx->err_recognition & VAR_38)
return VAR_5;
return 0;
}",ffmpeg/9ccc633068c6fe76989f487c8932bd11886ad65b/hevcdec.c/vul/before/0.json,"static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
{
    HEVCLocalContext *lc = s->HEVClc;
    GetBitContext *gb    = &lc->gb;
    int ctb_addr_ts, ret;

    *gb              = nal->gb;
    s->nal_unit_type = nal->type;
    s->temporal_id   = nal->temporal_id;

    switch (s->nal_unit_type) {
    case HEVC_NAL_VPS:
        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SPS:
        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
                                     s->apply_defdispwin);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_PPS:
        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SEI_PREFIX:
    case HEVC_NAL_SEI_SUFFIX:
        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_TRAIL_R:
    case HEVC_NAL_TRAIL_N:
    case HEVC_NAL_TSA_N:
    case HEVC_NAL_TSA_R:
    case HEVC_NAL_STSA_N:
    case HEVC_NAL_STSA_R:
    case HEVC_NAL_BLA_W_LP:
    case HEVC_NAL_BLA_W_RADL:
    case HEVC_NAL_BLA_N_LP:
    case HEVC_NAL_IDR_W_RADL:
    case HEVC_NAL_IDR_N_LP:
    case HEVC_NAL_CRA_NUT:
    case HEVC_NAL_RADL_N:
    case HEVC_NAL_RADL_R:
    case HEVC_NAL_RASL_N:
    case HEVC_NAL_RASL_R:
        ret = hls_slice_header(s);
        if (ret < 0)
            return ret;
        if (ret == 1) {
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }


        if (s->sh.first_slice_in_pic_flag) {
            if (s->max_ra == INT_MAX) {
                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                    s->max_ra = s->poc;
                } else {
                    if (IS_IDR(s))
                        s->max_ra = INT_MIN;
                }
            }

            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
                s->poc <= s->max_ra) {
                s->is_decoded = 0;
                break;
            } else {
                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
                    s->max_ra = INT_MIN;
            }

            ret = hevc_frame_start(s);
            if (ret < 0)
                return ret;
        } else if (!s->ref) {
            av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
            goto fail;
        }

        if (s->nal_unit_type != s->first_nal_type) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Non-matching NAL types of the VCL NALUs: %d %d\n"",
                   s->first_nal_type, s->nal_unit_type);
            return AVERROR_INVALIDDATA;
        }

        if (!s->sh.dependent_slice_segment_flag &&
            s->sh.slice_type != HEVC_SLICE_I) {
            ret = ff_hevc_slice_rpl(s);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Error constructing the reference lists for the current slice.\n"");
                goto fail;
            }
        }

        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
            if (ret < 0)
                goto fail;
        }

        if (s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
            if (ret < 0)
                goto fail;
        } else {
            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
                ctb_addr_ts = hls_slice_data_wpp(s, nal);
            else
                ctb_addr_ts = hls_slice_data(s);
            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
                s->is_decoded = 1;
            }

            if (ctb_addr_ts < 0) {
                ret = ctb_addr_ts;
                goto fail;
            }
        }
        break;
    case HEVC_NAL_EOS_NUT:
    case HEVC_NAL_EOB_NUT:
        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
        break;
    case HEVC_NAL_AUD:
    case HEVC_NAL_FD_NUT:
        break;
    default:
        av_log(s->avctx, AV_LOG_INFO,
               ""Skipping NAL unit %d\n"", s->nal_unit_type);
    }

    return 0;
fail:
    if (s->avctx->err_recognition & AV_EF_EXPLODE)
        return ret;
    return 0;
}","static int decode_nal_unit(HEVCContext *VAR_0, const H2645NAL *VAR_1)
{
    HEVCLocalContext *VAR_2 = VAR_0->HEVClc;
    GetBitContext *VAR_3    = &VAR_2->gb;
    int VAR_4, VAR_5;

    *VAR_3              = VAR_1->gb;
    VAR_0->nal_unit_type = VAR_1->type;
    VAR_0->temporal_id   = VAR_1->temporal_id;

    switch (VAR_0->nal_unit_type) {
    case VAR_6:
        VAR_5 = ff_hevc_decode_nal_vps(VAR_3, VAR_0->avctx, &VAR_0->ps);
        if (VAR_5 < 0)
            goto fail;
        break;
    case VAR_7:
        VAR_5 = ff_hevc_decode_nal_sps(VAR_3, VAR_0->avctx, &VAR_0->ps,
                                     VAR_0->apply_defdispwin);
        if (VAR_5 < 0)
            goto fail;
        break;
    case VAR_8:
        VAR_5 = ff_hevc_decode_nal_pps(VAR_3, VAR_0->avctx, &VAR_0->ps);
        if (VAR_5 < 0)
            goto fail;
        break;
    case VAR_9:
    case VAR_10:
        VAR_5 = ff_hevc_decode_nal_sei(VAR_3, VAR_0->avctx, &VAR_0->sei, &VAR_0->ps, VAR_0->nal_unit_type);
        if (VAR_5 < 0)
            goto fail;
        break;
    case VAR_11:
    case VAR_12:
    case VAR_13:
    case VAR_14:
    case VAR_15:
    case VAR_16:
    case VAR_17:
    case VAR_18:
    case VAR_19:
    case VAR_20:
    case VAR_21:
    case VAR_22:
    case VAR_23:
    case VAR_24:
    case VAR_25:
    case VAR_26:
        VAR_5 = hls_slice_header(VAR_0);
        if (VAR_5 < 0)
            return VAR_5;
        if (VAR_5 == 1) {
            VAR_5 = VAR_27;
            goto fail;
        }


        if (VAR_0->sh.first_slice_in_pic_flag) {
            if (VAR_0->max_ra == VAR_28) {
                if (VAR_0->nal_unit_type == VAR_22 || IS_BLA(VAR_0)) {
                    VAR_0->max_ra = VAR_0->poc;
                } else {
                    if (IS_IDR(VAR_0))
                        VAR_0->max_ra = VAR_29;
                }
            }

            if ((VAR_0->nal_unit_type == VAR_26 || VAR_0->nal_unit_type == VAR_25) &&
                VAR_0->poc <= VAR_0->max_ra) {
                VAR_0->is_decoded = 0;
                break;
            } else {
                if (VAR_0->nal_unit_type == VAR_26 && VAR_0->poc > VAR_0->max_ra)
                    VAR_0->max_ra = VAR_29;
            }

            VAR_5 = hevc_frame_start(VAR_0);
            if (VAR_5 < 0)
                return VAR_5;
        } else if (!VAR_0->ref) {
            av_log(VAR_0->avctx, VAR_30, ""First slice in a frame missing.\n"");
            goto fail;
        }

        if (VAR_0->nal_unit_type != VAR_0->first_nal_type) {
            av_log(VAR_0->avctx, VAR_30,
                   ""Non-matching NAL types of the VCL NALUs: %d %d\n"",
                   VAR_0->first_nal_type, VAR_0->nal_unit_type);
            return VAR_27;
        }

        if (!VAR_0->sh.dependent_slice_segment_flag &&
            VAR_0->sh.slice_type != VAR_31) {
            VAR_5 = ff_hevc_slice_rpl(VAR_0);
            if (VAR_5 < 0) {
                av_log(VAR_0->avctx, VAR_32,
                       ""Error constructing the reference lists for the current slice.\n"");
                goto fail;
            }
        }

        if (VAR_0->sh.first_slice_in_pic_flag && VAR_0->avctx->hwaccel) {
            VAR_5 = VAR_0->avctx->hwaccel->start_frame(VAR_0->avctx, NULL, 0);
            if (VAR_5 < 0)
                goto fail;
        }

        if (VAR_0->avctx->hwaccel) {
            VAR_5 = VAR_0->avctx->hwaccel->decode_slice(VAR_0->avctx, VAR_1->raw_data, VAR_1->raw_size);
            if (VAR_5 < 0)
                goto fail;
        } else {
            if (VAR_0->threads_number > 1 && VAR_0->sh.num_entry_point_offsets > 0)
                VAR_4 = hls_slice_data_wpp(VAR_0, VAR_1);
            else
                VAR_4 = hls_slice_data(VAR_0);
            if (VAR_4 >= (VAR_0->ps.sps->ctb_width * VAR_0->ps.sps->ctb_height)) {
                VAR_0->is_decoded = 1;
            }

            if (VAR_4 < 0) {
                VAR_5 = VAR_4;
                goto fail;
            }
        }
        break;
    case VAR_33:
    case VAR_34:
        VAR_0->seq_decode = (VAR_0->seq_decode + 1) & 0xff;
        VAR_0->max_ra     = VAR_28;
        break;
    case VAR_35:
    case VAR_36:
        break;
    default:
        av_log(VAR_0->avctx, VAR_37,
               ""Skipping NAL unit %d\n"", VAR_0->nal_unit_type);
    }

    return 0;
fail:
    if (VAR_0->avctx->err_recognition & VAR_38)
        return VAR_5;
    return 0;
}",ffmpeg/9ccc633068c6fe76989f487c8932bd11886ad65b/hevcdec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,12 +50,13 @@
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
+        if (ret == 1) {
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+
 
         if (s->sh.first_slice_in_pic_flag) {
-            if (s->ref) {
-                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
-                goto fail;
-            }
             if (s->max_ra == INT_MAX) {
                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                     s->max_ra = s->poc;","{'deleted_lines': ['            if (s->ref) {', '                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\\n"");', '                goto fail;', '            }'], 'added_lines': ['        if (ret == 1) {', '            ret = AVERROR_INVALIDDATA;', '            goto fail;', '        }', '']}",True,"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",8.8,HIGH,2,test,2019-03-23T19:55:08Z,2
CVE-2019-10069,['CWE-502'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,godotengine/godot,Multiplayer API now respects allow_object_decoding,65c7fd209947d5b2e080c9818b5a0df7c7d02440,https://github.com/godotengine/godot/commit/65c7fd209947d5b2e080c9818b5a0df7c7d02440,core/io/multiplayer_api.cpp,MultiplayerAPI::_process_rpc,"void MultiplayerAPI::_process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {
ERR_EXPLAIN(""Invalid packet received. Size too small."");
ERR_FAIL_COND(p_offset >= p_packet_len);
RPCMode rpc_mode = RPC_MODE_DISABLED;
const Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);
if (E) {
rpc_mode = E->get();
} else if (p_node->get_script_instance()) {
rpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);
}
ERR_EXPLAIN(""RPC '"" + String(p_name) + ""' is not allowed from: "" + itos(p_from) + "". Mode is "" + itos((int)rpc_mode) + "", master is "" + itos(p_node->get_network_master()) + ""."");
ERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));
int argc = p_packet[p_offset];
Vector<Variant> args;
Vector<const Variant *> argp;
args.resize(argc);
argp.resize(argc);
p_offset++;
for (int i = 0; i < argc; i++) {
ERR_EXPLAIN(""Invalid packet received. Size too small."");
ERR_FAIL_COND(p_offset >= p_packet_len);
int vlen;
Error err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);
ERR_EXPLAIN(""Invalid packet received. Unable to decode RPC argument."");
ERR_FAIL_COND(err != OK);
argp.write[i] = &args[i];
p_offset += vlen;
}
Variant::CallError ce;
p_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);
if (ce.error != Variant::CallError::CALL_OK) {
String error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);
error = ""RPC - "" + error;
ERR_PRINTS(error);
}
}","void MultiplayerAPI::_process_rpc(Node *VAR_0, const StringName &VAR_1, int VAR_2, const uint8_t *VAR_3, int VAR_4, int VAR_5) {
ERR_EXPLAIN(""Invalid packet received. Size too small."");
ERR_FAIL_COND(VAR_5 >= VAR_4);
RPCMode VAR_6 = VAR_7;
const Map<StringName, RPCMode>::Element *VAR_8 = VAR_0->get_node_rpc_mode(VAR_1);
if (VAR_8) {
VAR_6 = VAR_8->get();
} else if (VAR_0->get_script_instance()) {
VAR_6 = VAR_0->get_script_instance()->get_rpc_mode(VAR_1);
}
ERR_EXPLAIN(""RPC '"" + String(VAR_1) + ""' is not allowed from: "" + itos(VAR_2) + "". Mode is "" + itos((int)VAR_6) + "", master is "" + itos(VAR_0->get_network_master()) + ""."");
ERR_FAIL_COND(!_can_call_mode(VAR_0, VAR_6, VAR_2));
int VAR_9 = VAR_3[VAR_5];
Vector<Variant> VAR_10;
Vector<const Variant *> VAR_11;
VAR_10.resize(VAR_9);
VAR_11.resize(VAR_9);
VAR_5++;
for (int VAR_12 = 0; VAR_12 < VAR_9; VAR_12++) {
ERR_EXPLAIN(""Invalid packet received. Size too small."");
ERR_FAIL_COND(VAR_5 >= VAR_4);
int VAR_13;
Error VAR_14 = decode_variant(VAR_10.write[VAR_12], &VAR_3[VAR_5], VAR_4 - VAR_5, &VAR_13);
ERR_EXPLAIN(""Invalid packet received. Unable to decode RPC argument."");
ERR_FAIL_COND(VAR_14 != VAR_15);
VAR_11.write[VAR_12] = &VAR_10[VAR_12];
VAR_5 += VAR_13;
}
Variant::CallError VAR_16;
VAR_0->call(VAR_1, (const Variant **)VAR_11.ptr(), VAR_9, VAR_16);
if (VAR_16.error != Variant::CallError::CALL_OK) {
String VAR_17 = Variant::get_call_error_text(VAR_0, VAR_1, (const Variant **)VAR_11.ptr(), VAR_9, VAR_16);
VAR_17 = ""RPC - "" + VAR_17;
ERR_PRINTS(VAR_17);
}
}",godotengine/godot/65c7fd209947d5b2e080c9818b5a0df7c7d02440/multiplayer_api.cpp/vul/before/0.json,"void MultiplayerAPI::_process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {

	ERR_EXPLAIN(""Invalid packet received. Size too small."");
	ERR_FAIL_COND(p_offset >= p_packet_len);

	// Check that remote can call the RPC on this node.
	RPCMode rpc_mode = RPC_MODE_DISABLED;
	const Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);
	if (E) {
		rpc_mode = E->get();
	} else if (p_node->get_script_instance()) {
		rpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);
	}

	ERR_EXPLAIN(""RPC '"" + String(p_name) + ""' is not allowed from: "" + itos(p_from) + "". Mode is "" + itos((int)rpc_mode) + "", master is "" + itos(p_node->get_network_master()) + ""."");
	ERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));

	int argc = p_packet[p_offset];
	Vector<Variant> args;
	Vector<const Variant *> argp;
	args.resize(argc);
	argp.resize(argc);

	p_offset++;

	for (int i = 0; i < argc; i++) {

		ERR_EXPLAIN(""Invalid packet received. Size too small."");
		ERR_FAIL_COND(p_offset >= p_packet_len);

		int vlen;
		Error err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());
		ERR_EXPLAIN(""Invalid packet received. Unable to decode RPC argument."");
		ERR_FAIL_COND(err != OK);

		argp.write[i] = &args[i];
		p_offset += vlen;
	}

	Variant::CallError ce;

	p_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);
	if (ce.error != Variant::CallError::CALL_OK) {
		String error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);
		error = ""RPC - "" + error;
		ERR_PRINTS(error);
	}
}","void MultiplayerAPI::_process_rpc(Node *VAR_0, const StringName &VAR_1, int VAR_2, const uint8_t *VAR_3, int VAR_4, int VAR_5) {

	ERR_EXPLAIN(""Invalid packet received. Size too small."");
	ERR_FAIL_COND(VAR_5 >= VAR_4);

	/* COMMENT_0 */
	RPCMode VAR_6 = VAR_7;
	const Map<StringName, RPCMode>::Element *VAR_8 = VAR_0->get_node_rpc_mode(VAR_1);
	if (VAR_8) {
		VAR_6 = VAR_8->get();
	} else if (VAR_0->get_script_instance()) {
		VAR_6 = VAR_0->get_script_instance()->get_rpc_mode(VAR_1);
	}

	ERR_EXPLAIN(""RPC '"" + String(VAR_1) + ""' is not allowed from: "" + itos(VAR_2) + "". Mode is "" + itos((int)VAR_6) + "", master is "" + itos(VAR_0->get_network_master()) + ""."");
	ERR_FAIL_COND(!_can_call_mode(VAR_0, VAR_6, VAR_2));

	int VAR_9 = VAR_3[VAR_5];
	Vector<Variant> VAR_10;
	Vector<const Variant *> VAR_11;
	VAR_10.resize(VAR_9);
	VAR_11.resize(VAR_9);

	VAR_5++;

	for (int VAR_12 = 0; VAR_12 < VAR_9; VAR_12++) {

		ERR_EXPLAIN(""Invalid packet received. Size too small."");
		ERR_FAIL_COND(VAR_5 >= VAR_4);

		int VAR_13;
		Error VAR_14 = decode_variant(VAR_10.write[VAR_12], &VAR_3[VAR_5], VAR_4 - VAR_5, &VAR_13, VAR_15->is_object_decoding_allowed());
		ERR_EXPLAIN(""Invalid packet received. Unable to decode RPC argument."");
		ERR_FAIL_COND(VAR_14 != VAR_16);

		VAR_11.write[VAR_12] = &VAR_10[VAR_12];
		VAR_5 += VAR_13;
	}

	Variant::CallError VAR_17;

	VAR_0->call(VAR_1, (const Variant **)VAR_11.ptr(), VAR_9, VAR_17);
	if (VAR_17.error != Variant::CallError::CALL_OK) {
		String VAR_18 = Variant::get_call_error_text(VAR_0, VAR_1, (const Variant **)VAR_11.ptr(), VAR_9, VAR_17);
		VAR_18 = ""RPC - "" + VAR_18;
		ERR_PRINTS(VAR_18);
	}
}",godotengine/godot/65c7fd209947d5b2e080c9818b5a0df7c7d02440/multiplayer_api.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,7 +29,7 @@
 		ERR_FAIL_COND(p_offset >= p_packet_len);
 
 		int vlen;
-		Error err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);
+		Error err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());
 		ERR_EXPLAIN(""Invalid packet received. Unable to decode RPC argument."");
 		ERR_FAIL_COND(err != OK);
 ","{'deleted_lines': ['\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);'], 'added_lines': ['\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());']}",True,"In Godot through 3.1, remote code execution is possible due to the deserialization policy not being applied correctly.",9.8,CRITICAL,3,test,2019-03-25T11:48:46Z,2
CVE-2019-10069,['CWE-502'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,godotengine/godot,Multiplayer API now respects allow_object_decoding,65c7fd209947d5b2e080c9818b5a0df7c7d02440,https://github.com/godotengine/godot/commit/65c7fd209947d5b2e080c9818b5a0df7c7d02440,core/io/multiplayer_api.cpp,MultiplayerAPI::_process_rset,"void MultiplayerAPI::_process_rset(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {
ERR_EXPLAIN(""Invalid packet received. Size too small."");
ERR_FAIL_COND(p_offset >= p_packet_len);
RPCMode rset_mode = RPC_MODE_DISABLED;
const Map<StringName, RPCMode>::Element *E = p_node->get_node_rset_mode(p_name);
if (E) {
rset_mode = E->get();
} else if (p_node->get_script_instance()) {
rset_mode = p_node->get_script_instance()->get_rset_mode(p_name);
}
ERR_EXPLAIN(""RSET '"" + String(p_name) + ""' is not allowed from: "" + itos(p_from) + "". Mode is "" + itos((int)rset_mode) + "", master is "" + itos(p_node->get_network_master()) + ""."");
ERR_FAIL_COND(!_can_call_mode(p_node, rset_mode, p_from));
Variant value;
Error err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset);
ERR_EXPLAIN(""Invalid packet received. Unable to decode RSET value."");
ERR_FAIL_COND(err != OK);
bool valid;
p_node->set(p_name, value, &valid);
if (!valid) {
String error = ""Error setting remote property '"" + String(p_name) + ""', not found in object of type "" + p_node->get_class();
ERR_PRINTS(error);
}
}","void MultiplayerAPI::_process_rset(Node *VAR_0, const StringName &VAR_1, int VAR_2, const uint8_t *VAR_3, int VAR_4, int VAR_5) {
ERR_EXPLAIN(""Invalid packet received. Size too small."");
ERR_FAIL_COND(VAR_5 >= VAR_4);
RPCMode VAR_6 = VAR_7;
const Map<StringName, RPCMode>::Element *VAR_8 = VAR_0->get_node_rset_mode(VAR_1);
if (VAR_8) {
VAR_6 = VAR_8->get();
} else if (VAR_0->get_script_instance()) {
VAR_6 = VAR_0->get_script_instance()->get_rset_mode(VAR_1);
}
ERR_EXPLAIN(""RSET '"" + String(VAR_1) + ""' is not allowed from: "" + itos(VAR_2) + "". Mode is "" + itos((int)VAR_6) + "", master is "" + itos(VAR_0->get_network_master()) + ""."");
ERR_FAIL_COND(!_can_call_mode(VAR_0, VAR_6, VAR_2));
Variant VAR_9;
Error VAR_10 = decode_variant(VAR_9, &VAR_3[VAR_5], VAR_4 - VAR_5);
ERR_EXPLAIN(""Invalid packet received. Unable to decode RSET value."");
ERR_FAIL_COND(VAR_10 != VAR_11);
bool VAR_12;
VAR_0->set(VAR_1, VAR_9, &VAR_12);
if (!VAR_12) {
String VAR_13 = ""Error setting remote property '"" + String(VAR_1) + ""', not found in object of type "" + VAR_0->get_class();
ERR_PRINTS(VAR_13);
}
}",godotengine/godot/65c7fd209947d5b2e080c9818b5a0df7c7d02440/multiplayer_api.cpp/vul/before/1.json,"void MultiplayerAPI::_process_rset(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {

	ERR_EXPLAIN(""Invalid packet received. Size too small."");
	ERR_FAIL_COND(p_offset >= p_packet_len);

	// Check that remote can call the RSET on this node.
	RPCMode rset_mode = RPC_MODE_DISABLED;
	const Map<StringName, RPCMode>::Element *E = p_node->get_node_rset_mode(p_name);
	if (E) {
		rset_mode = E->get();
	} else if (p_node->get_script_instance()) {
		rset_mode = p_node->get_script_instance()->get_rset_mode(p_name);
	}

	ERR_EXPLAIN(""RSET '"" + String(p_name) + ""' is not allowed from: "" + itos(p_from) + "". Mode is "" + itos((int)rset_mode) + "", master is "" + itos(p_node->get_network_master()) + ""."");
	ERR_FAIL_COND(!_can_call_mode(p_node, rset_mode, p_from));

	Variant value;
	Error err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset, NULL, network_peer->is_object_decoding_allowed());

	ERR_EXPLAIN(""Invalid packet received. Unable to decode RSET value."");
	ERR_FAIL_COND(err != OK);

	bool valid;

	p_node->set(p_name, value, &valid);
	if (!valid) {
		String error = ""Error setting remote property '"" + String(p_name) + ""', not found in object of type "" + p_node->get_class();
		ERR_PRINTS(error);
	}
}","void MultiplayerAPI::_process_rset(Node *VAR_0, const StringName &VAR_1, int VAR_2, const uint8_t *VAR_3, int VAR_4, int VAR_5) {

	ERR_EXPLAIN(""Invalid packet received. Size too small."");
	ERR_FAIL_COND(VAR_5 >= VAR_4);

	/* COMMENT_0 */
	RPCMode VAR_6 = VAR_7;
	const Map<StringName, RPCMode>::Element *VAR_8 = VAR_0->get_node_rset_mode(VAR_1);
	if (VAR_8) {
		VAR_6 = VAR_8->get();
	} else if (VAR_0->get_script_instance()) {
		VAR_6 = VAR_0->get_script_instance()->get_rset_mode(VAR_1);
	}

	ERR_EXPLAIN(""RSET '"" + String(VAR_1) + ""' is not allowed from: "" + itos(VAR_2) + "". Mode is "" + itos((int)VAR_6) + "", master is "" + itos(VAR_0->get_network_master()) + ""."");
	ERR_FAIL_COND(!_can_call_mode(VAR_0, VAR_6, VAR_2));

	Variant VAR_9;
	Error VAR_10 = decode_variant(VAR_9, &VAR_3[VAR_5], VAR_4 - VAR_5, NULL, VAR_11->is_object_decoding_allowed());

	ERR_EXPLAIN(""Invalid packet received. Unable to decode RSET value."");
	ERR_FAIL_COND(VAR_10 != VAR_12);

	bool VAR_13;

	VAR_0->set(VAR_1, VAR_9, &VAR_13);
	if (!VAR_13) {
		String VAR_14 = ""Error setting remote property '"" + String(VAR_1) + ""', not found in object of type "" + VAR_0->get_class();
		ERR_PRINTS(VAR_14);
	}
}",godotengine/godot/65c7fd209947d5b2e080c9818b5a0df7c7d02440/multiplayer_api.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 	ERR_FAIL_COND(!_can_call_mode(p_node, rset_mode, p_from));
 
 	Variant value;
-	Error err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset);
+	Error err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset, NULL, network_peer->is_object_decoding_allowed());
 
 	ERR_EXPLAIN(""Invalid packet received. Unable to decode RSET value."");
 	ERR_FAIL_COND(err != OK);","{'deleted_lines': ['\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset);'], 'added_lines': ['\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset, NULL, network_peer->is_object_decoding_allowed());']}",True,"In Godot through 3.1, remote code execution is possible due to the deserialization policy not being applied correctly.",9.8,CRITICAL,3,test,2019-03-25T11:48:46Z,2
CVE-2019-10069,['CWE-502'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,godotengine/godot,Multiplayer API now respects allow_object_decoding,65c7fd209947d5b2e080c9818b5a0df7c7d02440,https://github.com/godotengine/godot/commit/65c7fd209947d5b2e080c9818b5a0df7c7d02440,core/io/multiplayer_api.cpp,MultiplayerAPI::_send_rpc,"void MultiplayerAPI::_send_rpc(Node *p_from, int p_to, bool p_unreliable, bool p_set, const StringName &p_name, const Variant **p_arg, int p_argcount) {
if (network_peer.is_null()) {
ERR_EXPLAIN(""Attempt to remote call/set when networking is not active in SceneTree."");
ERR_FAIL();
}
if (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_CONNECTING) {
ERR_EXPLAIN(""Attempt to remote call/set when networking is not connected yet in SceneTree."");
ERR_FAIL();
}
if (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_DISCONNECTED) {
ERR_EXPLAIN(""Attempt to remote call/set when networking is disconnected."");
ERR_FAIL();
}
if (p_argcount > 255) {
ERR_EXPLAIN(""Too many arguments >255."");
ERR_FAIL();
}
if (p_to != 0 && !connected_peers.has(ABS(p_to))) {
if (p_to == network_peer->get_unique_id()) {
ERR_EXPLAIN(""Attempt to remote call/set yourself! unique ID: "" + itos(network_peer->get_unique_id()));
} else {
ERR_EXPLAIN(""Attempt to remote call unexisting ID: "" + itos(p_to));
}
ERR_FAIL();
}
NodePath from_path = (root_node->get_path()).rel_path_to(p_from->get_path());
ERR_EXPLAIN(""Unable to send RPC. Relative path is empty. THIS IS LIKELY A BUG IN THE ENGINE!"");
ERR_FAIL_COND(from_path.is_empty());
PathSentCache *psc = path_send_cache.getptr(from_path);
if (!psc) {
path_send_cache[from_path] = PathSentCache();
psc = path_send_cache.getptr(from_path);
psc->id = last_send_cache_id++;
}
int ofs = 0;
#define MAKE_ROOM(m_amount) \
if (packet_cache.size() < m_amount) packet_cache.resize(m_amount);
MAKE_ROOM(1);
packet_cache.write[0] = p_set ? NETWORK_COMMAND_REMOTE_SET : NETWORK_COMMAND_REMOTE_CALL;
ofs += 1;
MAKE_ROOM(ofs + 4);
encode_uint32(psc->id, &(packet_cache.write[ofs]));
ofs += 4;
CharString name = String(p_name).utf8();
int len = encode_cstring(name.get_data(), NULL);
MAKE_ROOM(ofs + len);
encode_cstring(name.get_data(), &(packet_cache.write[ofs]));
ofs += len;
if (p_set) {
Error err = encode_variant(*p_arg[0], NULL, len);
ERR_EXPLAIN(""Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!"");
ERR_FAIL_COND(err != OK);
MAKE_ROOM(ofs + len);
encode_variant(*p_arg[0], &(packet_cache.write[ofs]), len);
ofs += len;
} else {
MAKE_ROOM(ofs + 1);
packet_cache.write[ofs] = p_argcount;
ofs += 1;
for (int i = 0; i < p_argcount; i++) {
Error err = encode_variant(*p_arg[i], NULL, len);
ERR_EXPLAIN(""Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!"");
ERR_FAIL_COND(err != OK);
MAKE_ROOM(ofs + len);
encode_variant(*p_arg[i], &(packet_cache.write[ofs]), len);
ofs += len;
}
}
bool has_all_peers = _send_confirm_path(from_path, psc, p_to);
network_peer->set_transfer_mode(p_unreliable ? NetworkedMultiplayerPeer::TRANSFER_MODE_UNRELIABLE : NetworkedMultiplayerPeer::TRANSFER_MODE_RELIABLE);
if (has_all_peers) {
network_peer->set_target_peer(p_to); network_peer->put_packet(packet_cache.ptr(), ofs); } else {
CharString pname = String(from_path).utf8();
int path_len = encode_cstring(pname.get_data(), NULL);
MAKE_ROOM(ofs + path_len);
encode_cstring(pname.get_data(), &(packet_cache.write[ofs]));
for (Set<int>::Element *E = connected_peers.front(); E; E = E->next()) {
if (p_to < 0 && E->get() == -p_to)
continue; 
if (p_to > 0 && E->get() != p_to)
continue; 
Map<int, bool>::Element *F = psc->confirmed_peers.find(E->get());
ERR_CONTINUE(!F); 
network_peer->set_target_peer(E->get()); 
if (F->get()) {
encode_uint32(psc->id, &(packet_cache.write[1]));
network_peer->put_packet(packet_cache.ptr(), ofs);
} else {
encode_uint32(0x80000000 | ofs, &(packet_cache.write[1])); network_peer->put_packet(packet_cache.ptr(), ofs + path_len);
}
}
}
}","void MultiplayerAPI::_send_rpc(Node *VAR_0, int VAR_1, bool VAR_2, bool VAR_3, const StringName &VAR_4, const Variant **VAR_5, int VAR_6) {
if (VAR_7.is_null()) {
ERR_EXPLAIN(""Attempt to remote call/set when networking is not active in SceneTree."");
ERR_FAIL();
}
if (VAR_7->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_CONNECTING) {
ERR_EXPLAIN(""Attempt to remote call/set when networking is not connected yet in SceneTree."");
ERR_FAIL();
}
if (VAR_7->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_DISCONNECTED) {
ERR_EXPLAIN(""Attempt to remote call/set when networking is disconnected."");
ERR_FAIL();
}
if (VAR_6 > 255) {
ERR_EXPLAIN(""Too many arguments >255."");
ERR_FAIL();
}
if (VAR_1 != 0 && !VAR_8.has(ABS(VAR_1))) {
if (VAR_1 == VAR_7->get_unique_id()) {
ERR_EXPLAIN(""Attempt to remote call/set yourself! unique ID: "" + itos(VAR_7->get_unique_id()));
} else {
ERR_EXPLAIN(""Attempt to remote call unexisting ID: "" + itos(VAR_1));
}
ERR_FAIL();
}
NodePath VAR_9 = (VAR_10->get_path()).rel_path_to(VAR_0->get_path());
ERR_EXPLAIN(""Unable to send RPC. Relative path is empty. THIS IS LIKELY A BUG IN THE ENGINE!"");
ERR_FAIL_COND(VAR_9.is_empty());
PathSentCache *VAR_11 = VAR_12.getptr(VAR_9);
if (!VAR_11) {
VAR_12[VAR_9] = PathSentCache();
VAR_11 = VAR_12.getptr(VAR_9);
VAR_11->id = VAR_13++;
}
int VAR_14 = 0;
#define MAKE_ROOM(VAR_15) \
if (packet_cache.size() < m_amount) packet_cache.resize(m_amount);
MAKE_ROOM(1);
VAR_16.write[0] = VAR_3 ? VAR_17 : VAR_18;
VAR_14 += 1;
MAKE_ROOM(VAR_14 + 4);
encode_uint32(VAR_11->id, &(VAR_16.write[VAR_14]));
VAR_14 += 4;
CharString VAR_19 = String(VAR_4).utf8();
int VAR_20 = encode_cstring(VAR_19.get_data(), NULL);
MAKE_ROOM(VAR_14 + VAR_20);
encode_cstring(VAR_19.get_data(), &(VAR_16.write[VAR_14]));
VAR_14 += VAR_20;
if (VAR_3) {
Error VAR_21 = encode_variant(*VAR_5[0], NULL, VAR_20);
ERR_EXPLAIN(""Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!"");
ERR_FAIL_COND(VAR_21 != VAR_22);
MAKE_ROOM(VAR_14 + VAR_20);
encode_variant(*VAR_5[0], &(VAR_16.write[VAR_14]), VAR_20);
VAR_14 += VAR_20;
} else {
MAKE_ROOM(VAR_14 + 1);
VAR_16.write[VAR_14] = VAR_6;
VAR_14 += 1;
for (int VAR_23 = 0; VAR_23 < VAR_6; VAR_23++) {
Error VAR_21 = encode_variant(*VAR_5[VAR_23], NULL, VAR_20);
ERR_EXPLAIN(""Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!"");
ERR_FAIL_COND(VAR_21 != VAR_22);
MAKE_ROOM(VAR_14 + VAR_20);
encode_variant(*VAR_5[VAR_23], &(VAR_16.write[VAR_14]), VAR_20);
VAR_14 += VAR_20;
}
}
bool VAR_24 = _send_confirm_path(VAR_9, VAR_11, VAR_1);
VAR_7->set_transfer_mode(VAR_2 ? NetworkedMultiplayerPeer::TRANSFER_MODE_UNRELIABLE : NetworkedMultiplayerPeer::TRANSFER_MODE_RELIABLE);
if (VAR_24) {
VAR_7->set_target_peer(VAR_1); 
VAR_7->put_packet(VAR_16.ptr(), VAR_14); 
} else {
CharString VAR_25 = String(VAR_9).utf8();
int VAR_26 = encode_cstring(VAR_25.get_data(), NULL);
MAKE_ROOM(VAR_14 + VAR_26);
encode_cstring(VAR_25.get_data(), &(VAR_16.write[VAR_14]));
for (Set<int>::Element *VAR_27 = VAR_8.front(); VAR_27; VAR_27 = VAR_27->next()) {
if (VAR_1 < 0 && VAR_27->get() == -VAR_1)
continue; 
if (VAR_1 > 0 && VAR_27->get() != VAR_1)
continue; 
Map<int, bool>::Element *VAR_28 = VAR_11->confirmed_peers.find(VAR_27->get());
ERR_CONTINUE(!VAR_28); 
VAR_7->set_target_peer(VAR_27->get()); 
if (VAR_28->get()) {
encode_uint32(VAR_11->id, &(VAR_16.write[1]));
VAR_7->put_packet(VAR_16.ptr(), VAR_14);
} else {
encode_uint32(0x80000000 | VAR_14, &(VAR_16.write[1])); 
VAR_7->put_packet(VAR_16.ptr(), VAR_14 + VAR_26);
}
}
}
}",godotengine/godot/65c7fd209947d5b2e080c9818b5a0df7c7d02440/multiplayer_api.cpp/vul/before/2.json,"void MultiplayerAPI::_send_rpc(Node *p_from, int p_to, bool p_unreliable, bool p_set, const StringName &p_name, const Variant **p_arg, int p_argcount) {

	if (network_peer.is_null()) {
		ERR_EXPLAIN(""Attempt to remote call/set when networking is not active in SceneTree."");
		ERR_FAIL();
	}

	if (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_CONNECTING) {
		ERR_EXPLAIN(""Attempt to remote call/set when networking is not connected yet in SceneTree."");
		ERR_FAIL();
	}

	if (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_DISCONNECTED) {
		ERR_EXPLAIN(""Attempt to remote call/set when networking is disconnected."");
		ERR_FAIL();
	}

	if (p_argcount > 255) {
		ERR_EXPLAIN(""Too many arguments >255."");
		ERR_FAIL();
	}

	if (p_to != 0 && !connected_peers.has(ABS(p_to))) {
		if (p_to == network_peer->get_unique_id()) {
			ERR_EXPLAIN(""Attempt to remote call/set yourself! unique ID: "" + itos(network_peer->get_unique_id()));
		} else {
			ERR_EXPLAIN(""Attempt to remote call unexisting ID: "" + itos(p_to));
		}

		ERR_FAIL();
	}

	NodePath from_path = (root_node->get_path()).rel_path_to(p_from->get_path());
	ERR_EXPLAIN(""Unable to send RPC. Relative path is empty. THIS IS LIKELY A BUG IN THE ENGINE!"");
	ERR_FAIL_COND(from_path.is_empty());

	// See if the path is cached.
	PathSentCache *psc = path_send_cache.getptr(from_path);
	if (!psc) {
		// Path is not cached, create.
		path_send_cache[from_path] = PathSentCache();
		psc = path_send_cache.getptr(from_path);
		psc->id = last_send_cache_id++;
	}

	// Create base packet, lots of hardcode because it must be tight.

	int ofs = 0;

#define MAKE_ROOM(m_amount) \
	if (packet_cache.size() < m_amount) packet_cache.resize(m_amount);

	// Encode type.
	MAKE_ROOM(1);
	packet_cache.write[0] = p_set ? NETWORK_COMMAND_REMOTE_SET : NETWORK_COMMAND_REMOTE_CALL;
	ofs += 1;

	// Encode ID.
	MAKE_ROOM(ofs + 4);
	encode_uint32(psc->id, &(packet_cache.write[ofs]));
	ofs += 4;

	// Encode function name.
	CharString name = String(p_name).utf8();
	int len = encode_cstring(name.get_data(), NULL);
	MAKE_ROOM(ofs + len);
	encode_cstring(name.get_data(), &(packet_cache.write[ofs]));
	ofs += len;

	if (p_set) {
		// Set argument.
		Error err = encode_variant(*p_arg[0], NULL, len, !network_peer->is_object_decoding_allowed());
		ERR_EXPLAIN(""Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!"");
		ERR_FAIL_COND(err != OK);
		MAKE_ROOM(ofs + len);
		encode_variant(*p_arg[0], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());
		ofs += len;

	} else {
		// Call arguments.
		MAKE_ROOM(ofs + 1);
		packet_cache.write[ofs] = p_argcount;
		ofs += 1;
		for (int i = 0; i < p_argcount; i++) {
			Error err = encode_variant(*p_arg[i], NULL, len, !network_peer->is_object_decoding_allowed());
			ERR_EXPLAIN(""Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!"");
			ERR_FAIL_COND(err != OK);
			MAKE_ROOM(ofs + len);
			encode_variant(*p_arg[i], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());
			ofs += len;
		}
	}

	// See if all peers have cached path (is so, call can be fast).
	bool has_all_peers = _send_confirm_path(from_path, psc, p_to);

	// Take chance and set transfer mode, since all send methods will use it.
	network_peer->set_transfer_mode(p_unreliable ? NetworkedMultiplayerPeer::TRANSFER_MODE_UNRELIABLE : NetworkedMultiplayerPeer::TRANSFER_MODE_RELIABLE);

	if (has_all_peers) {

		// They all have verified paths, so send fast.
		network_peer->set_target_peer(p_to); // To all of you.
		network_peer->put_packet(packet_cache.ptr(), ofs); // A message with love.
	} else {
		// Not all verified path, so send one by one.

		// Append path at the end, since we will need it for some packets.
		CharString pname = String(from_path).utf8();
		int path_len = encode_cstring(pname.get_data(), NULL);
		MAKE_ROOM(ofs + path_len);
		encode_cstring(pname.get_data(), &(packet_cache.write[ofs]));

		for (Set<int>::Element *E = connected_peers.front(); E; E = E->next()) {

			if (p_to < 0 && E->get() == -p_to)
				continue; // Continue, excluded.

			if (p_to > 0 && E->get() != p_to)
				continue; // Continue, not for this peer.

			Map<int, bool>::Element *F = psc->confirmed_peers.find(E->get());
			ERR_CONTINUE(!F); // Should never happen.

			network_peer->set_target_peer(E->get()); // To this one specifically.

			if (F->get()) {
				// This one confirmed path, so use id.
				encode_uint32(psc->id, &(packet_cache.write[1]));
				network_peer->put_packet(packet_cache.ptr(), ofs);
			} else {
				// This one did not confirm path yet, so use entire path (sorry!).
				encode_uint32(0x80000000 | ofs, &(packet_cache.write[1])); // Offset to path and flag.
				network_peer->put_packet(packet_cache.ptr(), ofs + path_len);
			}
		}
	}
}","void MultiplayerAPI::_send_rpc(Node *VAR_0, int VAR_1, bool VAR_2, bool VAR_3, const StringName &VAR_4, const Variant **VAR_5, int VAR_6) {

	if (VAR_7.is_null()) {
		ERR_EXPLAIN(""Attempt to remote call/set when networking is not active in SceneTree."");
		ERR_FAIL();
	}

	if (VAR_7->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_CONNECTING) {
		ERR_EXPLAIN(""Attempt to remote call/set when networking is not connected yet in SceneTree."");
		ERR_FAIL();
	}

	if (VAR_7->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_DISCONNECTED) {
		ERR_EXPLAIN(""Attempt to remote call/set when networking is disconnected."");
		ERR_FAIL();
	}

	if (VAR_6 > 255) {
		ERR_EXPLAIN(""Too many arguments >255."");
		ERR_FAIL();
	}

	if (VAR_1 != 0 && !VAR_8.has(ABS(VAR_1))) {
		if (VAR_1 == VAR_7->get_unique_id()) {
			ERR_EXPLAIN(""Attempt to remote call/set yourself! unique ID: "" + itos(VAR_7->get_unique_id()));
		} else {
			ERR_EXPLAIN(""Attempt to remote call unexisting ID: "" + itos(VAR_1));
		}

		ERR_FAIL();
	}

	NodePath VAR_9 = (VAR_10->get_path()).rel_path_to(VAR_0->get_path());
	ERR_EXPLAIN(""Unable to send RPC. Relative path is empty. THIS IS LIKELY A BUG IN THE ENGINE!"");
	ERR_FAIL_COND(VAR_9.is_empty());

	/* COMMENT_0 */
	PathSentCache *VAR_11 = VAR_12.getptr(VAR_9);
	if (!VAR_11) {
		/* COMMENT_1 */
		VAR_12[VAR_9] = PathSentCache();
		VAR_11 = VAR_12.getptr(VAR_9);
		VAR_11->id = VAR_13++;
	}

	/* COMMENT_2 */

	int VAR_14 = 0;

#define MAKE_ROOM(VAR_15) \
	if (packet_cache.size() < m_amount) packet_cache.resize(m_amount);

	/* COMMENT_3 */
	MAKE_ROOM(1);
	VAR_16.write[0] = VAR_3 ? VAR_17 : VAR_18;
	VAR_14 += 1;

	/* COMMENT_4 */
	MAKE_ROOM(VAR_14 + 4);
	encode_uint32(VAR_11->id, &(VAR_16.write[VAR_14]));
	VAR_14 += 4;

	/* COMMENT_5 */
	CharString VAR_19 = String(VAR_4).utf8();
	int VAR_20 = encode_cstring(VAR_19.get_data(), NULL);
	MAKE_ROOM(VAR_14 + VAR_20);
	encode_cstring(VAR_19.get_data(), &(VAR_16.write[VAR_14]));
	VAR_14 += VAR_20;

	if (VAR_3) {
		/* COMMENT_6 */
		Error VAR_21 = encode_variant(*VAR_5[0], NULL, VAR_20, !VAR_7->is_object_decoding_allowed());
		ERR_EXPLAIN(""Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!"");
		ERR_FAIL_COND(VAR_21 != VAR_22);
		MAKE_ROOM(VAR_14 + VAR_20);
		encode_variant(*VAR_5[0], &(VAR_16.write[VAR_14]), VAR_20, !VAR_7->is_object_decoding_allowed());
		VAR_14 += VAR_20;

	} else {
		/* COMMENT_7 */
		MAKE_ROOM(VAR_14 + 1);
		VAR_16.write[VAR_14] = VAR_6;
		VAR_14 += 1;
		for (int VAR_23 = 0; VAR_23 < VAR_6; VAR_23++) {
			Error VAR_21 = encode_variant(*VAR_5[VAR_23], NULL, VAR_20, !VAR_7->is_object_decoding_allowed());
			ERR_EXPLAIN(""Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!"");
			ERR_FAIL_COND(VAR_21 != VAR_22);
			MAKE_ROOM(VAR_14 + VAR_20);
			encode_variant(*VAR_5[VAR_23], &(VAR_16.write[VAR_14]), VAR_20, !VAR_7->is_object_decoding_allowed());
			VAR_14 += VAR_20;
		}
	}

	/* COMMENT_8 */
	bool VAR_24 = _send_confirm_path(VAR_9, VAR_11, VAR_1);

	/* COMMENT_9 */
	VAR_7->set_transfer_mode(VAR_2 ? NetworkedMultiplayerPeer::TRANSFER_MODE_UNRELIABLE : NetworkedMultiplayerPeer::TRANSFER_MODE_RELIABLE);

	if (VAR_24) {

		/* COMMENT_10 */
		VAR_7->set_target_peer(VAR_1); /* COMMENT_11 */
		VAR_7->put_packet(VAR_16.ptr(), VAR_14); /* COMMENT_12 */
	} else {
		/* COMMENT_13 */

		/* COMMENT_14 */
		CharString VAR_25 = String(VAR_9).utf8();
		int VAR_26 = encode_cstring(VAR_25.get_data(), NULL);
		MAKE_ROOM(VAR_14 + VAR_26);
		encode_cstring(VAR_25.get_data(), &(VAR_16.write[VAR_14]));

		for (Set<int>::Element *VAR_27 = VAR_8.front(); VAR_27; VAR_27 = VAR_27->next()) {

			if (VAR_1 < 0 && VAR_27->get() == -VAR_1)
				continue; /* COMMENT_15 */

			if (VAR_1 > 0 && VAR_27->get() != VAR_1)
				continue; /* COMMENT_16 */

			Map<int, bool>::Element *VAR_28 = VAR_11->confirmed_peers.find(VAR_27->get());
			ERR_CONTINUE(!VAR_28); /* COMMENT_17 */

			VAR_7->set_target_peer(VAR_27->get()); /* COMMENT_18 */

			if (VAR_28->get()) {
				/* COMMENT_19 */
				encode_uint32(VAR_11->id, &(VAR_16.write[1]));
				VAR_7->put_packet(VAR_16.ptr(), VAR_14);
			} else {
				/* COMMENT_20 */
				encode_uint32(0x80000000 | VAR_14, &(VAR_16.write[1])); /* COMMENT_21 */
				VAR_7->put_packet(VAR_16.ptr(), VAR_14 + VAR_26);
			}
		}
	}
}",godotengine/godot/65c7fd209947d5b2e080c9818b5a0df7c7d02440/multiplayer_api.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -69,11 +69,11 @@
 
 	if (p_set) {
 		// Set argument.
-		Error err = encode_variant(*p_arg[0], NULL, len);
+		Error err = encode_variant(*p_arg[0], NULL, len, !network_peer->is_object_decoding_allowed());
 		ERR_EXPLAIN(""Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!"");
 		ERR_FAIL_COND(err != OK);
 		MAKE_ROOM(ofs + len);
-		encode_variant(*p_arg[0], &(packet_cache.write[ofs]), len);
+		encode_variant(*p_arg[0], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());
 		ofs += len;
 
 	} else {
@@ -82,11 +82,11 @@
 		packet_cache.write[ofs] = p_argcount;
 		ofs += 1;
 		for (int i = 0; i < p_argcount; i++) {
-			Error err = encode_variant(*p_arg[i], NULL, len);
+			Error err = encode_variant(*p_arg[i], NULL, len, !network_peer->is_object_decoding_allowed());
 			ERR_EXPLAIN(""Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!"");
 			ERR_FAIL_COND(err != OK);
 			MAKE_ROOM(ofs + len);
-			encode_variant(*p_arg[i], &(packet_cache.write[ofs]), len);
+			encode_variant(*p_arg[i], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());
 			ofs += len;
 		}
 	}","{'deleted_lines': ['\t\tError err = encode_variant(*p_arg[0], NULL, len);', '\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len);', '\t\t\tError err = encode_variant(*p_arg[i], NULL, len);', '\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len);'], 'added_lines': ['\t\tError err = encode_variant(*p_arg[0], NULL, len, !network_peer->is_object_decoding_allowed());', '\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());', '\t\t\tError err = encode_variant(*p_arg[i], NULL, len, !network_peer->is_object_decoding_allowed());', '\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());']}",True,"In Godot through 3.1, remote code execution is possible due to the deserialization policy not being applied correctly.",9.8,CRITICAL,3,test,2019-03-25T11:48:46Z,2
CVE-2019-6706,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,lua,"Fixed bug in 'lua_upvaluejoin'

Bug-fix: joining an upvalue with itself could cause a use-after-free
crash.",89aee84cbc9224f638f3b7951b306d2ee8ecb71e,https://github.com/lua/lua/commit/89aee84cbc9224f638f3b7951b306d2ee8ecb71e,lapi.c,getupvalref,"static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
LClosure *f;
StkId fi = index2addr(L, fidx);
api_check(L, ttisLclosure(fi), ""Lua function expected"");
f = clLvalue(fi);
api_check(L, (1 <= n && n <= f->p->sizeupvalues), ""invalid upvalue index"");
if (pf) *pf = f;
return &f->upvals[n - 1];  
}","static UpVal **getupvalref (lua_State *VAR_0, int VAR_1, int VAR_2, LClosure **VAR_3) {
LClosure *VAR_4;
StkId VAR_5 = index2addr(VAR_0, VAR_1);
api_check(VAR_0, ttisLclosure(VAR_5), ""Lua function expected"");
VAR_4 = clLvalue(VAR_5);
api_check(VAR_0, (1 <= VAR_2 && VAR_2 <= VAR_4->p->sizeupvalues), ""invalid upvalue index"");
if (VAR_3) *VAR_3 = VAR_4;
return &VAR_4->upvals[VAR_2 - 1];  
}",lua/89aee84cbc9224f638f3b7951b306d2ee8ecb71e/lapi.c/vul/before/0.json,"static UpVal **getupvalref (lua_State *L, int fidx, int n) {
  LClosure *f;
  StkId fi = index2addr(L, fidx);
  api_check(L, ttisLclosure(fi), ""Lua function expected"");
  f = clLvalue(fi);
  api_check(L, (1 <= n && n <= f->p->sizeupvalues), ""invalid upvalue index"");
  return &f->upvals[n - 1];  /* get its upvalue pointer */
}","static UpVal **getupvalref (lua_State *VAR_0, int VAR_1, int VAR_2) {
  LClosure *VAR_3;
  StkId VAR_4 = index2addr(VAR_0, VAR_1);
  api_check(VAR_0, ttisLclosure(VAR_4), ""Lua function expected"");
  VAR_3 = clLvalue(VAR_4);
  api_check(VAR_0, (1 <= VAR_2 && VAR_2 <= VAR_3->p->sizeupvalues), ""invalid upvalue index"");
  return &VAR_3->upvals[VAR_2 - 1];  /* COMMENT_0 */
}",lua/89aee84cbc9224f638f3b7951b306d2ee8ecb71e/lapi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,9 +1,8 @@
-static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
+static UpVal **getupvalref (lua_State *L, int fidx, int n) {
   LClosure *f;
   StkId fi = index2addr(L, fidx);
   api_check(L, ttisLclosure(fi), ""Lua function expected"");
   f = clLvalue(fi);
   api_check(L, (1 <= n && n <= f->p->sizeupvalues), ""invalid upvalue index"");
-  if (pf) *pf = f;
   return &f->upvals[n - 1];  /* get its upvalue pointer */
 }","{'deleted_lines': ['static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {', '  if (pf) *pf = f;'], 'added_lines': ['static UpVal **getupvalref (lua_State *L, int fidx, int n) {']}",True,"Lua 5.3.5 has a use-after-free in lua_upvaluejoin in lapi.c. For example, a crash outcome might be achieved by an attacker who is able to trigger a debug.upvaluejoin call in which the arguments have certain relationships.",7.5,HIGH,2,test,2019-03-27T17:30:12Z,2
CVE-2019-6706,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,lua,"Fixed bug in 'lua_upvaluejoin'

Bug-fix: joining an upvalue with itself could cause a use-after-free
crash.",89aee84cbc9224f638f3b7951b306d2ee8ecb71e,https://github.com/lua/lua/commit/89aee84cbc9224f638f3b7951b306d2ee8ecb71e,lapi.c,lua_upvaluejoin,"LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
int fidx2, int n2) {
LClosure *f1;
UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
luaC_upvdeccount(L, *up1);
*up1 = *up2;
(*up1)->refcount++;
if (upisopen(*up1)) (*up1)->u.open.touched = 1;
luaC_upvalbarrier(L, *up1);
}","LUA_API VAR_0 lua_upvaluejoin (lua_State *VAR_1, int VAR_2, int VAR_3,
int VAR_4, int VAR_5) {
LClosure *VAR_6;
UpVal **VAR_7 = getupvalref(VAR_1, VAR_2, VAR_3, &VAR_6);
UpVal **VAR_8 = getupvalref(VAR_1, VAR_4, VAR_5, NULL);
luaC_upvdeccount(VAR_1, *VAR_7);
*VAR_7 = *VAR_8;
(*VAR_7)->refcount++;
if (upisopen(*VAR_7)) (*VAR_7)->u.open.touched = 1;
luaC_upvalbarrier(VAR_1, *VAR_7);
}",,"LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
                                            int fidx2, int n2) {
  UpVal **up1 = getupvalref(L, fidx1, n1);
  UpVal **up2 = getupvalref(L, fidx2, n2);
  if (*up1 == *up2)
    return;
  luaC_upvdeccount(L, *up1);
  *up1 = *up2;
  (*up1)->refcount++;
  if (upisopen(*up1)) (*up1)->u.open.touched = 1;
  luaC_upvalbarrier(L, *up1);
}","LUA_API VAR_0 lua_upvaluejoin (lua_State *VAR_1, int VAR_2, int VAR_3,
                                            int VAR_4, int VAR_5) {
  UpVal **VAR_6 = getupvalref(VAR_1, VAR_2, VAR_3);
  UpVal **VAR_7 = getupvalref(VAR_1, VAR_4, VAR_5);
  if (*VAR_6 == *VAR_7)
    return;
  luaC_upvdeccount(VAR_1, *VAR_6);
  *VAR_6 = *VAR_7;
  (*VAR_6)->refcount++;
  if (upisopen(*VAR_6)) (*VAR_6)->u.open.touched = 1;
  luaC_upvalbarrier(VAR_1, *VAR_6);
}",,"--- func_before
+++ func_after
@@ -1,8 +1,9 @@
 LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
                                             int fidx2, int n2) {
-  LClosure *f1;
-  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
-  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
+  UpVal **up1 = getupvalref(L, fidx1, n1);
+  UpVal **up2 = getupvalref(L, fidx2, n2);
+  if (*up1 == *up2)
+    return;
   luaC_upvdeccount(L, *up1);
   *up1 = *up2;
   (*up1)->refcount++;","{'deleted_lines': ['  LClosure *f1;', '  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);', '  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);'], 'added_lines': ['  UpVal **up1 = getupvalref(L, fidx1, n1);', '  UpVal **up2 = getupvalref(L, fidx2, n2);', '  if (*up1 == *up2)', '    return;']}",True,"Lua 5.3.5 has a use-after-free in lua_upvaluejoin in lapi.c. For example, a crash outcome might be achieved by an attacker who is able to trigger a debug.upvaluejoin call in which the arguments have certain relationships.",7.5,HIGH,2,test,2019-03-27T17:30:12Z,2
CVE-2019-6706,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,lua,"Fixed bug in 'lua_upvaluejoin'

Bug-fix: joining an upvalue with itself could cause a use-after-free
crash.",89aee84cbc9224f638f3b7951b306d2ee8ecb71e,https://github.com/lua/lua/commit/89aee84cbc9224f638f3b7951b306d2ee8ecb71e,lapi.c,lua_upvalueid,"LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
StkId fi = index2addr(L, fidx);
switch (ttype(fi)) {
case LUA_TLCL: {  
return *getupvalref(L, fidx, n, NULL);
}
case LUA_TCCL: {  
CClosure *f = clCvalue(fi);
api_check(L, 1 <= n && n <= f->nupvalues, ""invalid upvalue index"");
return &f->upvalue[n - 1];
}
default: {
api_check(L, 0, ""closure expected"");
return NULL;
}
}
}","LUA_API VAR_0 *lua_upvalueid (lua_State *VAR_1, int VAR_2, int VAR_3) {
StkId VAR_4 = index2addr(VAR_1, VAR_2);
switch (ttype(VAR_4)) {
case VAR_5: {  
return *getupvalref(VAR_1, VAR_2, VAR_3, NULL);
}
case VAR_6: {  
CClosure *VAR_7 = clCvalue(VAR_4);
api_check(VAR_1, 1 <= VAR_3 && VAR_3 <= VAR_7->nupvalues, ""invalid upvalue index"");
return &VAR_7->upvalue[VAR_3 - 1];
}
default: {
api_check(VAR_1, 0, ""closure expected"");
return NULL;
}
}
}",,"LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
  StkId fi = index2addr(L, fidx);
  switch (ttype(fi)) {
    case LUA_TLCL: {  /* lua closure */
      return *getupvalref(L, fidx, n);
    }
    case LUA_TCCL: {  /* C closure */
      CClosure *f = clCvalue(fi);
      api_check(L, 1 <= n && n <= f->nupvalues, ""invalid upvalue index"");
      return &f->upvalue[n - 1];
    }
    default: {
      api_check(L, 0, ""closure expected"");
      return NULL;
    }
  }
}","LUA_API VAR_0 *lua_upvalueid (lua_State *VAR_1, int VAR_2, int VAR_3) {
  StkId VAR_4 = index2addr(VAR_1, VAR_2);
  switch (ttype(VAR_4)) {
    case VAR_5: {  /* COMMENT_0 */
      return *getupvalref(VAR_1, VAR_2, VAR_3);
    }
    case VAR_6: {  /* COMMENT_1 */
      CClosure *VAR_7 = clCvalue(VAR_4);
      api_check(VAR_1, 1 <= VAR_3 && VAR_3 <= VAR_7->nupvalues, ""invalid upvalue index"");
      return &VAR_7->upvalue[VAR_3 - 1];
    }
    default: {
      api_check(VAR_1, 0, ""closure expected"");
      return NULL;
    }
  }
}",,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
   StkId fi = index2addr(L, fidx);
   switch (ttype(fi)) {
     case LUA_TLCL: {  /* lua closure */
-      return *getupvalref(L, fidx, n, NULL);
+      return *getupvalref(L, fidx, n);
     }
     case LUA_TCCL: {  /* C closure */
       CClosure *f = clCvalue(fi);","{'deleted_lines': ['      return *getupvalref(L, fidx, n, NULL);'], 'added_lines': ['      return *getupvalref(L, fidx, n);']}",True,"Lua 5.3.5 has a use-after-free in lua_upvaluejoin in lapi.c. For example, a crash outcome might be achieved by an attacker who is able to trigger a debug.upvaluejoin call in which the arguments have certain relationships.",7.5,HIGH,2,test,2019-03-27T17:30:12Z,2
CVE-2018-5727,['CWE-190'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,uclouvain/openjpeg,"opj_t1_encode_cblks: fix UBSAN signed integer overflow

Fixes #1053 / CVE-2018-5727

Note: I don't consider this issue to be a security vulnerability, in
practice.
At least with gcc or clang compilers on x86_64 which generate the same
assembly code with or without that fix.",a1d32a596a94280178c44a55d7e7f1acd992ed5d,https://github.com/uclouvain/openjpeg/commit/a1d32a596a94280178c44a55d7e7f1acd992ed5d,src/lib/openjp2/t1.c,opj_t1_encode_cblks,"OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1,
opj_tcd_tile_t *tile,
opj_tcp_t *tcp,
const OPJ_FLOAT64 * mct_norms,
OPJ_UINT32 mct_numcomps
)
{
OPJ_UINT32 compno, resno, bandno, precno, cblkno;
tile->distotile = 0;        
for (compno = 0; compno < tile->numcomps; ++compno) {
opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
opj_tccp_t* tccp = &tcp->tccps[compno];
OPJ_UINT32 tile_w = (OPJ_UINT32)(tilec->x1 - tilec->x0);
for (resno = 0; resno < tilec->numresolutions; ++resno) {
opj_tcd_resolution_t *res = &tilec->resolutions[resno];
for (bandno = 0; bandno < res->numbands; ++bandno) {
opj_tcd_band_t* OPJ_RESTRICT band = &res->bands[bandno];
OPJ_INT32 bandconst;
if (opj_tcd_is_band_empty(band)) {
continue;
}
bandconst = 8192 * 8192 / ((OPJ_INT32) floor(band->stepsize * 8192));
for (precno = 0; precno < res->pw * res->ph; ++precno) {
opj_tcd_precinct_t *prc = &band->precincts[precno];
for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
OPJ_INT32* OPJ_RESTRICT tiledp;
OPJ_UINT32 cblk_w;
OPJ_UINT32 cblk_h;
OPJ_UINT32 i, j, tileLineAdvance;
OPJ_SIZE_T tileIndex = 0;
OPJ_INT32 x = cblk->x0 - band->x0;
OPJ_INT32 y = cblk->y0 - band->y0;
if (band->bandno & 1) {
opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
x += pres->x1 - pres->x0;
}
if (band->bandno & 2) {
opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
y += pres->y1 - pres->y0;
}
if (!opj_t1_allocate_buffers(
t1,
(OPJ_UINT32)(cblk->x1 - cblk->x0),
(OPJ_UINT32)(cblk->y1 - cblk->y0))) {
return OPJ_FALSE;
}
cblk_w = t1->w;
cblk_h = t1->h;
tileLineAdvance = tile_w - cblk_w;
tiledp = &tilec->data[(OPJ_SIZE_T)y * tile_w + (OPJ_SIZE_T)x];
t1->data = tiledp;
t1->data_stride = tile_w;
if (tccp->qmfbid == 1) {
for (j = 0; j < cblk_h; ++j) {
for (i = 0; i < cblk_w; ++i) {
tiledp[tileIndex] *= (1 << T1_NMSEDEC_FRACBITS);
tileIndex++;
}
tileIndex += tileLineAdvance;
}
} else {        
for (j = 0; j < cblk_h; ++j) {
for (i = 0; i < cblk_w; ++i) {
OPJ_INT32 tmp = tiledp[tileIndex];
tiledp[tileIndex] =
opj_int_fix_mul_t1(
tmp,
bandconst);
tileIndex++;
}
tileIndex += tileLineAdvance;
}
}
opj_t1_encode_cblk(
t1,
cblk,
band->bandno,
compno,
tilec->numresolutions - 1 - resno,
tccp->qmfbid,
band->stepsize,
tccp->cblksty,
tile->numcomps,
tile,
mct_norms,
mct_numcomps);
} 
} 
} 
} 
} 
return OPJ_TRUE;
}","OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *VAR_0,
opj_tcd_tile_t *VAR_1,
opj_tcp_t *VAR_2,
const OPJ_FLOAT64 * VAR_3,
OPJ_UINT32 VAR_4
)
{
OPJ_UINT32 VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;
VAR_1->distotile = 0;        
for (VAR_5 = 0; VAR_5 < VAR_1->numcomps; ++VAR_5) {
opj_tcd_tilecomp_t* VAR_10 = &VAR_1->comps[VAR_5];
opj_tccp_t* VAR_11 = &VAR_2->tccps[VAR_5];
OPJ_UINT32 VAR_12 = (OPJ_UINT32)(VAR_10->x1 - VAR_10->x0);
for (VAR_6 = 0; VAR_6 < VAR_10->numresolutions; ++VAR_6) {
opj_tcd_resolution_t *VAR_13 = &VAR_10->resolutions[VAR_6];
for (VAR_7 = 0; VAR_7 < VAR_13->numbands; ++VAR_7) {
VAR_14* VAR_15 VAR_16 = &VAR_13->bands[VAR_7];
OPJ_INT32 VAR_17;
if (opj_tcd_is_band_empty(VAR_16)) {
continue;
}
VAR_17 = 8192 * 8192 / ((OPJ_INT32) floor(VAR_16->stepsize * 8192));
for (VAR_8 = 0; VAR_8 < VAR_13->pw * VAR_13->ph; ++VAR_8) {
opj_tcd_precinct_t *VAR_18 = &VAR_16->precincts[VAR_8];
for (VAR_9 = 0; VAR_9 < VAR_18->cw * VAR_18->ch; ++VAR_9) {
opj_tcd_cblk_enc_t* VAR_19 = &VAR_18->cblks.enc[VAR_9];
OPJ_INT32* VAR_15 VAR_20;
OPJ_UINT32 VAR_21;
OPJ_UINT32 VAR_22;
OPJ_UINT32 VAR_23, VAR_24, VAR_25;
OPJ_SIZE_T VAR_26 = 0;
OPJ_INT32 VAR_27 = VAR_19->x0 - VAR_16->x0;
OPJ_INT32 VAR_28 = VAR_19->y0 - VAR_16->y0;
if (VAR_16->bandno & 1) {
opj_tcd_resolution_t *VAR_29 = &VAR_10->resolutions[VAR_6 - 1];
VAR_27 += VAR_29->x1 - VAR_29->x0;
}
if (VAR_16->bandno & 2) {
opj_tcd_resolution_t *VAR_29 = &VAR_10->resolutions[VAR_6 - 1];
VAR_28 += VAR_29->y1 - VAR_29->y0;
}
if (!opj_t1_allocate_buffers(
VAR_0,
(OPJ_UINT32)(VAR_19->x1 - VAR_19->x0),
(OPJ_UINT32)(VAR_19->y1 - VAR_19->y0))) {
return VAR_30;
}
VAR_21 = VAR_0->w;
VAR_22 = VAR_0->h;
VAR_25 = VAR_12 - VAR_21;
VAR_20 = &VAR_10->data[(OPJ_SIZE_T)VAR_28 * VAR_12 + (OPJ_SIZE_T)VAR_27];
VAR_0->data = VAR_20;
VAR_0->data_stride = VAR_12;
if (VAR_11->qmfbid == 1) {
for (VAR_24 = 0; VAR_24 < VAR_22; ++VAR_24) {
for (VAR_23 = 0; VAR_23 < VAR_21; ++VAR_23) {
VAR_20[VAR_26] *= (1 << VAR_31);
VAR_26++;
}
VAR_26 += VAR_25;
}
} else {        
for (VAR_24 = 0; VAR_24 < VAR_22; ++VAR_24) {
for (VAR_23 = 0; VAR_23 < VAR_21; ++VAR_23) {
OPJ_INT32 VAR_32 = VAR_20[VAR_26];
VAR_20[VAR_26] =
opj_int_fix_mul_t1(
VAR_32,
VAR_17);
VAR_26++;
}
VAR_26 += VAR_25;
}
}
opj_t1_encode_cblk(
VAR_0,
VAR_19,
VAR_16->bandno,
VAR_5,
VAR_10->numresolutions - 1 - VAR_6,
VAR_11->qmfbid,
VAR_16->stepsize,
VAR_11->cblksty,
VAR_1->numcomps,
VAR_1,
VAR_3,
VAR_4);
} 
} 
} 
} 
} 
return VAR_33;
}",uclouvain/openjpeg/a1d32a596a94280178c44a55d7e7f1acd992ed5d/t1.c/vul/before/0.json,"OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *t1,
                             opj_tcd_tile_t *tile,
                             opj_tcp_t *tcp,
                             const OPJ_FLOAT64 * mct_norms,
                             OPJ_UINT32 mct_numcomps
                            )
{
    OPJ_UINT32 compno, resno, bandno, precno, cblkno;

    tile->distotile = 0;        /* fixed_quality */

    for (compno = 0; compno < tile->numcomps; ++compno) {
        opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
        opj_tccp_t* tccp = &tcp->tccps[compno];
        OPJ_UINT32 tile_w = (OPJ_UINT32)(tilec->x1 - tilec->x0);

        for (resno = 0; resno < tilec->numresolutions; ++resno) {
            opj_tcd_resolution_t *res = &tilec->resolutions[resno];

            for (bandno = 0; bandno < res->numbands; ++bandno) {
                opj_tcd_band_t* OPJ_RESTRICT band = &res->bands[bandno];
                OPJ_INT32 bandconst;

                /* Skip empty bands */
                if (opj_tcd_is_band_empty(band)) {
                    continue;
                }

                bandconst = 8192 * 8192 / ((OPJ_INT32) floor(band->stepsize * 8192));
                for (precno = 0; precno < res->pw * res->ph; ++precno) {
                    opj_tcd_precinct_t *prc = &band->precincts[precno];

                    for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
                        opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
                        OPJ_INT32* OPJ_RESTRICT tiledp;
                        OPJ_UINT32 cblk_w;
                        OPJ_UINT32 cblk_h;
                        OPJ_UINT32 i, j, tileLineAdvance;
                        OPJ_SIZE_T tileIndex = 0;

                        OPJ_INT32 x = cblk->x0 - band->x0;
                        OPJ_INT32 y = cblk->y0 - band->y0;
                        if (band->bandno & 1) {
                            opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
                            x += pres->x1 - pres->x0;
                        }
                        if (band->bandno & 2) {
                            opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
                            y += pres->y1 - pres->y0;
                        }

                        if (!opj_t1_allocate_buffers(
                                    t1,
                                    (OPJ_UINT32)(cblk->x1 - cblk->x0),
                                    (OPJ_UINT32)(cblk->y1 - cblk->y0))) {
                            return OPJ_FALSE;
                        }

                        cblk_w = t1->w;
                        cblk_h = t1->h;
                        tileLineAdvance = tile_w - cblk_w;

                        tiledp = &tilec->data[(OPJ_SIZE_T)y * tile_w + (OPJ_SIZE_T)x];
                        t1->data = tiledp;
                        t1->data_stride = tile_w;
                        if (tccp->qmfbid == 1) {
                            /* Do multiplication on unsigned type, even if the
                             * underlying type is signed, to avoid potential
                             * int overflow on large value (the output will be
                             * incorrect in such situation, but whatever...)
                             * This assumes complement-to-2 signed integer
                             * representation
                             * Fixes https://github.com/uclouvain/openjpeg/issues/1053
                             */
                            OPJ_UINT32* OPJ_RESTRICT tiledp_u = (OPJ_UINT32*) tiledp;
                            for (j = 0; j < cblk_h; ++j) {
                                for (i = 0; i < cblk_w; ++i) {
                                    tiledp_u[tileIndex] <<= T1_NMSEDEC_FRACBITS;
                                    tileIndex++;
                                }
                                tileIndex += tileLineAdvance;
                            }
                        } else {        /* if (tccp->qmfbid == 0) */
                            for (j = 0; j < cblk_h; ++j) {
                                for (i = 0; i < cblk_w; ++i) {
                                    OPJ_INT32 tmp = tiledp[tileIndex];
                                    tiledp[tileIndex] =
                                        opj_int_fix_mul_t1(
                                            tmp,
                                            bandconst);
                                    tileIndex++;
                                }
                                tileIndex += tileLineAdvance;
                            }
                        }

                        opj_t1_encode_cblk(
                            t1,
                            cblk,
                            band->bandno,
                            compno,
                            tilec->numresolutions - 1 - resno,
                            tccp->qmfbid,
                            band->stepsize,
                            tccp->cblksty,
                            tile->numcomps,
                            tile,
                            mct_norms,
                            mct_numcomps);

                    } /* cblkno */
                } /* precno */
            } /* bandno */
        } /* resno  */
    } /* compno  */
    return OPJ_TRUE;
}","OPJ_BOOL opj_t1_encode_cblks(opj_t1_t *VAR_0,
                             opj_tcd_tile_t *VAR_1,
                             opj_tcp_t *VAR_2,
                             const OPJ_FLOAT64 * VAR_3,
                             OPJ_UINT32 VAR_4
                            )
{
    OPJ_UINT32 VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;

    VAR_1->distotile = 0;        /* COMMENT_0 */

    for (VAR_5 = 0; VAR_5 < VAR_1->numcomps; ++VAR_5) {
        opj_tcd_tilecomp_t* VAR_10 = &VAR_1->comps[VAR_5];
        opj_tccp_t* VAR_11 = &VAR_2->tccps[VAR_5];
        OPJ_UINT32 VAR_12 = (OPJ_UINT32)(VAR_10->x1 - VAR_10->x0);

        for (VAR_6 = 0; VAR_6 < VAR_10->numresolutions; ++VAR_6) {
            opj_tcd_resolution_t *VAR_13 = &VAR_10->resolutions[VAR_6];

            for (VAR_7 = 0; VAR_7 < VAR_13->numbands; ++VAR_7) {
                VAR_14* VAR_15 VAR_16 = &VAR_13->bands[VAR_7];
                OPJ_INT32 VAR_17;

                /* COMMENT_1 */
                if (opj_tcd_is_band_empty(VAR_16)) {
                    continue;
                }

                VAR_17 = 8192 * 8192 / ((OPJ_INT32) floor(VAR_16->stepsize * 8192));
                for (VAR_8 = 0; VAR_8 < VAR_13->pw * VAR_13->ph; ++VAR_8) {
                    opj_tcd_precinct_t *VAR_18 = &VAR_16->precincts[VAR_8];

                    for (VAR_9 = 0; VAR_9 < VAR_18->cw * VAR_18->ch; ++VAR_9) {
                        opj_tcd_cblk_enc_t* VAR_19 = &VAR_18->cblks.enc[VAR_9];
                        OPJ_INT32* VAR_15 VAR_20;
                        OPJ_UINT32 VAR_21;
                        OPJ_UINT32 VAR_22;
                        OPJ_UINT32 VAR_23, VAR_24, VAR_25;
                        OPJ_SIZE_T VAR_26 = 0;

                        OPJ_INT32 VAR_27 = VAR_19->x0 - VAR_16->x0;
                        OPJ_INT32 VAR_28 = VAR_19->y0 - VAR_16->y0;
                        if (VAR_16->bandno & 1) {
                            opj_tcd_resolution_t *VAR_29 = &VAR_10->resolutions[VAR_6 - 1];
                            VAR_27 += VAR_29->x1 - VAR_29->x0;
                        }
                        if (VAR_16->bandno & 2) {
                            opj_tcd_resolution_t *VAR_29 = &VAR_10->resolutions[VAR_6 - 1];
                            VAR_28 += VAR_29->y1 - VAR_29->y0;
                        }

                        if (!opj_t1_allocate_buffers(
                                    VAR_0,
                                    (OPJ_UINT32)(VAR_19->x1 - VAR_19->x0),
                                    (OPJ_UINT32)(VAR_19->y1 - VAR_19->y0))) {
                            return VAR_30;
                        }

                        VAR_21 = VAR_0->w;
                        VAR_22 = VAR_0->h;
                        VAR_25 = VAR_12 - VAR_21;

                        VAR_20 = &VAR_10->data[(OPJ_SIZE_T)VAR_28 * VAR_12 + (OPJ_SIZE_T)VAR_27];
                        VAR_0->data = VAR_20;
                        VAR_0->data_stride = VAR_12;
                        if (VAR_11->qmfbid == 1) {
                            /* COMMENT_2 */
                                                                            
                                                                              
                                                                            
                                                                          
                                             
                                                                                      
                               
                            OPJ_UINT32* VAR_15 VAR_31 = (OPJ_UINT32*) VAR_20;
                            for (VAR_24 = 0; VAR_24 < VAR_22; ++VAR_24) {
                                for (VAR_23 = 0; VAR_23 < VAR_21; ++VAR_23) {
                                    VAR_31[VAR_26] <<= VAR_32;
                                    VAR_26++;
                                }
                                VAR_26 += VAR_25;
                            }
                        } else {        /* COMMENT_10 */
                            for (VAR_24 = 0; VAR_24 < VAR_22; ++VAR_24) {
                                for (VAR_23 = 0; VAR_23 < VAR_21; ++VAR_23) {
                                    OPJ_INT32 VAR_33 = VAR_20[VAR_26];
                                    VAR_20[VAR_26] =
                                        opj_int_fix_mul_t1(
                                            VAR_33,
                                            VAR_17);
                                    VAR_26++;
                                }
                                VAR_26 += VAR_25;
                            }
                        }

                        opj_t1_encode_cblk(
                            VAR_0,
                            VAR_19,
                            VAR_16->bandno,
                            VAR_5,
                            VAR_10->numresolutions - 1 - VAR_6,
                            VAR_11->qmfbid,
                            VAR_16->stepsize,
                            VAR_11->cblksty,
                            VAR_1->numcomps,
                            VAR_1,
                            VAR_3,
                            VAR_4);

                    } /* COMMENT_11 */
                } /* COMMENT_12 */
            } /* COMMENT_13 */
        } /* COMMENT_14 */
    } /* COMMENT_15 */
    return VAR_34;
}",uclouvain/openjpeg/a1d32a596a94280178c44a55d7e7f1acd992ed5d/t1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -64,9 +64,18 @@
                         t1->data = tiledp;
                         t1->data_stride = tile_w;
                         if (tccp->qmfbid == 1) {
+                            /* Do multiplication on unsigned type, even if the
+                             * underlying type is signed, to avoid potential
+                             * int overflow on large value (the output will be
+                             * incorrect in such situation, but whatever...)
+                             * This assumes complement-to-2 signed integer
+                             * representation
+                             * Fixes https://github.com/uclouvain/openjpeg/issues/1053
+                             */
+                            OPJ_UINT32* OPJ_RESTRICT tiledp_u = (OPJ_UINT32*) tiledp;
                             for (j = 0; j < cblk_h; ++j) {
                                 for (i = 0; i < cblk_w; ++i) {
-                                    tiledp[tileIndex] *= (1 << T1_NMSEDEC_FRACBITS);
+                                    tiledp_u[tileIndex] <<= T1_NMSEDEC_FRACBITS;
                                     tileIndex++;
                                 }
                                 tileIndex += tileLineAdvance;","{'deleted_lines': ['                                    tiledp[tileIndex] *= (1 << T1_NMSEDEC_FRACBITS);'], 'added_lines': ['                            /* Do multiplication on unsigned type, even if the', '                             * underlying type is signed, to avoid potential', '                             * int overflow on large value (the output will be', '                             * incorrect in such situation, but whatever...)', '                             * This assumes complement-to-2 signed integer', '                             * representation', '                             * Fixes https://github.com/uclouvain/openjpeg/issues/1053', '                             */', '                            OPJ_UINT32* OPJ_RESTRICT tiledp_u = (OPJ_UINT32*) tiledp;', '                                    tiledp_u[tileIndex] <<= T1_NMSEDEC_FRACBITS;']}",True,"In OpenJPEG 2.3.0, there is an integer overflow vulnerability in the opj_t1_encode_cblks function (openjp2/t1.c). Remote attackers could leverage this vulnerability to cause a denial of service via a crafted bmp file.",6.5,MEDIUM,1,test,2019-03-29T10:17:39Z,2
CVE-2019-12975,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1517,ee5b9c56b9ca18ed0750f8a15e0d1a6da92a6e99,https://github.com/ImageMagick/ImageMagick/commit/ee5b9c56b9ca18ed0750f8a15e0d1a6da92a6e99,coders/dpx.c,WriteDPXImage,"static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
const char
*value;
const StringInfo
*profile;
DPXInfo
dpx;
GeometryInfo
geometry_info;
MagickBooleanType
status;
MagickOffsetType
offset;
MagickStatusType
flags;
QuantumInfo
*quantum_info;
QuantumType
quantum_type;
register const Quantum
*p;
register ssize_t
i;
size_t
channels,
extent;
ssize_t
count,
horizontal_factor,
vertical_factor,
y;
time_t
seconds;
unsigned char
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
horizontal_factor=4;
vertical_factor=4;
if (image_info->sampling_factor != (char *) NULL)
{
flags=ParseGeometry(image_info->sampling_factor,&geometry_info);
horizontal_factor=(ssize_t) geometry_info.rho;
vertical_factor=(ssize_t) geometry_info.sigma;
if ((flags & SigmaValue) == 0)
vertical_factor=horizontal_factor;
if ((horizontal_factor != 1) && (horizontal_factor != 2) &&
(horizontal_factor != 4) && (vertical_factor != 1) &&
(vertical_factor != 2) && (vertical_factor != 4))
ThrowWriterException(CorruptImageError,""UnexpectedSamplingFactor"");
}
if ((image->colorspace == YCbCrColorspace) &&
((horizontal_factor == 2) || (vertical_factor == 2)))
if ((image->columns % 2) != 0)
image->columns++;
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
(void) memset(&dpx,0,sizeof(dpx));
offset=0;
dpx.file.magic=0x53445058U;
offset+=WriteBlobLong(image,dpx.file.magic);
dpx.file.image_offset=0x2000U;
profile=GetImageProfile(image,""dpx:user-data"");
if (profile != (StringInfo *) NULL)
{
if (GetStringInfoLength(profile) > 1048576)
ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
dpx.file.image_offset+=(unsigned int) GetStringInfoLength(profile);
dpx.file.image_offset=(((dpx.file.image_offset+0x2000-1)/0x2000)*0x2000);
}
offset+=WriteBlobLong(image,dpx.file.image_offset);
(void) strncpy(dpx.file.version,""V2.0"",sizeof(dpx.file.version)-1);
offset+=WriteBlob(image,8,(unsigned char *) &dpx.file.version);
channels=1;
if (IsImageGray(image) == MagickFalse)
channels=3;
if (image->alpha_trait != UndefinedPixelTrait)
channels++;
dpx.file.file_size=(unsigned int) (channels*image->columns*image->rows+
dpx.file.image_offset);
offset+=WriteBlobLong(image,dpx.file.file_size);
dpx.file.ditto_key=1U;  
offset+=WriteBlobLong(image,dpx.file.ditto_key);
dpx.file.generic_size=0x00000680U;
offset+=WriteBlobLong(image,dpx.file.generic_size);
dpx.file.industry_size=0x00000180U;
offset+=WriteBlobLong(image,dpx.file.industry_size);
dpx.file.user_size=0;
if (profile != (StringInfo *) NULL)
{
dpx.file.user_size+=(unsigned int) GetStringInfoLength(profile);
dpx.file.user_size=(((dpx.file.user_size+0x2000-1)/0x2000)*0x2000);
}
offset+=WriteBlobLong(image,dpx.file.user_size);
value=GetDPXProperty(image,""dpx:file.filename"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.file.filename,value,sizeof(dpx.file.filename)-1);
offset+=WriteBlob(image,sizeof(dpx.file.filename),(unsigned char *)
dpx.file.filename);
seconds=time((time_t *) NULL);
(void) FormatMagickTime(seconds,sizeof(dpx.file.timestamp),
dpx.file.timestamp);
offset+=WriteBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)
dpx.file.timestamp);
(void) strncpy(dpx.file.creator,MagickAuthoritativeURL,
sizeof(dpx.file.creator)-1);
value=GetDPXProperty(image,""dpx:file.creator"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.file.creator,value,sizeof(dpx.file.creator)-1);
offset+=WriteBlob(image,sizeof(dpx.file.creator),(unsigned char *)
dpx.file.creator);
value=GetDPXProperty(image,""dpx:file.project"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.file.project,value,sizeof(dpx.file.project)-1);
offset+=WriteBlob(image,sizeof(dpx.file.project),(unsigned char *)
dpx.file.project);
value=GetDPXProperty(image,""dpx:file.copyright"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.file.copyright,value,sizeof(dpx.file.copyright)-1);
offset+=WriteBlob(image,sizeof(dpx.file.copyright),(unsigned char *)
dpx.file.copyright);
dpx.file.encrypt_key=(~0U);
offset+=WriteBlobLong(image,dpx.file.encrypt_key);
offset+=WriteBlob(image,sizeof(dpx.file.reserve),(unsigned char *)
dpx.file.reserve);
switch (image->orientation)
{
default:
case TopLeftOrientation: dpx.image.orientation=0; break;
case TopRightOrientation: dpx.image.orientation=1; break;
case BottomLeftOrientation: dpx.image.orientation=2; break;
case BottomRightOrientation: dpx.image.orientation=3; break;
case LeftTopOrientation: dpx.image.orientation=4; break;
case RightTopOrientation: dpx.image.orientation=5; break;
case LeftBottomOrientation: dpx.image.orientation=6; break;
case RightBottomOrientation: dpx.image.orientation=7; break;
}
offset+=WriteBlobShort(image,dpx.image.orientation);
dpx.image.number_elements=1;
offset+=WriteBlobShort(image,dpx.image.number_elements);
if ((image->columns != (unsigned int) image->columns) ||
(image->rows != (unsigned int) image->rows))
ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
offset+=WriteBlobLong(image,(unsigned int) image->columns);
offset+=WriteBlobLong(image,(unsigned int) image->rows);
for (i=0; i < 8; i++)
{
dpx.image.image_element[i].data_sign=0U;
offset+=WriteBlobLong(image,dpx.image.image_element[i].data_sign);
dpx.image.image_element[i].low_data=0U;
offset+=WriteBlobLong(image,dpx.image.image_element[i].low_data);
dpx.image.image_element[i].low_quantity=0.0f;
offset+=WriteBlobFloat(image,dpx.image.image_element[i].low_quantity);
dpx.image.image_element[i].high_data=0U;
offset+=WriteBlobLong(image,dpx.image.image_element[i].high_data);
dpx.image.image_element[i].high_quantity=0.0f;
offset+=WriteBlobFloat(image,dpx.image.image_element[i].high_quantity);
dpx.image.image_element[i].descriptor=0;
if (i == 0)
switch (image->colorspace)
{
case Rec601YCbCrColorspace:
case Rec709YCbCrColorspace:
case YCbCrColorspace:
{
dpx.image.image_element[i].descriptor=CbYCr444ComponentType;
if (image->alpha_trait != UndefinedPixelTrait)
dpx.image.image_element[i].descriptor=CbYCrA4444ComponentType;
break;
}
default:
{
dpx.image.image_element[i].descriptor=RGBComponentType;
if (image->alpha_trait != UndefinedPixelTrait)
dpx.image.image_element[i].descriptor=RGBAComponentType;
if ((image_info->type != TrueColorType) &&
(image->alpha_trait == UndefinedPixelTrait) &&
(SetImageGray(image,exception) != MagickFalse))
dpx.image.image_element[i].descriptor=LumaComponentType;
break;
}
}
offset+=WriteBlobByte(image,dpx.image.image_element[i].descriptor);
dpx.image.image_element[i].transfer_characteristic=0;
if (image->colorspace == LogColorspace)
dpx.image.image_element[0].transfer_characteristic=
PrintingDensityColorimetric;
offset+=WriteBlobByte(image,
dpx.image.image_element[i].transfer_characteristic);
dpx.image.image_element[i].colorimetric=0;
offset+=WriteBlobByte(image,dpx.image.image_element[i].colorimetric);
dpx.image.image_element[i].bit_size=0;
if (i == 0)
dpx.image.image_element[i].bit_size=(unsigned char) image->depth;
offset+=WriteBlobByte(image,dpx.image.image_element[i].bit_size);
dpx.image.image_element[i].packing=0;
if ((image->depth == 10) || (image->depth == 12))
dpx.image.image_element[i].packing=1;
offset+=WriteBlobShort(image,dpx.image.image_element[i].packing);
dpx.image.image_element[i].encoding=0;
offset+=WriteBlobShort(image,dpx.image.image_element[i].encoding);
dpx.image.image_element[i].data_offset=0U;
if (i == 0)
dpx.image.image_element[i].data_offset=dpx.file.image_offset;
offset+=WriteBlobLong(image,dpx.image.image_element[i].data_offset);
dpx.image.image_element[i].end_of_line_padding=0U;
offset+=WriteBlobLong(image,dpx.image.image_element[i].end_of_line_padding);
offset+=WriteBlobLong(image,
dpx.image.image_element[i].end_of_image_padding);
offset+=WriteBlob(image,sizeof(dpx.image.image_element[i].description),
(unsigned char *) dpx.image.image_element[i].description);
}
offset+=WriteBlob(image,sizeof(dpx.image.reserve),(unsigned char *)
dpx.image.reserve);
if ((image->rows != image->magick_rows) ||
(image->columns != image->magick_columns))
{
(void) DeleteImageProperty(image,""dpx:orientation.x_offset"");
(void) DeleteImageProperty(image,""dpx:orientation.y_offset"");
(void) DeleteImageProperty(image,""dpx:orientation.x_center"");
(void) DeleteImageProperty(image,""dpx:orientation.y_center"");
(void) DeleteImageProperty(image,""dpx:orientation.x_size"");
(void) DeleteImageProperty(image,""dpx:orientation.y_size"");
}
dpx.orientation.x_offset=0U;
value=GetDPXProperty(image,""dpx:orientation.x_offset"",exception);
if (value != (const char *) NULL)
dpx.orientation.x_offset=(unsigned int) StringToUnsignedLong(value);
offset+=WriteBlobLong(image,dpx.orientation.x_offset);
dpx.orientation.y_offset=0U;
value=GetDPXProperty(image,""dpx:orientation.y_offset"",exception);
if (value != (const char *) NULL)
dpx.orientation.y_offset=(unsigned int) StringToUnsignedLong(value);
offset+=WriteBlobLong(image,dpx.orientation.y_offset);
dpx.orientation.x_center=0.0f;
value=GetDPXProperty(image,""dpx:orientation.x_center"",exception);
if (value != (const char *) NULL)
dpx.orientation.x_center=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.orientation.x_center);
dpx.orientation.y_center=0.0f;
value=GetDPXProperty(image,""dpx:orientation.y_center"",exception);
if (value != (const char *) NULL)
dpx.orientation.y_center=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.orientation.y_center);
dpx.orientation.x_size=0U;
value=GetDPXProperty(image,""dpx:orientation.x_size"",exception);
if (value != (const char *) NULL)
dpx.orientation.x_size=(unsigned int) StringToUnsignedLong(value);
offset+=WriteBlobLong(image,dpx.orientation.x_size);
dpx.orientation.y_size=0U;
value=GetDPXProperty(image,""dpx:orientation.y_size"",exception);
if (value != (const char *) NULL)
dpx.orientation.y_size=(unsigned int) StringToUnsignedLong(value);
offset+=WriteBlobLong(image,dpx.orientation.y_size);
value=GetDPXProperty(image,""dpx:orientation.filename"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.orientation.filename,value,
sizeof(dpx.orientation.filename)-1);
offset+=WriteBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)
dpx.orientation.filename);
offset+=WriteBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)
dpx.orientation.timestamp);
value=GetDPXProperty(image,""dpx:orientation.device"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.orientation.device,value,
sizeof(dpx.orientation.device)-1);
offset+=WriteBlob(image,sizeof(dpx.orientation.device),(unsigned char *)
dpx.orientation.device);
value=GetDPXProperty(image,""dpx:orientation.serial"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.orientation.serial,value,
sizeof(dpx.orientation.serial)-1);
offset+=WriteBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)
dpx.orientation.serial);
for (i=0; i < 4; i++)
dpx.orientation.border[i]=0;
value=GetDPXProperty(image,""dpx:orientation.border"",exception);
if (value != (const char *) NULL)
{
flags=ParseGeometry(value,&geometry_info);
if ((flags & SigmaValue) == 0)
geometry_info.sigma=geometry_info.rho;
dpx.orientation.border[0]=(unsigned short) (geometry_info.rho+0.5);
dpx.orientation.border[1]=(unsigned short) (geometry_info.sigma+0.5);
dpx.orientation.border[2]=(unsigned short) (geometry_info.xi+0.5);
dpx.orientation.border[3]=(unsigned short) (geometry_info.psi+0.5);
}
for (i=0; i < 4; i++)
offset+=WriteBlobShort(image,dpx.orientation.border[i]);
for (i=0; i < 2; i++)
dpx.orientation.aspect_ratio[i]=0U;
value=GetDPXProperty(image,""dpx:orientation.aspect_ratio"",exception);
if (value != (const char *) NULL)
{
flags=ParseGeometry(value,&geometry_info);
if ((flags & SigmaValue) == 0)
geometry_info.sigma=geometry_info.rho;
dpx.orientation.aspect_ratio[0]=(unsigned int) (geometry_info.rho+0.5);
dpx.orientation.aspect_ratio[1]=(unsigned int) (geometry_info.sigma+0.5);
}
for (i=0; i < 2; i++)
offset+=WriteBlobLong(image,dpx.orientation.aspect_ratio[i]);
offset+=WriteBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)
dpx.orientation.reserve);
(void) memset(dpx.film.id,0,sizeof(dpx.film.id));
value=GetDPXProperty(image,""dpx:film.id"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.id,value,sizeof(dpx.film.id)-1);
offset+=WriteBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);
(void) memset(dpx.film.type,0,sizeof(dpx.film.type));
value=GetDPXProperty(image,""dpx:film.type"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.type,value,sizeof(dpx.film.type)-1);
offset+=WriteBlob(image,sizeof(dpx.film.type),(unsigned char *)
dpx.film.type);
(void) memset(dpx.film.offset,0,sizeof(dpx.film.offset));
value=GetDPXProperty(image,""dpx:film.offset"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.offset,value,sizeof(dpx.film.offset)-1);
offset+=WriteBlob(image,sizeof(dpx.film.offset),(unsigned char *)
dpx.film.offset);
(void) memset(dpx.film.prefix,0,sizeof(dpx.film.prefix));
value=GetDPXProperty(image,""dpx:film.prefix"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.prefix,value,sizeof(dpx.film.prefix)-1);
offset+=WriteBlob(image,sizeof(dpx.film.prefix),(unsigned char *)
dpx.film.prefix);
(void) memset(dpx.film.count,0,sizeof(dpx.film.count));
value=GetDPXProperty(image,""dpx:film.count"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.count,value,sizeof(dpx.film.count)-1);
offset+=WriteBlob(image,sizeof(dpx.film.count),(unsigned char *)
dpx.film.count);
(void) memset(dpx.film.format,0,sizeof(dpx.film.format));
value=GetDPXProperty(image,""dpx:film.format"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.format,value,sizeof(dpx.film.format)-1);
offset+=WriteBlob(image,sizeof(dpx.film.format),(unsigned char *)
dpx.film.format);
dpx.film.frame_position=0U;
value=GetDPXProperty(image,""dpx:film.frame_position"",exception);
if (value != (const char *) NULL)
dpx.film.frame_position=(unsigned int) StringToUnsignedLong(value);
offset+=WriteBlobLong(image,dpx.film.frame_position);
dpx.film.sequence_extent=0U;
value=GetDPXProperty(image,""dpx:film.sequence_extent"",exception);
if (value != (const char *) NULL)
dpx.film.sequence_extent=(unsigned int) StringToUnsignedLong(value);
offset+=WriteBlobLong(image,dpx.film.sequence_extent);
dpx.film.held_count=0U;
value=GetDPXProperty(image,""dpx:film.held_count"",exception);
if (value != (const char *) NULL)
dpx.film.held_count=(unsigned int) StringToUnsignedLong(value);
offset+=WriteBlobLong(image,dpx.film.held_count);
dpx.film.frame_rate=0.0f;
value=GetDPXProperty(image,""dpx:film.frame_rate"",exception);
if (value != (const char *) NULL)
dpx.film.frame_rate=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.film.frame_rate);
dpx.film.shutter_angle=0.0f;
value=GetDPXProperty(image,""dpx:film.shutter_angle"",exception);
if (value != (const char *) NULL)
dpx.film.shutter_angle=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.film.shutter_angle);
(void) memset(dpx.film.frame_id,0,sizeof(dpx.film.frame_id));
value=GetDPXProperty(image,""dpx:film.frame_id"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.frame_id,value,sizeof(dpx.film.frame_id)-1);
offset+=WriteBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)
dpx.film.frame_id);
value=GetDPXProperty(image,""dpx:film.slate"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.film.slate,value,sizeof(dpx.film.slate)-1);
offset+=WriteBlob(image,sizeof(dpx.film.slate),(unsigned char *)
dpx.film.slate);
offset+=WriteBlob(image,sizeof(dpx.film.reserve),(unsigned char *)
dpx.film.reserve);
value=GetDPXProperty(image,""dpx:television.time.code"",exception);
if (value != (const char *) NULL)
dpx.television.time_code=StringToTimeCode(value);
offset+=WriteBlobLong(image,dpx.television.time_code);
value=GetDPXProperty(image,""dpx:television.user.bits"",exception);
if (value != (const char *) NULL)
dpx.television.user_bits=StringToTimeCode(value);
offset+=WriteBlobLong(image,dpx.television.user_bits);
value=GetDPXProperty(image,""dpx:television.interlace"",exception);
if (value != (const char *) NULL)
dpx.television.interlace=(unsigned char) StringToLong(value);
offset+=WriteBlobByte(image,dpx.television.interlace);
value=GetDPXProperty(image,""dpx:television.field_number"",exception);
if (value != (const char *) NULL)
dpx.television.field_number=(unsigned char) StringToLong(value);
offset+=WriteBlobByte(image,dpx.television.field_number);
dpx.television.video_signal=0;
value=GetDPXProperty(image,""dpx:television.video_signal"",exception);
if (value != (const char *) NULL)
dpx.television.video_signal=(unsigned char) StringToLong(value);
offset+=WriteBlobByte(image,dpx.television.video_signal);
dpx.television.padding=0;
value=GetDPXProperty(image,""dpx:television.padding"",exception);
if (value != (const char *) NULL)
dpx.television.padding=(unsigned char) StringToLong(value);
offset+=WriteBlobByte(image,dpx.television.padding);
dpx.television.horizontal_sample_rate=0.0f;
value=GetDPXProperty(image,""dpx:television.horizontal_sample_rate"",
exception);
if (value != (const char *) NULL)
dpx.television.horizontal_sample_rate=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.horizontal_sample_rate);
dpx.television.vertical_sample_rate=0.0f;
value=GetDPXProperty(image,""dpx:television.vertical_sample_rate"",exception);
if (value != (const char *) NULL)
dpx.television.vertical_sample_rate=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.vertical_sample_rate);
dpx.television.frame_rate=0.0f;
value=GetDPXProperty(image,""dpx:television.frame_rate"",exception);
if (value != (const char *) NULL)
dpx.television.frame_rate=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.frame_rate);
dpx.television.time_offset=0.0f;
value=GetDPXProperty(image,""dpx:television.time_offset"",exception);
if (value != (const char *) NULL)
dpx.television.time_offset=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.time_offset);
dpx.television.gamma=0.0f;
value=GetDPXProperty(image,""dpx:television.gamma"",exception);
if (value != (const char *) NULL)
dpx.television.gamma=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.gamma);
dpx.television.black_level=0.0f;
value=GetDPXProperty(image,""dpx:television.black_level"",exception);
if (value != (const char *) NULL)
dpx.television.black_level=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.black_level);
dpx.television.black_gain=0.0f;
value=GetDPXProperty(image,""dpx:television.black_gain"",exception);
if (value != (const char *) NULL)
dpx.television.black_gain=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.black_gain);
dpx.television.break_point=0.0f;
value=GetDPXProperty(image,""dpx:television.break_point"",exception);
if (value != (const char *) NULL)
dpx.television.break_point=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.break_point);
dpx.television.white_level=0.0f;
value=GetDPXProperty(image,""dpx:television.white_level"",exception);
if (value != (const char *) NULL)
dpx.television.white_level=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.white_level);
dpx.television.integration_times=0.0f;
value=GetDPXProperty(image,""dpx:television.integration_times"",exception);
if (value != (const char *) NULL)
dpx.television.integration_times=StringToDouble(value,(char **) NULL);
offset+=WriteBlobFloat(image,dpx.television.integration_times);
offset+=WriteBlob(image,sizeof(dpx.television.reserve),(unsigned char *)
dpx.television.reserve);
value=GetDPXProperty(image,""dpx:user.id"",exception);
if (value != (const char *) NULL)
(void) strncpy(dpx.user.id,value,sizeof(dpx.user.id)-1);
offset+=WriteBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);
if (profile != (StringInfo *) NULL)
offset+=WriteBlob(image,GetStringInfoLength(profile),
GetStringInfoDatum(profile));
while (offset < (MagickOffsetType) dpx.image.image_element[0].data_offset)
{
count=WriteBlobByte(image,0x00);
if (count != 1)
{
ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
image->filename);
break;
}
offset+=count;
}
quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
SetQuantumQuantum(quantum_info,32);
SetQuantumPack(quantum_info,dpx.image.image_element[0].packing == 0 ?
MagickTrue : MagickFalse);
quantum_type=RGBQuantum;
if (image->alpha_trait != UndefinedPixelTrait)
quantum_type=RGBAQuantum;
if (image->colorspace == YCbCrColorspace)
{
quantum_type=CbYCrQuantum;
if (image->alpha_trait != UndefinedPixelTrait)
quantum_type=CbYCrAQuantum;
if ((horizontal_factor == 2) || (vertical_factor == 2))
quantum_type=CbYCrYQuantum;
}
extent=GetBytesPerRow(image->columns,
image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL,image->depth,
dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);
if ((image_info->type != TrueColorType) &&
(image->alpha_trait == UndefinedPixelTrait) &&
(SetImageGray(image,exception) != MagickFalse))
{
quantum_type=GrayQuantum;
extent=GetBytesPerRow(image->columns,1UL,image->depth,
dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);
}
pixels=(unsigned char *) GetQuantumPixels(quantum_info);
for (y=0; y < (ssize_t) image->rows; y++)
{
size_t
length;
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
quantum_type,pixels,exception);
count=WriteBlob(image,extent,pixels);
if (count != (ssize_t) length)
break;
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
quantum_info=DestroyQuantumInfo(quantum_info);
if (y < (ssize_t) image->rows)
ThrowWriterException(CorruptImageError,""UnableToWriteImageData"");
(void) CloseBlob(image);
return(status);
}","static MagickBooleanType WriteDPXImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
const char
*VAR_3;
const StringInfo
*VAR_4;
DPXInfo
VAR_5;
GeometryInfo
VAR_6;
MagickBooleanType
VAR_7;
MagickOffsetType
VAR_8;
MagickStatusType
VAR_9;
QuantumInfo
*VAR_10;
QuantumType
VAR_11;
register const Quantum
*VAR_12;
register ssize_t
VAR_13;
size_t
VAR_14,
VAR_15;
ssize_t
VAR_16,
VAR_17,
VAR_18,
VAR_19;
time_t
VAR_20;
unsigned char
*VAR_21;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_22);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_22);
if (VAR_1->debug != VAR_23)
(void) LogMagickEvent(VAR_24,GetMagickModule(),""%s"",VAR_1->filename);
VAR_17=4;
VAR_18=4;
if (VAR_0->sampling_factor != (char *) NULL)
{
VAR_9=ParseGeometry(VAR_0->sampling_factor,&VAR_6);
VAR_17=(ssize_t) VAR_6.rho;
VAR_18=(ssize_t) VAR_6.sigma;
if ((VAR_9 & VAR_25) == 0)
VAR_18=VAR_17;
if ((VAR_17 != 1) && (VAR_17 != 2) &&
(VAR_17 != 4) && (VAR_18 != 1) &&
(VAR_18 != 2) && (VAR_18 != 4))
ThrowWriterException(VAR_26,""UnexpectedSamplingFactor"");
}
if ((VAR_1->colorspace == VAR_27) &&
((VAR_17 == 2) || (VAR_18 == 2)))
if ((VAR_1->columns % 2) != 0)
VAR_1->columns++;
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_22);
VAR_7=OpenBlob(VAR_0,VAR_1,VAR_28,VAR_2);
if (VAR_7 == VAR_23)
return(VAR_7);
(void) memset(&VAR_5,0,sizeof(VAR_5));
VAR_8=0;
VAR_5.file.magic=0x53445058U;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.magic);
VAR_5.file.image_offset=0x2000U;
VAR_4=GetImageProfile(VAR_1,""dpx:user-data"");
if (VAR_4 != (StringInfo *) NULL)
{
if (GetStringInfoLength(VAR_4) > 1048576)
ThrowWriterException(VAR_29,""WidthOrHeightExceedsLimit"");
VAR_5.file.image_offset+=(unsigned int) GetStringInfoLength(VAR_4);
VAR_5.file.image_offset=(((VAR_5.file.image_offset+0x2000-1)/0x2000)*0x2000);
}
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.image_offset);
(void) strncpy(VAR_5.file.version,""V2.0"",sizeof(VAR_5.file.version)-1);
VAR_8+=WriteBlob(VAR_1,8,(unsigned char *) &VAR_5.file.version);
VAR_14=1;
if (IsImageGray(VAR_1) == VAR_23)
VAR_14=3;
if (VAR_1->alpha_trait != VAR_30)
VAR_14++;
VAR_5.file.file_size=(unsigned int) (VAR_14*VAR_1->columns*VAR_1->rows+
VAR_5.file.image_offset);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.file_size);
VAR_5.file.ditto_key=1U;  
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.ditto_key);
VAR_5.file.generic_size=0x00000680U;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.generic_size);
VAR_5.file.industry_size=0x00000180U;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.industry_size);
VAR_5.file.user_size=0;
if (VAR_4 != (StringInfo *) NULL)
{
VAR_5.file.user_size+=(unsigned int) GetStringInfoLength(VAR_4);
VAR_5.file.user_size=(((VAR_5.file.user_size+0x2000-1)/0x2000)*0x2000);
}
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.user_size);
VAR_3=GetDPXProperty(VAR_1,""dpx:file.filename"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.file.filename,VAR_3,sizeof(VAR_5.file.filename)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.filename),(unsigned char *)
VAR_5.file.filename);
VAR_20=time((time_t *) NULL);
(void) FormatMagickTime(VAR_20,sizeof(VAR_5.file.timestamp),
VAR_5.file.timestamp);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.timestamp),(unsigned char *)
VAR_5.file.timestamp);
(void) strncpy(VAR_5.file.creator,VAR_31,
sizeof(VAR_5.file.creator)-1);
VAR_3=GetDPXProperty(VAR_1,""dpx:file.creator"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.file.creator,VAR_3,sizeof(VAR_5.file.creator)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.creator),(unsigned char *)
VAR_5.file.creator);
VAR_3=GetDPXProperty(VAR_1,""dpx:file.project"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.file.project,VAR_3,sizeof(VAR_5.file.project)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.project),(unsigned char *)
VAR_5.file.project);
VAR_3=GetDPXProperty(VAR_1,""dpx:file.copyright"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.file.copyright,VAR_3,sizeof(VAR_5.file.copyright)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.copyright),(unsigned char *)
VAR_5.file.copyright);
VAR_5.file.encrypt_key=(~0U);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.encrypt_key);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.reserve),(unsigned char *)
VAR_5.file.reserve);
switch (VAR_1->orientation)
{
default:
case VAR_32: VAR_5.image.orientation=0; break;
case VAR_33: VAR_5.image.orientation=1; break;
case VAR_34: VAR_5.image.orientation=2; break;
case VAR_35: VAR_5.image.orientation=3; break;
case VAR_36: VAR_5.image.orientation=4; break;
case VAR_37: VAR_5.image.orientation=5; break;
case VAR_38: VAR_5.image.orientation=6; break;
case VAR_39: VAR_5.image.orientation=7; break;
}
VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.orientation);
VAR_5.image.number_elements=1;
VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.number_elements);
if ((VAR_1->columns != (unsigned int) VAR_1->columns) ||
(VAR_1->rows != (unsigned int) VAR_1->rows))
ThrowWriterException(VAR_29,""WidthOrHeightExceedsLimit"");
VAR_8+=WriteBlobLong(VAR_1,(unsigned int) VAR_1->columns);
VAR_8+=WriteBlobLong(VAR_1,(unsigned int) VAR_1->rows);
for (VAR_13=0; VAR_13 < 8; VAR_13++)
{
VAR_5.image.image_element[VAR_13].data_sign=0U;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].data_sign);
VAR_5.image.image_element[VAR_13].low_data=0U;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].low_data);
VAR_5.image.image_element[VAR_13].low_quantity=0.0f;
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.image.image_element[VAR_13].low_quantity);
VAR_5.image.image_element[VAR_13].high_data=0U;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].high_data);
VAR_5.image.image_element[VAR_13].high_quantity=0.0f;
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.image.image_element[VAR_13].high_quantity);
VAR_5.image.image_element[VAR_13].descriptor=0;
if (VAR_13 == 0)
switch (VAR_1->colorspace)
{
case VAR_40:
case VAR_41:
case VAR_27:
{
VAR_5.image.image_element[VAR_13].descriptor=VAR_42;
if (VAR_1->alpha_trait != VAR_30)
VAR_5.image.image_element[VAR_13].descriptor=VAR_43;
break;
}
default:
{
VAR_5.image.image_element[VAR_13].descriptor=VAR_44;
if (VAR_1->alpha_trait != VAR_30)
VAR_5.image.image_element[VAR_13].descriptor=VAR_45;
if ((VAR_0->type != VAR_46) &&
(VAR_1->alpha_trait == VAR_30) &&
(SetImageGray(VAR_1,VAR_2) != VAR_23))
VAR_5.image.image_element[VAR_13].descriptor=VAR_47;
break;
}
}
VAR_8+=WriteBlobByte(VAR_1,VAR_5.image.image_element[VAR_13].descriptor);
VAR_5.image.image_element[VAR_13].transfer_characteristic=0;
if (VAR_1->colorspace == VAR_48)
VAR_5.image.image_element[0].transfer_characteristic=
VAR_49;
VAR_8+=WriteBlobByte(VAR_1,
VAR_5.image.image_element[VAR_13].transfer_characteristic);
VAR_5.image.image_element[VAR_13].colorimetric=0;
VAR_8+=WriteBlobByte(VAR_1,VAR_5.image.image_element[VAR_13].colorimetric);
VAR_5.image.image_element[VAR_13].bit_size=0;
if (VAR_13 == 0)
VAR_5.image.image_element[VAR_13].bit_size=(unsigned char) VAR_1->depth;
VAR_8+=WriteBlobByte(VAR_1,VAR_5.image.image_element[VAR_13].bit_size);
VAR_5.image.image_element[VAR_13].packing=0;
if ((VAR_1->depth == 10) || (VAR_1->depth == 12))
VAR_5.image.image_element[VAR_13].packing=1;
VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.image_element[VAR_13].packing);
VAR_5.image.image_element[VAR_13].encoding=0;
VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.image_element[VAR_13].encoding);
VAR_5.image.image_element[VAR_13].data_offset=0U;
if (VAR_13 == 0)
VAR_5.image.image_element[VAR_13].data_offset=VAR_5.file.image_offset;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].data_offset);
VAR_5.image.image_element[VAR_13].end_of_line_padding=0U;
VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].end_of_line_padding);
VAR_8+=WriteBlobLong(VAR_1,
VAR_5.image.image_element[VAR_13].end_of_image_padding);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.image.image_element[VAR_13].description),
(unsigned char *) VAR_5.image.image_element[VAR_13].description);
}
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.image.reserve),(unsigned char *)
VAR_5.image.reserve);
if ((VAR_1->rows != VAR_1->magick_rows) ||
(VAR_1->columns != VAR_1->magick_columns))
{
(void) DeleteImageProperty(VAR_1,""dpx:orientation.x_offset"");
(void) DeleteImageProperty(VAR_1,""dpx:orientation.y_offset"");
(void) DeleteImageProperty(VAR_1,""dpx:orientation.x_center"");
(void) DeleteImageProperty(VAR_1,""dpx:orientation.y_center"");
(void) DeleteImageProperty(VAR_1,""dpx:orientation.x_size"");
(void) DeleteImageProperty(VAR_1,""dpx:orientation.y_size"");
}
VAR_5.orientation.x_offset=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.x_offset"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.orientation.x_offset=(unsigned int) StringToUnsignedLong(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.x_offset);
VAR_5.orientation.y_offset=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.y_offset"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.orientation.y_offset=(unsigned int) StringToUnsignedLong(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.y_offset);
VAR_5.orientation.x_center=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.x_center"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.orientation.x_center=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.orientation.x_center);
VAR_5.orientation.y_center=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.y_center"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.orientation.y_center=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.orientation.y_center);
VAR_5.orientation.x_size=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.x_size"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.orientation.x_size=(unsigned int) StringToUnsignedLong(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.x_size);
VAR_5.orientation.y_size=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.y_size"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.orientation.y_size=(unsigned int) StringToUnsignedLong(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.y_size);
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.filename"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.orientation.filename,VAR_3,
sizeof(VAR_5.orientation.filename)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.filename),(unsigned char *)
VAR_5.orientation.filename);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.timestamp),(unsigned char *)
VAR_5.orientation.timestamp);
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.device"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.orientation.device,VAR_3,
sizeof(VAR_5.orientation.device)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.device),(unsigned char *)
VAR_5.orientation.device);
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.serial"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.orientation.serial,VAR_3,
sizeof(VAR_5.orientation.serial)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.serial),(unsigned char *)
VAR_5.orientation.serial);
for (VAR_13=0; VAR_13 < 4; VAR_13++)
VAR_5.orientation.border[VAR_13]=0;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.border"",VAR_2);
if (VAR_3 != (const char *) NULL)
{
VAR_9=ParseGeometry(VAR_3,&VAR_6);
if ((VAR_9 & VAR_25) == 0)
VAR_6.sigma=VAR_6.rho;
VAR_5.orientation.border[0]=(unsigned short) (VAR_6.rho+0.5);
VAR_5.orientation.border[1]=(unsigned short) (VAR_6.sigma+0.5);
VAR_5.orientation.border[2]=(unsigned short) (VAR_6.xi+0.5);
VAR_5.orientation.border[3]=(unsigned short) (VAR_6.psi+0.5);
}
for (VAR_13=0; VAR_13 < 4; VAR_13++)
VAR_8+=WriteBlobShort(VAR_1,VAR_5.orientation.border[VAR_13]);
for (VAR_13=0; VAR_13 < 2; VAR_13++)
VAR_5.orientation.aspect_ratio[VAR_13]=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.aspect_ratio"",VAR_2);
if (VAR_3 != (const char *) NULL)
{
VAR_9=ParseGeometry(VAR_3,&VAR_6);
if ((VAR_9 & VAR_25) == 0)
VAR_6.sigma=VAR_6.rho;
VAR_5.orientation.aspect_ratio[0]=(unsigned int) (VAR_6.rho+0.5);
VAR_5.orientation.aspect_ratio[1]=(unsigned int) (VAR_6.sigma+0.5);
}
for (VAR_13=0; VAR_13 < 2; VAR_13++)
VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.aspect_ratio[VAR_13]);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.reserve),(unsigned char *)
VAR_5.orientation.reserve);
(void) memset(VAR_5.film.id,0,sizeof(VAR_5.film.id));
VAR_3=GetDPXProperty(VAR_1,""dpx:film.id"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.id,VAR_3,sizeof(VAR_5.film.id)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.id),(unsigned char *) VAR_5.film.id);
(void) memset(VAR_5.film.type,0,sizeof(VAR_5.film.type));
VAR_3=GetDPXProperty(VAR_1,""dpx:film.type"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.type,VAR_3,sizeof(VAR_5.film.type)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.type),(unsigned char *)
VAR_5.film.type);
(void) memset(VAR_5.film.offset,0,sizeof(VAR_5.film.offset));
VAR_3=GetDPXProperty(VAR_1,""dpx:film.offset"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.offset,VAR_3,sizeof(VAR_5.film.offset)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.offset),(unsigned char *)
VAR_5.film.offset);
(void) memset(VAR_5.film.prefix,0,sizeof(VAR_5.film.prefix));
VAR_3=GetDPXProperty(VAR_1,""dpx:film.prefix"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.prefix,VAR_3,sizeof(VAR_5.film.prefix)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.prefix),(unsigned char *)
VAR_5.film.prefix);
(void) memset(VAR_5.film.count,0,sizeof(VAR_5.film.count));
VAR_3=GetDPXProperty(VAR_1,""dpx:film.count"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.count,VAR_3,sizeof(VAR_5.film.count)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.count),(unsigned char *)
VAR_5.film.count);
(void) memset(VAR_5.film.format,0,sizeof(VAR_5.film.format));
VAR_3=GetDPXProperty(VAR_1,""dpx:film.format"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.format,VAR_3,sizeof(VAR_5.film.format)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.format),(unsigned char *)
VAR_5.film.format);
VAR_5.film.frame_position=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:film.frame_position"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.film.frame_position=(unsigned int) StringToUnsignedLong(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.film.frame_position);
VAR_5.film.sequence_extent=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:film.sequence_extent"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.film.sequence_extent=(unsigned int) StringToUnsignedLong(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.film.sequence_extent);
VAR_5.film.held_count=0U;
VAR_3=GetDPXProperty(VAR_1,""dpx:film.held_count"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.film.held_count=(unsigned int) StringToUnsignedLong(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.film.held_count);
VAR_5.film.frame_rate=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:film.frame_rate"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.film.frame_rate=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.film.frame_rate);
VAR_5.film.shutter_angle=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:film.shutter_angle"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.film.shutter_angle=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.film.shutter_angle);
(void) memset(VAR_5.film.frame_id,0,sizeof(VAR_5.film.frame_id));
VAR_3=GetDPXProperty(VAR_1,""dpx:film.frame_id"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.frame_id,VAR_3,sizeof(VAR_5.film.frame_id)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.frame_id),(unsigned char *)
VAR_5.film.frame_id);
VAR_3=GetDPXProperty(VAR_1,""dpx:film.slate"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.film.slate,VAR_3,sizeof(VAR_5.film.slate)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.slate),(unsigned char *)
VAR_5.film.slate);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.reserve),(unsigned char *)
VAR_5.film.reserve);
VAR_3=GetDPXProperty(VAR_1,""dpx:television.time.code"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.time_code=StringToTimeCode(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.television.time_code);
VAR_3=GetDPXProperty(VAR_1,""dpx:television.user.bits"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.user_bits=StringToTimeCode(VAR_3);
VAR_8+=WriteBlobLong(VAR_1,VAR_5.television.user_bits);
VAR_3=GetDPXProperty(VAR_1,""dpx:television.interlace"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.interlace=(unsigned char) StringToLong(VAR_3);
VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.interlace);
VAR_3=GetDPXProperty(VAR_1,""dpx:television.field_number"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.field_number=(unsigned char) StringToLong(VAR_3);
VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.field_number);
VAR_5.television.video_signal=0;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.video_signal"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.video_signal=(unsigned char) StringToLong(VAR_3);
VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.video_signal);
VAR_5.television.padding=0;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.padding"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.padding=(unsigned char) StringToLong(VAR_3);
VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.padding);
VAR_5.television.horizontal_sample_rate=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.horizontal_sample_rate"",
VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.horizontal_sample_rate=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.horizontal_sample_rate);
VAR_5.television.vertical_sample_rate=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.vertical_sample_rate"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.vertical_sample_rate=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.vertical_sample_rate);
VAR_5.television.frame_rate=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.frame_rate"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.frame_rate=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.frame_rate);
VAR_5.television.time_offset=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.time_offset"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.time_offset=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.time_offset);
VAR_5.television.gamma=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.gamma"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.gamma=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.gamma);
VAR_5.television.black_level=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.black_level"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.black_level=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.black_level);
VAR_5.television.black_gain=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.black_gain"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.black_gain=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.black_gain);
VAR_5.television.break_point=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.break_point"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.break_point=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.break_point);
VAR_5.television.white_level=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.white_level"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.white_level=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.white_level);
VAR_5.television.integration_times=0.0f;
VAR_3=GetDPXProperty(VAR_1,""dpx:television.integration_times"",VAR_2);
if (VAR_3 != (const char *) NULL)
VAR_5.television.integration_times=StringToDouble(VAR_3,(char **) NULL);
VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.integration_times);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.television.reserve),(unsigned char *)
VAR_5.television.reserve);
VAR_3=GetDPXProperty(VAR_1,""dpx:user.id"",VAR_2);
if (VAR_3 != (const char *) NULL)
(void) strncpy(VAR_5.user.id,VAR_3,sizeof(VAR_5.user.id)-1);
VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.user.id),(unsigned char *) VAR_5.user.id);
if (VAR_4 != (StringInfo *) NULL)
VAR_8+=WriteBlob(VAR_1,GetStringInfoLength(VAR_4),
GetStringInfoDatum(VAR_4));
while (VAR_8 < (MagickOffsetType) VAR_5.image.image_element[0].data_offset)
{
VAR_16=WriteBlobByte(VAR_1,0x00);
if (VAR_16 != 1)
{
ThrowFileException(VAR_2,VAR_50,""UnableToWriteFile"",
VAR_1->filename);
break;
}
VAR_8+=VAR_16;
}
VAR_10=AcquireQuantumInfo(VAR_0,VAR_1);
if (VAR_10 == (QuantumInfo *) NULL)
ThrowWriterException(VAR_51,""MemoryAllocationFailed"");
SetQuantumQuantum(VAR_10,32);
SetQuantumPack(VAR_10,VAR_5.image.image_element[0].packing == 0 ?
VAR_52 : VAR_23);
VAR_11=VAR_53;
if (VAR_1->alpha_trait != VAR_30)
VAR_11=VAR_54;
if (VAR_1->colorspace == VAR_27)
{
VAR_11=VAR_55;
if (VAR_1->alpha_trait != VAR_30)
VAR_11=VAR_56;
if ((VAR_17 == 2) || (VAR_18 == 2))
VAR_11=VAR_57;
}
VAR_15=GetBytesPerRow(VAR_1->columns,
VAR_1->alpha_trait != VAR_30 ? 4UL : 3UL,VAR_1->depth,
VAR_5.image.image_element[0].packing == 0 ? VAR_23 : VAR_52);
if ((VAR_0->type != VAR_46) &&
(VAR_1->alpha_trait == VAR_30) &&
(SetImageGray(VAR_1,VAR_2) != VAR_23))
{
VAR_11=VAR_58;
VAR_15=GetBytesPerRow(VAR_1->columns,1UL,VAR_1->depth,
VAR_5.image.image_element[0].packing == 0 ? VAR_23 : VAR_52);
}
VAR_21=(unsigned char *) GetQuantumPixels(VAR_10);
for (VAR_19=0; VAR_19 < (ssize_t) VAR_1->rows; VAR_19++)
{
size_t
VAR_59;
VAR_12=GetVirtualPixels(VAR_1,0,VAR_19,VAR_1->columns,1,VAR_2);
if (VAR_12 == (const Quantum *) NULL)
break;
VAR_59=ExportQuantumPixels(VAR_1,(CacheView *) NULL,VAR_10,
VAR_11,VAR_21,VAR_2);
VAR_16=WriteBlob(VAR_1,VAR_15,VAR_21);
if (VAR_16 != (ssize_t) VAR_59)
break;
VAR_7=SetImageProgress(VAR_1,VAR_60,(MagickOffsetType) VAR_19,
VAR_1->rows);
if (VAR_7 == VAR_23)
break;
}
VAR_10=DestroyQuantumInfo(VAR_10);
if (VAR_19 < (ssize_t) VAR_1->rows)
ThrowWriterException(VAR_26,""UnableToWriteImageData"");
(void) CloseBlob(VAR_1);
return(VAR_7);
}",ImageMagick/ee5b9c56b9ca18ed0750f8a15e0d1a6da92a6e99/dpx.c/vul/before/0.json,"static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  const char
    *value;

  const StringInfo
    *profile;

  DPXInfo
    dpx;

  GeometryInfo
    geometry_info;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  MagickStatusType
    flags;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register const Quantum
    *p;

  register ssize_t
    i;

  size_t
    channels,
    extent;

  ssize_t
    count,
    horizontal_factor,
    vertical_factor,
    y;

  time_t
    seconds;

  unsigned char
    *pixels;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  horizontal_factor=4;
  vertical_factor=4;
  if (image_info->sampling_factor != (char *) NULL)
    {
      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);
      horizontal_factor=(ssize_t) geometry_info.rho;
      vertical_factor=(ssize_t) geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        vertical_factor=horizontal_factor;
      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&
          (horizontal_factor != 4) && (vertical_factor != 1) &&
          (vertical_factor != 2) && (vertical_factor != 4))
        ThrowWriterException(CorruptImageError,""UnexpectedSamplingFactor"");
    }
  if ((image->colorspace == YCbCrColorspace) &&
      ((horizontal_factor == 2) || (vertical_factor == 2)))
    if ((image->columns % 2) != 0)
      image->columns++;
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  /*
    Write file header.
  */
  (void) memset(&dpx,0,sizeof(dpx));
  offset=0;
  dpx.file.magic=0x53445058U;
  offset+=WriteBlobLong(image,dpx.file.magic);
  dpx.file.image_offset=0x2000U;
  profile=GetImageProfile(image,""dpx:user-data"");
  if (profile != (StringInfo *) NULL)
    {
      if (GetStringInfoLength(profile) > 1048576)
        ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
      dpx.file.image_offset+=(unsigned int) GetStringInfoLength(profile);
      dpx.file.image_offset=(((dpx.file.image_offset+0x2000-1)/0x2000)*0x2000);
    }
  offset+=WriteBlobLong(image,dpx.file.image_offset);
  (void) strncpy(dpx.file.version,""V2.0"",sizeof(dpx.file.version)-1);
  offset+=WriteBlob(image,8,(unsigned char *) &dpx.file.version);
  channels=1;
  if (IsImageGray(image) == MagickFalse)
    channels=3;
  if (image->alpha_trait != UndefinedPixelTrait)
    channels++;
  dpx.file.file_size=(unsigned int) (channels*image->columns*image->rows+
    dpx.file.image_offset);
  offset+=WriteBlobLong(image,dpx.file.file_size);
  dpx.file.ditto_key=1U;  /* new frame */
  offset+=WriteBlobLong(image,dpx.file.ditto_key);
  dpx.file.generic_size=0x00000680U;
  offset+=WriteBlobLong(image,dpx.file.generic_size);
  dpx.file.industry_size=0x00000180U;
  offset+=WriteBlobLong(image,dpx.file.industry_size);
  dpx.file.user_size=0;
  if (profile != (StringInfo *) NULL)
    {
      dpx.file.user_size+=(unsigned int) GetStringInfoLength(profile);
      dpx.file.user_size=(((dpx.file.user_size+0x2000-1)/0x2000)*0x2000);
    }
  offset+=WriteBlobLong(image,dpx.file.user_size);
  value=GetDPXProperty(image,""dpx:file.filename"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.file.filename,value,sizeof(dpx.file.filename)-1);
  offset+=WriteBlob(image,sizeof(dpx.file.filename),(unsigned char *)
    dpx.file.filename);
  seconds=time((time_t *) NULL);
  (void) FormatMagickTime(seconds,sizeof(dpx.file.timestamp),
    dpx.file.timestamp);
  offset+=WriteBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)
    dpx.file.timestamp);
  (void) strncpy(dpx.file.creator,MagickAuthoritativeURL,
    sizeof(dpx.file.creator)-1);
  value=GetDPXProperty(image,""dpx:file.creator"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.file.creator,value,sizeof(dpx.file.creator)-1);
  offset+=WriteBlob(image,sizeof(dpx.file.creator),(unsigned char *)
    dpx.file.creator);
  value=GetDPXProperty(image,""dpx:file.project"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.file.project,value,sizeof(dpx.file.project)-1);
  offset+=WriteBlob(image,sizeof(dpx.file.project),(unsigned char *)
    dpx.file.project);
  value=GetDPXProperty(image,""dpx:file.copyright"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.file.copyright,value,sizeof(dpx.file.copyright)-1);
  offset+=WriteBlob(image,sizeof(dpx.file.copyright),(unsigned char *)
    dpx.file.copyright);
  dpx.file.encrypt_key=(~0U);
  offset+=WriteBlobLong(image,dpx.file.encrypt_key);
  offset+=WriteBlob(image,sizeof(dpx.file.reserve),(unsigned char *)
    dpx.file.reserve);
  /*
    Write image header.
  */
  switch (image->orientation)
  {
    default:
    case TopLeftOrientation: dpx.image.orientation=0; break;
    case TopRightOrientation: dpx.image.orientation=1; break;
    case BottomLeftOrientation: dpx.image.orientation=2; break;
    case BottomRightOrientation: dpx.image.orientation=3; break;
    case LeftTopOrientation: dpx.image.orientation=4; break;
    case RightTopOrientation: dpx.image.orientation=5; break;
    case LeftBottomOrientation: dpx.image.orientation=6; break;
    case RightBottomOrientation: dpx.image.orientation=7; break;
  }
  offset+=WriteBlobShort(image,dpx.image.orientation);
  dpx.image.number_elements=1;
  offset+=WriteBlobShort(image,dpx.image.number_elements);
  if ((image->columns != (unsigned int) image->columns) ||
      (image->rows != (unsigned int) image->rows))
    ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
  offset+=WriteBlobLong(image,(unsigned int) image->columns);
  offset+=WriteBlobLong(image,(unsigned int) image->rows);
  for (i=0; i < 8; i++)
  {
    dpx.image.image_element[i].data_sign=0U;
    offset+=WriteBlobLong(image,dpx.image.image_element[i].data_sign);
    dpx.image.image_element[i].low_data=0U;
    offset+=WriteBlobLong(image,dpx.image.image_element[i].low_data);
    dpx.image.image_element[i].low_quantity=0.0f;
    offset+=WriteBlobFloat(image,dpx.image.image_element[i].low_quantity);
    dpx.image.image_element[i].high_data=0U;
    offset+=WriteBlobLong(image,dpx.image.image_element[i].high_data);
    dpx.image.image_element[i].high_quantity=0.0f;
    offset+=WriteBlobFloat(image,dpx.image.image_element[i].high_quantity);
    dpx.image.image_element[i].descriptor=0;
    if (i == 0)
      switch (image->colorspace)
      {
        case Rec601YCbCrColorspace:
        case Rec709YCbCrColorspace:
        case YCbCrColorspace:
        {
          dpx.image.image_element[i].descriptor=CbYCr444ComponentType;
          if (image->alpha_trait != UndefinedPixelTrait)
            dpx.image.image_element[i].descriptor=CbYCrA4444ComponentType;
          break;
        }
        default:
        {
          dpx.image.image_element[i].descriptor=RGBComponentType;
          if (image->alpha_trait != UndefinedPixelTrait)
            dpx.image.image_element[i].descriptor=RGBAComponentType;
          if ((image_info->type != TrueColorType) &&
              (image->alpha_trait == UndefinedPixelTrait) &&
              (SetImageGray(image,exception) != MagickFalse))
            dpx.image.image_element[i].descriptor=LumaComponentType;
          break;
        }
      }
    offset+=WriteBlobByte(image,dpx.image.image_element[i].descriptor);
    dpx.image.image_element[i].transfer_characteristic=0;
    if (image->colorspace == LogColorspace)
      dpx.image.image_element[0].transfer_characteristic=
        PrintingDensityColorimetric;
    offset+=WriteBlobByte(image,
      dpx.image.image_element[i].transfer_characteristic);
    dpx.image.image_element[i].colorimetric=0;
    offset+=WriteBlobByte(image,dpx.image.image_element[i].colorimetric);
    dpx.image.image_element[i].bit_size=0;
    if (i == 0)
      dpx.image.image_element[i].bit_size=(unsigned char) image->depth;
    offset+=WriteBlobByte(image,dpx.image.image_element[i].bit_size);
    dpx.image.image_element[i].packing=0;
    if ((image->depth == 10) || (image->depth == 12))
      dpx.image.image_element[i].packing=1;
    offset+=WriteBlobShort(image,dpx.image.image_element[i].packing);
    dpx.image.image_element[i].encoding=0;
    offset+=WriteBlobShort(image,dpx.image.image_element[i].encoding);
    dpx.image.image_element[i].data_offset=0U;
    if (i == 0)
      dpx.image.image_element[i].data_offset=dpx.file.image_offset;
    offset+=WriteBlobLong(image,dpx.image.image_element[i].data_offset);
    dpx.image.image_element[i].end_of_line_padding=0U;
    offset+=WriteBlobLong(image,dpx.image.image_element[i].end_of_line_padding);
    offset+=WriteBlobLong(image,
      dpx.image.image_element[i].end_of_image_padding);
    offset+=WriteBlob(image,sizeof(dpx.image.image_element[i].description),
      (unsigned char *) dpx.image.image_element[i].description);
  }
  offset+=WriteBlob(image,sizeof(dpx.image.reserve),(unsigned char *)
    dpx.image.reserve);
  /*
    Write orientation header.
  */
  if ((image->rows != image->magick_rows) ||
      (image->columns != image->magick_columns))
    {
      /*
        These properties are not valid if image size changed.
      */
      (void) DeleteImageProperty(image,""dpx:orientation.x_offset"");
      (void) DeleteImageProperty(image,""dpx:orientation.y_offset"");
      (void) DeleteImageProperty(image,""dpx:orientation.x_center"");
      (void) DeleteImageProperty(image,""dpx:orientation.y_center"");
      (void) DeleteImageProperty(image,""dpx:orientation.x_size"");
      (void) DeleteImageProperty(image,""dpx:orientation.y_size"");
    }
  dpx.orientation.x_offset=0U;
  value=GetDPXProperty(image,""dpx:orientation.x_offset"",exception);
  if (value != (const char *) NULL)
    dpx.orientation.x_offset=(unsigned int) StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,dpx.orientation.x_offset);
  dpx.orientation.y_offset=0U;
  value=GetDPXProperty(image,""dpx:orientation.y_offset"",exception);
  if (value != (const char *) NULL)
    dpx.orientation.y_offset=(unsigned int) StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,dpx.orientation.y_offset);
  dpx.orientation.x_center=0.0f;
  value=GetDPXProperty(image,""dpx:orientation.x_center"",exception);
  if (value != (const char *) NULL)
    dpx.orientation.x_center=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.orientation.x_center);
  dpx.orientation.y_center=0.0f;
  value=GetDPXProperty(image,""dpx:orientation.y_center"",exception);
  if (value != (const char *) NULL)
    dpx.orientation.y_center=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.orientation.y_center);
  dpx.orientation.x_size=0U;
  value=GetDPXProperty(image,""dpx:orientation.x_size"",exception);
  if (value != (const char *) NULL)
    dpx.orientation.x_size=(unsigned int) StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,dpx.orientation.x_size);
  dpx.orientation.y_size=0U;
  value=GetDPXProperty(image,""dpx:orientation.y_size"",exception);
  if (value != (const char *) NULL)
    dpx.orientation.y_size=(unsigned int) StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,dpx.orientation.y_size);
  value=GetDPXProperty(image,""dpx:orientation.filename"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.orientation.filename,value,
      sizeof(dpx.orientation.filename)-1);
  offset+=WriteBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)
    dpx.orientation.filename);
  offset+=WriteBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)
    dpx.orientation.timestamp);
  value=GetDPXProperty(image,""dpx:orientation.device"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.orientation.device,value,
      sizeof(dpx.orientation.device)-1);
  offset+=WriteBlob(image,sizeof(dpx.orientation.device),(unsigned char *)
    dpx.orientation.device);
  value=GetDPXProperty(image,""dpx:orientation.serial"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.orientation.serial,value,
      sizeof(dpx.orientation.serial)-1);
  offset+=WriteBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)
    dpx.orientation.serial);
  for (i=0; i < 4; i++)
    dpx.orientation.border[i]=0;
  value=GetDPXProperty(image,""dpx:orientation.border"",exception);
  if (value != (const char *) NULL)
    {
      flags=ParseGeometry(value,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      dpx.orientation.border[0]=(unsigned short) (geometry_info.rho+0.5);
      dpx.orientation.border[1]=(unsigned short) (geometry_info.sigma+0.5);
      dpx.orientation.border[2]=(unsigned short) (geometry_info.xi+0.5);
      dpx.orientation.border[3]=(unsigned short) (geometry_info.psi+0.5);
    }
  for (i=0; i < 4; i++)
    offset+=WriteBlobShort(image,dpx.orientation.border[i]);
  for (i=0; i < 2; i++)
    dpx.orientation.aspect_ratio[i]=0U;
  value=GetDPXProperty(image,""dpx:orientation.aspect_ratio"",exception);
  if (value != (const char *) NULL)
    {
      flags=ParseGeometry(value,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      dpx.orientation.aspect_ratio[0]=(unsigned int) (geometry_info.rho+0.5);
      dpx.orientation.aspect_ratio[1]=(unsigned int) (geometry_info.sigma+0.5);
    }
  for (i=0; i < 2; i++)
    offset+=WriteBlobLong(image,dpx.orientation.aspect_ratio[i]);
  offset+=WriteBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)
    dpx.orientation.reserve);
  /*
    Write film header.
  */
  (void) memset(dpx.film.id,0,sizeof(dpx.film.id));
  value=GetDPXProperty(image,""dpx:film.id"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.id,value,sizeof(dpx.film.id)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);
  (void) memset(dpx.film.type,0,sizeof(dpx.film.type));
  value=GetDPXProperty(image,""dpx:film.type"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.type,value,sizeof(dpx.film.type)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.type),(unsigned char *)
    dpx.film.type);
  (void) memset(dpx.film.offset,0,sizeof(dpx.film.offset));
  value=GetDPXProperty(image,""dpx:film.offset"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.offset,value,sizeof(dpx.film.offset)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.offset),(unsigned char *)
    dpx.film.offset);
  (void) memset(dpx.film.prefix,0,sizeof(dpx.film.prefix));
  value=GetDPXProperty(image,""dpx:film.prefix"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.prefix,value,sizeof(dpx.film.prefix)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.prefix),(unsigned char *)
    dpx.film.prefix);
  (void) memset(dpx.film.count,0,sizeof(dpx.film.count));
  value=GetDPXProperty(image,""dpx:film.count"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.count,value,sizeof(dpx.film.count)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.count),(unsigned char *)
    dpx.film.count);
  (void) memset(dpx.film.format,0,sizeof(dpx.film.format));
  value=GetDPXProperty(image,""dpx:film.format"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.format,value,sizeof(dpx.film.format)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.format),(unsigned char *)
    dpx.film.format);
  dpx.film.frame_position=0U;
  value=GetDPXProperty(image,""dpx:film.frame_position"",exception);
  if (value != (const char *) NULL)
    dpx.film.frame_position=(unsigned int) StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,dpx.film.frame_position);
  dpx.film.sequence_extent=0U;
  value=GetDPXProperty(image,""dpx:film.sequence_extent"",exception);
  if (value != (const char *) NULL)
    dpx.film.sequence_extent=(unsigned int) StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,dpx.film.sequence_extent);
  dpx.film.held_count=0U;
  value=GetDPXProperty(image,""dpx:film.held_count"",exception);
  if (value != (const char *) NULL)
    dpx.film.held_count=(unsigned int) StringToUnsignedLong(value);
  offset+=WriteBlobLong(image,dpx.film.held_count);
  dpx.film.frame_rate=0.0f;
  value=GetDPXProperty(image,""dpx:film.frame_rate"",exception);
  if (value != (const char *) NULL)
    dpx.film.frame_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.film.frame_rate);
  dpx.film.shutter_angle=0.0f;
  value=GetDPXProperty(image,""dpx:film.shutter_angle"",exception);
  if (value != (const char *) NULL)
    dpx.film.shutter_angle=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.film.shutter_angle);
  (void) memset(dpx.film.frame_id,0,sizeof(dpx.film.frame_id));
  value=GetDPXProperty(image,""dpx:film.frame_id"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.frame_id,value,sizeof(dpx.film.frame_id)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)
    dpx.film.frame_id);
  value=GetDPXProperty(image,""dpx:film.slate"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.film.slate,value,sizeof(dpx.film.slate)-1);
  offset+=WriteBlob(image,sizeof(dpx.film.slate),(unsigned char *)
    dpx.film.slate);
  offset+=WriteBlob(image,sizeof(dpx.film.reserve),(unsigned char *)
    dpx.film.reserve);
  /*
    Write television header.
  */
  value=GetDPXProperty(image,""dpx:television.time.code"",exception);
  if (value != (const char *) NULL)
    dpx.television.time_code=StringToTimeCode(value);
  offset+=WriteBlobLong(image,dpx.television.time_code);
  value=GetDPXProperty(image,""dpx:television.user.bits"",exception);
  if (value != (const char *) NULL)
    dpx.television.user_bits=StringToTimeCode(value);
  offset+=WriteBlobLong(image,dpx.television.user_bits);
  value=GetDPXProperty(image,""dpx:television.interlace"",exception);
  if (value != (const char *) NULL)
    dpx.television.interlace=(unsigned char) StringToLong(value);
  offset+=WriteBlobByte(image,dpx.television.interlace);
  value=GetDPXProperty(image,""dpx:television.field_number"",exception);
  if (value != (const char *) NULL)
    dpx.television.field_number=(unsigned char) StringToLong(value);
  offset+=WriteBlobByte(image,dpx.television.field_number);
  dpx.television.video_signal=0;
  value=GetDPXProperty(image,""dpx:television.video_signal"",exception);
  if (value != (const char *) NULL)
    dpx.television.video_signal=(unsigned char) StringToLong(value);
  offset+=WriteBlobByte(image,dpx.television.video_signal);
  dpx.television.padding=0;
  value=GetDPXProperty(image,""dpx:television.padding"",exception);
  if (value != (const char *) NULL)
    dpx.television.padding=(unsigned char) StringToLong(value);
  offset+=WriteBlobByte(image,dpx.television.padding);
  dpx.television.horizontal_sample_rate=0.0f;
  value=GetDPXProperty(image,""dpx:television.horizontal_sample_rate"",
    exception);
  if (value != (const char *) NULL)
    dpx.television.horizontal_sample_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.horizontal_sample_rate);
  dpx.television.vertical_sample_rate=0.0f;
  value=GetDPXProperty(image,""dpx:television.vertical_sample_rate"",exception);
  if (value != (const char *) NULL)
    dpx.television.vertical_sample_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.vertical_sample_rate);
  dpx.television.frame_rate=0.0f;
  value=GetDPXProperty(image,""dpx:television.frame_rate"",exception);
  if (value != (const char *) NULL)
    dpx.television.frame_rate=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.frame_rate);
  dpx.television.time_offset=0.0f;
  value=GetDPXProperty(image,""dpx:television.time_offset"",exception);
  if (value != (const char *) NULL)
    dpx.television.time_offset=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.time_offset);
  dpx.television.gamma=0.0f;
  value=GetDPXProperty(image,""dpx:television.gamma"",exception);
  if (value != (const char *) NULL)
    dpx.television.gamma=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.gamma);
  dpx.television.black_level=0.0f;
  value=GetDPXProperty(image,""dpx:television.black_level"",exception);
  if (value != (const char *) NULL)
    dpx.television.black_level=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.black_level);
  dpx.television.black_gain=0.0f;
  value=GetDPXProperty(image,""dpx:television.black_gain"",exception);
  if (value != (const char *) NULL)
    dpx.television.black_gain=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.black_gain);
  dpx.television.break_point=0.0f;
  value=GetDPXProperty(image,""dpx:television.break_point"",exception);
  if (value != (const char *) NULL)
    dpx.television.break_point=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.break_point);
  dpx.television.white_level=0.0f;
  value=GetDPXProperty(image,""dpx:television.white_level"",exception);
  if (value != (const char *) NULL)
    dpx.television.white_level=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.white_level);
  dpx.television.integration_times=0.0f;
  value=GetDPXProperty(image,""dpx:television.integration_times"",exception);
  if (value != (const char *) NULL)
    dpx.television.integration_times=StringToDouble(value,(char **) NULL);
  offset+=WriteBlobFloat(image,dpx.television.integration_times);
  offset+=WriteBlob(image,sizeof(dpx.television.reserve),(unsigned char *)
    dpx.television.reserve);
  /*
    Write user header.
  */
  value=GetDPXProperty(image,""dpx:user.id"",exception);
  if (value != (const char *) NULL)
    (void) strncpy(dpx.user.id,value,sizeof(dpx.user.id)-1);
  offset+=WriteBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);
  if (profile != (StringInfo *) NULL)
    offset+=WriteBlob(image,GetStringInfoLength(profile),
      GetStringInfoDatum(profile));
  while (offset < (MagickOffsetType) dpx.image.image_element[0].data_offset)
  {
    count=WriteBlobByte(image,0x00);
    if (count != 1)
      {
        ThrowFileException(exception,FileOpenError,""UnableToWriteFile"",
          image->filename);
        break;
      }
    offset+=count;
  }
  /*
    Convert pixel packets to DPX raster image.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  SetQuantumQuantum(quantum_info,32);
  SetQuantumPack(quantum_info,dpx.image.image_element[0].packing == 0 ?
    MagickTrue : MagickFalse);
  quantum_type=RGBQuantum;
  if (image->alpha_trait != UndefinedPixelTrait)
    quantum_type=RGBAQuantum;
  if (image->colorspace == YCbCrColorspace)
    {
      quantum_type=CbYCrQuantum;
      if (image->alpha_trait != UndefinedPixelTrait)
        quantum_type=CbYCrAQuantum;
      if ((horizontal_factor == 2) || (vertical_factor == 2))
        quantum_type=CbYCrYQuantum;
    }
  extent=GetBytesPerRow(image->columns,
    image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL,image->depth,
    dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);
  if ((image_info->type != TrueColorType) &&
      (image->alpha_trait == UndefinedPixelTrait) &&
      (SetImageGray(image,exception) != MagickFalse))
    {
      quantum_type=GrayQuantum;
      extent=GetBytesPerRow(image->columns,1UL,image->depth,
        dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);
    }
  pixels=(unsigned char *) GetQuantumPixels(quantum_info);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    size_t
      length;

    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (length == 0)
      break;
    count=WriteBlob(image,extent,pixels);
    if (count != (ssize_t) extent)
      break;
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (y < (ssize_t) image->rows)
    ThrowWriterException(CorruptImageError,""UnableToWriteImageData"");
  (void) CloseBlob(image);
  return(status);
}","static MagickBooleanType WriteDPXImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  const char
    *VAR_3;

  const StringInfo
    *VAR_4;

  DPXInfo
    VAR_5;

  GeometryInfo
    VAR_6;

  MagickBooleanType
    VAR_7;

  MagickOffsetType
    VAR_8;

  MagickStatusType
    VAR_9;

  QuantumInfo
    *VAR_10;

  QuantumType
    VAR_11;

  register const Quantum
    *VAR_12;

  register ssize_t
    VAR_13;

  size_t
    VAR_14,
    VAR_15;

  ssize_t
    VAR_16,
    VAR_17,
    VAR_18,
    VAR_19;

  time_t
    VAR_20;

  unsigned char
    *VAR_21;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_22);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_22);
  if (VAR_1->debug != VAR_23)
    (void) LogMagickEvent(VAR_24,GetMagickModule(),""%s"",VAR_1->filename);
  VAR_17=4;
  VAR_18=4;
  if (VAR_0->sampling_factor != (char *) NULL)
    {
      VAR_9=ParseGeometry(VAR_0->sampling_factor,&VAR_6);
      VAR_17=(ssize_t) VAR_6.rho;
      VAR_18=(ssize_t) VAR_6.sigma;
      if ((VAR_9 & VAR_25) == 0)
        VAR_18=VAR_17;
      if ((VAR_17 != 1) && (VAR_17 != 2) &&
          (VAR_17 != 4) && (VAR_18 != 1) &&
          (VAR_18 != 2) && (VAR_18 != 4))
        ThrowWriterException(VAR_26,""UnexpectedSamplingFactor"");
    }
  if ((VAR_1->colorspace == VAR_27) &&
      ((VAR_17 == 2) || (VAR_18 == 2)))
    if ((VAR_1->columns % 2) != 0)
      VAR_1->columns++;
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_22);
  VAR_7=OpenBlob(VAR_0,VAR_1,VAR_28,VAR_2);
  if (VAR_7 == VAR_23)
    return(VAR_7);
  /* COMMENT_3 */
                      
    
  (void) memset(&VAR_5,0,sizeof(VAR_5));
  VAR_8=0;
  VAR_5.file.magic=0x53445058U;
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.magic);
  VAR_5.file.image_offset=0x2000U;
  VAR_4=GetImageProfile(VAR_1,""dpx:user-data"");
  if (VAR_4 != (StringInfo *) NULL)
    {
      if (GetStringInfoLength(VAR_4) > 1048576)
        ThrowWriterException(VAR_29,""WidthOrHeightExceedsLimit"");
      VAR_5.file.image_offset+=(unsigned int) GetStringInfoLength(VAR_4);
      VAR_5.file.image_offset=(((VAR_5.file.image_offset+0x2000-1)/0x2000)*0x2000);
    }
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.image_offset);
  (void) strncpy(VAR_5.file.version,""V2.0"",sizeof(VAR_5.file.version)-1);
  VAR_8+=WriteBlob(VAR_1,8,(unsigned char *) &VAR_5.file.version);
  VAR_14=1;
  if (IsImageGray(VAR_1) == VAR_23)
    VAR_14=3;
  if (VAR_1->alpha_trait != VAR_30)
    VAR_14++;
  VAR_5.file.file_size=(unsigned int) (VAR_14*VAR_1->columns*VAR_1->rows+
    VAR_5.file.image_offset);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.file_size);
  VAR_5.file.ditto_key=1U;  /* COMMENT_6 */
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.ditto_key);
  VAR_5.file.generic_size=0x00000680U;
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.generic_size);
  VAR_5.file.industry_size=0x00000180U;
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.industry_size);
  VAR_5.file.user_size=0;
  if (VAR_4 != (StringInfo *) NULL)
    {
      VAR_5.file.user_size+=(unsigned int) GetStringInfoLength(VAR_4);
      VAR_5.file.user_size=(((VAR_5.file.user_size+0x2000-1)/0x2000)*0x2000);
    }
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.user_size);
  VAR_3=GetDPXProperty(VAR_1,""dpx:file.filename"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.file.filename,VAR_3,sizeof(VAR_5.file.filename)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.filename),(unsigned char *)
    VAR_5.file.filename);
  VAR_20=time((time_t *) NULL);
  (void) FormatMagickTime(VAR_20,sizeof(VAR_5.file.timestamp),
    VAR_5.file.timestamp);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.timestamp),(unsigned char *)
    VAR_5.file.timestamp);
  (void) strncpy(VAR_5.file.creator,VAR_31,
    sizeof(VAR_5.file.creator)-1);
  VAR_3=GetDPXProperty(VAR_1,""dpx:file.creator"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.file.creator,VAR_3,sizeof(VAR_5.file.creator)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.creator),(unsigned char *)
    VAR_5.file.creator);
  VAR_3=GetDPXProperty(VAR_1,""dpx:file.project"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.file.project,VAR_3,sizeof(VAR_5.file.project)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.project),(unsigned char *)
    VAR_5.file.project);
  VAR_3=GetDPXProperty(VAR_1,""dpx:file.copyright"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.file.copyright,VAR_3,sizeof(VAR_5.file.copyright)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.copyright),(unsigned char *)
    VAR_5.file.copyright);
  VAR_5.file.encrypt_key=(~0U);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.file.encrypt_key);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.file.reserve),(unsigned char *)
    VAR_5.file.reserve);
  /* COMMENT_7 */
                       
    
  switch (VAR_1->orientation)
  {
    default:
    case VAR_32: VAR_5.image.orientation=0; break;
    case VAR_33: VAR_5.image.orientation=1; break;
    case VAR_34: VAR_5.image.orientation=2; break;
    case VAR_35: VAR_5.image.orientation=3; break;
    case VAR_36: VAR_5.image.orientation=4; break;
    case VAR_37: VAR_5.image.orientation=5; break;
    case VAR_38: VAR_5.image.orientation=6; break;
    case VAR_39: VAR_5.image.orientation=7; break;
  }
  VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.orientation);
  VAR_5.image.number_elements=1;
  VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.number_elements);
  if ((VAR_1->columns != (unsigned int) VAR_1->columns) ||
      (VAR_1->rows != (unsigned int) VAR_1->rows))
    ThrowWriterException(VAR_29,""WidthOrHeightExceedsLimit"");
  VAR_8+=WriteBlobLong(VAR_1,(unsigned int) VAR_1->columns);
  VAR_8+=WriteBlobLong(VAR_1,(unsigned int) VAR_1->rows);
  for (VAR_13=0; VAR_13 < 8; VAR_13++)
  {
    VAR_5.image.image_element[VAR_13].data_sign=0U;
    VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].data_sign);
    VAR_5.image.image_element[VAR_13].low_data=0U;
    VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].low_data);
    VAR_5.image.image_element[VAR_13].low_quantity=0.0f;
    VAR_8+=WriteBlobFloat(VAR_1,VAR_5.image.image_element[VAR_13].low_quantity);
    VAR_5.image.image_element[VAR_13].high_data=0U;
    VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].high_data);
    VAR_5.image.image_element[VAR_13].high_quantity=0.0f;
    VAR_8+=WriteBlobFloat(VAR_1,VAR_5.image.image_element[VAR_13].high_quantity);
    VAR_5.image.image_element[VAR_13].descriptor=0;
    if (VAR_13 == 0)
      switch (VAR_1->colorspace)
      {
        case VAR_40:
        case VAR_41:
        case VAR_27:
        {
          VAR_5.image.image_element[VAR_13].descriptor=VAR_42;
          if (VAR_1->alpha_trait != VAR_30)
            VAR_5.image.image_element[VAR_13].descriptor=VAR_43;
          break;
        }
        default:
        {
          VAR_5.image.image_element[VAR_13].descriptor=VAR_44;
          if (VAR_1->alpha_trait != VAR_30)
            VAR_5.image.image_element[VAR_13].descriptor=VAR_45;
          if ((VAR_0->type != VAR_46) &&
              (VAR_1->alpha_trait == VAR_30) &&
              (SetImageGray(VAR_1,VAR_2) != VAR_23))
            VAR_5.image.image_element[VAR_13].descriptor=VAR_47;
          break;
        }
      }
    VAR_8+=WriteBlobByte(VAR_1,VAR_5.image.image_element[VAR_13].descriptor);
    VAR_5.image.image_element[VAR_13].transfer_characteristic=0;
    if (VAR_1->colorspace == VAR_48)
      VAR_5.image.image_element[0].transfer_characteristic=
        VAR_49;
    VAR_8+=WriteBlobByte(VAR_1,
      VAR_5.image.image_element[VAR_13].transfer_characteristic);
    VAR_5.image.image_element[VAR_13].colorimetric=0;
    VAR_8+=WriteBlobByte(VAR_1,VAR_5.image.image_element[VAR_13].colorimetric);
    VAR_5.image.image_element[VAR_13].bit_size=0;
    if (VAR_13 == 0)
      VAR_5.image.image_element[VAR_13].bit_size=(unsigned char) VAR_1->depth;
    VAR_8+=WriteBlobByte(VAR_1,VAR_5.image.image_element[VAR_13].bit_size);
    VAR_5.image.image_element[VAR_13].packing=0;
    if ((VAR_1->depth == 10) || (VAR_1->depth == 12))
      VAR_5.image.image_element[VAR_13].packing=1;
    VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.image_element[VAR_13].packing);
    VAR_5.image.image_element[VAR_13].encoding=0;
    VAR_8+=WriteBlobShort(VAR_1,VAR_5.image.image_element[VAR_13].encoding);
    VAR_5.image.image_element[VAR_13].data_offset=0U;
    if (VAR_13 == 0)
      VAR_5.image.image_element[VAR_13].data_offset=VAR_5.file.image_offset;
    VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].data_offset);
    VAR_5.image.image_element[VAR_13].end_of_line_padding=0U;
    VAR_8+=WriteBlobLong(VAR_1,VAR_5.image.image_element[VAR_13].end_of_line_padding);
    VAR_8+=WriteBlobLong(VAR_1,
      VAR_5.image.image_element[VAR_13].end_of_image_padding);
    VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.image.image_element[VAR_13].description),
      (unsigned char *) VAR_5.image.image_element[VAR_13].description);
  }
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.image.reserve),(unsigned char *)
    VAR_5.image.reserve);
  /* COMMENT_10 */
                             
    
  if ((VAR_1->rows != VAR_1->magick_rows) ||
      (VAR_1->columns != VAR_1->magick_columns))
    {
      /* COMMENT_13 */
                                                             
        
      (void) DeleteImageProperty(VAR_1,""dpx:orientation.x_offset"");
      (void) DeleteImageProperty(VAR_1,""dpx:orientation.y_offset"");
      (void) DeleteImageProperty(VAR_1,""dpx:orientation.x_center"");
      (void) DeleteImageProperty(VAR_1,""dpx:orientation.y_center"");
      (void) DeleteImageProperty(VAR_1,""dpx:orientation.x_size"");
      (void) DeleteImageProperty(VAR_1,""dpx:orientation.y_size"");
    }
  VAR_5.orientation.x_offset=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.x_offset"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.orientation.x_offset=(unsigned int) StringToUnsignedLong(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.x_offset);
  VAR_5.orientation.y_offset=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.y_offset"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.orientation.y_offset=(unsigned int) StringToUnsignedLong(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.y_offset);
  VAR_5.orientation.x_center=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.x_center"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.orientation.x_center=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.orientation.x_center);
  VAR_5.orientation.y_center=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.y_center"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.orientation.y_center=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.orientation.y_center);
  VAR_5.orientation.x_size=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.x_size"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.orientation.x_size=(unsigned int) StringToUnsignedLong(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.x_size);
  VAR_5.orientation.y_size=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.y_size"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.orientation.y_size=(unsigned int) StringToUnsignedLong(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.y_size);
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.filename"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.orientation.filename,VAR_3,
      sizeof(VAR_5.orientation.filename)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.filename),(unsigned char *)
    VAR_5.orientation.filename);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.timestamp),(unsigned char *)
    VAR_5.orientation.timestamp);
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.device"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.orientation.device,VAR_3,
      sizeof(VAR_5.orientation.device)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.device),(unsigned char *)
    VAR_5.orientation.device);
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.serial"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.orientation.serial,VAR_3,
      sizeof(VAR_5.orientation.serial)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.serial),(unsigned char *)
    VAR_5.orientation.serial);
  for (VAR_13=0; VAR_13 < 4; VAR_13++)
    VAR_5.orientation.border[VAR_13]=0;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.border"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    {
      VAR_9=ParseGeometry(VAR_3,&VAR_6);
      if ((VAR_9 & VAR_25) == 0)
        VAR_6.sigma=VAR_6.rho;
      VAR_5.orientation.border[0]=(unsigned short) (VAR_6.rho+0.5);
      VAR_5.orientation.border[1]=(unsigned short) (VAR_6.sigma+0.5);
      VAR_5.orientation.border[2]=(unsigned short) (VAR_6.xi+0.5);
      VAR_5.orientation.border[3]=(unsigned short) (VAR_6.psi+0.5);
    }
  for (VAR_13=0; VAR_13 < 4; VAR_13++)
    VAR_8+=WriteBlobShort(VAR_1,VAR_5.orientation.border[VAR_13]);
  for (VAR_13=0; VAR_13 < 2; VAR_13++)
    VAR_5.orientation.aspect_ratio[VAR_13]=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:orientation.aspect_ratio"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    {
      VAR_9=ParseGeometry(VAR_3,&VAR_6);
      if ((VAR_9 & VAR_25) == 0)
        VAR_6.sigma=VAR_6.rho;
      VAR_5.orientation.aspect_ratio[0]=(unsigned int) (VAR_6.rho+0.5);
      VAR_5.orientation.aspect_ratio[1]=(unsigned int) (VAR_6.sigma+0.5);
    }
  for (VAR_13=0; VAR_13 < 2; VAR_13++)
    VAR_8+=WriteBlobLong(VAR_1,VAR_5.orientation.aspect_ratio[VAR_13]);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.orientation.reserve),(unsigned char *)
    VAR_5.orientation.reserve);
  /* COMMENT_16 */
                      
    
  (void) memset(VAR_5.film.id,0,sizeof(VAR_5.film.id));
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.id"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.id,VAR_3,sizeof(VAR_5.film.id)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.id),(unsigned char *) VAR_5.film.id);
  (void) memset(VAR_5.film.type,0,sizeof(VAR_5.film.type));
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.type"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.type,VAR_3,sizeof(VAR_5.film.type)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.type),(unsigned char *)
    VAR_5.film.type);
  (void) memset(VAR_5.film.offset,0,sizeof(VAR_5.film.offset));
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.offset"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.offset,VAR_3,sizeof(VAR_5.film.offset)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.offset),(unsigned char *)
    VAR_5.film.offset);
  (void) memset(VAR_5.film.prefix,0,sizeof(VAR_5.film.prefix));
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.prefix"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.prefix,VAR_3,sizeof(VAR_5.film.prefix)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.prefix),(unsigned char *)
    VAR_5.film.prefix);
  (void) memset(VAR_5.film.count,0,sizeof(VAR_5.film.count));
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.count"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.count,VAR_3,sizeof(VAR_5.film.count)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.count),(unsigned char *)
    VAR_5.film.count);
  (void) memset(VAR_5.film.format,0,sizeof(VAR_5.film.format));
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.format"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.format,VAR_3,sizeof(VAR_5.film.format)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.format),(unsigned char *)
    VAR_5.film.format);
  VAR_5.film.frame_position=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.frame_position"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.film.frame_position=(unsigned int) StringToUnsignedLong(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.film.frame_position);
  VAR_5.film.sequence_extent=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.sequence_extent"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.film.sequence_extent=(unsigned int) StringToUnsignedLong(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.film.sequence_extent);
  VAR_5.film.held_count=0U;
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.held_count"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.film.held_count=(unsigned int) StringToUnsignedLong(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.film.held_count);
  VAR_5.film.frame_rate=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.frame_rate"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.film.frame_rate=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.film.frame_rate);
  VAR_5.film.shutter_angle=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.shutter_angle"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.film.shutter_angle=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.film.shutter_angle);
  (void) memset(VAR_5.film.frame_id,0,sizeof(VAR_5.film.frame_id));
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.frame_id"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.frame_id,VAR_3,sizeof(VAR_5.film.frame_id)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.frame_id),(unsigned char *)
    VAR_5.film.frame_id);
  VAR_3=GetDPXProperty(VAR_1,""dpx:film.slate"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.film.slate,VAR_3,sizeof(VAR_5.film.slate)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.slate),(unsigned char *)
    VAR_5.film.slate);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.film.reserve),(unsigned char *)
    VAR_5.film.reserve);
  /* COMMENT_19 */
                            
    
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.time.code"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.time_code=StringToTimeCode(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.television.time_code);
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.user.bits"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.user_bits=StringToTimeCode(VAR_3);
  VAR_8+=WriteBlobLong(VAR_1,VAR_5.television.user_bits);
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.interlace"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.interlace=(unsigned char) StringToLong(VAR_3);
  VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.interlace);
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.field_number"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.field_number=(unsigned char) StringToLong(VAR_3);
  VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.field_number);
  VAR_5.television.video_signal=0;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.video_signal"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.video_signal=(unsigned char) StringToLong(VAR_3);
  VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.video_signal);
  VAR_5.television.padding=0;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.padding"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.padding=(unsigned char) StringToLong(VAR_3);
  VAR_8+=WriteBlobByte(VAR_1,VAR_5.television.padding);
  VAR_5.television.horizontal_sample_rate=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.horizontal_sample_rate"",
    VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.horizontal_sample_rate=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.horizontal_sample_rate);
  VAR_5.television.vertical_sample_rate=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.vertical_sample_rate"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.vertical_sample_rate=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.vertical_sample_rate);
  VAR_5.television.frame_rate=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.frame_rate"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.frame_rate=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.frame_rate);
  VAR_5.television.time_offset=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.time_offset"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.time_offset=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.time_offset);
  VAR_5.television.gamma=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.gamma"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.gamma=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.gamma);
  VAR_5.television.black_level=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.black_level"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.black_level=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.black_level);
  VAR_5.television.black_gain=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.black_gain"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.black_gain=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.black_gain);
  VAR_5.television.break_point=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.break_point"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.break_point=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.break_point);
  VAR_5.television.white_level=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.white_level"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.white_level=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.white_level);
  VAR_5.television.integration_times=0.0f;
  VAR_3=GetDPXProperty(VAR_1,""dpx:television.integration_times"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    VAR_5.television.integration_times=StringToDouble(VAR_3,(char **) NULL);
  VAR_8+=WriteBlobFloat(VAR_1,VAR_5.television.integration_times);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.television.reserve),(unsigned char *)
    VAR_5.television.reserve);
  /* COMMENT_22 */
                      
    
  VAR_3=GetDPXProperty(VAR_1,""dpx:user.id"",VAR_2);
  if (VAR_3 != (const char *) NULL)
    (void) strncpy(VAR_5.user.id,VAR_3,sizeof(VAR_5.user.id)-1);
  VAR_8+=WriteBlob(VAR_1,sizeof(VAR_5.user.id),(unsigned char *) VAR_5.user.id);
  if (VAR_4 != (StringInfo *) NULL)
    VAR_8+=WriteBlob(VAR_1,GetStringInfoLength(VAR_4),
      GetStringInfoDatum(VAR_4));
  while (VAR_8 < (MagickOffsetType) VAR_5.image.image_element[0].data_offset)
  {
    VAR_16=WriteBlobByte(VAR_1,0x00);
    if (VAR_16 != 1)
      {
        ThrowFileException(VAR_2,VAR_50,""UnableToWriteFile"",
          VAR_1->filename);
        break;
      }
    VAR_8+=VAR_16;
  }
  /* COMMENT_25 */
                                              
    
  VAR_10=AcquireQuantumInfo(VAR_0,VAR_1);
  if (VAR_10 == (QuantumInfo *) NULL)
    ThrowWriterException(VAR_51,""MemoryAllocationFailed"");
  SetQuantumQuantum(VAR_10,32);
  SetQuantumPack(VAR_10,VAR_5.image.image_element[0].packing == 0 ?
    VAR_52 : VAR_23);
  VAR_11=VAR_53;
  if (VAR_1->alpha_trait != VAR_30)
    VAR_11=VAR_54;
  if (VAR_1->colorspace == VAR_27)
    {
      VAR_11=VAR_55;
      if (VAR_1->alpha_trait != VAR_30)
        VAR_11=VAR_56;
      if ((VAR_17 == 2) || (VAR_18 == 2))
        VAR_11=VAR_57;
    }
  VAR_15=GetBytesPerRow(VAR_1->columns,
    VAR_1->alpha_trait != VAR_30 ? 4UL : 3UL,VAR_1->depth,
    VAR_5.image.image_element[0].packing == 0 ? VAR_23 : VAR_52);
  if ((VAR_0->type != VAR_46) &&
      (VAR_1->alpha_trait == VAR_30) &&
      (SetImageGray(VAR_1,VAR_2) != VAR_23))
    {
      VAR_11=VAR_58;
      VAR_15=GetBytesPerRow(VAR_1->columns,1UL,VAR_1->depth,
        VAR_5.image.image_element[0].packing == 0 ? VAR_23 : VAR_52);
    }
  VAR_21=(unsigned char *) GetQuantumPixels(VAR_10);
  for (VAR_19=0; VAR_19 < (ssize_t) VAR_1->rows; VAR_19++)
  {
    size_t
      VAR_59;

    VAR_12=GetVirtualPixels(VAR_1,0,VAR_19,VAR_1->columns,1,VAR_2);
    if (VAR_12 == (const Quantum *) NULL)
      break;
    VAR_59=ExportQuantumPixels(VAR_1,(CacheView *) NULL,VAR_10,
      VAR_11,VAR_21,VAR_2);
    if (VAR_59 == 0)
      break;
    VAR_16=WriteBlob(VAR_1,VAR_15,VAR_21);
    if (VAR_16 != (ssize_t) VAR_15)
      break;
    VAR_7=SetImageProgress(VAR_1,VAR_60,(MagickOffsetType) VAR_19,
      VAR_1->rows);
    if (VAR_7 == VAR_23)
      break;
  }
  VAR_10=DestroyQuantumInfo(VAR_10);
  if (VAR_19 < (ssize_t) VAR_1->rows)
    ThrowWriterException(VAR_26,""UnableToWriteImageData"");
  (void) CloseBlob(VAR_1);
  return(VAR_7);
}",ImageMagick/ee5b9c56b9ca18ed0750f8a15e0d1a6da92a6e99/dpx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -562,8 +562,10 @@
       break;
     length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
       quantum_type,pixels,exception);
+    if (length == 0)
+      break;
     count=WriteBlob(image,extent,pixels);
-    if (count != (ssize_t) length)
+    if (count != (ssize_t) extent)
       break;
     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
       image->rows);","{'deleted_lines': ['    if (count != (ssize_t) length)'], 'added_lines': ['    if (length == 0)', '      break;', '    if (count != (ssize_t) extent)']}",True,ImageMagick 7.0.8-34 has a memory leak vulnerability in the WriteDPXImage function in coders/dpx.c.,5.5,MEDIUM,1,test,2019-03-30T12:47:09Z,2
CVE-2019-10879,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,teeworlds,added  additional checks to datafile loading. Closes #2070,4d529dcd2d01022e979ebfa0b91167dee37cdb8e,https://github.com/teeworlds/teeworlds/commit/4d529dcd2d01022e979ebfa0b91167dee37cdb8e,src/engine/shared/datafile.cpp,CDataFileReader::Open,"bool CDataFileReader::Open(class IStorage *pStorage, const char *pFilename, int StorageType)
{
dbg_msg(""datafile"", ""loading. filename='%s'"", pFilename);
IOHANDLE File = pStorage->OpenFile(pFilename, IOFLAG_READ, StorageType);
if(!File)
{
dbg_msg(""datafile"", ""could not open '%s'"", pFilename);
return false;
}
SHA256_CTX Sha256Ctx;
sha256_init(&Sha256Ctx);
unsigned Crc = crc32(0L, 0x0, 0);
{
enum
{
BUFFER_SIZE = 64*1024
};
unsigned char aBuffer[BUFFER_SIZE];
while(1)
{
unsigned Bytes = io_read(File, aBuffer, BUFFER_SIZE);
if(Bytes == 0)
break;
sha256_update(&Sha256Ctx, aBuffer, Bytes);
Crc = crc32(Crc, aBuffer, Bytes); }
io_seek(File, 0, IOSEEK_START);
}
CDatafileHeader Header;
io_read(File, &Header, sizeof(Header));
if(Header.m_aID[0] != 'A' || Header.m_aID[1] != 'T' || Header.m_aID[2] != 'A' || Header.m_aID[3] != 'D')
{
if(Header.m_aID[0] != 'D' || Header.m_aID[1] != 'A' || Header.m_aID[2] != 'T' || Header.m_aID[3] != 'A')
{
dbg_msg(""datafile"", ""wrong signature. %x %x %x %x"", Header.m_aID[0], Header.m_aID[1], Header.m_aID[2], Header.m_aID[3]);
io_close(File);
return 0;
}
}
#if defined(CONF_ARCH_ENDIAN_BIG)
swap_endian(&Header, sizeof(int), sizeof(Header)/sizeof(int));
#endif
if(Header.m_Version != 3 && Header.m_Version != 4)
{
dbg_msg(""datafile"", ""wrong version. version=%x"", Header.m_Version);
io_close(File);
return 0;
}
unsigned Size = 0;
Size += Header.m_NumItemTypes*sizeof(CDatafileItemType);
Size += (Header.m_NumItems+Header.m_NumRawData)*sizeof(int);
if(Header.m_Version == 4)
Size += Header.m_NumRawData*sizeof(int); Size += Header.m_ItemSize;
unsigned AllocSize = Size;
AllocSize += sizeof(CDatafile); AllocSize += Header.m_NumRawData*sizeof(void*); 
CDatafile *pTmpDataFile = (CDatafile*)mem_alloc(AllocSize, 1);
pTmpDataFile->m_Header = Header;
pTmpDataFile->m_DataStartOffset = sizeof(CDatafileHeader) + Size;
pTmpDataFile->m_ppDataPtrs = (char**)(pTmpDataFile+1);
pTmpDataFile->m_pData = (char *)(pTmpDataFile+1)+Header.m_NumRawData*sizeof(char *);
pTmpDataFile->m_File = File;
pTmpDataFile->m_Sha256 = sha256_finish(&Sha256Ctx);
pTmpDataFile->m_Crc = Crc;
mem_zero(pTmpDataFile->m_ppDataPtrs, Header.m_NumRawData*sizeof(void*));
unsigned ReadSize = io_read(File, pTmpDataFile->m_pData, Size);
if(ReadSize != Size)
{
io_close(pTmpDataFile->m_File);
mem_free(pTmpDataFile);
pTmpDataFile = 0;
dbg_msg(""datafile"", ""couldn't load the whole thing, wanted=%d got=%d"", Size, ReadSize);
return false;
}
Close();
m_pDataFile = pTmpDataFile;
#if defined(CONF_ARCH_ENDIAN_BIG)
swap_endian(m_pDataFile->m_pData, sizeof(int), min(static_cast<unsigned>(Header.m_Swaplen), Size) / sizeof(int));
#endif
{
dbg_msg(""datafile"", ""allocsize=%d"", AllocSize);
dbg_msg(""datafile"", ""readsize=%d"", ReadSize);
dbg_msg(""datafile"", ""swaplen=%d"", Header.m_Swaplen);
dbg_msg(""datafile"", ""item_size=%d"", m_pDataFile->m_Header.m_ItemSize);
}
m_pDataFile->m_Info.m_pItemTypes = (CDatafileItemType *)m_pDataFile->m_pData;
m_pDataFile->m_Info.m_pItemOffsets = (int *)&m_pDataFile->m_Info.m_pItemTypes[m_pDataFile->m_Header.m_NumItemTypes];
m_pDataFile->m_Info.m_pDataOffsets = (int *)&m_pDataFile->m_Info.m_pItemOffsets[m_pDataFile->m_Header.m_NumItems];
m_pDataFile->m_Info.m_pDataSizes = (int *)&m_pDataFile->m_Info.m_pDataOffsets[m_pDataFile->m_Header.m_NumRawData];
if(Header.m_Version == 4)
m_pDataFile->m_Info.m_pItemStart = (char *)&m_pDataFile->m_Info.m_pDataSizes[m_pDataFile->m_Header.m_NumRawData];
else
m_pDataFile->m_Info.m_pItemStart = (char *)&m_pDataFile->m_Info.m_pDataOffsets[m_pDataFile->m_Header.m_NumRawData];
m_pDataFile->m_Info.m_pDataStart = m_pDataFile->m_Info.m_pItemStart + m_pDataFile->m_Header.m_ItemSize;
dbg_msg(""datafile"", ""loading done. datafile='%s'"", pFilename);
if(DEBUG)
{
}
return true;
}","bool CDataFileReader::Open(class IStorage *VAR_0, const char *VAR_1, int VAR_2)
{
dbg_msg(""datafile"", ""loading. filename='%s'"", VAR_1);
IOHANDLE VAR_3 = VAR_0->OpenFile(VAR_1, VAR_4, VAR_2);
if(!VAR_3)
{
dbg_msg(""datafile"", ""could not open '%s'"", VAR_1);
return false;
}
SHA256_CTX VAR_5;
sha256_init(&VAR_5);
unsigned VAR_6 = crc32(0L, 0x0, 0);
{
enum
{
VAR_7 = 64*1024
};
unsigned char VAR_8[VAR_7];
while(1)
{
unsigned VAR_9 = io_read(VAR_3, VAR_8, VAR_7);
if(VAR_9 == 0)
break;
sha256_update(&VAR_5, VAR_8, VAR_9);
VAR_6 = crc32(VAR_6, VAR_8, VAR_9); 
}
io_seek(VAR_3, 0, VAR_10);
}
CDatafileHeader VAR_11;
io_read(VAR_3, &VAR_11, sizeof(VAR_11));
if(VAR_11.m_aID[0] != 'A' || VAR_11.m_aID[1] != 'T' || VAR_11.m_aID[2] != 'A' || VAR_11.m_aID[3] != 'D')
{
if(VAR_11.m_aID[0] != 'D' || VAR_11.m_aID[1] != 'A' || VAR_11.m_aID[2] != 'T' || VAR_11.m_aID[3] != 'A')
{
dbg_msg(""datafile"", ""wrong signature. %x %x %x %x"", VAR_11.m_aID[0], VAR_11.m_aID[1], VAR_11.m_aID[2], VAR_11.m_aID[3]);
io_close(VAR_3);
return 0;
}
}
#if defined(VAR_12)
swap_endian(&VAR_11, sizeof(int), sizeof(Header)/sizeof(int));
#endif
if(Header.m_Version != 3 && Header.m_Version != 4)
{
dbg_msg(""datafile"", ""wrong version. version=%x"", Header.m_Version);
io_close(VAR_3);
return 0;
}
unsigned VAR_13 = 0;
VAR_13 += Header.m_NumItemTypes*sizeof(VAR_14);
VAR_13 += (Header.m_NumItems+Header.m_NumRawData)*sizeof(int);
if(Header.m_Version == 4)
VAR_13 += Header.m_NumRawData*sizeof(int); 
VAR_13 += Header.m_ItemSize;
unsigned VAR_15 = VAR_13;
VAR_15 += sizeof(VAR_16); 
VAR_15 += Header.m_NumRawData*sizeof(void*); 
CDatafile *VAR_17 = (CDatafile*)mem_alloc(VAR_15, 1);
VAR_17->m_Header = Header;
VAR_17->m_DataStartOffset = sizeof(CDatafileHeader) + VAR_13;
VAR_17->m_ppDataPtrs = (char**)(VAR_17+1);
VAR_17->m_pData = (char *)(VAR_17+1)+Header.m_NumRawData*sizeof(char *);
VAR_17->m_File = VAR_3;
VAR_17->m_Sha256 = sha256_finish(&VAR_5);
VAR_17->m_Crc = VAR_6;
mem_zero(VAR_17->m_ppDataPtrs, Header.m_NumRawData*sizeof(void*));
unsigned VAR_18 = io_read(VAR_3, VAR_17->m_pData, VAR_13);
if(VAR_18 != VAR_13)
{
io_close(VAR_17->m_File);
mem_free(VAR_17);
VAR_17 = 0;
dbg_msg(""datafile"", ""couldn't load the whole thing, wanted=%d got=%d"", VAR_13, VAR_18);
return false;
}
Close();
VAR_19 = VAR_17;
#if defined(VAR_12)
swap_endian(VAR_19->m_pData, sizeof(int), min(VAR_20<unsigned>(Header.m_Swaplen), VAR_13) / sizeof(int));
#endif
{
dbg_msg(""datafile"", ""allocsize=%d"", VAR_15);
dbg_msg(""datafile"", ""readsize=%d"", VAR_18);
dbg_msg(""datafile"", ""swaplen=%d"", Header.m_Swaplen);
dbg_msg(""datafile"", ""item_size=%d"", VAR_19->m_Header.m_ItemSize);
}
VAR_19->m_Info.m_pItemTypes = (CDatafileItemType *)VAR_19->m_pData;
VAR_19->m_Info.m_pItemOffsets = (int *)&VAR_19->m_Info.m_pItemTypes[VAR_19->m_Header.m_NumItemTypes];
VAR_19->m_Info.m_pDataOffsets = (int *)&VAR_19->m_Info.m_pItemOffsets[VAR_19->m_Header.m_NumItems];
VAR_19->m_Info.m_pDataSizes = (int *)&VAR_19->m_Info.m_pDataOffsets[VAR_19->m_Header.m_NumRawData];
if(Header.m_Version == 4)
VAR_19->m_Info.m_pItemStart = (char *)&VAR_19->m_Info.m_pDataSizes[VAR_19->m_Header.m_NumRawData];
else
VAR_19->m_Info.m_pItemStart = (char *)&VAR_19->m_Info.m_pDataOffsets[VAR_19->m_Header.m_NumRawData];
VAR_19->m_Info.m_pDataStart = VAR_19->m_Info.m_pItemStart + VAR_19->m_Header.m_ItemSize;
dbg_msg(""datafile"", ""loading done. datafile='%s'"", VAR_1);
if(VAR_21)
{
}
return true;
}",teeworlds/4d529dcd2d01022e979ebfa0b91167dee37cdb8e/datafile.cpp/vul/before/0.json,"bool CDataFileReader::Open(class IStorage *pStorage, const char *pFilename, int StorageType)
{
	dbg_msg(""datafile"", ""loading. filename='%s'"", pFilename);

	IOHANDLE File = pStorage->OpenFile(pFilename, IOFLAG_READ, StorageType);
	if(!File)
	{
		dbg_msg(""datafile"", ""could not open '%s'"", pFilename);
		return false;
	}


	// take the hashes of the file and store them
	SHA256_CTX Sha256Ctx;
	sha256_init(&Sha256Ctx);
	unsigned Crc = crc32(0L, 0x0, 0);
	{
		enum
		{
			BUFFER_SIZE = 64*1024
		};

		unsigned char aBuffer[BUFFER_SIZE];

		while(1)
		{
			unsigned Bytes = io_read(File, aBuffer, BUFFER_SIZE);
			if(Bytes == 0)
				break;
			sha256_update(&Sha256Ctx, aBuffer, Bytes);
			Crc = crc32(Crc, aBuffer, Bytes); // ignore_convention
		}

		io_seek(File, 0, IOSEEK_START);
	}

	// TODO: change this header
	CDatafileHeader Header;
	io_read(File, &Header, sizeof(Header));
	if(Header.m_aID[0] != 'A' || Header.m_aID[1] != 'T' || Header.m_aID[2] != 'A' || Header.m_aID[3] != 'D')
	{
		if(Header.m_aID[0] != 'D' || Header.m_aID[1] != 'A' || Header.m_aID[2] != 'T' || Header.m_aID[3] != 'A')
		{
			dbg_msg(""datafile"", ""wrong signature. %x %x %x %x"", Header.m_aID[0], Header.m_aID[1], Header.m_aID[2], Header.m_aID[3]);
			io_close(File);
			return 0;
		}
	}

#if defined(CONF_ARCH_ENDIAN_BIG)
	swap_endian(&Header, sizeof(int), sizeof(Header)/sizeof(int));
#endif
	if(Header.m_Version != 3 && Header.m_Version != 4)
	{
		dbg_msg(""datafile"", ""wrong version. version=%x"", Header.m_Version);
		io_close(File);
		return 0;
	}

	// read in the rest except the data
	int64 Size = 0;
	Size += Header.m_NumItemTypes*sizeof(CDatafileItemType);
	Size += (Header.m_NumItems+Header.m_NumRawData)*sizeof(int);
	if(Header.m_Version == 4)
		Size += Header.m_NumRawData*sizeof(int); // v4 has uncompressed data sizes aswell
	Size += Header.m_ItemSize;

	int64 AllocSize = Size;
	AllocSize += sizeof(CDatafile); // add space for info structure
	AllocSize += Header.m_NumRawData*sizeof(void*); // add space for data pointers
	if(Size > (int64(1)<<31) || Header.m_NumItemTypes < 0 || Header.m_NumItems < 0 || Header.m_NumRawData < 0 || Header.m_ItemSize < 0)
	{
		io_close(File);
		dbg_msg(""datafile"", ""unable to load file, invalid file information"");
		return false;
	}

	CDatafile *pTmpDataFile = (CDatafile*)mem_alloc(AllocSize, 1);
	pTmpDataFile->m_Header = Header;
	pTmpDataFile->m_DataStartOffset = sizeof(CDatafileHeader) + Size;
	pTmpDataFile->m_ppDataPtrs = (char**)(pTmpDataFile+1);
	pTmpDataFile->m_pData = (char *)(pTmpDataFile+1)+Header.m_NumRawData*sizeof(char *);
	pTmpDataFile->m_File = File;
	pTmpDataFile->m_Sha256 = sha256_finish(&Sha256Ctx);
	pTmpDataFile->m_Crc = Crc;

	// clear the data pointers
	mem_zero(pTmpDataFile->m_ppDataPtrs, Header.m_NumRawData*sizeof(void*));

	// read types, offsets, sizes and item data
	unsigned ReadSize = io_read(File, pTmpDataFile->m_pData, Size);
	if(ReadSize != Size)
	{
		io_close(pTmpDataFile->m_File);
		mem_free(pTmpDataFile);
		pTmpDataFile = 0;
		dbg_msg(""datafile"", ""couldn't load the whole thing, wanted=%d got=%d"", Size, ReadSize);
		return false;
	}

	Close();
	m_pDataFile = pTmpDataFile;

#if defined(CONF_ARCH_ENDIAN_BIG)
	swap_endian(m_pDataFile->m_pData, sizeof(int), min(static_cast<unsigned>(Header.m_Swaplen), Size) / sizeof(int));
#endif

	//if(DEBUG)
	{
		dbg_msg(""datafile"", ""allocsize=%d"", AllocSize);
		dbg_msg(""datafile"", ""readsize=%d"", ReadSize);
		dbg_msg(""datafile"", ""swaplen=%d"", Header.m_Swaplen);
		dbg_msg(""datafile"", ""item_size=%d"", m_pDataFile->m_Header.m_ItemSize);
	}

	m_pDataFile->m_Info.m_pItemTypes = (CDatafileItemType *)m_pDataFile->m_pData;
	m_pDataFile->m_Info.m_pItemOffsets = (int *)&m_pDataFile->m_Info.m_pItemTypes[m_pDataFile->m_Header.m_NumItemTypes];
	m_pDataFile->m_Info.m_pDataOffsets = (int *)&m_pDataFile->m_Info.m_pItemOffsets[m_pDataFile->m_Header.m_NumItems];
	m_pDataFile->m_Info.m_pDataSizes = (int *)&m_pDataFile->m_Info.m_pDataOffsets[m_pDataFile->m_Header.m_NumRawData];

	if(Header.m_Version == 4)
		m_pDataFile->m_Info.m_pItemStart = (char *)&m_pDataFile->m_Info.m_pDataSizes[m_pDataFile->m_Header.m_NumRawData];
	else
		m_pDataFile->m_Info.m_pItemStart = (char *)&m_pDataFile->m_Info.m_pDataOffsets[m_pDataFile->m_Header.m_NumRawData];
	m_pDataFile->m_Info.m_pDataStart = m_pDataFile->m_Info.m_pItemStart + m_pDataFile->m_Header.m_ItemSize;

	dbg_msg(""datafile"", ""loading done. datafile='%s'"", pFilename);

	if(DEBUG)
	{
		/*
		for(int i = 0; i < m_pDataFile->data.num_raw_data; i++)
		{
			void *p = datafile_get_data(df, i);
			dbg_msg(""datafile"", ""%d %d"", (int)((char*)p - (char*)(&m_pDataFile->data)), size);
		}

		for(int i = 0; i < datafile_num_items(df); i++)
		{
			int type, id;
			void *data = datafile_get_item(df, i, &type, &id);
			dbg_msg(""map"", ""\t%d: type=%x id=%x p=%p offset=%d"", i, type, id, data, m_pDataFile->info.item_offsets[i]);
			int *idata = (int*)data;
			for(int k = 0; k < 3; k++)
				dbg_msg(""datafile"", ""\t\t%d=%d (%x)"", k, idata[k], idata[k]);
		}

		for(int i = 0; i < m_pDataFile->data.num_m_aItemTypes; i++)
		{
			dbg_msg(""map"", ""\t%d: type=%x start=%d num=%d"", i,
				m_pDataFile->info.m_aItemTypes[i].type,
				m_pDataFile->info.m_aItemTypes[i].start,
				m_pDataFile->info.m_aItemTypes[i].num);
			for(int k = 0; k < m_pDataFile->info.m_aItemTypes[i].num; k++)
			{
				int type, id;
				datafile_get_item(df, m_pDataFile->info.m_aItemTypes[i].start+k, &type, &id);
				if(type != m_pDataFile->info.m_aItemTypes[i].type)
					dbg_msg(""map"", ""\tERROR"");
			}
		}
		*/
	}

	return true;
}","bool CDataFileReader::Open(class IStorage *VAR_0, const char *VAR_1, int VAR_2)
{
	dbg_msg(""datafile"", ""loading. filename='%s'"", VAR_1);

	IOHANDLE VAR_3 = VAR_0->OpenFile(VAR_1, VAR_4, VAR_2);
	if(!VAR_3)
	{
		dbg_msg(""datafile"", ""could not open '%s'"", VAR_1);
		return false;
	}


	/* COMMENT_0 */
	SHA256_CTX VAR_5;
	sha256_init(&VAR_5);
	unsigned VAR_6 = crc32(0L, 0x0, 0);
	{
		enum
		{
			VAR_7 = 64*1024
		};

		unsigned char VAR_8[VAR_7];

		while(1)
		{
			unsigned VAR_9 = io_read(VAR_3, VAR_8, VAR_7);
			if(VAR_9 == 0)
				break;
			sha256_update(&VAR_5, VAR_8, VAR_9);
			VAR_6 = crc32(VAR_6, VAR_8, VAR_9); /* COMMENT_1 */
		}

		io_seek(VAR_3, 0, VAR_10);
	}

	/* COMMENT_2 */
	CDatafileHeader VAR_11;
	io_read(VAR_3, &VAR_11, sizeof(VAR_11));
	if(VAR_11.m_aID[0] != 'A' || VAR_11.m_aID[1] != 'T' || VAR_11.m_aID[2] != 'A' || VAR_11.m_aID[3] != 'D')
	{
		if(VAR_11.m_aID[0] != 'D' || VAR_11.m_aID[1] != 'A' || VAR_11.m_aID[2] != 'T' || VAR_11.m_aID[3] != 'A')
		{
			dbg_msg(""datafile"", ""wrong signature. %x %x %x %x"", VAR_11.m_aID[0], VAR_11.m_aID[1], VAR_11.m_aID[2], VAR_11.m_aID[3]);
			io_close(VAR_3);
			return 0;
		}
	}

#if defined(VAR_12)
	swap_endian(&VAR_11, sizeof(int), sizeof(Header)/sizeof(int));
#endif
	if(Header.m_Version != 3 && Header.m_Version != 4)
	{
		dbg_msg(""datafile"", ""wrong version. version=%x"", Header.m_Version);
		io_close(VAR_3);
		return 0;
	}

	/* COMMENT_3 */
	int64 VAR_13 = 0;
	VAR_13 += Header.m_NumItemTypes*sizeof(VAR_14);
	VAR_13 += (Header.m_NumItems+Header.m_NumRawData)*sizeof(int);
	if(Header.m_Version == 4)
		VAR_13 += Header.m_NumRawData*sizeof(int); /* COMMENT_4 */
	VAR_13 += Header.m_ItemSize;

	int64 VAR_15 = VAR_13;
	VAR_15 += sizeof(VAR_16); /* COMMENT_5 */
	VAR_15 += Header.m_NumRawData*sizeof(void*); /* COMMENT_6 */
	if(VAR_13 > (int64(1)<<31) || Header.m_NumItemTypes < 0 || Header.m_NumItems < 0 || Header.m_NumRawData < 0 || Header.m_ItemSize < 0)
	{
		io_close(VAR_3);
		dbg_msg(""datafile"", ""unable to load file, invalid file information"");
		return false;
	}

	CDatafile *VAR_17 = (CDatafile*)mem_alloc(VAR_15, 1);
	VAR_17->m_Header = Header;
	VAR_17->m_DataStartOffset = sizeof(CDatafileHeader) + VAR_13;
	VAR_17->m_ppDataPtrs = (char**)(VAR_17+1);
	VAR_17->m_pData = (char *)(VAR_17+1)+Header.m_NumRawData*sizeof(char *);
	VAR_17->m_File = VAR_3;
	VAR_17->m_Sha256 = sha256_finish(&VAR_5);
	VAR_17->m_Crc = VAR_6;

	/* COMMENT_7 */
	mem_zero(VAR_17->m_ppDataPtrs, Header.m_NumRawData*sizeof(void*));

	/* COMMENT_8 */
	unsigned VAR_18 = io_read(VAR_3, VAR_17->m_pData, VAR_13);
	if(VAR_18 != VAR_13)
	{
		io_close(VAR_17->m_File);
		mem_free(VAR_17);
		VAR_17 = 0;
		dbg_msg(""datafile"", ""couldn't load the whole thing, wanted=%d got=%d"", VAR_13, VAR_18);
		return false;
	}

	Close();
	VAR_19 = VAR_17;

#if defined(VAR_12)
	swap_endian(VAR_19->m_pData, sizeof(int), min(VAR_20<unsigned>(Header.m_Swaplen), VAR_13) / sizeof(int));
#endif

	/* COMMENT_9 */
	{
		dbg_msg(""datafile"", ""allocsize=%d"", VAR_15);
		dbg_msg(""datafile"", ""readsize=%d"", VAR_18);
		dbg_msg(""datafile"", ""swaplen=%d"", Header.m_Swaplen);
		dbg_msg(""datafile"", ""item_size=%d"", VAR_19->m_Header.m_ItemSize);
	}

	VAR_19->m_Info.m_pItemTypes = (CDatafileItemType *)VAR_19->m_pData;
	VAR_19->m_Info.m_pItemOffsets = (int *)&VAR_19->m_Info.m_pItemTypes[VAR_19->m_Header.m_NumItemTypes];
	VAR_19->m_Info.m_pDataOffsets = (int *)&VAR_19->m_Info.m_pItemOffsets[VAR_19->m_Header.m_NumItems];
	VAR_19->m_Info.m_pDataSizes = (int *)&VAR_19->m_Info.m_pDataOffsets[VAR_19->m_Header.m_NumRawData];

	if(Header.m_Version == 4)
		VAR_19->m_Info.m_pItemStart = (char *)&VAR_19->m_Info.m_pDataSizes[VAR_19->m_Header.m_NumRawData];
	else
		VAR_19->m_Info.m_pItemStart = (char *)&VAR_19->m_Info.m_pDataOffsets[VAR_19->m_Header.m_NumRawData];
	VAR_19->m_Info.m_pDataStart = VAR_19->m_Info.m_pItemStart + VAR_19->m_Header.m_ItemSize;

	dbg_msg(""datafile"", ""loading done. datafile='%s'"", VAR_1);

	if(VAR_21)
	{
		/* COMMENT_10 */
                                                         
   
                                      
                                                                                     
   

                                                 
   
                
                                                     
                                                                                                              
                           
                             
                                                                 
   

                                                             
   
                                                     
                                           
                                            
                                           
                                                                 
    
                 
                                                                                 
                                                      
                               
    
   
    
	}

	return true;
}",teeworlds/4d529dcd2d01022e979ebfa0b91167dee37cdb8e/datafile.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -58,16 +58,22 @@
 	}
 
 	// read in the rest except the data
-	unsigned Size = 0;
+	int64 Size = 0;
 	Size += Header.m_NumItemTypes*sizeof(CDatafileItemType);
 	Size += (Header.m_NumItems+Header.m_NumRawData)*sizeof(int);
 	if(Header.m_Version == 4)
 		Size += Header.m_NumRawData*sizeof(int); // v4 has uncompressed data sizes aswell
 	Size += Header.m_ItemSize;
 
-	unsigned AllocSize = Size;
+	int64 AllocSize = Size;
 	AllocSize += sizeof(CDatafile); // add space for info structure
 	AllocSize += Header.m_NumRawData*sizeof(void*); // add space for data pointers
+	if(Size > (int64(1)<<31) || Header.m_NumItemTypes < 0 || Header.m_NumItems < 0 || Header.m_NumRawData < 0 || Header.m_ItemSize < 0)
+	{
+		io_close(File);
+		dbg_msg(""datafile"", ""unable to load file, invalid file information"");
+		return false;
+	}
 
 	CDatafile *pTmpDataFile = (CDatafile*)mem_alloc(AllocSize, 1);
 	pTmpDataFile->m_Header = Header;","{'deleted_lines': ['\tunsigned Size = 0;', '\tunsigned AllocSize = Size;'], 'added_lines': ['\tint64 Size = 0;', '\tint64 AllocSize = Size;', '\tif(Size > (int64(1)<<31) || Header.m_NumItemTypes < 0 || Header.m_NumItems < 0 || Header.m_NumRawData < 0 || Header.m_ItemSize < 0)', '\t{', '\t\tio_close(File);', '\t\tdbg_msg(""datafile"", ""unable to load file, invalid file information"");', '\t\treturn false;', '\t}']}",True,"In Teeworlds 0.7.2, there is an integer overflow in CDataFileReader::Open() in engine/shared/datafile.cpp that can lead to a buffer overflow and possibly remote code execution, because size-related multiplications are mishandled.",9.8,CRITICAL,3,test,2019-03-31T15:10:59Z,2
CVE-2018-20190,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sass/libsass,"Error on incomplete `@supports` clause in parser

Fixes #2786

Spec added in https://github.com/sass/sass-spec/pull/1370",98d8d5dadacc3cd07c738b3772f56317a7a306e7,https://github.com/sass/libsass/commit/98d8d5dadacc3cd07c738b3772f56317a7a306e7,src/parser.cpp,Parser::parse_supports_condition,"Supports_Condition_Obj Parser::parse_supports_condition()
{
lex < css_whitespace >();
Supports_Condition_Obj cond;
if ((cond = parse_supports_negation())) return cond;
if ((cond = parse_supports_operator())) return cond;
if ((cond = parse_supports_interpolation())) return cond;
return cond;
}","Supports_Condition_Obj Parser::parse_supports_condition()
{
VAR_0 < css_whitespace >();
Supports_Condition_Obj VAR_1;
if ((VAR_1 = parse_supports_negation())) return VAR_1;
if ((VAR_1 = parse_supports_operator())) return VAR_1;
if ((VAR_1 = parse_supports_interpolation())) return VAR_1;
return VAR_1;
}",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/before/0.json,"Supports_Condition_Obj Parser::parse_supports_condition(bool top_level)
  {
    lex < css_whitespace >();
    Supports_Condition_Obj cond;
    if ((cond = parse_supports_negation())) return cond;
    if ((cond = parse_supports_operator(top_level))) return cond;
    if ((cond = parse_supports_interpolation())) return cond;
    return cond;
  }","Supports_Condition_Obj Parser::parse_supports_condition(bool VAR_0)
  {
    VAR_1 < css_whitespace >();
    Supports_Condition_Obj VAR_2;
    if ((VAR_2 = parse_supports_negation())) return VAR_2;
    if ((VAR_2 = parse_supports_operator(VAR_0))) return VAR_2;
    if ((VAR_2 = parse_supports_interpolation())) return VAR_2;
    return VAR_2;
  }",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,9 +1,9 @@
-Supports_Condition_Obj Parser::parse_supports_condition()
+Supports_Condition_Obj Parser::parse_supports_condition(bool top_level)
   {
     lex < css_whitespace >();
     Supports_Condition_Obj cond;
     if ((cond = parse_supports_negation())) return cond;
-    if ((cond = parse_supports_operator())) return cond;
+    if ((cond = parse_supports_operator(top_level))) return cond;
     if ((cond = parse_supports_interpolation())) return cond;
     return cond;
   }","{'deleted_lines': ['Supports_Condition_Obj Parser::parse_supports_condition()', '    if ((cond = parse_supports_operator())) return cond;'], 'added_lines': ['Supports_Condition_Obj Parser::parse_supports_condition(bool top_level)', '    if ((cond = parse_supports_operator(top_level))) return cond;']}",True,"In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Eval::operator()(Sass::Supports_Operator*) in eval.cpp may cause a Denial of Service (application crash) via a crafted sass input file.",6.5,MEDIUM,1,test,2019-04-04T18:59:24Z,2
CVE-2018-20190,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sass/libsass,"Error on incomplete `@supports` clause in parser

Fixes #2786

Spec added in https://github.com/sass/sass-spec/pull/1370",98d8d5dadacc3cd07c738b3772f56317a7a306e7,https://github.com/sass/libsass/commit/98d8d5dadacc3cd07c738b3772f56317a7a306e7,src/parser.cpp,Parser::parse_supports_operator,"Supports_Condition_Obj Parser::parse_supports_operator()
{
Supports_Condition_Obj cond = parse_supports_condition_in_parens();
if (cond.isNull()) return {};
while (true) {
Supports_Operator::Operand op = Supports_Operator::OR;
if (lex < kwd_and >()) { op = Supports_Operator::AND; }
else if(!lex < kwd_or >()) { break; }
lex < css_whitespace >();
Supports_Condition_Obj right = parse_supports_condition_in_parens();
cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
}
return cond;
}","Supports_Condition_Obj Parser::parse_supports_operator()
{
Supports_Condition_Obj VAR_0 = parse_supports_condition_in_parens();
if (VAR_0.isNull()) return {};
while (true) {
Supports_Operator::Operand VAR_1 = Supports_Operator::OR;
if (VAR_2 < kwd_and >()) { VAR_1 = Supports_Operator::AND; }
else if(!VAR_2 < kwd_or >()) { break; }
VAR_2 < css_whitespace >();
Supports_Condition_Obj VAR_3 = parse_supports_condition_in_parens();
VAR_0 = SASS_MEMORY_NEW(VAR_4, VAR_5, VAR_0, VAR_3, VAR_1);
}
return VAR_0;
}",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/before/4.json,"Supports_Condition_Obj Parser::parse_supports_operator(bool top_level)
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens(/*parens_required=*/top_level);
    if (cond.isNull()) return {};

    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }

      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens(/*parens_required=*/true);

      // Supports_Condition* cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition*>(cond));
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    return cond;
  }","Supports_Condition_Obj Parser::parse_supports_operator(bool VAR_0)
  {
    Supports_Condition_Obj VAR_1 = parse_supports_condition_in_parens(/* COMMENT_0 */VAR_0);
    if (VAR_1.isNull()) return {};

    while (true) {
      Supports_Operator::Operand VAR_2 = Supports_Operator::OR;
      if (VAR_3 < kwd_and >()) { VAR_2 = Supports_Operator::AND; }
      else if(!VAR_3 < kwd_or >()) { break; }

      VAR_3 < css_whitespace >();
      Supports_Condition_Obj VAR_4 = parse_supports_condition_in_parens(/* COMMENT_0 */true);

      /* COMMENT_1 */
      VAR_1 = SASS_MEMORY_NEW(VAR_5, VAR_6, VAR_1, VAR_4, VAR_2);
    }
    return VAR_1;
  }",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
-Supports_Condition_Obj Parser::parse_supports_operator()
+Supports_Condition_Obj Parser::parse_supports_operator(bool top_level)
   {
-    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
+    Supports_Condition_Obj cond = parse_supports_condition_in_parens(/*parens_required=*/top_level);
     if (cond.isNull()) return {};
 
     while (true) {
@@ -9,7 +9,7 @@
       else if(!lex < kwd_or >()) { break; }
 
       lex < css_whitespace >();
-      Supports_Condition_Obj right = parse_supports_condition_in_parens();
+      Supports_Condition_Obj right = parse_supports_condition_in_parens(/*parens_required=*/true);
 
       // Supports_Condition* cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition*>(cond));
       cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);","{'deleted_lines': ['Supports_Condition_Obj Parser::parse_supports_operator()', '    Supports_Condition_Obj cond = parse_supports_condition_in_parens();', '      Supports_Condition_Obj right = parse_supports_condition_in_parens();'], 'added_lines': ['Supports_Condition_Obj Parser::parse_supports_operator(bool top_level)', '    Supports_Condition_Obj cond = parse_supports_condition_in_parens(/*parens_required=*/top_level);', '      Supports_Condition_Obj right = parse_supports_condition_in_parens(/*parens_required=*/true);']}",True,"In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Eval::operator()(Sass::Supports_Operator*) in eval.cpp may cause a Denial of Service (application crash) via a crafted sass input file.",6.5,MEDIUM,1,test,2019-04-04T18:59:24Z,2
CVE-2018-20190,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sass/libsass,"Error on incomplete `@supports` clause in parser

Fixes #2786

Spec added in https://github.com/sass/sass-spec/pull/1370",98d8d5dadacc3cd07c738b3772f56317a7a306e7,https://github.com/sass/libsass/commit/98d8d5dadacc3cd07c738b3772f56317a7a306e7,src/parser.cpp,Parser::parse_supports_directive,"Supports_Block_Obj Parser::parse_supports_directive()
{
Supports_Condition_Obj cond = parse_supports_condition();
if (!cond) {
css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", false);
}
Supports_Block_Obj query = SASS_MEMORY_NEW(Supports_Block, pstate, cond);
query->block(parse_block());
return query;
}","Supports_Block_Obj Parser::parse_supports_directive()
{
Supports_Condition_Obj VAR_0 = parse_supports_condition();
if (!VAR_0) {
css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", false);
}
Supports_Block_Obj VAR_1 = SASS_MEMORY_NEW(VAR_2, VAR_3, VAR_0);
VAR_1->block(parse_block());
return VAR_1;
}",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/before/2.json,"Supports_Block_Obj Parser::parse_supports_directive()
  {
    Supports_Condition_Obj cond = parse_supports_condition(/*top_level=*/true);
    // create the ast node object for the support queries
    Supports_Block_Obj query = SASS_MEMORY_NEW(Supports_Block, pstate, cond);
    // additional block is mandatory
    // parse inner block
    query->block(parse_block());
    // return ast node
    return query;
  }","Supports_Block_Obj Parser::parse_supports_directive()
  {
    Supports_Condition_Obj VAR_0 = parse_supports_condition(/* COMMENT_0 */true);
    /* COMMENT_1 */
    Supports_Block_Obj VAR_1 = SASS_MEMORY_NEW(VAR_2, VAR_3, VAR_0);
    /* COMMENT_2 */
    /* COMMENT_3 */
    VAR_1->block(parse_block());
    /* COMMENT_4 */
    return VAR_1;
  }",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,9 +1,6 @@
 Supports_Block_Obj Parser::parse_supports_directive()
   {
-    Supports_Condition_Obj cond = parse_supports_condition();
-    if (!cond) {
-      css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", false);
-    }
+    Supports_Condition_Obj cond = parse_supports_condition(/*top_level=*/true);
     // create the ast node object for the support queries
     Supports_Block_Obj query = SASS_MEMORY_NEW(Supports_Block, pstate, cond);
     // additional block is mandatory","{'deleted_lines': ['    Supports_Condition_Obj cond = parse_supports_condition();', '    if (!cond) {', '      css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", false);', '    }'], 'added_lines': ['    Supports_Condition_Obj cond = parse_supports_condition(/*top_level=*/true);']}",True,"In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Eval::operator()(Sass::Supports_Operator*) in eval.cpp may cause a Denial of Service (application crash) via a crafted sass input file.",6.5,MEDIUM,1,test,2019-04-04T18:59:24Z,2
CVE-2018-20190,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sass/libsass,"Error on incomplete `@supports` clause in parser

Fixes #2786

Spec added in https://github.com/sass/sass-spec/pull/1370",98d8d5dadacc3cd07c738b3772f56317a7a306e7,https://github.com/sass/libsass/commit/98d8d5dadacc3cd07c738b3772f56317a7a306e7,src/parser.cpp,Parser::parse_supports_negation,"Supports_Condition_Obj Parser::parse_supports_negation()
{
if (!lex < kwd_not >()) return {};
Supports_Condition_Obj cond = parse_supports_condition_in_parens();
return SASS_MEMORY_NEW(Supports_Negation, pstate, cond);
}","Supports_Condition_Obj Parser::parse_supports_negation()
{
if (!VAR_0 < kwd_not >()) return {};
Supports_Condition_Obj VAR_1 = parse_supports_condition_in_parens();
return SASS_MEMORY_NEW(VAR_2, VAR_3, VAR_1);
}",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/before/3.json,"Supports_Condition_Obj Parser::parse_supports_negation()
  {
    if (!lex < kwd_not >()) return {};
    Supports_Condition_Obj cond = parse_supports_condition_in_parens(/*parens_required=*/true);
    return SASS_MEMORY_NEW(Supports_Negation, pstate, cond);
  }","Supports_Condition_Obj Parser::parse_supports_negation()
  {
    if (!VAR_0 < kwd_not >()) return {};
    Supports_Condition_Obj VAR_1 = parse_supports_condition_in_parens(/* COMMENT_0 */true);
    return SASS_MEMORY_NEW(VAR_2, VAR_3, VAR_1);
  }",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 Supports_Condition_Obj Parser::parse_supports_negation()
   {
     if (!lex < kwd_not >()) return {};
-    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
+    Supports_Condition_Obj cond = parse_supports_condition_in_parens(/*parens_required=*/true);
     return SASS_MEMORY_NEW(Supports_Negation, pstate, cond);
   }","{'deleted_lines': ['    Supports_Condition_Obj cond = parse_supports_condition_in_parens();'], 'added_lines': ['    Supports_Condition_Obj cond = parse_supports_condition_in_parens(/*parens_required=*/true);']}",True,"In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Eval::operator()(Sass::Supports_Operator*) in eval.cpp may cause a Denial of Service (application crash) via a crafted sass input file.",6.5,MEDIUM,1,test,2019-04-04T18:59:24Z,2
CVE-2018-20190,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,sass/libsass,"Error on incomplete `@supports` clause in parser

Fixes #2786

Spec added in https://github.com/sass/sass-spec/pull/1370",98d8d5dadacc3cd07c738b3772f56317a7a306e7,https://github.com/sass/libsass/commit/98d8d5dadacc3cd07c738b3772f56317a7a306e7,src/parser.cpp,Parser::parse_supports_condition_in_parens,"Supports_Condition_Obj Parser::parse_supports_condition_in_parens()
{
Supports_Condition_Obj interp = parse_supports_interpolation();
if (interp != 0) return interp;
if (!lex < exactly <'('> >()) return {};
lex < css_whitespace >();
Supports_Condition_Obj cond = parse_supports_condition();
if (cond != 0) {
if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");
} else {
cond = parse_supports_declaration();
if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");
}
lex < css_whitespace >();
return cond;
}","Supports_Condition_Obj Parser::parse_supports_condition_in_parens()
{
Supports_Condition_Obj VAR_0 = parse_supports_interpolation();
if (VAR_0 != 0) return VAR_0;
if (!VAR_1 < exactly <'('> >()) return {};
VAR_1 < css_whitespace >();
Supports_Condition_Obj VAR_2 = parse_supports_condition();
if (VAR_2 != 0) {
if (!VAR_1 < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");
} else {
VAR_2 = parse_supports_declaration();
if (!VAR_1 < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");
}
VAR_1 < css_whitespace >();
return VAR_2;
}",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/before/1.json,"Supports_Condition_Obj Parser::parse_supports_condition_in_parens(bool parens_required)
  {
    Supports_Condition_Obj interp = parse_supports_interpolation();
    if (interp != 0) return interp;

    if (!lex < exactly <'('> >()) {
      if (parens_required) {
        css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", /*trim=*/false);
      } else {
        return {};
      }
    }
    lex < css_whitespace >();

    Supports_Condition_Obj cond = parse_supports_condition(/*top_level=*/false);
    if (cond.isNull()) cond = parse_supports_declaration();
    if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");

    lex < css_whitespace >();
    return cond;
  }","Supports_Condition_Obj Parser::parse_supports_condition_in_parens(bool VAR_0)
  {
    Supports_Condition_Obj VAR_1 = parse_supports_interpolation();
    if (VAR_1 != 0) return VAR_1;

    if (!VAR_2 < exactly <'('> >()) {
      if (VAR_0) {
        css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", /* COMMENT_0 */false);
      } else {
        return {};
      }
    }
    VAR_2 < css_whitespace >();

    Supports_Condition_Obj VAR_3 = parse_supports_condition(/* COMMENT_1 */false);
    if (VAR_3.isNull()) VAR_3 = parse_supports_declaration();
    if (!VAR_2 < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");

    VAR_2 < css_whitespace >();
    return VAR_3;
  }",sass/libsass/98d8d5dadacc3cd07c738b3772f56317a7a306e7/parser.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,18 +1,21 @@
-Supports_Condition_Obj Parser::parse_supports_condition_in_parens()
+Supports_Condition_Obj Parser::parse_supports_condition_in_parens(bool parens_required)
   {
     Supports_Condition_Obj interp = parse_supports_interpolation();
     if (interp != 0) return interp;
 
-    if (!lex < exactly <'('> >()) return {};
+    if (!lex < exactly <'('> >()) {
+      if (parens_required) {
+        css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", /*trim=*/false);
+      } else {
+        return {};
+      }
+    }
     lex < css_whitespace >();
 
-    Supports_Condition_Obj cond = parse_supports_condition();
-    if (cond != 0) {
-      if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");
-    } else {
-      cond = parse_supports_declaration();
-      if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");
-    }
+    Supports_Condition_Obj cond = parse_supports_condition(/*top_level=*/false);
+    if (cond.isNull()) cond = parse_supports_declaration();
+    if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration"");
+
     lex < css_whitespace >();
     return cond;
   }","{'deleted_lines': ['Supports_Condition_Obj Parser::parse_supports_condition_in_parens()', ""    if (!lex < exactly <'('> >()) return {};"", '    Supports_Condition_Obj cond = parse_supports_condition();', '    if (cond != 0) {', '      if (!lex < exactly <\')\'> >()) error(""unclosed parenthesis in @supports declaration"");', '    } else {', '      cond = parse_supports_declaration();', '      if (!lex < exactly <\')\'> >()) error(""unclosed parenthesis in @supports declaration"");', '    }'], 'added_lines': ['Supports_Condition_Obj Parser::parse_supports_condition_in_parens(bool parens_required)', ""    if (!lex < exactly <'('> >()) {"", '      if (parens_required) {', '        css_error(""Invalid CSS"", "" after "", "": expected @supports condition (e.g. (display: flexbox)), was "", /*trim=*/false);', '      } else {', '        return {};', '      }', '    }', '    Supports_Condition_Obj cond = parse_supports_condition(/*top_level=*/false);', '    if (cond.isNull()) cond = parse_supports_declaration();', '    if (!lex < exactly <\')\'> >()) error(""unclosed parenthesis in @supports declaration"");', '']}",True,"In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Eval::operator()(Sass::Supports_Operator*) in eval.cpp may cause a Denial of Service (application crash) via a crafted sass input file.",6.5,MEDIUM,1,test,2019-04-04T18:59:24Z,2
CVE-2019-3561,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,facebook/hhvm,"Prevent strrpos and strripos from visiting out-of-bounds memory.

Reviewed By: alexeyt

Differential Revision: D14669668

fbshipit-source-id: 16bb4674bccf83ffd737e60d1fd9fd4a0093f77c",46003b4ab564b2abcd8470035fc324fe36aa8c75,https://github.com/facebook/hhvm/commit/46003b4ab564b2abcd8470035fc324fe36aa8c75,hphp/runtime/base/zend-string.cpp,string_rfind,"int string_rfind(const char *input, int len, const char *s, int s_len,
int pos, bool case_sensitive) {
assertx(input);
assertx(s);
if (!s_len || pos < -len || pos > len) {
return -1;
}
void *ptr;
if (case_sensitive) {
if (pos >= 0) {
ptr = bstrrstr(input + pos, len - pos, s, s_len);
} else {
ptr = bstrrstr(input, len + pos + s_len, s, s_len);
}
} else {
if (pos >= 0) {
ptr = bstrrcasestr(input + pos, len - pos, s, s_len);
} else {
ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);
}
}
if (ptr != nullptr) {
return (int)((const char *)ptr - input);
}
return -1;
}","int string_rfind(const char *VAR_0, int VAR_1, const char *VAR_2, int VAR_3,
int VAR_4, bool VAR_5) {
assertx(VAR_0);
assertx(VAR_2);
if (!VAR_3 || VAR_4 < -VAR_1 || VAR_4 > VAR_1) {
return -1;
}
void *VAR_6;
if (VAR_5) {
if (VAR_4 >= 0) {
VAR_6 = bstrrstr(VAR_0 + VAR_4, VAR_1 - VAR_4, VAR_2, VAR_3);
} else {
VAR_6 = bstrrstr(VAR_0, VAR_1 + VAR_4 + VAR_3, VAR_2, VAR_3);
}
} else {
if (VAR_4 >= 0) {
VAR_6 = bstrrcasestr(VAR_0 + VAR_4, VAR_1 - VAR_4, VAR_2, VAR_3);
} else {
VAR_6 = bstrrcasestr(VAR_0, VAR_1 + VAR_4 + VAR_3, VAR_2, VAR_3);
}
}
if (VAR_6 != nullptr) {
return (int)((const char *)VAR_6 - VAR_0);
}
return -1;
}",facebook/hhvm/46003b4ab564b2abcd8470035fc324fe36aa8c75/zend-string.cpp/vul/before/0.json,"int string_rfind(const char *input, int len, const char *s, int s_len,
                 int pos, bool case_sensitive) {
  assertx(input);
  assertx(s);
  if (!s_len || pos < -len || pos > len) {
    return -1;
  }
  void *ptr;
  if (case_sensitive) {
    if (pos >= 0) {
      ptr = bstrrstr(input + pos, len - pos, s, s_len);
    } else {
      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);
    }
  } else {
    if (pos >= 0) {
      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);
    } else {
      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);
    }
  }
  if (ptr != nullptr) {
    return (int)((const char *)ptr - input);
  }
  return -1;
}","int string_rfind(const char *VAR_0, int VAR_1, const char *VAR_2, int VAR_3,
                 int VAR_4, bool VAR_5) {
  assertx(VAR_0);
  assertx(VAR_2);
  if (!VAR_3 || VAR_4 < -VAR_1 || VAR_4 > VAR_1) {
    return -1;
  }
  void *VAR_6;
  if (VAR_5) {
    if (VAR_4 >= 0) {
      VAR_6 = bstrrstr(VAR_0 + VAR_4, VAR_1 - VAR_4, VAR_2, VAR_3);
    } else {
      VAR_6 = bstrrstr(VAR_0, VAR_1 + std::min(VAR_4 + VAR_3, 0), VAR_2, VAR_3);
    }
  } else {
    if (VAR_4 >= 0) {
      VAR_6 = bstrrcasestr(VAR_0 + VAR_4, VAR_1 - VAR_4, VAR_2, VAR_3);
    } else {
      VAR_6 = bstrrcasestr(VAR_0, VAR_1 + std::min(VAR_4 + VAR_3, 0), VAR_2, VAR_3);
    }
  }
  if (VAR_6 != nullptr) {
    return (int)((const char *)VAR_6 - VAR_0);
  }
  return -1;
}",facebook/hhvm/46003b4ab564b2abcd8470035fc324fe36aa8c75/zend-string.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,13 +10,13 @@
     if (pos >= 0) {
       ptr = bstrrstr(input + pos, len - pos, s, s_len);
     } else {
-      ptr = bstrrstr(input, len + pos + s_len, s, s_len);
+      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);
     }
   } else {
     if (pos >= 0) {
       ptr = bstrrcasestr(input + pos, len - pos, s, s_len);
     } else {
-      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);
+      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);
     }
   }
   if (ptr != nullptr) {","{'deleted_lines': ['      ptr = bstrrstr(input, len + pos + s_len, s, s_len);', '      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);'], 'added_lines': ['      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);', '      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);']}",True,"Insufficient boundary checks for the strrpos and strripos functions allow access to out-of-bounds memory. This affects all supported versions of HHVM (4.0.3, 3.30.4, and 3.27.7 and below).",9.8,CRITICAL,3,test,2019-04-06T15:53:56Z,2
CVE-2018-21017,['CWE-401'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,gpac,prevent dref memleak on invalid input (#1183),d2371b4b204f0a3c0af51ad4e9b491144dd1225c,https://github.com/gpac/gpac/commit/d2371b4b204f0a3c0af51ad4e9b491144dd1225c,src/isomedia/box_code_base.c,dinf_Read,"GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
{
GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);
if (e) {
return e;
}
if (!((GF_DataInformationBox *)s)->dref) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
}
return GF_OK;
}","GF_Err dinf_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_Err VAR_2 = gf_isom_box_array_read(VAR_0, VAR_1, VAR_3);
if (VAR_2) {
return VAR_2;
}
if (!((GF_DataInformationBox *)VAR_0)->dref) {
GF_LOG(VAR_4, VAR_5, (""[iso file] Missing dref box in dinf\n""));
((GF_DataInformationBox *)VAR_0)->dref = (GF_DataReferenceBox *)gf_isom_box_new(VAR_6);
}
return VAR_7;
}",gpac/d2371b4b204f0a3c0af51ad4e9b491144dd1225c/box_code_base.c/vul/before/0.json,"GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);
	if (e) {
		return e;
	}
	if (!((GF_DataInformationBox *)s)->dref) {
		GF_Box* dref;
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
		gf_isom_box_add_for_dump_mode(s, dref);
	}
	return GF_OK;
}","GF_Err dinf_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_Err VAR_2 = gf_isom_box_array_read(VAR_0, VAR_1, VAR_3);
	if (VAR_2) {
		return VAR_2;
	}
	if (!((GF_DataInformationBox *)VAR_0)->dref) {
		GF_Box* VAR_4;
		GF_LOG(VAR_5, VAR_6, (""[iso file] Missing dref box in dinf\n""));
		VAR_4 = gf_isom_box_new(VAR_7);
		((GF_DataInformationBox *)VAR_0)->dref = (GF_DataReferenceBox *)VAR_4;
		gf_isom_box_add_for_dump_mode(VAR_0, VAR_4);
	}
	return VAR_8;
}",gpac/d2371b4b204f0a3c0af51ad4e9b491144dd1225c/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,8 +5,11 @@
 		return e;
 	}
 	if (!((GF_DataInformationBox *)s)->dref) {
+		GF_Box* dref;
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
-		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
+		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
+		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
+		gf_isom_box_add_for_dump_mode(s, dref);
 	}
 	return GF_OK;
 }","{'deleted_lines': ['\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);'], 'added_lines': ['\t\tGF_Box* dref;', '\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);', '\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;', '\t\tgf_isom_box_add_for_dump_mode(s, dref);']}",True,GPAC 0.7.1 has a memory leak in dinf_Read in isomedia/box_code_base.c.,6.5,MEDIUM,1,test,2019-04-11T10:58:25Z,2
CVE-2019-11835,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,DaveGamble/cJSON,"Rewrite cJSON_Minify, fixing buffer overflows, fixes #338

Also first tests for cJSON_Minify.
Thanks @bigric3 for reporting",a43fa56a63920343d0ac8f8e73a6b0447867f459,https://github.com/DaveGamble/cJSON/commit/a43fa56a63920343d0ac8f8e73a6b0447867f459,cJSON.c,cJSON_Minify,"CJSON_PUBLIC(void) cJSON_Minify(char *json)
{
unsigned char *into = (unsigned char*)json;
if (json == NULL)
{
return;
}
while (*json)
{
if (*json == ' ')
{
json++;
}
else if (*json == '\t')
{
json++;
}
else if (*json == '\r')
{
json++;
}
else if (*json=='\n')
{
json++;
}
else if ((*json == '/') && (json[1] == '/'))
{
while (*json && (*json != '\n'))
{
json++;
}
}
else if ((*json == '/') && (json[1] == '*'))
{
while (*json && !((*json == '*') && (json[1] == '/')))
{
json++;
}
json += 2;
}
else if (*json == '\""')
{
*into++ = (unsigned char)*json++;
while (*json && (*json != '\""'))
{
if (*json == '\\')
{
*into++ = (unsigned char)*json++;
}
*into++ = (unsigned char)*json++;
}
*into++ = (unsigned char)*json++;
}
else
{
*into++ = (unsigned char)*json++;
}
}
*into = '\0';
}","VAR_0(void) cJSON_Minify(char *VAR_1)
{
unsigned char *VAR_2 = (unsigned char*)VAR_1;
if (VAR_1 == NULL)
{
return;
}
while (*VAR_1)
{
if (*VAR_1 == ' ')
{
VAR_1++;
}
else if (*VAR_1 == '\t')
{
VAR_1++;
}
else if (*VAR_1 == '\r')
{
VAR_1++;
}
else if (*VAR_1=='\n')
{
VAR_1++;
}
else if ((*VAR_1 == '/') && (VAR_1[1] == '/'))
{
while (*VAR_1 && (*VAR_1 != '\n'))
{
VAR_1++;
}
}
else if ((*VAR_1 == '/') && (VAR_1[1] == '*'))
{
while (*VAR_1 && !((*VAR_1 == '*') && (VAR_1[1] == '/')))
{
VAR_1++;
}
VAR_1 += 2;
}
else if (*VAR_1 == '\""')
{
*VAR_2++ = (unsigned char)*VAR_1++;
while (*VAR_1 && (*VAR_1 != '\""'))
{
if (*VAR_1 == '\\')
{
*VAR_2++ = (unsigned char)*VAR_1++;
}
*VAR_2++ = (unsigned char)*VAR_1++;
}
*VAR_2++ = (unsigned char)*VAR_1++;
}
else
{
*VAR_2++ = (unsigned char)*VAR_1++;
}
}
*VAR_2 = '\0';
}",,"CJSON_PUBLIC(void) cJSON_Minify(char *json)
{
    char *into = json;

    if (json == NULL)
    {
        return;
    }

    while (json[0] != '\0')
    {
        switch (json[0])
        {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                json++;
                break;

            case '/':
                if (json[1] == '/')
                {
                    skip_oneline_comment(&json);
                }
                else if (json[1] == '*')
                {
                    skip_multiline_comment(&json);
                }
                break;

            case '\""':
                minify_string(&json, (char**)&into);
                break;

            default:
                into[0] = json[0];
                json++;
                into++;
        }
    }

    /* and null-terminate. */
    *into = '\0';
}","VAR_0(void) cJSON_Minify(char *VAR_1)
{
    char *VAR_2 = VAR_1;

    if (VAR_1 == NULL)
    {
        return;
    }

    while (VAR_1[0] != '\0')
    {
        switch (VAR_1[0])
        {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                VAR_1++;
                break;

            case '/':
                if (VAR_1[1] == '/')
                {
                    skip_oneline_comment(&VAR_1);
                }
                else if (VAR_1[1] == '*')
                {
                    skip_multiline_comment(&VAR_1);
                }
                break;

            case '\""':
                minify_string(&VAR_1, (char**)&VAR_2);
                break;

            default:
                VAR_2[0] = VAR_1[0];
                VAR_1++;
                VAR_2++;
        }
    }

    /* COMMENT_0 */
    *VAR_2 = '\0';
}",,"--- func_before
+++ func_after
@@ -1,66 +1,42 @@
 CJSON_PUBLIC(void) cJSON_Minify(char *json)
 {
-    unsigned char *into = (unsigned char*)json;
+    char *into = json;
 
     if (json == NULL)
     {
         return;
     }
 
-    while (*json)
+    while (json[0] != '\0')
     {
-        if (*json == ' ')
+        switch (json[0])
         {
-            json++;
-        }
-        else if (*json == '\t')
-        {
-            /* Whitespace characters. */
-            json++;
-        }
-        else if (*json == '\r')
-        {
-            json++;
-        }
-        else if (*json=='\n')
-        {
-            json++;
-        }
-        else if ((*json == '/') && (json[1] == '/'))
-        {
-            /* double-slash comments, to end of line. */
-            while (*json && (*json != '\n'))
-            {
+            case ' ':
+            case '\t':
+            case '\r':
+            case '\n':
                 json++;
-            }
-        }
-        else if ((*json == '/') && (json[1] == '*'))
-        {
-            /* multiline comments. */
-            while (*json && !((*json == '*') && (json[1] == '/')))
-            {
+                break;
+
+            case '/':
+                if (json[1] == '/')
+                {
+                    skip_oneline_comment(&json);
+                }
+                else if (json[1] == '*')
+                {
+                    skip_multiline_comment(&json);
+                }
+                break;
+
+            case '\""':
+                minify_string(&json, (char**)&into);
+                break;
+
+            default:
+                into[0] = json[0];
                 json++;
-            }
-            json += 2;
-        }
-        else if (*json == '\""')
-        {
-            /* string literals, which are \"" sensitive. */
-            *into++ = (unsigned char)*json++;
-            while (*json && (*json != '\""'))
-            {
-                if (*json == '\\')
-                {
-                    *into++ = (unsigned char)*json++;
-                }
-                *into++ = (unsigned char)*json++;
-            }
-            *into++ = (unsigned char)*json++;
-        }
-        else
-        {
-            /* All other characters. */
-            *into++ = (unsigned char)*json++;
+                into++;
         }
     }
 ","{'deleted_lines': ['    unsigned char *into = (unsigned char*)json;', '    while (*json)', ""        if (*json == ' ')"", '            json++;', '        }', ""        else if (*json == '\\t')"", '        {', '            /* Whitespace characters. */', '            json++;', '        }', ""        else if (*json == '\\r')"", '        {', '            json++;', '        }', ""        else if (*json=='\\n')"", '        {', '            json++;', '        }', ""        else if ((*json == '/') && (json[1] == '/'))"", '        {', '            /* double-slash comments, to end of line. */', ""            while (*json && (*json != '\\n'))"", '            {', '            }', '        }', ""        else if ((*json == '/') && (json[1] == '*'))"", '        {', '            /* multiline comments. */', ""            while (*json && !((*json == '*') && (json[1] == '/')))"", '            {', '            }', '            json += 2;', '        }', '        else if (*json == \'\\""\')', '        {', '            /* string literals, which are \\"" sensitive. */', '            *into++ = (unsigned char)*json++;', '            while (*json && (*json != \'\\""\'))', '            {', ""                if (*json == '\\\\')"", '                {', '                    *into++ = (unsigned char)*json++;', '                }', '                *into++ = (unsigned char)*json++;', '            }', '            *into++ = (unsigned char)*json++;', '        }', '        else', '        {', '            /* All other characters. */', '            *into++ = (unsigned char)*json++;'], 'added_lines': ['    char *into = json;', ""    while (json[0] != '\\0')"", '        switch (json[0])', ""            case ' ':"", ""            case '\\t':"", ""            case '\\r':"", ""            case '\\n':"", '                break;', '', ""            case '/':"", ""                if (json[1] == '/')"", '                {', '                    skip_oneline_comment(&json);', '                }', ""                else if (json[1] == '*')"", '                {', '                    skip_multiline_comment(&json);', '                }', '                break;', '', '            case \'\\""\':', '                minify_string(&json, (char**)&into);', '                break;', '', '            default:', '                into[0] = json[0];', '                into++;']}",True,"cJSON before 1.7.11 allows out-of-bounds access, related to multiline comments.",9.8,CRITICAL,3,test,2019-04-14T21:13:41Z,2
CVE-2023-3022,['CWE-843'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1.0,torvalds/linux,"ipv6: Use result arg in fib_lookup_arg consistently

arg.result is sometimes used as fib6_result and sometimes used to
hold the rt6_info. Add rt6_info to fib6_result and make the use
of arg.result consistent through ipv6 rules.

The rt6 entry is filled in for lookups returning a dst_entry, but not
for direct fib_lookups that just want a fib6_info.

Fixes: effda4dd97e8 (""ipv6: Pass fib6_result to fib lookups"")
Signed-off-by: David Ahern <dsahern@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",a65120bae4b7,https://github.com/torvalds/linux/commit/a65120bae4b7425a39c5783aa3d4fc29677eef0e,net/ipv6/fib6_rules.c,fib6_rule_suppress,"static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)
{
struct rt6_info *rt = (struct rt6_info *) arg->result;
struct net_device *dev = NULL;
if (rt->rt6i_idev)
dev = rt->rt6i_idev->dev;
if (rt->rt6i_dst.plen <= rule->suppress_prefixlen)
goto suppress_route;
if (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)
goto suppress_route;
return false;
suppress_route:
ip6_rt_put(rt);
return true;
}","static bool fib6_rule_suppress(struct fib_rule *VAR_0, struct fib_lookup_arg *VAR_1)
{
struct rt6_info *VAR_2 = (struct rt6_info *) VAR_1->result;
struct net_device *VAR_3 = NULL;
if (VAR_2->rt6i_idev)
VAR_3 = VAR_2->rt6i_idev->dev;
if (VAR_2->rt6i_dst.plen <= VAR_0->suppress_prefixlen)
goto suppress_route;
if (VAR_0->suppress_ifgroup != -1 && VAR_3 && VAR_3->group == VAR_0->suppress_ifgroup)
goto suppress_route;
return false;
suppress_route:
ip6_rt_put(VAR_2);
return true;
}",torvalds/linux/a65120bae4b7/fib6_rules.c/vul/before/2.json,"static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)
{
	struct fib6_result *res = arg->result;
	struct rt6_info *rt = res->rt6;
	struct net_device *dev = NULL;

	if (!rt)
		return false;

	if (rt->rt6i_idev)
		dev = rt->rt6i_idev->dev;

	/* do not accept result if the route does
	 * not meet the required prefix length
	 */
	if (rt->rt6i_dst.plen <= rule->suppress_prefixlen)
		goto suppress_route;

	/* do not accept result if the route uses a device
	 * belonging to a forbidden interface group
	 */
	if (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)
		goto suppress_route;

	return false;

suppress_route:
	ip6_rt_put(rt);
	return true;
}","static bool fib6_rule_suppress(struct fib_rule *VAR_0, struct fib_lookup_arg *VAR_1)
{
	struct fib6_result *VAR_2 = VAR_1->result;
	struct rt6_info *VAR_3 = VAR_2->rt6;
	struct net_device *VAR_4 = NULL;

	if (!VAR_3)
		return false;

	if (VAR_3->rt6i_idev)
		VAR_4 = VAR_3->rt6i_idev->dev;

	/* COMMENT_0 */
                                       
    
	if (VAR_3->rt6i_dst.plen <= VAR_0->suppress_prefixlen)
		goto suppress_route;

	/* COMMENT_3 */
                                            
    
	if (VAR_0->suppress_ifgroup != -1 && VAR_4 && VAR_4->group == VAR_0->suppress_ifgroup)
		goto suppress_route;

	return false;

suppress_route:
	ip6_rt_put(VAR_3);
	return true;
}",torvalds/linux/a65120bae4b7/fib6_rules.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,7 +1,11 @@
 static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)
 {
-	struct rt6_info *rt = (struct rt6_info *) arg->result;
+	struct fib6_result *res = arg->result;
+	struct rt6_info *rt = res->rt6;
 	struct net_device *dev = NULL;
+
+	if (!rt)
+		return false;
 
 	if (rt->rt6i_idev)
 		dev = rt->rt6i_idev->dev;","{'deleted_lines': ['\tstruct rt6_info *rt = (struct rt6_info *) arg->result;'], 'added_lines': ['\tstruct fib6_result *res = arg->result;', '\tstruct rt6_info *rt = res->rt6;', '', '\tif (!rt)', '\t\treturn false;']}",True,"A flaw was found in the IPv6 module of the Linux kernel. The arg.result was not used consistently in fib6_rule_lookup, sometimes holding rt6_info and other times fib6_info. This was not accounted for in other parts of the code where rt6_info was expected unconditionally, potentially leading to a kernel panic in fib6_rule_suppress.",5.5,MEDIUM,1,test,2019-04-24T01:05:33Z,2
CVE-2023-3022,['CWE-843'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1.0,torvalds/linux,"ipv6: Use result arg in fib_lookup_arg consistently

arg.result is sometimes used as fib6_result and sometimes used to
hold the rt6_info. Add rt6_info to fib6_result and make the use
of arg.result consistent through ipv6 rules.

The rt6 entry is filled in for lookups returning a dst_entry, but not
for direct fib_lookups that just want a fib6_info.

Fixes: effda4dd97e8 (""ipv6: Pass fib6_result to fib lookups"")
Signed-off-by: David Ahern <dsahern@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",a65120bae4b7,https://github.com/torvalds/linux/commit/a65120bae4b7425a39c5783aa3d4fc29677eef0e,net/ipv6/fib6_rules.c,fib6_rule_lookup,"struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
const struct sk_buff *skb,
int flags, pol_lookup_t lookup)
{
if (net->ipv6.fib6_has_custom_rules) {
struct fib_lookup_arg arg = {
.lookup_ptr = lookup,
.lookup_data = skb,
.flags = FIB_LOOKUP_NOREF,
};
l3mdev_update_flow(net, flowi6_to_flowi(fl6));
fib_rules_lookup(net->ipv6.fib6_rules_ops,
flowi6_to_flowi(fl6), flags, &arg);
if (arg.result)
return arg.result;
} else {
struct rt6_info *rt;
rt = lookup(net, net->ipv6.fib6_local_tbl, fl6, skb, flags);
if (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)
return &rt->dst;
ip6_rt_put(rt);
rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);
if (rt->dst.error != -EAGAIN)
return &rt->dst;
ip6_rt_put(rt);
}
dst_hold(&net->ipv6.ip6_null_entry->dst);
return &net->ipv6.ip6_null_entry->dst;
}","struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *VAR_0,
const struct sk_buff *VAR_1,
int VAR_2, pol_lookup_t VAR_3)
{
if (net->ipv6.fib6_has_custom_rules) {
struct fib_lookup_arg VAR_4 = {
.lookup_ptr = VAR_3,
.lookup_data = VAR_1,
.flags = VAR_5,
};
l3mdev_update_flow(net, flowi6_to_flowi(VAR_0));
fib_rules_lookup(net->ipv6.fib6_rules_ops,
flowi6_to_flowi(VAR_0), VAR_2, &VAR_4);
if (VAR_4.result)
return VAR_4.result;
} else {
struct rt6_info *VAR_6;
VAR_6 = VAR_3(net, net->ipv6.fib6_local_tbl, VAR_0, VAR_1, VAR_2);
if (VAR_6 != net->ipv6.ip6_null_entry && VAR_6->dst.error != -VAR_7)
return &VAR_6->dst;
ip6_rt_put(VAR_6);
VAR_6 = VAR_3(net, net->ipv6.fib6_main_tbl, VAR_0, VAR_1, VAR_2);
if (VAR_6->dst.error != -VAR_7)
return &VAR_6->dst;
ip6_rt_put(VAR_6);
}
dst_hold(&net->ipv6.ip6_null_entry->dst);
return &net->ipv6.ip6_null_entry->dst;
}",torvalds/linux/a65120bae4b7/fib6_rules.c/vul/before/1.json,"struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
				   const struct sk_buff *skb,
				   int flags, pol_lookup_t lookup)
{
	if (net->ipv6.fib6_has_custom_rules) {
		struct fib6_result res = {};
		struct fib_lookup_arg arg = {
			.lookup_ptr = lookup,
			.lookup_data = skb,
			.result = &res,
			.flags = FIB_LOOKUP_NOREF,
		};

		/* update flow if oif or iif point to device enslaved to l3mdev */
		l3mdev_update_flow(net, flowi6_to_flowi(fl6));

		fib_rules_lookup(net->ipv6.fib6_rules_ops,
				 flowi6_to_flowi(fl6), flags, &arg);

		if (res.rt6)
			return &res.rt6->dst;
	} else {
		struct rt6_info *rt;

		rt = lookup(net, net->ipv6.fib6_local_tbl, fl6, skb, flags);
		if (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)
			return &rt->dst;
		ip6_rt_put(rt);
		rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);
		if (rt->dst.error != -EAGAIN)
			return &rt->dst;
		ip6_rt_put(rt);
	}

	dst_hold(&net->ipv6.ip6_null_entry->dst);
	return &net->ipv6.ip6_null_entry->dst;
}","struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *VAR_0,
				   const struct sk_buff *VAR_1,
				   int VAR_2, pol_lookup_t VAR_3)
{
	if (net->ipv6.fib6_has_custom_rules) {
		struct fib6_result VAR_4 = {};
		struct fib_lookup_arg VAR_5 = {
			.lookup_ptr = VAR_3,
			.lookup_data = VAR_1,
			.result = &VAR_4,
			.flags = VAR_6,
		};

		/* COMMENT_0 */
		l3mdev_update_flow(net, flowi6_to_flowi(VAR_0));

		fib_rules_lookup(net->ipv6.fib6_rules_ops,
				 flowi6_to_flowi(VAR_0), VAR_2, &VAR_5);

		if (VAR_4.rt6)
			return &VAR_4.rt6->dst;
	} else {
		struct rt6_info *VAR_7;

		VAR_7 = VAR_3(net, net->ipv6.fib6_local_tbl, VAR_0, VAR_1, VAR_2);
		if (VAR_7 != net->ipv6.ip6_null_entry && VAR_7->dst.error != -VAR_8)
			return &VAR_7->dst;
		ip6_rt_put(VAR_7);
		VAR_7 = VAR_3(net, net->ipv6.fib6_main_tbl, VAR_0, VAR_1, VAR_2);
		if (VAR_7->dst.error != -VAR_8)
			return &VAR_7->dst;
		ip6_rt_put(VAR_7);
	}

	dst_hold(&net->ipv6.ip6_null_entry->dst);
	return &net->ipv6.ip6_null_entry->dst;
}",torvalds/linux/a65120bae4b7/fib6_rules.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,9 +3,11 @@
 				   int flags, pol_lookup_t lookup)
 {
 	if (net->ipv6.fib6_has_custom_rules) {
+		struct fib6_result res = {};
 		struct fib_lookup_arg arg = {
 			.lookup_ptr = lookup,
 			.lookup_data = skb,
+			.result = &res,
 			.flags = FIB_LOOKUP_NOREF,
 		};
 
@@ -15,8 +17,8 @@
 		fib_rules_lookup(net->ipv6.fib6_rules_ops,
 				 flowi6_to_flowi(fl6), flags, &arg);
 
-		if (arg.result)
-			return arg.result;
+		if (res.rt6)
+			return &res.rt6->dst;
 	} else {
 		struct rt6_info *rt;
 ","{'deleted_lines': ['\t\tif (arg.result)', '\t\t\treturn arg.result;'], 'added_lines': ['\t\tstruct fib6_result res = {};', '\t\t\t.result = &res,', '\t\tif (res.rt6)', '\t\t\treturn &res.rt6->dst;']}",True,"A flaw was found in the IPv6 module of the Linux kernel. The arg.result was not used consistently in fib6_rule_lookup, sometimes holding rt6_info and other times fib6_info. This was not accounted for in other parts of the code where rt6_info was expected unconditionally, potentially leading to a kernel panic in fib6_rule_suppress.",5.5,MEDIUM,1,test,2019-04-24T01:05:33Z,2
CVE-2023-3022,['CWE-843'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1.0,torvalds/linux,"ipv6: Use result arg in fib_lookup_arg consistently

arg.result is sometimes used as fib6_result and sometimes used to
hold the rt6_info. Add rt6_info to fib6_result and make the use
of arg.result consistent through ipv6 rules.

The rt6 entry is filled in for lookups returning a dst_entry, but not
for direct fib_lookups that just want a fib6_info.

Fixes: effda4dd97e8 (""ipv6: Pass fib6_result to fib lookups"")
Signed-off-by: David Ahern <dsahern@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",a65120bae4b7,https://github.com/torvalds/linux/commit/a65120bae4b7425a39c5783aa3d4fc29677eef0e,net/ipv6/fib6_rules.c,__fib6_rule_action,"static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,
int flags, struct fib_lookup_arg *arg)
{
struct flowi6 *flp6 = &flp->u.ip6;
struct rt6_info *rt = NULL;
struct fib6_table *table;
struct net *net = rule->fr_net;
pol_lookup_t lookup = arg->lookup_ptr;
int err = 0;
u32 tb_id;
switch (rule->action) {
case FR_ACT_TO_TBL:
break;
case FR_ACT_UNREACHABLE:
err = -ENETUNREACH;
rt = net->ipv6.ip6_null_entry;
goto discard_pkt;
default:
case FR_ACT_BLACKHOLE:
err = -EINVAL;
rt = net->ipv6.ip6_blk_hole_entry;
goto discard_pkt;
case FR_ACT_PROHIBIT:
err = -EACCES;
rt = net->ipv6.ip6_prohibit_entry;
goto discard_pkt;
}
tb_id = fib_rule_get_table(rule, arg);
table = fib6_get_table(net, tb_id);
if (!table) {
err = -EAGAIN;
goto out;
}
rt = lookup(net, table, flp6, arg->lookup_data, flags);
if (rt != net->ipv6.ip6_null_entry) {
err = fib6_rule_saddr(net, rule, flags, flp6,
ip6_dst_idev(&rt->dst)->dev);
if (err == -EAGAIN)
goto again;
err = rt->dst.error;
if (err != -EAGAIN)
goto out;
}
again:
ip6_rt_put(rt);
err = -EAGAIN;
rt = NULL;
goto out;
discard_pkt:
dst_hold(&rt->dst);
out:
arg->result = rt;
return err;
}","static int __fib6_rule_action(struct fib_rule *VAR_0, struct flowi *VAR_1,
int VAR_2, struct fib_lookup_arg *VAR_3)
{
struct flowi6 *VAR_4 = &VAR_1->u.ip6;
struct rt6_info *VAR_5 = NULL;
struct fib6_table *VAR_6;
struct net *net = VAR_0->fr_net;
pol_lookup_t VAR_7 = VAR_3->lookup_ptr;
int VAR_8 = 0;
u32 VAR_9;
switch (VAR_0->action) {
case VAR_10:
break;
case VAR_11:
VAR_8 = -VAR_12;
VAR_5 = net->ipv6.ip6_null_entry;
goto discard_pkt;
default:
case VAR_13:
VAR_8 = -VAR_14;
VAR_5 = net->ipv6.ip6_blk_hole_entry;
goto discard_pkt;
case VAR_15:
VAR_8 = -VAR_16;
VAR_5 = net->ipv6.ip6_prohibit_entry;
goto discard_pkt;
}
VAR_9 = fib_rule_get_table(VAR_0, VAR_3);
VAR_6 = fib6_get_table(net, VAR_9);
if (!VAR_6) {
VAR_8 = -VAR_17;
goto out;
}
VAR_5 = VAR_7(net, VAR_6, VAR_4, VAR_3->lookup_data, VAR_2);
if (VAR_5 != net->ipv6.ip6_null_entry) {
VAR_8 = fib6_rule_saddr(net, VAR_0, VAR_2, VAR_4,
ip6_dst_idev(&VAR_5->dst)->dev);
if (VAR_8 == -VAR_17)
goto again;
VAR_8 = VAR_5->dst.error;
if (VAR_8 != -VAR_17)
goto out;
}
again:
ip6_rt_put(VAR_5);
VAR_8 = -VAR_17;
VAR_5 = NULL;
goto out;
discard_pkt:
dst_hold(&VAR_5->dst);
out:
VAR_3->result = VAR_5;
return VAR_8;
}",torvalds/linux/a65120bae4b7/fib6_rules.c/vul/before/0.json,"static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,
			      int flags, struct fib_lookup_arg *arg)
{
	struct fib6_result *res = arg->result;
	struct flowi6 *flp6 = &flp->u.ip6;
	struct rt6_info *rt = NULL;
	struct fib6_table *table;
	struct net *net = rule->fr_net;
	pol_lookup_t lookup = arg->lookup_ptr;
	int err = 0;
	u32 tb_id;

	switch (rule->action) {
	case FR_ACT_TO_TBL:
		break;
	case FR_ACT_UNREACHABLE:
		err = -ENETUNREACH;
		rt = net->ipv6.ip6_null_entry;
		goto discard_pkt;
	default:
	case FR_ACT_BLACKHOLE:
		err = -EINVAL;
		rt = net->ipv6.ip6_blk_hole_entry;
		goto discard_pkt;
	case FR_ACT_PROHIBIT:
		err = -EACCES;
		rt = net->ipv6.ip6_prohibit_entry;
		goto discard_pkt;
	}

	tb_id = fib_rule_get_table(rule, arg);
	table = fib6_get_table(net, tb_id);
	if (!table) {
		err = -EAGAIN;
		goto out;
	}

	rt = lookup(net, table, flp6, arg->lookup_data, flags);
	if (rt != net->ipv6.ip6_null_entry) {
		err = fib6_rule_saddr(net, rule, flags, flp6,
				      ip6_dst_idev(&rt->dst)->dev);

		if (err == -EAGAIN)
			goto again;

		err = rt->dst.error;
		if (err != -EAGAIN)
			goto out;
	}
again:
	ip6_rt_put(rt);
	err = -EAGAIN;
	rt = NULL;
	goto out;

discard_pkt:
	dst_hold(&rt->dst);
out:
	res->rt6 = rt;
	return err;
}","static int __fib6_rule_action(struct fib_rule *VAR_0, struct flowi *VAR_1,
			      int VAR_2, struct fib_lookup_arg *VAR_3)
{
	struct fib6_result *VAR_4 = VAR_3->result;
	struct flowi6 *VAR_5 = &VAR_1->u.ip6;
	struct rt6_info *VAR_6 = NULL;
	struct fib6_table *VAR_7;
	struct net *net = VAR_0->fr_net;
	pol_lookup_t VAR_8 = VAR_3->lookup_ptr;
	int VAR_9 = 0;
	u32 VAR_10;

	switch (VAR_0->action) {
	case VAR_11:
		break;
	case VAR_12:
		VAR_9 = -VAR_13;
		VAR_6 = net->ipv6.ip6_null_entry;
		goto discard_pkt;
	default:
	case VAR_14:
		VAR_9 = -VAR_15;
		VAR_6 = net->ipv6.ip6_blk_hole_entry;
		goto discard_pkt;
	case VAR_16:
		VAR_9 = -VAR_17;
		VAR_6 = net->ipv6.ip6_prohibit_entry;
		goto discard_pkt;
	}

	VAR_10 = fib_rule_get_table(VAR_0, VAR_3);
	VAR_7 = fib6_get_table(net, VAR_10);
	if (!VAR_7) {
		VAR_9 = -VAR_18;
		goto out;
	}

	VAR_6 = VAR_8(net, VAR_7, VAR_5, VAR_3->lookup_data, VAR_2);
	if (VAR_6 != net->ipv6.ip6_null_entry) {
		VAR_9 = fib6_rule_saddr(net, VAR_0, VAR_2, VAR_5,
				      ip6_dst_idev(&VAR_6->dst)->dev);

		if (VAR_9 == -VAR_18)
			goto again;

		VAR_9 = VAR_6->dst.error;
		if (VAR_9 != -VAR_18)
			goto out;
	}
again:
	ip6_rt_put(VAR_6);
	VAR_9 = -VAR_18;
	VAR_6 = NULL;
	goto out;

discard_pkt:
	dst_hold(&VAR_6->dst);
out:
	VAR_4->rt6 = VAR_6;
	return VAR_9;
}",torvalds/linux/a65120bae4b7/fib6_rules.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,
 			      int flags, struct fib_lookup_arg *arg)
 {
+	struct fib6_result *res = arg->result;
 	struct flowi6 *flp6 = &flp->u.ip6;
 	struct rt6_info *rt = NULL;
 	struct fib6_table *table;
@@ -55,6 +56,6 @@
 discard_pkt:
 	dst_hold(&rt->dst);
 out:
-	arg->result = rt;
+	res->rt6 = rt;
 	return err;
 }","{'deleted_lines': ['\targ->result = rt;'], 'added_lines': ['\tstruct fib6_result *res = arg->result;', '\tres->rt6 = rt;']}",True,"A flaw was found in the IPv6 module of the Linux kernel. The arg.result was not used consistently in fib6_rule_lookup, sometimes holding rt6_info and other times fib6_info. This was not accounted for in other parts of the code where rt6_info was expected unconditionally, potentially leading to a kernel panic in fib6_rule_suppress.",5.5,MEDIUM,1,test,2019-04-24T01:05:33Z,2
CVE-2019-15140,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1554,f7206618d27c2e69d977abf40e3035a33e5f6be0,https://github.com/ImageMagick/ImageMagick/commit/f7206618d27c2e69d977abf40e3035a33e5f6be0,coders/mat.c,ReadMATImageV4,"static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
typedef struct {
unsigned char Type[4];
unsigned int nRows;
unsigned int nCols;
unsigned int imagf;
unsigned int nameLen;
} MAT4_HDR;
long
ldblk;
EndianType
endian;
Image
*rotated_image;
MagickBooleanType
status;
MAT4_HDR
HDR;
QuantumInfo
*quantum_info;
QuantumFormatType
format_type;
register ssize_t
i;
ssize_t
count,
y;
unsigned char
*pixels;
unsigned int
depth;
quantum_info=(QuantumInfo *) NULL;
(void) SeekBlob(image,0,SEEK_SET);
status=MagickTrue;
while (EOFBlob(image) == MagickFalse)
{
ldblk=ReadBlobLSBLong(image);
if ((ldblk > 9999) || (ldblk < 0))
break;
HDR.Type[3]=ldblk % 10; ldblk /= 10;  
HDR.Type[2]=ldblk % 10; ldblk /= 10;  
HDR.Type[1]=ldblk % 10; ldblk /= 10;  
HDR.Type[0]=ldblk;        
if (HDR.Type[3] != 0)
break;  
if (HDR.Type[2] != 0)
break;  
if (HDR.Type[0] == 0)
{
HDR.nRows=ReadBlobLSBLong(image);
HDR.nCols=ReadBlobLSBLong(image);
HDR.imagf=ReadBlobLSBLong(image);
HDR.nameLen=ReadBlobLSBLong(image);
endian=LSBEndian;
}
else
{
HDR.nRows=ReadBlobMSBLong(image);
HDR.nCols=ReadBlobMSBLong(image);
HDR.imagf=ReadBlobMSBLong(image);
HDR.nameLen=ReadBlobMSBLong(image);
endian=MSBEndian;
}
if ((HDR.imagf != 0) && (HDR.imagf != 1))
break;
if (HDR.nameLen > 0xFFFF)
return(DestroyImageList(image));
for (i=0; i < (ssize_t) HDR.nameLen; i++)
{
int
byte;
byte=ReadBlobByte(image);
if (byte == EOF)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
}
image->columns=(size_t) HDR.nRows;
image->rows=(size_t) HDR.nCols;
if ((image->columns == 0) || (image->rows == 0))
return(DestroyImageList(image));
if (image_info->ping != MagickFalse)
{
Swap(image->columns,image->rows);
if(HDR.imagf==1) ldblk *= 2;
SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);
if ((image->columns == 0) || (image->rows == 0))
return(image->previous == (Image *) NULL ? DestroyImageList(image)
: image);
goto skip_reading_current;
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
(void) SetImageBackgroundColor(image,exception);
(void) SetImageColorspace(image,GRAYColorspace,exception);
quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
return(DestroyImageList(image));
switch(HDR.Type[1])
{
case 0:
format_type=FloatingPointQuantumFormat;
depth=64;
break;
case 1:
format_type=FloatingPointQuantumFormat;
depth=32;
break;
case 2:
format_type=UnsignedQuantumFormat;
depth=16;
break;
case 3:
format_type=SignedQuantumFormat;
depth=16;
break;
case 4:
format_type=UnsignedQuantumFormat;
depth=8;
break;
default:
format_type=UnsignedQuantumFormat;
depth=8;
break;
}
image->depth=depth;
if (HDR.Type[0] != 0)
SetQuantumEndian(image,quantum_info,MSBEndian);
status=SetQuantumFormat(image,quantum_info,format_type);
status=SetQuantumDepth(image,quantum_info,depth);
status=SetQuantumEndian(image,quantum_info,endian);
SetQuantumScale(quantum_info,1.0);
pixels=(unsigned char *) GetQuantumPixels(quantum_info);
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;
count=ReadBlob(image,depth/8*image->columns,(char *) pixels);
if (count == -1)
break;
q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
(void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
GrayQuantum,pixels,exception);
if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))
FixSignedValues(image,q,(int) image->columns);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
if (HDR.imagf == 1)
for (y=0; y < (ssize_t) image->rows; y++)
{
count=ReadBlob(image,depth/8*image->columns,(char *) pixels);
if (count == -1)
break;
if (HDR.Type[1] == 0)
InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);
else
InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);
}
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
rotated_image=RotateImage(image,90.0,exception);
if (rotated_image != (Image *) NULL)
{
rotated_image->page.x=0;
rotated_image->page.y=0;
rotated_image->colors = image->colors;
DestroyBlob(rotated_image);
rotated_image->blob=ReferenceBlob(image->blob);
AppendImageToList(&image,rotated_image);
DeleteImageFromList(&image);
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
skip_reading_current:
AcquireNextImage(image_info,image,exception);
if (GetNextImageInList(image) == (Image *) NULL)
{
status=MagickFalse;
break;
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
(void) CloseBlob(image);
if (status == MagickFalse)
return(DestroyImageList(image));
return(GetFirstImageInList(image));
}","static Image *ReadMATImageV4(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
typedef struct {
unsigned char Type[4];
unsigned int nRows;
unsigned int nCols;
unsigned int imagf;
unsigned int nameLen;
} MAT4_HDR;
long
VAR_3;
EndianType
VAR_4;
Image
*VAR_5;
MagickBooleanType
VAR_6;
MAT4_HDR
VAR_7;
QuantumInfo
*VAR_8;
QuantumFormatType
VAR_9;
register ssize_t
VAR_10;
ssize_t
VAR_11,
VAR_12;
unsigned char
*VAR_13;
unsigned int
VAR_14;
VAR_8=(QuantumInfo *) NULL;
(void) SeekBlob(VAR_1,0,VAR_15);
VAR_6=VAR_16;
while (EOFBlob(VAR_1) == VAR_17)
{
VAR_3=ReadBlobLSBLong(VAR_1);
if ((VAR_3 > 9999) || (VAR_3 < 0))
break;
VAR_7.Type[3]=VAR_3 % 10; VAR_3 /= 10;  
VAR_7.Type[2]=VAR_3 % 10; VAR_3 /= 10;  
VAR_7.Type[1]=VAR_3 % 10; VAR_3 /= 10;  
VAR_7.Type[0]=VAR_3;        
if (VAR_7.Type[3] != 0)
break;  
if (VAR_7.Type[2] != 0)
break;  
if (VAR_7.Type[0] == 0)
{
VAR_7.nRows=ReadBlobLSBLong(VAR_1);
VAR_7.nCols=ReadBlobLSBLong(VAR_1);
VAR_7.imagf=ReadBlobLSBLong(VAR_1);
VAR_7.nameLen=ReadBlobLSBLong(VAR_1);
VAR_4=VAR_18;
}
else
{
VAR_7.nRows=ReadBlobMSBLong(VAR_1);
VAR_7.nCols=ReadBlobMSBLong(VAR_1);
VAR_7.imagf=ReadBlobMSBLong(VAR_1);
VAR_7.nameLen=ReadBlobMSBLong(VAR_1);
VAR_4=VAR_19;
}
if ((VAR_7.imagf != 0) && (VAR_7.imagf != 1))
break;
if (VAR_7.nameLen > 0xFFFF)
return(DestroyImageList(VAR_1));
for (VAR_10=0; VAR_10 < (ssize_t) VAR_7.nameLen; VAR_10++)
{
int
VAR_20;
VAR_20=ReadBlobByte(VAR_1);
if (VAR_20 == VAR_21)
{
ThrowFileException(VAR_2,VAR_22,""UnexpectedEndOfFile"",
VAR_1->filename);
break;
}
}
VAR_1->columns=(size_t) VAR_7.nRows;
VAR_1->rows=(size_t) VAR_7.nCols;
if ((VAR_1->columns == 0) || (VAR_1->rows == 0))
return(DestroyImageList(VAR_1));
if (VAR_0->ping != VAR_17)
{
Swap(VAR_1->columns,VAR_1->rows);
if(VAR_7.imagf==1) VAR_3 *= 2;
SeekBlob(VAR_1, VAR_7.nCols*VAR_3, VAR_23);
if ((VAR_1->columns == 0) || (VAR_1->rows == 0))
return(VAR_1->previous == (Image *) NULL ? DestroyImageList(VAR_1)
: VAR_1);
goto skip_reading_current;
}
VAR_6=SetImageExtent(VAR_1,VAR_1->columns,VAR_1->rows,VAR_2);
if (VAR_6 == VAR_17)
return(DestroyImageList(VAR_1));
(void) SetImageBackgroundColor(VAR_1,VAR_2);
(void) SetImageColorspace(VAR_1,VAR_24,VAR_2);
VAR_8=AcquireQuantumInfo(VAR_0,VAR_1);
if (VAR_8 == (QuantumInfo *) NULL)
return(DestroyImageList(VAR_1));
switch(VAR_7.Type[1])
{
case 0:
VAR_9=VAR_25;
VAR_14=64;
break;
case 1:
VAR_9=VAR_25;
VAR_14=32;
break;
case 2:
VAR_9=VAR_26;
VAR_14=16;
break;
case 3:
VAR_9=VAR_27;
VAR_14=16;
break;
case 4:
VAR_9=VAR_26;
VAR_14=8;
break;
default:
VAR_9=VAR_26;
VAR_14=8;
break;
}
VAR_1->depth=VAR_14;
if (VAR_7.Type[0] != 0)
SetQuantumEndian(VAR_1,VAR_8,VAR_19);
VAR_6=SetQuantumFormat(VAR_1,VAR_8,VAR_9);
VAR_6=SetQuantumDepth(VAR_1,VAR_8,VAR_14);
VAR_6=SetQuantumEndian(VAR_1,VAR_8,VAR_4);
SetQuantumScale(VAR_8,1.0);
VAR_13=(unsigned char *) GetQuantumPixels(VAR_8);
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->rows; VAR_12++)
{
register Quantum
*magick_restrict VAR_28;
VAR_11=ReadBlob(VAR_1,VAR_14/8*VAR_1->columns,(char *) VAR_13);
if (VAR_11 == -1)
break;
VAR_28=QueueAuthenticPixels(VAR_1,0,VAR_1->rows-VAR_12-1,VAR_1->columns,1,
VAR_2);
if (VAR_28 == (Quantum *) NULL)
break;
(void) ImportQuantumPixels(VAR_1,(CacheView *) NULL,VAR_8,
VAR_29,VAR_13,VAR_2);
if ((VAR_7.Type[1] == 2) || (VAR_7.Type[1] == 3))
FixSignedValues(VAR_1,VAR_28,(int) VAR_1->columns);
if (SyncAuthenticPixels(VAR_1,VAR_2) == VAR_17)
break;
if (VAR_1->previous == (Image *) NULL)
{
VAR_6=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_12,
VAR_1->rows);
if (VAR_6 == VAR_17)
break;
}
}
if (VAR_7.imagf == 1)
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->rows; VAR_12++)
{
VAR_11=ReadBlob(VAR_1,VAR_14/8*VAR_1->columns,(char *) VAR_13);
if (VAR_11 == -1)
break;
if (VAR_7.Type[1] == 0)
InsertComplexDoubleRow(VAR_1,(double *) VAR_13,VAR_12,0,0,VAR_2);
else
InsertComplexFloatRow(VAR_1,(float *) VAR_13,VAR_12,0,0,VAR_2);
}
if (VAR_8 != (QuantumInfo *) NULL)
VAR_8=DestroyQuantumInfo(VAR_8);
if (EOFBlob(VAR_1) != VAR_17)
{
ThrowFileException(VAR_2,VAR_22,""UnexpectedEndOfFile"",
VAR_1->filename);
break;
}
VAR_5=RotateImage(VAR_1,90.0,VAR_2);
if (VAR_5 != (Image *) NULL)
{
VAR_5->page.x=0;
VAR_5->page.y=0;
VAR_5->colors = VAR_1->colors;
DestroyBlob(VAR_5);
VAR_5->blob=ReferenceBlob(VAR_1->blob);
AppendImageToList(&VAR_1,VAR_5);
DeleteImageFromList(&VAR_1);
}
if (VAR_0->number_scenes != 0)
if (VAR_1->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
skip_reading_current:
AcquireNextImage(VAR_0,VAR_1,VAR_2);
if (GetNextImageInList(VAR_1) == (Image *) NULL)
{
VAR_6=VAR_17;
break;
}
VAR_1=SyncNextImageInList(VAR_1);
VAR_6=SetImageProgress(VAR_1,VAR_31,TellBlob(VAR_1),
GetBlobSize(VAR_1));
if (VAR_6 == VAR_17)
break;
}
(void) CloseBlob(VAR_1);
if (VAR_6 == VAR_17)
return(DestroyImageList(VAR_1));
return(GetFirstImageInList(VAR_1));
}",ImageMagick/f7206618d27c2e69d977abf40e3035a33e5f6be0/mat.c/vul/before/0.json,"static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  typedef struct {
    unsigned char Type[4];
    unsigned int nRows;
    unsigned int nCols;
    unsigned int imagf;
    unsigned int nameLen;
  } MAT4_HDR;

  long
    ldblk;

  EndianType
    endian;

  Image
    *rotated_image;

  MagickBooleanType
    status;

  MAT4_HDR
    HDR;

  QuantumInfo
    *quantum_info;

  QuantumFormatType
    format_type;

  register ssize_t
    i;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned int
    depth;

  quantum_info=(QuantumInfo *) NULL;
  (void) SeekBlob(image,0,SEEK_SET);
  status=MagickTrue;
  while (EOFBlob(image) == MagickFalse)
  {
    /*
     Object parser loop.
    */
    ldblk=ReadBlobLSBLong(image);
    if(EOFBlob(image)) break;
    if ((ldblk > 9999) || (ldblk < 0))
      break;
    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */
    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */
    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */
    HDR.Type[0]=ldblk;        /* M digit */
    if (HDR.Type[3] != 0)
      break;  /* Data format */
    if (HDR.Type[2] != 0)
      break;  /* Always 0 */
    if (HDR.Type[0] == 0)
      {
        HDR.nRows=ReadBlobLSBLong(image);
        HDR.nCols=ReadBlobLSBLong(image);
        HDR.imagf=ReadBlobLSBLong(image);
        HDR.nameLen=ReadBlobLSBLong(image);
        endian=LSBEndian;
      }
    else
      {
        HDR.nRows=ReadBlobMSBLong(image);
        HDR.nCols=ReadBlobMSBLong(image);
        HDR.imagf=ReadBlobMSBLong(image);
        HDR.nameLen=ReadBlobMSBLong(image);
        endian=MSBEndian;
      }
    if ((HDR.imagf != 0) && (HDR.imagf != 1))
      break;
    if (HDR.nameLen > 0xFFFF)
      return(DestroyImageList(image));
    for (i=0; i < (ssize_t) HDR.nameLen; i++)
    {
      int
        byte;

      /*
        Skip matrix name.
      */
      byte=ReadBlobByte(image);
      if (byte == EOF)
        {
          ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
            image->filename);
          break;
        }
    }
    image->columns=(size_t) HDR.nRows;
    image->rows=(size_t) HDR.nCols;
    if ((image->columns == 0) || (image->rows == 0))
      return(DestroyImageList(image));
    if (image_info->ping != MagickFalse)
      {
        Swap(image->columns,image->rows);
        if(HDR.imagf==1) ldblk *= 2;
        SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);
        if ((image->columns == 0) || (image->rows == 0))
          return(image->previous == (Image *) NULL ? DestroyImageList(image)
            : image);
        goto skip_reading_current;
      }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    (void) SetImageBackgroundColor(image,exception);
    (void) SetImageColorspace(image,GRAYColorspace,exception);
    quantum_info=AcquireQuantumInfo(image_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      return(DestroyImageList(image));
    switch(HDR.Type[1])
    {
      case 0:
        format_type=FloatingPointQuantumFormat;
        depth=64;
        break;
      case 1:
        format_type=FloatingPointQuantumFormat;
        depth=32;
        break;
      case 2:
        format_type=UnsignedQuantumFormat;
        depth=16;
        break;
      case 3:
        format_type=SignedQuantumFormat;
        depth=16;
        break;
      case 4:
        format_type=UnsignedQuantumFormat;
        depth=8;
        break;
      default:
        format_type=UnsignedQuantumFormat;
        depth=8;
        break;
    }
    image->depth=depth;
    if (HDR.Type[0] != 0)
      SetQuantumEndian(image,quantum_info,MSBEndian);
    status=SetQuantumFormat(image,quantum_info,format_type);
    status=SetQuantumDepth(image,quantum_info,depth);
    status=SetQuantumEndian(image,quantum_info,endian);
    SetQuantumScale(quantum_info,1.0);
    pixels=(unsigned char *) GetQuantumPixels(quantum_info);
    for (y=0; y < (ssize_t) image->rows; y++)
    {
      register Quantum
        *magick_restrict q;

      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);
      if (count == -1)
        break;
      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,
        exception);
      if (q == (Quantum *) NULL)
        break;
      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
        GrayQuantum,pixels,exception);
      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))
        FixSignedValues(image,q,(int) image->columns);
      if (SyncAuthenticPixels(image,exception) == MagickFalse)
        break;
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
            image->rows);
          if (status == MagickFalse)
            break;
        }
    }
    if (HDR.imagf == 1)
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        /*
          Read complex pixels.
        */
        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);
        if (count == -1)
          break;
        if (HDR.Type[1] == 0)
          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);
        else
          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);
      }
    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    rotated_image=RotateImage(image,90.0,exception);
    if (rotated_image != (Image *) NULL)
      {
        rotated_image->page.x=0;
        rotated_image->page.y=0;
        rotated_image->colors = image->colors;
        DestroyBlob(rotated_image);
        rotated_image->blob=ReferenceBlob(image->blob);
        AppendImageToList(&image,rotated_image);
        DeleteImageFromList(&image);
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    /*
      Allocate next image structure.
    */
skip_reading_current:
    AcquireNextImage(image_info,image,exception);
    if (GetNextImageInList(image) == (Image *) NULL)
      {
        status=MagickFalse;
        break;
      }
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
      GetBlobSize(image));
    if (status == MagickFalse)
      break;
  }
  (void) CloseBlob(image);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  return(GetFirstImageInList(image));
}","static Image *ReadMATImageV4(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  typedef struct {
    unsigned char Type[4];
    unsigned int nRows;
    unsigned int nCols;
    unsigned int imagf;
    unsigned int nameLen;
  } MAT4_HDR;

  long
    VAR_3;

  EndianType
    VAR_4;

  Image
    *VAR_5;

  MagickBooleanType
    VAR_6;

  MAT4_HDR
    VAR_7;

  QuantumInfo
    *VAR_8;

  QuantumFormatType
    VAR_9;

  register ssize_t
    VAR_10;

  ssize_t
    VAR_11,
    VAR_12;

  unsigned char
    *VAR_13;

  unsigned int
    VAR_14;

  VAR_8=(QuantumInfo *) NULL;
  (void) SeekBlob(VAR_1,0,VAR_15);
  VAR_6=VAR_16;
  while (EOFBlob(VAR_1) == VAR_17)
  {
    /* COMMENT_0 */
                        
      
    VAR_3=ReadBlobLSBLong(VAR_1);
    if(EOFBlob(VAR_1)) break;
    if ((VAR_3 > 9999) || (VAR_3 < 0))
      break;
    VAR_7.Type[3]=VAR_3 % 10; VAR_3 /= 10;  /* COMMENT_3 */
    VAR_7.Type[2]=VAR_3 % 10; VAR_3 /= 10;  /* COMMENT_4 */
    VAR_7.Type[1]=VAR_3 % 10; VAR_3 /= 10;  /* COMMENT_5 */
    VAR_7.Type[0]=VAR_3;        /* COMMENT_6 */
    if (VAR_7.Type[3] != 0)
      break;  /* COMMENT_7 */
    if (VAR_7.Type[2] != 0)
      break;  /* COMMENT_8 */
    if (VAR_7.Type[0] == 0)
      {
        VAR_7.nRows=ReadBlobLSBLong(VAR_1);
        VAR_7.nCols=ReadBlobLSBLong(VAR_1);
        VAR_7.imagf=ReadBlobLSBLong(VAR_1);
        VAR_7.nameLen=ReadBlobLSBLong(VAR_1);
        VAR_4=VAR_18;
      }
    else
      {
        VAR_7.nRows=ReadBlobMSBLong(VAR_1);
        VAR_7.nCols=ReadBlobMSBLong(VAR_1);
        VAR_7.imagf=ReadBlobMSBLong(VAR_1);
        VAR_7.nameLen=ReadBlobMSBLong(VAR_1);
        VAR_4=VAR_19;
      }
    if ((VAR_7.imagf != 0) && (VAR_7.imagf != 1))
      break;
    if (VAR_7.nameLen > 0xFFFF)
      return(DestroyImageList(VAR_1));
    for (VAR_10=0; VAR_10 < (ssize_t) VAR_7.nameLen; VAR_10++)
    {
      int
        VAR_20;

      /* COMMENT_9 */
                         
        
      VAR_20=ReadBlobByte(VAR_1);
      if (VAR_20 == VAR_21)
        {
          ThrowFileException(VAR_2,VAR_22,""UnexpectedEndOfFile"",
            VAR_1->filename);
          break;
        }
    }
    VAR_1->columns=(size_t) VAR_7.nRows;
    VAR_1->rows=(size_t) VAR_7.nCols;
    if ((VAR_1->columns == 0) || (VAR_1->rows == 0))
      return(DestroyImageList(VAR_1));
    if (VAR_0->ping != VAR_17)
      {
        Swap(VAR_1->columns,VAR_1->rows);
        if(VAR_7.imagf==1) VAR_3 *= 2;
        SeekBlob(VAR_1, VAR_7.nCols*VAR_3, VAR_23);
        if ((VAR_1->columns == 0) || (VAR_1->rows == 0))
          return(VAR_1->previous == (Image *) NULL ? DestroyImageList(VAR_1)
            : VAR_1);
        goto skip_reading_current;
      }
    VAR_6=SetImageExtent(VAR_1,VAR_1->columns,VAR_1->rows,VAR_2);
    if (VAR_6 == VAR_17)
      return(DestroyImageList(VAR_1));
    (void) SetImageBackgroundColor(VAR_1,VAR_2);
    (void) SetImageColorspace(VAR_1,VAR_24,VAR_2);
    VAR_8=AcquireQuantumInfo(VAR_0,VAR_1);
    if (VAR_8 == (QuantumInfo *) NULL)
      return(DestroyImageList(VAR_1));
    switch(VAR_7.Type[1])
    {
      case 0:
        VAR_9=VAR_25;
        VAR_14=64;
        break;
      case 1:
        VAR_9=VAR_25;
        VAR_14=32;
        break;
      case 2:
        VAR_9=VAR_26;
        VAR_14=16;
        break;
      case 3:
        VAR_9=VAR_27;
        VAR_14=16;
        break;
      case 4:
        VAR_9=VAR_26;
        VAR_14=8;
        break;
      default:
        VAR_9=VAR_26;
        VAR_14=8;
        break;
    }
    VAR_1->depth=VAR_14;
    if (VAR_7.Type[0] != 0)
      SetQuantumEndian(VAR_1,VAR_8,VAR_19);
    VAR_6=SetQuantumFormat(VAR_1,VAR_8,VAR_9);
    VAR_6=SetQuantumDepth(VAR_1,VAR_8,VAR_14);
    VAR_6=SetQuantumEndian(VAR_1,VAR_8,VAR_4);
    SetQuantumScale(VAR_8,1.0);
    VAR_13=(unsigned char *) GetQuantumPixels(VAR_8);
    for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->rows; VAR_12++)
    {
      register Quantum
        *magick_restrict VAR_28;

      VAR_11=ReadBlob(VAR_1,VAR_14/8*VAR_1->columns,(char *) VAR_13);
      if (VAR_11 == -1)
        break;
      VAR_28=QueueAuthenticPixels(VAR_1,0,VAR_1->rows-VAR_12-1,VAR_1->columns,1,
        VAR_2);
      if (VAR_28 == (Quantum *) NULL)
        break;
      (void) ImportQuantumPixels(VAR_1,(CacheView *) NULL,VAR_8,
        VAR_29,VAR_13,VAR_2);
      if ((VAR_7.Type[1] == 2) || (VAR_7.Type[1] == 3))
        FixSignedValues(VAR_1,VAR_28,(int) VAR_1->columns);
      if (SyncAuthenticPixels(VAR_1,VAR_2) == VAR_17)
        break;
      if (VAR_1->previous == (Image *) NULL)
        {
          VAR_6=SetImageProgress(VAR_1,VAR_30,(MagickOffsetType) VAR_12,
            VAR_1->rows);
          if (VAR_6 == VAR_17)
            break;
        }
    }
    if (VAR_7.imagf == 1)
      for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->rows; VAR_12++)
      {
        /* COMMENT_12 */
                              
          
        VAR_11=ReadBlob(VAR_1,VAR_14/8*VAR_1->columns,(char *) VAR_13);
        if (VAR_11 == -1)
          break;
        if (VAR_7.Type[1] == 0)
          InsertComplexDoubleRow(VAR_1,(double *) VAR_13,VAR_12,0,0,VAR_2);
        else
          InsertComplexFloatRow(VAR_1,(float *) VAR_13,VAR_12,0,0,VAR_2);
      }
    if (VAR_8 != (QuantumInfo *) NULL)
      VAR_8=DestroyQuantumInfo(VAR_8);
    if (EOFBlob(VAR_1) != VAR_17)
      {
        ThrowFileException(VAR_2,VAR_22,""UnexpectedEndOfFile"",
          VAR_1->filename);
        break;
      }
    VAR_5=RotateImage(VAR_1,90.0,VAR_2);
    if (VAR_5 != (Image *) NULL)
      {
        VAR_5->page.x=0;
        VAR_5->page.y=0;
        VAR_5->colors = VAR_1->colors;
        DestroyBlob(VAR_5);
        VAR_5->blob=ReferenceBlob(VAR_1->blob);
        AppendImageToList(&VAR_1,VAR_5);
        DeleteImageFromList(&VAR_1);
      }
    /* COMMENT_15 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_1->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    /* COMMENT_18 */
                                    
      
skip_reading_current:
    AcquireNextImage(VAR_0,VAR_1,VAR_2);
    if (GetNextImageInList(VAR_1) == (Image *) NULL)
      {
        VAR_6=VAR_17;
        break;
      }
    VAR_1=SyncNextImageInList(VAR_1);
    VAR_6=SetImageProgress(VAR_1,VAR_31,TellBlob(VAR_1),
      GetBlobSize(VAR_1));
    if (VAR_6 == VAR_17)
      break;
  }
  (void) CloseBlob(VAR_1);
  if (VAR_6 == VAR_17)
    return(DestroyImageList(VAR_1));
  return(GetFirstImageInList(VAR_1));
}",ImageMagick/f7206618d27c2e69d977abf40e3035a33e5f6be0/mat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -52,6 +52,7 @@
      Object parser loop.
     */
     ldblk=ReadBlobLSBLong(image);
+    if(EOFBlob(image)) break;
     if ((ldblk > 9999) || (ldblk < 0))
       break;
     HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */","{'deleted_lines': [], 'added_lines': ['    if(EOFBlob(image)) break;']}",True,coders/mat.c in ImageMagick 7.0.8-43 Q16 allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact by crafting a Matlab image file that is mishandled in ReadImage in MagickCore/constitute.c.,8.8,HIGH,2,test,2019-04-27T12:32:23Z,2
CVE-2019-15140,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1554,f7206618d27c2e69d977abf40e3035a33e5f6be0,https://github.com/ImageMagick/ImageMagick/commit/f7206618d27c2e69d977abf40e3035a33e5f6be0,coders/mat.c,ReadMATImage,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
Image *image, *image2=NULL,
*rotated_image;
register Quantum *q;
unsigned int status;
MATHeader MATLAB_HDR;
size_t size;
size_t CellType;
QuantumInfo *quantum_info;
ImageInfo *clone_info;
int i;
ssize_t ldblk;
unsigned char *BImgBuff = NULL;
double MinVal, MaxVal;
unsigned z, z2;
unsigned Frames;
int logging;
int sample_size;
MagickOffsetType filepos=0x80;
unsigned int (*ReadBlobXXXLong)(Image *image);
unsigned short (*ReadBlobXXXShort)(Image *image);
void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
image = AcquireImage(image_info,exception);
image2 = (Image *) NULL;
status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
quantum_info=(QuantumInfo *) NULL;
clone_info=(ImageInfo *) NULL;
if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
{
image=ReadMATImageV4(image_info,image,exception);
if (image == NULL)
{
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
return((Image *) NULL);
}
goto END_OF_READING;
}
MATLAB_HDR.Version = ReadBlobLSBShort(image);
if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (logging)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
{
ReadBlobXXXLong = ReadBlobLSBLong;
ReadBlobXXXShort = ReadBlobLSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesLSB;
ReadBlobFloatsXXX = ReadBlobFloatsLSB;
image->endian = LSBEndian;
}
else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
{
ReadBlobXXXLong = ReadBlobMSBLong;
ReadBlobXXXShort = ReadBlobMSBShort;
ReadBlobDoublesXXX = ReadBlobDoublesMSB;
ReadBlobFloatsXXX = ReadBlobFloatsMSB;
image->endian = MSBEndian;
}
else
{
MATLAB_KO:
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
filepos = TellBlob(image);
while(!EOFBlob(image)) 
{
Frames = 1;
if (filepos != (unsigned int) filepos)
break;
if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;
MATLAB_HDR.DataType = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
if(EOFBlob(image)) break;
if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
goto MATLAB_KO;
filepos += (MagickOffsetType) MATLAB_HDR.ObjectSize + 4 + 4;
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
clone_info=CloneImageInfo(image_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
if(MATLAB_HDR.DataType == miCOMPRESSED)
{
image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
if(image2==NULL) continue;
MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
}
#endif
if (MATLAB_HDR.DataType != miMATRIX)
{
clone_info=DestroyImageInfo(clone_info);
#if defined(MAGICKCORE_ZLIB_DELEGATE)
if (image2 != image)
DeleteImageFromList(&image2);
#endif
continue;  
}
MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
if(image!=image2)
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
switch(MATLAB_HDR.DimFlag)
{
case  8: z2=z=1; break;      
case 12: z2=z = ReadBlobXXXLong(image2);  
(void) ReadBlobXXXLong(image2);
if(z!=3)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError,
""MultidimensionalMatricesAreNotSupported"");
}
break;
case 16: z2=z = ReadBlobXXXLong(image2);  
if(z!=3 && z!=1)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError,
""MultidimensionalMatricesAreNotSupported"");
}
Frames = ReadBlobXXXLong(image2);
if (Frames == 0)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
if (AcquireMagickResource(ListLengthResource,Frames) == MagickFalse)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(ResourceLimitError,""ListLengthExceedsLimit"");
}
break;
default:
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
}
MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
MATLAB_HDR.StructureClass != mxINT8_CLASS &&
MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
MATLAB_HDR.StructureClass != mxINT16_CLASS &&
MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
MATLAB_HDR.StructureClass != mxINT32_CLASS &&
MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
MATLAB_HDR.StructureClass != mxINT64_CLASS &&
MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
{
if ((image2 != (Image*) NULL) && (image2 != image))
{
CloseBlob(image2);
DeleteImageFromList(&image2);
}
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
}
switch (MATLAB_HDR.NameFlag)
{
case 0:
size = ReadBlobXXXLong(image2);  
size = 4 * (((size_t) size + 3 + 1) / 4);
(void) SeekBlob(image2, size, SEEK_CUR);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(image2, 4, (unsigned char *) &size); 
break;
default:
goto MATLAB_KO;
}
CellType = ReadBlobXXXLong(image2);    
if (logging)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) CellType);
if (ReadBlob(image2, 4, (unsigned char *) &size) != 4)
goto MATLAB_KO;
NEXT_FRAME:
switch (CellType)
{
case miINT8:
case miUINT8:
sample_size = 8;
if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
image->depth = 1;
else
image->depth = 8;         
ldblk = (ssize_t) MATLAB_HDR.SizeX;
break;
case miINT16:
case miUINT16:
sample_size = 16;
image->depth = 16;        
ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
break;
case miINT32:
case miUINT32:
sample_size = 32;
image->depth = 32;        
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miINT64:
case miUINT64:
sample_size = 64;
image->depth = 64;        
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
case miSINGLE:
sample_size = 32;
image->depth = 32;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{              
}
ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
break;
case miDOUBLE:
sample_size = 64;
image->depth = 64;        
(void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
RestoreMSCWarning
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
}
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{                         
}
ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
break;
default:
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
}
(void) sample_size;
image->columns = MATLAB_HDR.SizeX;
image->rows = MATLAB_HDR.SizeY;
image->colors = GetQuantumRange(image->depth);
if (image->columns == 0 || image->rows == 0)
goto MATLAB_KO;
if((unsigned int)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
goto MATLAB_KO;
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
{
image->type=GrayscaleType;
SetImageColorspace(image,GRAYColorspace,exception);
}
if (image_info->ping)
{
size_t temp = image->columns;
image->columns = image->rows;
image->rows = temp;
goto done_reading; 
}
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
return(DestroyImageList(image));
}
(void) SetImageBackgroundColor(image,exception);
quantum_info=AcquireQuantumInfo(clone_info,image);
if (quantum_info == (QuantumInfo *) NULL)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
if (BImgBuff == NULL)
{
if (clone_info != (ImageInfo *) NULL)
clone_info=DestroyImageInfo(clone_info);
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
(void) memset(BImgBuff,0,ldblk*sizeof(double));
MinVal = 0;
MaxVal = 0;
if (CellType==miDOUBLE || CellType==miSINGLE)        
{
CalcMinMax(image2,image_info->endian,MATLAB_HDR.SizeX,MATLAB_HDR.SizeY,
CellType,ldblk,BImgBuff,&quantum_info->minimum,
&quantum_info->maximum);
}
if(z==1) z=0; 
do
{
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
if (q == (Quantum *) NULL)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto done_reading;    
}
if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
{
FixLogical((unsigned char *)BImgBuff,ldblk);
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
{
ImportQuantumPixelsFailed:
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
break;
}
}
else
{
if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
goto ImportQuantumPixelsFailed;
if (z<=1 &&       
(CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
FixSignedValues(image,q,MATLAB_HDR.SizeX);
}
if (!SyncAuthenticPixels(image,exception))
{
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
goto ExitLoop;
}
}
} while(z-- >= 2);
ExitLoop:
if (i != (long) MATLAB_HDR.SizeY)
goto END_OF_READING;
if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
{        
CellType = ReadBlobXXXLong(image2);    
i = ReadBlobXXXLong(image2);           
if (CellType==miDOUBLE || CellType==miSINGLE)
{
CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
}
if (CellType==miDOUBLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
if (EOFBlob(image) != MagickFalse)
break;
InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
exception);
}
if (CellType==miSINGLE)
for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
{
ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
if (EOFBlob(image) != MagickFalse)
break;
InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
exception);
}
}
if ((MATLAB_HDR.DimFlag == 8) &&
((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
image->type=GrayscaleType;
if (image->depth == 1)
image->type=BilevelType;
if(image2==image)
image2 = NULL;    
rotated_image = RotateImage(image, 90.0, exception);
if (rotated_image != (Image *) NULL)
{
rotated_image->page.x=0;
rotated_image->page.y=0;
rotated_image->colors = image->colors;
DestroyBlob(rotated_image);
rotated_image->blob=ReferenceBlob(image->blob);
AppendImageToList(&image,rotated_image);
DeleteImageFromList(&image);
}
done_reading:
if(image2!=NULL)
if(image2!=image)
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
}
}
if (EOFBlob(image) != MagickFalse)
break;
AcquireNextImage(image_info,image,exception);
if (image->next == (Image *) NULL) break;
image=SyncNextImageInList(image);
image->columns=image->rows=0;
image->colors=0;
RelinquishMagickMemory(BImgBuff);
BImgBuff = NULL;
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
if(--Frames>0)
{
z = z2;
if(image2==NULL) image2 = image;
if(!EOFBlob(image) && TellBlob(image)<filepos)
goto NEXT_FRAME;
}
if ((image2!=NULL) && (image2!=image))   
{
DeleteImageFromList(&image2);
if(clone_info)
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
}
}
if (clone_info)
clone_info=DestroyImageInfo(clone_info);
}
END_OF_READING:
RelinquishMagickMemory(BImgBuff);
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
CloseBlob(image);
{
Image *p;
ssize_t scene=0;
p=image;
image=NULL;
while (p != (Image *) NULL)
{
Image *tmp=p;
if ((p->rows == 0) || (p->columns == 0)) {
p=p->previous;
if (tmp == image2)
image2=(Image *) NULL;
DeleteImageFromList(&tmp);
} else {
image=p;
p=p->previous;
}
}
for (p=image; p != (Image *) NULL; p=p->next)
p->scene=scene++;
}
if(clone_info != NULL)  
{
if(clone_info->file)
{
fclose(clone_info->file);
clone_info->file = NULL;
(void) remove_utf8(clone_info->filename);
}
DestroyImageInfo(clone_info);
clone_info = NULL;
}
if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
if ((image != image2) && (image2 != (Image *) NULL))
image2=DestroyImage(image2);
if (image == (Image *) NULL)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
return(image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
Image *VAR_2, *VAR_3=NULL,
*VAR_4;
register Quantum *VAR_5;
unsigned int VAR_6;
MATHeader VAR_7;
size_t VAR_8;
size_t VAR_9;
QuantumInfo *VAR_10;
ImageInfo *VAR_11;
int VAR_12;
ssize_t VAR_13;
unsigned char *VAR_14 = NULL;
double VAR_15, VAR_16;
unsigned VAR_17, VAR_18;
unsigned VAR_19;
int VAR_20;
int VAR_21;
MagickOffsetType VAR_22=0x80;
unsigned int (*VAR_23)(Image *VAR_2);
unsigned short (*VAR_24)(Image *VAR_2);
void (*VAR_25)(Image * VAR_2, size_t VAR_26, double *VAR_27);
void (*VAR_28)(Image * VAR_2, size_t VAR_26, float *VAR_27);
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_29);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_29);
VAR_20 = LogMagickEvent(VAR_30,GetMagickModule(),""enter"");
VAR_2 = AcquireImage(VAR_0,VAR_1);
VAR_3 = (Image *) NULL;
VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_31, VAR_1);
if (VAR_6 == VAR_32)
{
VAR_2=DestroyImageList(VAR_2);
return((Image *) NULL);
}
VAR_10=(QuantumInfo *) NULL;
VAR_11=(ImageInfo *) NULL;
if (ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
ThrowReaderException(VAR_33,""ImproperImageHeader"");
if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
{
VAR_2=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
if (VAR_2 == NULL)
{
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
return((Image *) NULL);
}
goto END_OF_READING;
}
VAR_7.Version = ReadBlobLSBShort(VAR_2);
if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
ThrowReaderException(VAR_33,""ImproperImageHeader"");
if (VAR_20)
(void) LogMagickEvent(VAR_30,GetMagickModule(),""  Endian %c%c"",
VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
{
VAR_23 = VAR_34;
VAR_24 = VAR_35;
VAR_25 = VAR_36;
VAR_28 = VAR_37;
VAR_2->endian = VAR_38;
}
else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
{
VAR_23 = VAR_39;
VAR_24 = VAR_40;
VAR_25 = VAR_41;
VAR_28 = VAR_42;
VAR_2->endian = VAR_43;
}
else
{
MATLAB_KO:
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_33,""ImproperImageHeader"");
}
VAR_22 = TellBlob(VAR_2);
while(!EOFBlob(VAR_2)) 
{
VAR_19 = 1;
if (VAR_22 != (unsigned int) VAR_22)
break;
if(SeekBlob(VAR_2,VAR_22,VAR_44) != VAR_22) break;
VAR_7.DataType = VAR_23(VAR_2);
if(EOFBlob(VAR_2)) break;
VAR_7.ObjectSize = VAR_23(VAR_2);
if(EOFBlob(VAR_2)) break;
if((VAR_45) (VAR_7.ObjectSize+VAR_22) > GetBlobSize(VAR_2))
goto MATLAB_KO;
VAR_22 += (MagickOffsetType) VAR_7.ObjectSize + 4 + 4;
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
VAR_11=CloneImageInfo(VAR_0);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
VAR_3 = VAR_2;
#if defined(VAR_46)
if(VAR_7.DataType == VAR_47)
{
VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
if(VAR_3==NULL) continue;
VAR_7.DataType = VAR_23(VAR_3); 
}
#endif
if (VAR_7.DataType != VAR_48)
{
VAR_11=DestroyImageInfo(VAR_11);
#if defined(VAR_46)
if (VAR_3 != VAR_2)
DeleteImageFromList(&VAR_3);
#endif
continue;  
}
VAR_7.unknown1 = VAR_23(VAR_3);
VAR_7.unknown2 = VAR_23(VAR_3);
VAR_7.unknown5 = VAR_23(VAR_3);
VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;
VAR_7.unknown3 = VAR_23(VAR_3);
if(VAR_2!=VAR_3)
VAR_7.unknown4 = VAR_23(VAR_3);  
VAR_7.unknown4 = VAR_23(VAR_3);
VAR_7.DimFlag = VAR_23(VAR_3);
VAR_7.SizeX = VAR_23(VAR_3);
VAR_7.SizeY = VAR_23(VAR_3);
switch(VAR_7.DimFlag)
{
case  8: VAR_18=VAR_17=1; break;      
case 12: VAR_18=VAR_17 = VAR_23(VAR_3);  
(void) VAR_23(VAR_3);
if(VAR_17!=3)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_49,
""MultidimensionalMatricesAreNotSupported"");
}
break;
case 16: VAR_18=VAR_17 = VAR_23(VAR_3);  
if(VAR_17!=3 && VAR_17!=1)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_49,
""MultidimensionalMatricesAreNotSupported"");
}
VAR_19 = VAR_23(VAR_3);
if (VAR_19 == 0)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_33,""ImproperImageHeader"");
}
if (AcquireMagickResource(VAR_50,VAR_19) == VAR_32)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_51,""ListLengthExceedsLimit"");
}
break;
default:
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_49, ""MultidimensionalMatricesAreNotSupported"");
}
VAR_7.Flag1 = VAR_24(VAR_3);
VAR_7.NameFlag = VAR_24(VAR_3);
if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
if (VAR_7.StructureClass != VAR_52 &&
VAR_7.StructureClass != VAR_53 &&    
VAR_7.StructureClass != VAR_54 &&    
VAR_7.StructureClass != VAR_55 &&
VAR_7.StructureClass != VAR_56 &&    
VAR_7.StructureClass != VAR_57 &&
VAR_7.StructureClass != VAR_58 &&    
VAR_7.StructureClass != VAR_59 &&
VAR_7.StructureClass != VAR_60 &&    
VAR_7.StructureClass != VAR_61 &&
VAR_7.StructureClass != VAR_62)    
{
if ((VAR_3 != (Image*) NULL) && (VAR_3 != VAR_2))
{
CloseBlob(VAR_3);
DeleteImageFromList(&VAR_3);
}
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_49,""UnsupportedCellTypeInTheMatrix"");
}
switch (VAR_7.NameFlag)
{
case 0:
VAR_8 = VAR_23(VAR_3);  
VAR_8 = 4 * (((size_t) VAR_8 + 3 + 1) / 4);
(void) SeekBlob(VAR_3, VAR_8, VAR_63);
break;
case 1:
case 2:
case 3:
case 4:
(void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); 
break;
default:
goto MATLAB_KO;
}
VAR_9 = VAR_23(VAR_3);    
if (VAR_20)
(void) LogMagickEvent(VAR_30,GetMagickModule(),
""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);
if (ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8) != 4)
goto MATLAB_KO;
NEXT_FRAME:
switch (VAR_9)
{
case VAR_64:
case VAR_65:
VAR_21 = 8;
if(VAR_7.StructureFlag & VAR_66)
VAR_2->depth = 1;
else
VAR_2->depth = 8;         
VAR_13 = (ssize_t) VAR_7.SizeX;
break;
case VAR_67:
case VAR_68:
VAR_21 = 16;
VAR_2->depth = 16;        
VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
break;
case VAR_69:
case VAR_70:
VAR_21 = 32;
VAR_2->depth = 32;        
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_71:
case VAR_72:
VAR_21 = 64;
VAR_2->depth = 64;        
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
case VAR_73:
VAR_21 = 32;
VAR_2->depth = 32;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
if (VAR_7.StructureFlag & VAR_74)
{              
}
VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
break;
case VAR_75:
VAR_21 = 64;
VAR_2->depth = 64;        
(void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
if (sizeof(double) != 8)
VAR_76
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_49, ""IncompatibleSizeOfDouble"");
}
if (VAR_7.StructureFlag & VAR_74)
{                         
}
VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
break;
default:
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
ThrowReaderException(VAR_49, ""UnsupportedCellTypeInTheMatrix"");
}
(void) VAR_21;
VAR_2->columns = VAR_7.SizeX;
VAR_2->rows = VAR_7.SizeY;
VAR_2->colors = GetQuantumRange(VAR_2->depth);
if (VAR_2->columns == 0 || VAR_2->rows == 0)
goto MATLAB_KO;
if((unsigned int)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
goto MATLAB_KO;
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_74) == 0))
{
VAR_2->type=VAR_77;
SetImageColorspace(VAR_2,VAR_78,VAR_1);
}
if (VAR_0->ping)
{
size_t VAR_79 = VAR_2->columns;
VAR_2->columns = VAR_2->rows;
VAR_2->rows = VAR_79;
goto done_reading; 
}
VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows,VAR_1);
if (VAR_6 == VAR_32)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
return(DestroyImageList(VAR_2));
}
(void) SetImageBackgroundColor(VAR_2,VAR_1);
VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
if (VAR_10 == (QuantumInfo *) NULL)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
ThrowReaderException(VAR_51,""MemoryAllocationFailed"");
}
VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    
if (VAR_14 == NULL)
{
if (VAR_11 != (ImageInfo *) NULL)
VAR_11=DestroyImageInfo(VAR_11);
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
ThrowReaderException(VAR_51,""MemoryAllocationFailed"");
}
(void) memset(VAR_14,0,VAR_13*sizeof(double));
VAR_15 = 0;
VAR_16 = 0;
if (VAR_9==VAR_75 || VAR_9==VAR_73)        
{
CalcMinMax(VAR_3,VAR_0->endian,VAR_7.SizeX,VAR_7.SizeY,
VAR_9,VAR_13,VAR_14,&VAR_10->minimum,
&VAR_10->maximum);
}
if(VAR_17==1) VAR_17=0; 
do
{
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
if (VAR_5 == (Quantum *) NULL)
{
if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto done_reading;    
}
if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
{
if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
if((VAR_9==VAR_64 || VAR_9==VAR_65) && (VAR_7.StructureFlag & VAR_66))
{
FixLogical((unsigned char *)VAR_14,VAR_13);
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_80[VAR_17],VAR_14,VAR_1) <= 0)
{
ImportQuantumPixelsFailed:
if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
break;
}
}
else
{
if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_80[VAR_17],VAR_14,VAR_1) <= 0)
goto ImportQuantumPixelsFailed;
if (VAR_17<=1 &&       
(VAR_9==VAR_64 || VAR_9==VAR_67 || VAR_9==VAR_69 || VAR_9==VAR_71))
FixSignedValues(VAR_2,VAR_5,VAR_7.SizeX);
}
if (!SyncAuthenticPixels(VAR_2,VAR_1))
{
if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
goto ExitLoop;
}
}
} while(VAR_17-- >= 2);
ExitLoop:
if (VAR_12 != (long) VAR_7.SizeY)
goto END_OF_READING;
if (VAR_7.StructureFlag & VAR_74)
{        
VAR_9 = VAR_23(VAR_3);    
VAR_12 = VAR_23(VAR_3);           
if (VAR_9==VAR_75 || VAR_9==VAR_73)
{
CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
}
if (VAR_9==VAR_75)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_25(VAR_3, VAR_13, (double *)VAR_14);
if (EOFBlob(VAR_2) != VAR_32)
break;
InsertComplexDoubleRow(VAR_2, (double *)VAR_14, VAR_12, VAR_15, VAR_16,
VAR_1);
}
if (VAR_9==VAR_73)
for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
{
VAR_28(VAR_3, VAR_13, (float *)VAR_14);
if (EOFBlob(VAR_2) != VAR_32)
break;
InsertComplexFloatRow(VAR_2,(float *)VAR_14,VAR_12,VAR_15,VAR_16,
VAR_1);
}
}
if ((VAR_7.DimFlag == 8) &&
((VAR_7.StructureFlag & VAR_74) == 0))
VAR_2->type=VAR_77;
if (VAR_2->depth == 1)
VAR_2->type=VAR_81;
if(VAR_3==VAR_2)
VAR_3 = NULL;    
VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
if (VAR_4 != (Image *) NULL)
{
VAR_4->page.x=0;
VAR_4->page.y=0;
VAR_4->colors = VAR_2->colors;
DestroyBlob(VAR_4);
VAR_4->blob=ReferenceBlob(VAR_2->blob);
AppendImageToList(&VAR_2,VAR_4);
DeleteImageFromList(&VAR_2);
}
done_reading:
if(VAR_3!=NULL)
if(VAR_3!=VAR_2)
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
}
}
if (EOFBlob(VAR_2) != VAR_32)
break;
AcquireNextImage(VAR_0,VAR_2,VAR_1);
if (VAR_2->next == (Image *) NULL) break;
VAR_2=SyncNextImageInList(VAR_2);
VAR_2->columns=VAR_2->rows=0;
VAR_2->colors=0;
RelinquishMagickMemory(VAR_14);
VAR_14 = NULL;
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
if(--VAR_19>0)
{
VAR_17 = VAR_18;
if(VAR_3==NULL) VAR_3 = VAR_2;
if(!EOFBlob(VAR_2) && TellBlob(VAR_2)<VAR_22)
goto NEXT_FRAME;
}
if ((VAR_3!=NULL) && (VAR_3!=VAR_2))   
{
DeleteImageFromList(&VAR_3);
if(VAR_11)
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
}
}
if (VAR_11)
VAR_11=DestroyImageInfo(VAR_11);
}
END_OF_READING:
RelinquishMagickMemory(VAR_14);
if (VAR_10 != (QuantumInfo *) NULL)
VAR_10=DestroyQuantumInfo(VAR_10);
CloseBlob(VAR_2);
{
Image *VAR_82;
ssize_t VAR_83=0;
VAR_82=VAR_2;
VAR_2=NULL;
while (VAR_82 != (Image *) NULL)
{
Image *VAR_84=VAR_82;
if ((VAR_82->rows == 0) || (VAR_82->columns == 0)) {
VAR_82=VAR_82->previous;
if (VAR_84 == VAR_3)
VAR_3=(Image *) NULL;
DeleteImageFromList(&VAR_84);
} else {
VAR_2=VAR_82;
VAR_82=VAR_82->previous;
}
}
for (VAR_82=VAR_2; VAR_82 != (Image *) NULL; VAR_82=VAR_82->next)
VAR_82->scene=VAR_83++;
}
if(VAR_11 != NULL)  
{
if(VAR_11->file)
{
fclose(VAR_11->file);
VAR_11->file = NULL;
(void) remove_utf8(VAR_11->filename);
}
DestroyImageInfo(VAR_11);
VAR_11 = NULL;
}
if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),""return"");
if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
VAR_3=DestroyImage(VAR_3);
if (VAR_2 == (Image *) NULL)
ThrowReaderException(VAR_33,""ImproperImageHeader"")
return(VAR_2);
}",ImageMagick/f7206618d27c2e69d977abf40e3035a33e5f6be0/mat.c/vul/before/1.json,"static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  /*
     Open image file.
   */
  image = AcquireImage(image_info,exception);
  image2 = (Image *) NULL;

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
     Read MATLAB image.
   */
  quantum_info=(QuantumInfo *) NULL;
  clone_info=(ImageInfo *) NULL;
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image=ReadMATImageV4(image_info,image,exception);
      if (image == NULL)
        {
          if ((image != image2) && (image2 != (Image *) NULL))
            image2=DestroyImage(image2);
          if (clone_info != (ImageInfo *) NULL)
            clone_info=DestroyImageInfo(clone_info);
          return((Image *) NULL);
        }
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    {
MATLAB_KO:
      if ((image != image2) && (image2 != (Image *) NULL))
        image2=DestroyImage(image2);
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }

  filepos = TellBlob(image);
  while(filepos < GetBlobSize(image) && !EOFBlob(image)) /* object parser loop */
  {
    Frames = 1;
    if(filepos > GetBlobSize(image) || filepos < 0)
      break;
    if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;
    /* printf(""pos=%X\n"",TellBlob(image)); */

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) >= GetBlobSize(image))
      goto MATLAB_KO;
    filepos += (MagickOffsetType) MATLAB_HDR.ObjectSize + 4 + 4;

    if (clone_info != (ImageInfo *) NULL)
      clone_info=DestroyImageInfo(clone_info);
    clone_info=CloneImageInfo(image_info);
    if ((image != image2) && (image2 != (Image *) NULL))
      image2=DestroyImage(image2);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */
    }
#endif

    if (MATLAB_HDR.DataType != miMATRIX)
      {
        clone_info=DestroyImageInfo(clone_info);
#if defined(MAGICKCORE_ZLIB_DELEGATE)
        if (image2 != image)
          DeleteImageFromList(&image2);
#endif
        continue;  /* skip another objects. */
      }

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      /* 2D matrix*/
      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/
           (void) ReadBlobXXXLong(image2);
         if(z!=3)
           {
             if (clone_info != (ImageInfo *) NULL)
               clone_info=DestroyImageInfo(clone_info);
             if ((image != image2) && (image2 != (Image *) NULL))
               image2=DestroyImage(image2);
             ThrowReaderException(CoderError,
               ""MultidimensionalMatricesAreNotSupported"");
           }
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */
         if(z!=3 && z!=1)
           {
             if (clone_info != (ImageInfo *) NULL)
               clone_info=DestroyImageInfo(clone_info);
             if ((image != image2) && (image2 != (Image *) NULL))
               image2=DestroyImage(image2);
             ThrowReaderException(CoderError,
               ""MultidimensionalMatricesAreNotSupported"");
           }
          Frames = ReadBlobXXXLong(image2);
          if (Frames == 0)
            {
              if (clone_info != (ImageInfo *) NULL)
                clone_info=DestroyImageInfo(clone_info);
              if ((image != image2) && (image2 != (Image *) NULL))
                image2=DestroyImage(image2);
              ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
            }
          if (AcquireMagickResource(ListLengthResource,Frames) == MagickFalse)
            {
              if (clone_info != (ImageInfo *) NULL)
                clone_info=DestroyImageInfo(clone_info);
              if ((image != image2) && (image2 != (Image *) NULL))
                image2=DestroyImage(image2);
              ThrowReaderException(ResourceLimitError,""ListLengthExceedsLimit"");
            }
         break;
      default:
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */
      {
        if ((image2 != (Image*) NULL) && (image2 != image))
          {
            CloseBlob(image2);
            DeleteImageFromList(&image2);
          }
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
      }

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  /* Object name string size */
        size = 4 * (((size_t) size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    /* Additional object type */
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    /* data size */
    if (ReadBlob(image2, 4, (unsigned char *) &size) != 4)
      goto MATLAB_KO;

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         /* Byte type cell */
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        /* Word type cell */
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        /* Dword type cell */
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        /* Qword type cell */
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
          {              /* complex float type cell */
          }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        /* double type cell */
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          {
            if (clone_info != (ImageInfo *) NULL)
              clone_info=DestroyImageInfo(clone_info);
            if ((image != image2) && (image2 != (Image *) NULL))
              image2=DestroyImage(image2);
            ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
          }
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
          {                         /* complex double type cell */
          }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    image->colors = GetQuantumRange(image->depth);
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned int)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
    /* Image is gray when no complex flag is set and 2D Matrix */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    /*
      If ping is true, then only set image size and colors without
      reading any image data.
    */
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; /* !!!!!! BAD  !!!! */
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      {
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        return(DestroyImageList(image));
      }
    (void) SetImageBackgroundColor(image,exception);
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      {
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }

  /* ----- Load raster data ----- */
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
    if (BImgBuff == NULL)
      {
        if (clone_info != (ImageInfo *) NULL)
          clone_info=DestroyImageInfo(clone_info);
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (quantum_info != (QuantumInfo *) NULL)
          quantum_info=DestroyQuantumInfo(quantum_info);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    (void) memset(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */
      {
        CalcMinMax(image2,image_info->endian,MATLAB_HDR.SizeX,MATLAB_HDR.SizeY,
          CellType,ldblk,BImgBuff,&quantum_info->minimum,
          &quantum_info->maximum);
      }

    /* Main loop for reading all scanlines */
    if(z==1) z=0; /* read grey scanlines */
    /* else read color scanlines */
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          {
            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
            goto done_reading;    /* Skip image rotation, when cannot set image pixels    */
          }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
          {
            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
            goto ExitLoop;
          }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
            {
ImportQuantumPixelsFailed:
              if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
              break;
            }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
            goto ImportQuantumPixelsFailed;


          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */
             (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
            FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
          {
            if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
            goto ExitLoop;
          }
      }
    } while(z-- >= 2);
ExitLoop:
    if (i != (long) MATLAB_HDR.SizeY)
      goto END_OF_READING;

    /* Read complex part of numbers here */
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        /* Find Min and Max Values for complex parts of floats */
      CellType = ReadBlobXXXLong(image2);    /* Additional object type */
      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
        {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          if (EOFBlob(image) != MagickFalse)
            break;
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
        }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
        {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          if (EOFBlob(image) != MagickFalse)
            break;
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
        }
    }

      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    /* Remove shadow copy to an image before rotation. */

      /*  Rotate image. */
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        /* Remove page offsets added by RotateImage */
      rotated_image->page.x=0;
      rotated_image->page.y=0;
      rotated_image->colors = image->colors;
      DestroyBlob(rotated_image);
      rotated_image->blob=ReferenceBlob(image->blob);
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
      }
    if (EOFBlob(image) != MagickFalse)
      break;

      /* Allocate next image structure. */
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      /* row scan buffer is no longer needed */
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;
    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      if(!EOFBlob(image) && TellBlob(image)<filepos)
        goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */
      {
/*  CloseBlob(image2); */
        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
      }

    if (clone_info)
      clone_info=DestroyImageInfo(clone_info);
  }

END_OF_READING:
  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    /*
      Rewind list, removing any empty images while rewinding.
    */
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    /*
      Fix scene numbers
    */
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  /* cleanup garbage file from compression */
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if ((image != image2) && (image2 != (Image *) NULL))
    image2=DestroyImage(image2);
  if (image == (Image *) NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"")
  return(image);
}","static Image *ReadMATImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  Image *VAR_2, *VAR_3=NULL,
   *VAR_4;
  register Quantum *VAR_5;

  unsigned int VAR_6;
  MATHeader VAR_7;
  size_t VAR_8;
  size_t VAR_9;
  QuantumInfo *VAR_10;
  ImageInfo *VAR_11;
  int VAR_12;
  ssize_t VAR_13;
  unsigned char *VAR_14 = NULL;
  double VAR_15, VAR_16;
  unsigned VAR_17, VAR_18;
  unsigned VAR_19;
  int VAR_20;
  int VAR_21;
  MagickOffsetType VAR_22=0x80;

  unsigned int (*VAR_23)(Image *VAR_2);
  unsigned short (*VAR_24)(Image *VAR_2);
  void (*VAR_25)(Image * VAR_2, size_t VAR_26, double *VAR_27);
  void (*VAR_28)(Image * VAR_2, size_t VAR_26, float *VAR_27);


  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_29);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_29);
  VAR_20 = LogMagickEvent(VAR_30,GetMagickModule(),""enter"");

  /* COMMENT_0 */
                     
     
  VAR_2 = AcquireImage(VAR_0,VAR_1);
  VAR_3 = (Image *) NULL;

  VAR_6 = OpenBlob(VAR_0, VAR_2, VAR_31, VAR_1);
  if (VAR_6 == VAR_32)
    {
      VAR_2=DestroyImageList(VAR_2);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                       
     
  VAR_10=(QuantumInfo *) NULL;
  VAR_11=(ImageInfo *) NULL;
  if (ReadBlob(VAR_2,124,(unsigned char *) &VAR_7.identific) != 124)
    ThrowReaderException(VAR_33,""ImproperImageHeader"");
  if (strncmp(VAR_7.identific,""MATLAB"",6) != 0)
    {
      VAR_2=ReadMATImageV4(VAR_0,VAR_2,VAR_1);
      if (VAR_2 == NULL)
        {
          if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
            VAR_3=DestroyImage(VAR_3);
          if (VAR_11 != (ImageInfo *) NULL)
            VAR_11=DestroyImageInfo(VAR_11);
          return((Image *) NULL);
        }
      goto END_OF_READING;
    }
  VAR_7.Version = ReadBlobLSBShort(VAR_2);
  if(ReadBlob(VAR_2,2,(unsigned char *) &VAR_7.EndianIndicator) != 2)
    ThrowReaderException(VAR_33,""ImproperImageHeader"");

  if (VAR_20)
    (void) LogMagickEvent(VAR_30,GetMagickModule(),""  Endian %c%c"",
      VAR_7.EndianIndicator[0],VAR_7.EndianIndicator[1]);
  if (!strncmp(VAR_7.EndianIndicator, ""IM"", 2))
  {
    VAR_23 = VAR_34;
    VAR_24 = VAR_35;
    VAR_25 = VAR_36;
    VAR_28 = VAR_37;
    VAR_2->endian = VAR_38;
  }
  else if (!strncmp(VAR_7.EndianIndicator, ""MI"", 2))
  {
    VAR_23 = VAR_39;
    VAR_24 = VAR_40;
    VAR_25 = VAR_41;
    VAR_28 = VAR_42;
    VAR_2->endian = VAR_43;
  }
  else
    {
MATLAB_KO:
      if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
        VAR_3=DestroyImage(VAR_3);
      if (VAR_11 != (ImageInfo *) NULL)
        VAR_11=DestroyImageInfo(VAR_11);
      ThrowReaderException(VAR_33,""ImproperImageHeader"");
    }

  VAR_22 = TellBlob(VAR_2);
  while(VAR_22 < GetBlobSize(VAR_2) && !EOFBlob(VAR_2)) /* COMMENT_6 */
  {
    VAR_19 = 1;
    if(VAR_22 > GetBlobSize(VAR_2) || VAR_22 < 0)
      break;
    if(SeekBlob(VAR_2,VAR_22,VAR_44) != VAR_22) break;
    /* COMMENT_7 */

    VAR_7.DataType = VAR_23(VAR_2);
    if(EOFBlob(VAR_2)) break;
    VAR_7.ObjectSize = VAR_23(VAR_2);
    if(EOFBlob(VAR_2)) break;
    if((VAR_45) (VAR_7.ObjectSize+VAR_22) >= GetBlobSize(VAR_2))
      goto MATLAB_KO;
    VAR_22 += (MagickOffsetType) VAR_7.ObjectSize + 4 + 4;

    if (VAR_11 != (ImageInfo *) NULL)
      VAR_11=DestroyImageInfo(VAR_11);
    VAR_11=CloneImageInfo(VAR_0);
    if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
      VAR_3=DestroyImage(VAR_3);
    VAR_3 = VAR_2;
#if defined(VAR_46)
    if(VAR_7.DataType == VAR_47)
    {
      VAR_3 = decompress_block(VAR_2,&VAR_7.ObjectSize,VAR_11,VAR_1);
      if(VAR_3==NULL) continue;
      VAR_7.DataType = VAR_23(VAR_3); /* COMMENT_8 */
    }
#endif

    if (VAR_7.DataType != VAR_48)
      {
        VAR_11=DestroyImageInfo(VAR_11);
#if defined(VAR_46)
        if (VAR_3 != VAR_2)
          DeleteImageFromList(&VAR_3);
#endif
        continue;  /* COMMENT_9 */
      }

    VAR_7.unknown1 = VAR_23(VAR_3);
    VAR_7.unknown2 = VAR_23(VAR_3);

    VAR_7.unknown5 = VAR_23(VAR_3);
    VAR_7.StructureClass = VAR_7.unknown5 & 0xFF;
    VAR_7.StructureFlag = (VAR_7.unknown5>>8) & 0xFF;

    VAR_7.unknown3 = VAR_23(VAR_3);
    if(VAR_2!=VAR_3)
      VAR_7.unknown4 = VAR_23(VAR_3);  /* COMMENT_10 */
    VAR_7.unknown4 = VAR_23(VAR_3);
    VAR_7.DimFlag = VAR_23(VAR_3);
    VAR_7.SizeX = VAR_23(VAR_3);
    VAR_7.SizeY = VAR_23(VAR_3);


    switch(VAR_7.DimFlag)
    {
      case  8: VAR_18=VAR_17=1; break;      /* COMMENT_11 */
      case 12: VAR_18=VAR_17 = VAR_23(VAR_3);  /* COMMENT_12 */
           (void) VAR_23(VAR_3);
         if(VAR_17!=3)
           {
             if (VAR_11 != (ImageInfo *) NULL)
               VAR_11=DestroyImageInfo(VAR_11);
             if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
               VAR_3=DestroyImage(VAR_3);
             ThrowReaderException(VAR_49,
               ""MultidimensionalMatricesAreNotSupported"");
           }
         break;
      case 16: VAR_18=VAR_17 = VAR_23(VAR_3);  /* COMMENT_13 */
         if(VAR_17!=3 && VAR_17!=1)
           {
             if (VAR_11 != (ImageInfo *) NULL)
               VAR_11=DestroyImageInfo(VAR_11);
             if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
               VAR_3=DestroyImage(VAR_3);
             ThrowReaderException(VAR_49,
               ""MultidimensionalMatricesAreNotSupported"");
           }
          VAR_19 = VAR_23(VAR_3);
          if (VAR_19 == 0)
            {
              if (VAR_11 != (ImageInfo *) NULL)
                VAR_11=DestroyImageInfo(VAR_11);
              if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
                VAR_3=DestroyImage(VAR_3);
              ThrowReaderException(VAR_33,""ImproperImageHeader"");
            }
          if (AcquireMagickResource(VAR_50,VAR_19) == VAR_32)
            {
              if (VAR_11 != (ImageInfo *) NULL)
                VAR_11=DestroyImageInfo(VAR_11);
              if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
                VAR_3=DestroyImage(VAR_3);
              ThrowReaderException(VAR_51,""ListLengthExceedsLimit"");
            }
         break;
      default:
        if (VAR_11 != (ImageInfo *) NULL)
          VAR_11=DestroyImageInfo(VAR_11);
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        ThrowReaderException(VAR_49, ""MultidimensionalMatricesAreNotSupported"");
    }

    VAR_7.Flag1 = VAR_24(VAR_3);
    VAR_7.NameFlag = VAR_24(VAR_3);

    if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",VAR_7.StructureClass);
    if (VAR_7.StructureClass != VAR_52 &&
        VAR_7.StructureClass != VAR_53 &&    /* COMMENT_14 */
        VAR_7.StructureClass != VAR_54 &&    /* COMMENT_15 */
        VAR_7.StructureClass != VAR_55 &&
        VAR_7.StructureClass != VAR_56 &&    /* COMMENT_16 */
        VAR_7.StructureClass != VAR_57 &&
        VAR_7.StructureClass != VAR_58 &&    /* COMMENT_17 */
        VAR_7.StructureClass != VAR_59 &&
        VAR_7.StructureClass != VAR_60 &&    /* COMMENT_18 */
        VAR_7.StructureClass != VAR_61 &&
        VAR_7.StructureClass != VAR_62)    /* COMMENT_19 */
      {
        if ((VAR_3 != (Image*) NULL) && (VAR_3 != VAR_2))
          {
            CloseBlob(VAR_3);
            DeleteImageFromList(&VAR_3);
          }
        if (VAR_11 != (ImageInfo *) NULL)
          VAR_11=DestroyImageInfo(VAR_11);
        ThrowReaderException(VAR_49,""UnsupportedCellTypeInTheMatrix"");
      }

    switch (VAR_7.NameFlag)
    {
      case 0:
        VAR_8 = VAR_23(VAR_3);  /* COMMENT_20 */
        VAR_8 = 4 * (((size_t) VAR_8 + 3 + 1) / 4);
        (void) SeekBlob(VAR_3, VAR_8, VAR_63);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8); /* COMMENT_21 */
        break;
      default:
        goto MATLAB_KO;
    }

    VAR_9 = VAR_23(VAR_3);    /* COMMENT_22 */
    if (VAR_20)
      (void) LogMagickEvent(VAR_30,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) VAR_9);

    /* COMMENT_23 */
    if (ReadBlob(VAR_3, 4, (unsigned char *) &VAR_8) != 4)
      goto MATLAB_KO;

    NEXT_FRAME:
    switch (VAR_9)
    {
      case VAR_64:
      case VAR_65:
        VAR_21 = 8;
        if(VAR_7.StructureFlag & VAR_66)
          VAR_2->depth = 1;
        else
          VAR_2->depth = 8;         /* COMMENT_24 */
        VAR_13 = (ssize_t) VAR_7.SizeX;
        break;
      case VAR_67:
      case VAR_68:
        VAR_21 = 16;
        VAR_2->depth = 16;        /* COMMENT_25 */
        VAR_13 = (ssize_t) (2 * VAR_7.SizeX);
        break;
      case VAR_69:
      case VAR_70:
        VAR_21 = 32;
        VAR_2->depth = 32;        /* COMMENT_26 */
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_71:
      case VAR_72:
        VAR_21 = 64;
        VAR_2->depth = 64;        /* COMMENT_27 */
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      case VAR_73:
        VAR_21 = 32;
        VAR_2->depth = 32;        /* COMMENT_28 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
        if (VAR_7.StructureFlag & VAR_74)
          {              /* COMMENT_29 */
          }
        VAR_13 = (ssize_t) (4 * VAR_7.SizeX);
        break;
      case VAR_75:
        VAR_21 = 64;
        VAR_2->depth = 64;        /* COMMENT_28 */
        (void) SetImageOption(VAR_11,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
VAR_76
          {
            if (VAR_11 != (ImageInfo *) NULL)
              VAR_11=DestroyImageInfo(VAR_11);
            if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
              VAR_3=DestroyImage(VAR_3);
            ThrowReaderException(VAR_49, ""IncompatibleSizeOfDouble"");
          }
        if (VAR_7.StructureFlag & VAR_74)
          {                         /* COMMENT_30 */
          }
        VAR_13 = (ssize_t) (8 * VAR_7.SizeX);
        break;
      default:
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        if (VAR_11)
          VAR_11=DestroyImageInfo(VAR_11);
        ThrowReaderException(VAR_49, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) VAR_21;
    VAR_2->columns = VAR_7.SizeX;
    VAR_2->rows = VAR_7.SizeY;
    VAR_2->colors = GetQuantumRange(VAR_2->depth);
    if (VAR_2->columns == 0 || VAR_2->rows == 0)
      goto MATLAB_KO;
    if((unsigned int)VAR_13*VAR_7.SizeY > VAR_7.ObjectSize)
      goto MATLAB_KO;
    /* COMMENT_31 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_74) == 0))
      {
        VAR_2->type=VAR_77;
        SetImageColorspace(VAR_2,VAR_78,VAR_1);
      }


    /* COMMENT_32 */
                                                                  
                             
      
    if (VAR_0->ping)
    {
      size_t VAR_79 = VAR_2->columns;
      VAR_2->columns = VAR_2->rows;
      VAR_2->rows = VAR_79;
      goto done_reading; /* COMMENT_36 */
    }
    VAR_6=SetImageExtent(VAR_2,VAR_2->columns,VAR_2->rows,VAR_1);
    if (VAR_6 == VAR_32)
      {
        if (VAR_11 != (ImageInfo *) NULL)
          VAR_11=DestroyImageInfo(VAR_11);
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        return(DestroyImageList(VAR_2));
      }
    (void) SetImageBackgroundColor(VAR_2,VAR_1);
    VAR_10=AcquireQuantumInfo(VAR_11,VAR_2);
    if (VAR_10 == (QuantumInfo *) NULL)
      {
        if (VAR_11 != (ImageInfo *) NULL)
          VAR_11=DestroyImageInfo(VAR_11);
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        ThrowReaderException(VAR_51,""MemoryAllocationFailed"");
      }

  /* COMMENT_37 */
    VAR_14 = (unsigned char *) AcquireQuantumMemory((size_t) (VAR_13),sizeof(double));    /* COMMENT_38 */
    if (VAR_14 == NULL)
      {
        if (VAR_11 != (ImageInfo *) NULL)
          VAR_11=DestroyImageInfo(VAR_11);
        if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
          VAR_3=DestroyImage(VAR_3);
        if (VAR_10 != (QuantumInfo *) NULL)
          VAR_10=DestroyQuantumInfo(VAR_10);
        ThrowReaderException(VAR_51,""MemoryAllocationFailed"");
      }
    (void) memset(VAR_14,0,VAR_13*sizeof(double));

    VAR_15 = 0;
    VAR_16 = 0;
    if (VAR_9==VAR_75 || VAR_9==VAR_73)        /* COMMENT_39 */
      {
        CalcMinMax(VAR_3,VAR_0->endian,VAR_7.SizeX,VAR_7.SizeY,
          VAR_9,VAR_13,VAR_14,&VAR_10->minimum,
          &VAR_10->maximum);
      }

    /* COMMENT_40 */
    if(VAR_17==1) VAR_17=0; /* COMMENT_41 */
    /* COMMENT_42 */
    do
    {
      for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
      {
        VAR_5=GetAuthenticPixels(VAR_2,0,VAR_7.SizeY-VAR_12-1,VAR_2->columns,1,VAR_1);
        if (VAR_5 == (Quantum *) NULL)
          {
            if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(VAR_7.SizeY-VAR_12-1));
            goto done_reading;    /* COMMENT_43 */
          }
        if(ReadBlob(VAR_3,VAR_13,(unsigned char *)VAR_14) != (ssize_t) VAR_13)
          {
            if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
              ""  MAT cannot read scanrow %u from a file."", (unsigned)(VAR_7.SizeY-VAR_12-1));
            ThrowReaderException(VAR_33,""UnexpectedEndOfFile"");
            goto ExitLoop;
          }
        if((VAR_9==VAR_64 || VAR_9==VAR_65) && (VAR_7.StructureFlag & VAR_66))
        {
          FixLogical((unsigned char *)VAR_14,VAR_13);
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_80[VAR_17],VAR_14,VAR_1) <= 0)
            {
ImportQuantumPixelsFailed:
              if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
                ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
              break;
            }
        }
        else
        {
          if(ImportQuantumPixels(VAR_2,(CacheView *) NULL,VAR_10,VAR_80[VAR_17],VAR_14,VAR_1) <= 0)
            goto ImportQuantumPixelsFailed;


          if (VAR_17<=1 &&       /* COMMENT_44 */
             (VAR_9==VAR_64 || VAR_9==VAR_67 || VAR_9==VAR_69 || VAR_9==VAR_71))
            FixSignedValues(VAR_2,VAR_5,VAR_7.SizeX);
        }

        if (!SyncAuthenticPixels(VAR_2,VAR_1))
          {
            if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),
              ""  MAT failed to sync image pixels for a row %u"", (unsigned)(VAR_7.SizeY-VAR_12-1));
            goto ExitLoop;
          }
      }
    } while(VAR_17-- >= 2);
ExitLoop:
    if (VAR_12 != (long) VAR_7.SizeY)
      goto END_OF_READING;

    /* COMMENT_45 */
    if (VAR_7.StructureFlag & VAR_74)
    {        /* COMMENT_46 */
      VAR_9 = VAR_23(VAR_3);    /* COMMENT_22 */
      VAR_12 = VAR_23(VAR_3);           /* COMMENT_47 */

      if (VAR_9==VAR_75 || VAR_9==VAR_73)
      {
        CalcMinMax(VAR_3,  VAR_0->endian, VAR_7.SizeX, VAR_7.SizeY, VAR_9, VAR_13, VAR_14, &VAR_15, &VAR_16);
      }

      if (VAR_9==VAR_75)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
        {
          VAR_25(VAR_3, VAR_13, (double *)VAR_14);
          if (EOFBlob(VAR_2) != VAR_32)
            break;
          InsertComplexDoubleRow(VAR_2, (double *)VAR_14, VAR_12, VAR_15, VAR_16,
            VAR_1);
        }

      if (VAR_9==VAR_73)
        for (VAR_12 = 0; VAR_12 < (ssize_t) VAR_7.SizeY; VAR_12++)
        {
          VAR_28(VAR_3, VAR_13, (float *)VAR_14);
          if (EOFBlob(VAR_2) != VAR_32)
            break;
          InsertComplexFloatRow(VAR_2,(float *)VAR_14,VAR_12,VAR_15,VAR_16,
            VAR_1);
        }
    }

      /* COMMENT_48 */
    if ((VAR_7.DimFlag == 8) &&
        ((VAR_7.StructureFlag & VAR_74) == 0))
      VAR_2->type=VAR_77;
    if (VAR_2->depth == 1)
      VAR_2->type=VAR_81;

    if(VAR_3==VAR_2)
        VAR_3 = NULL;    /* COMMENT_49 */

      /* COMMENT_50 */
    VAR_4 = RotateImage(VAR_2, 90.0, VAR_1);
    if (VAR_4 != (Image *) NULL)
    {
        /* COMMENT_51 */
      VAR_4->page.x=0;
      VAR_4->page.y=0;
      VAR_4->colors = VAR_2->colors;
      DestroyBlob(VAR_4);
      VAR_4->blob=ReferenceBlob(VAR_2->blob);
      AppendImageToList(&VAR_2,VAR_4);
      DeleteImageFromList(&VAR_2);
    }

done_reading:

    if(VAR_3!=NULL)
      if(VAR_3!=VAR_2)
      {
        DeleteImageFromList(&VAR_3);
        if(VAR_11)
        {
          if(VAR_11->file)
          {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) remove_utf8(VAR_11->filename);
          }
        }
      }
    if (EOFBlob(VAR_2) != VAR_32)
      break;

      /* COMMENT_52 */
    AcquireNextImage(VAR_0,VAR_2,VAR_1);
    if (VAR_2->next == (Image *) NULL) break;
    VAR_2=SyncNextImageInList(VAR_2);
    VAR_2->columns=VAR_2->rows=0;
    VAR_2->colors=0;

      /* COMMENT_53 */
    RelinquishMagickMemory(VAR_14);
    VAR_14 = NULL;
    if (VAR_10 != (QuantumInfo *) NULL)
      VAR_10=DestroyQuantumInfo(VAR_10);

    if(--VAR_19>0)
    {
      VAR_17 = VAR_18;
      if(VAR_3==NULL) VAR_3 = VAR_2;
      if(!EOFBlob(VAR_2) && TellBlob(VAR_2)<VAR_22)
        goto NEXT_FRAME;
    }
    if ((VAR_3!=NULL) && (VAR_3!=VAR_2))   /* COMMENT_54 */
      {
/* COMMENT_55 */
        DeleteImageFromList(&VAR_3);
        if(VAR_11)
        {
          if(VAR_11->file)
          {
            fclose(VAR_11->file);
            VAR_11->file = NULL;
            (void) remove_utf8(VAR_11->filename);
          }
        }
      }

    if (VAR_11)
      VAR_11=DestroyImageInfo(VAR_11);
  }

END_OF_READING:
  RelinquishMagickMemory(VAR_14);
  if (VAR_10 != (QuantumInfo *) NULL)
    VAR_10=DestroyQuantumInfo(VAR_10);
  CloseBlob(VAR_2);


  {
    Image *VAR_82;
    ssize_t VAR_83=0;

    /* COMMENT_56 */
                                                             
      
    VAR_82=VAR_2;
    VAR_2=NULL;
    while (VAR_82 != (Image *) NULL)
      {
        Image *VAR_84=VAR_82;
        if ((VAR_82->rows == 0) || (VAR_82->columns == 0)) {
          VAR_82=VAR_82->previous;
          if (VAR_84 == VAR_3)
            VAR_3=(Image *) NULL;
          DeleteImageFromList(&VAR_84);
        } else {
          VAR_2=VAR_82;
          VAR_82=VAR_82->previous;
        }
      }

    /* COMMENT_59 */
                       
      
    for (VAR_82=VAR_2; VAR_82 != (Image *) NULL; VAR_82=VAR_82->next)
      VAR_82->scene=VAR_83++;
  }

  if(VAR_11 != NULL)  /* COMMENT_62 */
  {
    if(VAR_11->file)
    {
      fclose(VAR_11->file);
      VAR_11->file = NULL;
      (void) remove_utf8(VAR_11->filename);
    }
    DestroyImageInfo(VAR_11);
    VAR_11 = NULL;
  }
  if (VAR_20) (void)LogMagickEvent(VAR_30,GetMagickModule(),""return"");
  if ((VAR_2 != VAR_3) && (VAR_3 != (Image *) NULL))
    VAR_3=DestroyImage(VAR_3);
  if (VAR_2 == (Image *) NULL)
    ThrowReaderException(VAR_33,""ImproperImageHeader"")
  return(VAR_2);
}",ImageMagick/f7206618d27c2e69d977abf40e3035a33e5f6be0/mat.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -98,10 +98,10 @@
     }
 
   filepos = TellBlob(image);
-  while(!EOFBlob(image)) /* object parser loop */
+  while(filepos < GetBlobSize(image) && !EOFBlob(image)) /* object parser loop */
   {
     Frames = 1;
-    if (filepos != (unsigned int) filepos)
+    if(filepos > GetBlobSize(image) || filepos < 0)
       break;
     if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;
     /* printf(""pos=%X\n"",TellBlob(image)); */
@@ -110,7 +110,7 @@
     if(EOFBlob(image)) break;
     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
     if(EOFBlob(image)) break;
-    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
+    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) >= GetBlobSize(image))
       goto MATLAB_KO;
     filepos += (MagickOffsetType) MATLAB_HDR.ObjectSize + 4 + 4;
 
@@ -413,6 +413,7 @@
           {
             if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
+            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
             goto ExitLoop;
           }
         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))","{'deleted_lines': ['  while(!EOFBlob(image)) /* object parser loop */', '    if (filepos != (unsigned int) filepos)', '    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))'], 'added_lines': ['  while(filepos < GetBlobSize(image) && !EOFBlob(image)) /* object parser loop */', '    if(filepos > GetBlobSize(image) || filepos < 0)', '    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) >= GetBlobSize(image))', '            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");']}",True,coders/mat.c in ImageMagick 7.0.8-43 Q16 allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact by crafting a Matlab image file that is mishandled in ReadImage in MagickCore/constitute.c.,8.8,HIGH,2,test,2019-04-27T12:32:23Z,2
CVE-2018-10756,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,transmission,"CVE-2018-10756: Fix heap-use-after-free in tr_variantWalk

In libtransmission/variant.c, function tr_variantWalk, when the variant
stack is reallocated, a pointer to the previously allocated memory
region is kept. This address is later accessed (heap use-after-free)
while walking back down the stack, causing the application to crash.
The application can be any application which uses libtransmission, such
as transmission-daemon, transmission-gtk, transmission-show, etc.

Reported-by: Tom Richards <tom@tomrichards.net>",2123adf8e5e1c2b48791f9d22fc8c747e974180e,https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e,libtransmission/variant.c,nodeDestruct,"static void nodeDestruct(struct SaveNode* node)
{
if (node->v == &node->sorted)
{
tr_free(node->sorted.val.l.vals);
}
}","static void nodeDestruct(struct SaveNode* VAR_0)
{
if (VAR_0->v == &VAR_0->sorted)
{
tr_free(VAR_0->sorted.val.l.vals);
}
}",transmission/2123adf8e5e1c2b48791f9d22fc8c747e974180e/variant.c/vul/before/1.json,"static void nodeDestruct(struct SaveNode* node)
{
    TR_ASSERT(node != NULL);

    if (node->sorted != NULL)
    {
        tr_free(node->sorted->val.l.vals);
        tr_free(node->sorted);
    }
}","static void nodeDestruct(struct SaveNode* VAR_0)
{
    TR_ASSERT(VAR_0 != NULL);

    if (VAR_0->sorted != NULL)
    {
        tr_free(VAR_0->sorted->val.l.vals);
        tr_free(VAR_0->sorted);
    }
}",transmission/2123adf8e5e1c2b48791f9d22fc8c747e974180e/variant.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,10 @@
 static void nodeDestruct(struct SaveNode* node)
 {
-    if (node->v == &node->sorted)
+    TR_ASSERT(node != NULL);
+
+    if (node->sorted != NULL)
     {
-        tr_free(node->sorted.val.l.vals);
+        tr_free(node->sorted->val.l.vals);
+        tr_free(node->sorted);
     }
 }","{'deleted_lines': ['    if (node->v == &node->sorted)', '        tr_free(node->sorted.val.l.vals);'], 'added_lines': ['    TR_ASSERT(node != NULL);', '', '    if (node->sorted != NULL)', '        tr_free(node->sorted->val.l.vals);', '        tr_free(node->sorted);']}",True,Use-after-free in libtransmission/variant.c in Transmission before 3.00 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted torrent file.,7.8,HIGH,2,test,2019-04-28T08:27:33Z,2
CVE-2018-10756,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,transmission,"CVE-2018-10756: Fix heap-use-after-free in tr_variantWalk

In libtransmission/variant.c, function tr_variantWalk, when the variant
stack is reallocated, a pointer to the previously allocated memory
region is kept. This address is later accessed (heap use-after-free)
while walking back down the stack, causing the application to crash.
The application can be any application which uses libtransmission, such
as transmission-daemon, transmission-gtk, transmission-show, etc.

Reported-by: Tom Richards <tom@tomrichards.net>",2123adf8e5e1c2b48791f9d22fc8c747e974180e,https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e,libtransmission/variant.c,nodeConstruct,"static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)
{
node->isVisited = false;
node->childIndex = 0;
if (sort_dicts && tr_variantIsDict(v))
{
size_t const n = v->val.l.count;
struct KeyIndex* tmp = tr_new(struct KeyIndex, n);
for (size_t i = 0; i < n; i++)
{
tmp[i].val = v->val.l.vals + i;
tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);
}
qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);
tr_variantInitDict(&node->sorted, n);
for (size_t i = 0; i < n; ++i)
{
node->sorted.val.l.vals[i] = *tmp[i].val;
}
node->sorted.val.l.count = n;
tr_free(tmp);
node->v = &node->sorted;
}
else
{
node->v = v;
}
}","static void nodeConstruct(struct SaveNode* VAR_0, tr_variant const* VAR_1, bool VAR_2)
{
VAR_0->isVisited = false;
VAR_0->childIndex = 0;
if (VAR_2 && tr_variantIsDict(VAR_1))
{
size_t const VAR_3 = VAR_1->val.l.count;
struct KeyIndex* VAR_4 = tr_new(struct KeyIndex, VAR_3);
for (size_t VAR_5 = 0; VAR_5 < VAR_3; VAR_5++)
{
VAR_4[VAR_5].val = VAR_1->val.l.vals + VAR_5;
VAR_4[VAR_5].keystr = tr_quark_get_string(VAR_4[VAR_5].val->key, NULL);
}
qsort(VAR_4, VAR_3, sizeof(struct KeyIndex), VAR_6);
tr_variantInitDict(&VAR_0->sorted, VAR_3);
for (size_t VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5)
{
VAR_0->sorted.val.l.vals[VAR_5] = *VAR_4[VAR_5].val;
}
VAR_0->sorted.val.l.count = VAR_3;
tr_free(VAR_4);
VAR_0->v = &VAR_0->sorted;
}
else
{
VAR_0->v = VAR_1;
}
}",transmission/2123adf8e5e1c2b48791f9d22fc8c747e974180e/variant.c/vul/before/0.json,"static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)
{
    node->isVisited = false;
    node->childIndex = 0;

    if (sort_dicts && tr_variantIsDict(v))
    {
        /* make node->sorted a sorted version of this dictionary */

        size_t const n = v->val.l.count;
        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);

        for (size_t i = 0; i < n; i++)
        {
            tmp[i].val = v->val.l.vals + i;
            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);
        }

        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);

        node->sorted = tr_new(tr_variant, 1);
        tr_variantInitDict(node->sorted, n);

        for (size_t i = 0; i < n; ++i)
        {
            node->sorted->val.l.vals[i] = *tmp[i].val;
        }

        node->sorted->val.l.count = n;

        tr_free(tmp);

        v = node->sorted;
    }
    else
    {
        node->sorted = NULL;
    }

    node->v = v;
}","static void nodeConstruct(struct SaveNode* VAR_0, tr_variant const* VAR_1, bool VAR_2)
{
    VAR_0->isVisited = false;
    VAR_0->childIndex = 0;

    if (VAR_2 && tr_variantIsDict(VAR_1))
    {
        /* COMMENT_0 */

        size_t const VAR_3 = VAR_1->val.l.count;
        struct KeyIndex* VAR_4 = tr_new(struct KeyIndex, VAR_3);

        for (size_t VAR_5 = 0; VAR_5 < VAR_3; VAR_5++)
        {
            VAR_4[VAR_5].val = VAR_1->val.l.vals + VAR_5;
            VAR_4[VAR_5].keystr = tr_quark_get_string(VAR_4[VAR_5].val->key, NULL);
        }

        qsort(VAR_4, VAR_3, sizeof(struct KeyIndex), VAR_6);

        VAR_0->sorted = tr_new(tr_variant, 1);
        tr_variantInitDict(VAR_0->sorted, VAR_3);

        for (size_t VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5)
        {
            VAR_0->sorted->val.l.vals[VAR_5] = *VAR_4[VAR_5].val;
        }

        VAR_0->sorted->val.l.count = VAR_3;

        tr_free(VAR_4);

        VAR_1 = VAR_0->sorted;
    }
    else
    {
        VAR_0->sorted = NULL;
    }

    VAR_0->v = VAR_1;
}",transmission/2123adf8e5e1c2b48791f9d22fc8c747e974180e/variant.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,21 +18,24 @@
 
         qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);
 
-        tr_variantInitDict(&node->sorted, n);
+        node->sorted = tr_new(tr_variant, 1);
+        tr_variantInitDict(node->sorted, n);
 
         for (size_t i = 0; i < n; ++i)
         {
-            node->sorted.val.l.vals[i] = *tmp[i].val;
+            node->sorted->val.l.vals[i] = *tmp[i].val;
         }
 
-        node->sorted.val.l.count = n;
+        node->sorted->val.l.count = n;
 
         tr_free(tmp);
 
-        node->v = &node->sorted;
+        v = node->sorted;
     }
     else
     {
-        node->v = v;
+        node->sorted = NULL;
     }
+
+    node->v = v;
 }","{'deleted_lines': ['        tr_variantInitDict(&node->sorted, n);', '            node->sorted.val.l.vals[i] = *tmp[i].val;', '        node->sorted.val.l.count = n;', '        node->v = &node->sorted;', '        node->v = v;'], 'added_lines': ['        node->sorted = tr_new(tr_variant, 1);', '        tr_variantInitDict(node->sorted, n);', '            node->sorted->val.l.vals[i] = *tmp[i].val;', '        node->sorted->val.l.count = n;', '        v = node->sorted;', '        node->sorted = NULL;', '', '    node->v = v;']}",True,Use-after-free in libtransmission/variant.c in Transmission before 3.00 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted torrent file.,7.8,HIGH,2,test,2019-04-28T08:27:33Z,2
CVE-2019-11036,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,php/php-src,"Fix bug #77950 - Heap-buffer-overflow in _estrndup via exif_process_IFD_TAG

I do not completely understand what is going on there, but I am pretty
sure dir_entry <= offset_base if not a normal situation, so we better not
to rely on such dir_entry.",f80ad18afae2230c2c1802c7d829100af646874e,https://github.com/php/php-src/commit/f80ad18afae2230c2c1802c7d829100af646874e,ext/exif/exif.c,exif_process_IFD_TAG,"static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table)
{
size_t length;
unsigned int tag, format, components;
char *value_ptr, tagname[64], cbuf[32], *outside=NULL;
size_t byte_count, offset_val, fpos, fgot;
int64_t byte_count_signed;
xp_field_type *tmp_xp;
#ifdef EXIF_DEBUG
char *dump_data;
int dump_free;
#endif 
if (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""corrupt EXIF header: maximum directory nesting level reached"");
return FALSE;
}
ImageInfo->ifd_nesting_level++;
tag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);
format = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);
components = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);
if (!format || format > NUM_FORMATS) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE"", tag, exif_get_tagname(tag, tagname, -12, tag_table), format);
format = TAG_FMT_BYTE;
}
if (components < 0) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal components(%d)"", tag, exif_get_tagname(tag, tagname, -12, tag_table), components);
return FALSE;
}
byte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];
if (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal byte_count"", tag, exif_get_tagname(tag, tagname, -12, tag_table));
return FALSE;
}
byte_count = (size_t)byte_count_signed;
if (byte_count > 4) {
offset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);
value_ptr = offset_base+offset_val;
if (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {
if (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {
if (value_ptr < dir_entry) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)"", tag, exif_get_tagname(tag, tagname, -12, tag_table), offset_val, dir_entry);
} else {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)"", tag, exif_get_tagname(tag, tagname, -12, tag_table), offset_val, byte_count, offset_val+byte_count, IFDlength);
}
return FALSE;
}
if (byte_count>sizeof(cbuf)) {
value_ptr = safe_emalloc(byte_count, 1, 0);
outside = value_ptr;
} else {
memset(&cbuf, 0, sizeof(cbuf));
value_ptr = cbuf;
}
fpos = php_stream_tell(ImageInfo->infile);
php_stream_seek(ImageInfo->infile, displacement+offset_val, SEEK_SET);
fgot = php_stream_tell(ImageInfo->infile);
if (fgot!=displacement+offset_val) {
EFREE_IF(outside);
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Wrong file pointer: 0x%08X != 0x%08X"", fgot, displacement+offset_val);
return FALSE;
}
fgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);
php_stream_seek(ImageInfo->infile, fpos, SEEK_SET);
if (fgot<byte_count) {
EFREE_IF(outside);
EXIF_ERRLOG_FILEEOF(ImageInfo)
return FALSE;
}
}
} else {
value_ptr = dir_entry+8;
offset_val= value_ptr-offset_base;
}
ImageInfo->sections_found |= FOUND_ANY_TAG;
#ifdef EXIF_DEBUG
dump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr);
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s"", tag, exif_get_tagname(tag, tagname, -12, tag_table), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?""ARRAY OF "":"""", exif_get_tagformat(format), dump_data);
if (dump_free) {
efree(dump_data);
}
#endif
if (section_index==SECTION_THUMBNAIL) {
if (!ImageInfo->Thumbnail.data) {
switch(tag) {
case TAG_IMAGEWIDTH:
case TAG_COMP_IMAGE_WIDTH:
ImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_IMAGEHEIGHT:
case TAG_COMP_IMAGE_HEIGHT:
ImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_STRIP_OFFSETS:
case TAG_JPEG_INTERCHANGE_FORMAT:
ImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_STRIP_BYTE_COUNTS:
if (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {
ImageInfo->Thumbnail.filetype = ImageInfo->FileType;
} else {
ImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;
}
ImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_JPEG_INTERCHANGE_FORMAT_LEN:
if (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {
ImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;
ImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
}
break;
}
}
} else {
if (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)
switch(tag) {
case TAG_COPYRIGHT:
if (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {
if (length<byte_count-1) {
ImageInfo->CopyrightPhotographer  = estrdup(value_ptr);
ImageInfo->CopyrightEditor        = estrndup(value_ptr+length+1, byte_count-length-1);
spprintf(&ImageInfo->Copyright, 0, ""%s, %s"", ImageInfo->CopyrightPhotographer, ImageInfo->CopyrightEditor);
} else {
ImageInfo->Copyright = estrndup(value_ptr, byte_count);
}
}
break;
case TAG_USERCOMMENT:
ImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count);
break;
case TAG_XP_TITLE:
case TAG_XP_COMMENTS:
case TAG_XP_AUTHOR:
case TAG_XP_KEYWORDS:
case TAG_XP_SUBJECT:
tmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);
ImageInfo->sections_found |= FOUND_WINXP;
ImageInfo->xp_fields.list = tmp_xp;
ImageInfo->xp_fields.count++;
exif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count);
break;
case TAG_FNUMBER:
ImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_APERTURE:
case TAG_MAX_APERTURE:
if (ImageInfo->ApertureFNumber == 0) {
ImageInfo->ApertureFNumber
= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel)*log(2)*0.5);
}
break;
case TAG_SHUTTERSPEED:
if (ImageInfo->ExposureTime == 0) {
ImageInfo->ExposureTime
= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel)*log(2)));
}
break;
case TAG_EXPOSURETIME:
ImageInfo->ExposureTime = -1;
break;
case TAG_COMP_IMAGE_WIDTH:
ImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_FOCALPLANE_X_RES:
ImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_SUBJECT_DISTANCE:
ImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel);
break;
case TAG_FOCALPLANE_RESOLUTION_UNIT:
switch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel)) {
case 1: ImageInfo->FocalplaneUnits = 25.4; break; 
case 2:
ImageInfo->FocalplaneUnits = 25.4;
break;
case 3: ImageInfo->FocalplaneUnits = 10;   break;  
case 4: ImageInfo->FocalplaneUnits = 1;    break;  
case 5: ImageInfo->FocalplaneUnits = .001; break;  
}
break;
case TAG_SUB_IFD:
if (format==TAG_FMT_IFD) {
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Skip SUB IFD"");
}
break;
case TAG_MAKE:
ImageInfo->make = estrndup(value_ptr, byte_count);
break;
case TAG_MODEL:
ImageInfo->model = estrndup(value_ptr, byte_count);
break;
case TAG_MAKER_NOTE:
if (!exif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement)) {
EFREE_IF(outside);
return FALSE;
}
break;
case TAG_EXIF_IFD_POINTER:
case TAG_GPS_IFD_POINTER:
case TAG_INTEROP_IFD_POINTER:
if (ReadNextIFD) {
char *Subdir_start;
int sub_section_index = 0;
switch(tag) {
case TAG_EXIF_IFD_POINTER:
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found EXIF"");
#endif
ImageInfo->sections_found |= FOUND_EXIF;
sub_section_index = SECTION_EXIF;
break;
case TAG_GPS_IFD_POINTER:
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found GPS"");
#endif
ImageInfo->sections_found |= FOUND_GPS;
sub_section_index = SECTION_GPS;
break;
case TAG_INTEROP_IFD_POINTER:
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found INTEROPERABILITY"");
#endif
ImageInfo->sections_found |= FOUND_INTEROP;
sub_section_index = SECTION_INTEROP;
break;
}
Subdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);
if (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {
exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD Pointer"");
return FALSE;
}
if (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index)) {
return FALSE;
}
#ifdef EXIF_DEBUG
exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(sub_section_index));
#endif
}
}
}
exif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table), tag, format, components, value_ptr, byte_count);
EFREE_IF(outside);
return TRUE;
}","static int exif_process_IFD_TAG(image_info_type *VAR_0, char *VAR_1, char *VAR_2, size_t VAR_3, size_t VAR_4, int VAR_5, int VAR_6, tag_table_type VAR_7)
{
size_t VAR_8;
unsigned int VAR_9, VAR_10, VAR_11;
char *VAR_12, VAR_13[64], VAR_14[32], *VAR_15=NULL;
size_t VAR_16, VAR_17, VAR_18, VAR_19;
int64_t VAR_20;
xp_field_type *VAR_21;
#ifdef VAR_22
char *VAR_23;
int VAR_24;
#endif 
if (VAR_0->ifd_nesting_level > VAR_25) {
exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""corrupt EXIF header: maximum directory nesting level reached"");
return FALSE;
}
VAR_0->ifd_nesting_level++;
VAR_9 = php_ifd_get16u(VAR_1, VAR_0->motorola_intel);
VAR_10 = php_ifd_get16u(VAR_1+2, VAR_0->motorola_intel);
VAR_11 = php_ifd_get32u(VAR_1+4, VAR_0->motorola_intel);
if (!VAR_10 || VAR_10 > VAR_28) {
exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_10);
VAR_10 = VAR_29;
}
if (VAR_11 < 0) {
exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal components(%d)"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_11);
return FALSE;
}
VAR_20 = (int64_t)VAR_11 * VAR_30[VAR_10];
if (VAR_20 < 0 || (VAR_20 > VAR_31)) {
exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal byte_count"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7));
return FALSE;
}
VAR_16 = (size_t)VAR_20;
if (VAR_16 > 4) {
VAR_17 = php_ifd_get32u(VAR_1+8, VAR_0->motorola_intel);
VAR_12 = VAR_2+VAR_17;
if (VAR_16 > VAR_3 || VAR_17 > VAR_3-VAR_16 || VAR_12 < VAR_1 || VAR_17 < (size_t)(VAR_1-VAR_2)) {
if (VAR_16 > VAR_0->FileSize || VAR_17>VAR_0->FileSize-VAR_16 || (VAR_0->FileType!=VAR_32 && VAR_0->FileType!=VAR_33 && VAR_0->FileType!=VAR_34)) {
if (VAR_12 < VAR_1) {
exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_17, VAR_1);
} else {
exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_17, VAR_16, VAR_17+VAR_16, VAR_3);
}
return FALSE;
}
if (VAR_16>sizeof(VAR_14)) {
VAR_12 = safe_emalloc(VAR_16, 1, 0);
VAR_15 = VAR_12;
} else {
memset(&VAR_14, 0, sizeof(VAR_14));
VAR_12 = VAR_14;
}
VAR_18 = php_stream_tell(VAR_0->infile);
php_stream_seek(VAR_0->infile, VAR_4+VAR_17, VAR_35);
VAR_19 = php_stream_tell(VAR_0->infile);
if (VAR_19!=VAR_4+VAR_17) {
EFREE_IF(VAR_15);
VAR_36(NULL VAR_26, VAR_0, VAR_27, ""Wrong file pointer: 0x%08X != 0x%08X"", VAR_19, VAR_4+VAR_17);
return FALSE;
}
VAR_19 = php_stream_read(VAR_0->infile, VAR_12, VAR_16);
php_stream_seek(VAR_0->infile, VAR_18, VAR_35);
if (VAR_19<VAR_16) {
EFREE_IF(VAR_15);
VAR_37(ImageInfo)
return VAR_38;
}
}
} else {
VAR_12 = VAR_1+8;
VAR_17= VAR_12-VAR_2;
}
ImageInfo->sections_found |= VAR_39;
#ifdef VAR_22
VAR_23 = exif_dump_data(&VAR_24, VAR_10, VAR_11, VAR_8, ImageInfo->motorola_intel, VAR_12);
VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_17+VAR_4, VAR_16, VAR_16, (VAR_11>1)&&VAR_10!=VAR_41&&VAR_10!=VAR_42?""ARRAY OF "":"""", exif_get_tagformat(VAR_10), VAR_23);
if (VAR_24) {
efree(VAR_23);
}
#endif
if (VAR_5==VAR_43) {
if (!ImageInfo->Thumbnail.data) {
switch(VAR_9) {
case VAR_44:
case VAR_45:
ImageInfo->Thumbnail.width = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_46:
case VAR_47:
ImageInfo->Thumbnail.height = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_48:
case VAR_49:
ImageInfo->Thumbnail.offset = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_50:
if (ImageInfo->FileType == VAR_32 || ImageInfo->FileType == VAR_33) {
ImageInfo->Thumbnail.filetype = ImageInfo->FileType;
} else {
ImageInfo->Thumbnail.filetype = VAR_33;
}
ImageInfo->Thumbnail.size = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_51:
if (ImageInfo->Thumbnail.filetype == VAR_52) {
ImageInfo->Thumbnail.filetype = VAR_34;
ImageInfo->Thumbnail.size = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
}
break;
}
}
} else {
if (VAR_5==VAR_53 || VAR_5==VAR_54)
switch(VAR_9) {
case VAR_55:
if (VAR_16>1 && (VAR_8=php_strnlen(VAR_12, VAR_16)) > 0) {
if (VAR_8<VAR_16-1) {
ImageInfo->CopyrightPhotographer  = estrdup(VAR_12);
ImageInfo->CopyrightEditor        = estrndup(VAR_12+VAR_8+1, VAR_16-VAR_8-1);
spprintf(&ImageInfo->Copyright, 0, ""%s, %s"", ImageInfo->CopyrightPhotographer, ImageInfo->CopyrightEditor);
} else {
ImageInfo->Copyright = estrndup(VAR_12, VAR_16);
}
}
break;
case VAR_56:
ImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), VAR_12, VAR_16);
break;
case VAR_57:
case VAR_58:
case VAR_59:
case VAR_60:
case VAR_61:
VAR_21 = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);
ImageInfo->sections_found |= VAR_62;
ImageInfo->xp_fields.list = VAR_21;
ImageInfo->xp_fields.count++;
exif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), VAR_9, VAR_12, VAR_16);
break;
case VAR_63:
ImageInfo->ApertureFNumber = (float)exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_64:
case VAR_65:
if (ImageInfo->ApertureFNumber == 0) {
ImageInfo->ApertureFNumber
= (float)exp(exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel)*log(2)*0.5);
}
break;
case VAR_66:
if (ImageInfo->ExposureTime == 0) {
ImageInfo->ExposureTime
= (float)(1/exp(exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel)*log(2)));
}
break;
case VAR_67:
ImageInfo->ExposureTime = -1;
break;
case VAR_45:
ImageInfo->ExifImageWidth = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_68:
ImageInfo->FocalplaneXRes = exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_69:
ImageInfo->Distance = (float)exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel);
break;
case VAR_70:
switch((int)exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel)) {
case 1: ImageInfo->FocalplaneUnits = 25.4; break; 
case 2:
ImageInfo->FocalplaneUnits = 25.4;
break;
case 3: ImageInfo->FocalplaneUnits = 10;   break;  
case 4: ImageInfo->FocalplaneUnits = 1;    break;  
case 5: ImageInfo->FocalplaneUnits = .001; break;  
}
break;
case VAR_71:
if (VAR_10==VAR_72) {
VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_73 VAR_74 VAR_75"");
}
break;
case VAR_76:
ImageInfo->make = estrndup(VAR_12, VAR_16);
break;
case VAR_77:
ImageInfo->model = estrndup(VAR_12, VAR_16);
break;
case VAR_78:
if (!exif_process_IFD_in_MAKERNOTE(ImageInfo, VAR_12, VAR_16, VAR_2, VAR_3, VAR_4)) {
EFREE_IF(VAR_15);
return FALSE;
}
break;
case VAR_79:
case VAR_80:
case VAR_81:
if (VAR_6) {
char *VAR_82;
int VAR_83 = 0;
switch(VAR_9) {
case VAR_79:
#ifdef VAR_22
VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_84 VAR_85"");
#endif
ImageInfo->sections_found |= VAR_86;
VAR_83 = VAR_54;
break;
case VAR_80:
#ifdef VAR_22
VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_84 VAR_87"");
#endif
ImageInfo->sections_found |= VAR_88;
VAR_83 = VAR_89;
break;
case VAR_81:
#ifdef VAR_22
VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_84 VAR_90"");
#endif
ImageInfo->sections_found |= VAR_91;
VAR_83 = VAR_92;
break;
}
VAR_82 = VAR_2 + php_ifd_get32u(VAR_12, ImageInfo->motorola_intel);
if (VAR_82 < VAR_2 || VAR_82 > VAR_2+VAR_3) {
VAR_36(""exif_read_data#error_ifd"" VAR_26, ImageInfo, VAR_27, ""Illegal IFD Pointer"");
return FALSE;
}
if (!exif_process_IFD_in_JPEG(ImageInfo, VAR_82, VAR_2, VAR_3, VAR_4, VAR_83)) {
return FALSE;
}
#ifdef VAR_22
VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_93 %VAR_94 VAR_95"", exif_get_sectionname(sub_section_index));
#endif
}
}
}
exif_iif_add_tag(ImageInfo, VAR_5, exif_get_tagname(VAR_9, VAR_13, sizeof(VAR_13), VAR_7), VAR_9, VAR_10, VAR_11, VAR_12, VAR_16);
EFREE_IF(VAR_15);
return TRUE;
}",php/php-src/f80ad18afae2230c2c1802c7d829100af646874e/exif.c/vul/before/0.json,"static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table)
{
	size_t length;
	unsigned int tag, format, components;
	char *value_ptr, tagname[64], cbuf[32], *outside=NULL;
	size_t byte_count, offset_val, fpos, fgot;
	int64_t byte_count_signed;
	xp_field_type *tmp_xp;
#ifdef EXIF_DEBUG
	char *dump_data;
	int dump_free;
#endif /* EXIF_DEBUG */

	/* Protect against corrupt headers */
	if (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {
		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""corrupt EXIF header: maximum directory nesting level reached"");
		return FALSE;
	}
	ImageInfo->ifd_nesting_level++;

	tag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);
	format = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);
	components = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);

	if (!format || format > NUM_FORMATS) {
		/* (-1) catches illegal zero case as unsigned underflows to positive large. */
		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE"", tag, exif_get_tagname(tag, tagname, -12, tag_table), format);
		format = TAG_FMT_BYTE;
		/*return TRUE;*/
	}

	if (components < 0) {
		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal components(%d)"", tag, exif_get_tagname(tag, tagname, -12, tag_table), components);
		return FALSE;
	}

	byte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];

	if (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {
		exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal byte_count"", tag, exif_get_tagname(tag, tagname, -12, tag_table));
		return FALSE;
	}

	byte_count = (size_t)byte_count_signed;

	if (byte_count > 4) {
		offset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);
		/* If its bigger than 4 bytes, the dir entry contains an offset. */
		value_ptr = offset_base+offset_val;
        /*
            dir_entry is ImageInfo->file.list[sn].data+2+i*12
            offset_base is ImageInfo->file.list[sn].data-dir_offset
            dir_entry - offset_base is dir_offset+2+i*12
        */
		if (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base) || dir_entry <= offset_base) {
			/* It is important to check for IMAGE_FILETYPE_TIFF
			 * JPEG does not use absolute pointers instead its pointers are
			 * relative to the start of the TIFF header in APP1 section. */
			if (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {
				if (value_ptr < dir_entry) {
					/* we can read this if offset_val > 0 */
					/* some files have their values in other parts of the file */
					exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)"", tag, exif_get_tagname(tag, tagname, -12, tag_table), offset_val, dir_entry);
				} else {
					/* this is for sure not allowed */
					/* exception are IFD pointers */
					exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)"", tag, exif_get_tagname(tag, tagname, -12, tag_table), offset_val, byte_count, offset_val+byte_count, IFDlength);
				}
				return FALSE;
			}
			if (byte_count>sizeof(cbuf)) {
				/* mark as outside range and get buffer */
				value_ptr = safe_emalloc(byte_count, 1, 0);
				outside = value_ptr;
			} else {
				/* In most cases we only access a small range so
				 * it is faster to use a static buffer there
				 * BUT it offers also the possibility to have
				 * pointers read without the need to free them
				 * explicitley before returning. */
				memset(&cbuf, 0, sizeof(cbuf));
				value_ptr = cbuf;
			}

			fpos = php_stream_tell(ImageInfo->infile);
			php_stream_seek(ImageInfo->infile, displacement+offset_val, SEEK_SET);
			fgot = php_stream_tell(ImageInfo->infile);
			if (fgot!=displacement+offset_val) {
				EFREE_IF(outside);
				exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, ""Wrong file pointer: 0x%08X != 0x%08X"", fgot, displacement+offset_val);
				return FALSE;
			}
			fgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);
			php_stream_seek(ImageInfo->infile, fpos, SEEK_SET);
			if (fgot<byte_count) {
				EFREE_IF(outside);
				EXIF_ERRLOG_FILEEOF(ImageInfo)
				return FALSE;
			}
		}
	} else {
		/* 4 bytes or less and value is in the dir entry itself */
		value_ptr = dir_entry+8;
		offset_val= value_ptr-offset_base;
	}

	ImageInfo->sections_found |= FOUND_ANY_TAG;
#ifdef EXIF_DEBUG
	dump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr);
	exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s"", tag, exif_get_tagname(tag, tagname, -12, tag_table), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?""ARRAY OF "":"""", exif_get_tagformat(format), dump_data);
	if (dump_free) {
		efree(dump_data);
	}
#endif

	if (section_index==SECTION_THUMBNAIL) {
		if (!ImageInfo->Thumbnail.data) {
			switch(tag) {
				case TAG_IMAGEWIDTH:
				case TAG_COMP_IMAGE_WIDTH:
					ImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
					break;

				case TAG_IMAGEHEIGHT:
				case TAG_COMP_IMAGE_HEIGHT:
					ImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
					break;

				case TAG_STRIP_OFFSETS:
				case TAG_JPEG_INTERCHANGE_FORMAT:
					/* accept both formats */
					ImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
					break;

				case TAG_STRIP_BYTE_COUNTS:
					if (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {
						ImageInfo->Thumbnail.filetype = ImageInfo->FileType;
					} else {
						/* motorola is easier to read */
						ImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;
					}
					ImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
					break;

				case TAG_JPEG_INTERCHANGE_FORMAT_LEN:
					if (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {
						ImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;
						ImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
					}
					break;
			}
		}
	} else {
		if (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)
		switch(tag) {
			case TAG_COPYRIGHT:
				/* check for ""<photographer> NUL <editor> NUL"" */
				if (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {
					if (length<byte_count-1) {
						/* When there are any characters after the first NUL */
						ImageInfo->CopyrightPhotographer  = estrdup(value_ptr);
						ImageInfo->CopyrightEditor        = estrndup(value_ptr+length+1, byte_count-length-1);
						spprintf(&ImageInfo->Copyright, 0, ""%s, %s"", ImageInfo->CopyrightPhotographer, ImageInfo->CopyrightEditor);
						/* format = TAG_FMT_UNDEFINED; this musn't be ASCII         */
						/* but we are not supposed to change this                   */
						/* keep in mind that image_info does not store editor value */
					} else {
						ImageInfo->Copyright = estrndup(value_ptr, byte_count);
					}
				}
				break;

			case TAG_USERCOMMENT:
				ImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count);
				break;

			case TAG_XP_TITLE:
			case TAG_XP_COMMENTS:
			case TAG_XP_AUTHOR:
			case TAG_XP_KEYWORDS:
			case TAG_XP_SUBJECT:
				tmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);
				ImageInfo->sections_found |= FOUND_WINXP;
				ImageInfo->xp_fields.list = tmp_xp;
				ImageInfo->xp_fields.count++;
				exif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count);
				break;

			case TAG_FNUMBER:
				/* Simplest way of expressing aperture, so I trust it the most.
				   (overwrite previously computed value if there is one) */
				ImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel);
				break;

			case TAG_APERTURE:
			case TAG_MAX_APERTURE:
				/* More relevant info always comes earlier, so only use this field if we don't
				   have appropriate aperture information yet. */
				if (ImageInfo->ApertureFNumber == 0) {
					ImageInfo->ApertureFNumber
						= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel)*log(2)*0.5);
				}
				break;

			case TAG_SHUTTERSPEED:
				/* More complicated way of expressing exposure time, so only use
				   this value if we don't already have it from somewhere else.
				   SHUTTERSPEED comes after EXPOSURE TIME
				  */
				if (ImageInfo->ExposureTime == 0) {
					ImageInfo->ExposureTime
						= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel)*log(2)));
				}
				break;
			case TAG_EXPOSURETIME:
				ImageInfo->ExposureTime = -1;
				break;

			case TAG_COMP_IMAGE_WIDTH:
				ImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel);
				break;

			case TAG_FOCALPLANE_X_RES:
				ImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel);
				break;

			case TAG_SUBJECT_DISTANCE:
				/* Inidcates the distacne the autofocus camera is focused to.
				   Tends to be less accurate as distance increases. */
				ImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel);
				break;

			case TAG_FOCALPLANE_RESOLUTION_UNIT:
				switch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel)) {
					case 1: ImageInfo->FocalplaneUnits = 25.4; break; /* inch */
					case 2:
						/* According to the information I was using, 2 measn meters.
						   But looking at the Cannon powershot's files, inches is the only
						   sensible value. */
						ImageInfo->FocalplaneUnits = 25.4;
						break;

					case 3: ImageInfo->FocalplaneUnits = 10;   break;  /* centimeter */
					case 4: ImageInfo->FocalplaneUnits = 1;    break;  /* milimeter  */
					case 5: ImageInfo->FocalplaneUnits = .001; break;  /* micrometer */
				}
				break;

			case TAG_SUB_IFD:
				if (format==TAG_FMT_IFD) {
					/* If this is called we are either in a TIFFs thumbnail or a JPEG where we cannot handle it */
					/* TIFF thumbnail: our data structure cannot store a thumbnail of a thumbnail */
					/* JPEG do we have the data area and what to do with it */
					exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Skip SUB IFD"");
				}
				break;

			case TAG_MAKE:
				ImageInfo->make = estrndup(value_ptr, byte_count);
				break;
			case TAG_MODEL:
				ImageInfo->model = estrndup(value_ptr, byte_count);
				break;

			case TAG_MAKER_NOTE:
				if (!exif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement)) {
					EFREE_IF(outside);
					return FALSE;
				}
				break;

			case TAG_EXIF_IFD_POINTER:
			case TAG_GPS_IFD_POINTER:
			case TAG_INTEROP_IFD_POINTER:
				if (ReadNextIFD) {
					char *Subdir_start;
					int sub_section_index = 0;
					switch(tag) {
						case TAG_EXIF_IFD_POINTER:
#ifdef EXIF_DEBUG
							exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found EXIF"");
#endif
							ImageInfo->sections_found |= FOUND_EXIF;
							sub_section_index = SECTION_EXIF;
							break;
						case TAG_GPS_IFD_POINTER:
#ifdef EXIF_DEBUG
							exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found GPS"");
#endif
							ImageInfo->sections_found |= FOUND_GPS;
							sub_section_index = SECTION_GPS;
							break;
						case TAG_INTEROP_IFD_POINTER:
#ifdef EXIF_DEBUG
							exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Found INTEROPERABILITY"");
#endif
							ImageInfo->sections_found |= FOUND_INTEROP;
							sub_section_index = SECTION_INTEROP;
							break;
					}
					Subdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);
					if (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {
						exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD Pointer"");
						return FALSE;
					}
					if (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index)) {
						return FALSE;
					}
#ifdef EXIF_DEBUG
					exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(sub_section_index));
#endif
				}
		}
	}
	exif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table), tag, format, components, value_ptr, byte_count);
	EFREE_IF(outside);
	return TRUE;
}","static int exif_process_IFD_TAG(image_info_type *VAR_0, char *VAR_1, char *VAR_2, size_t VAR_3, size_t VAR_4, int VAR_5, int VAR_6, tag_table_type VAR_7)
{
	size_t VAR_8;
	unsigned int VAR_9, VAR_10, VAR_11;
	char *VAR_12, VAR_13[64], VAR_14[32], *VAR_15=NULL;
	size_t VAR_16, VAR_17, VAR_18, VAR_19;
	int64_t VAR_20;
	xp_field_type *VAR_21;
#ifdef VAR_22
	char *VAR_23;
	int VAR_24;
#endif /* COMMENT_0 */

	/* COMMENT_1 */
	if (VAR_0->ifd_nesting_level > VAR_25) {
		exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""corrupt EXIF header: maximum directory nesting level reached"");
		return FALSE;
	}
	VAR_0->ifd_nesting_level++;

	VAR_9 = php_ifd_get16u(VAR_1, VAR_0->motorola_intel);
	VAR_10 = php_ifd_get16u(VAR_1+2, VAR_0->motorola_intel);
	VAR_11 = php_ifd_get32u(VAR_1+4, VAR_0->motorola_intel);

	if (!VAR_10 || VAR_10 > VAR_28) {
		/* COMMENT_2 */
		exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_10);
		VAR_10 = VAR_29;
		/* COMMENT_3 */
	}

	if (VAR_11 < 0) {
		exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal components(%d)"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_11);
		return FALSE;
	}

	VAR_20 = (int64_t)VAR_11 * VAR_30[VAR_10];

	if (VAR_20 < 0 || (VAR_20 > VAR_31)) {
		exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal byte_count"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7));
		return FALSE;
	}

	VAR_16 = (size_t)VAR_20;

	if (VAR_16 > 4) {
		VAR_17 = php_ifd_get32u(VAR_1+8, VAR_0->motorola_intel);
		/* COMMENT_4 */
		VAR_12 = VAR_2+VAR_17;
        /* COMMENT_5 */
                                                             
                                                                   
                                                        
          
		if (VAR_16 > VAR_3 || VAR_17 > VAR_3-VAR_16 || VAR_12 < VAR_1 || VAR_17 < (size_t)(VAR_1-VAR_2) || VAR_1 <= VAR_2) {
			/* COMMENT_10 */
                                                                  
                                                                  
			if (VAR_16 > VAR_0->FileSize || VAR_17>VAR_0->FileSize-VAR_16 || (VAR_0->FileType!=VAR_32 && VAR_0->FileType!=VAR_33 && VAR_0->FileType!=VAR_34)) {
				if (VAR_12 < VAR_1) {
					/* COMMENT_13 */
					/* COMMENT_14 */
					exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_17, VAR_1);
				} else {
					/* COMMENT_15 */
					/* COMMENT_16 */
					exif_error_docref(""exif_read_data#error_ifd"" VAR_26, VAR_0, VAR_27, ""Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_17, VAR_16, VAR_17+VAR_16, VAR_3);
				}
				return FALSE;
			}
			if (VAR_16>sizeof(VAR_14)) {
				/* COMMENT_17 */
				VAR_12 = safe_emalloc(VAR_16, 1, 0);
				VAR_15 = VAR_12;
			} else {
				/* COMMENT_18 */
                                                
                                                 
                                                  
                                       
				memset(&VAR_14, 0, sizeof(VAR_14));
				VAR_12 = VAR_14;
			}

			VAR_18 = php_stream_tell(VAR_0->infile);
			php_stream_seek(VAR_0->infile, VAR_4+VAR_17, VAR_35);
			VAR_19 = php_stream_tell(VAR_0->infile);
			if (VAR_19!=VAR_4+VAR_17) {
				EFREE_IF(VAR_15);
				VAR_36(NULL VAR_26, VAR_0, VAR_27, ""Wrong file pointer: 0x%08X != 0x%08X"", VAR_19, VAR_4+VAR_17);
				return FALSE;
			}
			VAR_19 = php_stream_read(VAR_0->infile, VAR_12, VAR_16);
			php_stream_seek(VAR_0->infile, VAR_18, VAR_35);
			if (VAR_19<VAR_16) {
				EFREE_IF(VAR_15);
				VAR_37(ImageInfo)
				return VAR_38;
			}
		}
	} else {
		/* COMMENT_23 */
		VAR_12 = VAR_1+8;
		VAR_17= VAR_12-VAR_2;
	}

	ImageInfo->sections_found |= VAR_39;
#ifdef VAR_22
	VAR_23 = exif_dump_data(&VAR_24, VAR_10, VAR_11, VAR_8, ImageInfo->motorola_intel, VAR_12);
	VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s"", VAR_9, exif_get_tagname(VAR_9, VAR_13, -12, VAR_7), VAR_17+VAR_4, VAR_16, VAR_16, (VAR_11>1)&&VAR_10!=VAR_41&&VAR_10!=VAR_42?""ARRAY OF "":"""", exif_get_tagformat(VAR_10), VAR_23);
	if (VAR_24) {
		efree(VAR_23);
	}
#endif

	if (VAR_5==VAR_43) {
		if (!ImageInfo->Thumbnail.data) {
			switch(VAR_9) {
				case VAR_44:
				case VAR_45:
					ImageInfo->Thumbnail.width = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
					break;

				case VAR_46:
				case VAR_47:
					ImageInfo->Thumbnail.height = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
					break;

				case VAR_48:
				case VAR_49:
					/* COMMENT_24 */
					ImageInfo->Thumbnail.offset = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
					break;

				case VAR_50:
					if (ImageInfo->FileType == VAR_32 || ImageInfo->FileType == VAR_33) {
						ImageInfo->Thumbnail.filetype = ImageInfo->FileType;
					} else {
						/* COMMENT_25 */
						ImageInfo->Thumbnail.filetype = VAR_33;
					}
					ImageInfo->Thumbnail.size = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
					break;

				case VAR_51:
					if (ImageInfo->Thumbnail.filetype == VAR_52) {
						ImageInfo->Thumbnail.filetype = VAR_34;
						ImageInfo->Thumbnail.size = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
					}
					break;
			}
		}
	} else {
		if (VAR_5==VAR_53 || VAR_5==VAR_54)
		switch(VAR_9) {
			case VAR_55:
				/* COMMENT_26 */
				if (VAR_16>1 && (VAR_8=php_strnlen(VAR_12, VAR_16)) > 0) {
					if (VAR_8<VAR_16-1) {
						/* COMMENT_27 */
						ImageInfo->CopyrightPhotographer  = estrdup(VAR_12);
						ImageInfo->CopyrightEditor        = estrndup(VAR_12+VAR_8+1, VAR_16-VAR_8-1);
						spprintf(&ImageInfo->Copyright, 0, ""%s, %s"", ImageInfo->CopyrightPhotographer, ImageInfo->CopyrightEditor);
						/* COMMENT_28 */
						/* COMMENT_29 */
						/* COMMENT_30 */
					} else {
						ImageInfo->Copyright = estrndup(VAR_12, VAR_16);
					}
				}
				break;

			case VAR_56:
				ImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), VAR_12, VAR_16);
				break;

			case VAR_57:
			case VAR_58:
			case VAR_59:
			case VAR_60:
			case VAR_61:
				VAR_21 = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);
				ImageInfo->sections_found |= VAR_62;
				ImageInfo->xp_fields.list = VAR_21;
				ImageInfo->xp_fields.count++;
				exif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), VAR_9, VAR_12, VAR_16);
				break;

			case VAR_63:
				/* COMMENT_31 */
                                                               
				ImageInfo->ApertureFNumber = (float)exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel);
				break;

			case VAR_64:
			case VAR_65:
				/* COMMENT_33 */
                                                    
				if (ImageInfo->ApertureFNumber == 0) {
					ImageInfo->ApertureFNumber
						= (float)exp(exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel)*log(2)*0.5);
				}
				break;

			case VAR_66:
				/* COMMENT_35 */
                                                                  
                                             
        
				if (ImageInfo->ExposureTime == 0) {
					ImageInfo->ExposureTime
						= (float)(1/exp(exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel)*log(2)));
				}
				break;
			case VAR_67:
				ImageInfo->ExposureTime = -1;
				break;

			case VAR_45:
				ImageInfo->ExifImageWidth = exif_convert_any_to_int(VAR_12, VAR_10, ImageInfo->motorola_intel);
				break;

			case VAR_68:
				ImageInfo->FocalplaneXRes = exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel);
				break;

			case VAR_69:
				/* COMMENT_39 */
                                                          
				ImageInfo->Distance = (float)exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel);
				break;

			case VAR_70:
				switch((int)exif_convert_any_format(VAR_12, VAR_10, ImageInfo->motorola_intel)) {
					case 1: ImageInfo->FocalplaneUnits = 25.4; break; /* COMMENT_41 */
					case 2:
						/* COMMENT_42 */
                                                                        
                           
						ImageInfo->FocalplaneUnits = 25.4;
						break;

					case 3: ImageInfo->FocalplaneUnits = 10;   break;  /* COMMENT_45 */
					case 4: ImageInfo->FocalplaneUnits = 1;    break;  /* COMMENT_46 */
					case 5: ImageInfo->FocalplaneUnits = .001; break;  /* COMMENT_47 */
				}
				break;

			case VAR_71:
				if (VAR_10==VAR_72) {
					/* COMMENT_48 */
					/* COMMENT_49 */
					/* COMMENT_50 */
					VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_73 VAR_74 VAR_75"");
				}
				break;

			case VAR_76:
				ImageInfo->make = estrndup(VAR_12, VAR_16);
				break;
			case VAR_77:
				ImageInfo->model = estrndup(VAR_12, VAR_16);
				break;

			case VAR_78:
				if (!exif_process_IFD_in_MAKERNOTE(ImageInfo, VAR_12, VAR_16, VAR_2, VAR_3, VAR_4)) {
					EFREE_IF(VAR_15);
					return FALSE;
				}
				break;

			case VAR_79:
			case VAR_80:
			case VAR_81:
				if (VAR_6) {
					char *VAR_82;
					int VAR_83 = 0;
					switch(VAR_9) {
						case VAR_79:
#ifdef VAR_22
							VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_84 VAR_85"");
#endif
							ImageInfo->sections_found |= VAR_86;
							VAR_83 = VAR_54;
							break;
						case VAR_80:
#ifdef VAR_22
							VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_84 VAR_87"");
#endif
							ImageInfo->sections_found |= VAR_88;
							VAR_83 = VAR_89;
							break;
						case VAR_81:
#ifdef VAR_22
							VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_84 VAR_90"");
#endif
							ImageInfo->sections_found |= VAR_91;
							VAR_83 = VAR_92;
							break;
					}
					VAR_82 = VAR_2 + php_ifd_get32u(VAR_12, ImageInfo->motorola_intel);
					if (VAR_82 < VAR_2 || VAR_82 > VAR_2+VAR_3) {
						VAR_36(""exif_read_data#error_ifd"" VAR_26, ImageInfo, VAR_27, ""Illegal IFD Pointer"");
						return FALSE;
					}
					if (!exif_process_IFD_in_JPEG(ImageInfo, VAR_82, VAR_2, VAR_3, VAR_4, VAR_83)) {
						return FALSE;
					}
#ifdef VAR_22
					VAR_36(NULL VAR_26, ImageInfo, VAR_40, ""VAR_93 %VAR_94 VAR_95"", exif_get_sectionname(sub_section_index));
#endif
				}
		}
	}
	exif_iif_add_tag(ImageInfo, VAR_5, exif_get_tagname(VAR_9, VAR_13, sizeof(VAR_13), VAR_7), VAR_9, VAR_10, VAR_11, VAR_12, VAR_16);
	EFREE_IF(VAR_15);
	return TRUE;
}",php/php-src/f80ad18afae2230c2c1802c7d829100af646874e/exif.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -52,7 +52,7 @@
             offset_base is ImageInfo->file.list[sn].data-dir_offset
             dir_entry - offset_base is dir_offset+2+i*12
         */
-		if (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {
+		if (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base) || dir_entry <= offset_base) {
 			/* It is important to check for IMAGE_FILETYPE_TIFF
 			 * JPEG does not use absolute pointers instead its pointers are
 			 * relative to the start of the TIFF header in APP1 section. */","{'deleted_lines': ['\t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {'], 'added_lines': ['\t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base) || dir_entry <= offset_base) {']}",True,"When processing certain files, PHP EXIF extension in versions 7.1.x below 7.1.29, 7.2.x below 7.2.18 and 7.3.x below 7.3.5 can be caused to read past allocated buffer in exif_process_IFD_TAG function. This may lead to information disclosure or crash.",9.1,CRITICAL,3,test,2019-04-30T06:38:12Z,2
CVE-2019-20398,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,CESNET/libyang,"schema tree BUGFIX do not copy unresolved exts in groupings restrictions

Fixes #773",7852b272ef77f8098c35deea6c6f09cb78176f08,https://github.com/CESNET/libyang/commit/7852b272ef77f8098c35deea6c6f09cb78176f08,src/tree_schema.c,lys_restr_dup,"static struct lys_restr *
lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)
{
struct lys_restr *result;
int i;
if (!size) {
return NULL;
}
result = calloc(size, sizeof *result);
LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);
for (i = 0; i < size; i++) {
result[i].ext_size = old[i].ext_size;
lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);
result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);
result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);
result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);
result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);
result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);
}
return result;
}","static struct lys_restr *
lys_restr_dup(struct lys_module *VAR_0, struct lys_restr *VAR_1, int VAR_2, int VAR_3, struct unres_schema *VAR_4)
{
struct lys_restr *VAR_5;
int VAR_6;
if (!VAR_2) {
return NULL;
}
VAR_5 = calloc(VAR_2, sizeof *VAR_5);
LY_CHECK_ERR_RETURN(!VAR_5, LOGMEM(VAR_0->ctx), NULL);
for (VAR_6 = 0; VAR_6 < VAR_2; VAR_6++) {
VAR_5[VAR_6].ext_size = VAR_1[VAR_6].ext_size;
lys_ext_dup(VAR_0->ctx, VAR_0, VAR_1[VAR_6].ext, VAR_1[VAR_6].ext_size, &VAR_5[VAR_6], VAR_7, &VAR_5[VAR_6].ext, VAR_3, VAR_4);
VAR_5[VAR_6].expr = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].expr, 0);
VAR_5[VAR_6].dsc = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].dsc, 0);
VAR_5[VAR_6].ref = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].ref, 0);
VAR_5[VAR_6].eapptag = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].eapptag, 0);
VAR_5[VAR_6].emsg = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].emsg, 0);
}
return VAR_5;
}",CESNET/libyang/7852b272ef77f8098c35deea6c6f09cb78176f08/tree_schema.c/vul/before/0.json,"static struct lys_restr *
lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)
{
    struct lys_restr *result;
    int i;

    if (!size) {
        return NULL;
    }

    result = calloc(size, sizeof *result);
    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);

    for (i = 0; i < size; i++) {
        /* copying unresolved extensions is not supported */
        if (unres_schema_find(unres, -1, (void *)&old[i].ext, UNRES_EXT) == -1) {
            result[i].ext_size = old[i].ext_size;
            lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);
        }
        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);
        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);
        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);
        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);
        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);
    }

    return result;
}","static struct lys_restr *
lys_restr_dup(struct lys_module *VAR_0, struct lys_restr *VAR_1, int VAR_2, int VAR_3, struct unres_schema *VAR_4)
{
    struct lys_restr *VAR_5;
    int VAR_6;

    if (!VAR_2) {
        return NULL;
    }

    VAR_5 = calloc(VAR_2, sizeof *VAR_5);
    LY_CHECK_ERR_RETURN(!VAR_5, LOGMEM(VAR_0->ctx), NULL);

    for (VAR_6 = 0; VAR_6 < VAR_2; VAR_6++) {
        /* COMMENT_0 */
        if (unres_schema_find(VAR_4, -1, (void *)&VAR_1[VAR_6].ext, VAR_7) == -1) {
            VAR_5[VAR_6].ext_size = VAR_1[VAR_6].ext_size;
            lys_ext_dup(VAR_0->ctx, VAR_0, VAR_1[VAR_6].ext, VAR_1[VAR_6].ext_size, &VAR_5[VAR_6], VAR_8, &VAR_5[VAR_6].ext, VAR_3, VAR_4);
        }
        VAR_5[VAR_6].expr = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].expr, 0);
        VAR_5[VAR_6].dsc = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].dsc, 0);
        VAR_5[VAR_6].ref = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].ref, 0);
        VAR_5[VAR_6].eapptag = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].eapptag, 0);
        VAR_5[VAR_6].emsg = lydict_insert(VAR_0->ctx, VAR_1[VAR_6].emsg, 0);
    }

    return VAR_5;
}",CESNET/libyang/7852b272ef77f8098c35deea6c6f09cb78176f08/tree_schema.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,8 +12,11 @@
     LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);
 
     for (i = 0; i < size; i++) {
-        result[i].ext_size = old[i].ext_size;
-        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);
+        /* copying unresolved extensions is not supported */
+        if (unres_schema_find(unres, -1, (void *)&old[i].ext, UNRES_EXT) == -1) {
+            result[i].ext_size = old[i].ext_size;
+            lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);
+        }
         result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);
         result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);
         result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);","{'deleted_lines': ['        result[i].ext_size = old[i].ext_size;', '        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);'], 'added_lines': ['        /* copying unresolved extensions is not supported */', '        if (unres_schema_find(unres, -1, (void *)&old[i].ext, UNRES_EXT) == -1) {', '            result[i].ext_size = old[i].ext_size;', '            lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);', '        }']}",True,A NULL pointer dereference is present in libyang before v1.0-r3 in the function lys_extension_instances_free() due to a copy of unresolved extensions in lys_restr_dup(). Applications that use libyang to parse untrusted input yang files may crash.,6.5,MEDIUM,1,test,2019-04-30T07:25:26Z,2
CVE-2018-20196,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,knik0/faad2,"sbr_fbt: sbr->M should not exceed MAX_M

sbr->M is set by derived_frequency_table() from user-passed input
without checking for > MAX_M.

This leads to out-of-bounds accesses later, crashes and potential
security relevant issues. It should be considered a fatal error for
the SBR block.

return error code if sbr->M > MAX_M.

also, in some cases sbr_extension_data() ignores the return value of
calc_sbr_tables, probably assuming that sbr is always valid. It should
almost certainly not do that.

fixes #19 (CVE-2018-20196).",6aeeaa1af0caf986daf22852a97f7c13c5edd879,https://github.com/knik0/faad2/commit/6aeeaa1af0caf986daf22852a97f7c13c5edd879,libfaad/sbr_fbt.c,derived_frequency_table,"uint8_t derived_frequency_table(sbr_info *sbr, uint8_t bs_xover_band,
uint8_t k2)
{
uint8_t k, i;
uint32_t minus;
if (sbr->N_master <= bs_xover_band)
return 1;
sbr->N_high = sbr->N_master - bs_xover_band;
sbr->N_low = (sbr->N_high>>1) + (sbr->N_high - ((sbr->N_high>>1)<<1));
sbr->n[0] = sbr->N_low;
sbr->n[1] = sbr->N_high;
for (k = 0; k <= sbr->N_high; k++)
{
sbr->f_table_res[HI_RES][k] = sbr->f_master[k + bs_xover_band];
}
sbr->M = sbr->f_table_res[HI_RES][sbr->N_high] - sbr->f_table_res[HI_RES][0];
sbr->kx = sbr->f_table_res[HI_RES][0];
if (sbr->kx > 32)
return 1;
if (sbr->kx + sbr->M > 64)
return 1;
minus = (sbr->N_high & 1) ? 1 : 0;
for (k = 0; k <= sbr->N_low; k++)
{
if (k == 0)
i = 0;
else
i = (uint8_t)(2*k - minus);
sbr->f_table_res[LO_RES][k] = sbr->f_table_res[HI_RES][i];
}
#if 0
printf(""bs_freq_scale: %d\n"", sbr->bs_freq_scale);
printf(""bs_limiter_bands: %d\n"", sbr->bs_limiter_bands);
printf(""f_table_res[HI_RES][%d]: "", sbr->N_high);
for (k = 0; k <= sbr->N_high; k++)
{
printf(""%d "", sbr->f_table_res[HI_RES][k]);
}
printf(""\n"");
#endif
#if 0
printf(""f_table_res[LO_RES][%d]: "", sbr->N_low);
for (k = 0; k <= sbr->N_low; k++)
{
printf(""%d "", sbr->f_table_res[LO_RES][k]);
}
printf(""\n"");
#endif
sbr->N_Q = 0;
if (sbr->bs_noise_bands == 0)
{
sbr->N_Q = 1;
} else {
#if 0
sbr->N_Q = max(1, (int32_t)(sbr->bs_noise_bands*(log(k2/(float)sbr->kx)/log(2.0)) + 0.5));
#else
sbr->N_Q = (uint8_t)(max(1, find_bands(0, sbr->bs_noise_bands, sbr->kx, k2)));
#endif
sbr->N_Q = min(5, sbr->N_Q);
}
for (k = 0; k <= sbr->N_Q; k++)
{
if (k == 0)
{
i = 0;
} else {
i = i + (sbr->N_low - i)/(sbr->N_Q + 1 - k);
}
sbr->f_table_noise[k] = sbr->f_table_res[LO_RES][i];
}
for (k = 0; k < 64; k++)
{
uint8_t g;
for (g = 0; g < sbr->N_Q; g++)
{
if ((sbr->f_table_noise[g] <= k) &&
(k < sbr->f_table_noise[g+1]))
{
sbr->table_map_k_to_g[k] = g;
break;
}
}
}
#if 0
printf(""f_table_noise[%d]: "", sbr->N_Q);
for (k = 0; k <= sbr->N_Q; k++)
{
printf(""%d "", sbr->f_table_noise[k] - sbr->kx);
}
printf(""\n"");
#endif
return 0;
}","uint8_t derived_frequency_table(sbr_info *VAR_0, uint8_t VAR_1,
uint8_t VAR_2)
{
uint8_t VAR_3, VAR_4;
uint32_t VAR_5;
if (VAR_0->N_master <= VAR_1)
return 1;
VAR_0->N_high = VAR_0->N_master - VAR_1;
VAR_0->N_low = (VAR_0->N_high>>1) + (VAR_0->N_high - ((VAR_0->N_high>>1)<<1));
VAR_0->n[0] = VAR_0->N_low;
VAR_0->n[1] = VAR_0->N_high;
for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)
{
VAR_0->f_table_res[VAR_6][VAR_3] = VAR_0->f_master[VAR_3 + VAR_1];
}
VAR_0->M = VAR_0->f_table_res[VAR_6][VAR_0->N_high] - VAR_0->f_table_res[VAR_6][0];
VAR_0->kx = VAR_0->f_table_res[VAR_6][0];
if (VAR_0->kx > 32)
return 1;
if (VAR_0->kx + VAR_0->M > 64)
return 1;
VAR_5 = (VAR_0->N_high & 1) ? 1 : 0;
for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)
{
if (VAR_3 == 0)
VAR_4 = 0;
else
VAR_4 = (uint8_t)(2*VAR_3 - VAR_5);
VAR_0->f_table_res[VAR_7][VAR_3] = VAR_0->f_table_res[VAR_6][VAR_4];
}
#if 0
printf(""bs_freq_scale: %d\n"", VAR_0->bs_freq_scale);
printf(""bs_limiter_bands: %d\n"", VAR_0->bs_limiter_bands);
printf(""f_table_res[HI_RES][%d]: "", VAR_0->N_high);
for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)
{
printf(""%d "", VAR_0->f_table_res[VAR_6][VAR_3]);
}
printf(""\n"");
#endif
#if 0
printf(""f_table_res[LO_RES][%d]: "", VAR_0->N_low);
for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)
{
printf(""%d "", VAR_0->f_table_res[VAR_7][VAR_3]);
}
printf(""\n"");
#endif
VAR_0->N_Q = 0;
if (VAR_0->bs_noise_bands == 0)
{
VAR_0->N_Q = 1;
} else {
#if 0
VAR_0->N_Q = max(1, (int32_t)(VAR_0->bs_noise_bands*(log(VAR_2/(float)VAR_0->kx)/log(2.0)) + 0.5));
#else
VAR_0->N_Q = (uint8_t)(max(1, find_bands(0, VAR_0->bs_noise_bands, VAR_0->kx, VAR_2)));
#endif
VAR_0->N_Q = min(5, VAR_0->N_Q);
}
for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)
{
if (VAR_3 == 0)
{
VAR_4 = 0;
} else {
VAR_4 = VAR_4 + (VAR_0->N_low - VAR_4)/(VAR_0->N_Q + 1 - VAR_3);
}
VAR_0->f_table_noise[VAR_3] = VAR_0->f_table_res[VAR_7][VAR_4];
}
for (VAR_3 = 0; VAR_3 < 64; VAR_3++)
{
uint8_t VAR_8;
for (VAR_8 = 0; VAR_8 < VAR_0->N_Q; VAR_8++)
{
if ((VAR_0->f_table_noise[VAR_8] <= VAR_3) &&
(VAR_3 < VAR_0->f_table_noise[VAR_8+1]))
{
VAR_0->table_map_k_to_g[VAR_3] = VAR_8;
break;
}
}
}
#if 0
printf(""f_table_noise[%d]: "", VAR_0->N_Q);
for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)
{
printf(""%d "", VAR_0->f_table_noise[VAR_3] - VAR_0->kx);
}
printf(""\n"");
#endif
return 0;
}",knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_fbt.c/vul/before/0.json,"uint8_t derived_frequency_table(sbr_info *sbr, uint8_t bs_xover_band,
                                uint8_t k2)
{
    uint8_t k, i;
    uint32_t minus;

    /* The following relation shall be satisfied: bs_xover_band < N_Master */
    if (sbr->N_master <= bs_xover_band)
        return 1;

    sbr->N_high = sbr->N_master - bs_xover_band;
    sbr->N_low = (sbr->N_high>>1) + (sbr->N_high - ((sbr->N_high>>1)<<1));

    sbr->n[0] = sbr->N_low;
    sbr->n[1] = sbr->N_high;

    for (k = 0; k <= sbr->N_high; k++)
    {
        sbr->f_table_res[HI_RES][k] = sbr->f_master[k + bs_xover_band];
    }

    sbr->M = sbr->f_table_res[HI_RES][sbr->N_high] - sbr->f_table_res[HI_RES][0];
    if (sbr->M > MAX_M)
        return 1;
    sbr->kx = sbr->f_table_res[HI_RES][0];
    if (sbr->kx > 32)
        return 1;
    if (sbr->kx + sbr->M > 64)
        return 1;

    minus = (sbr->N_high & 1) ? 1 : 0;

    for (k = 0; k <= sbr->N_low; k++)
    {
        if (k == 0)
            i = 0;
        else
            i = (uint8_t)(2*k - minus);
        sbr->f_table_res[LO_RES][k] = sbr->f_table_res[HI_RES][i];
    }

#if 0
    printf(""bs_freq_scale: %d\n"", sbr->bs_freq_scale);
    printf(""bs_limiter_bands: %d\n"", sbr->bs_limiter_bands);
    printf(""f_table_res[HI_RES][%d]: "", sbr->N_high);
    for (k = 0; k <= sbr->N_high; k++)
    {
        printf(""%d "", sbr->f_table_res[HI_RES][k]);
    }
    printf(""\n"");
#endif
#if 0
    printf(""f_table_res[LO_RES][%d]: "", sbr->N_low);
    for (k = 0; k <= sbr->N_low; k++)
    {
        printf(""%d "", sbr->f_table_res[LO_RES][k]);
    }
    printf(""\n"");
#endif

    sbr->N_Q = 0;
    if (sbr->bs_noise_bands == 0)
    {
        sbr->N_Q = 1;
    } else {
#if 0
        sbr->N_Q = max(1, (int32_t)(sbr->bs_noise_bands*(log(k2/(float)sbr->kx)/log(2.0)) + 0.5));
#else
        sbr->N_Q = (uint8_t)(max(1, find_bands(0, sbr->bs_noise_bands, sbr->kx, k2)));
#endif
        sbr->N_Q = min(5, sbr->N_Q);
    }

    for (k = 0; k <= sbr->N_Q; k++)
    {
        if (k == 0)
        {
            i = 0;
        } else {
            /* i = i + (int32_t)((sbr->N_low - i)/(sbr->N_Q + 1 - k)); */
            i = i + (sbr->N_low - i)/(sbr->N_Q + 1 - k);
        }
        sbr->f_table_noise[k] = sbr->f_table_res[LO_RES][i];
    }

    /* build table for mapping k to g in hf patching */
    for (k = 0; k < 64; k++)
    {
        uint8_t g;
        for (g = 0; g < sbr->N_Q; g++)
        {
            if ((sbr->f_table_noise[g] <= k) &&
                (k < sbr->f_table_noise[g+1]))
            {
                sbr->table_map_k_to_g[k] = g;
                break;
            }
        }
    }

#if 0
    printf(""f_table_noise[%d]: "", sbr->N_Q);
    for (k = 0; k <= sbr->N_Q; k++)
    {
        printf(""%d "", sbr->f_table_noise[k] - sbr->kx);
    }
    printf(""\n"");
#endif

    return 0;
}","uint8_t derived_frequency_table(sbr_info *VAR_0, uint8_t VAR_1,
                                uint8_t VAR_2)
{
    uint8_t VAR_3, VAR_4;
    uint32_t VAR_5;

    /* COMMENT_0 */
    if (VAR_0->N_master <= VAR_1)
        return 1;

    VAR_0->N_high = VAR_0->N_master - VAR_1;
    VAR_0->N_low = (VAR_0->N_high>>1) + (VAR_0->N_high - ((VAR_0->N_high>>1)<<1));

    VAR_0->n[0] = VAR_0->N_low;
    VAR_0->n[1] = VAR_0->N_high;

    for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)
    {
        VAR_0->f_table_res[VAR_6][VAR_3] = VAR_0->f_master[VAR_3 + VAR_1];
    }

    VAR_0->M = VAR_0->f_table_res[VAR_6][VAR_0->N_high] - VAR_0->f_table_res[VAR_6][0];
    if (VAR_0->M > VAR_7)
        return 1;
    VAR_0->kx = VAR_0->f_table_res[VAR_6][0];
    if (VAR_0->kx > 32)
        return 1;
    if (VAR_0->kx + VAR_0->M > 64)
        return 1;

    VAR_5 = (VAR_0->N_high & 1) ? 1 : 0;

    for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)
    {
        if (VAR_3 == 0)
            VAR_4 = 0;
        else
            VAR_4 = (uint8_t)(2*VAR_3 - VAR_5);
        VAR_0->f_table_res[VAR_8][VAR_3] = VAR_0->f_table_res[VAR_6][VAR_4];
    }

#if 0
    printf(""bs_freq_scale: %d\n"", VAR_0->bs_freq_scale);
    printf(""bs_limiter_bands: %d\n"", VAR_0->bs_limiter_bands);
    printf(""f_table_res[HI_RES][%d]: "", VAR_0->N_high);
    for (VAR_3 = 0; VAR_3 <= VAR_0->N_high; VAR_3++)
    {
        printf(""%d "", VAR_0->f_table_res[VAR_6][VAR_3]);
    }
    printf(""\n"");
#endif
#if 0
    printf(""f_table_res[LO_RES][%d]: "", VAR_0->N_low);
    for (VAR_3 = 0; VAR_3 <= VAR_0->N_low; VAR_3++)
    {
        printf(""%d "", VAR_0->f_table_res[VAR_8][VAR_3]);
    }
    printf(""\n"");
#endif

    VAR_0->N_Q = 0;
    if (VAR_0->bs_noise_bands == 0)
    {
        VAR_0->N_Q = 1;
    } else {
#if 0
        VAR_0->N_Q = max(1, (int32_t)(VAR_0->bs_noise_bands*(log(VAR_2/(float)VAR_0->kx)/log(2.0)) + 0.5));
#else
        VAR_0->N_Q = (uint8_t)(max(1, find_bands(0, VAR_0->bs_noise_bands, VAR_0->kx, VAR_2)));
#endif
        VAR_0->N_Q = min(5, VAR_0->N_Q);
    }

    for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)
    {
        if (VAR_3 == 0)
        {
            VAR_4 = 0;
        } else {
            /* COMMENT_1 */
            VAR_4 = VAR_4 + (VAR_0->N_low - VAR_4)/(VAR_0->N_Q + 1 - VAR_3);
        }
        VAR_0->f_table_noise[VAR_3] = VAR_0->f_table_res[VAR_8][VAR_4];
    }

    /* COMMENT_2 */
    for (VAR_3 = 0; VAR_3 < 64; VAR_3++)
    {
        uint8_t VAR_9;
        for (VAR_9 = 0; VAR_9 < VAR_0->N_Q; VAR_9++)
        {
            if ((VAR_0->f_table_noise[VAR_9] <= VAR_3) &&
                (VAR_3 < VAR_0->f_table_noise[VAR_9+1]))
            {
                VAR_0->table_map_k_to_g[VAR_3] = VAR_9;
                break;
            }
        }
    }

#if 0
    printf(""f_table_noise[%d]: "", VAR_0->N_Q);
    for (VAR_3 = 0; VAR_3 <= VAR_0->N_Q; VAR_3++)
    {
        printf(""%d "", VAR_0->f_table_noise[VAR_3] - VAR_0->kx);
    }
    printf(""\n"");
#endif

    return 0;
}",knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_fbt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,6 +20,8 @@
     }
 
     sbr->M = sbr->f_table_res[HI_RES][sbr->N_high] - sbr->f_table_res[HI_RES][0];
+    if (sbr->M > MAX_M)
+        return 1;
     sbr->kx = sbr->f_table_res[HI_RES][0];
     if (sbr->kx > 32)
         return 1;","{'deleted_lines': [], 'added_lines': ['    if (sbr->M > MAX_M)', '        return 1;']}",True,There is a stack-based buffer overflow in the third instance of the calculate_gain function in libfaad/sbr_hfadj.c in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. A crafted input will lead to a denial of service or possibly unspecified other impact because the S_M array is mishandled.,7.8,HIGH,2,test,2019-05-05T09:53:01Z,2
CVE-2018-20196,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,knik0/faad2,"sbr_fbt: sbr->M should not exceed MAX_M

sbr->M is set by derived_frequency_table() from user-passed input
without checking for > MAX_M.

This leads to out-of-bounds accesses later, crashes and potential
security relevant issues. It should be considered a fatal error for
the SBR block.

return error code if sbr->M > MAX_M.

also, in some cases sbr_extension_data() ignores the return value of
calc_sbr_tables, probably assuming that sbr is always valid. It should
almost certainly not do that.

fixes #19 (CVE-2018-20196).",6aeeaa1af0caf986daf22852a97f7c13c5edd879,https://github.com/knik0/faad2/commit/6aeeaa1af0caf986daf22852a97f7c13c5edd879,libfaad/sbr_syntax.c,sbr_extension_data,"uint8_t sbr_extension_data(bitfile *ld, sbr_info *sbr, uint16_t cnt,
uint8_t psResetFlag)
{
uint8_t result = 0;
uint16_t num_align_bits = 0;
uint16_t num_sbr_bits1 = (uint16_t)faad_get_processed_bits(ld);
uint16_t num_sbr_bits2;
uint8_t saved_start_freq, saved_samplerate_mode;
uint8_t saved_stop_freq, saved_freq_scale;
uint8_t saved_alter_scale, saved_xover_band;
#if (defined(PS_DEC) || defined(DRM_PS))
if (psResetFlag)
sbr->psResetFlag = psResetFlag;
#endif
#ifdef DRM
if (!sbr->Is_DRM_SBR)
#endif
{
uint8_t bs_extension_type = (uint8_t)faad_getbits(ld, 4
DEBUGVAR(1,198,""sbr_bitstream(): bs_extension_type""));
if (bs_extension_type == EXT_SBR_DATA_CRC)
{
sbr->bs_sbr_crc_bits = (uint16_t)faad_getbits(ld, 10
DEBUGVAR(1,199,""sbr_bitstream(): bs_sbr_crc_bits""));
}
}
saved_start_freq = sbr->bs_start_freq;
saved_samplerate_mode = sbr->bs_samplerate_mode;
saved_stop_freq = sbr->bs_stop_freq;
saved_freq_scale = sbr->bs_freq_scale;
saved_alter_scale = sbr->bs_alter_scale;
saved_xover_band = sbr->bs_xover_band;
sbr->bs_header_flag = faad_get1bit(ld
DEBUGVAR(1,200,""sbr_bitstream(): bs_header_flag""));
if (sbr->bs_header_flag)
sbr_header(ld, sbr);
sbr_reset(sbr);
if (sbr->header_count != 0)
{
if (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked))
{
uint8_t rt = calc_sbr_tables(sbr, sbr->bs_start_freq, sbr->bs_stop_freq,
sbr->bs_samplerate_mode, sbr->bs_freq_scale,
sbr->bs_alter_scale, sbr->bs_xover_band);
if (rt > 0)
{
calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
saved_samplerate_mode, saved_freq_scale,
saved_alter_scale, saved_xover_band);
}
}
if (result == 0)
{
result = sbr_data(ld, sbr);
if ((result > 0) &&
(sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked)))
{
calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
saved_samplerate_mode, saved_freq_scale,
saved_alter_scale, saved_xover_band);          
}
}
} else {
result = 1;
}
num_sbr_bits2 = (uint16_t)faad_get_processed_bits(ld) - num_sbr_bits1;
if (8*cnt < num_sbr_bits2)
{
faad_resetbits(ld, num_sbr_bits1 + 8*cnt);
num_sbr_bits2 = 8*cnt;
#ifdef PS_DEC
sbr->ps_used = 0;
#endif
return 1;
}
#ifdef DRM
if (!sbr->Is_DRM_SBR)
#endif
{       
num_align_bits = 8*cnt  - num_sbr_bits2;
while (num_align_bits > 7)
{
faad_getbits(ld, 8
DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
num_align_bits -= 8;
}
faad_getbits(ld, num_align_bits
DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
}
return result;
}","uint8_t sbr_extension_data(bitfile *VAR_0, sbr_info *VAR_1, uint16_t VAR_2,
uint8_t VAR_3)
{
uint8_t VAR_4 = 0;
uint16_t VAR_5 = 0;
uint16_t VAR_6 = (uint16_t)faad_get_processed_bits(VAR_0);
uint16_t VAR_7;
uint8_t VAR_8, VAR_9;
uint8_t VAR_10, VAR_11;
uint8_t VAR_12, VAR_13;
#if (defined(VAR_14) || defined(VAR_15))
if (VAR_3)
VAR_1->psResetFlag = VAR_3;
#endif
#ifdef VAR_16
if (!VAR_1->Is_DRM_SBR)
#endif
{
uint8_t VAR_17 = (uint8_t)faad_getbits(VAR_0, 4
DEBUGVAR(1,198,""sbr_bitstream(): bs_extension_type""));
if (VAR_17 == VAR_18)
{
VAR_1->bs_sbr_crc_bits = (uint16_t)faad_getbits(VAR_0, 10
DEBUGVAR(1,199,""sbr_bitstream(): bs_sbr_crc_bits""));
}
}
VAR_8 = VAR_1->bs_start_freq;
VAR_9 = VAR_1->bs_samplerate_mode;
VAR_10 = VAR_1->bs_stop_freq;
VAR_11 = VAR_1->bs_freq_scale;
VAR_12 = VAR_1->bs_alter_scale;
VAR_13 = VAR_1->bs_xover_band;
VAR_1->bs_header_flag = faad_get1bit(VAR_0
DEBUGVAR(1,200,""sbr_bitstream(): bs_header_flag""));
if (VAR_1->bs_header_flag)
sbr_header(VAR_0, VAR_1);
sbr_reset(VAR_1);
if (VAR_1->header_count != 0)
{
if (VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked))
{
uint8_t VAR_19 = calc_sbr_tables(VAR_1, VAR_1->bs_start_freq, VAR_1->bs_stop_freq,
VAR_1->bs_samplerate_mode, VAR_1->bs_freq_scale,
VAR_1->bs_alter_scale, VAR_1->bs_xover_band);
if (VAR_19 > 0)
{
calc_sbr_tables(VAR_1, VAR_8, VAR_10,
VAR_9, VAR_11,
VAR_12, VAR_13);
}
}
if (VAR_4 == 0)
{
VAR_4 = sbr_data(VAR_0, VAR_1);
if ((VAR_4 > 0) &&
(VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked)))
{
calc_sbr_tables(VAR_1, VAR_8, VAR_10,
VAR_9, VAR_11,
VAR_12, VAR_13);          
}
}
} else {
VAR_4 = 1;
}
VAR_7 = (uint16_t)faad_get_processed_bits(VAR_0) - VAR_6;
if (8*VAR_2 < VAR_7)
{
faad_resetbits(VAR_0, VAR_6 + 8*VAR_2);
VAR_7 = 8*VAR_2;
#ifdef VAR_14
VAR_1->ps_used = 0;
#endif
return 1;
}
#ifdef VAR_16
if (!VAR_1->Is_DRM_SBR)
#endif
{       
VAR_5 = 8*VAR_2  - VAR_7;
while (VAR_5 > 7)
{
faad_getbits(VAR_0, 8
DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
VAR_5 -= 8;
}
faad_getbits(VAR_0, VAR_5
DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
}
return VAR_4;
}",knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_syntax.c/vul/before/0.json,"uint8_t sbr_extension_data(bitfile *ld, sbr_info *sbr, uint16_t cnt,
                           uint8_t psResetFlag)
{
    uint8_t result = 0;
    uint16_t num_align_bits = 0;
    uint16_t num_sbr_bits1 = (uint16_t)faad_get_processed_bits(ld);
    uint16_t num_sbr_bits2;

    uint8_t saved_start_freq, saved_samplerate_mode;
    uint8_t saved_stop_freq, saved_freq_scale;
    uint8_t saved_alter_scale, saved_xover_band;

#if (defined(PS_DEC) || defined(DRM_PS))
    if (psResetFlag)
        sbr->psResetFlag = psResetFlag;
#endif

#ifdef DRM
    if (!sbr->Is_DRM_SBR)
#endif
    {
        uint8_t bs_extension_type = (uint8_t)faad_getbits(ld, 4
            DEBUGVAR(1,198,""sbr_bitstream(): bs_extension_type""));

        if (bs_extension_type == EXT_SBR_DATA_CRC)
        {
            sbr->bs_sbr_crc_bits = (uint16_t)faad_getbits(ld, 10
                DEBUGVAR(1,199,""sbr_bitstream(): bs_sbr_crc_bits""));
        }
    }

    /* save old header values, in case the new ones are corrupted */
    saved_start_freq = sbr->bs_start_freq;
    saved_samplerate_mode = sbr->bs_samplerate_mode;
    saved_stop_freq = sbr->bs_stop_freq;
    saved_freq_scale = sbr->bs_freq_scale;
    saved_alter_scale = sbr->bs_alter_scale;
    saved_xover_band = sbr->bs_xover_band;

    sbr->bs_header_flag = faad_get1bit(ld
        DEBUGVAR(1,200,""sbr_bitstream(): bs_header_flag""));

    if (sbr->bs_header_flag)
        sbr_header(ld, sbr);

    /* Reset? */
    sbr_reset(sbr);

    /* first frame should have a header */
    //if (!(sbr->frame == 0 && sbr->bs_header_flag == 0))
    if (sbr->header_count != 0)
    {
        if (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked))
        {
            uint8_t rt = calc_sbr_tables(sbr, sbr->bs_start_freq, sbr->bs_stop_freq,
                sbr->bs_samplerate_mode, sbr->bs_freq_scale,
                sbr->bs_alter_scale, sbr->bs_xover_band);

            /* if an error occured with the new header values revert to the old ones */
            if (rt > 0)
            {
                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
                    saved_samplerate_mode, saved_freq_scale,
                    saved_alter_scale, saved_xover_band);
            }
        }

        if (result == 0)
        {
            result = sbr_data(ld, sbr);

            /* sbr_data() returning an error means that there was an error in
               envelope_time_border_vector().
               In this case the old time border vector is saved and all the previous
               data normally read after sbr_grid() is saved.
            */
            /* to be on the safe side, calculate old sbr tables in case of error */
            if ((result > 0) &&
                (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked)))
            {
                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
                    saved_samplerate_mode, saved_freq_scale,
                    saved_alter_scale, saved_xover_band);          
            }

            /* we should be able to safely set result to 0 now, */
            /* but practise indicates this doesn't work well */
        }
    } else {
        result = 1;
    }

    num_sbr_bits2 = (uint16_t)faad_get_processed_bits(ld) - num_sbr_bits1;

    /* check if we read more bits then were available for sbr */
    if (8*cnt < num_sbr_bits2)
    {
        faad_resetbits(ld, num_sbr_bits1 + 8*cnt);
        num_sbr_bits2 = 8*cnt;

#ifdef PS_DEC
        /* turn off PS for the unfortunate case that we randomly read some
         * PS data that looks correct */
        sbr->ps_used = 0;
#endif

        /* Make sure it doesn't decode SBR in this frame, or we'll get glitches */
        return 1;
    }

#ifdef DRM
    if (!sbr->Is_DRM_SBR)
#endif
    {       
        /* -4 does not apply, bs_extension_type is re-read in this function */
        num_align_bits = 8*cnt /*- 4*/ - num_sbr_bits2;

        while (num_align_bits > 7)
        {
            faad_getbits(ld, 8
                DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
            num_align_bits -= 8;
        }
        faad_getbits(ld, num_align_bits
            DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
    }

    return result;
}","uint8_t sbr_extension_data(bitfile *VAR_0, sbr_info *VAR_1, uint16_t VAR_2,
                           uint8_t VAR_3)
{
    uint8_t VAR_4 = 0;
    uint16_t VAR_5 = 0;
    uint16_t VAR_6 = (uint16_t)faad_get_processed_bits(VAR_0);
    uint16_t VAR_7;

    uint8_t VAR_8, VAR_9;
    uint8_t VAR_10, VAR_11;
    uint8_t VAR_12, VAR_13;

#if (defined(VAR_14) || defined(VAR_15))
    if (VAR_3)
        VAR_1->psResetFlag = VAR_3;
#endif

#ifdef VAR_16
    if (!VAR_1->Is_DRM_SBR)
#endif
    {
        uint8_t VAR_17 = (uint8_t)faad_getbits(VAR_0, 4
            DEBUGVAR(1,198,""sbr_bitstream(): bs_extension_type""));

        if (VAR_17 == VAR_18)
        {
            VAR_1->bs_sbr_crc_bits = (uint16_t)faad_getbits(VAR_0, 10
                DEBUGVAR(1,199,""sbr_bitstream(): bs_sbr_crc_bits""));
        }
    }

    /* COMMENT_0 */
    VAR_8 = VAR_1->bs_start_freq;
    VAR_9 = VAR_1->bs_samplerate_mode;
    VAR_10 = VAR_1->bs_stop_freq;
    VAR_11 = VAR_1->bs_freq_scale;
    VAR_12 = VAR_1->bs_alter_scale;
    VAR_13 = VAR_1->bs_xover_band;

    VAR_1->bs_header_flag = faad_get1bit(VAR_0
        DEBUGVAR(1,200,""sbr_bitstream(): bs_header_flag""));

    if (VAR_1->bs_header_flag)
        sbr_header(VAR_0, VAR_1);

    /* COMMENT_1 */
    sbr_reset(VAR_1);

    /* COMMENT_2 */
    /* COMMENT_3 */
    if (VAR_1->header_count != 0)
    {
        if (VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked))
        {
            uint8_t VAR_19 = calc_sbr_tables(VAR_1, VAR_1->bs_start_freq, VAR_1->bs_stop_freq,
                VAR_1->bs_samplerate_mode, VAR_1->bs_freq_scale,
                VAR_1->bs_alter_scale, VAR_1->bs_xover_band);

            /* COMMENT_4 */
            if (VAR_19 > 0)
            {
                VAR_4 += calc_sbr_tables(VAR_1, VAR_8, VAR_10,
                    VAR_9, VAR_11,
                    VAR_12, VAR_13);
            }
        }

        if (VAR_4 == 0)
        {
            VAR_4 = sbr_data(VAR_0, VAR_1);

            /* COMMENT_5 */
                                             
                                                                                    
                                                            
              
            /* COMMENT_10 */
            if ((VAR_4 > 0) &&
                (VAR_1->Reset || (VAR_1->bs_header_flag && VAR_1->just_seeked)))
            {
                VAR_4 += calc_sbr_tables(VAR_1, VAR_8, VAR_10,
                    VAR_9, VAR_11,
                    VAR_12, VAR_13);          
            }

            /* COMMENT_11 */
            /* COMMENT_12 */
        }
    } else {
        VAR_4 = 1;
    }

    VAR_7 = (uint16_t)faad_get_processed_bits(VAR_0) - VAR_6;

    /* COMMENT_13 */
    if (8*VAR_2 < VAR_7)
    {
        faad_resetbits(VAR_0, VAR_6 + 8*VAR_2);
        VAR_7 = 8*VAR_2;

#ifdef VAR_14
        /* COMMENT_14 */
                                        
        VAR_1->ps_used = 0;
#endif

        /* COMMENT_16 */
        return 1;
    }

#ifdef VAR_16
    if (!VAR_1->Is_DRM_SBR)
#endif
    {       
        /* COMMENT_17 */
        VAR_5 = 8*VAR_2 /* COMMENT_18 */ - VAR_7;

        while (VAR_5 > 7)
        {
            faad_getbits(VAR_0, 8
                DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
            VAR_5 -= 8;
        }
        faad_getbits(VAR_0, VAR_5
            DEBUGVAR(1,999,""sbr_bitstream(): num_align_bits""));
    }

    return VAR_4;
}",knik0/faad2/6aeeaa1af0caf986daf22852a97f7c13c5edd879/sbr_syntax.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -59,7 +59,7 @@
             /* if an error occured with the new header values revert to the old ones */
             if (rt > 0)
             {
-                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
+                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
                     saved_samplerate_mode, saved_freq_scale,
                     saved_alter_scale, saved_xover_band);
             }
@@ -78,7 +78,7 @@
             if ((result > 0) &&
                 (sbr->Reset || (sbr->bs_header_flag && sbr->just_seeked)))
             {
-                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
+                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,
                     saved_samplerate_mode, saved_freq_scale,
                     saved_alter_scale, saved_xover_band);          
             }","{'deleted_lines': ['                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,', '                calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,'], 'added_lines': ['                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,', '                result += calc_sbr_tables(sbr, saved_start_freq, saved_stop_freq,']}",True,There is a stack-based buffer overflow in the third instance of the calculate_gain function in libfaad/sbr_hfadj.c in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. A crafted input will lead to a denial of service or possibly unspecified other impact because the S_M array is mishandled.,7.8,HIGH,2,test,2019-05-05T09:53:01Z,2
CVE-2020-14976,['CWE-269'],AV:L/AC:L/Au:N/C:C/I:N/A:N,0.0,GNS3/ubridge,Hide errored line content during parsing configuration INI file on default,2eb0d1dab6a6de76cf3556130a2d52af101077db,https://github.com/GNS3/ubridge/commit/2eb0d1dab6a6de76cf3556130a2d52af101077db,src/parse.c,parse_config,"int parse_config(char *filename, bridge_t **bridges)
{
dictionary *ubridge_config = NULL;
const char *value;
const char *bridge_name;
int i, nsec;
if ((ubridge_config = iniparser_load(filename)) == NULL) {
return FALSE;
}
nsec = iniparser_getnsec(ubridge_config);
for (i = 0; i < nsec; i++) {
bridge_t *bridge;
nio_t *source_nio = NULL;
nio_t *destination_nio = NULL;
bridge_name = iniparser_getsecname(ubridge_config, i);
printf(""Parsing %s\n"", bridge_name);
if (getstr(ubridge_config, bridge_name, ""source_udp"", &value))
source_nio = create_udp_tunnel(value);
else if (getstr(ubridge_config, bridge_name, ""source_unix"", &value))
source_nio = create_unix_socket(value);
else if (getstr(ubridge_config, bridge_name, ""source_ethernet"", &value))
source_nio = open_ethernet_device(value);
else if (getstr(ubridge_config, bridge_name, ""source_tap"", &value))
source_nio = open_tap_device(value);
#ifdef LINUX_RAW
else if (getstr(ubridge_config, bridge_name, ""source_linux_raw"", &value))
source_nio = open_linux_raw(value);
#endif
#ifdef __APPLE__
else if (getstr(ubridge_config, bridge_name, ""source_fusion_vmnet"", &value))
source_nio = open_fusion_vmnet(value);
#endif
else
fprintf(stderr, ""source NIO not found\n"");
if (getstr(ubridge_config, bridge_name, ""destination_udp"", &value))
destination_nio = create_udp_tunnel(value);
else if (getstr(ubridge_config, bridge_name, ""destination_unix"", &value))
destination_nio = create_unix_socket(value);
else if (getstr(ubridge_config, bridge_name, ""destination_ethernet"", &value))
destination_nio = open_ethernet_device(value);
else if (getstr(ubridge_config, bridge_name, ""destination_tap"", &value))
destination_nio = open_tap_device(value);
#ifdef LINUX_RAW
else if (getstr(ubridge_config, bridge_name, ""destination_linux_raw"", &value))
source_nio = open_linux_raw(value);
#endif
#ifdef __APPLE__
else if (getstr(ubridge_config, bridge_name, ""destination_fusion_vmnet"", &value))
destination_nio = open_fusion_vmnet(value);
#endif
else
fprintf(stderr, ""destination NIO not found\n"");
if (source_nio && destination_nio) {
bridge = add_bridge(bridges);
bridge->source_nio = source_nio;
bridge->destination_nio = destination_nio;
if (!(bridge->name = strdup(bridge_name))) {
fprintf(stderr, ""bridge creation: insufficient memory\n"");
return FALSE;
}
parse_capture(ubridge_config, bridge_name, bridge);
parse_filter(ubridge_config, bridge_name, bridge);
}
else if (source_nio != NULL)
free_nio(source_nio);
else if (destination_nio != NULL)
free_nio(destination_nio);
}
iniparser_freedict(ubridge_config);
return TRUE;
}","int parse_config(char *VAR_0, bridge_t **VAR_1)
{
dictionary *VAR_2 = NULL;
const char *VAR_3;
const char *VAR_4;
int VAR_5, VAR_6;
if ((VAR_2 = iniparser_load(VAR_0)) == NULL) {
return FALSE;
}
VAR_6 = iniparser_getnsec(VAR_2);
for (VAR_5 = 0; VAR_5 < VAR_6; VAR_5++) {
bridge_t *VAR_7;
nio_t *VAR_8 = NULL;
nio_t *VAR_9 = NULL;
VAR_4 = iniparser_getsecname(VAR_2, VAR_5);
printf(""Parsing %s\n"", VAR_4);
if (getstr(VAR_2, VAR_4, ""source_udp"", &VAR_3))
VAR_8 = create_udp_tunnel(VAR_3);
else if (getstr(VAR_2, VAR_4, ""source_unix"", &VAR_3))
VAR_8 = create_unix_socket(VAR_3);
else if (getstr(VAR_2, VAR_4, ""source_ethernet"", &VAR_3))
VAR_8 = open_ethernet_device(VAR_3);
else if (getstr(VAR_2, VAR_4, ""source_tap"", &VAR_3))
VAR_8 = open_tap_device(VAR_3);
#ifdef VAR_10
else if (getstr(ubridge_config, bridge_name, ""source_linux_raw"", &VAR_3))
VAR_8 = open_linux_raw(VAR_3);
#endif
#ifdef VAR_11
else if (getstr(ubridge_config, bridge_name, ""source_fusion_vmnet"", &VAR_3))
VAR_8 = open_fusion_vmnet(VAR_3);
#endif
else
VAR_12(stderr, ""source NIO not found\n"");
if (getstr(ubridge_config, bridge_name, ""destination_udp"", &VAR_3))
VAR_9 = create_udp_tunnel(VAR_3);
else if (getstr(ubridge_config, bridge_name, ""destination_unix"", &VAR_3))
VAR_9 = create_unix_socket(VAR_3);
else if (getstr(ubridge_config, bridge_name, ""destination_ethernet"", &VAR_3))
VAR_9 = open_ethernet_device(VAR_3);
else if (getstr(ubridge_config, bridge_name, ""destination_tap"", &VAR_3))
VAR_9 = open_tap_device(VAR_3);
#ifdef VAR_10
else if (getstr(ubridge_config, bridge_name, ""destination_linux_raw"", &VAR_3))
VAR_8 = open_linux_raw(VAR_3);
#endif
#ifdef VAR_11
else if (getstr(ubridge_config, bridge_name, ""destination_fusion_vmnet"", &VAR_3))
VAR_9 = open_fusion_vmnet(VAR_3);
#endif
else
VAR_12(stderr, ""destination NIO not found\n"");
if (VAR_8 && VAR_9) {
VAR_7 = add_bridge(VAR_1);
VAR_7->source_nio = VAR_8;
VAR_7->destination_nio = VAR_9;
if (!(VAR_7->name = strdup(bridge_name))) {
VAR_12(stderr, ""bridge creation: insufficient memory\n"");
return FALSE;
}
parse_capture(ubridge_config, bridge_name, VAR_7);
parse_filter(ubridge_config, bridge_name, VAR_7);
}
else if (VAR_8 != NULL)
free_nio(VAR_8);
else if (VAR_9 != NULL)
free_nio(VAR_9);
}
iniparser_freedict(ubridge_config);
return TRUE;
}",GNS3/ubridge/2eb0d1dab6a6de76cf3556130a2d52af101077db/parse.c/vul/before/0.json,"int parse_config(char *filename, bridge_t **bridges)
{
    dictionary *ubridge_config = NULL;
    const char *value;
    const char *bridge_name;
    int i, nsec;

    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {
       return FALSE;
    }

    nsec = iniparser_getnsec(ubridge_config);
    for (i = 0; i < nsec; i++) {
        bridge_t *bridge;
        nio_t *source_nio = NULL;
        nio_t *destination_nio = NULL;

        bridge_name = iniparser_getsecname(ubridge_config, i);
        printf(""Parsing %s\n"", bridge_name);
        if (getstr(ubridge_config, bridge_name, ""source_udp"", &value))
           source_nio = create_udp_tunnel(value);
        else if (getstr(ubridge_config, bridge_name, ""source_unix"", &value))
           source_nio = create_unix_socket(value);
        else if (getstr(ubridge_config, bridge_name, ""source_ethernet"", &value))
           source_nio = open_ethernet_device(value);
        else if (getstr(ubridge_config, bridge_name, ""source_tap"", &value))
           source_nio = open_tap_device(value);
#ifdef LINUX_RAW
        else if (getstr(ubridge_config, bridge_name, ""source_linux_raw"", &value))
           source_nio = open_linux_raw(value);
#endif
#ifdef __APPLE__
        else if (getstr(ubridge_config, bridge_name, ""source_fusion_vmnet"", &value))
           source_nio = open_fusion_vmnet(value);
#endif
        else
           fprintf(stderr, ""source NIO not found\n"");

        if (getstr(ubridge_config, bridge_name, ""destination_udp"", &value))
           destination_nio = create_udp_tunnel(value);
        else if (getstr(ubridge_config, bridge_name, ""destination_unix"", &value))
           destination_nio = create_unix_socket(value);
        else if (getstr(ubridge_config, bridge_name, ""destination_ethernet"", &value))
           destination_nio = open_ethernet_device(value);
        else if (getstr(ubridge_config, bridge_name, ""destination_tap"", &value))
           destination_nio = open_tap_device(value);
#ifdef LINUX_RAW
        else if (getstr(ubridge_config, bridge_name, ""destination_linux_raw"", &value))
           source_nio = open_linux_raw(value);
#endif
#ifdef __APPLE__
        else if (getstr(ubridge_config, bridge_name, ""destination_fusion_vmnet"", &value))
           destination_nio = open_fusion_vmnet(value);
#endif
        else
           fprintf(stderr, ""destination NIO not found\n"");

        if (source_nio && destination_nio) {
           bridge = add_bridge(bridges);
           bridge->source_nio = source_nio;
           bridge->destination_nio = destination_nio;
           if (!(bridge->name = strdup(bridge_name))) {
              fprintf(stderr, ""bridge creation: insufficient memory\n"");
              return FALSE;
           }
           parse_capture(ubridge_config, bridge_name, bridge);
           parse_filter(ubridge_config, bridge_name, bridge);
        }
        else if (source_nio != NULL)
           free_nio(source_nio);
        else if (destination_nio != NULL)
           free_nio(destination_nio);
    }
    iniparser_freedict(ubridge_config);
    return TRUE;
}","int parse_config(char *VAR_0, bridge_t **VAR_1)
{
    dictionary *VAR_2 = NULL;
    const char *VAR_3;
    const char *VAR_4;
    int VAR_5, VAR_6;

    if ((VAR_2 = iniparser_load(VAR_0, VAR_7)) == NULL) {
       return FALSE;
    }

    VAR_6 = iniparser_getnsec(VAR_2);
    for (VAR_5 = 0; VAR_5 < VAR_6; VAR_5++) {
        bridge_t *VAR_8;
        nio_t *VAR_9 = NULL;
        nio_t *VAR_10 = NULL;

        VAR_4 = iniparser_getsecname(VAR_2, VAR_5);
        printf(""Parsing %s\n"", VAR_4);
        if (getstr(VAR_2, VAR_4, ""source_udp"", &VAR_3))
           VAR_9 = create_udp_tunnel(VAR_3);
        else if (getstr(VAR_2, VAR_4, ""source_unix"", &VAR_3))
           VAR_9 = create_unix_socket(VAR_3);
        else if (getstr(VAR_2, VAR_4, ""source_ethernet"", &VAR_3))
           VAR_9 = open_ethernet_device(VAR_3);
        else if (getstr(VAR_2, VAR_4, ""source_tap"", &VAR_3))
           VAR_9 = open_tap_device(VAR_3);
#ifdef VAR_11
        else if (getstr(ubridge_config, bridge_name, ""source_linux_raw"", &VAR_3))
           VAR_9 = open_linux_raw(VAR_3);
#endif
#ifdef VAR_12
        else if (getstr(ubridge_config, bridge_name, ""source_fusion_vmnet"", &VAR_3))
           VAR_9 = open_fusion_vmnet(VAR_3);
#endif
        else
           VAR_13(stderr, ""source NIO not found\n"");

        if (getstr(ubridge_config, bridge_name, ""destination_udp"", &VAR_3))
           VAR_10 = create_udp_tunnel(VAR_3);
        else if (getstr(ubridge_config, bridge_name, ""destination_unix"", &VAR_3))
           VAR_10 = create_unix_socket(VAR_3);
        else if (getstr(ubridge_config, bridge_name, ""destination_ethernet"", &VAR_3))
           VAR_10 = open_ethernet_device(VAR_3);
        else if (getstr(ubridge_config, bridge_name, ""destination_tap"", &VAR_3))
           VAR_10 = open_tap_device(VAR_3);
#ifdef VAR_11
        else if (getstr(ubridge_config, bridge_name, ""destination_linux_raw"", &VAR_3))
           VAR_9 = open_linux_raw(VAR_3);
#endif
#ifdef VAR_12
        else if (getstr(ubridge_config, bridge_name, ""destination_fusion_vmnet"", &VAR_3))
           VAR_10 = open_fusion_vmnet(VAR_3);
#endif
        else
           VAR_13(stderr, ""destination NIO not found\n"");

        if (VAR_9 && VAR_10) {
           VAR_8 = add_bridge(VAR_1);
           VAR_8->source_nio = VAR_9;
           VAR_8->destination_nio = VAR_10;
           if (!(VAR_8->name = strdup(bridge_name))) {
              VAR_13(stderr, ""bridge creation: insufficient memory\n"");
              return FALSE;
           }
           parse_capture(ubridge_config, bridge_name, VAR_8);
           parse_filter(ubridge_config, bridge_name, VAR_8);
        }
        else if (VAR_9 != NULL)
           free_nio(VAR_9);
        else if (VAR_10 != NULL)
           free_nio(VAR_10);
    }
    iniparser_freedict(ubridge_config);
    return TRUE;
}",GNS3/ubridge/2eb0d1dab6a6de76cf3556130a2d52af101077db/parse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
     const char *bridge_name;
     int i, nsec;
 
-    if ((ubridge_config = iniparser_load(filename)) == NULL) {
+    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {
        return FALSE;
     }
 ","{'deleted_lines': ['    if ((ubridge_config = iniparser_load(filename)) == NULL) {'], 'added_lines': ['    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {']}",True,"GNS3 ubridge through 0.9.18 on macOS, as used in GNS3 server before 2.1.17, allows a local attacker to read arbitrary files because it handles configuration-file errors by printing the configuration file while executing in a setuid root context.",5.5,MEDIUM,1,test,2019-05-08T14:48:24Z,2
CVE-2020-14976,['CWE-269'],AV:L/AC:L/Au:N/C:C/I:N/A:N,0.0,GNS3/ubridge,Hide errored line content during parsing configuration INI file on default,2eb0d1dab6a6de76cf3556130a2d52af101077db,https://github.com/GNS3/ubridge/commit/2eb0d1dab6a6de76cf3556130a2d52af101077db,src/iniparser/iniparser.c,iniparser_load,"dictionary * iniparser_load(const char * ininame)
{
FILE * in ;
char line    [ASCIILINESZ+1] ;
char section [ASCIILINESZ+1] ;
char key     [ASCIILINESZ+1] ;
char tmp     [(ASCIILINESZ * 2) + 1] ;
char val     [ASCIILINESZ+1] ;
int  last=0 ;
int  len ;
int  lineno=0 ;
int  errs=0;
dictionary * dict ;
if ((in=fopen(ininame, ""r""))==NULL) {
fprintf(stderr, ""iniparser: cannot open %s\n"", ininame);
return NULL ;
}
dict = dictionary_new(0) ;
if (!dict) {
fclose(in);
return NULL ;
}
memset(line,    0, ASCIILINESZ);
memset(section, 0, ASCIILINESZ);
memset(key,     0, ASCIILINESZ);
memset(val,     0, ASCIILINESZ);
last=0 ;
while (fgets(line+last, ASCIILINESZ-last, in)!=NULL) {
lineno++ ;
len = (int)strlen(line)-1;
if (len==0)
continue;
if (line[len]!='\n' && !feof(in)) {
fprintf(stderr,
""iniparser: input line too long in %s (%d)\n"",
ininame,
lineno);
dictionary_del(dict);
fclose(in);
return NULL ;
}
while ((len>=0) &&
((line[len]=='\n') || (isspace(line[len])))) {
line[len]=0 ;
len-- ;
}
if (len < 0) { 
len = 0;
}
if (line[len]=='\\') {
last=len ;
continue ;
} else {
last=0 ;
}
switch (iniparser_line(line, section, key, val)) {
case LINE_EMPTY:
case LINE_COMMENT:
break ;
case LINE_SECTION:
errs = dictionary_set(dict, section, NULL);
break ;
case LINE_VALUE:
sprintf(tmp, ""%s:%s"", section, key);
errs = dictionary_set(dict, tmp, val) ;
break ;
case LINE_ERROR:
fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"",
ininame,
lineno);
fprintf(stderr, ""-> %s\n"", line);
errs++ ;
break;
default:
break ;
}
memset(line, 0, ASCIILINESZ);
last=0;
if (errs<0) {
fprintf(stderr, ""iniparser: memory allocation failure\n"");
break ;
}
}
if (errs) {
dictionary_del(dict);
dict = NULL ;
}
fclose(in);
return dict ;
}","dictionary * iniparser_load(const char * VAR_0)
{
FILE * VAR_1 ;
char VAR_2    [VAR_3+1] ;
char VAR_4 [VAR_3+1] ;
char VAR_5     [VAR_3+1] ;
char VAR_6     [(VAR_3 * 2) + 1] ;
char VAR_7     [VAR_3+1] ;
int  VAR_8=0 ;
int  VAR_9 ;
int  VAR_10=0 ;
int  VAR_11=0;
dictionary * VAR_12 ;
if ((VAR_1=fopen(VAR_0, ""r""))==NULL) {
fprintf(VAR_13, ""iniparser: cannot open %s\n"", VAR_0);
return NULL ;
}
VAR_12 = dictionary_new(0) ;
if (!VAR_12) {
fclose(VAR_1);
return NULL ;
}
memset(VAR_2,    0, VAR_3);
memset(VAR_4, 0, VAR_3);
memset(VAR_5,     0, VAR_3);
memset(VAR_7,     0, VAR_3);
VAR_8=0 ;
while (fgets(VAR_2+VAR_8, VAR_3-VAR_8, VAR_1)!=NULL) {
VAR_10++ ;
VAR_9 = (int)strlen(VAR_2)-1;
if (VAR_9==0)
continue;
if (VAR_2[VAR_9]!='\n' && !feof(VAR_1)) {
fprintf(VAR_13,
""iniparser: input line too long in %s (%d)\n"",
VAR_0,
VAR_10);
dictionary_del(VAR_12);
fclose(VAR_1);
return NULL ;
}
while ((VAR_9>=0) &&
((VAR_2[VAR_9]=='\n') || (isspace(VAR_2[VAR_9])))) {
VAR_2[VAR_9]=0 ;
VAR_9-- ;
}
if (VAR_9 < 0) { 
VAR_9 = 0;
}
if (VAR_2[VAR_9]=='\\') {
VAR_8=VAR_9 ;
continue ;
} else {
VAR_8=0 ;
}
switch (iniparser_line(VAR_2, VAR_4, VAR_5, VAR_7)) {
case VAR_14:
case VAR_15:
break ;
case VAR_16:
VAR_11 = dictionary_set(VAR_12, VAR_4, NULL);
break ;
case VAR_17:
sprintf(VAR_6, ""%s:%s"", VAR_4, VAR_5);
VAR_11 = dictionary_set(VAR_12, VAR_6, VAR_7) ;
break ;
case VAR_18:
fprintf(VAR_13, ""iniparser: syntax error in %s (%d):\n"",
VAR_0,
VAR_10);
fprintf(VAR_13, ""-> %s\n"", VAR_2);
VAR_11++ ;
break;
default:
break ;
}
memset(VAR_2, 0, VAR_3);
VAR_8=0;
if (VAR_11<0) {
fprintf(VAR_13, ""iniparser: memory allocation failure\n"");
break ;
}
}
if (VAR_11) {
dictionary_del(VAR_12);
VAR_12 = NULL ;
}
fclose(VAR_1);
return VAR_12 ;
}",GNS3/ubridge/2eb0d1dab6a6de76cf3556130a2d52af101077db/iniparser.c/vul/before/0.json,"dictionary * iniparser_load(const char * ininame, load_options options)
{
    FILE * in ;

    char line    [ASCIILINESZ+1] ;
    char section [ASCIILINESZ+1] ;
    char key     [ASCIILINESZ+1] ;
    char tmp     [(ASCIILINESZ * 2) + 1] ;
    char val     [ASCIILINESZ+1] ;

    int  last=0 ;
    int  len ;
    int  lineno=0 ;
    int  errs=0;

    dictionary * dict ;

    if ((in=fopen(ininame, ""r""))==NULL) {
        fprintf(stderr, ""iniparser: cannot open %s\n"", ininame);
        return NULL ;
    }

    dict = dictionary_new(0) ;
    if (!dict) {
        fclose(in);
        return NULL ;
    }

    memset(line,    0, ASCIILINESZ);
    memset(section, 0, ASCIILINESZ);
    memset(key,     0, ASCIILINESZ);
    memset(val,     0, ASCIILINESZ);
    last=0 ;

    while (fgets(line+last, ASCIILINESZ-last, in)!=NULL) {
        lineno++ ;
        len = (int)strlen(line)-1;
        if (len==0)
            continue;
        /* Safety check against buffer overflows */
        if (line[len]!='\n' && !feof(in)) {
            fprintf(stderr,
                    ""iniparser: input line too long in %s (%d)\n"",
                    ininame,
                    lineno);
            dictionary_del(dict);
            fclose(in);
            return NULL ;
        }
        /* Get rid of \n and spaces at end of line */
        while ((len>=0) &&
                ((line[len]=='\n') || (isspace(line[len])))) {
            line[len]=0 ;
            len-- ;
        }
        if (len < 0) { /* Line was entirely \n and/or spaces */
            len = 0;
        }
        /* Detect multi-line */
        if (line[len]=='\\') {
            /* Multi-line value */
            last=len ;
            continue ;
        } else {
            last=0 ;
        }
        switch (iniparser_line(line, section, key, val)) {
            case LINE_EMPTY:
            case LINE_COMMENT:
            break ;

            case LINE_SECTION:
            errs = dictionary_set(dict, section, NULL);
            break ;

            case LINE_VALUE:
            sprintf(tmp, ""%s:%s"", section, key);
            errs = dictionary_set(dict, tmp, val) ;
            break ;

            case LINE_ERROR:

            if(options & HIDE_ERRORED_LINE_CONTENT) {
              fprintf(stderr, ""iniparser: syntax error in %s (%d)\n"",
                      ininame,
                      lineno);
            }
            else {
              fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"",
                      ininame,
                      lineno);
              fprintf(stderr, ""-> %s\n"", line);
            }
            errs++ ;
            break;

            default:
            break ;
        }
        memset(line, 0, ASCIILINESZ);
        last=0;
        if (errs<0) {
            fprintf(stderr, ""iniparser: memory allocation failure\n"");
            break ;
        }
    }
    if (errs) {
        dictionary_del(dict);
        dict = NULL ;
    }
    fclose(in);
    return dict ;
}","dictionary * iniparser_load(const char * VAR_0, load_options VAR_1)
{
    FILE * VAR_2 ;

    char VAR_3    [VAR_4+1] ;
    char VAR_5 [VAR_4+1] ;
    char VAR_6     [VAR_4+1] ;
    char VAR_7     [(VAR_4 * 2) + 1] ;
    char VAR_8     [VAR_4+1] ;

    int  VAR_9=0 ;
    int  VAR_10 ;
    int  VAR_11=0 ;
    int  VAR_12=0;

    dictionary * VAR_13 ;

    if ((VAR_2=fopen(VAR_0, ""r""))==NULL) {
        fprintf(VAR_14, ""iniparser: cannot open %s\n"", VAR_0);
        return NULL ;
    }

    VAR_13 = dictionary_new(0) ;
    if (!VAR_13) {
        fclose(VAR_2);
        return NULL ;
    }

    memset(VAR_3,    0, VAR_4);
    memset(VAR_5, 0, VAR_4);
    memset(VAR_6,     0, VAR_4);
    memset(VAR_8,     0, VAR_4);
    VAR_9=0 ;

    while (fgets(VAR_3+VAR_9, VAR_4-VAR_9, VAR_2)!=NULL) {
        VAR_11++ ;
        VAR_10 = (int)strlen(VAR_3)-1;
        if (VAR_10==0)
            continue;
        /* COMMENT_0 */
        if (VAR_3[VAR_10]!='\n' && !feof(VAR_2)) {
            fprintf(VAR_14,
                    ""iniparser: input line too long in %s (%d)\n"",
                    VAR_0,
                    VAR_11);
            dictionary_del(VAR_13);
            fclose(VAR_2);
            return NULL ;
        }
        /* COMMENT_1 */
        while ((VAR_10>=0) &&
                ((VAR_3[VAR_10]=='\n') || (isspace(VAR_3[VAR_10])))) {
            VAR_3[VAR_10]=0 ;
            VAR_10-- ;
        }
        if (VAR_10 < 0) { /* COMMENT_2 */
            VAR_10 = 0;
        }
        /* COMMENT_3 */
        if (VAR_3[VAR_10]=='\\') {
            /* COMMENT_4 */
            VAR_9=VAR_10 ;
            continue ;
        } else {
            VAR_9=0 ;
        }
        switch (iniparser_line(VAR_3, VAR_5, VAR_6, VAR_8)) {
            case VAR_15:
            case VAR_16:
            break ;

            case VAR_17:
            VAR_12 = dictionary_set(VAR_13, VAR_5, NULL);
            break ;

            case VAR_18:
            sprintf(VAR_7, ""%s:%s"", VAR_5, VAR_6);
            VAR_12 = dictionary_set(VAR_13, VAR_7, VAR_8) ;
            break ;

            case VAR_19:

            if(VAR_1 & VAR_20) {
              fprintf(VAR_14, ""iniparser: syntax error in %s (%d)\n"",
                      VAR_0,
                      VAR_11);
            }
            else {
              fprintf(VAR_14, ""iniparser: syntax error in %s (%d):\n"",
                      VAR_0,
                      VAR_11);
              fprintf(VAR_14, ""-> %s\n"", VAR_3);
            }
            VAR_12++ ;
            break;

            default:
            break ;
        }
        memset(VAR_3, 0, VAR_4);
        VAR_9=0;
        if (VAR_12<0) {
            fprintf(VAR_14, ""iniparser: memory allocation failure\n"");
            break ;
        }
    }
    if (VAR_12) {
        dictionary_del(VAR_13);
        VAR_13 = NULL ;
    }
    fclose(VAR_2);
    return VAR_13 ;
}",GNS3/ubridge/2eb0d1dab6a6de76cf3556130a2d52af101077db/iniparser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-dictionary * iniparser_load(const char * ininame)
+dictionary * iniparser_load(const char * ininame, load_options options)
 {
     FILE * in ;
 
@@ -79,10 +79,18 @@
             break ;
 
             case LINE_ERROR:
-            fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"",
-                    ininame,
-                    lineno);
-            fprintf(stderr, ""-> %s\n"", line);
+
+            if(options & HIDE_ERRORED_LINE_CONTENT) {
+              fprintf(stderr, ""iniparser: syntax error in %s (%d)\n"",
+                      ininame,
+                      lineno);
+            }
+            else {
+              fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"",
+                      ininame,
+                      lineno);
+              fprintf(stderr, ""-> %s\n"", line);
+            }
             errs++ ;
             break;
 ","{'deleted_lines': ['dictionary * iniparser_load(const char * ininame)', '            fprintf(stderr, ""iniparser: syntax error in %s (%d):\\n"",', '                    ininame,', '                    lineno);', '            fprintf(stderr, ""-> %s\\n"", line);'], 'added_lines': ['dictionary * iniparser_load(const char * ininame, load_options options)', '', '            if(options & HIDE_ERRORED_LINE_CONTENT) {', '              fprintf(stderr, ""iniparser: syntax error in %s (%d)\\n"",', '                      ininame,', '                      lineno);', '            }', '            else {', '              fprintf(stderr, ""iniparser: syntax error in %s (%d):\\n"",', '                      ininame,', '                      lineno);', '              fprintf(stderr, ""-> %s\\n"", line);', '            }']}",True,"GNS3 ubridge through 0.9.18 on macOS, as used in GNS3 server before 2.1.17, allows a local attacker to read arbitrary files because it handles configuration-file errors by printing the configuration file while executing in a setuid root context.",5.5,MEDIUM,1,test,2019-05-08T14:48:24Z,2
CVE-2019-11833,['CWE-908'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0.0,torvalds/linux,"ext4: zero out the unused memory region in the extent tree block

This commit zeroes out the unused memory region in the buffer_head
corresponding to the extent metablock after writing the extent header
and the corresponding extent node entries.

This is done to prevent random uninitialized data from getting into
the filesystem when the extent block is synced.

This fixes CVE-2019-11833.

Signed-off-by: Sriram Rajagopalan <sriramr@arista.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org",592acbf16821288ecdc4192c47e3774a4c48bb64,https://github.com/torvalds/linux/commit/592acbf16821288ecdc4192c47e3774a4c48bb64,fs/ext4/extents.c,ext4_ext_grow_indepth,"static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
unsigned int flags)
{
struct ext4_extent_header *neh;
struct buffer_head *bh;
ext4_fsblk_t newblock, goal = 0;
struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
int err = 0;
if (ext_depth(inode))
goal = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));
if (goal > le32_to_cpu(es->s_first_data_block)) {
flags |= EXT4_MB_HINT_TRY_GOAL;
goal--;
} else
goal = ext4_inode_to_goal_block(inode);
newblock = ext4_new_meta_blocks(handle, inode, goal, flags,
NULL, &err);
if (newblock == 0)
return err;
bh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);
if (unlikely(!bh))
return -ENOMEM;
lock_buffer(bh);
err = ext4_journal_get_create_access(handle, bh);
if (err) {
unlock_buffer(bh);
goto out;
}
memmove(bh->b_data, EXT4_I(inode)->i_data,
sizeof(EXT4_I(inode)->i_data));
neh = ext_block_hdr(bh);
if (ext_depth(inode))
neh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
else
neh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
neh->eh_magic = EXT4_EXT_MAGIC;
ext4_extent_block_csum_set(inode, neh);
set_buffer_uptodate(bh);
unlock_buffer(bh);
err = ext4_handle_dirty_metadata(handle, inode, bh);
if (err)
goto out;
neh = ext_inode_hdr(inode);
neh->eh_entries = cpu_to_le16(1);
ext4_idx_store_pblock(EXT_FIRST_INDEX(neh), newblock);
if (neh->eh_depth == 0) {
neh->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));
EXT_FIRST_INDEX(neh)->ei_block =
EXT_FIRST_EXTENT(neh)->ee_block;
}
ext_debug(""new root: num %d(%d), lblock %d, ptr %llu\n"",
le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),
le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),
ext4_idx_pblock(EXT_FIRST_INDEX(neh)));
le16_add_cpu(&neh->eh_depth, 1);
ext4_mark_inode_dirty(handle, inode);
out:
brelse(bh);
return err;
}","static int ext4_ext_grow_indepth(handle_t *VAR_0, struct inode *inode,
unsigned int VAR_1)
{
struct ext4_extent_header *VAR_2;
struct buffer_head *VAR_3;
ext4_fsblk_t VAR_4, VAR_5 = 0;
struct ext4_super_block *VAR_6 = EXT4_SB(inode->i_sb)->s_es;
int VAR_7 = 0;
if (ext_depth(inode))
VAR_5 = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));
if (VAR_5 > le32_to_cpu(VAR_6->s_first_data_block)) {
VAR_1 |= VAR_8;
VAR_5--;
} else
VAR_5 = ext4_inode_to_goal_block(inode);
VAR_4 = ext4_new_meta_blocks(VAR_0, inode, VAR_5, VAR_1,
NULL, &VAR_7);
if (VAR_4 == 0)
return VAR_7;
VAR_3 = sb_getblk_gfp(inode->i_sb, VAR_4, VAR_9 | VAR_10);
if (unlikely(!VAR_3))
return -VAR_11;
lock_buffer(VAR_3);
VAR_7 = ext4_journal_get_create_access(VAR_0, VAR_3);
if (VAR_7) {
unlock_buffer(VAR_3);
goto out;
}
memmove(VAR_3->b_data, EXT4_I(inode)->i_data,
sizeof(EXT4_I(inode)->i_data));
VAR_2 = ext_block_hdr(VAR_3);
if (ext_depth(inode))
VAR_2->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
else
VAR_2->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
VAR_2->eh_magic = VAR_12;
ext4_extent_block_csum_set(inode, VAR_2);
set_buffer_uptodate(VAR_3);
unlock_buffer(VAR_3);
VAR_7 = ext4_handle_dirty_metadata(VAR_0, inode, VAR_3);
if (VAR_7)
goto out;
VAR_2 = ext_inode_hdr(inode);
VAR_2->eh_entries = cpu_to_le16(1);
ext4_idx_store_pblock(EXT_FIRST_INDEX(VAR_2), VAR_4);
if (VAR_2->eh_depth == 0) {
VAR_2->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));
EXT_FIRST_INDEX(VAR_2)->ei_block =
EXT_FIRST_EXTENT(VAR_2)->ee_block;
}
ext_debug(""new root: num %d(%d), lblock %d, ptr %llu\n"",
le16_to_cpu(VAR_2->eh_entries), le16_to_cpu(VAR_2->eh_max),
le32_to_cpu(EXT_FIRST_INDEX(VAR_2)->ei_block),
ext4_idx_pblock(EXT_FIRST_INDEX(VAR_2)));
le16_add_cpu(&VAR_2->eh_depth, 1);
ext4_mark_inode_dirty(VAR_0, inode);
out:
brelse(VAR_3);
return VAR_7;
}",torvalds/linux/592acbf16821288ecdc4192c47e3774a4c48bb64/extents.c/vul/before/1.json,"static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
				 unsigned int flags)
{
	struct ext4_extent_header *neh;
	struct buffer_head *bh;
	ext4_fsblk_t newblock, goal = 0;
	struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
	int err = 0;
	size_t ext_size = 0;

	/* Try to prepend new index to old one */
	if (ext_depth(inode))
		goal = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));
	if (goal > le32_to_cpu(es->s_first_data_block)) {
		flags |= EXT4_MB_HINT_TRY_GOAL;
		goal--;
	} else
		goal = ext4_inode_to_goal_block(inode);
	newblock = ext4_new_meta_blocks(handle, inode, goal, flags,
					NULL, &err);
	if (newblock == 0)
		return err;

	bh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);
	if (unlikely(!bh))
		return -ENOMEM;
	lock_buffer(bh);

	err = ext4_journal_get_create_access(handle, bh);
	if (err) {
		unlock_buffer(bh);
		goto out;
	}

	ext_size = sizeof(EXT4_I(inode)->i_data);
	/* move top-level index/leaf into new block */
	memmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);
	/* zero out unused area in the extent block */
	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);

	/* set size of new block */
	neh = ext_block_hdr(bh);
	/* old root could have indexes or leaves
	 * so calculate e_max right way */
	if (ext_depth(inode))
		neh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
	else
		neh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
	neh->eh_magic = EXT4_EXT_MAGIC;
	ext4_extent_block_csum_set(inode, neh);
	set_buffer_uptodate(bh);
	unlock_buffer(bh);

	err = ext4_handle_dirty_metadata(handle, inode, bh);
	if (err)
		goto out;

	/* Update top-level index: num,max,pointer */
	neh = ext_inode_hdr(inode);
	neh->eh_entries = cpu_to_le16(1);
	ext4_idx_store_pblock(EXT_FIRST_INDEX(neh), newblock);
	if (neh->eh_depth == 0) {
		/* Root extent block becomes index block */
		neh->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));
		EXT_FIRST_INDEX(neh)->ei_block =
			EXT_FIRST_EXTENT(neh)->ee_block;
	}
	ext_debug(""new root: num %d(%d), lblock %d, ptr %llu\n"",
		  le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),
		  le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),
		  ext4_idx_pblock(EXT_FIRST_INDEX(neh)));

	le16_add_cpu(&neh->eh_depth, 1);
	ext4_mark_inode_dirty(handle, inode);
out:
	brelse(bh);

	return err;
}","static int ext4_ext_grow_indepth(handle_t *VAR_0, struct inode *inode,
				 unsigned int VAR_1)
{
	struct ext4_extent_header *VAR_2;
	struct buffer_head *VAR_3;
	ext4_fsblk_t VAR_4, VAR_5 = 0;
	struct ext4_super_block *VAR_6 = EXT4_SB(inode->i_sb)->s_es;
	int VAR_7 = 0;
	size_t VAR_8 = 0;

	/* COMMENT_0 */
	if (ext_depth(inode))
		VAR_5 = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));
	if (VAR_5 > le32_to_cpu(VAR_6->s_first_data_block)) {
		VAR_1 |= VAR_9;
		VAR_5--;
	} else
		VAR_5 = ext4_inode_to_goal_block(inode);
	VAR_4 = ext4_new_meta_blocks(VAR_0, inode, VAR_5, VAR_1,
					NULL, &VAR_7);
	if (VAR_4 == 0)
		return VAR_7;

	VAR_3 = sb_getblk_gfp(inode->i_sb, VAR_4, VAR_10 | VAR_11);
	if (unlikely(!VAR_3))
		return -VAR_12;
	lock_buffer(VAR_3);

	VAR_7 = ext4_journal_get_create_access(VAR_0, VAR_3);
	if (VAR_7) {
		unlock_buffer(VAR_3);
		goto out;
	}

	VAR_8 = sizeof(EXT4_I(inode)->i_data);
	/* COMMENT_1 */
	memmove(VAR_3->b_data, EXT4_I(inode)->i_data, VAR_8);
	/* COMMENT_2 */
	memset(VAR_3->b_data + VAR_8, 0, inode->i_sb->s_blocksize - VAR_8);

	/* COMMENT_3 */
	VAR_2 = ext_block_hdr(VAR_3);
	/* COMMENT_4 */
                                   
	if (ext_depth(inode))
		VAR_2->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
	else
		VAR_2->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
	VAR_2->eh_magic = VAR_13;
	ext4_extent_block_csum_set(inode, VAR_2);
	set_buffer_uptodate(VAR_3);
	unlock_buffer(VAR_3);

	VAR_7 = ext4_handle_dirty_metadata(VAR_0, inode, VAR_3);
	if (VAR_7)
		goto out;

	/* COMMENT_6 */
	VAR_2 = ext_inode_hdr(inode);
	VAR_2->eh_entries = cpu_to_le16(1);
	ext4_idx_store_pblock(EXT_FIRST_INDEX(VAR_2), VAR_4);
	if (VAR_2->eh_depth == 0) {
		/* COMMENT_7 */
		VAR_2->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));
		EXT_FIRST_INDEX(VAR_2)->ei_block =
			EXT_FIRST_EXTENT(VAR_2)->ee_block;
	}
	ext_debug(""new root: num %d(%d), lblock %d, ptr %llu\n"",
		  le16_to_cpu(VAR_2->eh_entries), le16_to_cpu(VAR_2->eh_max),
		  le32_to_cpu(EXT_FIRST_INDEX(VAR_2)->ei_block),
		  ext4_idx_pblock(EXT_FIRST_INDEX(VAR_2)));

	le16_add_cpu(&VAR_2->eh_depth, 1);
	ext4_mark_inode_dirty(VAR_0, inode);
out:
	brelse(VAR_3);

	return VAR_7;
}",torvalds/linux/592acbf16821288ecdc4192c47e3774a4c48bb64/extents.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
 	ext4_fsblk_t newblock, goal = 0;
 	struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
 	int err = 0;
+	size_t ext_size = 0;
 
 	/* Try to prepend new index to old one */
 	if (ext_depth(inode))
@@ -31,9 +32,11 @@
 		goto out;
 	}
 
+	ext_size = sizeof(EXT4_I(inode)->i_data);
 	/* move top-level index/leaf into new block */
-	memmove(bh->b_data, EXT4_I(inode)->i_data,
-		sizeof(EXT4_I(inode)->i_data));
+	memmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);
+	/* zero out unused area in the extent block */
+	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
 
 	/* set size of new block */
 	neh = ext_block_hdr(bh);","{'deleted_lines': ['\tmemmove(bh->b_data, EXT4_I(inode)->i_data,', '\t\tsizeof(EXT4_I(inode)->i_data));'], 'added_lines': ['\tsize_t ext_size = 0;', '\text_size = sizeof(EXT4_I(inode)->i_data);', '\tmemmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);', '\t/* zero out unused area in the extent block */', '\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);']}",True,"fs/ext4/extents.c in the Linux kernel through 5.1.2 does not zero out the unused memory region in the extent tree block, which might allow local users to obtain sensitive information by reading uninitialized data in the filesystem.",5.5,MEDIUM,1,test,2019-05-10T23:28:06Z,2
CVE-2019-11833,['CWE-908'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0.0,torvalds/linux,"ext4: zero out the unused memory region in the extent tree block

This commit zeroes out the unused memory region in the buffer_head
corresponding to the extent metablock after writing the extent header
and the corresponding extent node entries.

This is done to prevent random uninitialized data from getting into
the filesystem when the extent block is synced.

This fixes CVE-2019-11833.

Signed-off-by: Sriram Rajagopalan <sriramr@arista.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org",592acbf16821288ecdc4192c47e3774a4c48bb64,https://github.com/torvalds/linux/commit/592acbf16821288ecdc4192c47e3774a4c48bb64,fs/ext4/extents.c,ext4_ext_split,"static int ext4_ext_split(handle_t *handle, struct inode *inode,
unsigned int flags,
struct ext4_ext_path *path,
struct ext4_extent *newext, int at)
{
struct buffer_head *bh = NULL;
int depth = ext_depth(inode);
struct ext4_extent_header *neh;
struct ext4_extent_idx *fidx;
int i = at, k, m, a;
ext4_fsblk_t newblock, oldblock;
__le32 border;
ext4_fsblk_t *ablocks = NULL; 
int err = 0;
if (unlikely(path[depth].p_ext > EXT_MAX_EXTENT(path[depth].p_hdr))) {
EXT4_ERROR_INODE(inode, ""p_ext > EXT_MAX_EXTENT!"");
return -EFSCORRUPTED;
}
if (path[depth].p_ext != EXT_MAX_EXTENT(path[depth].p_hdr)) {
border = path[depth].p_ext[1].ee_block;
ext_debug(""leaf will be split.""
"" next leaf starts at %d\n"",
le32_to_cpu(border));
} else {
border = newext->ee_block;
ext_debug(""leaf will be added.""
"" next leaf starts at %d\n"",
le32_to_cpu(border));
}
ablocks = kcalloc(depth, sizeof(ext4_fsblk_t), GFP_NOFS);
if (!ablocks)
return -ENOMEM;
ext_debug(""allocate %d blocks for indexes/leaf\n"", depth - at);
for (a = 0; a < depth - at; a++) {
newblock = ext4_ext_new_meta_block(handle, inode, path,
newext, &err, flags);
if (newblock == 0)
goto cleanup;
ablocks[a] = newblock;
}
newblock = ablocks[--a];
if (unlikely(newblock == 0)) {
EXT4_ERROR_INODE(inode, ""newblock == 0!"");
err = -EFSCORRUPTED;
goto cleanup;
}
bh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);
if (unlikely(!bh)) {
err = -ENOMEM;
goto cleanup;
}
lock_buffer(bh);
err = ext4_journal_get_create_access(handle, bh);
if (err)
goto cleanup;
neh = ext_block_hdr(bh);
neh->eh_entries = 0;
neh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
neh->eh_magic = EXT4_EXT_MAGIC;
neh->eh_depth = 0;
if (unlikely(path[depth].p_hdr->eh_entries !=
path[depth].p_hdr->eh_max)) {
EXT4_ERROR_INODE(inode, ""eh_entries %d != eh_max %d!"",
path[depth].p_hdr->eh_entries,
path[depth].p_hdr->eh_max);
err = -EFSCORRUPTED;
goto cleanup;
}
m = EXT_MAX_EXTENT(path[depth].p_hdr) - path[depth].p_ext++;
ext4_ext_show_move(inode, path, newblock, depth);
if (m) {
struct ext4_extent *ex;
ex = EXT_FIRST_EXTENT(neh);
memmove(ex, path[depth].p_ext, sizeof(struct ext4_extent) * m);
le16_add_cpu(&neh->eh_entries, m);
}
ext4_extent_block_csum_set(inode, neh);
set_buffer_uptodate(bh);
unlock_buffer(bh);
err = ext4_handle_dirty_metadata(handle, inode, bh);
if (err)
goto cleanup;
brelse(bh);
bh = NULL;
if (m) {
err = ext4_ext_get_access(handle, inode, path + depth);
if (err)
goto cleanup;
le16_add_cpu(&path[depth].p_hdr->eh_entries, -m);
err = ext4_ext_dirty(handle, inode, path + depth);
if (err)
goto cleanup;
}
k = depth - at - 1;
if (unlikely(k < 0)) {
EXT4_ERROR_INODE(inode, ""k %d < 0!"", k);
err = -EFSCORRUPTED;
goto cleanup;
}
if (k)
ext_debug(""create %d intermediate indices\n"", k);
i = depth - 1;
while (k--) {
oldblock = newblock;
newblock = ablocks[--a];
bh = sb_getblk(inode->i_sb, newblock);
if (unlikely(!bh)) {
err = -ENOMEM;
goto cleanup;
}
lock_buffer(bh);
err = ext4_journal_get_create_access(handle, bh);
if (err)
goto cleanup;
neh = ext_block_hdr(bh);
neh->eh_entries = cpu_to_le16(1);
neh->eh_magic = EXT4_EXT_MAGIC;
neh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
neh->eh_depth = cpu_to_le16(depth - i);
fidx = EXT_FIRST_INDEX(neh);
fidx->ei_block = border;
ext4_idx_store_pblock(fidx, oldblock);
ext_debug(""int.index at %d (block %llu): %u -> %llu\n"",
i, newblock, le32_to_cpu(border), oldblock);
if (unlikely(EXT_MAX_INDEX(path[i].p_hdr) !=
EXT_LAST_INDEX(path[i].p_hdr))) {
EXT4_ERROR_INODE(inode,
""EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!"",
le32_to_cpu(path[i].p_ext->ee_block));
err = -EFSCORRUPTED;
goto cleanup;
}
m = EXT_MAX_INDEX(path[i].p_hdr) - path[i].p_idx++;
ext_debug(""cur 0x%p, last 0x%p\n"", path[i].p_idx,
EXT_MAX_INDEX(path[i].p_hdr));
ext4_ext_show_move(inode, path, newblock, i);
if (m) {
memmove(++fidx, path[i].p_idx,
sizeof(struct ext4_extent_idx) * m);
le16_add_cpu(&neh->eh_entries, m);
}
ext4_extent_block_csum_set(inode, neh);
set_buffer_uptodate(bh);
unlock_buffer(bh);
err = ext4_handle_dirty_metadata(handle, inode, bh);
if (err)
goto cleanup;
brelse(bh);
bh = NULL;
if (m) {
err = ext4_ext_get_access(handle, inode, path + i);
if (err)
goto cleanup;
le16_add_cpu(&path[i].p_hdr->eh_entries, -m);
err = ext4_ext_dirty(handle, inode, path + i);
if (err)
goto cleanup;
}
i--;
}
err = ext4_ext_insert_index(handle, inode, path + at,
le32_to_cpu(border), newblock);
cleanup:
if (bh) {
if (buffer_locked(bh))
unlock_buffer(bh);
brelse(bh);
}
if (err) {
for (i = 0; i < depth; i++) {
if (!ablocks[i])
continue;
ext4_free_blocks(handle, inode, NULL, ablocks[i], 1,
EXT4_FREE_BLOCKS_METADATA);
}
}
kfree(ablocks);
return err;
}","static int ext4_ext_split(handle_t *VAR_0, struct inode *inode,
unsigned int VAR_1,
struct ext4_ext_path *VAR_2,
struct ext4_extent *VAR_3, int VAR_4)
{
struct buffer_head *VAR_5 = NULL;
int VAR_6 = ext_depth(inode);
struct ext4_extent_header *VAR_7;
struct ext4_extent_idx *VAR_8;
int VAR_9 = VAR_4, VAR_10, VAR_11, VAR_12;
ext4_fsblk_t VAR_13, VAR_14;
__le32 VAR_15;
ext4_fsblk_t *VAR_16 = NULL; 
int VAR_17 = 0;
if (unlikely(VAR_2[VAR_6].p_ext > EXT_MAX_EXTENT(VAR_2[VAR_6].p_hdr))) {
EXT4_ERROR_INODE(inode, ""p_ext > EXT_MAX_EXTENT!"");
return -VAR_18;
}
if (VAR_2[VAR_6].p_ext != EXT_MAX_EXTENT(VAR_2[VAR_6].p_hdr)) {
VAR_15 = VAR_2[VAR_6].p_ext[1].ee_block;
ext_debug(""leaf will be split.""
"" next leaf starts at %d\n"",
le32_to_cpu(VAR_15));
} else {
VAR_15 = VAR_3->ee_block;
ext_debug(""leaf will be added.""
"" next leaf starts at %d\n"",
le32_to_cpu(VAR_15));
}
VAR_16 = kcalloc(VAR_6, sizeof(ext4_fsblk_t), VAR_19);
if (!VAR_16)
return -VAR_20;
ext_debug(""allocate %d blocks for indexes/leaf\n"", VAR_6 - VAR_4);
for (VAR_12 = 0; VAR_12 < VAR_6 - VAR_4; VAR_12++) {
VAR_13 = ext4_ext_new_meta_block(VAR_0, inode, VAR_2,
VAR_3, &VAR_17, VAR_1);
if (VAR_13 == 0)
goto cleanup;
VAR_16[VAR_12] = VAR_13;
}
VAR_13 = VAR_16[--VAR_12];
if (unlikely(VAR_13 == 0)) {
EXT4_ERROR_INODE(inode, ""newblock == 0!"");
VAR_17 = -VAR_18;
goto cleanup;
}
VAR_5 = sb_getblk_gfp(inode->i_sb, VAR_13, VAR_21 | VAR_19);
if (unlikely(!VAR_5)) {
VAR_17 = -VAR_20;
goto cleanup;
}
lock_buffer(VAR_5);
VAR_17 = ext4_journal_get_create_access(VAR_0, VAR_5);
if (VAR_17)
goto cleanup;
VAR_7 = ext_block_hdr(VAR_5);
VAR_7->eh_entries = 0;
VAR_7->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
VAR_7->eh_magic = VAR_22;
VAR_7->eh_depth = 0;
if (unlikely(VAR_2[VAR_6].p_hdr->eh_entries !=
VAR_2[VAR_6].p_hdr->eh_max)) {
EXT4_ERROR_INODE(inode, ""eh_entries %d != eh_max %d!"",
VAR_2[VAR_6].p_hdr->eh_entries,
VAR_2[VAR_6].p_hdr->eh_max);
VAR_17 = -VAR_18;
goto cleanup;
}
VAR_11 = EXT_MAX_EXTENT(VAR_2[VAR_6].p_hdr) - VAR_2[VAR_6].p_ext++;
ext4_ext_show_move(inode, VAR_2, VAR_13, VAR_6);
if (VAR_11) {
struct ext4_extent *VAR_23;
VAR_23 = EXT_FIRST_EXTENT(VAR_7);
memmove(VAR_23, VAR_2[VAR_6].p_ext, sizeof(struct ext4_extent) * VAR_11);
le16_add_cpu(&VAR_7->eh_entries, VAR_11);
}
ext4_extent_block_csum_set(inode, VAR_7);
set_buffer_uptodate(VAR_5);
unlock_buffer(VAR_5);
VAR_17 = ext4_handle_dirty_metadata(VAR_0, inode, VAR_5);
if (VAR_17)
goto cleanup;
brelse(VAR_5);
VAR_5 = NULL;
if (VAR_11) {
VAR_17 = ext4_ext_get_access(VAR_0, inode, VAR_2 + VAR_6);
if (VAR_17)
goto cleanup;
le16_add_cpu(&VAR_2[VAR_6].p_hdr->eh_entries, -VAR_11);
VAR_17 = ext4_ext_dirty(VAR_0, inode, VAR_2 + VAR_6);
if (VAR_17)
goto cleanup;
}
VAR_10 = VAR_6 - VAR_4 - 1;
if (unlikely(VAR_10 < 0)) {
EXT4_ERROR_INODE(inode, ""k %d < 0!"", VAR_10);
VAR_17 = -VAR_18;
goto cleanup;
}
if (VAR_10)
ext_debug(""create %d intermediate indices\n"", VAR_10);
VAR_9 = VAR_6 - 1;
while (VAR_10--) {
VAR_14 = VAR_13;
VAR_13 = VAR_16[--VAR_12];
VAR_5 = sb_getblk(inode->i_sb, VAR_13);
if (unlikely(!VAR_5)) {
VAR_17 = -VAR_20;
goto cleanup;
}
lock_buffer(VAR_5);
VAR_17 = ext4_journal_get_create_access(VAR_0, VAR_5);
if (VAR_17)
goto cleanup;
VAR_7 = ext_block_hdr(VAR_5);
VAR_7->eh_entries = cpu_to_le16(1);
VAR_7->eh_magic = VAR_22;
VAR_7->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
VAR_7->eh_depth = cpu_to_le16(VAR_6 - VAR_9);
VAR_8 = EXT_FIRST_INDEX(VAR_7);
VAR_8->ei_block = VAR_15;
ext4_idx_store_pblock(VAR_8, VAR_14);
ext_debug(""int.index at %d (block %llu): %u -> %llu\n"",
VAR_9, VAR_13, le32_to_cpu(VAR_15), VAR_14);
if (unlikely(EXT_MAX_INDEX(VAR_2[VAR_9].p_hdr) !=
EXT_LAST_INDEX(VAR_2[VAR_9].p_hdr))) {
EXT4_ERROR_INODE(inode,
""EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!"",
le32_to_cpu(VAR_2[VAR_9].p_ext->ee_block));
VAR_17 = -VAR_18;
goto cleanup;
}
VAR_11 = EXT_MAX_INDEX(VAR_2[VAR_9].p_hdr) - VAR_2[VAR_9].p_idx++;
ext_debug(""cur 0x%p, last 0x%p\n"", VAR_2[VAR_9].p_idx,
EXT_MAX_INDEX(VAR_2[VAR_9].p_hdr));
ext4_ext_show_move(inode, VAR_2, VAR_13, VAR_9);
if (VAR_11) {
memmove(++VAR_8, VAR_2[VAR_9].p_idx,
sizeof(struct ext4_extent_idx) * VAR_11);
le16_add_cpu(&VAR_7->eh_entries, VAR_11);
}
ext4_extent_block_csum_set(inode, VAR_7);
set_buffer_uptodate(VAR_5);
unlock_buffer(VAR_5);
VAR_17 = ext4_handle_dirty_metadata(VAR_0, inode, VAR_5);
if (VAR_17)
goto cleanup;
brelse(VAR_5);
VAR_5 = NULL;
if (VAR_11) {
VAR_17 = ext4_ext_get_access(VAR_0, inode, VAR_2 + VAR_9);
if (VAR_17)
goto cleanup;
le16_add_cpu(&VAR_2[VAR_9].p_hdr->eh_entries, -VAR_11);
VAR_17 = ext4_ext_dirty(VAR_0, inode, VAR_2 + VAR_9);
if (VAR_17)
goto cleanup;
}
VAR_9--;
}
VAR_17 = ext4_ext_insert_index(VAR_0, inode, VAR_2 + VAR_4,
le32_to_cpu(VAR_15), VAR_13);
cleanup:
if (VAR_5) {
if (buffer_locked(VAR_5))
unlock_buffer(VAR_5);
brelse(VAR_5);
}
if (VAR_17) {
for (VAR_9 = 0; VAR_9 < VAR_6; VAR_9++) {
if (!VAR_16[VAR_9])
continue;
ext4_free_blocks(VAR_0, inode, NULL, VAR_16[VAR_9], 1,
VAR_24);
}
}
kfree(VAR_16);
return VAR_17;
}",torvalds/linux/592acbf16821288ecdc4192c47e3774a4c48bb64/extents.c/vul/before/0.json,"static int ext4_ext_split(handle_t *handle, struct inode *inode,
			  unsigned int flags,
			  struct ext4_ext_path *path,
			  struct ext4_extent *newext, int at)
{
	struct buffer_head *bh = NULL;
	int depth = ext_depth(inode);
	struct ext4_extent_header *neh;
	struct ext4_extent_idx *fidx;
	int i = at, k, m, a;
	ext4_fsblk_t newblock, oldblock;
	__le32 border;
	ext4_fsblk_t *ablocks = NULL; /* array of allocated blocks */
	int err = 0;
	size_t ext_size = 0;

	/* make decision: where to split? */
	/* FIXME: now decision is simplest: at current extent */

	/* if current leaf will be split, then we should use
	 * border from split point */
	if (unlikely(path[depth].p_ext > EXT_MAX_EXTENT(path[depth].p_hdr))) {
		EXT4_ERROR_INODE(inode, ""p_ext > EXT_MAX_EXTENT!"");
		return -EFSCORRUPTED;
	}
	if (path[depth].p_ext != EXT_MAX_EXTENT(path[depth].p_hdr)) {
		border = path[depth].p_ext[1].ee_block;
		ext_debug(""leaf will be split.""
				"" next leaf starts at %d\n"",
				  le32_to_cpu(border));
	} else {
		border = newext->ee_block;
		ext_debug(""leaf will be added.""
				"" next leaf starts at %d\n"",
				le32_to_cpu(border));
	}

	/*
	 * If error occurs, then we break processing
	 * and mark filesystem read-only. index won't
	 * be inserted and tree will be in consistent
	 * state. Next mount will repair buffers too.
	 */

	/*
	 * Get array to track all allocated blocks.
	 * We need this to handle errors and free blocks
	 * upon them.
	 */
	ablocks = kcalloc(depth, sizeof(ext4_fsblk_t), GFP_NOFS);
	if (!ablocks)
		return -ENOMEM;

	/* allocate all needed blocks */
	ext_debug(""allocate %d blocks for indexes/leaf\n"", depth - at);
	for (a = 0; a < depth - at; a++) {
		newblock = ext4_ext_new_meta_block(handle, inode, path,
						   newext, &err, flags);
		if (newblock == 0)
			goto cleanup;
		ablocks[a] = newblock;
	}

	/* initialize new leaf */
	newblock = ablocks[--a];
	if (unlikely(newblock == 0)) {
		EXT4_ERROR_INODE(inode, ""newblock == 0!"");
		err = -EFSCORRUPTED;
		goto cleanup;
	}
	bh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);
	if (unlikely(!bh)) {
		err = -ENOMEM;
		goto cleanup;
	}
	lock_buffer(bh);

	err = ext4_journal_get_create_access(handle, bh);
	if (err)
		goto cleanup;

	neh = ext_block_hdr(bh);
	neh->eh_entries = 0;
	neh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
	neh->eh_magic = EXT4_EXT_MAGIC;
	neh->eh_depth = 0;

	/* move remainder of path[depth] to the new leaf */
	if (unlikely(path[depth].p_hdr->eh_entries !=
		     path[depth].p_hdr->eh_max)) {
		EXT4_ERROR_INODE(inode, ""eh_entries %d != eh_max %d!"",
				 path[depth].p_hdr->eh_entries,
				 path[depth].p_hdr->eh_max);
		err = -EFSCORRUPTED;
		goto cleanup;
	}
	/* start copy from next extent */
	m = EXT_MAX_EXTENT(path[depth].p_hdr) - path[depth].p_ext++;
	ext4_ext_show_move(inode, path, newblock, depth);
	if (m) {
		struct ext4_extent *ex;
		ex = EXT_FIRST_EXTENT(neh);
		memmove(ex, path[depth].p_ext, sizeof(struct ext4_extent) * m);
		le16_add_cpu(&neh->eh_entries, m);
	}

	/* zero out unused area in the extent block */
	ext_size = sizeof(struct ext4_extent_header) +
		sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);
	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
	ext4_extent_block_csum_set(inode, neh);
	set_buffer_uptodate(bh);
	unlock_buffer(bh);

	err = ext4_handle_dirty_metadata(handle, inode, bh);
	if (err)
		goto cleanup;
	brelse(bh);
	bh = NULL;

	/* correct old leaf */
	if (m) {
		err = ext4_ext_get_access(handle, inode, path + depth);
		if (err)
			goto cleanup;
		le16_add_cpu(&path[depth].p_hdr->eh_entries, -m);
		err = ext4_ext_dirty(handle, inode, path + depth);
		if (err)
			goto cleanup;

	}

	/* create intermediate indexes */
	k = depth - at - 1;
	if (unlikely(k < 0)) {
		EXT4_ERROR_INODE(inode, ""k %d < 0!"", k);
		err = -EFSCORRUPTED;
		goto cleanup;
	}
	if (k)
		ext_debug(""create %d intermediate indices\n"", k);
	/* insert new index into current index block */
	/* current depth stored in i var */
	i = depth - 1;
	while (k--) {
		oldblock = newblock;
		newblock = ablocks[--a];
		bh = sb_getblk(inode->i_sb, newblock);
		if (unlikely(!bh)) {
			err = -ENOMEM;
			goto cleanup;
		}
		lock_buffer(bh);

		err = ext4_journal_get_create_access(handle, bh);
		if (err)
			goto cleanup;

		neh = ext_block_hdr(bh);
		neh->eh_entries = cpu_to_le16(1);
		neh->eh_magic = EXT4_EXT_MAGIC;
		neh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
		neh->eh_depth = cpu_to_le16(depth - i);
		fidx = EXT_FIRST_INDEX(neh);
		fidx->ei_block = border;
		ext4_idx_store_pblock(fidx, oldblock);

		ext_debug(""int.index at %d (block %llu): %u -> %llu\n"",
				i, newblock, le32_to_cpu(border), oldblock);

		/* move remainder of path[i] to the new index block */
		if (unlikely(EXT_MAX_INDEX(path[i].p_hdr) !=
					EXT_LAST_INDEX(path[i].p_hdr))) {
			EXT4_ERROR_INODE(inode,
					 ""EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!"",
					 le32_to_cpu(path[i].p_ext->ee_block));
			err = -EFSCORRUPTED;
			goto cleanup;
		}
		/* start copy indexes */
		m = EXT_MAX_INDEX(path[i].p_hdr) - path[i].p_idx++;
		ext_debug(""cur 0x%p, last 0x%p\n"", path[i].p_idx,
				EXT_MAX_INDEX(path[i].p_hdr));
		ext4_ext_show_move(inode, path, newblock, i);
		if (m) {
			memmove(++fidx, path[i].p_idx,
				sizeof(struct ext4_extent_idx) * m);
			le16_add_cpu(&neh->eh_entries, m);
		}
		/* zero out unused area in the extent block */
		ext_size = sizeof(struct ext4_extent_header) +
		   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));
		memset(bh->b_data + ext_size, 0,
			inode->i_sb->s_blocksize - ext_size);
		ext4_extent_block_csum_set(inode, neh);
		set_buffer_uptodate(bh);
		unlock_buffer(bh);

		err = ext4_handle_dirty_metadata(handle, inode, bh);
		if (err)
			goto cleanup;
		brelse(bh);
		bh = NULL;

		/* correct old index */
		if (m) {
			err = ext4_ext_get_access(handle, inode, path + i);
			if (err)
				goto cleanup;
			le16_add_cpu(&path[i].p_hdr->eh_entries, -m);
			err = ext4_ext_dirty(handle, inode, path + i);
			if (err)
				goto cleanup;
		}

		i--;
	}

	/* insert new index */
	err = ext4_ext_insert_index(handle, inode, path + at,
				    le32_to_cpu(border), newblock);

cleanup:
	if (bh) {
		if (buffer_locked(bh))
			unlock_buffer(bh);
		brelse(bh);
	}

	if (err) {
		/* free all allocated blocks in error case */
		for (i = 0; i < depth; i++) {
			if (!ablocks[i])
				continue;
			ext4_free_blocks(handle, inode, NULL, ablocks[i], 1,
					 EXT4_FREE_BLOCKS_METADATA);
		}
	}
	kfree(ablocks);

	return err;
}","static int ext4_ext_split(handle_t *VAR_0, struct inode *inode,
			  unsigned int VAR_1,
			  struct ext4_ext_path *VAR_2,
			  struct ext4_extent *VAR_3, int VAR_4)
{
	struct buffer_head *VAR_5 = NULL;
	int VAR_6 = ext_depth(inode);
	struct ext4_extent_header *VAR_7;
	struct ext4_extent_idx *VAR_8;
	int VAR_9 = VAR_4, VAR_10, VAR_11, VAR_12;
	ext4_fsblk_t VAR_13, VAR_14;
	__le32 VAR_15;
	ext4_fsblk_t *VAR_16 = NULL; /* COMMENT_0 */
	int VAR_17 = 0;
	size_t VAR_18 = 0;

	/* COMMENT_1 */
	/* COMMENT_2 */

	/* COMMENT_3 */
                              
	if (unlikely(VAR_2[VAR_6].p_ext > EXT_MAX_EXTENT(VAR_2[VAR_6].p_hdr))) {
		EXT4_ERROR_INODE(inode, ""p_ext > EXT_MAX_EXTENT!"");
		return -VAR_19;
	}
	if (VAR_2[VAR_6].p_ext != EXT_MAX_EXTENT(VAR_2[VAR_6].p_hdr)) {
		VAR_15 = VAR_2[VAR_6].p_ext[1].ee_block;
		ext_debug(""leaf will be split.""
				"" next leaf starts at %d\n"",
				  le32_to_cpu(VAR_15));
	} else {
		VAR_15 = VAR_3->ee_block;
		ext_debug(""leaf will be added.""
				"" next leaf starts at %d\n"",
				le32_to_cpu(VAR_15));
	}

	/* COMMENT_5 */
                                             
                                              
                                              
                                              
    

	/* COMMENT_11 */
                                            
                                                 
              
    
	VAR_16 = kcalloc(VAR_6, sizeof(ext4_fsblk_t), VAR_20);
	if (!VAR_16)
		return -VAR_21;

	/* COMMENT_16 */
	ext_debug(""allocate %d blocks for indexes/leaf\n"", VAR_6 - VAR_4);
	for (VAR_12 = 0; VAR_12 < VAR_6 - VAR_4; VAR_12++) {
		VAR_13 = ext4_ext_new_meta_block(VAR_0, inode, VAR_2,
						   VAR_3, &VAR_17, VAR_1);
		if (VAR_13 == 0)
			goto cleanup;
		VAR_16[VAR_12] = VAR_13;
	}

	/* COMMENT_17 */
	VAR_13 = VAR_16[--VAR_12];
	if (unlikely(VAR_13 == 0)) {
		EXT4_ERROR_INODE(inode, ""newblock == 0!"");
		VAR_17 = -VAR_19;
		goto cleanup;
	}
	VAR_5 = sb_getblk_gfp(inode->i_sb, VAR_13, VAR_22 | VAR_20);
	if (unlikely(!VAR_5)) {
		VAR_17 = -VAR_21;
		goto cleanup;
	}
	lock_buffer(VAR_5);

	VAR_17 = ext4_journal_get_create_access(VAR_0, VAR_5);
	if (VAR_17)
		goto cleanup;

	VAR_7 = ext_block_hdr(VAR_5);
	VAR_7->eh_entries = 0;
	VAR_7->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
	VAR_7->eh_magic = VAR_23;
	VAR_7->eh_depth = 0;

	/* COMMENT_18 */
	if (unlikely(VAR_2[VAR_6].p_hdr->eh_entries !=
		     VAR_2[VAR_6].p_hdr->eh_max)) {
		EXT4_ERROR_INODE(inode, ""eh_entries %d != eh_max %d!"",
				 VAR_2[VAR_6].p_hdr->eh_entries,
				 VAR_2[VAR_6].p_hdr->eh_max);
		VAR_17 = -VAR_19;
		goto cleanup;
	}
	/* COMMENT_19 */
	VAR_11 = EXT_MAX_EXTENT(VAR_2[VAR_6].p_hdr) - VAR_2[VAR_6].p_ext++;
	ext4_ext_show_move(inode, VAR_2, VAR_13, VAR_6);
	if (VAR_11) {
		struct ext4_extent *VAR_24;
		VAR_24 = EXT_FIRST_EXTENT(VAR_7);
		memmove(VAR_24, VAR_2[VAR_6].p_ext, sizeof(struct ext4_extent) * VAR_11);
		le16_add_cpu(&VAR_7->eh_entries, VAR_11);
	}

	/* COMMENT_20 */
	VAR_18 = sizeof(struct ext4_extent_header) +
		sizeof(struct ext4_extent) * le16_to_cpu(VAR_7->eh_entries);
	memset(VAR_5->b_data + VAR_18, 0, inode->i_sb->s_blocksize - VAR_18);
	ext4_extent_block_csum_set(inode, VAR_7);
	set_buffer_uptodate(VAR_5);
	unlock_buffer(VAR_5);

	VAR_17 = ext4_handle_dirty_metadata(VAR_0, inode, VAR_5);
	if (VAR_17)
		goto cleanup;
	brelse(VAR_5);
	VAR_5 = NULL;

	/* COMMENT_21 */
	if (VAR_11) {
		VAR_17 = ext4_ext_get_access(VAR_0, inode, VAR_2 + VAR_6);
		if (VAR_17)
			goto cleanup;
		le16_add_cpu(&VAR_2[VAR_6].p_hdr->eh_entries, -VAR_11);
		VAR_17 = ext4_ext_dirty(VAR_0, inode, VAR_2 + VAR_6);
		if (VAR_17)
			goto cleanup;

	}

	/* COMMENT_22 */
	VAR_10 = VAR_6 - VAR_4 - 1;
	if (unlikely(VAR_10 < 0)) {
		EXT4_ERROR_INODE(inode, ""k %d < 0!"", VAR_10);
		VAR_17 = -VAR_19;
		goto cleanup;
	}
	if (VAR_10)
		ext_debug(""create %d intermediate indices\n"", VAR_10);
	/* COMMENT_23 */
	/* COMMENT_24 */
	VAR_9 = VAR_6 - 1;
	while (VAR_10--) {
		VAR_14 = VAR_13;
		VAR_13 = VAR_16[--VAR_12];
		VAR_5 = sb_getblk(inode->i_sb, VAR_13);
		if (unlikely(!VAR_5)) {
			VAR_17 = -VAR_21;
			goto cleanup;
		}
		lock_buffer(VAR_5);

		VAR_17 = ext4_journal_get_create_access(VAR_0, VAR_5);
		if (VAR_17)
			goto cleanup;

		VAR_7 = ext_block_hdr(VAR_5);
		VAR_7->eh_entries = cpu_to_le16(1);
		VAR_7->eh_magic = VAR_23;
		VAR_7->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
		VAR_7->eh_depth = cpu_to_le16(VAR_6 - VAR_9);
		VAR_8 = EXT_FIRST_INDEX(VAR_7);
		VAR_8->ei_block = VAR_15;
		ext4_idx_store_pblock(VAR_8, VAR_14);

		ext_debug(""int.index at %d (block %llu): %u -> %llu\n"",
				VAR_9, VAR_13, le32_to_cpu(VAR_15), VAR_14);

		/* COMMENT_25 */
		if (unlikely(EXT_MAX_INDEX(VAR_2[VAR_9].p_hdr) !=
					EXT_LAST_INDEX(VAR_2[VAR_9].p_hdr))) {
			EXT4_ERROR_INODE(inode,
					 ""EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!"",
					 le32_to_cpu(VAR_2[VAR_9].p_ext->ee_block));
			VAR_17 = -VAR_19;
			goto cleanup;
		}
		/* COMMENT_26 */
		VAR_11 = EXT_MAX_INDEX(VAR_2[VAR_9].p_hdr) - VAR_2[VAR_9].p_idx++;
		ext_debug(""cur 0x%p, last 0x%p\n"", VAR_2[VAR_9].p_idx,
				EXT_MAX_INDEX(VAR_2[VAR_9].p_hdr));
		ext4_ext_show_move(inode, VAR_2, VAR_13, VAR_9);
		if (VAR_11) {
			memmove(++VAR_8, VAR_2[VAR_9].p_idx,
				sizeof(struct ext4_extent_idx) * VAR_11);
			le16_add_cpu(&VAR_7->eh_entries, VAR_11);
		}
		/* COMMENT_20 */
		VAR_18 = sizeof(struct ext4_extent_header) +
		   (sizeof(struct ext4_extent) * le16_to_cpu(VAR_7->eh_entries));
		memset(VAR_5->b_data + VAR_18, 0,
			inode->i_sb->s_blocksize - VAR_18);
		ext4_extent_block_csum_set(inode, VAR_7);
		set_buffer_uptodate(VAR_5);
		unlock_buffer(VAR_5);

		VAR_17 = ext4_handle_dirty_metadata(VAR_0, inode, VAR_5);
		if (VAR_17)
			goto cleanup;
		brelse(VAR_5);
		VAR_5 = NULL;

		/* COMMENT_27 */
		if (VAR_11) {
			VAR_17 = ext4_ext_get_access(VAR_0, inode, VAR_2 + VAR_9);
			if (VAR_17)
				goto cleanup;
			le16_add_cpu(&VAR_2[VAR_9].p_hdr->eh_entries, -VAR_11);
			VAR_17 = ext4_ext_dirty(VAR_0, inode, VAR_2 + VAR_9);
			if (VAR_17)
				goto cleanup;
		}

		VAR_9--;
	}

	/* COMMENT_28 */
	VAR_17 = ext4_ext_insert_index(VAR_0, inode, VAR_2 + VAR_4,
				    le32_to_cpu(VAR_15), VAR_13);

cleanup:
	if (VAR_5) {
		if (buffer_locked(VAR_5))
			unlock_buffer(VAR_5);
		brelse(VAR_5);
	}

	if (VAR_17) {
		/* COMMENT_29 */
		for (VAR_9 = 0; VAR_9 < VAR_6; VAR_9++) {
			if (!VAR_16[VAR_9])
				continue;
			ext4_free_blocks(VAR_0, inode, NULL, VAR_16[VAR_9], 1,
					 VAR_25);
		}
	}
	kfree(VAR_16);

	return VAR_17;
}",torvalds/linux/592acbf16821288ecdc4192c47e3774a4c48bb64/extents.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
 	__le32 border;
 	ext4_fsblk_t *ablocks = NULL; /* array of allocated blocks */
 	int err = 0;
+	size_t ext_size = 0;
 
 	/* make decision: where to split? */
 	/* FIXME: now decision is simplest: at current extent */
@@ -103,6 +104,10 @@
 		le16_add_cpu(&neh->eh_entries, m);
 	}
 
+	/* zero out unused area in the extent block */
+	ext_size = sizeof(struct ext4_extent_header) +
+		sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);
+	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
 	ext4_extent_block_csum_set(inode, neh);
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
@@ -182,6 +187,11 @@
 				sizeof(struct ext4_extent_idx) * m);
 			le16_add_cpu(&neh->eh_entries, m);
 		}
+		/* zero out unused area in the extent block */
+		ext_size = sizeof(struct ext4_extent_header) +
+		   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));
+		memset(bh->b_data + ext_size, 0,
+			inode->i_sb->s_blocksize - ext_size);
 		ext4_extent_block_csum_set(inode, neh);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);","{'deleted_lines': [], 'added_lines': ['\tsize_t ext_size = 0;', '\t/* zero out unused area in the extent block */', '\text_size = sizeof(struct ext4_extent_header) +', '\t\tsizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);', '\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);', '\t\t/* zero out unused area in the extent block */', '\t\text_size = sizeof(struct ext4_extent_header) +', '\t\t   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));', '\t\tmemset(bh->b_data + ext_size, 0,', '\t\t\tinode->i_sb->s_blocksize - ext_size);']}",True,"fs/ext4/extents.c in the Linux kernel through 5.1.2 does not zero out the unused memory region in the extent tree block, which might allow local users to obtain sensitive information by reading uninitialized data in the filesystem.",5.5,MEDIUM,1,test,2019-05-10T23:28:06Z,2
CVE-2020-18831,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H,1.0,Exiv2/exiv2,Add better bounds checking in PngImage::printStructure().,20a13f00e2db24c58ee326e4c89a56469718b30e,https://github.com/Exiv2/exiv2/commit/20a13f00e2db24c58ee326e4c89a56469718b30e,src/pngimage.cpp,PngImage::printStructure,"void PngImage::printStructure(std::ostream& out, PrintStructureOption option, int depth)
{
if (io_->open() != 0) {
throw Error(kerDataSourceOpenFailed, io_->path(), strError());
}
if (!isPngType(*io_, true)) {
throw Error(kerNotAnImage, ""PNG"");
}
char    chType[5];
chType[0]=0;
chType[4]=0;
if ( option == kpsBasic || option == kpsXMP || option == kpsIccProfile || option == kpsRecursive ) {
const std::string xmpKey  = ""XML:com.adobe.xmp"";
const std::string exifKey = ""Raw profile type exif"";
const std::string app1Key = ""Raw profile type APP1"";
const std::string iptcKey = ""Raw profile type iptc"";
const std::string iccKey  = ""icc"";
const std::string softKey = ""Software"";
const std::string commKey = ""Comment"";
const std::string descKey = ""Description"";
bool bPrint = option == kpsBasic || option == kpsRecursive ;
if ( bPrint ) {
out << ""STRUCTURE OF PNG FILE: "" << io_->path() << std::endl;
out << "" address | chunk |  length | data                           | checksum"" << std::endl;
}
const long imgSize = (long) io_->size();
DataBuf    cheaderBuf(8);
while( !io_->eof() && ::strcmp(chType,""IEND"") ) {
size_t address = io_->tell();
std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);
long bufRead = io_->read(cheaderBuf.pData_, cheaderBuf.size_);
if (io_->error()) throw Error(kerFailedToReadImageData);
if (bufRead != cheaderBuf.size_) throw Error(kerInputDataReadFailed);
uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);
for (int i = 4; i < 8; i++) {
chType[i-4]=cheaderBuf.pData_[i];
}
long restore = io_->tell();
if(  restore == -1
||  dataOffset > uint32_t(0x7FFFFFFF)
||  static_cast<long>(dataOffset) > imgSize - restore
){
throw Exiv2::Error(kerFailedToReadImageData);
}
DataBuf   buff(dataOffset);
io_->read(buff.pData_,dataOffset);
io_->seek(restore, BasicIo::beg);
const int    iMax = 30 ;
const uint32_t blen = dataOffset > iMax ? iMax : dataOffset ;
std::string dataString = """";
if (blen > 0) {
std::stringstream ss;
ss << Internal::binaryToString(makeSlice(buff, 0, blen));
dataString = ss.str();
}
while (      dataString.size() < iMax ) dataString += ' ';
dataString = dataString.substr(0,iMax);
if ( bPrint ) {
io_->seek(dataOffset, BasicIo::cur);                    byte checksum[4];
io_->read(checksum,4);
io_->seek(restore, BasicIo::beg)   ;
out << Internal::stringFormat(""%8d | %-5s |%8d | ""
,(uint32_t)address, chType,dataOffset)
<< dataString
<< Internal::stringFormat("" | 0x%02x%02x%02x%02x""
,checksum[0],checksum[1],checksum[2],checksum[3])
<< std::endl;
}
bool tEXt  = std::strcmp(chType,""tEXt"")== 0;
bool zTXt  = std::strcmp(chType,""zTXt"")== 0;
bool iCCP  = std::strcmp(chType,""iCCP"")== 0;
bool iTXt  = std::strcmp(chType,""iTXt"")== 0;
bool bXMP  = option == kpsXMP        && findi(dataString,xmpKey)==0;
bool bICC  = option == kpsIccProfile && findi(dataString,iccKey)==0;
bool bExif = option == kpsRecursive  &&(findi(dataString,exifKey)==0 || findi(dataString,app1Key)==0);
bool bIptc = option == kpsRecursive  && findi(dataString,iptcKey)==0;
bool bSoft = option == kpsRecursive  && findi(dataString,softKey)==0;
bool bComm = option == kpsRecursive  && findi(dataString,commKey)==0;
bool bDesc = option == kpsRecursive  && findi(dataString,descKey)==0;
bool bDump = bXMP || bICC || bExif || bIptc || bSoft || bComm || bDesc ;
if( bDump ) {
DataBuf   dataBuf;
byte*     data   = new byte[dataOffset+1];
data[dataOffset] = 0;
io_->read(data,dataOffset);
io_->seek(restore, BasicIo::beg);
uint32_t  name_l = (uint32_t) std::strlen((const char*)data)+1;                     uint32_t  start  = name_l;
bool      bLF    = false;
bool bGood = false;
if ( tEXt ) {
bGood = tEXtToDataBuf(data+name_l,dataOffset-name_l,dataBuf);
}
if ( zTXt || iCCP ) {
bGood = zlibToDataBuf(data+name_l+1,dataOffset-name_l-1,dataBuf);                     }
if ( iTXt ) {
bGood = (start+3) < dataOffset ;                        }
if ( bGood ) {
if ( bXMP ) {
while ( !data[start] && start < dataOffset) start++;                             out <<  data+start;                                     }
if ( bExif || bIptc ) {
DataBuf parsedBuf = PngChunk::readRawProfile(dataBuf,tEXt);
#if DEBUG
std::cerr << Exiv2::Internal::binaryToString(parsedBuf.pData_, parsedBuf.size_>50?50:parsedBuf.size_,0) << std::endl;
#endif
if ( parsedBuf.size_ ) {
if ( bExif ) {
BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(parsedBuf.pData_+6,parsedBuf.size_-6));
printTiffStructure(*p,out,option,depth);
}
if ( bIptc ) {
IptcData::printStructure(out, makeSlice(parsedBuf.pData_, 0, parsedBuf.size_), depth);
}
}
}
if ( bSoft && dataBuf.size_ > 0) {
DataBuf     s(dataBuf.size_+1);                                           memcpy(s.pData_,dataBuf.pData_,dataBuf.size_);                            s.pData_[dataBuf.size_] = 0 ;                                             const char* str = (const char*) s.pData_;                                 out << Internal::indent(depth) << (const char*) buff.pData_ << "": "" << str ;
bLF=true;
}
if ( bICC || bComm ) {
out.write((const char*) dataBuf.pData_,dataBuf.size_);
bLF = bComm ;
}
if ( bDesc && iTXt ) {
DataBuf decoded = PngChunk::decodeTXTChunk(buff,PngChunk::iTXt_Chunk );
out.write((const char*)decoded.pData_,decoded.size_);
bLF = true;
}
if ( bLF ) out << std::endl;
}
delete[] data;
}
io_->seek(dataOffset+4, BasicIo::cur);                if (io_->error()) throw Error(kerFailedToReadImageData);
}
}
}","void PngImage::printStructure(std::ostream& VAR_0, PrintStructureOption VAR_1, int VAR_2)
{
if (VAR_3->open() != 0) {
throw Error(VAR_4, VAR_3->path(), strError());
}
if (!isPngType(*VAR_3, true)) {
throw Error(VAR_5, ""PNG"");
}
char    VAR_6[5];
VAR_6[0]=0;
VAR_6[4]=0;
if ( VAR_1 == VAR_7 || VAR_1 == VAR_8 || VAR_1 == VAR_9 || VAR_1 == VAR_10 ) {
const std::string VAR_11  = ""XML:com.adobe.xmp"";
const std::string VAR_12 = ""Raw profile type exif"";
const std::string VAR_13 = ""Raw profile type APP1"";
const std::string VAR_14 = ""Raw profile type iptc"";
const std::string VAR_15  = ""icc"";
const std::string VAR_16 = ""Software"";
const std::string VAR_17 = ""Comment"";
const std::string VAR_18 = ""Description"";
bool VAR_19 = VAR_1 == VAR_7 || VAR_1 == VAR_10 ;
if ( VAR_19 ) {
VAR_0 << ""STRUCTURE OF PNG FILE: "" << VAR_3->path() << std::endl;
VAR_0 << "" address | chunk |  length | data                           | checksum"" << std::endl;
}
const long VAR_20 = (long) VAR_3->size();
DataBuf    VAR_21(8);
while( !VAR_3->eof() && ::strcmp(VAR_6,""IEND"") ) {
size_t VAR_22 = VAR_3->tell();
std::memset(VAR_21.pData_, 0x0, VAR_21.size_);
long VAR_23 = VAR_3->read(VAR_21.pData_, VAR_21.size_);
if (VAR_3->error()) throw Error(VAR_24);
if (VAR_23 != VAR_21.size_) throw Error(VAR_25);
uint32_t VAR_26 = Exiv2::getULong(VAR_21.pData_, Exiv2::bigEndian);
for (int VAR_27 = 4; VAR_27 < 8; VAR_27++) {
VAR_6[VAR_27-4]=VAR_21.pData_[VAR_27];
}
long VAR_28 = VAR_3->tell();
if(  VAR_28 == -1
||  VAR_26 > uint32_t(0x7FFFFFFF)
||  VAR_29<long>(VAR_26) > VAR_20 - VAR_28
){
throw Exiv2::Error(VAR_24);
}
DataBuf   buff(dataOffset);
VAR_3->read(VAR_30.pData_,dataOffset);
VAR_3->seek(VAR_28, BasicIo::beg);
const int    VAR_31 = 30 ;
const uint32_t VAR_32 = dataOffset > VAR_31 ? VAR_31 : dataOffset ;
std::string VAR_33 = """";
if (VAR_32 > 0) {
std::stringstream VAR_34;
VAR_34 << Internal::binaryToString(makeSlice(VAR_30, 0, VAR_32));
VAR_33 = VAR_34.str();
}
while (      VAR_33.size() < VAR_31 ) VAR_33 += ' ';
VAR_33 = VAR_33.substr(0,VAR_31);
if ( VAR_19 ) {
VAR_3->seek(dataOffset, BasicIo::cur);
byte VAR_35[4];
VAR_3->read(VAR_35,4);
VAR_3->seek(VAR_28, BasicIo::beg)   ;
VAR_0 << Internal::stringFormat(""%8d | %-5s |%8d | ""
,(uint32_t)VAR_22, VAR_6,dataOffset)
<< VAR_33
<< Internal::stringFormat("" | 0x%02x%02x%02x%02x""
,VAR_35[0],VAR_35[1],VAR_35[2],VAR_35[3])
<< std::endl;
}
bool VAR_36  = std::strcmp(VAR_6,""tEXt"")== 0;
bool VAR_37  = std::strcmp(VAR_6,""zTXt"")== 0;
bool VAR_38  = std::strcmp(VAR_6,""iCCP"")== 0;
bool VAR_39  = std::strcmp(VAR_6,""iTXt"")== 0;
bool VAR_40  = VAR_1 == VAR_8        && findi(VAR_33,VAR_11)==0;
bool VAR_41  = VAR_1 == VAR_9 && findi(VAR_33,VAR_15)==0;
bool VAR_42 = VAR_1 == VAR_10  &&(findi(VAR_33,VAR_12)==0 || findi(VAR_33,VAR_13)==0);
bool VAR_43 = VAR_1 == VAR_10  && findi(VAR_33,VAR_14)==0;
bool VAR_44 = VAR_1 == VAR_10  && findi(VAR_33,VAR_16)==0;
bool VAR_45 = VAR_1 == VAR_10  && findi(VAR_33,VAR_17)==0;
bool VAR_46 = VAR_1 == VAR_10  && findi(VAR_33,VAR_18)==0;
bool VAR_47 = VAR_40 || VAR_41 || VAR_42 || VAR_43 || VAR_44 || VAR_45 || VAR_46 ;
if( VAR_47 ) {
DataBuf   VAR_48;
byte*     VAR_49   = new byte[dataOffset+1];
VAR_49[dataOffset] = 0;
VAR_3->read(VAR_49,dataOffset);
VAR_3->seek(VAR_28, BasicIo::beg);
uint32_t  VAR_50 = (uint32_t) std::strlen((const char*)VAR_49)+1; 
uint32_t  VAR_51  = VAR_50;
bool      VAR_52    = false;
bool VAR_53 = false;
if ( VAR_36 ) {
VAR_53 = tEXtToDataBuf(VAR_49+VAR_50,dataOffset-VAR_50,VAR_48);
}
if ( VAR_37 || VAR_38 ) {
VAR_53 = zlibToDataBuf(VAR_49+VAR_50+1,dataOffset-VAR_50-1,VAR_48); 
}
if ( VAR_39 ) {
VAR_53 = (VAR_51+3) < dataOffset ;    
}
if ( VAR_53 ) {
if ( VAR_40 ) {
while ( !VAR_49[VAR_51] && VAR_51 < dataOffset) VAR_51++; 
VAR_0 <<  VAR_49+VAR_51;             
}
if ( VAR_42 || VAR_43 ) {
DataBuf VAR_54 = PngChunk::readRawProfile(VAR_48,VAR_36);
#if VAR_55
std::cerr << Exiv2::Internal::binaryToString(VAR_54.pData_, VAR_54.size_>50?50:VAR_54.size_,0) << std::endl;
#endif
if ( VAR_54.size_ ) {
if ( VAR_42 ) {
BasicIo::AutoPtr VAR_56 = BasicIo::AutoPtr(new MemIo(VAR_54.pData_+6,VAR_54.size_-6));
printTiffStructure(*VAR_56,VAR_0,VAR_1,VAR_2);
}
if ( VAR_43 ) {
IptcData::printStructure(VAR_0, makeSlice(VAR_54.pData_, 0, VAR_54.size_), VAR_2);
}
}
}
if ( VAR_44 && VAR_48.size_ > 0) {
DataBuf     VAR_57(VAR_48.size_+1);               
memcpy(VAR_57.pData_,VAR_48.pData_,VAR_48.size_);
VAR_57.pData_[VAR_48.size_] = 0 ;                 
const char* VAR_58 = (const char*) VAR_57.pData_;     
VAR_0 << Internal::indent(VAR_2) << (const char*) VAR_30.pData_ << "": "" << VAR_58 ;
VAR_52=true;
}
if ( VAR_41 || VAR_45 ) {
VAR_0.write((const char*) VAR_48.pData_,VAR_48.size_);
VAR_52 = VAR_45 ;
}
if ( VAR_46 && VAR_39 ) {
DataBuf VAR_59 = PngChunk::decodeTXTChunk(VAR_30,PngChunk::iTXt_Chunk );
VAR_0.write((const char*)VAR_59.pData_,VAR_59.size_);
VAR_52 = true;
}
if ( VAR_52 ) VAR_0 << std::endl;
}
delete[] VAR_49;
}
VAR_3->seek(dataOffset+4, BasicIo::cur);
if (VAR_3->error()) throw Error(VAR_24);
}
}
}",Exiv2/exiv2/20a13f00e2db24c58ee326e4c89a56469718b30e/pngimage.cpp/vul/before/0.json,"void PngImage::printStructure(std::ostream& out, PrintStructureOption option, int depth)
    {
        if (io_->open() != 0) {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        if (!isPngType(*io_, true)) {
            throw Error(kerNotAnImage, ""PNG"");
        }

        char    chType[5];
        chType[0]=0;
        chType[4]=0;

        if ( option == kpsBasic || option == kpsXMP || option == kpsIccProfile || option == kpsRecursive ) {

            const std::string xmpKey  = ""XML:com.adobe.xmp"";
            const std::string exifKey = ""Raw profile type exif"";
            const std::string app1Key = ""Raw profile type APP1"";
            const std::string iptcKey = ""Raw profile type iptc"";
            const std::string iccKey  = ""icc"";
            const std::string softKey = ""Software"";
            const std::string commKey = ""Comment"";
            const std::string descKey = ""Description"";

            bool bPrint = option == kpsBasic || option == kpsRecursive ;
            if ( bPrint ) {
                out << ""STRUCTURE OF PNG FILE: "" << io_->path() << std::endl;
                out << "" address | chunk |  length | data                           | checksum"" << std::endl;
            }

            const long imgSize = (long) io_->size();
            DataBuf    cheaderBuf(8);

            while( !io_->eof() && ::strcmp(chType,""IEND"") ) {
                size_t address = io_->tell();

                std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);
                long bufRead = io_->read(cheaderBuf.pData_, cheaderBuf.size_);
                if (io_->error()) throw Error(kerFailedToReadImageData);
                if (bufRead != cheaderBuf.size_) throw Error(kerInputDataReadFailed);

                // Decode chunk data length.
                const uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);
                for (int i = 4; i < 8; i++) {
                    chType[i-4]=cheaderBuf.pData_[i];
                }

                // test that we haven't hit EOF, or wanting to read excessive data
                long restore = io_->tell();
                if(  restore == -1
                ||  dataOffset > uint32_t(0x7FFFFFFF)
                ||  static_cast<long>(dataOffset) > imgSize - restore
                ){
                    throw Exiv2::Error(kerFailedToReadImageData);
                }

                DataBuf   buff(dataOffset);
                bufRead = io_->read(buff.pData_,dataOffset);
                enforce(bufRead == static_cast<long>(dataOffset), kerFailedToReadImageData);
                io_->seek(restore, BasicIo::beg);

                // format output
                const int    iMax = 30 ;
                const uint32_t blen = dataOffset > iMax ? iMax : dataOffset ;
                std::string dataString = """";
                // if blen == 0 => slice construction fails
                if (blen > 0) {
                    std::stringstream ss;
                    ss << Internal::binaryToString(makeSlice(buff, 0, blen));
                    dataString = ss.str();
                }
                while (      dataString.size() < iMax ) dataString += ' ';
                dataString = dataString.substr(0,iMax);

                if ( bPrint ) {
                    io_->seek(dataOffset, BasicIo::cur);// jump to checksum
                    byte checksum[4];
                    bufRead = io_->read(checksum,4);
                    enforce(bufRead == 4, kerFailedToReadImageData);
                    io_->seek(restore, BasicIo::beg)   ;// restore file pointer

                    out << Internal::stringFormat(""%8d | %-5s |%8d | ""
                                                  ,(uint32_t)address, chType,dataOffset)
                        << dataString
                        << Internal::stringFormat("" | 0x%02x%02x%02x%02x""
                                                   ,checksum[0],checksum[1],checksum[2],checksum[3])
                        << std::endl;
                }

                // chunk type
                bool tEXt  = std::strcmp(chType,""tEXt"")== 0;
                bool zTXt  = std::strcmp(chType,""zTXt"")== 0;
                bool iCCP  = std::strcmp(chType,""iCCP"")== 0;
                bool iTXt  = std::strcmp(chType,""iTXt"")== 0;

                // for XMP, ICC etc: read and format data
                bool bXMP  = option == kpsXMP        && findi(dataString,xmpKey)==0;
                bool bICC  = option == kpsIccProfile && findi(dataString,iccKey)==0;
                bool bExif = option == kpsRecursive  &&(findi(dataString,exifKey)==0 || findi(dataString,app1Key)==0);
                bool bIptc = option == kpsRecursive  && findi(dataString,iptcKey)==0;
                bool bSoft = option == kpsRecursive  && findi(dataString,softKey)==0;
                bool bComm = option == kpsRecursive  && findi(dataString,commKey)==0;
                bool bDesc = option == kpsRecursive  && findi(dataString,descKey)==0;
                bool bDump = bXMP || bICC || bExif || bIptc || bSoft || bComm || bDesc ;

                if( bDump ) {
                    DataBuf   dataBuf;
                    byte*     data   = new byte[dataOffset+1];
                    data[dataOffset] = 0;
                    bufRead = io_->read(data,dataOffset);
                    enforce(bufRead == static_cast<long>(dataOffset), kerFailedToReadImageData);
                    io_->seek(restore, BasicIo::beg);
                    uint32_t  name_l = (uint32_t) std::strlen((const char*)data)+1; // leading string length
                    enforce(name_l <= dataOffset, kerCorruptedMetadata);

                    uint32_t  start  = name_l;
                    bool      bLF    = false;

                    // decode the chunk
                    bool bGood = false;
                    if ( tEXt ) {
                        bGood = tEXtToDataBuf(data+name_l,dataOffset-name_l,dataBuf);
                    }
                    if ( zTXt || iCCP ) {
                        bGood = zlibToDataBuf(data+name_l+1,dataOffset-name_l-1,dataBuf); // +1 = 'compressed' flag
                    }
                    if ( iTXt ) {
                        bGood = (start+3) < dataOffset ;    // good if not a nul chunk
                    }

                    // format is content dependent
                    if ( bGood ) {
                        if ( bXMP ) {
                            while ( !data[start] && start < dataOffset) start++; // skip leading nul bytes
                            out <<  data+start;             // output the xmp
                        }

                        if ( bExif || bIptc ) {
                            DataBuf parsedBuf = PngChunk::readRawProfile(dataBuf,tEXt);
#if DEBUG
                            std::cerr << Exiv2::Internal::binaryToString(parsedBuf.pData_, parsedBuf.size_>50?50:parsedBuf.size_,0) << std::endl;
#endif
                            if ( parsedBuf.size_ ) {
                                if ( bExif ) {
                                    // create memio object with the data, then print the structure
                                    BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(parsedBuf.pData_+6,parsedBuf.size_-6));
                                    printTiffStructure(*p,out,option,depth);
                                }
                                if ( bIptc ) {
                                    IptcData::printStructure(out, makeSlice(parsedBuf.pData_, 0, parsedBuf.size_), depth);
                                }
                            }
                        }

                        if ( bSoft && dataBuf.size_ > 0) {
                            DataBuf     s(dataBuf.size_+1);               // allocate buffer with an extra byte
                            memcpy(s.pData_,dataBuf.pData_,dataBuf.size_);// copy in the dataBuf
                            s.pData_[dataBuf.size_] = 0 ;                 // nul terminate it
                            const char* str = (const char*) s.pData_;     // give it name
                            out << Internal::indent(depth) << (const char*) buff.pData_ << "": "" << str ;
                            bLF=true;
                        }

                        if ( bICC || bComm ) {
                            out.write((const char*) dataBuf.pData_,dataBuf.size_);
                            bLF = bComm ;
                        }

                        if ( bDesc && iTXt ) {
                            DataBuf decoded = PngChunk::decodeTXTChunk(buff,PngChunk::iTXt_Chunk );
                            out.write((const char*)decoded.pData_,decoded.size_);
                            bLF = true;
                        }

                        if ( bLF ) out << std::endl;
                    }
                    delete[] data;
                }
                io_->seek(dataOffset+4, BasicIo::cur);// jump past checksum
                if (io_->error()) throw Error(kerFailedToReadImageData);
            }
        }
    }","void PngImage::printStructure(std::ostream& VAR_0, PrintStructureOption VAR_1, int VAR_2)
    {
        if (VAR_3->open() != 0) {
            throw Error(VAR_4, VAR_3->path(), strError());
        }
        if (!isPngType(*VAR_3, true)) {
            throw Error(VAR_5, ""PNG"");
        }

        char    VAR_6[5];
        VAR_6[0]=0;
        VAR_6[4]=0;

        if ( VAR_1 == VAR_7 || VAR_1 == VAR_8 || VAR_1 == VAR_9 || VAR_1 == VAR_10 ) {

            const std::string VAR_11  = ""XML:com.adobe.xmp"";
            const std::string VAR_12 = ""Raw profile type exif"";
            const std::string VAR_13 = ""Raw profile type APP1"";
            const std::string VAR_14 = ""Raw profile type iptc"";
            const std::string VAR_15  = ""icc"";
            const std::string VAR_16 = ""Software"";
            const std::string VAR_17 = ""Comment"";
            const std::string VAR_18 = ""Description"";

            bool VAR_19 = VAR_1 == VAR_7 || VAR_1 == VAR_10 ;
            if ( VAR_19 ) {
                VAR_0 << ""STRUCTURE OF PNG FILE: "" << VAR_3->path() << std::endl;
                VAR_0 << "" address | chunk |  length | data                           | checksum"" << std::endl;
            }

            const long VAR_20 = (long) VAR_3->size();
            DataBuf    VAR_21(8);

            while( !VAR_3->eof() && ::strcmp(VAR_6,""IEND"") ) {
                size_t VAR_22 = VAR_3->tell();

                std::memset(VAR_21.pData_, 0x0, VAR_21.size_);
                long VAR_23 = VAR_3->read(VAR_21.pData_, VAR_21.size_);
                if (VAR_3->error()) throw Error(VAR_24);
                if (VAR_23 != VAR_21.size_) throw Error(VAR_25);

                /* COMMENT_0 */
                const uint32_t VAR_26 = Exiv2::getULong(VAR_21.pData_, Exiv2::bigEndian);
                for (int VAR_27 = 4; VAR_27 < 8; VAR_27++) {
                    VAR_6[VAR_27-4]=VAR_21.pData_[VAR_27];
                }

                /* COMMENT_1 */
                long VAR_28 = VAR_3->tell();
                if(  VAR_28 == -1
                ||  VAR_26 > uint32_t(0x7FFFFFFF)
                ||  VAR_29<long>(VAR_26) > VAR_20 - VAR_28
                ){
                    throw Exiv2::Error(VAR_24);
                }

                DataBuf   buff(dataOffset);
                VAR_23 = VAR_3->read(VAR_30.pData_,dataOffset);
                enforce(VAR_23 == VAR_29<long>(dataOffset), VAR_24);
                VAR_3->seek(VAR_28, BasicIo::beg);

                /* COMMENT_2 */
                const int    VAR_31 = 30 ;
                const uint32_t VAR_32 = dataOffset > VAR_31 ? VAR_31 : dataOffset ;
                std::string VAR_33 = """";
                /* COMMENT_3 */
                if (VAR_32 > 0) {
                    std::stringstream VAR_34;
                    VAR_34 << Internal::binaryToString(makeSlice(VAR_30, 0, VAR_32));
                    VAR_33 = VAR_34.str();
                }
                while (      VAR_33.size() < VAR_31 ) VAR_33 += ' ';
                VAR_33 = VAR_33.substr(0,VAR_31);

                if ( VAR_19 ) {
                    VAR_3->seek(dataOffset, BasicIo::cur);/* COMMENT_4 */
                    byte VAR_35[4];
                    VAR_23 = VAR_3->read(VAR_35,4);
                    enforce(VAR_23 == 4, VAR_24);
                    VAR_3->seek(VAR_28, BasicIo::beg)   ;/* COMMENT_5 */

                    VAR_0 << Internal::stringFormat(""%8d | %-5s |%8d | ""
                                                  ,(uint32_t)VAR_22, VAR_6,dataOffset)
                        << VAR_33
                        << Internal::stringFormat("" | 0x%02x%02x%02x%02x""
                                                   ,VAR_35[0],VAR_35[1],VAR_35[2],VAR_35[3])
                        << std::endl;
                }

                /* COMMENT_6 */
                bool VAR_36  = std::strcmp(VAR_6,""tEXt"")== 0;
                bool VAR_37  = std::strcmp(VAR_6,""zTXt"")== 0;
                bool VAR_38  = std::strcmp(VAR_6,""iCCP"")== 0;
                bool VAR_39  = std::strcmp(VAR_6,""iTXt"")== 0;

                /* COMMENT_7 */
                bool VAR_40  = VAR_1 == VAR_8        && findi(VAR_33,VAR_11)==0;
                bool VAR_41  = VAR_1 == VAR_9 && findi(VAR_33,VAR_15)==0;
                bool VAR_42 = VAR_1 == VAR_10  &&(findi(VAR_33,VAR_12)==0 || findi(VAR_33,VAR_13)==0);
                bool VAR_43 = VAR_1 == VAR_10  && findi(VAR_33,VAR_14)==0;
                bool VAR_44 = VAR_1 == VAR_10  && findi(VAR_33,VAR_16)==0;
                bool VAR_45 = VAR_1 == VAR_10  && findi(VAR_33,VAR_17)==0;
                bool VAR_46 = VAR_1 == VAR_10  && findi(VAR_33,VAR_18)==0;
                bool VAR_47 = VAR_40 || VAR_41 || VAR_42 || VAR_43 || VAR_44 || VAR_45 || VAR_46 ;

                if( VAR_47 ) {
                    DataBuf   VAR_48;
                    byte*     VAR_49   = new byte[dataOffset+1];
                    VAR_49[dataOffset] = 0;
                    VAR_23 = VAR_3->read(VAR_49,dataOffset);
                    enforce(VAR_23 == VAR_29<long>(dataOffset), VAR_24);
                    VAR_3->seek(VAR_28, BasicIo::beg);
                    uint32_t  VAR_50 = (uint32_t) std::strlen((const char*)VAR_49)+1; /* COMMENT_8 */
                    enforce(VAR_50 <= dataOffset, VAR_51);

                    uint32_t  VAR_52  = VAR_50;
                    bool      VAR_53    = false;

                    /* COMMENT_9 */
                    bool VAR_54 = false;
                    if ( VAR_36 ) {
                        VAR_54 = tEXtToDataBuf(VAR_49+VAR_50,dataOffset-VAR_50,VAR_48);
                    }
                    if ( VAR_37 || VAR_38 ) {
                        VAR_54 = zlibToDataBuf(VAR_49+VAR_50+1,dataOffset-VAR_50-1,VAR_48); /* COMMENT_10 */
                    }
                    if ( VAR_39 ) {
                        VAR_54 = (VAR_52+3) < dataOffset ;    /* COMMENT_11 */
                    }

                    /* COMMENT_12 */
                    if ( VAR_54 ) {
                        if ( VAR_40 ) {
                            while ( !VAR_49[VAR_52] && VAR_52 < dataOffset) VAR_52++; /* COMMENT_13 */
                            VAR_0 <<  VAR_49+VAR_52;             /* COMMENT_14 */
                        }

                        if ( VAR_42 || VAR_43 ) {
                            DataBuf VAR_55 = PngChunk::readRawProfile(VAR_48,VAR_36);
#if VAR_56
                            std::cerr << Exiv2::Internal::binaryToString(VAR_55.pData_, VAR_55.size_>50?50:VAR_55.size_,0) << std::endl;
#endif
                            if ( VAR_55.size_ ) {
                                if ( VAR_42 ) {
                                    /* COMMENT_15 */
                                    BasicIo::AutoPtr VAR_57 = BasicIo::AutoPtr(new MemIo(VAR_55.pData_+6,VAR_55.size_-6));
                                    printTiffStructure(*VAR_57,VAR_0,VAR_1,VAR_2);
                                }
                                if ( VAR_43 ) {
                                    IptcData::printStructure(VAR_0, makeSlice(VAR_55.pData_, 0, VAR_55.size_), VAR_2);
                                }
                            }
                        }

                        if ( VAR_44 && VAR_48.size_ > 0) {
                            DataBuf     VAR_58(VAR_48.size_+1);               /* COMMENT_16 */
                            memcpy(VAR_58.pData_,VAR_48.pData_,VAR_48.size_);/* COMMENT_17 */
                            VAR_58.pData_[VAR_48.size_] = 0 ;                 /* COMMENT_18 */
                            const char* VAR_59 = (const char*) VAR_58.pData_;     /* COMMENT_19 */
                            VAR_0 << Internal::indent(VAR_2) << (const char*) VAR_30.pData_ << "": "" << VAR_59 ;
                            VAR_53=true;
                        }

                        if ( VAR_41 || VAR_45 ) {
                            VAR_0.write((const char*) VAR_48.pData_,VAR_48.size_);
                            VAR_53 = VAR_45 ;
                        }

                        if ( VAR_46 && VAR_39 ) {
                            DataBuf VAR_60 = PngChunk::decodeTXTChunk(VAR_30,PngChunk::iTXt_Chunk );
                            VAR_0.write((const char*)VAR_60.pData_,VAR_60.size_);
                            VAR_53 = true;
                        }

                        if ( VAR_53 ) VAR_0 << std::endl;
                    }
                    delete[] VAR_49;
                }
                VAR_3->seek(dataOffset+4, BasicIo::cur);/* COMMENT_20 */
                if (VAR_3->error()) throw Error(VAR_24);
            }
        }
    }",Exiv2/exiv2/20a13f00e2db24c58ee326e4c89a56469718b30e/pngimage.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,7 +40,7 @@
                 if (bufRead != cheaderBuf.size_) throw Error(kerInputDataReadFailed);
 
                 // Decode chunk data length.
-                uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);
+                const uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);
                 for (int i = 4; i < 8; i++) {
                     chType[i-4]=cheaderBuf.pData_[i];
                 }
@@ -55,7 +55,8 @@
                 }
 
                 DataBuf   buff(dataOffset);
-                io_->read(buff.pData_,dataOffset);
+                bufRead = io_->read(buff.pData_,dataOffset);
+                enforce(bufRead == static_cast<long>(dataOffset), kerFailedToReadImageData);
                 io_->seek(restore, BasicIo::beg);
 
                 // format output
@@ -74,7 +75,8 @@
                 if ( bPrint ) {
                     io_->seek(dataOffset, BasicIo::cur);// jump to checksum
                     byte checksum[4];
-                    io_->read(checksum,4);
+                    bufRead = io_->read(checksum,4);
+                    enforce(bufRead == 4, kerFailedToReadImageData);
                     io_->seek(restore, BasicIo::beg)   ;// restore file pointer
 
                     out << Internal::stringFormat(""%8d | %-5s |%8d | ""
@@ -105,9 +107,12 @@
                     DataBuf   dataBuf;
                     byte*     data   = new byte[dataOffset+1];
                     data[dataOffset] = 0;
-                    io_->read(data,dataOffset);
+                    bufRead = io_->read(data,dataOffset);
+                    enforce(bufRead == static_cast<long>(dataOffset), kerFailedToReadImageData);
                     io_->seek(restore, BasicIo::beg);
                     uint32_t  name_l = (uint32_t) std::strlen((const char*)data)+1; // leading string length
+                    enforce(name_l <= dataOffset, kerCorruptedMetadata);
+
                     uint32_t  start  = name_l;
                     bool      bLF    = false;
 ","{'deleted_lines': ['                uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);', '                io_->read(buff.pData_,dataOffset);', '                    io_->read(checksum,4);', '                    io_->read(data,dataOffset);'], 'added_lines': ['                const uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);', '                bufRead = io_->read(buff.pData_,dataOffset);', '                enforce(bufRead == static_cast<long>(dataOffset), kerFailedToReadImageData);', '                    bufRead = io_->read(checksum,4);', '                    enforce(bufRead == 4, kerFailedToReadImageData);', '                    bufRead = io_->read(data,dataOffset);', '                    enforce(bufRead == static_cast<long>(dataOffset), kerFailedToReadImageData);', '                    enforce(name_l <= dataOffset, kerCorruptedMetadata);', '']}",True,Buffer Overflow vulnerability in tEXtToDataBuf function in pngimage.cpp in Exiv2 0.27.1 allows remote attackers to cause a denial of service and other unspecified impacts via use of crafted file.,7.8,HIGH,2,test,2019-05-16T12:22:53Z,2
CVE-2019-12448,['CWE-362'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,GNOME/gvfs,"admin: Add query_info_on_read/write functionality

Admin backend doesn't implement query_info_on_read/write which might
potentially lead to some race conditions which aren't really wanted
especially in case of admin backend. For example, in file_copy_fallback(),
g_file_query_info() is used if g_file_input_stream_query_info() is not
supported, which in theory means that the info might be obtained from
the different file then it is opened. Let's add this missing
functionality to prevent this possibility.",764e9af7522e3096c0f44613c330377d31c9bbb5,https://github.com/GNOME/gvfs/commit/764e9af7522e3096c0f44613c330377d31c9bbb5,daemon/gvfsbackendadmin.c,do_query_info,"static void
do_query_info (GVfsBackend *backend,
GVfsJobQueryInfo *query_info_job,
const char *filename,
GFileQueryInfoFlags flags,
GFileInfo *info,
GFileAttributeMatcher *matcher)
{
GVfsBackendAdmin *self = G_VFS_BACKEND_ADMIN (backend);
GVfsJob *job = G_VFS_JOB (query_info_job);
GError *error = NULL;
GFile *file;
GFileInfo *real_info;
if (!check_permission (self, job))
return;
file = g_file_new_for_path (filename);
real_info = g_file_query_info (file, query_info_job->attributes,
flags, job->cancellable, &error);
g_object_unref (file);
if (error != NULL)
goto out;
g_file_info_set_attribute_boolean (real_info,
G_FILE_ATTRIBUTE_ACCESS_CAN_READ, TRUE);
g_file_info_set_attribute_boolean (real_info,
G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE, TRUE);
g_file_info_set_attribute_boolean (real_info,
G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE, TRUE);
g_file_info_set_attribute_boolean (real_info,
G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME, TRUE);
g_file_info_copy_into (real_info, info);
g_object_unref (real_info);
out:
complete_job (job, error);
}","static void
do_query_info (GVfsBackend *VAR_0,
GVfsJobQueryInfo *VAR_1,
const char *VAR_2,
GFileQueryInfoFlags VAR_3,
GFileInfo *VAR_4,
GFileAttributeMatcher *VAR_5)
{
GVfsBackendAdmin *VAR_6 = G_VFS_BACKEND_ADMIN (VAR_0);
GVfsJob *VAR_7 = G_VFS_JOB (VAR_1);
GError *VAR_8 = NULL;
GFile *VAR_9;
GFileInfo *VAR_10;
if (!check_permission (VAR_6, VAR_7))
return;
VAR_9 = g_file_new_for_path (VAR_2);
VAR_10 = g_file_query_info (VAR_9, VAR_1->attributes,
VAR_3, VAR_7->cancellable, &VAR_8);
g_object_unref (VAR_9);
if (VAR_8 != NULL)
goto out;
g_file_info_set_attribute_boolean (VAR_10,
VAR_11, TRUE);
g_file_info_set_attribute_boolean (VAR_10,
VAR_12, TRUE);
g_file_info_set_attribute_boolean (VAR_10,
VAR_13, TRUE);
g_file_info_set_attribute_boolean (VAR_10,
VAR_14, TRUE);
g_file_info_copy_into (VAR_10, VAR_4);
g_object_unref (VAR_10);
out:
complete_job (VAR_7, VAR_8);
}",GNOME/gvfs/764e9af7522e3096c0f44613c330377d31c9bbb5/gvfsbackendadmin.c/vul/before/0.json,"static void
do_query_info (GVfsBackend *backend,
               GVfsJobQueryInfo *query_info_job,
               const char *filename,
               GFileQueryInfoFlags flags,
               GFileInfo *info,
               GFileAttributeMatcher *matcher)
{
  GVfsBackendAdmin *self = G_VFS_BACKEND_ADMIN (backend);
  GVfsJob *job = G_VFS_JOB (query_info_job);
  GError *error = NULL;
  GFile *file;
  GFileInfo *real_info;

  if (!check_permission (self, job))
    return;

  file = g_file_new_for_path (filename);
  real_info = g_file_query_info (file, query_info_job->attributes,
                                 flags, job->cancellable, &error);
  g_object_unref (file);

  if (error != NULL)
    goto out;

  fix_file_info (real_info);
  g_file_info_copy_into (real_info, info);
  g_object_unref (real_info);

 out:
  complete_job (job, error);
}","static void
do_query_info (GVfsBackend *VAR_0,
               GVfsJobQueryInfo *VAR_1,
               const char *VAR_2,
               GFileQueryInfoFlags VAR_3,
               GFileInfo *VAR_4,
               GFileAttributeMatcher *VAR_5)
{
  GVfsBackendAdmin *VAR_6 = G_VFS_BACKEND_ADMIN (VAR_0);
  GVfsJob *VAR_7 = G_VFS_JOB (VAR_1);
  GError *VAR_8 = NULL;
  GFile *VAR_9;
  GFileInfo *VAR_10;

  if (!check_permission (VAR_6, VAR_7))
    return;

  VAR_9 = g_file_new_for_path (VAR_2);
  VAR_10 = g_file_query_info (VAR_9, VAR_1->attributes,
                                 VAR_3, VAR_7->cancellable, &VAR_8);
  g_object_unref (VAR_9);

  if (VAR_8 != NULL)
    goto out;

  fix_file_info (VAR_10);
  g_file_info_copy_into (VAR_10, VAR_4);
  g_object_unref (VAR_10);

 out:
  complete_job (VAR_7, VAR_8);
}",GNOME/gvfs/764e9af7522e3096c0f44613c330377d31c9bbb5/gvfsbackendadmin.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -23,19 +23,7 @@
   if (error != NULL)
     goto out;
 
-  /* Override read/write flags, since the above call will use access()
-   * to determine permissions, which does not honor our privileged
-   * capabilities.
-   */
-  g_file_info_set_attribute_boolean (real_info,
-                                     G_FILE_ATTRIBUTE_ACCESS_CAN_READ, TRUE);
-  g_file_info_set_attribute_boolean (real_info,
-                                     G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE, TRUE);
-  g_file_info_set_attribute_boolean (real_info,
-                                     G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE, TRUE);
-  g_file_info_set_attribute_boolean (real_info,
-                                     G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME, TRUE);
-
+  fix_file_info (real_info);
   g_file_info_copy_into (real_info, info);
   g_object_unref (real_info);
 ","{'deleted_lines': ['  /* Override read/write flags, since the above call will use access()', '   * to determine permissions, which does not honor our privileged', '   * capabilities.', '   */', '  g_file_info_set_attribute_boolean (real_info,', '                                     G_FILE_ATTRIBUTE_ACCESS_CAN_READ, TRUE);', '  g_file_info_set_attribute_boolean (real_info,', '                                     G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE, TRUE);', '  g_file_info_set_attribute_boolean (real_info,', '                                     G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE, TRUE);', '  g_file_info_set_attribute_boolean (real_info,', '                                     G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME, TRUE);', ''], 'added_lines': ['  fix_file_info (real_info);']}",True,An issue was discovered in GNOME gvfs 1.29.4 through 1.41.2. daemon/gvfsbackendadmin.c has race conditions because the admin backend doesn't implement query_info_on_read/write.,8.1,HIGH,2,test,2019-05-23T08:24:36Z,2
CVE-2019-12448,['CWE-362'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,GNOME/gvfs,"admin: Add query_info_on_read/write functionality

Admin backend doesn't implement query_info_on_read/write which might
potentially lead to some race conditions which aren't really wanted
especially in case of admin backend. For example, in file_copy_fallback(),
g_file_query_info() is used if g_file_input_stream_query_info() is not
supported, which in theory means that the info might be obtained from
the different file then it is opened. Let's add this missing
functionality to prevent this possibility.",764e9af7522e3096c0f44613c330377d31c9bbb5,https://github.com/GNOME/gvfs/commit/764e9af7522e3096c0f44613c330377d31c9bbb5,daemon/gvfsbackendadmin.c,g_vfs_backend_admin_class_init,"static void
g_vfs_backend_admin_class_init (GVfsBackendAdminClass * klass)
{
GObjectClass *object_class = G_OBJECT_CLASS (klass);
GVfsBackendClass *backend_class = G_VFS_BACKEND_CLASS (klass);
object_class->finalize = do_finalize;
backend_class->mount = do_mount;
backend_class->open_for_read = do_open_for_read;
backend_class->query_info = do_query_info;
backend_class->read = do_read;
backend_class->create = do_create;
backend_class->append_to = do_append_to;
backend_class->replace = do_replace;
backend_class->write = do_write;
backend_class->close_read = do_close_read;
backend_class->close_write = do_close_write;
backend_class->seek_on_read = do_seek_on_read;
backend_class->seek_on_write = do_seek_on_write;
backend_class->enumerate = do_enumerate;
backend_class->truncate = do_truncate;
backend_class->make_directory = do_make_directory;
backend_class->make_symlink = do_make_symlink;
backend_class->query_fs_info = do_query_fs_info;
backend_class->create_dir_monitor = do_create_dir_monitor;
backend_class->create_file_monitor = do_create_file_monitor;
backend_class->set_display_name = do_set_display_name;
backend_class->set_attribute = do_set_attribute;
backend_class->delete = do_delete;
backend_class->move = do_move;
backend_class->query_settable_attributes = do_query_settable_attributes;
backend_class->query_writable_namespaces = do_query_writable_namespaces;
}","static void
g_vfs_backend_admin_class_init (GVfsBackendAdminClass * VAR_0)
{
GObjectClass *VAR_1 = G_OBJECT_CLASS (VAR_0);
GVfsBackendClass *VAR_2 = G_VFS_BACKEND_CLASS (VAR_0);
VAR_1->finalize = VAR_3;
VAR_2->mount = VAR_4;
VAR_2->open_for_read = VAR_5;
VAR_2->query_info = VAR_6;
VAR_2->read = VAR_7;
VAR_2->create = VAR_8;
VAR_2->append_to = VAR_9;
VAR_2->replace = VAR_10;
VAR_2->write = VAR_11;
VAR_2->close_read = VAR_12;
VAR_2->close_write = VAR_13;
VAR_2->seek_on_read = VAR_14;
VAR_2->seek_on_write = VAR_15;
VAR_2->enumerate = VAR_16;
VAR_2->truncate = VAR_17;
VAR_2->make_directory = VAR_18;
VAR_2->make_symlink = VAR_19;
VAR_2->query_fs_info = VAR_20;
VAR_2->create_dir_monitor = VAR_21;
VAR_2->create_file_monitor = VAR_22;
VAR_2->set_display_name = VAR_23;
VAR_2->set_attribute = VAR_24;
VAR_2->delete = VAR_25;
VAR_2->move = VAR_26;
VAR_2->query_settable_attributes = VAR_27;
VAR_2->query_writable_namespaces = VAR_28;
}",GNOME/gvfs/764e9af7522e3096c0f44613c330377d31c9bbb5/gvfsbackendadmin.c/vul/before/1.json,"static void
g_vfs_backend_admin_class_init (GVfsBackendAdminClass * klass)
{
  GObjectClass *object_class = G_OBJECT_CLASS (klass);
  GVfsBackendClass *backend_class = G_VFS_BACKEND_CLASS (klass);

  object_class->finalize = do_finalize;

  backend_class->mount = do_mount;
  backend_class->open_for_read = do_open_for_read;
  backend_class->query_info = do_query_info;
  backend_class->query_info_on_read = do_query_info_on_read;
  backend_class->query_info_on_write = do_query_info_on_write;
  backend_class->read = do_read;
  backend_class->create = do_create;
  backend_class->append_to = do_append_to;
  backend_class->replace = do_replace;
  backend_class->write = do_write;
  backend_class->close_read = do_close_read;
  backend_class->close_write = do_close_write;
  backend_class->seek_on_read = do_seek_on_read;
  backend_class->seek_on_write = do_seek_on_write;
  backend_class->enumerate = do_enumerate;
  backend_class->truncate = do_truncate;
  backend_class->make_directory = do_make_directory;
  backend_class->make_symlink = do_make_symlink;
  backend_class->query_fs_info = do_query_fs_info;
  backend_class->create_dir_monitor = do_create_dir_monitor;
  backend_class->create_file_monitor = do_create_file_monitor;
  backend_class->set_display_name = do_set_display_name;
  backend_class->set_attribute = do_set_attribute;
  backend_class->delete = do_delete;
  backend_class->move = do_move;
  backend_class->query_settable_attributes = do_query_settable_attributes;
  backend_class->query_writable_namespaces = do_query_writable_namespaces;
}","static void
g_vfs_backend_admin_class_init (GVfsBackendAdminClass * VAR_0)
{
  GObjectClass *VAR_1 = G_OBJECT_CLASS (VAR_0);
  GVfsBackendClass *VAR_2 = G_VFS_BACKEND_CLASS (VAR_0);

  VAR_1->finalize = VAR_3;

  VAR_2->mount = VAR_4;
  VAR_2->open_for_read = VAR_5;
  VAR_2->query_info = VAR_6;
  VAR_2->query_info_on_read = VAR_7;
  VAR_2->query_info_on_write = VAR_8;
  VAR_2->read = VAR_9;
  VAR_2->create = VAR_10;
  VAR_2->append_to = VAR_11;
  VAR_2->replace = VAR_12;
  VAR_2->write = VAR_13;
  VAR_2->close_read = VAR_14;
  VAR_2->close_write = VAR_15;
  VAR_2->seek_on_read = VAR_16;
  VAR_2->seek_on_write = VAR_17;
  VAR_2->enumerate = VAR_18;
  VAR_2->truncate = VAR_19;
  VAR_2->make_directory = VAR_20;
  VAR_2->make_symlink = VAR_21;
  VAR_2->query_fs_info = VAR_22;
  VAR_2->create_dir_monitor = VAR_23;
  VAR_2->create_file_monitor = VAR_24;
  VAR_2->set_display_name = VAR_25;
  VAR_2->set_attribute = VAR_26;
  VAR_2->delete = VAR_27;
  VAR_2->move = VAR_28;
  VAR_2->query_settable_attributes = VAR_29;
  VAR_2->query_writable_namespaces = VAR_30;
}",GNOME/gvfs/764e9af7522e3096c0f44613c330377d31c9bbb5/gvfsbackendadmin.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,6 +9,8 @@
   backend_class->mount = do_mount;
   backend_class->open_for_read = do_open_for_read;
   backend_class->query_info = do_query_info;
+  backend_class->query_info_on_read = do_query_info_on_read;
+  backend_class->query_info_on_write = do_query_info_on_write;
   backend_class->read = do_read;
   backend_class->create = do_create;
   backend_class->append_to = do_append_to;","{'deleted_lines': [], 'added_lines': ['  backend_class->query_info_on_read = do_query_info_on_read;', '  backend_class->query_info_on_write = do_query_info_on_write;']}",True,An issue was discovered in GNOME gvfs 1.29.4 through 1.41.2. daemon/gvfsbackendadmin.c has race conditions because the admin backend doesn't implement query_info_on_read/write.,8.1,HIGH,2,test,2019-05-23T08:24:36Z,2
CVE-2019-13118,['CWE-843'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0.0,GNOME/libxslt,"Fix uninitialized read with UTF-8 grouping chars

The character type in xsltFormatNumberConversion was too narrow and
an invalid character/length combination could be passed to
xsltNumberFormatDecimal, resulting in an uninitialized read.

Found by OSS-Fuzz.",6ce8de69330783977dd14f6569419489875fb71b,https://github.com/GNOME/libxslt/commit/6ce8de69330783977dd14f6569419489875fb71b,libxslt/numbers.c,xsltFormatNumberConversion,"xmlXPathError
xsltFormatNumberConversion(xsltDecimalFormatPtr self,
xmlChar *format,
double number,
xmlChar **result)
{
xmlXPathError status = XPATH_EXPRESSION_OK;
xmlBufferPtr buffer;
xmlChar *the_format, *prefix = NULL, *suffix = NULL;
xmlChar *nprefix, *nsuffix = NULL;
xmlChar pchar;
int    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;
double  scale;
int    j, len;
int     self_grouping_len;
xsltFormatNumberInfo format_info;
intdelayed_multiplier = 0;
chardefault_sign = 0;
charfound_error = 0;
if (xmlStrlen(format) <= 0) {
xsltTransformError(NULL, NULL, NULL,
""xsltFormatNumberConversion : ""
""Invalid format (0-length)\n"");
}
*result = NULL;
switch (xmlXPathIsInf(number)) {
case -1:
if (self->minusSign == NULL)
*result = xmlStrdup(BAD_CAST ""-"");
else
*result = xmlStrdup(self->minusSign);
case 1:
if ((self == NULL) || (self->infinity == NULL))
*result = xmlStrcat(*result, BAD_CAST ""Infinity"");
else
*result = xmlStrcat(*result, self->infinity);
return(status);
default:
if (xmlXPathIsNaN(number)) {
if ((self == NULL) || (self->noNumber == NULL))
*result = xmlStrdup(BAD_CAST ""NaN"");
else
*result = xmlStrdup(self->noNumber);
return(status);
}
}
buffer = xmlBufferCreate();
if (buffer == NULL) {
return XPATH_MEMORY_ERROR;
}
format_info.integer_hash = 0;
format_info.integer_digits = 0;
format_info.frac_digits = 0;
format_info.frac_hash = 0;
format_info.group = -1;
format_info.multiplier = 1;
format_info.add_decimal = FALSE;
format_info.is_multiplier_set = FALSE;
format_info.is_negative_pattern = FALSE;
the_format = format;
prefix = the_format;
prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);
if (prefix_length < 0) {
found_error = 1;
goto OUTPUT_NUMBER;
}
self_grouping_len = xmlStrlen(self->grouping);
while ((*the_format != 0) &&
(xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&
(xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {
if (delayed_multiplier != 0) {
format_info.multiplier = delayed_multiplier;
format_info.is_multiplier_set = TRUE;
delayed_multiplier = 0;
}
if (xsltUTF8Charcmp(the_format, self->digit) == 0) {
if (format_info.integer_digits > 0) {
found_error = 1;
goto OUTPUT_NUMBER;
}
format_info.integer_hash++;
if (format_info.group >= 0)
format_info.group++;
} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {
format_info.integer_digits++;
if (format_info.group >= 0)
format_info.group++;
} else if ((self_grouping_len > 0) &&
(!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {
format_info.group = 0;
the_format += self_grouping_len;
continue;
} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {
if (format_info.is_multiplier_set) {
found_error = 1;
goto OUTPUT_NUMBER;
}
delayed_multiplier = 100;
} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {
if (format_info.is_multiplier_set) {
found_error = 1;
goto OUTPUT_NUMBER;
}
delayed_multiplier = 1000;
} else
break; 
if ((len=xmlUTF8Strsize(the_format, 1)) < 1) {
found_error = 1;
goto OUTPUT_NUMBER;
}
the_format += len;
}
if ( (*the_format != 0) &&
(xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {
format_info.add_decimal = TRUE;
if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
found_error = 1;
goto OUTPUT_NUMBER;
}
the_format += len;
}
while (*the_format != 0) {
if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {
if (format_info.frac_hash != 0) {
found_error = 1;
goto OUTPUT_NUMBER;
}
format_info.frac_digits++;
} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {
format_info.frac_hash++;
} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {
if (format_info.is_multiplier_set) {
found_error = 1;
goto OUTPUT_NUMBER;
}
delayed_multiplier = 100;
if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
found_error = 1;
goto OUTPUT_NUMBER;
}
the_format += len;
continue; 
} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {
if (format_info.is_multiplier_set) {
found_error = 1;
goto OUTPUT_NUMBER;
}
delayed_multiplier = 1000;
if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
found_error = 1;
goto OUTPUT_NUMBER;
}
the_format += len;
continue; 
} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {
break; 
}
if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
found_error = 1;
goto OUTPUT_NUMBER;
}
the_format += len;
if (delayed_multiplier != 0) {
format_info.multiplier = delayed_multiplier;
delayed_multiplier = 0;
format_info.is_multiplier_set = TRUE;
}
}
if (delayed_multiplier != 0) {
the_format -= len;
delayed_multiplier = 0;
}
suffix = the_format;
suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);
if ( (suffix_length < 0) ||
((*the_format != 0) &&
(xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {
found_error = 1;
goto OUTPUT_NUMBER;
}
if (number < 0) {
j =  xmlUTF8Strloc(format, self->patternSeparator);
if (j < 0) {
default_sign = 1;
}
else {
the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);
format_info.is_negative_pattern = TRUE;
format_info.is_multiplier_set = FALSE;
nprefix = the_format;
nprefix_length = xsltFormatNumberPreSuffix(self,
&the_format, &format_info);
if (nprefix_length<0) {
found_error = 1;
goto OUTPUT_NUMBER;
}
while (*the_format != 0) {
if ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||
(xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {
if (format_info.is_multiplier_set) {
found_error = 1;
goto OUTPUT_NUMBER;
}
format_info.is_multiplier_set = TRUE;
delayed_multiplier = 1;
}
else if (IS_SPECIAL(self, the_format))
delayed_multiplier = 0;
else
break; 
if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
found_error = 1;
goto OUTPUT_NUMBER;
}
the_format += len;
}
if (delayed_multiplier != 0) {
format_info.is_multiplier_set = FALSE;
the_format -= len;
}
if (*the_format != 0) {
nsuffix = the_format;
nsuffix_length = xsltFormatNumberPreSuffix(self,
&the_format, &format_info);
if (nsuffix_length < 0) {
found_error = 1;
goto OUTPUT_NUMBER;
}
}
else
nsuffix_length = 0;
if (*the_format != 0) {
found_error = 1;
goto OUTPUT_NUMBER;
}
if ((nprefix_length != prefix_length) ||
(nsuffix_length != suffix_length) ||
((nprefix_length > 0) &&
(xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||
((nsuffix_length > 0) &&
(xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {
prefix = nprefix;
prefix_length = nprefix_length;
suffix = nsuffix;
suffix_length = nsuffix_length;
} 
}
}
OUTPUT_NUMBER:
if (found_error != 0) {
xsltTransformError(NULL, NULL, NULL,
""xsltFormatNumberConversion : ""
""error in format string '%s', using default\n"", format);
default_sign = (number < 0.0) ? 1 : 0;
prefix_length = suffix_length = 0;
format_info.integer_hash = 0;
format_info.integer_digits = 1;
format_info.frac_digits = 1;
format_info.frac_hash = 4;
format_info.group = -1;
format_info.multiplier = 1;
format_info.add_decimal = TRUE;
}
if (default_sign != 0)
xmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));
for (j = 0; j < prefix_length; j++) {
if ((pchar = *prefix++) == SYMBOL_QUOTE) {
len = xmlUTF8Strsize(prefix, 1);
xmlBufferAdd(buffer, prefix, len);
prefix += len;
j += len - 1;
} else
xmlBufferAdd(buffer, &pchar, 1);
}
number = fabs(number) * (double)format_info.multiplier;
scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));
number = floor((scale * number + 0.5)) / scale;
if ((self->grouping != NULL) &&
(self->grouping[0] != 0)) {
len = xmlStrlen(self->grouping);
pchar = xsltGetUTF8Char(self->grouping, &len);
xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
format_info.integer_digits,
format_info.group,
pchar, len);
} else
xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
format_info.integer_digits,
format_info.group,
',', 1);
if ((format_info.integer_digits + format_info.integer_hash +
format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {
++format_info.frac_digits;
--format_info.frac_hash;
}
if ((floor(number) == 0) &&
(format_info.integer_digits + format_info.frac_digits == 0)) {
xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));
}
if (format_info.frac_digits + format_info.frac_hash == 0) {
if (format_info.add_decimal)
xmlBufferAdd(buffer, self->decimalPoint,
xmlUTF8Strsize(self->decimalPoint, 1));
}
else {
number -= floor(number);
if ((number != 0) || (format_info.frac_digits != 0)) {
xmlBufferAdd(buffer, self->decimalPoint,
xmlUTF8Strsize(self->decimalPoint, 1));
number = floor(scale * number + 0.5);
for (j = format_info.frac_hash; j > 0; j--) {
if (fmod(number, 10.0) >= 1.0)
break; 
number /= 10.0;
}
xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
format_info.frac_digits + j,
0, 0, 0);
}
}
for (j = 0; j < suffix_length; j++) {
if ((pchar = *suffix++) == SYMBOL_QUOTE) {
len = xmlUTF8Strsize(suffix, 1);
xmlBufferAdd(buffer, suffix, len);
suffix += len;
j += len - 1;
} else
xmlBufferAdd(buffer, &pchar, 1);
}
*result = xmlStrdup(xmlBufferContent(buffer));
xmlBufferFree(buffer);
return status;
}","xmlXPathError
xsltFormatNumberConversion(xsltDecimalFormatPtr VAR_0,
xmlChar *VAR_1,
double VAR_2,
xmlChar **VAR_3)
{
xmlXPathError VAR_4 = VAR_5;
xmlBufferPtr VAR_6;
xmlChar *VAR_7, *VAR_8 = NULL, *VAR_9 = NULL;
xmlChar *VAR_10, *VAR_11 = NULL;
xmlChar VAR_12;
int    VAR_13, VAR_14 = 0, VAR_15, VAR_16;
double  VAR_17;
int    VAR_18, VAR_19;
int     VAR_20;
xsltFormatNumberInfo VAR_21;
intVAR_22 = 0;
charVAR_23 = 0;
charVAR_24 = 0;
if (xmlStrlen(VAR_1) <= 0) {
xsltTransformError(NULL, NULL, NULL,
""xsltFormatNumberConversion : ""
""Invalid format (0-length)\n"");
}
*VAR_3 = NULL;
switch (xmlXPathIsInf(VAR_2)) {
case -1:
if (VAR_0->minusSign == NULL)
*VAR_3 = xmlStrdup(VAR_25 ""-"");
else
*VAR_3 = xmlStrdup(VAR_0->minusSign);
case 1:
if ((VAR_0 == NULL) || (VAR_0->infinity == NULL))
*VAR_3 = xmlStrcat(*VAR_3, VAR_25 ""Infinity"");
else
*VAR_3 = xmlStrcat(*VAR_3, VAR_0->infinity);
return(VAR_4);
default:
if (xmlXPathIsNaN(VAR_2)) {
if ((VAR_0 == NULL) || (VAR_0->noNumber == NULL))
*VAR_3 = xmlStrdup(VAR_25 ""NaN"");
else
*VAR_3 = xmlStrdup(VAR_0->noNumber);
return(VAR_4);
}
}
VAR_6 = xmlBufferCreate();
if (VAR_6 == NULL) {
return VAR_26;
}
VAR_21.integer_hash = 0;
VAR_21.integer_digits = 0;
VAR_21.frac_digits = 0;
VAR_21.frac_hash = 0;
VAR_21.group = -1;
VAR_21.multiplier = 1;
VAR_21.add_decimal = FALSE;
VAR_21.is_multiplier_set = FALSE;
VAR_21.is_negative_pattern = FALSE;
VAR_7 = VAR_1;
VAR_8 = VAR_7;
VAR_13 = xsltFormatNumberPreSuffix(VAR_0, &VAR_7, &VAR_21);
if (VAR_13 < 0) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_20 = xmlStrlen(VAR_0->grouping);
while ((*VAR_7 != 0) &&
(xsltUTF8Charcmp(VAR_7, VAR_0->decimalPoint) != 0) &&
(xsltUTF8Charcmp(VAR_7, VAR_0->patternSeparator) != 0)) {
if (VAR_22 != 0) {
VAR_21.multiplier = VAR_22;
VAR_21.is_multiplier_set = TRUE;
VAR_22 = 0;
}
if (xsltUTF8Charcmp(VAR_7, VAR_0->digit) == 0) {
if (VAR_21.integer_digits > 0) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_21.integer_hash++;
if (VAR_21.group >= 0)
VAR_21.group++;
} else if (xsltUTF8Charcmp(VAR_7, VAR_0->zeroDigit) == 0) {
VAR_21.integer_digits++;
if (VAR_21.group >= 0)
VAR_21.group++;
} else if ((VAR_20 > 0) &&
(!xmlStrncmp(VAR_7, VAR_0->grouping, VAR_20))) {
VAR_21.group = 0;
VAR_7 += VAR_20;
continue;
} else if (xsltUTF8Charcmp(VAR_7, VAR_0->percent) == 0) {
if (VAR_21.is_multiplier_set) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_22 = 100;
} else  if (xsltUTF8Charcmp(VAR_7, VAR_0->permille) == 0) {
if (VAR_21.is_multiplier_set) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_22 = 1000;
} else
break; 
if ((VAR_19=xmlUTF8Strsize(VAR_7, 1)) < 1) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_7 += VAR_19;
}
if ( (*VAR_7 != 0) &&
(xsltUTF8Charcmp(VAR_7, VAR_0->decimalPoint) == 0) ) {
VAR_21.add_decimal = TRUE;
if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_7 += VAR_19;
}
while (*VAR_7 != 0) {
if (xsltUTF8Charcmp(VAR_7, VAR_0->zeroDigit) == 0) {
if (VAR_21.frac_hash != 0) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_21.frac_digits++;
} else if (xsltUTF8Charcmp(VAR_7, VAR_0->digit) == 0) {
VAR_21.frac_hash++;
} else if (xsltUTF8Charcmp(VAR_7, VAR_0->percent) == 0) {
if (VAR_21.is_multiplier_set) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_22 = 100;
if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_7 += VAR_19;
continue; 
} else if (xsltUTF8Charcmp(VAR_7, VAR_0->permille) == 0) {
if (VAR_21.is_multiplier_set) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_22 = 1000;
if  ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_7 += VAR_19;
continue; 
} else if (xsltUTF8Charcmp(VAR_7, VAR_0->grouping) != 0) {
break; 
}
if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_7 += VAR_19;
if (VAR_22 != 0) {
VAR_21.multiplier = VAR_22;
VAR_22 = 0;
VAR_21.is_multiplier_set = TRUE;
}
}
if (VAR_22 != 0) {
VAR_7 -= VAR_19;
VAR_22 = 0;
}
VAR_9 = VAR_7;
VAR_14 = xsltFormatNumberPreSuffix(VAR_0, &VAR_7, &VAR_21);
if ( (VAR_14 < 0) ||
((*VAR_7 != 0) &&
(xsltUTF8Charcmp(VAR_7, VAR_0->patternSeparator) != 0)) ) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
if (VAR_2 < 0) {
VAR_18 =  xmlUTF8Strloc(VAR_1, VAR_0->patternSeparator);
if (VAR_18 < 0) {
VAR_23 = 1;
}
else {
VAR_7 = (xmlChar *)xmlUTF8Strpos(VAR_1, VAR_18 + 1);
VAR_21.is_negative_pattern = TRUE;
VAR_21.is_multiplier_set = FALSE;
VAR_10 = VAR_7;
VAR_15 = xsltFormatNumberPreSuffix(VAR_0,
&VAR_7, &VAR_21);
if (VAR_15<0) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
while (*VAR_7 != 0) {
if ( (xsltUTF8Charcmp(VAR_7, (VAR_0)->percent) == 0) ||
(xsltUTF8Charcmp(VAR_7, (VAR_0)->permille)== 0) ) {
if (VAR_21.is_multiplier_set) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_21.is_multiplier_set = TRUE;
VAR_22 = 1;
}
else if (IS_SPECIAL(VAR_0, VAR_7))
VAR_22 = 0;
else
break; 
if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
VAR_7 += VAR_19;
}
if (VAR_22 != 0) {
VAR_21.is_multiplier_set = FALSE;
VAR_7 -= VAR_19;
}
if (*VAR_7 != 0) {
VAR_11 = VAR_7;
VAR_16 = xsltFormatNumberPreSuffix(VAR_0,
&VAR_7, &VAR_21);
if (VAR_16 < 0) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
}
else
VAR_16 = 0;
if (*VAR_7 != 0) {
VAR_24 = 1;
goto OUTPUT_NUMBER;
}
if ((VAR_15 != VAR_13) ||
(VAR_16 != VAR_14) ||
((VAR_15 > 0) &&
(xmlStrncmp(VAR_10, VAR_8, VAR_13) !=0 )) ||
((VAR_16 > 0) &&
(xmlStrncmp(VAR_11, VAR_9, VAR_14) !=0 ))) {
VAR_8 = VAR_10;
VAR_13 = VAR_15;
VAR_9 = VAR_11;
VAR_14 = VAR_16;
} 
}
}
OUTPUT_NUMBER:
if (VAR_24 != 0) {
xsltTransformError(NULL, NULL, NULL,
""xsltFormatNumberConversion : ""
""error in format string '%s', using default\n"", VAR_1);
VAR_23 = (VAR_2 < 0.0) ? 1 : 0;
VAR_13 = VAR_14 = 0;
VAR_21.integer_hash = 0;
VAR_21.integer_digits = 1;
VAR_21.frac_digits = 1;
VAR_21.frac_hash = 4;
VAR_21.group = -1;
VAR_21.multiplier = 1;
VAR_21.add_decimal = TRUE;
}
if (VAR_23 != 0)
xmlBufferAdd(VAR_6, VAR_0->minusSign, xmlUTF8Strsize(VAR_0->minusSign, 1));
for (VAR_18 = 0; VAR_18 < VAR_13; VAR_18++) {
if ((VAR_12 = *VAR_8++) == VAR_27) {
VAR_19 = xmlUTF8Strsize(VAR_8, 1);
xmlBufferAdd(VAR_6, VAR_8, VAR_19);
VAR_8 += VAR_19;
VAR_18 += VAR_19 - 1;
} else
xmlBufferAdd(VAR_6, &VAR_12, 1);
}
VAR_2 = fabs(VAR_2) * (double)VAR_21.multiplier;
VAR_17 = pow(10.0, (double)(VAR_21.frac_digits + VAR_21.frac_hash));
VAR_2 = floor((VAR_17 * VAR_2 + 0.5)) / VAR_17;
if ((VAR_0->grouping != NULL) &&
(VAR_0->grouping[0] != 0)) {
VAR_19 = xmlStrlen(VAR_0->grouping);
VAR_12 = xsltGetUTF8Char(VAR_0->grouping, &VAR_19);
xsltNumberFormatDecimal(VAR_6, floor(VAR_2), VAR_0->zeroDigit[0],
VAR_21.integer_digits,
VAR_21.group,
VAR_12, VAR_19);
} else
xsltNumberFormatDecimal(VAR_6, floor(VAR_2), VAR_0->zeroDigit[0],
VAR_21.integer_digits,
VAR_21.group,
',', 1);
if ((VAR_21.integer_digits + VAR_21.integer_hash +
VAR_21.frac_digits == 0) && (VAR_21.frac_hash > 0)) {
++VAR_21.frac_digits;
--VAR_21.frac_hash;
}
if ((floor(VAR_2) == 0) &&
(VAR_21.integer_digits + VAR_21.frac_digits == 0)) {
xmlBufferAdd(VAR_6, VAR_0->zeroDigit, xmlUTF8Strsize(VAR_0->zeroDigit, 1));
}
if (VAR_21.frac_digits + VAR_21.frac_hash == 0) {
if (VAR_21.add_decimal)
xmlBufferAdd(VAR_6, VAR_0->decimalPoint,
xmlUTF8Strsize(VAR_0->decimalPoint, 1));
}
else {
VAR_2 -= floor(VAR_2);
if ((VAR_2 != 0) || (VAR_21.frac_digits != 0)) {
xmlBufferAdd(VAR_6, VAR_0->decimalPoint,
xmlUTF8Strsize(VAR_0->decimalPoint, 1));
VAR_2 = floor(VAR_17 * VAR_2 + 0.5);
for (VAR_18 = VAR_21.frac_hash; VAR_18 > 0; VAR_18--) {
if (fmod(VAR_2, 10.0) >= 1.0)
break; 
VAR_2 /= 10.0;
}
xsltNumberFormatDecimal(VAR_6, floor(VAR_2), VAR_0->zeroDigit[0],
VAR_21.frac_digits + VAR_18,
0, 0, 0);
}
}
for (VAR_18 = 0; VAR_18 < VAR_14; VAR_18++) {
if ((VAR_12 = *VAR_9++) == VAR_27) {
VAR_19 = xmlUTF8Strsize(VAR_9, 1);
xmlBufferAdd(VAR_6, VAR_9, VAR_19);
VAR_9 += VAR_19;
VAR_18 += VAR_19 - 1;
} else
xmlBufferAdd(VAR_6, &VAR_12, 1);
}
*VAR_3 = xmlStrdup(xmlBufferContent(VAR_6));
xmlBufferFree(VAR_6);
return VAR_4;
}",GNOME/libxslt/6ce8de69330783977dd14f6569419489875fb71b/numbers.c/vul/before/0.json,"xmlXPathError
xsltFormatNumberConversion(xsltDecimalFormatPtr self,
			   xmlChar *format,
			   double number,
			   xmlChar **result)
{
    xmlXPathError status = XPATH_EXPRESSION_OK;
    xmlBufferPtr buffer;
    xmlChar *the_format, *prefix = NULL, *suffix = NULL;
    xmlChar *nprefix, *nsuffix = NULL;
    xmlChar pchar;
    int	    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;
    double  scale;
    int	    j, len;
    int     self_grouping_len;
    xsltFormatNumberInfo format_info;
    /*
     * delayed_multiplier allows a 'trailing' percent or
     * permille to be treated as suffix
     */
    int		delayed_multiplier = 0;
    /* flag to show no -ve format present for -ve number */
    char	default_sign = 0;
    /* flag to show error found, should use default format */
    char	found_error = 0;

    if (xmlStrlen(format) <= 0) {
	xsltTransformError(NULL, NULL, NULL,
                ""xsltFormatNumberConversion : ""
		""Invalid format (0-length)\n"");
    }
    *result = NULL;
    switch (xmlXPathIsInf(number)) {
	case -1:
	    if (self->minusSign == NULL)
		*result = xmlStrdup(BAD_CAST ""-"");
	    else
		*result = xmlStrdup(self->minusSign);
	    /* no-break on purpose */
	case 1:
	    if ((self == NULL) || (self->infinity == NULL))
		*result = xmlStrcat(*result, BAD_CAST ""Infinity"");
	    else
		*result = xmlStrcat(*result, self->infinity);
	    return(status);
	default:
	    if (xmlXPathIsNaN(number)) {
		if ((self == NULL) || (self->noNumber == NULL))
		    *result = xmlStrdup(BAD_CAST ""NaN"");
		else
		    *result = xmlStrdup(self->noNumber);
		return(status);
	    }
    }

    buffer = xmlBufferCreate();
    if (buffer == NULL) {
	return XPATH_MEMORY_ERROR;
    }

    format_info.integer_hash = 0;
    format_info.integer_digits = 0;
    format_info.frac_digits = 0;
    format_info.frac_hash = 0;
    format_info.group = -1;
    format_info.multiplier = 1;
    format_info.add_decimal = FALSE;
    format_info.is_multiplier_set = FALSE;
    format_info.is_negative_pattern = FALSE;

    the_format = format;

    /*
     * First we process the +ve pattern to get percent / permille,
     * as well as main format
     */
    prefix = the_format;
    prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);
    if (prefix_length < 0) {
	found_error = 1;
	goto OUTPUT_NUMBER;
    }

    /*
     * Here we process the ""number"" part of the format.  It gets
     * a little messy because of the percent/per-mille - if that
     * appears at the end, it may be part of the suffix instead
     * of part of the number, so the variable delayed_multiplier
     * is used to handle it
     */
    self_grouping_len = xmlStrlen(self->grouping);
    while ((*the_format != 0) &&
	   (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&
	   (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {

	if (delayed_multiplier != 0) {
	    format_info.multiplier = delayed_multiplier;
	    format_info.is_multiplier_set = TRUE;
	    delayed_multiplier = 0;
	}
	if (xsltUTF8Charcmp(the_format, self->digit) == 0) {
	    if (format_info.integer_digits > 0) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    format_info.integer_hash++;
	    if (format_info.group >= 0)
		format_info.group++;
	} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {
	    format_info.integer_digits++;
	    if (format_info.group >= 0)
		format_info.group++;
	} else if ((self_grouping_len > 0) &&
	    (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {
	    /* Reset group count */
	    format_info.group = 0;
	    the_format += self_grouping_len;
	    continue;
	} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {
	    if (format_info.is_multiplier_set) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    delayed_multiplier = 100;
	} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {
	    if (format_info.is_multiplier_set) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    delayed_multiplier = 1000;
	} else
	    break; /* while */

	if ((len=xmlUTF8Strsize(the_format, 1)) < 1) {
	    found_error = 1;
	    goto OUTPUT_NUMBER;
	}
	the_format += len;

    }

    /* We have finished the integer part, now work on fraction */
    if ( (*the_format != 0) &&
         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {
        format_info.add_decimal = TRUE;
        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
            found_error = 1;
            goto OUTPUT_NUMBER;
        }
	the_format += len;	/* Skip over the decimal */
    }

    while (*the_format != 0) {

	if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {
	    if (format_info.frac_hash != 0) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    format_info.frac_digits++;
	} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {
	    format_info.frac_hash++;
	} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {
	    if (format_info.is_multiplier_set) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    delayed_multiplier = 100;
	    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
	        found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    the_format += len;
	    continue; /* while */
	} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {
	    if (format_info.is_multiplier_set) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    delayed_multiplier = 1000;
	    if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
	        found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    the_format += len;
	    continue; /* while */
	} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {
	    break; /* while */
	}
	if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
	    found_error = 1;
	    goto OUTPUT_NUMBER;
	}
	the_format += len;
	if (delayed_multiplier != 0) {
	    format_info.multiplier = delayed_multiplier;
	    delayed_multiplier = 0;
	    format_info.is_multiplier_set = TRUE;
	}
    }

    /*
     * If delayed_multiplier is set after processing the
     * ""number"" part, should be in suffix
     */
    if (delayed_multiplier != 0) {
	the_format -= len;
	delayed_multiplier = 0;
    }

    suffix = the_format;
    suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);
    if ( (suffix_length < 0) ||
	 ((*the_format != 0) &&
	  (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {
	found_error = 1;
	goto OUTPUT_NUMBER;
    }

    /*
     * We have processed the +ve prefix, number part and +ve suffix.
     * If the number is -ve, we must substitute the -ve prefix / suffix
     */
    if (number < 0) {
        /*
	 * Note that j is the number of UTF8 chars before the separator,
	 * not the number of bytes! (bug 151975)
	 */
        j =  xmlUTF8Strloc(format, self->patternSeparator);
	if (j < 0) {
	/* No -ve pattern present, so use default signing */
	    default_sign = 1;
	}
	else {
	    /* Skip over pattern separator (accounting for UTF8) */
	    the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);
	    /*
	     * Flag changes interpretation of percent/permille
	     * in -ve pattern
	     */
	    format_info.is_negative_pattern = TRUE;
	    format_info.is_multiplier_set = FALSE;

	    /* First do the -ve prefix */
	    nprefix = the_format;
	    nprefix_length = xsltFormatNumberPreSuffix(self,
					&the_format, &format_info);
	    if (nprefix_length<0) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }

	    while (*the_format != 0) {
		if ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||
		     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {
		    if (format_info.is_multiplier_set) {
			found_error = 1;
			goto OUTPUT_NUMBER;
		    }
		    format_info.is_multiplier_set = TRUE;
		    delayed_multiplier = 1;
		}
		else if (IS_SPECIAL(self, the_format))
		    delayed_multiplier = 0;
		else
		    break; /* while */
		if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {
		    found_error = 1;
		    goto OUTPUT_NUMBER;
		}
		the_format += len;
	    }
	    if (delayed_multiplier != 0) {
		format_info.is_multiplier_set = FALSE;
		the_format -= len;
	    }

	    /* Finally do the -ve suffix */
	    if (*the_format != 0) {
		nsuffix = the_format;
		nsuffix_length = xsltFormatNumberPreSuffix(self,
					&the_format, &format_info);
		if (nsuffix_length < 0) {
		    found_error = 1;
		    goto OUTPUT_NUMBER;
		}
	    }
	    else
		nsuffix_length = 0;
	    if (*the_format != 0) {
		found_error = 1;
		goto OUTPUT_NUMBER;
	    }
	    /*
	     * Here's another Java peculiarity:
	     * if -ve prefix/suffix == +ve ones, discard & use default
	     */
	    if ((nprefix_length != prefix_length) ||
		(nsuffix_length != suffix_length) ||
		((nprefix_length > 0) &&
		 (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||
		((nsuffix_length > 0) &&
		 (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {
		prefix = nprefix;
		prefix_length = nprefix_length;
		suffix = nsuffix;
		suffix_length = nsuffix_length;
	    } /* else {
		default_sign = 1;
	    }
	    */
	}
    }

OUTPUT_NUMBER:
    if (found_error != 0) {
	xsltTransformError(NULL, NULL, NULL,
                ""xsltFormatNumberConversion : ""
		""error in format string '%s', using default\n"", format);
	default_sign = (number < 0.0) ? 1 : 0;
	prefix_length = suffix_length = 0;
	format_info.integer_hash = 0;
	format_info.integer_digits = 1;
	format_info.frac_digits = 1;
	format_info.frac_hash = 4;
	format_info.group = -1;
	format_info.multiplier = 1;
	format_info.add_decimal = TRUE;
    }

    /* Ready to output our number.  First see if ""default sign"" is required */
    if (default_sign != 0)
	xmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));

    /* Put the prefix into the buffer */
    for (j = 0; j < prefix_length; j++) {
	if ((pchar = *prefix++) == SYMBOL_QUOTE) {
	    len = xmlUTF8Strsize(prefix, 1);
	    xmlBufferAdd(buffer, prefix, len);
	    prefix += len;
	    j += len - 1;	/* length of symbol less length of quote */
	} else
	    xmlBufferAdd(buffer, &pchar, 1);
    }

    /* Next do the integer part of the number */
    number = fabs(number) * (double)format_info.multiplier;
    scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));
    number = floor((scale * number + 0.5)) / scale;
    if ((self->grouping != NULL) &&
        (self->grouping[0] != 0)) {
        int gchar;

	len = xmlStrlen(self->grouping);
	gchar = xsltGetUTF8Char(self->grouping, &len);
	xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
				format_info.integer_digits,
				format_info.group,
				gchar, len);
    } else
	xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
				format_info.integer_digits,
				format_info.group,
				',', 1);

    /* Special case: java treats '.#' like '.0', '.##' like '.0#', etc. */
    if ((format_info.integer_digits + format_info.integer_hash +
	 format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {
        ++format_info.frac_digits;
	--format_info.frac_hash;
    }

    /* Add leading zero, if required */
    if ((floor(number) == 0) &&
	(format_info.integer_digits + format_info.frac_digits == 0)) {
        xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));
    }

    /* Next the fractional part, if required */
    if (format_info.frac_digits + format_info.frac_hash == 0) {
        if (format_info.add_decimal)
	    xmlBufferAdd(buffer, self->decimalPoint,
			 xmlUTF8Strsize(self->decimalPoint, 1));
    }
    else {
      number -= floor(number);
	if ((number != 0) || (format_info.frac_digits != 0)) {
	    xmlBufferAdd(buffer, self->decimalPoint,
			 xmlUTF8Strsize(self->decimalPoint, 1));
	    number = floor(scale * number + 0.5);
	    for (j = format_info.frac_hash; j > 0; j--) {
		if (fmod(number, 10.0) >= 1.0)
		    break; /* for */
		number /= 10.0;
	    }
	    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
				format_info.frac_digits + j,
				0, 0, 0);
	}
    }
    /* Put the suffix into the buffer */
    for (j = 0; j < suffix_length; j++) {
	if ((pchar = *suffix++) == SYMBOL_QUOTE) {
            len = xmlUTF8Strsize(suffix, 1);
	    xmlBufferAdd(buffer, suffix, len);
	    suffix += len;
	    j += len - 1;	/* length of symbol less length of escape */
	} else
	    xmlBufferAdd(buffer, &pchar, 1);
    }

    *result = xmlStrdup(xmlBufferContent(buffer));
    xmlBufferFree(buffer);
    return status;
}","xmlXPathError
xsltFormatNumberConversion(xsltDecimalFormatPtr VAR_0,
			   xmlChar *VAR_1,
			   double VAR_2,
			   xmlChar **VAR_3)
{
    xmlXPathError VAR_4 = VAR_5;
    xmlBufferPtr VAR_6;
    xmlChar *VAR_7, *VAR_8 = NULL, *VAR_9 = NULL;
    xmlChar *VAR_10, *VAR_11 = NULL;
    xmlChar VAR_12;
    int	    VAR_13, VAR_14 = 0, VAR_15, VAR_16;
    double  VAR_17;
    int	    VAR_18, VAR_19;
    int     VAR_20;
    xsltFormatNumberInfo VAR_21;
    /* COMMENT_0 */
                                                        
                                       
       
    int		VAR_22 = 0;
    /* COMMENT_4 */
    char	VAR_23 = 0;
    /* COMMENT_5 */
    char	VAR_24 = 0;

    if (xmlStrlen(VAR_1) <= 0) {
	xsltTransformError(NULL, NULL, NULL,
                ""xsltFormatNumberConversion : ""
		""Invalid format (0-length)\n"");
    }
    *VAR_3 = NULL;
    switch (xmlXPathIsInf(VAR_2)) {
	case -1:
	    if (VAR_0->minusSign == NULL)
		*VAR_3 = xmlStrdup(VAR_25 ""-"");
	    else
		*VAR_3 = xmlStrdup(VAR_0->minusSign);
	    /* COMMENT_6 */
	case 1:
	    if ((VAR_0 == NULL) || (VAR_0->infinity == NULL))
		*VAR_3 = xmlStrcat(*VAR_3, VAR_25 ""Infinity"");
	    else
		*VAR_3 = xmlStrcat(*VAR_3, VAR_0->infinity);
	    return(VAR_4);
	default:
	    if (xmlXPathIsNaN(VAR_2)) {
		if ((VAR_0 == NULL) || (VAR_0->noNumber == NULL))
		    *VAR_3 = xmlStrdup(VAR_25 ""NaN"");
		else
		    *VAR_3 = xmlStrdup(VAR_0->noNumber);
		return(VAR_4);
	    }
    }

    VAR_6 = xmlBufferCreate();
    if (VAR_6 == NULL) {
	return VAR_26;
    }

    VAR_21.integer_hash = 0;
    VAR_21.integer_digits = 0;
    VAR_21.frac_digits = 0;
    VAR_21.frac_hash = 0;
    VAR_21.group = -1;
    VAR_21.multiplier = 1;
    VAR_21.add_decimal = FALSE;
    VAR_21.is_multiplier_set = FALSE;
    VAR_21.is_negative_pattern = FALSE;

    VAR_7 = VAR_1;

    /* COMMENT_7 */
                                                                  
                             
       
    VAR_8 = VAR_7;
    VAR_13 = xsltFormatNumberPreSuffix(VAR_0, &VAR_7, &VAR_21);
    if (VAR_13 < 0) {
	VAR_24 = 1;
	goto OUTPUT_NUMBER;
    }

    /* COMMENT_11 */
                                                                
                                                                
                                                               
                                                                
                           
       
    VAR_20 = xmlStrlen(VAR_0->grouping);
    while ((*VAR_7 != 0) &&
	   (xsltUTF8Charcmp(VAR_7, VAR_0->decimalPoint) != 0) &&
	   (xsltUTF8Charcmp(VAR_7, VAR_0->patternSeparator) != 0)) {

	if (VAR_22 != 0) {
	    VAR_21.multiplier = VAR_22;
	    VAR_21.is_multiplier_set = TRUE;
	    VAR_22 = 0;
	}
	if (xsltUTF8Charcmp(VAR_7, VAR_0->digit) == 0) {
	    if (VAR_21.integer_digits > 0) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_21.integer_hash++;
	    if (VAR_21.group >= 0)
		VAR_21.group++;
	} else if (xsltUTF8Charcmp(VAR_7, VAR_0->zeroDigit) == 0) {
	    VAR_21.integer_digits++;
	    if (VAR_21.group >= 0)
		VAR_21.group++;
	} else if ((VAR_20 > 0) &&
	    (!xmlStrncmp(VAR_7, VAR_0->grouping, VAR_20))) {
	    /* COMMENT_18 */
	    VAR_21.group = 0;
	    VAR_7 += VAR_20;
	    continue;
	} else if (xsltUTF8Charcmp(VAR_7, VAR_0->percent) == 0) {
	    if (VAR_21.is_multiplier_set) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_22 = 100;
	} else  if (xsltUTF8Charcmp(VAR_7, VAR_0->permille) == 0) {
	    if (VAR_21.is_multiplier_set) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_22 = 1000;
	} else
	    break; /* COMMENT_19 */

	if ((VAR_19=xmlUTF8Strsize(VAR_7, 1)) < 1) {
	    VAR_24 = 1;
	    goto OUTPUT_NUMBER;
	}
	VAR_7 += VAR_19;

    }

    /* COMMENT_20 */
    if ( (*VAR_7 != 0) &&
         (xsltUTF8Charcmp(VAR_7, VAR_0->decimalPoint) == 0) ) {
        VAR_21.add_decimal = TRUE;
        if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
            VAR_24 = 1;
            goto OUTPUT_NUMBER;
        }
	VAR_7 += VAR_19;	/* COMMENT_21 */
    }

    while (*VAR_7 != 0) {

	if (xsltUTF8Charcmp(VAR_7, VAR_0->zeroDigit) == 0) {
	    if (VAR_21.frac_hash != 0) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_21.frac_digits++;
	} else if (xsltUTF8Charcmp(VAR_7, VAR_0->digit) == 0) {
	    VAR_21.frac_hash++;
	} else if (xsltUTF8Charcmp(VAR_7, VAR_0->percent) == 0) {
	    if (VAR_21.is_multiplier_set) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_22 = 100;
	    if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
	        VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_7 += VAR_19;
	    continue; /* COMMENT_19 */
	} else if (xsltUTF8Charcmp(VAR_7, VAR_0->permille) == 0) {
	    if (VAR_21.is_multiplier_set) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_22 = 1000;
	    if  ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
	        VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    VAR_7 += VAR_19;
	    continue; /* COMMENT_19 */
	} else if (xsltUTF8Charcmp(VAR_7, VAR_0->grouping) != 0) {
	    break; /* COMMENT_19 */
	}
	if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
	    VAR_24 = 1;
	    goto OUTPUT_NUMBER;
	}
	VAR_7 += VAR_19;
	if (VAR_22 != 0) {
	    VAR_21.multiplier = VAR_22;
	    VAR_22 = 0;
	    VAR_21.is_multiplier_set = TRUE;
	}
    }

    /* COMMENT_22 */
                                                        
                                         
       
    if (VAR_22 != 0) {
	VAR_7 -= VAR_19;
	VAR_22 = 0;
    }

    VAR_9 = VAR_7;
    VAR_14 = xsltFormatNumberPreSuffix(VAR_0, &VAR_7, &VAR_21);
    if ( (VAR_14 < 0) ||
	 ((*VAR_7 != 0) &&
	  (xsltUTF8Charcmp(VAR_7, VAR_0->patternSeparator) != 0)) ) {
	VAR_24 = 1;
	goto OUTPUT_NUMBER;
    }

    /* COMMENT_26 */
                                                                    
                                                                       
       
    if (VAR_2 < 0) {
        /* COMMENT_30 */
                                                                 
                                         
    
        VAR_18 =  xmlUTF8Strloc(VAR_1, VAR_0->patternSeparator);
	if (VAR_18 < 0) {
	/* COMMENT_34 */
	    VAR_23 = 1;
	}
	else {
	    /* COMMENT_35 */
	    VAR_7 = (xmlChar *)xmlUTF8Strpos(VAR_1, VAR_18 + 1);
	    /* COMMENT_36 */
                                                       
                      
        
	    VAR_21.is_negative_pattern = TRUE;
	    VAR_21.is_multiplier_set = FALSE;

	    /* COMMENT_40 */
	    VAR_10 = VAR_7;
	    VAR_15 = xsltFormatNumberPreSuffix(VAR_0,
					&VAR_7, &VAR_21);
	    if (VAR_15<0) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }

	    while (*VAR_7 != 0) {
		if ( (xsltUTF8Charcmp(VAR_7, (VAR_0)->percent) == 0) ||
		     (xsltUTF8Charcmp(VAR_7, (VAR_0)->permille)== 0) ) {
		    if (VAR_21.is_multiplier_set) {
			VAR_24 = 1;
			goto OUTPUT_NUMBER;
		    }
		    VAR_21.is_multiplier_set = TRUE;
		    VAR_22 = 1;
		}
		else if (IS_SPECIAL(VAR_0, VAR_7))
		    VAR_22 = 0;
		else
		    break; /* COMMENT_19 */
		if ((VAR_19 = xmlUTF8Strsize(VAR_7, 1)) < 1) {
		    VAR_24 = 1;
		    goto OUTPUT_NUMBER;
		}
		VAR_7 += VAR_19;
	    }
	    if (VAR_22 != 0) {
		VAR_21.is_multiplier_set = FALSE;
		VAR_7 -= VAR_19;
	    }

	    /* COMMENT_41 */
	    if (*VAR_7 != 0) {
		VAR_11 = VAR_7;
		VAR_16 = xsltFormatNumberPreSuffix(VAR_0,
					&VAR_7, &VAR_21);
		if (VAR_16 < 0) {
		    VAR_24 = 1;
		    goto OUTPUT_NUMBER;
		}
	    }
	    else
		VAR_16 = 0;
	    if (*VAR_7 != 0) {
		VAR_24 = 1;
		goto OUTPUT_NUMBER;
	    }
	    /* COMMENT_42 */
                                        
                                                               
        
	    if ((VAR_15 != VAR_13) ||
		(VAR_16 != VAR_14) ||
		((VAR_15 > 0) &&
		 (xmlStrncmp(VAR_10, VAR_8, VAR_13) !=0 )) ||
		((VAR_16 > 0) &&
		 (xmlStrncmp(VAR_11, VAR_9, VAR_14) !=0 ))) {
		VAR_8 = VAR_10;
		VAR_13 = VAR_15;
		VAR_9 = VAR_11;
		VAR_14 = VAR_16;
	    } /* COMMENT_46 */
                   
      
       
	}
    }

OUTPUT_NUMBER:
    if (VAR_24 != 0) {
	xsltTransformError(NULL, NULL, NULL,
                ""xsltFormatNumberConversion : ""
		""error in format string '%s', using default\n"", VAR_1);
	VAR_23 = (VAR_2 < 0.0) ? 1 : 0;
	VAR_13 = VAR_14 = 0;
	VAR_21.integer_hash = 0;
	VAR_21.integer_digits = 1;
	VAR_21.frac_digits = 1;
	VAR_21.frac_hash = 4;
	VAR_21.group = -1;
	VAR_21.multiplier = 1;
	VAR_21.add_decimal = TRUE;
    }

    /* COMMENT_50 */
    if (VAR_23 != 0)
	xmlBufferAdd(VAR_6, VAR_0->minusSign, xmlUTF8Strsize(VAR_0->minusSign, 1));

    /* COMMENT_51 */
    for (VAR_18 = 0; VAR_18 < VAR_13; VAR_18++) {
	if ((VAR_12 = *VAR_8++) == VAR_27) {
	    VAR_19 = xmlUTF8Strsize(VAR_8, 1);
	    xmlBufferAdd(VAR_6, VAR_8, VAR_19);
	    VAR_8 += VAR_19;
	    VAR_18 += VAR_19 - 1;	/* COMMENT_52 */
	} else
	    xmlBufferAdd(VAR_6, &VAR_12, 1);
    }

    /* COMMENT_53 */
    VAR_2 = fabs(VAR_2) * (double)VAR_21.multiplier;
    VAR_17 = pow(10.0, (double)(VAR_21.frac_digits + VAR_21.frac_hash));
    VAR_2 = floor((VAR_17 * VAR_2 + 0.5)) / VAR_17;
    if ((VAR_0->grouping != NULL) &&
        (VAR_0->grouping[0] != 0)) {
        int VAR_28;

	VAR_19 = xmlStrlen(VAR_0->grouping);
	VAR_28 = xsltGetUTF8Char(VAR_0->grouping, &VAR_19);
	xsltNumberFormatDecimal(VAR_6, floor(VAR_2), VAR_0->zeroDigit[0],
				VAR_21.integer_digits,
				VAR_21.group,
				VAR_28, VAR_19);
    } else
	xsltNumberFormatDecimal(VAR_6, floor(VAR_2), VAR_0->zeroDigit[0],
				VAR_21.integer_digits,
				VAR_21.group,
				',', 1);

    /* COMMENT_54 */
    if ((VAR_21.integer_digits + VAR_21.integer_hash +
	 VAR_21.frac_digits == 0) && (VAR_21.frac_hash > 0)) {
        ++VAR_21.frac_digits;
	--VAR_21.frac_hash;
    }

    /* COMMENT_55 */
    if ((floor(VAR_2) == 0) &&
	(VAR_21.integer_digits + VAR_21.frac_digits == 0)) {
        xmlBufferAdd(VAR_6, VAR_0->zeroDigit, xmlUTF8Strsize(VAR_0->zeroDigit, 1));
    }

    /* COMMENT_56 */
    if (VAR_21.frac_digits + VAR_21.frac_hash == 0) {
        if (VAR_21.add_decimal)
	    xmlBufferAdd(VAR_6, VAR_0->decimalPoint,
			 xmlUTF8Strsize(VAR_0->decimalPoint, 1));
    }
    else {
      VAR_2 -= floor(VAR_2);
	if ((VAR_2 != 0) || (VAR_21.frac_digits != 0)) {
	    xmlBufferAdd(VAR_6, VAR_0->decimalPoint,
			 xmlUTF8Strsize(VAR_0->decimalPoint, 1));
	    VAR_2 = floor(VAR_17 * VAR_2 + 0.5);
	    for (VAR_18 = VAR_21.frac_hash; VAR_18 > 0; VAR_18--) {
		if (fmod(VAR_2, 10.0) >= 1.0)
		    break; /* COMMENT_57 */
		VAR_2 /= 10.0;
	    }
	    xsltNumberFormatDecimal(VAR_6, floor(VAR_2), VAR_0->zeroDigit[0],
				VAR_21.frac_digits + VAR_18,
				0, 0, 0);
	}
    }
    /* COMMENT_58 */
    for (VAR_18 = 0; VAR_18 < VAR_14; VAR_18++) {
	if ((VAR_12 = *VAR_9++) == VAR_27) {
            VAR_19 = xmlUTF8Strsize(VAR_9, 1);
	    xmlBufferAdd(VAR_6, VAR_9, VAR_19);
	    VAR_9 += VAR_19;
	    VAR_18 += VAR_19 - 1;	/* COMMENT_59 */
	} else
	    xmlBufferAdd(VAR_6, &VAR_12, 1);
    }

    *VAR_3 = xmlStrdup(xmlBufferContent(VAR_6));
    xmlBufferFree(VAR_6);
    return VAR_4;
}",GNOME/libxslt/6ce8de69330783977dd14f6569419489875fb71b/numbers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -349,13 +349,14 @@
     number = floor((scale * number + 0.5)) / scale;
     if ((self->grouping != NULL) &&
         (self->grouping[0] != 0)) {
+        int gchar;
 
 	len = xmlStrlen(self->grouping);
-	pchar = xsltGetUTF8Char(self->grouping, &len);
+	gchar = xsltGetUTF8Char(self->grouping, &len);
 	xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
 				format_info.integer_digits,
 				format_info.group,
-				pchar, len);
+				gchar, len);
     } else
 	xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],
 				format_info.integer_digits,","{'deleted_lines': ['\tpchar = xsltGetUTF8Char(self->grouping, &len);', '\t\t\t\tpchar, len);'], 'added_lines': ['        int gchar;', '\tgchar = xsltGetUTF8Char(self->grouping, &len);', '\t\t\t\tgchar, len);']}",True,"In numbers.c in libxslt 1.1.33, a type holding grouping characters of an xsl:number instruction was too narrow and an invalid character/length combination could be passed to xsltNumberFormatDecimal, leading to a read of uninitialized stack data.",5.3,MEDIUM,1,test,2019-06-03T11:14:45Z,2
CVE-2019-25016,"['CWE-459', 'CWE-909']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0.0,Duncaen/OpenDoas,"redo the environment inheritance to not inherit. it was intended to make life easier, but it can be surprising or even unsafe. instead, reset just about everything to the target user's values. ok deraadt martijn Thanks to Sander Bos in particular for pointing out some nasty edge cases.",01c658f8c45cb92a343be5f32aa6da70b2032168,https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168,doas.c,main,"int
main(int argc, char **argv)
{
const char *safepath = ""/bin:/sbin:/usr/bin:/usr/sbin:""
""/usr/local/bin:/usr/local/sbin"";
const char *confpath = NULL;
char *shargv[] = { NULL, NULL };
char *sh;
const char *cmd;
char cmdline[LINE_MAX];
#ifdef __OpenBSD__
char mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];
#else
char *mypwbuf = NULL, *targpwbuf = NULL;
#endif
struct passwd mypwstore, targpwstore;
struct passwd *mypw, *targpw;
const struct rule *rule;
uid_t uid;
uid_t target = 0;
gid_t groups[NGROUPS_MAX + 1];
int ngroups;
int i, ch, rv;
int sflag = 0;
int nflag = 0;
char cwdpath[PATH_MAX];
const char *cwd;
char **envp;
#ifdef USE_BSD_AUTH
char *login_style = NULL;
#endif
setprogname(""doas"");
closefrom(STDERR_FILENO + 1);
uid = getuid();
#ifdef USE_BSD_AUTH
# define OPTSTRING ""a:C:Lnsu:""
#else
# define OPTSTRING ""+C:Lnsu:""
#endif
while ((ch = getopt(argc, argv, OPTSTRING)) != -1) {
switch (ch) {
#ifdef USE_BSD_AUTH
case 'a':
login_style = optarg;
break;
#endif
case 'C':
confpath = optarg;
break;
case 'L':
#if defined(USE_BSD_AUTH)
i = open(""/dev/tty"", O_RDWR);
if (i != -1)
ioctl(i, TIOCCLRVERAUTH);
exit(i == -1);
#elif defined(USE_TIMESTAMP)
exit(timestamp_clear() == -1);
#else
exit(0);
#endif
case 'u':
if (parseuid(optarg, &target) != 0)
errx(1, ""unknown user"");
break;
case 'n':
nflag = 1;
break;
case 's':
sflag = 1;
break;
default:
usage();
break;
}
}
argv += optind;
argc -= optind;
if (confpath) {
if (sflag)
usage();
} else if ((!sflag && !argc) || (sflag && argc))
usage();
#ifdef __OpenBSD__
rv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);
if (rv != 0)
err(1, ""getpwuid_r failed"");
#else
for (size_t sz = 1024; sz <= 16*1024; sz *= 2) {
mypwbuf = reallocarray(mypwbuf, sz, sizeof (char));
if (mypwbuf == NULL)
errx(1, ""can't allocate mypwbuf"");
rv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);
if (rv != ERANGE)
break;
}
if (rv != 0)
err(1, ""getpwuid_r failed"");
#endif
if (mypw == NULL)
errx(1, ""no passwd entry for self"");
ngroups = getgroups(NGROUPS_MAX, groups);
if (ngroups == -1)
err(1, ""can't get groups"");
groups[ngroups++] = getgid();
if (sflag) {
sh = getenv(""SHELL"");
if (sh == NULL || *sh == '\0') {
shargv[0] = mypw->pw_shell;
} else
shargv[0] = sh;
argv = shargv;
argc = 1;
}
if (confpath) {
checkconfig(confpath, argc, argv, uid, groups, ngroups,
target);
exit(1);
}
if (geteuid())
errx(1, ""not installed setuid"");
parseconfig(""/etc/doas.conf"", 1);
(void)strlcpy(cmdline, argv[0], sizeof(cmdline));
for (i = 1; i < argc; i++) {
if (strlcat(cmdline, "" "", sizeof(cmdline)) >= sizeof(cmdline))
break;
if (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))
break;
}
cmd = argv[0];
if (!permit(uid, groups, ngroups, &rule, target, cmd,
(const char **)argv + 1)) {
syslog(LOG_AUTHPRIV | LOG_NOTICE,
""failed command for %s: %s"", mypw->pw_name, cmdline);
errc(1, EPERM, NULL);
}
#if defined(__OpenBSD__) || defined(USE_SHADOW)
if (!(rule->options & NOPASS)) {
if (nflag)
errx(1, ""Authorization required"");
# ifdef __OpenBSD__
authuser(mypw->pw_name, login_style, rule->options & PERSIST);
# else
shadowauth(mypw->pw_name, rule->options & PERSIST);
# endif
}
# ifdef __OpenBSD__
if (pledge(""stdio rpath getpw exec id"", NULL) == -1)
err(1, ""pledge"");
# endif
#elif !defined(USE_PAM)
(void) nflag;
if (!(rule->options & NOPASS)) {
errx(1, ""Authorization required"");
}
#endif 
#ifdef __OpenBSD__
rv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);
if (rv != 0)
errx(1, ""no passwd entry for target"");
#else
for (size_t sz = 1024; sz <= 16*1024; sz *= 2) {
targpwbuf = reallocarray(targpwbuf, sz, sizeof (char));
if (targpwbuf == NULL)
errx(1, ""can't allocate targpwbuf"");
rv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);
if (rv != ERANGE)
break;
}
if (rv != 0)
err(1, ""getpwuid_r failed"");
#endif
if (targpw == NULL)
err(1, ""getpwuid_r failed"");
#if defined(USE_PAM)
pamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,
rule->options & PERSIST);
#endif
#ifdef HAVE_SETUSERCONTEXT
if (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |
LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |
LOGIN_SETUSER) != 0)
errx(1, ""failed to set user context for target"");
#else
if (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)
err(1, ""setresgid"");
if (initgroups(targpw->pw_name, targpw->pw_gid) != 0)
err(1, ""initgroups"");
if (setresuid(target, target, target) != 0)
err(1, ""setresuid"");
#endif
#ifdef __OpenBSD__
if (pledge(""stdio rpath exec"", NULL) == -1)
err(1, ""pledge"");
#endif
if (getcwd(cwdpath, sizeof(cwdpath)) == NULL)
cwd = ""(failed)"";
else
cwd = cwdpath;
#ifdef __OpenBSD__
if (pledge(""stdio exec"", NULL) == -1)
err(1, ""pledge"");
#endif
syslog(LOG_AUTHPRIV | LOG_INFO, ""%s ran command %s as %s from %s"",
mypw->pw_name, cmdline, targpw->pw_name, cwd);
envp = prepenv(rule);
if (rule->cmd) {
if (setenv(""PATH"", safepath, 1) == -1)
err(1, ""failed to set PATH '%s'"", safepath);
}
execvpe(cmd, argv, envp);
if (errno == ENOENT)
errx(1, ""%s: command not found"", cmd);
err(1, ""%s"", cmd);
}","int
main(int VAR_0, char **VAR_1)
{
const char *VAR_2 = ""/bin:/sbin:/usr/bin:/usr/sbin:""
""/usr/local/bin:/usr/local/sbin"";
const char *VAR_3 = NULL;
char *VAR_4[] = { NULL, NULL };
char *VAR_5;
const char *VAR_6;
char VAR_7[VAR_8];
#ifdef VAR_9
char VAR_10[VAR_11], VAR_12[VAR_11];
#else
char *VAR_10 = NULL, *VAR_12 = NULL;
#endif
struct passwd VAR_13, VAR_14;
struct passwd *VAR_15, *VAR_16;
const struct rule *rule;
uid_t VAR_17;
uid_t VAR_18 = 0;
gid_t VAR_19[VAR_20 + 1];
int VAR_21;
int VAR_22, VAR_23, VAR_24;
int VAR_25 = 0;
int VAR_26 = 0;
char VAR_27[VAR_28];
const char *VAR_29;
char **VAR_30;
#ifdef VAR_31
char *VAR_32 = NULL;
#endif
setprogname(""doas"");
closefrom(VAR_33 + 1);
VAR_17 = getuid();
#ifdef VAR_31
# define VAR_34 ""a:C:Lnsu:""
#else
# define VAR_34 ""+C:Lnsu:""
#endif
while ((VAR_23 = getopt(VAR_0, VAR_1, VAR_34)) != -1) {
switch (VAR_23) {
#ifdef VAR_31
case 'a':
VAR_32 = VAR_35;
break;
#endif
case 'C':
VAR_3 = VAR_35;
break;
case 'L':
#if defined(VAR_31)
VAR_22 = open(""/dev/tty"", VAR_36);
if (VAR_22 != -1)
ioctl(VAR_22, VAR_37);
exit(VAR_22 == -1);
#elif defined(VAR_38)
exit(timestamp_clear() == -1);
#else
exit(0);
#endif
case 'u':
if (parseuid(VAR_35, &VAR_18) != 0)
errx(1, ""unknown user"");
break;
case 'n':
VAR_26 = 1;
break;
case 's':
VAR_25 = 1;
break;
default:
usage();
break;
}
}
VAR_1 += VAR_39;
VAR_0 -= VAR_39;
if (VAR_3) {
if (VAR_25)
usage();
} else if ((!VAR_25 && !VAR_0) || (VAR_25 && VAR_0))
usage();
#ifdef VAR_9
VAR_24 = getpwuid_r(VAR_17, &VAR_13, VAR_10, sizeof(VAR_10), &VAR_15);
if (VAR_24 != 0)
err(1, ""getpwuid_r failed"");
#else
for (size_t VAR_40 = 1024; VAR_40 <= 16*1024; VAR_40 *= 2) {
VAR_10 = reallocarray(VAR_10, VAR_40, sizeof (char));
if (VAR_10 == NULL)
errx(1, ""can't allocate mypwbuf"");
VAR_24 = getpwuid_r(VAR_17, &VAR_13, VAR_10, VAR_40, &VAR_15);
if (VAR_24 != VAR_41)
break;
}
if (VAR_24 != 0)
err(1, ""getpwuid_r failed"");
#endif
if (VAR_15 == NULL)
errx(1, ""no passwd entry for self"");
VAR_21 = getgroups(VAR_20, VAR_19);
if (VAR_21 == -1)
err(1, ""can't get groups"");
VAR_19[VAR_21++] = getgid();
if (VAR_25) {
VAR_5 = getenv(""SHELL"");
if (VAR_5 == NULL || *VAR_5 == '\0') {
VAR_4[0] = VAR_15->pw_shell;
} else
VAR_4[0] = VAR_5;
VAR_1 = VAR_4;
VAR_0 = 1;
}
if (VAR_3) {
checkconfig(VAR_3, VAR_0, VAR_1, VAR_17, VAR_19, VAR_21,
VAR_18);
exit(1);
}
if (geteuid())
errx(1, ""not installed setuid"");
parseconfig(""/etc/doas.conf"", 1);
(void)strlcpy(VAR_7, VAR_1[0], sizeof(VAR_7));
for (VAR_22 = 1; VAR_22 < VAR_0; VAR_22++) {
if (strlcat(VAR_7, "" "", sizeof(VAR_7)) >= sizeof(VAR_7))
break;
if (strlcat(VAR_7, VAR_1[VAR_22], sizeof(VAR_7)) >= sizeof(VAR_7))
break;
}
VAR_6 = VAR_1[0];
if (!permit(VAR_17, VAR_19, VAR_21, &rule, VAR_18, VAR_6,
(const char **)VAR_1 + 1)) {
syslog(VAR_42 | VAR_43,
""failed command for %s: %s"", VAR_15->pw_name, VAR_7);
errc(1, VAR_44, NULL);
}
#if defined(VAR_9) || defined(VAR_45)
if (!(rule->options & VAR_46)) {
if (VAR_26)
errx(1, ""Authorization required"");
# ifdef VAR_9
authuser(VAR_15->pw_name, VAR_32, rule->options & VAR_47);
# else
shadowauth(VAR_15->pw_name, rule->options & VAR_47);
# endif
}
# ifdef VAR_9
if (pledge(""stdio rpath getpw exec id"", NULL) == -1)
err(1, ""pledge"");
# endif
#elif !defined(VAR_48)
(void) VAR_26;
if (!(rule->options & VAR_46)) {
errx(1, ""Authorization required"");
}
#endif 
#ifdef VAR_9
VAR_24 = getpwuid_r(VAR_18, &VAR_14, VAR_12, sizeof(VAR_12), &VAR_16);
if (VAR_24 != 0)
errx(1, ""no passwd entry for target"");
#else
for (size_t VAR_40 = 1024; VAR_40 <= 16*1024; VAR_40 *= 2) {
VAR_12 = reallocarray(VAR_12, VAR_40, sizeof (char));
if (VAR_12 == NULL)
errx(1, ""can't allocate targpwbuf"");
VAR_24 = getpwuid_r(VAR_18, &VAR_14, VAR_12, VAR_40, &VAR_16);
if (VAR_24 != VAR_41)
break;
}
if (VAR_24 != 0)
err(1, ""getpwuid_r failed"");
#endif
if (VAR_16 == NULL)
err(1, ""getpwuid_r failed"");
#if defined(VAR_48)
pamauth(VAR_16->pw_name, VAR_15->pw_name, !VAR_26, rule->options & VAR_46,
rule->options & VAR_47);
#endif
#ifdef VAR_49
if (setusercontext(NULL, VAR_16, VAR_18, VAR_50 |
VAR_51 | VAR_52 | VAR_53 |
VAR_54) != 0)
errx(1, ""failed to set user context for target"");
#else
if (setresgid(VAR_16->pw_gid, VAR_16->pw_gid, VAR_16->pw_gid) != 0)
err(1, ""setresgid"");
if (initgroups(VAR_16->pw_name, VAR_16->pw_gid) != 0)
err(1, ""initgroups"");
if (setresuid(VAR_18, VAR_18, VAR_18) != 0)
err(1, ""setresuid"");
#endif
#ifdef VAR_9
if (pledge(""stdio rpath exec"", NULL) == -1)
err(1, ""pledge"");
#endif
if (getcwd(VAR_27, sizeof(VAR_27)) == NULL)
VAR_29 = ""(failed)"";
else
VAR_29 = VAR_27;
#ifdef VAR_9
if (pledge(""stdio exec"", NULL) == -1)
err(1, ""pledge"");
#endif
syslog(VAR_42 | VAR_55, ""%s ran command %s as %s from %s"",
VAR_15->pw_name, VAR_7, VAR_16->pw_name, VAR_29);
VAR_30 = prepenv(rule);
if (rule->cmd) {
if (setenv(""PATH"", VAR_2, 1) == -1)
err(1, ""failed to set PATH '%s'"", VAR_2);
}
execvpe(VAR_6, VAR_1, VAR_30);
if (VAR_56 == VAR_57)
errx(1, ""%s: command not found"", VAR_6);
err(1, ""%s"", VAR_6);
}",Duncaen/OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168/doas.c/vul/before/0.json,"int
main(int argc, char **argv)
{
	const char *safepath = ""/bin:/sbin:/usr/bin:/usr/sbin:""
	    ""/usr/local/bin:/usr/local/sbin"";
	const char *confpath = NULL;
	char *shargv[] = { NULL, NULL };
	char *sh;
	const char *cmd;
	char cmdline[LINE_MAX];
#ifdef __OpenBSD__
	char mypwbuf[_PW_BUF_LEN], targpwbuf[_PW_BUF_LEN];
#else
	char *mypwbuf = NULL, *targpwbuf = NULL;
#endif
	struct passwd mypwstore, targpwstore;
	struct passwd *mypw, *targpw;
	const struct rule *rule;
	uid_t uid;
	uid_t target = 0;
	gid_t groups[NGROUPS_MAX + 1];
	int ngroups;
	int i, ch, rv;
	int sflag = 0;
	int nflag = 0;
	char cwdpath[PATH_MAX];
	const char *cwd;
	char **envp;
#ifdef USE_BSD_AUTH
	char *login_style = NULL;
#endif

	setprogname(""doas"");

	closefrom(STDERR_FILENO + 1);

	uid = getuid();

#ifdef USE_BSD_AUTH
# define OPTSTRING ""a:C:Lnsu:""
#else
# define OPTSTRING ""+C:Lnsu:""
#endif

	while ((ch = getopt(argc, argv, OPTSTRING)) != -1) {
		switch (ch) {
#ifdef USE_BSD_AUTH
		case 'a':
			login_style = optarg;
			break;
#endif
		case 'C':
			confpath = optarg;
			break;
		case 'L':
#if defined(USE_BSD_AUTH)
			i = open(""/dev/tty"", O_RDWR);
			if (i != -1)
				ioctl(i, TIOCCLRVERAUTH);
			exit(i == -1);
#elif defined(USE_TIMESTAMP)
			exit(timestamp_clear() == -1);
#else
			exit(0);
#endif
		case 'u':
			if (parseuid(optarg, &target) != 0)
				errx(1, ""unknown user"");
			break;
		case 'n':
			nflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		default:
			usage();
			break;
		}
	}
	argv += optind;
	argc -= optind;

	if (confpath) {
		if (sflag)
			usage();
	} else if ((!sflag && !argc) || (sflag && argc))
		usage();

#ifdef __OpenBSD__
	rv = getpwuid_r(uid, &mypwstore, mypwbuf, sizeof(mypwbuf), &mypw);
	if (rv != 0)
		err(1, ""getpwuid_r failed"");
#else
	for (size_t sz = 1024; sz <= 16*1024; sz *= 2) {
		mypwbuf = reallocarray(mypwbuf, sz, sizeof (char));
		if (mypwbuf == NULL)
			errx(1, ""can't allocate mypwbuf"");
		rv = getpwuid_r(uid, &mypwstore, mypwbuf, sz, &mypw);
		if (rv != ERANGE)
			break;
	}
	if (rv != 0)
		err(1, ""getpwuid_r failed"");
#endif
	if (mypw == NULL)
		errx(1, ""no passwd entry for self"");
	ngroups = getgroups(NGROUPS_MAX, groups);
	if (ngroups == -1)
		err(1, ""can't get groups"");
	groups[ngroups++] = getgid();

	if (sflag) {
		sh = getenv(""SHELL"");
		if (sh == NULL || *sh == '\0') {
			shargv[0] = mypw->pw_shell;
		} else
			shargv[0] = sh;
		argv = shargv;
		argc = 1;
	}

	if (confpath) {
		checkconfig(confpath, argc, argv, uid, groups, ngroups,
		    target);
		exit(1);	/* fail safe */
	}

	if (geteuid())
		errx(1, ""not installed setuid"");

	parseconfig(""/etc/doas.conf"", 1);

	/* cmdline is used only for logging, no need to abort on truncate */
	(void)strlcpy(cmdline, argv[0], sizeof(cmdline));
	for (i = 1; i < argc; i++) {
		if (strlcat(cmdline, "" "", sizeof(cmdline)) >= sizeof(cmdline))
			break;
		if (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))
			break;
	}

	cmd = argv[0];
	if (!permit(uid, groups, ngroups, &rule, target, cmd,
	    (const char **)argv + 1)) {
		syslog(LOG_AUTHPRIV | LOG_NOTICE,
		    ""failed command for %s: %s"", mypw->pw_name, cmdline);
		errc(1, EPERM, NULL);
	}

#if defined(__OpenBSD__) || defined(USE_SHADOW)
	if (!(rule->options & NOPASS)) {
		if (nflag)
			errx(1, ""Authorization required"");

# ifdef __OpenBSD__
		authuser(mypw->pw_name, login_style, rule->options & PERSIST);
# else
		shadowauth(mypw->pw_name, rule->options & PERSIST);
# endif
	}

# ifdef __OpenBSD__
	if (pledge(""stdio rpath getpw exec id"", NULL) == -1)
		err(1, ""pledge"");
# endif

#elif !defined(USE_PAM)
	(void) nflag;
	if (!(rule->options & NOPASS)) {
		errx(1, ""Authorization required"");
	}
#endif /* !(__OpenBSD__ || USE_SHADOW) && !USE_PAM */

#ifdef __OpenBSD__
	rv = getpwuid_r(target, &targpwstore, targpwbuf, sizeof(targpwbuf), &targpw);
	if (rv != 0)
		errx(1, ""no passwd entry for target"");
#else
	for (size_t sz = 1024; sz <= 16*1024; sz *= 2) {
		targpwbuf = reallocarray(targpwbuf, sz, sizeof (char));
		if (targpwbuf == NULL)
			errx(1, ""can't allocate targpwbuf"");
		rv = getpwuid_r(target, &targpwstore, targpwbuf, sz, &targpw);
		if (rv != ERANGE)
			break;
	}
	if (rv != 0)
		err(1, ""getpwuid_r failed"");
#endif
	if (targpw == NULL)
		err(1, ""getpwuid_r failed"");

#if defined(USE_PAM)
	pamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,
	    rule->options & PERSIST);
#endif

#ifdef HAVE_SETUSERCONTEXT
	if (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |
	    LOGIN_SETPATH |
	    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |
	    LOGIN_SETUSER) != 0)
		errx(1, ""failed to set user context for target"");
#else
	if (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)
		err(1, ""setresgid"");
	if (initgroups(targpw->pw_name, targpw->pw_gid) != 0)
		err(1, ""initgroups"");
	if (setresuid(target, target, target) != 0)
		err(1, ""setresuid"");
#endif

#ifdef __OpenBSD__
	if (pledge(""stdio rpath exec"", NULL) == -1)
		err(1, ""pledge"");
#endif

	if (getcwd(cwdpath, sizeof(cwdpath)) == NULL)
		cwd = ""(failed)"";
	else
		cwd = cwdpath;

#ifdef __OpenBSD__
	if (pledge(""stdio exec"", NULL) == -1)
		err(1, ""pledge"");
#endif

	syslog(LOG_AUTHPRIV | LOG_INFO, ""%s ran command %s as %s from %s"",
	    mypw->pw_name, cmdline, targpw->pw_name, cwd);

	envp = prepenv(rule, mypw, targpw);

	if (rule->cmd) {
		/* do this again after setusercontext reset it */
		if (setenv(""PATH"", safepath, 1) == -1)
			err(1, ""failed to set PATH '%s'"", safepath);
	}
	execvpe(cmd, argv, envp);
	if (errno == ENOENT)
		errx(1, ""%s: command not found"", cmd);
	err(1, ""%s"", cmd);
}","int
main(int VAR_0, char **VAR_1)
{
	const char *VAR_2 = ""/bin:/sbin:/usr/bin:/usr/sbin:""
	    ""/usr/local/bin:/usr/local/sbin"";
	const char *VAR_3 = NULL;
	char *VAR_4[] = { NULL, NULL };
	char *VAR_5;
	const char *VAR_6;
	char VAR_7[VAR_8];
#ifdef VAR_9
	char VAR_10[VAR_11], VAR_12[VAR_11];
#else
	char *VAR_10 = NULL, *VAR_12 = NULL;
#endif
	struct passwd VAR_13, VAR_14;
	struct passwd *VAR_15, *VAR_16;
	const struct rule *rule;
	uid_t VAR_17;
	uid_t VAR_18 = 0;
	gid_t VAR_19[VAR_20 + 1];
	int VAR_21;
	int VAR_22, VAR_23, VAR_24;
	int VAR_25 = 0;
	int VAR_26 = 0;
	char VAR_27[VAR_28];
	const char *VAR_29;
	char **VAR_30;
#ifdef VAR_31
	char *VAR_32 = NULL;
#endif

	setprogname(""doas"");

	closefrom(VAR_33 + 1);

	VAR_17 = getuid();

#ifdef VAR_31
# define VAR_34 ""a:C:Lnsu:""
#else
# define VAR_34 ""+C:Lnsu:""
#endif

	while ((VAR_23 = getopt(VAR_0, VAR_1, VAR_34)) != -1) {
		switch (VAR_23) {
#ifdef VAR_31
		case 'a':
			VAR_32 = VAR_35;
			break;
#endif
		case 'C':
			VAR_3 = VAR_35;
			break;
		case 'L':
#if defined(VAR_31)
			VAR_22 = open(""/dev/tty"", VAR_36);
			if (VAR_22 != -1)
				ioctl(VAR_22, VAR_37);
			exit(VAR_22 == -1);
#elif defined(VAR_38)
			exit(timestamp_clear() == -1);
#else
			exit(0);
#endif
		case 'u':
			if (parseuid(VAR_35, &VAR_18) != 0)
				errx(1, ""unknown user"");
			break;
		case 'n':
			VAR_26 = 1;
			break;
		case 's':
			VAR_25 = 1;
			break;
		default:
			usage();
			break;
		}
	}
	VAR_1 += VAR_39;
	VAR_0 -= VAR_39;

	if (VAR_3) {
		if (VAR_25)
			usage();
	} else if ((!VAR_25 && !VAR_0) || (VAR_25 && VAR_0))
		usage();

#ifdef VAR_9
	VAR_24 = getpwuid_r(VAR_17, &VAR_13, VAR_10, sizeof(VAR_10), &VAR_15);
	if (VAR_24 != 0)
		err(1, ""getpwuid_r failed"");
#else
	for (size_t VAR_40 = 1024; VAR_40 <= 16*1024; VAR_40 *= 2) {
		VAR_10 = reallocarray(VAR_10, VAR_40, sizeof (char));
		if (VAR_10 == NULL)
			errx(1, ""can't allocate mypwbuf"");
		VAR_24 = getpwuid_r(VAR_17, &VAR_13, VAR_10, VAR_40, &VAR_15);
		if (VAR_24 != VAR_41)
			break;
	}
	if (VAR_24 != 0)
		err(1, ""getpwuid_r failed"");
#endif
	if (VAR_15 == NULL)
		errx(1, ""no passwd entry for self"");
	VAR_21 = getgroups(VAR_20, VAR_19);
	if (VAR_21 == -1)
		err(1, ""can't get groups"");
	VAR_19[VAR_21++] = getgid();

	if (VAR_25) {
		VAR_5 = getenv(""SHELL"");
		if (VAR_5 == NULL || *VAR_5 == '\0') {
			VAR_4[0] = VAR_15->pw_shell;
		} else
			VAR_4[0] = VAR_5;
		VAR_1 = VAR_4;
		VAR_0 = 1;
	}

	if (VAR_3) {
		checkconfig(VAR_3, VAR_0, VAR_1, VAR_17, VAR_19, VAR_21,
		    VAR_18);
		exit(1);	/* COMMENT_0 */
	}

	if (geteuid())
		errx(1, ""not installed setuid"");

	parseconfig(""/etc/doas.conf"", 1);

	/* COMMENT_1 */
	(void)strlcpy(VAR_7, VAR_1[0], sizeof(VAR_7));
	for (VAR_22 = 1; VAR_22 < VAR_0; VAR_22++) {
		if (strlcat(VAR_7, "" "", sizeof(VAR_7)) >= sizeof(VAR_7))
			break;
		if (strlcat(VAR_7, VAR_1[VAR_22], sizeof(VAR_7)) >= sizeof(VAR_7))
			break;
	}

	VAR_6 = VAR_1[0];
	if (!permit(VAR_17, VAR_19, VAR_21, &rule, VAR_18, VAR_6,
	    (const char **)VAR_1 + 1)) {
		syslog(VAR_42 | VAR_43,
		    ""failed command for %s: %s"", VAR_15->pw_name, VAR_7);
		errc(1, VAR_44, NULL);
	}

#if defined(VAR_9) || defined(VAR_45)
	if (!(rule->options & VAR_46)) {
		if (VAR_26)
			errx(1, ""Authorization required"");

# ifdef VAR_9
		authuser(VAR_15->pw_name, VAR_32, rule->options & VAR_47);
# else
		shadowauth(VAR_15->pw_name, rule->options & VAR_47);
# endif
	}

# ifdef VAR_9
	if (pledge(""stdio rpath getpw exec id"", NULL) == -1)
		err(1, ""pledge"");
# endif

#elif !defined(VAR_48)
	(void) VAR_26;
	if (!(rule->options & VAR_46)) {
		errx(1, ""Authorization required"");
	}
#endif /* COMMENT_2 */

#ifdef VAR_9
	VAR_24 = getpwuid_r(VAR_18, &VAR_14, VAR_12, sizeof(VAR_12), &VAR_16);
	if (VAR_24 != 0)
		errx(1, ""no passwd entry for target"");
#else
	for (size_t VAR_40 = 1024; VAR_40 <= 16*1024; VAR_40 *= 2) {
		VAR_12 = reallocarray(VAR_12, VAR_40, sizeof (char));
		if (VAR_12 == NULL)
			errx(1, ""can't allocate targpwbuf"");
		VAR_24 = getpwuid_r(VAR_18, &VAR_14, VAR_12, VAR_40, &VAR_16);
		if (VAR_24 != VAR_41)
			break;
	}
	if (VAR_24 != 0)
		err(1, ""getpwuid_r failed"");
#endif
	if (VAR_16 == NULL)
		err(1, ""getpwuid_r failed"");

#if defined(VAR_48)
	pamauth(VAR_16->pw_name, VAR_15->pw_name, !VAR_26, rule->options & VAR_46,
	    rule->options & VAR_47);
#endif

#ifdef VAR_49
	if (setusercontext(NULL, VAR_16, VAR_18, VAR_50 |
	    VAR_51 |
	    VAR_52 | VAR_53 | VAR_54 |
	    VAR_55) != 0)
		errx(1, ""failed to set user context for target"");
#else
	if (setresgid(VAR_16->pw_gid, VAR_16->pw_gid, VAR_16->pw_gid) != 0)
		err(1, ""setresgid"");
	if (initgroups(VAR_16->pw_name, VAR_16->pw_gid) != 0)
		err(1, ""initgroups"");
	if (setresuid(VAR_18, VAR_18, VAR_18) != 0)
		err(1, ""setresuid"");
#endif

#ifdef VAR_9
	if (pledge(""stdio rpath exec"", NULL) == -1)
		err(1, ""pledge"");
#endif

	if (getcwd(VAR_27, sizeof(VAR_27)) == NULL)
		VAR_29 = ""(failed)"";
	else
		VAR_29 = VAR_27;

#ifdef VAR_9
	if (pledge(""stdio exec"", NULL) == -1)
		err(1, ""pledge"");
#endif

	syslog(VAR_42 | VAR_56, ""%s ran command %s as %s from %s"",
	    VAR_15->pw_name, VAR_7, VAR_16->pw_name, VAR_29);

	VAR_30 = prepenv(rule, VAR_15, VAR_16);

	if (rule->cmd) {
		/* COMMENT_3 */
		if (setenv(""PATH"", VAR_2, 1) == -1)
			err(1, ""failed to set PATH '%s'"", VAR_2);
	}
	execvpe(VAR_6, VAR_1, VAR_30);
	if (VAR_57 == VAR_58)
		errx(1, ""%s: command not found"", VAR_6);
	err(1, ""%s"", VAR_6);
}",Duncaen/OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168/doas.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -198,6 +198,7 @@
 
 #ifdef HAVE_SETUSERCONTEXT
 	if (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |
+	    LOGIN_SETPATH |
 	    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |
 	    LOGIN_SETUSER) != 0)
 		errx(1, ""failed to set user context for target"");
@@ -228,9 +229,10 @@
 	syslog(LOG_AUTHPRIV | LOG_INFO, ""%s ran command %s as %s from %s"",
 	    mypw->pw_name, cmdline, targpw->pw_name, cwd);
 
-	envp = prepenv(rule);
+	envp = prepenv(rule, mypw, targpw);
 
 	if (rule->cmd) {
+		/* do this again after setusercontext reset it */
 		if (setenv(""PATH"", safepath, 1) == -1)
 			err(1, ""failed to set PATH '%s'"", safepath);
 	}","{'deleted_lines': ['\tenvp = prepenv(rule);'], 'added_lines': ['\t    LOGIN_SETPATH |', '\tenvp = prepenv(rule, mypw, targpw);', '\t\t/* do this again after setusercontext reset it */']}",True,In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.,8.8,HIGH,2,test,2019-06-16T18:16:34Z,2
CVE-2019-25016,"['CWE-459', 'CWE-909']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0.0,Duncaen/OpenDoas,"redo the environment inheritance to not inherit. it was intended to make life easier, but it can be surprising or even unsafe. instead, reset just about everything to the target user's values. ok deraadt martijn Thanks to Sander Bos in particular for pointing out some nasty edge cases.",01c658f8c45cb92a343be5f32aa6da70b2032168,https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168,env.c,createenv,"static struct env *
createenv(const struct rule *rule)
{
struct env *env;
u_int i;
env = malloc(sizeof(*env));
if (!env)
err(1, NULL);
RB_INIT(&env->root);
env->count = 0;
if (rule->options & KEEPENV) {
extern char **environ;
for (i = 0; environ[i] != NULL; i++) {
struct envnode *node;
const char *e, *eq;
size_t len;
char keybuf[1024];
e = environ[i];
if ((eq = strchr(e, '=')) == NULL || eq == e)
continue;
len = eq - e;
if (len > sizeof(keybuf) - 1)
continue;
memcpy(keybuf, e, len);
keybuf[len] = '\0';
node = createnode(keybuf, eq + 1);
if (RB_INSERT(envtree, &env->root, node)) {
freenode(node);
} else {
env->count++;
}
}
}
return env;
}","static struct env *
createenv(const struct rule *rule)
{
struct env *env;
u_int VAR_0;
env = malloc(sizeof(*env));
if (!env)
err(1, NULL);
RB_INIT(&env->root);
env->count = 0;
if (rule->options & VAR_1) {
extern char **VAR_2;
for (VAR_0 = 0; VAR_2[VAR_0] != NULL; VAR_0++) {
struct envnode *VAR_3;
const char *VAR_4, *VAR_5;
size_t VAR_6;
char VAR_7[1024];
VAR_4 = VAR_2[VAR_0];
if ((VAR_5 = strchr(VAR_4, '=')) == NULL || VAR_5 == VAR_4)
continue;
VAR_6 = VAR_5 - VAR_4;
if (VAR_6 > sizeof(VAR_7) - 1)
continue;
memcpy(VAR_7, VAR_4, VAR_6);
VAR_7[VAR_6] = '\0';
VAR_3 = createnode(VAR_7, VAR_5 + 1);
if (RB_INSERT(VAR_8, &env->root, VAR_3)) {
freenode(VAR_3);
} else {
env->count++;
}
}
}
return env;
}",Duncaen/OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168/env.c/vul/before/0.json,"static struct env *
createenv(const struct rule *rule, const struct passwd *mypw,
    const struct passwd *targpw)
{
	struct env *env;
	u_int i;

	env = malloc(sizeof(*env));
	if (!env)
		err(1, NULL);
	RB_INIT(&env->root);
	env->count = 0;

	addnode(env, ""DOAS_USER"", mypw->pw_name);

	if (rule->options & KEEPENV) {
		extern char **environ;

		for (i = 0; environ[i] != NULL; i++) {
			struct envnode *node;
			const char *e, *eq;
			size_t len;
			char keybuf[1024];

			e = environ[i];

			/* ignore invalid or overlong names */
			if ((eq = strchr(e, '=')) == NULL || eq == e)
				continue;
			len = eq - e;
			if (len > sizeof(keybuf) - 1)
				continue;
			memcpy(keybuf, e, len);
			keybuf[len] = '\0';

			node = createnode(keybuf, eq + 1);
			if (RB_INSERT(envtree, &env->root, node)) {
				/* ignore any later duplicates */
				freenode(node);
			} else {
				env->count++;
			}
		}
	} else {
		static const char *copyset[] = {
			""DISPLAY"", ""TERM"",
			NULL
		};

		addnode(env, ""HOME"", targpw->pw_dir);
		addnode(env, ""LOGNAME"", targpw->pw_name);
		addnode(env, ""PATH"", getenv(""PATH""));
		addnode(env, ""SHELL"", targpw->pw_shell);
		addnode(env, ""USER"", targpw->pw_name);

		fillenv(env, copyset);
	}

	return env;
}","static struct env *
createenv(const struct rule *rule, const struct passwd *VAR_0,
    const struct passwd *VAR_1)
{
	struct env *env;
	u_int VAR_2;

	env = malloc(sizeof(*env));
	if (!env)
		err(1, NULL);
	RB_INIT(&env->root);
	env->count = 0;

	addnode(env, ""DOAS_USER"", VAR_0->pw_name);

	if (rule->options & VAR_3) {
		extern char **VAR_4;

		for (VAR_2 = 0; VAR_4[VAR_2] != NULL; VAR_2++) {
			struct envnode *VAR_5;
			const char *VAR_6, *VAR_7;
			size_t VAR_8;
			char VAR_9[1024];

			VAR_6 = VAR_4[VAR_2];

			/* COMMENT_0 */
			if ((VAR_7 = strchr(VAR_6, '=')) == NULL || VAR_7 == VAR_6)
				continue;
			VAR_8 = VAR_7 - VAR_6;
			if (VAR_8 > sizeof(VAR_9) - 1)
				continue;
			memcpy(VAR_9, VAR_6, VAR_8);
			VAR_9[VAR_8] = '\0';

			VAR_5 = createnode(VAR_9, VAR_7 + 1);
			if (RB_INSERT(VAR_10, &env->root, VAR_5)) {
				/* COMMENT_1 */
				freenode(VAR_5);
			} else {
				env->count++;
			}
		}
	} else {
		static const char *VAR_11[] = {
			""DISPLAY"", ""TERM"",
			NULL
		};

		addnode(env, ""HOME"", VAR_1->pw_dir);
		addnode(env, ""LOGNAME"", VAR_1->pw_name);
		addnode(env, ""PATH"", getenv(""PATH""));
		addnode(env, ""SHELL"", VAR_1->pw_shell);
		addnode(env, ""USER"", VAR_1->pw_name);

		fillenv(env, VAR_11);
	}

	return env;
}",Duncaen/OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168/env.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 static struct env *
-createenv(const struct rule *rule)
+createenv(const struct rule *rule, const struct passwd *mypw,
+    const struct passwd *targpw)
 {
 	struct env *env;
 	u_int i;
@@ -9,6 +10,8 @@
 		err(1, NULL);
 	RB_INIT(&env->root);
 	env->count = 0;
+
+	addnode(env, ""DOAS_USER"", mypw->pw_name);
 
 	if (rule->options & KEEPENV) {
 		extern char **environ;
@@ -38,6 +41,19 @@
 				env->count++;
 			}
 		}
+	} else {
+		static const char *copyset[] = {
+			""DISPLAY"", ""TERM"",
+			NULL
+		};
+
+		addnode(env, ""HOME"", targpw->pw_dir);
+		addnode(env, ""LOGNAME"", targpw->pw_name);
+		addnode(env, ""PATH"", getenv(""PATH""));
+		addnode(env, ""SHELL"", targpw->pw_shell);
+		addnode(env, ""USER"", targpw->pw_name);
+
+		fillenv(env, copyset);
 	}
 
 	return env;","{'deleted_lines': ['createenv(const struct rule *rule)'], 'added_lines': ['createenv(const struct rule *rule, const struct passwd *mypw,', '    const struct passwd *targpw)', '', '\taddnode(env, ""DOAS_USER"", mypw->pw_name);', '\t} else {', '\t\tstatic const char *copyset[] = {', '\t\t\t""DISPLAY"", ""TERM"",', '\t\t\tNULL', '\t\t};', '', '\t\taddnode(env, ""HOME"", targpw->pw_dir);', '\t\taddnode(env, ""LOGNAME"", targpw->pw_name);', '\t\taddnode(env, ""PATH"", getenv(""PATH""));', '\t\taddnode(env, ""SHELL"", targpw->pw_shell);', '\t\taddnode(env, ""USER"", targpw->pw_name);', '', '\t\tfillenv(env, copyset);']}",True,In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.,8.8,HIGH,2,test,2019-06-16T18:16:34Z,2
CVE-2019-25016,"['CWE-459', 'CWE-909']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0.0,Duncaen/OpenDoas,"redo the environment inheritance to not inherit. it was intended to make life easier, but it can be surprising or even unsafe. instead, reset just about everything to the target user's values. ok deraadt martijn Thanks to Sander Bos in particular for pointing out some nasty edge cases.",01c658f8c45cb92a343be5f32aa6da70b2032168,https://github.com/Duncaen/OpenDoas/commit/01c658f8c45cb92a343be5f32aa6da70b2032168,env.c,prepenv,"char **
prepenv(const struct rule *rule)
{
static const char *safeset[] = {
""DISPLAY"", ""HOME"", ""LOGNAME"", ""MAIL"",
""PATH"", ""TERM"", ""USER"", ""USERNAME"",
NULL
};
struct env *env;
env = createenv(rule);
if (!(rule->options & KEEPENV))
fillenv(env, safeset);
if (rule->envlist)
fillenv(env, rule->envlist);
return flattenenv(env);
}","char **
prepenv(const struct rule *rule)
{
static const char *VAR_0[] = {
""DISPLAY"", ""HOME"", ""LOGNAME"", ""MAIL"",
""PATH"", ""TERM"", ""USER"", ""USERNAME"",
NULL
};
struct env *env;
env = createenv(rule);
if (!(rule->options & VAR_1))
fillenv(env, VAR_0);
if (rule->envlist)
fillenv(env, rule->envlist);
return flattenenv(env);
}",Duncaen/OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168/env.c/vul/before/1.json,"char **
prepenv(const struct rule *rule, const struct passwd *mypw,
    const struct passwd *targpw)
{
	struct env *env;

	env = createenv(rule, mypw, targpw);
	if (rule->envlist)
		fillenv(env, rule->envlist);

	return flattenenv(env);
}","char **
prepenv(const struct rule *rule, const struct passwd *VAR_0,
    const struct passwd *VAR_1)
{
	struct env *env;

	env = createenv(rule, VAR_0, VAR_1);
	if (rule->envlist)
		fillenv(env, rule->envlist);

	return flattenenv(env);
}",Duncaen/OpenDoas/01c658f8c45cb92a343be5f32aa6da70b2032168/env.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,18 +1,10 @@
 char **
-prepenv(const struct rule *rule)
+prepenv(const struct rule *rule, const struct passwd *mypw,
+    const struct passwd *targpw)
 {
-	static const char *safeset[] = {
-		""DISPLAY"", ""HOME"", ""LOGNAME"", ""MAIL"",
-		""PATH"", ""TERM"", ""USER"", ""USERNAME"",
-		NULL
-	};
 	struct env *env;
 
-	env = createenv(rule);
-
-	/* if we started with blank, fill some defaults then apply rules */
-	if (!(rule->options & KEEPENV))
-		fillenv(env, safeset);
+	env = createenv(rule, mypw, targpw);
 	if (rule->envlist)
 		fillenv(env, rule->envlist);
 ","{'deleted_lines': ['prepenv(const struct rule *rule)', '\tstatic const char *safeset[] = {', '\t\t""DISPLAY"", ""HOME"", ""LOGNAME"", ""MAIL"",', '\t\t""PATH"", ""TERM"", ""USER"", ""USERNAME"",', '\t\tNULL', '\t};', '\tenv = createenv(rule);', '', '\t/* if we started with blank, fill some defaults then apply rules */', '\tif (!(rule->options & KEEPENV))', '\t\tfillenv(env, safeset);'], 'added_lines': ['prepenv(const struct rule *rule, const struct passwd *mypw,', '    const struct passwd *targpw)', '\tenv = createenv(rule, mypw, targpw);']}",True,In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.,8.8,HIGH,2,test,2019-06-16T18:16:34Z,2
CVE-2019-13300,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,ImageMagick/ImageMagick6,https://github.com/ImageMagick/ImageMagick/issues/1586,5e409ae7a389cdf2ed17469303be3f3f21cec450,https://github.com/ImageMagick/ImageMagick6/commit/5e409ae7a389cdf2ed17469303be3f3f21cec450,magick/statistic.c,AcquirePixelThreadSet,"static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)
{
MagickPixelPacket
**pixels;
register ssize_t
i,
j;
size_t
number_threads;
number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,
sizeof(*pixels));
if (pixels == (MagickPixelPacket **) NULL)
return((MagickPixelPacket **) NULL);
(void) memset(pixels,0,number_threads*sizeof(*pixels));
for (i=0; i < (ssize_t) number_threads; i++)
{
pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(image->columns,
sizeof(**pixels));
if (pixels[i] == (MagickPixelPacket *) NULL)
return(DestroyPixelThreadSet(pixels));
for (j=0; j < (ssize_t) image->columns; j++)
GetMagickPixelPacket(image,&pixels[i][j]);
}
return(pixels);
}","static MagickPixelPacket **AcquirePixelThreadSet(const Image *VAR_0)
{
MagickPixelPacket
**VAR_1;
register ssize_t
VAR_2,
VAR_3;
size_t
VAR_4;
VAR_4=(size_t) GetMagickResourceLimit(VAR_5);
VAR_1=(MagickPixelPacket **) AcquireQuantumMemory(VAR_4,
sizeof(*VAR_1));
if (VAR_1 == (MagickPixelPacket **) NULL)
return((MagickPixelPacket **) NULL);
(void) memset(VAR_1,0,VAR_4*sizeof(*VAR_1));
for (VAR_2=0; VAR_2 < (ssize_t) VAR_4; VAR_2++)
{
VAR_1[VAR_2]=(MagickPixelPacket *) AcquireQuantumMemory(VAR_0->columns,
sizeof(**VAR_1));
if (VAR_1[VAR_2] == (MagickPixelPacket *) NULL)
return(DestroyPixelThreadSet(VAR_1));
for (VAR_3=0; VAR_3 < (ssize_t) VAR_0->columns; VAR_3++)
GetMagickPixelPacket(VAR_0,&VAR_1[VAR_2][VAR_3]);
}
return(VAR_1);
}",ImageMagick/ImageMagick6/5e409ae7a389cdf2ed17469303be3f3f21cec450/statistic.c/vul/before/0.json,"static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)
{
  const Image
    *next;

  MagickPixelPacket
    **pixels;

  register ssize_t
    i,
    j;

  size_t
    columns,
    number_threads;

  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
  pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,
    sizeof(*pixels));
  if (pixels == (MagickPixelPacket **) NULL)
    return((MagickPixelPacket **) NULL);
  (void) memset(pixels,0,number_threads*sizeof(*pixels));
  columns=images->columns;
  for (next=images; next != (Image *) NULL; next=next->next)
    columns=MagickMax(next->columns,columns);
  for (i=0; i < (ssize_t) number_threads; i++)
  {
    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,
      sizeof(**pixels));
    if (pixels[i] == (MagickPixelPacket *) NULL)
      return(DestroyPixelThreadSet(pixels));
    for (j=0; j < (ssize_t) columns; j++)
      GetMagickPixelPacket(images,&pixels[i][j]);
  }
  return(pixels);
}","static MagickPixelPacket **AcquirePixelThreadSet(const Image *VAR_0)
{
  const Image
    *VAR_1;

  MagickPixelPacket
    **VAR_2;

  register ssize_t
    VAR_3,
    VAR_4;

  size_t
    VAR_5,
    VAR_6;

  VAR_6=(size_t) GetMagickResourceLimit(VAR_7);
  VAR_2=(MagickPixelPacket **) AcquireQuantumMemory(VAR_6,
    sizeof(*VAR_2));
  if (VAR_2 == (MagickPixelPacket **) NULL)
    return((MagickPixelPacket **) NULL);
  (void) memset(VAR_2,0,VAR_6*sizeof(*VAR_2));
  VAR_5=VAR_0->columns;
  for (VAR_1=VAR_0; VAR_1 != (Image *) NULL; VAR_1=VAR_1->next)
    VAR_5=MagickMax(VAR_1->columns,VAR_5);
  for (VAR_3=0; VAR_3 < (ssize_t) VAR_6; VAR_3++)
  {
    VAR_2[VAR_3]=(MagickPixelPacket *) AcquireQuantumMemory(VAR_5,
      sizeof(**VAR_2));
    if (VAR_2[VAR_3] == (MagickPixelPacket *) NULL)
      return(DestroyPixelThreadSet(VAR_2));
    for (VAR_4=0; VAR_4 < (ssize_t) VAR_5; VAR_4++)
      GetMagickPixelPacket(VAR_0,&VAR_2[VAR_3][VAR_4]);
  }
  return(VAR_2);
}",ImageMagick/ImageMagick6/5e409ae7a389cdf2ed17469303be3f3f21cec450/statistic.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
-static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)
+static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)
 {
+  const Image
+    *next;
+
   MagickPixelPacket
     **pixels;
 
@@ -8,6 +11,7 @@
     j;
 
   size_t
+    columns,
     number_threads;
 
   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
@@ -16,14 +20,17 @@
   if (pixels == (MagickPixelPacket **) NULL)
     return((MagickPixelPacket **) NULL);
   (void) memset(pixels,0,number_threads*sizeof(*pixels));
+  columns=images->columns;
+  for (next=images; next != (Image *) NULL; next=next->next)
+    columns=MagickMax(next->columns,columns);
   for (i=0; i < (ssize_t) number_threads; i++)
   {
-    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(image->columns,
+    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,
       sizeof(**pixels));
     if (pixels[i] == (MagickPixelPacket *) NULL)
       return(DestroyPixelThreadSet(pixels));
-    for (j=0; j < (ssize_t) image->columns; j++)
-      GetMagickPixelPacket(image,&pixels[i][j]);
+    for (j=0; j < (ssize_t) columns; j++)
+      GetMagickPixelPacket(images,&pixels[i][j]);
   }
   return(pixels);
 }","{'deleted_lines': ['static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)', '    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(image->columns,', '    for (j=0; j < (ssize_t) image->columns; j++)', '      GetMagickPixelPacket(image,&pixels[i][j]);'], 'added_lines': ['static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)', '  const Image', '    *next;', '', '    columns,', '  columns=images->columns;', '  for (next=images; next != (Image *) NULL; next=next->next)', '    columns=MagickMax(next->columns,columns);', '    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,', '    for (j=0; j < (ssize_t) columns; j++)', '      GetMagickPixelPacket(images,&pixels[i][j]);']}",True,ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling columns.,8.8,HIGH,2,test,2019-06-16T18:36:10Z,2
CVE-2019-13619,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,wireshark,"asn1: don't increment a buffer beyond its end.

Bug: 15870
Change-Id: I04cbb822f0e77c8e0ac8513e3a5c13116920ca6e
Reviewed-on: https://code.wireshark.org/review/33731
Petri-Dish: Anders Broman <a.broman58@gmail.com>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 45a3d0787f3c9f6f5fb5b53a8c29771b3f28e406)
Reviewed-on: https://code.wireshark.org/review/33736
Petri-Dish: Dario Lombardo <lomato@gmail.com>
Reviewed-by: Gerald Combs <gerald@wireshark.org>",7e90aed666e809c0db5de9d1816802a7dcea28d9,https://github.com/wireshark/wireshark/commit/7e90aed666e809c0db5de9d1816802a7dcea28d9,epan/asn1.c,asn1_get_real,"double asn1_get_real(const guint8 *real_ptr, gint len) {
guint8 octet;
const guint8 *p;
guint8 *buf;
double val = 0;
if (len < 1) return val;
octet = real_ptr[0];
p = real_ptr + 1;
len -= 1;
if (octet & 0x80) {  
int i;
gboolean Eneg;
gint8 S; 
guint8 B; 
guint8 F; 
gint32 E = 0; 
guint64 N = 0; 
guint8 lenE, lenN;
if(octet & 0x40) S = -1; else S = 1;
switch(octet & 0x30) {
case 0x00: B = 2; break;
case 0x10: B = 8; break;
case 0x20: B = 16; break;
case 0x30: 
default:
return 0;
}
F = (octet & 0x0c) >> 2;
lenE = (octet & 0x3) + 1;
if(lenE == 4)
{
DISSECTOR_ASSERT_NOT_REACHED();
}
Eneg = (*p) & 0x80 ? TRUE : FALSE;
for (i = 0; i < lenE; i++) {
if(Eneg) {
E = (E<<8) | ((guint8) ~(*p));
} else {
E = (E<<8) | *p;
}
p++;
}
if(Eneg) {
E = -(E + 1);
}
lenN = len - lenE;
if(lenN > 8)
{
DISSECTOR_ASSERT_NOT_REACHED();
}
for (i=0; i<lenN; i++) {
N = (N<<8) | *p;
p++;
}
val = (double) S * N * pow(2, F) * pow(B, E);
#ifdef DEBUG
ws_debug_printf(""S = %d, N = %lu, F = %u, B = %u, E = %d -> %f\n"", S, N, F, B, E, val);
#endif
} else if (octet & 0x40) {  
switch (octet & 0x3F) {
case 0x00: val = HUGE_VAL; break;
case 0x01: val = -HUGE_VAL; break;
}
} else {  
buf = g_strndup(p, len);
val = g_ascii_strtod(buf, NULL);
g_free(buf);
}
return val;
}","double asn1_get_real(const guint8 *VAR_0, gint VAR_1) {
guint8 VAR_2;
const guint8 *VAR_3;
guint8 *VAR_4;
double VAR_5 = 0;
if (VAR_1 < 1) return VAR_5;
VAR_2 = VAR_0[0];
VAR_3 = VAR_0 + 1;
VAR_1 -= 1;
if (VAR_2 & 0x80) {  
int VAR_6;
gboolean VAR_7;
gint8 VAR_8; 
guint8 VAR_9; 
guint8 VAR_10; 
gint32 VAR_11 = 0; 
guint64 VAR_12 = 0; 
guint8 VAR_13, VAR_14;
if(VAR_2 & 0x40) VAR_8 = -1; else VAR_8 = 1;
switch(VAR_2 & 0x30) {
case 0x00: VAR_9 = 2; break;
case 0x10: VAR_9 = 8; break;
case 0x20: VAR_9 = 16; break;
case 0x30: 
default:
return 0;
}
VAR_10 = (VAR_2 & 0x0c) >> 2;
VAR_13 = (VAR_2 & 0x3) + 1;
if(VAR_13 == 4)
{
DISSECTOR_ASSERT_NOT_REACHED();
}
VAR_7 = (*VAR_3) & 0x80 ? TRUE : FALSE;
for (VAR_6 = 0; VAR_6 < VAR_13; VAR_6++) {
if(VAR_7) {
VAR_11 = (VAR_11<<8) | ((guint8) ~(*VAR_3));
} else {
VAR_11 = (VAR_11<<8) | *VAR_3;
}
VAR_3++;
}
if(VAR_7) {
VAR_11 = -(VAR_11 + 1);
}
VAR_14 = VAR_1 - VAR_13;
if(VAR_14 > 8)
{
DISSECTOR_ASSERT_NOT_REACHED();
}
for (VAR_6=0; VAR_6<VAR_14; VAR_6++) {
VAR_12 = (VAR_12<<8) | *VAR_3;
VAR_3++;
}
VAR_5 = (double) VAR_8 * VAR_12 * pow(2, VAR_10) * pow(VAR_9, VAR_11);
#ifdef VAR_15
ws_debug_printf(""S = %d, N = %lu, F = %u, B = %u, E = %d -> %f\n"", VAR_8, VAR_12, VAR_10, VAR_9, VAR_11, VAR_5);
#endif
} else if (VAR_2 & 0x40) {  
switch (VAR_2 & 0x3F) {
case 0x00: VAR_5 = VAR_16; break;
case 0x01: VAR_5 = -VAR_16; break;
}
} else {  
VAR_4 = g_strndup(VAR_3, VAR_1);
VAR_5 = g_ascii_strtod(VAR_4, NULL);
g_free(VAR_4);
}
return VAR_5;
}",wireshark/7e90aed666e809c0db5de9d1816802a7dcea28d9/asn1.c/vul/before/0.json,"double asn1_get_real(const guint8 *real_ptr, gint len) {
  guint8 octet;
  const guint8 *p;
  guint8 *buf;
  double val = 0;

  /* 8.5.2    If the real value is the value zero,
   *          there shall be no contents octets in the encoding.
   */
  if (len < 1) return val;

  octet = real_ptr[0];
  p = real_ptr + 1;
  len -= 1;
  if (octet & 0x80) {  /* binary encoding */
    int i;
    gboolean Eneg;
    gint8 S; /* Sign */
    guint8 B; /* Base */
    guint8 F; /* scaling Factor */
    gint32 E = 0; /* Exponent (supported max 3 octets/24 bit) */
    guint64 N = 0; /* N (supported max 8 octets/64 bit) */

    guint8 lenE, lenN;

    if(octet & 0x40) S = -1; else S = 1;
    switch(octet & 0x30) {
      case 0x00: B = 2; break;
      case 0x10: B = 8; break;
      case 0x20: B = 16; break;
      case 0x30: /* Reserved */
      default:
        /* TODO Add some warning in tree about reserved value for Base */
        return 0;
    }
    F = (octet & 0x0c) >> 2;

    /* 8.5.6.4 Exponent length */
    lenE = (octet & 0x3) + 1;
    if(lenE == 4)
    {
      /* we can't handle exponents > 24 bits */
      /* TODO Next octet(s) define length of exponent */
      DISSECTOR_ASSERT_NOT_REACHED();
    }

    /* Ensure the buffer len and its content are coherent */
    DISSECTOR_ASSERT(lenE < len - 1);

    Eneg = (*p) & 0x80 ? TRUE : FALSE;
    for (i = 0; i < lenE; i++) {
      if(Eneg) {
        /* 2's complement: inverse bits */
        E = (E<<8) | ((guint8) ~(*p));
      } else {
        E = (E<<8) | *p;
      }
      p++;
    }
    if(Eneg) {
      /* 2's complement: ... and add 1 (and make negative of course) */
      E = -(E + 1);
    }

    lenN = len - lenE;
    if(lenN > 8)
    {
      /* we can't handle integers > 64 bits */
      DISSECTOR_ASSERT_NOT_REACHED();
    }
    for (i=0; i<lenN; i++) {
      N = (N<<8) | *p;
      p++;
    }
    val = (double) S * N * pow(2, F) * pow(B, E);
#ifdef DEBUG
    ws_debug_printf(""S = %d, N = %lu, F = %u, B = %u, E = %d -> %f\n"", S, N, F, B, E, val);
#endif
  } else if (octet & 0x40) {  /* SpecialRealValue */
    switch (octet & 0x3F) {
      case 0x00: val = HUGE_VAL; break;
      case 0x01: val = -HUGE_VAL; break;
    }
  } else {  /* decimal encoding */
    buf = g_strndup(p, len);
    val = g_ascii_strtod(buf, NULL);
    g_free(buf);
  }

  return val;
}","double asn1_get_real(const guint8 *VAR_0, gint VAR_1) {
  guint8 VAR_2;
  const guint8 *VAR_3;
  guint8 *VAR_4;
  double VAR_5 = 0;

  /* COMMENT_0 */
                                                                
     
  if (VAR_1 < 1) return VAR_5;

  VAR_2 = VAR_0[0];
  VAR_3 = VAR_0 + 1;
  VAR_1 -= 1;
  if (VAR_2 & 0x80) {  /* COMMENT_3 */
    int VAR_6;
    gboolean VAR_7;
    gint8 VAR_8; /* COMMENT_4 */
    guint8 VAR_9; /* COMMENT_5 */
    guint8 VAR_10; /* COMMENT_6 */
    gint32 VAR_11 = 0; /* COMMENT_7 */
    guint64 VAR_12 = 0; /* COMMENT_8 */

    guint8 VAR_13, VAR_14;

    if(VAR_2 & 0x40) VAR_8 = -1; else VAR_8 = 1;
    switch(VAR_2 & 0x30) {
      case 0x00: VAR_9 = 2; break;
      case 0x10: VAR_9 = 8; break;
      case 0x20: VAR_9 = 16; break;
      case 0x30: /* COMMENT_9 */
      default:
        /* COMMENT_10 */
        return 0;
    }
    VAR_10 = (VAR_2 & 0x0c) >> 2;

    /* COMMENT_11 */
    VAR_13 = (VAR_2 & 0x3) + 1;
    if(VAR_13 == 4)
    {
      /* COMMENT_12 */
      /* COMMENT_13 */
      DISSECTOR_ASSERT_NOT_REACHED();
    }

    /* COMMENT_14 */
    DISSECTOR_ASSERT(VAR_13 < VAR_1 - 1);

    VAR_7 = (*VAR_3) & 0x80 ? TRUE : FALSE;
    for (VAR_6 = 0; VAR_6 < VAR_13; VAR_6++) {
      if(VAR_7) {
        /* COMMENT_15 */
        VAR_11 = (VAR_11<<8) | ((guint8) ~(*VAR_3));
      } else {
        VAR_11 = (VAR_11<<8) | *VAR_3;
      }
      VAR_3++;
    }
    if(VAR_7) {
      /* COMMENT_16 */
      VAR_11 = -(VAR_11 + 1);
    }

    VAR_14 = VAR_1 - VAR_13;
    if(VAR_14 > 8)
    {
      /* COMMENT_17 */
      DISSECTOR_ASSERT_NOT_REACHED();
    }
    for (VAR_6=0; VAR_6<VAR_14; VAR_6++) {
      VAR_12 = (VAR_12<<8) | *VAR_3;
      VAR_3++;
    }
    VAR_5 = (double) VAR_8 * VAR_12 * pow(2, VAR_10) * pow(VAR_9, VAR_11);
#ifdef VAR_15
    ws_debug_printf(""S = %d, N = %lu, F = %u, B = %u, E = %d -> %f\n"", VAR_8, VAR_12, VAR_10, VAR_9, VAR_11, VAR_5);
#endif
  } else if (VAR_2 & 0x40) {  /* COMMENT_18 */
    switch (VAR_2 & 0x3F) {
      case 0x00: VAR_5 = VAR_16; break;
      case 0x01: VAR_5 = -VAR_16; break;
    }
  } else {  /* COMMENT_19 */
    VAR_4 = g_strndup(VAR_3, VAR_1);
    VAR_5 = g_ascii_strtod(VAR_4, NULL);
    g_free(VAR_4);
  }

  return VAR_5;
}",wireshark/7e90aed666e809c0db5de9d1816802a7dcea28d9/asn1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -44,6 +44,9 @@
       DISSECTOR_ASSERT_NOT_REACHED();
     }
 
+    /* Ensure the buffer len and its content are coherent */
+    DISSECTOR_ASSERT(lenE < len - 1);
+
     Eneg = (*p) & 0x80 ? TRUE : FALSE;
     for (i = 0; i < lenE; i++) {
       if(Eneg) {","{'deleted_lines': [], 'added_lines': ['    /* Ensure the buffer len and its content are coherent */', '    DISSECTOR_ASSERT(lenE < len - 1);', '']}",True,"In Wireshark 3.0.0 to 3.0.2, 2.6.0 to 2.6.9, and 2.4.0 to 2.4.15, the ASN.1 BER dissector and related dissectors could crash. This was addressed in epan/asn1.c by properly restricting buffer increments.",7.5,HIGH,2,test,2019-06-24T21:36:15Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_cryp_state_copy,"TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)
{
TEE_Result res;
struct tee_cryp_state *cs_dst;
struct tee_cryp_state *cs_src;
struct tee_ta_session *sess;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);
if (res != TEE_SUCCESS)
return res;
if (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)
return TEE_ERROR_BAD_PARAMETERS;
switch (TEE_ALG_GET_CLASS(cs_src->algo)) {
case TEE_OPERATION_CIPHER:
crypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,
cs_src->algo);
break;
case TEE_OPERATION_AE:
crypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,
cs_src->algo);
break;
case TEE_OPERATION_DIGEST:
crypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);
break;
case TEE_OPERATION_MAC:
crypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);
break;
default:
return TEE_ERROR_BAD_STATE;
}
return TEE_SUCCESS;
}","TEE_Result syscall_cryp_state_copy(unsigned long VAR_0, unsigned long VAR_1)
{
TEE_Result VAR_2;
struct tee_cryp_state *VAR_3;
struct tee_cryp_state *VAR_4;
struct tee_ta_session *VAR_5;
VAR_2 = tee_ta_get_current_session(&VAR_5);
if (VAR_2 != VAR_6)
return VAR_2;
VAR_2 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_3);
if (VAR_2 != VAR_6)
return VAR_2;
VAR_2 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_1), &VAR_4);
if (VAR_2 != VAR_6)
return VAR_2;
if (VAR_3->algo != VAR_4->algo || VAR_3->mode != VAR_4->mode)
return VAR_7;
switch (TEE_ALG_GET_CLASS(VAR_4->algo)) {
case VAR_8:
crypto_cipher_copy_state(VAR_3->ctx, VAR_4->ctx,
VAR_4->algo);
break;
case VAR_9:
crypto_authenc_copy_state(VAR_3->ctx, VAR_4->ctx,
VAR_4->algo);
break;
case VAR_10:
crypto_hash_copy_state(VAR_3->ctx, VAR_4->ctx, VAR_4->algo);
break;
case VAR_11:
crypto_mac_copy_state(VAR_3->ctx, VAR_4->ctx, VAR_4->algo);
break;
default:
return VAR_12;
}
return VAR_6;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/3.json,"TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)
{
	TEE_Result res;
	struct tee_cryp_state *cs_dst;
	struct tee_cryp_state *cs_src;
	struct tee_ta_session *sess;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);
	if (res != TEE_SUCCESS)
		return res;
	if (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)
		return TEE_ERROR_BAD_PARAMETERS;

	switch (TEE_ALG_GET_CLASS(cs_src->algo)) {
	case TEE_OPERATION_CIPHER:
		crypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,
					 cs_src->algo);
		break;
	case TEE_OPERATION_AE:
		crypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,
					  cs_src->algo);
		break;
	case TEE_OPERATION_DIGEST:
		crypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);
		break;
	case TEE_OPERATION_MAC:
		crypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);
		break;
	default:
		return TEE_ERROR_BAD_STATE;
	}

	cs_dst->state = cs_src->state;

	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_state_copy(unsigned long VAR_0, unsigned long VAR_1)
{
	TEE_Result VAR_2;
	struct tee_cryp_state *VAR_3;
	struct tee_cryp_state *VAR_4;
	struct tee_ta_session *VAR_5;

	VAR_2 = tee_ta_get_current_session(&VAR_5);
	if (VAR_2 != VAR_6)
		return VAR_2;

	VAR_2 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_3);
	if (VAR_2 != VAR_6)
		return VAR_2;

	VAR_2 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_1), &VAR_4);
	if (VAR_2 != VAR_6)
		return VAR_2;
	if (VAR_3->algo != VAR_4->algo || VAR_3->mode != VAR_4->mode)
		return VAR_7;

	switch (TEE_ALG_GET_CLASS(VAR_4->algo)) {
	case VAR_8:
		crypto_cipher_copy_state(VAR_3->ctx, VAR_4->ctx,
					 VAR_4->algo);
		break;
	case VAR_9:
		crypto_authenc_copy_state(VAR_3->ctx, VAR_4->ctx,
					  VAR_4->algo);
		break;
	case VAR_10:
		crypto_hash_copy_state(VAR_3->ctx, VAR_4->ctx, VAR_4->algo);
		break;
	case VAR_11:
		crypto_mac_copy_state(VAR_3->ctx, VAR_4->ctx, VAR_4->algo);
		break;
	default:
		return VAR_12;
	}

	VAR_3->state = VAR_4->state;

	return VAR_6;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -38,5 +38,7 @@
 		return TEE_ERROR_BAD_STATE;
 	}
 
+	cs_dst->state = cs_src->state;
+
 	return TEE_SUCCESS;
 }","{'deleted_lines': [], 'added_lines': ['\tcs_dst->state = cs_src->state;', '']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_cryp_state_alloc,"TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,
unsigned long key1, unsigned long key2,
uint32_t *state)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
struct tee_obj *o1 = NULL;
struct tee_obj *o2 = NULL;
struct user_ta_ctx *utc;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
utc = to_user_ta_ctx(sess->ctx);
if (key1 != 0) {
res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);
if (res != TEE_SUCCESS)
return res;
if (o1->busy)
return TEE_ERROR_BAD_PARAMETERS;
res = tee_svc_cryp_check_key_type(o1, algo, mode);
if (res != TEE_SUCCESS)
return res;
}
if (key2 != 0) {
res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);
if (res != TEE_SUCCESS)
return res;
if (o2->busy)
return TEE_ERROR_BAD_PARAMETERS;
res = tee_svc_cryp_check_key_type(o2, algo, mode);
if (res != TEE_SUCCESS)
return res;
}
cs = calloc(1, sizeof(struct tee_cryp_state));
if (!cs)
return TEE_ERROR_OUT_OF_MEMORY;
TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);
cs->algo = algo;
cs->mode = mode;
switch (TEE_ALG_GET_CLASS(algo)) {
case TEE_OPERATION_EXTENSION:
#ifdef CFG_CRYPTO_RSASSA_NA1
if (algo == TEE_ALG_RSASSA_PKCS1_V1_5)
goto rsassa_na1;
#endif
res = TEE_ERROR_NOT_SUPPORTED;
break;
case TEE_OPERATION_CIPHER:
if ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||
(algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
res = crypto_cipher_alloc_ctx(&cs->ctx, algo);
if (res != TEE_SUCCESS)
break;
}
break;
case TEE_OPERATION_AE:
if (key1 == 0 || key2 != 0) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
res = crypto_authenc_alloc_ctx(&cs->ctx, algo);
if (res != TEE_SUCCESS)
break;
}
break;
case TEE_OPERATION_MAC:
if (key1 == 0 || key2 != 0) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
res = crypto_mac_alloc_ctx(&cs->ctx, algo);
if (res != TEE_SUCCESS)
break;
}
break;
case TEE_OPERATION_DIGEST:
if (key1 != 0 || key2 != 0) {
res = TEE_ERROR_BAD_PARAMETERS;
} else {
res = crypto_hash_alloc_ctx(&cs->ctx, algo);
if (res != TEE_SUCCESS)
break;
}
break;
case TEE_OPERATION_ASYMMETRIC_CIPHER:
case TEE_OPERATION_ASYMMETRIC_SIGNATURE:
rsassa_na1: __maybe_unused
if (key1 == 0 || key2 != 0)
res = TEE_ERROR_BAD_PARAMETERS;
break;
case TEE_OPERATION_KEY_DERIVATION:
if (key1 == 0 || key2 != 0)
res = TEE_ERROR_BAD_PARAMETERS;
break;
default:
res = TEE_ERROR_NOT_SUPPORTED;
break;
}
if (res != TEE_SUCCESS)
goto out;
res = tee_svc_copy_kaddr_to_uref(state, cs);
if (res != TEE_SUCCESS)
goto out;
if (o1 != NULL) {
o1->busy = true;
cs->key1 = (vaddr_t)o1;
}
if (o2 != NULL) {
o2->busy = true;
cs->key2 = (vaddr_t)o2;
}
out:
if (res != TEE_SUCCESS)
cryp_state_free(utc, cs);
return res;
}","TEE_Result syscall_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,
unsigned long VAR_2, unsigned long VAR_3,
uint32_t *VAR_4)
{
TEE_Result VAR_5;
struct tee_cryp_state *VAR_6;
struct tee_ta_session *VAR_7;
struct tee_obj *VAR_8 = NULL;
struct tee_obj *VAR_9 = NULL;
struct user_ta_ctx *VAR_10;
VAR_5 = tee_ta_get_current_session(&VAR_7);
if (VAR_5 != VAR_11)
return VAR_5;
VAR_10 = to_user_ta_ctx(VAR_7->ctx);
if (VAR_2 != 0) {
VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);
if (VAR_5 != VAR_11)
return VAR_5;
if (VAR_8->busy)
return VAR_12;
VAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);
if (VAR_5 != VAR_11)
return VAR_5;
}
if (VAR_3 != 0) {
VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);
if (VAR_5 != VAR_11)
return VAR_5;
if (VAR_9->busy)
return VAR_12;
VAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);
if (VAR_5 != VAR_11)
return VAR_5;
}
VAR_6 = calloc(1, sizeof(struct tee_cryp_state));
if (!VAR_6)
return VAR_13;
TAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_14);
VAR_6->algo = VAR_0;
VAR_6->mode = VAR_1;
switch (TEE_ALG_GET_CLASS(VAR_0)) {
case VAR_15:
#ifdef VAR_16
if (VAR_0 == VAR_17)
goto rsassa_na1;
#endif
VAR_5 = VAR_18;
break;
case VAR_19:
if ((VAR_0 == VAR_20 && (VAR_2 == 0 || VAR_3 == 0)) ||
(VAR_0 != VAR_20 && (VAR_2 == 0 || VAR_3 != 0))) {
VAR_5 = VAR_12;
} else {
VAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);
if (VAR_5 != VAR_11)
break;
}
break;
case VAR_21:
if (VAR_2 == 0 || VAR_3 != 0) {
VAR_5 = VAR_12;
} else {
VAR_5 = crypto_authenc_alloc_ctx(&VAR_6->ctx, VAR_0);
if (VAR_5 != VAR_11)
break;
}
break;
case VAR_22:
if (VAR_2 == 0 || VAR_3 != 0) {
VAR_5 = VAR_12;
} else {
VAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);
if (VAR_5 != VAR_11)
break;
}
break;
case VAR_23:
if (VAR_2 != 0 || VAR_3 != 0) {
VAR_5 = VAR_12;
} else {
VAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);
if (VAR_5 != VAR_11)
break;
}
break;
case VAR_24:
case VAR_25:
rsassa_na1: VAR_26
if (VAR_2 == 0 || VAR_3 != 0)
VAR_5 = VAR_12;
break;
case VAR_27:
if (VAR_2 == 0 || VAR_3 != 0)
VAR_5 = VAR_12;
break;
default:
VAR_5 = VAR_18;
break;
}
if (VAR_5 != VAR_11)
goto out;
VAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);
if (VAR_5 != VAR_11)
goto out;
if (VAR_8 != NULL) {
VAR_8->busy = true;
VAR_6->key1 = (vaddr_t)VAR_8;
}
if (VAR_9 != NULL) {
VAR_9->busy = true;
VAR_6->key2 = (vaddr_t)VAR_9;
}
out:
if (VAR_5 != VAR_11)
cryp_state_free(VAR_10, VAR_6);
return VAR_5;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/11.json,"TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,
			unsigned long key1, unsigned long key2,
			uint32_t *state)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	struct tee_obj *o1 = NULL;
	struct tee_obj *o2 = NULL;
	struct user_ta_ctx *utc;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	utc = to_user_ta_ctx(sess->ctx);

	if (key1 != 0) {
		res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);
		if (res != TEE_SUCCESS)
			return res;
		if (o1->busy)
			return TEE_ERROR_BAD_PARAMETERS;
		res = tee_svc_cryp_check_key_type(o1, algo, mode);
		if (res != TEE_SUCCESS)
			return res;
	}
	if (key2 != 0) {
		res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);
		if (res != TEE_SUCCESS)
			return res;
		if (o2->busy)
			return TEE_ERROR_BAD_PARAMETERS;
		res = tee_svc_cryp_check_key_type(o2, algo, mode);
		if (res != TEE_SUCCESS)
			return res;
	}

	cs = calloc(1, sizeof(struct tee_cryp_state));
	if (!cs)
		return TEE_ERROR_OUT_OF_MEMORY;
	TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);
	cs->algo = algo;
	cs->mode = mode;
	cs->state = CRYP_STATE_UNINITIALIZED;

	switch (TEE_ALG_GET_CLASS(algo)) {
	case TEE_OPERATION_EXTENSION:
#ifdef CFG_CRYPTO_RSASSA_NA1
		if (algo == TEE_ALG_RSASSA_PKCS1_V1_5)
			goto rsassa_na1;
#endif
		res = TEE_ERROR_NOT_SUPPORTED;
		break;
	case TEE_OPERATION_CIPHER:
		if ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||
		    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
			res = crypto_cipher_alloc_ctx(&cs->ctx, algo);
			if (res != TEE_SUCCESS)
				break;
		}
		break;
	case TEE_OPERATION_AE:
		if (key1 == 0 || key2 != 0) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
			res = crypto_authenc_alloc_ctx(&cs->ctx, algo);
			if (res != TEE_SUCCESS)
				break;
		}
		break;
	case TEE_OPERATION_MAC:
		if (key1 == 0 || key2 != 0) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
			res = crypto_mac_alloc_ctx(&cs->ctx, algo);
			if (res != TEE_SUCCESS)
				break;
		}
		break;
	case TEE_OPERATION_DIGEST:
		if (key1 != 0 || key2 != 0) {
			res = TEE_ERROR_BAD_PARAMETERS;
		} else {
			res = crypto_hash_alloc_ctx(&cs->ctx, algo);
			if (res != TEE_SUCCESS)
				break;
		}
		break;
	case TEE_OPERATION_ASYMMETRIC_CIPHER:
	case TEE_OPERATION_ASYMMETRIC_SIGNATURE:
rsassa_na1: __maybe_unused
		if (key1 == 0 || key2 != 0)
			res = TEE_ERROR_BAD_PARAMETERS;
		break;
	case TEE_OPERATION_KEY_DERIVATION:
		if (key1 == 0 || key2 != 0)
			res = TEE_ERROR_BAD_PARAMETERS;
		break;
	default:
		res = TEE_ERROR_NOT_SUPPORTED;
		break;
	}
	if (res != TEE_SUCCESS)
		goto out;

	res = tee_svc_copy_kaddr_to_uref(state, cs);
	if (res != TEE_SUCCESS)
		goto out;

	/* Register keys */
	if (o1 != NULL) {
		o1->busy = true;
		cs->key1 = (vaddr_t)o1;
	}
	if (o2 != NULL) {
		o2->busy = true;
		cs->key2 = (vaddr_t)o2;
	}

out:
	if (res != TEE_SUCCESS)
		cryp_state_free(utc, cs);
	return res;
}","TEE_Result syscall_cryp_state_alloc(unsigned long VAR_0, unsigned long VAR_1,
			unsigned long VAR_2, unsigned long VAR_3,
			uint32_t *VAR_4)
{
	TEE_Result VAR_5;
	struct tee_cryp_state *VAR_6;
	struct tee_ta_session *VAR_7;
	struct tee_obj *VAR_8 = NULL;
	struct tee_obj *VAR_9 = NULL;
	struct user_ta_ctx *VAR_10;

	VAR_5 = tee_ta_get_current_session(&VAR_7);
	if (VAR_5 != VAR_11)
		return VAR_5;
	VAR_10 = to_user_ta_ctx(VAR_7->ctx);

	if (VAR_2 != 0) {
		VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_2), &VAR_8);
		if (VAR_5 != VAR_11)
			return VAR_5;
		if (VAR_8->busy)
			return VAR_12;
		VAR_5 = tee_svc_cryp_check_key_type(VAR_8, VAR_0, VAR_1);
		if (VAR_5 != VAR_11)
			return VAR_5;
	}
	if (VAR_3 != 0) {
		VAR_5 = tee_obj_get(VAR_10, tee_svc_uref_to_vaddr(VAR_3), &VAR_9);
		if (VAR_5 != VAR_11)
			return VAR_5;
		if (VAR_9->busy)
			return VAR_12;
		VAR_5 = tee_svc_cryp_check_key_type(VAR_9, VAR_0, VAR_1);
		if (VAR_5 != VAR_11)
			return VAR_5;
	}

	VAR_6 = calloc(1, sizeof(struct tee_cryp_state));
	if (!VAR_6)
		return VAR_13;
	TAILQ_INSERT_TAIL(&VAR_10->cryp_states, VAR_6, VAR_14);
	VAR_6->algo = VAR_0;
	VAR_6->mode = VAR_1;
	VAR_6->state = VAR_15;

	switch (TEE_ALG_GET_CLASS(VAR_0)) {
	case VAR_16:
#ifdef VAR_17
		if (VAR_0 == VAR_18)
			goto rsassa_na1;
#endif
		VAR_5 = VAR_19;
		break;
	case VAR_20:
		if ((VAR_0 == VAR_21 && (VAR_2 == 0 || VAR_3 == 0)) ||
		    (VAR_0 != VAR_21 && (VAR_2 == 0 || VAR_3 != 0))) {
			VAR_5 = VAR_12;
		} else {
			VAR_5 = crypto_cipher_alloc_ctx(&VAR_6->ctx, VAR_0);
			if (VAR_5 != VAR_11)
				break;
		}
		break;
	case VAR_22:
		if (VAR_2 == 0 || VAR_3 != 0) {
			VAR_5 = VAR_12;
		} else {
			VAR_5 = crypto_authenc_alloc_ctx(&VAR_6->ctx, VAR_0);
			if (VAR_5 != VAR_11)
				break;
		}
		break;
	case VAR_23:
		if (VAR_2 == 0 || VAR_3 != 0) {
			VAR_5 = VAR_12;
		} else {
			VAR_5 = crypto_mac_alloc_ctx(&VAR_6->ctx, VAR_0);
			if (VAR_5 != VAR_11)
				break;
		}
		break;
	case VAR_24:
		if (VAR_2 != 0 || VAR_3 != 0) {
			VAR_5 = VAR_12;
		} else {
			VAR_5 = crypto_hash_alloc_ctx(&VAR_6->ctx, VAR_0);
			if (VAR_5 != VAR_11)
				break;
		}
		break;
	case VAR_25:
	case VAR_26:
rsassa_na1: VAR_27
		if (VAR_2 == 0 || VAR_3 != 0)
			VAR_5 = VAR_12;
		break;
	case VAR_28:
		if (VAR_2 == 0 || VAR_3 != 0)
			VAR_5 = VAR_12;
		break;
	default:
		VAR_5 = VAR_19;
		break;
	}
	if (VAR_5 != VAR_11)
		goto out;

	VAR_5 = tee_svc_copy_kaddr_to_uref(VAR_4, VAR_6);
	if (VAR_5 != VAR_11)
		goto out;

	/* COMMENT_0 */
	if (VAR_8 != NULL) {
		VAR_8->busy = true;
		VAR_6->key1 = (vaddr_t)VAR_8;
	}
	if (VAR_9 != NULL) {
		VAR_9->busy = true;
		VAR_6->key2 = (vaddr_t)VAR_9;
	}

out:
	if (VAR_5 != VAR_11)
		cryp_state_free(VAR_10, VAR_6);
	return VAR_5;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/11.json,"--- func_before
+++ func_after
@@ -41,6 +41,7 @@
 	TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);
 	cs->algo = algo;
 	cs->mode = mode;
+	cs->state = CRYP_STATE_UNINITIALIZED;
 
 	switch (TEE_ALG_GET_CLASS(algo)) {
 	case TEE_OPERATION_EXTENSION:","{'deleted_lines': [], 'added_lines': ['\tcs->state = CRYP_STATE_UNINITIALIZED;']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_authenc_enc_final,"TEE_Result syscall_authenc_enc_final(unsigned long state,
const void *src_data, size_t src_len, void *dst_data,
uint64_t *dst_len, void *tag, uint64_t *tag_len)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
size_t dlen = 0;
size_t tlen = 0;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
if (cs->mode != TEE_MODE_ENCRYPT)
return TEE_ERROR_BAD_PARAMETERS;
if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
return TEE_ERROR_BAD_STATE;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)src_data, src_len);
if (res != TEE_SUCCESS)
return res;
if (!dst_len) {
dlen = 0;
} else {
res = get_user_u64_as_size_t(&dlen, dst_len);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_WRITE |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)dst_data, dlen);
if (res != TEE_SUCCESS)
return res;
}
if (dlen < src_len) {
res = TEE_ERROR_SHORT_BUFFER;
goto out;
}
res = get_user_u64_as_size_t(&tlen, tag_len);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_WRITE |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)tag, tlen);
if (res != TEE_SUCCESS)
return res;
res = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,
src_len, dst_data, &dlen, tag, &tlen);
out:
if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
TEE_Result res2;
if (dst_len != NULL) {
res2 = put_user_u64(dst_len, dlen);
if (res2 != TEE_SUCCESS)
return res2;
}
res2 = put_user_u64(tag_len, tlen);
if (res2 != TEE_SUCCESS)
return res2;
}
return res;
}","TEE_Result syscall_authenc_enc_final(unsigned long VAR_0,
const void *VAR_1, size_t VAR_2, void *VAR_3,
uint64_t *VAR_4, void *VAR_5, uint64_t *VAR_6)
{
TEE_Result VAR_7;
struct tee_cryp_state *VAR_8;
struct tee_ta_session *VAR_9;
size_t VAR_10 = 0;
size_t VAR_11 = 0;
VAR_7 = tee_ta_get_current_session(&VAR_9);
if (VAR_7 != VAR_12)
return VAR_7;
VAR_7 = tee_svc_cryp_get_state(VAR_9, tee_svc_uref_to_vaddr(VAR_0), &VAR_8);
if (VAR_7 != VAR_12)
return VAR_7;
if (VAR_8->mode != VAR_13)
return VAR_14;
if (TEE_ALG_GET_CLASS(VAR_8->algo) != VAR_15)
return VAR_16;
VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
VAR_17 |
VAR_18,
(uaddr_t)VAR_1, VAR_2);
if (VAR_7 != VAR_12)
return VAR_7;
if (!VAR_4) {
VAR_10 = 0;
} else {
VAR_7 = get_user_u64_as_size_t(&VAR_10, VAR_4);
if (VAR_7 != VAR_12)
return VAR_7;
VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
VAR_17 |
VAR_19 |
VAR_18,
(uaddr_t)VAR_3, VAR_10);
if (VAR_7 != VAR_12)
return VAR_7;
}
if (VAR_10 < VAR_2) {
VAR_7 = VAR_20;
goto out;
}
VAR_7 = get_user_u64_as_size_t(&VAR_11, VAR_6);
if (VAR_7 != VAR_12)
return VAR_7;
VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
VAR_17 |
VAR_19 |
VAR_18,
(uaddr_t)VAR_5, VAR_11);
if (VAR_7 != VAR_12)
return VAR_7;
VAR_7 = crypto_authenc_enc_final(VAR_8->ctx, VAR_8->algo, VAR_1,
VAR_2, VAR_3, &VAR_10, VAR_5, &VAR_11);
out:
if (VAR_7 == VAR_12 || VAR_7 == VAR_20) {
TEE_Result VAR_21;
if (VAR_4 != NULL) {
VAR_21 = put_user_u64(VAR_4, VAR_10);
if (VAR_21 != VAR_12)
return VAR_21;
}
VAR_21 = put_user_u64(VAR_6, VAR_11);
if (VAR_21 != VAR_12)
return VAR_21;
}
return VAR_7;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/10.json,"TEE_Result syscall_authenc_enc_final(unsigned long state,
			const void *src_data, size_t src_len, void *dst_data,
			uint64_t *dst_len, void *tag, uint64_t *tag_len)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	size_t dlen = 0;
	size_t tlen = 0;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
		return TEE_ERROR_BAD_STATE;

	if (cs->mode != TEE_MODE_ENCRYPT)
		return TEE_ERROR_BAD_PARAMETERS;

	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
		return TEE_ERROR_BAD_STATE;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)src_data, src_len);
	if (res != TEE_SUCCESS)
		return res;

	if (!dst_len) {
		dlen = 0;
	} else {
		res = get_user_u64_as_size_t(&dlen, dst_len);
		if (res != TEE_SUCCESS)
			return res;

		res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
						  TEE_MEMORY_ACCESS_READ |
						  TEE_MEMORY_ACCESS_WRITE |
						  TEE_MEMORY_ACCESS_ANY_OWNER,
						  (uaddr_t)dst_data, dlen);
		if (res != TEE_SUCCESS)
			return res;
	}

	if (dlen < src_len) {
		res = TEE_ERROR_SHORT_BUFFER;
		goto out;
	}

	res = get_user_u64_as_size_t(&tlen, tag_len);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_WRITE |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)tag, tlen);
	if (res != TEE_SUCCESS)
		return res;

	res = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,
				       src_len, dst_data, &dlen, tag, &tlen);

out:
	if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
		TEE_Result res2;

		if (dst_len != NULL) {
			res2 = put_user_u64(dst_len, dlen);
			if (res2 != TEE_SUCCESS)
				return res2;
		}

		res2 = put_user_u64(tag_len, tlen);
		if (res2 != TEE_SUCCESS)
			return res2;
	}

	return res;
}","TEE_Result syscall_authenc_enc_final(unsigned long VAR_0,
			const void *VAR_1, size_t VAR_2, void *VAR_3,
			uint64_t *VAR_4, void *VAR_5, uint64_t *VAR_6)
{
	TEE_Result VAR_7;
	struct tee_cryp_state *VAR_8;
	struct tee_ta_session *VAR_9;
	size_t VAR_10 = 0;
	size_t VAR_11 = 0;

	VAR_7 = tee_ta_get_current_session(&VAR_9);
	if (VAR_7 != VAR_12)
		return VAR_7;

	VAR_7 = tee_svc_cryp_get_state(VAR_9, tee_svc_uref_to_vaddr(VAR_0), &VAR_8);
	if (VAR_7 != VAR_12)
		return VAR_7;

	if (VAR_8->state != VAR_13)
		return VAR_14;

	if (VAR_8->mode != VAR_15)
		return VAR_16;

	if (TEE_ALG_GET_CLASS(VAR_8->algo) != VAR_17)
		return VAR_14;

	VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
					  VAR_18 |
					  VAR_19,
					  (uaddr_t)VAR_1, VAR_2);
	if (VAR_7 != VAR_12)
		return VAR_7;

	if (!VAR_4) {
		VAR_10 = 0;
	} else {
		VAR_7 = get_user_u64_as_size_t(&VAR_10, VAR_4);
		if (VAR_7 != VAR_12)
			return VAR_7;

		VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
						  VAR_18 |
						  VAR_20 |
						  VAR_19,
						  (uaddr_t)VAR_3, VAR_10);
		if (VAR_7 != VAR_12)
			return VAR_7;
	}

	if (VAR_10 < VAR_2) {
		VAR_7 = VAR_21;
		goto out;
	}

	VAR_7 = get_user_u64_as_size_t(&VAR_11, VAR_6);
	if (VAR_7 != VAR_12)
		return VAR_7;

	VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
					  VAR_18 |
					  VAR_20 |
					  VAR_19,
					  (uaddr_t)VAR_5, VAR_11);
	if (VAR_7 != VAR_12)
		return VAR_7;

	VAR_7 = crypto_authenc_enc_final(VAR_8->ctx, VAR_8->algo, VAR_1,
				       VAR_2, VAR_3, &VAR_10, VAR_5, &VAR_11);

out:
	if (VAR_7 == VAR_12 || VAR_7 == VAR_21) {
		TEE_Result VAR_22;

		if (VAR_4 != NULL) {
			VAR_22 = put_user_u64(VAR_4, VAR_10);
			if (VAR_22 != VAR_12)
				return VAR_22;
		}

		VAR_22 = put_user_u64(VAR_6, VAR_11);
		if (VAR_22 != VAR_12)
			return VAR_22;
	}

	return VAR_7;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/10.json,"--- func_before
+++ func_after
@@ -15,6 +15,9 @@
 	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
 	if (res != TEE_SUCCESS)
 		return res;
+
+	if (cs->state != CRYP_STATE_INITIALIZED)
+		return TEE_ERROR_BAD_STATE;
 
 	if (cs->mode != TEE_MODE_ENCRYPT)
 		return TEE_ERROR_BAD_PARAMETERS;","{'deleted_lines': [], 'added_lines': ['', '\tif (cs->state != CRYP_STATE_INITIALIZED)', '\t\treturn TEE_ERROR_BAD_STATE;']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_hash_init,"TEE_Result syscall_hash_init(unsigned long state,
const void *iv __maybe_unused,
size_t iv_len __maybe_unused)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
switch (TEE_ALG_GET_CLASS(cs->algo)) {
case TEE_OPERATION_DIGEST:
res = crypto_hash_init(cs->ctx, cs->algo);
if (res != TEE_SUCCESS)
return res;
break;
case TEE_OPERATION_MAC:
{
struct tee_obj *o;
struct tee_cryp_obj_secret *key;
res = tee_obj_get(to_user_ta_ctx(sess->ctx),
cs->key1, &o);
if (res != TEE_SUCCESS)
return res;
if ((o->info.handleFlags &
TEE_HANDLE_FLAG_INITIALIZED) == 0)
return TEE_ERROR_BAD_PARAMETERS;
key = (struct tee_cryp_obj_secret *)o->attr;
res = crypto_mac_init(cs->ctx, cs->algo,
(void *)(key + 1), key->key_size);
if (res != TEE_SUCCESS)
return res;
break;
}
default:
return TEE_ERROR_BAD_PARAMETERS;
}
return TEE_SUCCESS;
}","TEE_Result syscall_hash_init(unsigned long VAR_0,
const void *VAR_1 VAR_2,
size_t VAR_3 VAR_2)
{
TEE_Result VAR_4;
struct tee_cryp_state *VAR_5;
struct tee_ta_session *VAR_6;
VAR_4 = tee_ta_get_current_session(&VAR_6);
if (VAR_4 != VAR_7)
return VAR_4;
VAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_5);
if (VAR_4 != VAR_7)
return VAR_4;
switch (TEE_ALG_GET_CLASS(VAR_5->algo)) {
case VAR_8:
VAR_4 = crypto_hash_init(VAR_5->ctx, VAR_5->algo);
if (VAR_4 != VAR_7)
return VAR_4;
break;
case VAR_9:
{
struct tee_obj *VAR_10;
struct tee_cryp_obj_secret *VAR_11;
VAR_4 = tee_obj_get(to_user_ta_ctx(VAR_6->ctx),
VAR_5->key1, &VAR_10);
if (VAR_4 != VAR_7)
return VAR_4;
if ((VAR_10->info.handleFlags &
VAR_12) == 0)
return VAR_13;
VAR_11 = (struct tee_cryp_obj_secret *)VAR_10->attr;
VAR_4 = crypto_mac_init(VAR_5->ctx, VAR_5->algo,
(void *)(VAR_11 + 1), VAR_11->key_size);
if (VAR_4 != VAR_7)
return VAR_4;
break;
}
default:
return VAR_13;
}
return VAR_7;
}",,"TEE_Result syscall_hash_init(unsigned long state,
			     const void *iv __maybe_unused,
			     size_t iv_len __maybe_unused)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	switch (TEE_ALG_GET_CLASS(cs->algo)) {
	case TEE_OPERATION_DIGEST:
		res = crypto_hash_init(cs->ctx, cs->algo);
		if (res != TEE_SUCCESS)
			return res;
		break;
	case TEE_OPERATION_MAC:
		{
			struct tee_obj *o;
			struct tee_cryp_obj_secret *key;

			res = tee_obj_get(to_user_ta_ctx(sess->ctx),
					  cs->key1, &o);
			if (res != TEE_SUCCESS)
				return res;
			if ((o->info.handleFlags &
			     TEE_HANDLE_FLAG_INITIALIZED) == 0)
				return TEE_ERROR_BAD_PARAMETERS;

			key = (struct tee_cryp_obj_secret *)o->attr;
			res = crypto_mac_init(cs->ctx, cs->algo,
					      (void *)(key + 1), key->key_size);
			if (res != TEE_SUCCESS)
				return res;
			break;
		}
	default:
		return TEE_ERROR_BAD_PARAMETERS;
	}

	cs->state = CRYP_STATE_INITIALIZED;

	return TEE_SUCCESS;
}","TEE_Result syscall_hash_init(unsigned long VAR_0,
			     const void *VAR_1 VAR_2,
			     size_t VAR_3 VAR_2)
{
	TEE_Result VAR_4;
	struct tee_cryp_state *VAR_5;
	struct tee_ta_session *VAR_6;

	VAR_4 = tee_ta_get_current_session(&VAR_6);
	if (VAR_4 != VAR_7)
		return VAR_4;

	VAR_4 = tee_svc_cryp_get_state(VAR_6, tee_svc_uref_to_vaddr(VAR_0), &VAR_5);
	if (VAR_4 != VAR_7)
		return VAR_4;

	switch (TEE_ALG_GET_CLASS(VAR_5->algo)) {
	case VAR_8:
		VAR_4 = crypto_hash_init(VAR_5->ctx, VAR_5->algo);
		if (VAR_4 != VAR_7)
			return VAR_4;
		break;
	case VAR_9:
		{
			struct tee_obj *VAR_10;
			struct tee_cryp_obj_secret *VAR_11;

			VAR_4 = tee_obj_get(to_user_ta_ctx(VAR_6->ctx),
					  VAR_5->key1, &VAR_10);
			if (VAR_4 != VAR_7)
				return VAR_4;
			if ((VAR_10->info.handleFlags &
			     VAR_12) == 0)
				return VAR_13;

			VAR_11 = (struct tee_cryp_obj_secret *)VAR_10->attr;
			VAR_4 = crypto_mac_init(VAR_5->ctx, VAR_5->algo,
					      (void *)(VAR_11 + 1), VAR_11->key_size);
			if (VAR_4 != VAR_7)
				return VAR_4;
			break;
		}
	default:
		return VAR_13;
	}

	VAR_5->state = VAR_14;

	return VAR_7;
}",,"--- func_before
+++ func_after
@@ -44,5 +44,7 @@
 		return TEE_ERROR_BAD_PARAMETERS;
 	}
 
+	cs->state = CRYP_STATE_INITIALIZED;
+
 	return TEE_SUCCESS;
 }","{'deleted_lines': [], 'added_lines': ['\tcs->state = CRYP_STATE_INITIALIZED;', '']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_authenc_init,"TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,
size_t nonce_len, size_t tag_len,
size_t aad_len, size_t payload_len)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
struct tee_obj *o;
struct tee_cryp_obj_secret *key;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)nonce, nonce_len);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
res = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);
if (res != TEE_SUCCESS)
return res;
if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
return TEE_ERROR_BAD_PARAMETERS;
key = o->attr;
res = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,
(uint8_t *)(key + 1), key->key_size,
nonce, nonce_len, tag_len, aad_len,
payload_len);
if (res != TEE_SUCCESS)
return res;
cs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;
return TEE_SUCCESS;
}","TEE_Result syscall_authenc_init(unsigned long VAR_0, const void *VAR_1,
size_t VAR_2, size_t VAR_3,
size_t VAR_4, size_t VAR_5)
{
TEE_Result VAR_6;
struct tee_cryp_state *VAR_7;
struct tee_ta_session *VAR_8;
struct tee_obj *VAR_9;
struct tee_cryp_obj_secret *VAR_10;
VAR_6 = tee_ta_get_current_session(&VAR_8);
if (VAR_6 != VAR_11)
return VAR_6;
VAR_6 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_8->ctx),
VAR_12 |
VAR_13,
(uaddr_t)VAR_1, VAR_2);
if (VAR_6 != VAR_11)
return VAR_6;
VAR_6 = tee_svc_cryp_get_state(VAR_8, tee_svc_uref_to_vaddr(VAR_0), &VAR_7);
if (VAR_6 != VAR_11)
return VAR_6;
VAR_6 = tee_obj_get(to_user_ta_ctx(VAR_8->ctx), VAR_7->key1, &VAR_9);
if (VAR_6 != VAR_11)
return VAR_6;
if ((VAR_9->info.handleFlags & VAR_14) == 0)
return VAR_15;
VAR_10 = VAR_9->attr;
VAR_6 = crypto_authenc_init(VAR_7->ctx, VAR_7->algo, VAR_7->mode,
(uint8_t *)(VAR_10 + 1), VAR_10->key_size,
VAR_1, VAR_2, VAR_3, VAR_4,
VAR_5);
if (VAR_6 != VAR_11)
return VAR_6;
VAR_7->ctx_finalize = (tee_cryp_ctx_finalize_func_t)VAR_16;
return VAR_11;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/8.json,"TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,
			size_t nonce_len, size_t tag_len,
			size_t aad_len, size_t payload_len)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	struct tee_cryp_obj_secret *key;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)nonce, nonce_len);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);
	if (res != TEE_SUCCESS)
		return res;
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
		return TEE_ERROR_BAD_PARAMETERS;

	key = o->attr;
	res = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,
				  (uint8_t *)(key + 1), key->key_size,
				  nonce, nonce_len, tag_len, aad_len,
				  payload_len);
	if (res != TEE_SUCCESS)
		return res;

	cs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;
	cs->state = CRYP_STATE_INITIALIZED;

	return TEE_SUCCESS;
}","TEE_Result syscall_authenc_init(unsigned long VAR_0, const void *VAR_1,
			size_t VAR_2, size_t VAR_3,
			size_t VAR_4, size_t VAR_5)
{
	TEE_Result VAR_6;
	struct tee_cryp_state *VAR_7;
	struct tee_ta_session *VAR_8;
	struct tee_obj *VAR_9;
	struct tee_cryp_obj_secret *VAR_10;

	VAR_6 = tee_ta_get_current_session(&VAR_8);
	if (VAR_6 != VAR_11)
		return VAR_6;

	VAR_6 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_8->ctx),
					  VAR_12 |
					  VAR_13,
					  (uaddr_t)VAR_1, VAR_2);
	if (VAR_6 != VAR_11)
		return VAR_6;

	VAR_6 = tee_svc_cryp_get_state(VAR_8, tee_svc_uref_to_vaddr(VAR_0), &VAR_7);
	if (VAR_6 != VAR_11)
		return VAR_6;

	VAR_6 = tee_obj_get(to_user_ta_ctx(VAR_8->ctx), VAR_7->key1, &VAR_9);
	if (VAR_6 != VAR_11)
		return VAR_6;
	if ((VAR_9->info.handleFlags & VAR_14) == 0)
		return VAR_15;

	VAR_10 = VAR_9->attr;
	VAR_6 = crypto_authenc_init(VAR_7->ctx, VAR_7->algo, VAR_7->mode,
				  (uint8_t *)(VAR_10 + 1), VAR_10->key_size,
				  VAR_1, VAR_2, VAR_3, VAR_4,
				  VAR_5);
	if (VAR_6 != VAR_11)
		return VAR_6;

	VAR_7->ctx_finalize = (tee_cryp_ctx_finalize_func_t)VAR_16;
	VAR_7->state = VAR_17;

	return VAR_11;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/8.json,"--- func_before
+++ func_after
@@ -38,5 +38,7 @@
 		return res;
 
 	cs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;
+	cs->state = CRYP_STATE_INITIALIZED;
+
 	return TEE_SUCCESS;
 }","{'deleted_lines': [], 'added_lines': ['\tcs->state = CRYP_STATE_INITIALIZED;', '']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,tee_svc_cipher_update_helper,"static TEE_Result tee_svc_cipher_update_helper(unsigned long state,
bool last_block, const void *src, size_t src_len,
void *dst, uint64_t *dst_len)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
size_t dlen = 0;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)src, src_len);
if (res != TEE_SUCCESS)
return res;
if (!dst_len) {
dlen = 0;
} else {
res = get_user_u64_as_size_t(&dlen, dst_len);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_WRITE |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)dst, dlen);
if (res != TEE_SUCCESS)
return res;
}
if (dlen < src_len) {
res = TEE_ERROR_SHORT_BUFFER;
goto out;
}
if (src_len > 0) {
res = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,
last_block, src, src_len, dst);
}
if (last_block && cs->ctx_finalize != NULL) {
cs->ctx_finalize(cs->ctx, cs->algo);
cs->ctx_finalize = NULL;
}
out:
if ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&
dst_len != NULL) {
TEE_Result res2;
res2 = put_user_u64(dst_len, src_len);
if (res2 != TEE_SUCCESS)
res = res2;
}
return res;
}","static TEE_Result tee_svc_cipher_update_helper(unsigned long VAR_0,
bool VAR_1, const void *VAR_2, size_t VAR_3,
void *VAR_4, uint64_t *VAR_5)
{
TEE_Result VAR_6;
struct tee_cryp_state *VAR_7;
struct tee_ta_session *VAR_8;
size_t VAR_9 = 0;
VAR_6 = tee_ta_get_current_session(&VAR_8);
if (VAR_6 != VAR_10)
return VAR_6;
VAR_6 = tee_svc_cryp_get_state(VAR_8, tee_svc_uref_to_vaddr(VAR_0), &VAR_7);
if (VAR_6 != VAR_10)
return VAR_6;
VAR_6 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_8->ctx),
VAR_11 |
VAR_12,
(uaddr_t)VAR_2, VAR_3);
if (VAR_6 != VAR_10)
return VAR_6;
if (!VAR_5) {
VAR_9 = 0;
} else {
VAR_6 = get_user_u64_as_size_t(&VAR_9, VAR_5);
if (VAR_6 != VAR_10)
return VAR_6;
VAR_6 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_8->ctx),
VAR_11 |
VAR_13 |
VAR_12,
(uaddr_t)VAR_4, VAR_9);
if (VAR_6 != VAR_10)
return VAR_6;
}
if (VAR_9 < VAR_3) {
VAR_6 = VAR_14;
goto out;
}
if (VAR_3 > 0) {
VAR_6 = tee_do_cipher_update(VAR_7->ctx, VAR_7->algo, VAR_7->mode,
VAR_1, VAR_2, VAR_3, VAR_4);
}
if (VAR_1 && VAR_7->ctx_finalize != NULL) {
VAR_7->ctx_finalize(VAR_7->ctx, VAR_7->algo);
VAR_7->ctx_finalize = NULL;
}
out:
if ((VAR_6 == VAR_10 || VAR_6 == VAR_14) &&
VAR_5 != NULL) {
TEE_Result VAR_15;
VAR_15 = put_user_u64(VAR_5, VAR_3);
if (VAR_15 != VAR_10)
VAR_6 = VAR_15;
}
return VAR_6;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/7.json,"static TEE_Result tee_svc_cipher_update_helper(unsigned long state,
			bool last_block, const void *src, size_t src_len,
			void *dst, uint64_t *dst_len)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	size_t dlen = 0;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
		return TEE_ERROR_BAD_STATE;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)src, src_len);
	if (res != TEE_SUCCESS)
		return res;

	if (!dst_len) {
		dlen = 0;
	} else {
		res = get_user_u64_as_size_t(&dlen, dst_len);
		if (res != TEE_SUCCESS)
			return res;

		res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
						  TEE_MEMORY_ACCESS_READ |
						  TEE_MEMORY_ACCESS_WRITE |
						  TEE_MEMORY_ACCESS_ANY_OWNER,
						  (uaddr_t)dst, dlen);
		if (res != TEE_SUCCESS)
			return res;
	}

	if (dlen < src_len) {
		res = TEE_ERROR_SHORT_BUFFER;
		goto out;
	}

	if (src_len > 0) {
		/* Permit src_len == 0 to finalize the operation */
		res = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,
					   last_block, src, src_len, dst);
	}

	if (last_block && cs->ctx_finalize != NULL) {
		cs->ctx_finalize(cs->ctx, cs->algo);
		cs->ctx_finalize = NULL;
	}

out:
	if ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&
	    dst_len != NULL) {
		TEE_Result res2;

		res2 = put_user_u64(dst_len, src_len);
		if (res2 != TEE_SUCCESS)
			res = res2;
	}

	return res;
}","static TEE_Result tee_svc_cipher_update_helper(unsigned long VAR_0,
			bool VAR_1, const void *VAR_2, size_t VAR_3,
			void *VAR_4, uint64_t *VAR_5)
{
	TEE_Result VAR_6;
	struct tee_cryp_state *VAR_7;
	struct tee_ta_session *VAR_8;
	size_t VAR_9 = 0;

	VAR_6 = tee_ta_get_current_session(&VAR_8);
	if (VAR_6 != VAR_10)
		return VAR_6;

	VAR_6 = tee_svc_cryp_get_state(VAR_8, tee_svc_uref_to_vaddr(VAR_0), &VAR_7);
	if (VAR_6 != VAR_10)
		return VAR_6;

	if (VAR_7->state != VAR_11)
		return VAR_12;

	VAR_6 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_8->ctx),
					  VAR_13 |
					  VAR_14,
					  (uaddr_t)VAR_2, VAR_3);
	if (VAR_6 != VAR_10)
		return VAR_6;

	if (!VAR_5) {
		VAR_9 = 0;
	} else {
		VAR_6 = get_user_u64_as_size_t(&VAR_9, VAR_5);
		if (VAR_6 != VAR_10)
			return VAR_6;

		VAR_6 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_8->ctx),
						  VAR_13 |
						  VAR_15 |
						  VAR_14,
						  (uaddr_t)VAR_4, VAR_9);
		if (VAR_6 != VAR_10)
			return VAR_6;
	}

	if (VAR_9 < VAR_3) {
		VAR_6 = VAR_16;
		goto out;
	}

	if (VAR_3 > 0) {
		/* COMMENT_0 */
		VAR_6 = tee_do_cipher_update(VAR_7->ctx, VAR_7->algo, VAR_7->mode,
					   VAR_1, VAR_2, VAR_3, VAR_4);
	}

	if (VAR_1 && VAR_7->ctx_finalize != NULL) {
		VAR_7->ctx_finalize(VAR_7->ctx, VAR_7->algo);
		VAR_7->ctx_finalize = NULL;
	}

out:
	if ((VAR_6 == VAR_10 || VAR_6 == VAR_16) &&
	    VAR_5 != NULL) {
		TEE_Result VAR_17;

		VAR_17 = put_user_u64(VAR_5, VAR_3);
		if (VAR_17 != VAR_10)
			VAR_6 = VAR_17;
	}

	return VAR_6;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -14,6 +14,9 @@
 	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
 	if (res != TEE_SUCCESS)
 		return res;
+
+	if (cs->state != CRYP_STATE_INITIALIZED)
+		return TEE_ERROR_BAD_STATE;
 
 	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
 					  TEE_MEMORY_ACCESS_READ |","{'deleted_lines': [], 'added_lines': ['', '\tif (cs->state != CRYP_STATE_INITIALIZED)', '\t\treturn TEE_ERROR_BAD_STATE;']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_hash_final,"TEE_Result syscall_hash_final(unsigned long state, const void *chunk,
size_t chunk_size, void *hash, uint64_t *hash_len)
{
TEE_Result res, res2;
size_t hash_size;
size_t hlen = 0;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
if (!chunk && chunk_size)
return TEE_ERROR_BAD_PARAMETERS;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)chunk, chunk_size);
if (res != TEE_SUCCESS)
return res;
res = get_user_u64_as_size_t(&hlen, hash_len);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_WRITE |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)hash, hlen);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
switch (TEE_ALG_GET_CLASS(cs->algo)) {
case TEE_OPERATION_DIGEST:
res = tee_hash_get_digest_size(cs->algo, &hash_size);
if (res != TEE_SUCCESS)
return res;
if (hlen < hash_size) {
res = TEE_ERROR_SHORT_BUFFER;
goto out;
}
if (chunk_size) {
res = crypto_hash_update(cs->ctx, cs->algo, chunk,
chunk_size);
if (res != TEE_SUCCESS)
return res;
}
res = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);
if (res != TEE_SUCCESS)
return res;
break;
case TEE_OPERATION_MAC:
res = tee_mac_get_digest_size(cs->algo, &hash_size);
if (res != TEE_SUCCESS)
return res;
if (hlen < hash_size) {
res = TEE_ERROR_SHORT_BUFFER;
goto out;
}
if (chunk_size) {
res = crypto_mac_update(cs->ctx, cs->algo, chunk,
chunk_size);
if (res != TEE_SUCCESS)
return res;
}
res = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);
if (res != TEE_SUCCESS)
return res;
break;
default:
return TEE_ERROR_BAD_PARAMETERS;
}
out:
res2 = put_user_u64(hash_len, hash_size);
if (res2 != TEE_SUCCESS)
return res2;
return res;
}","TEE_Result syscall_hash_final(unsigned long VAR_0, const void *VAR_1,
size_t VAR_2, void *VAR_3, uint64_t *VAR_4)
{
TEE_Result VAR_5, VAR_6;
size_t VAR_7;
size_t VAR_8 = 0;
struct tee_cryp_state *VAR_9;
struct tee_ta_session *VAR_10;
if (!VAR_1 && VAR_2)
return VAR_11;
VAR_5 = tee_ta_get_current_session(&VAR_10);
if (VAR_5 != VAR_12)
return VAR_5;
VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),
VAR_13 |
VAR_14,
(uaddr_t)VAR_1, VAR_2);
if (VAR_5 != VAR_12)
return VAR_5;
VAR_5 = get_user_u64_as_size_t(&VAR_8, VAR_4);
if (VAR_5 != VAR_12)
return VAR_5;
VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),
VAR_13 |
VAR_15 |
VAR_14,
(uaddr_t)VAR_3, VAR_8);
if (VAR_5 != VAR_12)
return VAR_5;
VAR_5 = tee_svc_cryp_get_state(VAR_10, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);
if (VAR_5 != VAR_12)
return VAR_5;
switch (TEE_ALG_GET_CLASS(VAR_9->algo)) {
case VAR_16:
VAR_5 = tee_hash_get_digest_size(VAR_9->algo, &VAR_7);
if (VAR_5 != VAR_12)
return VAR_5;
if (VAR_8 < VAR_7) {
VAR_5 = VAR_17;
goto out;
}
if (VAR_2) {
VAR_5 = crypto_hash_update(VAR_9->ctx, VAR_9->algo, VAR_1,
VAR_2);
if (VAR_5 != VAR_12)
return VAR_5;
}
VAR_5 = crypto_hash_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);
if (VAR_5 != VAR_12)
return VAR_5;
break;
case VAR_18:
VAR_5 = tee_mac_get_digest_size(VAR_9->algo, &VAR_7);
if (VAR_5 != VAR_12)
return VAR_5;
if (VAR_8 < VAR_7) {
VAR_5 = VAR_17;
goto out;
}
if (VAR_2) {
VAR_5 = crypto_mac_update(VAR_9->ctx, VAR_9->algo, VAR_1,
VAR_2);
if (VAR_5 != VAR_12)
return VAR_5;
}
VAR_5 = crypto_mac_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);
if (VAR_5 != VAR_12)
return VAR_5;
break;
default:
return VAR_11;
}
out:
VAR_6 = put_user_u64(VAR_4, VAR_7);
if (VAR_6 != VAR_12)
return VAR_6;
return VAR_5;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/6.json,"TEE_Result syscall_hash_final(unsigned long state, const void *chunk,
			size_t chunk_size, void *hash, uint64_t *hash_len)
{
	TEE_Result res, res2;
	size_t hash_size;
	size_t hlen = 0;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;

	/* No data, but size provided isn't valid parameters. */
	if (!chunk && chunk_size)
		return TEE_ERROR_BAD_PARAMETERS;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)chunk, chunk_size);
	if (res != TEE_SUCCESS)
		return res;

	res = get_user_u64_as_size_t(&hlen, hash_len);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_WRITE |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)hash, hlen);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
		return TEE_ERROR_BAD_STATE;

	switch (TEE_ALG_GET_CLASS(cs->algo)) {
	case TEE_OPERATION_DIGEST:
		res = tee_hash_get_digest_size(cs->algo, &hash_size);
		if (res != TEE_SUCCESS)
			return res;
		if (hlen < hash_size) {
			res = TEE_ERROR_SHORT_BUFFER;
			goto out;
		}

		if (chunk_size) {
			res = crypto_hash_update(cs->ctx, cs->algo, chunk,
						 chunk_size);
			if (res != TEE_SUCCESS)
				return res;
		}

		res = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);
		if (res != TEE_SUCCESS)
			return res;
		break;

	case TEE_OPERATION_MAC:
		res = tee_mac_get_digest_size(cs->algo, &hash_size);
		if (res != TEE_SUCCESS)
			return res;
		if (hlen < hash_size) {
			res = TEE_ERROR_SHORT_BUFFER;
			goto out;
		}

		if (chunk_size) {
			res = crypto_mac_update(cs->ctx, cs->algo, chunk,
						chunk_size);
			if (res != TEE_SUCCESS)
				return res;
		}

		res = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);
		if (res != TEE_SUCCESS)
			return res;
		break;

	default:
		return TEE_ERROR_BAD_PARAMETERS;
	}
out:
	res2 = put_user_u64(hash_len, hash_size);
	if (res2 != TEE_SUCCESS)
		return res2;
	return res;
}","TEE_Result syscall_hash_final(unsigned long VAR_0, const void *VAR_1,
			size_t VAR_2, void *VAR_3, uint64_t *VAR_4)
{
	TEE_Result VAR_5, VAR_6;
	size_t VAR_7;
	size_t VAR_8 = 0;
	struct tee_cryp_state *VAR_9;
	struct tee_ta_session *VAR_10;

	/* COMMENT_0 */
	if (!VAR_1 && VAR_2)
		return VAR_11;

	VAR_5 = tee_ta_get_current_session(&VAR_10);
	if (VAR_5 != VAR_12)
		return VAR_5;

	VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),
					  VAR_13 |
					  VAR_14,
					  (uaddr_t)VAR_1, VAR_2);
	if (VAR_5 != VAR_12)
		return VAR_5;

	VAR_5 = get_user_u64_as_size_t(&VAR_8, VAR_4);
	if (VAR_5 != VAR_12)
		return VAR_5;

	VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_10->ctx),
					  VAR_13 |
					  VAR_15 |
					  VAR_14,
					  (uaddr_t)VAR_3, VAR_8);
	if (VAR_5 != VAR_12)
		return VAR_5;

	VAR_5 = tee_svc_cryp_get_state(VAR_10, tee_svc_uref_to_vaddr(VAR_0), &VAR_9);
	if (VAR_5 != VAR_12)
		return VAR_5;

	if (VAR_9->state != VAR_16)
		return VAR_17;

	switch (TEE_ALG_GET_CLASS(VAR_9->algo)) {
	case VAR_18:
		VAR_5 = tee_hash_get_digest_size(VAR_9->algo, &VAR_7);
		if (VAR_5 != VAR_12)
			return VAR_5;
		if (VAR_8 < VAR_7) {
			VAR_5 = VAR_19;
			goto out;
		}

		if (VAR_2) {
			VAR_5 = crypto_hash_update(VAR_9->ctx, VAR_9->algo, VAR_1,
						 VAR_2);
			if (VAR_5 != VAR_12)
				return VAR_5;
		}

		VAR_5 = crypto_hash_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);
		if (VAR_5 != VAR_12)
			return VAR_5;
		break;

	case VAR_20:
		VAR_5 = tee_mac_get_digest_size(VAR_9->algo, &VAR_7);
		if (VAR_5 != VAR_12)
			return VAR_5;
		if (VAR_8 < VAR_7) {
			VAR_5 = VAR_19;
			goto out;
		}

		if (VAR_2) {
			VAR_5 = crypto_mac_update(VAR_9->ctx, VAR_9->algo, VAR_1,
						VAR_2);
			if (VAR_5 != VAR_12)
				return VAR_5;
		}

		VAR_5 = crypto_mac_final(VAR_9->ctx, VAR_9->algo, VAR_3, VAR_7);
		if (VAR_5 != VAR_12)
			return VAR_5;
		break;

	default:
		return VAR_11;
	}
out:
	VAR_6 = put_user_u64(VAR_4, VAR_7);
	if (VAR_6 != VAR_12)
		return VAR_6;
	return VAR_5;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -37,6 +37,9 @@
 	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
 	if (res != TEE_SUCCESS)
 		return res;
+
+	if (cs->state != CRYP_STATE_INITIALIZED)
+		return TEE_ERROR_BAD_STATE;
 
 	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 	case TEE_OPERATION_DIGEST:","{'deleted_lines': [], 'added_lines': ['', '\tif (cs->state != CRYP_STATE_INITIALIZED)', '\t\treturn TEE_ERROR_BAD_STATE;']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_cipher_init,"TEE_Result syscall_cipher_init(unsigned long state, const void *iv,
size_t iv_len)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
struct tee_obj *o;
struct tee_cryp_obj_secret *key1;
struct user_ta_ctx *utc;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
utc = to_user_ta_ctx(sess->ctx);
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)
return TEE_ERROR_BAD_STATE;
res = tee_mmu_check_access_rights(utc,
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t) iv, iv_len);
if (res != TEE_SUCCESS)
return res;
res = tee_obj_get(utc, cs->key1, &o);
if (res != TEE_SUCCESS)
return res;
if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
return TEE_ERROR_BAD_PARAMETERS;
key1 = o->attr;
if (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {
struct tee_cryp_obj_secret *key2 = o->attr;
if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
return TEE_ERROR_BAD_PARAMETERS;
res = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,
(uint8_t *)(key1 + 1), key1->key_size,
(uint8_t *)(key2 + 1), key2->key_size,
iv, iv_len);
} else {
res = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,
(uint8_t *)(key1 + 1), key1->key_size,
NULL, 0, iv, iv_len);
}
if (res != TEE_SUCCESS)
return res;
cs->ctx_finalize = crypto_cipher_final;
return TEE_SUCCESS;
}","TEE_Result syscall_cipher_init(unsigned long VAR_0, const void *VAR_1,
size_t VAR_2)
{
TEE_Result VAR_3;
struct tee_cryp_state *VAR_4;
struct tee_ta_session *VAR_5;
struct tee_obj *VAR_6;
struct tee_cryp_obj_secret *VAR_7;
struct user_ta_ctx *VAR_8;
VAR_3 = tee_ta_get_current_session(&VAR_5);
if (VAR_3 != VAR_9)
return VAR_3;
VAR_8 = to_user_ta_ctx(VAR_5->ctx);
VAR_3 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_4);
if (VAR_3 != VAR_9)
return VAR_3;
if (TEE_ALG_GET_CLASS(VAR_4->algo) != VAR_10)
return VAR_11;
VAR_3 = tee_mmu_check_access_rights(VAR_8,
VAR_12 |
VAR_13,
(uaddr_t) VAR_1, VAR_2);
if (VAR_3 != VAR_9)
return VAR_3;
VAR_3 = tee_obj_get(VAR_8, VAR_4->key1, &VAR_6);
if (VAR_3 != VAR_9)
return VAR_3;
if ((VAR_6->info.handleFlags & VAR_14) == 0)
return VAR_15;
VAR_7 = VAR_6->attr;
if (tee_obj_get(VAR_8, VAR_4->key2, &VAR_6) == VAR_9) {
struct tee_cryp_obj_secret *VAR_16 = VAR_6->attr;
if ((VAR_6->info.handleFlags & VAR_14) == 0)
return VAR_15;
VAR_3 = crypto_cipher_init(VAR_4->ctx, VAR_4->algo, VAR_4->mode,
(uint8_t *)(VAR_7 + 1), VAR_7->key_size,
(uint8_t *)(VAR_16 + 1), VAR_16->key_size,
VAR_1, VAR_2);
} else {
VAR_3 = crypto_cipher_init(VAR_4->ctx, VAR_4->algo, VAR_4->mode,
(uint8_t *)(VAR_7 + 1), VAR_7->key_size,
NULL, 0, VAR_1, VAR_2);
}
if (VAR_3 != VAR_9)
return VAR_3;
VAR_4->ctx_finalize = VAR_17;
return VAR_9;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/4.json,"TEE_Result syscall_cipher_init(unsigned long state, const void *iv,
			size_t iv_len)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	struct tee_cryp_obj_secret *key1;
	struct user_ta_ctx *utc;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	utc = to_user_ta_ctx(sess->ctx);

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)
		return TEE_ERROR_BAD_STATE;

	res = tee_mmu_check_access_rights(utc,
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t) iv, iv_len);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(utc, cs->key1, &o);
	if (res != TEE_SUCCESS)
		return res;
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
		return TEE_ERROR_BAD_PARAMETERS;

	key1 = o->attr;

	if (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {
		struct tee_cryp_obj_secret *key2 = o->attr;

		if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)
			return TEE_ERROR_BAD_PARAMETERS;

		res = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,
					 (uint8_t *)(key1 + 1), key1->key_size,
					 (uint8_t *)(key2 + 1), key2->key_size,
					 iv, iv_len);
	} else {
		res = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,
					 (uint8_t *)(key1 + 1), key1->key_size,
					 NULL, 0, iv, iv_len);
	}
	if (res != TEE_SUCCESS)
		return res;

	cs->ctx_finalize = crypto_cipher_final;
	cs->state = CRYP_STATE_INITIALIZED;

	return TEE_SUCCESS;
}","TEE_Result syscall_cipher_init(unsigned long VAR_0, const void *VAR_1,
			size_t VAR_2)
{
	TEE_Result VAR_3;
	struct tee_cryp_state *VAR_4;
	struct tee_ta_session *VAR_5;
	struct tee_obj *VAR_6;
	struct tee_cryp_obj_secret *VAR_7;
	struct user_ta_ctx *VAR_8;

	VAR_3 = tee_ta_get_current_session(&VAR_5);
	if (VAR_3 != VAR_9)
		return VAR_3;
	VAR_8 = to_user_ta_ctx(VAR_5->ctx);

	VAR_3 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_4);
	if (VAR_3 != VAR_9)
		return VAR_3;

	if (TEE_ALG_GET_CLASS(VAR_4->algo) != VAR_10)
		return VAR_11;

	VAR_3 = tee_mmu_check_access_rights(VAR_8,
					  VAR_12 |
					  VAR_13,
					  (uaddr_t) VAR_1, VAR_2);
	if (VAR_3 != VAR_9)
		return VAR_3;

	VAR_3 = tee_obj_get(VAR_8, VAR_4->key1, &VAR_6);
	if (VAR_3 != VAR_9)
		return VAR_3;
	if ((VAR_6->info.handleFlags & VAR_14) == 0)
		return VAR_15;

	VAR_7 = VAR_6->attr;

	if (tee_obj_get(VAR_8, VAR_4->key2, &VAR_6) == VAR_9) {
		struct tee_cryp_obj_secret *VAR_16 = VAR_6->attr;

		if ((VAR_6->info.handleFlags & VAR_14) == 0)
			return VAR_15;

		VAR_3 = crypto_cipher_init(VAR_4->ctx, VAR_4->algo, VAR_4->mode,
					 (uint8_t *)(VAR_7 + 1), VAR_7->key_size,
					 (uint8_t *)(VAR_16 + 1), VAR_16->key_size,
					 VAR_1, VAR_2);
	} else {
		VAR_3 = crypto_cipher_init(VAR_4->ctx, VAR_4->algo, VAR_4->mode,
					 (uint8_t *)(VAR_7 + 1), VAR_7->key_size,
					 NULL, 0, VAR_1, VAR_2);
	}
	if (VAR_3 != VAR_9)
		return VAR_3;

	VAR_4->ctx_finalize = VAR_17;
	VAR_4->state = VAR_18;

	return VAR_9;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -54,5 +54,7 @@
 		return res;
 
 	cs->ctx_finalize = crypto_cipher_final;
+	cs->state = CRYP_STATE_INITIALIZED;
+
 	return TEE_SUCCESS;
 }","{'deleted_lines': [], 'added_lines': ['\tcs->state = CRYP_STATE_INITIALIZED;', '']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_hash_update,"TEE_Result syscall_hash_update(unsigned long state, const void *chunk,
size_t chunk_size)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
if (!chunk && chunk_size)
return TEE_ERROR_BAD_PARAMETERS;
if (!chunk_size)
return TEE_SUCCESS;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)chunk, chunk_size);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
switch (TEE_ALG_GET_CLASS(cs->algo)) {
case TEE_OPERATION_DIGEST:
res = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);
if (res != TEE_SUCCESS)
return res;
break;
case TEE_OPERATION_MAC:
res = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);
if (res != TEE_SUCCESS)
return res;
break;
default:
return TEE_ERROR_BAD_PARAMETERS;
}
return TEE_SUCCESS;
}","TEE_Result syscall_hash_update(unsigned long VAR_0, const void *VAR_1,
size_t VAR_2)
{
TEE_Result VAR_3;
struct tee_cryp_state *VAR_4;
struct tee_ta_session *VAR_5;
if (!VAR_1 && VAR_2)
return VAR_6;
if (!VAR_2)
return VAR_7;
VAR_3 = tee_ta_get_current_session(&VAR_5);
if (VAR_3 != VAR_7)
return VAR_3;
VAR_3 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_5->ctx),
VAR_8 |
VAR_9,
(uaddr_t)VAR_1, VAR_2);
if (VAR_3 != VAR_7)
return VAR_3;
VAR_3 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_4);
if (VAR_3 != VAR_7)
return VAR_3;
switch (TEE_ALG_GET_CLASS(VAR_4->algo)) {
case VAR_10:
VAR_3 = crypto_hash_update(VAR_4->ctx, VAR_4->algo, VAR_1, VAR_2);
if (VAR_3 != VAR_7)
return VAR_3;
break;
case VAR_11:
VAR_3 = crypto_mac_update(VAR_4->ctx, VAR_4->algo, VAR_1, VAR_2);
if (VAR_3 != VAR_7)
return VAR_3;
break;
default:
return VAR_6;
}
return VAR_7;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/5.json,"TEE_Result syscall_hash_update(unsigned long state, const void *chunk,
			size_t chunk_size)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;

	/* No data, but size provided isn't valid parameters. */
	if (!chunk && chunk_size)
		return TEE_ERROR_BAD_PARAMETERS;

	/* Zero length hash is valid, but nothing we need to do. */
	if (!chunk_size)
		return TEE_SUCCESS;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)chunk, chunk_size);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
		return TEE_ERROR_BAD_STATE;

	switch (TEE_ALG_GET_CLASS(cs->algo)) {
	case TEE_OPERATION_DIGEST:
		res = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);
		if (res != TEE_SUCCESS)
			return res;
		break;
	case TEE_OPERATION_MAC:
		res = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);
		if (res != TEE_SUCCESS)
			return res;
		break;
	default:
		return TEE_ERROR_BAD_PARAMETERS;
	}

	return TEE_SUCCESS;
}","TEE_Result syscall_hash_update(unsigned long VAR_0, const void *VAR_1,
			size_t VAR_2)
{
	TEE_Result VAR_3;
	struct tee_cryp_state *VAR_4;
	struct tee_ta_session *VAR_5;

	/* COMMENT_0 */
	if (!VAR_1 && VAR_2)
		return VAR_6;

	/* COMMENT_1 */
	if (!VAR_2)
		return VAR_7;

	VAR_3 = tee_ta_get_current_session(&VAR_5);
	if (VAR_3 != VAR_7)
		return VAR_3;

	VAR_3 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_5->ctx),
					  VAR_8 |
					  VAR_9,
					  (uaddr_t)VAR_1, VAR_2);
	if (VAR_3 != VAR_7)
		return VAR_3;

	VAR_3 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_4);
	if (VAR_3 != VAR_7)
		return VAR_3;

	if (VAR_4->state != VAR_10)
		return VAR_11;

	switch (TEE_ALG_GET_CLASS(VAR_4->algo)) {
	case VAR_12:
		VAR_3 = crypto_hash_update(VAR_4->ctx, VAR_4->algo, VAR_1, VAR_2);
		if (VAR_3 != VAR_7)
			return VAR_3;
		break;
	case VAR_13:
		VAR_3 = crypto_mac_update(VAR_4->ctx, VAR_4->algo, VAR_1, VAR_2);
		if (VAR_3 != VAR_7)
			return VAR_3;
		break;
	default:
		return VAR_6;
	}

	return VAR_7;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -28,6 +28,9 @@
 	if (res != TEE_SUCCESS)
 		return res;
 
+	if (cs->state != CRYP_STATE_INITIALIZED)
+		return TEE_ERROR_BAD_STATE;
+
 	switch (TEE_ALG_GET_CLASS(cs->algo)) {
 	case TEE_OPERATION_DIGEST:
 		res = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);","{'deleted_lines': [], 'added_lines': ['\tif (cs->state != CRYP_STATE_INITIALIZED)', '\t\treturn TEE_ERROR_BAD_STATE;', '']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_authenc_update_aad,"TEE_Result syscall_authenc_update_aad(unsigned long state,
const void *aad_data, size_t aad_data_len)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t) aad_data,
aad_data_len);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
return TEE_ERROR_BAD_STATE;
res = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,
aad_data, aad_data_len);
if (res != TEE_SUCCESS)
return res;
return TEE_SUCCESS;
}","TEE_Result syscall_authenc_update_aad(unsigned long VAR_0,
const void *VAR_1, size_t VAR_2)
{
TEE_Result VAR_3;
struct tee_cryp_state *VAR_4;
struct tee_ta_session *VAR_5;
VAR_3 = tee_ta_get_current_session(&VAR_5);
if (VAR_3 != VAR_6)
return VAR_3;
VAR_3 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_5->ctx),
VAR_7 |
VAR_8,
(uaddr_t) VAR_1,
VAR_2);
if (VAR_3 != VAR_6)
return VAR_3;
VAR_3 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_4);
if (VAR_3 != VAR_6)
return VAR_3;
if (TEE_ALG_GET_CLASS(VAR_4->algo) != VAR_9)
return VAR_10;
VAR_3 = crypto_authenc_update_aad(VAR_4->ctx, VAR_4->algo, VAR_4->mode,
VAR_1, VAR_2);
if (VAR_3 != VAR_6)
return VAR_3;
return VAR_6;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/0.json,"TEE_Result syscall_authenc_update_aad(unsigned long state,
			const void *aad_data, size_t aad_data_len)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t) aad_data,
					  aad_data_len);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
		return TEE_ERROR_BAD_STATE;

	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
		return TEE_ERROR_BAD_STATE;

	res = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,
					aad_data, aad_data_len);
	if (res != TEE_SUCCESS)
		return res;

	return TEE_SUCCESS;
}","TEE_Result syscall_authenc_update_aad(unsigned long VAR_0,
			const void *VAR_1, size_t VAR_2)
{
	TEE_Result VAR_3;
	struct tee_cryp_state *VAR_4;
	struct tee_ta_session *VAR_5;

	VAR_3 = tee_ta_get_current_session(&VAR_5);
	if (VAR_3 != VAR_6)
		return VAR_3;

	VAR_3 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_5->ctx),
					  VAR_7 |
					  VAR_8,
					  (uaddr_t) VAR_1,
					  VAR_2);
	if (VAR_3 != VAR_6)
		return VAR_3;

	VAR_3 = tee_svc_cryp_get_state(VAR_5, tee_svc_uref_to_vaddr(VAR_0), &VAR_4);
	if (VAR_3 != VAR_6)
		return VAR_3;

	if (VAR_4->state != VAR_9)
		return VAR_10;

	if (TEE_ALG_GET_CLASS(VAR_4->algo) != VAR_11)
		return VAR_10;

	VAR_3 = crypto_authenc_update_aad(VAR_4->ctx, VAR_4->algo, VAR_4->mode,
					VAR_1, VAR_2);
	if (VAR_3 != VAR_6)
		return VAR_3;

	return VAR_6;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,9 @@
 	if (res != TEE_SUCCESS)
 		return res;
 
+	if (cs->state != CRYP_STATE_INITIALIZED)
+		return TEE_ERROR_BAD_STATE;
+
 	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
 		return TEE_ERROR_BAD_STATE;
 ","{'deleted_lines': [], 'added_lines': ['\tif (cs->state != CRYP_STATE_INITIALIZED)', '\t\treturn TEE_ERROR_BAD_STATE;', '']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_authenc_update_payload,"TEE_Result syscall_authenc_update_payload(unsigned long state,
const void *src_data, size_t src_len, void *dst_data,
uint64_t *dst_len)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
size_t dlen = 0;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
return TEE_ERROR_BAD_STATE;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t) src_data, src_len);
if (res != TEE_SUCCESS)
return res;
res = get_user_u64_as_size_t(&dlen, dst_len);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_WRITE |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)dst_data, dlen);
if (res != TEE_SUCCESS)
return res;
if (dlen < src_len) {
res = TEE_ERROR_SHORT_BUFFER;
goto out;
}
res = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,
src_data, src_len, dst_data,
&dlen);
out:
if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
TEE_Result res2 = put_user_u64(dst_len, dlen);
if (res2 != TEE_SUCCESS)
res = res2;
}
return res;
}","TEE_Result syscall_authenc_update_payload(unsigned long VAR_0,
const void *VAR_1, size_t VAR_2, void *VAR_3,
uint64_t *VAR_4)
{
TEE_Result VAR_5;
struct tee_cryp_state *VAR_6;
struct tee_ta_session *VAR_7;
size_t VAR_8 = 0;
VAR_5 = tee_ta_get_current_session(&VAR_7);
if (VAR_5 != VAR_9)
return VAR_5;
VAR_5 = tee_svc_cryp_get_state(VAR_7, tee_svc_uref_to_vaddr(VAR_0), &VAR_6);
if (VAR_5 != VAR_9)
return VAR_5;
if (TEE_ALG_GET_CLASS(VAR_6->algo) != VAR_10)
return VAR_11;
VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_7->ctx),
VAR_12 |
VAR_13,
(uaddr_t) VAR_1, VAR_2);
if (VAR_5 != VAR_9)
return VAR_5;
VAR_5 = get_user_u64_as_size_t(&VAR_8, VAR_4);
if (VAR_5 != VAR_9)
return VAR_5;
VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_7->ctx),
VAR_12 |
VAR_14 |
VAR_13,
(uaddr_t)VAR_3, VAR_8);
if (VAR_5 != VAR_9)
return VAR_5;
if (VAR_8 < VAR_2) {
VAR_5 = VAR_15;
goto out;
}
VAR_5 = crypto_authenc_update_payload(VAR_6->ctx, VAR_6->algo, VAR_6->mode,
VAR_1, VAR_2, VAR_3,
&VAR_8);
out:
if (VAR_5 == VAR_9 || VAR_5 == VAR_15) {
TEE_Result VAR_16 = put_user_u64(VAR_4, VAR_8);
if (VAR_16 != VAR_9)
VAR_5 = VAR_16;
}
return VAR_5;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/2.json,"TEE_Result syscall_authenc_update_payload(unsigned long state,
			const void *src_data, size_t src_len, void *dst_data,
			uint64_t *dst_len)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	size_t dlen = 0;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
		return TEE_ERROR_BAD_STATE;

	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
		return TEE_ERROR_BAD_STATE;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t) src_data, src_len);
	if (res != TEE_SUCCESS)
		return res;

	res = get_user_u64_as_size_t(&dlen, dst_len);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_WRITE |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)dst_data, dlen);
	if (res != TEE_SUCCESS)
		return res;

	if (dlen < src_len) {
		res = TEE_ERROR_SHORT_BUFFER;
		goto out;
	}

	res = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,
					    src_data, src_len, dst_data,
					    &dlen);
out:
	if (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {
		TEE_Result res2 = put_user_u64(dst_len, dlen);

		if (res2 != TEE_SUCCESS)
			res = res2;
	}

	return res;
}","TEE_Result syscall_authenc_update_payload(unsigned long VAR_0,
			const void *VAR_1, size_t VAR_2, void *VAR_3,
			uint64_t *VAR_4)
{
	TEE_Result VAR_5;
	struct tee_cryp_state *VAR_6;
	struct tee_ta_session *VAR_7;
	size_t VAR_8 = 0;

	VAR_5 = tee_ta_get_current_session(&VAR_7);
	if (VAR_5 != VAR_9)
		return VAR_5;

	VAR_5 = tee_svc_cryp_get_state(VAR_7, tee_svc_uref_to_vaddr(VAR_0), &VAR_6);
	if (VAR_5 != VAR_9)
		return VAR_5;

	if (VAR_6->state != VAR_10)
		return VAR_11;

	if (TEE_ALG_GET_CLASS(VAR_6->algo) != VAR_12)
		return VAR_11;

	VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_7->ctx),
					  VAR_13 |
					  VAR_14,
					  (uaddr_t) VAR_1, VAR_2);
	if (VAR_5 != VAR_9)
		return VAR_5;

	VAR_5 = get_user_u64_as_size_t(&VAR_8, VAR_4);
	if (VAR_5 != VAR_9)
		return VAR_5;

	VAR_5 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_7->ctx),
					  VAR_13 |
					  VAR_15 |
					  VAR_14,
					  (uaddr_t)VAR_3, VAR_8);
	if (VAR_5 != VAR_9)
		return VAR_5;

	if (VAR_8 < VAR_2) {
		VAR_5 = VAR_16;
		goto out;
	}

	VAR_5 = crypto_authenc_update_payload(VAR_6->ctx, VAR_6->algo, VAR_6->mode,
					    VAR_1, VAR_2, VAR_3,
					    &VAR_8);
out:
	if (VAR_5 == VAR_9 || VAR_5 == VAR_16) {
		TEE_Result VAR_17 = put_user_u64(VAR_4, VAR_8);

		if (VAR_17 != VAR_9)
			VAR_5 = VAR_17;
	}

	return VAR_5;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -14,6 +14,9 @@
 	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
 	if (res != TEE_SUCCESS)
 		return res;
+
+	if (cs->state != CRYP_STATE_INITIALIZED)
+		return TEE_ERROR_BAD_STATE;
 
 	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
 		return TEE_ERROR_BAD_STATE;","{'deleted_lines': [], 'added_lines': ['', '\tif (cs->state != CRYP_STATE_INITIALIZED)', '\t\treturn TEE_ERROR_BAD_STATE;']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-25052,['CWE-327'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0.0,OP-TEE/optee_os,"cryp: prevent direct calls to update and final functions

With inconsistent or malformed data it has been possible to call
""update"" and ""final"" crypto functions directly. Using a fuzzer tool [1]
we have seen that this results in asserts, i.e., a crash that
potentially could leak sensitive information.

By setting the state (initialized) in the crypto context (i.e., the
tee_cryp_state) at the end of all syscall_*_init functions and then add
a check of the state at the beginning of all update and final functions,
  we prevent direct entrance to the ""update"" and ""final"" functions.

[1] https://github.com/MartijnB/optee_fuzzer

Fixes: OP-TEE-2019-0021

Signed-off-by: Joakim Bech <joakim.bech@linaro.org>
Reported-by: Martijn Bogaard <bogaard@riscure.com>
Acked-by: Jerome Forissier <jerome.forissier@linaro.org>
Reviewed-by: Jens Wiklander <jens.wiklander@linaro.org>",34a08bec755670ea0490cb53bbc68058cafc69b6,https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6,core/tee/tee_svc_cryp.c,syscall_authenc_dec_final,"TEE_Result syscall_authenc_dec_final(unsigned long state,
const void *src_data, size_t src_len, void *dst_data,
uint64_t *dst_len, const void *tag, size_t tag_len)
{
TEE_Result res;
struct tee_cryp_state *cs;
struct tee_ta_session *sess;
size_t dlen = 0;
res = tee_ta_get_current_session(&sess);
if (res != TEE_SUCCESS)
return res;
res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
if (res != TEE_SUCCESS)
return res;
if (cs->mode != TEE_MODE_DECRYPT)
return TEE_ERROR_BAD_PARAMETERS;
if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
return TEE_ERROR_BAD_STATE;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)src_data, src_len);
if (res != TEE_SUCCESS)
return res;
if (!dst_len) {
dlen = 0;
} else {
res = get_user_u64_as_size_t(&dlen, dst_len);
if (res != TEE_SUCCESS)
return res;
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_WRITE |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)dst_data, dlen);
if (res != TEE_SUCCESS)
return res;
}
if (dlen < src_len) {
res = TEE_ERROR_SHORT_BUFFER;
goto out;
}
res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
TEE_MEMORY_ACCESS_READ |
TEE_MEMORY_ACCESS_ANY_OWNER,
(uaddr_t)tag, tag_len);
if (res != TEE_SUCCESS)
return res;
res = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,
dst_data, &dlen, tag, tag_len);
out:
if ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&
dst_len != NULL) {
TEE_Result res2 = put_user_u64(dst_len, dlen);
if (res2 != TEE_SUCCESS)
return res2;
}
return res;
}","TEE_Result syscall_authenc_dec_final(unsigned long VAR_0,
const void *VAR_1, size_t VAR_2, void *VAR_3,
uint64_t *VAR_4, const void *VAR_5, size_t VAR_6)
{
TEE_Result VAR_7;
struct tee_cryp_state *VAR_8;
struct tee_ta_session *VAR_9;
size_t VAR_10 = 0;
VAR_7 = tee_ta_get_current_session(&VAR_9);
if (VAR_7 != VAR_11)
return VAR_7;
VAR_7 = tee_svc_cryp_get_state(VAR_9, tee_svc_uref_to_vaddr(VAR_0), &VAR_8);
if (VAR_7 != VAR_11)
return VAR_7;
if (VAR_8->mode != VAR_12)
return VAR_13;
if (TEE_ALG_GET_CLASS(VAR_8->algo) != VAR_14)
return VAR_15;
VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
VAR_16 |
VAR_17,
(uaddr_t)VAR_1, VAR_2);
if (VAR_7 != VAR_11)
return VAR_7;
if (!VAR_4) {
VAR_10 = 0;
} else {
VAR_7 = get_user_u64_as_size_t(&VAR_10, VAR_4);
if (VAR_7 != VAR_11)
return VAR_7;
VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
VAR_16 |
VAR_18 |
VAR_17,
(uaddr_t)VAR_3, VAR_10);
if (VAR_7 != VAR_11)
return VAR_7;
}
if (VAR_10 < VAR_2) {
VAR_7 = VAR_19;
goto out;
}
VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
VAR_16 |
VAR_17,
(uaddr_t)VAR_5, VAR_6);
if (VAR_7 != VAR_11)
return VAR_7;
VAR_7 = crypto_authenc_dec_final(VAR_8->ctx, VAR_8->algo, VAR_1, VAR_2,
VAR_3, &VAR_10, VAR_5, VAR_6);
out:
if ((VAR_7 == VAR_11 || VAR_7 == VAR_19) &&
VAR_4 != NULL) {
TEE_Result VAR_20 = put_user_u64(VAR_4, VAR_10);
if (VAR_20 != VAR_11)
return VAR_20;
}
return VAR_7;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/before/1.json,"TEE_Result syscall_authenc_dec_final(unsigned long state,
			const void *src_data, size_t src_len, void *dst_data,
			uint64_t *dst_len, const void *tag, size_t tag_len)
{
	TEE_Result res;
	struct tee_cryp_state *cs;
	struct tee_ta_session *sess;
	size_t dlen = 0;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
	if (res != TEE_SUCCESS)
		return res;

	if (cs->state != CRYP_STATE_INITIALIZED)
		return TEE_ERROR_BAD_STATE;

	if (cs->mode != TEE_MODE_DECRYPT)
		return TEE_ERROR_BAD_PARAMETERS;

	if (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)
		return TEE_ERROR_BAD_STATE;

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)src_data, src_len);
	if (res != TEE_SUCCESS)
		return res;

	if (!dst_len) {
		dlen = 0;
	} else {
		res = get_user_u64_as_size_t(&dlen, dst_len);
		if (res != TEE_SUCCESS)
			return res;

		res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
						  TEE_MEMORY_ACCESS_READ |
						  TEE_MEMORY_ACCESS_WRITE |
						  TEE_MEMORY_ACCESS_ANY_OWNER,
						  (uaddr_t)dst_data, dlen);
		if (res != TEE_SUCCESS)
			return res;
	}

	if (dlen < src_len) {
		res = TEE_ERROR_SHORT_BUFFER;
		goto out;
	}

	res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
					  TEE_MEMORY_ACCESS_READ |
					  TEE_MEMORY_ACCESS_ANY_OWNER,
					  (uaddr_t)tag, tag_len);
	if (res != TEE_SUCCESS)
		return res;

	res = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,
				       dst_data, &dlen, tag, tag_len);

out:
	if ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&
	    dst_len != NULL) {
		TEE_Result res2 = put_user_u64(dst_len, dlen);

		if (res2 != TEE_SUCCESS)
			return res2;
	}

	return res;
}","TEE_Result syscall_authenc_dec_final(unsigned long VAR_0,
			const void *VAR_1, size_t VAR_2, void *VAR_3,
			uint64_t *VAR_4, const void *VAR_5, size_t VAR_6)
{
	TEE_Result VAR_7;
	struct tee_cryp_state *VAR_8;
	struct tee_ta_session *VAR_9;
	size_t VAR_10 = 0;

	VAR_7 = tee_ta_get_current_session(&VAR_9);
	if (VAR_7 != VAR_11)
		return VAR_7;

	VAR_7 = tee_svc_cryp_get_state(VAR_9, tee_svc_uref_to_vaddr(VAR_0), &VAR_8);
	if (VAR_7 != VAR_11)
		return VAR_7;

	if (VAR_8->state != VAR_12)
		return VAR_13;

	if (VAR_8->mode != VAR_14)
		return VAR_15;

	if (TEE_ALG_GET_CLASS(VAR_8->algo) != VAR_16)
		return VAR_13;

	VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
					  VAR_17 |
					  VAR_18,
					  (uaddr_t)VAR_1, VAR_2);
	if (VAR_7 != VAR_11)
		return VAR_7;

	if (!VAR_4) {
		VAR_10 = 0;
	} else {
		VAR_7 = get_user_u64_as_size_t(&VAR_10, VAR_4);
		if (VAR_7 != VAR_11)
			return VAR_7;

		VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
						  VAR_17 |
						  VAR_19 |
						  VAR_18,
						  (uaddr_t)VAR_3, VAR_10);
		if (VAR_7 != VAR_11)
			return VAR_7;
	}

	if (VAR_10 < VAR_2) {
		VAR_7 = VAR_20;
		goto out;
	}

	VAR_7 = tee_mmu_check_access_rights(to_user_ta_ctx(VAR_9->ctx),
					  VAR_17 |
					  VAR_18,
					  (uaddr_t)VAR_5, VAR_6);
	if (VAR_7 != VAR_11)
		return VAR_7;

	VAR_7 = crypto_authenc_dec_final(VAR_8->ctx, VAR_8->algo, VAR_1, VAR_2,
				       VAR_3, &VAR_10, VAR_5, VAR_6);

out:
	if ((VAR_7 == VAR_11 || VAR_7 == VAR_20) &&
	    VAR_4 != NULL) {
		TEE_Result VAR_21 = put_user_u64(VAR_4, VAR_10);

		if (VAR_21 != VAR_11)
			return VAR_21;
	}

	return VAR_7;
}",OP-TEE/optee_os/34a08bec755670ea0490cb53bbc68058cafc69b6/tee_svc_cryp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -14,6 +14,9 @@
 	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);
 	if (res != TEE_SUCCESS)
 		return res;
+
+	if (cs->state != CRYP_STATE_INITIALIZED)
+		return TEE_ERROR_BAD_STATE;
 
 	if (cs->mode != TEE_MODE_DECRYPT)
 		return TEE_ERROR_BAD_PARAMETERS;","{'deleted_lines': [], 'added_lines': ['', '\tif (cs->state != CRYP_STATE_INITIALIZED)', '\t\treturn TEE_ERROR_BAD_STATE;']}",True,"In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",9.1,CRITICAL,3,test,2019-06-25T09:47:09Z,2
CVE-2019-13225,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,kkos/oniguruma,Fix CVE-2019-13225: problem in converting if-then-else pattern to bytecode.,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,src/regcomp.c,compile_bag_node,"static int
compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
{
int r, len;
switch (node->type) {
case BAG_MEMORY:
r = compile_bag_memory_node(node, reg, env);
break;
case BAG_OPTION:
r = compile_option_node(node, reg, env);
break;
case BAG_STOP_BACKTRACK:
if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
QuantNode* qn = QUANT_(NODE_BAG_BODY(node));
r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);
if (r != 0) return r;
len = compile_length_tree(NODE_QUANT_BODY(qn), reg);
if (len < 0) return len;
r = add_op(reg, OP_PUSH);
if (r != 0) return r;
COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
r = compile_tree(NODE_QUANT_BODY(qn), reg, env);
if (r != 0) return r;
r = add_op(reg, OP_POP_OUT);
if (r != 0) return r;
r = add_op(reg, OP_JUMP);
if (r != 0) return r;
COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);
}
else {
r = add_op(reg, OP_ATOMIC_START);
if (r != 0) return r;
r = compile_tree(NODE_BAG_BODY(node), reg, env);
if (r != 0) return r;
r = add_op(reg, OP_ATOMIC_END);
}
break;
case BAG_IF_ELSE:
{
int cond_len, then_len, jump_len;
Node* cond = NODE_BAG_BODY(node);
Node* Then = node->te.Then;
Node* Else = node->te.Else;
r = add_op(reg, OP_ATOMIC_START);
if (r != 0) return r;
cond_len = compile_length_tree(cond, reg);
if (cond_len < 0) return cond_len;
if (IS_NOT_NULL(Then)) {
then_len = compile_length_tree(Then, reg);
if (then_len < 0) return then_len;
}
else
then_len = 0;
jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
r = add_op(reg, OP_PUSH);
if (r != 0) return r;
COP(reg)->push.addr = SIZE_INC_OP + jump_len;
r = compile_tree(cond, reg, env);
if (r != 0) return r;
r = add_op(reg, OP_ATOMIC_END);
if (r != 0) return r;
if (IS_NOT_NULL(Then)) {
r = compile_tree(Then, reg, env);
if (r != 0) return r;
}
if (IS_NOT_NULL(Else)) {
int else_len = compile_length_tree(Else, reg);
r = add_op(reg, OP_JUMP);
if (r != 0) return r;
COP(reg)->jump.addr = else_len + SIZE_INC_OP;
r = compile_tree(Else, reg, env);
}
}
break;
}
return r;
}","static int
compile_bag_node(BagNode* VAR_0, regex_t* VAR_1, ScanEnv* VAR_2)
{
int VAR_3, VAR_4;
switch (VAR_0->type) {
case VAR_5:
VAR_3 = compile_bag_memory_node(VAR_0, VAR_1, VAR_2);
break;
case VAR_6:
VAR_3 = compile_option_node(VAR_0, VAR_1, VAR_2);
break;
case VAR_7:
if (NODE_IS_STOP_BT_SIMPLE_REPEAT(VAR_0)) {
QuantNode* VAR_8 = QUANT_(NODE_BAG_BODY(VAR_0));
VAR_3 = compile_tree_n_times(NODE_QUANT_BODY(VAR_8), VAR_8->lower, VAR_1, VAR_2);
if (VAR_3 != 0) return VAR_3;
VAR_4 = compile_length_tree(NODE_QUANT_BODY(VAR_8), VAR_1);
if (VAR_4 < 0) return VAR_4;
VAR_3 = add_op(VAR_1, VAR_9);
if (VAR_3 != 0) return VAR_3;
COP(VAR_1)->push.addr = VAR_10 + VAR_4 + VAR_11 + VAR_12;
VAR_3 = compile_tree(NODE_QUANT_BODY(VAR_8), VAR_1, VAR_2);
if (VAR_3 != 0) return VAR_3;
VAR_3 = add_op(VAR_1, VAR_13);
if (VAR_3 != 0) return VAR_3;
VAR_3 = add_op(VAR_1, VAR_14);
if (VAR_3 != 0) return VAR_3;
COP(VAR_1)->jump.addr = -((int )VAR_15 + VAR_4 + (int )VAR_11);
}
else {
VAR_3 = add_op(VAR_1, VAR_16);
if (VAR_3 != 0) return VAR_3;
VAR_3 = compile_tree(NODE_BAG_BODY(VAR_0), VAR_1, VAR_2);
if (VAR_3 != 0) return VAR_3;
VAR_3 = add_op(VAR_1, VAR_17);
}
break;
case VAR_18:
{
int VAR_19, VAR_20, VAR_21;
Node* VAR_22 = NODE_BAG_BODY(VAR_0);
Node* VAR_23 = VAR_0->te.Then;
Node* VAR_24 = VAR_0->te.Else;
VAR_3 = add_op(VAR_1, VAR_16);
if (VAR_3 != 0) return VAR_3;
VAR_19 = compile_length_tree(VAR_22, VAR_1);
if (VAR_19 < 0) return VAR_19;
if (IS_NOT_NULL(VAR_23)) {
VAR_20 = compile_length_tree(VAR_23, VAR_1);
if (VAR_20 < 0) return VAR_20;
}
else
VAR_20 = 0;
VAR_21 = VAR_19 + VAR_20 + VAR_25;
if (IS_NOT_NULL(VAR_24)) VAR_21 += VAR_12;
VAR_3 = add_op(VAR_1, VAR_9);
if (VAR_3 != 0) return VAR_3;
COP(VAR_1)->push.addr = VAR_10 + VAR_21;
VAR_3 = compile_tree(VAR_22, VAR_1, VAR_2);
if (VAR_3 != 0) return VAR_3;
VAR_3 = add_op(VAR_1, VAR_17);
if (VAR_3 != 0) return VAR_3;
if (IS_NOT_NULL(VAR_23)) {
VAR_3 = compile_tree(VAR_23, VAR_1, VAR_2);
if (VAR_3 != 0) return VAR_3;
}
if (IS_NOT_NULL(VAR_24)) {
int VAR_26 = compile_length_tree(VAR_24, VAR_1);
VAR_3 = add_op(VAR_1, VAR_14);
if (VAR_3 != 0) return VAR_3;
COP(VAR_1)->jump.addr = VAR_26 + VAR_10;
VAR_3 = compile_tree(VAR_24, VAR_1, VAR_2);
}
}
break;
}
return VAR_3;
}",kkos/oniguruma/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/regcomp.c/vul/before/0.json,"static int
compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
{
  int r, len;

  switch (node->type) {
  case BAG_MEMORY:
    r = compile_bag_memory_node(node, reg, env);
    break;

  case BAG_OPTION:
    r = compile_option_node(node, reg, env);
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));
      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);
      if (r != 0) return r;

      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (len < 0) return len;

      r = add_op(reg, OP_PUSH);
      if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;

      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_POP_OUT);
      if (r != 0) return r;

      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);
    }
    else {
      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;
      r = compile_tree(NODE_BAG_BODY(node), reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
    }
    break;

  case BAG_IF_ELSE:
    {
      int cond_len, then_len, else_len, jump_len;
      Node* cond = NODE_BAG_BODY(node);
      Node* Then = node->te.Then;
      Node* Else = node->te.Else;

      r = add_op(reg, OP_ATOMIC_START);
      if (r != 0) return r;

      cond_len = compile_length_tree(cond, reg);
      if (cond_len < 0) return cond_len;
      if (IS_NOT_NULL(Then)) {
        then_len = compile_length_tree(Then, reg);
        if (then_len < 0) return then_len;
      }
      else
        then_len = 0;

      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;

      r = add_op(reg, OP_PUSH);
      if (r != 0) return r;
      COP(reg)->push.addr = SIZE_INC_OP + jump_len;

      r = compile_tree(cond, reg, env);
      if (r != 0) return r;
      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Then)) {
        r = compile_tree(Then, reg, env);
        if (r != 0) return r;
      }

      if (IS_NOT_NULL(Else)) {
        else_len = compile_length_tree(Else, reg);
        if (else_len < 0) return else_len;
      }
      else
        else_len = 0;

      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;

      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Else)) {
        r = compile_tree(Else, reg, env);
      }
    }
    break;
  }

  return r;
}","static int
compile_bag_node(BagNode* VAR_0, regex_t* VAR_1, ScanEnv* VAR_2)
{
  int VAR_3, VAR_4;

  switch (VAR_0->type) {
  case VAR_5:
    VAR_3 = compile_bag_memory_node(VAR_0, VAR_1, VAR_2);
    break;

  case VAR_6:
    VAR_3 = compile_option_node(VAR_0, VAR_1, VAR_2);
    break;

  case VAR_7:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(VAR_0)) {
      QuantNode* VAR_8 = QUANT_(NODE_BAG_BODY(VAR_0));
      VAR_3 = compile_tree_n_times(NODE_QUANT_BODY(VAR_8), VAR_8->lower, VAR_1, VAR_2);
      if (VAR_3 != 0) return VAR_3;

      VAR_4 = compile_length_tree(NODE_QUANT_BODY(VAR_8), VAR_1);
      if (VAR_4 < 0) return VAR_4;

      VAR_3 = add_op(VAR_1, VAR_9);
      if (VAR_3 != 0) return VAR_3;
      COP(VAR_1)->push.addr = VAR_10 + VAR_4 + VAR_11 + VAR_12;

      VAR_3 = compile_tree(NODE_QUANT_BODY(VAR_8), VAR_1, VAR_2);
      if (VAR_3 != 0) return VAR_3;
      VAR_3 = add_op(VAR_1, VAR_13);
      if (VAR_3 != 0) return VAR_3;

      VAR_3 = add_op(VAR_1, VAR_14);
      if (VAR_3 != 0) return VAR_3;
      COP(VAR_1)->jump.addr = -((int )VAR_15 + VAR_4 + (int )VAR_11);
    }
    else {
      VAR_3 = add_op(VAR_1, VAR_16);
      if (VAR_3 != 0) return VAR_3;
      VAR_3 = compile_tree(NODE_BAG_BODY(VAR_0), VAR_1, VAR_2);
      if (VAR_3 != 0) return VAR_3;
      VAR_3 = add_op(VAR_1, VAR_17);
    }
    break;

  case VAR_18:
    {
      int VAR_19, VAR_20, VAR_21, VAR_22;
      Node* VAR_23 = NODE_BAG_BODY(VAR_0);
      Node* VAR_24 = VAR_0->te.Then;
      Node* VAR_25 = VAR_0->te.Else;

      VAR_3 = add_op(VAR_1, VAR_16);
      if (VAR_3 != 0) return VAR_3;

      VAR_19 = compile_length_tree(VAR_23, VAR_1);
      if (VAR_19 < 0) return VAR_19;
      if (IS_NOT_NULL(VAR_24)) {
        VAR_20 = compile_length_tree(VAR_24, VAR_1);
        if (VAR_20 < 0) return VAR_20;
      }
      else
        VAR_20 = 0;

      VAR_22 = VAR_19 + VAR_20 + VAR_26 + VAR_12;

      VAR_3 = add_op(VAR_1, VAR_9);
      if (VAR_3 != 0) return VAR_3;
      COP(VAR_1)->push.addr = VAR_10 + VAR_22;

      VAR_3 = compile_tree(VAR_23, VAR_1, VAR_2);
      if (VAR_3 != 0) return VAR_3;
      VAR_3 = add_op(VAR_1, VAR_17);
      if (VAR_3 != 0) return VAR_3;

      if (IS_NOT_NULL(VAR_24)) {
        VAR_3 = compile_tree(VAR_24, VAR_1, VAR_2);
        if (VAR_3 != 0) return VAR_3;
      }

      if (IS_NOT_NULL(VAR_25)) {
        VAR_21 = compile_length_tree(VAR_25, VAR_1);
        if (VAR_21 < 0) return VAR_21;
      }
      else
        VAR_21 = 0;

      VAR_3 = add_op(VAR_1, VAR_14);
      if (VAR_3 != 0) return VAR_3;
      COP(VAR_1)->jump.addr = VAR_26 + VAR_21 + VAR_10;

      VAR_3 = add_op(VAR_1, VAR_17);
      if (VAR_3 != 0) return VAR_3;

      if (IS_NOT_NULL(VAR_25)) {
        VAR_3 = compile_tree(VAR_25, VAR_1, VAR_2);
      }
    }
    break;
  }

  return VAR_3;
}",kkos/oniguruma/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/regcomp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,7 @@
 
   case BAG_IF_ELSE:
     {
-      int cond_len, then_len, jump_len;
+      int cond_len, then_len, else_len, jump_len;
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;
@@ -62,8 +62,7 @@
       else
         then_len = 0;
 
-      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
-      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;
+      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
 
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
@@ -80,11 +79,20 @@
       }
 
       if (IS_NOT_NULL(Else)) {
-        int else_len = compile_length_tree(Else, reg);
-        r = add_op(reg, OP_JUMP);
-        if (r != 0) return r;
-        COP(reg)->jump.addr = else_len + SIZE_INC_OP;
+        else_len = compile_length_tree(Else, reg);
+        if (else_len < 0) return else_len;
+      }
+      else
+        else_len = 0;
 
+      r = add_op(reg, OP_JUMP);
+      if (r != 0) return r;
+      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;
+
+      r = add_op(reg, OP_ATOMIC_END);
+      if (r != 0) return r;
+
+      if (IS_NOT_NULL(Else)) {
         r = compile_tree(Else, reg, env);
       }
     }","{'deleted_lines': ['      int cond_len, then_len, jump_len;', '      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;', '      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;', '        int else_len = compile_length_tree(Else, reg);', '        r = add_op(reg, OP_JUMP);', '        if (r != 0) return r;', '        COP(reg)->jump.addr = else_len + SIZE_INC_OP;'], 'added_lines': ['      int cond_len, then_len, else_len, jump_len;', '      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;', '        else_len = compile_length_tree(Else, reg);', '        if (else_len < 0) return else_len;', '      }', '      else', '        else_len = 0;', '      r = add_op(reg, OP_JUMP);', '      if (r != 0) return r;', '      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;', '', '      r = add_op(reg, OP_ATOMIC_END);', '      if (r != 0) return r;', '', '      if (IS_NOT_NULL(Else)) {']}",True,"A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",6.5,MEDIUM,1,test,2019-06-27T05:11:55Z,2
CVE-2019-13225,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,kkos/oniguruma,Fix CVE-2019-13225: problem in converting if-then-else pattern to bytecode.,c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,https://github.com/kkos/oniguruma/commit/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c,src/regcomp.c,compile_length_bag_node,"static int
compile_length_bag_node(BagNode* node, regex_t* reg)
{
int len;
int tlen;
if (node->type == BAG_OPTION)
return compile_length_option_node(node, reg);
if (NODE_BAG_BODY(node)) {
tlen = compile_length_tree(NODE_BAG_BODY(node), reg);
if (tlen < 0) return tlen;
}
else
tlen = 0;
switch (node->type) {
case BAG_MEMORY:
#ifdef USE_CALL
if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {
len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
return len;
}
if (NODE_IS_CALLED(node)) {
len = SIZE_OP_MEMORY_START_PUSH + tlen
+ SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))
len += (NODE_IS_RECURSION(node)
? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);
else
len += (NODE_IS_RECURSION(node)
? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);
}
else if (NODE_IS_RECURSION(node)) {
len = SIZE_OP_MEMORY_START_PUSH;
len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);
}
else
#endif
{
if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))
len = SIZE_OP_MEMORY_START_PUSH;
else
len = SIZE_OP_MEMORY_START;
len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);
}
break;
case BAG_STOP_BACKTRACK:
if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
int v;
QuantNode* qn;
qn = QUANT_(NODE_BAG_BODY(node));
tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);
if (tlen < 0) return tlen;
v = onig_positive_int_multiply(qn->lower, tlen);
if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
}
else {
len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;
}
break;
case BAG_IF_ELSE:
{
Node* cond = NODE_BAG_BODY(node);
Node* Then = node->te.Then;
Node* Else = node->te.Else;
len = compile_length_tree(cond, reg);
if (len < 0) return len;
len += SIZE_OP_PUSH;
len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;
if (IS_NOT_NULL(Then)) {
tlen = compile_length_tree(Then, reg);
if (tlen < 0) return tlen;
len += tlen;
}
if (IS_NOT_NULL(Else)) {
len += SIZE_OP_JUMP;
tlen = compile_length_tree(Else, reg);
if (tlen < 0) return tlen;
len += tlen;
}
}
break;
case BAG_OPTION:
len = 0;
break;
}
return len;
}","static int
compile_length_bag_node(BagNode* VAR_0, regex_t* VAR_1)
{
int VAR_2;
int VAR_3;
if (VAR_0->type == VAR_4)
return compile_length_option_node(VAR_0, VAR_1);
if (NODE_BAG_BODY(VAR_0)) {
VAR_3 = compile_length_tree(NODE_BAG_BODY(VAR_0), VAR_1);
if (VAR_3 < 0) return VAR_3;
}
else
VAR_3 = 0;
switch (VAR_0->type) {
case VAR_5:
#ifdef VAR_6
if (VAR_0->m.regnum == 0 && NODE_IS_CALLED(VAR_0)) {
VAR_2 = VAR_3 + VAR_7 + VAR_8 + VAR_9;
return VAR_2;
}
if (NODE_IS_CALLED(VAR_0)) {
VAR_2 = VAR_10 + VAR_3
+ VAR_7 + VAR_8 + VAR_9;
if (MEM_STATUS_AT0(VAR_1->bt_mem_end, VAR_0->m.regnum))
VAR_2 += (NODE_IS_RECURSION(VAR_0)
? VAR_11 : VAR_12);
else
VAR_2 += (NODE_IS_RECURSION(VAR_0)
? VAR_13 : VAR_14);
}
else if (NODE_IS_RECURSION(VAR_0)) {
VAR_2 = VAR_10;
VAR_2 += VAR_3 + (MEM_STATUS_AT0(VAR_1->bt_mem_end, VAR_0->m.regnum)
? VAR_11 : VAR_13);
}
else
#endif
{
if (MEM_STATUS_AT0(VAR_1->bt_mem_start, VAR_0->m.regnum))
VAR_2 = VAR_10;
else
VAR_2 = VAR_15;
VAR_2 += VAR_3 + (MEM_STATUS_AT0(VAR_1->bt_mem_end, VAR_0->m.regnum)
? VAR_12 : VAR_14);
}
break;
case VAR_16:
if (NODE_IS_STOP_BT_SIMPLE_REPEAT(VAR_0)) {
int VAR_17;
QuantNode* VAR_18;
VAR_18 = QUANT_(NODE_BAG_BODY(VAR_0));
VAR_3 = compile_length_tree(NODE_QUANT_BODY(VAR_18), VAR_1);
if (VAR_3 < 0) return VAR_3;
VAR_17 = onig_positive_int_multiply(VAR_18->lower, VAR_3);
if (VAR_17 < 0) return VAR_19;
VAR_2 = VAR_17 + VAR_20 + VAR_3 + VAR_21 + VAR_8;
}
else {
VAR_2 = VAR_22 + VAR_3 + VAR_23;
}
break;
case VAR_24:
{
Node* VAR_25 = NODE_BAG_BODY(VAR_0);
Node* VAR_26 = VAR_0->te.Then;
Node* VAR_27 = VAR_0->te.Else;
VAR_2 = compile_length_tree(VAR_25, VAR_1);
if (VAR_2 < 0) return VAR_2;
VAR_2 += VAR_20;
VAR_2 += VAR_22 + VAR_23;
if (IS_NOT_NULL(VAR_26)) {
VAR_3 = compile_length_tree(VAR_26, VAR_1);
if (VAR_3 < 0) return VAR_3;
VAR_2 += VAR_3;
}
if (IS_NOT_NULL(VAR_27)) {
VAR_2 += VAR_8;
VAR_3 = compile_length_tree(VAR_27, VAR_1);
if (VAR_3 < 0) return VAR_3;
VAR_2 += VAR_3;
}
}
break;
case VAR_4:
VAR_2 = 0;
break;
}
return VAR_2;
}",kkos/oniguruma/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/regcomp.c/vul/before/1.json,"static int
compile_length_bag_node(BagNode* node, regex_t* reg)
{
  int len;
  int tlen;

  if (node->type == BAG_OPTION)
    return compile_length_option_node(node, reg);

  if (NODE_BAG_BODY(node)) {
    tlen = compile_length_tree(NODE_BAG_BODY(node), reg);
    if (tlen < 0) return tlen;
  }
  else
    tlen = 0;

  switch (node->type) {
  case BAG_MEMORY:
#ifdef USE_CALL

    if (node->m.regnum == 0 && NODE_IS_CALLED(node)) {
      len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      return len;
    }

    if (NODE_IS_CALLED(node)) {
      len = SIZE_OP_MEMORY_START_PUSH + tlen
        + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN;
      if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum))
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH);
      else
        len += (NODE_IS_RECURSION(node)
                ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END);
    }
    else if (NODE_IS_RECURSION(node)) {
      len = SIZE_OP_MEMORY_START_PUSH;
      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC);
    }
    else
#endif
    {
      if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum))
        len = SIZE_OP_MEMORY_START_PUSH;
      else
        len = SIZE_OP_MEMORY_START;

      len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)
                     ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END);
    }
    break;

  case BAG_STOP_BACKTRACK:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
      int v;
      QuantNode* qn;

      qn = QUANT_(NODE_BAG_BODY(node));
      tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg);
      if (tlen < 0) return tlen;

      v = onig_positive_int_multiply(qn->lower, tlen);
      if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE;
      len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP;
    }
    else {
      len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END;
    }
    break;

  case BAG_IF_ELSE:
    {
      Node* cond = NODE_BAG_BODY(node);
      Node* Then = node->te.Then;
      Node* Else = node->te.Else;

      len = compile_length_tree(cond, reg);
      if (len < 0) return len;
      len += SIZE_OP_PUSH;
      len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END;

      if (IS_NOT_NULL(Then)) {
        tlen = compile_length_tree(Then, reg);
        if (tlen < 0) return tlen;
        len += tlen;
      }

      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;

      if (IS_NOT_NULL(Else)) {
        tlen = compile_length_tree(Else, reg);
        if (tlen < 0) return tlen;
        len += tlen;
      }
    }
    break;

  case BAG_OPTION:
    /* never come here, but set for escape warning */
    len = 0;
    break;
  }

  return len;
}","static int
compile_length_bag_node(BagNode* VAR_0, regex_t* VAR_1)
{
  int VAR_2;
  int VAR_3;

  if (VAR_0->type == VAR_4)
    return compile_length_option_node(VAR_0, VAR_1);

  if (NODE_BAG_BODY(VAR_0)) {
    VAR_3 = compile_length_tree(NODE_BAG_BODY(VAR_0), VAR_1);
    if (VAR_3 < 0) return VAR_3;
  }
  else
    VAR_3 = 0;

  switch (VAR_0->type) {
  case VAR_5:
#ifdef VAR_6

    if (VAR_0->m.regnum == 0 && NODE_IS_CALLED(VAR_0)) {
      VAR_2 = VAR_3 + VAR_7 + VAR_8 + VAR_9;
      return VAR_2;
    }

    if (NODE_IS_CALLED(VAR_0)) {
      VAR_2 = VAR_10 + VAR_3
        + VAR_7 + VAR_8 + VAR_9;
      if (MEM_STATUS_AT0(VAR_1->bt_mem_end, VAR_0->m.regnum))
        VAR_2 += (NODE_IS_RECURSION(VAR_0)
                ? VAR_11 : VAR_12);
      else
        VAR_2 += (NODE_IS_RECURSION(VAR_0)
                ? VAR_13 : VAR_14);
    }
    else if (NODE_IS_RECURSION(VAR_0)) {
      VAR_2 = VAR_10;
      VAR_2 += VAR_3 + (MEM_STATUS_AT0(VAR_1->bt_mem_end, VAR_0->m.regnum)
                     ? VAR_11 : VAR_13);
    }
    else
#endif
    {
      if (MEM_STATUS_AT0(VAR_1->bt_mem_start, VAR_0->m.regnum))
        VAR_2 = VAR_10;
      else
        VAR_2 = VAR_15;

      VAR_2 += VAR_3 + (MEM_STATUS_AT0(VAR_1->bt_mem_end, VAR_0->m.regnum)
                     ? VAR_12 : VAR_14);
    }
    break;

  case VAR_16:
    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(VAR_0)) {
      int VAR_17;
      QuantNode* VAR_18;

      VAR_18 = QUANT_(NODE_BAG_BODY(VAR_0));
      VAR_3 = compile_length_tree(NODE_QUANT_BODY(VAR_18), VAR_1);
      if (VAR_3 < 0) return VAR_3;

      VAR_17 = onig_positive_int_multiply(VAR_18->lower, VAR_3);
      if (VAR_17 < 0) return VAR_19;
      VAR_2 = VAR_17 + VAR_20 + VAR_3 + VAR_21 + VAR_8;
    }
    else {
      VAR_2 = VAR_22 + VAR_3 + VAR_23;
    }
    break;

  case VAR_24:
    {
      Node* VAR_25 = NODE_BAG_BODY(VAR_0);
      Node* VAR_26 = VAR_0->te.Then;
      Node* VAR_27 = VAR_0->te.Else;

      VAR_2 = compile_length_tree(VAR_25, VAR_1);
      if (VAR_2 < 0) return VAR_2;
      VAR_2 += VAR_20;
      VAR_2 += VAR_22 + VAR_23;

      if (IS_NOT_NULL(VAR_26)) {
        VAR_3 = compile_length_tree(VAR_26, VAR_1);
        if (VAR_3 < 0) return VAR_3;
        VAR_2 += VAR_3;
      }

      VAR_2 += VAR_8 + VAR_23;

      if (IS_NOT_NULL(VAR_27)) {
        VAR_3 = compile_length_tree(VAR_27, VAR_1);
        if (VAR_3 < 0) return VAR_3;
        VAR_2 += VAR_3;
      }
    }
    break;

  case VAR_4:
    /* COMMENT_0 */
    VAR_2 = 0;
    break;
  }

  return VAR_2;
}",kkos/oniguruma/c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c/regcomp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -86,8 +86,9 @@
         len += tlen;
       }
 
+      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;
+
       if (IS_NOT_NULL(Else)) {
-        len += SIZE_OP_JUMP;
         tlen = compile_length_tree(Else, reg);
         if (tlen < 0) return tlen;
         len += tlen;","{'deleted_lines': ['        len += SIZE_OP_JUMP;'], 'added_lines': ['      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;', '']}",True,"A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust.",6.5,MEDIUM,1,test,2019-06-27T05:11:55Z,2
CVE-2019-13067,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,nginx/njs,"Added support for functions in regexp with global match.

This closes #183 issue on GitHub.",f15fb784bbc537917cf59a5de922131fc5c18431,https://github.com/nginx/njs/commit/f15fb784bbc537917cf59a5de922131fc5c18431,njs/njs_string.c,njs_string_replace_regexp_function,"static njs_ret_t
njs_string_replace_regexp_function(njs_vm_t *vm, njs_value_t *args,
njs_string_replace_t *r, int *captures, nxt_uint_t n)
{
u_char       *start;
size_t       size, length;
njs_ret_t    ret;
nxt_uint_t   i, k;
njs_value_t  *arguments;
r->u.cont.function = njs_string_replace_regexp_continuation;
njs_set_invalid(&r->retval);
arguments = nxt_mp_alloc(vm->mem_pool, (n + 3) * sizeof(njs_value_t));
if (nxt_slow_path(arguments == NULL)) {
return NXT_ERROR;
}
arguments[0] = njs_value_undefined;
for (k = 0, i = 1; i <= n; i++) {
start = r->part[0].start + captures[k];
size = captures[k + 1] - captures[k];
k += 2;
length = njs_string_calc_length(r->utf8, start, size);
ret = njs_string_new(vm, &arguments[i], start, size, length);
if (nxt_slow_path(ret != NXT_OK)) {
return NXT_ERROR;
}
}
njs_value_number_set(&arguments[n + 1], captures[0]);
length = njs_string_calc_length(r->utf8, r->part[0].start, r->part[0].size);
ret = njs_string_new(vm, &arguments[n + 2], r->part[0].start,
r->part[0].size, length);
if (nxt_slow_path(ret != NXT_OK)) {
return NXT_ERROR;
}
r->part[0].size = captures[0];
return njs_function_apply(vm, r->function, arguments, n + 3,
(njs_index_t) &r->retval);
}","static njs_ret_t
njs_string_replace_regexp_function(njs_vm_t *VAR_0, njs_value_t *VAR_1,
njs_string_replace_t *VAR_2, int *VAR_3, nxt_uint_t VAR_4)
{
u_char       *VAR_5;
size_t       VAR_6, VAR_7;
njs_ret_t    VAR_8;
nxt_uint_t   VAR_9, VAR_10;
njs_value_t  *VAR_11;
VAR_2->u.cont.function = VAR_12;
njs_set_invalid(&VAR_2->retval);
VAR_11 = nxt_mp_alloc(VAR_0->mem_pool, (VAR_4 + 3) * sizeof(njs_value_t));
if (nxt_slow_path(VAR_11 == NULL)) {
return VAR_13;
}
VAR_11[0] = VAR_14;
for (VAR_10 = 0, VAR_9 = 1; VAR_9 <= VAR_4; VAR_9++) {
VAR_5 = VAR_2->part[0].start + VAR_3[VAR_10];
VAR_6 = VAR_3[VAR_10 + 1] - VAR_3[VAR_10];
VAR_10 += 2;
VAR_7 = njs_string_calc_length(VAR_2->utf8, VAR_5, VAR_6);
VAR_8 = njs_string_new(VAR_0, &VAR_11[VAR_9], VAR_5, VAR_6, VAR_7);
if (nxt_slow_path(VAR_8 != VAR_15)) {
return VAR_13;
}
}
njs_value_number_set(&VAR_11[VAR_4 + 1], VAR_3[0]);
VAR_7 = njs_string_calc_length(VAR_2->utf8, VAR_2->part[0].start, VAR_2->part[0].size);
VAR_8 = njs_string_new(VAR_0, &VAR_11[VAR_4 + 2], VAR_2->part[0].start,
VAR_2->part[0].size, VAR_7);
if (nxt_slow_path(VAR_8 != VAR_15)) {
return VAR_13;
}
VAR_2->part[0].size = VAR_3[0];
return njs_function_apply(VAR_0, VAR_2->function, VAR_11, VAR_4 + 3,
(VAR_16) &VAR_2->retval);
}",nginx/njs/f15fb784bbc537917cf59a5de922131fc5c18431/njs_string.c/vul/before/0.json,"static njs_ret_t
njs_string_replace_regexp_function(njs_vm_t *vm, njs_value_t *args,
    njs_string_replace_t *r, int *captures, nxt_uint_t n)
{
    u_char             *start;
    size_t             size, length;
    njs_ret_t          ret;
    nxt_uint_t         i, k;
    njs_value_t        *arguments;
    njs_string_prop_t  string;

    r->u.cont.function = njs_string_replace_regexp_continuation;
    njs_set_invalid(&r->retval);

    arguments = nxt_mp_alloc(vm->mem_pool, (n + 3) * sizeof(njs_value_t));
    if (nxt_slow_path(arguments == NULL)) {
        return NXT_ERROR;
    }

    arguments[0] = njs_value_undefined;

    /* Matched substring and parenthesized submatch strings. */
    for (k = 0, i = 1; i <= n; i++) {

        start = r->part[0].start + captures[k];
        size = captures[k + 1] - captures[k];
        k += 2;

        length = njs_string_calc_length(r->utf8, start, size);

        ret = njs_string_new(vm, &arguments[i], start, size, length);
        if (nxt_slow_path(ret != NXT_OK)) {
            return NXT_ERROR;
        }
    }

    r->empty = (captures[0] == captures[1]);

    /* The offset of the matched substring. */
    njs_value_number_set(&arguments[n + 1], captures[0]);

    /* The whole string being examined. */
    length = njs_string_calc_length(r->utf8, r->part[0].start, r->part[0].size);

    (void) njs_string_prop(&string, &args[0]);

    ret = njs_string_new(vm, &arguments[n + 2], string.start, string.size,
                         length);

    if (nxt_slow_path(ret != NXT_OK)) {
        return NXT_ERROR;
    }

    r->part[0].size = captures[0];

    return njs_function_apply(vm, r->function, arguments, n + 3,
                              (njs_index_t) &r->retval);
}","static njs_ret_t
njs_string_replace_regexp_function(njs_vm_t *VAR_0, njs_value_t *VAR_1,
    njs_string_replace_t *VAR_2, int *VAR_3, nxt_uint_t VAR_4)
{
    u_char             *VAR_5;
    size_t             VAR_6, VAR_7;
    njs_ret_t          VAR_8;
    nxt_uint_t         VAR_9, VAR_10;
    njs_value_t        *VAR_11;
    njs_string_prop_t  VAR_12;

    VAR_2->u.cont.function = VAR_13;
    njs_set_invalid(&VAR_2->retval);

    VAR_11 = nxt_mp_alloc(VAR_0->mem_pool, (VAR_4 + 3) * sizeof(njs_value_t));
    if (nxt_slow_path(VAR_11 == NULL)) {
        return VAR_14;
    }

    VAR_11[0] = VAR_15;

    /* COMMENT_0 */
    for (VAR_10 = 0, VAR_9 = 1; VAR_9 <= VAR_4; VAR_9++) {

        VAR_5 = VAR_2->part[0].start + VAR_3[VAR_10];
        VAR_6 = VAR_3[VAR_10 + 1] - VAR_3[VAR_10];
        VAR_10 += 2;

        VAR_7 = njs_string_calc_length(VAR_2->utf8, VAR_5, VAR_6);

        VAR_8 = njs_string_new(VAR_0, &VAR_11[VAR_9], VAR_5, VAR_6, VAR_7);
        if (nxt_slow_path(VAR_8 != VAR_16)) {
            return VAR_14;
        }
    }

    VAR_2->empty = (VAR_3[0] == VAR_3[1]);

    /* COMMENT_1 */
    njs_value_number_set(&VAR_11[VAR_4 + 1], VAR_3[0]);

    /* COMMENT_2 */
    VAR_7 = njs_string_calc_length(VAR_2->utf8, VAR_2->part[0].start, VAR_2->part[0].size);

    (void) njs_string_prop(&VAR_12, &VAR_1[0]);

    VAR_8 = njs_string_new(VAR_0, &VAR_11[VAR_4 + 2], VAR_12.start, VAR_12.size,
                         VAR_7);

    if (nxt_slow_path(VAR_8 != VAR_16)) {
        return VAR_14;
    }

    VAR_2->part[0].size = VAR_3[0];

    return njs_function_apply(VAR_0, VAR_2->function, VAR_11, VAR_4 + 3,
                              (VAR_17) &VAR_2->retval);
}",nginx/njs/f15fb784bbc537917cf59a5de922131fc5c18431/njs_string.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,11 +2,12 @@
 njs_string_replace_regexp_function(njs_vm_t *vm, njs_value_t *args,
     njs_string_replace_t *r, int *captures, nxt_uint_t n)
 {
-    u_char       *start;
-    size_t       size, length;
-    njs_ret_t    ret;
-    nxt_uint_t   i, k;
-    njs_value_t  *arguments;
+    u_char             *start;
+    size_t             size, length;
+    njs_ret_t          ret;
+    nxt_uint_t         i, k;
+    njs_value_t        *arguments;
+    njs_string_prop_t  string;
 
     r->u.cont.function = njs_string_replace_regexp_continuation;
     njs_set_invalid(&r->retval);
@@ -33,14 +34,18 @@
         }
     }
 
+    r->empty = (captures[0] == captures[1]);
+
     /* The offset of the matched substring. */
     njs_value_number_set(&arguments[n + 1], captures[0]);
 
     /* The whole string being examined. */
     length = njs_string_calc_length(r->utf8, r->part[0].start, r->part[0].size);
 
-    ret = njs_string_new(vm, &arguments[n + 2], r->part[0].start,
-                         r->part[0].size, length);
+    (void) njs_string_prop(&string, &args[0]);
+
+    ret = njs_string_new(vm, &arguments[n + 2], string.start, string.size,
+                         length);
 
     if (nxt_slow_path(ret != NXT_OK)) {
         return NXT_ERROR;","{'deleted_lines': ['    u_char       *start;', '    size_t       size, length;', '    njs_ret_t    ret;', '    nxt_uint_t   i, k;', '    njs_value_t  *arguments;', '    ret = njs_string_new(vm, &arguments[n + 2], r->part[0].start,', '                         r->part[0].size, length);'], 'added_lines': ['    u_char             *start;', '    size_t             size, length;', '    njs_ret_t          ret;', '    nxt_uint_t         i, k;', '    njs_value_t        *arguments;', '    njs_string_prop_t  string;', '    r->empty = (captures[0] == captures[1]);', '', '    (void) njs_string_prop(&string, &args[0]);', '', '    ret = njs_string_new(vm, &arguments[n + 2], string.start, string.size,', '                         length);']}",True,"njs through 0.3.3, used in NGINX, has a buffer over-read in nxt_utf8_decode in nxt/nxt_utf8.c. This issue occurs after the fix for CVE-2019-12207 is in place.",9.8,CRITICAL,3,test,2019-07-01T16:57:34Z,2
CVE-2019-13067,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,nginx/njs,"Added support for functions in regexp with global match.

This closes #183 issue on GitHub.",f15fb784bbc537917cf59a5de922131fc5c18431,https://github.com/nginx/njs/commit/f15fb784bbc537917cf59a5de922131fc5c18431,njs/njs_string.c,njs_string_replace_regexp_continuation,"static njs_ret_t
njs_string_replace_regexp_continuation(njs_vm_t *vm, njs_value_t *args,
nxt_uint_t nargs, njs_index_t unused)
{
njs_string_replace_t  *r;
r = njs_vm_continuation(vm);
if (njs_is_string(&r->retval)) {
njs_string_replacement_copy(&r->part[1], &r->retval);
if (args[1].data.u.regexp->pattern->global) {
r->part += 2;
return njs_string_replace_regexp(vm, args, r);
}
return njs_string_replace_regexp_join(vm, r);
}
nxt_regex_match_data_free(r->match_data, vm->regex_context);
njs_internal_error(vm, ""unexpected continuation retval type:%s"",
njs_type_string(r->retval.type));
return NXT_ERROR;
}","static njs_ret_t
njs_string_replace_regexp_continuation(njs_vm_t *VAR_0, njs_value_t *VAR_1,
nxt_uint_t VAR_2, njs_index_t VAR_3)
{
njs_string_replace_t  *VAR_4;
VAR_4 = njs_vm_continuation(VAR_0);
if (njs_is_string(&VAR_4->retval)) {
njs_string_replacement_copy(&VAR_4->part[1], &VAR_4->retval);
if (VAR_1[1].data.u.regexp->pattern->global) {
VAR_4->part += 2;
return njs_string_replace_regexp(VAR_0, VAR_1, VAR_4);
}
return njs_string_replace_regexp_join(VAR_0, VAR_4);
}
nxt_regex_match_data_free(VAR_4->match_data, VAR_0->regex_context);
njs_internal_error(VAR_0, ""unexpected continuation retval type:%s"",
njs_type_string(VAR_4->retval.type));
return VAR_5;
}",nginx/njs/f15fb784bbc537917cf59a5de922131fc5c18431/njs_string.c/vul/before/1.json,"static njs_ret_t
njs_string_replace_regexp_continuation(njs_vm_t *vm, njs_value_t *args,
    nxt_uint_t nargs, njs_index_t unused)
{
    njs_string_prop_t     string;
    njs_string_replace_t  *r;

    r = njs_vm_continuation(vm);

    (void) njs_string_prop(&string, &args[0]);

    if (njs_is_string(&r->retval)) {
        njs_string_replacement_copy(&r->part[r->empty ? 0 : 1], &r->retval);

        if (args[1].data.u.regexp->pattern->global) {
            r->part += 2;

            if (r->part[0].start > (string.start + string.size)) {
                return njs_string_replace_regexp_join(vm, r);
            }

            return njs_string_replace_regexp(vm, args, r);
        }

        return njs_string_replace_regexp_join(vm, r);
    }

    nxt_regex_match_data_free(r->match_data, vm->regex_context);

    njs_internal_error(vm, ""unexpected continuation retval type:%s"",
                       njs_type_string(r->retval.type));

    return NXT_ERROR;
}","static njs_ret_t
njs_string_replace_regexp_continuation(njs_vm_t *VAR_0, njs_value_t *VAR_1,
    nxt_uint_t VAR_2, njs_index_t VAR_3)
{
    njs_string_prop_t     VAR_4;
    njs_string_replace_t  *VAR_5;

    VAR_5 = njs_vm_continuation(VAR_0);

    (void) njs_string_prop(&VAR_4, &VAR_1[0]);

    if (njs_is_string(&VAR_5->retval)) {
        njs_string_replacement_copy(&VAR_5->part[VAR_5->empty ? 0 : 1], &VAR_5->retval);

        if (VAR_1[1].data.u.regexp->pattern->global) {
            VAR_5->part += 2;

            if (VAR_5->part[0].start > (VAR_4.start + VAR_4.size)) {
                return njs_string_replace_regexp_join(VAR_0, VAR_5);
            }

            return njs_string_replace_regexp(VAR_0, VAR_1, VAR_5);
        }

        return njs_string_replace_regexp_join(VAR_0, VAR_5);
    }

    nxt_regex_match_data_free(VAR_5->match_data, VAR_0->regex_context);

    njs_internal_error(VAR_0, ""unexpected continuation retval type:%s"",
                       njs_type_string(VAR_5->retval.type));

    return VAR_6;
}",nginx/njs/f15fb784bbc537917cf59a5de922131fc5c18431/njs_string.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,15 +2,23 @@
 njs_string_replace_regexp_continuation(njs_vm_t *vm, njs_value_t *args,
     nxt_uint_t nargs, njs_index_t unused)
 {
+    njs_string_prop_t     string;
     njs_string_replace_t  *r;
 
     r = njs_vm_continuation(vm);
 
+    (void) njs_string_prop(&string, &args[0]);
+
     if (njs_is_string(&r->retval)) {
-        njs_string_replacement_copy(&r->part[1], &r->retval);
+        njs_string_replacement_copy(&r->part[r->empty ? 0 : 1], &r->retval);
 
         if (args[1].data.u.regexp->pattern->global) {
             r->part += 2;
+
+            if (r->part[0].start > (string.start + string.size)) {
+                return njs_string_replace_regexp_join(vm, r);
+            }
+
             return njs_string_replace_regexp(vm, args, r);
         }
 ","{'deleted_lines': ['        njs_string_replacement_copy(&r->part[1], &r->retval);'], 'added_lines': ['    njs_string_prop_t     string;', '    (void) njs_string_prop(&string, &args[0]);', '', '        njs_string_replacement_copy(&r->part[r->empty ? 0 : 1], &r->retval);', '', '            if (r->part[0].start > (string.start + string.size)) {', '                return njs_string_replace_regexp_join(vm, r);', '            }', '']}",True,"njs through 0.3.3, used in NGINX, has a buffer over-read in nxt_utf8_decode in nxt/nxt_utf8.c. This issue occurs after the fix for CVE-2019-12207 is in place.",9.8,CRITICAL,3,test,2019-07-01T16:57:34Z,2
CVE-2019-13067,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,nginx/njs,"Added support for functions in regexp with global match.

This closes #183 issue on GitHub.",f15fb784bbc537917cf59a5de922131fc5c18431,https://github.com/nginx/njs/commit/f15fb784bbc537917cf59a5de922131fc5c18431,njs/njs_string.c,njs_string_replace_regexp,"static njs_ret_t
njs_string_replace_regexp(njs_vm_t *vm, njs_value_t *args,
njs_string_replace_t *r)
{
int                        *captures;
u_char                     *p, *start;
njs_ret_t                  ret;
const u_char               *end;
njs_regexp_pattern_t       *pattern;
njs_string_replace_part_t  replace;
pattern = args[1].data.u.regexp->pattern;
end = r->part[0].start + r->part[0].size;
replace = r->part[1];
do {
ret = njs_regexp_match(vm, &pattern->regex[r->type],
r->part[0].start, r->part[0].size,
r->match_data);
if (ret >= 0) {
captures = nxt_regex_captures(r->match_data);
if (r->substitutions != NULL) {
ret = njs_string_replace_substitute(vm, r, captures);
if (nxt_slow_path(ret != NXT_OK)) {
return ret;
}
if (!pattern->global) {
return njs_string_replace_regexp_join(vm, r);
}
} else {
if (r->part != r->parts.start) {
r->part = nxt_array_add(&r->parts, &njs_array_mem_proto,
vm->mem_pool);
if (nxt_slow_path(r->part == NULL)) {
return NXT_ERROR;
}
r->part = nxt_array_add(&r->parts, &njs_array_mem_proto,
vm->mem_pool);
if (nxt_slow_path(r->part == NULL)) {
return NXT_ERROR;
}
r->part -= 2;
}
if (captures[1] == 0) {
start = r->part[0].start;
if (start < end) {
p = (u_char *) nxt_utf8_next(start, end);
r->part[1].start = start;
r->part[1].size = p - start;
r->part[2].start = p;
r->part[2].size = end - p;
} else {
r->part[1].size = 0;
r->part[2].size = 0;
r->part[2].start = start + 1;
}
r->part[0] = replace;
} else {
r->part[2].start = r->part[0].start + captures[1];
r->part[2].size = r->part[0].size - captures[1];
njs_set_invalid(&r->part[2].value);
if (r->function != NULL) {
return njs_string_replace_regexp_function(vm, args, r,
captures, ret);
}
r->part[0].size = captures[0];
r->part[1] = replace;
}
if (!pattern->global) {
return njs_string_replace_regexp_join(vm, r);
}
r->part += 2;
}
} else if (ret == NXT_REGEX_NOMATCH) {
break;
} else {
return NXT_ERROR;
}
} while (r->part[0].start <= end);
if (r->part != r->parts.start) {
return njs_string_replace_regexp_join(vm, r);
}
nxt_regex_match_data_free(r->match_data, vm->regex_context);
nxt_array_destroy(&r->parts, &njs_array_mem_proto, vm->mem_pool);
njs_string_copy(&vm->retval, &args[0]);
return NXT_OK;
}","static njs_ret_t
njs_string_replace_regexp(njs_vm_t *VAR_0, njs_value_t *VAR_1,
njs_string_replace_t *VAR_2)
{
int                        *VAR_3;
u_char                     *VAR_4, *VAR_5;
njs_ret_t                  VAR_6;
const u_char               *VAR_7;
njs_regexp_pattern_t       *VAR_8;
njs_string_replace_part_t  VAR_9;
VAR_8 = VAR_1[1].data.u.regexp->pattern;
VAR_7 = VAR_2->part[0].start + VAR_2->part[0].size;
VAR_9 = VAR_2->part[1];
do {
VAR_6 = njs_regexp_match(VAR_0, &VAR_8->regex[VAR_2->type],
VAR_2->part[0].start, VAR_2->part[0].size,
VAR_2->match_data);
if (VAR_6 >= 0) {
VAR_3 = nxt_regex_captures(VAR_2->match_data);
if (VAR_2->substitutions != NULL) {
VAR_6 = njs_string_replace_substitute(VAR_0, VAR_2, VAR_3);
if (nxt_slow_path(VAR_6 != VAR_10)) {
return VAR_6;
}
if (!VAR_8->global) {
return njs_string_replace_regexp_join(VAR_0, VAR_2);
}
} else {
if (VAR_2->part != VAR_2->parts.start) {
VAR_2->part = nxt_array_add(&VAR_2->parts, &VAR_11,
VAR_0->mem_pool);
if (nxt_slow_path(VAR_2->part == NULL)) {
return VAR_12;
}
VAR_2->part = nxt_array_add(&VAR_2->parts, &VAR_11,
VAR_0->mem_pool);
if (nxt_slow_path(VAR_2->part == NULL)) {
return VAR_12;
}
VAR_2->part -= 2;
}
if (VAR_3[1] == 0) {
VAR_5 = VAR_2->part[0].start;
if (VAR_5 < VAR_7) {
VAR_4 = (u_char *) nxt_utf8_next(VAR_5, VAR_7);
VAR_2->part[1].start = VAR_5;
VAR_2->part[1].size = VAR_4 - VAR_5;
VAR_2->part[2].start = VAR_4;
VAR_2->part[2].size = VAR_7 - VAR_4;
} else {
VAR_2->part[1].size = 0;
VAR_2->part[2].size = 0;
VAR_2->part[2].start = VAR_5 + 1;
}
VAR_2->part[0] = VAR_9;
} else {
VAR_2->part[2].start = VAR_2->part[0].start + VAR_3[1];
VAR_2->part[2].size = VAR_2->part[0].size - VAR_3[1];
njs_set_invalid(&VAR_2->part[2].value);
if (VAR_2->function != NULL) {
return njs_string_replace_regexp_function(VAR_0, VAR_1, VAR_2,
VAR_3, VAR_6);
}
VAR_2->part[0].size = VAR_3[0];
VAR_2->part[1] = VAR_9;
}
if (!VAR_8->global) {
return njs_string_replace_regexp_join(VAR_0, VAR_2);
}
VAR_2->part += 2;
}
} else if (VAR_6 == VAR_13) {
break;
} else {
return VAR_12;
}
} while (VAR_2->part[0].start <= VAR_7);
if (VAR_2->part != VAR_2->parts.start) {
return njs_string_replace_regexp_join(VAR_0, VAR_2);
}
nxt_regex_match_data_free(VAR_2->match_data, VAR_0->regex_context);
nxt_array_destroy(&VAR_2->parts, &VAR_11, VAR_0->mem_pool);
njs_string_copy(&VAR_0->retval, &VAR_1[0]);
return VAR_10;
}",nginx/njs/f15fb784bbc537917cf59a5de922131fc5c18431/njs_string.c/vul/before/2.json,"static njs_ret_t
njs_string_replace_regexp(njs_vm_t *vm, njs_value_t *args,
    njs_string_replace_t *r)
{
    int                        *captures;
    u_char                     *p, *start;
    njs_ret_t                  ret;
    const u_char               *end;
    njs_regexp_pattern_t       *pattern;
    njs_string_replace_part_t  replace;

    pattern = args[1].data.u.regexp->pattern;
    end = r->part[0].start + r->part[0].size;

    replace = r->part[1];

    do {
        ret = njs_regexp_match(vm, &pattern->regex[r->type],
                               r->part[0].start, r->part[0].size,
                               r->match_data);

        if (ret >= 0) {
            captures = nxt_regex_captures(r->match_data);

            if (r->substitutions != NULL) {
                ret = njs_string_replace_substitute(vm, r, captures);
                if (nxt_slow_path(ret != NXT_OK)) {
                    return ret;
                }

                if (!pattern->global) {
                    return njs_string_replace_regexp_join(vm, r);
                }

            } else {
                if (r->part != r->parts.start) {
                    r->part = nxt_array_add(&r->parts, &njs_array_mem_proto,
                                            vm->mem_pool);
                    if (nxt_slow_path(r->part == NULL)) {
                        return NXT_ERROR;
                    }

                    r->part = nxt_array_add(&r->parts, &njs_array_mem_proto,
                                            vm->mem_pool);
                    if (nxt_slow_path(r->part == NULL)) {
                        return NXT_ERROR;
                    }

                    r->part -= 2;
                }

                if (captures[1] == 0) {

                    /* Empty match. */

                    start = r->part[0].start;

                    if (start < end) {
                        p = (u_char *) nxt_utf8_next(start, end);

                        r->part[1].start = start;
                        r->part[1].size = p - start;

                        r->part[2].start = p;
                        r->part[2].size = end - p;

                    } else {
                        r->part[1].size = 0;
                        r->part[2].size = 0;

                        /* To exit the loop. */
                        r->part[2].start = start + 1;
                    }

                    if (r->function != NULL) {
                        return njs_string_replace_regexp_function(vm, args, r,
                                                                 captures, ret);
                    }

                    r->part[0] = replace;

                } else {
                    r->part[2].start = r->part[0].start + captures[1];
                    r->part[2].size = r->part[0].size - captures[1];
                    njs_set_invalid(&r->part[2].value);

                    if (r->function != NULL) {
                        return njs_string_replace_regexp_function(vm, args, r,
                                                                 captures, ret);
                    }

                    r->part[0].size = captures[0];

                    r->part[1] = replace;
                }

                if (!pattern->global) {
                    return njs_string_replace_regexp_join(vm, r);
                }

                r->part += 2;
            }

        } else if (ret == NXT_REGEX_NOMATCH) {
            break;

        } else {
            return NXT_ERROR;
        }

    } while (r->part[0].start <= end);

    if (r->part != r->parts.start) {
        return njs_string_replace_regexp_join(vm, r);
    }

    nxt_regex_match_data_free(r->match_data, vm->regex_context);

    nxt_array_destroy(&r->parts, &njs_array_mem_proto, vm->mem_pool);

    njs_string_copy(&vm->retval, &args[0]);

    return NXT_OK;
}","static njs_ret_t
njs_string_replace_regexp(njs_vm_t *VAR_0, njs_value_t *VAR_1,
    njs_string_replace_t *VAR_2)
{
    int                        *VAR_3;
    u_char                     *VAR_4, *VAR_5;
    njs_ret_t                  VAR_6;
    const u_char               *VAR_7;
    njs_regexp_pattern_t       *VAR_8;
    njs_string_replace_part_t  VAR_9;

    VAR_8 = VAR_1[1].data.u.regexp->pattern;
    VAR_7 = VAR_2->part[0].start + VAR_2->part[0].size;

    VAR_9 = VAR_2->part[1];

    do {
        VAR_6 = njs_regexp_match(VAR_0, &VAR_8->regex[VAR_2->type],
                               VAR_2->part[0].start, VAR_2->part[0].size,
                               VAR_2->match_data);

        if (VAR_6 >= 0) {
            VAR_3 = nxt_regex_captures(VAR_2->match_data);

            if (VAR_2->substitutions != NULL) {
                VAR_6 = njs_string_replace_substitute(VAR_0, VAR_2, VAR_3);
                if (nxt_slow_path(VAR_6 != VAR_10)) {
                    return VAR_6;
                }

                if (!VAR_8->global) {
                    return njs_string_replace_regexp_join(VAR_0, VAR_2);
                }

            } else {
                if (VAR_2->part != VAR_2->parts.start) {
                    VAR_2->part = nxt_array_add(&VAR_2->parts, &VAR_11,
                                            VAR_0->mem_pool);
                    if (nxt_slow_path(VAR_2->part == NULL)) {
                        return VAR_12;
                    }

                    VAR_2->part = nxt_array_add(&VAR_2->parts, &VAR_11,
                                            VAR_0->mem_pool);
                    if (nxt_slow_path(VAR_2->part == NULL)) {
                        return VAR_12;
                    }

                    VAR_2->part -= 2;
                }

                if (VAR_3[1] == 0) {

                    /* COMMENT_0 */

                    VAR_5 = VAR_2->part[0].start;

                    if (VAR_5 < VAR_7) {
                        VAR_4 = (u_char *) nxt_utf8_next(VAR_5, VAR_7);

                        VAR_2->part[1].start = VAR_5;
                        VAR_2->part[1].size = VAR_4 - VAR_5;

                        VAR_2->part[2].start = VAR_4;
                        VAR_2->part[2].size = VAR_7 - VAR_4;

                    } else {
                        VAR_2->part[1].size = 0;
                        VAR_2->part[2].size = 0;

                        /* COMMENT_1 */
                        VAR_2->part[2].start = VAR_5 + 1;
                    }

                    if (VAR_2->function != NULL) {
                        return njs_string_replace_regexp_function(VAR_0, VAR_1, VAR_2,
                                                                 VAR_3, VAR_6);
                    }

                    VAR_2->part[0] = VAR_9;

                } else {
                    VAR_2->part[2].start = VAR_2->part[0].start + VAR_3[1];
                    VAR_2->part[2].size = VAR_2->part[0].size - VAR_3[1];
                    njs_set_invalid(&VAR_2->part[2].value);

                    if (VAR_2->function != NULL) {
                        return njs_string_replace_regexp_function(VAR_0, VAR_1, VAR_2,
                                                                 VAR_3, VAR_6);
                    }

                    VAR_2->part[0].size = VAR_3[0];

                    VAR_2->part[1] = VAR_9;
                }

                if (!VAR_8->global) {
                    return njs_string_replace_regexp_join(VAR_0, VAR_2);
                }

                VAR_2->part += 2;
            }

        } else if (VAR_6 == VAR_13) {
            break;

        } else {
            return VAR_12;
        }

    } while (VAR_2->part[0].start <= VAR_7);

    if (VAR_2->part != VAR_2->parts.start) {
        return njs_string_replace_regexp_join(VAR_0, VAR_2);
    }

    nxt_regex_match_data_free(VAR_2->match_data, VAR_0->regex_context);

    nxt_array_destroy(&VAR_2->parts, &VAR_11, VAR_0->mem_pool);

    njs_string_copy(&VAR_0->retval, &VAR_1[0]);

    return VAR_10;
}",nginx/njs/f15fb784bbc537917cf59a5de922131fc5c18431/njs_string.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -72,6 +72,11 @@
                         r->part[2].start = start + 1;
                     }
 
+                    if (r->function != NULL) {
+                        return njs_string_replace_regexp_function(vm, args, r,
+                                                                 captures, ret);
+                    }
+
                     r->part[0] = replace;
 
                 } else {","{'deleted_lines': [], 'added_lines': ['                    if (r->function != NULL) {', '                        return njs_string_replace_regexp_function(vm, args, r,', '                                                                 captures, ret);', '                    }', '']}",True,"njs through 0.3.3, used in NGINX, has a buffer over-read in nxt_utf8_decode in nxt/nxt_utf8.c. This issue occurs after the fix for CVE-2019-12207 is in place.",9.8,CRITICAL,3,test,2019-07-01T16:57:34Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,fs/f2fs/data.c,f2fs_read_data_page,"static int f2fs_read_data_page(struct file *file, struct page *page)
{
struct inode *inode = page->mapping->host;
int ret = -EAGAIN;
trace_f2fs_readpage(page, DATA);
if (f2fs_has_inline_data(inode))
ret = f2fs_read_inline_data(inode, page);
if (ret == -EAGAIN)
ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);
return ret;
}","static int f2fs_read_data_page(struct file *file, struct page *page)
{
struct inode *inode = page->mapping->host;
int VAR_0 = -VAR_1;
trace_f2fs_readpage(page, VAR_2);
if (f2fs_has_inline_data(inode))
VAR_0 = f2fs_read_inline_data(inode, page);
if (VAR_0 == -VAR_1)
VAR_0 = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);
return VAR_0;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/before/1.json,"static int f2fs_read_data_page(struct file *file, struct page *page)
{
	struct inode *inode = page_file_mapping(page)->host;
	int ret = -EAGAIN;

	trace_f2fs_readpage(page, DATA);

	/* If the file has inline data, try to read it directly */
	if (f2fs_has_inline_data(inode))
		ret = f2fs_read_inline_data(inode, page);
	if (ret == -EAGAIN)
		ret = f2fs_mpage_readpages(page_file_mapping(page),
						NULL, page, 1, false);
	return ret;
}","static int f2fs_read_data_page(struct file *file, struct page *page)
{
	struct inode *inode = page_file_mapping(page)->host;
	int VAR_0 = -VAR_1;

	trace_f2fs_readpage(page, VAR_2);

	/* COMMENT_0 */
	if (f2fs_has_inline_data(inode))
		VAR_0 = f2fs_read_inline_data(inode, page);
	if (VAR_0 == -VAR_1)
		VAR_0 = f2fs_mpage_readpages(page_file_mapping(page),
						NULL, page, 1, false);
	return VAR_0;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int f2fs_read_data_page(struct file *file, struct page *page)
 {
-	struct inode *inode = page->mapping->host;
+	struct inode *inode = page_file_mapping(page)->host;
 	int ret = -EAGAIN;
 
 	trace_f2fs_readpage(page, DATA);
@@ -9,6 +9,7 @@
 	if (f2fs_has_inline_data(inode))
 		ret = f2fs_read_inline_data(inode, page);
 	if (ret == -EAGAIN)
-		ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);
+		ret = f2fs_mpage_readpages(page_file_mapping(page),
+						NULL, page, 1, false);
 	return ret;
 }","{'deleted_lines': ['\tstruct inode *inode = page->mapping->host;', '\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);'], 'added_lines': ['\tstruct inode *inode = page_file_mapping(page)->host;', '\t\tret = f2fs_mpage_readpages(page_file_mapping(page),', '\t\t\t\t\t\tNULL, page, 1, false);']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,fs/f2fs/data.c,f2fs_set_data_page_dirty,"static int f2fs_set_data_page_dirty(struct page *page)
{
struct address_space *mapping = page->mapping;
struct inode *inode = mapping->host;
trace_f2fs_set_page_dirty(page, DATA);
if (!PageUptodate(page))
SetPageUptodate(page);
if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
f2fs_register_inmem_page(inode, page);
return 1;
}
return 0;
}
if (!PageDirty(page)) {
__set_page_dirty_nobuffers(page);
f2fs_update_dirty_page(inode, page);
return 1;
}
return 0;
}","static int f2fs_set_data_page_dirty(struct page *page)
{
struct address_space *VAR_0 = page->mapping;
struct inode *inode = VAR_0->host;
trace_f2fs_set_page_dirty(page, VAR_1);
if (!PageUptodate(page))
SetPageUptodate(page);
if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
f2fs_register_inmem_page(inode, page);
return 1;
}
return 0;
}
if (!PageDirty(page)) {
__set_page_dirty_nobuffers(page);
f2fs_update_dirty_page(inode, page);
return 1;
}
return 0;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/before/0.json,"static int f2fs_set_data_page_dirty(struct page *page)
{
	struct inode *inode = page_file_mapping(page)->host;

	trace_f2fs_set_page_dirty(page, DATA);

	if (!PageUptodate(page))
		SetPageUptodate(page);
	if (PageSwapCache(page))
		return __set_page_dirty_nobuffers(page);

	if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
		if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
			f2fs_register_inmem_page(inode, page);
			return 1;
		}
		/*
		 * Previously, this page has been registered, we just
		 * return here.
		 */
		return 0;
	}

	if (!PageDirty(page)) {
		__set_page_dirty_nobuffers(page);
		f2fs_update_dirty_page(inode, page);
		return 1;
	}
	return 0;
}","static int f2fs_set_data_page_dirty(struct page *page)
{
	struct inode *inode = page_file_mapping(page)->host;

	trace_f2fs_set_page_dirty(page, VAR_0);

	if (!PageUptodate(page))
		SetPageUptodate(page);
	if (PageSwapCache(page))
		return __set_page_dirty_nobuffers(page);

	if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
		if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
			f2fs_register_inmem_page(inode, page);
			return 1;
		}
		/* COMMENT_0 */
                                                       
                 
     
		return 0;
	}

	if (!PageDirty(page)) {
		__set_page_dirty_nobuffers(page);
		f2fs_update_dirty_page(inode, page);
		return 1;
	}
	return 0;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,12 +1,13 @@
 static int f2fs_set_data_page_dirty(struct page *page)
 {
-	struct address_space *mapping = page->mapping;
-	struct inode *inode = mapping->host;
+	struct inode *inode = page_file_mapping(page)->host;
 
 	trace_f2fs_set_page_dirty(page, DATA);
 
 	if (!PageUptodate(page))
 		SetPageUptodate(page);
+	if (PageSwapCache(page))
+		return __set_page_dirty_nobuffers(page);
 
 	if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
 		if (!IS_ATOMIC_WRITTEN_PAGE(page)) {","{'deleted_lines': ['\tstruct address_space *mapping = page->mapping;', '\tstruct inode *inode = mapping->host;'], 'added_lines': ['\tstruct inode *inode = page_file_mapping(page)->host;', '\tif (PageSwapCache(page))', '\t\treturn __set_page_dirty_nobuffers(page);']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,fs/f2fs/f2fs.h,f2fs_force_buffered_io,"static inline bool f2fs_force_buffered_io(struct inode *inode,
struct kiocb *iocb, struct iov_iter *iter)
{
struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
int rw = iov_iter_rw(iter);
if (f2fs_post_read_required(inode))
return true;
if (f2fs_is_multi_device(sbi))
return true;
if (f2fs_sb_has_blkzoned(sbi))
return true;
if (test_opt(sbi, LFS) && (rw == WRITE) &&
block_unaligned_IO(inode, iocb, iter))
return true;
if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))
return true;
return false;
}","static inline bool f2fs_force_buffered_io(struct inode *inode,
struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
struct f2fs_sb_info *VAR_2 = F2FS_I_SB(inode);
int VAR_3 = iov_iter_rw(VAR_1);
if (f2fs_post_read_required(inode))
return true;
if (f2fs_is_multi_device(VAR_2))
return true;
if (f2fs_sb_has_blkzoned(VAR_2))
return true;
if (test_opt(VAR_2, VAR_4) && (VAR_3 == VAR_5) &&
block_unaligned_IO(inode, VAR_0, VAR_1))
return true;
if (is_sbi_flag_set(F2FS_I_SB(inode), VAR_6))
return true;
return false;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/before/1.json,"static inline bool f2fs_force_buffered_io(struct inode *inode,
				struct kiocb *iocb, struct iov_iter *iter)
{
	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
	int rw = iov_iter_rw(iter);

	if (f2fs_post_read_required(inode))
		return true;
	if (f2fs_is_multi_device(sbi))
		return true;
	/*
	 * for blkzoned device, fallback direct IO to buffered IO, so
	 * all IOs can be serialized by log-structured write.
	 */
	if (f2fs_sb_has_blkzoned(sbi))
		return true;
	if (test_opt(sbi, LFS) && (rw == WRITE) &&
				block_unaligned_IO(inode, iocb, iter))
		return true;
	if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&
					!(inode->i_flags & S_SWAPFILE))
		return true;

	return false;
}","static inline bool f2fs_force_buffered_io(struct inode *inode,
				struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
	struct f2fs_sb_info *VAR_2 = F2FS_I_SB(inode);
	int VAR_3 = iov_iter_rw(VAR_1);

	if (f2fs_post_read_required(inode))
		return true;
	if (f2fs_is_multi_device(VAR_2))
		return true;
	/* COMMENT_0 */
                                                              
                                                      
    
	if (f2fs_sb_has_blkzoned(VAR_2))
		return true;
	if (test_opt(VAR_2, VAR_4) && (VAR_3 == VAR_5) &&
				block_unaligned_IO(inode, VAR_0, VAR_1))
		return true;
	if (is_sbi_flag_set(F2FS_I_SB(inode), VAR_6) &&
					!(inode->i_flags & VAR_7))
		return true;

	return false;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -17,7 +17,8 @@
 	if (test_opt(sbi, LFS) && (rw == WRITE) &&
 				block_unaligned_IO(inode, iocb, iter))
 		return true;
-	if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))
+	if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&
+					!(inode->i_flags & S_SWAPFILE))
 		return true;
 
 	return false;","{'deleted_lines': ['\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))'], 'added_lines': ['\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&', '\t\t\t\t\t!(inode->i_flags & S_SWAPFILE))']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,fs/f2fs/data.c,f2fs_read_single_page,"static int f2fs_read_single_page(struct inode *inode, struct page *page,
unsigned nr_pages,
struct f2fs_map_blocks *map,
struct bio **bio_ret,
sector_t *last_block_in_bio,
bool is_readahead)
{
struct bio *bio = *bio_ret;
const unsigned blkbits = inode->i_blkbits;
const unsigned blocksize = 1 << blkbits;
sector_t block_in_file;
sector_t last_block;
sector_t last_block_in_file;
sector_t block_nr;
int ret = 0;
block_in_file = (sector_t)page->index;
last_block = block_in_file + nr_pages;
last_block_in_file = (i_size_read(inode) + blocksize - 1) >>
blkbits;
if (last_block > last_block_in_file)
last_block = last_block_in_file;
if (block_in_file >= last_block)
goto zero_out;
if ((map->m_flags & F2FS_MAP_MAPPED) &&
block_in_file > map->m_lblk &&
block_in_file < (map->m_lblk + map->m_len))
goto got_it;
map->m_lblk = block_in_file;
map->m_len = last_block - block_in_file;
ret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);
if (ret)
goto out;
got_it:
if ((map->m_flags & F2FS_MAP_MAPPED)) {
block_nr = map->m_pblk + block_in_file - map->m_lblk;
SetPageMappedToDisk(page);
if (!PageUptodate(page) && !cleancache_get_page(page)) {
SetPageUptodate(page);
goto confused;
}
if (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,
DATA_GENERIC_ENHANCE_READ)) {
ret = -EFSCORRUPTED;
goto out;
}
} else {
zero_out:
zero_user_segment(page, 0, PAGE_SIZE);
if (!PageUptodate(page))
SetPageUptodate(page);
unlock_page(page);
goto out;
}
if (bio && (*last_block_in_bio != block_nr - 1 ||
!__same_bdev(F2FS_I_SB(inode), block_nr, bio))) {
submit_and_realloc:
__submit_bio(F2FS_I_SB(inode), bio, DATA);
bio = NULL;
}
if (bio == NULL) {
bio = f2fs_grab_read_bio(inode, block_nr, nr_pages,
is_readahead ? REQ_RAHEAD : 0);
if (IS_ERR(bio)) {
ret = PTR_ERR(bio);
bio = NULL;
goto out;
}
}
f2fs_wait_on_block_writeback(inode, block_nr);
if (bio_add_page(bio, page, blocksize, 0) < blocksize)
goto submit_and_realloc;
inc_page_count(F2FS_I_SB(inode), F2FS_RD_DATA);
ClearPageError(page);
*last_block_in_bio = block_nr;
goto out;
confused:
if (bio) {
__submit_bio(F2FS_I_SB(inode), bio, DATA);
bio = NULL;
}
unlock_page(page);
out:
*bio_ret = bio;
return ret;
}","static int f2fs_read_single_page(struct inode *inode, struct page *page,
unsigned VAR_0,
struct f2fs_map_blocks *VAR_1,
struct bio **VAR_2,
sector_t *VAR_3,
bool VAR_4)
{
struct bio *bio = *VAR_2;
const unsigned VAR_5 = inode->i_blkbits;
const unsigned VAR_6 = 1 << VAR_5;
sector_t VAR_7;
sector_t VAR_8;
sector_t VAR_9;
sector_t VAR_10;
int VAR_11 = 0;
VAR_7 = (sector_t)page->index;
VAR_8 = VAR_7 + VAR_0;
VAR_9 = (i_size_read(inode) + VAR_6 - 1) >>
VAR_5;
if (VAR_8 > VAR_9)
VAR_8 = VAR_9;
if (VAR_7 >= VAR_8)
goto zero_out;
if ((VAR_1->m_flags & VAR_12) &&
VAR_7 > VAR_1->m_lblk &&
VAR_7 < (VAR_1->m_lblk + VAR_1->m_len))
goto got_it;
VAR_1->m_lblk = VAR_7;
VAR_1->m_len = VAR_8 - VAR_7;
VAR_11 = f2fs_map_blocks(inode, VAR_1, 0, VAR_13);
if (VAR_11)
goto out;
got_it:
if ((VAR_1->m_flags & VAR_12)) {
VAR_10 = VAR_1->m_pblk + VAR_7 - VAR_1->m_lblk;
SetPageMappedToDisk(page);
if (!PageUptodate(page) && !cleancache_get_page(page)) {
SetPageUptodate(page);
goto confused;
}
if (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), VAR_10,
VAR_14)) {
VAR_11 = -VAR_15;
goto out;
}
} else {
zero_out:
zero_user_segment(page, 0, VAR_16);
if (!PageUptodate(page))
SetPageUptodate(page);
unlock_page(page);
goto out;
}
if (bio && (*VAR_3 != VAR_10 - 1 ||
!__same_bdev(F2FS_I_SB(inode), VAR_10, bio))) {
submit_and_realloc:
__submit_bio(F2FS_I_SB(inode), bio, VAR_17);
bio = NULL;
}
if (bio == NULL) {
bio = f2fs_grab_read_bio(inode, VAR_10, VAR_0,
VAR_4 ? VAR_18 : 0);
if (IS_ERR(bio)) {
VAR_11 = PTR_ERR(bio);
bio = NULL;
goto out;
}
}
f2fs_wait_on_block_writeback(inode, VAR_10);
if (bio_add_page(bio, page, VAR_6, 0) < VAR_6)
goto submit_and_realloc;
inc_page_count(F2FS_I_SB(inode), VAR_19);
ClearPageError(page);
*VAR_3 = VAR_10;
goto out;
confused:
if (bio) {
__submit_bio(F2FS_I_SB(inode), bio, VAR_17);
bio = NULL;
}
unlock_page(page);
out:
*VAR_2 = bio;
return VAR_11;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/before/2.json,"static int f2fs_read_single_page(struct inode *inode, struct page *page,
					unsigned nr_pages,
					struct f2fs_map_blocks *map,
					struct bio **bio_ret,
					sector_t *last_block_in_bio,
					bool is_readahead)
{
	struct bio *bio = *bio_ret;
	const unsigned blkbits = inode->i_blkbits;
	const unsigned blocksize = 1 << blkbits;
	sector_t block_in_file;
	sector_t last_block;
	sector_t last_block_in_file;
	sector_t block_nr;
	int ret = 0;

	block_in_file = (sector_t)page_index(page);
	last_block = block_in_file + nr_pages;
	last_block_in_file = (i_size_read(inode) + blocksize - 1) >>
							blkbits;
	if (last_block > last_block_in_file)
		last_block = last_block_in_file;

	/* just zeroing out page which is beyond EOF */
	if (block_in_file >= last_block)
		goto zero_out;
	/*
	 * Map blocks using the previous result first.
	 */
	if ((map->m_flags & F2FS_MAP_MAPPED) &&
			block_in_file > map->m_lblk &&
			block_in_file < (map->m_lblk + map->m_len))
		goto got_it;

	/*
	 * Then do more f2fs_map_blocks() calls until we are
	 * done with this page.
	 */
	map->m_lblk = block_in_file;
	map->m_len = last_block - block_in_file;

	ret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);
	if (ret)
		goto out;
got_it:
	if ((map->m_flags & F2FS_MAP_MAPPED)) {
		block_nr = map->m_pblk + block_in_file - map->m_lblk;
		SetPageMappedToDisk(page);

		if (!PageUptodate(page) && (!PageSwapCache(page) &&
					!cleancache_get_page(page))) {
			SetPageUptodate(page);
			goto confused;
		}

		if (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,
						DATA_GENERIC_ENHANCE_READ)) {
			ret = -EFSCORRUPTED;
			goto out;
		}
	} else {
zero_out:
		zero_user_segment(page, 0, PAGE_SIZE);
		if (!PageUptodate(page))
			SetPageUptodate(page);
		unlock_page(page);
		goto out;
	}

	/*
	 * This page will go to BIO.  Do we need to send this
	 * BIO off first?
	 */
	if (bio && (*last_block_in_bio != block_nr - 1 ||
		!__same_bdev(F2FS_I_SB(inode), block_nr, bio))) {
submit_and_realloc:
		__submit_bio(F2FS_I_SB(inode), bio, DATA);
		bio = NULL;
	}
	if (bio == NULL) {
		bio = f2fs_grab_read_bio(inode, block_nr, nr_pages,
				is_readahead ? REQ_RAHEAD : 0);
		if (IS_ERR(bio)) {
			ret = PTR_ERR(bio);
			bio = NULL;
			goto out;
		}
	}

	/*
	 * If the page is under writeback, we need to wait for
	 * its completion to see the correct decrypted data.
	 */
	f2fs_wait_on_block_writeback(inode, block_nr);

	if (bio_add_page(bio, page, blocksize, 0) < blocksize)
		goto submit_and_realloc;

	inc_page_count(F2FS_I_SB(inode), F2FS_RD_DATA);
	ClearPageError(page);
	*last_block_in_bio = block_nr;
	goto out;
confused:
	if (bio) {
		__submit_bio(F2FS_I_SB(inode), bio, DATA);
		bio = NULL;
	}
	unlock_page(page);
out:
	*bio_ret = bio;
	return ret;
}","static int f2fs_read_single_page(struct inode *inode, struct page *page,
					unsigned VAR_0,
					struct f2fs_map_blocks *VAR_1,
					struct bio **VAR_2,
					sector_t *VAR_3,
					bool VAR_4)
{
	struct bio *bio = *VAR_2;
	const unsigned VAR_5 = inode->i_blkbits;
	const unsigned VAR_6 = 1 << VAR_5;
	sector_t VAR_7;
	sector_t VAR_8;
	sector_t VAR_9;
	sector_t VAR_10;
	int VAR_11 = 0;

	VAR_7 = (sector_t)page_index(page);
	VAR_8 = VAR_7 + VAR_0;
	VAR_9 = (i_size_read(inode) + VAR_6 - 1) >>
							VAR_5;
	if (VAR_8 > VAR_9)
		VAR_8 = VAR_9;

	/* COMMENT_0 */
	if (VAR_7 >= VAR_8)
		goto zero_out;
	/* COMMENT_1 */
                                               
    
	if ((VAR_1->m_flags & VAR_12) &&
			VAR_7 > VAR_1->m_lblk &&
			VAR_7 < (VAR_1->m_lblk + VAR_1->m_len))
		goto got_it;

	/* COMMENT_4 */
                                                     
                        
    
	VAR_1->m_lblk = VAR_7;
	VAR_1->m_len = VAR_8 - VAR_7;

	VAR_11 = f2fs_map_blocks(inode, VAR_1, 0, VAR_13);
	if (VAR_11)
		goto out;
got_it:
	if ((VAR_1->m_flags & VAR_12)) {
		VAR_10 = VAR_1->m_pblk + VAR_7 - VAR_1->m_lblk;
		SetPageMappedToDisk(page);

		if (!PageUptodate(page) && (!PageSwapCache(page) &&
					!cleancache_get_page(page))) {
			SetPageUptodate(page);
			goto confused;
		}

		if (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), VAR_10,
						VAR_14)) {
			VAR_11 = -VAR_15;
			goto out;
		}
	} else {
zero_out:
		zero_user_segment(page, 0, VAR_16);
		if (!PageUptodate(page))
			SetPageUptodate(page);
		unlock_page(page);
		goto out;
	}

	/* COMMENT_8 */
                                                      
                  
    
	if (bio && (*VAR_3 != VAR_10 - 1 ||
		!__same_bdev(F2FS_I_SB(inode), VAR_10, bio))) {
submit_and_realloc:
		__submit_bio(F2FS_I_SB(inode), bio, VAR_17);
		bio = NULL;
	}
	if (bio == NULL) {
		bio = f2fs_grab_read_bio(inode, VAR_10, VAR_0,
				VAR_4 ? VAR_18 : 0);
		if (IS_ERR(bio)) {
			VAR_11 = PTR_ERR(bio);
			bio = NULL;
			goto out;
		}
	}

	/* COMMENT_12 */
                                                       
                                                     
    
	f2fs_wait_on_block_writeback(inode, VAR_10);

	if (bio_add_page(bio, page, VAR_6, 0) < VAR_6)
		goto submit_and_realloc;

	inc_page_count(F2FS_I_SB(inode), VAR_19);
	ClearPageError(page);
	*VAR_3 = VAR_10;
	goto out;
confused:
	if (bio) {
		__submit_bio(F2FS_I_SB(inode), bio, VAR_17);
		bio = NULL;
	}
	unlock_page(page);
out:
	*VAR_2 = bio;
	return VAR_11;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -14,7 +14,7 @@
 	sector_t block_nr;
 	int ret = 0;
 
-	block_in_file = (sector_t)page->index;
+	block_in_file = (sector_t)page_index(page);
 	last_block = block_in_file + nr_pages;
 	last_block_in_file = (i_size_read(inode) + blocksize - 1) >>
 							blkbits;
@@ -47,7 +47,8 @@
 		block_nr = map->m_pblk + block_in_file - map->m_lblk;
 		SetPageMappedToDisk(page);
 
-		if (!PageUptodate(page) && !cleancache_get_page(page)) {
+		if (!PageUptodate(page) && (!PageSwapCache(page) &&
+					!cleancache_get_page(page))) {
 			SetPageUptodate(page);
 			goto confused;
 		}","{'deleted_lines': ['\tblock_in_file = (sector_t)page->index;', '\t\tif (!PageUptodate(page) && !cleancache_get_page(page)) {'], 'added_lines': ['\tblock_in_file = (sector_t)page_index(page);', '\t\tif (!PageUptodate(page) && (!PageSwapCache(page) &&', '\t\t\t\t\t!cleancache_get_page(page))) {']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,include/trace/events/f2fs.h,f2fs_force_buffered_io,"static inline bool f2fs_force_buffered_io(struct inode *inode,
struct kiocb *iocb, struct iov_iter *iter)
{
struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
int rw = iov_iter_rw(iter);
if (f2fs_post_read_required(inode))
return true;
if (f2fs_is_multi_device(sbi))
return true;
if (f2fs_sb_has_blkzoned(sbi))
return true;
if (test_opt(sbi, LFS) && (rw == WRITE) &&
block_unaligned_IO(inode, iocb, iter))
return true;
if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))
return true;
return false;
}","static inline bool f2fs_force_buffered_io(struct inode *inode,
struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
struct f2fs_sb_info *VAR_2 = F2FS_I_SB(inode);
int VAR_3 = iov_iter_rw(VAR_1);
if (f2fs_post_read_required(inode))
return true;
if (f2fs_is_multi_device(VAR_2))
return true;
if (f2fs_sb_has_blkzoned(VAR_2))
return true;
if (test_opt(VAR_2, VAR_4) && (VAR_3 == VAR_5) &&
block_unaligned_IO(inode, VAR_0, VAR_1))
return true;
if (is_sbi_flag_set(F2FS_I_SB(inode), VAR_6))
return true;
return false;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/before/1.json,"static inline bool f2fs_force_buffered_io(struct inode *inode,
				struct kiocb *iocb, struct iov_iter *iter)
{
	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
	int rw = iov_iter_rw(iter);

	if (f2fs_post_read_required(inode))
		return true;
	if (f2fs_is_multi_device(sbi))
		return true;
	/*
	 * for blkzoned device, fallback direct IO to buffered IO, so
	 * all IOs can be serialized by log-structured write.
	 */
	if (f2fs_sb_has_blkzoned(sbi))
		return true;
	if (test_opt(sbi, LFS) && (rw == WRITE) &&
				block_unaligned_IO(inode, iocb, iter))
		return true;
	if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&
					!(inode->i_flags & S_SWAPFILE))
		return true;

	return false;
}","static inline bool f2fs_force_buffered_io(struct inode *inode,
				struct kiocb *VAR_0, struct iov_iter *VAR_1)
{
	struct f2fs_sb_info *VAR_2 = F2FS_I_SB(inode);
	int VAR_3 = iov_iter_rw(VAR_1);

	if (f2fs_post_read_required(inode))
		return true;
	if (f2fs_is_multi_device(VAR_2))
		return true;
	/* COMMENT_0 */
                                                              
                                                      
    
	if (f2fs_sb_has_blkzoned(VAR_2))
		return true;
	if (test_opt(VAR_2, VAR_4) && (VAR_3 == VAR_5) &&
				block_unaligned_IO(inode, VAR_0, VAR_1))
		return true;
	if (is_sbi_flag_set(F2FS_I_SB(inode), VAR_6) &&
					!(inode->i_flags & VAR_7))
		return true;

	return false;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -17,7 +17,8 @@
 	if (test_opt(sbi, LFS) && (rw == WRITE) &&
 				block_unaligned_IO(inode, iocb, iter))
 		return true;
-	if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))
+	if (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&
+					!(inode->i_flags & S_SWAPFILE))
 		return true;
 
 	return false;","{'deleted_lines': ['\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))'], 'added_lines': ['\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&', '\t\t\t\t\t!(inode->i_flags & S_SWAPFILE))']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,fs/f2fs/data.c,__read_io_type,"static enum count_type __read_io_type(struct page *page)
{
struct address_space *mapping = page->mapping;
if (mapping) {
struct inode *inode = mapping->host;
struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
if (inode->i_ino == F2FS_META_INO(sbi))
return F2FS_RD_META;
if (inode->i_ino == F2FS_NODE_INO(sbi))
return F2FS_RD_NODE;
}
return F2FS_RD_DATA;
}","static enum count_type __read_io_type(struct page *page)
{
struct address_space *VAR_0 = page->mapping;
if (VAR_0) {
struct inode *inode = VAR_0->host;
struct f2fs_sb_info *VAR_1 = F2FS_I_SB(inode);
if (inode->i_ino == F2FS_META_INO(VAR_1))
return VAR_2;
if (inode->i_ino == F2FS_NODE_INO(VAR_1))
return VAR_3;
}
return VAR_4;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/before/4.json,"static enum count_type __read_io_type(struct page *page)
{
	struct address_space *mapping = page_file_mapping(page);

	if (mapping) {
		struct inode *inode = mapping->host;
		struct f2fs_sb_info *sbi = F2FS_I_SB(inode);

		if (inode->i_ino == F2FS_META_INO(sbi))
			return F2FS_RD_META;

		if (inode->i_ino == F2FS_NODE_INO(sbi))
			return F2FS_RD_NODE;
	}
	return F2FS_RD_DATA;
}","static enum count_type __read_io_type(struct page *page)
{
	struct address_space *VAR_0 = page_file_mapping(page);

	if (VAR_0) {
		struct inode *inode = VAR_0->host;
		struct f2fs_sb_info *VAR_1 = F2FS_I_SB(inode);

		if (inode->i_ino == F2FS_META_INO(VAR_1))
			return VAR_2;

		if (inode->i_ino == F2FS_NODE_INO(VAR_1))
			return VAR_3;
	}
	return VAR_4;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static enum count_type __read_io_type(struct page *page)
 {
-	struct address_space *mapping = page->mapping;
+	struct address_space *mapping = page_file_mapping(page);
 
 	if (mapping) {
 		struct inode *inode = mapping->host;","{'deleted_lines': ['\tstruct address_space *mapping = page->mapping;'], 'added_lines': ['\tstruct address_space *mapping = page_file_mapping(page);']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,fs/f2fs/data.c,f2fs_mpage_readpages,"static int f2fs_mpage_readpages(struct address_space *mapping,
struct list_head *pages, struct page *page,
unsigned nr_pages, bool is_readahead)
{
struct bio *bio = NULL;
sector_t last_block_in_bio = 0;
struct inode *inode = mapping->host;
struct f2fs_map_blocks map;
int ret = 0;
map.m_pblk = 0;
map.m_lblk = 0;
map.m_len = 0;
map.m_flags = 0;
map.m_next_pgofs = NULL;
map.m_next_extent = NULL;
map.m_seg_type = NO_CHECK_TYPE;
map.m_may_create = false;
for (; nr_pages; nr_pages--) {
if (pages) {
page = list_last_entry(pages, struct page, lru);
prefetchw(&page->flags);
list_del(&page->lru);
if (add_to_page_cache_lru(page, mapping,
page->index,
readahead_gfp_mask(mapping)))
goto next_page;
}
ret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,
&last_block_in_bio, is_readahead);
if (ret) {
SetPageError(page);
zero_user_segment(page, 0, PAGE_SIZE);
unlock_page(page);
}
next_page:
if (pages)
put_page(page);
}
BUG_ON(pages && !list_empty(pages));
if (bio)
__submit_bio(F2FS_I_SB(inode), bio, DATA);
return pages ? 0 : ret;
}","static int f2fs_mpage_readpages(struct address_space *VAR_0,
struct list_head *VAR_1, struct page *page,
unsigned VAR_2, bool VAR_3)
{
struct bio *bio = NULL;
sector_t VAR_4 = 0;
struct inode *inode = VAR_0->host;
struct f2fs_map_blocks VAR_5;
int VAR_6 = 0;
VAR_5.m_pblk = 0;
VAR_5.m_lblk = 0;
VAR_5.m_len = 0;
VAR_5.m_flags = 0;
VAR_5.m_next_pgofs = NULL;
VAR_5.m_next_extent = NULL;
VAR_5.m_seg_type = VAR_7;
VAR_5.m_may_create = false;
for (; VAR_2; VAR_2--) {
if (VAR_1) {
page = list_last_entry(VAR_1, struct page, VAR_8);
prefetchw(&page->flags);
list_del(&page->lru);
if (add_to_page_cache_lru(page, VAR_0,
page->index,
readahead_gfp_mask(VAR_0)))
goto next_page;
}
VAR_6 = f2fs_read_single_page(inode, page, VAR_2, &VAR_5, &bio,
&VAR_4, VAR_3);
if (VAR_6) {
SetPageError(page);
zero_user_segment(page, 0, VAR_9);
unlock_page(page);
}
next_page:
if (VAR_1)
put_page(page);
}
BUG_ON(VAR_1 && !list_empty(VAR_1));
if (bio)
__submit_bio(F2FS_I_SB(inode), bio, VAR_10);
return VAR_1 ? 0 : VAR_6;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/before/3.json,"static int f2fs_mpage_readpages(struct address_space *mapping,
			struct list_head *pages, struct page *page,
			unsigned nr_pages, bool is_readahead)
{
	struct bio *bio = NULL;
	sector_t last_block_in_bio = 0;
	struct inode *inode = mapping->host;
	struct f2fs_map_blocks map;
	int ret = 0;

	map.m_pblk = 0;
	map.m_lblk = 0;
	map.m_len = 0;
	map.m_flags = 0;
	map.m_next_pgofs = NULL;
	map.m_next_extent = NULL;
	map.m_seg_type = NO_CHECK_TYPE;
	map.m_may_create = false;

	for (; nr_pages; nr_pages--) {
		if (pages) {
			page = list_last_entry(pages, struct page, lru);

			prefetchw(&page->flags);
			list_del(&page->lru);
			if (add_to_page_cache_lru(page, mapping,
						  page_index(page),
						  readahead_gfp_mask(mapping)))
				goto next_page;
		}

		ret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,
					&last_block_in_bio, is_readahead);
		if (ret) {
			SetPageError(page);
			zero_user_segment(page, 0, PAGE_SIZE);
			unlock_page(page);
		}
next_page:
		if (pages)
			put_page(page);
	}
	BUG_ON(pages && !list_empty(pages));
	if (bio)
		__submit_bio(F2FS_I_SB(inode), bio, DATA);
	return pages ? 0 : ret;
}","static int f2fs_mpage_readpages(struct address_space *VAR_0,
			struct list_head *VAR_1, struct page *page,
			unsigned VAR_2, bool VAR_3)
{
	struct bio *bio = NULL;
	sector_t VAR_4 = 0;
	struct inode *inode = VAR_0->host;
	struct f2fs_map_blocks VAR_5;
	int VAR_6 = 0;

	VAR_5.m_pblk = 0;
	VAR_5.m_lblk = 0;
	VAR_5.m_len = 0;
	VAR_5.m_flags = 0;
	VAR_5.m_next_pgofs = NULL;
	VAR_5.m_next_extent = NULL;
	VAR_5.m_seg_type = VAR_7;
	VAR_5.m_may_create = false;

	for (; VAR_2; VAR_2--) {
		if (VAR_1) {
			page = list_last_entry(VAR_1, struct page, VAR_8);

			prefetchw(&page->flags);
			list_del(&page->lru);
			if (add_to_page_cache_lru(page, VAR_0,
						  page_index(page),
						  readahead_gfp_mask(VAR_0)))
				goto next_page;
		}

		VAR_6 = f2fs_read_single_page(inode, page, VAR_2, &VAR_5, &bio,
					&VAR_4, VAR_3);
		if (VAR_6) {
			SetPageError(page);
			zero_user_segment(page, 0, VAR_9);
			unlock_page(page);
		}
next_page:
		if (VAR_1)
			put_page(page);
	}
	BUG_ON(VAR_1 && !list_empty(VAR_1));
	if (bio)
		__submit_bio(F2FS_I_SB(inode), bio, VAR_10);
	return VAR_1 ? 0 : VAR_6;
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/data.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -24,7 +24,7 @@
 			prefetchw(&page->flags);
 			list_del(&page->lru);
 			if (add_to_page_cache_lru(page, mapping,
-						  page->index,
+						  page_index(page),
 						  readahead_gfp_mask(mapping)))
 				goto next_page;
 		}","{'deleted_lines': ['\t\t\t\t\t\t  page->index,'], 'added_lines': ['\t\t\t\t\t\t  page_index(page),']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,fs/f2fs/f2fs.h,F2FS_P_SB,"static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
return F2FS_M_SB(page->mapping);
}","static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
return F2FS_M_SB(page->mapping);
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/before/0.json,"static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
	return F2FS_M_SB(page_file_mapping(page));
}","static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
	return F2FS_M_SB(page_file_mapping(page));
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
 static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
 {
-	return F2FS_M_SB(page->mapping);
+	return F2FS_M_SB(page_file_mapping(page));
 }","{'deleted_lines': ['\treturn F2FS_M_SB(page->mapping);'], 'added_lines': ['\treturn F2FS_M_SB(page_file_mapping(page));']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2019-19815,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0.0,torvalds/linux,"f2fs: support swap file w/ DIO

Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,include/trace/events/f2fs.h,F2FS_P_SB,"static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
return F2FS_M_SB(page->mapping);
}","static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
return F2FS_M_SB(page->mapping);
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/before/0.json,"static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
	return F2FS_M_SB(page_file_mapping(page));
}","static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
{
	return F2FS_M_SB(page_file_mapping(page));
}",torvalds/linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6/f2fs.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
 static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)
 {
-	return F2FS_M_SB(page->mapping);
+	return F2FS_M_SB(page_file_mapping(page));
 }","{'deleted_lines': ['\treturn F2FS_M_SB(page->mapping);'], 'added_lines': ['\treturn F2FS_M_SB(page_file_mapping(page));']}",True,"In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause a NULL pointer dereference in f2fs_recover_fsync_data in fs/f2fs/recovery.c. This is related to F2FS_P_SB in fs/f2fs/f2fs.h.",5.5,MEDIUM,1,test,2019-07-02T02:15:29Z,2
CVE-2020-19695,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1.0,nginx/njs,"Fixed Array.prototype.slice() for primitive types.

This closes #188 issue on Github.",e6263dd0086779138aa3ab5fbac9b6b012639b0c,https://github.com/nginx/njs/commit/e6263dd0086779138aa3ab5fbac9b6b012639b0c,njs/njs_array.c,njs_array_prototype_slice_copy,"static njs_ret_t
njs_array_prototype_slice_copy(njs_vm_t *vm, njs_value_t *this,
int64_t start, int64_t length)
{
size_t             size;
u_char             *dst;
uint32_t           n;
njs_ret_t          ret;
njs_array_t        *array;
njs_value_t        *value, name;
const u_char       *src, *end;
njs_slice_prop_t   string_slice;
njs_string_prop_t  string;
array = njs_array_alloc(vm, length, NJS_ARRAY_SPARE);
if (nxt_slow_path(array == NULL)) {
return NXT_ERROR;
}
njs_set_array(&vm->retval, array);
if (length != 0) {
n = 0;
if (nxt_fast_path(njs_is_array(this))) {
value = njs_array_start(this);
do {
array->start[n++] = value[start++];
length--;
} while (length != 0);
} else if (njs_is_string(this) || this->type == NJS_OBJECT_STRING) {
if (this->type == NJS_OBJECT_STRING) {
this = &this->data.u.object_value->value;
}
string_slice.start = start;
string_slice.length = length;
string_slice.string_length = njs_string_prop(&string, this);
njs_string_slice_string_prop(&string, &string, &string_slice);
src = string.start;
end = src + string.size;
if (string.length == 0) {
do {
value = &array->start[n++];
dst = njs_string_short_start(value);
*dst = *src++;
njs_string_short_set(value, 1, 0);
length--;
} while (length != 0);
} else {
do {
value = &array->start[n++];
dst = njs_string_short_start(value);
dst = nxt_utf8_copy(dst, &src, end);
size = dst - njs_string_short_start(value);
njs_string_short_set(value, size, 1);
length--;
} while (length != 0);
}
} else if (njs_is_object(this)) {
do {
njs_uint32_to_string(&name, start++);
value = &array->start[n++];
ret = njs_value_property(vm, this, &name, value, 0);
if (ret != NXT_OK) {
*value = njs_value_invalid;
}
length--;
} while (length != 0);
}
}
return NXT_OK;
}","static njs_ret_t
njs_array_prototype_slice_copy(njs_vm_t *VAR_0, njs_value_t *VAR_1,
int64_t VAR_2, int64_t VAR_3)
{
size_t             VAR_4;
u_char             *VAR_5;
uint32_t           VAR_6;
njs_ret_t          VAR_7;
njs_array_t        *VAR_8;
njs_value_t        *VAR_9, VAR_10;
const u_char       *VAR_11, *VAR_12;
njs_slice_prop_t   VAR_13;
njs_string_prop_t  VAR_14;
VAR_8 = njs_array_alloc(VAR_0, VAR_3, VAR_15);
if (nxt_slow_path(VAR_8 == NULL)) {
return VAR_16;
}
njs_set_array(&VAR_0->retval, VAR_8);
if (VAR_3 != 0) {
VAR_6 = 0;
if (nxt_fast_path(njs_is_array(VAR_1))) {
VAR_9 = njs_array_start(VAR_1);
do {
VAR_8->start[VAR_6++] = VAR_9[VAR_2++];
VAR_3--;
} while (VAR_3 != 0);
} else if (njs_is_string(VAR_1) || VAR_1->type == VAR_17) {
if (VAR_1->type == VAR_17) {
VAR_1 = &VAR_1->data.u.object_value->value;
}
VAR_13.start = VAR_2;
VAR_13.length = VAR_3;
VAR_13.string_length = njs_string_prop(&VAR_14, VAR_1);
njs_string_slice_string_prop(&VAR_14, &VAR_14, &VAR_13);
VAR_11 = VAR_14.start;
VAR_12 = VAR_11 + VAR_14.size;
if (VAR_14.length == 0) {
do {
VAR_9 = &VAR_8->start[VAR_6++];
VAR_5 = njs_string_short_start(VAR_9);
*VAR_5 = *VAR_11++;
njs_string_short_set(VAR_9, 1, 0);
VAR_3--;
} while (VAR_3 != 0);
} else {
do {
VAR_9 = &VAR_8->start[VAR_6++];
VAR_5 = njs_string_short_start(VAR_9);
VAR_5 = nxt_utf8_copy(VAR_5, &VAR_11, VAR_12);
VAR_4 = VAR_5 - njs_string_short_start(VAR_9);
njs_string_short_set(VAR_9, VAR_4, 1);
VAR_3--;
} while (VAR_3 != 0);
}
} else if (njs_is_object(VAR_1)) {
do {
njs_uint32_to_string(&VAR_10, VAR_2++);
VAR_9 = &VAR_8->start[VAR_6++];
VAR_7 = njs_value_property(VAR_0, VAR_1, &VAR_10, VAR_9, 0);
if (VAR_7 != VAR_18) {
*VAR_9 = VAR_19;
}
VAR_3--;
} while (VAR_3 != 0);
}
}
return VAR_18;
}",nginx/njs/e6263dd0086779138aa3ab5fbac9b6b012639b0c/njs_array.c/vul/before/0.json,"static njs_ret_t
njs_array_prototype_slice_copy(njs_vm_t *vm, njs_value_t *this,
    int64_t start, int64_t length)
{
    size_t             size;
    u_char             *dst;
    uint32_t           n;
    njs_ret_t          ret;
    njs_array_t        *array;
    njs_value_t        *value, name;
    const u_char       *src, *end;
    njs_slice_prop_t   string_slice;
    njs_string_prop_t  string;

    array = njs_array_alloc(vm, length, NJS_ARRAY_SPARE);
    if (nxt_slow_path(array == NULL)) {
        return NXT_ERROR;
    }

    njs_set_array(&vm->retval, array);

    if (length != 0) {
        n = 0;

        if (nxt_fast_path(njs_is_array(this))) {
            value = njs_array_start(this);

            do {
                /* GC: retain long string and object in values[start]. */
                array->start[n++] = value[start++];
                length--;
            } while (length != 0);

        } else if (njs_is_string(this) || this->type == NJS_OBJECT_STRING) {

            if (this->type == NJS_OBJECT_STRING) {
                this = &this->data.u.object_value->value;
            }

            string_slice.start = start;
            string_slice.length = length;
            string_slice.string_length = njs_string_prop(&string, this);

            njs_string_slice_string_prop(&string, &string, &string_slice);

            src = string.start;
            end = src + string.size;

            if (string.length == 0) {
                /* Byte string. */
                do {
                    value = &array->start[n++];
                    dst = njs_string_short_start(value);
                    *dst = *src++;
                    njs_string_short_set(value, 1, 0);

                    length--;
                } while (length != 0);

            } else {
                /* UTF-8 or ASCII string. */
                do {
                    value = &array->start[n++];
                    dst = njs_string_short_start(value);
                    dst = nxt_utf8_copy(dst, &src, end);
                    size = dst - njs_string_short_start(value);
                    njs_string_short_set(value, size, 1);

                    length--;
                } while (length != 0);
            }

        } else if (njs_is_object(this)) {

            do {
                njs_uint32_to_string(&name, start++);

                value = &array->start[n++];
                ret = njs_value_property(vm, this, &name, value, 0);

                if (ret != NXT_OK) {
                    *value = njs_value_invalid;
                }

                length--;
            } while (length != 0);

        } else {

            /* Primitive types. */

            value = array->start;

            do {
                *value++ = njs_value_invalid;
                length--;
            } while (length != 0);
        }
    }

    return NXT_OK;
}","static njs_ret_t
njs_array_prototype_slice_copy(njs_vm_t *VAR_0, njs_value_t *VAR_1,
    int64_t VAR_2, int64_t VAR_3)
{
    size_t             VAR_4;
    u_char             *VAR_5;
    uint32_t           VAR_6;
    njs_ret_t          VAR_7;
    njs_array_t        *VAR_8;
    njs_value_t        *VAR_9, VAR_10;
    const u_char       *VAR_11, *VAR_12;
    njs_slice_prop_t   VAR_13;
    njs_string_prop_t  VAR_14;

    VAR_8 = njs_array_alloc(VAR_0, VAR_3, VAR_15);
    if (nxt_slow_path(VAR_8 == NULL)) {
        return VAR_16;
    }

    njs_set_array(&VAR_0->retval, VAR_8);

    if (VAR_3 != 0) {
        VAR_6 = 0;

        if (nxt_fast_path(njs_is_array(VAR_1))) {
            VAR_9 = njs_array_start(VAR_1);

            do {
                /* COMMENT_0 */
                VAR_8->start[VAR_6++] = VAR_9[VAR_2++];
                VAR_3--;
            } while (VAR_3 != 0);

        } else if (njs_is_string(VAR_1) || VAR_1->type == VAR_17) {

            if (VAR_1->type == VAR_17) {
                VAR_1 = &VAR_1->data.u.object_value->value;
            }

            VAR_13.start = VAR_2;
            VAR_13.length = VAR_3;
            VAR_13.string_length = njs_string_prop(&VAR_14, VAR_1);

            njs_string_slice_string_prop(&VAR_14, &VAR_14, &VAR_13);

            VAR_11 = VAR_14.start;
            VAR_12 = VAR_11 + VAR_14.size;

            if (VAR_14.length == 0) {
                /* COMMENT_1 */
                do {
                    VAR_9 = &VAR_8->start[VAR_6++];
                    VAR_5 = njs_string_short_start(VAR_9);
                    *VAR_5 = *VAR_11++;
                    njs_string_short_set(VAR_9, 1, 0);

                    VAR_3--;
                } while (VAR_3 != 0);

            } else {
                /* COMMENT_2 */
                do {
                    VAR_9 = &VAR_8->start[VAR_6++];
                    VAR_5 = njs_string_short_start(VAR_9);
                    VAR_5 = nxt_utf8_copy(VAR_5, &VAR_11, VAR_12);
                    VAR_4 = VAR_5 - njs_string_short_start(VAR_9);
                    njs_string_short_set(VAR_9, VAR_4, 1);

                    VAR_3--;
                } while (VAR_3 != 0);
            }

        } else if (njs_is_object(VAR_1)) {

            do {
                njs_uint32_to_string(&VAR_10, VAR_2++);

                VAR_9 = &VAR_8->start[VAR_6++];
                VAR_7 = njs_value_property(VAR_0, VAR_1, &VAR_10, VAR_9, 0);

                if (VAR_7 != VAR_18) {
                    *VAR_9 = VAR_19;
                }

                VAR_3--;
            } while (VAR_3 != 0);

        } else {

            /* COMMENT_3 */

            VAR_9 = VAR_8->start;

            do {
                *VAR_9++ = VAR_19;
                VAR_3--;
            } while (VAR_3 != 0);
        }
    }

    return VAR_18;
}",nginx/njs/e6263dd0086779138aa3ab5fbac9b6b012639b0c/njs_array.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -84,6 +84,17 @@
 
                 length--;
             } while (length != 0);
+
+        } else {
+
+            /* Primitive types. */
+
+            value = array->start;
+
+            do {
+                *value++ = njs_value_invalid;
+                length--;
+            } while (length != 0);
         }
     }
 ","{'deleted_lines': [], 'added_lines': ['', '        } else {', '', '            /* Primitive types. */', '', '            value = array->start;', '', '            do {', '                *value++ = njs_value_invalid;', '                length--;', '            } while (length != 0);']}",True,Buffer Overflow found in Nginx NJS allows a remote attacker to execute arbitrary code via the njs_object_property parameter of the njs/njs_vm.c function.,9.8,CRITICAL,3,test,2019-07-03T14:16:40Z,2
CVE-2019-13454,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1629,1ddcf2e4f28029a888cadef2e757509ef5047ad8,https://github.com/ImageMagick/ImageMagick/commit/1ddcf2e4f28029a888cadef2e757509ef5047ad8,MagickCore/layer.c,RemoveDuplicateLayers,"MagickExport void RemoveDuplicateLayers(Image **images,
ExceptionInfo *exception)
{
register Image
*curr,
*next;
RectangleInfo
bounds;
assert((*images) != (const Image *) NULL);
assert((*images)->signature == MagickCoreSignature);
if ((*images)->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
curr=GetFirstImageInList(*images);
for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
{
if ( curr->columns != next->columns || curr->rows != next->rows
|| curr->page.x != next->page.x || curr->page.y != next->page.y )
continue;
bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
if ( bounds.x < 0 ) {
size_t time;
time = curr->delay*1000/curr->ticks_per_second;
time += next->delay*1000/next->ticks_per_second;
next->ticks_per_second = 100L;
next->delay = time*curr->ticks_per_second/1000;
next->iterations = curr->iterations;
*images = curr;
(void) DeleteImageFromList(images);
}
}
*images = GetFirstImageInList(*images);
}","MagickExport VAR_0 RemoveDuplicateLayers(Image **VAR_1,
ExceptionInfo *VAR_2)
{
register Image
*VAR_3,
*VAR_4;
RectangleInfo
VAR_5;
assert((*VAR_1) != (const Image *) NULL);
assert((*VAR_1)->signature == VAR_6);
if ((*VAR_1)->debug != VAR_7)
(void) LogMagickEvent(VAR_8,GetMagickModule(),""%s"",(*VAR_1)->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_6);
VAR_3=GetFirstImageInList(*VAR_1);
for (; (VAR_4=GetNextImageInList(VAR_3)) != (Image *) NULL; VAR_3=VAR_4)
{
if ( VAR_3->columns != VAR_4->columns || VAR_3->rows != VAR_4->rows
|| VAR_3->page.x != VAR_4->page.x || VAR_3->page.y != VAR_4->page.y )
continue;
VAR_5=CompareImagesBounds(VAR_3,VAR_4,VAR_9,VAR_2);
if ( VAR_5.x < 0 ) {
size_t VAR_10;
VAR_10 = VAR_3->delay*1000/VAR_3->ticks_per_second;
VAR_10 += VAR_4->delay*1000/VAR_4->ticks_per_second;
VAR_4->ticks_per_second = 100L;
VAR_4->delay = VAR_10*VAR_3->ticks_per_second/1000;
VAR_4->iterations = VAR_3->iterations;
*VAR_1 = VAR_3;
(void) DeleteImageFromList(VAR_1);
}
}
*VAR_1 = GetFirstImageInList(*VAR_1);
}",,"MagickExport void RemoveDuplicateLayers(Image **images,ExceptionInfo *exception)
{
  RectangleInfo
    bounds;

  register Image
    *image,
    *next;

  assert((*images) != (const Image *) NULL);
  assert((*images)->signature == MagickCoreSignature);
  if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      (*images)->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=GetFirstImageInList(*images);
  for ( ; (next=GetNextImageInList(image)) != (Image *) NULL; image=next)
  {
    if ((image->columns != next->columns) || (image->rows != next->rows) ||
        (image->page.x != next->page.x) || (image->page.y != next->page.y))
      continue;
    bounds=CompareImagesBounds(image,next,CompareAnyLayer,exception);
    if (bounds.x < 0)
      {
        /*
          Two images are the same, merge time delays and delete one.
        */
        size_t
          time;

        time=1000*image->delay*PerceptibleReciprocal(image->ticks_per_second);
        time+=1000*next->delay*PerceptibleReciprocal(next->ticks_per_second);
        next->ticks_per_second=100L;
        next->delay=time*image->ticks_per_second/1000;
        next->iterations=image->iterations;
        *images=image;
        (void) DeleteImageFromList(images);
      }
  }
  *images=GetFirstImageInList(*images);
}","MagickExport VAR_0 RemoveDuplicateLayers(Image **VAR_1,ExceptionInfo *VAR_2)
{
  RectangleInfo
    VAR_3;

  register Image
    *VAR_4,
    *VAR_5;

  assert((*VAR_1) != (const Image *) NULL);
  assert((*VAR_1)->signature == VAR_6);
  if ((*VAR_1)->debug != VAR_7)
    (void) LogMagickEvent(VAR_8,GetMagickModule(),""%s"",
      (*VAR_1)->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_6);
  VAR_4=GetFirstImageInList(*VAR_1);
  for ( ; (VAR_5=GetNextImageInList(VAR_4)) != (Image *) NULL; VAR_4=VAR_5)
  {
    if ((VAR_4->columns != VAR_5->columns) || (VAR_4->rows != VAR_5->rows) ||
        (VAR_4->page.x != VAR_5->page.x) || (VAR_4->page.y != VAR_5->page.y))
      continue;
    VAR_3=CompareImagesBounds(VAR_4,VAR_5,VAR_9,VAR_2);
    if (VAR_3.x < 0)
      {
        /* COMMENT_0 */
                                                                    
          
        size_t
          VAR_10;

        VAR_10=1000*VAR_4->delay*PerceptibleReciprocal(VAR_4->ticks_per_second);
        VAR_10+=1000*VAR_5->delay*PerceptibleReciprocal(VAR_5->ticks_per_second);
        VAR_5->ticks_per_second=100L;
        VAR_5->delay=VAR_10*VAR_4->ticks_per_second/1000;
        VAR_5->iterations=VAR_4->iterations;
        *VAR_1=VAR_4;
        (void) DeleteImageFromList(VAR_1);
      }
  }
  *VAR_1=GetFirstImageInList(*VAR_1);
}",,"--- func_before
+++ func_after
@@ -1,40 +1,42 @@
-MagickExport void RemoveDuplicateLayers(Image **images,
-     ExceptionInfo *exception)
+MagickExport void RemoveDuplicateLayers(Image **images,ExceptionInfo *exception)
 {
-  register Image
-    *curr,
-    *next;
-
   RectangleInfo
     bounds;
+
+  register Image
+    *image,
+    *next;
 
   assert((*images) != (const Image *) NULL);
   assert((*images)->signature == MagickCoreSignature);
   if ((*images)->debug != MagickFalse)
-    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);
+    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
+      (*images)->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
+  image=GetFirstImageInList(*images);
+  for ( ; (next=GetNextImageInList(image)) != (Image *) NULL; image=next)
+  {
+    if ((image->columns != next->columns) || (image->rows != next->rows) ||
+        (image->page.x != next->page.x) || (image->page.y != next->page.y))
+      continue;
+    bounds=CompareImagesBounds(image,next,CompareAnyLayer,exception);
+    if (bounds.x < 0)
+      {
+        /*
+          Two images are the same, merge time delays and delete one.
+        */
+        size_t
+          time;
 
-  curr=GetFirstImageInList(*images);
-  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)
-  {
-    if ( curr->columns != next->columns || curr->rows != next->rows
-         || curr->page.x != next->page.x || curr->page.y != next->page.y )
-      continue;
-    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);
-    if ( bounds.x < 0 ) {
-      /*
-        the two images are the same, merge time delays and delete one.
-      */
-      size_t time;
-      time = curr->delay*1000/curr->ticks_per_second;
-      time += next->delay*1000/next->ticks_per_second;
-      next->ticks_per_second = 100L;
-      next->delay = time*curr->ticks_per_second/1000;
-      next->iterations = curr->iterations;
-      *images = curr;
-      (void) DeleteImageFromList(images);
-    }
+        time=1000*image->delay*PerceptibleReciprocal(image->ticks_per_second);
+        time+=1000*next->delay*PerceptibleReciprocal(next->ticks_per_second);
+        next->ticks_per_second=100L;
+        next->delay=time*image->ticks_per_second/1000;
+        next->iterations=image->iterations;
+        *images=image;
+        (void) DeleteImageFromList(images);
+      }
   }
-  *images = GetFirstImageInList(*images);
+  *images=GetFirstImageInList(*images);
 }","{'deleted_lines': ['MagickExport void RemoveDuplicateLayers(Image **images,', '     ExceptionInfo *exception)', '  register Image', '    *curr,', '    *next;', '', '    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",(*images)->filename);', '  curr=GetFirstImageInList(*images);', '  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)', '  {', '    if ( curr->columns != next->columns || curr->rows != next->rows', '         || curr->page.x != next->page.x || curr->page.y != next->page.y )', '      continue;', '    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);', '    if ( bounds.x < 0 ) {', '      /*', '        the two images are the same, merge time delays and delete one.', '      */', '      size_t time;', '      time = curr->delay*1000/curr->ticks_per_second;', '      time += next->delay*1000/next->ticks_per_second;', '      next->ticks_per_second = 100L;', '      next->delay = time*curr->ticks_per_second/1000;', '      next->iterations = curr->iterations;', '      *images = curr;', '      (void) DeleteImageFromList(images);', '    }', '  *images = GetFirstImageInList(*images);'], 'added_lines': ['MagickExport void RemoveDuplicateLayers(Image **images,ExceptionInfo *exception)', '', '  register Image', '    *image,', '    *next;', '    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",', '      (*images)->filename);', '  image=GetFirstImageInList(*images);', '  for ( ; (next=GetNextImageInList(image)) != (Image *) NULL; image=next)', '  {', '    if ((image->columns != next->columns) || (image->rows != next->rows) ||', '        (image->page.x != next->page.x) || (image->page.y != next->page.y))', '      continue;', '    bounds=CompareImagesBounds(image,next,CompareAnyLayer,exception);', '    if (bounds.x < 0)', '      {', '        /*', '          Two images are the same, merge time delays and delete one.', '        */', '        size_t', '          time;', '        time=1000*image->delay*PerceptibleReciprocal(image->ticks_per_second);', '        time+=1000*next->delay*PerceptibleReciprocal(next->ticks_per_second);', '        next->ticks_per_second=100L;', '        next->delay=time*image->ticks_per_second/1000;', '        next->iterations=image->iterations;', '        *images=image;', '        (void) DeleteImageFromList(images);', '      }', '  *images=GetFirstImageInList(*images);']}",True,ImageMagick 7.0.8-54 Q16 allows Division by Zero in RemoveDuplicateLayers in MagickCore/layer.c.,6.5,MEDIUM,1,test,2019-07-08T10:14:34Z,2
CVE-2017-14988,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,AcademySoftwareFoundation/openexr,specific check for bad size field in header attributes (related to #248),4c146c50e952655bc193567224c2a081c7da5e98,https://github.com/AcademySoftwareFoundation/openexr/commit/4c146c50e952655bc193567224c2a081c7da5e98,OpenEXR/IlmImf/ImfHeader.cpp,Header::readFrom,"void
Header::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int &version)
{
int attrCount = 0;
while (true)
{
char name[Name::SIZE];
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, name);
if (name[0] == 0)
{
if (attrCount == 0) _readsNothing = true;
else                _readsNothing = false;
break;
}
attrCount++;
checkIsNullTerminated (name, ""attribute name"");
char typeName[Name::SIZE];
int size;
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, typeName);
checkIsNullTerminated (typeName, ""attribute type name"");
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, size);
AttributeMap::iterator i = _map.find (name);
if (i != _map.end())
{
if (strncmp (i->second->typeName(), typeName, sizeof (typeName)))
THROW (IEX_NAMESPACE::InputExc, ""Unexpected type for image attribute ""
""\"""" << name << ""\""."");
i->second->readValueFrom (is, size, version);
}
else
{
Attribute *attr;
if (Attribute::knownType (typeName))
attr = Attribute::newAttribute (typeName);
else
attr = new OpaqueAttribute (typeName);
try
{
attr->readValueFrom (is, size, version);
_map[name] = attr;
}
catch (...)
{
delete attr;
throw;
}
}
}
}","void
Header::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &VAR_0, int &VAR_1)
{
int VAR_2 = 0;
while (true)
{
char VAR_3[Name::SIZE];
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_3);
if (VAR_3[0] == 0)
{
if (VAR_2 == 0) VAR_5 = true;
else                VAR_5 = false;
break;
}
VAR_2++;
checkIsNullTerminated (VAR_3, ""attribute name"");
char VAR_6[Name::SIZE];
int VAR_7;
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_6);
checkIsNullTerminated (VAR_6, ""attribute type name"");
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_7);
AttributeMap::iterator VAR_8 = VAR_9.find (VAR_3);
if (VAR_8 != VAR_9.end())
{
if (strncmp (VAR_8->second->typeName(), VAR_6, sizeof (VAR_6)))
THROW (IEX_NAMESPACE::InputExc, ""Unexpected type for image attribute ""
""\"""" << VAR_3 << ""\""."");
VAR_8->second->readValueFrom (VAR_0, VAR_7, VAR_1);
}
else
{
Attribute *VAR_10;
if (Attribute::knownType (VAR_6))
VAR_10 = Attribute::newAttribute (VAR_6);
else
VAR_10 = new OpaqueAttribute (VAR_6);
try
{
VAR_10->readValueFrom (VAR_0, VAR_7, VAR_1);
VAR_9[VAR_3] = VAR_10;
}
catch (...)
{
delete VAR_10;
throw;
}
}
}
}",,"void
Header::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &is, int &version)
{
    //
    // Read all attributes.
    //

    int attrCount = 0;

    while (true)
    {
	//
	// Read the name of the attribute.
	// A zero-length attribute name indicates the end of the header.
	//

	char name[Name::SIZE];
	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, name);

	if (name[0] == 0)
	{
	    if (attrCount == 0) _readsNothing = true;
	    else                _readsNothing = false;
	    break;
	}

	attrCount++;

	checkIsNullTerminated (name, ""attribute name"");

	//
	// Read the attribute type and the size of the attribute value.
	//

	char typeName[Name::SIZE];
	int size;

	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, typeName);
	checkIsNullTerminated (typeName, ""attribute type name"");
	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, size);

    if( size < 0 )
    {
        throw IEX_NAMESPACE::InputExc(""Invalid size field in header attribute"");
    }

	AttributeMap::iterator i = _map.find (name);

	if (i != _map.end())
	{
	    //
	    // The attribute already exists (for example,
	    // because it is a predefined attribute).
	    // Read the attribute's new value from the file.
	    //

	    if (strncmp (i->second->typeName(), typeName, sizeof (typeName)))
		THROW (IEX_NAMESPACE::InputExc, ""Unexpected type for image attribute ""
				      ""\"""" << name << ""\""."");

	    i->second->readValueFrom (is, size, version);
	}
	else
	{
	    //
	    // The new attribute does not exist yet.
	    // If the attribute type is of a known type,
	    // read the attribute value.  If the attribute
	    // is of an unknown type, read its value and
	    // store it as an OpaqueAttribute.
	    //

	    Attribute *attr;

	    if (Attribute::knownType (typeName))
		attr = Attribute::newAttribute (typeName);
	    else
		attr = new OpaqueAttribute (typeName);

	    try
	    {
		attr->readValueFrom (is, size, version);
		_map[name] = attr;
	    }
	    catch (...)
	    {
		delete attr;
		throw;
	    }
	}
    }
}","void
Header::readFrom (OPENEXR_IMF_INTERNAL_NAMESPACE::IStream &VAR_0, int &VAR_1)
{
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_0 */

    int VAR_2 = 0;

    while (true)
    {
	/* COMMENT_0 */
	/* COMMENT_2 */
	/* COMMENT_3 */
	/* COMMENT_0 */

	char VAR_3[Name::SIZE];
	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_3);

	if (VAR_3[0] == 0)
	{
	    if (VAR_2 == 0) VAR_5 = true;
	    else                VAR_5 = false;
	    break;
	}

	VAR_2++;

	checkIsNullTerminated (VAR_3, ""attribute name"");

	/* COMMENT_0 */
	/* COMMENT_4 */
	/* COMMENT_0 */

	char VAR_6[Name::SIZE];
	int VAR_7;

	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, Name::MAX_LENGTH, VAR_6);
	checkIsNullTerminated (VAR_6, ""attribute type name"");
	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::VAR_4 <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (VAR_0, VAR_7);

    if( VAR_7 < 0 )
    {
        throw IEX_NAMESPACE::InputExc(""Invalid size field in header attribute"");
    }

	AttributeMap::iterator VAR_8 = VAR_9.find (VAR_3);

	if (VAR_8 != VAR_9.end())
	{
	    /* COMMENT_0 */
	    /* COMMENT_5 */
	    /* COMMENT_6 */
	    /* COMMENT_7 */
	    /* COMMENT_0 */

	    if (strncmp (VAR_8->second->typeName(), VAR_6, sizeof (VAR_6)))
		THROW (IEX_NAMESPACE::InputExc, ""Unexpected type for image attribute ""
				      ""\"""" << VAR_3 << ""\""."");

	    VAR_8->second->readValueFrom (VAR_0, VAR_7, VAR_1);
	}
	else
	{
	    /* COMMENT_0 */
	    /* COMMENT_8 */
	    /* COMMENT_9 */
	    /* COMMENT_10 */
	    /* COMMENT_11 */
	    /* COMMENT_12 */
	    /* COMMENT_0 */

	    Attribute *VAR_10;

	    if (Attribute::knownType (VAR_6))
		VAR_10 = Attribute::newAttribute (VAR_6);
	    else
		VAR_10 = new OpaqueAttribute (VAR_6);

	    try
	    {
		VAR_10->readValueFrom (VAR_0, VAR_7, VAR_1);
		VAR_9[VAR_3] = VAR_10;
	    }
	    catch (...)
	    {
		delete VAR_10;
		throw;
	    }
	}
    }
}",,"--- func_before
+++ func_after
@@ -38,6 +38,11 @@
 	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, Name::MAX_LENGTH, typeName);
 	checkIsNullTerminated (typeName, ""attribute type name"");
 	OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (is, size);
+
+    if( size < 0 )
+    {
+        throw IEX_NAMESPACE::InputExc(""Invalid size field in header attribute"");
+    }
 
 	AttributeMap::iterator i = _map.find (name);
 ","{'deleted_lines': [], 'added_lines': ['', '    if( size < 0 )', '    {', '        throw IEX_NAMESPACE::InputExc(""Invalid size field in header attribute"");', '    }']}",True,Header::readfrom in IlmImf/ImfHeader.cpp in OpenEXR 2.2.0 allows remote attackers to cause a denial of service (excessive memory allocation) via a crafted file that is accessed with the ImfOpenInputFile function in IlmImf/ImfCRgbaFile.cpp. NOTE: The maintainer and multiple third parties believe that this vulnerability isn't valid,5.5,MEDIUM,1,test,2019-07-11T22:29:52Z,2
CVE-2022-32166,['CWE-125'],,,cloudbase/ovs,"flow: Avoid unsafe comparison of minimasks.

The following, run inside the OVS sandbox, caused OVS to abort when
Address Sanitizer was used:

    ovs-vsctl add-br br-int
    ovs-ofctl add-flow br-int ""table=0,cookie=0x1234,priority=10000,icmp,actions=drop""
    ovs-ofctl --strict del-flows br-int ""table=0,cookie=0x1234/-1,priority=10000""

Sample report from Address Sanitizer:

==3029==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000043260 at pc 0x7f6b09c2459b bp 0x7ffcb67e7540 sp 0x7ffcb67e6cf0
READ of size 40 at 0x603000043260 thread T0
    #0 0x7f6b09c2459a  (/lib/x86_64-linux-gnu/libasan.so.5+0xb859a)
    #1 0x565110a748a5 in minimask_equal ../lib/flow.c:3510
    #2 0x565110a9ea41 in minimatch_equal ../lib/match.c:1821
    #3 0x56511091e864 in collect_rules_strict ../ofproto/ofproto.c:4516
    #4 0x56511093d526 in delete_flow_start_strict ../ofproto/ofproto.c:5959
    #5 0x56511093d526 in ofproto_flow_mod_start ../ofproto/ofproto.c:7949
    #6 0x56511093d77b in handle_flow_mod__ ../ofproto/ofproto.c:6122
    #7 0x56511093db71 in handle_flow_mod ../ofproto/ofproto.c:6099
    #8 0x5651109407f6 in handle_single_part_openflow ../ofproto/ofproto.c:8406
    #9 0x5651109407f6 in handle_openflow ../ofproto/ofproto.c:8587
    #10 0x5651109e40da in ofconn_run ../ofproto/connmgr.c:1318
    #11 0x5651109e40da in connmgr_run ../ofproto/connmgr.c:355
    #12 0x56511092b129 in ofproto_run ../ofproto/ofproto.c:1826
    #13 0x5651108f23cd in bridge_run__ ../vswitchd/bridge.c:2965
    #14 0x565110904887 in bridge_run ../vswitchd/bridge.c:3023
    #15 0x5651108e659c in main ../vswitchd/ovs-vswitchd.c:127
    #16 0x7f6b093b709a in __libc_start_main ../csu/libc-start.c:308
    #17 0x5651108e9009 in _start (/home/blp/nicira/ovs/_build/vswitchd/ovs-vswitchd+0x11d009)

This fixes the problem, which although largely theoretical could crop up
with odd implementations of memcmp(), perhaps ones optimized in various
""clever"" ways.  All in all, it seems best to avoid the theoretical problem.

Acked-by: Dumitru Ceara <dceara@redhat.com>
Signed-off-by: Ben Pfaff <blp@ovn.org>",2ed6505555cdcb46f9b1f0329d1491b75290fc73,https://github.com/cloudbase/ovs/commit/2ed6505555cdcb46f9b1f0329d1491b75290fc73,lib/flow.c,minimask_equal,"bool
minimask_equal(const struct minimask *a, const struct minimask *b)
{
return !memcmp(a, b, sizeof *a
+ MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));
}","bool
minimask_equal(const struct minimask *VAR_0, const struct minimask *VAR_1)
{
return !memcmp(VAR_0, VAR_1, sizeof *VAR_0
+ MINIFLOW_VALUES_SIZE(miniflow_n_values(&VAR_0->masks)));
}",cloudbase/ovs/2ed6505555cdcb46f9b1f0329d1491b75290fc73/flow.c/vul/before/0.json,"bool
minimask_equal(const struct minimask *a, const struct minimask *b)
{
    /* At first glance, it might seem that this can be reasonably optimized
     * into a single memcmp() for the total size of the region.  Such an
     * optimization will work OK with most implementations of memcmp() that
     * proceed from the start of the regions to be compared to the end in
     * reasonably sized chunks.  However, memcmp() is not required to be
     * implemented that way, and an implementation that, for example, compares
     * all of the bytes in both regions without early exit when it finds a
     * difference, or one that compares, say, 64 bytes at a time, could access
     * an unmapped region of memory if minimasks 'a' and 'b' have different
     * lengths.  By first checking that the maps are the same with the first
     * memcmp(), we verify that 'a' and 'b' have the same length and therefore
     * ensure that the second memcmp() is safe. */
    return (!memcmp(a, b, sizeof *a)
            && !memcmp(a + 1, b + 1,
                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))));
}","bool
minimask_equal(const struct minimask *VAR_0, const struct minimask *VAR_1)
{
    /* COMMENT_0 */
                                                                        
                                                                           
                                                                         
                                                                        
                                                                              
                                                                          
                                                                              
                                                                           
                                                                            
                                                                              
                                                  
    return (!memcmp(VAR_0, VAR_1, sizeof *VAR_0)
            && !memcmp(VAR_0 + 1, VAR_1 + 1,
                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&VAR_0->masks))));
}",cloudbase/ovs/2ed6505555cdcb46f9b1f0329d1491b75290fc73/flow.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,19 @@
 bool
 minimask_equal(const struct minimask *a, const struct minimask *b)
 {
-    return !memcmp(a, b, sizeof *a
-                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));
+    /* At first glance, it might seem that this can be reasonably optimized
+     * into a single memcmp() for the total size of the region.  Such an
+     * optimization will work OK with most implementations of memcmp() that
+     * proceed from the start of the regions to be compared to the end in
+     * reasonably sized chunks.  However, memcmp() is not required to be
+     * implemented that way, and an implementation that, for example, compares
+     * all of the bytes in both regions without early exit when it finds a
+     * difference, or one that compares, say, 64 bytes at a time, could access
+     * an unmapped region of memory if minimasks 'a' and 'b' have different
+     * lengths.  By first checking that the maps are the same with the first
+     * memcmp(), we verify that 'a' and 'b' have the same length and therefore
+     * ensure that the second memcmp() is safe. */
+    return (!memcmp(a, b, sizeof *a)
+            && !memcmp(a + 1, b + 1,
+                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))));
 }","{'deleted_lines': ['    return !memcmp(a, b, sizeof *a', '                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));'], 'added_lines': ['    /* At first glance, it might seem that this can be reasonably optimized', '     * into a single memcmp() for the total size of the region.  Such an', '     * optimization will work OK with most implementations of memcmp() that', '     * proceed from the start of the regions to be compared to the end in', '     * reasonably sized chunks.  However, memcmp() is not required to be', '     * implemented that way, and an implementation that, for example, compares', '     * all of the bytes in both regions without early exit when it finds a', '     * difference, or one that compares, say, 64 bytes at a time, could access', ""     * an unmapped region of memory if minimasks 'a' and 'b' have different"", '     * lengths.  By first checking that the maps are the same with the first', ""     * memcmp(), we verify that 'a' and 'b' have the same length and therefore"", '     * ensure that the second memcmp() is safe. */', '    return (!memcmp(a, b, sizeof *a)', '            && !memcmp(a + 1, b + 1,', '                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))));']}",True,"In ovs versions v0.90.0 through v2.5.0 are vulnerable to heap buffer over-read in flow.c. An unsafe comparison of minimasks function could lead access to an unmapped region of memory. This vulnerability is capable of crashing the software, memory modification, and possible remote execution.",8.8,HIGH,2,test,2019-07-17T17:55:16Z,2
CVE-2020-16589,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0.0,AcademySoftwareFoundation/openexr,Fix for #494: validate tile coordinates when doing copyPixels,6bb36714528a9563dd3b92720c5063a1284b86f8,https://github.com/AcademySoftwareFoundation/openexr/commit/6bb36714528a9563dd3b92720c5063a1284b86f8,OpenEXR/IlmImf/ImfTiledInputFile.cpp,TiledInputFile::rawTileData,"void
TiledInputFile::rawTileData (int &dx, int &dy,
int &lx, int &ly,
const char *&pixelData,
int &pixelDataSize)
{
try
{
Lock lock (*_data->_streamData);
if (!isValidTile (dx, dy, lx, ly))
throw IEX_NAMESPACE::ArgExc (""Tried to read a tile outside ""
""the image file's data window."");
TileBuffer *tileBuffer = _data->getTileBuffer (0);
int old_dx=dx;
int old_dy=dy;
int old_lx=lx;
int old_ly=ly;
if(isMultiPart(version()))
{
_data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));
}
readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,
tileBuffer->buffer,
pixelDataSize);
if(isMultiPart(version()))
{
if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)
{
throw IEX_NAMESPACE::ArgExc (""rawTileData read the wrong tile"");
}
}
pixelData = tileBuffer->buffer;
}
catch (IEX_NAMESPACE::BaseExc &e)
{
REPLACE_EXC (e, ""Error reading pixel data from image ""
""file \"""" << fileName() << ""\"". "" << e.what());
throw;
}
}","void
TiledInputFile::rawTileData (int &VAR_0, int &VAR_1,
int &VAR_2, int &VAR_3,
const char *&VAR_4,
int &VAR_5)
{
try
{
Lock VAR_6 (*VAR_7->_streamData);
if (!isValidTile (VAR_0, VAR_1, VAR_2, VAR_3))
throw IEX_NAMESPACE::ArgExc (""Tried to read a tile outside ""
""the image file's data window."");
TileBuffer *VAR_8 = VAR_7->getTileBuffer (0);
int VAR_9=VAR_0;
int VAR_10=VAR_1;
int VAR_11=VAR_2;
int VAR_12=VAR_3;
if(isMultiPart(version()))
{
VAR_7->_streamData->is->seekg(VAR_7->tileOffsets(VAR_0,VAR_1,VAR_2,VAR_3));
}
readNextTileData (VAR_7->_streamData, VAR_7, VAR_0, VAR_1, VAR_2, VAR_3,
VAR_8->buffer,
VAR_5);
if(isMultiPart(version()))
{
if (VAR_9!=VAR_0 || VAR_10 !=VAR_1 || VAR_11!=VAR_2 || VAR_12!=VAR_3)
{
throw IEX_NAMESPACE::ArgExc (""rawTileData read the wrong tile"");
}
}
VAR_4 = VAR_8->buffer;
}
catch (IEX_NAMESPACE::BaseExc &VAR_13)
{
REPLACE_EXC (VAR_13, ""Error reading pixel data from image ""
""file \"""" << fileName() << ""\"". "" << VAR_13.what());
throw;
}
}",AcademySoftwareFoundation/openexr/6bb36714528a9563dd3b92720c5063a1284b86f8/ImfTiledInputFile.cpp/vul/before/0.json,"void
TiledInputFile::rawTileData (int &dx, int &dy,
			     int &lx, int &ly,
                             const char *&pixelData,
			     int &pixelDataSize)
{
    try
    {
        Lock lock (*_data->_streamData);

        if (!isValidTile (dx, dy, lx, ly))
            throw IEX_NAMESPACE::ArgExc (""Tried to read a tile outside ""
			       ""the image file's data window."");

        TileBuffer *tileBuffer = _data->getTileBuffer (0);

        //
        // if file is a multipart file, we have to seek to the required tile
        // since we don't know where the file pointer is
        //
        int old_dx=dx;
        int old_dy=dy;
        int old_lx=lx;
        int old_ly=ly;
        if(isMultiPart(version()))
        {
            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));
        }
        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,
			  tileBuffer->buffer,
                          pixelDataSize);
        if(isMultiPart(version()))
        {
            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)
            {
                throw IEX_NAMESPACE::ArgExc (""rawTileData read the wrong tile"");
            }
        }
        else
        {
             if(!isValidTile (dx, dy, lx, ly) )
             {
                 throw IEX_NAMESPACE::IoExc (""rawTileData read an invalid tile"");
             }
        }
        pixelData = tileBuffer->buffer;
    }
    catch (IEX_NAMESPACE::BaseExc &e)
    {
        REPLACE_EXC (e, ""Error reading pixel data from image ""
                     ""file \"""" << fileName() << ""\"". "" << e.what());
        throw;
    }
}","void
TiledInputFile::rawTileData (int &VAR_0, int &VAR_1,
			     int &VAR_2, int &VAR_3,
                             const char *&VAR_4,
			     int &VAR_5)
{
    try
    {
        Lock VAR_6 (*VAR_7->_streamData);

        if (!isValidTile (VAR_0, VAR_1, VAR_2, VAR_3))
            throw IEX_NAMESPACE::ArgExc (""Tried to read a tile outside ""
			       ""the image file's data window."");

        TileBuffer *VAR_8 = VAR_7->getTileBuffer (0);

        /* COMMENT_0 */
        /* COMMENT_1 */
        /* COMMENT_2 */
        /* COMMENT_0 */
        int VAR_9=VAR_0;
        int VAR_10=VAR_1;
        int VAR_11=VAR_2;
        int VAR_12=VAR_3;
        if(isMultiPart(version()))
        {
            VAR_7->_streamData->is->seekg(VAR_7->tileOffsets(VAR_0,VAR_1,VAR_2,VAR_3));
        }
        readNextTileData (VAR_7->_streamData, VAR_7, VAR_0, VAR_1, VAR_2, VAR_3,
			  VAR_8->buffer,
                          VAR_5);
        if(isMultiPart(version()))
        {
            if (VAR_9!=VAR_0 || VAR_10 !=VAR_1 || VAR_11!=VAR_2 || VAR_12!=VAR_3)
            {
                throw IEX_NAMESPACE::ArgExc (""rawTileData read the wrong tile"");
            }
        }
        else
        {
             if(!isValidTile (VAR_0, VAR_1, VAR_2, VAR_3) )
             {
                 throw IEX_NAMESPACE::IoExc (""rawTileData read an invalid tile"");
             }
        }
        VAR_4 = VAR_8->buffer;
    }
    catch (IEX_NAMESPACE::BaseExc &VAR_13)
    {
        REPLACE_EXC (VAR_13, ""Error reading pixel data from image ""
                     ""file \"""" << fileName() << ""\"". "" << VAR_13.what());
        throw;
    }
}",AcademySoftwareFoundation/openexr/6bb36714528a9563dd3b92720c5063a1284b86f8/ImfTiledInputFile.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,6 +36,13 @@
                 throw IEX_NAMESPACE::ArgExc (""rawTileData read the wrong tile"");
             }
         }
+        else
+        {
+             if(!isValidTile (dx, dy, lx, ly) )
+             {
+                 throw IEX_NAMESPACE::IoExc (""rawTileData read an invalid tile"");
+             }
+        }
         pixelData = tileBuffer->buffer;
     }
     catch (IEX_NAMESPACE::BaseExc &e)","{'deleted_lines': [], 'added_lines': ['        else', '        {', '             if(!isValidTile (dx, dy, lx, ly) )', '             {', '                 throw IEX_NAMESPACE::IoExc (""rawTileData read an invalid tile"");', '             }', '        }']}",True,A head-based buffer overflow exists in Academy Software Foundation OpenEXR 2.3.0 in writeTileData in ImfTiledOutputFile.cpp that can cause a denial of service via a crafted EXR file.,5.5,MEDIUM,1,test,2019-07-25T07:23:37Z,2
CVE-2019-14975,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0.0,ArtifexSoftware/mupdf,Bug 701292: Fix test for missing/empty string.,97096297d409ec6f206298444ba00719607e8ba8,https://github.com/ArtifexSoftware/mupdf/commit/97096297d409ec6f206298444ba00719607e8ba8,source/pdf/pdf-op-filter.c,pdf_filter_BDC,"static void
pdf_filter_BDC(fz_context *ctx, pdf_processor *proc, const char *tag, pdf_obj *raw, pdf_obj *cooked)
{
pdf_filter_processor *p = (pdf_filter_processor*)proc;
tag_record *bdc = fz_malloc_struct(ctx, tag_record);
pdf_obj *mcid;
fz_try(ctx)
{
bdc->bdc = 1;
bdc->tag = fz_strdup(ctx, tag);
bdc->raw = pdf_keep_obj(ctx, raw);
bdc->cooked = pdf_keep_obj(ctx, raw);
}
fz_catch(ctx)
{
fz_free(ctx, bdc->tag);
pdf_drop_obj(ctx, bdc->raw);
pdf_drop_obj(ctx, bdc->cooked);
fz_free(ctx, bdc);
fz_rethrow(ctx);
}
bdc->prev = p->pending_tags;
p->pending_tags = bdc;
mcid = pdf_dict_get(ctx, cooked, PDF_NAME(MCID));
if (!pdf_is_number(ctx, mcid))
return;
bdc->mcid_num = pdf_to_int(ctx, mcid);
bdc->mcid_obj = pdf_keep_obj(ctx, pdf_array_get(ctx, p->structarray, bdc->mcid_num));
bdc->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(Alt)));
bdc->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(ActualText)));
}","static void
pdf_filter_BDC(fz_context *VAR_0, pdf_processor *VAR_1, const char *VAR_2, pdf_obj *VAR_3, pdf_obj *VAR_4)
{
pdf_filter_processor *VAR_5 = (pdf_filter_processor*)VAR_1;
tag_record *VAR_6 = fz_malloc_struct(VAR_0, tag_record);
pdf_obj *VAR_7;
fz_try(VAR_0)
{
VAR_6->bdc = 1;
VAR_6->tag = fz_strdup(VAR_0, VAR_2);
VAR_6->raw = pdf_keep_obj(VAR_0, VAR_3);
VAR_6->cooked = pdf_keep_obj(VAR_0, VAR_3);
}
fz_catch(VAR_0)
{
fz_free(VAR_0, VAR_6->tag);
pdf_drop_obj(VAR_0, VAR_6->raw);
pdf_drop_obj(VAR_0, VAR_6->cooked);
fz_free(VAR_0, VAR_6);
fz_rethrow(VAR_0);
}
VAR_6->prev = VAR_5->pending_tags;
VAR_5->pending_tags = VAR_6;
VAR_7 = pdf_dict_get(VAR_0, VAR_4, PDF_NAME(VAR_8));
if (!pdf_is_number(VAR_0, VAR_7))
return;
VAR_6->mcid_num = pdf_to_int(VAR_0, VAR_7);
VAR_6->mcid_obj = pdf_keep_obj(VAR_0, pdf_array_get(VAR_0, VAR_5->structarray, VAR_6->mcid_num));
VAR_6->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(VAR_0, pdf_dict_get(VAR_0, VAR_6->mcid_obj, PDF_NAME(VAR_9)));
VAR_6->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(VAR_0, pdf_dict_get(VAR_0, VAR_6->mcid_obj, PDF_NAME(VAR_10)));
}",ArtifexSoftware/mupdf/97096297d409ec6f206298444ba00719607e8ba8/pdf-op-filter.c/vul/before/1.json,"static void
pdf_filter_BDC(fz_context *ctx, pdf_processor *proc, const char *tag, pdf_obj *raw, pdf_obj *cooked)
{
	/* Create a tag, and push it onto pending_tags. If it gets
	 * flushed to the stream, it'll be moved from there onto
	 * current_tags. */
	pdf_filter_processor *p = (pdf_filter_processor*)proc;
	tag_record *bdc = fz_malloc_struct(ctx, tag_record);
	pdf_obj *mcid;
	pdf_obj *str;

	fz_try(ctx)
	{
		bdc->bdc = 1;
		bdc->tag = fz_strdup(ctx, tag);
		bdc->raw = pdf_keep_obj(ctx, raw);
		bdc->cooked = pdf_keep_obj(ctx, raw);
	}
	fz_catch(ctx)
	{
		fz_free(ctx, bdc->tag);
		pdf_drop_obj(ctx, bdc->raw);
		pdf_drop_obj(ctx, bdc->cooked);
		fz_free(ctx, bdc);
		fz_rethrow(ctx);
	}
	bdc->prev = p->pending_tags;
	p->pending_tags = bdc;

	/* Look to see if this has an mcid object */
	mcid = pdf_dict_get(ctx, cooked, PDF_NAME(MCID));
	if (!pdf_is_number(ctx, mcid))
		return;
	bdc->mcid_num = pdf_to_int(ctx, mcid);
	bdc->mcid_obj = pdf_keep_obj(ctx, pdf_array_get(ctx, p->structarray, bdc->mcid_num));
	str = pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(Alt));
	if (str)
		bdc->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, str);
	str = pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(ActualText));
	if (str)
		bdc->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, str);
}","static void
pdf_filter_BDC(fz_context *VAR_0, pdf_processor *VAR_1, const char *VAR_2, pdf_obj *VAR_3, pdf_obj *VAR_4)
{
	/* COMMENT_0 */
                                                         
                    
	pdf_filter_processor *VAR_5 = (pdf_filter_processor*)VAR_1;
	tag_record *VAR_6 = fz_malloc_struct(VAR_0, tag_record);
	pdf_obj *VAR_7;
	pdf_obj *VAR_8;

	fz_try(VAR_0)
	{
		VAR_6->bdc = 1;
		VAR_6->tag = fz_strdup(VAR_0, VAR_2);
		VAR_6->raw = pdf_keep_obj(VAR_0, VAR_3);
		VAR_6->cooked = pdf_keep_obj(VAR_0, VAR_3);
	}
	fz_catch(VAR_0)
	{
		fz_free(VAR_0, VAR_6->tag);
		pdf_drop_obj(VAR_0, VAR_6->raw);
		pdf_drop_obj(VAR_0, VAR_6->cooked);
		fz_free(VAR_0, VAR_6);
		fz_rethrow(VAR_0);
	}
	VAR_6->prev = VAR_5->pending_tags;
	VAR_5->pending_tags = VAR_6;

	/* COMMENT_3 */
	VAR_7 = pdf_dict_get(VAR_0, VAR_4, PDF_NAME(VAR_9));
	if (!pdf_is_number(VAR_0, VAR_7))
		return;
	VAR_6->mcid_num = pdf_to_int(VAR_0, VAR_7);
	VAR_6->mcid_obj = pdf_keep_obj(VAR_0, pdf_array_get(VAR_0, VAR_5->structarray, VAR_6->mcid_num));
	VAR_8 = pdf_dict_get(VAR_0, VAR_6->mcid_obj, PDF_NAME(VAR_10));
	if (VAR_8)
		VAR_6->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(VAR_0, VAR_8);
	VAR_8 = pdf_dict_get(VAR_0, VAR_6->mcid_obj, PDF_NAME(VAR_11));
	if (VAR_8)
		VAR_6->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(VAR_0, VAR_8);
}",ArtifexSoftware/mupdf/97096297d409ec6f206298444ba00719607e8ba8/pdf-op-filter.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,6 +7,7 @@
 	pdf_filter_processor *p = (pdf_filter_processor*)proc;
 	tag_record *bdc = fz_malloc_struct(ctx, tag_record);
 	pdf_obj *mcid;
+	pdf_obj *str;
 
 	fz_try(ctx)
 	{
@@ -32,6 +33,10 @@
 		return;
 	bdc->mcid_num = pdf_to_int(ctx, mcid);
 	bdc->mcid_obj = pdf_keep_obj(ctx, pdf_array_get(ctx, p->structarray, bdc->mcid_num));
-	bdc->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(Alt)));
-	bdc->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(ActualText)));
+	str = pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(Alt));
+	if (str)
+		bdc->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, str);
+	str = pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(ActualText));
+	if (str)
+		bdc->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, str);
 }","{'deleted_lines': ['\tbdc->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(Alt)));', '\tbdc->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(ActualText)));'], 'added_lines': ['\tpdf_obj *str;', '\tstr = pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(Alt));', '\tif (str)', '\t\tbdc->alt.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, str);', '\tstr = pdf_dict_get(ctx, bdc->mcid_obj, PDF_NAME(ActualText));', '\tif (str)', '\t\tbdc->actualtext.utf8 = pdf_new_utf8_from_pdf_string_obj(ctx, str);']}",True,Artifex MuPDF before 1.16.0 has a heap-based buffer over-read in fz_chartorune in fitz/string.c because pdf/pdf-op-filter.c does not check for a missing string.,7.1,HIGH,2,test,2019-07-25T10:10:01Z,2
CVE-2019-14975,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0.0,ArtifexSoftware/mupdf,Bug 701292: Fix test for missing/empty string.,97096297d409ec6f206298444ba00719607e8ba8,https://github.com/ArtifexSoftware/mupdf/commit/97096297d409ec6f206298444ba00719607e8ba8,source/pdf/pdf-op-filter.c,walk_string,"static void
walk_string(fz_context *ctx, int uni, int remove, editable_str *str)
{
int rune;
if (str->utf8 == NULL)
return;
do
{
char *s = &str->utf8[str->pos];
size_t len;
int n = fz_chartorune(&rune, s);
if (rune == uni)
{
str->pos += n;
}
else if (uni == 32) {
break;
}
else if (rune == 32) {
}
else
{
str->pos = -1;
break;
}
if (remove)
{
len = strlen(s+n);
memmove(s, s+n, len+1);
str->edited = 1;
}
}
while (rune != uni);
}","static void
walk_string(fz_context *VAR_0, int VAR_1, int VAR_2, editable_str *VAR_3)
{
int VAR_4;
if (VAR_3->utf8 == NULL)
return;
do
{
char *VAR_5 = &VAR_3->utf8[VAR_3->pos];
size_t VAR_6;
int VAR_7 = fz_chartorune(&VAR_4, VAR_5);
if (VAR_4 == VAR_1)
{
VAR_3->pos += VAR_7;
}
else if (VAR_1 == 32) {
break;
}
else if (VAR_4 == 32) {
}
else
{
VAR_3->pos = -1;
break;
}
if (VAR_2)
{
VAR_6 = strlen(VAR_5+VAR_7);
memmove(VAR_5, VAR_5+VAR_7, VAR_6+1);
VAR_3->edited = 1;
}
}
while (VAR_4 != VAR_1);
}",ArtifexSoftware/mupdf/97096297d409ec6f206298444ba00719607e8ba8/pdf-op-filter.c/vul/before/0.json,"static void
walk_string(fz_context *ctx, int uni, int remove, editable_str *str)
{
	int rune;

	if (str->utf8 == NULL || str->pos == -1)
		return;

	do
	{
		char *s = &str->utf8[str->pos];
		size_t len;
		int n = fz_chartorune(&rune, s);
		if (rune == uni)
		{
			/* Match. Skip over that one. */
			str->pos += n;
		}
		else if (uni == 32) {
			/* We don't care if we're given whitespace
			 * and it doesn't match the string. Don't
			 * skip forward. Nothing to remove. */
			break;
		}
		else if (rune == 32) {
			/* The string has a whitespace, and we
			 * don't match it; that's forgivable as
			 * PDF often misses out spaces. Remove this
			 * if we are removing stuff. */
		}
		else
		{
			/* Mismatch. No point in tracking through any more. */
			str->pos = -1;
			break;
		}
		if (remove)
		{
			len = strlen(s+n);
			memmove(s, s+n, len+1);
			str->edited = 1;
		}
	}
	while (rune != uni);
}","static void
walk_string(fz_context *VAR_0, int VAR_1, int VAR_2, editable_str *VAR_3)
{
	int VAR_4;

	if (VAR_3->utf8 == NULL || VAR_3->pos == -1)
		return;

	do
	{
		char *VAR_5 = &VAR_3->utf8[VAR_3->pos];
		size_t VAR_6;
		int VAR_7 = fz_chartorune(&VAR_4, VAR_5);
		if (VAR_4 == VAR_1)
		{
			/* COMMENT_0 */
			VAR_3->pos += VAR_7;
		}
		else if (VAR_1 == 32) {
			/* COMMENT_1 */
                                            
                                         
			break;
		}
		else if (VAR_4 == 32) {
			/* COMMENT_4 */
                                          
                                              
                                  
		}
		else
		{
			/* COMMENT_8 */
			VAR_3->pos = -1;
			break;
		}
		if (VAR_2)
		{
			VAR_6 = strlen(VAR_5+VAR_7);
			memmove(VAR_5, VAR_5+VAR_7, VAR_6+1);
			VAR_3->edited = 1;
		}
	}
	while (VAR_4 != VAR_1);
}",ArtifexSoftware/mupdf/97096297d409ec6f206298444ba00719607e8ba8/pdf-op-filter.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
 	int rune;
 
-	if (str->utf8 == NULL)
+	if (str->utf8 == NULL || str->pos == -1)
 		return;
 
 	do","{'deleted_lines': ['\tif (str->utf8 == NULL)'], 'added_lines': ['\tif (str->utf8 == NULL || str->pos == -1)']}",True,Artifex MuPDF before 1.16.0 has a heap-based buffer over-read in fz_chartorune in fitz/string.c because pdf/pdf-op-filter.c does not check for a missing string.,7.1,HIGH,2,test,2019-07-25T10:10:01Z,2
CVE-2019-14975,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0.0,ArtifexSoftware/mupdf,Bug 701292: Fix test for missing/empty string.,97096297d409ec6f206298444ba00719607e8ba8,https://github.com/ArtifexSoftware/mupdf/commit/97096297d409ec6f206298444ba00719607e8ba8,source/pdf/pdf-op-filter.c,mcid_char_imp,"static void
mcid_char_imp(fz_context *ctx, pdf_filter_processor *p, tag_record *tr, int uni, int remove)
{
if (tr->mcid_obj == NULL)
return;
if (remove)
{
pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(E));
pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(T));
}
walk_string(ctx, uni, remove, &tr->alt);
walk_string(ctx, uni, remove, &tr->actualtext);
if (remove)
remove = (tr->alt.pos == -1 || tr->actualtext.pos == -1);
else if (tr->alt.pos >= 0 || tr->actualtext.pos >= 0)
{
remove = 0;
}
if (remove)
{
if (tr->actualtext.pos == -1)
pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(ActualText));
if (tr->alt.pos == -1)
pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(Alt));
pdf_drop_obj(ctx, tr->mcid_obj);
tr->mcid_obj = NULL;
fz_free(ctx, tr->alt.utf8);
tr->alt.utf8 = NULL;
fz_free(ctx, tr->actualtext.utf8);
tr->actualtext.utf8 = NULL;
}
}","static void
mcid_char_imp(fz_context *VAR_0, pdf_filter_processor *VAR_1, tag_record *VAR_2, int VAR_3, int VAR_4)
{
if (VAR_2->mcid_obj == NULL)
return;
if (VAR_4)
{
pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_5));
pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_6));
}
walk_string(VAR_0, VAR_3, VAR_4, &VAR_2->alt);
walk_string(VAR_0, VAR_3, VAR_4, &VAR_2->actualtext);
if (VAR_4)
VAR_4 = (VAR_2->alt.pos == -1 || VAR_2->actualtext.pos == -1);
else if (VAR_2->alt.pos >= 0 || VAR_2->actualtext.pos >= 0)
{
VAR_4 = 0;
}
if (VAR_4)
{
if (VAR_2->actualtext.pos == -1)
pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_7));
if (VAR_2->alt.pos == -1)
pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_8));
pdf_drop_obj(VAR_0, VAR_2->mcid_obj);
VAR_2->mcid_obj = NULL;
fz_free(VAR_0, VAR_2->alt.utf8);
VAR_2->alt.utf8 = NULL;
fz_free(VAR_0, VAR_2->actualtext.utf8);
VAR_2->actualtext.utf8 = NULL;
}
}",ArtifexSoftware/mupdf/97096297d409ec6f206298444ba00719607e8ba8/pdf-op-filter.c/vul/before/2.json,"static void
mcid_char_imp(fz_context *ctx, pdf_filter_processor *p, tag_record *tr, int uni, int remove)
{
	if (tr->mcid_obj == NULL)
		/* No object, or already deleted */
		return;

	if (remove)
	{
		/* Remove the expanded abbreviation, if there is one. */
		pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(E));
		/* Remove the structure title, if there is one. */
		pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(T));
	}

	/* Edit the Alt string */
	walk_string(ctx, uni, remove, &tr->alt);
	/* Edit the ActualText string */
	walk_string(ctx, uni, remove, &tr->actualtext);

	/* If we're removing a character, and either of the strings
	 * haven't matched up to what we were expecting, then just
	 * delete the whole string. */
	if (remove)
		remove = (tr->alt.pos == -1 || tr->actualtext.pos == -1);
	else if (tr->alt.pos >= 0 || tr->actualtext.pos >= 0)
	{
		/* The strings are making sense so far */
		remove = 0;
	}

	if (remove)
	{
		/* Anything else we have to err on the side of caution and
		 * delete everything that might leak info. */
		if (tr->actualtext.pos == -1)
			pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(ActualText));
		if (tr->alt.pos == -1)
			pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(Alt));
		pdf_drop_obj(ctx, tr->mcid_obj);
		tr->mcid_obj = NULL;
		fz_free(ctx, tr->alt.utf8);
		tr->alt.utf8 = NULL;
		fz_free(ctx, tr->actualtext.utf8);
		tr->actualtext.utf8 = NULL;
	}
}","static void
mcid_char_imp(fz_context *VAR_0, pdf_filter_processor *VAR_1, tag_record *VAR_2, int VAR_3, int VAR_4)
{
	if (VAR_2->mcid_obj == NULL)
		/* COMMENT_0 */
		return;

	if (VAR_4)
	{
		/* COMMENT_1 */
		pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_5));
		/* COMMENT_2 */
		pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_6));
	}

	/* COMMENT_3 */
	walk_string(VAR_0, VAR_3, VAR_4, &VAR_2->alt);
	/* COMMENT_4 */
	walk_string(VAR_0, VAR_3, VAR_4, &VAR_2->actualtext);

	/* COMMENT_5 */
                                                           
                               
	if (VAR_4)
		VAR_4 = (VAR_2->alt.pos == -1 || VAR_2->actualtext.pos == -1);
	else if (VAR_2->alt.pos >= 0 || VAR_2->actualtext.pos >= 0)
	{
		/* COMMENT_8 */
		VAR_4 = 0;
	}

	if (VAR_4)
	{
		/* COMMENT_9 */
                                               
		if (VAR_2->actualtext.pos == -1)
			pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_7));
		if (VAR_2->alt.pos == -1)
			pdf_dict_del(VAR_0, VAR_2->mcid_obj, PDF_NAME(VAR_8));
		pdf_drop_obj(VAR_0, VAR_2->mcid_obj);
		VAR_2->mcid_obj = NULL;
		fz_free(VAR_0, VAR_2->alt.utf8);
		VAR_2->alt.utf8 = NULL;
		fz_free(VAR_0, VAR_2->actualtext.utf8);
		VAR_2->actualtext.utf8 = NULL;
	}
}",ArtifexSoftware/mupdf/97096297d409ec6f206298444ba00719607e8ba8/pdf-op-filter.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -12,10 +12,12 @@
 		/* Remove the structure title, if there is one. */
 		pdf_dict_del(ctx, tr->mcid_obj, PDF_NAME(T));
 	}
+
 	/* Edit the Alt string */
 	walk_string(ctx, uni, remove, &tr->alt);
 	/* Edit the ActualText string */
 	walk_string(ctx, uni, remove, &tr->actualtext);
+
 	/* If we're removing a character, and either of the strings
 	 * haven't matched up to what we were expecting, then just
 	 * delete the whole string. */
@@ -26,6 +28,7 @@
 		/* The strings are making sense so far */
 		remove = 0;
 	}
+
 	if (remove)
 	{
 		/* Anything else we have to err on the side of caution and","{'deleted_lines': [], 'added_lines': ['', '', '']}",True,Artifex MuPDF before 1.16.0 has a heap-based buffer over-read in fz_chartorune in fitz/string.c because pdf/pdf-op-filter.c does not check for a missing string.,7.1,HIGH,2,test,2019-07-25T10:10:01Z,2
CVE-2019-17542,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0.0,ffmpeg,"avcodec/vqavideo: Set video size

Fixes: out of array access
Fixes: 15919/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_VQA_fuzzer-5657368257363968

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",02f909dc24b1f05cfbba75077c7707b905e63cd2,https://github.com/FFmpeg/FFmpeg/commit/02f909dc24b1f05cfbba75077c7707b905e63cd2,libavcodec/vqavideo.c,vqa_decode_init,"static av_cold int vqa_decode_init(AVCodecContext *avctx)
{
VqaContext *s = avctx->priv_data;
int i, j, codebook_index, ret;
s->avctx = avctx;
avctx->pix_fmt = AV_PIX_FMT_PAL8;
if (s->avctx->extradata_size != VQA_HEADER_SIZE) {
av_log(s->avctx, AV_LOG_ERROR, ""expected extradata size of %d\n"", VQA_HEADER_SIZE);
return AVERROR(EINVAL);
}
s->vqa_version = s->avctx->extradata[0];
switch (s->vqa_version) {
case 1:
case 2:
break;
case 3:
avpriv_report_missing_feature(avctx, ""VQA Version %d"", s->vqa_version);
return AVERROR_PATCHWELCOME;
default:
avpriv_request_sample(avctx, ""VQA Version %i"", s->vqa_version);
return AVERROR_PATCHWELCOME;
}
s->width = AV_RL16(&s->avctx->extradata[6]);
s->height = AV_RL16(&s->avctx->extradata[8]);
if ((ret = av_image_check_size(s->width, s->height, 0, avctx)) < 0) {
s->width= s->height= 0;
return ret;
}
s->vector_width = s->avctx->extradata[10];
s->vector_height = s->avctx->extradata[11];
s->partial_count = s->partial_countdown = s->avctx->extradata[13];
if ((s->vector_width != 4) ||
((s->vector_height != 2) && (s->vector_height != 4))) {
return AVERROR_INVALIDDATA;
}
if (s->width % s->vector_width || s->height % s->vector_height) {
av_log(avctx, AV_LOG_ERROR, ""Image size not multiple of block size\n"");
return AVERROR_INVALIDDATA;
}
s->codebook_size = MAX_CODEBOOK_SIZE;
s->codebook = av_malloc(s->codebook_size);
if (!s->codebook)
goto fail;
s->next_codebook_buffer = av_malloc(s->codebook_size);
if (!s->next_codebook_buffer)
goto fail;
s->decode_buffer_size = (s->width / s->vector_width) *
(s->height / s->vector_height) * 2;
s->decode_buffer = av_mallocz(s->decode_buffer_size);
if (!s->decode_buffer)
goto fail;
if (s->vector_height == 4) {
codebook_index = 0xFF00 * 16;
for (i = 0; i < 256; i++)
for (j = 0; j < 16; j++)
s->codebook[codebook_index++] = i;
} else {
codebook_index = 0xF00 * 8;
for (i = 0; i < 256; i++)
for (j = 0; j < 8; j++)
s->codebook[codebook_index++] = i;
}
s->next_codebook_buffer_index = 0;
return 0;
fail:
av_freep(&s->codebook);
av_freep(&s->next_codebook_buffer);
av_freep(&s->decode_buffer);
return AVERROR(ENOMEM);
}","static av_cold VAR_0 vqa_decode_init(AVCodecContext *VAR_1)
{
VqaContext *VAR_2 = VAR_1->priv_data;
int VAR_3, VAR_4, VAR_5, VAR_6;
VAR_2->avctx = VAR_1;
VAR_1->pix_fmt = VAR_7;
if (VAR_2->avctx->extradata_size != VAR_8) {
av_log(VAR_2->avctx, VAR_9, ""expected extradata size of %d\n"", VAR_8);
return AVERROR(VAR_10);
}
VAR_2->vqa_version = VAR_2->avctx->extradata[0];
switch (VAR_2->vqa_version) {
case 1:
case 2:
break;
case 3:
avpriv_report_missing_feature(VAR_1, ""VQA Version %d"", VAR_2->vqa_version);
return VAR_11;
default:
avpriv_request_sample(VAR_1, ""VQA Version %i"", VAR_2->vqa_version);
return VAR_11;
}
VAR_2->width = AV_RL16(&VAR_2->avctx->extradata[6]);
VAR_2->height = AV_RL16(&VAR_2->avctx->extradata[8]);
if ((VAR_6 = av_image_check_size(VAR_2->width, VAR_2->height, 0, VAR_1)) < 0) {
VAR_2->width= VAR_2->height= 0;
return VAR_6;
}
VAR_2->vector_width = VAR_2->avctx->extradata[10];
VAR_2->vector_height = VAR_2->avctx->extradata[11];
VAR_2->partial_count = VAR_2->partial_countdown = VAR_2->avctx->extradata[13];
if ((VAR_2->vector_width != 4) ||
((VAR_2->vector_height != 2) && (VAR_2->vector_height != 4))) {
return VAR_12;
}
if (VAR_2->width % VAR_2->vector_width || VAR_2->height % VAR_2->vector_height) {
av_log(VAR_1, VAR_9, ""Image size not multiple of block size\n"");
return VAR_12;
}
VAR_2->codebook_size = VAR_13;
VAR_2->codebook = av_malloc(VAR_2->codebook_size);
if (!VAR_2->codebook)
goto fail;
VAR_2->next_codebook_buffer = av_malloc(VAR_2->codebook_size);
if (!VAR_2->next_codebook_buffer)
goto fail;
VAR_2->decode_buffer_size = (VAR_2->width / VAR_2->vector_width) *
(VAR_2->height / VAR_2->vector_height) * 2;
VAR_2->decode_buffer = av_mallocz(VAR_2->decode_buffer_size);
if (!VAR_2->decode_buffer)
goto fail;
if (VAR_2->vector_height == 4) {
VAR_5 = 0xFF00 * 16;
for (VAR_3 = 0; VAR_3 < 256; VAR_3++)
for (VAR_4 = 0; VAR_4 < 16; VAR_4++)
VAR_2->codebook[VAR_5++] = VAR_3;
} else {
VAR_5 = 0xF00 * 8;
for (VAR_3 = 0; VAR_3 < 256; VAR_3++)
for (VAR_4 = 0; VAR_4 < 8; VAR_4++)
VAR_2->codebook[VAR_5++] = VAR_3;
}
VAR_2->next_codebook_buffer_index = 0;
return 0;
fail:
av_freep(&VAR_2->codebook);
av_freep(&VAR_2->next_codebook_buffer);
av_freep(&VAR_2->decode_buffer);
return AVERROR(VAR_14);
}",,"static av_cold int vqa_decode_init(AVCodecContext *avctx)
{
    VqaContext *s = avctx->priv_data;
    int i, j, codebook_index, ret;

    s->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_PAL8;

    /* make sure the extradata made it */
    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""expected extradata size of %d\n"", VQA_HEADER_SIZE);
        return AVERROR(EINVAL);
    }

    /* load up the VQA parameters from the header */
    s->vqa_version = s->avctx->extradata[0];
    switch (s->vqa_version) {
    case 1:
    case 2:
        break;
    case 3:
        avpriv_report_missing_feature(avctx, ""VQA Version %d"", s->vqa_version);
        return AVERROR_PATCHWELCOME;
    default:
        avpriv_request_sample(avctx, ""VQA Version %i"", s->vqa_version);
        return AVERROR_PATCHWELCOME;
    }
    s->width = AV_RL16(&s->avctx->extradata[6]);
    s->height = AV_RL16(&s->avctx->extradata[8]);
    if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {
        s->width= s->height= 0;
        return ret;
    }
    s->vector_width = s->avctx->extradata[10];
    s->vector_height = s->avctx->extradata[11];
    s->partial_count = s->partial_countdown = s->avctx->extradata[13];

    /* the vector dimensions have to meet very stringent requirements */
    if ((s->vector_width != 4) ||
        ((s->vector_height != 2) && (s->vector_height != 4))) {
        /* return without further initialization */
        return AVERROR_INVALIDDATA;
    }

    if (s->width % s->vector_width || s->height % s->vector_height) {
        av_log(avctx, AV_LOG_ERROR, ""Image size not multiple of block size\n"");
        return AVERROR_INVALIDDATA;
    }

    /* allocate codebooks */
    s->codebook_size = MAX_CODEBOOK_SIZE;
    s->codebook = av_malloc(s->codebook_size);
    if (!s->codebook)
        goto fail;
    s->next_codebook_buffer = av_malloc(s->codebook_size);
    if (!s->next_codebook_buffer)
        goto fail;

    /* allocate decode buffer */
    s->decode_buffer_size = (s->width / s->vector_width) *
        (s->height / s->vector_height) * 2;
    s->decode_buffer = av_mallocz(s->decode_buffer_size);
    if (!s->decode_buffer)
        goto fail;

    /* initialize the solid-color vectors */
    if (s->vector_height == 4) {
        codebook_index = 0xFF00 * 16;
        for (i = 0; i < 256; i++)
            for (j = 0; j < 16; j++)
                s->codebook[codebook_index++] = i;
    } else {
        codebook_index = 0xF00 * 8;
        for (i = 0; i < 256; i++)
            for (j = 0; j < 8; j++)
                s->codebook[codebook_index++] = i;
    }
    s->next_codebook_buffer_index = 0;

    return 0;
fail:
    av_freep(&s->codebook);
    av_freep(&s->next_codebook_buffer);
    av_freep(&s->decode_buffer);
    return AVERROR(ENOMEM);
}","static av_cold VAR_0 vqa_decode_init(AVCodecContext *VAR_1)
{
    VqaContext *VAR_2 = VAR_1->priv_data;
    int VAR_3, VAR_4, VAR_5, VAR_6;

    VAR_2->avctx = VAR_1;
    VAR_1->pix_fmt = VAR_7;

    /* COMMENT_0 */
    if (VAR_2->avctx->extradata_size != VAR_8) {
        av_log(VAR_2->avctx, VAR_9, ""expected extradata size of %d\n"", VAR_8);
        return AVERROR(VAR_10);
    }

    /* COMMENT_1 */
    VAR_2->vqa_version = VAR_2->avctx->extradata[0];
    switch (VAR_2->vqa_version) {
    case 1:
    case 2:
        break;
    case 3:
        avpriv_report_missing_feature(VAR_1, ""VQA Version %d"", VAR_2->vqa_version);
        return VAR_11;
    default:
        avpriv_request_sample(VAR_1, ""VQA Version %i"", VAR_2->vqa_version);
        return VAR_11;
    }
    VAR_2->width = AV_RL16(&VAR_2->avctx->extradata[6]);
    VAR_2->height = AV_RL16(&VAR_2->avctx->extradata[8]);
    if ((VAR_6 = ff_set_dimensions(VAR_1, VAR_2->width, VAR_2->height)) < 0) {
        VAR_2->width= VAR_2->height= 0;
        return VAR_6;
    }
    VAR_2->vector_width = VAR_2->avctx->extradata[10];
    VAR_2->vector_height = VAR_2->avctx->extradata[11];
    VAR_2->partial_count = VAR_2->partial_countdown = VAR_2->avctx->extradata[13];

    /* COMMENT_2 */
    if ((VAR_2->vector_width != 4) ||
        ((VAR_2->vector_height != 2) && (VAR_2->vector_height != 4))) {
        /* COMMENT_3 */
        return VAR_12;
    }

    if (VAR_2->width % VAR_2->vector_width || VAR_2->height % VAR_2->vector_height) {
        av_log(VAR_1, VAR_9, ""Image size not multiple of block size\n"");
        return VAR_12;
    }

    /* COMMENT_4 */
    VAR_2->codebook_size = VAR_13;
    VAR_2->codebook = av_malloc(VAR_2->codebook_size);
    if (!VAR_2->codebook)
        goto fail;
    VAR_2->next_codebook_buffer = av_malloc(VAR_2->codebook_size);
    if (!VAR_2->next_codebook_buffer)
        goto fail;

    /* COMMENT_5 */
    VAR_2->decode_buffer_size = (VAR_2->width / VAR_2->vector_width) *
        (VAR_2->height / VAR_2->vector_height) * 2;
    VAR_2->decode_buffer = av_mallocz(VAR_2->decode_buffer_size);
    if (!VAR_2->decode_buffer)
        goto fail;

    /* COMMENT_6 */
    if (VAR_2->vector_height == 4) {
        VAR_5 = 0xFF00 * 16;
        for (VAR_3 = 0; VAR_3 < 256; VAR_3++)
            for (VAR_4 = 0; VAR_4 < 16; VAR_4++)
                VAR_2->codebook[VAR_5++] = VAR_3;
    } else {
        VAR_5 = 0xF00 * 8;
        for (VAR_3 = 0; VAR_3 < 256; VAR_3++)
            for (VAR_4 = 0; VAR_4 < 8; VAR_4++)
                VAR_2->codebook[VAR_5++] = VAR_3;
    }
    VAR_2->next_codebook_buffer_index = 0;

    return 0;
fail:
    av_freep(&VAR_2->codebook);
    av_freep(&VAR_2->next_codebook_buffer);
    av_freep(&VAR_2->decode_buffer);
    return AVERROR(VAR_14);
}",,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
     }
     s->width = AV_RL16(&s->avctx->extradata[6]);
     s->height = AV_RL16(&s->avctx->extradata[8]);
-    if ((ret = av_image_check_size(s->width, s->height, 0, avctx)) < 0) {
+    if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {
         s->width= s->height= 0;
         return ret;
     }","{'deleted_lines': ['    if ((ret = av_image_check_size(s->width, s->height, 0, avctx)) < 0) {'], 'added_lines': ['    if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {']}",True,FFmpeg before 4.2 has a heap-based buffer overflow in vqa_decode_chunk because of an out-of-array access in vqa_decode_init in libavcodec/vqavideo.c.,9.8,CRITICAL,3,test,2019-07-25T22:35:32Z,2
CVE-2019-20387,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,openSUSE/libsolv,"repodata_schema2id: fix heap-buffer-overflow in memcmp

When the length of last schema in data->schemadata is
less than length of input schema, we got a read overflow
in asan test.

Signed-off-by: Zhipeng Xie <xiezhipeng1@huawei.com>",fdb9c9c03508990e4583046b590c30d958f272da,https://github.com/openSUSE/libsolv/commit/fdb9c9c03508990e4583046b590c30d958f272da,src/repodata.c,repodata_schema2id,"Id
repodata_schema2id(Repodata *data, Id *schema, int create)
{
int h, len, i;
Id *sp, cid;
Id *schematahash;
if (!*schema)
return 0;
if ((schematahash = data->schematahash) == 0)
{
data->schematahash = schematahash = solv_calloc(256, sizeof(Id));
for (i = 1; i < data->nschemata; i++)
{
for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)
h = h * 7 + *sp++;
h &= 255;
schematahash[h] = i;
}
data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);
data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);
}
for (sp = schema, len = 0, h = 0; *sp; len++)
h = h * 7 + *sp++;
h &= 255;
len++;
cid = schematahash[h];
if (cid)
{
if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
return cid;
for (cid = 1; cid < data->nschemata; cid++)
if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
return cid;
}
if (!create)
return 0;
data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);
data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);
memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));
data->schemata[data->nschemata] = data->schemadatalen;
data->schemadatalen += len;
schematahash[h] = data->nschemata;
#if 0
fprintf(stderr, ""schema2id: new schema\n"");
#endif
return data->nschemata++;
}","Id
repodata_schema2id(Repodata *VAR_0, Id *VAR_1, int VAR_2)
{
int VAR_3, VAR_4, VAR_5;
Id *VAR_6, VAR_7;
Id *VAR_8;
if (!*VAR_1)
return 0;
if ((VAR_8 = VAR_0->schematahash) == 0)
{
VAR_0->schematahash = VAR_8 = solv_calloc(256, sizeof(Id));
for (VAR_5 = 1; VAR_5 < VAR_0->nschemata; VAR_5++)
{
for (VAR_6 = VAR_0->schemadata + VAR_0->schemata[VAR_5], VAR_3 = 0; *VAR_6;)
VAR_3 = VAR_3 * 7 + *VAR_6++;
VAR_3 &= 255;
VAR_8[VAR_3] = VAR_5;
}
VAR_0->schemadata = solv_extend_resize(VAR_0->schemadata, VAR_0->schemadatalen, sizeof(Id), VAR_9);
VAR_0->schemata = solv_extend_resize(VAR_0->schemata, VAR_0->nschemata, sizeof(Id), VAR_10);
}
for (VAR_6 = VAR_1, VAR_4 = 0, VAR_3 = 0; *VAR_6; VAR_4++)
VAR_3 = VAR_3 * 7 + *VAR_6++;
VAR_3 &= 255;
VAR_4++;
VAR_7 = VAR_8[VAR_3];
if (VAR_7)
{
if (!memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))
return VAR_7;
for (VAR_7 = 1; VAR_7 < VAR_0->nschemata; VAR_7++)
if (!memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))
return VAR_7;
}
if (!VAR_2)
return 0;
VAR_0->schemadata = solv_extend(VAR_0->schemadata, VAR_0->schemadatalen, VAR_4, sizeof(Id), VAR_9);
VAR_0->schemata = solv_extend(VAR_0->schemata, VAR_0->nschemata, 1, sizeof(Id), VAR_10);
memcpy(VAR_0->schemadata + VAR_0->schemadatalen, VAR_1, VAR_4 * sizeof(Id));
VAR_0->schemata[VAR_0->nschemata] = VAR_0->schemadatalen;
VAR_0->schemadatalen += VAR_4;
VAR_8[VAR_3] = VAR_0->nschemata;
#if 0
fprintf(VAR_11, ""schema2id: new schema\n"");
#endif
return VAR_0->nschemata++;
}",openSUSE/libsolv/fdb9c9c03508990e4583046b590c30d958f272da/repodata.c/vul/before/0.json,"Id
repodata_schema2id(Repodata *data, Id *schema, int create)
{
  int h, len, i;
  Id *sp, cid;
  Id *schematahash;

  if (!*schema)
    return 0;	/* XXX: allow empty schema? */
  if ((schematahash = data->schematahash) == 0)
    {
      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));
      for (i = 1; i < data->nschemata; i++)
	{
	  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)
	    h = h * 7 + *sp++;
	  h &= 255;
	  schematahash[h] = i;
	}
      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);
      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);
    }

  for (sp = schema, len = 0, h = 0; *sp; len++)
    h = h * 7 + *sp++;
  h &= 255;
  len++;

  cid = schematahash[h];
  if (cid)
    {
      if ((data->schemata[cid] + len <= data->schemadatalen) &&
			  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
        return cid;
      /* cache conflict, do a slow search */
      for (cid = 1; cid < data->nschemata; cid++)
        if ((data->schemata[cid] + len <= data->schemadatalen) &&
				!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
          return cid;
    }
  /* a new one */
  if (!create)
    return 0;
  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);
  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);
  /* add schema */
  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));
  data->schemata[data->nschemata] = data->schemadatalen;
  data->schemadatalen += len;
  schematahash[h] = data->nschemata;
#if 0
fprintf(stderr, ""schema2id: new schema\n"");
#endif
  return data->nschemata++;
}","Id
repodata_schema2id(Repodata *VAR_0, Id *VAR_1, int VAR_2)
{
  int VAR_3, VAR_4, VAR_5;
  Id *VAR_6, VAR_7;
  Id *VAR_8;

  if (!*VAR_1)
    return 0;	/* COMMENT_0 */
  if ((VAR_8 = VAR_0->schematahash) == 0)
    {
      VAR_0->schematahash = VAR_8 = solv_calloc(256, sizeof(Id));
      for (VAR_5 = 1; VAR_5 < VAR_0->nschemata; VAR_5++)
	{
	  for (VAR_6 = VAR_0->schemadata + VAR_0->schemata[VAR_5], VAR_3 = 0; *VAR_6;)
	    VAR_3 = VAR_3 * 7 + *VAR_6++;
	  VAR_3 &= 255;
	  VAR_8[VAR_3] = VAR_5;
	}
      VAR_0->schemadata = solv_extend_resize(VAR_0->schemadata, VAR_0->schemadatalen, sizeof(Id), VAR_9);
      VAR_0->schemata = solv_extend_resize(VAR_0->schemata, VAR_0->nschemata, sizeof(Id), VAR_10);
    }

  for (VAR_6 = VAR_1, VAR_4 = 0, VAR_3 = 0; *VAR_6; VAR_4++)
    VAR_3 = VAR_3 * 7 + *VAR_6++;
  VAR_3 &= 255;
  VAR_4++;

  VAR_7 = VAR_8[VAR_3];
  if (VAR_7)
    {
      if ((VAR_0->schemata[VAR_7] + VAR_4 <= VAR_0->schemadatalen) &&
			  !memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))
        return VAR_7;
      /* COMMENT_1 */
      for (VAR_7 = 1; VAR_7 < VAR_0->nschemata; VAR_7++)
        if ((VAR_0->schemata[VAR_7] + VAR_4 <= VAR_0->schemadatalen) &&
				!memcmp(VAR_0->schemadata + VAR_0->schemata[VAR_7], VAR_1, VAR_4 * sizeof(Id)))
          return VAR_7;
    }
  /* COMMENT_2 */
  if (!VAR_2)
    return 0;
  VAR_0->schemadata = solv_extend(VAR_0->schemadata, VAR_0->schemadatalen, VAR_4, sizeof(Id), VAR_9);
  VAR_0->schemata = solv_extend(VAR_0->schemata, VAR_0->nschemata, 1, sizeof(Id), VAR_10);
  /* COMMENT_3 */
  memcpy(VAR_0->schemadata + VAR_0->schemadatalen, VAR_1, VAR_4 * sizeof(Id));
  VAR_0->schemata[VAR_0->nschemata] = VAR_0->schemadatalen;
  VAR_0->schemadatalen += VAR_4;
  VAR_8[VAR_3] = VAR_0->nschemata;
#if 0
fprintf(VAR_11, ""schema2id: new schema\n"");
#endif
  return VAR_0->nschemata++;
}",openSUSE/libsolv/fdb9c9c03508990e4583046b590c30d958f272da/repodata.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,11 +29,13 @@
   cid = schematahash[h];
   if (cid)
     {
-      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
+      if ((data->schemata[cid] + len <= data->schemadatalen) &&
+			  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
         return cid;
       /* cache conflict, do a slow search */
       for (cid = 1; cid < data->nschemata; cid++)
-        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
+        if ((data->schemata[cid] + len <= data->schemadatalen) &&
+				!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))
           return cid;
     }
   /* a new one */","{'deleted_lines': ['      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))', '        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))'], 'added_lines': ['      if ((data->schemata[cid] + len <= data->schemadatalen) &&', '\t\t\t  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))', '        if ((data->schemata[cid] + len <= data->schemadatalen) &&', '\t\t\t\t!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))']}",True,repodata_schema2id in repodata.c in libsolv before 0.7.6 has a heap-based buffer over-read via a last schema whose length is less than the length of the input schema.,7.5,HIGH,2,test,2019-08-06T01:50:57Z,2
CVE-2019-13217,"['CWE-787', 'CWE-125', 'CWE-617', 'CWE-908', 'CWE-369', 'CWE-476']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,nothings/stb,"Fix seven bugs discovered and fixed by ForAllSecure:

CVE-2019-13217: heap buffer overflow in start_decoder()
CVE-2019-13218: stack buffer overflow in compute_codewords()
CVE-2019-13219: uninitialized memory in vorbis_decode_packet_rest()
CVE-2019-13220: out-of-range read in draw_line()
CVE-2019-13221: issue with large 1D codebooks in lookup1_values()
CVE-2019-13222: unchecked NULL returned by get_window()
CVE-2019-13223: division by zero in predict_point()",98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,stb_vorbis.c,start_decoder,"static int start_decoder(vorb *f)
{
uint8 header[6], x,y;
int len,i,j,k, max_submaps = 0;
int longest_floorlist=0;
if (!start_page(f))                              return FALSE;
if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);
if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);
if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);
if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);
if (f->segments[0] != 30) {
if (f->segments[0] == 64 &&
getn(f, header, 6) &&
header[0] == 'f' &&
header[1] == 'i' &&
header[2] == 's' &&
header[3] == 'h' &&
header[4] == 'e' &&
header[5] == 'a' &&
get8(f)   == 'd' &&
get8(f)   == '\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);
else
return error(f, VORBIS_invalid_first_page);
}
if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);
if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);
if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);
if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);
f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);
if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);
f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);
get32(f);    get32(f);    get32(f);    x = get8(f);
{
int log0,log1;
log0 = x & 15;
log1 = x >> 4;
f->blocksize_0 = 1 << log0;
f->blocksize_1 = 1 << log1;
if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);
if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);
if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);
}
x = get8(f);
if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);
if (!start_page(f))                              return FALSE;
if (!start_packet(f))                            return FALSE;
do {
len = next_segment(f);
skip(f, len);
f->bytes_in_seg = 0;
} while (len);
if (!start_packet(f))                            return FALSE;
#ifndef STB_VORBIS_NO_PUSHDATA_API
if (IS_PUSH_MODE(f)) {
if (!is_whole_packet_present(f, TRUE)) {
if (f->error == VORBIS_invalid_stream)
f->error = VORBIS_invalid_setup;
return FALSE;
}
}
#endif
crc32_init(); 
if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);
for (i=0; i < 6; ++i) header[i] = get8_packet(f);
if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);
f->codebook_count = get_bits(f,8) + 1;
f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);
if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);
memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);
for (i=0; i < f->codebook_count; ++i) {
uint32 *values;
int ordered, sorted_count;
int total=0;
uint8 *lengths;
Codebook *c = f->codebooks+i;
CHECK(f);
x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);
x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);
x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);
x = get_bits(f, 8);
c->dimensions = (get_bits(f, 8)<<8) + x;
x = get_bits(f, 8);
y = get_bits(f, 8);
c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;
ordered = get_bits(f,1);
c->sparse = ordered ? 0 : get_bits(f,1);
if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);
if (c->sparse)
lengths = (uint8 *) setup_temp_malloc(f, c->entries);
else
lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
if (!lengths) return error(f, VORBIS_outofmem);
if (ordered) {
int current_entry = 0;
int current_length = get_bits(f,5) + 1;
while (current_entry < c->entries) {
int limit = c->entries - current_entry;
int n = get_bits(f, ilog(limit));
if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
memset(lengths + current_entry, current_length, n);
current_entry += n;
++current_length;
}
} else {
for (j=0; j < c->entries; ++j) {
int present = c->sparse ? get_bits(f,1) : 1;
if (present) {
lengths[j] = get_bits(f, 5) + 1;
++total;
if (lengths[j] == 32)
return error(f, VORBIS_invalid_setup);
} else {
lengths[j] = NO_CODE;
}
}
}
if (c->sparse && total >= c->entries >> 2) {
if (c->entries > (int) f->setup_temp_memory_required)
f->setup_temp_memory_required = c->entries;
c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);
memcpy(c->codeword_lengths, lengths, c->entries);
setup_temp_free(f, lengths, c->entries);          lengths = c->codeword_lengths;
c->sparse = 0;
}
if (c->sparse) {
sorted_count = total;
} else {
sorted_count = 0;
#ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH
for (j=0; j < c->entries; ++j)
if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)
++sorted_count;
#endif
}
c->sorted_entries = sorted_count;
values = NULL;
CHECK(f);
if (!c->sparse) {
c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);
if (!c->codewords)                  return error(f, VORBIS_outofmem);
} else {
unsigned int size;
if (c->sorted_entries) {
c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);
if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);
c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);
if (!c->codewords)                  return error(f, VORBIS_outofmem);
values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);
if (!values)                        return error(f, VORBIS_outofmem);
}
size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;
if (size > f->setup_temp_memory_required)
f->setup_temp_memory_required = size;
}
if (!compute_codewords(c, lengths, c->entries, values)) {
if (c->sparse) setup_temp_free(f, values, 0);
return error(f, VORBIS_invalid_setup);
}
if (c->sorted_entries) {
c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));
if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);
c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));
if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);
++c->sorted_values;
c->sorted_values[-1] = -1;
compute_sorted_huffman(c, lengths, values);
}
if (c->sparse) {
setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);
setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);
setup_temp_free(f, lengths, c->entries);
c->codewords = NULL;
}
compute_accelerated_huffman(c);
CHECK(f);
c->lookup_type = get_bits(f, 4);
if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);
if (c->lookup_type > 0) {
uint16 *mults;
c->minimum_value = float32_unpack(get_bits(f, 32));
c->delta_value = float32_unpack(get_bits(f, 32));
c->value_bits = get_bits(f, 4)+1;
c->sequence_p = get_bits(f,1);
if (c->lookup_type == 1) {
c->lookup_values = lookup1_values(c->entries, c->dimensions);
} else {
c->lookup_values = c->entries * c->dimensions;
}
if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);
mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);
if (mults == NULL) return error(f, VORBIS_outofmem);
for (j=0; j < (int) c->lookup_values; ++j) {
int q = get_bits(f, c->value_bits);
if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }
mults[j] = q;
}
#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
if (c->lookup_type == 1) {
int len, sparse = c->sparse;
float last=0;
if (sparse) {
if (c->sorted_entries == 0) goto skip;
c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);
} else
c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);
if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
len = sparse ? c->sorted_entries : c->entries;
for (j=0; j < len; ++j) {
unsigned int z = sparse ? c->sorted_values[j] : j;
unsigned int div=1;
for (k=0; k < c->dimensions; ++k) {
int off = (z / div) % c->lookup_values;
float val = mults[off];
val = mults[off]*c->delta_value + c->minimum_value + last;
c->multiplicands[j*c->dimensions + k] = val;
if (c->sequence_p)
last = val;
if (k+1 < c->dimensions) {
if (div > UINT_MAX / (unsigned int) c->lookup_values) {
setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);
return error(f, VORBIS_invalid_setup);
}
div *= c->lookup_values;
}
}
}
c->lookup_type = 2;
}
else
#endif
{
float last=0;
CHECK(f);
c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);
if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
for (j=0; j < (int) c->lookup_values; ++j) {
float val = mults[j] * c->delta_value + c->minimum_value + last;
c->multiplicands[j] = val;
if (c->sequence_p)
last = val;
}
}
#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
skip:;
#endif
setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);
CHECK(f);
}
CHECK(f);
}
x = get_bits(f, 6) + 1;
for (i=0; i < x; ++i) {
uint32 z = get_bits(f, 16);
if (z != 0) return error(f, VORBIS_invalid_setup);
}
f->floor_count = get_bits(f, 6)+1;
f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));
if (f->floor_config == NULL) return error(f, VORBIS_outofmem);
for (i=0; i < f->floor_count; ++i) {
f->floor_types[i] = get_bits(f, 16);
if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);
if (f->floor_types[i] == 0) {
Floor0 *g = &f->floor_config[i].floor0;
g->order = get_bits(f,8);
g->rate = get_bits(f,16);
g->bark_map_size = get_bits(f,16);
g->amplitude_bits = get_bits(f,6);
g->amplitude_offset = get_bits(f,8);
g->number_of_books = get_bits(f,4) + 1;
for (j=0; j < g->number_of_books; ++j)
g->book_list[j] = get_bits(f,8);
return error(f, VORBIS_feature_not_supported);
} else {
stbv__floor_ordering p[31*8+2];
Floor1 *g = &f->floor_config[i].floor1;
int max_class = -1; 
g->partitions = get_bits(f, 5);
for (j=0; j < g->partitions; ++j) {
g->partition_class_list[j] = get_bits(f, 4);
if (g->partition_class_list[j] > max_class)
max_class = g->partition_class_list[j];
}
for (j=0; j <= max_class; ++j) {
g->class_dimensions[j] = get_bits(f, 3)+1;
g->class_subclasses[j] = get_bits(f, 2);
if (g->class_subclasses[j]) {
g->class_masterbooks[j] = get_bits(f, 8);
if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
}
for (k=0; k < 1 << g->class_subclasses[j]; ++k) {
g->subclass_books[j][k] = get_bits(f,8)-1;
if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
}
}
g->floor1_multiplier = get_bits(f,2)+1;
g->rangebits = get_bits(f,4);
g->Xlist[0] = 0;
g->Xlist[1] = 1 << g->rangebits;
g->values = 2;
for (j=0; j < g->partitions; ++j) {
int c = g->partition_class_list[j];
for (k=0; k < g->class_dimensions[c]; ++k) {
g->Xlist[g->values] = get_bits(f, g->rangebits);
++g->values;
}
}
for (j=0; j < g->values; ++j) {
p[j].x = g->Xlist[j];
p[j].id = j;
}
qsort(p, g->values, sizeof(p[0]), point_compare);
for (j=0; j < g->values; ++j)
g->sorted_order[j] = (uint8) p[j].id;
for (j=2; j < g->values; ++j) {
int low,hi;
neighbors(g->Xlist, j, &low,&hi);
g->neighbors[j][0] = low;
g->neighbors[j][1] = hi;
}
if (g->values > longest_floorlist)
longest_floorlist = g->values;
}
}
f->residue_count = get_bits(f, 6)+1;
f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));
if (f->residue_config == NULL) return error(f, VORBIS_outofmem);
memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));
for (i=0; i < f->residue_count; ++i) {
uint8 residue_cascade[64];
Residue *r = f->residue_config+i;
f->residue_types[i] = get_bits(f, 16);
if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);
r->begin = get_bits(f, 24);
r->end = get_bits(f, 24);
if (r->end < r->begin) return error(f, VORBIS_invalid_setup);
r->part_size = get_bits(f,24)+1;
r->classifications = get_bits(f,6)+1;
r->classbook = get_bits(f,8);
if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);
for (j=0; j < r->classifications; ++j) {
uint8 high_bits=0;
uint8 low_bits=get_bits(f,3);
if (get_bits(f,1))
high_bits = get_bits(f,5);
residue_cascade[j] = high_bits*8 + low_bits;
}
r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);
if (r->residue_books == NULL) return error(f, VORBIS_outofmem);
for (j=0; j < r->classifications; ++j) {
for (k=0; k < 8; ++k) {
if (residue_cascade[j] & (1 << k)) {
r->residue_books[j][k] = get_bits(f, 8);
if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
} else {
r->residue_books[j][k] = -1;
}
}
}
r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
if (!r->classdata) return error(f, VORBIS_outofmem);
memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
for (j=0; j < f->codebooks[r->classbook].entries; ++j) {
int classwords = f->codebooks[r->classbook].dimensions;
int temp = j;
r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);
if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);
for (k=classwords-1; k >= 0; --k) {
r->classdata[j][k] = temp % r->classifications;
temp /= r->classifications;
}
}
}
f->mapping_count = get_bits(f,6)+1;
f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));
if (f->mapping == NULL) return error(f, VORBIS_outofmem);
memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));
for (i=0; i < f->mapping_count; ++i) {
Mapping *m = f->mapping + i;      
int mapping_type = get_bits(f,16);
if (mapping_type != 0) return error(f, VORBIS_invalid_setup);
m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));
if (m->chan == NULL) return error(f, VORBIS_outofmem);
if (get_bits(f,1))
m->submaps = get_bits(f,4)+1;
else
m->submaps = 1;
if (m->submaps > max_submaps)
max_submaps = m->submaps;
if (get_bits(f,1)) {
m->coupling_steps = get_bits(f,8)+1;
for (k=0; k < m->coupling_steps; ++k) {
m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
m->chan[k].angle = get_bits(f, ilog(f->channels-1));
if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);
if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);
if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);
}
} else
m->coupling_steps = 0;
if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);
if (m->submaps > 1) {
for (j=0; j < f->channels; ++j) {
m->chan[j].mux = get_bits(f, 4);
if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);
}
} else
for (j=0; j < f->channels; ++j)
m->chan[j].mux = 0;
for (j=0; j < m->submaps; ++j) {
get_bits(f,8);          m->submap_floor[j] = get_bits(f,8);
m->submap_residue[j] = get_bits(f,8);
if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);
if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);
}
}
f->mode_count = get_bits(f, 6)+1;
for (i=0; i < f->mode_count; ++i) {
Mode *m = f->mode_config+i;
m->blockflag = get_bits(f,1);
m->windowtype = get_bits(f,16);
m->transformtype = get_bits(f,16);
m->mapping = get_bits(f,8);
if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);
if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);
if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);
}
flush_packet(f);
f->previous_length = 0;
for (i=0; i < f->channels; ++i) {
f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);
f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);
if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);
memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);
#ifdef STB_VORBIS_NO_DEFER_FLOOR
f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);
#endif
}
if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;
if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;
f->blocksize[0] = f->blocksize_0;
f->blocksize[1] = f->blocksize_1;
#ifdef STB_VORBIS_DIVIDE_TABLE
if (integer_divide_table[1][1]==0)
for (i=0; i < DIVTAB_NUMER; ++i)
for (j=1; j < DIVTAB_DENOM; ++j)
integer_divide_table[i][j] = i / j;
#endif
{
uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);
uint32 classify_mem;
int i,max_part_read=0;
for (i=0; i < f->residue_count; ++i) {
Residue *r = f->residue_config + i;
unsigned int actual_size = f->blocksize_1 / 2;
unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;
unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;
int n_read = limit_r_end - limit_r_begin;
int part_read = n_read / r->part_size;
if (part_read > max_part_read)
max_part_read = part_read;
}
#ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));
#else
classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));
#endif
f->temp_memory_required = classify_mem;
if (imdct_mem > f->temp_memory_required)
f->temp_memory_required = imdct_mem;
}
f->first_decode = TRUE;
if (f->alloc.alloc_buffer) {
assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);
if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)
return error(f, VORBIS_outofmem);
}
f->first_audio_page_offset = stb_vorbis_get_file_offset(f);
return TRUE;
}","static int start_decoder(vorb *VAR_0)
{
uint8 VAR_1[6], VAR_2,VAR_3;
int VAR_4,VAR_5,VAR_6,VAR_7, VAR_8 = 0;
int VAR_9=0;
if (!start_page(VAR_0))                              return FALSE;
if (!(VAR_0->page_flag & VAR_10))       return error(VAR_0, VAR_11);
if (VAR_0->page_flag & VAR_12)           return error(VAR_0, VAR_11);
if (VAR_0->page_flag & VAR_13)    return error(VAR_0, VAR_11);
if (VAR_0->segment_count != 1)                       return error(VAR_0, VAR_11);
if (VAR_0->segments[0] != 30) {
if (VAR_0->segments[0] == 64 &&
getn(VAR_0, VAR_1, 6) &&
VAR_1[0] == 'f' &&
VAR_1[1] == 'i' &&
VAR_1[2] == 's' &&
VAR_1[3] == 'h' &&
VAR_1[4] == 'e' &&
VAR_1[5] == 'a' &&
get8(VAR_0)   == 'd' &&
get8(VAR_0)   == '\0')                        return error(VAR_0, VAR_14);
else
return error(VAR_0, VAR_11);
}
if (get8(VAR_0) != VAR_15)                 return error(VAR_0, VAR_11);
if (!getn(VAR_0, VAR_1, 6))                         return error(VAR_0, VAR_16);
if (!vorbis_validate(VAR_1))                    return error(VAR_0, VAR_11);
if (get32(VAR_0) != 0)                               return error(VAR_0, VAR_11);
VAR_0->channels = get8(VAR_0); if (!VAR_0->channels)         return error(VAR_0, VAR_11);
if (VAR_0->channels > VAR_17)       return error(VAR_0, VAR_18);
VAR_0->sample_rate = get32(VAR_0); if (!VAR_0->sample_rate)  return error(VAR_0, VAR_11);
get32(VAR_0); 
get32(VAR_0); 
get32(VAR_0); 
VAR_2 = get8(VAR_0);
{
int VAR_19,VAR_20;
VAR_19 = VAR_2 & 15;
VAR_20 = VAR_2 >> 4;
VAR_0->blocksize_0 = 1 << VAR_19;
VAR_0->blocksize_1 = 1 << VAR_20;
if (VAR_19 < 6 || VAR_19 > 13)                       return error(VAR_0, VAR_21);
if (VAR_20 < 6 || VAR_20 > 13)                       return error(VAR_0, VAR_21);
if (VAR_19 > VAR_20)                                 return error(VAR_0, VAR_21);
}
VAR_2 = get8(VAR_0);
if (!(VAR_2 & 1))                                    return error(VAR_0, VAR_11);
if (!start_page(VAR_0))                              return FALSE;
if (!start_packet(VAR_0))                            return FALSE;
do {
VAR_4 = next_segment(VAR_0);
skip(VAR_0, VAR_4);
VAR_0->bytes_in_seg = 0;
} while (VAR_4);
if (!start_packet(VAR_0))                            return FALSE;
#ifndef VAR_22
if (IS_PUSH_MODE(VAR_0)) {
if (!is_whole_packet_present(VAR_0, TRUE)) {
if (VAR_0->error == VAR_23)
VAR_0->error = VAR_21;
return FALSE;
}
}
#endif
crc32_init(); 
if (get8_packet(VAR_0) != VAR_24)       return error(VAR_0, VAR_21);
for (VAR_5=0; VAR_5 < 6; ++VAR_5) VAR_1[VAR_5] = get8_packet(VAR_0);
if (!vorbis_validate(VAR_1))                    return error(VAR_0, VAR_21);
VAR_0->codebook_count = get_bits(VAR_0,8) + 1;
VAR_0->codebooks = (Codebook *) setup_malloc(VAR_0, sizeof(*VAR_0->codebooks) * VAR_0->codebook_count);
if (VAR_0->codebooks == NULL)                        return error(VAR_0, VAR_25);
memset(VAR_0->codebooks, 0, sizeof(*VAR_0->codebooks) * VAR_0->codebook_count);
for (VAR_5=0; VAR_5 < VAR_0->codebook_count; ++VAR_5) {
uint32 *VAR_26;
int VAR_27, VAR_28;
int VAR_29=0;
uint8 *VAR_30;
Codebook *VAR_31 = VAR_0->codebooks+VAR_5;
CHECK(VAR_0);
VAR_2 = get_bits(VAR_0, 8); if (VAR_2 != 0x42)            return error(VAR_0, VAR_21);
VAR_2 = get_bits(VAR_0, 8); if (VAR_2 != 0x43)            return error(VAR_0, VAR_21);
VAR_2 = get_bits(VAR_0, 8); if (VAR_2 != 0x56)            return error(VAR_0, VAR_21);
VAR_2 = get_bits(VAR_0, 8);
VAR_31->dimensions = (get_bits(VAR_0, 8)<<8) + VAR_2;
VAR_2 = get_bits(VAR_0, 8);
VAR_3 = get_bits(VAR_0, 8);
VAR_31->entries = (get_bits(VAR_0, 8)<<16) + (VAR_3<<8) + VAR_2;
VAR_27 = get_bits(VAR_0,1);
VAR_31->sparse = VAR_27 ? 0 : get_bits(VAR_0,1);
if (VAR_31->dimensions == 0 && VAR_31->entries != 0)    return error(VAR_0, VAR_21);
if (VAR_31->sparse)
VAR_30 = (uint8 *) setup_temp_malloc(VAR_0, VAR_31->entries);
else
VAR_30 = VAR_31->codeword_lengths = (uint8 *) setup_malloc(VAR_0, VAR_31->entries);
if (!VAR_30) return error(VAR_0, VAR_25);
if (VAR_27) {
int VAR_32 = 0;
int VAR_33 = get_bits(VAR_0,5) + 1;
while (VAR_32 < VAR_31->entries) {
int VAR_34 = VAR_31->entries - VAR_32;
int VAR_35 = get_bits(VAR_0, ilog(VAR_34));
if (VAR_32 + VAR_35 > (int) VAR_31->entries) { return error(VAR_0, VAR_21); }
memset(VAR_30 + VAR_32, VAR_33, VAR_35);
VAR_32 += VAR_35;
++VAR_33;
}
} else {
for (VAR_6=0; VAR_6 < VAR_31->entries; ++VAR_6) {
int VAR_36 = VAR_31->sparse ? get_bits(VAR_0,1) : 1;
if (VAR_36) {
VAR_30[VAR_6] = get_bits(VAR_0, 5) + 1;
++VAR_29;
if (VAR_30[VAR_6] == 32)
return error(VAR_0, VAR_21);
} else {
VAR_30[VAR_6] = VAR_37;
}
}
}
if (VAR_31->sparse && VAR_29 >= VAR_31->entries >> 2) {
if (VAR_31->entries > (int) VAR_0->setup_temp_memory_required)
VAR_0->setup_temp_memory_required = VAR_31->entries;
VAR_31->codeword_lengths = (uint8 *) setup_malloc(VAR_0, VAR_31->entries);
if (VAR_31->codeword_lengths == NULL) return error(VAR_0, VAR_25);
memcpy(VAR_31->codeword_lengths, VAR_30, VAR_31->entries);
setup_temp_free(VAR_0, VAR_30, VAR_31->entries); 
VAR_30 = VAR_31->codeword_lengths;
VAR_31->sparse = 0;
}
if (VAR_31->sparse) {
VAR_28 = VAR_29;
} else {
VAR_28 = 0;
#ifndef VAR_38
for (VAR_6=0; VAR_6 < VAR_31->entries; ++VAR_6)
if (VAR_30[VAR_6] > VAR_39 && VAR_30[VAR_6] != VAR_37)
++VAR_28;
#endif
}
VAR_31->sorted_entries = VAR_28;
VAR_26 = NULL;
CHECK(VAR_0);
if (!VAR_31->sparse) {
VAR_31->codewords = (uint32 *) setup_malloc(VAR_0, sizeof(VAR_31->codewords[0]) * VAR_31->entries);
if (!VAR_31->codewords)                  return error(VAR_0, VAR_25);
} else {
unsigned int VAR_40;
if (VAR_31->sorted_entries) {
VAR_31->codeword_lengths = (uint8 *) setup_malloc(VAR_0, VAR_31->sorted_entries);
if (!VAR_31->codeword_lengths)           return error(VAR_0, VAR_25);
VAR_31->codewords = (uint32 *) setup_temp_malloc(VAR_0, sizeof(*VAR_31->codewords) * VAR_31->sorted_entries);
if (!VAR_31->codewords)                  return error(VAR_0, VAR_25);
VAR_26 = (uint32 *) setup_temp_malloc(VAR_0, sizeof(*VAR_26) * VAR_31->sorted_entries);
if (!VAR_26)                        return error(VAR_0, VAR_25);
}
VAR_40 = VAR_31->entries + (sizeof(*VAR_31->codewords) + sizeof(*VAR_26)) * VAR_31->sorted_entries;
if (VAR_40 > VAR_0->setup_temp_memory_required)
VAR_0->setup_temp_memory_required = VAR_40;
}
if (!compute_codewords(VAR_31, VAR_30, VAR_31->entries, VAR_26)) {
if (VAR_31->sparse) setup_temp_free(VAR_0, VAR_26, 0);
return error(VAR_0, VAR_21);
}
if (VAR_31->sorted_entries) {
VAR_31->sorted_codewords = (uint32 *) setup_malloc(VAR_0, sizeof(*VAR_31->sorted_codewords) * (VAR_31->sorted_entries+1));
if (VAR_31->sorted_codewords == NULL) return error(VAR_0, VAR_25);
VAR_31->sorted_values    = ( int   *) setup_malloc(VAR_0, sizeof(*VAR_31->sorted_values   ) * (VAR_31->sorted_entries+1));
if (VAR_31->sorted_values == NULL) return error(VAR_0, VAR_25);
++VAR_31->sorted_values;
VAR_31->sorted_values[-1] = -1;
compute_sorted_huffman(VAR_31, VAR_30, VAR_26);
}
if (VAR_31->sparse) {
setup_temp_free(VAR_0, VAR_26, sizeof(*VAR_26)*VAR_31->sorted_entries);
setup_temp_free(VAR_0, VAR_31->codewords, sizeof(*VAR_31->codewords)*VAR_31->sorted_entries);
setup_temp_free(VAR_0, VAR_30, VAR_31->entries);
VAR_31->codewords = NULL;
}
compute_accelerated_huffman(VAR_31);
CHECK(VAR_0);
VAR_31->lookup_type = get_bits(VAR_0, 4);
if (VAR_31->lookup_type > 2) return error(VAR_0, VAR_21);
if (VAR_31->lookup_type > 0) {
uint16 *VAR_41;
VAR_31->minimum_value = float32_unpack(get_bits(VAR_0, 32));
VAR_31->delta_value = float32_unpack(get_bits(VAR_0, 32));
VAR_31->value_bits = get_bits(VAR_0, 4)+1;
VAR_31->sequence_p = get_bits(VAR_0,1);
if (VAR_31->lookup_type == 1) {
VAR_31->lookup_values = lookup1_values(VAR_31->entries, VAR_31->dimensions);
} else {
VAR_31->lookup_values = VAR_31->entries * VAR_31->dimensions;
}
if (VAR_31->lookup_values == 0) return error(VAR_0, VAR_21);
VAR_41 = (uint16 *) setup_temp_malloc(VAR_0, sizeof(VAR_41[0]) * VAR_31->lookup_values);
if (VAR_41 == NULL) return error(VAR_0, VAR_25);
for (VAR_6=0; VAR_6 < (int) VAR_31->lookup_values; ++VAR_6) {
int VAR_42 = get_bits(VAR_0, VAR_31->value_bits);
if (VAR_42 == VAR_43) { setup_temp_free(VAR_0,VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values); return error(VAR_0, VAR_21); }
VAR_41[VAR_6] = VAR_42;
}
#ifndef VAR_44
if (VAR_31->lookup_type == 1) {
int VAR_4, VAR_45 = VAR_31->sparse;
float VAR_46=0;
if (VAR_45) {
if (VAR_31->sorted_entries == 0) goto skip;
VAR_31->multiplicands = (codetype *) setup_malloc(VAR_0, sizeof(VAR_31->multiplicands[0]) * VAR_31->sorted_entries * VAR_31->dimensions);
} else
VAR_31->multiplicands = (codetype *) setup_malloc(VAR_0, sizeof(VAR_31->multiplicands[0]) * VAR_31->entries        * VAR_31->dimensions);
if (VAR_31->multiplicands == NULL) { setup_temp_free(VAR_0,VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values); return error(VAR_0, VAR_25); }
VAR_4 = VAR_45 ? VAR_31->sorted_entries : VAR_31->entries;
for (VAR_6=0; VAR_6 < VAR_4; ++VAR_6) {
unsigned int VAR_47 = VAR_45 ? VAR_31->sorted_values[VAR_6] : VAR_6;
unsigned int VAR_48=1;
for (VAR_7=0; VAR_7 < VAR_31->dimensions; ++VAR_7) {
int VAR_49 = (VAR_47 / VAR_48) % VAR_31->lookup_values;
float VAR_50 = VAR_41[VAR_49];
VAR_50 = VAR_41[VAR_49]*VAR_31->delta_value + VAR_31->minimum_value + VAR_46;
VAR_31->multiplicands[VAR_6*VAR_31->dimensions + VAR_7] = VAR_50;
if (VAR_31->sequence_p)
VAR_46 = VAR_50;
if (VAR_7+1 < VAR_31->dimensions) {
if (VAR_48 > VAR_51 / (unsigned int) VAR_31->lookup_values) {
setup_temp_free(VAR_0, VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values);
return error(VAR_0, VAR_21);
}
VAR_48 *= VAR_31->lookup_values;
}
}
}
VAR_31->lookup_type = 2;
}
else
#endif
{
float VAR_46=0;
CHECK(VAR_0);
VAR_31->multiplicands = (codetype *) setup_malloc(VAR_0, sizeof(VAR_31->multiplicands[0]) * VAR_31->lookup_values);
if (VAR_31->multiplicands == NULL) { setup_temp_free(VAR_0, VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values); return error(VAR_0, VAR_25); }
for (VAR_6=0; VAR_6 < (int) VAR_31->lookup_values; ++VAR_6) {
float VAR_50 = VAR_41[VAR_6] * VAR_31->delta_value + VAR_31->minimum_value + VAR_46;
VAR_31->multiplicands[VAR_6] = VAR_50;
if (VAR_31->sequence_p)
VAR_46 = VAR_50;
}
}
#ifndef VAR_44
skip:;
#endif
setup_temp_free(VAR_0, VAR_41, sizeof(VAR_41[0])*VAR_31->lookup_values);
CHECK(VAR_0);
}
CHECK(VAR_0);
}
VAR_2 = get_bits(VAR_0, 6) + 1;
for (VAR_5=0; VAR_5 < VAR_2; ++VAR_5) {
uint32 VAR_47 = get_bits(VAR_0, 16);
if (VAR_47 != 0) return error(VAR_0, VAR_21);
}
VAR_0->floor_count = get_bits(VAR_0, 6)+1;
VAR_0->floor_config = (Floor *)  setup_malloc(VAR_0, VAR_0->floor_count * sizeof(*VAR_0->floor_config));
if (VAR_0->floor_config == NULL) return error(VAR_0, VAR_25);
for (VAR_5=0; VAR_5 < VAR_0->floor_count; ++VAR_5) {
VAR_0->floor_types[VAR_5] = get_bits(VAR_0, 16);
if (VAR_0->floor_types[VAR_5] > 1) return error(VAR_0, VAR_21);
if (VAR_0->floor_types[VAR_5] == 0) {
Floor0 *VAR_52 = &VAR_0->floor_config[VAR_5].floor0;
VAR_52->order = get_bits(VAR_0,8);
VAR_52->rate = get_bits(VAR_0,16);
VAR_52->bark_map_size = get_bits(VAR_0,16);
VAR_52->amplitude_bits = get_bits(VAR_0,6);
VAR_52->amplitude_offset = get_bits(VAR_0,8);
VAR_52->number_of_books = get_bits(VAR_0,4) + 1;
for (VAR_6=0; VAR_6 < VAR_52->number_of_books; ++VAR_6)
VAR_52->book_list[VAR_6] = get_bits(VAR_0,8);
return error(VAR_0, VAR_53);
} else {
stbv__floor_ordering VAR_54[31*8+2];
Floor1 *VAR_52 = &VAR_0->floor_config[VAR_5].floor1;
int VAR_55 = -1; 
VAR_52->partitions = get_bits(VAR_0, 5);
for (VAR_6=0; VAR_6 < VAR_52->partitions; ++VAR_6) {
VAR_52->partition_class_list[VAR_6] = get_bits(VAR_0, 4);
if (VAR_52->partition_class_list[VAR_6] > VAR_55)
VAR_55 = VAR_52->partition_class_list[VAR_6];
}
for (VAR_6=0; VAR_6 <= VAR_55; ++VAR_6) {
VAR_52->class_dimensions[VAR_6] = get_bits(VAR_0, 3)+1;
VAR_52->class_subclasses[VAR_6] = get_bits(VAR_0, 2);
if (VAR_52->class_subclasses[VAR_6]) {
VAR_52->class_masterbooks[VAR_6] = get_bits(VAR_0, 8);
if (VAR_52->class_masterbooks[VAR_6] >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
}
for (VAR_7=0; VAR_7 < 1 << VAR_52->class_subclasses[VAR_6]; ++VAR_7) {
VAR_52->subclass_books[VAR_6][VAR_7] = get_bits(VAR_0,8)-1;
if (VAR_52->subclass_books[VAR_6][VAR_7] >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
}
}
VAR_52->floor1_multiplier = get_bits(VAR_0,2)+1;
VAR_52->rangebits = get_bits(VAR_0,4);
VAR_52->Xlist[0] = 0;
VAR_52->Xlist[1] = 1 << VAR_52->rangebits;
VAR_52->values = 2;
for (VAR_6=0; VAR_6 < VAR_52->partitions; ++VAR_6) {
int VAR_31 = VAR_52->partition_class_list[VAR_6];
for (VAR_7=0; VAR_7 < VAR_52->class_dimensions[VAR_31]; ++VAR_7) {
VAR_52->Xlist[VAR_52->values] = get_bits(VAR_0, VAR_52->rangebits);
++VAR_52->values;
}
}
for (VAR_6=0; VAR_6 < VAR_52->values; ++VAR_6) {
VAR_54[VAR_6].x = VAR_52->Xlist[VAR_6];
VAR_54[VAR_6].id = VAR_6;
}
qsort(VAR_54, VAR_52->values, sizeof(VAR_54[0]), VAR_56);
for (VAR_6=0; VAR_6 < VAR_52->values; ++VAR_6)
VAR_52->sorted_order[VAR_6] = (uint8) VAR_54[VAR_6].id;
for (VAR_6=2; VAR_6 < VAR_52->values; ++VAR_6) {
int VAR_57,VAR_58;
neighbors(VAR_52->Xlist, VAR_6, &VAR_57,&VAR_58);
VAR_52->neighbors[VAR_6][0] = VAR_57;
VAR_52->neighbors[VAR_6][1] = VAR_58;
}
if (VAR_52->values > VAR_9)
VAR_9 = VAR_52->values;
}
}
VAR_0->residue_count = get_bits(VAR_0, 6)+1;
VAR_0->residue_config = (Residue *) setup_malloc(VAR_0, VAR_0->residue_count * sizeof(VAR_0->residue_config[0]));
if (VAR_0->residue_config == NULL) return error(VAR_0, VAR_25);
memset(VAR_0->residue_config, 0, VAR_0->residue_count * sizeof(VAR_0->residue_config[0]));
for (VAR_5=0; VAR_5 < VAR_0->residue_count; ++VAR_5) {
uint8 VAR_59[64];
Residue *VAR_60 = VAR_0->residue_config+VAR_5;
VAR_0->residue_types[VAR_5] = get_bits(VAR_0, 16);
if (VAR_0->residue_types[VAR_5] > 2) return error(VAR_0, VAR_21);
VAR_60->begin = get_bits(VAR_0, 24);
VAR_60->end = get_bits(VAR_0, 24);
if (VAR_60->end < VAR_60->begin) return error(VAR_0, VAR_21);
VAR_60->part_size = get_bits(VAR_0,24)+1;
VAR_60->classifications = get_bits(VAR_0,6)+1;
VAR_60->classbook = get_bits(VAR_0,8);
if (VAR_60->classbook >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
for (VAR_6=0; VAR_6 < VAR_60->classifications; ++VAR_6) {
uint8 VAR_61=0;
uint8 VAR_62=get_bits(VAR_0,3);
if (get_bits(VAR_0,1))
VAR_61 = get_bits(VAR_0,5);
VAR_59[VAR_6] = VAR_61*8 + VAR_62;
}
VAR_60->residue_books = (short (*)[8]) setup_malloc(VAR_0, sizeof(VAR_60->residue_books[0]) * VAR_60->classifications);
if (VAR_60->residue_books == NULL) return error(VAR_0, VAR_25);
for (VAR_6=0; VAR_6 < VAR_60->classifications; ++VAR_6) {
for (VAR_7=0; VAR_7 < 8; ++VAR_7) {
if (VAR_59[VAR_6] & (1 << VAR_7)) {
VAR_60->residue_books[VAR_6][VAR_7] = get_bits(VAR_0, 8);
if (VAR_60->residue_books[VAR_6][VAR_7] >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
} else {
VAR_60->residue_books[VAR_6][VAR_7] = -1;
}
}
}
VAR_60->classdata = (uint8 **) setup_malloc(VAR_0, sizeof(*VAR_60->classdata) * VAR_0->codebooks[VAR_60->classbook].entries);
if (!VAR_60->classdata) return error(VAR_0, VAR_25);
memset(VAR_60->classdata, 0, sizeof(*VAR_60->classdata) * VAR_0->codebooks[VAR_60->classbook].entries);
for (VAR_6=0; VAR_6 < VAR_0->codebooks[VAR_60->classbook].entries; ++VAR_6) {
int VAR_63 = VAR_0->codebooks[VAR_60->classbook].dimensions;
int VAR_64 = VAR_6;
VAR_60->classdata[VAR_6] = (uint8 *) setup_malloc(VAR_0, sizeof(VAR_60->classdata[VAR_6][0]) * VAR_63);
if (VAR_60->classdata[VAR_6] == NULL) return error(VAR_0, VAR_25);
for (VAR_7=VAR_63-1; VAR_7 >= 0; --VAR_7) {
VAR_60->classdata[VAR_6][VAR_7] = VAR_64 % VAR_60->classifications;
VAR_64 /= VAR_60->classifications;
}
}
}
VAR_0->mapping_count = get_bits(VAR_0,6)+1;
VAR_0->mapping = (Mapping *) setup_malloc(VAR_0, VAR_0->mapping_count * sizeof(*VAR_0->mapping));
if (VAR_0->mapping == NULL) return error(VAR_0, VAR_25);
memset(VAR_0->mapping, 0, VAR_0->mapping_count * sizeof(*VAR_0->mapping));
for (VAR_5=0; VAR_5 < VAR_0->mapping_count; ++VAR_5) {
Mapping *VAR_65 = VAR_0->mapping + VAR_5;      
int VAR_66 = get_bits(VAR_0,16);
if (VAR_66 != 0) return error(VAR_0, VAR_21);
VAR_65->chan = (MappingChannel *) setup_malloc(VAR_0, VAR_0->channels * sizeof(*VAR_65->chan));
if (VAR_65->chan == NULL) return error(VAR_0, VAR_25);
if (get_bits(VAR_0,1))
VAR_65->submaps = get_bits(VAR_0,4)+1;
else
VAR_65->submaps = 1;
if (VAR_65->submaps > VAR_8)
VAR_8 = VAR_65->submaps;
if (get_bits(VAR_0,1)) {
VAR_65->coupling_steps = get_bits(VAR_0,8)+1;
for (VAR_7=0; VAR_7 < VAR_65->coupling_steps; ++VAR_7) {
VAR_65->chan[VAR_7].magnitude = get_bits(VAR_0, ilog(VAR_0->channels-1));
VAR_65->chan[VAR_7].angle = get_bits(VAR_0, ilog(VAR_0->channels-1));
if (VAR_65->chan[VAR_7].magnitude >= VAR_0->channels)        return error(VAR_0, VAR_21);
if (VAR_65->chan[VAR_7].angle     >= VAR_0->channels)        return error(VAR_0, VAR_21);
if (VAR_65->chan[VAR_7].magnitude == VAR_65->chan[VAR_7].angle)   return error(VAR_0, VAR_21);
}
} else
VAR_65->coupling_steps = 0;
if (get_bits(VAR_0,2)) return error(VAR_0, VAR_21);
if (VAR_65->submaps > 1) {
for (VAR_6=0; VAR_6 < VAR_0->channels; ++VAR_6) {
VAR_65->chan[VAR_6].mux = get_bits(VAR_0, 4);
if (VAR_65->chan[VAR_6].mux >= VAR_65->submaps)                return error(VAR_0, VAR_21);
}
} else
for (VAR_6=0; VAR_6 < VAR_0->channels; ++VAR_6)
VAR_65->chan[VAR_6].mux = 0;
for (VAR_6=0; VAR_6 < VAR_65->submaps; ++VAR_6) {
get_bits(VAR_0,8); 
VAR_65->submap_floor[VAR_6] = get_bits(VAR_0,8);
VAR_65->submap_residue[VAR_6] = get_bits(VAR_0,8);
if (VAR_65->submap_floor[VAR_6] >= VAR_0->floor_count)      return error(VAR_0, VAR_21);
if (VAR_65->submap_residue[VAR_6] >= VAR_0->residue_count)  return error(VAR_0, VAR_21);
}
}
VAR_0->mode_count = get_bits(VAR_0, 6)+1;
for (VAR_5=0; VAR_5 < VAR_0->mode_count; ++VAR_5) {
Mode *VAR_65 = VAR_0->mode_config+VAR_5;
VAR_65->blockflag = get_bits(VAR_0,1);
VAR_65->windowtype = get_bits(VAR_0,16);
VAR_65->transformtype = get_bits(VAR_0,16);
VAR_65->mapping = get_bits(VAR_0,8);
if (VAR_65->windowtype != 0)                 return error(VAR_0, VAR_21);
if (VAR_65->transformtype != 0)              return error(VAR_0, VAR_21);
if (VAR_65->mapping >= VAR_0->mapping_count)     return error(VAR_0, VAR_21);
}
flush_packet(VAR_0);
VAR_0->previous_length = 0;
for (VAR_5=0; VAR_5 < VAR_0->channels; ++VAR_5) {
VAR_0->channel_buffers[VAR_5] = (float *) setup_malloc(VAR_0, sizeof(float) * VAR_0->blocksize_1);
VAR_0->previous_window[VAR_5] = (float *) setup_malloc(VAR_0, sizeof(float) * VAR_0->blocksize_1/2);
VAR_0->finalY[VAR_5]          = (int16 *) setup_malloc(VAR_0, sizeof(int16) * VAR_9);
if (VAR_0->channel_buffers[VAR_5] == NULL || VAR_0->previous_window[VAR_5] == NULL || VAR_0->finalY[VAR_5] == NULL) return error(VAR_0, VAR_25);
memset(VAR_0->channel_buffers[VAR_5], 0, sizeof(float) * VAR_0->blocksize_1);
#ifdef VAR_67
VAR_0->floor_buffers[VAR_5]   = (float *) setup_malloc(VAR_0, sizeof(float) * VAR_0->blocksize_1/2);
if (VAR_0->floor_buffers[VAR_5] == NULL) return error(VAR_0, VAR_25);
#endif
}
if (!init_blocksize(VAR_0, 0, VAR_0->blocksize_0)) return FALSE;
if (!init_blocksize(VAR_0, 1, VAR_0->blocksize_1)) return FALSE;
VAR_0->blocksize[0] = VAR_0->blocksize_0;
VAR_0->blocksize[1] = VAR_0->blocksize_1;
#ifdef VAR_68
if (VAR_69[1][1]==0)
for (VAR_5=0; VAR_5 < VAR_70; ++VAR_5)
for (VAR_6=1; VAR_6 < VAR_71; ++VAR_6)
VAR_69[VAR_5][VAR_6] = VAR_5 / VAR_6;
#endif
{
uint32 VAR_72 = (VAR_0->blocksize_1 * sizeof(float) >> 1);
uint32 VAR_73;
int VAR_5,VAR_74=0;
for (VAR_5=0; VAR_5 < VAR_0->residue_count; ++VAR_5) {
Residue *VAR_60 = VAR_0->residue_config + VAR_5;
unsigned int VAR_75 = VAR_0->blocksize_1 / 2;
unsigned int VAR_76 = VAR_60->begin < VAR_75 ? VAR_60->begin : VAR_75;
unsigned int VAR_77   = VAR_60->end   < VAR_75 ? VAR_60->end   : VAR_75;
int VAR_78 = VAR_77 - VAR_76;
int VAR_79 = VAR_78 / VAR_60->part_size;
if (VAR_79 > VAR_74)
VAR_74 = VAR_79;
}
#ifndef VAR_80
VAR_73 = VAR_0->channels * (sizeof(void*) + VAR_74 * sizeof(uint8 *));
#else
VAR_73 = VAR_0->channels * (sizeof(void*) + VAR_74 * sizeof(int *));
#endif
VAR_0->temp_memory_required = VAR_73;
if (VAR_72 > VAR_0->temp_memory_required)
VAR_0->temp_memory_required = VAR_72;
}
VAR_0->first_decode = TRUE;
if (VAR_0->alloc.alloc_buffer) {
assert(VAR_0->temp_offset == VAR_0->alloc.alloc_buffer_length_in_bytes);
if (VAR_0->setup_offset + sizeof(*VAR_0) + VAR_0->temp_memory_required > (unsigned) VAR_0->temp_offset)
return error(VAR_0, VAR_25);
}
VAR_0->first_audio_page_offset = stb_vorbis_get_file_offset(VAR_0);
return TRUE;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/before/0.json,"static int start_decoder(vorb *f)
{
   uint8 header[6], x,y;
   int len,i,j,k, max_submaps = 0;
   int longest_floorlist=0;

   // first page, first packet

   if (!start_page(f))                              return FALSE;
   // validate page flag
   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);
   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);
   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);
   // check for expected packet length
   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);
   if (f->segments[0] != 30) {
      // check for the Ogg skeleton fishead identifying header to refine our error
      if (f->segments[0] == 64 &&
          getn(f, header, 6) &&
          header[0] == 'f' &&
          header[1] == 'i' &&
          header[2] == 's' &&
          header[3] == 'h' &&
          header[4] == 'e' &&
          header[5] == 'a' &&
          get8(f)   == 'd' &&
          get8(f)   == '\0')                        return error(f, VORBIS_ogg_skeleton_not_supported);
      else
                                                    return error(f, VORBIS_invalid_first_page);
   }

   // read packet
   // check packet header
   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);
   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);
   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);
   // vorbis_version
   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);
   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);
   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);
   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);
   get32(f); // bitrate_maximum
   get32(f); // bitrate_nominal
   get32(f); // bitrate_minimum
   x = get8(f);
   {
      int log0,log1;
      log0 = x & 15;
      log1 = x >> 4;
      f->blocksize_0 = 1 << log0;
      f->blocksize_1 = 1 << log1;
      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);
      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);
      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);
   }

   // framing_flag
   x = get8(f);
   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);

   // second packet!
   if (!start_page(f))                              return FALSE;

   if (!start_packet(f))                            return FALSE;
   do {
      len = next_segment(f);
      skip(f, len);
      f->bytes_in_seg = 0;
   } while (len);

   // third packet!
   if (!start_packet(f))                            return FALSE;

   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (IS_PUSH_MODE(f)) {
      if (!is_whole_packet_present(f, TRUE)) {
         // convert error in ogg header to write type
         if (f->error == VORBIS_invalid_stream)
            f->error = VORBIS_invalid_setup;
         return FALSE;
      }
   }
   #endif

   crc32_init(); // always init it, to avoid multithread race conditions

   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);
   for (i=0; i < 6; ++i) header[i] = get8_packet(f);
   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);

   // codebooks

   f->codebook_count = get_bits(f,8) + 1;
   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);
   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);
   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);
   for (i=0; i < f->codebook_count; ++i) {
      uint32 *values;
      int ordered, sorted_count;
      int total=0;
      uint8 *lengths;
      Codebook *c = f->codebooks+i;
      CHECK(f);
      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);
      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);
      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);
      x = get_bits(f, 8);
      c->dimensions = (get_bits(f, 8)<<8) + x;
      x = get_bits(f, 8);
      y = get_bits(f, 8);
      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;
      ordered = get_bits(f,1);
      c->sparse = ordered ? 0 : get_bits(f,1);

      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);

      if (c->sparse)
         lengths = (uint8 *) setup_temp_malloc(f, c->entries);
      else
         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);

      if (!lengths) return error(f, VORBIS_outofmem);

      if (ordered) {
         int current_entry = 0;
         int current_length = get_bits(f,5) + 1;
         while (current_entry < c->entries) {
            int limit = c->entries - current_entry;
            int n = get_bits(f, ilog(limit));
            if (current_length >= 32) return error(f, VORBIS_invalid_setup);
            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
            memset(lengths + current_entry, current_length, n);
            current_entry += n;
            ++current_length;
         }
      } else {
         for (j=0; j < c->entries; ++j) {
            int present = c->sparse ? get_bits(f,1) : 1;
            if (present) {
               lengths[j] = get_bits(f, 5) + 1;
               ++total;
               if (lengths[j] == 32)
                  return error(f, VORBIS_invalid_setup);
            } else {
               lengths[j] = NO_CODE;
            }
         }
      }

      if (c->sparse && total >= c->entries >> 2) {
         // convert sparse items to non-sparse!
         if (c->entries > (int) f->setup_temp_memory_required)
            f->setup_temp_memory_required = c->entries;

         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);
         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);
         memcpy(c->codeword_lengths, lengths, c->entries);
         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!
         lengths = c->codeword_lengths;
         c->sparse = 0;
      }

      // compute the size of the sorted tables
      if (c->sparse) {
         sorted_count = total;
      } else {
         sorted_count = 0;
         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH
         for (j=0; j < c->entries; ++j)
            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)
               ++sorted_count;
         #endif
      }

      c->sorted_entries = sorted_count;
      values = NULL;

      CHECK(f);
      if (!c->sparse) {
         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);
         if (!c->codewords)                  return error(f, VORBIS_outofmem);
      } else {
         unsigned int size;
         if (c->sorted_entries) {
            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);
            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);
            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);
            if (!c->codewords)                  return error(f, VORBIS_outofmem);
            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);
            if (!values)                        return error(f, VORBIS_outofmem);
         }
         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;
         if (size > f->setup_temp_memory_required)
            f->setup_temp_memory_required = size;
      }

      if (!compute_codewords(c, lengths, c->entries, values)) {
         if (c->sparse) setup_temp_free(f, values, 0);
         return error(f, VORBIS_invalid_setup);
      }

      if (c->sorted_entries) {
         // allocate an extra slot for sentinels
         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));
         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);
         // allocate an extra slot at the front so that c->sorted_values[-1] is defined
         // so that we can catch that case without an extra if
         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));
         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);
         ++c->sorted_values;
         c->sorted_values[-1] = -1;
         compute_sorted_huffman(c, lengths, values);
      }

      if (c->sparse) {
         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);
         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);
         setup_temp_free(f, lengths, c->entries);
         c->codewords = NULL;
      }

      compute_accelerated_huffman(c);

      CHECK(f);
      c->lookup_type = get_bits(f, 4);
      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);
      if (c->lookup_type > 0) {
         uint16 *mults;
         c->minimum_value = float32_unpack(get_bits(f, 32));
         c->delta_value = float32_unpack(get_bits(f, 32));
         c->value_bits = get_bits(f, 4)+1;
         c->sequence_p = get_bits(f,1);
         if (c->lookup_type == 1) {
            int values = lookup1_values(c->entries, c->dimensions);
            if (values < 0) return error(f, VORBIS_invalid_setup);
            c->lookup_values = (uint32) values;
         } else {
            c->lookup_values = c->entries * c->dimensions;
         }
         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);
         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);
         if (mults == NULL) return error(f, VORBIS_outofmem);
         for (j=0; j < (int) c->lookup_values; ++j) {
            int q = get_bits(f, c->value_bits);
            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }
            mults[j] = q;
         }

#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
         if (c->lookup_type == 1) {
            int len, sparse = c->sparse;
            float last=0;
            // pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop
            if (sparse) {
               if (c->sorted_entries == 0) goto skip;
               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);
            } else
               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);
            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
            len = sparse ? c->sorted_entries : c->entries;
            for (j=0; j < len; ++j) {
               unsigned int z = sparse ? c->sorted_values[j] : j;
               unsigned int div=1;
               for (k=0; k < c->dimensions; ++k) {
                  int off = (z / div) % c->lookup_values;
                  float val = mults[off];
                  val = mults[off]*c->delta_value + c->minimum_value + last;
                  c->multiplicands[j*c->dimensions + k] = val;
                  if (c->sequence_p)
                     last = val;
                  if (k+1 < c->dimensions) {
                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {
                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);
                        return error(f, VORBIS_invalid_setup);
                     }
                     div *= c->lookup_values;
                  }
               }
            }
            c->lookup_type = 2;
         }
         else
#endif
         {
            float last=0;
            CHECK(f);
            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);
            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }
            for (j=0; j < (int) c->lookup_values; ++j) {
               float val = mults[j] * c->delta_value + c->minimum_value + last;
               c->multiplicands[j] = val;
               if (c->sequence_p)
                  last = val;
            }
         }
#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK
        skip:;
#endif
         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);

         CHECK(f);
      }
      CHECK(f);
   }

   // time domain transfers (notused)

   x = get_bits(f, 6) + 1;
   for (i=0; i < x; ++i) {
      uint32 z = get_bits(f, 16);
      if (z != 0) return error(f, VORBIS_invalid_setup);
   }

   // Floors
   f->floor_count = get_bits(f, 6)+1;
   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));
   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);
   for (i=0; i < f->floor_count; ++i) {
      f->floor_types[i] = get_bits(f, 16);
      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);
      if (f->floor_types[i] == 0) {
         Floor0 *g = &f->floor_config[i].floor0;
         g->order = get_bits(f,8);
         g->rate = get_bits(f,16);
         g->bark_map_size = get_bits(f,16);
         g->amplitude_bits = get_bits(f,6);
         g->amplitude_offset = get_bits(f,8);
         g->number_of_books = get_bits(f,4) + 1;
         for (j=0; j < g->number_of_books; ++j)
            g->book_list[j] = get_bits(f,8);
         return error(f, VORBIS_feature_not_supported);
      } else {
         stbv__floor_ordering p[31*8+2];
         Floor1 *g = &f->floor_config[i].floor1;
         int max_class = -1; 
         g->partitions = get_bits(f, 5);
         for (j=0; j < g->partitions; ++j) {
            g->partition_class_list[j] = get_bits(f, 4);
            if (g->partition_class_list[j] > max_class)
               max_class = g->partition_class_list[j];
         }
         for (j=0; j <= max_class; ++j) {
            g->class_dimensions[j] = get_bits(f, 3)+1;
            g->class_subclasses[j] = get_bits(f, 2);
            if (g->class_subclasses[j]) {
               g->class_masterbooks[j] = get_bits(f, 8);
               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
            }
            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {
               g->subclass_books[j][k] = get_bits(f,8)-1;
               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
            }
         }
         g->floor1_multiplier = get_bits(f,2)+1;
         g->rangebits = get_bits(f,4);
         g->Xlist[0] = 0;
         g->Xlist[1] = 1 << g->rangebits;
         g->values = 2;
         for (j=0; j < g->partitions; ++j) {
            int c = g->partition_class_list[j];
            for (k=0; k < g->class_dimensions[c]; ++k) {
               g->Xlist[g->values] = get_bits(f, g->rangebits);
               ++g->values;
            }
         }
         // precompute the sorting
         for (j=0; j < g->values; ++j) {
            p[j].x = g->Xlist[j];
            p[j].id = j;
         }
         qsort(p, g->values, sizeof(p[0]), point_compare);
         for (j=0; j < g->values-1; ++j)
            if (p[j].x == p[j+1].x)
               return error(f, VORBIS_invalid_setup);
         for (j=0; j < g->values; ++j)
            g->sorted_order[j] = (uint8) p[j].id;
         // precompute the neighbors
         for (j=2; j < g->values; ++j) {
            int low,hi;
            neighbors(g->Xlist, j, &low,&hi);
            g->neighbors[j][0] = low;
            g->neighbors[j][1] = hi;
         }

         if (g->values > longest_floorlist)
            longest_floorlist = g->values;
      }
   }

   // Residue
   f->residue_count = get_bits(f, 6)+1;
   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));
   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);
   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));
   for (i=0; i < f->residue_count; ++i) {
      uint8 residue_cascade[64];
      Residue *r = f->residue_config+i;
      f->residue_types[i] = get_bits(f, 16);
      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);
      r->begin = get_bits(f, 24);
      r->end = get_bits(f, 24);
      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);
      r->part_size = get_bits(f,24)+1;
      r->classifications = get_bits(f,6)+1;
      r->classbook = get_bits(f,8);
      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);
      for (j=0; j < r->classifications; ++j) {
         uint8 high_bits=0;
         uint8 low_bits=get_bits(f,3);
         if (get_bits(f,1))
            high_bits = get_bits(f,5);
         residue_cascade[j] = high_bits*8 + low_bits;
      }
      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);
      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);
      for (j=0; j < r->classifications; ++j) {
         for (k=0; k < 8; ++k) {
            if (residue_cascade[j] & (1 << k)) {
               r->residue_books[j][k] = get_bits(f, 8);
               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);
            } else {
               r->residue_books[j][k] = -1;
            }
         }
      }
      // precompute the classifications[] array to avoid inner-loop mod/divide
      // call it 'classdata' since we already have r->classifications
      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
      if (!r->classdata) return error(f, VORBIS_outofmem);
      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);
      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {
         int classwords = f->codebooks[r->classbook].dimensions;
         int temp = j;
         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);
         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);
         for (k=classwords-1; k >= 0; --k) {
            r->classdata[j][k] = temp % r->classifications;
            temp /= r->classifications;
         }
      }
   }

   f->mapping_count = get_bits(f,6)+1;
   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));
   if (f->mapping == NULL) return error(f, VORBIS_outofmem);
   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));
   for (i=0; i < f->mapping_count; ++i) {
      Mapping *m = f->mapping + i;      
      int mapping_type = get_bits(f,16);
      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);
      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));
      if (m->chan == NULL) return error(f, VORBIS_outofmem);
      if (get_bits(f,1))
         m->submaps = get_bits(f,4)+1;
      else
         m->submaps = 1;
      if (m->submaps > max_submaps)
         max_submaps = m->submaps;
      if (get_bits(f,1)) {
         m->coupling_steps = get_bits(f,8)+1;
         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);
         for (k=0; k < m->coupling_steps; ++k) {
            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
            m->chan[k].angle = get_bits(f, ilog(f->channels-1));
            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);
            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);
            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);
         }
      } else
         m->coupling_steps = 0;

      // reserved field
      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);
      if (m->submaps > 1) {
         for (j=0; j < f->channels; ++j) {
            m->chan[j].mux = get_bits(f, 4);
            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);
         }
      } else
         // @SPECIFICATION: this case is missing from the spec
         for (j=0; j < f->channels; ++j)
            m->chan[j].mux = 0;

      for (j=0; j < m->submaps; ++j) {
         get_bits(f,8); // discard
         m->submap_floor[j] = get_bits(f,8);
         m->submap_residue[j] = get_bits(f,8);
         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);
         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);
      }
   }

   // Modes
   f->mode_count = get_bits(f, 6)+1;
   for (i=0; i < f->mode_count; ++i) {
      Mode *m = f->mode_config+i;
      m->blockflag = get_bits(f,1);
      m->windowtype = get_bits(f,16);
      m->transformtype = get_bits(f,16);
      m->mapping = get_bits(f,8);
      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);
      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);
      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);
   }

   flush_packet(f);

   f->previous_length = 0;

   for (i=0; i < f->channels; ++i) {
      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);
      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);
      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);
      memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1);
      #ifdef STB_VORBIS_NO_DEFER_FLOOR
      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);
      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);
      #endif
   }

   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;
   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;
   f->blocksize[0] = f->blocksize_0;
   f->blocksize[1] = f->blocksize_1;

#ifdef STB_VORBIS_DIVIDE_TABLE
   if (integer_divide_table[1][1]==0)
      for (i=0; i < DIVTAB_NUMER; ++i)
         for (j=1; j < DIVTAB_DENOM; ++j)
            integer_divide_table[i][j] = i / j;
#endif

   // compute how much temporary memory is needed

   // 1.
   {
      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);
      uint32 classify_mem;
      int i,max_part_read=0;
      for (i=0; i < f->residue_count; ++i) {
         Residue *r = f->residue_config + i;
         unsigned int actual_size = f->blocksize_1 / 2;
         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;
         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;
         int n_read = limit_r_end - limit_r_begin;
         int part_read = n_read / r->part_size;
         if (part_read > max_part_read)
            max_part_read = part_read;
      }
      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));
      #else
      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));
      #endif

      // maximum reasonable partition size is f->blocksize_1

      f->temp_memory_required = classify_mem;
      if (imdct_mem > f->temp_memory_required)
         f->temp_memory_required = imdct_mem;
   }

   f->first_decode = TRUE;

   if (f->alloc.alloc_buffer) {
      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);
      // check if there's enough temp memory so we don't error later
      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)
         return error(f, VORBIS_outofmem);
   }

   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);

   return TRUE;
}","static int start_decoder(vorb *VAR_0)
{
   uint8 VAR_1[6], VAR_2,VAR_3;
   int VAR_4,VAR_5,VAR_6,VAR_7, VAR_8 = 0;
   int VAR_9=0;

   /* COMMENT_0 */

   if (!start_page(VAR_0))                              return FALSE;
   /* COMMENT_1 */
   if (!(VAR_0->page_flag & VAR_10))       return error(VAR_0, VAR_11);
   if (VAR_0->page_flag & VAR_12)           return error(VAR_0, VAR_11);
   if (VAR_0->page_flag & VAR_13)    return error(VAR_0, VAR_11);
   /* COMMENT_2 */
   if (VAR_0->segment_count != 1)                       return error(VAR_0, VAR_11);
   if (VAR_0->segments[0] != 30) {
      /* COMMENT_3 */
      if (VAR_0->segments[0] == 64 &&
          getn(VAR_0, VAR_1, 6) &&
          VAR_1[0] == 'f' &&
          VAR_1[1] == 'i' &&
          VAR_1[2] == 's' &&
          VAR_1[3] == 'h' &&
          VAR_1[4] == 'e' &&
          VAR_1[5] == 'a' &&
          get8(VAR_0)   == 'd' &&
          get8(VAR_0)   == '\0')                        return error(VAR_0, VAR_14);
      else
                                                    return error(VAR_0, VAR_11);
   }

   /* COMMENT_4 */
   /* COMMENT_5 */
   if (get8(VAR_0) != VAR_15)                 return error(VAR_0, VAR_11);
   if (!getn(VAR_0, VAR_1, 6))                         return error(VAR_0, VAR_16);
   if (!vorbis_validate(VAR_1))                    return error(VAR_0, VAR_11);
   /* COMMENT_6 */
   if (get32(VAR_0) != 0)                               return error(VAR_0, VAR_11);
   VAR_0->channels = get8(VAR_0); if (!VAR_0->channels)         return error(VAR_0, VAR_11);
   if (VAR_0->channels > VAR_17)       return error(VAR_0, VAR_18);
   VAR_0->sample_rate = get32(VAR_0); if (!VAR_0->sample_rate)  return error(VAR_0, VAR_11);
   get32(VAR_0); /* COMMENT_7 */
   get32(VAR_0); /* COMMENT_8 */
   get32(VAR_0); /* COMMENT_9 */
   VAR_2 = get8(VAR_0);
   {
      int VAR_19,VAR_20;
      VAR_19 = VAR_2 & 15;
      VAR_20 = VAR_2 >> 4;
      VAR_0->blocksize_0 = 1 << VAR_19;
      VAR_0->blocksize_1 = 1 << VAR_20;
      if (VAR_19 < 6 || VAR_19 > 13)                       return error(VAR_0, VAR_21);
      if (VAR_20 < 6 || VAR_20 > 13)                       return error(VAR_0, VAR_21);
      if (VAR_19 > VAR_20)                                 return error(VAR_0, VAR_21);
   }

   /* COMMENT_10 */
   VAR_2 = get8(VAR_0);
   if (!(VAR_2 & 1))                                    return error(VAR_0, VAR_11);

   /* COMMENT_11 */
   if (!start_page(VAR_0))                              return FALSE;

   if (!start_packet(VAR_0))                            return FALSE;
   do {
      VAR_4 = next_segment(VAR_0);
      skip(VAR_0, VAR_4);
      VAR_0->bytes_in_seg = 0;
   } while (VAR_4);

   /* COMMENT_12 */
   if (!start_packet(VAR_0))                            return FALSE;

   #ifndef VAR_22
   if (IS_PUSH_MODE(VAR_0)) {
      if (!is_whole_packet_present(VAR_0, TRUE)) {
         /* COMMENT_13 */
         if (VAR_0->error == VAR_23)
            VAR_0->error = VAR_21;
         return FALSE;
      }
   }
   #endif

   crc32_init(); /* COMMENT_14 */

   if (get8_packet(VAR_0) != VAR_24)       return error(VAR_0, VAR_21);
   for (VAR_5=0; VAR_5 < 6; ++VAR_5) VAR_1[VAR_5] = get8_packet(VAR_0);
   if (!vorbis_validate(VAR_1))                    return error(VAR_0, VAR_21);

   /* COMMENT_15 */

   VAR_0->codebook_count = get_bits(VAR_0,8) + 1;
   VAR_0->codebooks = (Codebook *) setup_malloc(VAR_0, sizeof(*VAR_0->codebooks) * VAR_0->codebook_count);
   if (VAR_0->codebooks == NULL)                        return error(VAR_0, VAR_25);
   memset(VAR_0->codebooks, 0, sizeof(*VAR_0->codebooks) * VAR_0->codebook_count);
   for (VAR_5=0; VAR_5 < VAR_0->codebook_count; ++VAR_5) {
      uint32 *VAR_26;
      int VAR_27, VAR_28;
      int VAR_29=0;
      uint8 *VAR_30;
      Codebook *VAR_31 = VAR_0->codebooks+VAR_5;
      CHECK(VAR_0);
      VAR_2 = get_bits(VAR_0, 8); if (VAR_2 != 0x42)            return error(VAR_0, VAR_21);
      VAR_2 = get_bits(VAR_0, 8); if (VAR_2 != 0x43)            return error(VAR_0, VAR_21);
      VAR_2 = get_bits(VAR_0, 8); if (VAR_2 != 0x56)            return error(VAR_0, VAR_21);
      VAR_2 = get_bits(VAR_0, 8);
      VAR_31->dimensions = (get_bits(VAR_0, 8)<<8) + VAR_2;
      VAR_2 = get_bits(VAR_0, 8);
      VAR_3 = get_bits(VAR_0, 8);
      VAR_31->entries = (get_bits(VAR_0, 8)<<16) + (VAR_3<<8) + VAR_2;
      VAR_27 = get_bits(VAR_0,1);
      VAR_31->sparse = VAR_27 ? 0 : get_bits(VAR_0,1);

      if (VAR_31->dimensions == 0 && VAR_31->entries != 0)    return error(VAR_0, VAR_21);

      if (VAR_31->sparse)
         VAR_30 = (uint8 *) setup_temp_malloc(VAR_0, VAR_31->entries);
      else
         VAR_30 = VAR_31->codeword_lengths = (uint8 *) setup_malloc(VAR_0, VAR_31->entries);

      if (!VAR_30) return error(VAR_0, VAR_25);

      if (VAR_27) {
         int VAR_32 = 0;
         int VAR_33 = get_bits(VAR_0,5) + 1;
         while (VAR_32 < VAR_31->entries) {
            int VAR_34 = VAR_31->entries - VAR_32;
            int VAR_35 = get_bits(VAR_0, ilog(VAR_34));
            if (VAR_33 >= 32) return error(VAR_0, VAR_21);
            if (VAR_32 + VAR_35 > (int) VAR_31->entries) { return error(VAR_0, VAR_21); }
            memset(VAR_30 + VAR_32, VAR_33, VAR_35);
            VAR_32 += VAR_35;
            ++VAR_33;
         }
      } else {
         for (VAR_6=0; VAR_6 < VAR_31->entries; ++VAR_6) {
            int VAR_36 = VAR_31->sparse ? get_bits(VAR_0,1) : 1;
            if (VAR_36) {
               VAR_30[VAR_6] = get_bits(VAR_0, 5) + 1;
               ++VAR_29;
               if (VAR_30[VAR_6] == 32)
                  return error(VAR_0, VAR_21);
            } else {
               VAR_30[VAR_6] = VAR_37;
            }
         }
      }

      if (VAR_31->sparse && VAR_29 >= VAR_31->entries >> 2) {
         /* COMMENT_16 */
         if (VAR_31->entries > (int) VAR_0->setup_temp_memory_required)
            VAR_0->setup_temp_memory_required = VAR_31->entries;

         VAR_31->codeword_lengths = (uint8 *) setup_malloc(VAR_0, VAR_31->entries);
         if (VAR_31->codeword_lengths == NULL) return error(VAR_0, VAR_25);
         memcpy(VAR_31->codeword_lengths, VAR_30, VAR_31->entries);
         setup_temp_free(VAR_0, VAR_30, VAR_31->entries); /* COMMENT_17 */
         VAR_30 = VAR_31->codeword_lengths;
         VAR_31->sparse = 0;
      }

      /* COMMENT_18 */
      if (VAR_31->sparse) {
         VAR_28 = VAR_29;
      } else {
         VAR_28 = 0;
         #ifndef VAR_38
         for (VAR_6=0; VAR_6 < VAR_31->entries; ++VAR_6)
            if (VAR_30[VAR_6] > VAR_39 && VAR_30[VAR_6] != VAR_37)
               ++VAR_28;
         #endif
      }

      VAR_31->sorted_entries = VAR_28;
      VAR_26 = NULL;

      CHECK(VAR_0);
      if (!VAR_31->sparse) {
         VAR_31->codewords = (uint32 *) setup_malloc(VAR_0, sizeof(VAR_31->codewords[0]) * VAR_31->entries);
         if (!VAR_31->codewords)                  return error(VAR_0, VAR_25);
      } else {
         unsigned int VAR_40;
         if (VAR_31->sorted_entries) {
            VAR_31->codeword_lengths = (uint8 *) setup_malloc(VAR_0, VAR_31->sorted_entries);
            if (!VAR_31->codeword_lengths)           return error(VAR_0, VAR_25);
            VAR_31->codewords = (uint32 *) setup_temp_malloc(VAR_0, sizeof(*VAR_31->codewords) * VAR_31->sorted_entries);
            if (!VAR_31->codewords)                  return error(VAR_0, VAR_25);
            VAR_26 = (uint32 *) setup_temp_malloc(VAR_0, sizeof(*VAR_26) * VAR_31->sorted_entries);
            if (!VAR_26)                        return error(VAR_0, VAR_25);
         }
         VAR_40 = VAR_31->entries + (sizeof(*VAR_31->codewords) + sizeof(*VAR_26)) * VAR_31->sorted_entries;
         if (VAR_40 > VAR_0->setup_temp_memory_required)
            VAR_0->setup_temp_memory_required = VAR_40;
      }

      if (!compute_codewords(VAR_31, VAR_30, VAR_31->entries, VAR_26)) {
         if (VAR_31->sparse) setup_temp_free(VAR_0, VAR_26, 0);
         return error(VAR_0, VAR_21);
      }

      if (VAR_31->sorted_entries) {
         /* COMMENT_19 */
         VAR_31->sorted_codewords = (uint32 *) setup_malloc(VAR_0, sizeof(*VAR_31->sorted_codewords) * (VAR_31->sorted_entries+1));
         if (VAR_31->sorted_codewords == NULL) return error(VAR_0, VAR_25);
         /* COMMENT_20 */
         /* COMMENT_21 */
         VAR_31->sorted_values    = ( int   *) setup_malloc(VAR_0, sizeof(*VAR_31->sorted_values   ) * (VAR_31->sorted_entries+1));
         if (VAR_31->sorted_values == NULL) return error(VAR_0, VAR_25);
         ++VAR_31->sorted_values;
         VAR_31->sorted_values[-1] = -1;
         compute_sorted_huffman(VAR_31, VAR_30, VAR_26);
      }

      if (VAR_31->sparse) {
         setup_temp_free(VAR_0, VAR_26, sizeof(*VAR_26)*VAR_31->sorted_entries);
         setup_temp_free(VAR_0, VAR_31->codewords, sizeof(*VAR_31->codewords)*VAR_31->sorted_entries);
         setup_temp_free(VAR_0, VAR_30, VAR_31->entries);
         VAR_31->codewords = NULL;
      }

      compute_accelerated_huffman(VAR_31);

      CHECK(VAR_0);
      VAR_31->lookup_type = get_bits(VAR_0, 4);
      if (VAR_31->lookup_type > 2) return error(VAR_0, VAR_21);
      if (VAR_31->lookup_type > 0) {
         uint16 *VAR_41;
         VAR_31->minimum_value = float32_unpack(get_bits(VAR_0, 32));
         VAR_31->delta_value = float32_unpack(get_bits(VAR_0, 32));
         VAR_31->value_bits = get_bits(VAR_0, 4)+1;
         VAR_31->sequence_p = get_bits(VAR_0,1);
         if (VAR_31->lookup_type == 1) {
            int VAR_26 = lookup1_values(VAR_31->entries, VAR_31->dimensions);
            if (VAR_26 < 0) return error(VAR_0, VAR_21);
            VAR_31->lookup_values = (uint32) VAR_26;
         } else {
            VAR_31->lookup_values = VAR_31->entries * VAR_31->dimensions;
         }
         if (VAR_31->lookup_values == 0) return error(VAR_0, VAR_21);
         VAR_41 = (uint16 *) setup_temp_malloc(VAR_0, sizeof(VAR_41[0]) * VAR_31->lookup_values);
         if (VAR_41 == NULL) return error(VAR_0, VAR_25);
         for (VAR_6=0; VAR_6 < (int) VAR_31->lookup_values; ++VAR_6) {
            int VAR_42 = get_bits(VAR_0, VAR_31->value_bits);
            if (VAR_42 == VAR_43) { setup_temp_free(VAR_0,VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values); return error(VAR_0, VAR_21); }
            VAR_41[VAR_6] = VAR_42;
         }

#ifndef VAR_44
         if (VAR_31->lookup_type == 1) {
            int VAR_4, VAR_45 = VAR_31->sparse;
            float VAR_46=0;
            /* COMMENT_22 */
            if (VAR_45) {
               if (VAR_31->sorted_entries == 0) goto skip;
               VAR_31->multiplicands = (codetype *) setup_malloc(VAR_0, sizeof(VAR_31->multiplicands[0]) * VAR_31->sorted_entries * VAR_31->dimensions);
            } else
               VAR_31->multiplicands = (codetype *) setup_malloc(VAR_0, sizeof(VAR_31->multiplicands[0]) * VAR_31->entries        * VAR_31->dimensions);
            if (VAR_31->multiplicands == NULL) { setup_temp_free(VAR_0,VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values); return error(VAR_0, VAR_25); }
            VAR_4 = VAR_45 ? VAR_31->sorted_entries : VAR_31->entries;
            for (VAR_6=0; VAR_6 < VAR_4; ++VAR_6) {
               unsigned int VAR_47 = VAR_45 ? VAR_31->sorted_values[VAR_6] : VAR_6;
               unsigned int VAR_48=1;
               for (VAR_7=0; VAR_7 < VAR_31->dimensions; ++VAR_7) {
                  int VAR_49 = (VAR_47 / VAR_48) % VAR_31->lookup_values;
                  float VAR_50 = VAR_41[VAR_49];
                  VAR_50 = VAR_41[VAR_49]*VAR_31->delta_value + VAR_31->minimum_value + VAR_46;
                  VAR_31->multiplicands[VAR_6*VAR_31->dimensions + VAR_7] = VAR_50;
                  if (VAR_31->sequence_p)
                     VAR_46 = VAR_50;
                  if (VAR_7+1 < VAR_31->dimensions) {
                     if (VAR_48 > VAR_51 / (unsigned int) VAR_31->lookup_values) {
                        setup_temp_free(VAR_0, VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values);
                        return error(VAR_0, VAR_21);
                     }
                     VAR_48 *= VAR_31->lookup_values;
                  }
               }
            }
            VAR_31->lookup_type = 2;
         }
         else
#endif
         {
            float VAR_46=0;
            CHECK(VAR_0);
            VAR_31->multiplicands = (codetype *) setup_malloc(VAR_0, sizeof(VAR_31->multiplicands[0]) * VAR_31->lookup_values);
            if (VAR_31->multiplicands == NULL) { setup_temp_free(VAR_0, VAR_41,sizeof(VAR_41[0])*VAR_31->lookup_values); return error(VAR_0, VAR_25); }
            for (VAR_6=0; VAR_6 < (int) VAR_31->lookup_values; ++VAR_6) {
               float VAR_50 = VAR_41[VAR_6] * VAR_31->delta_value + VAR_31->minimum_value + VAR_46;
               VAR_31->multiplicands[VAR_6] = VAR_50;
               if (VAR_31->sequence_p)
                  VAR_46 = VAR_50;
            }
         }
#ifndef VAR_44
        skip:;
#endif
         setup_temp_free(VAR_0, VAR_41, sizeof(VAR_41[0])*VAR_31->lookup_values);

         CHECK(VAR_0);
      }
      CHECK(VAR_0);
   }

   /* COMMENT_23 */

   VAR_2 = get_bits(VAR_0, 6) + 1;
   for (VAR_5=0; VAR_5 < VAR_2; ++VAR_5) {
      uint32 VAR_47 = get_bits(VAR_0, 16);
      if (VAR_47 != 0) return error(VAR_0, VAR_21);
   }

   /* COMMENT_24 */
   VAR_0->floor_count = get_bits(VAR_0, 6)+1;
   VAR_0->floor_config = (Floor *)  setup_malloc(VAR_0, VAR_0->floor_count * sizeof(*VAR_0->floor_config));
   if (VAR_0->floor_config == NULL) return error(VAR_0, VAR_25);
   for (VAR_5=0; VAR_5 < VAR_0->floor_count; ++VAR_5) {
      VAR_0->floor_types[VAR_5] = get_bits(VAR_0, 16);
      if (VAR_0->floor_types[VAR_5] > 1) return error(VAR_0, VAR_21);
      if (VAR_0->floor_types[VAR_5] == 0) {
         Floor0 *VAR_52 = &VAR_0->floor_config[VAR_5].floor0;
         VAR_52->order = get_bits(VAR_0,8);
         VAR_52->rate = get_bits(VAR_0,16);
         VAR_52->bark_map_size = get_bits(VAR_0,16);
         VAR_52->amplitude_bits = get_bits(VAR_0,6);
         VAR_52->amplitude_offset = get_bits(VAR_0,8);
         VAR_52->number_of_books = get_bits(VAR_0,4) + 1;
         for (VAR_6=0; VAR_6 < VAR_52->number_of_books; ++VAR_6)
            VAR_52->book_list[VAR_6] = get_bits(VAR_0,8);
         return error(VAR_0, VAR_53);
      } else {
         stbv__floor_ordering VAR_54[31*8+2];
         Floor1 *VAR_52 = &VAR_0->floor_config[VAR_5].floor1;
         int VAR_55 = -1; 
         VAR_52->partitions = get_bits(VAR_0, 5);
         for (VAR_6=0; VAR_6 < VAR_52->partitions; ++VAR_6) {
            VAR_52->partition_class_list[VAR_6] = get_bits(VAR_0, 4);
            if (VAR_52->partition_class_list[VAR_6] > VAR_55)
               VAR_55 = VAR_52->partition_class_list[VAR_6];
         }
         for (VAR_6=0; VAR_6 <= VAR_55; ++VAR_6) {
            VAR_52->class_dimensions[VAR_6] = get_bits(VAR_0, 3)+1;
            VAR_52->class_subclasses[VAR_6] = get_bits(VAR_0, 2);
            if (VAR_52->class_subclasses[VAR_6]) {
               VAR_52->class_masterbooks[VAR_6] = get_bits(VAR_0, 8);
               if (VAR_52->class_masterbooks[VAR_6] >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
            }
            for (VAR_7=0; VAR_7 < 1 << VAR_52->class_subclasses[VAR_6]; ++VAR_7) {
               VAR_52->subclass_books[VAR_6][VAR_7] = get_bits(VAR_0,8)-1;
               if (VAR_52->subclass_books[VAR_6][VAR_7] >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
            }
         }
         VAR_52->floor1_multiplier = get_bits(VAR_0,2)+1;
         VAR_52->rangebits = get_bits(VAR_0,4);
         VAR_52->Xlist[0] = 0;
         VAR_52->Xlist[1] = 1 << VAR_52->rangebits;
         VAR_52->values = 2;
         for (VAR_6=0; VAR_6 < VAR_52->partitions; ++VAR_6) {
            int VAR_31 = VAR_52->partition_class_list[VAR_6];
            for (VAR_7=0; VAR_7 < VAR_52->class_dimensions[VAR_31]; ++VAR_7) {
               VAR_52->Xlist[VAR_52->values] = get_bits(VAR_0, VAR_52->rangebits);
               ++VAR_52->values;
            }
         }
         /* COMMENT_25 */
         for (VAR_6=0; VAR_6 < VAR_52->values; ++VAR_6) {
            VAR_54[VAR_6].x = VAR_52->Xlist[VAR_6];
            VAR_54[VAR_6].id = VAR_6;
         }
         qsort(VAR_54, VAR_52->values, sizeof(VAR_54[0]), VAR_56);
         for (VAR_6=0; VAR_6 < VAR_52->values-1; ++VAR_6)
            if (VAR_54[VAR_6].x == VAR_54[VAR_6+1].x)
               return error(VAR_0, VAR_21);
         for (VAR_6=0; VAR_6 < VAR_52->values; ++VAR_6)
            VAR_52->sorted_order[VAR_6] = (uint8) VAR_54[VAR_6].id;
         /* COMMENT_26 */
         for (VAR_6=2; VAR_6 < VAR_52->values; ++VAR_6) {
            int VAR_57,VAR_58;
            neighbors(VAR_52->Xlist, VAR_6, &VAR_57,&VAR_58);
            VAR_52->neighbors[VAR_6][0] = VAR_57;
            VAR_52->neighbors[VAR_6][1] = VAR_58;
         }

         if (VAR_52->values > VAR_9)
            VAR_9 = VAR_52->values;
      }
   }

   /* COMMENT_27 */
   VAR_0->residue_count = get_bits(VAR_0, 6)+1;
   VAR_0->residue_config = (Residue *) setup_malloc(VAR_0, VAR_0->residue_count * sizeof(VAR_0->residue_config[0]));
   if (VAR_0->residue_config == NULL) return error(VAR_0, VAR_25);
   memset(VAR_0->residue_config, 0, VAR_0->residue_count * sizeof(VAR_0->residue_config[0]));
   for (VAR_5=0; VAR_5 < VAR_0->residue_count; ++VAR_5) {
      uint8 VAR_59[64];
      Residue *VAR_60 = VAR_0->residue_config+VAR_5;
      VAR_0->residue_types[VAR_5] = get_bits(VAR_0, 16);
      if (VAR_0->residue_types[VAR_5] > 2) return error(VAR_0, VAR_21);
      VAR_60->begin = get_bits(VAR_0, 24);
      VAR_60->end = get_bits(VAR_0, 24);
      if (VAR_60->end < VAR_60->begin) return error(VAR_0, VAR_21);
      VAR_60->part_size = get_bits(VAR_0,24)+1;
      VAR_60->classifications = get_bits(VAR_0,6)+1;
      VAR_60->classbook = get_bits(VAR_0,8);
      if (VAR_60->classbook >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
      for (VAR_6=0; VAR_6 < VAR_60->classifications; ++VAR_6) {
         uint8 VAR_61=0;
         uint8 VAR_62=get_bits(VAR_0,3);
         if (get_bits(VAR_0,1))
            VAR_61 = get_bits(VAR_0,5);
         VAR_59[VAR_6] = VAR_61*8 + VAR_62;
      }
      VAR_60->residue_books = (short (*)[8]) setup_malloc(VAR_0, sizeof(VAR_60->residue_books[0]) * VAR_60->classifications);
      if (VAR_60->residue_books == NULL) return error(VAR_0, VAR_25);
      for (VAR_6=0; VAR_6 < VAR_60->classifications; ++VAR_6) {
         for (VAR_7=0; VAR_7 < 8; ++VAR_7) {
            if (VAR_59[VAR_6] & (1 << VAR_7)) {
               VAR_60->residue_books[VAR_6][VAR_7] = get_bits(VAR_0, 8);
               if (VAR_60->residue_books[VAR_6][VAR_7] >= VAR_0->codebook_count) return error(VAR_0, VAR_21);
            } else {
               VAR_60->residue_books[VAR_6][VAR_7] = -1;
            }
         }
      }
      /* COMMENT_28 */
      /* COMMENT_29 */
      VAR_60->classdata = (uint8 **) setup_malloc(VAR_0, sizeof(*VAR_60->classdata) * VAR_0->codebooks[VAR_60->classbook].entries);
      if (!VAR_60->classdata) return error(VAR_0, VAR_25);
      memset(VAR_60->classdata, 0, sizeof(*VAR_60->classdata) * VAR_0->codebooks[VAR_60->classbook].entries);
      for (VAR_6=0; VAR_6 < VAR_0->codebooks[VAR_60->classbook].entries; ++VAR_6) {
         int VAR_63 = VAR_0->codebooks[VAR_60->classbook].dimensions;
         int VAR_64 = VAR_6;
         VAR_60->classdata[VAR_6] = (uint8 *) setup_malloc(VAR_0, sizeof(VAR_60->classdata[VAR_6][0]) * VAR_63);
         if (VAR_60->classdata[VAR_6] == NULL) return error(VAR_0, VAR_25);
         for (VAR_7=VAR_63-1; VAR_7 >= 0; --VAR_7) {
            VAR_60->classdata[VAR_6][VAR_7] = VAR_64 % VAR_60->classifications;
            VAR_64 /= VAR_60->classifications;
         }
      }
   }

   VAR_0->mapping_count = get_bits(VAR_0,6)+1;
   VAR_0->mapping = (Mapping *) setup_malloc(VAR_0, VAR_0->mapping_count * sizeof(*VAR_0->mapping));
   if (VAR_0->mapping == NULL) return error(VAR_0, VAR_25);
   memset(VAR_0->mapping, 0, VAR_0->mapping_count * sizeof(*VAR_0->mapping));
   for (VAR_5=0; VAR_5 < VAR_0->mapping_count; ++VAR_5) {
      Mapping *VAR_65 = VAR_0->mapping + VAR_5;      
      int VAR_66 = get_bits(VAR_0,16);
      if (VAR_66 != 0) return error(VAR_0, VAR_21);
      VAR_65->chan = (MappingChannel *) setup_malloc(VAR_0, VAR_0->channels * sizeof(*VAR_65->chan));
      if (VAR_65->chan == NULL) return error(VAR_0, VAR_25);
      if (get_bits(VAR_0,1))
         VAR_65->submaps = get_bits(VAR_0,4)+1;
      else
         VAR_65->submaps = 1;
      if (VAR_65->submaps > VAR_8)
         VAR_8 = VAR_65->submaps;
      if (get_bits(VAR_0,1)) {
         VAR_65->coupling_steps = get_bits(VAR_0,8)+1;
         if (VAR_65->coupling_steps > VAR_0->channels) return error(VAR_0, VAR_21);
         for (VAR_7=0; VAR_7 < VAR_65->coupling_steps; ++VAR_7) {
            VAR_65->chan[VAR_7].magnitude = get_bits(VAR_0, ilog(VAR_0->channels-1));
            VAR_65->chan[VAR_7].angle = get_bits(VAR_0, ilog(VAR_0->channels-1));
            if (VAR_65->chan[VAR_7].magnitude >= VAR_0->channels)        return error(VAR_0, VAR_21);
            if (VAR_65->chan[VAR_7].angle     >= VAR_0->channels)        return error(VAR_0, VAR_21);
            if (VAR_65->chan[VAR_7].magnitude == VAR_65->chan[VAR_7].angle)   return error(VAR_0, VAR_21);
         }
      } else
         VAR_65->coupling_steps = 0;

      /* COMMENT_30 */
      if (get_bits(VAR_0,2)) return error(VAR_0, VAR_21);
      if (VAR_65->submaps > 1) {
         for (VAR_6=0; VAR_6 < VAR_0->channels; ++VAR_6) {
            VAR_65->chan[VAR_6].mux = get_bits(VAR_0, 4);
            if (VAR_65->chan[VAR_6].mux >= VAR_65->submaps)                return error(VAR_0, VAR_21);
         }
      } else
         /* COMMENT_31 */
         for (VAR_6=0; VAR_6 < VAR_0->channels; ++VAR_6)
            VAR_65->chan[VAR_6].mux = 0;

      for (VAR_6=0; VAR_6 < VAR_65->submaps; ++VAR_6) {
         get_bits(VAR_0,8); /* COMMENT_32 */
         VAR_65->submap_floor[VAR_6] = get_bits(VAR_0,8);
         VAR_65->submap_residue[VAR_6] = get_bits(VAR_0,8);
         if (VAR_65->submap_floor[VAR_6] >= VAR_0->floor_count)      return error(VAR_0, VAR_21);
         if (VAR_65->submap_residue[VAR_6] >= VAR_0->residue_count)  return error(VAR_0, VAR_21);
      }
   }

   /* COMMENT_33 */
   VAR_0->mode_count = get_bits(VAR_0, 6)+1;
   for (VAR_5=0; VAR_5 < VAR_0->mode_count; ++VAR_5) {
      Mode *VAR_65 = VAR_0->mode_config+VAR_5;
      VAR_65->blockflag = get_bits(VAR_0,1);
      VAR_65->windowtype = get_bits(VAR_0,16);
      VAR_65->transformtype = get_bits(VAR_0,16);
      VAR_65->mapping = get_bits(VAR_0,8);
      if (VAR_65->windowtype != 0)                 return error(VAR_0, VAR_21);
      if (VAR_65->transformtype != 0)              return error(VAR_0, VAR_21);
      if (VAR_65->mapping >= VAR_0->mapping_count)     return error(VAR_0, VAR_21);
   }

   flush_packet(VAR_0);

   VAR_0->previous_length = 0;

   for (VAR_5=0; VAR_5 < VAR_0->channels; ++VAR_5) {
      VAR_0->channel_buffers[VAR_5] = (float *) setup_malloc(VAR_0, sizeof(float) * VAR_0->blocksize_1);
      VAR_0->previous_window[VAR_5] = (float *) setup_malloc(VAR_0, sizeof(float) * VAR_0->blocksize_1/2);
      VAR_0->finalY[VAR_5]          = (int16 *) setup_malloc(VAR_0, sizeof(int16) * VAR_9);
      if (VAR_0->channel_buffers[VAR_5] == NULL || VAR_0->previous_window[VAR_5] == NULL || VAR_0->finalY[VAR_5] == NULL) return error(VAR_0, VAR_25);
      memset(VAR_0->channel_buffers[VAR_5], 0, sizeof(float) * VAR_0->blocksize_1);
      #ifdef VAR_67
      VAR_0->floor_buffers[VAR_5]   = (float *) setup_malloc(VAR_0, sizeof(float) * VAR_0->blocksize_1/2);
      if (VAR_0->floor_buffers[VAR_5] == NULL) return error(VAR_0, VAR_25);
      #endif
   }

   if (!init_blocksize(VAR_0, 0, VAR_0->blocksize_0)) return FALSE;
   if (!init_blocksize(VAR_0, 1, VAR_0->blocksize_1)) return FALSE;
   VAR_0->blocksize[0] = VAR_0->blocksize_0;
   VAR_0->blocksize[1] = VAR_0->blocksize_1;

#ifdef VAR_68
   if (VAR_69[1][1]==0)
      for (VAR_5=0; VAR_5 < VAR_70; ++VAR_5)
         for (VAR_6=1; VAR_6 < VAR_71; ++VAR_6)
            VAR_69[VAR_5][VAR_6] = VAR_5 / VAR_6;
#endif

   /* COMMENT_34 */

   /* COMMENT_35 */
   {
      uint32 VAR_72 = (VAR_0->blocksize_1 * sizeof(float) >> 1);
      uint32 VAR_73;
      int VAR_5,VAR_74=0;
      for (VAR_5=0; VAR_5 < VAR_0->residue_count; ++VAR_5) {
         Residue *VAR_60 = VAR_0->residue_config + VAR_5;
         unsigned int VAR_75 = VAR_0->blocksize_1 / 2;
         unsigned int VAR_76 = VAR_60->begin < VAR_75 ? VAR_60->begin : VAR_75;
         unsigned int VAR_77   = VAR_60->end   < VAR_75 ? VAR_60->end   : VAR_75;
         int VAR_78 = VAR_77 - VAR_76;
         int VAR_79 = VAR_78 / VAR_60->part_size;
         if (VAR_79 > VAR_74)
            VAR_74 = VAR_79;
      }
      #ifndef VAR_80
      VAR_73 = VAR_0->channels * (sizeof(void*) + VAR_74 * sizeof(uint8 *));
      #else
      VAR_73 = VAR_0->channels * (sizeof(void*) + VAR_74 * sizeof(int *));
      #endif

      /* COMMENT_36 */

      VAR_0->temp_memory_required = VAR_73;
      if (VAR_72 > VAR_0->temp_memory_required)
         VAR_0->temp_memory_required = VAR_72;
   }

   VAR_0->first_decode = TRUE;

   if (VAR_0->alloc.alloc_buffer) {
      assert(VAR_0->temp_offset == VAR_0->alloc.alloc_buffer_length_in_bytes);
      /* COMMENT_37 */
      if (VAR_0->setup_offset + sizeof(*VAR_0) + VAR_0->temp_memory_required > (unsigned) VAR_0->temp_offset)
         return error(VAR_0, VAR_25);
   }

   VAR_0->first_audio_page_offset = stb_vorbis_get_file_offset(VAR_0);

   return TRUE;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -127,6 +127,7 @@
          while (current_entry < c->entries) {
             int limit = c->entries - current_entry;
             int n = get_bits(f, ilog(limit));
+            if (current_length >= 32) return error(f, VORBIS_invalid_setup);
             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
             memset(lengths + current_entry, current_length, n);
             current_entry += n;
@@ -230,7 +231,9 @@
          c->value_bits = get_bits(f, 4)+1;
          c->sequence_p = get_bits(f,1);
          if (c->lookup_type == 1) {
-            c->lookup_values = lookup1_values(c->entries, c->dimensions);
+            int values = lookup1_values(c->entries, c->dimensions);
+            if (values < 0) return error(f, VORBIS_invalid_setup);
+            c->lookup_values = (uint32) values;
          } else {
             c->lookup_values = c->entries * c->dimensions;
          }
@@ -366,6 +369,9 @@
             p[j].id = j;
          }
          qsort(p, g->values, sizeof(p[0]), point_compare);
+         for (j=0; j < g->values-1; ++j)
+            if (p[j].x == p[j+1].x)
+               return error(f, VORBIS_invalid_setup);
          for (j=0; j < g->values; ++j)
             g->sorted_order[j] = (uint8) p[j].id;
          // precompute the neighbors
@@ -452,6 +458,7 @@
          max_submaps = m->submaps;
       if (get_bits(f,1)) {
          m->coupling_steps = get_bits(f,8)+1;
+         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);
          for (k=0; k < m->coupling_steps; ++k) {
             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
             m->chan[k].angle = get_bits(f, ilog(f->channels-1));","{'deleted_lines': ['            c->lookup_values = lookup1_values(c->entries, c->dimensions);'], 'added_lines': ['            if (current_length >= 32) return error(f, VORBIS_invalid_setup);', '            int values = lookup1_values(c->entries, c->dimensions);', '            if (values < 0) return error(f, VORBIS_invalid_setup);', '            c->lookup_values = (uint32) values;', '         for (j=0; j < g->values-1; ++j)', '            if (p[j].x == p[j+1].x)', '               return error(f, VORBIS_invalid_setup);', '         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);']}",True,A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,7.8,HIGH,2,test,2019-08-09T11:05:22Z,2
CVE-2019-13217,"['CWE-787', 'CWE-125', 'CWE-617', 'CWE-908', 'CWE-369', 'CWE-476']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,nothings/stb,"Fix seven bugs discovered and fixed by ForAllSecure:

CVE-2019-13217: heap buffer overflow in start_decoder()
CVE-2019-13218: stack buffer overflow in compute_codewords()
CVE-2019-13219: uninitialized memory in vorbis_decode_packet_rest()
CVE-2019-13220: out-of-range read in draw_line()
CVE-2019-13221: issue with large 1D codebooks in lookup1_values()
CVE-2019-13222: unchecked NULL returned by get_window()
CVE-2019-13223: division by zero in predict_point()",98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,stb_vorbis.c,get_window,"static float *get_window(vorb *f, int len)
{
len <<= 1;
if (len == f->blocksize_0) return f->window[0];
if (len == f->blocksize_1) return f->window[1];
assert(0);
return NULL;
}","static float *get_window(vorb *VAR_0, int VAR_1)
{
VAR_1 <<= 1;
if (VAR_1 == VAR_0->blocksize_0) return VAR_0->window[0];
if (VAR_1 == VAR_0->blocksize_1) return VAR_0->window[1];
assert(0);
return NULL;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/before/3.json,"static float *get_window(vorb *f, int len)
{
   len <<= 1;
   if (len == f->blocksize_0) return f->window[0];
   if (len == f->blocksize_1) return f->window[1];
   return NULL;
}","static float *get_window(vorb *VAR_0, int VAR_1)
{
   VAR_1 <<= 1;
   if (VAR_1 == VAR_0->blocksize_0) return VAR_0->window[0];
   if (VAR_1 == VAR_0->blocksize_1) return VAR_0->window[1];
   return NULL;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -3,6 +3,5 @@
    len <<= 1;
    if (len == f->blocksize_0) return f->window[0];
    if (len == f->blocksize_1) return f->window[1];
-   assert(0);
    return NULL;
 }","{'deleted_lines': ['   assert(0);'], 'added_lines': []}",True,A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,7.8,HIGH,2,test,2019-08-09T11:05:22Z,2
CVE-2019-13217,"['CWE-787', 'CWE-125', 'CWE-617', 'CWE-908', 'CWE-369', 'CWE-476']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,nothings/stb,"Fix seven bugs discovered and fixed by ForAllSecure:

CVE-2019-13217: heap buffer overflow in start_decoder()
CVE-2019-13218: stack buffer overflow in compute_codewords()
CVE-2019-13219: uninitialized memory in vorbis_decode_packet_rest()
CVE-2019-13220: out-of-range read in draw_line()
CVE-2019-13221: issue with large 1D codebooks in lookup1_values()
CVE-2019-13222: unchecked NULL returned by get_window()
CVE-2019-13223: division by zero in predict_point()",98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,stb_vorbis.c,lookup1_values,"static int lookup1_values(int entries, int dim)
{
int r = (int) floor(exp((float) log((float) entries) / dim));
if ((int) floor(pow((float) r+1, dim)) <= entries)         ++r;                                                 assert(pow((float) r+1, dim) > entries);
assert((int) floor(pow((float) r, dim)) <= entries);    return r;
}","static int lookup1_values(int VAR_0, int VAR_1)
{
int VAR_2 = (int) floor(exp((float) log((float) VAR_0) / VAR_1));
if ((int) floor(pow((float) VAR_2+1, VAR_1)) <= VAR_0)   
++VAR_2;                                              
assert(pow((float) VAR_2+1, VAR_1) > VAR_0);
assert((int) floor(pow((float) VAR_2, VAR_1)) <= VAR_0); 
return VAR_2;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/before/1.json,"static int lookup1_values(int entries, int dim)
{
   int r = (int) floor(exp((float) log((float) entries) / dim));
   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;
      ++r;                                              // floor() to avoid _ftol() when non-CRT
   if (pow((float) r+1, dim) <= entries)
      return -1;
   if ((int) floor(pow((float) r, dim)) > entries)
      return -1;
   return r;
}","static int lookup1_values(int VAR_0, int VAR_1)
{
   int VAR_2 = (int) floor(exp((float) log((float) VAR_0) / VAR_1));
   if ((int) floor(pow((float) VAR_2+1, VAR_1)) <= VAR_0)   /* COMMENT_0 */
      ++VAR_2;                                              /* COMMENT_1 */
   if (pow((float) VAR_2+1, VAR_1) <= VAR_0)
      return -1;
   if ((int) floor(pow((float) VAR_2, VAR_1)) > VAR_0)
      return -1;
   return VAR_2;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -3,7 +3,9 @@
    int r = (int) floor(exp((float) log((float) entries) / dim));
    if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;
       ++r;                                              // floor() to avoid _ftol() when non-CRT
-   assert(pow((float) r+1, dim) > entries);
-   assert((int) floor(pow((float) r, dim)) <= entries); // (int),floor() as above
+   if (pow((float) r+1, dim) <= entries)
+      return -1;
+   if ((int) floor(pow((float) r, dim)) > entries)
+      return -1;
    return r;
 }","{'deleted_lines': ['   assert(pow((float) r+1, dim) > entries);', '   assert((int) floor(pow((float) r, dim)) <= entries); // (int),floor() as above'], 'added_lines': ['   if (pow((float) r+1, dim) <= entries)', '      return -1;', '   if ((int) floor(pow((float) r, dim)) > entries)', '      return -1;']}",True,A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,7.8,HIGH,2,test,2019-08-09T11:05:22Z,2
CVE-2019-13217,"['CWE-787', 'CWE-125', 'CWE-617', 'CWE-908', 'CWE-369', 'CWE-476']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,nothings/stb,"Fix seven bugs discovered and fixed by ForAllSecure:

CVE-2019-13217: heap buffer overflow in start_decoder()
CVE-2019-13218: stack buffer overflow in compute_codewords()
CVE-2019-13219: uninitialized memory in vorbis_decode_packet_rest()
CVE-2019-13220: out-of-range read in draw_line()
CVE-2019-13221: issue with large 1D codebooks in lookup1_values()
CVE-2019-13222: unchecked NULL returned by get_window()
CVE-2019-13223: division by zero in predict_point()",98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,stb_vorbis.c,vorbis_finish_frame,"static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)
{
int prev,i,j;
if (f->previous_length) {
int i,j, n = f->previous_length;
float *w = get_window(f, n);
for (i=0; i < f->channels; ++i) {
for (j=0; j < n; ++j)
f->channel_buffers[i][left+j] =
f->channel_buffers[i][left+j]*w[    j] +
f->previous_window[i][     j]*w[n-1-j];
}
}
prev = f->previous_length;
f->previous_length = len - right;
for (i=0; i < f->channels; ++i)
for (j=0; right+j < len; ++j)
f->previous_window[i][j] = f->channel_buffers[i][right+j];
if (!prev)
return 0;
if (len < right) right = len;
f->samples_output += right-left;
return right - left;
}","static int vorbis_finish_frame(stb_vorbis *VAR_0, int VAR_1, int VAR_2, int VAR_3)
{
int VAR_4,VAR_5,VAR_6;
if (VAR_0->previous_length) {
int VAR_5,VAR_6, VAR_7 = VAR_0->previous_length;
float *VAR_8 = get_window(VAR_0, VAR_7);
for (VAR_5=0; VAR_5 < VAR_0->channels; ++VAR_5) {
for (VAR_6=0; VAR_6 < VAR_7; ++VAR_6)
VAR_0->channel_buffers[VAR_5][VAR_2+VAR_6] =
VAR_0->channel_buffers[VAR_5][VAR_2+VAR_6]*VAR_8[    VAR_6] +
VAR_0->previous_window[VAR_5][     VAR_6]*VAR_8[VAR_7-1-VAR_6];
}
}
VAR_4 = VAR_0->previous_length;
VAR_0->previous_length = VAR_1 - VAR_3;
for (VAR_5=0; VAR_5 < VAR_0->channels; ++VAR_5)
for (VAR_6=0; VAR_3+VAR_6 < VAR_1; ++VAR_6)
VAR_0->previous_window[VAR_5][VAR_6] = VAR_0->channel_buffers[VAR_5][VAR_3+VAR_6];
if (!VAR_4)
return 0;
if (VAR_1 < VAR_3) VAR_3 = VAR_1;
VAR_0->samples_output += VAR_3-VAR_2;
return VAR_3 - VAR_2;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/before/2.json,"static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)
{
   int prev,i,j;
   // we use right&left (the start of the right- and left-window sin()-regions)
   // to determine how much to return, rather than inferring from the rules
   // (same result, clearer code); 'left' indicates where our sin() window
   // starts, therefore where the previous window's right edge starts, and
   // therefore where to start mixing from the previous buffer. 'right'
   // indicates where our sin() ending-window starts, therefore that's where
   // we start saving, and where our returned-data ends.

   // mixin from previous window
   if (f->previous_length) {
      int i,j, n = f->previous_length;
      float *w = get_window(f, n);
      if (w == NULL) return 0;
      for (i=0; i < f->channels; ++i) {
         for (j=0; j < n; ++j)
            f->channel_buffers[i][left+j] =
               f->channel_buffers[i][left+j]*w[    j] +
               f->previous_window[i][     j]*w[n-1-j];
      }
   }

   prev = f->previous_length;

   // last half of this data becomes previous window
   f->previous_length = len - right;

   // @OPTIMIZE: could avoid this copy by double-buffering the
   // output (flipping previous_window with channel_buffers), but
   // then previous_window would have to be 2x as large, and
   // channel_buffers couldn't be temp mem (although they're NOT
   // currently temp mem, they could be (unless we want to level
   // performance by spreading out the computation))
   for (i=0; i < f->channels; ++i)
      for (j=0; right+j < len; ++j)
         f->previous_window[i][j] = f->channel_buffers[i][right+j];

   if (!prev)
      // there was no previous packet, so this data isn't valid...
      // this isn't entirely true, only the would-have-overlapped data
      // isn't valid, but this seems to be what the spec requires
      return 0;

   // truncate a short frame
   if (len < right) right = len;

   f->samples_output += right-left;

   return right - left;
}","static int vorbis_finish_frame(stb_vorbis *VAR_0, int VAR_1, int VAR_2, int VAR_3)
{
   int VAR_4,VAR_5,VAR_6;
   /* COMMENT_0 */
   /* COMMENT_1 */
   /* COMMENT_2 */
   /* COMMENT_3 */
   /* COMMENT_4 */
   /* COMMENT_5 */
   /* COMMENT_6 */

   /* COMMENT_7 */
   if (VAR_0->previous_length) {
      int VAR_5,VAR_6, VAR_7 = VAR_0->previous_length;
      float *VAR_8 = get_window(VAR_0, VAR_7);
      if (VAR_8 == NULL) return 0;
      for (VAR_5=0; VAR_5 < VAR_0->channels; ++VAR_5) {
         for (VAR_6=0; VAR_6 < VAR_7; ++VAR_6)
            VAR_0->channel_buffers[VAR_5][VAR_2+VAR_6] =
               VAR_0->channel_buffers[VAR_5][VAR_2+VAR_6]*VAR_8[    VAR_6] +
               VAR_0->previous_window[VAR_5][     VAR_6]*VAR_8[VAR_7-1-VAR_6];
      }
   }

   VAR_4 = VAR_0->previous_length;

   /* COMMENT_8 */
   VAR_0->previous_length = VAR_1 - VAR_3;

   /* COMMENT_9 */
   /* COMMENT_10 */
   /* COMMENT_11 */
   /* COMMENT_12 */
   /* COMMENT_13 */
   /* COMMENT_14 */
   for (VAR_5=0; VAR_5 < VAR_0->channels; ++VAR_5)
      for (VAR_6=0; VAR_3+VAR_6 < VAR_1; ++VAR_6)
         VAR_0->previous_window[VAR_5][VAR_6] = VAR_0->channel_buffers[VAR_5][VAR_3+VAR_6];

   if (!VAR_4)
      /* COMMENT_15 */
      /* COMMENT_16 */
      /* COMMENT_17 */
      return 0;

   /* COMMENT_18 */
   if (VAR_1 < VAR_3) VAR_3 = VAR_1;

   VAR_0->samples_output += VAR_3-VAR_2;

   return VAR_3 - VAR_2;
}",nothings/stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6/stb_vorbis.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -13,6 +13,7 @@
    if (f->previous_length) {
       int i,j, n = f->previous_length;
       float *w = get_window(f, n);
+      if (w == NULL) return 0;
       for (i=0; i < f->channels; ++i) {
          for (j=0; j < n; ++j)
             f->channel_buffers[i][left+j] =","{'deleted_lines': [], 'added_lines': ['      if (w == NULL) return 0;']}",True,A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,7.8,HIGH,2,test,2019-08-09T11:05:22Z,2
CVE-2019-13217,"['CWE-787', 'CWE-125', 'CWE-617', 'CWE-908', 'CWE-369', 'CWE-476']",AV:N/AC:M/Au:N/C:P/I:P/A:P,0.0,nothings/stb,"Fix seven bugs discovered and fixed by ForAllSecure:

CVE-2019-13217: heap buffer overflow in start_decoder()
CVE-2019-13218: stack buffer overflow in compute_codewords()
CVE-2019-13219: uninitialized memory in vorbis_decode_packet_rest()
CVE-2019-13220: out-of-range read in draw_line()
CVE-2019-13221: issue with large 1D codebooks in lookup1_values()
CVE-2019-13222: unchecked NULL returned by get_window()
CVE-2019-13223: division by zero in predict_point()",98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,stb_vorbis.c,draw_line,"static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)
{
int dy = y1 - y0;
int adx = x1 - x0;
int ady = abs(dy);
int base;
int x=x0,y=y0;
int err = 0;
int sy;
#ifdef STB_VORBIS_DIVIDE_TABLE
if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {
if (dy < 0) {
base = -integer_divide_table[ady][adx];
sy = base-1;
} else {
base =  integer_divide_table[ady][adx];
sy = base+1;
}
} else {
base = dy / adx;
if (dy < 0)
sy = base - 1;
else
sy = base+1;
}
#else
base = dy / adx;
if (dy < 0)
sy = base - 1;
else
sy = base+1;
#endif
ady -= abs(base) * adx;
if (x1 > n) x1 = n;
if (x < x1) {
LINE_OP(output[x], inverse_db_table[y]);
for (++x; x < x1; ++x) {
err += ady;
if (err >= adx) {
err -= adx;
y += sy;
} else
y += base;
LINE_OP(output[x], inverse_db_table[y]);
}
}
}","static __forceinline VAR_0 draw_line(float *VAR_1, int VAR_2, int VAR_3, int VAR_4, int VAR_5, int VAR_6)
{
int VAR_7 = VAR_5 - VAR_3;
int VAR_8 = VAR_4 - VAR_2;
int VAR_9 = abs(VAR_7);
int VAR_10;
int VAR_11=VAR_2,VAR_12=VAR_3;
int VAR_13 = 0;
int VAR_14;
#ifdef VAR_15
if (VAR_8 < VAR_16 && VAR_9 < VAR_17) {
if (VAR_7 < 0) {
VAR_10 = -VAR_18[VAR_9][VAR_8];
VAR_14 = VAR_10-1;
} else {
VAR_10 =  VAR_18[VAR_9][VAR_8];
VAR_14 = VAR_10+1;
}
} else {
VAR_10 = VAR_7 / VAR_8;
if (VAR_7 < 0)
VAR_14 = VAR_10 - 1;
else
VAR_14 = VAR_10+1;
}
#else
VAR_10 = VAR_7 / VAR_8;
if (VAR_7 < 0)
VAR_14 = VAR_10 - 1;
else
VAR_14 = VAR_10+1;
#endif
VAR_9 -= abs(VAR_10) * VAR_8;
if (VAR_4 > VAR_6) VAR_4 = VAR_6;
if (VAR_11 < VAR_4) {
LINE_OP(VAR_1[VAR_11], VAR_19[VAR_12]);
for (++VAR_11; VAR_11 < VAR_4; ++VAR_11) {
VAR_13 += VAR_9;
if (VAR_13 >= VAR_8) {
VAR_13 -= VAR_8;
VAR_12 += VAR_14;
} else
VAR_12 += VAR_10;
LINE_OP(VAR_1[VAR_11], VAR_19[VAR_12]);
}
}
}",,"static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)
{
   int dy = y1 - y0;
   int adx = x1 - x0;
   int ady = abs(dy);
   int base;
   int x=x0,y=y0;
   int err = 0;
   int sy;

#ifdef STB_VORBIS_DIVIDE_TABLE
   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {
      if (dy < 0) {
         base = -integer_divide_table[ady][adx];
         sy = base-1;
      } else {
         base =  integer_divide_table[ady][adx];
         sy = base+1;
      }
   } else {
      base = dy / adx;
      if (dy < 0)
         sy = base - 1;
      else
         sy = base+1;
   }
#else
   base = dy / adx;
   if (dy < 0)
      sy = base - 1;
   else
      sy = base+1;
#endif
   ady -= abs(base) * adx;
   if (x1 > n) x1 = n;
   if (x < x1) {
      LINE_OP(output[x], inverse_db_table[y&255]);
      for (++x; x < x1; ++x) {
         err += ady;
         if (err >= adx) {
            err -= adx;
            y += sy;
         } else
            y += base;
         LINE_OP(output[x], inverse_db_table[y&255]);
      }
   }
}","static __forceinline VAR_0 draw_line(float *VAR_1, int VAR_2, int VAR_3, int VAR_4, int VAR_5, int VAR_6)
{
   int VAR_7 = VAR_5 - VAR_3;
   int VAR_8 = VAR_4 - VAR_2;
   int VAR_9 = abs(VAR_7);
   int VAR_10;
   int VAR_11=VAR_2,VAR_12=VAR_3;
   int VAR_13 = 0;
   int VAR_14;

#ifdef VAR_15
   if (VAR_8 < VAR_16 && VAR_9 < VAR_17) {
      if (VAR_7 < 0) {
         VAR_10 = -VAR_18[VAR_9][VAR_8];
         VAR_14 = VAR_10-1;
      } else {
         VAR_10 =  VAR_18[VAR_9][VAR_8];
         VAR_14 = VAR_10+1;
      }
   } else {
      VAR_10 = VAR_7 / VAR_8;
      if (VAR_7 < 0)
         VAR_14 = VAR_10 - 1;
      else
         VAR_14 = VAR_10+1;
   }
#else
   VAR_10 = VAR_7 / VAR_8;
   if (VAR_7 < 0)
      VAR_14 = VAR_10 - 1;
   else
      VAR_14 = VAR_10+1;
#endif
   VAR_9 -= abs(VAR_10) * VAR_8;
   if (VAR_4 > VAR_6) VAR_4 = VAR_6;
   if (VAR_11 < VAR_4) {
      LINE_OP(VAR_1[VAR_11], VAR_19[VAR_12&255]);
      for (++VAR_11; VAR_11 < VAR_4; ++VAR_11) {
         VAR_13 += VAR_9;
         if (VAR_13 >= VAR_8) {
            VAR_13 -= VAR_8;
            VAR_12 += VAR_14;
         } else
            VAR_12 += VAR_10;
         LINE_OP(VAR_1[VAR_11], VAR_19[VAR_12&255]);
      }
   }
}",,"--- func_before
+++ func_after
@@ -34,7 +34,7 @@
    ady -= abs(base) * adx;
    if (x1 > n) x1 = n;
    if (x < x1) {
-      LINE_OP(output[x], inverse_db_table[y]);
+      LINE_OP(output[x], inverse_db_table[y&255]);
       for (++x; x < x1; ++x) {
          err += ady;
          if (err >= adx) {
@@ -42,7 +42,7 @@
             y += sy;
          } else
             y += base;
-         LINE_OP(output[x], inverse_db_table[y]);
+         LINE_OP(output[x], inverse_db_table[y&255]);
       }
    }
 }","{'deleted_lines': ['      LINE_OP(output[x], inverse_db_table[y]);', '         LINE_OP(output[x], inverse_db_table[y]);'], 'added_lines': ['      LINE_OP(output[x], inverse_db_table[y&255]);', '         LINE_OP(output[x], inverse_db_table[y&255]);']}",True,A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.,7.8,HIGH,2,test,2019-08-09T11:05:22Z,2
CVE-2019-19246,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0.0,kkos/oniguruma,fix heap-buffer-overflow,d3e402928b6eb3327f8f7d59a9edfa622fec557b,https://github.com/kkos/oniguruma/commit/d3e402928b6eb3327f8f7d59a9edfa622fec557b,src/regexec.c,str_lower_case_match,"static int
str_lower_case_match(OnigEncoding enc, int case_fold_flag,
const UChar* t, const UChar* tend,
const UChar* p, const UChar* end)
{
int lowlen;
UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];
while (t < tend) {
lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
q = lowbuf;
while (lowlen > 0) {
if (*t++ != *q++) return 0;
lowlen--;
}
}
return 1;
}","static int
str_lower_case_match(OnigEncoding VAR_0, int VAR_1,
const UChar* VAR_2, const UChar* VAR_3,
const UChar* VAR_4, const UChar* VAR_5)
{
int VAR_6;
UChar *VAR_7, VAR_8[VAR_9];
while (VAR_2 < VAR_3) {
VAR_6 = ONIGENC_MBC_CASE_FOLD(VAR_0, VAR_1, &VAR_4, VAR_5, VAR_8);
VAR_7 = VAR_8;
while (VAR_6 > 0) {
if (*VAR_2++ != *VAR_7++) return 0;
VAR_6--;
}
}
return 1;
}",kkos/oniguruma/d3e402928b6eb3327f8f7d59a9edfa622fec557b/regexec.c/vul/before/0.json,"static int
str_lower_case_match(OnigEncoding enc, int case_fold_flag,
                     const UChar* t, const UChar* tend,
                     const UChar* p, const UChar* end)
{
  int lowlen;
  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];

  while (t < tend) {
    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
    q = lowbuf;
    while (lowlen > 0) {
      if (t >= tend)    return 0;
      if (*t++ != *q++) return 0;
      lowlen--;
    }
  }

  return 1;
}","static int
str_lower_case_match(OnigEncoding VAR_0, int VAR_1,
                     const UChar* VAR_2, const UChar* VAR_3,
                     const UChar* VAR_4, const UChar* VAR_5)
{
  int VAR_6;
  UChar *VAR_7, VAR_8[VAR_9];

  while (VAR_2 < VAR_3) {
    VAR_6 = ONIGENC_MBC_CASE_FOLD(VAR_0, VAR_1, &VAR_4, VAR_5, VAR_8);
    VAR_7 = VAR_8;
    while (VAR_6 > 0) {
      if (VAR_2 >= VAR_3)    return 0;
      if (*VAR_2++ != *VAR_7++) return 0;
      VAR_6--;
    }
  }

  return 1;
}",kkos/oniguruma/d3e402928b6eb3327f8f7d59a9edfa622fec557b/regexec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,7 @@
     lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);
     q = lowbuf;
     while (lowlen > 0) {
+      if (t >= tend)    return 0;
       if (*t++ != *q++) return 0;
       lowlen--;
     }","{'deleted_lines': [], 'added_lines': ['      if (t >= tend)    return 0;']}",True,"Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.",7.5,HIGH,2,test,2019-08-13T04:37:30Z,2
